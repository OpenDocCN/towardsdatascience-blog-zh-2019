<html>
<head>
<title>4 Reasons Why Your Machine Learning Code is Probably Bad</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的机器学习代码可能不好的 4 个原因</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-reasons-why-your-machine-learning-code-is-probably-bad-c291752e4953?source=collection_archive---------18-----------------------#2019-03-27">https://towardsdatascience.com/4-reasons-why-your-machine-learning-code-is-probably-bad-c291752e4953?source=collection_archive---------18-----------------------#2019-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4955" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">你当前的 ML 工作流程可能会将几个线性执行的功能链接在一起。虽然很快，但它可能有许多问题。与其线性链接函数，不如将数据科学代码编写为一组任务，它们之间存在依赖关系。也就是说，您的数据科学工作流应该是一个 DAG。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/aed41c1c627ab5bf85fcbdbe62494b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNeHZP7DZrMkVbC_lRShmQ.png"/></div></div></figure><p id="ec92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您当前的工作流程可能将几个功能连接在一起，如下例所示。虽然很快，但它可能有许多问题:</p><ul class=""><li id="38de" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">随着复杂性的增加，它无法很好地扩展</li><li id="bd9c" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">您必须手动跟踪哪些函数是用哪些参数运行的</li><li id="2f0f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">您必须手动跟踪数据保存的位置</li><li id="1c0f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">其他人很难阅读</li></ul><pre class="kq kr ks kt gt lp lq lr ls aw lt bi"><span id="4ab4" class="lu lv it lq b gy lw lx l ly lz">import pandas as pd<br/>import sklearn.svm, sklearn.metrics</span><span id="357c" class="lu lv it lq b gy ma lx l ly lz">def get_data():<br/>    data = download_data()<br/>    data.to_pickle('data.pkl')</span><span id="c8e6" class="lu lv it lq b gy ma lx l ly lz">def preprocess(data):<br/>    data = clean_data(data)<br/>    return data</span><span id="1897" class="lu lv it lq b gy ma lx l ly lz"># flow parameters<br/>do_preprocess = True</span><span id="08de" class="lu lv it lq b gy ma lx l ly lz"># run workflow<br/>get_data()</span><span id="79c6" class="lu lv it lq b gy ma lx l ly lz">df_train = pd.read_pickle('data.pkl')<br/>if do_preprocess:<br/>    df_train = preprocess(df_train)<br/>model = sklearn.svm.SVC()<br/>model.fit(df_train.iloc[:,:-1], df_train['y'])<br/>print(sklearn.metrics.accuracy_score(df_train['y'],model.predict(df_train.iloc[:,:-1])))</span></pre><h1 id="2891" class="mb lv it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">该怎么办呢？</h1><p id="c000" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">与其线性链接函数，不如将数据科学代码编写为一组任务，它们之间存在依赖关系。也就是说，您的数据科学工作流应该是一个 DAG。</p><p id="a156" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">https://github.com/d6t/d6tflow 是一个免费的开源库，可以让你轻松构建高效的数据科学工作流。</p><p id="aafa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们没有编写这样的函数:</p><pre class="kq kr ks kt gt lp lq lr ls aw lt bi"><span id="7827" class="lu lv it lq b gy lw lx l ly lz">def process_data(df, parameter):<br/>    df = do_stuff(df)<br/>    data.to_pickle('data.pkl')<br/>    return df</span><span id="bee4" class="lu lv it lq b gy ma lx l ly lz">dataraw = download_data()<br/>data = process_data(dataraw)</span></pre><p id="8123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以编写可以作为 DAG 链接在一起的任务:</p><pre class="kq kr ks kt gt lp lq lr ls aw lt bi"><span id="031c" class="lu lv it lq b gy lw lx l ly lz">class TaskGetData(d6tflow.tasks.TaskPqPandas):</span><span id="c1be" class="lu lv it lq b gy ma lx l ly lz">    def run():<br/>        data = download_data()<br/>        self.save(data) # save output data</span><span id="9440" class="lu lv it lq b gy ma lx l ly lz">class TaskProcess(d6tflow.tasks.TaskPqPandas):</span><span id="d50f" class="lu lv it lq b gy ma lx l ly lz">    def requires(self):<br/>        return TaskGetData() # define dependency</span><span id="2f70" class="lu lv it lq b gy ma lx l ly lz">    def run(self):<br/>        data = self.input().load() # load input data<br/>        data = do_stuff(data) # process data<br/>        self.save(data) # save output data</span><span id="ce05" class="lu lv it lq b gy ma lx l ly lz">data = TaskProcess().output().load() # load output data</span></pre><p id="326d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的好处是:</p><ul class=""><li id="d0b0" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">不管你的工作流程有多复杂，所有的任务都遵循相同的模式</li><li id="e0c2" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">你有一个可伸缩的输入<code class="fe ne nf ng lq b">requires()</code>和处理功能<code class="fe ne nf ng lq b">run()</code></li><li id="2511" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">您可以快速加载和保存数据，而不必硬编码文件名</li><li id="c2fd" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">如果输入任务没有完成，它将自动运行</li><li id="b66b" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">如果输入数据或参数改变，该功能将自动重新运行</li><li id="efd7" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">其他人阅读和理解工作流要容易得多</li></ul><h1 id="39c4" class="mb lv it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">机器学习 DAG 示例</h1><p id="453a" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">下面是一个机器学习流程的程式化示例，用 DAG 表示。最后，您只需要运行 TaskTrain()，它就会自动知道要运行哪些依赖项。完整示例见<a class="ae nd" href="https://github.com/d6t/d6tflow/blob/master/docs/example-ml.md" rel="noopener ugc nofollow" target="_blank">https://github . com/d6t/d6t flow/blob/master/docs/example-ml . MD</a></p><pre class="kq kr ks kt gt lp lq lr ls aw lt bi"><span id="b9d3" class="lu lv it lq b gy lw lx l ly lz">import pandas as pd<br/>import sklearn, sklearn.svm<br/>import d6tflow<br/>import luigi</span><span id="d577" class="lu lv it lq b gy ma lx l ly lz"># define workflow<br/>class TaskGetData(d6tflow.tasks.TaskPqPandas):  # save dataframe as parquet</span><span id="093f" class="lu lv it lq b gy ma lx l ly lz">    def run(self):<br/>        data = download_data()<br/>        data = clean_data(data)<br/>        self.save(data) # quickly save dataframe</span><span id="5b59" class="lu lv it lq b gy ma lx l ly lz">class TaskPreprocess(d6tflow.tasks.TaskCachePandas):  # save data in memory<br/>    do_preprocess = luigi.BoolParameter(default=True) # parameter for preprocessing yes/no</span><span id="8576" class="lu lv it lq b gy ma lx l ly lz">    def requires(self):<br/>        return TaskGetData() # define dependency</span><span id="c21c" class="lu lv it lq b gy ma lx l ly lz">    def run(self):<br/>        df_train = self.input().load() # quickly load required data<br/>        if self.do_preprocess:<br/>            df_train = preprocess(df_train)<br/>        self.save(df_train)</span><span id="540b" class="lu lv it lq b gy ma lx l ly lz">class TaskTrain(d6tflow.tasks.TaskPickle): # save output as pickle<br/>    do_preprocess = luigi.BoolParameter(default=True)</span><span id="5081" class="lu lv it lq b gy ma lx l ly lz">    def requires(self):<br/>        return TaskPreprocess(do_preprocess=self.do_preprocess)</span><span id="4d7e" class="lu lv it lq b gy ma lx l ly lz">    def run(self):<br/>        df_train = self.input().load()<br/>        model = sklearn.svm.SVC()<br/>        model.fit(df_train.iloc[:,:-1], df_train['y'])<br/>        self.save(model)</span><span id="4ce8" class="lu lv it lq b gy ma lx l ly lz"># Check task dependencies and their execution status<br/>d6tflow.preview(TaskTrain())</span><span id="1c9c" class="lu lv it lq b gy ma lx l ly lz">'''<br/>└─--[TaskTrain-{'do_preprocess': 'True'} (PENDING)]<br/>   └─--[TaskPreprocess-{'do_preprocess': 'True'} (PENDING)]<br/>      └─--[TaskGetData-{} (PENDING)]<br/>'''</span><span id="2f0b" class="lu lv it lq b gy ma lx l ly lz"># Execute the model training task including dependencies<br/>d6tflow.run(TaskTrain())</span><span id="7f09" class="lu lv it lq b gy ma lx l ly lz">'''<br/>===== Luigi Execution Summary =====</span><span id="60f8" class="lu lv it lq b gy ma lx l ly lz">Scheduled 3 tasks of which:<br/>* 3 ran successfully:<br/>    - 1 TaskGetData()<br/>    - 1 TaskPreprocess(do_preprocess=True)<br/>    - 1 TaskTrain(do_preprocess=True)<br/>'''</span><span id="6b7b" class="lu lv it lq b gy ma lx l ly lz"># Load task output to pandas dataframe and model object for model evaluation<br/>model = TaskTrain().output().load()<br/>df_train = TaskPreprocess().output().load()<br/>print(sklearn.metrics.accuracy_score(df_train['y'],model.predict(df_train.iloc[:,:-1])))<br/># 0.9733333333333334</span></pre><h1 id="3003" class="mb lv it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="106e" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">将机器学习代码编写为一系列线性函数可能会产生许多工作流问题。由于不同 ML 任务之间复杂的依赖关系，最好将它们写成 DAG。https://github.com/d6t/d6tflow 让这变得非常容易。或者，你可以使用<a class="ae nd" href="https://github.com/spotify/luigi" rel="noopener ugc nofollow" target="_blank"> luigi </a>和<a class="ae nd" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank"> airflow </a>，但是它们更适合 ETL 而不是数据科学。</p></div></div>    
</body>
</html>