<html>
<head>
<title>Advanced Keras — Accurately Resuming a Training Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级 Keras —准确恢复训练过程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/resuming-a-training-process-with-keras-3e93152ee11a?source=collection_archive---------4-----------------------#2019-01-02">https://towardsdatascience.com/resuming-a-training-process-with-keras-3e93152ee11a?source=collection_archive---------4-----------------------#2019-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bb0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理使用自定义回调的重要情况</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6dfc34bd9904d7a904c28eb4f88e1e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KFqEdMr1TZjNg5GGq_i6A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo Credit: Eyal Zakkay</figcaption></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="c58a" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在这篇文章中，我将展示 Keras API 的一个用例，在这个用例中，从一个加载的检查点恢复一个训练过程需要以不同于平常的方式来处理。</p><p id="a3bf" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir">TL；DR —如果您使用的自定义回调函数的内部变量在训练过程中会发生变化，那么您需要在恢复时通过不同的方式初始化这些回调函数来解决这个问题。</strong></p><p id="4534" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">当使用 Keras 训练深度学习模型时，我们通常会保存该模型状态的检查点，以便我们可以恢复中断的训练过程，并从我们停止的地方重新开始。通常这是通过<a class="ae ly" href="https://keras.io/callbacks/#modelcheckpoint" rel="noopener ugc nofollow" target="_blank">模型检查点回调</a>来完成的。根据 Keras 的<a class="ae ly" href="https://keras.io/getting-started/faq/#savingloading-whole-models-architecture-weights-optimizer-state" rel="noopener ugc nofollow" target="_blank">文档，保存的模型(用<code class="fe lz ma mb mc b">model.save(filepath)</code>保存)包含以下内容:</a></p><ul class=""><li id="2c5e" class="md me iq le b lf lg li lj ll mf lp mg lt mh lx mi mj mk ml bi translated">模型的架构，允许重新创建模型</li><li id="5b30" class="md me iq le b lf mm li mn ll mo lp mp lt mq lx mi mj mk ml bi translated">模型的权重</li><li id="482b" class="md me iq le b lf mm li mn ll mo lp mp lt mq lx mi mj mk ml bi translated">培训配置(损失、优化器)</li><li id="5c48" class="md me iq le b lf mm li mn ll mo lp mp lt mq lx mi mj mk ml bi translated">优化器的状态，<strong class="le ir">允许从您停止的地方继续训练</strong>。</li></ul><p id="e7b3" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在某些用例中，最后一部分并不完全正确。</p><p id="e605" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir">示例</strong>:</p><p id="4182" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">假设您正在训练一个具有自定义学习率调度器回调的模型，它会在<strong class="le ir">每批</strong>之后更新 LR:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f2b1" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">当回调被创建时，<code class="fe lz ma mb mc b">counter</code>变量被初始化为零，并与全局批处理索引保持一致(在<code class="fe lz ma mb mc b">on_batch_end</code>中的<code class="fe lz ma mb mc b">batch </code>参数将批处理索引保存在<em class="mt">当前</em>时期内)。</p><p id="e8a4" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">假设我们想从一个检查点恢复一个训练过程。通常的方法是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The wrong way to do it</figcaption></figure><p id="79ef" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">注意，<code class="fe lz ma mb mc b">LearningRateSchedulerPerBatch</code>回调用<code class="fe lz ma mb mc b">counter=0</code>初始化，即使在恢复时也是如此。当训练恢复时<strong class="le ir">,这将不会重现保存检查点时发生的相同情况。</strong>学习率将从初始值重新开始，这可能不是我们想要的。</p><h1 id="3f3f" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">做这件事的正确方法</h1><p id="f2a4" class="pw-post-body-paragraph lc ld iq le b lf nm jr lh li nn ju lk ll no ln lo lp np lr ls lt nq lv lw lx ij bi translated">我们看到了一个例子，回调的错误初始化如何在恢复时导致不想要的结果。有几种方法可以实现这一点，这里我将描述两种方法:</p><p id="b4cf" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir">解决方案 1:用正确的值更新变量</strong></p><p id="3d2d" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在处理简单的情况时，回调只有少量的更新变量，在恢复之前覆盖这些变量的值是相当简单的。在我们的例子中，如果我们想用正确的值<code class="fe lz ma mb mc b">count</code>来恢复，我们将做以下事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="846b" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir">解决方案 2:用 Pickle 保存和加载回调</strong></p><p id="9144" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">当我们的自定义回调有许多更新变量或包含复杂行为时，安全地覆盖每个变量可能会很困难。另一个解决方案是在每次保存检查点时清理回调实例，然后我们可以在恢复时加载这个清理，并用所有正确的值重建原始回调。</p><p id="b927" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir"> <em class="mt">注意:为了清理你的回调函数，它们不能包含任何不可序列化的元素。此外，在 Keras 版本&lt; 2.2.3 中，模型本身是不可序列化的。这防止了任何回调的酸洗，因为每个回调也持有对模型的引用。</em> </strong></p><p id="39fe" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在这种情况下，恢复将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e623" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">您可能已经注意到，我使用了一个名为<code class="fe lz ma mb mc b">ModelCheckpointEnhanced</code>的修改过的检查点回调。这是因为使用 pickless 方法意味着我们还需要<code class="fe lz ma mb mc b">ModelCheckpoint</code>回调来保存相关回调的 pickle。这种修改后的回调的示例实现可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="cef7" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">上面的例子处理了你只需要处理一个回调的情况，如果你有多个回调需要保存，你将需要执行一些小的修改。</p><h1 id="bc6d" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">摘要</h1><p id="3e0c" class="pw-post-body-paragraph lc ld iq le b lf nm jr lh li nn ju lk ll no ln lo lp np lr ls lt nq lv lw lx ij bi translated">我们看到了在某些情况下，采取天真的方法来恢复训练过程会导致不希望的结果。我们看到了两种处理这种情况的方法，以便在重新开始中断的培训过程时获得一致的结果。</p><p id="794e" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我使用的例子来自我的草图-RNN 算法的<a class="ae ly" href="https://github.com/eyalzk/sketch_rnn_keras" rel="noopener ugc nofollow" target="_blank"> Keras 实现，这是一个用于生成草图的序列到序列变分自动编码器模型。</a></p></div></div>    
</body>
</html>