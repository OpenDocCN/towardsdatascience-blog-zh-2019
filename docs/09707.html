<html>
<head>
<title>Santa2Graph: visualize high dimensional data with Giotto Mapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Santa2Graph:使用 Giotto Mapper 可视化高维数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualising-high-dimensional-data-with-giotto-mapper-897fcdb575d7?source=collection_archive---------13-----------------------#2019-12-20">https://towardsdatascience.com/visualising-high-dimensional-data-with-giotto-mapper-897fcdb575d7?source=collection_archive---------13-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="111a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拓扑数据可视化的 Mapper 算法的简单介绍，包括使用 giotto-learn 中的实现的教程</h2></div><blockquote class="ki kj kk"><p id="60fc" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">由弗朗西斯科·帕尔马、<a class="ae li" href="https://medium.com/@davide.burba" rel="noopener">大卫·伯巴、</a><a class="ae li" href="https://medium.com/@lewis.c.tunstall" rel="noopener">路易斯·汤斯顿、</a><a class="ae li" href="https://medium.com/@t.boys_87095" rel="noopener">托马斯·博伊斯</a>编剧</p></blockquote><p id="9c4c" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">教程链接:<a class="ae li" href="https://github.com/giotto-ai/tutorial_mapper" rel="noopener ugc nofollow" target="_blank">https://github.com/giotto-ai/tutorial_mapper</a></p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="0c02" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">除非你天生擅长数字，否则数据可视化仍然是数据分析最直接、最有效的洞察来源。特征之间的视觉相互作用提供了影响许多选择的洞察力，如特征工程和特征选择。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/d42fc16429e65c037e522762fdb654f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRcTJO54aRdzWhSaUcUCNw.png"/></div></div></figure><p id="99f3" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我们都喜欢有很多功能。好的一面是潜在的更多信息；不利的一面是很难分离这些信息。由于我们不能轻易地可视化三维以上的物体，标准的可视化方法不太适合高维数据。</p><p id="10e9" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><a class="ae li" href="https://research.math.osu.edu/tgda/mapperPBG.pdf" rel="noopener ugc nofollow" target="_blank"> Mapper 算法</a>提供了一种在单个图形中可视化数据内在形状的方法。这个图表是通过一个巧妙的聚类过程构建的，揭示了底层数据的粗略结构。实际上，理论结果证实了输出的拓扑准确性。</p><p id="4fd5" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在本文中，我们将介绍映射器算法，以及基于<a class="ae li" href="https://github.com/giotto-ai/giotto-learn" rel="noopener ugc nofollow" target="_blank"> giotto-learn </a>库给出的实现的<a class="ae li" href="https://github.com/giotto-ai/tutorial_mapper" rel="noopener ugc nofollow" target="_blank">教程</a>。它的一个很酷的特性允许您与一些映射器参数进行交互，而无需重新运行代码。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mf"><img src="../Images/254e3bda25a7a5e6ee2fc8c6d3ed99bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*bkrDPjcFejyTdGuE.gif"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Interactive Mapper available in giotto-learn.</figcaption></figure><h1 id="c72e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">映射器算法的应用</h1><p id="3aab" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">自 2007 年以来，Mapper 一直用于简化复杂交互的可视化。它提供了对大特征空间的定性分析，有助于在医学、材料科学和基因组学中的应用。最近，它也被应用于提高神经网络的鲁棒性。</p><p id="3df4" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">下面我们总结了映射器算法的两个著名应用:</p><h2 id="558b" class="nh ml it bd mm ni nj dn mq nk nl dp mu lj nm nn mw lk no np my ll nq nr na ns bi translated"><a class="ae li" href="https://www.ncbi.nlm.nih.gov/pubmed/21482760" rel="noopener ugc nofollow" target="_blank"> 1)乳腺癌患者分析</a></h2><p id="d43b" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">在一项乳腺癌研究中，只有 200 名患者，需要一种专门的方法来处理基因型特征空间的 30k 维。Mapper 算法已成功应用于对患者进行更精细的细分，从而大大改善了靶向治疗。在两个不同的数据集上进行了相同的分析，并提供了一致的输出，证明了算法的稳定性。</p><h2 id="7db7" class="nh ml it bd mm ni nj dn mq nk nl dp mu lj nm nn mw lk no np my ll nq nr na ns bi translated"><a class="ae li" href="https://www.nature.com/articles/srep01236" rel="noopener ugc nofollow" target="_blank">2)NBA 球员的分类</a></h2><p id="d909" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">如果你打过篮球，你就会知道篮球一直有五个位置:<em class="kn">控卫、得分后卫、小前锋、大前锋和中锋</em>。使用球员的统计数据和比赛中的表现，Mapper 算法确定了 13 种反映现代篮球动态的新打法。这让团队的总经理知道了组建团队时不可错过的技能。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nt"><img src="../Images/4758484d3a2ad52e66d2ad269edd44c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0N26To5P1ur4D0P94C5V8w.jpeg"/></div></div></figure><h1 id="e793" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">映射器算法</h1><p id="a59f" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">摘自<a class="ae li" href="https://research.math.osu.edu/tgda/mapperPBG.pdf" rel="noopener ugc nofollow" target="_blank">原创论文</a>:</p><blockquote class="ki kj kk"><p id="e179" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们并不试图获得一个数据集的完全准确的表示，而是获得一个易于理解的低维图像，它可以指出感兴趣的领域。</p></blockquote><p id="39cb" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">为了生成表示数据结构的粗略图形，该算法将点合并成节点，并在不同节点的公共点处连接它们。</p><p id="0cd1" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这个过程是由<a class="ae li" href="https://en.wikipedia.org/wiki/Nerve_of_a_covering" rel="noopener ugc nofollow" target="_blank">神经定理</a>驱动的，它保证了映射器输出在拓扑上等同于数据采样的形状。</p><p id="f3cd" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">实际上，该算法是一个三步过程:</p><ol class=""><li id="e36b" class="nu nv it ko b kp kq ks kt lj nw lk nx ll ny lh nz oa ob oc bi translated"><strong class="ko iu">过滤</strong>:我们通过使用过滤函数<em class="kn"> f. </em>将数据点映射到ℝ</li><li id="d881" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh nz oa ob oc bi translated"><strong class="ko iu">覆盖</strong>:我们用重叠区间覆盖过滤值。</li><li id="c36a" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh nz oa ob oc bi translated"><strong class="ko iu">聚类</strong>:对于每个区间，我们将一个聚类算法应用于在该区间中映射的观察值。</li></ol><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/72f23f088f876faeb03c06478482e969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Zvy4mH0gLUlS4i9PnBLbQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Among the points that are close in filter value, we cluster together the one that are similar in the original space. Nodes are connected whenever they share a point. (Source: <a class="ae li" href="https://arxiv.org/abs/1904.11044" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1904.11044</a>)</figcaption></figure><h1 id="6718" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1)过滤</h1><p id="f64a" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">映射器的第一步在于通过<strong class="ko iu">过滤函数</strong><em class="kn">f</em>:ℝⁿ<strong class="ko iu">→</strong>ℝᵐ.将每个数据点<strong class="ko iu"> x </strong>映射到低维空间ℝᵐ通常我们选择<em class="kn"> m=1 </em>或者<em class="kn"> m=2 </em>。</p><p id="6abd" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">过滤函数的选择对映射结果有很大的影响，因为过滤值较远的点没有机会聚集在一起。因此，过滤函数用作接近度的粗略测量。</p><p id="0457" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在上图中，作者使用了高度函数，但是原则上任何函数都可以完成这项工作。但是，一些常见的选择是:</p><ol class=""><li id="2ce6" class="nu nv it ko b kp kq ks kt lj nw lk nx ll ny lh nz oa ob oc bi translated">轴上的投影</li><li id="deb0" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh nz oa ob oc bi translated"><a class="ae li" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank"> PCA </a></li><li id="ad09" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh nz oa ob oc bi translated"><a class="ae li" href="https://research.math.osu.edu/tgda/mapperPBG.pdf" rel="noopener ugc nofollow" target="_blank">怪癖</a></li><li id="e749" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh nz oa ob oc bi translated"><a class="ae li" href="https://research.math.osu.edu/tgda/mapperPBG.pdf" rel="noopener ugc nofollow" target="_blank">密度</a></li><li id="c0dd" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh nz oa ob oc bi translated"><a class="ae li" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.entropy.html" rel="noopener ugc nofollow" target="_blank">熵</a></li></ol><h1 id="2211" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2)覆盖</h1><p id="1b27" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">我们以覆盖所有滤波器值的方式将图像空间划分成重叠的区间(或者区间的乘积，如果<em class="kn"> m &gt; 1 </em>)。我们称这样的结构为盖。</p><p id="4e6c" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">通常我们将封面设定为由相同尺寸的<em class="kn"> m </em>维间隔制成。例如，如果 filter 函数采用ℝ中的值，则 cover 由一系列等长的重叠线段组成。</p><p id="9f6f" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在这种情况下，要选择的参数是间隔数及其重叠百分比。在上面的例子中，有 4 个 25%重叠的区间。</p><h1 id="4808" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">3)聚类</h1><p id="7d0d" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">在最后一步中，我们在封面的每个区间上连续地执行聚类。通过过滤函数每次取间隔的预图像，在原始空间上进行聚类。输出图由以下部分组成:</p><ul class=""><li id="4d06" class="nu nv it ko b kp kq ks kt lj nw lk nx ll ny lh oi oa ob oc bi translated"><strong class="ko iu">节点</strong>，表示数据点的集群；</li><li id="f222" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh oi oa ob oc bi translated"><strong class="ko iu">边缘</strong>代表聚类对(共享一些数据点的聚类)之间的非空交集。由于时间间隔重叠，这是可能的。</li></ul><p id="3c9a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在这一点上，每个聚类代表图的一个节点，并且边对应于具有共同观察的聚类。</p><h1 id="fb95" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">教程:使用映射器检索圣诞老人</h1><p id="a696" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">直观理解映射器如何工作的最好方法是使用它并“玩”它的参数。</p><p id="b206" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><a class="ae li" href="https://giotto.ai" rel="noopener ugc nofollow" target="_blank"> Giotto </a>是一个开源项目，包含 giotto-learn，一个易于使用的拓扑数据分析工具包。它使用了一个类似 Scikit-learn 的 API，并提供了一种通过管道函数来适应映射器的便捷方法。给定 Numpy 数组形式的数据集，构建图形的代码如下:</p><pre class="lu lv lw lx gt oj ok ol om aw on bi"><span id="f052" class="nh ml it ok b gy oo op l oq or">pipeline = make_mapper_pipeline(<br/>    filter_func=Projection(column_indices=2),<br/>    cover=OneDimensionalCover(n_intervals=10, overlap_frac=0.1),<br/>    clusterer=DBSCAN(eps=0.5),<br/>)<br/>graph = pipeline.fit_transform(data)</span></pre><p id="815e" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我们将 Mapper 算法应用于数据集，该数据集包含从圣诞老人形状(即所谓的“圣诞老人云”)中采样的 20，000 个三维数据点。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi os"><img src="../Images/414c985fb323bb19674ffbf31fe42a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*pxa0Cx4WDgQGH0BpeThEJg.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Left: dataset sampled from <a class="ae li" href="https://free3d.com/3d-model/santa-clau-77751.html" rel="noopener ugc nofollow" target="_blank">here</a> using <a class="ae li" href="https://www.cloudcompare.org" rel="noopener ugc nofollow" target="_blank">CloudCompare</a>. Right: Mapper output using different parameters.</figcaption></figure><p id="5c6b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">作为第一次尝试，我们使用覆盖和聚类的默认参数以及高度上的投影作为过滤函数，即<em class="kn"> f: </em> <strong class="ko iu"> [ </strong> x，y，z <strong class="ko iu"> ]↦ </strong> z。我们通过点的平均颜色给每个节点着色:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ot"><img src="../Images/c8f21ceada3b715b8638c6c2209dabee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ODz9ANOTSNfEwhGG.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">With the default parameters Santa might make it through the chimney.</figcaption></figure><p id="2ded" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">该图不代表数据集，因为我们无法区分圣诞老人身体的任何特征。除了节点的任意位置之外，给圣诞老人一个蛇形的外观，该图相当于一条连接节点的线。这表明聚类算法的默认参数需要改变，因为我们总是将所有的过滤器间隔聚集在一起。</p><p id="ec46" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">为了解决这个问题，我们执行了更精细的聚类:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ou"><img src="../Images/8a697bce1e82fc4230da079b64b2bfe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqCeQuz54aQFRIOTu_Vg4Q.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Mapper output: DBSCAN(eps = 0.06).</figcaption></figure><p id="e588" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">太好了！这是一个不平凡的图形结构。特别是我们看到树枝的外观，代表圣诞老人的胳膊和腿。然而，在这幅画中，圣诞老人有四只手臂。</p><p id="8e52" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我们通过调整封面中间隔之间的重叠部分(默认值为 0.1)来解决这个问题:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ov"><img src="../Images/ccb4472371b4bcb2855271ec7e353597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*reGzMRSSixkVMBR_.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Mapper output: DBSCAN(eps = 0.06), overlap_frac = 0.35.</figcaption></figure><p id="c29e" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这次我们可以清楚地分辨出腿、胳膊和头。虽然它非常简单，但一般来说，这足以抓住主要结构。</p><p id="afc6" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我们可以通过<strong class="ko iu">增加封面中的区间数</strong>(默认为 10)来进一步完善我们的研究。这样，我们看到了代表帽子的节点的外观，以及将胸部与胡须分开的分支:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ow"><img src="../Images/64ce6989c0703f92be0c606828479ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sBSzcVldCHdyK6xj.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Mapper output: DBSCAN(eps = 0.06), overlap_frac = 0.35, n_intervals = 20.</figcaption></figure><h1 id="03bb" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="74ff" class="pw-post-body-paragraph kl km it ko b kp nc ju kr ks nd jx ku lj ne kx ky lk nf lb lc ll ng lf lg lh im bi translated">giotto-learn 库提供了 Mapper 算法的快速完整的 Python 实现。我们正在分享一个关于 3-d 数据的教程，现在你可以用你自己的映射图来表现高维数据集了。</p><p id="87ce" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><em class="kn">特别感谢 Umberto Lupo 和</em><a class="ae li" href="https://medium.com/@lewis.c.tunstall" rel="noopener"><em class="kn">Lewis Tunstall</em></a><em class="kn">在 giotto-learn 中实现映射器。</em></p><h1 id="f6c8" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">链接:</h1><ul class=""><li id="b56e" class="nu nv it ko b kp nc ks nd lj ox lk oy ll oz lh oi oa ob oc bi translated"><a class="ae li" href="https://github.com/giotto-ai/giotto-learn" rel="noopener ugc nofollow" target="_blank">Github 上的 Giotto 库</a></li><li id="8fc1" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh oi oa ob oc bi translated"><a class="ae li" href="https://github.com/giotto-ai/tutorial_mapper/blob/master/Christmas%20Mapper.ipynb" rel="noopener ugc nofollow" target="_blank">包含代码的笔记本</a></li><li id="397c" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh oi oa ob oc bi translated">更多学习资料请访问<a class="ae li" href="https://giotto.ai/" rel="noopener ugc nofollow" target="_blank">网站</a></li><li id="3902" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh oi oa ob oc bi translated"><a class="ae li" rel="noopener" target="_blank" href="/the-shape-of-chemical-functions-d1e1568d020">化学函数的形状</a>及其<a class="ae li" href="https://github.com/giotto-ai/the-shape-of-chemical-functions" rel="noopener ugc nofollow" target="_blank">笔记本</a></li><li id="e403" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh oi oa ob oc bi translated"><a class="ae li" rel="noopener" target="_blank" href="/the-shape-of-football-games-1589dc4e652a">足球的形状</a>及其<a class="ae li" href="https://github.com/giotto-ai/noise-to-signal" rel="noopener ugc nofollow" target="_blank">笔记本</a></li><li id="f452" class="nu nv it ko b kp od ks oe lj of lk og ll oh lh oi oa ob oc bi translated"><a class="ae li" rel="noopener" target="_blank" href="/detecting-stock-market-crashes-with-topological-data-analysis-7d5dd98abe42">检测股灾</a>及其<a class="ae li" href="https://github.com/giotto-ai/stock-market-crashes" rel="noopener ugc nofollow" target="_blank">笔记本</a></li></ul></div></div>    
</body>
</html>