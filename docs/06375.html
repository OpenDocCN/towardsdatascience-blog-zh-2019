<html>
<head>
<title>Building A Collaborative Filtering Recommender System with TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 TensorFlow 构建协同过滤推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-collaborative-filtering-recommender-system-with-tensorflow-82e63d27b420?source=collection_archive---------2-----------------------#2019-09-13">https://towardsdatascience.com/building-a-collaborative-filtering-recommender-system-with-tensorflow-82e63d27b420?source=collection_archive---------2-----------------------#2019-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/71893eb8c94611dd1f95adda807b7769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOM8OeGZq6FkquXQq-l7HA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source: Pixabay</figcaption></figure><div class=""/><div class=""><h2 id="2a29" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">推荐是建立在其他用户的现有评级基础上的，这些用户与我们想要推荐的用户具有相似的评级。矩阵分解</h2></div><h2 id="594d" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>是一种被<a class="ae lq" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank">推荐系统</a>广泛使用的技术，当你有足够大的用户项目数据时。它会根据相似用户的内容偏好进行推荐。</h2><p id="4b44" class="pw-post-body-paragraph lr ls jf lt b lu lv kg lw lx ly kj lz ld ma mb mc lh md me mf ll mg mh mi mj ij bi translated">因此，协同过滤不是处理<a class="ae lq" href="https://en.wikipedia.org/wiki/Cold_start_(computing)" rel="noopener ugc nofollow" target="_blank">冷启动</a>问题的合适模型，在这种情况下，协同过滤不能对尚未收集到足够信息的用户或项目做出任何推断。</p><p id="6970" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">但是一旦你有了相对大的用户-项目交互数据，那么协同过滤就是最广泛使用的推荐方法。我们将学习如何使用<a class="ae lq" href="https://cloud.google.com/solutions/machine-learning/recommendation-system-tensorflow-overview" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>构建一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>推荐系统。</p><h1 id="e1fc" class="mp kv jf bd kw mq mr ms kz mt mu mv lc kl mw km lg ko mx kp lk kr my ks lo mz bi translated">数据</h1><p id="3a5d" class="pw-post-body-paragraph lr ls jf lt b lu lv kg lw lx ly kj lz ld ma mb mc lh md me mf ll mg mh mi mj ij bi translated">我们再次使用预订交叉数据集，可以在<a class="ae lq" href="http://www2.informatik.uni-freiburg.de/~cziegler/BX/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。数据预处理步骤执行以下操作:</p><ul class=""><li id="fd89" class="na nb jf lt b lu mk lx ml ld nc lh nd ll ne mj nf ng nh ni bi translated">合并用户、评级和图书数据。</li><li id="4181" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">移除未使用的列。</li><li id="4dff" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">过滤至少有 25 个评分的书籍。</li><li id="b7a0" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">过滤至少给出 20 个评级的用户。记住，协同过滤算法通常需要用户的积极参与。</li></ul><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">recSys_preprocessing.py</figcaption></figure><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b192a8ccd694f0b5f3564f34a773df4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*P5SHlsBt17fKOtWq-G3JzQ.png"/></div></figure><p id="6355" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">因此，我们的最终数据集包含 5，850 本书的 3，192 个用户。并且每个用户给出了至少 20 个评级，每本书获得了至少 25 个评级。如果你没有图形处理器，这将是一个很好的大小。</p><p id="a8f1" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>方法专注于寻找对同一本书给出相似评价的用户，从而在用户之间建立一个链接，向他们推荐被正面评价的书籍。这样，我们寻找的是用户之间的关联，而不是书籍之间的关联。因此，协同过滤仅依靠观察到的用户行为来做出推荐，不需要简档数据或内容数据。</p><p id="9dfc" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">我们的技术将基于以下观察:</p><ul class=""><li id="89ec" class="na nb jf lt b lu mk lx ml ld nc lh nd ll ne mj nf ng nh ni bi translated">以类似方式对书籍进行评级的用户共享一个或多个隐藏的偏好。</li><li id="476f" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">具有共享偏好的用户可能会以相同的方式对相同的书籍进行评级。</li></ul><h1 id="7589" class="mp kv jf bd kw mq mr ms kz mt mu mv lc kl mw km lg ko mx kp lk kr my ks lo mz bi translated">张量流中的过程</h1><p id="1136" class="pw-post-body-paragraph lr ls jf lt b lu lv kg lw lx ly kj lz ld ma mb mc lh md me mf ll mg mh mi mj ij bi translated">首先，我们将标准化评级功能。</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="d8bf" class="ku kv jf nw b gy oa ob l oc od">scaler = MinMaxScaler()<br/>combined['Book-Rating'] = combined['Book-Rating'].values.astype(float)<br/>rating_scaled = pd.DataFrame(scaler.fit_transform(combined['Book-Rating'].values.reshape(-1,1)))<br/>combined['Book-Rating'] = rating_scaled</span></pre><p id="8946" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">然后，构建具有三个特征的用户、预订矩阵:</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="2818" class="ku kv jf nw b gy oa ob l oc od">combined = combined.drop_duplicates(['User-ID', 'Book-Title'])<br/>user_book_matrix = combined.pivot(index='User-ID', columns='Book-Title', values='Book-Rating')<br/>user_book_matrix.fillna(0, inplace=True)</span><span id="5d3c" class="ku kv jf nw b gy oe ob l oc od">users = user_book_matrix.index.tolist()<br/>books = user_book_matrix.columns.tolist()</span><span id="0eb2" class="ku kv jf nw b gy oe ob l oc od">user_book_matrix = user_book_matrix.as_matrix()</span></pre><p id="ff56" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated"><code class="fe of og oh nw b">tf.placeholder</code>仅在 v1 中可用，所以我必须这样做:</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="7562" class="ku kv jf nw b gy oa ob l oc od">import tensorflow.compat.v1 as tf<br/>tf.disable_v2_behavior()</span></pre><p id="1b5e" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">在下面的代码脚本中</p><ul class=""><li id="f19c" class="na nb jf lt b lu mk lx ml ld nc lh nd ll ne mj nf ng nh ni bi translated">我们设置了一些网络参数，比如每个隐层的维数。</li><li id="d46a" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">我们将初始化 TensorFlow 占位符。</li><li id="b955" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">权重和偏差是随机初始化的。</li><li id="f967" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">以下代码摘自《Python 机器学习烹饪书——第二版》</li></ul><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">placeholder.py</figcaption></figure><p id="dce0" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">现在，我们可以建立编码器和解码器模型。</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">encoder_decoder.py</figcaption></figure><p id="9140" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">现在，我们构建模型和预测</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="13bb" class="ku kv jf nw b gy oa ob l oc od">encoder_op = encoder(X)<br/>decoder_op = decoder(encoder_op)</span><span id="4e5f" class="ku kv jf nw b gy oe ob l oc od">y_pred = decoder_op</span><span id="439d" class="ku kv jf nw b gy oe ob l oc od">y_true = X</span></pre><p id="1c91" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">在下面的代码中，我们定义损失函数和优化器，最小化平方误差，并定义评估指标。</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="2238" class="ku kv jf nw b gy oa ob l oc od">loss = tf.losses.mean_squared_error(y_true, y_pred)<br/>optimizer = tf.train.RMSPropOptimizer(0.03).minimize(loss)<br/>eval_x = tf.placeholder(tf.int32, )<br/>eval_y = tf.placeholder(tf.int32, )<br/>pre, pre_op = tf.metrics.precision(labels=eval_x, predictions=eval_y)</span></pre><p id="bb7c" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">因为 TensorFlow 使用计算图形进行运算，所以占位符和变量必须在拥有值之前进行初始化。因此，在下面的代码中，我们初始化变量，然后创建一个空数据框来存储结果表，这将是对每个用户的前 10 项建议。</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="d8a3" class="ku kv jf nw b gy oa ob l oc od">init = tf.global_variables_initializer()<br/>local_init = tf.local_variables_initializer()<br/>pred_data = pd.DataFrame()</span></pre><p id="48db" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">我们终于可以开始训练我们的模型了。</p><ul class=""><li id="7565" class="na nb jf lt b lu mk lx ml ld nc lh nd ll ne mj nf ng nh ni bi translated">我们把训练数据分成几批，然后把它们输入网络。</li><li id="9f61" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">我们用用户评级的向量来训练我们的模型，每个向量代表一个用户，每个列代表一本书，条目是用户给书的评级。</li><li id="4731" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">经过几次尝试，我发现批量大小为 35 的 100 个时期的训练模型将消耗足够的内存。这意味着整个训练集将馈给我们的神经网络 100 次，每次使用 35 个用户。</li><li id="20c1" class="na nb jf lt b lu nj lx nk ld nl lh nm ll nn mj nf ng nh ni bi translated">最后，我们必须确保删除训练集中的用户评级。也就是说，我们不能向一个用户推荐他(或她)已经评价过的书籍。</li></ul><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">recSys_train.py</figcaption></figure><p id="8dee" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">最后，让我们看看我们的模型是如何工作的。我随机选择了一个用户，看看我们应该向他(或她)推荐什么书。</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="0cc7" class="ku kv jf nw b gy oa ob l oc od">top_ten_ranked.loc[top_ten_ranked['User-ID'] == 278582]</span></pre><figure class="no np nq nr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/e474dd6758b6832ed63972d0593de344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zO0kGInfC3i2hmwtRaXTqQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Table 2</figcaption></figure><p id="eb96" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">以上是该用户的前 10 个结果，按标准化预测评分排序。</p><p id="94a1" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">我们来看看他(或她)评价过哪些书，按评价排序。</p><pre class="no np nq nr gt nv nw nx ny aw nz bi"><span id="bdfc" class="ku kv jf nw b gy oa ob l oc od">book_rating.loc[book_rating['User-ID'] == 278582].sort_values(by=['Book-Rating'], ascending=False)</span></pre><figure class="no np nq nr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/1be403ca9e359864193567914eca95c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ax0sm54IE45Ia_7Mrtz2KQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Table 2</figcaption></figure><p id="e687" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">这位用户喜欢的书籍类型有:历史推理小说、惊悚悬疑小说、科幻小说、奇幻小说等。</p><p id="c07f" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">这个用户的前 10 个结果是:谋杀幻想小说，神秘惊悚小说等等。</p><p id="a254" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">结果并不令人失望。</p><p id="5dd2" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated"><a class="ae lq" href="https://github.com/susanli2016/Machine-Learning-with-Python/blob/master/Collaborative%20Filtering%20Model%20with%20TensorFlow.ipynb" rel="noopener ugc nofollow" target="_blank">Jupyter 笔记本</a>可以在<a class="ae lq" href="https://github.com/susanli2016/Machine-Learning-with-Python/blob/master/Collaborative%20Filtering%20Model%20with%20TensorFlow.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。星期五快乐！</p><p id="513f" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">参考资料:</p><p id="e460" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated">Python 机器学习烹饪书—第二版</p><p id="a819" class="pw-post-body-paragraph lr ls jf lt b lu mk kg lw lx ml kj lz ld mm mb mc lh mn me mf ll mo mh mi mj ij bi translated"><a class="ae lq" href="https://cloud.google.com/solutions/machine-learning/recommendation-system-tensorflow-overview" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/solutions/machine-learning/recommendation-system-tensor flow-overview</a></p></div></div>    
</body>
</html>