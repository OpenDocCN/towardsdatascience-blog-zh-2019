<html>
<head>
<title>Getting Your Hands Dirty with TensorFlow 2.0 and Keras API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TensorFlow 2.0 和 Keras API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-your-hands-dirty-with-tensorflow-2-0-and-keras-api-cc8579eb0915?source=collection_archive---------12-----------------------#2019-10-31">https://towardsdatascience.com/getting-your-hands-dirty-with-tensorflow-2-0-and-keras-api-cc8579eb0915?source=collection_archive---------12-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="225b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入研究使用 TensorFlow 2.0 和 Keras API 创建回归模型的技术细节。在 TensorFlow 2.0 中，Keras 自带 TensorFlow 库。API 得到了简化，使用起来更加方便。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/167756bc6cf5cb38086db06314d7c91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYiKMob1epC_ZoxPLBmp5A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Source: Pixabay</figcaption></figure><p id="a2cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TensorFlow 2.0 内部打包了 Keras，没有必要将 Keras 作为单独的模块导入(虽然如果需要也可以这样做)。TensorFlow 2.0 API 进行了简化和改进。这对我们——机器学习开发者来说是个好消息。</p><p id="f270" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以这样从 TensorFlow 导入 Keras:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="e1d4" class="lz ma it lv b gy mb mc l md me">from tensorflow import feature_column<br/>from tensorflow import keras<br/>from tensorflow.keras import layers</span><span id="33cf" class="lz ma it lv b gy mf mc l md me">print(tf.__version__)<br/>2.0.0</span></pre><p id="cfe5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我正在使用<a class="ae mg" href="https://www.tensorflow.org/guide/data#consuming_csv_data" rel="noopener ugc nofollow" target="_blank"> tf.data </a>输入管道来编码分类列，Keras API 与 tf.data 配合得很好。tf.data 的一个主要优势是它充当了数据和模型之间的桥梁。无需自己转换数据，只需定义转换规则，转换后的数据将自动应用于训练。</p><p id="4da8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据从 CSV 文件提取到 Pandas 数据帧:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="561f" class="lz ma it lv b gy mb mc l md me">column_names = ['report_id','report_params','day_part','exec_time']<br/>raw_dataframe = pd.read_csv('report_exec_times.csv')<br/>dataframe = raw_dataframe.copy()</span><span id="63d6" class="lz ma it lv b gy mf mc l md me">dataframe.head()</span></pre><p id="fd5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mh"> report_params </em>的列值各不相同，我们需要对该列进行规范化(使值处于相似的范围内):</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="01bb" class="lz ma it lv b gy mb mc l md me">eps=0.001 # 0 =&gt; 0.1¢<br/>dataframe['report_params'] = np.log(dataframe.pop('report_params')+eps)</span></pre><p id="e81f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用一个实用的方法(这个方法取自 TensorFlow <a class="ae mg" href="https://www.tensorflow.org/tutorials/structured_data/feature_columns" rel="noopener ugc nofollow" target="_blank">教程</a>)从熊猫数据帧创建 tf.data 数据集:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="9e63" class="lz ma it lv b gy mb mc l md me">def df_to_dataset(dataframe, shuffle=True, batch_size=32):<br/>  dataframe = dataframe.copy()<br/>  labels = dataframe.pop('exec_time')<br/>  ds = tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))<br/>  if shuffle:<br/>    ds = ds.shuffle(buffer_size=len(dataframe))<br/>  ds = ds.batch(batch_size)<br/>  return ds</span></pre><p id="2612" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要为分类列编码定义数据映射。我用的是 TensorFlow 词汇列表函数，包括所有唯一值的映射(如果值很多，用嵌入 API 会更好)。两列被编码— <em class="mh">报告 _id </em>和<em class="mh">日 _ 部分</em>:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="f816" class="lz ma it lv b gy mb mc l md me">feature_columns = []</span><span id="0108" class="lz ma it lv b gy mf mc l md me">feature_columns.append(feature_column.numeric_column('report_params'))</span><span id="bfa8" class="lz ma it lv b gy mf mc l md me">report_id = feature_column.categorical_column_with_vocabulary_list('report_id', ['1', '2', '3', '4', '5'])<br/>report_id_one_hot = feature_column.indicator_column(report_id)<br/>feature_columns.append(report_id_one_hot)</span><span id="12e6" class="lz ma it lv b gy mf mc l md me">day_part = feature_column.categorical_column_with_vocabulary_list('day_part', ['1', '2', '3'])<br/>day_part_one_hot = feature_column.indicator_column(day_part)<br/>feature_columns.append(day_part_one_hot)</span></pre><p id="018c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 TensorFlow 编码在数组外创建 Keras 密集要素图层。我们将在 Keras 模型构建期间使用该层来定义模型训练特征:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="3a95" class="lz ma it lv b gy mb mc l md me">feature_layer = tf.keras.layers.DenseFeatures(feature_columns)</span></pre><p id="2fc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经完成了功能。接下来，在实用函数的帮助下，将 Pandas dataframe 转换为 tf.data:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="2f60" class="lz ma it lv b gy mb mc l md me">batch_size = 32<br/>train_ds = df_to_dataset(train, batch_size=batch_size)<br/>val_ds = df_to_dataset(val, shuffle=False, batch_size=batch_size)<br/>test_ds = df_to_dataset(test, shuffle=False, batch_size=batch_size)</span></pre><p id="7e01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义 Keras 顺序模型时使用密集特征层(无需将特征数组传递到<em class="mh"> fit </em>函数中):</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="633f" class="lz ma it lv b gy mb mc l md me">def build_model(feature_layer):<br/>  model = keras.Sequential([<br/>    feature_layer,<br/>    layers.Dense(16, activation='relu'),<br/>    layers.Dense(16, activation='relu'),<br/>    layers.Dense(1)<br/>  ])</span><span id="db1c" class="lz ma it lv b gy mf mc l md me">  optimizer = keras.optimizers.RMSprop(0.001)</span><span id="b772" class="lz ma it lv b gy mf mc l md me">  model.compile(loss='mse',<br/>                optimizer=optimizer,<br/>                metrics=['mae', 'mse'])<br/>  return model</span></pre><p id="173a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过<em class="mh"> model.fit </em>功能执行训练。我们使用 tf.data 输入管道来通过训练和验证集:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="f793" class="lz ma it lv b gy mb mc l md me">history = model.fit(train_ds,<br/>              validation_data=val_ds,<br/>              epochs=EPOCHS,<br/>              callbacks=[early_stop])</span></pre><p id="cdc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令人惊叹的是，数据编码发生在幕后，基于为要素图层定义的规则。</p><p id="aa8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何用 tf.data 和 feature 图层运行<em class="mh"> model.predict </em>函数？很简单。</p><p id="6f20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用输入数据构建熊猫数据框架:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="7bf6" class="lz ma it lv b gy mb mc l md me">headers = ['report_id', 'report_params', 'day_part']<br/>dataframe_input = pd.DataFrame([[1, 15, 3]],<br/>                                columns=headers, <br/>                                dtype=float,<br/>                                index=['input'])</span></pre><p id="f40d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将<em class="mh"> report_params </em>值转换为与训练时相同的比例:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="42e5" class="lz ma it lv b gy mb mc l md me">eps=0.001 # 0 =&gt; 0.1¢<br/>dataframe_input['report_params'] = np.log(dataframe_input.pop('report_params')+eps)</span></pre><p id="30d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从 Pandas 数据帧创建 tf.data 输入管道:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="43d5" class="lz ma it lv b gy mb mc l md me">input_ds = tf.data.Dataset.from_tensor_slices(dict(dataframe_input))<br/>input_ds = input_ds.batch(1)</span></pre><p id="2ec7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行<em class="mh">模型预测</em>功能:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="9262" class="lz ma it lv b gy mb mc l md me">res = model.predict(input_ds)<br/>print(res)</span></pre><p id="fe2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">资源:</p><ul class=""><li id="6da5" class="mi mj it la b lb lc le lf lh mk ll ml lp mm lt mn mo mp mq bi translated">带有示例数据的源代码可以在我的<a class="ae mg" href="https://github.com/abaranovskis-redsamurai/automation-repo/tree/master/tf2.0" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo 上获得</li></ul><p id="232a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽情享受吧！</p></div></div>    
</body>
</html>