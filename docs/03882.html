<html>
<head>
<title>Keras vs PyTorch for Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习的 Keras vs PyTorch</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d?source=collection_archive---------1-----------------------#2019-06-19">https://towardsdatascience.com/keras-vs-pytorch-for-deep-learning-a013cb63870d?source=collection_archive---------1-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/52c4ffe0003e6df5ac40abbafab1728f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDQkh3ymaYRciVo5w4nwoQ.png"/></div></div></figure><blockquote class="kb kc kd"><p id="d260" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">想获得灵感？快来加入我的<a class="ae ld" href="https://www.superquotes.co/?utm_source=mediumtech&amp;utm_medium=web&amp;utm_campaign=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="kh iu">超级行情快讯</strong> </a>。😎</p></blockquote><p id="7e03" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">对于许多科学家、工程师和开发人员来说，TensorFlow 是他们的第一个深度学习框架。TensorFlow 1.0 发布于 2017 年 2 月；至少可以说，它对用户不太友好。</p><p id="ff36" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在过去的几年里，两个主要的深度学习库获得了巨大的人气，主要是因为它们比 TensorFlow 更容易使用:<strong class="kh iu"> Keras </strong>和<strong class="kh iu"> PyTorch </strong>。</p><p id="b0a0" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">本文将涵盖 Keras vs. PyTorch 的 4 个不同方面，以及为什么您会选择一个库而不是另一个库。</p><h2 id="9bb1" class="lh li it bd lj lk ll dn lm ln lo dp lp le lq lr ls lf lt lu lv lg lw lx ly lz bi translated">克拉斯</h2><p id="5b8d" class="pw-post-body-paragraph ke kf it kh b ki ma kk kl km mb ko kp le mc ks kt lf md kw kx lg me la lb lc im bi translated">Keras 本身并不是一个框架，实际上是一个位于其他深度学习框架之上的高级 API。目前它支持 TensorFlow、Theano 和 CNTK。</p><p id="e50f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Keras 的妙处在于好用。这是迄今为止最容易快速启动和运行的框架。定义神经网络是直观的，使用函数式 API 可以将层定义为函数。</p><h2 id="97ac" class="lh li it bd lj lk ll dn lm ln lo dp lp le lq lr ls lf lt lu lv lg lw lx ly lz bi translated">PyTorch</h2><p id="d781" class="pw-post-body-paragraph ke kf it kh b ki ma kk kl km mb ko kp le mc ks kt lf md kw kx lg me la lb lc im bi translated">Pyorch 是由脸书人工智能研究小组开发的深度学习框架(类似 TensorFlow)。像 Keras 一样，它也抽象掉了编程深度网络的许多混乱部分。</p><p id="680b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">就高级和低级编码风格而言，Pytorch 介于 Keras 和 TensorFlow 之间。与 Keras 相比，您有更多的灵活性和控制力，但同时您不必进行任何疯狂的声明式编程。</p><p id="dad3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">深度学习的实践者整天都在考虑应该使用哪个框架。一般看个人喜好。但是当你做出选择时，你应该记住 Keras 和 Pytorch 的一些方面。</p><div class="mf mg mh mi gt ab cb"><figure class="mj ju mk ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/47931e4a519e0dfe029e5414302e503a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*x39y4Ukydd8fum-h_fnHjw.jpeg"/></div></figure><figure class="mj ju mk ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/793e2a6311ccea247ae352393fea78d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jhDZCg3hhTtz2mqcKmY1Lg.jpeg"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk mt di mu mv">It’s Pytorch!</figcaption></figure></div><h1 id="6d45" class="mw li it bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">(1)用于定义模型的类与函数</h1><p id="9fbd" class="pw-post-body-paragraph ke kf it kh b ki ma kk kl km mb ko kp le mc ks kt lf md kw kx lg me la lb lc im bi translated">为了定义深度学习模型，Keras 提供了函数式 API。使用函数式 API，神经网络被定义为一组连续的函数，一个接一个地应用。例如，功能定义层 1 的输出是功能定义层 2 的输入。</p><pre class="mf mg mh mi gt nn no np nq aw nr bi"><span id="263d" class="lh li it no b gy ns nt l nu nv">img_input = layers.Input(shape=input_shape)<br/>x = layers.Conv2D(64, (3, 3), activation='relu')(img_input)    <br/>x = layers.Conv2D(64, (3, 3), activation='relu')(x)    <br/>x = layers.MaxPooling2D((2, 2), strides=(2, 2))(x)</span></pre><p id="1e13" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在 Pytorch 中，您将网络设置为一个类，该类扩展了 torch 库中的 torch.nn .模块。与 Keras 类似，Pytorch 为您提供了作为构建块的层，但由于它们位于 Python 类中，因此它们在该类的 __init__()方法中被引用，并由该类的 forward()方法执行。</p><pre class="mf mg mh mi gt nn no np nq aw nr bi"><span id="85ac" class="lh li it no b gy ns nt l nu nv">class Net(nn.Module):<br/>    def __init__(self):<br/>        super(Net, self).__init__()<br/>        self.conv1 = nn.Conv2d(3, 64, 3)<br/>        self.conv2 = nn.Conv2d(64, 64, 3)<br/>        self.pool = nn.MaxPool2d(2, 2)<br/>    def forward(self, x):<br/>        x = F.relu(self.conv1(x))<br/>        x = self.pool(F.relu(self.conv2(x)))<br/>        return x<br/>model = Net()</span></pre><p id="7fd6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">因为 Pytorch 让您可以访问 Python 的所有类特性，而不是简单的函数调用，所以定义网络可以更清晰、更优雅。这真的没有太大的坏处，除非你真的觉得尽快编写网络代码对你来说是最重要的，那么 Keras 会更容易使用。</p><h1 id="73ab" class="mw li it bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">(2)张量和计算图形与标准数组</h1><p id="ef72" class="pw-post-body-paragraph ke kf it kh b ki ma kk kl km mb ko kp le mc ks kt lf md kw kx lg me la lb lc im bi translated">Keras API 隐藏了许多不经意间被编码者发现的混乱细节。定义网络层很直观，默认设置通常足以让您入门。</p><p id="d843" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">只有在实现一个相当前沿或“奇特”的模型时，才真正需要深入到底层的、本质的张量流。</p><p id="cf02" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">棘手的部分是，当你真的深入到底层 TensorFlow 代码时，你会得到随之而来的所有具有挑战性的部分！你需要确保所有的矩阵乘法都排成一行。哦，甚至不要想打印出你的层的输出之一，因为你只会得到一个很好的张量定义打印在你的终端上。</p><p id="c131" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Pytorch 在这些方面更宽容一些。您需要知道每一层的输入和输出大小，但是这是比较容易的方面之一，您可以很快掌握。你不必处理构建一个抽象的计算图，你看不到里面的调试。</p><p id="8213" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Pytorch 的另一个优点是可以在 torch 张量和 Numpy 数组之间来回切换。如果您需要实现一些自定义的东西，那么在 TF tensors 和 Numpy 数组之间来回切换可能会很痛苦，需要开发人员对 TensorFlow 会话有很好的理解。</p><p id="8e47" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Pytorch 互操作实际上要简单得多。您只需要知道两个操作:一个是将 Torch 张量(一个可变对象)切换到 Numpy，另一个是相反的方向。</p><p id="7923" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">当然，如果您从来不需要实现任何花哨的东西，那么 Keras 会做得很好，因为您不会遇到任何 TensorFlow 路障。但如果你这样做了，Pytorch 可能会顺利得多。</p><h1 id="07bc" class="mw li it bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">(3)培训模式</h1><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/5d44fd2c3ffa8a053b20d7ec8012be82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lq0BPNz7gYQHvZkP.jpg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Time to train!</figcaption></figure><p id="2cd9" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在 Keras 训练一个模特超级容易！只需一个简单的<code class="fe nx ny nz no b">.fit()</code>动作，你就可以尽情享受旅程了！</p><pre class="mf mg mh mi gt nn no np nq aw nr bi"><span id="a02d" class="lh li it no b gy ns nt l nu nv">history = model.fit_generator(<br/>    generator=train_generator,<br/>    epochs=10,<br/>    validation_data=validation_generator)</span></pre><p id="f1e3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在 Pytorch 中训练模型包括几个步骤:</p><ol class=""><li id="dc30" class="oa ob it kh b ki kj km kn le oc lf od lg oe lc of og oh oi bi translated">在每批训练开始时初始化梯度</li><li id="d8fb" class="oa ob it kh b ki oj km ok le ol lf om lg on lc of og oh oi bi translated">通过模式运行正向传递；</li><li id="5a1c" class="oa ob it kh b ki oj km ok le ol lf om lg on lc of og oh oi bi translated">向后传球</li><li id="7b23" class="oa ob it kh b ki oj km ok le ol lf om lg on lc of og oh oi bi translated">计算损失并更新权重</li></ol><pre class="mf mg mh mi gt nn no np nq aw nr bi"><span id="5e6e" class="lh li it no b gy ns nt l nu nv">for epoch in range(2):  # loop over the dataset multiple times</span><span id="ab2e" class="lh li it no b gy oo nt l nu nv">    running_loss = 0.0<br/>    for i, data in enumerate(trainloader, 0):<br/>        # Get the inputs; data is a list of [inputs, labels]<br/>        inputs, labels = data</span><span id="a2e3" class="lh li it no b gy oo nt l nu nv">        # (1) Initialise gradients<br/>        optimizer.zero_grad()</span><span id="9b03" class="lh li it no b gy oo nt l nu nv">        # (2) Forward pass<br/>        outputs = net(inputs)<br/>        loss = criterion(outputs, labels)</span><span id="3b20" class="lh li it no b gy oo nt l nu nv">        # (3) Backward<br/>        loss.backward()</span><span id="abc6" class="lh li it no b gy oo nt l nu nv">        # (4) Compute the loss and update the weights<br/>        optimizer.step()</span></pre><p id="5fd2" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">光是运行培训就有很多步骤！</p><p id="db37" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我想这样你总是能意识到发生了什么。同时，这是完全不必要的，因为这些模型训练步骤对于训练不同的模型基本上保持不变。</p><h1 id="7382" class="mw li it bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">(4)控制 CPU 与 GPU 模式</h1><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/75f738a71a4c9c627ffa64cd776106a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vUkT0iaKt7aP1Fb8"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">We need MORE POWER</figcaption></figure><p id="bfa2" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果您已经安装了<code class="fe nx ny nz no b">tensorflow-gpu</code>，那么在 Keras 中，默认情况下会启用并使用 GPU。然后，如果您希望将某些操作转移到 CPU，您可以使用一行程序来完成。</p><pre class="mf mg mh mi gt nn no np nq aw nr bi"><span id="8123" class="lh li it no b gy ns nt l nu nv">with tf.device('/cpu:0'):<br/>    y = apply_non_max_suppression(x)</span></pre><p id="e35e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">对于 Pytorch，您必须为每个 torch 张量和 numpy 变量显式启用 GPU。这使代码变得混乱，如果您为了不同的操作在 CPU 和 GPU 之间来回移动，可能会有点容易出错。</p><p id="513c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">例如，要将我们以前的模型转移到 GPU 上运行，我们必须执行以下操作:</p><pre class="mf mg mh mi gt nn no np nq aw nr bi"><span id="ba3b" class="lh li it no b gy ns nt l nu nv"># Get the GPU device<br/>device <strong class="no iu">=</strong> torch<strong class="no iu">.</strong>device("cuda:0" <strong class="no iu">if</strong> torch<strong class="no iu">.</strong>cuda<strong class="no iu">.</strong>is_available() <strong class="no iu">else</strong> "cpu")</span><span id="6509" class="lh li it no b gy oo nt l nu nv"># Transfer the network to GPU<br/>net<strong class="no iu">.</strong>to(device)</span><span id="69ae" class="lh li it no b gy oo nt l nu nv"># Transfer the inputs and labels to GPU<br/>inputs, labels <strong class="no iu">=</strong> data[0]<strong class="no iu">.</strong>to(device), data[1]<strong class="no iu">.</strong>to(device)</span></pre><p id="a30e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Keras 的优势在于它的简单性和良好的默认设置</p><h1 id="c9ff" class="mw li it bd lj mx my mz lm na nb nc lp nd ne nf ls ng nh ni lv nj nk nl ly nm bi translated">选择框架的一般建议</h1><p id="7cfd" class="pw-post-body-paragraph ke kf it kh b ki ma kk kl km mb ko kp le mc ks kt lf md kw kx lg me la lb lc im bi translated">我通常给的建议是从 Keras 开始。</p><p id="51ac" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Keras 绝对是最容易使用、理解和快速启动并运行的框架。你不必担心 GPU 的设置，摆弄抽象代码，或一般做任何复杂的事情。你甚至可以做一些事情，比如实现<a class="ae ld" rel="noopener" target="_blank" href="/4-awesome-things-you-can-do-with-keras-and-the-code-you-need-to-make-it-happen-9b591286e4e0">自定义层和损失函数</a>，而无需接触 TensorFlow 的任何一行。</p><p id="b07a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果您开始深入到深层网络的更细粒度的方面，或者正在实现一些非标准的东西，那么 Pytorch 就是您的首选库。在 Keras 上会有一点额外的工作，但不会太多以至于减慢你的速度。您仍然能够快速实现、训练和测试您的网络，同时还能轻松调试！</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="c5b7" class="mw li it bd lj mx ox mz lm na oy nc lp nd oz nf ls ng pa ni lv nj pb nl ly nm bi translated">喜欢学习？</h1><p id="b36c" class="pw-post-body-paragraph ke kf it kh b ki ma kk kl km mb ko kp le mc ks kt lf md kw kx lg me la lb lc im bi translated">在<a class="ae ld" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，我会在那里发布所有最新最棒的人工智能、技术和科学！也在<a class="ae ld" href="https://www.linkedin.com/in/georgeseif/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系吧！</p></div></div>    
</body>
</html>