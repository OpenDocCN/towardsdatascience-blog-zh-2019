<html>
<head>
<title>Visualisation of Information from Raw Twitter Data — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自原始 Twitter 数据的信息可视化——第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualisation-of-information-from-raw-twitter-data-part-2-11707a65e920?source=collection_archive---------22-----------------------#2019-06-27">https://towardsdatascience.com/visualisation-of-information-from-raw-twitter-data-part-2-11707a65e920?source=collection_archive---------22-----------------------#2019-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e728" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">想要了解用户活动，查看某些用户是否是机器人，制作 Tweet 出版物的时间序列等等吗？接着读下去！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/874f9b7c8f9f40264f0343c4048ec11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEAxFiYG_cc59m4VCXzukQ.png"/></div></div></figure><p id="f73f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前一篇文章介绍了如何从 Twitter 下载关于某个主题的数据，在 Jupyter 笔记本中准备好这些数据<strong class="kw iu">，从这些数据中发现<strong class="kw iu">的见解</strong>，并探索了一些非常酷的<strong class="kw iu">可视化</strong>技术。如果您尚未阅读，您可以在此处找到它:</strong></p><div class="lq lr gp gr ls lt"><a rel="noopener follow" target="_blank" href="/visualization-of-information-from-raw-twitter-data-part-1-99181ad19c"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">来自原始 Twitter 数据的信息可视化—第 1 部分</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">让我们探索一下我们可以从原始 Twitter 数据中轻松检索到什么样的信息！</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">towardsdatascience.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ks lt"/></div></div></a></div><p id="bd29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这第二篇文章将描述其他令人敬畏的可视化，同时也探索一些可以从下载的<em class="mi"> tweets </em>中获得的更多信息。</p><p id="2c00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将从发现发布<em class="mi">推文</em>的用户的信息开始:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="eba5" class="mo mp it mk b gy mq mr l ms mt">#Lets take a look at the users who are posting these tweets:</span><span id="664b" class="mo mp it mk b gy mu mr l ms mt">print("There are {} different users".format(tweets['Username'].nunique()))</span></pre><p id="e0fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的例子中，<em class="mi">条推文</em>是由<strong class="kw iu"> 59508 个不同的用户</strong>发布的。</p><p id="59df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用我们精心准备的<strong class="kw iu">数据框架</strong>我们可以看到谁是发布最多<em class="mi">推文</em>的用户，更酷的是:看到高度活跃的用户成为<strong class="kw iu">机器人</strong>的几率！</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="bcf7" class="mo mp it mk b gy mq mr l ms mt">#Going to see who are the users who have tweeted or retweeted the #most and see how<br/>#Likely it is that they are bots</span><span id="e7ef" class="mo mp it mk b gy mu mr l ms mt">usertweets = tweets.groupby('Username')</span><span id="3642" class="mo mp it mk b gy mu mr l ms mt">#Taking the top 25 tweeting users</span><span id="eaaf" class="mo mp it mk b gy mu mr l ms mt">top_users = usertweets.count()['text'].sort_values(ascending = False)[:25]<br/>top_users_dict = top_users.to_dict()<br/>user_ordered_dict =sorted(top_users_dict.items(), key=lambda x:x[1])<br/>user_ordered_dict = user_ordered_dict[::-1]</span><span id="6faa" class="mo mp it mk b gy mu mr l ms mt">#Now, like in the previous hashtags and mention cases, going to make #two lists, one with the username and one with the value</span><span id="d777" class="mo mp it mk b gy mu mr l ms mt">dict_values = []<br/>dict_keys = []<br/>for item in user_ordered_dict[0:25]:<br/>    dict_keys.append(item[0])<br/>    dict_values.append(item[1])</span></pre><p id="d549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码非常类似于我们在<a class="ae mv" rel="noopener" target="_blank" href="/visualization-of-information-from-raw-twitter-data-part-1-99181ad19c">上一篇文章</a>中使用的代码，以查看最常用的<em class="mi">标签</em>或提到的用户。现在，像前面的例子一样，我们将绘制结果。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="dac3" class="mo mp it mk b gy mq mr l ms mt">#Plot these results</span><span id="0c9c" class="mo mp it mk b gy mu mr l ms mt">fig = plt.figure(figsize = (15,15))<br/>index = np.arange(25)<br/>plt.bar(index, dict_values, edgecolor = 'black', linewidth=1)<br/>plt.xlabel('Most active Users', fontsize = 18)<br/>plt.ylabel('Nº of Tweets', fontsize=20)<br/>plt.xticks(index,dict_keys, fontsize=15, rotation=90)<br/>plt.title('Number of tweets for the most active users', fontsize = 20)<br/>plt.savefig('Tweets_of_active_users.jpg')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/281c25786377755a02cfa7a8f57d8c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpjoABjcrgZ-tly3nv8ZJg.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Bar chart of the number of tweets produced by the top 25 tweeting users.</figcaption></figure><p id="aabe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到，<strong class="kw iu">最活跃的用户</strong>是<em class="mi"> @CrytoKaku </em>，发布的推文超过 400 条。太多了！他/她是机器人吗？让我们来看看吧！</p><p id="602a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们需要下载并导入<strong class="kw iu">僵尸工具</strong> Python 库，并获得一个能够使用他们的 API 的密钥。有关如何做到这一点的信息可以在以下链接中找到:</p><div class="lq lr gp gr ls lt"><a href="https://rapidapi.com/OSoMe/api/botometer?utm_source=mashape&amp;utm_medium=301" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">Botometer API 文档(OSoMe) | RapidAPI</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">Botometer(以前的 Truthy BotOrNot)检查 Twitter 账户的活动，并根据可能性给它打分</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">rapidapi.com</p></div></div></div></a></div><p id="812a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们将需要检索我们的<strong class="kw iu"> Twitter API 密钥</strong>，因为我们将需要它们来允许 Botometer 访问我们想要研究其活动的帐户的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/9caa9a0167f90f659b489fc20ade17b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssS0BhmaU3hqVp8T6zRD0w.jpeg"/></div></div></figure><p id="29cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将导入两个库。考虑到 Botometer 和 Tweepy 都必须使用您选择的软件包管理器<strong class="kw iu">预先下载</strong>。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f6de" class="mo mp it mk b gy mq mr l ms mt">#Now we will see the probabilities of each of the users being a bot #using the BOTOMETER API:</span><span id="0f95" class="mo mp it mk b gy mu mr l ms mt">import botometer<br/>import tweepy</span></pre><p id="dc11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们将<strong class="kw iu">输入所需的 API 键</strong>:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="33ea" class="mo mp it mk b gy mq mr l ms mt">#Key from BOTOMETER API<br/>mashape_key = "ENTER BOTOMETER API KEY"</span><span id="4647" class="mo mp it mk b gy mu mr l ms mt">#Dictionary with the credentials for the Twitter APIs<br/>twitter_app_auth = {<br/>    'access_token' : "ENTER ACCESS TOKEN",<br/>    'access_token_secret' : "ENTER ACCESS TOKEN SECRET",<br/>    'consumer_key' : "ENTER CONSUMER KEY",<br/>    'consumer_secret' : "ENTER CONSUMER SECRET",    <br/>}</span></pre><p id="8e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像以前的文章一样，把“<strong class="kw iu"> <em class="mi">回车… </em> </strong>”换成相应的键，就可以了。</p><p id="d055" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行下面的代码块来访问<strong class="kw iu">僵尸工具 API，</strong>，让我们看看前 25 名推特用户中哪些账户最有可能成为僵尸工具！</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="86ec" class="mo mp it mk b gy mq mr l ms mt">#Connecting to the botometer API<br/>bom = botometer.Botometer(wait_on_ratelimit = True, mashape_key = mashape_key, **twitter_app_auth)</span><span id="4ba7" class="mo mp it mk b gy mu mr l ms mt">#Returns a dictionary with the most active users and the porcentage #of likeliness of them bein a Bot using botometer</span><span id="d2a1" class="mo mp it mk b gy mu mr l ms mt">bot_dict = {}<br/>top_users_list = dict_keys<br/>for user in top_users_list:<br/>    user = '@'+ user<br/>    try:<br/>        result = bom.check_account(user)<br/>        bot_dict[user] = int((result['scores']['english'])*100)<br/>    except tweepy.TweepError:<br/>        bot_dict[user] = 'None'<br/>        continue</span></pre><p id="aaf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个模块的输出是一个<strong class="kw iu">字典<em class="mi"> (bot_dict) </em> </strong>，其中的关键字是我们正在检查的帐户名称，值是一个介于 0 和 1 之间的数值<strong class="kw iu">分数，它描述了每个用户成为机器人的概率，其中考虑了某些因素，如关注者/被关注者的比例、帐户描述、发布频率、发布类型以及更多参数。</strong></p><p id="1603" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于一些用户，Botometer API 得到一个<strong class="kw iu"> <em class="mi">拒绝请求</em>错误</strong>，所以这些将有一个“<em class="mi">无</em>”作为它们的值。</p><p id="16e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说，我在检查<strong class="kw iu"> <em class="mi"> bot_dict </em> </strong>时得到如下结果:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e383" class="mo mp it mk b gy mq mr l ms mt">{'@CryptoKaku': 25,<br/> '@ChrisWill1337': 'None',<br/> '@Doozy_45': 44,<br/> '@TornadoNewsLink': 59,<br/> '@johnnystarling': 15,<br/> '@brexit_politics': 42,<br/> '@lauramarsh70': 32,<br/> '@MikeMol1982': 22,<br/> '@EUVoteLeave23rd': 66,<br/> '@TheStephenRalph': 11,<br/> '@DavidLance3': 40,<br/> '@curiocat13': 6,<br/> '@IsThisAB0t': 68,<br/> '@Whocare31045220': 'None',<br/> '@EUwatchers': 34,<br/> '@c_plumpton': 15,<br/> '@DuPouvoirDachat': 40,<br/> '@botcotu': 5,<br/> '@Simon_FBFE': 42,<br/> '@CAGeurope': 82,<br/> '@botanic_my': 50,<br/> '@SandraDunn1955': 36,<br/> '@HackettTom': 44,<br/> '@shirleymcbrinn': 13,<br/> '@JKLDNMAD': 20}</span></pre><p id="0a59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这其中，成为 Bot 几率最高的账号是<strong class="kw iu"> @CAGeurope，概率为 82%。</strong>让我们来看看这个账户，看看为什么 Botometer 赋予它如此高的概率成为一个机器人。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/4e146b74ee80d886b193744676176619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYhkQLX9BkE6gG7vnmFUYw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Twitter account of <strong class="bd nd">@CAGeurope</strong></figcaption></figure><p id="4196" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来像一个合法的帐户，然而，有各种各样的原因解释为什么 Botometer 给了它这么高的概率是一个机器人。首先，这个账户关注的账户数量几乎是关注它的账户数量的三倍。其次，如果我们看看他们的<em class="mi">推文</em>出版物的<strong class="kw iu">周期性，我们可以看到他们始终如一地每小时发布各种推文，有时间隔 5 分钟，这是一个很大的<em class="mi">推文</em>。最后，他们的<em class="mi">推文</em>的<strong class="kw iu">内容</strong>总是非常相似，都是简短的文本、一个 URL 和一些标签。</strong></p><p id="9c64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您不想编写任何代码或获取 API 密钥，Botometer 还提供了一个基于 web 的解决方案<strong class="kw iu">，在这里您还可以检查帐户成为机器人的可能性:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/360003d8a19c3ae77172cab2b62cf832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6M8ouqiOKB81lvT1-qIrg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Web based solution offered by Botometer</figcaption></figure><p id="a035" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看来我不得不停止发送垃圾消息和大量关注他人，以使我的 Twitter 账户更像人类:P</p><p id="d424" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">酷！通过<em class="mi"> tweet 的</em> JSON 中的<em class="mi">‘user</em>’对象，我们可以看到更多关于用户的信息，然而，这将留到另一篇文章中。</p><p id="ada4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们制作一个<em class="mi">推文</em>出版物的<strong class="kw iu">时间序列，这样我们就可以看到哪一天关于所选主题的<em class="mi">推文</em>比较多，并尝试找出<strong class="kw iu">哪些事件导致了这些较高的<em class="mi">推文</em>产量</strong>。</strong></p><p id="e8b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将绘制特定月份每天发布的<em class="mi">条推文</em>的数量。要显示与此类似的图，但时间更长，必须添加一些额外的代码。</p><p id="ab4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要修改 dataframe 的“<em class="mi">时间戳</em>字段，使用 Pandas incorporated 函数<em class="mi"> to_datetime </em>将其转换为<strong class="kw iu"> Datetime 对象</strong>。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="43ce" class="mo mp it mk b gy mq mr l ms mt">tweets['Timestamp'] = pd.to_datetime(tweets['Timestamp'], infer_datetime_format = "%d/%m/%Y", utc  = False)</span></pre><p id="f3f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们创建一个返回 DateTime 对象的日期的函数，并将其应用到我们的'<em class="mi"> Timestamp' </em>'字段，为我们的 dataframe 创建一个新列，存储发布<em class="mi"> tweet </em>的日期。此外，我们将把这些天组合在一起，统计每天产生的<em class="mi"> tweets </em>(使用'<em class="mi"> text' </em>字段)的数量，并用结果创建一个字典<strong class="kw iu"> ( <em class="mi"> timedict) </em> </strong>，其中键是对应于一个月中某一天的数字，值是当天发布的<em class="mi"> tweets </em>的数量。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="2419" class="mo mp it mk b gy mq mr l ms mt">def giveday(timestamp):<br/>    day_string = timestamp.day<br/>    return day_string</span><span id="f98c" class="mo mp it mk b gy mu mr l ms mt">tweets['day'] = tweets['Timestamp'].apply(giveday)<br/>days = tweets.groupby('day')<br/>daycount = days['text'].count()<br/>timedict = daycount.to_dict()</span></pre><p id="a4b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">做完这些，我们就可以准备好<strong class="kw iu">绘制我们的结果了！</strong></p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="d2e1" class="mo mp it mk b gy mq mr l ms mt">fig = plt.figure(figsize = (15,15))<br/>plt.plot(list(timedict.keys()), list(timedict.values()))<br/>plt.xlabel('Day of the month', fontsize = 12)<br/>plt.ylabel('Nº of Tweets', fontsize=12)<br/>plt.xticks(list(timedict.keys()), fontsize=15, rotation=90)<br/>plt.title('Number of tweets on each day of the month', fontsize = 20)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/1dc39cd444c477a475d4631eba00d370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrSBrAM6Q0QCK11qYpLsiA.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Time Series of 2 days tweet collection for the #Brexit (Left) and for a whole month on the #Oscars (right)</figcaption></figure><p id="bef1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果像我一样，你只收集了几天的推文，你会得到一个很短的时间序列，就像左边的图片。然而，右边的一个显示了从关于<strong class="kw iu"><em class="mi"/></strong>奥斯卡的<em class="mi">推文</em>的数据集制作的<strong class="kw iu">整月时间序列</strong>，这是通过查询一个多月推文的流媒体 API 构建的。在这第二个时间序列中，我们可以看到在月初很少有<em class="mi">推文</em>被生成<em class="mi"> </em>，随着仪式日期的临近<em class="mi">推文</em>的生成开始上升，在活动当晚达到顶峰。</p><p id="84cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">厉害！现在，我们将绘制一个关于从产生<em class="mi">推文</em>的<strong class="kw iu">设备的图。</strong></p><p id="e064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于该代码与前面的条形图所使用的代码非常相似，所以我将在这里发布它，不做进一步的解释:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f65f" class="mo mp it mk b gy mq mr l ms mt">#Now lets explore the different devices where the tweets are #produced from and plot these results</span><span id="0d27" class="mo mp it mk b gy mu mr l ms mt">devices = tweets.groupby('device')<br/>devicecount = devices['text'].count()</span><span id="3fdf" class="mo mp it mk b gy mu mr l ms mt">#Same procedure as the for the mentions, hashtags, etc..<br/>device_dict = devicecount.to_dict()<br/>device_ordered_list =sorted(device_dict.items(), key=lambda x:x[1])<br/>device_ordered_list = device_ordered_list[::-1]</span><span id="86a8" class="mo mp it mk b gy mu mr l ms mt">device_dict_values = []<br/>device_dict_keys = []<br/>for item in device_ordered_list:<br/>    device_dict_keys.append(item[0])<br/>    device_dict_values.append(item[1])</span></pre><p id="6617" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们绘图，看看结果:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="b3dd" class="mo mp it mk b gy mq mr l ms mt">fig = plt.figure(figsize = (12,12))<br/>index = np.arange(len(device_dict_keys))<br/>plt.bar(index, device_dict_values, edgecolor = 'black', linewidth=1)<br/>plt.xlabel('Devices', fontsize = 15)<br/>plt.ylabel('Nº tweets from device', fontsize=15)<br/>plt.xticks(index, list(device_dict_keys), fontsize=12, rotation=90)<br/>plt.title('Number of tweets from different devices', fontsize = 20)<br/><br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ee4c24862d9e69c4ac2299d86af76442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iY_U5v8BK6elsustJJPDtg.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Plot of tweet production from different devices</figcaption></figure><p id="4bf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过查看这张图表，我们可以看到大多数推文是由智能手机发布的，在这一类别中，Android 设备以微弱优势击败了 Iphones。</p><p id="f384" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">网络产生的推文也可能来自移动设备，但产生于浏览器，而不是 Twitter 应用程序。除了这些网络发布的推文(我们无法判断它们是来自 PC、Mac 还是移动网络浏览器)，很少有推文来自公认的 Mac 或 Windows 设备。这些结果非常符合社交网络的<strong class="kw iu">轻松随和的本质。</strong></p><p id="d402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们看看一些可以从收集的数据中容易获得的额外信息</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="a2ef" class="mo mp it mk b gy mq mr l ms mt">#Lets see other useful information that can be gathered:</span><span id="9cd4" class="mo mp it mk b gy mu mr l ms mt">#MEAN LENGTH OF THE TWEETS<br/>print("The mean length of the tweets is:", np.mean(tweets['length']))</span><span id="5b63" class="mo mp it mk b gy mu mr l ms mt">#TWEETS WITH AN URL<br/>url_tweets = tweets[tweets['text'].str.contains("http")]<br/>print(f"The percentage of tweets with Urls is {round(len(url_tweets)/len(tweets)*100)}% of all the tweets")</span><span id="6e10" class="mo mp it mk b gy mu mr l ms mt">#MEAN TWEETS PER USER<br/>print("Number of tweets per user:", len(tweets)/tweets['Username'].nunique())</span></pre><p id="46e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说，这是平均长度为的<strong class="kw iu">145 条推文，<strong class="kw iu">23%的推文有 URL</strong>，平均每个用户的推文产量为<strong class="kw iu">2.23 条推文</strong>。</strong></p><p id="e3f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！你可以在这里 找到这篇文章和上一篇文章<a class="ae mv" href="https://github.com/jaimezorno/Twitter_Medium" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">使用的 Jupyter 笔记本，以及我关于 Twitter 数据收集的其他文章的脚本和笔记本。</strong></a></p><p id="e061" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有，更多关于自然语言处理和机器学习的牛逼资源，可以看看这个牛逼的博客:<a class="ae mv" href="https://howtolearnmachinelearning.com/books/machine-learning-books/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">如何学习机器学习</strong> </a>。</p><p id="ca93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常感谢你的阅读，请鼓掌，继续发微博，再见！</p></div></div>    
</body>
</html>