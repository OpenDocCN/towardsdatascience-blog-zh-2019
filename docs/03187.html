<html>
<head>
<title>Converting a Simple Deep Learning Model from PyTorch to TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将简单的深度学习模型从 PyTorch 转换为 TensorFlow</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/converting-a-simple-deep-learning-model-from-pytorch-to-tensorflow-b6b353351f5d?source=collection_archive---------3-----------------------#2019-05-22">https://towardsdatascience.com/converting-a-simple-deep-learning-model-from-pytorch-to-tensorflow-b6b353351f5d?source=collection_archive---------3-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8877d9a0ec989904c6a990a19ca8e595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fA77_mLNiJTSgZFhYnU0Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Reference: <a class="ae kf" rel="noopener" target="_blank" href="/applied-deep-learning-part-1-artificial-neural-networks-d7834f67a4f6">https://towardsdatascience.com/applied-deep-learning-part-1-artificial-neural-networks-d7834f67a4f6</a></figcaption></figure><p id="fa05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">简介</strong></p><p id="18fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TensorFlow 和 PyTorch 是两个比较流行的深度学习框架。有些人更喜欢 TensorFlow 以获得部署方面的支持，有些人更喜欢 PyTorch，因为它在模型构建和培训方面具有灵活性，而没有使用 TensorFlow 所面临的困难。使用 PyTorch 的缺点是，使用该框架构建和训练的模型不能部署到生产中。(2019 年 12 月更新:据称 PyTorch 的后续版本对部署有更好的支持，但我相信这是有待探索的其他事情。)为了解决部署使用 PyTorch 构建的模型的问题，一种解决方案是使用 ONNX(开放式神经网络交换)。</p><p id="7d64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如 ONNX 的<a class="ae kf" href="https://onnx.ai/about" rel="noopener ugc nofollow" target="_blank">关于第</a>页所解释的，ONNX 就像一座桥梁，将各种深度学习框架连接在一起。为此，ONNX 工具支持模型从一个框架到另一个框架的转换。到撰写本文时为止，ONNX 仅限于更简单的模型结构，但以后可能会有进一步的补充。本文将说明如何将一个简单的深度学习模型从 PyTorch 转换为 TensorFlow。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="6b48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">安装必要的软件包</strong></p><p id="29d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要安装 PyTorch、TensorFlow、ONNX 和 ONNX-TF(将 ONNX 模型转换为 TensorFlow 的包)。如果在 Linux 中使用<em class="ll"> virtualenv </em>，你可以运行下面的命令(如果你安装了 NVidia CUDA，用<em class="ll"> tensorflow-gpu </em>替换<em class="ll"> tensorflow </em>)。请注意，截至 2019 年 12 月，ONNX 尚不支持 TensorFlow 2.0，因此请注意您安装的 TensorFlow 版本。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d915" class="lv lw it lr b gy lx ly l lz ma">source &lt;your virtual environment&gt;/bin/activate<br/>pip install tensorflow==1.15.0</span><span id="89f6" class="lv lw it lr b gy mb ly l lz ma"># For PyTorch, choose one of the following (refer to <a class="ae kf" href="https://pytorch.org/get-started/locally/" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/get-started/locally/</a> for further details)<br/>pip install torch torchvision # if using CUDA 10.1<br/>pip install torch==1.3.1+cu92 torchvision==0.4.2+cu92 -f <a class="ae kf" href="https://download.pytorch.org/whl/torch_stable.html" rel="noopener ugc nofollow" target="_blank">https://download.pytorch.org/whl/torch_stable.html</a> # if using CUDA 9.2<br/>pip install torch==1.3.1+cpu torchvision==0.4.2+cpu -f <a class="ae kf" href="https://download.pytorch.org/whl/torch_stable.html" rel="noopener ugc nofollow" target="_blank">https://download.pytorch.org/whl/torch_stable.html</a> # if using CPU only</span><span id="0ece" class="lv lw it lr b gy mb ly l lz ma">pip install onnx</span><span id="cc0b" class="lv lw it lr b gy mb ly l lz ma"># For onnx-tensorflow, you may want to refer to the installation guide here: <a class="ae kf" href="https://github.com/onnx/onnx-tensorflow" rel="noopener ugc nofollow" target="_blank">https://github.com/onnx/onnx-tensorflow</a><br/>git clone <a class="ae kf" href="https://github.com/onnx/onnx-tensorflow.git" rel="noopener ugc nofollow" target="_blank">https://github.com/onnx/onnx-tensorflow.git</a><br/>cd onnx-tensorflow<br/>pip install -e .<!-- -->.</span></pre><p id="c8b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果使用 Conda，您可能希望改为运行以下命令:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="56c4" class="lv lw it lr b gy lx ly l lz ma">conda activte &lt;your virtual environment&gt;<br/>conda install -c pytorch pytorch</span><span id="9e86" class="lv lw it lr b gy mb ly l lz ma">pip install tensorflow==1.15.0</span><span id="a328" class="lv lw it lr b gy mb ly l lz ma">pip install onnx</span><span id="d149" class="lv lw it lr b gy mb ly l lz ma"># For onnx-tensorflow, you may want to refer to the installation guide here: <a class="ae kf" href="https://github.com/onnx/onnx-tensorflow" rel="noopener ugc nofollow" target="_blank">https://github.com/onnx/onnx-tensorflow</a><br/>git clone <a class="ae kf" href="https://github.com/onnx/onnx-tensorflow.git" rel="noopener ugc nofollow" target="_blank">https://github.com/onnx/onnx-tensorflow.git</a><br/>cd onnx-tensorflow<br/>pip install -e .<!-- -->.</span></pre><p id="3534" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现使用 pip 安装 TensorFlow、ONNX 和 ONNX-TF 将确保这些包相互兼容。但是，也可以使用其他方式安装软件包，只要它们能在您的机器上正常工作。</p><p id="6de8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要测试软件包是否已正确安装，可以运行以下命令:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d870" class="lv lw it lr b gy lx ly l lz ma">python<br/>import tensorflow as tf<br/>import torch<br/>import onnx<br/>from onnx_tf.backend import prepare</span></pre><p id="9864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您没有看到任何错误消息，这意味着软件包安装正确，我们可以开始了。</p><p id="5d42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我使用了 Jupyter Notebook，但是转换也可以在. py 文件中完成。要安装 Jupyter Notebook，您可以运行以下命令之一:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="95f9" class="lv lw it lr b gy lx ly l lz ma"># Installing Jupyter Notebook via pip<br/>pip install notebook</span><span id="5d20" class="lv lw it lr b gy mb ly l lz ma"># Installing Jupyter Notebook via Conda<br/>conda install notebook</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="f5ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">构建、培训和评估示例模型</strong></p><p id="8a22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来要做的是在 PyTorch 中获得一个可用于转换的模型。在这个例子中，我生成了一些模拟数据，并使用这些数据来训练和评估一个简单的多层感知器(MLP)模型。下面的代码片段展示了如何导入已安装的包，以及如何生成和准备数据。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我为简单的 MLP 模型创建了一个类，并定义了层，这样我们就可以指定任意数量和大小的隐藏层。我还定义了一个二进制交叉熵损失和 Adam 优化器，用于计算训练期间的损失和权重更新。下面的代码片段展示了这个过程。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="a306" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构建模型并定义损失和优化器之后，我使用生成的训练集对模型进行了 20 个时期的训练，然后使用测试集进行评估。模型的测试损失和准确性不好，但这在这里并不重要，因为这里的主要目的是展示如何将 PyTorch 模型转换为 TensorFlow。下面的片段显示了培训和评估过程。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="361c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在训练和评估模型之后，我们需要保存模型，如下所示:</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="20be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">将模型转换为张量流</strong></p><p id="0e43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们需要转换<em class="ll">。pt </em>文件到了一个<em class="ll">。onnx </em>文件使用<em class="ll"> torch.onnx.export </em>函数。这里我们需要注意两件事:1)我们需要定义一个虚拟输入作为导出函数的输入之一，2)虚拟输入需要具有形状(1，单个输入的维度)。例如，如果单个输入是具有形状(通道数、高度、宽度)的图像数组，那么伪输入需要具有形状(1，通道数、高度、宽度)。需要虚拟输入作为所得张量流模型的输入占位符)。下面的代码片段显示了以 ONNX 格式导出 PyTorch 模型的过程。我还将输入和输出名称作为参数，以便在 TensorFlow 中更容易进行推理。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拿到<em class="ll">后。onnx </em>文件，我们需要使用 onnx-TF 的<em class="ll">后端</em>模块中的<em class="ll"> prepare() </em>函数将模型从 ONNX 转换为 TensorFlow。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="01df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">在 TensorFlow 中做推理</strong></p><p id="fb5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的部分来了，这是为了看看合成的张量流模型是否能按预期进行推理。从<em class="ll">加载张量流模型。pb </em>文件可以通过定义以下函数来完成。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5ac7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义了加载模型的函数后，我们需要启动一个 TensorFlow graph 会话，为输入和输出指定占位符，并将输入输入到会话中。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6414" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码片段的输出如下所示。占位符的名称对应于在<code class="fe me mf mg lr b">torch.onnx.export</code>功能中指定的名称(用粗体表示)。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4c9b" class="lv lw it lr b gy lx ly l lz ma">(&lt;tf.Tensor 'Const:0' shape=(50,) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Const_1:0' shape=(50, 20) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Const_2:0' shape=(50,) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Const_3:0' shape=(50, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Const_4:0' shape=(1,) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Const_5:0' shape=(1, 50) dtype=float32&gt;,)<br/>(<strong class="lr iu">&lt;tf.Tensor 'input:0' shape=(1, 20) dtype=float32&gt;,)</strong><br/>(&lt;tf.Tensor 'flatten/Reshape/shape:0' shape=(2,) dtype=int32&gt;,)<br/>(&lt;tf.Tensor 'flatten/Reshape:0' shape=(1, 20) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'transpose/perm:0' shape=(2,) dtype=int32&gt;,)<br/>(&lt;tf.Tensor 'transpose:0' shape=(20, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'MatMul:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul/x:0' shape=() dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_1/x:0' shape=() dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_1:0' shape=(50,) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'add:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Relu:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'flatten_1/Reshape/shape:0' shape=(2,) dtype=int32&gt;,)<br/>(&lt;tf.Tensor 'flatten_1/Reshape:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'transpose_1/perm:0' shape=(2,) dtype=int32&gt;,)<br/>(&lt;tf.Tensor 'transpose_1:0' shape=(50, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'MatMul_1:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_2/x:0' shape=() dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_2:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_3/x:0' shape=() dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_3:0' shape=(50,) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'add_1:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'Relu_1:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'flatten_2/Reshape/shape:0' shape=(2,) dtype=int32&gt;,)<br/>(&lt;tf.Tensor 'flatten_2/Reshape:0' shape=(1, 50) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'transpose_2/perm:0' shape=(2,) dtype=int32&gt;,)<br/>(&lt;tf.Tensor 'transpose_2:0' shape=(50, 1) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'MatMul_2:0' shape=(1, 1) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_4/x:0' shape=() dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_4:0' shape=(1, 1) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_5/x:0' shape=() dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'mul_5:0' shape=(1,) dtype=float32&gt;,)<br/>(&lt;tf.Tensor 'add_2:0' shape=(1, 1) dtype=float32&gt;,)<br/><strong class="lr iu">(&lt;tf.Tensor 'output:0' shape=(1, 1) dtype=float32&gt;,)</strong></span></pre><p id="c994" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切顺利，<em class="ll"> print(output) </em>的结果应该与前面步骤中的<em class="ll"> print(dummy_output) </em>的结果相匹配。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="9b54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">结论</strong></p><p id="700c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ONNX 可以非常简单，只要你的模型不太复杂。这个例子中的步骤将对具有单个输入和输出的深度学习模型起作用。对于具有多个输入和/或输出的模型，通过 ONNX 进行转换更具挑战性。因此，转换多个输入/输出模型的示例必须在另一篇文章中完成，除非以后有新版本的 ONNX 可以处理这样的模型。</p><p id="8d16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">包含所有代码的 Jupyter 笔记本可以在这里找到。</p></div></div>    
</body>
</html>