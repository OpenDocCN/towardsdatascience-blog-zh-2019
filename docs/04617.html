<html>
<head>
<title>Modeling customer churn for an e-commerce company with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 为一家电子商务公司建模客户流失</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modeling-customer-churn-for-an-e-commerce-business-with-python-874315e688bf?source=collection_archive---------5-----------------------#2019-07-15">https://towardsdatascience.com/modeling-customer-churn-for-an-e-commerce-business-with-python-874315e688bf?source=collection_archive---------5-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b0ad836253fe0a025f421a109976121c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a5W0YLpv0wyVeDUElHHb4A.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by mohamad_hassan on Pixabay</figcaption></figure><div class=""/><div class=""><h2 id="662f" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">如何使用寿命包来预测非合同流失风险</h2></div></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><p id="1344" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">留住现有客户比获得新客户更具成本效益，这就是为什么跟踪高流失风险(流失)的客户并针对他们制定保留策略非常重要。</p><p id="58ea" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在这个项目中，我将基于巴西电子商务网站 Olist 的数据建立一个客户流失模型。我会用它来识别高风险客户，并告知保留策略和营销实验。</p><p id="968e" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">电子商务有一个复杂之处。虽然衡量合同业务(基于订阅的业务)的客户流失很简单，但在非合同业务(电子商务)中却看不到客户流失。在这些情况下，概率模型在估计客户死亡时间时会派上用场。我将使用的概率模型是寿命包中的 BG/NBD 模型。</p><h1 id="117e" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi translated">加载数据</h1><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7a5b" class="nb mb ji mx b gy nc nd l ne nf">import pandas as pd<br/>import numpy as np<br/>import datetime as dt<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt</span><span id="0761" class="nb mb ji mx b gy ng nd l ne nf">from lifetimes.utils import *<br/>from lifetimes import BetaGeoFitter,GammaGammaFitter<br/>from lifetimes.plotting import plot_probability_alive_matrix, plot_frequency_recency_matrix, plot_period_transactions, plot_cumulative_transactions,plot_incremental_transactions<br/>from lifetimes.generate_data import beta_geometric_nbd_model<br/>from lifetimes.plotting import plot_calibration_purchases_vs_holdout_purchases, plot_period_transactions,plot_history_alive</span><span id="30e9" class="nb mb ji mx b gy ng nd l ne nf">orders = pd.read_csv(‘brazilian-ecommerce/olist_orders_dataset.csv’)<br/>items = pd.read_csv(‘brazilian-ecommerce/olist_order_items_dataset.csv’)<br/>cust = pd.read_csv(‘brazilian-ecommerce/olist_customers_dataset.csv’)</span></pre><p id="9717" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">生命周期包依赖于最近频率货币(RFM)分析来模拟客户流失和客户生命周期价值(CLV)。为了制作我们的模型，我们需要一个由最近、频率和货币列组成的数据框架。每个的定义如下。</p><ul class=""><li id="bffe" class="nh ni ji lg b lh li lk ll ln nj lr nk lv nl lz nm nn no np bi translated">最近:初次购买和最近(最后一次)购买之间的时间</li><li id="a138" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">频率:客户重复购买的次数(总购买次数— 1)</li><li id="e549" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">货币:购买的总支出</li></ul><p id="5276" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">客户 ID 信息将来自<code class="fe nv nw nx mx b">cust</code>。订单日期将从<code class="fe nv nw nx mx b">orders</code>开始。价格将来自<code class="fe nv nw nx mx b">items</code>。</p><h1 id="146c" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi translated">构建数据集</h1><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="11b5" class="nb mb ji mx b gy nc nd l ne nf">print(cust.columns)</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/9cca4d2360eca1147c60e8bc37a5e96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jahFXxSCAyXFQ-k-HhkXjg.png"/></div></div></figure><p id="6126" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">有两列用于标识客户。<code class="fe nv nw nx mx b">customer_id</code>是为每个订单生成的客户 ID 令牌。如果同一个客户下了多个订单，他就有多个 customer_id 标识符。我们希望在这个分析中使用的是<code class="fe nv nw nx mx b">customer_unique_id</code>，它对每个购买者都是唯一的，可以用来跟踪他们一段时间内的购买情况。</p><p id="23a5" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这是顾客购物的分布情况。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="055b" class="nb mb ji mx b gy nc nd l ne nf">cust.groupby('customer_unique_id').size().value_counts()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/f796af5a8b4597c1537be8bda6ad95b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dW42Z9lSfHoIG00uCZltMg.png"/></div></div></figure><p id="747f" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">大多数顾客只进行了一次购买。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="743c" class="nb mb ji mx b gy nc nd l ne nf">orders = pd.merge(orders,cust[['customer_id','customer_unique_id']],on='customer_id')<br/>orders.columns</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/3e165cdab3ec8cd5b65f30c2a4b9282e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8h3IEttqPbaCI1Giqadpmg.png"/></div></div></figure><p id="52bd" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在<code class="fe nv nw nx mx b">items</code>数据集中，订单中的每一项都有单独的一行。<code class="fe nv nw nx mx b">price</code>栏指的是累计订单购买量，而不是单项价格。因为我只需要订单价格，所以我会保留每个订单的第一个项目。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1639" class="nb mb ji mx b gy nc nd l ne nf">print(items.columns)</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/0fb05b0f2d650b0837748cd30cf43d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUYOkxzSx5sprnOB0h4vDg.png"/></div></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8724" class="nb mb ji mx b gy nc nd l ne nf">items.drop_duplicates('order_id',keep='first',inplace=True)</span></pre><p id="6ce3" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">接下来，我将把订单与商品连接起来，以附加价格信息。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5968" class="nb mb ji mx b gy nc nd l ne nf">transaction_data = pd.merge(orders,items,'inner','order_id')<br/>transaction_data = transaction_data[['customer_unique_id','order_purchase_timestamp','price']]</span><span id="4651" class="nb mb ji mx b gy ng nd l ne nf">## convert timestamp to date; only need the day<br/>transaction_data['date'] = pd.to_datetime(transaction_data['order_purchase_timestamp']).dt.date<br/>transaction_data = transaction_data.drop('order_purchase_timestamp',axis=1)<br/>transaction_data.head()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/33ff079017ab2564e2f781f27e67dc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaoZ0WrfL5HqBU_tBIYKMQ.png"/></div></div></figure><p id="9b3c" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在我有了交易数据，我想用我在引言中提到的 RFM 变量将它转换成数据帧。生存期包具有将事务数据转换为 RFM 数据帧的功能。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4436" class="nb mb ji mx b gy nc nd l ne nf">summary = summary_data_from_transaction_data(transaction_data,'customer_unique_id','date',monetary_value_col='price',)<br/>summary.describe()</span></pre><h1 id="bfd8" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi translated">了解 RFM 数据框架</h1><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8bab" class="nb mb ji mx b gy nc nd l ne nf">summary.head()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/b3d593d7de2b0ea4cc35b8126c2ca4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKyW6l4TE1niMiq8bHpxCA.png"/></div></div></figure><p id="a109" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">summary 函数将客户交易转换为汇总表。许多客户的频率、新近度和货币= 0，如客户<code class="fe nv nw nx mx b">0000366f3b9a7992bf8c76cfdf3221e2</code>。这是因为 Lifetimes 只考虑重复购买的顾客。</p><p id="81ab" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">使用天数作为时间段(也可以定义为周或月)，生命周期模型的变量定义如下:</p><ul class=""><li id="d233" class="nh ni ji lg b lh li lk ll ln nj lr nk lv nl lz nm nn no np bi translated"><code class="fe nv nw nx mx b">frequency</code>:客户重复购买的天数</li><li id="88cd" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated"><code class="fe nv nw nx mx b">T</code>:客户年龄天数</li><li id="7926" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated"><code class="fe nv nw nx mx b">recency</code>:客户最近一次购买时的年龄(天数)</li><li id="a6cd" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated"><code class="fe nv nw nx mx b">monetary_value</code>:客户购买的平均值，不包括第一次购买</li></ul><p id="8422" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe nv nw nx mx b">frequency</code>不包括客户的第一次购买，因为那是客户出生的那一天。之后，你可以开始质疑那个客户是否还活着。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ef9e" class="nb mb ji mx b gy nc nd l ne nf">summary[summary['frequency']&gt;0].head()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/0d6e384e8907994ad8b834c96a013414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPkOVLbeWP8jkX3R8W3TJQ.png"/></div></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2246" class="nb mb ji mx b gy nc nd l ne nf">transaction_data[transaction_data['customer_unique_id']=='004288347e5e88a27ded2bb23747066c']</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/3e2b83b3a9c39f2ebff752cbdb864f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*my5jl9AEroMKm2581NpIvQ.png"/></div></div></figure><p id="9c83" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">请注意客户<code class="fe nv nw nx mx b">004288347e5e88a27ded2bb23747066c</code>如何使用 Olist 进行了两次购买，但是根据频率和货币值的定义，他的<code class="fe nv nw nx mx b">frequency</code>是 1 而<code class="fe nv nw nx mx b">monetary_value</code>是 87.90 美元。</p><h1 id="c760" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi translated">可视化 RFM 数据框架</h1><p id="3f21" class="pw-post-body-paragraph le lf ji lg b lh of kj lj lk og km lm ln oh lp lq lr oi lt lu lv oj lx ly lz im bi translated">我们将使用贝塔几何/NBD (BG/NBD)模型来分析客户流失。BG/NBD 模型是对帕累托/NBD 模型的改编。两个模型都描述了顾客流动不明显的企业中的重复购买模式；然而，BG/NBD 在计算上更加可行。</p><p id="daf6" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">BG/NBD 模型的假设:</p><ul class=""><li id="bca1" class="nh ni ji lg b lh li lk ll ln nj lr nk lv nl lz nm nn no np bi translated">客户关系有两个阶段:“存活”一段时间，然后“死亡”</li><li id="5e0f" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">在活动期间，客户进行的交易数量遵循交易速率为λ的泊松分布</li><li id="fe8f" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">λ的不均匀性遵循伽马分布</li><li id="52d3" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">在任何交易之后，客户以概率 p 死亡；客户在多次交易后死亡的概率服从几何分布</li><li id="528d" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">p 服从贝塔分布</li><li id="193d" class="nh ni ji lg b lh nq lk nr ln ns lr nt lv nu lz nm nn no np bi translated">λ和 p 因客户而异</li></ul><p id="6441" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">有关 BG/NBD 模型的更多信息，请查看彼得·法德尔的这篇<a class="ae ok" href="http://brucehardie.com/papers/bgnbd_2004-04-20.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>和卡姆·戴维森-皮隆的这篇<a class="ae ok" href="https://medium.com/data-shopify/how-shopify-merchants-can-measure-retention-c12284bfed6f" rel="noopener">帖子</a>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fea8" class="nb mb ji mx b gy nc nd l ne nf">bgf = BetaGeoFitter(penalizer_coef=0.0)<br/>bgf.fit(summary['frequency'], summary['recency'], summary['T']);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/295beb67a0e1be4f688aa4d29e93b281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIVhfIaB0oLDNvtGc8ChdA.png"/></div></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5301" class="nb mb ji mx b gy nc nd l ne nf">plot_frequency_recency_matrix(bgf);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/5f903d65e49db721110bcf7f844a98e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qcy30XuPI64gijFA3B5cw.png"/></div></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7e7f" class="nb mb ji mx b gy nc nd l ne nf">plot_probability_alive_matrix(bgf);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/5ad73c464ceed244389837b31ad9eb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuuotfARUyYeWZK6Dl30rA.png"/></div></div></figure><h1 id="f349" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi translated">训练模型并评估模型性能</h1><p id="40f0" class="pw-post-body-paragraph le lf ji lg b lh of kj lj lk og km lm ln oh lp lq lr oi lt lu lv oj lx ly lz im bi translated">接下来，我们要评估该模型，看看它在未来的表现如何。我会将数据分为训练(校准)期和维持(观察)期，训练 BG/NBD 模型，并使用 Peter Fader 在本次演讲<a class="ae ok" href="https://www.youtube.com/watch?v=guj2gVEEx4s" rel="noopener ugc nofollow" target="_blank">(@ 26:10)中概述的四幅图来评估性能。这些地块是:</a></p><p id="919c" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jj"> 1)校准周期直方图</strong>:模型是否符合训练数据？</p><p id="574a" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jj"> 2)累计成交图</strong>:模型对累计销售额的预测效果好吗？</p><p id="4569" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jj"> 3)增量交易图</strong>:模型是否捕捉到了交易的整体趋势？</p><p id="38fb" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jj"> 4)条件期望图</strong>:模型能否根据训练数据预测客户的购买数量？</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h2 id="ead3" class="nb mb ji bd mc oo op dn mg oq or dp mk ln os ot mm lr ou ov mo lv ow ox mq oy bi translated">1)校准周期直方图</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0a86" class="nb mb ji mx b gy nc nd l ne nf">plot_period_transactions(bgf).set_yscale('log');</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/9232937b6d59a2856c6c3df25fa0c1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFJM3BcwgQMz55lU_TEEcg.png"/></div></div></figure><p id="5840" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">该模型相当好地代表了直到四次重复交易的真实数据。很少有顾客购买更多的东西。</p><h2 id="fcab" class="nb mb ji bd mc oo op dn mg oq or dp mk ln os ot mm lr ou ov mo lv ow ox mq oy bi translated">2)累积交易图</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="464c" class="nb mb ji mx b gy nc nd l ne nf">summary_cal_holdout = calibration_and_holdout_data(transaction_data, 'customer_unique_id', 'date',calibration_period_end='2017-09-03', observation_period_end='2018-09-03' )</span></pre><p id="16a7" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们可以通过绘制两者来评估数据集的工作方式。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="75fd" class="nb mb ji mx b gy nc nd l ne nf">bgf.fit(summary_cal_holdout['frequency_cal'], summary_cal_holdout['recency_cal'], summary_cal_holdout['T_cal'])</span><span id="e7c3" class="nb mb ji mx b gy ng nd l ne nf">plot_cumulative_transactions(bgf, transaction_data, 'date', 'customer_unique_id', 730, 365);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/9319b6cd4eb55c46d9a3580b69b8ea77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDaDtJ2EbGQw2VpUlRgiRw.png"/></div></div></figure><p id="ba81" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">红线代表左侧校准周期和右侧维持周期之间的边界。如你所见，BG/NBD 模型在预测累积交易方面做得非常出色。</p><h2 id="93cc" class="nb mb ji bd mc oo op dn mg oq or dp mk ln os ot mm lr ou ov mo lv ow ox mq oy bi translated">3)增量交易图</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="140c" class="nb mb ji mx b gy nc nd l ne nf">plot_incremental_transactions(bgf, transaction_data, 'date', 'customer_unique_id', 730, 365);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/30cf04222bee02f6c93b079d04e9e998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2V-Ur3irnALPsufRrlxAg.png"/></div></div></figure><p id="d776" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">该图表明，该模型在捕捉数据的总体趋势方面做得不错。</p><h2 id="c8ee" class="nb mb ji bd mc oo op dn mg oq or dp mk ln os ot mm lr ou ov mo lv ow ox mq oy bi translated">4)条件期望图</h2><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0d0e" class="nb mb ji mx b gy nc nd l ne nf">plot_calibration_purchases_vs_holdout_purchases(bgf, summary_cal_holdout);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/98b2ef4c3e58fcf7487129453e92b355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2gAcpurcSK4P3-S3yen_w.png"/></div></div></figure><p id="6521" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">该模型在三个校准周期内性能良好，但由于数据的分布，与维持数据存在偏差。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7596" class="nb mb ji mx b gy nc nd l ne nf">cust.groupby('customer_unique_id').size().value_counts()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/ca34333214008f0ca9e80a9dbfdc08cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*GFtK_o5xB8wtJxzj0Yi2eA.png"/></div></figure><p id="8bc9" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">只有不到 1%的顾客进行了四次或更多的购买，所以 BG/NBD 模型没有太多的数据来了解那些进行了多次重复交易的顾客。</p><p id="22eb" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">实际上，如果我要继续对客户流失建模，我会考虑收集更多的数据。但是出于学习的目的，预测客户流失仍然是一个很好的练习。</p><h1 id="13f6" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi translated">客户流失风险建模</h1><p id="2ad2" class="pw-post-body-paragraph le lf ji lg b lh of kj lj lk og km lm ln oh lp lq lr oi lt lu lv oj lx ly lz im bi translated">BG/NBD 模型假设只有在重复购买后才会发生死亡，因为顾客在购买过程中离开，而第一次购买被保留下来以表示顾客的出生。</p><p id="2896" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">正因为如此，只有一笔交易的客户，会有 100%的概率是活着的，这是值得怀疑的。考虑到这一限制，我们将只预测至少进行过一次重复交易的客户的流失风险。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="3189" class="nb mb ji mx b gy nc nd l ne nf">df = summary[summary['frequency']&gt;0]<br/>df['prob_alive'] = bgf.conditional_probability_alive(df['frequency'],df['recency'],df['T'])<br/>sns.distplot(df['prob_alive']);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/971539adf58fcc4615abf29ec8316ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fugaM7M4reXN0Aap7tJKg.png"/></div></div></figure><p id="5eb4" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">从这里，我们可以根据客户“活着”的概率来可视化他们。利用领域知识，我们也许能够为可能已经流失的客户设定一个阈值，并且还能识别出处于流失风险中但尚未消失的客户。</p><p id="77a1" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">接下来，我想为客户流失设定一个决策阈值。这是一个注入个人专业知识或与领域专家交流的机会。假设我与销售和营销经理交谈，我们同意考虑一位客户，感谢他阅读！如果你想跟着代码走，这里有<a class="ae ok" href="https://github.com/collindching/Olist-Customer-Churn" rel="noopener ugc nofollow" target="_blank"><em class="pe">GitHub repo</em></a><em class="pe">。随时欢迎反馈和问题。下面评论！</em></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4a8f" class="nb mb ji mx b gy nc nd l ne nf">df['churn'] = ['churned' if p &lt; .1 else 'not churned' for p in df['prob_alive']]<br/>sns.countplot(df['churn']);</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/2aa0619002f10c6e2e8dfc8b7fedfc57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orcx-RtciRrIJGpFkR9Ajg.png"/></div></div></figure><p id="c854" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">A little over 92% of customers have churned, meaning that there’s a lot of opportunity for improvement regarding retention.</p><p id="0b9c" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">We can assume that the customers who have churned are already lost. But what is interesting in a business setting is the customers who are at high risk for churn, but haven’t churned yet. Later on, it might still be a good idea to apply different treatments to the churned group.</p><p id="b7ff" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">If I can identify them, maybe I can encourage the marketing team to target them with promotions.</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="95d0" class="nb mb ji mx b gy nc nd l ne nf">sns.distplot(df[df['churn']=='not churned']['prob_alive']).set_title('Probability alive, not churned');</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/1d1bf8224dfe93aeeb979deb61c0da3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXAGK76bNeq4ltIBXJylLA.png"/></div></div></figure><p id="f1a7" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">It seems reasonable to bucket customers with 80% or more churn risk to be considered high risk for churn.</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="08a0" class="nb mb ji mx b gy nc nd l ne nf">df['churn'][(df['prob_alive']&gt;=.1) &amp; (df['prob_alive']&lt;.2)] = "high risk"<br/>df['churn'].value_counts()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/e3234f6c37bf8c01bb4e5c5dfaacd7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*fMXnwdAjL63lpX4JOeO3LA.png"/></div></figure><p id="79fc" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">Now that I have these churn groupings, I can move forward and apply special treatments to these groups. Ideally there would be more data and a bigger population of high-risk customers.</p><h1 id="41fc" class="ma mb ji bd mc md me mf mg mh mi mj mk ko ml kp mm kr mn ks mo ku mp kv mq mr bi">Conclusion</h1><p id="4858" class="pw-post-body-paragraph le lf ji lg b lh of kj lj lk og km lm ln oh lp lq lr oi lt lu lv oj lx ly lz im bi">We’ve modeled churn risk in a non-contractual setting, and now have three customer segments — not churned, high risk, and churned. This could feed into a dashboard to give stakeholders a glimpse of “at-risk” customers. It also provides three different groups that we can run specific actions. Some ideas:</p><p id="5d0e" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">1) Reach out to churned customers to figure out why they left.</p><p id="5f3d" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">2) Send different types of targeted emails and special offers to the high risk group. If the sample size of high risk customers is large enough, you could split off a few small treatment groups and compare how their retention and CLV change with different promotional or customer relationship strategies.</p><p id="abd2" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi">3) Determine the the highest value customers in the non-churn group, and serve them additional benefits to ensure that they remain loyal customers.</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><p id="54ff" class="pw-post-body-paragraph le lf ji lg b lh li kj lj lk ll km lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi"><em class="pe">Thanks for reading! If you want to follow along with the code, here’s the </em><a class="ae ok" href="https://github.com/collindching/Olist-Customer-Churn" rel="noopener ugc nofollow" target="_blank"><em class="pe">GitHub repo</em></a><em class="pe">. Always open to feedback and questions. Comment below!</em></p></div></div>    
</body>
</html>