<html>
<head>
<title>Some More Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再来点饭桶</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/some-more-git-f6d8a1179918?source=collection_archive---------35-----------------------#2019-06-11">https://towardsdatascience.com/some-more-git-f6d8a1179918?source=collection_archive---------35-----------------------#2019-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="549a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看在这篇关于 Git 中分支和合并的文章之前的<a class="ae ki" href="https://medium.com/@shivangisareen/git-basics-ec81696be4e6" rel="noopener"> Git 基础知识</a>文章！</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/6fbab526858410664ca8bc6340830129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1CD-3jMvukthLv2oU4Dqg.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ki" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git 的设计是为了促进同一个项目的并行/多个版本。这个工具叫做分支。分支有效地允许我们将项目带入多个不同的方向，而不是单一的线性进展。它让我们维护一个分支，即“主”分支，它拥有原始版本的代码，然后还有其他分支，允许我们处理原始代码的不同版本，然后，将这些分支合并到原始代码中——合并。</p><p id="c159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有其他人在同一个项目上工作，但是在不同的特性上工作，同时发生但是分开开发时，这个工具特别有用。最后，我们可以将不同的分支(比如代表不同特性的不同分支)合并到主分支中。</p><h2 id="38ab" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">与分支相关的命令:</h2><ul class=""><li id="1839" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">列出当前在我们仓库中的所有分支。带有*和绿色的文本表示这是我们当前所在的分支。</li><li id="b22d" class="mo mp it lb b lc nd lf ne li nf lm ng lq nh lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git branch -a</code>:列出所有远程和本地分支</li><li id="acce" class="mo mp it lb b lc nd lf ne li nf lm ng lq nh lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git branch &lt;branch name&gt;</code>:用该分支名称创建一个新分支</li><li id="4170" class="mo mp it lb b lc nd lf ne li nf lm ng lq nh lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git branch -d &lt;branch name&gt;</code>:删除分支</li><li id="5f24" class="mo mp it lb b lc nd lf ne li nf lm ng lq nh lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git checkout &lt;branch name&gt;</code>:转移到不同的分支机构</li><li id="08aa" class="mo mp it lb b lc nd lf ne li nf lm ng lq nh lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git commit -am "message"</code>:合并了添加和提交步骤——添加我们已经更改的所有行并提交它们。</li></ul><p id="6999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将两个分支合并在一起:转到(<code class="fe mz na nb nc b">git checkout</code>)分支<code class="fe mz na nb nc b">master</code>，然后:<code class="fe mz na nb nc b">git merge &lt;name of branch to be merged with the master branch&gt;</code></p><p id="57c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:所有这些变化都发生在我们的本地计算机上。因此，主机站点只有主分支，而我们在我们的存储库中有一个新的分支——我们刚刚创建的分支。</p><p id="a11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们<strong class="lb iu">将</strong>检出到新的分支，<strong class="lb iu">添加</strong>并<strong class="lb iu">提交</strong>对新分支所做的更改，然后<strong class="lb iu">将</strong>这些更改推送到主机站点，我们会得到一条消息，说明<em class="ni">“当前分支特性没有上游分支”</em>。这是因为我们在主机站点上没有可以推送的新分支—它只有一个主分支。</p><p id="6f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了推送至主机站点上的新分支，我们使用:</p><ul class=""><li id="e083" class="mo mp it lb b lc ld lf lg li nj lm nk lq nl lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git push --set-upstream origin &lt;name of the new branch&gt;</code>，其中 origin 是远程的名称(存储在主机站点上的存储库的版本)。因此，主机站点主分支本质上是，<code class="fe mz na nb nc b">origin/master</code>，而我们的本地主分支就是<code class="fe mz na nb nc b">master</code>分支。</li><li id="dbbf" class="mo mp it lb b lc nd lf ne li nf lm ng lq nh lu mv mw mx my bi translated"><code class="fe mz na nb nc b">git fetch</code>:从源获取提交并下载到本地。因此，我们在本地得到的两个分支是，<code class="fe mz na nb nc b">master</code>和<code class="fe mz na nb nc b">origin/master</code>。</li></ul><p id="bb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们希望我们的主分支反映整体的新变化，基本上，合并我们所在的位置，即<code class="fe mz na nb nc b">master</code>分支与<code class="fe mz na nb nc b">origin/master</code>所在的位置，我们:<code class="fe mz na nb nc b">git merge origin/master</code>。因此，我们的主分支现在反映了 origin 的最新版本。</p><h2 id="24eb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">叉</h2><p id="ef43" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">存储库的分支是该存储库的完全独立的版本，它只是原始版本的副本。分叉一个项目就是重命名它，启动一个新项目，围绕这个想法建立一个社区。</p><h2 id="3295" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">叉还是克隆？</strong></h2><p id="245c" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">当我们分叉一个项目时，我们实际上只是在克隆它。fork 就是选择获取原项目的副本，启动父项目的不同线程。另一方面，贡献者可以选择克隆一个存储库，从而获得一个原始项目的副本来进行工作、修改、添加/删除。在做出他们认为合适的更改后，他们希望这些更改与代码的原始版本合并。为此，他们提交一个拉取请求。这仅仅是一种方式，说明“嘿，我已经做了一些更改，希望有人在将它们合并到代码的原始版本之前对它们进行审核”。这是一个非常有用的功能，可以获得持续的反馈和渐进的修改。</p><blockquote class="np nq nr"><p id="0630" class="kz la ni lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated"><em class="it">捐款时，将项目转入您自己的主机站点帐户是有益的。从那里:将其克隆到您的本地计算机，为您的新代码创建一个本地分支，进行更改，提交，推送，与 master 合并，删除本地分支，最后发送您的 pull 请求以查看您所做的更改是否生效！</em></p></blockquote></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="e13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您抽出时间阅读这篇文章！</p></div></div>    
</body>
</html>