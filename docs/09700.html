<html>
<head>
<title>PID Controller Intro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PID 控制器介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pid-controller-intro-26fda41aaa59?source=collection_archive---------6-----------------------#2019-12-20">https://towardsdatascience.com/pid-controller-intro-26fda41aaa59?source=collection_archive---------6-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">控制自动驾驶汽车沿着路径行驶</h2></div><p id="2896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PID 控制器是一种调节应用程序以平滑地跟随某个值或路径的方法。我在这里第一次学到了这个概念<a class="ae le" href="https://classroom.udacity.com/courses/cs373/lessons/48743150/concepts/487283450923" rel="noopener ugc nofollow" target="_blank"/>，它介绍了如何驾驶汽车沿着特定的路径行驶。虽然一个完整的应用程序解释可能非常复杂，但它以一种超级优雅和简洁的方式总结了背后的数学，并使这一思想可以很容易地扩展到许多现实生活中的问题。在本帖中，让我们跟随关键结构，探索 PID 控制器如何工作。</p><p id="668b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将遵循以下路径:</p><ol class=""><li id="f86d" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="kk iu"> P </strong>:比例</li><li id="5c08" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> PD </strong>:比例微分</li><li id="421b" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> PID </strong>:比例-微分-积分</li></ol><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/db17666aa40fd117f932aff757e13866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43kEzittZsEvRo-wQs-9oQ.jpeg"/></div></div></figure><h1 id="95ee" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">基础设置</h1><p id="670d" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">让我们通过一个问题的实现来学习这个想法。假设我们有一个机器人汽车对象，我们希望汽车能够控制自己沿着一条路径行驶，在这种情况下，这条路径将是一条直线，汽车控制自己的唯一方法是调整它的转向或方向，以便它可以逐渐优雅地接近这条路径，并在到达那里后沿着这条路径行驶。简单地说，问题是:</p><blockquote class="nc nd ne"><p id="e049" class="ki kj nf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">通过改变方向盘来控制自动驾驶汽车沿着直线行驶</p></blockquote><p id="efc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">car 对象的完整实现在这里是<a class="ae le" href="https://github.com/MJeremy2017/Machine-Learning-Models/blob/master/Control/PID.ipynb" rel="noopener ugc nofollow" target="_blank"/>(整个对象的解释在我们的范围后面)。基本上，机器人对象遵循以下结构:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ab14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nl nm nn no b">set</code>功能设置汽车的初始坐标和方向。我们需要知道的是，每次我们都需要给机器人发出<code class="fe nl nm nn no b">steering</code>的指令，这样它就可以调整自己来接近路径。</p><h1 id="94e4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">P</h1><p id="7577" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">p 代表比例。事情是这样的，我们的机器人坐在坐标为<code class="fe nl nm nn no b">(x, y)</code>的二维世界里。假设目标路径是<code class="fe nl nm nn no b">y = 0</code>，那么当前朝向目标的误差是<code class="fe nl nm nn no b">y — 0 = y</code>，基于该误差，我们应该相应地调整汽车的转向。<em class="nf">那么如何调整转向，以便我们可以快速减少误差呢？如果你驾驶的汽车偏离了你的目标路线，你会怎么办？</em></p><p id="aed1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个直接的方法是根据误差按比例调整转向，这意味着你离目标越远，你驾驶汽车的角度就越大。考虑到这一点，我们有了第一个解决方案:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5f96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe nl nm nn no b">n</code>步骤中调整汽车，在每一步中，我们根据误差<code class="fe nl nm nn no b">robot.y</code>成比例地驾驶汽车:</p><pre class="lu lv lw lx gt np no nq nr aw ns bi"><span id="70b1" class="nt mg it no b gy nu nv l nw nx">steering = -tau*robot.y</span></pre><p id="957a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe nl nm nn no b">tau</code>是我们分配给误差的权重。(注:汽车以<code class="fe nl nm nn no b">speed = 1</code>移动，由于时间戳为 1，所以<code class="fe nl nm nn no b">distance = speed * 1 = speed</code></p><p id="d8dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们画出汽车的轨迹:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0a5216dd7f03678692141c818787f0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*cfTVkMgruHwiMjPZwcbQhA.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">P Control</figcaption></figure><p id="010d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们设定我们的机器人从<code class="fe nl nm nn no b">(0, 1)</code>开始水平前进。轨迹在目标路径外振荡。看起来我们的转向太过激烈，以至于赛车超过了我们的目标，当它试图转向时，又超过了目标。显然坐在这样的车里会很头疼。<em class="nf">那么，我们可以在接近目标时减小转向角吗？</em></p><h1 id="32d2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">帕金森氏症</h1><p id="f0eb" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">问题引出 PD 控制，其中 D 代表导数。这个想法是，随着误差的减少，我们的汽车应该反向转向，以避免超调，而不是不断转向，导致振荡。</p><p id="3a29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该在控制过程中添加的新项是<code class="fe nl nm nn no b">δy/δt</code>，其中<code class="fe nl nm nn no b">δt</code>为 1，因此<code class="fe nl nm nn no b">δy = current_y — last_y</code>。实施将是:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6054" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的导数项是<code class="fe nl nm nn no b">dev = robot.y — prev_cte</code>，<code class="fe nl nm nn no b">tau_d</code>是它的权重。结果轨迹如下所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi od"><img src="../Images/c2f6a747b66b016743dea6190e497c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*oBYzZBZ32a40qMrJL08FNA.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">PD Control</figcaption></figure><p id="d487" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来很完美！现在一切看起来都很好，但实际上这个模型并不稳健。我的意思是<em class="nf">如果存在固有的系统缺陷怎么办？如果你的车轮在开始时有一点小故障，总是转移到另一个方向，PD 能够克服这一点吗？</em></p><p id="97f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">答案是否定的。让我们举个例子:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="656f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们<code class="fe nl nm nn no b">set_steering_drift</code>给汽车的方向添加了一些噪声，结果变成了:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi od"><img src="../Images/a9c755157800a172a126eea8c5bfe60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*NWtkIbLzUamOJhZpLRKAeQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">PD Noise</figcaption></figure><p id="e896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它远离我们的目标路径振荡。原因是，虽然我们的车正在转向目标，但它不能抵消固有的系统偏差。</p><h1 id="a0b3" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">PID</h1><p id="8574" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">为了克服这个问题，我们需要第三项 I，它代表积分，它有助于监控误差，如果在一定时间内误差没有减少，汽车应该增加更多的转向。</p><p id="d946" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，积分实际上是每步误差的总和，实现方式如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5526" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每一步，当前误差<code class="fe nl nm nn no b">robot.y</code>被加到<code class="fe nl nm nn no b">sum_cte</code>上，并且<code class="fe nl nm nn no b">tau_i</code>是该项的权重。因此<em class="nf">通过增加这一项，汽车避免了在远离目标的某个地方振荡的机会，因为这一项将不断变大，转向角将相应调整。</em></p><p id="dc84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给出了校正后的结果:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi od"><img src="../Images/7e18f8f8ebd99a7f37d22b06f5d488d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*CpmVbBC4uOLsuCzL4yz3Aw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">PID Control</figcaption></figure><p id="b8b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在同样的转向噪音下，这一次机器人汽车仍然能够到达目的地。</p><h1 id="6e39" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="108f" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">另一个需要注意的是 P、I 和 d 的权重。这些参数需要仔细调整，不同的权重选择会导致显著不同的性能。您可以通过查看<a class="ae le" href="https://github.com/MJeremy2017/Machine-Learning-Models/blob/master/Control/PID.ipynb" rel="noopener ugc nofollow" target="_blank">的完整实现</a>来测试和演示它。</p><p id="29ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之，PID 控制器其实挺有意思的，尤其是被这么直观简单的讲解。你可以把三个组成部分 P、I 和 D 想象成负责一项任务的三个不同方面的三个不同的人:</p><ul class=""><li id="9f50" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld oe ll lm ln bi translated"><strong class="kk iu"> P </strong>:将应用推向目标状态的主要力量</li><li id="7f01" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld oe ll lm ln bi translated"><strong class="kk iu"> I </strong>:全程监控，遇到困境时帮助跳出困境</li><li id="4081" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld oe ll lm ln bi translated"><strong class="kk iu"> D </strong>:监控 P 并在必要时进行计数器测量</li></ul><p id="7c28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，PID 控制器的应用绝对不仅限于这个用例，您可以应用和探索更多的乐趣！</p><p id="b96c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考</strong>:</p><ol class=""><li id="2c8c" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><a class="ae le" href="https://classroom.udacity.com/courses/cs373/lessons/48743150/concepts/4a5b7329-1df6-48d0-9f5b-146f9e58ad22" rel="noopener ugc nofollow" target="_blank">https://classroom . uda city . com/courses/cs 373/lessons/48743150/concepts/4a5b 7329-1df 6-48d 0-9f5b-146 F9 e 58 ad 22</a></li></ol></div></div>    
</body>
</html>