<html>
<head>
<title>WebSocket Streaming with Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Scala 的 WebSocket 流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/websocket-streaming-with-scala-fab2feb11868?source=collection_archive---------27-----------------------#2019-12-09">https://towardsdatascience.com/websocket-streaming-with-scala-fab2feb11868?source=collection_archive---------27-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">阿卡河如何让生活变得更简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b36ba14b4379a429de2921072293d137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jzKcWoe8tHgJefju"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@vitalysacred?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vitaly Sacred</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">假设你有一个处理器，一个图像处理器，这个图像处理器有几个处理阶段。每个阶段都以不同的方式改变或处理图像。这个图像处理非常棒，你想和全世界分享。所以你编写了一个服务器来上传文件并运行图像处理。也许每个处理阶段都是一个<code class="fe me mf mg mh b">Flow[BufferedImage]</code>。为了便于讨论，我们假设每个阶段大约需要一秒钟，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ac5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您将所有的流程阶段链接在一起，这可能看起来有点像<code class="fe me mf mg mh b">Flow[BufferedImage, ImageProcessed]</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您构建了一个方法，将这个流作为一个流运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><blockquote class="mk ml mm"><p id="e901" class="kz la mn lb b lc ld ju le lf lg jx lh mo lj lk ll mp ln lo lp mq lr ls lt lu im bi translated">在现实世界中，这不会进入<code class="fe me mf mg mh b">Sink.ignore</code>，因为我们可能会将处理后的图像保存到 S3 桶或其他存储中。</p></blockquote><p id="2662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 Akka Http，您可以轻松定义一个<code class="fe me mf mg mh b">Route</code>来处理文件上传:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><blockquote class="mr"><p id="aba3" class="ms mt it bd mu mv mw mx my mz na lu dk translated">现在我们的朋友可以使用我们的图像服务了！但是，如果我们想通知用户我们的处理进度<strong class="ak">呢？</strong></p></blockquote></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="ac09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从 Akka Http 文档中知道，我们使用<code class="fe me mf mg mh b">Flow[Message]</code>来处理 WebSockets，正如他们的例子所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://doc.akka.io/docs/akka-http/current/server-side/websocket-support.html" rel="noopener ugc nofollow" target="_blank">Akka WebSocket Example</a></figcaption></figure><p id="7f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<em class="mn">我们如何从外部</em>与这个 WebSocket 流<em class="mn">对话</em>？🤔</p><p id="bf4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是<code class="fe me mf mg mh b">preMaterialize</code>一个<code class="fe me mf mg mh b">Source</code>，然后从<code class="fe me mf mg mh b">Sink</code>和这个预物质化的<code class="fe me mf mg mh b">Source</code>构建一个<code class="fe me mf mg mh b">Flow</code>…让我们开始吧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们发送给<code class="fe me mf mg mh b">wsActor</code>的任何东西都将被发送回我们的 JavaScript web 客户端！我们的新路由现在包含 WebSocket 处理程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们更新处理阶段以通知我们的<code class="fe me mf mg mh b">wsActor</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们上传一张图片时，我们会得到一个很好的列表，告诉我们图片正在经历哪些处理阶段😎</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/494354df06b5c5b61812a5c7d33ce9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*TrDeqAmchBrojDp_3qUacw.gif"/></div></figure><p id="0e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有代码(包括前端！)这里的<a class="ae ky" href="https://github.com/duanebester/akka-ws-test" rel="noopener ugc nofollow" target="_blank">是开源的</a>。🐾</p></div></div>    
</body>
</html>