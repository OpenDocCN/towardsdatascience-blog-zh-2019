<html>
<head>
<title>Sending Automated Emails from Blackbaud CRM (BBEC) Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 从 Blackbaud CRM (BBEC)发送自动电子邮件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sending-automated-emails-from-blackbaud-crm-bbec-using-python-part-1-ba4955e91ca2?source=collection_archive---------20-----------------------#2019-12-22">https://towardsdatascience.com/sending-automated-emails-from-blackbaud-crm-bbec-using-python-part-1-ba4955e91ca2?source=collection_archive---------20-----------------------#2019-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4cf4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="http://towardsdatascience.com/tagged/python-and-blackbaud" rel="noopener" target="_blank"> Blackbaud CRM Python 教程</a></h2><div class=""/><div class=""><h2 id="75a8" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">连接到 BBEC 的基本设置</h2></div><p id="9a3d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我的新工作使用 Blackbaud CRM 作为他们数据基础设施的主干，我的经验主要是 Python。令我惊讶的是，关于使用 Python 连接到 Blackbaud Enterprise CRM (BBEC)的资源并不多。最近，我需要拉一个选民名单，并给他们发送一封定制的电子邮件，其中包含他们的帐户信息。这比我预想的要困难得多，我想分享一下我的技巧和工具，以备其他人想要处理类似的问题时使用。我发现的主要方法是使用 API，特别是 AppFxWebService 端点。</p><p id="876f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">要实现这一点，需要几个主要步骤。API 是基于 SOAP 的，这意味着我们必须使用 HTTP 和 XML 来与之通信。我发现通过创建 Jinja2 模板可以很容易地将这些合并到 Python 脚本中。之后，我们将使用<code class="fe lk ll lm ln b">pandas</code>和<code class="fe lk ll lm ln b">xmltodict</code>将 XML 响应转换成数据帧。一旦数据变得更易于管理，我们将向选出的选民发送一些个性化的电子邮件。这篇文章将重点介绍如何使用 Python 建立到 Blackbaud CRM 的连接。我将在以后的文章中更详细地介绍这些其他主题，但这里是从 CRM 中提取信息并使用 Python 发送电子邮件所需的整个过程的概述:</p><ul class=""><li id="9c17" class="lo lp iq kq b kr ks ku kv kx lq lb lr lf ls lj lt lu lv lw bi translated">使用 Python 建立与 Blackbaud CRM 的连接</li><li id="fbf5" class="lo lp iq kq b kr lx ku ly kx lz lb ma lf mb lj lt lu lv lw bi translated">使用 Jinja2 模板与 API 通信</li><li id="3a91" class="lo lp iq kq b kr lx ku ly kx lz lb ma lf mb lj lt lu lv lw bi translated">将 XML 结果解析成熊猫数据帧</li><li id="3573" class="lo lp iq kq b kr lx ku ly kx lz lb ma lf mb lj lt lu lv lw bi translated">使用我们从 CRM 收到的数据发送电子邮件</li></ul><p id="25c6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这个过程中，<a class="ae mc" href="https://www.blackbaud.com/files/support/guides/infinitydevguide/infsdk-developer-help.htm#infinitywebapi/coapioverview.htm" rel="noopener ugc nofollow" target="_blank"> Blackbaud CRM API 文档</a>非常有用。根据您对这些概念的熟悉程度，您可能需要阅读入门指南。但是要注意，当我搜索这些文档时，我找不到任何 Python 示例。希望这篇指南能让你在下一个涉及 Blackbaud CRM 的项目中使用 Python。</p><p id="ae6a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">另外，应该注意的是，这只是一个人解决这个问题的方法。如果你有任何建议或不同的方法来解决这些问题，我很乐意听到你的想法。</p><p id="cf61" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">本指南假设您有一些 Python 经验，一些使用<code class="fe lk ll lm ln b">requests</code>包的经验，也许还有一些使用<code class="fe lk ll lm ln b">pandas</code>和数据分析的经验。如果你认为你能处理，我们将通过打开 IDE 或编辑器直接进入。我更喜欢 PyCharm，这也是本指南中的演示将使用的。然而，我会尽可能地包含使用替代方法完成这些步骤的链接。</p><p id="5b55" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">第一步是在 PyCharm 中创建新项目。如果您选择另一条路线，主要步骤是为您的项目创建一个新目录，<a class="ae mc" href="https://docs.python.org/3/tutorial/venv.html" rel="noopener ugc nofollow" target="_blank">创建并激活一个虚拟环境</a>，并安装一些必需的包。如果你像我一样使用 PyCharm，你需要从欢迎界面选择“创建一个新项目”。然后在接下来的屏幕上从列表顶部选择“纯 Python”。默认情况下，我的配置是用 conda 创建一个新环境。通过将“位置”栏中的“无标题”更改为项目的描述性名称来更改项目名称。对于这个例子，我选择了<code class="fe lk ll lm ln b">bbec_demo</code>。PyCharm 很好地自动创建了一个同名的新 conda 环境，并将其指定为这个项目的项目解释器。</p><p id="2e9b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，我们想要在我们的项目中创建一个名为<code class="fe lk ll lm ln b">config.py</code>的新 Python 文件。如果您非常喜欢 PyCharm 快捷方式，那么当您选择了项目根目录时，可以使用 Alt + Insert +'pf '创建一个新的 python 文件。然后，我们要将以下代码添加到该文件中:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="a608" class="ml mm iq ln b gy mn mo l mp mq">from requests import Session<br/>from requests.auth import HTTPBasicAuth</span></pre><p id="f66c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了向 API 发送请求，我们将结合使用<code class="fe lk ll lm ln b">requests</code>包和其他一些工具。如果您使用 PyCharm，它可能会为您建立一个虚拟环境，您只需安装 requests 包。在 PyCharm 中，最简单的方法是将光标放在标有红色下划线的包(<code class="fe lk ll lm ln b">requests</code>)上，然后按 Alt + Shift + Enter。这将自动选择最合适的上下文菜单项，即“安装包请求”</p><p id="5357" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，在开始与 Blackbaud CRM 通信之前，我们需要收集一些不同的 URL。您可能会发现关于制作 HTTP 请求的文档页面<a class="ae mc" href="https://www.blackbaud.com/files/support/guides/infinitydevguide/content/infinitywebapi/cocraftinghttprequests.htm" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae mc" href="https://www.blackbaud.com/files/support/guides/infinitydevguide/infsdk-developer-help.htm#infinitywebapi/cousingfiddlercreatehttprequest.htm" rel="noopener ugc nofollow" target="_blank"> Fiddler 演示</a>有助于找到这些请求。如果你登录了你公司的客户关系管理系统，你可以通过这个网址找到你需要的信息。例如，您可能有一个如下所示的 URL:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="7b94" class="ml mm iq ln b gy mn mo l mp mq"><a class="ae mc" href="https://bbisec04pro.blackbaudhosting.com/4249COL_fa341b46-12a4-4119-a334-8379e2e59d29/webui/WebShellLogin.aspx?databaseName=4249COL&amp;url=https%3A%2F%2Fbbisec04pro.blackbaudhosting.com%2F4249COL_fa341b46-12a4-4119-a334-8379e2e59d29%2Fwebui%2FWebShellPage.aspx%3FdatabaseName%3D4249COL" rel="noopener ugc nofollow" target="_blank">https://bbisec02pro.blackbaudhosting.com/1234ABC_</a>fbd2546c-1d4d-4508-812c-5d4d915d856a<a class="ae mc" href="https://bbisec04pro.blackbaudhosting.com/4249COL_fa341b46-12a4-4119-a334-8379e2e59d29/webui/WebShellLogin.aspx?databaseName=4249COL&amp;url=https%3A%2F%2Fbbisec04pro.blackbaudhosting.com%2F4249COL_fa341b46-12a4-4119-a334-8379e2e59d29%2Fwebui%2FWebShellPage.aspx%3FdatabaseName%3D4249COL" rel="noopener ugc nofollow" target="_blank">/webui/WebShellLogin.aspx</a></span></pre><p id="c193" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">可能有一个以“？”开头的查询字符串紧跟在<code class="fe lk ll lm ln b"><a class="ae mc" href="https://bbisec04pro.blackbaudhosting.com/4249COL_fa341b46-12a4-4119-a334-8379e2e59d29/webui/WebShellLogin.aspx?databaseName=4249COL&amp;url=https%3A%2F%2Fbbisec04pro.blackbaudhosting.com%2F4249COL_fa341b46-12a4-4119-a334-8379e2e59d29%2Fwebui%2FWebShellPage.aspx%3FdatabaseName%3D4249COL" rel="noopener ugc nofollow" target="_blank">WebShellLogin.aspx</a></code>之后，但是我们可以忽略该信息。在本例中，我们希望所有内容都达到<code class="fe lk ll lm ln b">/webui</code>。我们将把它记录在配置文件中，现在完整的文件应该是这样的:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="c9f1" class="ml mm iq ln b gy mn mo l mp mq">from requests import Session<br/>from requests.auth import HTTPBasicAuth</span><span id="4db7" class="ml mm iq ln b gy mr mo l mp mq">base_url = 'https://bbisec02pro.blackbaudhosting.com/'<br/>database_name = '1234ABC_fbd2546c-1d4d-4508-812c-5d4d915d856a'</span></pre><p id="b0a0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我把 URL 分成两部分，这样我们的代码可读性更好一些。我们需要的最后一部分是 AppFxWebService 端点，即<code class="fe lk ll lm ln b">/appfxwebservice.asmx</code>。我们将使用 f 弦把所有这些放在一起。请注意，f 字符串仅在 Python 3.6 及更高版本中可用，如果您使用的是 Python 的旧版本，则必须使用<code class="fe lk ll lm ln b">.format()</code>字符串方法。我们的配置文件现在应该如下所示:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="0d6d" class="ml mm iq ln b gy mn mo l mp mq">from requests import Session<br/>from requests.auth import HTTPBasicAuth<br/><br/># URLs used for various API calls<br/>base_url = 'https://bbisec02pro.blackbaudhosting.com/'<br/>database_name = '1234ABC_fbd2546c-1d4d-4508-812c-5d4d915d856a'<br/>appfx = '/AppFxWebService.asmx'<br/>api = f'{base_url}{database_name}{appfx}'</span></pre><p id="ba52" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在已经精心制作了将用于与 API 通信的 URL。我们需要的下一部分是登录数据库的凭证。我选择使用 AWS Secret Management 来存储我的凭据。这相对容易，但是设置它可能超出了本文的范围。你需要按照<code class="fe lk ll lm ln b"><a class="ae mc" href="https://pypi.org/project/boto3/" rel="noopener ugc nofollow" target="_blank">boto3</a></code>和<a class="ae mc" href="https://console.aws.amazon.com/secretsmanager/home?region=us-east-1#/newSecret?step=selectSecret" rel="noopener ugc nofollow" target="_blank">的设置指南添加一个新的秘密</a>。与此相关的成本很小，但它非常安全，只需几分钱。如果你以前没有用过，甚至可以免费试用 30 天。</p><p id="bbca" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果 AWS 方法不适合您，一个快速的替代方法是创建一个名为<code class="fe lk ll lm ln b">secret.py</code>的新 Python 文件，但是要确保这个文件不受源代码控制(将其添加到您的<code class="fe lk ll lm ln b">.gitignore</code>文件中)。这个文件应该和<code class="fe lk ll lm ln b">config.py</code>在同一个目录下。它可以简单到:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="6513" class="ml mm iq ln b gy mn mo l mp mq">username = 'BLACKBAUDHOST\your_username1234ABC'<br/>password = 'your password'</span></pre><p id="89ec" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我在这里遇到的一个问题是你用户名前后的前缀和后缀。如果您的环境由 Blackbaud 托管(如果您正在阅读本文，很可能就是这样)，那么合适的前缀是“BLACKBAUDHOST\”。请注意，它只适用于反斜杠，不适用于正斜杠。后缀通常作为用户名的一部分显示在 Blackbaud 中，但它应该是数据库名称。登录 Blackbaud CRM 后，您可以通过查看 URL 中的查询字符串来确认这一点:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="8bdf" class="ml mm iq ln b gy mn mo l mp mq">.../WebShellPage.aspx?databaseName=1234ABC</span></pre><p id="285a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">1234ABC</code>是需要添加到您的用户名后面的内容。确认您的用户名格式正确的另一种方法是在 Blackbaud CRM 中导航至管理&gt;安全&gt;应用程序用户，并查看您的姓名旁边列出的“登录名”内容。这将为您提供我们进行身份验证所需的完整登录名。我还想包含 AWS 的这个代码片段，展示如何访问存储在秘密管理器中的秘密，以防您决定走这条路:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="0d5a" class="ml mm iq ln b gy mn mo l mp mq">import boto3<br/>import base64<br/>from botocore.exceptions import ClientError<br/><br/><br/>def get_secret():<br/>    <br/>    secret_name = "credentials"<br/>    region_name = "us-east-1"<br/><br/>    # Create a Secrets Manager client<br/>    session = boto3.session.Session()<br/>    client = session.client(<br/>        service_name='secretsmanager',<br/>        region_name=region_name<br/>    )<br/><br/>    # In this sample we only handle the specific exceptions for the 'GetSecretValue' API.<br/>    # See https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html<br/>    # We rethrow the exception by default.<br/><br/>    try:<br/>        get_secret_value_response = client.get_secret_value(<br/>            SecretId=secret_name<br/>        )<br/>    except ClientError as e:<br/>        if e.response['Error']['Code'] == 'DecryptionFailureException':<br/>            # Secrets Manager can't decrypt the protected secret text using the provided KMS key.<br/>            # Deal with the exception here, and/or rethrow at your discretion.<br/>            raise e<br/>        elif e.response['Error']['Code'] == 'InternalServiceErrorException':<br/>            # An error occurred on the server side.<br/>            # Deal with the exception here, and/or rethrow at your discretion.<br/>            raise e<br/>        elif e.response['Error']['Code'] == 'InvalidParameterException':<br/>            # You provided an invalid value for a parameter.<br/>            # Deal with the exception here, and/or rethrow at your discretion.<br/>            raise e<br/>        elif e.response['Error']['Code'] == 'InvalidRequestException':<br/>            # You provided a parameter value that is not valid for the current state of the resource.<br/>            # Deal with the exception here, and/or rethrow at your discretion.<br/>            raise e<br/>        elif e.response['Error']['Code'] == 'ResourceNotFoundException':<br/>            # We can't find the resource that you asked for.<br/>            # Deal with the exception here, and/or rethrow at your discretion.<br/>            raise e<br/>    else:<br/>        # Decrypts secret using the associated KMS CMK.<br/>        # Depending on whether the secret is a string or binary, one of these fields will be populated.<br/>        if 'SecretString' in get_secret_value_response:<br/>            secret = get_secret_value_response['SecretString']<br/>            secret = secret.strip('{}').replace('"', '')<br/>            username, password = secret.split(':')<br/>        else:<br/>            decoded_binary_secret = base64.b64decode(get_secret_value_response['SecretBinary'])<br/><br/>    return username, password</span></pre><p id="b6d9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">它包括一些基本的错误处理，我只需要为自己的目的添加三行代码。</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="e610" class="ml mm iq ln b gy mn mo l mp mq">secret = secret.strip('{}').replace('"', '')<br/>username, password = secret.split(':')<br/>...<br/>return username, password</span></pre><p id="77d4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这只是一些文本解析，将响应格式化为用户名和密码对。一旦完成，我就在函数的末尾添加<code class="fe lk ll lm ln b">return username, password</code>。我要说的是，由于“\”字符，在我的用户名中包含“BLACKBAUDHOST”前缀时，我得到了一些奇怪的结果。我无法让它正确地转义，所以我选择从 AWS 中存储的秘密中删除它，并在检索到秘密后添加它。因为它不是用户名的唯一部分，我不认为这里有任何安全问题。</p><p id="44b4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果您走第一条路，将用户名和密码作为明文存储在源代码控制之外的文件中，那么您会想要将这个 import 语句添加到<code class="fe lk ll lm ln b">config.py</code>:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="24d4" class="ml mm iq ln b gy mn mo l mp mq">from secret import username, password</span></pre><p id="6a10" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果您走 AWS Secrets Manager 路线，您的导入看起来会稍有不同，您必须分配用户名和密码:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="91f7" class="ml mm iq ln b gy mn mo l mp mq">import secret</span><span id="c1fb" class="ml mm iq ln b gy mr mo l mp mq">username, password = secret.get_secret()<br/>username = 'BLACKBAUDHOST\\' + username</span></pre><p id="60d0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">由于<code class="fe lk ll lm ln b">get_secret()</code>函数返回一个带有用户名密码对的元组，我们可以编写<code class="fe lk ll lm ln b">username, password</code>来告诉 Python 解包元组并分别分配变量。然后我们会加上我之前提到的前缀。这里需要一个双反斜杠，因为单反斜杠是转义序列的开始，您需要第二个反斜杠来表示被转义的字符(" \ ")。</p><p id="c13e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在凭证已经处理好了，并且可以安全地访问它们，我们只需要做最后一点设置。我们必须用<code class="fe lk ll lm ln b">requests</code>包创建一个会话，并使用我们的凭证授权该会话。</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="2f9b" class="ml mm iq ln b gy mn mo l mp mq">session = Session()<br/>session.auth = HTTPBasicAuth(username, password)</span></pre><p id="087f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我将在这里包括一个其他的位，这是我们所有的 API 调用将使用的头。在发送请求之前，我们将添加一点点信息，但是我喜欢设置一个默认的信息。一旦我们包含了这些，完整的<code class="fe lk ll lm ln b">config.py</code>文件应该是这样的:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="8ff4" class="ml mm iq ln b gy mn mo l mp mq">from requests import Session<br/>from requests.auth import HTTPBasicAuth<br/>import secret<br/><br/># URLs used for various API calls<br/>base_url = 'https://bbisec02pro.blackbaudhosting.com/'<br/>database_name = '1234ABC_fbd2546c-1d4d-4508-812c-5d4d915d856a'<br/>appfx = '/AppFxWebService.asmx'<br/>api = f'{base_url}{database_name}{appfx}'<br/>base_endpoint = 'Blackbaud.AppFx.WebService.API.1/'</span><span id="a41f" class="ml mm iq ln b gy mr mo l mp mq"># Credentials<br/>username, password = secret.get_secret()<br/>username = 'BLACKBAUDHOST\\' + username</span><span id="b1b4" class="ml mm iq ln b gy mr mo l mp mq"># Authorization<br/>session = Session()<br/>session.auth = HTTPBasicAuth(username, password)</span><span id="25cc" class="ml mm iq ln b gy mr mo l mp mq"># Headers<br/>headers = {'Content-Type': 'text/xml; charset=utf-8',<br/>           'Host': 'bbisec02pro.blackbaudhosting.com',<br/>           'SOAPAction': ''}</span></pre><p id="18c1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我还偷偷添加了一行代码来定义<code class="fe lk ll lm ln b">base_endpoint</code>。这是我们将用来配置我们的 SOAP 请求的东西。不是超级关键，但是为了方便可能要加上。<code class="fe lk ll lm ln b">Content-Type</code>头将根据您使用的 SOAP 版本(1.1 或 1.2)而变化。到目前为止，我只使用了 1.1，所以这就是这里所反映的。您也可以通过自己导航到端点来找到此信息。登录你的 Blackbaud CRM，用<code class="fe lk ll lm ln b">.../appfxwebservice.asmx</code>替换网址的<code class="fe lk ll lm ln b">.../webui/WebShellPage.aspx?</code>部分和其后的所有内容。在这里，您将能够看到所有可用的操作以及使用它们所需的 SOAP 模板。模板显示了填充了你的数据库信息的标题，如果对你来说更容易的话，你可以窃取这些并把它们放在如上图所示的<code class="fe lk ll lm ln b">config.py</code>中。</p><p id="62b7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们就要连接到数据库了，但是我们需要再创建一个名为<code class="fe lk ll lm ln b">api.py</code>的文件。在这里，让我们多写一点代码来测试我们的连接:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="f7bc" class="ml mm iq ln b gy mn mo l mp mq">import config<br/><br/>action = 'AdHocQueryGetIDByName'<br/>body = '''&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>               xmlns:xsd="http://www.w3.org/2001/XMLSchema"<br/>               xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;<br/>              &lt;soap:Body&gt;<br/>                &lt;AdHocQueryGetIDByNameRequest &gt;<br/>                  &lt;ClientAppInfo REDatabaseToUse="1234ABC" <br/>                                 ClientAppName="bbec_demo" <br/>                                 TimeOutSeconds="5"/&gt;<br/>                  &lt;Name&gt;Interaction Data List Query&lt;/Name&gt;<br/>                &lt;/AdHocQueryGetIDByNameRequest&gt;<br/>              &lt;/soap:Body&gt;<br/>            &lt;/soap:Envelope&gt;'''</span></pre><p id="03fa" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，我从<code class="fe lk ll lm ln b">/appfxwebservice.asmx </code>端点借用了一个模板，具体来说就是名为“AdHocQueryGetIDByName”的模板，这就是为什么<code class="fe lk ll lm ln b">action = ‘AdHocQueryGetIDByName'</code>。然后，我将文本直接粘贴到我们的文件中。我去掉了所有我不会使用的不重要的标签，然后我必须输入一些其他的信息。你可能会注意到<code class="fe lk ll lm ln b">ClientAppInfo</code>标签。这不会出现在<code class="fe lk ll lm ln b">/appfxwebservice.asmx</code>端点的模板中，但是我们的请求必须有效。他们只是在文档中简单地提到了它，当我第一次开始做这个的时候，它对我来说绝对是一个陷阱。不过，你所要做的就是将<code class="fe lk ll lm ln b">REDatabaseToUse</code>设置为你的数据库名称(在你的 CRM 的 URL 的查询字符串中找到)并为<code class="fe lk ll lm ln b">ClientAppName</code>输入一些名称。按照惯例，我喜欢将它设置为我们的项目名称，但它可以是您想要的任何名称。我们需要做的最后一件事是在<code class="fe lk ll lm ln b">Name</code>标签中输入我们的信息库中存在的查询的名称。我选择“交互数据列表查询”是因为它是一个现成的报告，应该默认包含在您的 CRM 中。</p><p id="465a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，让我们使用给定的操作创建一个函数来设置我们的标题:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="d384" class="ml mm iq ln b gy mn mo l mp mq">def set_head(endpoint):<br/>    headers = config.headers.copy()<br/>    headers.update({'SOAPAction': f'{config.base_endpoint}{endpoint}'})<br/>    return headers</span></pre><p id="b918" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这将更新我们在<code class="fe lk ll lm ln b">config.py</code>文件中定义的头的副本，并返回给<code class="fe lk ll lm ln b">SOAPAction</code>合适的头。</p><p id="9b8e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最后一步是使用我们在<code class="fe lk ll lm ln b">config.py</code>文件中设置的<code class="fe lk ll lm ln b">requests</code>和<code class="fe lk ll lm ln b">session</code>发送 POST 请求。我们将添加我们的头部和身体，我们应该准备好了。</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="0ced" class="ml mm iq ln b gy mn mo l mp mq">res = config.session.post(config.api, headers=set_head(action), data=body)<br/>print(res)</span></pre><p id="edef" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们的<code class="fe lk ll lm ln b">api.py</code>文件作为一个整体现在应该看起来像这样:</p><pre class="md me mf mg gt mh ln mi mj aw mk bi"><span id="c2a6" class="ml mm iq ln b gy mn mo l mp mq">import config<br/><br/>action = 'AdHocQueryGetIDByName'<br/>body = '''&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>               xmlns:xsd="http://www.w3.org/2001/XMLSchema"<br/>               xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;<br/>              &lt;soap:Body&gt;<br/>                &lt;AdHocQueryGetIDByNameRequest &gt;<br/>                  &lt;ClientAppInfo REDatabaseToUse="1234ABC" <br/>                                 ClientAppName="bbec_demo" <br/>                                 TimeOutSeconds="5"/&gt;<br/>                  &lt;Name&gt;AdHocQueryGetIDByName&lt;/Name&gt;<br/>                &lt;/AdHocQueryGetIDByNameRequest&gt;<br/>              &lt;/soap:Body&gt;<br/>            &lt;/soap:Envelope&gt;'''<br/><br/><br/>def set_head(endpoint):<br/>    headers = config.headers.copy()<br/>    headers.update({'SOAPAction': f'{config.base_endpoint}{endpoint}'})<br/>    return headers<br/><br/><br/>res = config.session.post(config.api, headers=set_head(action), data=body)<br/>print(res)</span></pre><p id="1ba2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">运气好的话，当您运行它时，它会打印出<code class="fe lk ll lm ln b">&lt;Response [200]&gt;</code>。这意味着我们已经成功地建立了到数据库的连接，我们可以开始从中提取信息了！</p><p id="b43d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在下一节中，我们将去掉 body 的那个难看的三重引号字符串，并用一些漂亮的 Jinja2 模板替换它。欢迎在下面提出建议或问题。你可以在我的<a class="ae mc" href="https://github.com/smidem/bbec_demo/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本节涉及的所有代码。</p></div></div>    
</body>
</html>