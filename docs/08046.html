<html>
<head>
<title>Object-Oriented Programming in Python — Corey Schafer &amp; DataCamp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的面向对象编程——科里·斯查费和 DataCamp</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-oop-corey-schafer-datacamp-be6b0b3cafc6?source=collection_archive---------12-----------------------#2019-11-05">https://towardsdatascience.com/python-oop-corey-schafer-datacamp-be6b0b3cafc6?source=collection_archive---------12-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="31ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">面向对象编程(OOP) </em> </strong>是一种基于<strong class="js iu"><em class="ko">【Object】</em></strong>的编程范式，是一种将编程语言中包含变量的东西定义为“字段/属性”，功能为“方法”的方式。<em class="ko">OOP</em><strong class="js iu"><em class="ko"/></strong>允许程序员创建自己的拥有方法和属性的对象。OOP 允许用户创建他们自己的可重复和有组织的对象。</p><p id="9a3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我试图总结我对 python 中 OOP 的看法。我要感谢<a class="kp kq ep" href="https://medium.com/u/703ff67f629f?source=post_page-----be6b0b3cafc6--------------------------------" rel="noopener" target="_blank">何塞·马西亚尔·波尔蒂利亚</a>、<a class="kp kq ep" href="https://medium.com/u/e18542fdcc02?source=post_page-----be6b0b3cafc6--------------------------------" rel="noopener" target="_blank">数据营团队</a>和<a class="ae kr" href="https://www.youtube.com/playlist?list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc" rel="noopener ugc nofollow" target="_blank">科里·谢弗</a>他们精彩的描述性教程。这对我帮助很大。我会尽快为此添加一个 GitHub 库。</p><h1 id="5d59" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">为什么上课？</strong></h1><p id="9055" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">类是具有方法和变量的可重用代码块。准确地说，类是对象的模板。类允许我们对数据和函数进行逻辑分组，这种方式易于重用，如果需要的话也易于构建。在这里，数据和函数被称为属性和方法。在下图中，定义了一个没有传递任何属性的类数据外壳。<code class="fe lv lw lx ly b"><strong class="js iu">pass</strong></code>什么都不做，只是一个<em class="ko">占位符</em>。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/a7cb41a2cab83f75c4166ad90b340e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*d3-g0bKJlnq3dC4ZUtZZiQ.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Defining a class <strong class="bd ml">Datashell</strong> without passing any attributes</figcaption></figure><h1 id="1cf9" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">属性的初始化器或构造器</strong></h1><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/a02a42e4a1daa1feb1e2959904bc4d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GB11gA2IYOCTjyeNEQINw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Class <strong class="bd ml">Datashell </strong>with Initializer/Constructor <strong class="bd ml">__init__</strong> of it.</figcaption></figure><p id="b42b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">self</strong></code>表示对象本身的实例。大多数面向对象语言将其作为隐藏参数传递给方法。任何东西都可以代替<code class="fe lv lw lx ly b"><strong class="js iu">self</strong></code>，但是为了让其他人更容易理解，我们应该用<code class="fe lv lw lx ly b"><strong class="js iu">self</strong></code>。要打印一个方法，我们需要在最后使用圆括号<code class="fe lv lw lx ly b"><strong class="js iu">()</strong></code>。如果我们跳过<code class="fe lv lw lx ly b"><strong class="js iu">()</strong></code>，那么它只打印方法而不是<em class="ko">返回值</em>。类、方法和实例通过下图被清晰地描述。</p><p id="a0a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">&lt;blockquote&gt;</strong></code></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mr"><img src="../Images/4fd85080f1fd3df5bf457a6a035efd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f53kAFryBdrGf6bHbvPOdw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Class <strong class="bd ml">hello </strong>with methods <strong class="bd ml">setdata </strong>and <strong class="bd ml">showdata </strong>and instances <strong class="bd ml">x </strong>and <strong class="bd ml">y</strong></figcaption></figure><h1 id="8dc6" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">类变量</strong></h1><p id="a177" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">在 OOP 中，类级别的变量被称为类变量，而对象级别的变量被称为实例变量。下图描述了类变量的一般形式和示例。这里<em class="ko">‘spam’</em>被定义为类变量<strong class="js iu"> <em class="ko">数据</em> </strong>，它在后面的几个<em class="ko">方法</em> <strong class="js iu"> <em class="ko">中被用作实例变量。</em> </strong></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ms"><img src="../Images/f89e73a30930d7930046030e578cb04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6TZjXLm9Z_SlFQMRPTuXA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk"><strong class="bd ml">data</strong> as Class variable</figcaption></figure><p id="94fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们通过调用类来改变类变量，那么所有地方的值都会改变，而如果我们通过实例来改变变量，那么只有那个值会改变。假设如果我们将<em class="ko">数据</em>的值更改为“<em class="ko">非垃圾信息</em>，那么包括数据在内的所有实例值都将被更改，但是如果我们在任何<em class="ko">方法</em>中更改实例变量，那么它将只在那个<em class="ko">方法</em>中。</p><h1 id="278a" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">类方法和静态方法</h1><p id="31bd" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated"><strong class="js iu">常规方法</strong>自动将实例作为第一个参数传递，我们称之为<code class="fe lv lw lx ly b"><strong class="js iu">self.</strong></code> <strong class="js iu">类方法</strong>自动将类作为第一个参数传递，我们称之为<code class="fe lv lw lx ly b"><strong class="js iu">cls</strong></code> <strong class="js iu">。静态方法</strong>不自动传递任何东西，它们不传递实例或类，它们的行为就像一个常规函数，它们与类有一些逻辑联系。以上所有例子中提到的方法都是常规方法。但是对于类方法和静态方法，我们需要在应用之前提到它[ <code class="fe lv lw lx ly b"><strong class="js iu">@classmethod / @staticmethod</strong></code> ]。</p><pre class="ma mb mc md gt mt ly mu mv aw mw bi"><span id="ed45" class="mx kt it ly b gy my mz l na nb">@classmethod<br/>def set_raise(cls,amount):<br/>    cls.raise = amount</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nc"><img src="../Images/f096079224d1d8ce6a37efff26595333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JBd1q8A4XMNoVvCFJ32xw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk"><strong class="bd ml">Static method</strong> and <strong class="bd ml">class method</strong></figcaption></figure><h1 id="e2dc" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">继承(创建子类)</h1><p id="5087" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">继承允许我们从父类继承属性和方法。这是重用和降低复杂性的能力。我们可以创建子类并获得父类的所有功能，然后我们可以覆盖或添加全新的功能，而不会以任何方式影响父类。下面的例子清楚地描述了继承。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nd"><img src="../Images/61f49fdd7fb2e2478269b51898d40d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rDR3tITRVxhhLcunraW5A.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk"><strong class="bd ml">Inheritance </strong>in OOP</figcaption></figure><p id="6c0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们想从另一个类中复制任何属性，并在其上添加更多的属性，那么我们可以通过以下方式来完成。我们可以在应该避免使用<code class="fe lv lw lx ly b"><strong class="js iu">self</strong></code>的地方使用<code class="fe lv lw lx ly b"><strong class="js iu">super()</strong></code> <strong class="js iu"> </strong>，或者我们可以直接调用提到<code class="fe lv lw lx ly b"><strong class="js iu">self</strong></code> <strong class="js iu">的类。</strong></p><pre class="ma mb mc md gt mt ly mu mv aw mw bi"><span id="3f0f" class="mx kt it ly b gy my mz l na nb">class hi(hello):<br/>    def __init__(self, name, age):<br/>        <strong class="ly iu">super().__init__(data)<br/></strong><em class="ko">or </em>     "<strong class="ly iu">hello.__init__(self, data)"</strong></span></pre><h1 id="14c8" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">特殊(魔法/邓德)方法</h1><p id="9042" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">特殊的方法允许我们模拟 python 中的一些内置行为。通过定义我们自己的特殊方法，我们将能够改变一些内置的行为和操作。特殊方法总是被<code class="fe lv lw lx ly b"><strong class="js iu">__method__</strong></code>包围。很多人称它们为双下划线<em class="ko"> Dunder </em> <strong class="js iu">。</strong>下面是一些常见的特殊方法:</p><p id="32ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">__init__(self)</strong></code> <strong class="js iu"> : </strong>当我们创建我们的对象时隐式调用，它设置所有属性。</p><p id="e3f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">__repr__(self)</strong></code> <strong class="js iu"> </strong>:对象的明确表示，应该用于调试和日志记录</p><p id="9474" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">__str__(self)</strong></code> <strong class="js iu"> </strong>:对象的可读表示，旨在向最终用户显示。</p><p id="863b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">__add__(self)</strong></code> <strong class="js iu"> </strong>:添加对象。</p><p id="6f80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lv lw lx ly b"><strong class="js iu">__len__(self)</strong></code> <strong class="js iu"> </strong>:生成物体的长度。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ne"><img src="../Images/fabdbded350061fb7b11c61acb6be992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4t97eY9HzxPcb4dFrt-VYw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Some special <strong class="bd ml">methods</strong></figcaption></figure><h1 id="69a3" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">属性装饰器(Getter、Setter 和 Deleters)</h1><p id="dcc7" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">Property decorator 允许我们定义一个方法，但是我们可以像访问属性一样访问它。在下面的例子中，name 是一个方法，但是我们可以像调用属性一样调用它。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nf"><img src="../Images/ad9fbe7f4adc5d4e5e4c792a9bc5c620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJ7qTP3zrt9opcFa_YPDWw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Using <strong class="bd ml">Property </strong>to call a<strong class="bd ml"> method</strong> just like an<strong class="bd ml"> attribute</strong></figcaption></figure><p id="8074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我对 python 中 OOP 的了解到此为止。我已经尽力在我的限度内详细描述了。如果您能对此提出意见或批评，我们将不胜感激。我不是 CS 出身，但我每天都在学习。如果你喜欢这篇文章，那么你可以看看我的另一篇关于<strong class="js iu">Markdown Cells——Jupyter 笔记本的文章。</strong></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/markdown-cells-jupyter-notebook-d3bea8416671"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">降价单元格— Jupyter 笔记本</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">我不知道如何开始。这将是我第一个与编程相关的故事。今天我将努力缩小…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx mf nj"/></div></div></a></div><h1 id="f9b5" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">参考链接:</strong></h1><ol class=""><li id="8e01" class="ny nz it js b jt lq jx lr kb oa kf ob kj oc kn od oe of og bi translated"><a class="ae kr" href="https://campus.datacamp.com/courses/object-oriented-programming-in-python/getting-ready-for-object-oriented-programming?ex=1" rel="noopener ugc nofollow" target="_blank">https://camp . data camp . com/courses/object-oriented-programming-in-python/getting-ready-for-object-oriented-programming？ex=1 </a></li><li id="5dfc" class="ny nz it js b jt oh jx oi kb oj kf ok kj ol kn od oe of og bi translated"><a class="ae kr" href="https://www.youtube.com/playlist?list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/playlist?list = PL-osie 80 tetshiuoqkhwlxsibidseytc</a></li><li id="6b97" class="ny nz it js b jt oh jx oi kb oj kf ok kj ol kn od oe of og bi translated"><a class="ae kr" href="https://www.udemy.com/course/complete-python-bootcamp/" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/complete-python-bootcamp/</a></li></ol></div></div>    
</body>
</html>