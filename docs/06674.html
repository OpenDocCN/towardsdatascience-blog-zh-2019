<html>
<head>
<title>Here’s How Apache Flink Stores Your State data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是 Apache Flink 如何存储您的状态数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/heres-how-flink-stores-your-state-7b37fbb60e1a?source=collection_archive---------8-----------------------#2019-09-24">https://towardsdatascience.com/heres-how-flink-stores-your-state-7b37fbb60e1a?source=collection_archive---------8-----------------------#2019-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="426d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Flink 中有状态处理的幕后</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9ef248763963c916f1df5d4e31d5ee76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A8b_iiL1JQaR9QL6"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@samuelzeller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Samuel Zeller</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Apache Flink 的一个重要特性是它能够进行有状态处理。存储和检索状态数据的 API 很简单，这使得它很容易使用。</p><p id="20c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在 API 的背后是一个管理数据的系统，同时提供持久性保证，这就是我们将在本文中理解的。</p><p id="4ac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将会看到国家管理的三个部分——</p><ol class=""><li id="62b6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">状态后端</li><li id="b421" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据格式</li><li id="d469" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">持久性和故障恢复</li></ol><p id="6609" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先看看状态实际存储在哪里。</p><h1 id="1376" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我的数据存储在哪里？</h1><p id="8563" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Flink 为您的状态提供了三个现成的后端存储。这些是</p><ol class=""><li id="3c68" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">内存状态后端</li><li id="dfac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">文件系统(FS)状态后端</li><li id="134d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">RocksDB 状态后端</li></ol><h2 id="ab4e" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">内存状态后端</h2><p id="8939" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这种存储将数据保存在每个任务管理器堆的内存中。因此，这使得它的访问速度极快。尽管有这样的性能，但这种状态永远不应该在生产作业中使用。这是因为状态会在作业管理器内存中创建数据备份(也称为检查点),这给作业管理器的操作稳定性带来了不必要的压力。</p><p id="a439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个后端的另一个限制是任务的总状态大小不能超过 10MB。可以将其配置为更高的限制，但出于性能考虑，作者不建议这样做。</p><p id="12e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是 Flink 在没有配置任何东西的情况下使用的默认后端。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/1191ea4ee451c82a92a12e1b8e042186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmVL7vA8nlfvLwlbqNo1eQ.png"/></div></div></figure><h2 id="0abd" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">文件系统后端</h2><p id="ab7b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个后端类似于内存状态后端，只是它将备份存储在文件系统上，而不是作业管理器内存中。文件系统可以是任务管理器的本地文件系统或持久存储，如 HDFS/S3。</p><p id="5db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种状态也受到堆内存的限制，因此应该在数据较少并且需要高性能的情况下使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/32fc51092d52673f5dd9d79b1aa0e4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaecLcKYL8Yo8HMS4-8jMA.png"/></div></div></figure><h2 id="2bfe" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">RocksDB 后端</h2><p id="918f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个后端使用脸书的 RocksDB 来存储数据。如果您不知道 RocksDB，那么它是一个提供 ACID 保证的可嵌入键值存储。它基于谷歌的<a class="ae kv" href="https://github.com/google/leveldb" rel="noopener ugc nofollow" target="_blank"> LevelDB，但提供了更好的写性能。</a></p><p id="4cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flink 选择使用 RocksDB，而不是一些最流行的嵌入式存储，如 SQLlite，因为它的高写入性能来自基于 LSM 架构的设计。<br/>由于 RocksDB 还维护着一个内存表(也称为 mem-table)和 bloom filters，读取最近的数据也非常快。</p><p id="5cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个任务管理器维护它自己的 Rocks DB 文件，并且这个状态的备份被检查点设置到一个持久存储，比如 HDFS。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/6dd4d092e02a9cb3300c5efa615a1df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4Y4SzMaE6YmgeaHm9Tdgw.png"/></div></div></figure><p id="1cf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是唯一支持增量检查点的后端，即只备份修改过的数据，而不是完整的数据。</p><p id="ac7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的应用程序需要存储一个大的州，这应该是您的选择。但是，因为它需要磁盘访问和序列化/反序列化，所以它比其他后端要慢。</p><h1 id="be07" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">这个国家实际上是什么样子的？</h1><p id="7445" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们看看在应用程序中创建状态后，数据实际上是如何存储的。</p><p id="c56d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储格式因后端而异。但是，常见的部分是状态的键和值都存储在使用 Flink 自己的类型序列化程序创建的字节数组中。</p><p id="dfe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用 RocksDB 后端进行演示。</p><p id="760d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个任务管理器都有多个 RocksDB 文件夹，每个文件夹本身就是一个数据库。每个数据库包含由状态描述符中给出的名称定义的多个列族。</p><p id="dd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个列族都包含键-值对，其中键是操作符的键，值是状态数据。</p><p id="4f36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子。让我们看看这个示例作业的状态</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b2fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该作业包含两个状态函数，定义如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e94b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果运行此作业，并在 flink-conf.yml 文件中将 Rocksdb 设置为 state backend，则在每个任务管理器上都将生成以下目录。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="91d9" class="nd mh iq nu b gy ny nz l oa ob">drwxr-xr-x   4 abc  74715970   128B Sep 23 03:19 job_127b2b84f80b368b8edfe02b2762d10d_op_KeyedProcessOperator_0d49016af99997646695a030f69aa7ee__1_1__uuid_65b50444-5857-4940-9f8c-77326cc79279/db</span><span id="6214" class="nd mh iq nu b gy oc nz l oa ob">drwxr-xr-x   4 abc  74715970   128B Sep 23 03:20 job_127b2b84f80b368b8edfe02b2762d10d_op_StreamFlatMap_11f49afc24b1cce91c7169b1e5140284__1_1__uuid_19b333d3-3278-4e51-93c8-ac6c3608507c/db</span></pre><p id="8a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是目录名的定义方式</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/8566dce662214f1b99bc120f3a97a3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfqHmhM73KHvJtsNMHdL6A.png"/></div></div></figure><p id="eaa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些名称由三部分组成</p><ol class=""><li id="3ca1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir"> JOB_ID: </strong>创建作业图表时分配给作业的随机 ID。</li><li id="bcf2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> OPERATOR_ID </strong>:这是 OPERATOR 的基类、operator uid 的 Murmur3 Hash、任务的索引和任务的整体并行度的组合。例如，对于我们的 StatefulMapTest 函数，这 4 个部分结果是</li></ol><ul class=""><li id="2e3f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oe ly lz ma bi translated">河流平面图</li><li id="52b2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oe ly lz ma bi translated">mur mur 3 _ 128(" stateful _ map _ test ")-&gt; 11f 49 AFC 24 B1 CCE 91 c 7169 B1 e 5140284</li><li id="2689" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oe ly lz ma bi translated">1，因为在并行度为 1 的作业中只能有一个任务，因此任务索引为 1</li><li id="a686" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oe ly lz ma bi translated">1，因为我在执行作业时将并行度设置为 1</li></ul><p id="83e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir"> UUID </strong>:这只是创建目录时随机生成的 UUID。</p><p id="38d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个目录都包含一个 RocksDB 实例。RocksDB 的文件结构将是</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="2f3b" class="nd mh iq nu b gy ny nz l oa ob">-rw-r--r--  1 abc  74715970    21K Sep 23 03:20 000011.sst<br/>-rw-r--r--  1 abc  74715970    21K Sep 23 03:20 000012.sst<br/>-rw-r--r--  1 abc  74715970     0B Sep 23 03:36 000015.log<br/>-rw-r--r--  1 abc  74715970    16B Sep 23 03:36 CURRENT<br/>-rw-r--r--  1 abc  74715970    33B Sep 23 03:18 IDENTITY<br/>-rw-r--r--  1 abc  74715970     0B Sep 23 03:33 LOCK<br/>-rw-r--r--  1 abc  74715970    34K Sep 23 03:36 LOG<br/>-rw-r--r--  1 abc  74715970   339B Sep 23 03:36 MANIFEST-000014<br/>-rw-r--r--  1 abc  74715970    10K Sep 23 03:36 OPTIONS-000017</span></pre><p id="b4ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">的。sst 文件是包含实际数据的 Rocksdb 的 SSTable 文件。<br/>日志文件包含提交日志。<br/>清单包含元数据，如列族。<br/>选项包含用于创建 RocksDB 实例的配置。</p><p id="0757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用 RocksDB java API 打开这个 DB。我们将看一下 StatefulMapTest 函数目录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码打印数据库中存在的所有列族名称。上面这段代码的输出结果是</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c554" class="nd mh iq nu b gy ny nz l oa ob">default<br/>previousInt<br/>nextInt</span></pre><p id="9a47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以打印每个列族中的所有键值对。这可以使用下面的代码来完成</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，它将打印出键值对，如<br/> (testing123，1423)，(testing456，1212)等。</p><p id="540f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的 TestInputView 只是 Flink 特定的构造，用于读取字节数组数据流。</p><h1 id="f314" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我需要备份数据吗？</h1><p id="3e63" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Flink 使用一种称为检查点的机制为应用程序状态提供持久性。它定期拍摄状态快照，然后将其存储在持久性存储中，如 HDFS/S3。这允许 Flink 应用程序在出现故障时从该备份中恢复。</p><p id="865f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，对 Flink 作业禁用检查点。要启用它，您可以将以下代码添加到您的应用程序中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="25d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将配置您的应用程序每 60 秒拍摄一次状态快照，并将其放入作业管理器/HDFS/S3 以备将来恢复。在 HDFS/S3 的情况下，可以用 flink-conf.yml 中的<strong class="ky ir"> state.checkpoints.dir </strong>配置用于存储检查点的目录</p><p id="34a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查点的最终目录结构如下所示</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="19ec" class="nd mh iq nu b gy ny nz l oa ob">hdfs:///path/to/state.checkpoints.dir/{JOB_ID}/chk-{CHECKPOINT_ID}/</span></pre><p id="ae78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JOB_ID 是应用程序的唯一 ID，检查点 ID 是自动递增的数字 ID。</p><p id="471b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在应用程序启动时从检查点恢复状态，只需运行</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="5f1e" class="nd mh iq nu b gy ny nz l oa ob">flink-1.9.0/bin/flink run -s hdfs:///path/to/state.checkpoints.dir/{JOB_ID}/chk-{CHECKPOINT_ID}/ path/to//your/jar</span></pre><p id="b9ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用检查点函数来扩展有状态函数，该函数提供了在初始化和拍摄快照时修改状态的能力。可以扩展前面的 StatefulProcess 函数来使用这个接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e3fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就完成了我们对 Flink 状态的深入研究，现在您可以确信您的状态被应用程序很好地保存了。</p><p id="8c62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想开始使用状态处理 Apache Flink，这里有一些到官方文档的有用链接</p><ol class=""><li id="2b58" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/state/state.html" rel="noopener ugc nofollow" target="_blank">工作状态</a></li><li id="f7d6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/state/state_backends.html" rel="noopener ugc nofollow" target="_blank">州后端</a></li><li id="0493" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/libs/state_processor_api.html" rel="noopener ugc nofollow" target="_blank">状态处理器 API </a></li></ol></div></div>    
</body>
</html>