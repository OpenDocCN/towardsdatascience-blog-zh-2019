<html>
<head>
<title>Decoding the performance secret of world’s most popular Data Science library— Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码世界上最流行的数据科学库——Numpy 的性能秘密</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decoding-the-performance-secret-of-worlds-most-popular-data-science-library-numpy-7a7da54b7d72?source=collection_archive---------9-----------------------#2019-12-15">https://towardsdatascience.com/decoding-the-performance-secret-of-worlds-most-popular-data-science-library-numpy-7a7da54b7d72?source=collection_archive---------9-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3f3595c3e2989d3e716821e91f0cff01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdlQBxQSj4BCZ2S--_SdFQ.png"/></div></div></figure><p id="87b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有这个魔咒，任何机器学习脚本都无法启动</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/5a3c882506bc41c2f2f45de39ceb6e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xu8QF7567f6iPkPluRCRNw.png"/></div></div></figure><p id="7f03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无论是数据科学爱好者，还是经验丰富的从业者，每个人都知道这个精彩的 Python 库的威力。</p><p id="71b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当涉及到处理大型多维数组(表格、图像等)时。)，用 numpy 也不会错的很离谱。</p><p id="0c54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是你知道吗，除了超级方便之外，强大的软件包还包含相当多的性能果汁！</p><p id="ba42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，使用 numpy 内置的基于元素的数组操作通常比遍历标准 python list 要快得多。</p><p id="97ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑这个简单的任务，按元素添加两个列表</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="9782" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比较这两者的性能，我们可以观察到</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lg"><img src="../Images/6c83e10a853eb88b4df51b785079a8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwSDobwy-mNp-UQrAPMmig.png"/></div></div></figure><p id="1f3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着元素数量从 1000 增加到 100，000，Python-lists 所用的时间成线性比例——O(n ),相对于此,<code class="fe lh li lj lk b"><em class="ll">np.add()</em></code>所用的时间几乎保持不变——O(1)。</p><p id="625e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让您了解阵列大小为 100，000 的一些情况，这些数字如下:</p><pre class="la lb lc ld gt lm lk ln lo aw lp bi"><span id="0912" class="lq lr it lk b gy ls lt l lu lv">%timeit sum_using_loop(a,b,c)<br/># Average run time: 10.5 ms ± 15.9 µs</span><span id="4101" class="lq lr it lk b gy lw lt l lu lv">%timeit sum_using_numpy_builtin(a, b)<br/># Average run time: 79.6 µs ± 835 ns</span></pre><blockquote class="lx"><p id="0fc7" class="ly lz it bd ma mb mc md me mf mg ky dk translated">numpy 方法快了将近 130 倍！！</p></blockquote><p id="7c94" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">问题是—</p><blockquote class="mm mn mo"><p id="a75d" class="kb kc ll kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated">Numpy 是如何实现如此荒谬的加速的？？</p></blockquote><p id="d501" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一些显而易见的答案包括:</p><ul class=""><li id="715e" class="ms mt it kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">Numpy 主要是用 C 写的，比 Python 快。</li><li id="7b54" class="ms mt it kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">Numpy 数组是同构的(所有数组元素都有固定的数据类型- <code class="fe lh li lj lk b"><em class="ll">np.float32, np.uint8</em></code>等等)。与没有这种限制的 python 列表相比)，从而允许将数字存储在连续的存储器位置中以便更快地访问(<em class="ll">利用</em> <a class="ae ng" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank"> <em class="ll">引用位置</em> </a>)</li></ul><p id="e13f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管如此，上述原因还不足以解释处理时间为何不与数组大小成比例。</p><h1 id="870b" class="nh lr it bd ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od bi translated">走到幕后</h1><p id="b974" class="pw-post-body-paragraph kb kc it kd b ke oe kg kh ki of kk kl km og ko kp kq oh ks kt ku oi kw kx ky im bi translated">为了找到答案，让我们开始在 Numpy Land 的秘密任务——解构源代码。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/f88235574239909129f5d8260810507d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVXQuXB7kejNxHDsCJ5Hzg.png"/></div></div></figure><p id="844c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解这一点，让我们先熟悉一些本地术语:</p><ul class=""><li id="5b3a" class="ms mt it kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated"><strong class="kd iu">通用函数</strong>(uf unc)—numpy 中的函数，对“N”维数组(又名 ndarray)执行快速元素运算</li><li id="cfdc" class="ms mt it kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated"><strong class="kd iu"> umath </strong> — Numpy 模块，包含常见数学运算的实现，如加、减、乘、正弦、余弦等。)</li></ul><blockquote class="mm mn mo"><p id="a141" class="kb kc ll kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated"><strong class="kd iu">剧透警告</strong> : Numpy 使用矢量指令(SIMD)来加速“ufunc ”,你可以跳到下一节，或者如果你有兴趣了解如何加速，请继续阅读。</p></blockquote><p id="862e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经过一番挖掘，我们可以在<code class="fe lh li lj lk b"><em class="ll">__umath_generated.c</em></code>中找到一些我们感兴趣的添加函数的引用</p><p id="d11d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们看到，<code class="fe lh li lj lk b"><em class="ll">add_functions</em></code>是一个数组，包含对所有特定类型加法函数的引用，包括<code class="fe lh li lj lk b"><em class="ll">INT_add</em>, <em class="ll">FLOAT_add</em>, <em class="ll">DOUBLE_add</em></code>等。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/d5bdaae95401e8982703b724a1b71c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObiSnw0dJr9Bub4cIkMVEw.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">How Numpy stores references to all data-type specific addition functions — Numpy source</figcaption></figure><p id="c998" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些<code class="fe lh li lj lk b"><em class="ll">add_functions</em></code>通过下面的代码映射到我们的 python 的<code class="fe lh li lj lk b"><em class="ll">numpy.add</em></code>函数调用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/d90b67b57a76e0a40003f6be5c1859f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lt2Kb4d-Slpq008LAec3FQ.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Where ‘numpy.add’ comes from — Numpy source</figcaption></figure><p id="fa49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在为了简单起见，让我们只关注一种数据类型，比如说浮点加法，并弄清楚是什么让它如此快速！</p><p id="24b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的查询将我们带到了实现相关方法的文件— <code class="fe lh li lj lk b"> <em class="ll">loops.c</em></code></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/e550f01693ee06f20292c6dfda229c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNBw94aXT-pyQpGW9tQmvw.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">‘Float_add’ method inside ‘loops.c’ — Numpy source</figcaption></figure><p id="20a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">流程是这样的:</p><ol class=""><li id="58e7" class="ms mt it kd b ke kf ki kj km mu kq mv ku mw ky or my mz na bi translated">确定它是否是一个归约操作——组合输入参数并返回一个聚合结果<em class="ll">(在我们的例子中不是这样)</em></li></ol><p id="27ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.尝试使用<code class="fe lh li lj lk b"><em class="ll">run_binary_simd_add_FLOAT()</em></code> <em class="ll"> </em>将它们相加(这里的‘二进制’指的是对两个输入的运算，可以是数组或标量或者两者的组合)</p><p id="d2d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.如果对<em class="ll"> simd_add </em>函数的调用失败，那么它使用标准的循环元素加法。</p><blockquote class="mm mn mo"><p id="d0b7" class="kb kc ll kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated">注意:这些名字- ' <em class="it"> sse2 </em>'，'<em class="it"> simd </em>'可能现在看起来很陌生，但是以后会有意义的</p></blockquote><p id="bd3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">沿着<code class="fe lh li lj lk b"><em class="ll">run_binary_simd_add_FLOAT()</em></code> <em class="ll">，</em>的轨迹，我们最终会找到我们最感兴趣的那段代码<code class="fe lh li lj lk b"><em class="ll">sse2_binary_add_FLOAT()</em></code></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/ca638a25b5a3e4a62e6772fb503f09ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eajg2DBzpVcQHL2GPK0wJw.png"/></div></div></figure><p id="12ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仔细观察，我们可以发现一些奇怪的代码，这些代码(<em class="ll">如果你还记得你的“计算机架构”课</em>)类似于汇编语言。</p><pre class="la lb lc ld gt lm lk ln lo aw lp bi"><span id="8107" class="lq lr it lk b gy ls lt l lu lv"><em class="ll">_mm512_load_ps<br/></em>_<em class="ll">mm512_add_ps<br/>_mm512_store_ps</em></span></pre><p id="d6dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，这些是<em class="ll"> ' </em> <a class="ae ng" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=SSE4_2,AVX,AVX2" rel="noopener ugc nofollow" target="_blank">英特尔内部函数</a> ' — <em class="ll"> C 函数，它们提供对汇编指令的访问，而无需实际编写汇编代码！</em></p><p id="66e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更确切地说，这些是矢量指令！！</p><h1 id="5d62" class="nh lr it bd ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od bi translated">向量:什么鬼东西？？</h1><p id="f95f" class="pw-post-body-paragraph kb kc it kd b ke oe kg kh ki of kk kl km og ko kp kq oh ks kt ku oi kw kx ky im bi translated">在你开始思考汇编代码之前，请允许我解释一下。</p><blockquote class="mm mn mo"><p id="8a1c" class="kb kc ll kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated">现代 CPU 有称为向量寄存器的专用硬件寄存器，能够同时对多个操作数(相同类型/大小)进行操作，引入了被称为<strong class="kd iu">‘单指令多数据</strong>’(或 SIMD)机制的并行性</p></blockquote><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/df76816535a3e10cee0770977bf688e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*pzbo9I5t7cVVyymxnRqoxQ.png"/></div><figcaption class="ol om gj gh gi on oo bd b be z dk"><a class="ae ng" href="https://www.nativescript.org/blog/nativescript-now-supports-vector-types" rel="noopener ugc nofollow" target="_blank"><strong class="bd ou">Image Credit: NativeScript</strong></a></figcaption></figure><p id="096a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向量指令(也称为向量扩展)是访问这些向量寄存器的手段，允许在大型数组(也称为向量扩展)上更快地处理最常见的算术和逻辑运算。向量)。</p><p id="053b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些通常用于涉及大型多维数组操作的应用程序，例如</p><ul class=""><li id="eb94" class="ms mt it kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">图形处理(视频游戏、4K 视频渲染等。)</li><li id="961b" class="ms mt it kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">统计(寻找大型数组的平均值/模式)</li><li id="7d8a" class="ms mt it kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">机器学习(矩阵乘法-&gt;输入*权重+偏差)</li></ul><blockquote class="lx"><p id="5b97" class="ly lz it bd ma mb mc md me mf mg ky dk translated">啊哈！！</p></blockquote><h1 id="4a92" class="nh lr it bd ni nj nk nl nm nn no np nq nr ov nt nu nv ow nx ny nz ox ob oc od bi translated">是什么让这些寄存器这么酷(快)？</h1><p id="27c5" class="pw-post-body-paragraph kb kc it kd b ke oe kg kh ki of kk kl km og ko kp kq oh ks kt ku oi kw kx ky im bi translated">这是他们的能力。</p><p id="31d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">典型地，CPU 具有多个 32 位和 64 位通用寄存器，而向量寄存器的大小是 128/256 位，或者在较新的情况下甚至是 512 位。(我们将会看到)。</p><blockquote class="mm mn mo"><p id="53c2" class="kb kc ll kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated">更大的容量意味着，一个 256 位向量寄存器可以在一个时钟周期内并行保存和操作“8”个 32 位浮点！—与最大的通用寄存器相比，速度提高了近<strong class="kd iu">4 倍</strong></p></blockquote><p id="8ee5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SSE 和 AVX 是最流行的向量扩展。</p><p id="a6ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ng" href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="noopener ugc nofollow" target="_blank"> SSE ( <strong class="kd iu">流 SIMD 扩展)</strong> </a> <strong class="kd iu"> </strong>最早于 1999 年在英特尔奔腾 III 中推出，附带<strong class="kd iu">‘8’-128</strong>位向量寄存器。</p><p id="ea2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">12 年后，随着“<em class="ll"> Sandy bridge </em>”，英特尔推出了新的<a class="ae ng" href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions" rel="noopener ugc nofollow" target="_blank"> AVX ( <strong class="kd iu">高级向量扩展</strong> ) </a>，它拥有<strong class="kd iu"> 256 位</strong>寄存器(几乎是上一代的两倍)</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/86f7cb2ee4ce29ff11e735ab7cca8df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62sFhU-MgWfxR_7C3Nr1EA.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Intel Processor vectorization capacity increasing as the generations progress</figcaption></figure><p id="9503" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ll">因此，现在我们有了一些很酷的东西来欣赏现代 CPU 能够进行的硬件优化，而不仅仅是痴迷于它们的时钟速度。</em></p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="eb29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，Numpy 对向量指令的利用，使得它在大型数组上执行操作的速度超快，这与标准 python-lists 相反。此外，在内部，numpy 使用了许多其他性能提升技巧，包括'<a class="ae ng" href="https://www.jessicayung.com/numpy-arrays-memory-and-strides/" rel="noopener ugc nofollow" target="_blank"><em class="ll"/></a><em class="ll">'</em>，&amp;其他编译器级优化标志，以执行'<a class="ae ng" href="https://gcc.gnu.org/projects/tree-ssa/vectorization.html" rel="noopener ugc nofollow" target="_blank"><em class="ll"/></a>'自动向量化。</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><h1 id="b5b2" class="nh lr it bd ni nj pg nl nm nn ph np nq nr pi nt nu nv pj nx ny nz pk ob oc od bi translated">常见问题</h1><blockquote class="mm mn mo"><p id="1819" class="kb kc ll kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated"><strong class="kd iu">问:上述加速仅适用于英特尔 CPU 吗？AMD 处理器呢？</strong></p></blockquote><blockquote class="lx"><p id="10d6" class="ly lz it bd ma mb mc md me mf mg ky dk translated">AMD 确实支持 SSE 和 AVX，但是它的支持仅限于 AVX2 (256 位)，而较新的英特尔处理器配备 AVX-512 (512 位)</p></blockquote><blockquote class="mm mn mo"><p id="8001" class="kb kc ll kd b ke mh kg kh ki mi kk kl mp mj ko kp mq mk ks kt mr ml kw kx ky im bi translated"><strong class="kd iu">问。)这些新获得的知识如何让我成为更聪明的数据科学家？</strong></p></blockquote><blockquote class="lx"><p id="9a54" class="ly lz it bd ma mb mc md me mf mg ky dk translated">既然你已经知道了内部秘密，那么对你最有利的是:</p><p id="523d" class="ly lz it bd ma mb pl pm pn po pp ky dk translated">-尽可能避免使用 for 循环，使用 numpy 内置的操作和方法。</p><p id="9561" class="ly lz it bd ma mb pl pm pn po pp ky dk translated">-如果代码包含一维数组上的条件循环，一种快速矢量化代码的方法是使用<code class="fe lh li lj lk b">np.vectorize</code>。这里有一个帖子告诉你如何去做。</p><p id="3812" class="ly lz it bd ma mb pl pm pn po pp ky dk translated">-对于复杂运算，技巧是尝试将循环转换为一系列矩阵运算(点积/矩阵乘法/加法等)。).<a class="ae ng" href="https://hackernoon.com/speeding-up-your-code-2-vectorizing-the-loops-with-numpy-e380e939bed3" rel="noopener ugc nofollow" target="_blank">这里有一个帖子用一个例子</a>描述了同样的情况。</p></blockquote></div></div>    
</body>
</html>