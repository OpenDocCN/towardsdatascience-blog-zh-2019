<html>
<head>
<title>Finding What You Need Using AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用人工智能找到你需要的东西</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-what-you-need-using-ai-e42b4cdec8fa?source=collection_archive---------20-----------------------#2019-07-24">https://towardsdatascience.com/finding-what-you-need-using-ai-e42b4cdec8fa?source=collection_archive---------20-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f87f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">路径搜索算法介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c41e744e2dc19f5ac36c9ed8fbbf346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOFvX8a0ROaYnq_vzRPxSw.png"/></div></div></figure><p id="50a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大三的时候上了第一堂人工智能课。我神采奕奕地走进去。我期待着所有的热门词汇——神经网络、支持向量机、贝叶斯网络等等。第一堂课是我杜克经历中最令人失望的 75 分钟。我得到了深度优先搜索和递归，而不是听起来很酷的时髦词汇。</p><p id="3121" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我最喜欢的课程之一，我的教授非常清楚他在做什么。我们必须先学习基础知识，然后才能做大事。如果我们不了解内部和外部的基本原理，我们就没有对抗深度学习的机会。宫城先生在教我们给汽车打蜡。路径搜索打开，路径搜索关闭…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/292d90aaaa326597a93775b1e4e27709.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*vNG5eO9e-J_d-ZiFecN4Qg.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Copyright 1984 Columbia Pictures — <a class="ae lv" href="https://giphy.com/gifs/memecandy-kewtvhA4tgH30DYKZr" rel="noopener ugc nofollow" target="_blank">The Karate Kid</a></figcaption></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="ee94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">尽管如此，随着我了解的越来越多，我记得我对路径搜索算法嗤之以鼻。他们看起来一点也不聪明。</strong>你是说你只是生成所有可能的路径，猜测其中最好的一条，然后探索那条路径？人类比这聪明多了。我们处于食物链的顶端是有原因的！</p><p id="a0d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但那次演讲后我不得不去办点事。我得去吃午饭，买课本，然后去上另一节课。所以，我想“<em class="md">我可以吃午饭，然后去上课，然后拿我的课本。啊，但是等等，那时候商店已经关门了。也许我会去拿书，然后吃午饭，然后去上课。但是，不，我现在饿了。好吧，我去吃午饭，拿书，然后去上课。</em>“如果你错过了这里的讽刺，再读一遍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/e5e8775e89f5d0fc1a9abdc834ae48b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQsRkKU7JqDgp-8ySuWICA.png"/></div></div></figure><p id="f9fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要么是计算机非常聪明，要么是人类没有我们想象的那么聪明。我倾向于后者。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="cf38" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">概观</h2><p id="3ade" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在本文中，我们将介绍四种搜索算法来解决下面的问题。假设给你一个二维网格。你从左上角开始，只能向下或向右移动。网格中的每个单元格都有一个点值。收集路径上所有像元的点值。你的目标是收集尽可能多的分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ee55781d51ac36488b7711ef165b8e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxJZx4iuFSEPSqJnAae03Q.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="053f" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">递归</h2><p id="3bc8" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们首先尝试一种递归方法。递归简单易行。我们的基本情况是到达右下角的单元格。否则，我们将递归调用向下向右移动。然后我们在每一步取这两个调用的最大值。这允许我们将问题分解成更小的子问题。这种方法的实现如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/ba616e591e3e2a256d241213384710d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOvWss9YC6dDbhdiXa3YEg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Code source <a class="ae lv" href="https://github.com/andrewjoliver/OptimalGridSearch/blob/master/RecursiveSearch.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="38ba" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">深度优先搜索</h2><p id="f3dc" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">这种方法可行，但是递归调用代价很高。随着网格的增长，我们可能会遇到堆栈溢出。当我们进行的递归调用超过内存中的堆栈所能处理的数量时，就会发生这种情况。因此，我们转向<strong class="kw iu">一种深度优先搜索(DFS)方法</strong>。</p><p id="01b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 DFS 中，我们会先充分探索一条道路，然后再转向另一条。我们使用堆栈来跟踪我们的路径。我们尽可能向下移动，然后向右移动。我们仍然在探索与递归解决方案一样多的路径，但是我们使用了更少的内存并防止了堆栈溢出。对于长度为 2 的二维网格，我们的堆栈如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0a0b7acc80ce4e9d85bcae3f5bf0d5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sh9CIY9BB_NT-wgkowVl8A.png"/></div></div></figure><p id="92cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须做一些跑腿的工作来编写我们的 DFS 算法。我们将定义一个 GridCell 类。对于每个单元格，我们将记录我们是从这个单元格向下还是向右。对于每个完整路径，我们将记录分数。如果它大于我们当前路径的分数，我们将把我们的最大值和最优路径更新为当前值和路径。这显示在下面的代码中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/3913f87bb0ee4e0b5dbc8d777898efe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vg7bcP61xIgFVRWlFor2lw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Code source <a class="ae lv" href="https://github.com/andrewjoliver/OptimalGridSearch/blob/master/DFSSearch.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="0f74" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">双向搜索</h2><p id="0371" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们仍然没有解决算法中的一个主要问题。我们重复计算来自同一个单元的所有路径。这导致了许多重叠的子问题。例如，考虑下面大小为<em class="md"> n = 5 </em>的网格。大致有 n<em class="md">n</em>种方法可以到达中间的细胞。从中间的单元格，有大约<em class="md"> n </em>多种方式到达右下角的单元格。这意味着我们正在为此路径和所有其他路径进行<em class="md"> n </em>计算。这是非常低效的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/05b2c69bb68f36019bf091416275db52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3Pe1LEAEydkfs9RLmfM4Q.png"/></div></div></figure><p id="56af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们能从角落开始呢？如果我们从左上和右下开始工作，然后在中间相遇会怎么样？然后，我们可以从上半部分和下半部分分别选择最佳路径，并将它们配对。我们现在只做<em class="md"> n </em>计算，而不是<em class="md"> n </em>计算。这是一个巨大的进步，尤其是对于大<em class="md"> n </em>来说。这被称为<strong class="kw iu">双向搜索</strong>，如下图所示。注意箭头的方向。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3203f5b3cf2b5024779c367435fb4e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0rHxqk-hRW0W6a8bhKVew.png"/></div></div></figure><p id="99a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，我们可以做得更多。我们可以利用现代计算机的处理能力。当你的 Python 代码运行时，它被分解成你的 CPU 可以执行的代码。开箱即用，Python 代码不支持并行性。出于我们的目的，我们认为并行是功能的同时执行。现在，我们的代码线性运行。如果<em class="md"> funcA() </em>在<em class="md"> funcB() </em>之前，<em class="md"> funcA() </em>需要在<em class="md"> funcB() </em>开始之前终止。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/356383235a3b493807ace9ac5066b523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHhRods7sRk2wcOyUfFNfA.png"/></div></div></figure><p id="59a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，事实并非如此。如果<em class="md"> funcA() </em>和<em class="md"> funcB() </em>是独立的，我们可以同时运行。我们可以使用 Python 中的<a class="ae lv" href="https://docs.python.org/2/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多处理来利用并行性。这意味着我们可以同时计算左上和右下的路径。</a></p><p id="eae9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们并行执行双向搜索，并在运行时看到了相当大的改进。这个实现的代码可以在<a class="ae lv" href="https://github.com/andrewjoliver/OptimalGridSearch/blob/master/DSFBidirectionalSearch.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到。但是，对于非常大的<em class="md"> n </em>，这个问题还是需要一段时间。为了解决这个问题，我们求助于<strong class="kw iu">启发式搜索</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/b674c37afe9dd29f49ba55e20a7b5a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PD1GcdvOvcGg_tjDYqIdsg.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="5888" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">启发式搜索</h2><p id="2e5b" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们的下一个算法利用了搜索和人工智能中的一个关键概念。<a class="ae lv" href="https://data-flair.training/blogs/heuristic-search-ai/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">启发式</strong> </a>的想法。启发式是一种评估功能，帮助我们估计达到目标的最佳路径。在每次迭代中，我们将启发式算法应用于所有可能的未来状态。然后我们探索哪个状态具有最高启发值的路径。</p><p id="7335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要为我们的问题定义一个试探法。假设我们位于网格的左上角。无论我们向右还是向下移动，所有灰色的单元格都是可以访问的。然而，如果我们向下移动，就会失去橙色细胞，如果我们向右移动，就会失去蓝色细胞。因此，我们可以查看橙色单元格和蓝色单元格的平均单元格值。我们将朝着更高的平均单元格值的方向移动。我们可以对每个细胞都这样做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b0eae4feea8d4bb1092a57405f93bda6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdxT-cvr0LBYj4sO6Q6mdA.png"/></div></div></figure><p id="8e77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个解决方案不精确。但是，它快得令人难以置信。我们也看到相对最优的解决方案。如果我们的单元格值范围从 1 到 5，我们会看到对于网格大小为<em class="md"> n = 13 </em>的解决方案有 90%是最优的。随着单元格范围的增加，我们看到的最优解会越来越少。例如，在 1 到 100 的范围内，我们看到对于<em class="md"> n = 13 </em>有 85%的最优解。这可能不会给你一条去月球的路，但会给你一条去杂货店的路。</p><p id="6bc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种启发式搜索算法的实现如下。如果你感兴趣，可以随意克隆<a class="ae lv" href="https://github.com/andrewjoliver/OptimalGridSearch" rel="noopener ugc nofollow" target="_blank">库</a>并尝试启发式方法。更精确的启发式方法会导致更优的解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/abcc008736a5581cb53cb97798ae4225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02lnwPdrzJzqxnHxls_SjA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Code source <a class="ae lv" href="https://github.com/andrewjoliver/OptimalGridSearch/blob/master/HueristicSearch.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="bc66" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">结束语</h2><p id="cda3" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">这个问题在现实世界中有很多应用。一个明显的例子是 GPS 应用程序规划路线。我们可以根据道路的速度限制除以距离来给道路赋值。在这里找到一个解决方案可以让我们找到一条快捷的路线。但是如果我们能给代表一个问题的状态分配点值，我们可以使用这些算法中的任何一个。我们可以很容易地使用这些完全相同的算法来为新 iPhone 的发布找到最佳的营销策略。</p><p id="c755" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也凸显了很多搜索问题的问题。随着这些问题越来越多，找到最佳解决方案需要太长时间。因此，我们必须在速度和优化之间做出权衡，正如我们在这里所做的那样。</p><h1 id="8d50" class="nk mg it bd mh nl nm nn mk no np nq mn jz nr ka mq kc ns kd mt kf nt kg mw nu bi translated">感谢阅读！</h1></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="c447" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="md">疑问？评论？在</em><a class="ae lv" href="mailto:andrew.oliver.medium@gmail.com?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"><em class="md">【andrew.oliver.medium@gmail.com】</em></a><em class="md">给我发邮件。我很想收到你的来信！</em></p></div></div>    
</body>
</html>