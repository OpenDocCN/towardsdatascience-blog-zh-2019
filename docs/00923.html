<html>
<head>
<title>Python Intro#3: Connect Government Data API’s By Using The Factory Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 简介#3:使用工厂模式连接政府数据 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tutorial-connect-government-data-apis-by-using-the-factory-pattern-501e5c65ba6d?source=collection_archive---------33-----------------------#2019-02-11">https://towardsdatascience.com/python-tutorial-connect-government-data-apis-by-using-the-factory-pattern-501e5c65ba6d?source=collection_archive---------33-----------------------#2019-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="294e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/python-stat-tutorial" rel="noopener" target="_blank"> Python 统计教程系列</a></h2><div class=""/><div class=""><h2 id="fdee" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从公共政府数据 API 中获取政治家数据，以提高分配准确性</h2></div><p id="6bc5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">点击标题上方的链接，查看所有教程文章的列表。</p><p id="1e3d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本教程中，我们主要做两个步骤</p><ul class=""><li id="7b33" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">首先，我们从收集的数据中生成一些图表，</li><li id="f849" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">其次，我们将一个公共政府 API 连接到我们的程序，以可靠的方式检索政府成员和党派分配</li></ul><p id="a818" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所有教程的列表可以在<a class="ae mb" href="https://twitter.com/i/moments/1092507080307720193" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="e476" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如你已经知道的，我们对一个通用程序感兴趣，它可以在多个国家工作。为此，我们将在教程的第二部分介绍一个抽象类和工厂模式。</p><h1 id="977f" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">Plotly 图表生成</h1><p id="42e9" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">但是让我们从第一个非常简单的任务开始，为我们的表生成两个图表。</p><p id="00bb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们创建了条形图和饼图。作为基础，我们以我们的 plotly 表<em class="mz"> CH-tw-party-list </em>。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/8845acc7e37f4a9f77f6c7fcd1937933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D72cLv49xf-FBLXK.png"/></div></div></figure><p id="a6f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">代码很简单:</p><ul class=""><li id="f940" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">在条形图中，我们直观地显示了每个聚会累积的朋友数。</li><li id="4abf" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在饼状图中，我们汇总了每一方的 twitter 账户。</li></ul><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9b4c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从代码摘录中可以看出，各种配置参数允许您修改图表的布局。前往<a class="ae mb" href="https://plot.ly/pandas/" rel="noopener ugc nofollow" target="_blank"> Plotly Python 开源图形库</a>了解更多关于图表、panda 和 Plotly 的多种可能性。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/924592877792a6792698796008ebb538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XSJuLxuMkfwrvaMN.png"/></div></div></figure><p id="2d1a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如你所看到的，我们有很多“未知数”，也就是说，我们不能仅仅通过分析 Twitter 数据元素来确定相应的一方。在本教程的第二部分，我们将连接另一个数据源来解决这个问题。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/e9b362ae010efb5a3eb87de8e4fdff86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ju22RjVtrY6aGDFJ.png"/></div></div></figure><h1 id="8569" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">政府数据 API 工厂</h1><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/cf246ef4f3ba4310bd9917c451aa54e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ot2puuifgmsp7uBM.jpeg"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Photo by <a class="ae mb" href="https://unsplash.com/photos/zb29xBwpt6c?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Rodney Minter-Brown</a> on <a class="ae mb" href="https://unsplash.com/search/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f180" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">近年来，所谓的开放政府 API 的可用性激增。它源于数据应该开放的理念，正如维基百科对术语<a class="ae mb" href="https://en.wikipedia.org/wiki/Open_data" rel="noopener ugc nofollow" target="_blank">开放数据</a>的描述:</p><blockquote class="ns nt nu"><p id="f42a" class="kr ks mz kt b ku kv kd kw kx ky kg kz nv lb lc ld nw lf lg lh nx lj lk ll lm im bi translated">开放数据的理念是，一些数据应该免费提供给每个人使用和重新发布，不受版权、专利或其他控制机制的限制。</p><p id="3d39" class="kr ks mz kt b ku kv kd kw kx ky kg kz nv lb lc ld nw lf lg lh nx lj lk ll lm im bi translated">开放数据的最重要形式之一是开放政府数据(OGD)，这是由执政的政府机构创建的一种开放数据形式。开放政府数据的重要性在于它是公民日常生活的一部分，甚至是看似远离政府的最日常/最平凡的任务。</p></blockquote><p id="4ad2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">获得政府数据 API 概述的一个很好的起点是 programmableweb 目录，它列出了 20，000 多个不同的 API。</p><p id="c62f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">政府 API 类别可在此处找到:</p><p id="d059" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae mb" href="https://www.programmableweb.com/category/government/apis?category=20094" rel="noopener ugc nofollow" target="_blank">https://www.programmableweb.com/category/government/apis?类别=20094 </a></p><p id="c7db" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">政府空气污染指数的两个例子:</p><p id="2c45" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">美国政府的数据 API:【https://www.data.gov/developers/apis T2】T3</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/fa467fc01ba517042a8950e0a719da67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k0q372fZeckMtO7m.png"/></div></div></figure><p id="4198" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">或者瑞士议会的瑞士政府 API:【http://ws-old.parlament.ch/ T4】:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/6c5700f81cfdc1d156f811b185724eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5HCMbeuz6nRAiUMk.png"/></div></div></figure><p id="0c3d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将使用瑞士议会 API 提取议会成员的个人数据(主要是政党分配)，以提高我们的 twitter 匹配算法的准确性。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/9149c5bc183fb7a38c49ef81f811e492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eyOLlgMASByqukj1.png"/></div></div></figure><p id="9c0d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如我们在第二篇教程中已经解释过的，一个公共 API 可能会返回很多信息。为了控制一个请求中返回的数据量，使用了游标或分页机制的概念。</p><p id="13c7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">瑞士议会 API 在一次请求中返回大约 25 条记录。最新的请求记录将附带一个属性，告诉您是否有更多可用的数据(<em class="mz"> hasMorePages=true </em>)。</p><p id="e03e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果设置为'<em class="mz"> true </em>，您可以通过添加查询参数:<em class="mz"> pageNumber=2 </em>等获取下一页。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/31625c29ad4936b753633f8c5fb90adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*El0OBEsIKP350xMp.png"/></div></div></figure><p id="0ca5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可以在 API 的用户文档中找到这类信息，例如，瑞士议会 API 有一些控制输出格式、语言等的参数。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/8885a08951636c2d1d16c476a4f4ff6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DwZkm4JvH7YZzuCe.png"/></div></div></figure><p id="bec1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在对 API 有了基本的了解，我们可以增强程序，使其能够从特定国家的政府 API 中读取数据。让我们深入研究代码。</p><h1 id="b9ba" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">增强代码 UML 图</h1><p id="f7a3" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">以一种通用的方式引入政府 API 需要对我们的程序进行一些认真的设计和改进。我们的增强程序的 UML 类图如下所示(不要被复杂性淹没，所有细节将在本文后面解释)。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ny"><img src="../Images/0baa969cb1fa5c5c9b85fef921630cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cIstLnDhxj7Zmzi9.png"/></div></div></figure><p id="74e0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们到目前为止所做工作的快速总结:</p><ul class=""><li id="1f9f" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">我们在第二个<a class="ae mb" rel="noopener" target="_blank" href="/python-tutorial-government-social-media-analyser-class-build-out-12858190b284">教程</a>中创建了 GovernmentSocialMediaAnalyzer 类，它能够检索一个国家的政治家的 twitter 相关账户数据。我们使用了一种基于配置驱动的方法——基于 YAML——将特定于国家的数据抽象到一个配置文件中</li><li id="c0f8" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">定义了几种方法，使我们能够创建 panda 数据框，以及 plotly 特定的表格和图表。</li></ul><p id="e254" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们将引入三个新类<em class="mz"> govAPIFactory </em>、<em class="mz"> govAPI </em>(一个抽象类)和<em class="mz"> govAPI_CH </em>，它们将构建一个通用的方法来连接任何类型的政府 API。</p><p id="4a73" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">软件设计模式在软件设计中起着重要的作用，正如<a class="ae mb" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> Wikipedia </a>所描述的:</p><blockquote class="ns nt nu"><p id="669d" class="kr ks mz kt b ku kv kd kw kx ky kg kz nv lb lc ld nw lf lg lh nx lj lk ll lm im bi translated">在软件工程中，软件设计模式是对软件设计中给定上下文中常见问题的通用、可重用的解决方案。它不是一个可以直接转化为源代码或机器码的成品设计。它是如何解决一个问题的描述或模板，可以在许多不同的情况下使用。设计模式是形式化的最佳实践，程序员可以用它来解决设计应用程序或系统时的常见问题。</p></blockquote><p id="612f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们的设计中，我们将使用工厂方法模式将连接推广到政府 API，这由<a class="ae mb" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>解释如下:</p><blockquote class="ns nt nu"><p id="edc8" class="kr ks mz kt b ku kv kd kw kx ky kg kz nv lb lc ld nw lf lg lh nx lj lk ll lm im bi translated">在基于类的编程中，工厂方法模式是一种创造性的模式，它使用工厂方法来处理创建对象的问题，而不必指定将要创建的对象的确切类。这是通过调用工厂方法(在接口中指定并由子类实现，或者在基类中实现并可选地由派生类重写)而不是通过调用构造函数来创建对象来完成的。</p></blockquote><p id="d22f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的设计将以策略为基础，来定义</p><ul class=""><li id="4e18" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">一个抽象的基类(父类— <em class="mz"> GovAPI </em>)</li><li id="428e" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">一个派生类(child — <em class="mz"> GovAPI_CH </em>)，它将具有特定于国家的实现(如瑞士)。</li><li id="1217" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">将来，我们可以引入额外的类，例如对于英国，我们将构建实现类:<em class="mz"> GovAPI_UK </em></li></ul><h1 id="709c" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">抽象基类“GovAPI”</h1><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/225fe6a5841904b2b730170e0ed2bbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WiA_QEctuiRyAuDY.png"/></div></div></figure><p id="8230" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">govAPI 是一个抽象类，包含几个抽象方法。抽象方法是已声明但不包含实现的方法。</p><p id="ccde" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 Python 中，抽象类是从 ABC 类派生(或继承)的，并且将有一个或多个标有@abstractmethod 的方法。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4402" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以抽象类为你提供了一个构建计划，在我们的类<em class="mz"> govAPI_CH </em>中，任何继承它的实现类。</p><p id="4171" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="mz"> govAPI_CH </em>要实现什么样的方法？</p><p id="1fde" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，<em class="mz">load _ government _ members()</em>方法的实现必须处理从政府 API 获取的政治家的数据记录。每个提取的记录——代表一个政治家的数据——必须传递给方法<em class="mz"> add_person_record </em>(该方法已经由<em class="mz"> govAPI </em>基类实现)</p><p id="94de" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在的问题是，<em class="mz"> add_person_record </em>方法到底在做什么？好吧，看看下面的代码。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1963" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该方法只是为我们的个人记录准备一个目标字典。即定义的属性名(<em class="mz">姓</em>、<em class="mz">名</em>、<em class="mz">会</em>等)。)是我们希望用于任何<em class="mz"> GovAPI </em>实现的名称。</p><p id="d893" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这意味着我们检索的记录以专用政府 API 实现的形式(即以瑞士政府议会 API 的形式)必须通过使用一堆 getter 方法来转换。</p><p id="7a59" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些 getter 方法要么是抽象的，要么返回空字符串。提供正确的 getter 实现是继承类(<em class="mz"> GovAPI_CH </em>)的实现者的责任。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="81f3" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">实现类“GovAPI_CH”</h1><p id="143e" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">下面显示了<em class="mz"> GovAPI_CH </em>的 getter 方法实现。它由一组 getter 方法组成，这些方法将从记录中返回所需的属性值。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9532" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们深入到方法<em class="mz">load _ gegovernment _ members</em>:</p><p id="de6f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的实现使用了 python 模块<a class="ae mb" href="http://docs.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> requests </em> </a>，这是“一个优雅而简单的人类 HTTP 库”在本文的简介部分，我们提供了瑞士议会 API 的概述。下面的代码将使用分页机制获取数据。</p><p id="3848" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将 URL 及其参数放在配置 YAML 文件中。</p><pre class="nb nc nd ne gt nz oa ob oc aw od bi"><span id="9cef" class="oe md it oa b gy of og l oh oi">govAPIUrl: "http://ws-old.parlament.ch/" <br/>govAPICouncillorsRes: "councillors" <br/>govAPIParams: <br/>  - format : "json"</span></pre><ul class=""><li id="f0ae" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">8:第一个<em class="mz"> requests.get </em>将获取所有议员概况页面<a class="ae mb" href="http://ws-old.parlament.ch/councillors?format=json&amp;pageNumber=1" rel="noopener ugc nofollow" target="_blank">http://ws-old.parlament.ch/councillors?format=json&amp;page number = 1</a>。</li><li id="4505" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">15:如果数据记录被标记为<em class="mz">激活</em>,将提取详细记录</li><li id="ac77" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">17:第二个请求将使用记录的 id<em class="mz">和细节记录的 URL。也就是说，在这个例子中，我们获取了 id 为‘1358’的政治家记录:<a class="ae mb" href="http://ws-old.parlament.ch/councillors/1358?format=json&amp;pageNumber=1" rel="noopener ugc nofollow" target="_blank">http://ws-old.parlament.ch/councillors/1358?format=json</a></em></li><li id="12fb" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">19:我们将检索到的详细记录传递给方法<em class="mz"> addPerson </em>，该方法将把提供的数据记录转换成目标记录(通过使用我们已经实现的 getters)。</li><li id="ac3f" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">20:最后，我们检查<em class="mz"> hasMorePages </em>属性，如果到达最后一条记录，我们将中断循环。</li></ul><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c824" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上述方法将在<em class="mz"> govAPI </em>函数<em class="mz">create _ political _ from _ govAPI _ table</em>(已经由 govAPI 父类实现)中调用，该函数将把政客记录列表转换为 Panda 数据帧。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="dd5e" class="oe md it bd me oj ok dn mi ol om dp mm la on oo mo le op oq mq li or os ms iz bi translated">正则模型</h2><p id="53bf" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">重要的是要认识到，只要我们基于 govAPI 抽象类实现一个特定的类，这个 Panda 数据帧的结构将与任何种类的政府 API 相同。所以我们将数据标准化，这样我们就可以用标准化的方式工作和处理它。</p><p id="f7c6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们再次努力实现一个重要的设计模式，我们的目标结构(或模型)，被称为<a class="ae mb" href="https://en.wikipedia.org/wiki/Canonical_model" rel="noopener ugc nofollow" target="_blank">规范模型</a>。正如维基百科所描述的:</p><blockquote class="ns nt nu"><p id="34fa" class="kr ks mz kt b ku kv kd kw kx ky kg kz nv lb lc ld nw lf lg lh nx lj lk ll lm im bi translated">规范模型是一种用于在不同数据格式之间进行通信的设计模式。本质上:创建一个数据模型，它是所有其他模型的超集(“规范的”)，并创建一个“翻译”模块或层，所有现有的模块通过它与其他模块交换数据。</p></blockquote><p id="6cfa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从概念上讲，我们已经建立了一个迷你数据管道。对于每个政府 API，我们必须实现一个数据记录获取函数和转换规则(getters ),将数据转换为我们的标准化数据。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/d30b20258a7c5e6cea52533c40601098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DIZpXKhf4b9XI8OC.png"/></div></div></figure><p id="922d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">整个模式在 UML 序列图中可视化。</p><ul class=""><li id="a309" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">“消费”操作由步骤 60 表示</li><li id="be8c" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">“转换规则”操作由步骤 80-120 表示。</li><li id="a5cb" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">“存储”操作由步骤 130 表示</li></ul><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/bc3c6a87965e42641ebd96b7684b116c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QmXFLExxwdQnCQyL.png"/></div></div></figure><p id="eb38" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">重要的是你要理解各种类的职责。<em class="mz"> govAPI </em>和<em class="mz"> govAPI_CH </em>(红点)对外界可见(<em class="mz"> govAPIFactory </em>，<em class="mz"> gsma </em>)作为一个类实例。对于调用者来说，谁实现哪个方法并不重要。</p><h1 id="a2dd" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">govAPIFactory 类</h1><p id="de59" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">还缺少最后一个东西，即<em class="mz"> govAPIFactory </em>类，它非常简单。根据<em class="mz"> country_code </em>，将创建相应的实现类实例并返回给调用者:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4b3d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">可以看到，这个类只有一个类方法。即<em class="mz"> GovAPIFactory </em>不支持对象实例。一个工厂在一个程序中只包含一次，这被称为单例模式。</p><blockquote class="ns nt nu"><p id="5a7f" class="kr ks mz kt b ku kv kd kw kx ky kg kz nv lb lc ld nw lf lg lh nx lj lk ll lm im bi translated">在<a class="ae mb" href="https://en.wikipedia.org/wiki/Software_engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a>中，<strong class="kt jd">单件模式</strong>是一种<a class="ae mb" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，它将一个<a class="ae mb" href="https://en.wikipedia.org/wiki/Class_(computer_programming)" rel="noopener ugc nofollow" target="_blank">类</a>的<a class="ae mb" href="https://en.wikipedia.org/wiki/Instantiation_(computer_science)" rel="noopener ugc nofollow" target="_blank">实例化</a>限制为一个。当只需要一个对象来协调整个系统的动作时，这很有用</p></blockquote><p id="fe48" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们在这里使用了一个派生，通过只有一个静态类方法来确保单例性。</p><p id="4015" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是相当多的内容要吸收，我们介绍了两个重要的设计模式工厂方法和规范的数据模型，以及如何生成第一对图表。</p><p id="f0d5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="mz"> lesson3.py </em>程序将在 Plotly 内生成名为<em class="mz"> CH-govapi-member-list </em>的表格。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/f45018f6ab59d1bbdd8dfa9eb768d890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YvxPsRNwmlTWnpsm.png"/></div></div></figure><p id="0e9b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">今天就到这里，在下一篇文章中，我们将开始通过结合两个数据源来进行一些数据分析。</p><h1 id="1076" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">锻炼</h1><p id="16a4" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">你可以在这里找到练习教程:<a class="ae mb" href="https://dev.cloudburo.net/2019/02/18/python-tutorial-exercise-3-implement-the-govapi_uk-class.html" rel="noopener ugc nofollow" target="_blank">链接</a></p><h1 id="e805" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">源代码</h1><p id="62ef" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">源代码可以在这里找到(第三课目录):<a class="ae mb" href="https://github.com/talfco/clb-sentiment" rel="noopener ugc nofollow" target="_blank">https://github.com/talfco/clb-sentiment</a></p><h1 id="dcf2" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">进一步阅读</h1><p id="990a" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">如果您想更深入地了解设计模式和 Python 的主题，请阅读下面的文章"<a class="ae mb" href="https://www.toptal.com/python/python-parameterized-design-patterns" rel="noopener ugc nofollow" target="_blank">确保代码整洁:Python 的一瞥，参数化的</a>"</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="8862" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="mz">原载于 2019 年 2 月 11 日</em><a class="ae mb" href="https://dev.cloudburo.net/2019/02/11/python-tutorial-connect-government-data-api-s-by-using-the-factory-pattern.html" rel="noopener ugc nofollow" target="_blank"><em class="mz">dev.cloudburo.net</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>