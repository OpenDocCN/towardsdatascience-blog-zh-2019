<html>
<head>
<title>Stratified sampling and how to perform it in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分层抽样以及如何在 R</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stratified-sampling-and-how-to-perform-it-in-r-8b753efde1ef?source=collection_archive---------6-----------------------#2019-05-07">https://towardsdatascience.com/stratified-sampling-and-how-to-perform-it-in-r-8b753efde1ef?source=collection_archive---------6-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对大型数据集进行采样的正确方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f888b8c4bbb1216d64d4cc8fa8ec6675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YYl5mkam37ElNoXK"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@gtomassetti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Giorgio Tomassetti</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/data-science-journal/how-to-correctly-select-a-sample-from-a-huge-dataset-in-machine-learning-24327650372c" rel="noopener">之前的一篇文章</a>中，我写了关于<strong class="lb iu">以适当的方式从人群中选择样本</strong>的重要性。今天我将向大家展示一种叫做<strong class="lb iu">分层抽样</strong>的技术，它可以帮助我们从一个庞大的数据集中创建一个<strong class="lb iu">具有统计显著性的</strong>样本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c311" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对大量人口进行抽样的正确方法</h1><p id="c4c5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们从总体中执行一个样本时，我们想要实现的是一个更小的数据集，它保持总体的<strong class="lb iu">相同的统计信息</strong>。</p><p id="8491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">产生一个相当好的样本的最好方法是统一收集人口记录，但是这种工作方式并不是完美的。事实上，虽然平均来说效果很好，但单个样本与总体差异太大的概率仍然很低，有限。这种概率非常小，但它会在我们的样本中引入偏差，这将<strong class="lb iu">破坏</strong>我们在其上训练的任何机器学习模型的预测能力。</p><p id="8065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的要点是，我们不想要一个理论上正确的方法，这个方法适用于大数；我们想要提取一个正确的样本，并尽可能具有最高的统计显著性。</p><p id="6f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，统一的抽样已经不够了，我们需要一个更强的方法。</p><h1 id="7a0d" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">分层抽样</h1><p id="3f32" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">分层抽样是为了从一个人口记录<strong class="lb iu">到另一个记录</strong>构建样本，尽可能忠实地保持原始<strong class="lb iu">多元</strong>直方图而创建的一种方法。</p><p id="d2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是如何工作的？好吧，让我们从一个单一的，<strong class="lb iu">单变量直方图</strong>开始。对这种直方图进行采样的最佳方式是将 0–1 区间分割成子区间，子区间的宽度与直方图条的<strong class="lb iu">概率</strong>相同。然后，我们从 0 和 1 之间的均匀分布生成一个伪随机数。我们将根据随机数的位置从直方图中选择一个值。然后我们想重复多少次就重复多少次。</p><p id="c36f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图让一切都变得更加清晰。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c1a2bf616ca7ee5229e11b6e29b4d0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*xz9FH_MJdwchBbiPWQVLsQ.jpeg"/></div></figure><p id="bbbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这张图表是由以下代码制成的:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="26a8" class="nk md it ng b gy nl nm l nn no">library(“ggplot2”)</span><span id="7587" class="nk md it ng b gy np nm l nn no">s = c(rep(“A”,50),rep(“B”,35),rep(“C”,15))</span><span id="96cb" class="nk md it ng b gy np nm l nn no">d = as.data.frame(table(s))</span><span id="09f1" class="nk md it ng b gy np nm l nn no">p = ggplot(d,aes(x=s,y=Freq,fill=s)) + geom_bar(stat=”identity”)+<br/> geom_text(aes(label=Freq),vjust=1.6) +<br/> theme(legend.position = “none”)<br/> <br/>p</span></pre><p id="b6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何在 R 中进行采样？强大的<strong class="lb iu">样本</strong>功能可以指定赋予每个值的<strong class="lb iu">权重</strong>，即概率。</p><p id="f842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们想要该数据的 10 个样本观察值，我们可以简单地使用这一行代码:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="b57c" class="nk md it ng b gy nl nm l nn no">sample(d$s,replace = TRUE,prob = d$Freq,10)</span></pre><p id="1af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式，我们能够创建具有高置信度的直方图，<strong class="lb iu">迫使样本</strong>遵循相同的总体分布。</p><h1 id="31ab" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">多元方法</h1><p id="ec8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">多元直方图怎么样？嗯，多元直方图只是许多直方图的<strong class="lb iu">层次结构</strong>，通过<strong class="lb iu">条件概率</strong>的<strong class="lb iu">贝叶斯公式</strong>粘合在一起。我们可以轻松地将多变量直方图转换为单变量直方图<strong class="lb iu">来标记</strong>每个聚类组合，但是如果我们有太多的列，那么在计算上<strong class="lb iu">很难</strong>将它们全部聚集起来。当我试图在 200 列上聚合 3000 万条记录的数据集时，我亲眼目睹了强大的 RDBMS 的失败。</p><p id="0ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过下面的过程，我们可以独立地管理每一列<strong class="lb iu"/>，而不用关心它们的数量，也不会让我们的 CPU 遭受太多的痛苦。</p><p id="2c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序如下:</p><ul class=""><li id="6738" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><strong class="lb iu">根据第一个变量聚集整个数据集(即根据第一个变量创建数据集的直方图)。</strong></li><li id="5806" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><strong class="lb iu">根据用于单变量直方图的相同技术，选择</strong>该变量的一个值。</li><li id="d89f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><strong class="lb iu">过滤</strong>整个数据集，仅考虑那些在所选变量上具有该值的记录。</li><li id="c922" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">继续处理第二个变量(聚合并选择一个值)等等，直到最后一个变量。由于过滤器的作用，每一步都会产生一个<strong class="lb iu">更小的</strong>数据集。</li><li id="5147" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">最后，您有一个非常小的数据集，但没有变量留给切片。此时，您可以从该数据集中选择一个<strong class="lb iu">随机</strong>记录<strong class="lb iu">统一</strong>并重复整个过程，直到您得到想要的样本大小。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/53989bb9cd5750d76079808cdef7e663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bgzbQ4FSgyQHSIhuqLT7g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Stratified sampling procedure</figcaption></figure><h1 id="0e6e" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">连续值和分类值</h1><p id="5910" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">会发生什么呢？有些变量是连续的，有些是分类的？嗯，问题现在变得非常困难。我能给你的唯一答案是<strong class="lb iu">用直方图标准(如斯特奇斯或赖斯的)离散化</strong>连续变量。</p><p id="cd0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定数据集中的<em class="of"> n </em>点，用于直方图的仓的数量<em class="of"> k </em>通过以下公式从两个规则中导出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/b13a7e10e2ba04bc70c2b35be480804f.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/0*llhz9-MseaFg99C2.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Sturges’ rule</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b292116dbec897a57d835cdc359c9162.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/0*u_A48CGZjNEX6XT9.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Rice rule</figcaption></figure><p id="ec14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看他们的行动。使用下面的代码，我们将从对数正态分布(本质上是偏斜的)中创建 10000 个随机数，绘制原始密度函数和由这两个规则生成的直方图。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="274a" class="nk md it ng b gy nl nm l nn no">x = rlnorm(10000,0,0.5)<br/>windows()<br/>layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))</span><span id="40da" class="nk md it ng b gy np nm l nn no">plot(seq(0,3,length.out=1000),dlnorm(seq(0,3,length.out=1000),0,0.5),xlab="x",ylab="Density",main="Lognormal distribution with mean = 0 and sd = 0.5")</span><span id="d4d6" class="nk md it ng b gy np nm l nn no">hist(x,probability = TRUE,main="Sturges rule",xlim=c(0,3))</span><span id="d586" class="nk md it ng b gy np nm l nn no">hist(x,breaks=2*length(x)**(1/3),probability = TRUE,main="Rice rule",xlim=c(0,3))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c78017e2cc457372832314e30c46318b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u28pgcTE3BXxOwnGPas0rw.png"/></div></div></figure><p id="2b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，莱斯法则能够非常有效地再现原始概率分布形状<strong class="lb iu"/>。这就是为什么它是我个人最喜欢的直方图标准，我总是用它来离散数值变量。</p><h1 id="4497" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">R 中的一个例子</h1><p id="b508" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在是时候让所有的理论在 r 变成实践了。</p><p id="568d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将模拟一些数据，确定维度和所需的样本大小:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="5c94" class="nk md it ng b gy nl nm l nn no"># Generate a random 10000 records data frame<br/>set.seed(1)<br/>n = 1000<br/>d = data.frame(<br/>    a = sample(c(1,NA),replace=TRUE,n),<br/>    b = sample(c("a 1","b 2","c 3"),replace=TRUE,n),<br/>    c = c(runif(n-100,0,1),rep(NA,100)),<br/>    id = 1:n<br/>  )</span><span id="caac" class="nk md it ng b gy np nm l nn no"># Remove the useless "id" column<br/>dimensions = setdiff(names(d),"id")</span><span id="ff9e" class="nk md it ng b gy np nm l nn no"># Desired sample size<br/>n_sample = 100</span></pre><p id="b01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们执行分层采样，目标是用样本<strong class="lb iu">填充<strong class="lb iu">生成的</strong>数据帧，而不重复</strong>。为了应用最后一条规则，我们将使用强大的<strong class="lb iu"> sqldf </strong>库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="beba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在“生成”的数据帧包含了我们想要的样本。</p><h1 id="4b89" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">结论</h1><p id="b281" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我介绍了数据科学家应该知道的最重要的<strong class="lb iu">采样技术。记住:一个生成良好的样本真的可以<strong class="lb iu">在机器学习中发挥作用</strong>，因为它可以让我们用更少的数据工作，而不会失去统计意义。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d7fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Gianluca Malato 是意大利的一名小说作家和数据科学家。他的书可以在</strong> <a class="ae ky" href="https://www.amazon.it/Gianluca-Malato/e/B076CHTG3W?_encoding=UTF8&amp;pd_rd_i=B07D7HG8V8&amp;pd_rd_r=d34f8c07-0ef6-11e9-8c18-03e9e1f87d64&amp;pd_rd_w=PjgeY&amp;pd_rd_wg=3XHRC&amp;pf_rd_p=466c5af4-0171-4b17-9b3f-b4036a90f75d&amp;pf_rd_r=VYXNVD02NTB20Y1QS4JG" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">亚马逊</strong> </a> <strong class="lb iu">上找到，他的文章可以在</strong> <a class="ae ky" href="https://medium.com/@gianlucamalato" rel="noopener"> <strong class="lb iu">中型</strong> </a> <strong class="lb iu">上找到。</strong></p></div></div>    
</body>
</html>