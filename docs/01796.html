<html>
<head>
<title>Market Basket Analysis with recommenderlab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带推荐人的购物篮分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/market-basket-analysis-with-recommenderlab-5e8bdc0de236?source=collection_archive---------9-----------------------#2019-03-25">https://towardsdatascience.com/market-basket-analysis-with-recommenderlab-5e8bdc0de236?source=collection_archive---------9-----------------------#2019-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我对购物篮分析的看法——第 2 部分，共 3 部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a04e6232f85fa51bbf60a39c14e1ee62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5UpDgPtdrZtYrJqd"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@victoriano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Victoriano Izquierdo</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="e3bd" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><span class="l ls lt lu bm lv lw lx ly lz di"> O </span> verview</h2><p id="5163" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">最近我想学习一些新的东西，并挑战自己进行端到端的<strong class="mc ir">市场篮子分析</strong>。为了继续挑战自己，我决定将我的努力成果展示给数据科学界。</p><p id="e99d" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">这是<strong class="mc ir">三柱</strong>中的<strong class="mc ir">第二柱</strong>，排列如下:</p><blockquote class="my mz na"><p id="83ba" class="ma mb nb mc b md mt jr mf mg mu ju mi nc mv mk ml nd mw mn mo ne mx mq mr ms ij bi translated"><strong class="mc ir"> <em class="iq">第一部分</em> </strong> <em class="iq">:(可以在这里找到</em><a class="ae kv" rel="noopener" target="_blank" href="/clean-a-complex-dataset-for-modelling-with-recommendation-algorithms-c977f7ba28b1"><strong class="mc ir"><em class="iq"/></strong></a><em class="iq">)用推荐算法<br/> </em> <strong class="mc ir"> <em class="iq">第二部分</em> </strong> <em class="iq">:用</em> <strong class="mc ir"> <em class="iq">推荐器 lab </em> </strong> <em class="iq"> R 包<br/>应用各种产品推荐模型</em></p></blockquote><h2 id="af0c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">加载包</h2><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="f01e" class="kw kx iq ng b gy nk nl l nm nn"># Importing libraries<br/>library(data.table)<br/>library(tidyverse)            <br/>library(knitr)<br/>library(recommenderlab)</span></pre><h2 id="1ee9" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">数据</h2><p id="fe1c" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">为了进行分析，我将使用在第 1 部分<a class="ae kv" rel="noopener" target="_blank" href="/clean-a-complex-dataset-for-modelling-with-recommendation-algorithms-c977f7ba28b1"><strong class="mc ir"/></a>中准备和清理的<code class="fe no np nq ng b">retail</code>数据集。如果你想继续这篇文章，确保你得到了<a class="ae kv" href="http://archive.ics.uci.edu/ml/datasets/online+retail" rel="noopener ugc nofollow" target="_blank">数据集</a>并运行第 1 部分的<a class="ae kv" href="https://github.com/DiegoUsaiUK/Market_Basket_Analysis/blob/master/Market_Basket_Analysis_Part1.R" rel="noopener ugc nofollow" target="_blank"> R 代码，你可以在我的</a><a class="ae kv" href="https://github.com/DiegoUsaiUK/Market_Basket_Analysis" rel="noopener ugc nofollow" target="_blank"> Github 简介</a>中找到。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="972e" class="kw kx iq ng b gy nk nl l nm nn">glimpse(retail)<br/>## Observations: 528,148<br/>## Variables: 10<br/>## $ InvoiceNo   &lt;dbl&gt; 536365, 536365, 536365, 536365, ...<br/>## $ StockCode   &lt;chr&gt; "85123A", "71053", "84406B", "...<br/>## $ Description &lt;fct&gt; WHITE HANGING HEART T-LIGHT HOLDER, ...<br/>## $ Quantity    &lt;dbl&gt; 6, 6, 8, 6, 6, 2, 6, 6, 6, 32, 6, 6, 8, ...<br/>## $ InvoiceDate &lt;dttm&gt; 2010-12-01 08:26:00, 2010-12-01 08:26:00, 2010-12...<br/>## $ UnitPrice   &lt;dbl&gt; 2.55, 3.39, 2.75, 3.39, 3.39, 7.65, ....<br/>## $ CustomerID  &lt;dbl&gt; 17850, 17850, 17850, 17850, 17850, ...<br/>## $ Country     &lt;fct&gt; United Kingdom, United Kingdom, ...<br/>## $ Date        &lt;date&gt; 2010-12-01, 2010-12-01, 2010-12-01, ...<br/>## $ Time        &lt;fct&gt; 08:26:00, 08:26:00, 08:26:00, 08:26:00, ...</span></pre><h2 id="070c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">系统模型化</h2><p id="bbb2" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">对于这个项目的分析部分，我使用的是<a class="ae kv" href="https://cran.r-project.org/web/packages/recommenderlab/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="mc ir">re commender lab</strong></a>，这是一个 R 包，它提供了一个方便的框架来评估和比较各种推荐算法，并快速建立最适合的方法。</p><h2 id="c1be" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建评级矩阵</h2><p id="2756" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">在开始之前，我需要在一个<em class="nb">评级矩阵</em>中安排购买历史，订单按行排列，产品按列排列。这种格式通常被称为<em class="nb"> user_item matrix </em>，因为<em class="nb">“用户”</em>(例如客户或订单)往往位于行上，而<em class="nb">“项目”</em>(例如产品)位于列上。</p><p id="7799" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated"><strong class="mc ir">推荐者实验室</strong>接受两种类型的评级矩阵用于建模:</p><ul class=""><li id="8b02" class="nr ns iq mc b md mt mg mu lf nt lj nu ln nv ms nw nx ny nz bi translated"><strong class="mc ir">实际评分矩阵</strong>由实际用户评分组成，需要标准化。</li><li id="53ad" class="nr ns iq mc b md oa mg ob lf oc lj od ln oe ms nw nx ny nz bi translated"><strong class="mc ir">二进制评级矩阵</strong>，由<strong class="mc ir"> 0 的</strong>和<strong class="mc ir"> 1 的</strong>组成，其中<strong class="mc ir"> 1 的</strong>表示产品是否被购买。这是分析所需的矩阵类型，不需要标准化。</li></ul><p id="93cf" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">但是，在创建评级矩阵时，很明显有些订单不止一次包含相同的商品，如下例所示。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="97cd" class="kw kx iq ng b gy nk nl l nm nn"># Filtering by an order number which contains the same stock code more than once</span><span id="c14c" class="kw kx iq ng b gy of nl l nm nn">retail %&gt;% <br/>  filter(InvoiceNo == 557886 &amp; StockCode == 22436) %&gt;% <br/>  select(InvoiceNo, StockCode, Quantity, UnitPrice, CustomerID)</span><span id="4990" class="kw kx iq ng b gy of nl l nm nn">## # A tibble: 2 x 5<br/>##   InvoiceNo StockCode Quantity UnitPrice CustomerID<br/>##       &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;<br/>## 1    557886 22436            1      0.65      17799<br/>## 2    557886 22436            3      0.65      17799</span></pre><p id="71ce" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">向<a class="ae kv" href="http://archive.ics.uci.edu/ml/index.php" rel="noopener ugc nofollow" target="_blank"> <strong class="mc ir"> UCI 机器学习库</strong> </a>捐赠该数据集的公司可能有一个订单处理系统，该系统允许将一个项目多次添加到同一订单中。对于这个分析，我只需要知道一个项目是否包含在一个订单中，因此需要删除这些重复的项目。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="37b2" class="kw kx iq ng b gy nk nl l nm nn">retail &lt;- retail %&gt;% <br/># Create unique identifier<br/>    mutate(InNo_Desc = paste(InvoiceNo, Description, sep = ' ')) </span><span id="e173" class="kw kx iq ng b gy of nl l nm nn"># Filter out duplicates and drop unique identifier<br/>    retail &lt;- retail[!duplicated(retail$InNo_Desc), ] %&gt;% <br/>    select(-InNo_Desc)</span><span id="7ece" class="kw kx iq ng b gy of nl l nm nn"># CHECK:  total row count - 517,354</span></pre><p id="4d27" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">我现在可以创建评级矩阵。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="9bb6" class="kw kx iq ng b gy nk nl l nm nn">ratings_matrix &lt;- retail %&gt;%<br/># Select only needed variables<br/>  select(InvoiceNo, Description) %&gt;% </span><span id="82dc" class="kw kx iq ng b gy of nl l nm nn"># Add a column of 1s<br/>  mutate(value = 1) %&gt;%</span><span id="e22a" class="kw kx iq ng b gy of nl l nm nn"># Spread into user-item format<br/>  spread(Description, value, fill = 0) %&gt;%<br/>  select(-InvoiceNo) %&gt;%</span><span id="935e" class="kw kx iq ng b gy of nl l nm nn"># Convert to matrix<br/>  as.matrix() %&gt;%</span><span id="5fe1" class="kw kx iq ng b gy of nl l nm nn"># Convert to recommenderlab class 'binaryRatingsMatrix'<br/>  as("binaryRatingMatrix")</span><span id="37d7" class="kw kx iq ng b gy of nl l nm nn">ratings_matrix<br/>## 19792 x 4001 rating matrix of class 'binaryRatingMatrix' with 517354 ratings.</span></pre><h2 id="3d55" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">评估方案和模型验证</h2><p id="4f97" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">为了确定模型的有效性，推荐者实验室实施了许多评估方案。在这个<code class="fe no np nq ng b">scheme</code>中，我选择<em class="nb"> train = 0.8 </em>进行 80/20 训练/测试分割，将数据分割成一个训练和一个测试集。我还设置了<em class="nb"> method = "cross" </em>和<em class="nb"> k = 5 </em>进行 5 重交叉验证。这意味着数据被分成 k 个大小相等的子集，80%的数据用于训练，剩下的 20%用于评估。模型被递归估计 5 次，每次使用不同的训练/测试分割，这确保了所有用户和项目都被考虑用于训练和测试。然后可以对结果进行平均，以产生单个评估集。</p><p id="f610" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">选择<em class="nb"> given = -1 </em>意味着对于测试用户来说，除了 1 个项目外，所有随机选择的项目都被保留进行评估。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c37f" class="kw kx iq ng b gy nk nl l nm nn">scheme &lt;- ratings_matrix %&gt;% <br/>  evaluationScheme(method = "cross",<br/>                   k      = 5, <br/>                   train  = 0.8,  <br/>                   given  = -1)</span><span id="a2dd" class="kw kx iq ng b gy of nl l nm nn">scheme<br/>## Evaluation scheme using all-but-1 items<br/>## Method: 'cross-validation' with 5 run(s).<br/>## Good ratings: NA<br/>## Data set: 19792 x 4001 rating matrix of class 'binaryRatingMatrix' with 517354 ratings.</span></pre><h2 id="3fec" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置算法列表</h2><p id="1c38" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated"><strong class="mc ir">推荐实验室</strong>的主要特性之一是能够一次评估多个算法。首先，我用我想要估计的<code class="fe no np nq ng b">algorithms</code>创建一个列表，指定所有的模型参数。在这里，我考虑在<strong class="mc ir">二元评级矩阵上评估的方案。</strong>我包含了<strong class="mc ir">随机项目</strong>算法，用于基准测试。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="7db8" class="kw kx iq ng b gy nk nl l nm nn">algorithms &lt;- list(<br/>  "association rules" = list(name  = "AR", <br/>                        param = list(supp = 0.01, conf = 0.01)),<br/>  "random items"      = list(name  = "RANDOM",  param = NULL),<br/>  "popular items"     = list(name  = "POPULAR", param = NULL),<br/>  "item-based CF"     = list(name  = "IBCF", param = list(k = 5)),<br/>  "user-based CF"     = list(name  = "UBCF", <br/>                        param = list(method = "Cosine", nn = 500))<br/>                   )</span></pre><h2 id="47eb" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">评估模型</h2><p id="da00" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">我现在要做的就是将<code class="fe no np nq ng b">scheme</code>和<code class="fe no np nq ng b">algoritms</code>传递给<code class="fe no np nq ng b">evaluate()</code>函数，选择<em class="nb"> type = topNList </em>来评估前 N 个产品推荐列表，并使用参数<em class="nb"> n = c(1，3，5，10，15，20) </em>指定要计算多少个推荐。</p><p id="1fde" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated"><strong class="mc ir">请注意</strong>基于 CF 的算法每种都需要几分钟来估计。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c89f" class="kw kx iq ng b gy nk nl l nm nn">results &lt;- recommenderlab::evaluate(scheme, <br/>                                    algorithms, <br/>                                    type  = "topNList", <br/>                                    n     = c(1, 3, 5, 10, 15, 20)<br/>                                    )</span><span id="66ea" class="kw kx iq ng b gy of nl l nm nn">## AR run fold/sample [model time/prediction time]<br/>##   1  [0.32sec/73.17sec] <br/>##   2  [0.24sec/72.72sec] <br/>##   3  [0.23sec/72.27sec] <br/>##   4  [0.24sec/72.82sec] <br/>##   5  [0.24sec/72.69sec] <br/>## RANDOM run fold/sample [model time/prediction time]<br/>##   1  [0sec/20.08sec] <br/>##   2  [0sec/19.01sec] <br/>##   3  [0sec/18.69sec] <br/>##   4  [0sec/19.26sec] <br/>##   5  [0.02sec/19.41sec] <br/>## POPULAR run fold/sample [model time/prediction time]<br/>##   1  [0.01sec/15.94sec] <br/>##   2  [0sec/16.34sec] <br/>##   3  [0sec/15.91sec] <br/>##   4  [0.02sec/16.02sec] <br/>##   5  [0.01sec/15.86sec] <br/>## IBCF run fold/sample [model time/prediction time]<br/>##   1  [515.11sec/3.11sec] <br/>##   2  [513.94sec/2.88sec] <br/>##   3  [509.98sec/3.05sec] <br/>##   4  [513.94sec/3.13sec] <br/>##   5  [512.58sec/2.81sec] <br/>## UBCF run fold/sample [model time/prediction time]<br/>##   1  [0sec/296.54sec] <br/>##   2  [0sec/291.54sec] <br/>##   3  [0sec/292.68sec] <br/>##   4  [0sec/293.33sec] <br/>##   5  [0sec/300.35sec]</span></pre><p id="17fd" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">输出存储为包含所有评估的列表。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="7b71" class="kw kx iq ng b gy nk nl l nm nn">results</span><span id="a40d" class="kw kx iq ng b gy of nl l nm nn">## List of evaluation results for 5 recommenders:<br/>## Evaluation results for 5 folds/samples using method 'AR'.<br/>## Evaluation results for 5 folds/samples using method 'RANDOM'.<br/>## Evaluation results for 5 folds/samples using method 'POPULAR'.<br/>## Evaluation results for 5 folds/samples using method 'IBCF'.<br/>## Evaluation results for 5 folds/samples using method 'UBCF'.</span></pre><h2 id="2712" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">想象结果</h2><p id="9286" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated"><strong class="mc ir">推荐者实验室</strong>有一个基本的<code class="fe no np nq ng b">plot</code>功能，可用于比较型号性能。然而，我更喜欢把结果整理成整齐的格式，以增加灵活性和图表定制。</p><p id="0e64" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">首先，我以一种方便的格式安排一个模型的混淆矩阵输出。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="87bf" class="kw kx iq ng b gy nk nl l nm nn"># Pull into a list all confusion matrix information for one model <br/>tmp &lt;- results$`user-based CF` %&gt;%<br/>  getConfusionMatrix()  %&gt;%  <br/>  as.list() </span><span id="fd9b" class="kw kx iq ng b gy of nl l nm nn"># Calculate average value of 5 cross-validation rounds <br/>  as.data.frame( Reduce("+",tmp) / length(tmp)) %&gt;% </span><span id="07e5" class="kw kx iq ng b gy of nl l nm nn"># Add a column to mark the number of recommendations calculated<br/>  mutate(n = c(1, 3, 5, 10, 15, 20)) %&gt;%</span><span id="3aec" class="kw kx iq ng b gy of nl l nm nn"># Select only columns needed and sorting out order <br/>  select('n', 'precision', 'recall', 'TPR', 'FPR')</span><span id="aaad" class="kw kx iq ng b gy of nl l nm nn">##    n  precision     recall        TPR          FPR<br/>## 1  1 0.06858938 0.07420981 0.07420981 0.0002327780<br/>## 2  3 0.04355442 0.14137351 0.14137351 0.0007171045<br/>## 3  5 0.03354715 0.18148235 0.18148235 0.0012076795<br/>## 4 10 0.02276376 0.24627561 0.24627561 0.0024423093<br/>## 5 15 0.01762715 0.28605934 0.28605934 0.0036827205<br/>## 6 20 0.01461690 0.31627924 0.31627924 0.0049253407</span></pre><p id="ac5a" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">然后，我把前面的步骤代入一个公式。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="4275" class="kw kx iq ng b gy nk nl l nm nn">avg_conf_matr &lt;- function(results) {<br/>  tmp &lt;- results %&gt;%<br/>    getConfusionMatrix()  %&gt;%  <br/>    as.list() <br/>    as.data.frame(Reduce("+",tmp) / length(tmp)) %&gt;% <br/>    mutate(n = c(1, 3, 5, 10, 15, 20)) %&gt;%<br/>    select('n', 'precision', 'recall', 'TPR', 'FPR') <br/>}</span></pre><p id="f9c7" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">接下来，我使用<code class="fe no np nq ng b">purrr</code>包中的<code class="fe no np nq ng b">map()</code>函数以一种整齐的格式获得所有结果，为图表制作做好准备。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="74e9" class="kw kx iq ng b gy nk nl l nm nn"># Using map() to iterate function across all models<br/>results_tbl &lt;- results %&gt;%<br/>  map(avg_conf_matr) %&gt;% </span><span id="4374" class="kw kx iq ng b gy of nl l nm nn"># Turning into an unnested tibble<br/>  enframe() %&gt;%</span><span id="0da5" class="kw kx iq ng b gy of nl l nm nn"># Unnesting to have all variables on same level<br/>  unnest()</span><span id="6a3a" class="kw kx iq ng b gy of nl l nm nn">results_tbl</span><span id="5ae3" class="kw kx iq ng b gy of nl l nm nn">## # A tibble: 30 x 6<br/>##    name                  n precision   recall      TPR      FPR<br/>##    &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;<br/>##  1 association rules     1  0.0428   0.0380   0.0380   0.000197<br/>##  2 association rules     3  0.0306   0.0735   0.0735   0.000579<br/>##  3 association rules     5  0.0266   0.0979   0.0979   0.000944<br/>##  4 association rules    10  0.0224   0.139    0.139    0.00179 <br/>##  5 association rules    15  0.0202   0.162    0.162    0.00255 <br/>##  6 association rules    20  0.0188   0.176    0.176    0.00325 <br/>##  7 random items          1  0.000202 0.000219 0.000219 0.000250<br/>##  8 random items          3  0.000253 0.000820 0.000820 0.000750<br/>##  9 random items          5  0.000242 0.00131  0.00131  0.00125 <br/>## 10 random items         10  0.000222 0.00241  0.00241  0.00250 <br/>## # ... with 20 more rows</span></pre><h2 id="fbab" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">受试者工作特征曲线</h2><p id="9135" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">可以使用 ROC 曲线来比较分类模型的性能，该曲线绘制了<em class="nb">真阳性率</em> (TPR)与<em class="nb">假阳性率</em> (FPR)。</p><p id="0354" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">基于项目的协同过滤模型是明显的赢家，因为它在任何给定的 FPR 水平上都实现了最高的 TPR。这意味着，对于相同级别的不相关推荐(误报)，该模型正在产生最高数量的相关推荐(真阳性)。</p><p id="8aa3" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated"><strong class="mc ir">注意</strong>使用<code class="fe no np nq ng b">fct_reorder2()</code>按最佳最终 FPR 和 TPR 排列情节图例条目，用曲线排列它们，使情节更容易阅读。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="d668" class="kw kx iq ng b gy nk nl l nm nn">results_tbl %&gt;%<br/>  ggplot(aes(FPR, TPR, <br/>             colour = fct_reorder2(as.factor(name), <br/>                      FPR, TPR))) +<br/>  geom_line() +<br/>  geom_label(aes(label = n))  +<br/>  labs(title = "ROC curves", colour = "Model") +<br/>  theme_grey(base_size = 14)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0c4eea1be550b3058f9def9c34d58bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lBDAiETqh0vljIKZAs2jQ.png"/></div></div></figure><h2 id="9eaa" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">精确回忆曲线</h2><p id="eed1" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">另一种比较分类模型性能的常用方法是使用<strong class="mc ir">精度与召回曲线</strong>。Precision 显示模型对<em class="nb">假阳性</em>(即推荐不太可能被购买的商品)的敏感程度，而 Recall(TPR 的另一个名称)则显示模型对<em class="nb">假阴性</em>(即不推荐极有可能被购买的商品)的敏感程度。</p><p id="628e" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">通常，我们关心的是准确预测哪些商品更有可能被购买，因为这将对销售和收入产生积极影响。换句话说，我们希望在<strong class="mc ir">精度</strong>相同的情况下，最大化<strong class="mc ir">召回</strong>(或最小化 FNs)。</p><p id="9bc6" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">该图证实了<strong class="mc ir">基于项目的协作过滤器</strong> (IBCF)是最好的模型，因为它对于任何给定的精度水平都具有更高的召回率。这意味着<strong class="mc ir"> IBCF </strong>将所有级别的第一手资料的 FNs 降至最低(即不建议购买可能性很高的物品)。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="1b74" class="kw kx iq ng b gy nk nl l nm nn">results_tbl %&gt;%<br/>  ggplot(aes(recall, precision, <br/>             colour = fct_reorder2(as.factor(name),  <br/>                      precision, recall))) +<br/>  geom_line() +<br/>  geom_label(aes(label = n))  +<br/>  labs(title = "Precision-Recall curves", colour = "Model") +<br/>  theme_grey(base_size = 14)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/e8a805e9071955f5db29bb7d129b7f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVdqMNp3Tg2YCmA48SQY_g.png"/></div></div></figure><h2 id="5604" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">对新用户的预测</h2><p id="44c7" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">最后一步是生成具有最佳性能模型的预测。为此，我需要创建一个虚构的采购订单。</p><p id="9c7f" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">首先，我创建了一个包含 6 个随机选择的产品的字符串。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="859a" class="kw kx iq ng b gy nk nl l nm nn">customer_order &lt;- c("GREEN REGENCY TEACUP AND SAUCER",<br/>                     "SET OF 3 BUTTERFLY COOKIE CUTTERS",<br/>                     "JAM MAKING SET WITH JARS",<br/>                     "SET OF TEA COFFEE SUGAR TINS PANTRY",<br/>                     "SET OF 4 PANTRY JELLY MOULDS")</span></pre><p id="dcf1" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">接下来，我将这个订单以一种<strong class="mc ir">推荐者 lab </strong>接受的格式放置。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="3991" class="kw kx iq ng b gy nk nl l nm nn">new_order_rat_matrx &lt;- retail %&gt;% </span><span id="2cdd" class="kw kx iq ng b gy of nl l nm nn"># Select item descriptions from retail dataset<br/>  select(Description) %&gt;% <br/>  unique() %&gt;% </span><span id="2aed" class="kw kx iq ng b gy of nl l nm nn"># Add a 'value' column with 1's for customer order items<br/>  mutate(value = as.numeric(Description %in% customer_order)) %&gt;% </span><span id="b5b7" class="kw kx iq ng b gy of nl l nm nn"># Spread into sparse matrix format<br/>  spread(key = Description, value = value) %&gt;% </span><span id="32a4" class="kw kx iq ng b gy of nl l nm nn"># Change to a matrix<br/>  as.matrix() %&gt;% </span><span id="0167" class="kw kx iq ng b gy of nl l nm nn"># Convert to recommenderlab class 'binaryRatingsMatrix'<br/>  as("binaryRatingMatrix")</span></pre><p id="e1be" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">现在，我可以创建一个<code class="fe no np nq ng b">Recommender</code>。我使用<code class="fe no np nq ng b">getData</code>来检索训练数据，并设置<em class="nb"> method = "IBCF" </em>来选择性能最好的模型(“基于项目的协同过滤”)。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="cb66" class="kw kx iq ng b gy nk nl l nm nn">recomm &lt;- Recommender(getData(scheme, 'train'), <br/>                       method = "IBCF",  <br/>                       param = list(k = 5))</span><span id="b20a" class="kw kx iq ng b gy of nl l nm nn">recomm</span><span id="2420" class="kw kx iq ng b gy of nl l nm nn">## Recommender of type 'IBCF' for 'binaryRatingMatrix' <br/>## learned using 15832 users.</span></pre><p id="0766" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">最后，我可以将<code class="fe no np nq ng b">Recommender</code>和生成的订单传递给<code class="fe no np nq ng b">predict</code>函数，为新客户创建前 10 名推荐列表。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="4207" class="kw kx iq ng b gy nk nl l nm nn">pred &lt;- predict(recomm, <br/>                newdata = new_order_rat_matrx, <br/>                n       = 10)</span></pre><p id="c0e4" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated">最后，建议的项目可以作为一个列表进行检查</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="8f26" class="kw kx iq ng b gy nk nl l nm nn">as(pred, 'list')</span><span id="0ca5" class="kw kx iq ng b gy of nl l nm nn">## $`1`<br/>##  [1] "ROSES REGENCY TEACUP AND SAUCER"   <br/>##  [2] "PINK REGENCY TEACUP AND SAUCER"    <br/>##  [3] "SET OF 3 HEART COOKIE CUTTERS"     <br/>##  [4] "REGENCY CAKESTAND 3 TIER"          <br/>##  [5] "JAM MAKING SET PRINTED"            <br/>##  [6] "RECIPE BOX PANTRY YELLOW DESIGN"   <br/>##  [7] "SET OF 3 CAKE TINS PANTRY DESIGN"  <br/>##  [8] "GINGERBREAD MAN COOKIE CUTTER"     <br/>##  [9] "3 PIECE SPACEBOY COOKIE CUTTER SET"<br/>## [10] "SET OF 6 SPICE TINS PANTRY DESIGN"</span></pre><h1 id="1524" class="oh kx iq bd ky oi oj ok lb ol om on le jw oo jx li jz op ka lm kc oq kd lq or bi translated">评论</h1><p id="26c3" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">这就结束了这个项目的建模和评估部分，我发现这很简单，也很愉快。<strong class="mc ir"> recommenderlab </strong>直观易用，我特别欣赏它同时评估和比较几种分类算法的能力。总之，我已经学会了如何在 R 中使用<strong class="mc ir"> recommenderlab </strong>进行市场购物篮分析，以解释结果并选择表现最佳的模型。</p><h2 id="3741" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">代码库</h2><p id="cf1c" class="pw-post-body-paragraph ma mb iq mc b md me jr mf mg mh ju mi lf mj mk ml lj mm mn mo ln mp mq mr ms ij bi translated">完整的 R 代码可以在<a class="ae kv" href="https://github.com/DiegoUsaiUK/Market_Basket_Analysis" rel="noopener ugc nofollow" target="_blank">我的 GitHub 简介</a>中找到</p><h2 id="679c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考</h2><ul class=""><li id="9e6e" class="nr ns iq mc b md me mg mh lf os lj ot ln ou ms nw nx ny nz bi translated">有关推荐的实验室包，请参见:<a class="ae kv" href="https://cran.r-project.org/package=recommenderlab" rel="noopener ugc nofollow" target="_blank">https://cran.r-project.org/package=recommenderlab</a></li><li id="ba0f" class="nr ns iq mc b md oa mg ob lf oc lj od ln oe ms nw nx ny nz bi translated">关于推荐者实验室软件包简介，请参见:<a class="ae kv" href="https://cran.r-project.org/web/packages/recommenderlab/vignettes/recommenderlab.pdf" rel="noopener ugc nofollow" target="_blank">https://cran . r-project . org/web/packages/re commender lab/vignettes/re commender lab . pdf</a></li></ul></div><div class="ab cl ov ow hu ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="ij ik il im in"><p id="7554" class="pw-post-body-paragraph ma mb iq mc b md mt jr mf mg mu ju mi lf mv mk ml lj mw mn mo ln mx mq mr ms ij bi translated"><em class="nb">原载于 2019 年 3 月 25 日</em><a class="ae kv" href="https://diegousai.io/2019/03/market-basket-analysis-part-2-of-3/" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://diegousei . io</em></a><em class="nb">。</em></p></div></div>    
</body>
</html>