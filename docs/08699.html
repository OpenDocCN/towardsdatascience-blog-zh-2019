<html>
<head>
<title>How to Build a Reusable Custom NLP Pipeline with Scikit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Scikit-Learn 构建可重用的自定义 NLP 管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-reusable-nlp-code-pipeline-with-scikit-learn-with-an-emphasis-on-feature-504f8aa14699?source=collection_archive---------21-----------------------#2019-11-22">https://towardsdatascience.com/how-to-build-a-reusable-nlp-code-pipeline-with-scikit-learn-with-an-emphasis-on-feature-504f8aa14699?source=collection_archive---------21-----------------------#2019-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d836" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重点是功能工程和培训</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/949032d98587e37c0938b1370b944260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfjvR5gGFIQAluxjBMBq-Q.jpeg"/></div></div></figure><p id="91d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">机器学习代码管道最重要的特征之一是可重用性。一个可重用、可共享和可扩展的管道将通过对程序流强制一致地使用直观的结构元素来确保流程和代码的完整性，并因此可以增强数据科学家的开发流程，该流程本质上是迭代的。在本文中，我将演示<strong class="kw iu">如何使用 scikit-learn 从头构建一个定制的机器学习代码管道，重点是以下两个组件:</strong></p><ol class=""><li id="c897" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">特性化</strong>管道，支持灵活定义和选择特性</li><li id="f881" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">一个<strong class="kw iu">训练</strong>管道，它结合了用于后续步骤的特征化管道的输出:向量化和模型训练</li></ol><p id="f466" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两个组件都以类似的方式利用类继承；也就是说，它们的特征在于一个底层的类结构，从这个结构中可以派生出更具体的类来解决不同种类的监督学习问题或项目需求。作为本文的一个额外收获，在第 2 节中，我将触及与继承相关的一个强大的概念，即<strong class="kw iu">抽象方法</strong>，并说明它如何使所提出的管道设计如此直观和易于使用。</p><h1 id="b364" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">1.特征管线</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/ce33c3c336bd0aaeade6b576e6a9082c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTMg5_SJG8BKz7wqMk_yIA.jpeg"/></div></div></figure><p id="d63a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个典型的 NLP 任务需要大量的特征工程，这个过程包括为训练模型准备合适的输入数据。该步骤可能需要将输入文本数据转换成单词包表示或多维向量，或者它可能涉及编写更原始的用户定义函数来提取诸如句子长度标准偏差、主要动词之前的单词数(句法复杂性的粗略度量)、可读性分数等特征的值。在任何给定的项目中，可以选择任意数量的这种特征来训练模型或首先确定特征重要性、减少维度或进行消融研究。</p><p id="42dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了方便、控制和灵活地选择或测试特性，你可以想象有一种<strong class="kw iu">“特性库”，当你需要它们的时候，你可以从中提取你(或你的队友)曾经写过的任何特性</strong>。这个库可以表示为下面称为<code class="fe my mz na nb b">BaseFeaturizer</code>的类，它的每个方法都包含计算特性值的逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6bf9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们在<code class="fe my mz na nb b">BaseFeaturizer</code>中定义了这些基本方法，我们就可以派生新的类来修改这些方法或者添加新的方法。但是也许<strong class="kw iu">这些派生类最重要的属性是它们可以根据它们选择/引入的特性的<em class="mx">数量和类型而变化。</em></strong>并且该信息应该在所有派生类中以一致的方式定义，即在每个派生类的 main 方法中，我将命名为<code class="fe my mz na nb b"><strong class="kw iu">featurize</strong></code>。</p><p id="e078" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，假设我们要训练一个预测文档语法复杂性的文本分类模型，将它们分为两个离散的类:“简单”和“复杂”。这项任务的两个潜在有用的语法特征是:</p><ol class=""><li id="654f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">主要动词前的单词数</strong>:主要动词前的文本越长，该文本的语法就越复杂(可能是因为存在从句和/或主语修饰语，如从句)</li><li id="12fb" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">可读性</strong>:可读性分数越高，越复杂。(例如，在此阅读 Flesch–Kincaid 可读性测试<a class="ae ne" href="https://en.wikipedia.org/wiki/Flesch%E2%80%93Kincaid_readability_tests" rel="noopener ugc nofollow" target="_blank">。)</a></li></ol><p id="658e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(我在这个例子中有些随意地选择了这些特征，但是有各种各样的<a class="ae ne" rel="noopener" target="_blank" href="/feature-selection-techniques-in-machine-learning-with-python-f24e7da3f36e">特征选择技术</a>可以用来首先确定哪些特征是最有用的，并且只包括那些在最终训练中的特征。)</p><p id="0a78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面，<code class="fe my mz na nb b"><strong class="kw iu">SyntacticComplexityFeaturizer</strong></code>被定义为<code class="fe my mz na nb b">BaseFeaturier</code>的子类，两个特性的值在<code class="fe my mz na nb b">featurize</code>中通过调用前面在<code class="fe my mz na nb b">BaseFeaturizer</code>中定义的函数来计算。这些值存储在每个文档的<code class="fe my mz na nb b">feature_dict</code>中，而<code class="fe my mz na nb b">featurize</code>返回整个文档集的特征值映射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1953" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个<code class="fe my mz na nb b">feature_dicts</code>的例子，在<code class="fe my mz na nb b">SyntacticComplexityFeaturizer</code>的实例上调用<code class="fe my mz na nb b">featurize</code>的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="093e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">2.培训渠道</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e4470adae7d3a8afe36b725376aa6d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJixFVIuvtOvppvRb61O0g.jpeg"/></div></div></figure><p id="e1ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个特征化管道的输出自然会作为下一个组件(训练管道)的输入。这两个管道在形式上是同构的，因为后者也包含一个基础设计(类),从该基础设计可以导出更具体的训练管道来满足不同的训练要求。我把这个类命名为<code class="fe my mz na nb b">BaseTrainingPipeline</code>。<strong class="kw iu">这个类的一个重要属性是它继承了</strong> <code class="fe my mz na nb b"><strong class="kw iu">ABC</strong></code> <strong class="kw iu">(“抽象基类”的简称)</strong>，原因很快就会明了。</p><p id="f906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">BaseTrainingPipeline</code>可以用您以后可能想要访问的任何属性进行初始化，例如，<code class="fe my mz na nb b">self.y_test</code>和<code class="fe my mz na nb b">self.y_preds</code>(这些值适合存储用于评估目的)，以及<code class="fe my mz na nb b">self.models</code>(所有模型都基于相同的数据进行训练)。我在<code class="fe my mz na nb b">__init__</code>函数中定义了以下属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="be95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，该类的 main 方法<code class="fe my mz na nb b">pipeline_main</code>包含将输入文本首先转换为数字特征，然后转换为向量所需的最少代码，这些步骤在大多数受监督的 NLP 任务中都会重复。注意，两条管道(特征化和训练)通过该方法连接，因为该方法将<code class="fe my mz na nb b">FeaturizerClass</code>作为参数，例如<code class="fe my mz na nb b">SyntacticComplexityClass.</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ol class=""><li id="5120" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">一旦实例化(<code class="fe my mz na nb b">featurizer = FeaturizerClass()</code>，该对象将对数据(语料库)调用<code class="fe my mz na nb b">featurize</code>方法，返回一个特征值映射列表(第 22–23 行)。</li><li id="fdf7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">然后可以使用<code class="fe my mz na nb b">DictVectorizer</code>(第 31–33 行)将这个列表转换成 numpy 数组或矩阵(向量)。</li><li id="6fdc" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">然后，向量<code class="fe my mz na nb b">X_train</code>和<code class="fe my mz na nb b">y_train</code>可用于训练任何 scikit-learn 估计器(第 39–42 行)。</li></ol><p id="8ccb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了详细说明前面的观点，<code class="fe my mz na nb b"><strong class="kw iu">train_model</strong></code>被定义为<code class="fe my mz na nb b">BaseTrainingPipeline</code>的一个<strong class="kw iu">抽象方法</strong>(这使得它成为一个<strong class="kw iu">抽象类</strong>)。抽象方法可以用装饰器<code class="fe my mz na nb b">@abstractmethod</code>来装饰，相关部分转载如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fe98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里阅读更多关于抽象方法的内容，但简单来说:</p><blockquote class="ng nh ni"><p id="e321" class="ku kv mx kw b kx ky ju kz la lb jx lc nj le lf lg nk li lj lk nl lm ln lo lp im bi translated">抽象类是包含一个或多个抽象方法的类。抽象方法是声明的方法，但不包含实现。抽象类可以不被实例化，并且<strong class="kw iu">需要子类为抽象方法</strong>提供实现。Python 中抽象类的子类不需要实现父类的抽象方法。</p></blockquote><p id="a8ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将<code class="fe my mz na nb b">train_model</code>定义为一个抽象方法是必要的，因为它为该方法的所有实现提供了一个公共功能，这些实现由<code class="fe my mz na nb b">BaseTrainingPipeline</code>的子类提供。也就是说，因为我们将<code class="fe my mz na nb b">train_model</code>定义为<em class="mx">基类</em>的一个方法，所以我们可以从同一个类中定义的另一个方法中调用它(在我们的例子中，从<code class="fe my mz na nb b">pipeline_main</code>)，然而因为它的实现只能由<em class="mx">子类</em>提供，所以我们能够以多种不同的方式定义<code class="fe my mz na nb b">train_model</code>。这些实现可能变化的一个方面是估计器类型。</p><p id="bdac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使这一切更具体，考虑我从<code class="fe my mz na nb b">BaseTrainingPipeline</code> : <code class="fe my mz na nb b"><strong class="kw iu">ClassificationTrainingPipeline</strong></code>和<code class="fe my mz na nb b"><strong class="kw iu">RegressionTrainingPipeline</strong></code>得到的两个示例训练管道。这种分离具有直观的意义，因为一个处理目标变量为分类/离散的分类器，而另一个处理目标变量为数值/连续的回归变量。<strong class="kw iu">这允许我们使用相同的通用(训练)流水线来支持不同类型的监督学习问题，而无需重写上面</strong> <code class="fe my mz na nb b"><strong class="kw iu">pipeline_main</strong></code> <strong class="kw iu">中定义的<em class="mx">核心</em>元素和<em class="mx">可重复</em>步骤的任何部分。</strong>注意<code class="fe my mz na nb b">train_model</code>的实现在两种情况下有什么不同:在<code class="fe my mz na nb b">ClassificationTrainingPipeline</code>中，<code class="fe my mz na nb b">train_model</code>为满足特定条件的模型指定新的参数设置，即<code class="fe my mz na nb b">if algorithm == "logistic_regression"</code>(下面的第 12-19 行)，覆盖初始化模型的原始设置。<code class="fe my mz na nb b">RegressionTrainingPipeline</code>不包含这样的覆盖设置，尽管它肯定<em class="mx">可能</em>用于任何<em class="mx">其</em>初始化的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7574" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将所有这些放在一起，我们现在可以实例化这些训练管道中的一个，它将某个特征化类作为参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b70f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们运行了这段代码，<code class="fe my mz na nb b">__init__</code>属性的值将会被更新，这样我们就可以访问保存的数组，比如<code class="fe my mz na nb b">y_test</code>和<code class="fe my mz na nb b">y_preds</code>，以及模型本身(您可能想要保存)。此时，您可以考虑扩展培训管道，以支持其他步骤，如模型评估、指标报告和可视化。例如，您可以将如下方法添加到<code class="fe my mz na nb b">RegressorTrainingPipeline</code>中，以在 heldout 数据集上进行预测，并保存每次迭代训练的指标报告:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="9f49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我介绍了构建可重用、可扩展的 ML 代码管道的一步一步的过程，该管道可以很容易地适应各种 NLP 问题。设计的两个核心组件——特征管道和训练管道——在它们的基本组织中相互反映，并且通过类继承和在某些情况下的抽象方法，它们能够(1)适应灵活的特征定义和选择，以及(2)为训练不同种类的监督模型(例如，分类对回归)提供通用支持。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="0f7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2019 年 12 月更新:关于使用 scikit-learn 的<code class="fe my mz na nb b">Pipeline</code>实现您的 ML 管道的替代方法，请查看以下帖子:</p><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/the-triune-pipeline-for-three-major-transformers-in-nlp-18c14e20530"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">基于 Scikit-Learn 流水线的文本特征提取</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">使用 2010 年初选辩论记录</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div></div></div>    
</body>
</html>