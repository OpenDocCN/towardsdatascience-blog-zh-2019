# Python 中的不可变数据类型与可变数据类型

> 原文：<https://towardsdatascience.com/immutable-vs-mutable-data-types-in-python-e8a9a6fcfbdc?source=collection_archive---------0----------------------->

![](img/88e9408e35557eac7423b1a7e277f53d.png)

## 了解可变数据类型和不可变数据类型之间的区别，以及如何找出哪个是哪个！

到现在为止，你可能听说过“Python 中的一切都是对象”这句话。**对象**是数据的抽象，Python 有多种多样的数据结构，你可以用它们来表示数据，或者组合它们来创建你自己的定制数据。

Python 对数据的第一个基本区别是对象的值是否会改变。如果值可以改变，对象称为**可变**，如果值不能改变，对象称为**不可变**。

在这个速成课程中，我们将探索:

*   可变类型和不可变类型的区别
*   不同的数据类型以及如何确定它们是可变的还是不可变的

理解可变和不可变之间的区别非常重要，因为它会影响您编写的代码。

我们开始吧！

> 这个速成课程改编自 Next Tech 的**学习 Python 编程**课程，该课程使用理论和实践的混合来探索 Python 及其特性，并从 Python 初学者进步到熟练。它包括一个浏览器内沙盒环境，预装了所有必要的软件和库。这里可以免费上手[！](https://c.next.tech/2OYvckb)

# 可变与不可变

首先，理解 Python 中的每个对象都有一个 ID(或标识)、一个类型和值是很重要的，如下面的代码片段所示:

```
age = 42
print(id(age))    # id
print(type(age))  # type
print(age)        # value [Out:]
10966208
<class ‘int’>
42
```

一旦创建，对象的 ID 永远不会改变。这是它的唯一标识符，当我们想要使用它时，Python 在幕后使用它来检索对象。

类型也永远不会改变。类型告诉对象支持哪些操作，以及可以分配给它的可能值。

该值可以更改，也可以不更改。如果可以，则称该对象是可变的，如果不能，则称该对象是不可变的。

让我们来看一个例子:

```
age = 42
print(id(age))
print(type(age))
print(age)age = 43
print(age)
print(id(age)) [Out:]
10966208
<class ‘int’>
42
43
10966240
```

`age`的值变了吗？嗯，【T1 号】是一个整数，类型为`int`，是不可变的。所以，实际上在第一行，`age`是一个名字，它指向一个`int`对象，它的值是`42`。

当我们键入`age = 43`时，所发生的是另一个对象被创建，类型为`int`，值为`43`(同样，`id`也会不同)，名字`age`被设置为指向它。所以，我们没有把那个`42`改成`43`。我们实际上只是将`age`指向了一个不同的位置。

从第二个名为`age`的对象创建前后的打印`id(age)`可以看出，它们是不同的。

现在，让我们看看使用可变对象的同一个例子。

```
x = [1, 2, 3]
print(x)
print(id(x))x.pop()
print(x)
print(id(x)) [Out:]
[1, 2, 3]
139912816421064
[1, 2]
139912816421064
```

对于这个例子，我们创建了一个名为`m`的列表，其中包含 3 个整数`1`、`2`和`3`。在我们通过“弹出”最后一个值`3`来改变`m`之后，`m`的 ID 保持不变！

因此，`int`类型的对象是不可变的，而`list`类型的对象是可变的。现在让我们讨论其他不可变和可变的数据类型！

# 可变数据类型

可变序列在创建后可以改变。Python 的一些可变数据类型有:**列表**、**字节数组**、**集合**和**字典**。

## 列表

如前所述，列表是可变的。这里是另一个使用`append()`方法的例子:

```
a = list(('apple', 'banana', 'clementine'))
print(id(a))a.append('dates')
print(id(a)) [Out:]
140372445629448
140372445629448
```

## 字节数组

字节数组代表了`bytes`对象的可变版本。它们公开了大多数可变序列的常用方法以及大多数`bytes`类型的方法。项目是范围[0，256]内的整数。

让我们看一个简单的例子，用`bytearray`类型来说明它是可变的:

```
b = bytearray(b'python')
print(id(b))b.replace(b'p', b'P')
print(id(b)) [Out:]
139963525979808
139963525979808
```

## 设置

Python 提供了两种集合类型，`set`和`frozenset`。它们是不可变对象的无序集合。

```
c = set((‘San Francisco’, ‘Sydney’, ‘Sapporo’))
print(id(c))
c.pop()
print(id(c)) [Out:]
140494031990344
140494031990344
```

如你所见，`set` s 确实是可变的。稍后，在**不可变数据类型**部分，我们将看到`frozenset`是不可变的。

## 字典

```
d = {
    'a': 'alpha',
    'b': 'bravo',
    'c': 'charlie',
    'd': 'delta',
    'e': 'echo'
}
print(id(d))d.update({
    'f': 'foxtrot'
})
print(id(d)) [Out:]
14007111431940
14007111431940
```

# 不可变数据类型

不可变数据类型与可变数据类型的不同之处在于，它们在创建后不能更改。一些不可变类型包括**数字数据类型**、**字符串**、**字节**、**冻结集**和**元组**。

## 数字数据类型

你已经看到整数是不可变的；同样，Python 的其他内置数值数据类型如布尔、浮点、复数、分数和小数也是不可变的！

## 字符串和字节

Python 中的文本数据是用`str`对象处理的，通常称为**字符串**。它们是不可变的 **Unicode 码位序列**。Unicode 码位可以表示一个字符。

当涉及到存储文本数据或在网络上发送文本数据时，您可能希望对其进行编码，使用适合您所使用的介质的编码。编码的结果产生一个`bytes`对象，其语法和行为类似于字符串。

字符串和字节都是不可变的，如下面的代码片段所示:

```
# string
e = 'Hello, World!'
print(id(e))e = 'Hello, Mars!'
print(id(e)) [Out:]
140595675113648
140595675113776# bytes
unicode = 'This is üŋíc0de'  # unicode string: code points
print(type(unicode))
f = unicode.encode('utf-8')  # utf-8 encoded version
print(type(f))
print(id(f))f = b'A bytes object'        # a bytes object
print(id(f)) [Out:]
<class 'str'>
<class 'bytes'>
140595675068152
140595675461360
```

在字节部分，我们首先将`f`定义为我们的`unicode`字符串的编码版本。正如你从`print(type(f))`中看到的，这是一款`bytes`型。然后我们创建另一个名为`f`的`bytes`对象，其值为`b'A bytes object'`。两个`f`对象有不同的 id，这表明字节是不可变的。

## 冻结集

正如上一节所讨论的，`frozenset`与`set`相似。但是，`frozenset`对象在可变对应物方面非常有限，因为它们不能被改变。尽管如此，对于成员测试、并集、交集和差运算以及性能原因，它们仍然被证明是非常有效的。

## 元组

我们将要看到的最后一个不可变序列类型是元组。元组是任意 Python 对象的序列。在元组中，项目由逗号分隔。这些也是不可变的，如下例所示:

```
g = (1, 3, 5)
print(id(g))g = (42, )
print(id(g)) [Out:]
139952252343784
139952253457184
```

我希望你喜欢这个速成班，它讲述了不可变对象和可变对象之间的区别，以及如何找出哪一个是对象！既然您已经理解了 Python 编程的这个基本概念，那么现在您可以探索可以用于每种数据类型的方法。

*如果你想学习这方面的知识并继续提高你的 Python 技能，Next Tech 有一个完整的* ***学习 Python 编程*** *课程，该课程涵盖:*

*   *功能*
*   *条件编程*
*   *理解和生成器*
*   *装饰器、面向对象编程和迭代器*
*   *文件数据持久化*
*   *测试，包括对测试驱动开发的简要介绍*
*   *异常处理*
*   *剖析和性能*

*这里* *可以免费上手* [*！*](https://c.next.tech/2OYvckb)