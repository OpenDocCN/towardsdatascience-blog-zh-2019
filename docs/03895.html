<html>
<head>
<title>The Kalman Filter and External Control Inputs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡尔曼滤波器和外部控制输入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-kalman-filter-and-external-control-inputs-70ea6bcbc55f?source=collection_archive---------14-----------------------#2019-06-19">https://towardsdatascience.com/the-kalman-filter-and-external-control-inputs-70ea6bcbc55f?source=collection_archive---------14-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="39d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用状态偏移处理外部控制输入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10356332ae3931399de5989769378934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epqL-0HKA4NcQLtbJyxJSw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Block diagram of a control system<a class="ae ky" href="https://en.wikipedia.org/wiki/Control_theory#/media/File:Feedback_loop_with_descriptions.svg" rel="noopener ugc nofollow" target="_blank"> by Wikimedia user Orzetto</a> (<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>). This article features a “controller” to the system, though not one designed to match a reference value.</figcaption></figure><p id="856b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将</p><ul class=""><li id="ea66" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">statsmodels</code> Python 模块实现带有外部控制输入的卡尔曼滤波器模型，</li><li id="a04e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用最大似然估计卡尔曼滤波器模型矩阵中的未知参数，</li><li id="b5aa" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/modeling-cumulative-impact-part-i-f7ef490ed5e3">运动表现的体能-疲劳模型</a>的背景下，了解如何通过卡尔曼滤波器对累积影响进行建模。</li></ul><h1 id="cf61" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">具有控制输入的卡尔曼滤波器</h1><p id="35af" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">以下是具有外部“控制”输入<strong class="lb iu"> B u </strong> _t 的卡尔曼滤波器模型的说明:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/e46fe564b4fb4f2a3c6db33044e40c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AAcTtaeaPp0B946x.png"/></div></div></figure><p id="f6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<strong class="lb iu">q</strong>_<em class="nl">t</em>∾n(<strong class="lb iu">0</strong>、𝐐)和<strong class="lb iu">r</strong>_<em class="nl">t</em>∾n(<strong class="lb iu">0</strong>、𝐑).模型矩阵<strong class="lb iu"> A <em class="nl">、</em> B </strong>、<strong class="lb iu"> H <em class="nl">、</em> Q </strong>和<strong class="lb iu"> R </strong>可能包含未知参数，并且通常被允许随时间变化。外部“控制向量”输入，<strong class="lb iu"> u </strong> _ <em class="nl"> t </em>，必须知道到目前为止的所有时间点，如果任务需要预测未来的多个时间步，也必须知道。</p><p id="5077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多预测环境中，外部控制项是不使用的。标准的时间序列模型，其中内部系统动力学是唯一发挥作用的力量(如 ARIMA)，不需要它们。因此，在<code class="fe me mf mg mh b">statsmodels</code>中缺乏明确的控制规范机制并不奇怪。幸运的是，<code class="fe me mf mg mh b">statsmodels</code>确实提供了一个状态截取的接口，它足以包含外部控制输入。</p><h1 id="b0a8" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">将控制输入用于 stats 模型</h1><p id="ddfc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">花点时间熟悉一下<code class="fe me mf mg mh b">statsmodels</code> <a class="ae ky" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.representation.Representation.html" rel="noopener ugc nofollow" target="_blank">状态空间表示法</a>，它对状态方程使用了与本文开头略有不同的符号:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/75b4d328a4a2358f3411d74d1c781fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-OC2DRIfAKMhh8sO.png"/></div></div></figure><p id="8258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本规范中没有的“<strong class="lb iu">state _ intercept</strong>”<strong class="lb iu"><em class="nl">c</em></strong>_<em class="nl">t</em>在<code class="fe me mf mg mh b">statsmodels</code>中默认为零。描述为“<em class="nl">c:state _ intercept(k _ States x nobs)</em>”，这意味着用户可以在每个时间点自由指定不同的状态截距值。(对于所有的<code class="fe me mf mg mh b">statsmodels</code>卡尔曼滤波器模型矩阵都是如此。)但是设置</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8299e2bb1a16ddf8a02625bfc1d2d99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*MuAopgLz5hqeb7MR.png"/></div></figure><p id="e39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<em class="nl"> t </em> =1… <em class="nl"> T，</em>，我们有一个带有控制输入的卡尔曼滤波器模型。</p><h1 id="15f3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">示例:状态空间形式的体能-疲劳模型</h1><p id="baa0" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/modeling-cumulative-impact-part-i-f7ef490ed5e3"> <em class="nl">建模累积冲击第一部分</em> </a>中的体能-疲劳模型为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6b8e2971301f402e1c4d85f50187aad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rP3unltIBdzCJ142.png"/></div></div></figure><p id="a917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="nl"> p_t </em>为(运动)表现，<em class="nl"> w_t </em>为时间<em class="nl"> t </em>的训练“剂量”(时间加权训练强度)。在我以前探索该模型的文章中，训练历史与其他函数的卷积是表示训练课程累积影响的机制。本文将通过保持一个<em class="nl">系统状态</em>来做一些不同的事情。为了做到这一点，我们必须将体能-疲劳模型置于状态空间形式，以训练剂量作为外部控制输入。</p><p id="a222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的等式中，第一个卷积和代表运动健康，我现在称之为<em class="nl"> h_t </em>。以下是滞后一个时间步长的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/740e3518b49ca76afd2ef2ebf2cc5196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*allFSW1EgzgU6p7I.png"/></div></div></figure><p id="74f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分离定义<em class="nl"> h_t </em>的卷积和中的最后一项，我们得到递归:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/412fe012d5b58dbd737cf4b61b591645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*64pAL51y5R4PKicz.png"/></div></div></figure><p id="c770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于疲劳的卷积和，该论证以相同的方式进行，此后称为<em class="nl"> g_t </em>，并且健康和疲劳的递归关系可以用下面的“状态空间形式”表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/cebdb83f5561995851db8a9541cb1523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-9VIiQ_1u9Pt_Y6v.png"/></div></div></figure><p id="ee2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以继续使用矩阵来表达模型的第二个“测量”阶段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/973050eeec87f5ffc559fb0b281eb979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zy4B4z91BAIZkrYw.png"/></div></div></figure><p id="bd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="nl"> r_t </em> ~ N(0，σ)。控制输入滞后一个时间周期，这是我们必须考虑的，但除此之外，我们有一个带有外源控制输入的健康疲劳模型的典型状态空间公式。结合给定健康和疲劳的当前状态的性能测量模型，卡尔曼滤波器工具包(状态估计、简单插补和可能性评估)由我们支配。</p><p id="af4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本节将使用可从<a class="ae ky" rel="noopener" target="_blank" href="/modeling-cumulative-impact-part-ii-2bf65db3bb98"> <em class="nl">建模累积影响第二部分</em> </a>中使用的<a class="ae ky" href="https://gist.github.com/baogorek/6d682e42079005b3bde951e98ebae89e" rel="noopener ugc nofollow" target="_blank"> R 要点</a>中复制的模拟数据，也可作为<a class="ae ky" href="https://drive.google.com/open?id=1kk40wiVYzPXOkrPffU55Vzy-LLTrgAVh" rel="noopener ugc nofollow" target="_blank"> csv 文件</a>提供给读者。要运行以下代码，请更改以下 Python 代码块中的文件路径:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="c849" class="nv mo it mh b gy nw nx l ny nz">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="ba19" class="nv mo it mh b gy oa nx l ny nz">import statsmodels as sm<br/>from statsmodels.tsa.statespace.mlemodel import MLEModel</span><span id="93e3" class="nv mo it mh b gy oa nx l ny nz">train_df = pd.read_csv("&lt;your location&gt;/train_df.csv")<br/>train_df.head()</span></pre><p id="a302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个块加载所需的依赖项，并打印几行输入数据集<code class="fe me mf mg mh b">train_df</code>:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="94d1" class="nv mo it mh b gy nw nx l ny nz">day  day_of_week    period   w        perf<br/>0    1            0  build-up  10  489.197363<br/>1    2            1  build-up  40  500.545312<br/>2    3            2  build-up  42  479.886648<br/>3    4            3  build-up  31  474.226865<br/>4    5            4  build-up  46  459.322820</span></pre></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="9931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在<code class="fe me mf mg mh b">statsmodels</code>中创建一个卡尔曼滤波器模型，我们必须扩展<code class="fe me mf mg mh b">MLEModel</code>基类(从<code class="fe me mf mg mh b"><a class="ae ky" href="https://www.statsmodels.org/dev/_modules/statsmodels/tsa/statespace/mlemodel.html" rel="noopener ugc nofollow" target="_blank">mlemodel</a></code>模块<a class="ae ky" href="https://www.statsmodels.org/dev/_modules/statsmodels/tsa/statespace/mlemodel.html" rel="noopener ugc nofollow" target="_blank">扩展到</a>)。</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="3ff1" class="nv mo it mh b gy nw nx l ny nz">class FitnessFatigue(MLEModel):</span><span id="ae17" class="nv mo it mh b gy oa nx l ny nz">    start_params = [500, .1, .3, 60, 15, 10]<br/>    param_names = ['p_0', 'k_g', 'k_h', 'tau_g', 'tau_h', 'sigma']</span><span id="5c39" class="nv mo it mh b gy oa nx l ny nz">    def __init__(self, p, w_lag1):<br/>        super().__init__(endog=p, k_states=2, exog=w_lag1)<br/>        self.initialize_approximate_diffuse()</span><span id="112a" class="nv mo it mh b gy oa nx l ny nz">    def update(self, params, **kwargs):<br/>        params = super().update(params, **kwargs)</span><span id="6b22" class="nv mo it mh b gy oa nx l ny nz">        self['obs_intercept', 0, 0] = params[0]<br/>        # state space model ------<br/>        self['transition'] = (<br/>            np.array([[np.exp(-1.0 / params[3]), 0],<br/>                      [0, np.exp(-1.0 / params[4])]])<br/>        )<br/>        self['state_intercept'] = (<br/>            np.array([[np.exp(-1.0 / params[3])],<br/>                     [np.exp(-1.0 / params[4])]])<br/>            * self.exog<br/>        )<br/>        # measurement model<br/>        self['design', 0, 0] = params[1]<br/>        self['design', 0, 1] = params[2]<br/>        self['obs_cov', 0, 0] = params[5] ** 2</span></pre><p id="1d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于上面的类，需要注意一些事情:</p><ul class=""><li id="a25d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们必须在<code class="fe me mf mg mh b">start_params</code>中输入起始值</li><li id="7a8b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">我们必须指定一个接受数据的<code class="fe me mf mg mh b">__init__</code>方法。在这种情况下，它必须接受性能测量和训练(即控制)数据。</li><li id="9de6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">请注意<code class="fe me mf mg mh b">__init__</code>内滞后训练变量的创建。体能-疲劳模型特别指定了在训练事件影响<em class="nl">体能</em>或<em class="nl">疲劳</em>之前的一段时间间隔。</li><li id="6580" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">我们能够避免在<code class="fe me mf mg mh b"><a class="ae ky" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.representation.Representation.html" rel="noopener ugc nofollow" target="_blank">statsmodels</a></code> <a class="ae ky" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.representation.Representation.html" rel="noopener ugc nofollow" target="_blank">表示</a>中指定预乘状态误差项的选择矩阵。这默认为一个零矩阵，我们通常会遇到麻烦，因为没有设置，但健康疲劳模型，当直接转换为状态空间形式时，没有状态误差项。</li></ul><p id="1d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，用数据实例化对象，并使用最大似然估计未知参数。请注意，我们确实需要延迟训练输入，以便匹配模型的规范(在文章发表期间，我已经反复讨论过这个问题)。</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="9235" class="nv mo it mh b gy nw nx l ny nz">train_df['lag_w'] = train_df['w'].shift(1)<br/>train_df = train_df.iloc[1:]</span><span id="b3a4" class="nv mo it mh b gy oa nx l ny nz">ffm_kf = FitnessFatigue(train_df.perf, train_df.lag_w)</span><span id="ea2f" class="nv mo it mh b gy oa nx l ny nz">mle_results = ffm_kf.fit(method = 'bfgs', maxiter = 1000)<br/>mle_results.summary()</span></pre><p id="2ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个命令产生以下输出(间距已被修改):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/894d6ac6bcd9308ac9ec62a2a021caba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*HVRK7xfR5bJLnEQrqbsr6A.png"/></div></figure><p id="cd9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出显示卡尔曼滤波器在恢复仿真中使用的参数值方面做得很好。在<a class="ae ky" rel="noopener" target="_blank" href="/modeling-cumulative-impact-part-iii-1b216273b499"> <em class="nl">累积影响建模第三部分</em> </a>中需要自定义非线性近似的标准误差，现在已经“开箱即用”另一方面，最大似然法在这种情况下确实需要一些调整；增加最小迭代次数并选择<a class="ae ky" href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm" rel="noopener ugc nofollow" target="_blank"> BFGS 方法</a>得到稳定的拟合。</p><p id="0de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鼓励读者重复上面的练习，用已知的初始化代替“近似漫射”初始化(目前已被注释掉)。与卡尔曼滤波器和最大似然法不同，使用已知初始化的结果有些不同，尤其是标准误差。当使用已知的初始化时，来自卡尔曼滤波器的标准误差估计类似于使用非线性近似的估计。对于近似漫射初始化，对于某些参数(尤其是指数中的“时间常数”)来说，它们要大得多。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="8138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卡尔曼滤波器使我们能够访问滤波状态估计和平滑状态估计，前者仅使用特定时间点之前的可用数据，后者将所有可用数据合并到每个时间点的状态估计中。下面我们将可视化过滤后的状态估计，这自然会经历一个粗略的开始:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="29ba" class="nv mo it mh b gy nw nx l ny nz">fig = plt.figure(figsize = (12, 8))<br/>plt.rcParams.update({'font.size': 18})</span><span id="a723" class="nv mo it mh b gy oa nx l ny nz">plt.plot(mle_results.filtered_state[0, :], color='green',<br/>         label='fitness')<br/>plt.plot(mle_results.filtered_state[1, :], color='red',<br/>         label='fatigue')<br/>plt.title("Filtered estimates of state vector (Fitness and " +<br/>          "Fatigue) over time")<br/>plt.xlabel('Time')<br/>plt.ylabel('Filtered state estimate')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/6fbca089c59feb783862d77657b4f13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jz3I_7q8vDpHXH6dNGLLMg.png"/></div></div></figure><p id="f0fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设真实的适应状态被初始化为 0，并逐渐变高，那么最初的几个过滤状态估计值会偏离很多，这解释了为什么<code class="fe me mf mg mh b">likelihood_burn</code>被设置为 15。将图形代码中的<code class="fe me mf mg mh b">filtered_state</code>替换为<code class="fe me mf mg mh b">smoothed_state</code>显示的图片与<a class="ae ky" rel="noopener" target="_blank" href="/modeling-cumulative-impact-part-i-f7ef490ed5e3"> <em class="nl">建模累积影响第一部分</em> </a>中的图片非常相似。</p><h1 id="a652" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">讨论</h1><p id="5912" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在写这篇文章之前，我认为获得带控制输入的卡尔曼滤波器的唯一方法是购买<a class="ae ky" href="https://www.mathworks.com/help/control/ug/kalman-filtering.html#responsive_offcanvas" rel="noopener ugc nofollow" target="_blank"> MATLAB </a>或<a class="ae ky" href="http://support.sas.com/documentation/cdl/en/etsug/67525/HTML/default/viewer.htm#etsug_ssm_details01.htm" rel="noopener ugc nofollow" target="_blank"> SAS/ETS </a>。虽然<code class="fe me mf mg mh b">statsmodels</code>可以使规范更加简单，但使用时变状态截距仍然可以轻松地将控制输入添加到卡尔曼滤波器例程中。</p><p id="bab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于定义模型的子类派生，就像在<code class="fe me mf mg mh b">statsmodels</code>中使用的，是圆滑的，但是使得调试不那么透明。(有时这些例子不起作用。)记住结果对象包含它们的模型矩阵；将它们打印出来是调试的好方法！不要忘记<code class="fe me mf mg mh b">statsmodels</code>中乘以状态误差的“选择矩阵”——它默认为零。我们在这里不需要它，因为适应性疲劳模型没有指定状态错误，但它会导致令人沮丧的调试场景，其中代码更改不会影响输出。</p><p id="05ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管由于<code class="fe me mf mg mh b">statsmodels</code>默认值，缺少状态误差项使得当前任务更简单，但是添加状态误差项的能力是卡尔曼滤波器优于原始适应性-疲劳模型的一个优点。很容易想象训练之外影响潜伏<em class="nl">体能</em>和<em class="nl">疲劳</em>的事情，包括睡眠质量和营养。将状态误差项添加到原始的体能-疲劳模型是另一个要探索的变化。</p><p id="8163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<a class="ae ky" rel="noopener" target="_blank" href="/the-kalman-filter-and-maximum-likelihood-9861666f6742"> <em class="nl">中的卡尔曼滤波器和</em> </a>中的最大似然不同，“近似扩散”初始化导致了与状态的已知初始化不同的结果。在那篇文章中，也许平稳 ARMA(1，2)模型太像垒球了，初始状态的不确定性只有在没有均值<em class="nl">的非平稳情况下才真正重要。然而，这让我好奇如果在<code class="fe me mf mg mh b">statsmodels</code>中实现的话,“精确扩散”初始化会有多么不同。</em></p><p id="2e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卡尔曼滤波器是一个非常强大的时间序列分析和建模工具。它不仅能够计算经典时间序列模型的困难可能性，而且能够处理具有外源控制输入的非平稳模型，甚至引导下一架航天飞机飞往月球。作为数据科学家，我们很幸运在<code class="fe me mf mg mh b">statsmodels</code>有一个卡尔曼滤波器的免费开源实现，对于统计和工程目的都足够灵活。</p></div></div>    
</body>
</html>