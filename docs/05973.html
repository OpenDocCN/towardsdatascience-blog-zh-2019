<html>
<head>
<title>Understanding Input Output shapes in Convolution Neural Network | Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解卷积神经网络中的输入输出形状| Keras</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-input-and-output-shapes-in-convolution-network-keras-f143923d56ca?source=collection_archive---------0-----------------------#2019-08-31">https://towardsdatascience.com/understanding-input-and-output-shapes-in-convolution-network-keras-f143923d56ca?source=collection_archive---------0-----------------------#2019-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b59bd504df37282df0a0b85735345e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*2mtkq3DCaQ3erHo1ickV5g.png"/></div></figure><p id="8eb1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">即使我们从理论上理解了<strong class="jz iu">卷积神经网络</strong>，但在将数据拟合到网络时，我们中的很多人仍然会对其<strong class="jz iu">输入</strong>和<strong class="jz iu">输出</strong>的形状感到困惑。本指南将帮助您理解卷积神经网络的输入和输出形状。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><p id="4c92" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看输入形状是什么样的。输入到<strong class="jz iu"> CNN </strong>的数据将如下图所示。我们假设我们的数据是图像的集合。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/209dee7699f23d218b740e76cccef34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*Ub3UmjFyHrq9vIHBzev9PQ.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">ConvNet Input Shape</figcaption></figure><h2 id="037d" class="ll lm it bd ln lo lp dn lq lr ls dp lt ki lu lv lw km lx ly lz kq ma mb mc md bi translated">输入形状</h2><p id="3af3" class="pw-post-body-paragraph jx jy it jz b ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku im bi translated">你总是需要给 CNN 一个 4D 数组作为输入。因此输入数据的形状为<em class="mj"> (batch_size，height，width，depth) </em>，其中第一维表示图像的<strong class="jz iu">批量大小</strong>，其他三维表示图像的维度，即高度、宽度和深度。对于那些想知道图像深度是什么的人来说，它只不过是颜色通道的数量。例如，<strong class="jz iu"> RGB </strong>图像的深度为 3，而<strong class="jz iu">灰度</strong>图像的深度为 1。</p><h2 id="2f0e" class="ll lm it bd ln lo lp dn lq lr ls dp lt ki lu lv lw km lx ly lz kq ma mb mc md bi translated">输出形状</h2><p id="d1f5" class="pw-post-body-paragraph jx jy it jz b ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku im bi translated">CNN 的输出也是一个 4D 阵列。其中<strong class="jz iu">批次大小</strong>将与输入批次大小相同，但是图像的其他 3 个维度可能会根据过滤器<strong class="jz iu">、</strong>内核大小和我们使用的填充的值而改变。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><p id="28a6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看下面的代码片段。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d5ea7cda39607bd967d0e3414a8e2943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*C-isphFAhfNBdxQFyXmUZA.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Snippet-1</figcaption></figure><p id="9851" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不要被这里的<strong class="jz iu"> input_shape </strong>论点所欺骗。虽然它看起来像我们的输入形状是三维的，但你必须在拟合数据时通过一个 4D 数组，应该像<em class="mj"> (batch_size，10，10，3) </em>。因为在<strong class="jz iu"> input_shape </strong>参数中没有批量值，所以我们可以在拟合数据时使用任何批量值。</p><p id="b1e6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以注意到<strong class="jz iu">输出</strong>的形状是<em class="mj">(无，10，10，64) </em>。第一维表示批量大小，目前为<strong class="jz iu">无</strong>。因为网络事先不知道批量大小。一旦您拟合了数据，<strong class="jz iu"> None </strong>将会被您在拟合数据时给出的批量所取代。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><p id="e355" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看另一个代码片段。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/01088e7ca439f1014343c12539a762e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*A8J77ajdmdkUOaDGzudEJA.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Snippet-2</figcaption></figure><p id="46fa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我用<strong class="jz iu">批处理输入形状</strong>替换了<strong class="jz iu">输入形状</strong>参数。顾名思义，该参数会提前询问您批次<strong class="jz iu"> </strong>大小，在拟合数据时您可以不提供任何其他批次大小。例如，您必须使 16 个批次中的数据仅适合网络。</p><p id="2ca7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，您可以看到输出形状的批量大小也是 16，而不是<strong class="jz iu"> None </strong>。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h2 id="0650" class="ll lm it bd ln lo lp dn lq lr ls dp lt ki lu lv lw km lx ly lz kq ma mb mc md bi translated">在卷积层上附加密集层</h2><p id="89ec" class="pw-post-body-paragraph jx jy it jz b ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku im bi translated">我们可以简单地在另一个卷积层的顶部添加一个卷积层，因为卷积的输出维度与其输入维度相同。</p><p id="f45d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们通常在<strong class="jz iu">卷积</strong>层的顶部加上<strong class="jz iu">密集</strong>层，对图像进行分类。然而输入数据到密集层 2D 数组的形状<em class="mj"> (batch_size，units) </em>。卷积层的输出是 4D 阵列。因此，我们必须将从卷积层接收的输出的维度改变为 2D 阵列。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/c4f0a81c2037a2523fcfa2869e986cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*lXbcy-MhbXHPQIvow7bp1Q.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Snippet-3</figcaption></figure><p id="8ee7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以在<strong class="jz iu">卷积</strong>层的顶部插入一个<strong class="jz iu">展平</strong>层。展平图层将图像的三维压缩为一维。现在我们只有一个形状为<em class="mj"> (batch_size，squaded _ size)</em>的 2D 数组，对于密集层来说是可以接受的。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="f628" class="mn lm it bd ln mo mp mq lq mr ms mt lt mu mv mw lw mx my mz lz na nb nc mc nd bi translated">摘要</h1><ul class=""><li id="4fb6" class="ne nf it jz b ka me ke mf ki ng km nh kq ni ku nj nk nl nm bi translated">你总是需要将一个形状为<em class="mj"> (batch_size，height，width，depth) </em>的 4D 数组输入到<strong class="jz iu"> CNN </strong>中。</li><li id="7792" class="ne nf it jz b ka nn ke no ki np km nq kq nr ku nj nk nl nm bi translated">来自<strong class="jz iu"> CNN </strong>的输出数据也是一个形状为<em class="mj"> (batch_size，height，width，depth)的 4D 数组。</em></li><li id="e6ee" class="ne nf it jz b ka nn ke no ki np km nq kq nr ku nj nk nl nm bi translated">要在<strong class="jz iu"> CNN </strong>图层上添加<strong class="jz iu">密集</strong>图层，我们必须使用<strong class="jz iu">展平</strong>图层将 CNN 的 4D 输出更改为 2D。</li></ul></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><p id="0ecc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">阅读我的下一篇文章，了解<strong class="jz iu"> LSTM </strong>中的<strong class="jz iu">输入</strong>和<strong class="jz iu">输出</strong>形状。</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/@shivajbd/understanding-input-and-output-shape-in-lstm-keras-c501ee95c65e" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">了解 LSTM | Keras 中的输入和输出形状</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">当我开始研究 LSTM 网络时，我对输入和输出的形状感到非常困惑。这篇文章将…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jv nv"/></div></div></a></div></div></div>    
</body>
</html>