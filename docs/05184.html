<html>
<head>
<title>Understanding and using Python classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解和使用 Python 类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-and-using-python-classes-3f7e8d1ef2d8?source=collection_archive---------5-----------------------#2019-08-03">https://towardsdatascience.com/understanding-and-using-python-classes-3f7e8d1ef2d8?source=collection_archive---------5-----------------------#2019-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4f91775c43363d43efe70bae0e0dd39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0GPyMZGdCfAsbfMgYZRUA.png"/></div></div></figure><div class=""/><p id="50b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python 是一种解释的、面向对象的、具有动态语义的高级编程语言。后者是官方网站<a class="ae kz" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">python.org</a>给出的正式定义。让我们打破它，试着理解它:</p><ul class=""><li id="7c43" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">解释型:与编译型编程语言(源代码必须转换成机器可读的代码)不同，解释型语言不直接由目标机器执行。取而代之的是，它们被称为解释器的其他计算机程序读取和执行；</li><li id="b893" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">面向对象:这意味着 python 像任何其他面向对象编程(OOP)语言一样，是围绕对象组织的。python 中的一切(列表、字典、类等等)都是对象；</li><li id="0a4d" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">高级:这意味着代码的语法更容易被人类理解。也就是说，如果你必须在屏幕上显示一些东西，这个内置函数叫做<em class="lo">print；</em></li><li id="411a" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">动态语义:动态对象是包含在代码结构中的值的实例，它们存在于运行时级别。此外，我们可以给一个对象分配多个值，因为它会自我更新，这与静态语义语言不同。也就是说，如果我们设置<em class="lo"> a=2 </em>，然后<em class="lo">a =‘hello’</em>，那么一旦执行了该行，字符串值将替换整数 1。</li></ul><p id="d93c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我想更深入地研究类的概念。类是一种特殊类型的对象。更具体地说，它们是对象构造器，能够构建数据表示和我们可以用来与该对象交互的过程(因此是方法、函数等等)。</p><p id="8114" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在 Python 中创建一个类，我们需要给这个类一个名称和一些属性。让我们从下面的例子开始:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="59f2" class="ly lz je lu b gy ma mb l mc md">class Actor:<br/>    def __init__(self, name, surname, age, years_on_stage):<br/>        self.name=name<br/>        self.surname=surname<br/>        self.age=age<br/>        self.years_on_stage=years_on_stage</span></pre><p id="37d8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">于是我们创建了一个名为 Actor 的类，它定义了一些特征(名字、姓氏、年龄、登台年数)。有两个要素需要关注:</p><ul class=""><li id="5358" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><em class="lo"> __init__() </em>:用于初始化数据属性的特殊方法。我们可以把它看作一个初始化器。</li><li id="1872" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="lo"> self </em>:这是一个标准符号，用来指向参数。</li></ul><p id="4370" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以使用我们的类并创建一个类 Actor 的对象:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6fc5" class="ly lz je lu b gy ma mb l mc md">mario=Actor(<br/>    'Mario',<br/>    'Rossi',<br/>    40,<br/>    13<br/>)</span></pre><p id="4a88" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以访问 mario 的所有属性(我们在<em class="lo"> __init__() </em>中定义的):</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="8e4d" class="ly lz je lu b gy ma mb l mc md">mario.name</span><span id="7274" class="ly lz je lu b gy me mb l mc md">"mario"</span><span id="da87" class="ly lz je lu b gy me mb l mc md">mario.age</span><span id="10dc" class="ly lz je lu b gy me mb l mc md">40</span></pre><p id="a413" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，假设我们想知道 mario 的具体信息，而这些信息并没有存储在它的属性中。更具体地说，我们想知道出道的年份，但只提供给我们在舞台上的年份。所以我们想要的是一个从当前日期减去舞台上的年份的函数，这样它就返回出道的年份。</p><p id="05e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以这样直接进入我们的演员类:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f047" class="ly lz je lu b gy ma mb l mc md">class Actor:<br/>    def __init__(self, name, surname, age, years_on_stage):<br/>        self.name=name<br/>        self.surname=surname<br/>        self.age=age<br/>        self.years_on_stage=years_on_stage<br/>    def year_of_debut(self, current_year):<br/>        self.current_year=current_year<br/>        year_of_debut=self.current_year-self.years_on_stage<br/>        return year_of_debut</span></pre><p id="ca96" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们在我们的对象 mario 上测试它:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="cb40" class="ly lz je lu b gy ma mb l mc md">mario.year_of_debut(2019)</span><span id="1e2e" class="ly lz je lu b gy me mb l mc md">2006</span></pre><p id="71b8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后我要讲的是 python 类的一个非常有趣且有用的属性，叫做<em class="lo">类继承</em>。其思想是，如果您必须创建一个类(称为子类),它是您已经创建的类(称为父类)的子集，您可以很容易地将其属性导入子类。</p><p id="72d7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过下面的例子来看看如何做到这一点。假设您想要创建一个名为 Comedian 的子类，它与父类 Actor 有一些共同的属性:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f31b" class="ly lz je lu b gy ma mb l mc md">class Comedian(Actor):<br/>    def __init__(self, n_shows, field, shows_schedule, name, surname, age, years_on_stage):<br/>        self.n_shows=n_shows<br/>        self.field=field<br/>        self.shows_schedule=shows_schedule<br/>        super().__init__(name,surname,age,years_on_stage)</span></pre><p id="1c1f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以看到，我们没有为<em class="lo">的名字、姓氏、年龄</em>和<em class="lo"> years_on_stage </em>指定<em class="lo"> self.attribute=attribute </em>，而是通过函数<em class="lo"> super() </em>直接由父类继承。现在，我们可以创建一个子类的对象，并像在父类示例中一样访问它的属性:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c0a1" class="ly lz je lu b gy ma mb l mc md">a_comedian=Comedian(<br/>           21,<br/>          'politics',<br/>          'late night', <br/>          'amelia', <br/>          'smith', <br/>          '33', <br/>          '10'<br/>)</span><span id="c8f3" class="ly lz je lu b gy me mb l mc md">a_comedian.name</span><span id="4e12" class="ly lz je lu b gy me mb l mc md">'amelia'</span><span id="0a56" class="ly lz je lu b gy me mb l mc md">a_comedian.field</span><span id="535d" class="ly lz je lu b gy me mb l mc md">'politics'</span></pre><p id="36f6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python 类的优势显而易见。特别是，它们使得 Python 语言非常具有可定制性:不仅可以创建个性化的函数(除了那些内置的函数)，还可以创建能够完美满足您需求的对象生成器。</p></div></div>    
</body>
</html>