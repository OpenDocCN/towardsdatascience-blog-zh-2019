<html>
<head>
<title>Intermediate Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中间细流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intermediate-streamlit-d5a1381daa65?source=collection_archive---------5-----------------------#2019-12-27">https://towardsdatascience.com/intermediate-streamlit-d5a1381daa65?source=collection_archive---------5-----------------------#2019-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c94" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建不断发展的应用程序时的一些提示和技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/120d47b9c17d07330b2aa2556c770038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PC3yaQVrexX691Higz8i_w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">It’s never too early to start scaffolding your app. Image by <a class="ae ky" href="https://pixabay.com/users/MichaelGaida-652234/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3331438" rel="noopener ugc nofollow" target="_blank">Michael Gaida</a> from <a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3331438" rel="noopener ugc nofollow" target="_blank">Pixabay</a>.</figcaption></figure><p id="937a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Streamlit 是一款非常棒的工具，可以为您的数据科学工作提供一个界面。我一直将它作为一个轻量级仪表板工具来显示简单的可视化效果，在 UI 中包装 python 包，并探索 NLP 模型的模型评估(真实示例<a class="ae ky" href="https://twitter.com/pmbaumgartner/status/1210628105003511811" rel="noopener ugc nofollow" target="_blank"> 1 </a>和<a class="ae ky" href="https://twitter.com/pmbaumgartner/status/1207359153787805697" rel="noopener ugc nofollow" target="_blank"> 2 </a>)。它让我能够更好地理解我的数据，并创建了一个界面，可以帮助在代码/数据/分析之间进行转换，并与利益相关者和主题专家进行交流。</p><p id="799d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，今天的原型变成了明天的生产应用。把事情变得太容易是有风险的——在你知道之前，你已经建立了下一次迭代会同样快发生的预期，或者你的应用程序是健壮的和经过良好测试的，或者在整个公司范围内部署它是指日可待的，或者新实习生可以从这里开始节省一些钱。</p><p id="0c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着应用的增长，您需要管理成长的烦恼。在这篇文章中，我将提供一些随着我的 streamit 应用程序的发展而变得有用的技巧和想法。我将从一些构建更好的应用程序的简单技巧开始，以一些使应用程序模块化和可测试的想法结束。</p><p id="e090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(作为一个功能说明，任何时候你看到一个要点，你都应该能够将其作为一个 streamlit 应用程序运行，并探索自己。如果你愿意做一个<code class="fe lv lw lx ly b">pip install streamlit pandas altair vega_datasets</code>，你可以用<code class="fe lv lw lx ly b">streamlit run &lt;gist_url&gt;</code>运行下面的任何一个 gists。</p><h1 id="6aea" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">显示干净的变量名</h1><p id="eb1e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">数据帧中的变量名可能是蛇形的或以不适合最终用户的方式格式化，例如<code class="fe lv lw lx ly b">pointless_metric_my_boss_requested_and_i_reluctantly_included</code>。大多数 streamlit 小部件都包含一个<code class="fe lv lw lx ly b">format_func</code>参数，该参数具有将显示格式应用于您提供给小部件的选项值的功能。举个简单的例子，你可以给每个变量名都加上大小写。</p><p id="7aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以将此功能与字典结合使用，以显式处理值的格式。下面的例子清理了<code class="fe lv lw lx ly b">birdstrikes</code>数据集中的列名，用作描述每一列的下拉列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Passing `dict.get` as an argument to `format_func` allows you to explicitly control the display of widget values</figcaption></figure><h1 id="f0e9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用缓存(但首先要进行基准测试)</h1><p id="e063" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">人们很容易把那个便利的<code class="fe lv lw lx ly b">@st.cache</code>装饰器扔在所有东西上，并希望一切顺利。然而，盲目地应用缓存意味着我们错过了一个获得 meta 并使用 streamlit 来了解缓存在哪里最有帮助的大好机会。</p><p id="0ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其装饰每个函数，不如为每个函数创建两个版本:一个有装饰器，一个没有。然后做一些基本的基准测试，看看执行这个函数的缓存版本和非缓存版本需要多长时间。</p><p id="b931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们通过连接 100 个<code class="fe lv lw lx ly b">airports</code>数据集的副本，然后动态选择第一个<code class="fe lv lw lx ly b">n</code>行并描述它们来模拟加载一个大型数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Don’t blindly apply `@st.cache` — benchmark and apply where appropriate</figcaption></figure><p id="e455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为其中的每一步(数据加载、选择行、描述选择)都是计时的，所以我们可以看到缓存在哪里提供了加速。根据我在这个例子中的经验，我对缓存的启发是:</p><ul class=""><li id="030c" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">总是缓存加载数据集</li><li id="8e07" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">可能缓存时间超过半秒的函数</li><li id="cc8f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">衡量其他一切</li></ul><p id="d206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为缓存是 streamlit 的杀手锏之一，我知道他们正在关注并改进它。智能缓存也是一个复杂的问题，所以更倾向于基准测试和验证缓存功能是否按预期运行是一个好主意。</p><h1 id="1c19" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建动态小部件</h1><p id="893a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">许多例子侧重于创建动态可视化，但是不要忘记您也可以编程动态小部件。这种需求最简单的例子是当数据集中的两列有嵌套关系，并且有两个小部件从这两列中选择值时。构建应用程序来过滤数据时，第一列的下拉列表应更改第二个下拉列表中的可用选项。</p><p id="4b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个下拉菜单的链接行为是一个常见的用例。以下示例使用<code class="fe lv lw lx ly b">cars</code>数据集构建了一个散点图。这里我们需要一个动态下拉菜单，因为我们为 x 轴选择的变量不需要在 y 轴上可供选择。</p><p id="3605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以超越这个基本的动态功能:如果我们按照 y 轴选项与所选 x 变量的相关性对它们进行排序，会怎么样呢？我们可以计算相关性，并将其与小部件的<code class="fe lv lw lx ly b">format_func</code>结合起来，以排序的顺序显示变量及其相关性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Dynamic widgets are a powerful way to add more context around your app’s functionality</figcaption></figure><h1 id="3d8b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">大量使用 f 弦和降价</h1><p id="6811" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在上面的例子中，我们使用 python 的 f 字符串来插入变量名及其相关值。在围绕分析构建界面时，大部分工作都需要在变量名、小部件值、轴标签、小部件标签或叙述性描述中创建或操作字符串。</p><p id="8f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想以叙述的形式展示一些分析，并且有一些特定的变量我们想突出显示，f-strings 和 markdown 可以帮助我们。除了用特定的变量值填充字符串的简单方法之外，内联格式化它们也是一种简单的方法。例如，我们可以使用类似这样的东西来显示数据集中某一列的基本信息，并在 markdown 字符串中突出显示它们。</p><pre class="kj kk kl km gt nm ly nn no aw np bi"><span id="6af6" class="nq ma it ly b gy nr ns l nt nu">mean = df["values"].mean()<br/>n_rows = len(df)</span><span id="4b55" class="nq ma it ly b gy nv ns l nt nu">md_results = f"The mean is **{mean:.2f}** and there are **{n_rows:,}**."</span><span id="0a5d" class="nq ma it ly b gy nv ns l nt nu">st.markdown(md_results)</span></pre><p id="0bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用了两种格式:<code class="fe lv lw lx ly b">.2f</code>将浮点数舍入到两位小数，而<code class="fe lv lw lx ly b">,</code>使用逗号作为千位分隔符。我们还使用 markdown 语法来加粗这些值，以便它们在文本中视觉上突出。</p><h1 id="5a8e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">考虑切换到 Altair 进行可视化</h1><p id="1f29" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果您一直在用另一个库构建可视化原型，那么可以考虑切换到 Altair 来构建您的可视化。以我的经验来看，我认为有三个关键原因可以说明转换是有益的:</p><ol class=""><li id="0b63" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nw ne nf ng bi translated">Altair 可能更快(除非我们在绘制大量数据)</li><li id="a087" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nw ne nf ng bi translated">它直接在熊猫数据帧上操作</li><li id="a982" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nw ne nf ng bi translated">交互式可视化很容易创建</li></ol><p id="3b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于速度的第一点，如果我们使用 matplotlib 进行原型化，我们可以看到显著的加速。与渲染 javascript 可视化相比，大部分加速只是因为渲染静态图像并将其放入应用程序需要更多时间。下面的示例应用程序演示了这一点，它为一些生成的数据生成散点图，并为可视化的每个部分输出创建和渲染的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Altair can be faster than matplotlib if you’re plotting less than a few thousand pionts.</figcaption></figure><p id="6379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接使用数据框架提供了另一个好处。它可以简化调试过程:如果输入数据有问题，我们可以使用<code class="fe lv lw lx ly b">st.write(df)</code>在 streamlit 应用程序中显示数据帧并检查它。这使得调试数据问题的反馈循环更短。第二个好处是，它减少了创建特定可视化所需的转换粘合代码的数量。对于基本的绘图，我们可以使用 DataFrame 的绘图方法，但是更复杂的可视化可能需要我们以一种对可视化 API 有意义的方式来重构数据集。数据集和可视化之间的这些额外代码可能会导致额外的复杂性，并且随着应用程序的增长，可能会成为一个棘手的问题。由于 Altair 使用 Vega-Lite 可视化语法，<a class="ae ky" href="https://vega.github.io/vega-lite/docs/transform.html" rel="noopener ugc nofollow" target="_blank">转换 API </a>中可用的函数可用于进行任何可视化的适当转换。</p><p id="f8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，Altair 的交互式可视化非常简单。虽然应用程序可能会使用 streamlit 小部件来过滤和选择数据，但应用程序也可以使用可视化功能作为选择机制。<a class="ae ky" href="https://altair-viz.github.io/gallery/index.html#interactive-charts" rel="noopener ugc nofollow" target="_blank">交互式可视化</a>允许在可视化中对数据的各个方面进行可视化交流，而不是在小部件或叙述中以字符串的形式交流信息。</p><h1 id="65fc" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">不要忽视重构、编写模块化代码和测试</h1><p id="ff8b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">花几个小时使用 streamlit 并拥有一个除了你之外没有人理解的 500 行文件是很容易的。如果你正在交付你的代码，部署你的应用程序，或者添加一些新的功能，现在你可能会花费大量的时间试图记住你的代码是如何工作的，因为你已经忽略了良好的代码卫生。</p><p id="0ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个应用程序超过 100 行代码，它可能会从重构中受益。好的第一步是从代码中创建函数，并将这些函数放在一个单独的<code class="fe lv lw lx ly b">helpers.py</code>文件中。这也使得在这些函数上测试和测试缓存变得更加容易。</p><p id="b4de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何重构代码，没有具体的正确方法，但是我开发了一个练习，可以在开始重构应用程序时提供帮助。</p><p id="54ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重构练习</strong></p><p id="fad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="http://app.py" rel="noopener ugc nofollow" target="_blank"> app.py </a>中，尝试:</p><ul class=""><li id="05fe" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">仅导入 streamlit 和助手函数(不要忘记在这些助手函数上测试<code class="fe lv lw lx ly b">@st.cache</code>)</li><li id="cf3f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">不要在下一行代码中创建没有输入到 streamlit 对象的变量，例如可视化或小部件(数据加载函数除外)</li></ul><p id="fe4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些并不是必须遵守的硬性规则:你可以明确地遵循它们，因为你有大量复杂的功能，所以你的应用组织得很差。然而，当从 app.py 中的所有东西转移到更模块化的结构时，它们是很好的开始目标。</p><p id="0d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子突出显示了在进行这个练习前后的一个应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Functions are great and you should use them.</figcaption></figure><p id="d129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式重新组织代码的另一个好处是，helpers 文件中的函数现在更容易编写测试。有时我很难想出要测试什么，但我发现现在为我的应用程序进行测试真的很容易，因为我现在可以更快地发现错误和边缘情况，因为我与数据和代码的交互更紧密了。现在，每当我的应用程序显示回溯，我就修复导致它的函数，并编写一个测试来确保新的行为是我所期望的。</p><h1 id="e982" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包裹</h1><p id="43c1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我一直很享受使用 streamlit 的时光，这是一款出色的工具，能够满足数据科学工作流程中的明确需求。然而，今天的原型就是明天的生产应用，一个简单的应用很容易成为数据科学团队无法维护的噩梦。这篇文章中的想法帮助我处理了与将我的应用程序移出原型相关的痛苦，我希望它们对你也一样。</p></div></div>    
</body>
</html>