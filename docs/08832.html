<html>
<head>
<title>A Brief Tour of Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫之旅</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-brief-tour-of-pandas-9f10a8ce490a?source=collection_archive---------35-----------------------#2019-11-25">https://towardsdatascience.com/a-brief-tour-of-pandas-9f10a8ce490a?source=collection_archive---------35-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8be6f764e2a4344bf19a4cf211932f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNISkw72ghYbzTLiJ_naEw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://www.pexels.com/@diana-silaraja-794257" rel="noopener ugc nofollow" target="_blank">Diana Silaraja</a> on <a class="ae kf" href="https://www.pexels.com/photo/photo-of-panda-and-cub-playing-1661535/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="9ce0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas 是一个用于处理数据的 python 库。在这篇文章中，我们将回顾我作为数据科学家最常用的一些 pandas 方法。</p><p id="7f1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先让我们导入熊猫库:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9687" class="ln lo it lj b gy lp lq l lr ls">import pandas as pd </span></pre><ol class=""><li id="8d33" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated"><strong class="ki iu">读取数据</strong></li></ol><p id="9ade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我通常对熊猫做的第一件事就是把数据读入所谓的熊猫数据帧。我们将使用来自 Kaggle 的<a class="ae kf" href="https://www.kaggle.com/aaronschlegel/austin-animal-center-shelter-outcomes-and" rel="noopener ugc nofollow" target="_blank">奥斯丁动物中心收容所结果</a>数据。如果我们想在。csv 文件我们可以做到以下几点:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fd4f" class="ln lo it lj b gy lp lq l lr ls">df = pd.read_csv("aac_shelter_outcomes.csv")</span></pre><p id="aea1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用。头()和。tail()方法分别查看第一行和最后五行数据:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a5bd" class="ln lo it lj b gy lp lq l lr ls">print(df.head())<br/></span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/efa798ea065d1e31fd5627b57f429b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*6ZDFluGXD-BseH3Z149LoQ.png"/></div></figure><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="bb37" class="ln lo it lj b gy lp lq l lr ls">print(df.tail())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/be702e168c24358500a1530b1532ed73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Wn1r9DUBcUbTBwYnr1TsZA.png"/></div></figure><p id="d155" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以查看列名:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="bad5" class="ln lo it lj b gy lp lq l lr ls">print(df.columns)</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/04afca5278a3d75122befba299f296ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*33fW6btnj82yEUJUU5cXtQ.png"/></div></figure><p id="bd32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于包含大量列的数据集尤其有用。</p><p id="0028" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<strong class="ki iu">清理资料用。dropna()和。菲尔娜()</strong></p><p id="3680" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在真实数据中，我们经常需要处理数据列中缺失的值。使用 pandas，我们可以通过执行以下操作快速了解数据有多稀疏:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8e6e" class="ln lo it lj b gy lp lq l lr ls">print(df.isnull().sum())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/cc054374b37fef627e33c6e1896f9074.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*phF_LZK-5mO_8P1zCrUqUw.png"/></div></figure><p id="693e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果数据中有缺失值，我们可以使用。dropna()方法删除这些值。这可以就地完成，我们可以返回一个值，我们可以将它存储在一个新的变量中。要将缺少的值放到适当的位置:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b8ab" class="ln lo it lj b gy lp lq l lr ls">df.dropna(inplace=True)</span></pre><p id="1a80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里 df 变量已经被修改了。或者，我们可以:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cbed" class="ln lo it lj b gy lp lq l lr ls">df = df.dropna()</span></pre><p id="1067" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在删除丢失的值之前和之后检查数据帧的长度:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="efa7" class="ln lo it lj b gy lp lq l lr ls">print("Length Before:", len(df))<br/>df.dropna(inplace=True)<br/>print("Length After:", len(df))</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/2c89c50a5429880ebf74720c827d7a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*hbJCTGXslSz7jXIx6TmtYQ.png"/></div></figure><p id="93d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，如果您想要填充数据帧中缺失的值，我们假设在适当的位置用零填充:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e459" class="ln lo it lj b gy lp lq l lr ls">df.fillna(0, inplace=True)</span></pre><p id="faaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2ecc" class="ln lo it lj b gy lp lq l lr ls">df = df.fillna(0)</span></pre><p id="edb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们在这里输入缺失值，所以数据帧的长度不应改变:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8f7d" class="ln lo it lj b gy lp lq l lr ls">print("Length Before:", len(df))<br/>df.fillna(0, inplace=True)<br/>print("Length After:", len(df))</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/4cd0636a2368cdba9f0ea30f4f69b3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*PuH2bRY059gmUvnxA3dObQ.png"/></div></figure><p id="fef0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.<strong class="ki iu">过滤数据</strong></p><p id="0425" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以很容易地根据列值过滤数据帧。例如，如果我们想要阉割的雌性獒混种狗，我们可以写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="38b7" class="ln lo it lj b gy lp lq l lr ls">df = df[df['breed'== 'Mastiff Mix']]<br/>df = df[df['sex_upon_outcome'] == 'Spayed Female']<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e367a24807cf0b57603d212da1c0a641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*7m0_XsHLN7CEYVCWieSnSA.png"/></div></figure><p id="2f86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以很容易地处理时间戳。pandas 将大多数时间值处理为字符串，因此我们需要将感兴趣的日期转换为 datetime 对象:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f3c8" class="ln lo it lj b gy lp lq l lr ls">df['date_of_birth'] = pd.to_datetime(df['date_of_birth'])<br/></span></pre><p id="c57b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以从日期时间值中提取周、月和年的值:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="89ec" class="ln lo it lj b gy lp lq l lr ls">df['week_of_birth'] = df['date_of_birth'].dt.week<br/>df['month_of_birth'] = df['date_of_birth'].dt.month<br/>df['year_of_birth'] = df['date_of_birth'].dt.year<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5d6d284d2c90941af6ae1d2f59a4cd11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*2OxTr1p09tMX0FqEaI6nEA.png"/></div></figure><p id="4228" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以根据周、月或年过滤数据框架。例如，我们可以提取第一个月的数据:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ceee" class="ln lo it lj b gy lp lq l lr ls">df = df[df['month_of_birth'] == 1]<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/4e4c099acd0ae1bc4c7cd728b55bb8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*0OLUz4yhaVrSUWOnu6pUtQ.png"/></div></figure><p id="a535" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，由于我们删除了一些数据，指数也被修改。我们可以使用 reset_index 来解决这个问题:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c6ee" class="ln lo it lj b gy lp lq l lr ls">df = df[df['month_of_birth'] == 1].reset_index()<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/f94298786a581908c084af6db303aa38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*mjDuJxTyErf2UL8Gkr5eiQ.png"/></div></figure><p id="b69b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以重新定义指数:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2043" class="ln lo it lj b gy lp lq l lr ls">df = df.set_index('month_of_birth')<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/3177fd0297fbf0af7b152587a4f5f4de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*uQfZPMYWbKbzTUCib7-ofQ.png"/></div></figure><p id="cc5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.<strong class="ki iu">选择行和列</strong></p><p id="5f90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以利用。iloc()来选择索引。要选择数据集中的第一个、第二个和最后一个索引:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0256" class="ln lo it lj b gy lp lq l lr ls">print(df.head())<br/>print("---------------------First---------------------")<br/>print(df.iloc[0])<br/>print("---------------------Second---------------------") <br/>print(df.iloc[1])<br/>print("---------------------Last---------------------")<br/>print(df.iloc[-1])</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3614a26c2214f190d53ce001647a681c.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*VkA-iMhCLKwBhoJIUa7iug.png"/></div></figure><p id="6205" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以用。特定列的 loc():</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c1f5" class="ln lo it lj b gy lp lq l lr ls">print("---------------------First---------------------")<br/>print(df.loc[0, 'breed'])<br/>print("---------------------Second---------------------") <br/>print(df.loc[1, 'breed'])</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f39b3c493e1ebc61047295fccc6295ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*wvdDl_JArIRzDK8yALi-WA.png"/></div></figure><p id="4ca3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在一列中选择多行:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="45ab" class="ln lo it lj b gy lp lq l lr ls">print("---------------------First---------------------")<br/>print(df.loc[0:3, 'breed'])<br/>print("---------------------Second---------------------") <br/>print(df.loc[3:6, 'breed'])</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/aa729a4d7eb06110d2916def9a4335d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*hRM9AUAL_13PiiT9W35OkA.png"/></div></figure><p id="f3c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.<strong class="ki iu">汇总数据&amp;生成统计数据</strong></p><p id="1233" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个有用的方法是。可用于聚合数据的 groupby()方法。假设我们想知道数据集中某一年每种类型的品种的数量:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0436" class="ln lo it lj b gy lp lq l lr ls">df  = df.groupby(['year_of_birth', 'breed'])['breed'].count()<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0f604af3b033d90bef90ee1cdfd74bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*r47AqFxaEd_PKNY-sR3KUw.png"/></div></figure><p id="87f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们需要每个品种的平均出生周数:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3cae" class="ln lo it lj b gy lp lq l lr ls">df  = df.groupby('breed')['week_of_birth'].mean()<br/>print(df.head())</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ac130ced34af0eadeb3093b6a2c93cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*PAi-q7RET9Ew021hqeDBUQ.png"/></div></figure><p id="9f2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用 sum()、std()、max()和 min()等方法进行类似的聚合。</p><p id="f326" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">6.<strong class="ki iu">写入文件</strong></p><p id="46b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，如果我们对数据帧做了足够的修改，我们会想把它保存到一个单独的文件中。to_csv():</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="16b4" class="ln lo it lj b gy lp lq l lr ls">df.to_csv("new_name_of_file.csv")</span></pre><p id="c64a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这有所帮助。这篇文章的代码可以在<a class="ae kf" href="https://github.com/spierre91/medium_code" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="9afa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">祝你好运，享受你的熊猫之旅！</p></div></div>    
</body>
</html>