<html>
<head>
<title>EMOJIFY- Machine Learning Web App using Flask + Containerization +Deployment on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Flask +容器化+在 AWS 上部署的机器学习 Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/emojify-machine-learning-web-app-using-flask-containerization-deployment-on-aws-14a9bdb75535?source=collection_archive---------8-----------------------#2019-06-22">https://towardsdatascience.com/emojify-machine-learning-web-app-using-flask-containerization-deployment-on-aws-14a9bdb75535?source=collection_archive---------8-----------------------#2019-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4bf4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">构建和部署机器学习 web 应用的直观指南。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/ce037d38c352e2752356039c11f9961f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gy6k5l30-mUrlR8ozyG9Uw.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">PC: Unsplash</figcaption></figure><p id="2fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我将分享我在使用 Flask 构建一个简单的端到端机器学习 web 应用程序并随后将其部署到 AWS 上的学习。只有当用户可以通过 web 应用程序交互地使用 ML 模型时，它的目的才能得到很好的服务。传统的 Jupyter 笔记本电脑只提供了一个交互式控制台，对于将它应用到 web 应用程序上没有多大用处。</p><p id="32fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flask 是一个用 Python 编写的微框架，可以帮助我们快速开始构建应用程序。我们将使用 Keras 中的长短期记忆(LSTM)单元来训练来自<a class="ae ls" href="https://github.com/bfelbo/DeepMoji/tree/master/data" rel="noopener ugc nofollow" target="_blank">深度莫吉</a>数据集的数据。然后，我们将最终模型保存为 HDF5 文件，并在以后用于预测目的。最终的应用程序将像这个<a class="ae ls" href="https://deepmoji.mit.edu/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lt">链接</em> </strong> </a>中提到的那样工作。让我们更深入地探讨如何使用 Docker 容器在 AWS 中构建和部署整个 web 应用程序。这个项目的代码可以在我的<a class="ae ls" href="https://github.com/SRIRAM777/Emojify-ML-Flask-App" rel="noopener ugc nofollow" target="_blank"> Github repo 中找到。</a></p><h1 id="df43" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">内容</h1><ol class=""><li id="1ea3" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated">数据</li></ol><p id="89ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.数据提取和处理</p><p id="bb91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.嵌入层</p><p id="7b60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.双向 RNN 模型</p><p id="ddb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.训练模型</p><p id="815d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">6.构建 Flask 应用程序</p><p id="571b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">7.使用码头集装箱的集装箱化</p><p id="36af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">8.将 Docker 映像推送到 AWS ECR</p><p id="8be6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">9.在 AWS EC2 上部署 Flask 应用程序</p><h2 id="839a" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">数据</h2><p id="703f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们将使用<a class="ae ls" href="https://github.com/bfelbo/DeepMoji/tree/master/data" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">深度莫吉</strong> </a>数据集，特别是 PsychExp 数据集来构建模型。数据集由<strong class="ky ir"> 7840 </strong>个样本组成，其中每一行包含一条文本消息和编码为一个热点向量的标签。这些标签属于这 7 类中的一类——快乐、恐惧、愤怒、悲伤、厌恶、羞耻、内疚。数据集中的一行示例如下:<code class="fe nm nn no np b">[ 1. 0. 0. 0. 0. 0. 0.] I am very happy today.</code></p><h2 id="4a34" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated"><strong class="ak">数据提取和处理</strong></h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Extracting text and labels from the pickled dataset.</figcaption></figure><p id="e4a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们从 pickle 文件中提取文本和标签，然后将它们写入一个文本文件。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Separating Labels and Texts</figcaption></figure><p id="c68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在读取文本文件函数中，我们返回一个包含文本消息和标签的列表。然后，我们将消息和标签分离到单独的列表中。</p><p id="1da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何 ML 模型，我们都必须以数字格式输入数据，以便进行处理。类似地，为了在 7 个类别中分类我们的输入文本，我们必须将我们的输入句子转换成单词向量表示。为此，我们将使用预先训练的 50 维手套单词嵌入。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的“read_glove_vector”函数返回给定单词的索引列表、给定索引的单词以及每个单词对应的 50 维表示。</p><h2 id="f061" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">嵌入层</h2><p id="de48" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在构建嵌入层之前，让我们知道为什么要使用嵌入层。让我们考虑我们有 1000 个单词的文本语料库。文本中每个单词的一个热编码将是具有 999 个零和 1 个非零值的向量。这些向量非常稀疏，不太适合大型数据集。在单词嵌入中，单词由密集向量表示，其中每个向量是单词在连续向量空间中的投影。因此，单词嵌入帮助将单词投影到一个更低的维度，而不是将单词投影到一个更高的维度。此外，单词嵌入帮助我们捕捉单词之间的关系，否则使用一个热编码向量难以捕捉。让我们看看如何为我们的应用程序实现这个嵌入层:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d11d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，嵌入层的第一个参数是手套单词嵌入中的单词总数，第二个参数是每个单词在向量空间中表示的维度。</p><h2 id="f119" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">双向 RNN 模型</h2><p id="ab1d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">双向 RNN 有两个网络，一个正向训练信息，另一个反向训练信息。因此，这些模型可以访问过去和未来的数据，而标准的 LSTM 模型只能访问过去的数据。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/50fb6533cdc0c9e85a9fa3321f0510d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*N78Lm_Fn5LkF-G9Rb3PzMA.jpeg"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Bi-Directional LSTM</figcaption></figure><p id="0183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在使用 Keras 的应用程序中看到它的实现。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">LSTM Model</figcaption></figure><p id="0e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们正在构建一个深度递归神经网络，它包含一个具有批量归一化和丢失的双向 LSTM。此处使用 Softmax 激活来获得跨 7 个类别的概率分布。</p><p id="c8cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简化的图像，显示了我们整个 LSTM 模型的架构。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nt"><img src="../Images/6fa34971e7f145a9796f339ee090e193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODolT2JxnftsksCBlu8lsw.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk"><a class="ae ls" href="http://thelillysblog.com/2017/10/02/sentiment-analysis-with-deep-learning/" rel="noopener ugc nofollow" target="_blank">Architecture of our Neural Network</a></figcaption></figure><h2 id="8daf" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">训练模型</h2><p id="3c7a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们将使用分类交叉熵作为损失函数，因为我们将在 7 个类别中对输出进行分类。我们将试图在每个时期最小化这种损失，以便它在测试数据上表现良好。Adam optimizer 用于帮助我们加快训练过程。准确性是我们在这里用来评估模型的性能指标。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="0349" class="mx lv iq np b gy ny nz l oa ob">X_train = pad_sequences(train_tokenized, maxlen = maxlen)<br/>X_test = pad_sequences(test_tokenized, maxlen = maxlen)</span><span id="8a69" class="mx lv iq np b gy oc nz l oa ob">model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])</span><span id="d013" class="mx lv iq np b gy oc nz l oa ob">model.fit(X_train, np.array(y_train), epochs = 30, batch_size = 32, shuffle=True)</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi od"><img src="../Images/8fb6809f7677d29d41837cf62d577f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zgwfpx7f1OlsAIQy45QQXg.png"/></div></div></figure><p id="cb34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将使用 Tensorflow 的 save_model 来保存 Keras 模型，以便我们稍后可以加载它来给出预测。经过 30 个周期的训练，准确率达到了 86%。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="ec73" class="mx lv iq np b gy ny nz l oa ob">model.save('emoji_model.h5')<br/>model = load_model('emoji_model.h5')</span></pre><h2 id="01ad" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">构建 Flask 应用程序</h2><p id="58e8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">首先我们必须使用命令- <code class="fe nm nn no np b"><strong class="ky ir">pip install flask</strong></code> <strong class="ky ir">安装 flask。</strong>然后创建一个名为 application.py 的文件，这是我们应用程序的主要后端文件。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们必须实例化 Flask 类的一个对象。然后，我们使用 load_model 函数加载已经训练好的模型。我们还为文本标记器保存了一个 pickle 文件，以便它可以用于标记未来的文本输入。有两条路线-预测和更新。“预测”路由接收输入文本字段中输入的值，我们使用 tokenizer 对象对文本进行标记。我们使用加载的模型对输入文本进行预测，然后以 JSON 格式返回响应。“更新”路线用于在预测值不正确时更新预测值，以便针对新输入对模型进行微调。虽然这可能不是在大规模系统中更新模型的正确方法，但我想尝试一下模型再训练是如何工作的。为了返回预测的正确表情响应，创建了以下 Javascript 文件。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3f72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个 Javascript 文件可以通过从下拉列表中选择值来帮助我们进行更新操作，并向“update”路由发送 POST 请求来更新值。我不太擅长构建 UI，因此前端部分可以根据我们的需要进行更改。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c1c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使我们的应用程序在主机 0.0.0.0 和端口 5000 上运行。我们也将在 Docker 文件中对此进行配置。这是在我们的 localhost 中运行后的最终应用程序的样子。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/7362416425fb99cad785acd94fc2857f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iR-GlZVjRnVU9YGdf5hsFg.png"/></div></div></figure><h2 id="88c2" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">使用码头集装箱的集装箱化</h2><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a3f783a56576c0b58d1e9c24814af7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*hClfljxq29JkJrgiwR_v5g.png"/></div></figure><p id="42cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker 是一个开源应用程序，允许用户使用容器创建、管理和部署应用程序。使用 Docker 运行的应用程序驻留在它们自己的环境中，并且拥有运行应用程序所需的依赖关系。Docker 可以使用以下<a class="ae ls" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lt">链接</em> </strong> </a> <strong class="ky ir"> <em class="lt">安装在 Mac 上。</em> </strong>安装 docker 后移动到我们终端中的应用文件夹。创建一个 docker 文件，指导 docker 安装依赖项并在构建 Docker 映像时执行其他命令。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="184c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的 docker 文件指示 Docker 从 Docker hub 安装 python，然后创建一个‘app’目录来复制我们 web app 的所有内容。然后它会安装 requirements.txt 文件中提到的所有包。则暴露端口 5000 以从容器外部访问应用程序。默认情况下，使用 CMD 命令运行 application.py 文件。我们将把 docker 图像命名为“flaskapp”。现在我们必须使用以下命令构建 docker 映像。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="5007" class="mx lv iq np b gy ny nz l oa ob">docker build -t flaskapp:latest .</span></pre><p id="32d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“.”在这个命令的末尾，复制当前目录中的所有文件来构建镜像。然后，我们将使用上面创建的 docker 映像在端口 5000 运行 docker 容器。该命令如下所示:</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="a93a" class="mx lv iq np b gy ny nz l oa ob">docker run -p 5000:5000 flaskapp</span></pre><p id="39b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在浏览器的端口 5000 上启动应用程序，检查应用程序是否可在容器外部访问。</p><h2 id="3510" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">将 Docker 映像推送到 AWS ECR</h2><p id="a45f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我假设在 AWS 中已经创建了一个帐户。如果没有，任何人都可以按照这个<a class="ae ls" href="https://aws.amazon.com/free/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lt">链接</em> </strong> </a> <strong class="ky ir"> <em class="lt">免费上手。</em> </strong>我们必须使用<code class="fe nm nn no np b"><strong class="ky ir">pip install awscli --upgrade --user</strong></code>在桌面上安装<code class="fe nm nn no np b"><strong class="ky ir">awscli</strong></code>，以便直接从终端执行 AWS 中的操作。我们必须从我们的终端使用命令<code class="fe nm nn no np b"><strong class="ky ir">aws configure</strong></code> <strong class="ky ir"> </strong>来配置我们的 AWS 凭证，在这里我们输入我们的访问密钥 ID、秘密访问密钥、默认区域和输出格式。</p><p id="0e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用 AWS 弹性容器注册表来存储和部署我们的 docker 容器映像。为了存储 Docker 图像，我们必须首先在 AWS ECR 中创建一个存储库。这是使用以下命令完成的:</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="b928" class="mx lv iq np b gy ny nz l oa ob">aws ecr create-repository --repository-name ml_flask_app</span></pre><p id="11ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，为了获得访问 AWS ECR 的权限，我们输入以下命令-</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="0675" class="mx lv iq np b gy ny nz l oa ob">$(aws ecr get-login --region region_name --no-include-email)</span></pre><p id="12c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们在本地用创建的存储库标记我们的 flaskapp 容器。在这里，每个用户的 account_id 和 region name 是不同的。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="0730" class="mx lv iq np b gy ny nz l oa ob">docker tag flaskapp:latest aws_account_id.dkr.ecr.region_name.amazonaws.com/</span></pre><p id="4f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们必须将本地 docker 映像推送到在 AWS ECR 中创建的存储库中。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="02a0" class="mx lv iq np b gy ny nz l oa ob">docker push aws_account_id.dkr.ecr.region_name.amazonaws.com/ml_flask_app</span></pre><h2 id="e2e1" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated"><strong class="ak">在 AWS EC2 上部署 Flask 应用</strong></h2><p id="9d7e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">将图像推送到 AWS ECR 后，我们必须创建一个 EC2 实例，在其中我们可以为 web 应用程序提供服务。AWS 在免费层范围内提供了许多实例，我们可以利用这一点。我们将启动一台 Linux 机器，其中大部分配置都是默认设置的，只有安全组进行了如下更改:</p><p id="710d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SSH -&gt;仅从我们的 IP 和</p><p id="7524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义 TCP -&gt;端口 5000。</p><p id="1d9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些安全组规则是我们的 web 应用程序运行所必需的。一旦实例启动并运行，我们可以通过在终端中的‘PEM’文件所在的同一文件夹中输入以下命令来 ssh 到实例中。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="7ab3" class="mx lv iq np b gy ny nz l oa ob">ssh -i "test_ml_app.pem" <a class="ae ls" href="mailto:ec2-user@ec2-18-191-94-75.us-east-2.compute.amazonaws.com" rel="noopener ugc nofollow" target="_blank">ec2-user@ec2-12-345-67-89.us-east-1.compute.amazonaws.com</a></span></pre><p id="fdb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们登录到实例中，我们可以使用下面的命令安装 docker 并启动它。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="771a" class="mx lv iq np b gy ny nz l oa ob">sudo yum install -y docker<br/>sudo docker service start</span></pre><p id="bb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须像以前一样通过再次输入 aws configure 命令来配置 AWS 凭证。然后输入以下命令，以便添加 ec2 用户来在 Linux 机器上执行 docker 命令。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="7f01" class="mx lv iq np b gy ny nz l oa ob">sudo groupadd docker<br/>sudo gpasswd -a ${USER} docker<br/>sudo service docker restart</span></pre><p id="8a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后退出该实例，并再次使用 ssh 进入该实例。运行以下命令从 AWS ECR 中提取 docker 映像，然后在 Linux 机器中运行 docker 容器。</p><pre class="kh ki kj kk gt nu np nv nw aw nx bi"><span id="1f46" class="mx lv iq np b gy ny nz l oa ob">docker pull account_id.dkr.ecr.region_name.amazonaws.com/ml_flask_app_:latest</span><span id="be6b" class="mx lv iq np b gy oc nz l oa ob">docker run -p 5000:5000 account_id.dkr.ecr.region_name.amazonaws.com/ml_flask_app</span></pre><p id="93fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从实例详细信息页面获取实例的公共 IP，并在浏览器中启动时添加端口 5000。瞧啊。！！这款应用终于在 AWS 上运行了。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi og"><img src="../Images/e03c24f01b30ad0495a5255857dace7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_lEyZ48Y3WEarjbBq9ftg.png"/></div></div></figure><p id="f32b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一些给出错误预测的输入。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oh"><img src="../Images/0b066803afdcab4b9418a4b9c55936ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48-tKQ4Lo7909cwjUYdU8w.png"/></div></div></figure><p id="2c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将为上述输入更新标签为“Sad”的模型。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oi"><img src="../Images/93a23847c0cc14b17625319697a67b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BL9sMPfNUL2r2dllLJzcIA.png"/></div></div></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oj"><img src="../Images/c22b58f435ec566aeddcd623884db713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SU7UmufSYd7UoDV-lJPGLA.png"/></div></div></figure><p id="9d72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那里！！该模型已经更新了其对新输入文本的响应，并将尝试改进其对未来输入的预测。</p><p id="8a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这是我的第一个博客，我请求你们分享你们对这个博客的内容和质量的看法。如果有任何疑问，我非常乐意帮忙。你可以在 Linkedin @<a class="ae ls" href="https://www.linkedin.com/in/sriram-muralishankar/" rel="noopener ugc nofollow" target="_blank">Sri ram Muralishankar</a>上和我联系。</p><h2 id="6c86" class="mx lv iq bd lw my mz dn ma na nb dp me lf nc nd mg lj ne nf mi ln ng nh mk ni bi translated">参考资料:</h2><ol class=""><li id="c1e4" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated">深度莫吉数据集-【https://github.com/bfelbo/DeepMoji/tree/master/data T2】</li><li id="173a" class="mm mn iq ky b kz ok lc ol lf om lj on ln oo lr mt mu mv mw bi translated">Coursera 序列模型教程-<a class="ae ls" href="https://github.com/Kulbear/deep-learning-coursera/blob/master/Sequence%20Models/Emojify%20-%20v2.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/kul bear/deep-learning-coursera/blob/master/Sequence % 20 Models/Emojify % 20-% 20 v2 . ipynb</a></li><li id="38be" class="mm mn iq ky b kz ok lc ol lf om lj on ln oo lr mt mu mv mw bi translated">AWS 文档-<a class="ae ls" href="https://docs.aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">https://docs.aws.amazon.com/</a></li><li id="044c" class="mm mn iq ky b kz ok lc ol lf om lj on ln oo lr mt mu mv mw bi translated">码头文件-<a class="ae ls" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/</a></li></ol></div></div>    
</body>
</html>