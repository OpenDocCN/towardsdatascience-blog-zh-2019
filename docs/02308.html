<html>
<head>
<title>Hopfield Networks are useless. Here’s why you should learn them.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hopfield 网络毫无用处。以下是你应该学习它们的原因。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hopfield-networks-are-useless-heres-why-you-should-learn-them-f0930ebeadcd?source=collection_archive---------6-----------------------#2019-04-16">https://towardsdatascience.com/hopfield-networks-are-useless-heres-why-you-should-learn-them-f0930ebeadcd?source=collection_archive---------6-----------------------#2019-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/be0345e67d795fd3d48c4d794da9c467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*75TsP3iRN7ec0-Ff"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@ryanschroeder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ryan Schroeder</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="d11a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Hopfield 网络是由 J.J. Hopfield 于 1982 年发明的，到那时，许多不同的神经网络模型已经被放在一起，相比之下具有更好的性能和鲁棒性。据我所知，它们大多是在教科书中介绍和提到的，当接近玻尔兹曼机器和深度信念网络时，因为它们是建立在 Hopfield 的工作基础上的。</p><p id="e41b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然而，与深度学习的当前状态相比，它们提供了如此不同和替代的学习系统视角，因此值得理解。</p><p id="0086" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们来看看<em class="ll">它们是如何工作的。</em></p><h1 id="b4fe" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">一个基本的 Hopfield 网络及其工作原理</strong></h1><p id="b596" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">Hopfield 网络的核心是一种模型，它可以在收到相同数据的损坏版本后重建数据。</p><p id="d174" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以把它描述为一个由节点——或单元，或神经元——通过链接连接起来的网络。每个单元在任一时刻都有两种状态，我们假设这些状态可以是+1 或-1。我们可以在向量 v 中列出每个单元在给定时间的状态。</p><p id="14b8" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">链接代表单元之间的连接，它们是对称的。换句话说，无论您在图中向哪个方向看，node-i 和 node-j 之间的链接都是相同的。特别是，相同的是代表每个单元之间连接强度的数字。我们可以在矩阵中列出这些数字。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1faa8a694fc722a0502ae6f1034a7a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*fztpVL3Q2EpLzWg5gi6lEQ.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Fig.1 — A Hopfield Network</figcaption></figure><p id="974e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果我们有一个如图 1 所示的网络，我们可以这样描述它:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/b91e8759441828b1435a4fad2e71c9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5VWSO7nmSM1x1Ltwzl-Kw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">A state vector and a weight matrix describe the graph at some point in time</figcaption></figure><p id="6d30" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们如何构建<em class="ll"> W </em>？我们首先注意到一个节点与其自身之间没有连接，因此我们通过将 waa、wbb、wcc、wdd 置零来明确这一点。我们也知道链接或者权重是对称的，所以例如<em class="ll"> wab = wba </em>。所以<em class="ll"> W </em>是零对角线对称的。其余元素是这样填充的:<em class="ll"> wab = Va Vb </em>。结果是矩阵<em class="ll"> W </em>。对于连接权重来说，这是一个聪明的选择，因为它遵循了我们稍后将再次看到的赫比规则。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f579619d0a4d43c22ac12e984709879f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*9WgANQ5c2e4R0ANvB9-dgA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">The weight matrix fully describes the network connections</figcaption></figure><p id="9c64" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们已经建立了权重矩阵，我们需要定义一个规则来确定每个节点的状态。因为我们有二进制状态，我们可以使用这个定律:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8241f79d2ac2f1b66bece26a7f0f8eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*QEXsP9lVr7Vr9CX2NW_jMA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">State update rule</figcaption></figure><p id="815e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">类似地，通过使用上面定义的权重矩阵，我们得到:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/91af1534fdb7530770d5eef05b16875a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5pR2dVWz6-7HiuIpTJm3Q.png"/></div></div></figure><p id="f61c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们可以直观地了解 Hopfield 网络实际上是如何工作的。</p><p id="774f" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">假设我们有一个<em class="ll"> V </em>的腐败版本，我们就叫它<em class="ll"> V' = [1 -1 -1 -1] </em>，这样最后一位就反过来了。我们可以用<em class="ll">V’</em>初始化网络状态。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/5c3d4045604116e721734afa71e060fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*nJOCCLhDWmbmdZlQLGFNIQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Network initialized with corrupted states: d is now -1</figcaption></figure><p id="e710" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以继续用之前建立的规则更新网络状态。对于 Va，我们将有:</p><p id="8370" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">Va = f(wab Vb+WAC Vc+wad Vd)</em>=+1</p><p id="c487" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">注意<em class="ll"> wab Vb </em>和<em class="ll"> wac Vc </em>对<em class="ll"> x </em>都有正的贡献，尽管<em class="ll"> Vb </em>和<em class="ll"> Vc </em>为-1，推动<em class="ll"> Va </em>为+1，而讹误位的贡献方向相反。换句话说，通过像以前一样构建<em class="ll"> W </em>，我们迫使节点在它们应该具有相反符号时处于相反状态，而在它们应该相等时处于相同状态。相反的状态互相排斥，而相同的状态互相吸引。这是赫比规则的一种表述。</p><blockquote class="my mz na"><p id="251e" class="kn ko ll kp b kq kr ks kt ku kv kw kx nb kz la lb nc ld le lf nd lh li lj lk im bi translated"><em class="it">赫布边法则:</em>一起放电的神经元，连接在一起</p></blockquote><p id="c969" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">同理:<br/><em class="ll">Vb = f(wba Va+WBC Vc+wbd Vd)=</em>-1<em class="ll"><br/>Vc = f(WCA Va+WCB Vb+wcd Vd)=</em>-1<br/>现已损坏位:<br/><em class="ll">Vd = f(wda Va+wdc Vc+wdb Vb)=</em>+1</p><p id="565e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">并且<em class="ll"> Va = </em> +1 通过让 wda Va &gt; 0 吸引节点<em class="ll"> d </em>为正，而<em class="ll"> Vc=Vd= </em> -1 通过给予整体正贡献<em class="ll"> wdc Vc + wdb Vd &gt; </em> 0 排斥节点<em class="ll"> d </em>。</p><p id="8df2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">原本相同的节点被驱使变得相同，原本符号相反的节点互相排斥变得相反。</p><p id="5ca3" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp iu">原来的<em class="ll"> V </em>神奇的恢复了！</strong></p><h1 id="b2c4" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">但是* <em class="ne">为什么* </em>有用呢？</h1><p id="a20a" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">到目前为止，我们已经看到，一旦我们用状态向量<em class="ll"> V </em>完全定义了网络——它的<em class="ll">W</em>——我们想要在损坏后恢复，我们可以通过更新网络状态来完成。</p><p id="4a1b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">换句话说，在用<em class="ll">V’</em>初始化网络状态后，我们让网络按照我们之前定义的规律进化，它会收敛到我们最初想要的状态。不仅如此，无论我们持续更新多少次，它都会一直存在。</p><p id="b97b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们找出<em class="ll">为什么是</em>。</p><p id="44b4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以定义一个依赖于图的状态和矩阵的函数。我们将把这个函数称为与网络状态相关的能量函数，并表示为:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b9423ce5f790e0057919e1eaba37edc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*LItMRIv5NRZxeaNuC6e-oA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Energy function in a Hopfield Network</figcaption></figure><h2 id="e62c" class="ng ln it bd lo nh ni dn ls nj nk dp lw ky nl nm ma lc nn no me lg np nq mi nr bi translated">结果#1</h2><p id="0089" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">如果节点<em class="ll"> Vi </em>将其状态从+1 更改为-1，反之亦然，我们将得到:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e628356fb132678abb7873732e3abbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*thcXe91mo-qt4GAJpE6czw.png"/></div></figure><blockquote class="my mz na"><p id="f2cb" class="kn ko ll kp b kq kr ks kt ku kv kw kx nb kz la lb nc ld le lf nd lh li lj lk im bi translated">现在:<br/>如果<em class="it"> Vi </em>从-1 变为+1，那么<em class="it"> dVi </em> = +2 <br/>，这意味着<strong class="kp iu"> <em class="it"> x </em> </strong> <em class="it"> </em>必须为正，<br/>反过来，能量增量必须为负</p></blockquote><p id="c43f" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这意味着如果按照我们的规则更新网络，能量函数会一直递减，它是<em class="ll">单调递减</em>，它会努力达到最低点。</p><h2 id="f6f5" class="ng ln it bd lo nh ni dn ls nj nk dp lw ky nl nm ma lc nn no me lg np nq mi nr bi translated"><strong class="ak">结果#2 </strong></h2><p id="99b1" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">但是有没有一个最低点或者能量会一直减少到负无穷大？</p><p id="e810" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">换句话说，我们试图弄清楚能量增量是否可以为零。<br/>为了让<em class="ll"> dEi = 0 </em>，我们需要，例如，让<em class="ll"> dVi = 0 </em>，这仅在<em class="ll"> Vi(k-1)' = Vi(k)' </em>时成立，其中<em class="ll"> Vi(k-1)' </em>是更新前的节点状态，而<em class="ll"> Vi(k)' </em>是更新后的节点状态。</p><p id="0aa8" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">假设我们有<em class="ll"> Vi(k-1)' = +1 </em>，我们想要<em class="ll"> Vi(k)' = +1 </em>，或者类似的<br/> <em class="ll"> xi(k) &gt; 0 </em>。<br/>这是:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e8b702424de41a1870a7d1b810eb798d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*JgtmAiPxQ8kyOt3ytcpJDQ.png"/></div></figure><p id="22a2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是当<em class="ll"> Vj(k-1)' = Vj </em>那么<em class="ll"> xi(k) </em>总是正的！</p><p id="3b51" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在一个镜头中，我们展示了当状态采用原始值(未损坏的值)时，能量函数将不再改变。换句话说，<em class="ll"> dVi = 0 </em>并且节点不会更新到不同的值——配置被认为是稳定的。</p><blockquote class="nu"><p id="7a1f" class="nv nw it bd nx ny nz oa ob oc od lk dk translated">因此我们证明了在网络达到节点状态的稳定配置之前，能量一直在减少。甚至，稳定配置是对应于恢复的状态向量的配置，即能量函数的局部最小值。</p></blockquote><p id="a2fb" class="pw-post-body-paragraph kn ko it kp b kq oe ks kt ku of kw kx ky og la lb lc oh le lf lg oi li lj lk im bi translated">这里省略了许多实现细节，但是我在这里准备的这个 Jupyter 笔记本中有一个基本的工作 Hopfield 网络。</p></div></div>    
</body>
</html>