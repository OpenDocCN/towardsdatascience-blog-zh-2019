<html>
<head>
<title>How to use the Split-Apply-Combine strategy in Pandas groupby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在熊猫小组中运用分裂-运用-结合策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-the-split-apply-combine-strategy-in-pandas-groupby-29e0eb44b62e?source=collection_archive---------1-----------------------#2019-07-16">https://towardsdatascience.com/how-to-use-the-split-apply-combine-strategy-in-pandas-groupby-29e0eb44b62e?source=collection_archive---------1-----------------------#2019-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过这个熊猫视觉指南掌握 Python 中的分割-应用-组合模式<code class="fe ki kj kk kl b">groupby-apply</code>。</h2></div><h2 id="0979" class="km kn it bd ko kp kq dn kr ks kt dp ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="ea59" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">Pandas <code class="fe ki kj kk kl b">groupby-apply</code>是 Python 数据科学家工具箱中的一个无价工具。在没有完全理解其所有内部复杂性的情况下，您可能会走得很远。然而，有时这可能会表现为意外的行为和错误。吃过吗？或者也许您正在努力解决如何处理更高级的数据转换问题？然后阅读这个熊猫<code class="fe ki kj kk kl b">groupby-apply</code>范例的视觉指南<strong class="lk iu"> </strong>，一劳永逸地理解它是如何工作的。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/3038ccc7f5df85ca2b82ec2b676d3b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlsIJ9oc4PDQu7k5Dy85Hg.jpeg"/></div></div></figure><p id="3463" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated"><em class="ms">来源:我的团队在</em> <a class="ae mt" href="https://sunscrapers.com/?utm_source=medium&amp;utm_medium=article" rel="noopener ugc nofollow" target="_blank"> <em class="ms">晒版机</em> </a> <em class="ms">提供。</em></p><h1 id="0173" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">介绍</h1><p id="57e3" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">在 Pandas 中处理更高级的数据转换和数据透视表时，对<code class="fe ki kj kk kl b">groupby-apply</code>机制的深入理解通常是至关重要的。</p><p id="b033" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这对新手来说可能是一个陡峭的学习曲线，对中级熊猫用户来说也是一种“陷阱”。这就是为什么我想与你分享一些视觉指南，展示当我们运行<code class="fe ki kj kk kl b">groupby-apply</code>操作时实际发生的事情。</p><p id="425e" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">下面是我认为您应该首先了解的一些事情，以便更直接地使用更高级的 Pandas 数据透视表:</p><p id="11e3" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">Groupby —它是做什么的？</p><ol class=""><li id="d06e" class="nf ng it lk b ll mn lo mo kv nh kz ni ld nj ma nk nl nm nn bi translated">应用—它是如何工作的，我们传递给它什么？</li><li id="c5f1" class="nf ng it lk b ll no lo np kv nq kz nr ld ns ma nk nl nm nn bi translated">联合收割机阶段会发生什么？</li><li id="6004" class="nf ng it lk b ll no lo np kv nq kz nr ld ns ma nk nl nm nn bi translated">当自定义函数返回一个序列时会发生什么？</li><li id="4376" class="nf ng it lk b ll no lo np kv nq kz nr ld ns ma nk nl nm nn bi translated">当它返回一个数据帧时呢？</li><li id="7a89" class="nf ng it lk b ll no lo np kv nq kz nr ld ns ma nk nl nm nn bi translated">当自定义函数返回除了上面两个以外的东西时会发生什么？</li></ol><p id="3bde" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">请继续阅读，以获得这些问题的答案以及关于在 Pandas 中使用数据透视表的一些额外见解。</p><h1 id="6acf" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">我们的示例表</h1><p id="3bfb" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">让我们以经典的 Iris 数据集为例(可从 Seaborn 绘图库中获取),为简单起见，将其限制为 15 行:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="25ed" class="km kn it kl b gy nx ny l nz oa">import seaborn as sns</span><span id="e643" class="km kn it kl b gy ob ny l nz oa">iris_data = sns.load_dataset(‘iris’)<br/>df = iris_data.head(5).copy()<br/>df = pd.concat([df, iris_data..iloc[50:55]])<br/>df = pd.concat([df, iris_data.iloc[100:105]])</span></pre><p id="e196" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">该表很小，但足以满足我们的需求，非常适合本文中的演示目的:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/518e4378a2e2d8acdef7190ba1e90a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lbb89FnzrCVdzTB5"/></div></div></figure><h1 id="d6b3" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">使用 groupby()分组</h1><p id="63a6" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">让我们从更新一些关于<code class="fe ki kj kk kl b">groupby</code>的基础知识开始，然后在我们进行的过程中在上面构建复杂性。</p><p id="cb9b" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">您可以将<code class="fe ki kj kk kl b">groupby</code>方法应用于具有简单 1D 索引列的平面表。它还没有在表上执行任何操作，只是返回了一个<code class="fe ki kj kk kl b">DataFrameGroupBy</code>实例，因此需要链接到某种聚合函数(例如，<code class="fe ki kj kk kl b">sum</code>、<code class="fe ki kj kk kl b">mean</code>、<code class="fe ki kj kk kl b">min</code>、<code class="fe ki kj kk kl b">max</code>等)。更多的见这里的<a class="ae mt" href="https://pandas.pydata.org/pandas-docs/stable/reference/groupby.html" rel="noopener ugc nofollow" target="_blank">，它们将对分组行起作用(我们将在后面讨论应用)。</a></p><p id="1ca8" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这里需要记住的重要一点是，它会自动将单个聚合结果连接回一个数据框架。</p><p id="f58e" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">一个非常简单的例子是按特定的列值分组(如我们表中的“物种”),并对所有剩余的适用列求和:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="d063" class="km kn it kl b gy nx ny l nz oa">df.groupby(‘species’).sum()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/78a597ba11fbc10ca8cd17ff711a519b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m-puRNwcnUl5zZ4O"/></div></div></figure><p id="5db2" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">或者，我们可以指定要对哪些列求和。一些人犯的一个常见错误是先计算总和，然后在末尾添加一个列选择器，如下所示:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="7d7e" class="km kn it kl b gy nx ny l nz oa">df.groupby(‘species’).sum()[‘sepal_width’] <em class="ms"># ← BAD!</em></span></pre><p id="7de5" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这意味着首先对每个适用的列(数字或字符串)进行求和，然后选择一个指定的列进行输出。</p><p id="c936" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这里有一个更好的方法:</p><p id="e497" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated"><strong class="lk iu">在聚合函数之前指定列，以便在过程中只对一列求和，从而显著提高速度(对于这个小表是 2.5 倍):</strong></p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="4c65" class="km kn it kl b gy nx ny l nz oa">df.groupby(‘species’)[‘sepal_width’].sum() <em class="ms"># ← BETTER &amp; FASTER!</em></span></pre><p id="3212" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">注意，由于只有一列被求和，因此结果输出是一个<code class="fe ki kj kk kl b">pd.Series</code>对象:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="c36b" class="km kn it kl b gy nx ny l nz oa">species<br/>setosa 16.4<br/>versicolor 14.6<br/>virginica 14.9<br/>Name: sepal_width, dtype: float64</span></pre><p id="ce19" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">但是，如果您想直接自动返回 dataframe 对象(毕竟它的可读性要好得多)，就没有必要通过<code class="fe ki kj kk kl b">pd.Dataframe()</code>进行强制转换。相反，将列名作为列表提供给列选择(本质上，使用双括号)，如下所示:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="fc55" class="km kn it kl b gy nx ny l nz oa">df.groupby(‘species’)[<strong class="kl iu">[</strong>‘sepal_width’<strong class="kl iu">]</strong>].sum()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e98fb315b5e293d7c95ea18d33bb9312.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*Bzt0RvjWZwI5qjX5"/></div></figure><p id="71ad" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">最后，<code class="fe ki kj kk kl b">groupby</code>可以接受一个列名列表，并对所有剩余的适用列(之前没有提到)执行聚合函数。</p><p id="8360" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated"><strong class="lk iu">理解这一点很重要，结果表将有一个</strong> <code class="fe ki kj kk kl b"><strong class="lk iu">MultiIndex</strong></code> <strong class="lk iu">对象作为索引，其行为与常规表略有不同。</strong></p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="fc47" class="km kn it kl b gy nx ny l nz oa">multicol_sum = df.groupby([‘species’, ‘petal_width’]).sum()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oe"><img src="../Images/cf94479fc625ae12200612652554ccd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8aKyrm6_gvZm5A0b"/></div></div></figure><p id="df8d" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated"><strong class="lk iu">有用提示:使用</strong> <code class="fe ki kj kk kl b"><strong class="lk iu">MultiIndex</strong></code> <strong class="lk iu">表时，您可以使用</strong> <code class="fe ki kj kk kl b"><strong class="lk iu">.xs</strong></code> <strong class="lk iu">选择数据帧的子集，方法是选择一个值，然后选择特定的索引级别。产生的输出通常也是 dataframe 对象。</strong></p><p id="1fe9" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这里有一个例子:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="8b7c" class="km kn it kl b gy nx ny l nz oa">multicol_sum.xs(‘virginica’, level=’species’)</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/bc3227b71ba172ca12502944668d4040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t7PJvOoRa-U7CBoY"/></div></div></figure><p id="5d49" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">另外，不要忘记您可以通过运行<code class="fe ki kj kk kl b">reset_idnex</code>方法将索引“展平”成列:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="06b9" class="km kn it kl b gy nx ny l nz oa">multi_sum.reset_index()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi of"><img src="../Images/7e54c92262d9d329d34a7d784f9a44dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hjGBPdkbreAI1CIL"/></div></div></figure><p id="87c1" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">此外，如果您将一个<code class="fe ki kj kk kl b">drop=True</code>参数传递给<code class="fe ki kj kk kl b">reset_index</code>函数，您的输出数据帧将删除组成<code class="fe ki kj kk kl b">MultiIndex </code>的列，并创建一个具有增量整数值的新索引。</p><h1 id="577a" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated"><code class="fe ki kj kk kl b">apply()</code>法</h1><p id="2d33" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">现在让我们进入下一个阶段。</p><p id="aba6" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">我们可以定义自己的自定义函数，并通过<code class="fe ki kj kk kl b">apply()</code>方法在表上运行它，而不是使用 Pandas 提供的常用函数来操作组。</p><p id="f7bc" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">要写好一个自定义函数，你需要理解这两个方法如何在所谓的 Groupby-Split-Apply-Combine 链式机制中相互协作(更多关于这个<a class="ae mt" href="http://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><p id="2e28" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">正如我已经提到的，第一阶段是创建一个 Pandas <code class="fe ki kj kk kl b">groupby</code>对象(<code class="fe ki kj kk kl b">DataFrameGroupBy</code>)，它为 apply 方法提供一个接口，以便根据指定的列值将行分组在一起。</p><p id="f5c6" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">我们暂时将这些组分开，并通过一个优化的 Pandas 内部代码将它们循环。然后，我们将每个组作为一个<code class="fe ki kj kk kl b">Series</code>或<code class="fe ki kj kk kl b">DataFrame</code>对象传递给一个指定的函数。</p><p id="b4bf" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">函数的输出被临时存储，直到所有组都被处理。在最后一个阶段，所有结果(来自每个函数调用)最终被组合成一个输出。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/1f3bf6fe2b2936c7d82864e6fa88d8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pg5iUGsYPVFNpixe"/></div></div></figure><p id="b7cc" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这里有几点我们需要记住，以避免在使用<code class="fe ki kj kk kl b">groupby</code>和<code class="fe ki kj kk kl b">apply</code>方法时可能出现的意外。</p><p id="1250" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">在极少数情况下，当我们被迫使用一个<em class="ms"> for-in </em>循环迭代单个行组时，这一点尤其重要(通常，这是一种不好的做法——然而，在某些情况下这可能是不可避免的)。</p><h1 id="2778" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">1]应用功能</h1><p id="f40c" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">您可以通过几种方式为每组操作提供逻辑。</p><p id="d997" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">您可以定义单独的函数并将其作为要应用的对象传递，也可以直接传递 lambda 表达式。还有一种<code class="fe ki kj kk kl b">.agg()</code>方法，它通过提供一个名称或一系列函数名称来实现多个聚合函数(但这超出了本文的范围)。</p><p id="5933" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">例如，这两个命令</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="f3d7" class="km kn it kl b gy nx ny l nz oa">df.groupby(‘species’).apply(lambda gr: gr.sum())</span></pre><p id="94b3" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">和</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="ef8e" class="km kn it kl b gy nx ny l nz oa">def my_sum(gr):<br/> return gr.sum()</span><span id="e155" class="km kn it kl b gy ob ny l nz oa">df.groupby(‘species’).apply(my_sum)</span></pre><p id="3805" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">产生完全相同的结果:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi og"><img src="../Images/2d18ce0ebc5d6c507aa0dc3ecdc98216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iukLsvgcqxnQXaXk"/></div></div></figure><p id="2433" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">顺便说一下，是的，具有字符串值的列也被“求和”，它们只是简单地连接在一起。</p><h1 id="a57e" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">2]功能输入</h1><p id="59a5" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">定制函数应该有一个输入参数，该参数可以是一个<code class="fe ki kj kk kl b">Series</code>或一个<code class="fe ki kj kk kl b">DataFrame</code>对象，这取决于通过<code class="fe ki kj kk kl b">groupby</code>方法指定的是一列还是多列:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="0e2e" class="km kn it kl b gy nx ny l nz oa">def foo(gr):<br/> print(type(gr))<br/> return None</span><span id="093c" class="km kn it kl b gy ob ny l nz oa">df.groupby(‘species’).apply(foo)</span></pre><p id="dd42" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">产出:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="5761" class="km kn it kl b gy nx ny l nz oa">&lt;class ‘pandas.core.frame.DataFrame’&gt;<br/>&lt;class ‘pandas.core.frame.DataFrame’&gt;<br/>&lt;class ‘pandas.core.frame.DataFrame’&gt;<br/>&lt;class ‘pandas.core.frame.DataFrame’&gt;</span></pre><p id="9cfe" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">，而(忽略这里有 4 行的事实，我稍后会解释)</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="8918" class="km kn it kl b gy nx ny l nz oa">df.groupby(‘species’)[‘petal_length’].apply(foo)</span></pre><p id="cf5f" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">退货:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="3b64" class="km kn it kl b gy nx ny l nz oa">&lt;class ‘pandas.core.series.Series’&gt;<br/>&lt;class ‘pandas.core.series.Series’&gt;<br/>&lt;class ‘pandas.core.series.Series’&gt;</span></pre><h1 id="bc28" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">3]在自定义函数中使用 print()语句</h1><p id="d9c9" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">当编写一个复杂的表转换时，你有时可能想要遍历<code class="fe ki kj kk kl b">apply</code>ed 函数的内部工作方式，并添加一个<code class="fe ki kj kk kl b">print()</code>语句来检查操作过程中发生了什么(我经常这样做，以便在遇到困难时确定方向)。</p><p id="0c37" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">对你们中的一些人来说，这可能很令人吃惊，但是当你运行下面的代码时，你将得到一个你可能没有预料到的额外的位:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="9a62" class="km kn it kl b gy nx ny l nz oa">def foo(gr): <br/> print(gr, ‘\n’)<br/> <br/>df.groupby(‘species’).apply(func=foo)</span></pre><p id="91a0" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这是打印出来的内容:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/167603e1fa35d6f151ec43cfb21864b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lVfvrFTJZSpYmriD"/></div></div></figure><p id="209f" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这种神秘的行为实际上在熊猫文档<a class="ae mt" href="http://pandas.pydata.org/pandas-docs/version/0.24/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">中有解释，但是很容易被忽略——我知道我是这么做的，而且不得不艰难地学习它，所以让我来帮你省点麻烦:</a></p><blockquote class="oh oi oj"><p id="667d" class="li lj ms lk b ll mn ju ln lo mo jx lq ok mp ls lt ol mq lv lw om mr ly lz ma im bi translated"><em class="it">在当前实现中，在第一列/行上应用调用 func 两次，以决定它是否可以采用快速或慢速代码路径。如果 func 有副作用，这可能会导致意外的行为，因为它们会对第一列/行生效两次。</em></p></blockquote><h1 id="3f29" class="mu kn it bd ko mv mw mx kr my mz na ku jz nb ka ky kc nc kd lc kf nd kg lg ne bi translated">4]功能输出</h1><p id="0092" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq kv lr ls lt kz lu lv lw ld lx ly lz ma im bi translated">拼图的最后一块是应用函数的输出，以及如何在<em class="ms">合并</em>阶段处理它。这里发生的事情是，Pandas 从每个后续的组操作中获取所有的输出，并将它们与它们相应的标签连接起来，这些标签也是由<code class="fe ki kj kk kl b">DataFrameGroupBy</code>对象提供的。后者随后被用于创建新的索引。</p><p id="29c1" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这意味着您可以设计一个自定义函数来返回任何内容，它将被放置在组名标签下的特定组的一行中。</p><p id="4931" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这个例子应该很好地说明了这一点:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="801c" class="km kn it kl b gy nx ny l nz oa">def foo(gr):<br/> return pd.Series(“This is a test”)</span><span id="6d8f" class="km kn it kl b gy ob ny l nz oa">df.groupby(‘species’).apply(func=foo)</span></pre><p id="8065" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">将创建:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi on"><img src="../Images/1821aec9fe810ede79a1aa5814e83868.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/0*rNEeM1V-CnJXsB4W"/></div></figure><p id="14b3" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">然而，在大多数情况下(例如，使用 sum 函数)，每次迭代都返回每行一个 Pandas <code class="fe ki kj kk kl b">Series</code>对象，其中索引值用于将值分类到最终数据帧中的正确列名。</p><p id="b0a8" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">这个例子应该说明:</p><p id="265d" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">让我们创建一个定制的<code class="fe ki kj kk kl b">Series</code>对象，并通过<code class="fe ki kj kk kl b">apply</code>方法在每个组上返回它:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="4773" class="km kn it kl b gy nx ny l nz oa">myseries = pd.Series(<br/> data=[‘one’, ‘two’, ‘3’],<br/> index=[‘a’, ‘b’, ‘c’]<br/>)</span><span id="ca5e" class="km kn it kl b gy ob ny l nz oa">def foo(gr):<br/> return myseries</span><span id="17ab" class="km kn it kl b gy ob ny l nz oa">df2.groupby([‘species’, ‘petal_width’]).apply(func=foo)</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oc"><img src="../Images/5b1bb0a4e59ab4388cebe0840c9ecc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cV1Wnmrju3-7GmrJ"/></div></div></figure><p id="8667" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">如果我们为每个迭代组返回一个<code class="fe ki kj kk kl b">DataFrame</code>会怎么样？结果有点有趣，因为它将创建一个具有<code class="fe ki kj kk kl b">MultiIndex</code>结构的表。它将把<code class="fe ki kj kk kl b">DataFrame</code>按原样追加到每一行中，并且它的索引将与组标签值集成在一起，例如:</p><pre class="mc md me mf gt nt kl nu nv aw nw bi"><span id="e621" class="km kn it kl b gy nx ny l nz oa">def foo(gr):<br/> return pd.DataFrame(myseries) </span><span id="6ea8" class="km kn it kl b gy ob ny l nz oa">df2.groupby([‘species’, ‘petal_width’]).apply(func=foo)</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oo"><img src="../Images/c736de1fe77aebebcb503167e7be8a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7GAkqiY-0g47BSgS"/></div></div></figure><p id="ee32" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated"><strong class="lk iu">现在就这样。</strong></p><p id="509a" class="pw-post-body-paragraph li lj it lk b ll mn ju ln lo mo jx lq kv mp ls lt kz mq lv lw ld mr ly lz ma im bi translated">理解这些问题将使您更容易在 Pandas 表上处理一些更复杂的枢轴和操作。每当我陷入困境时，我会时不时地重温这些基础知识——它总能帮助我大大加快这个过程！</p></div></div>    
</body>
</html>