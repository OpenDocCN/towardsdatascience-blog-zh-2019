<html>
<head>
<title>Build a Docker Container with Your Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用你的机器学习模型构建一个 Docker 容器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-docker-container-with-your-machine-learning-model-3cf906f5e07e?source=collection_archive---------3-----------------------#2019-10-04">https://towardsdatascience.com/build-a-docker-container-with-your-machine-learning-model-3cf906f5e07e?source=collection_archive---------3-----------------------#2019-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Docker 初学者模板脚本完全指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a2d68494efc5e4062835325e997c165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1KMeVSWmBe2jx8fu"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@cleipelt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Leipelt</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="05ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名数据科学家，我没有太多的软件工程经验，但是我肯定听过很多关于容器的很棒的评论。我听说过与传统虚拟机相比，它们是多么的轻量级，它们在确保您的代码有一个安全一致的环境方面有多好，以及我的 devops 工作如何节省，以便您可以专注于您的代码。</p><p id="721b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我试图将我自己的模型分类时，我很快意识到它并不那么直观。这一点也不像在 EC2 引导脚本前面加上<code class="fe lv lw lx ly b">RUN</code>那么简单。我发现不一致和不可预测的行为经常发生，学习调试一个新工具可能会令人沮丧。</p><p id="2b00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些促使我创建了这篇文章，其中包含了将 Python 中的 ML 模型分解到 Docker 容器所需的所有代码片段。我将指导您安装您需要的所有 pip 包，并构建您的第一个容器映像。在这篇文章的第二部分的<a class="ae ky" rel="noopener" target="_blank" href="/configure-cloud-environment-for-batch-ml-job-on-aws-82edb5631540">中，我们将设置所有必要的 AWS 环境，并在这个系列的第三部分也是最后一部分开始批处理容器。</a></p><p id="659a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">免责声明 1:我这里说的模型是单个实例上的批处理作业，不是有 API 端点的 web 服务，不是分布式并行作业。如果您遵循本教程，将代码放入容器的整个过程应该不会超过 25 分钟。</em></p><p id="3d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">免责声明 2:如果这是你第一次阅读关于容器的文章，这篇文章可能不会提供理解容器如何工作的必要信息，我强烈建议你在继续之前查阅一些在线教程。</em></p><h1 id="d5b8" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">先决条件</h1><ul class=""><li id="8b65" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated"><a class="ae ky" href="https://aws.amazon.com/account/" rel="noopener ugc nofollow" target="_blank">AWS 账户</a></li><li id="97c6" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">安装了 AWS CLI<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="e41d" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>已安装，账户设置在<a class="ae ky" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> DockerHub </a></li><li id="d9bf" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python 3 </a>已安装</li></ul><h1 id="18f6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">创建 Dockerfile 文件👷🏻‍♀️</h1><p id="a3ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">要将您的代码放入容器，您需要创建一个<code class="fe lv lw lx ly b">Dockerfile</code>，它告诉 Docker 您在应用程序中需要什么。</p><blockquote class="nl nm nn"><p id="218b" class="kz la lz lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Dockerfile</code>是一个文本文档，它包含了用户可以在命令行上调用的所有命令来组合一个图像。</p></blockquote><p id="514a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(您可以从<code class="fe lv lw lx ly b">Dockerfile</code>或<code class="fe lv lw lx ly b">docker-compose.yml</code>构建 Docker 映像。如果你的代码可以被重构为一个多容器 Docker 应用程序，你可能想看看<code class="fe lv lw lx ly b">docker compose</code>，但是现在一个<code class="fe lv lw lx ly b">Dockerfile</code>应该足够了。)</p><p id="cb72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker 映像从基础映像开始，由只读层构建而成，每一层都添加了一些依赖关系。最后，您告诉容器如何触发您的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">minimal Dockerfile for a Python application</figcaption></figure><p id="5f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的 other 文件中，我从基本的 Python 3.6 伸展映像开始，<code class="fe lv lw lx ly b">apt-get</code>更新了系统库，安装了一些<code class="fe lv lw lx ly b">make</code>和<code class="fe lv lw lx ly b">build</code>的东西，检查了我的 Python 和<code class="fe lv lw lx ly b">pip</code>版本以确保它们是好的，建立了我的工作目录，将<code class="fe lv lw lx ly b">requirements.txt</code>复制到容器中，pip 在其中安装了所有的库，最后将所有其他代码文件复制到容器中，列出了所有文件以确保我需要的都在那里，并触发了我的入口点<code class="fe lv lw lx ly b">main.py</code>文件。</p><p id="0fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的代码文件夹结构是这样的，这个<code class="fe lv lw lx ly b">Dockerfile</code>应该对你有用。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="99af" class="nx mb it ly b gy ny nz l oa ob">- app-name<br/>     |-- src<br/>          |-- main.py<br/>          |-- other_module.py<br/>     |-- requirements.txt<br/>     |-- Dockerfile</span></pre><p id="4592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的代码还没有一个<code class="fe lv lw lx ly b">main.py</code>或 shell 脚本来触发模型训练/推理，那么您可能想要首先重构您的代码。还记得用<code class="fe lv lw lx ly b">pipreqs path/to/project</code>将库依赖关系冻结到一个<code class="fe lv lw lx ly b">requirements.txt</code>文件中。我推荐使用<code class="fe lv lw lx ly b">pipreqs</code>而不是<code class="fe lv lw lx ly b">pip freeze</code>，因为当你运行<code class="fe lv lw lx ly b">pip freeze &gt; requirements.txt</code>时，它会输出该环境中所有已安装的包，而<code class="fe lv lw lx ly b">pipreqs</code>只给你这个项目实际导入的包。(如果还没有<code class="fe lv lw lx ly b">pip(3) install pipreqs</code>安装<code class="fe lv lw lx ly b">pipreqs</code></p><p id="b59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的代码已经有了一个入口点，你需要做的就是把<code class="fe lv lw lx ly b">&lt;app- name&gt;</code>改成你的应用程序的名字，我们就可以把它构建成一个图像了。</p><p id="b290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多让<code class="fe lv lw lx ly b">Dockerfile</code>变得更小更高效的<a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">最佳实践</a>，但是大多数都超出了本文的范围。但是，您可能需要注意以下几点:</p><h2 id="5f7c" class="nx mb it bd mc oc od dn mg oe of dp mk li og oh mm lm oi oj mo lq ok ol mq om bi translated">1.1 使用 Python 拉伸作为基础图像</h2><p id="a559" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">人们说不要从一个普通的 Ubuntu 镜像开始，而是使用一个官方的基础镜像，比如 Alpine Python。Alpine Python 是一个基于 Alpine Linux 的非常小的 Python Docker 映像，比默认的 docker python 映像小得多，但仍然拥有最常见的 Python 项目所需的一切。但是我发现使用它非常困难，尤其是在安装包的时候。</p><p id="e187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Ubuntu 基础映像将提供更可预测的行为，但是您需要自己安装所有 Python 的东西。</p><p id="c3b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我建议你从 Python 3.6 stretch 开始，这是基于 Debian 9(又名 stretch)的官方 Python 镜像。Python stretch 附带了 Python 环境和 pip 安装，并且是最新的，如果你选择 Ubuntu，你需要弄清楚如何安装所有这些。</p><h2 id="c455" class="nx mb it bd mc oc od dn mg oe of dp mk li og oh mm lm oi oj mo lq ok ol mq om bi translated">1.2 仅安装您需要的东西</h2><p id="f5bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">复制和粘贴一些网上发布的<code class="fe lv lw lx ly b">Dockerfile</code>模板也很有诱惑力，尤其是如果这是你的第一个 Docker 项目。但是建议只安装你实际需要的东西来控制图像的大小。如果你看到其他人安装了一大堆<code class="fe lv lw lx ly b">make</code>和<code class="fe lv lw lx ly b">build</code>的东西，试着先不要包括它们，看看你的容器是否能工作。较小的映像通常意味着构建和部署速度更快。(你应该试试我上面的极简主义模板的另一个原因！)</p><p id="ef64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样为了保持图像尽可能的简洁，使用<code class="fe lv lw lx ly b">.dockerignore</code>，它的工作方式和<code class="fe lv lw lx ly b">.gitignore</code>完全一样，忽略那些不会影响模型的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">an example .dockerignore file</figcaption></figure><h2 id="3e69" class="nx mb it bd mc oc od dn mg oe of dp mk li og oh mm lm oi oj mo lq ok ol mq om bi translated">1.3 在代码前增加<code class="fe lv lw lx ly b">requirements.txt</code></h2><p id="65a6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在您的<code class="fe lv lw lx ly b">Dockerfile</code>中，总是在复制源代码之前添加您的<code class="fe lv lw lx ly b">requirements.txt</code>文件。这样，当您更改代码并重新构建容器时，Docker 将重用缓存层，直到安装了包，而不是在每次构建时执行<code class="fe lv lw lx ly b">pip install</code>命令，即使库依赖关系从未更改。没有人愿意仅仅因为你在代码中添加了一个空行就多等几分钟。</p><p id="8bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣了解更多关于<code class="fe lv lw lx ly b">Dockerfile</code>的信息，在附录 I 中有我们使用的一些基本命令的快速总结。或者你可以在这里查看 Dockerfile 文档<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="edfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以随意跳到第 2 步，用刚刚创建的<code class="fe lv lw lx ly b">Dockerfile</code>构建一个容器。</p><h1 id="ef92" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">第二步——用你的 docker 文件建立一个图像👩🏻‍🍳</h1><p id="6fed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">准备好<code class="fe lv lw lx ly b">Dockerfile</code>之后，就该构建容器映像了。<code class="fe lv lw lx ly b">docker build</code>根据<code class="fe lv lw lx ly b">Dockerfile</code>中给出的指令创建图像。你所需要做的就是给你的图像一个名字(一个可选的版本标签)。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="5af3" class="nx mb it ly b gy ny nz l oa ob">$ docker build -t IMAGE_NAME:TAG .<br/>$ # or<br/>$ docker build -t USERNAME/IMAGE_NAME:TAG .</span></pre><p id="3066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个命令的唯一区别是图像名称前是否有一个<code class="fe lv lw lx ly b">USERNAME/</code>。映像名称由斜杠分隔的名称组成，通常前缀是注册表主机名。<code class="fe lv lw lx ly b">USERNAME/IMAGE_NAME</code>一般不是指定图像名称的强制格式。但是亚马逊 ECR 存储库中的图像确实遵循完整的<code class="fe lv lw lx ly b">REGISTRY/REPOSITORY:TAG</code>命名约定。比如<code class="fe lv lw lx ly b">aws_account_id.dkr.ecr.region.amazonaws.com/my-web-app:latest</code>。</p><p id="b4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令中发生了一些事情。</p><p id="2fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们告诉 Docker 守护进程获取当前目录中的<code class="fe lv lw lx ly b">Dockerfile</code>(这就是末尾的<code class="fe lv lw lx ly b">.</code>所做的)。</p><p id="25d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们告诉 Docker 守护进程构建图像并给它指定标签。标记对我来说一直很困惑。通常标记图像就像给它一个别名。这与给现有图像指定另一个名称来引用它是一样的。这有助于区分 Docker 图像的版本。</p><p id="03a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指定标记名不是强制性的。在没有指定特定标签的情况下运行构建时，<code class="fe lv lw lx ly b">:latest</code>标签是默认标签。因此，如果您想维护一个好的版本历史，建议您在每次构建之后都明确地标记您的映像。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="1b85" class="nx mb it ly b gy ny nz l oa ob">$ docker build -t USERNAME/IMAGE_NAME .<br/>$ docker tag USERNAME/IMAGE_NAME USERNAME/IMAGE_NAME:1.0<br/>$ ...<br/>$ docker build -t USERNAME/IMAGE_NAME .<br/>$ docker tag USERNAME/IMAGE_NAME USERNAME/IMAGE_NAME:2.0<br/>$ ...</span></pre><p id="20d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在使用<code class="fe lv lw lx ly b">docker build -t USERNAME/IMAGE_NAME:TAG .</code>构建图像时标记图像，或者在构建后像<code class="fe lv lw lx ly b">docker tag SOURCE_IMAGE:TAG TARGET_IMAGE:TAG</code>一样显式标记图像。</p><p id="a136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您运行<code class="fe lv lw lx ly b">docker images</code>，您应该看到本地存在一个图像，它的存储库是<code class="fe lv lw lx ly b">USERNAME/IMAGE_NAME</code>，标签是<code class="fe lv lw lx ly b">TAG</code>。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="395e" class="nx mb it ly b gy ny nz l oa ob">$ docker images</span></pre><p id="562e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还建议您此时在本地机器上测试您的容器，以确保一切正常。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="daf9" class="nx mb it ly b gy ny nz l oa ob">$ docker run USERNAEM/IMAGE_NAME:TAG</span></pre><p id="e579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意查看附录 II，获取一些基本 Docker CLI 命令的快速摘要，或在此处查看官方文档<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/cli/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="4aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您只是将您的模型放入一个可以在任何安装了 Docker 的地方运行的容器中。请加入我这篇文章的第二部分，来配置您的 AWS 环境，以满足调度批处理作业的先决条件。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="8ae4" class="ma mb it bd mc md ou mf mg mh ov mj mk jz ow ka mm kc ox kd mo kf oy kg mq mr bi translated">附录 I — Dockerfile 命令👩🏻‍🏫</h1><ul class=""><li id="ad79" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">FROM</code>启动<code class="fe lv lw lx ly b">Dockerfile</code>。要求<code class="fe lv lw lx ly b">Dockerfile</code>必须以<code class="fe lv lw lx ly b">FROM</code>命令开始。图像是在层中创建的，这意味着您可以使用另一个图像作为您自己的基础图像。<code class="fe lv lw lx ly b">FROM</code>命令定义了你的基础层。作为参数，它采用图像的名称。可选的，你可以添加维护者和镜像版本的 Docker Cloud 用户名，格式<code class="fe lv lw lx ly b"> username/imagename:version</code>。</li><li id="d191" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">RUN</code>用于构建您正在创建的图像。对于每个<code class="fe lv lw lx ly b">RUN</code>命令，Docker 将运行命令，然后创建一个新的图像层。这样，您可以轻松地将映像回滚到以前的状态。<code class="fe lv lw lx ly b">RUN</code>指令的语法是将 shell 命令的全文放在<code class="fe lv lw lx ly b">RUN</code>之后(例如<code class="fe lv lw lx ly b">RUN mkdir /user/local/foo</code>)。这将在一个<code class="fe lv lw lx ly b">/bin/sh</code>外壳中自动运行。您可以像这样定义一个不同的 shell:<code class="fe lv lw lx ly b">RUN /bin/bash -c 'mkdir /user/local/foo'</code>。</li><li id="027f" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">COPY</code>将本地文件复制到容器中。</li><li id="8a85" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">CMD</code>定义启动时将在图像上运行的命令。与<code class="fe lv lw lx ly b">RUN</code>不同，这不会为图像创建一个新层，而只是运行命令。每个 Dockerfile/Image 只能有一个<code class="fe lv lw lx ly b">CMD</code>。如果您需要运行多个命令，最好的方法是让<code class="fe lv lw lx ly b">CMD</code>运行一个脚本。<code class="fe lv lw lx ly b">CMD</code>要求你告诉它在哪里运行命令，不像<code class="fe lv lw lx ly b">RUN</code>。</li><li id="0b0a" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">EXPOSE</code>为镜像用户创建一个提示，提示哪些端口提供服务。它包含在可通过<code class="fe lv lw lx ly b">docker inspect &lt;container-id&gt;</code>检索的信息中。</li><li id="db9e" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">注意:<code class="fe lv lw lx ly b">EXPOSE</code>命令实际上并没有让主机访问任何端口！相反，这需要在使用<code class="fe lv lw lx ly b">docker run</code>时通过<code class="fe lv lw lx ly b">-p</code>标志发布端口。</li><li id="92f8" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">将您的映像推送到私有或云注册表。</li></ul></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="5db7" class="ma mb it bd mc md ou mf mg mh ov mj mk jz ow ka mm kc ox kd mo kf oy kg mq mr bi translated">附录 II — Docker CLI 命令👩🏻‍🏫</h1><p id="1156" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一些基本的 Docker CLI 命令包括:</p><ul class=""><li id="9e0c" class="ms mt it lb b lc ld lf lg li oz lm pa lq pb lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker build</code>从 Dockerfile 文件构建图像</li><li id="b489" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker images</code>显示机器上的所有 Docker 图像</li><li id="589a" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">启动一个容器并在其中运行命令</li><li id="3d5e" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker run</code>选项:</li><li id="659c" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">-p</code>指定主机和 Docker 容器中的端口</li><li id="12d9" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">-it</code>打开交互式控制台</li><li id="d0c7" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">-d</code>以守护模式启动容器(在后台运行)</li><li id="9bd9" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">-e</code>设置环境变量</li><li id="4069" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker ps</code>显示所有正在运行的容器</li><li id="7a7e" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker rmi</code>删除一个或多个图像</li><li id="92a5" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker rm</code>移除一个或多个容器</li><li id="876c" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker kill</code>杀死一个或多个运行中的容器</li><li id="faf2" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker tag</code>用别名标记图像，以便以后参考</li><li id="6bfb" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">docker login</code>登录您的 Docker 注册表</li></ul></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="87b4" class="ma mb it bd mc md ou mf mg mh ov mj mk jz ow ka mm kc ox kd mo kf oy kg mq mr bi translated">关于作者</h1><p id="4f44" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><em class="lz">我是一名机器学习工程师，除了技术教程之外，我还撰写关于生产力和自我发展的文章。我在 7 月 4 日参观了黄石公园，这就是封面图片。</em></p></div></div>    
</body>
</html>