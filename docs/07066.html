<html>
<head>
<title>Deploy a Keras Model for Text Classification using TensorFlow Serving (Part 1 of 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TensorFlow 服务部署用于文本分类的 Keras 模型(第 1 部分，共 2 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-kaggle-solution-with-tensorflow-serving-part-1-of-2-803391c9648?source=collection_archive---------10-----------------------#2019-10-06">https://towardsdatascience.com/deploying-kaggle-solution-with-tensorflow-serving-part-1-of-2-803391c9648?source=collection_archive---------10-----------------------#2019-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9f8cd44a2837dd6eaae7de6d0804235d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WiLrsJja3IXmUNl5.png"/></div></div></figure><p id="82eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">注:</em> </strong> <em class="kz">这是在 TensorFlow 1.0 中完成的</em></p><p id="66b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">更新:</strong>抱歉，不会有第二部了。这里使用的许多函数在 2.X 中不再受支持。相反，我写了<a class="ae la" rel="noopener" target="_blank" href="/deploying-a-text-classifier-with-tensorflow-serving-docker-in-2-0-cba6851e46ed?source=post_stats_page-------------------------------------">这篇文章，介绍如何在 TensorFlow 2.0 </a>中提供类似的分类器。</p><p id="3be8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是附带的<a class="ae la" href="https://github.com/happilyeverafter95/toxic-comment-classifer" rel="noopener ugc nofollow" target="_blank"> Github 回购</a>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="69e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大约两年前，我使用 Keras 库为<a class="ae la" href="https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/" rel="noopener ugc nofollow" target="_blank"> Kaggle 的有毒评论分类挑战构建了一个解决方案。</a>该解决方案集成了多个深度学习分类器，实现了 98.6%的平均 ROC。</p><p id="ed30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像我提交的大多数 Kaggle 文件一样，这份文件是 Jupyter 笔记本中的一堆杂乱的代码，除了生成一个非常随意的 csv 文件之外，几乎没有其他用途。为了使我的提交更有用，我选择了 ensemble 解决方案中使用的一个模型，对其进行了清理，并使用 TensorFlow 为模型推理公开了一个 HTTP 端点。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h1 id="28f0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">比赛背景</h1><blockquote class="mg mh mi"><p id="3d96" class="kb kc kz kd b ke kf kg kh ki kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ky im bi translated">在这场比赛中，你面临的挑战是建立一个多头模型，能够比 Perspective 的<a class="ae la" href="https://github.com/conversationai/unintended-ml-bias-analysis" rel="noopener ugc nofollow" target="_blank">当前模型</a>更好地检测不同类型的毒性，如威胁、淫秽、侮辱和基于身份的仇恨。你将使用维基百科谈话页面编辑的评论数据集。对当前模式的改进将有望帮助在线讨论变得更有成效和尊重。</p></blockquote><p id="9c62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该数据集包含大量被评估为有毒行为的维基百科评论。每个注释被分配一个二进制指示符，指示它们是否:</p><ul class=""><li id="e511" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">有毒的</li><li id="ab04" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">剧毒</li><li id="72cb" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">猥亵的</li><li id="9038" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">威胁</li><li id="57c5" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">侮辱</li><li id="4bba" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">身份仇恨</li></ul><h1 id="bf22" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">问题陈述</h1><p id="d570" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">为简单起见，我们将只关注基本的有毒类。给定一条文本评论，我们的分类器能确定这条评论是否有毒吗？</p><h1 id="a471" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">模型部署</h1><p id="923b" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">模型部署是将机器学习模型与生产环境相集成的过程，通常是为了使推理可用于其他业务系统。数据被发送到模型服务器，在那里进行预处理并用于生成推理结果。推断结果随后被返回给消费应用程序。</p><h1 id="b83e" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">真实生活应用</h1><p id="f9f1" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">想象一下，我们正在运行一个聊天平台，它促进了文本消息的交换。根据设计，我们的系统会过滤掉所有有害信息。</p><figure class="nl nm nn no gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/47539399656e5c1f34e4a5c668b66f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*fzW1KO7G8E4zXURz.jpg"/></div></figure><p id="46af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们系统中的数据流可能如下所示:</p><ul class=""><li id="2377" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">用户写了一条消息</li><li id="8ff5" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">我们的应用程序服务接收消息。应用程序服务通过 POST 请求将消息(以及任何相关的元数据)发送到我们的模型服务器</li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="ba1f" class="nu lj it nq b gy nv nw l nx ny">message_payload = {<br/>    'message': 'got plans today?',<br/>    'region': 'CA'<br/>}</span></pre><ul class=""><li id="829e" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">模型服务器使用消息和元数据作为预测器返回推理输出</li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="f212" class="nu lj it nq b gy nv nw l nx ny">inference_payload = {<br/>    'toxic': False,<br/>    'probability': 0.93,<br/>    'version': 'toxicity-detector-3.0'<br/>}</span></pre><ul class=""><li id="8028" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">app 系统接收推理有效载荷，并决定是否应该发送消息。app 系统还可以将推断结果写入数据库。</li></ul><h1 id="ddbf" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">数据获取和管理</h1><p id="51d2" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">数据采集是每个建模过程中最重要的步骤之一，也是最具挑战性的步骤。<a class="ae la" href="https://www.kdnuggets.com/2019/01/data-scientist-dilemma-cold-start-machine-learning.html" rel="noopener ugc nofollow" target="_blank">冷启动问题</a>是每个数据科学家都会遇到的头疼问题。这是 Kaggle 竞赛不总是代表真实生活数据科学项目的最大原因之一。</p><p id="b357" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在生产环境中工作还会给数据获取和数据管理带来额外的注意事项。为了让我们的模型可以通过本地机器访问，我们需要构建管道来检索我们的数据，而不是在机器之间传递平面文件。</p><h1 id="cfad" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">Kaggle API</h1><p id="1abb" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">记住最后一点，我们转向<a class="ae la" href="https://www.kaggle.com/docs/api" rel="noopener ugc nofollow" target="_blank"> Kaggle API </a>。Kaggle API 允许以编程方式/通过命令行界面下载 Kaggle 数据集。</p><ol class=""><li id="d12f" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky nz ms mt mu bi translated">如果您还没有 Kaggle 帐户，请创建一个</li><li id="94c6" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky nz ms mt mu bi translated">在<code class="fe oa ob oc nq b">kaggle.com/USERNAME/accounts.</code>生成新令牌这将提示您下载一个<code class="fe oa ob oc nq b">kaggle.json</code>文件，其中包含访问 API 的凭证</li><li id="c170" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky nz ms mt mu bi translated">确保您接受<a class="ae la" href="https://www.kaggle.com/c/jigsaw-toxic-comment-classification-challenge/rules" rel="noopener ugc nofollow" target="_blank">竞赛规则</a>(这是下载数据的要求)</li></ol><p id="5aa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.将凭证从 json 文件导出为环境变量:</p><p id="529e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe oa ob oc nq b">export KAGGLE_USERNAME = [kaggle username]</code></p><p id="be86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe oa ob oc nq b">export KAGGLE_KEY = [generated key]</code></p><h1 id="9d06" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">数据管道</h1><p id="6d9a" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">导出 Kaggle 凭证后，我们可以构建一个简单的数据管道来从 Kaggle API 获取数据，并执行任何功能工程/数据清理步骤。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d821" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据管道包含在类结构中。训练数据和测试数据将作为类变量存储。入口点是<code class="fe oa ob oc nq b">preprocess</code>方法，它用预处理的训练和测试返回一个实例化的<code class="fe oa ob oc nq b">DataPipeline</code>类。</p><p id="722d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">预处理步骤序列包含在<code class="fe oa ob oc nq b">preprocessing_steps</code>变量中。在<code class="fe oa ob oc nq b">preprocess()</code>调用期间，每个步骤都按照它们出现的顺序应用于两个数据集。</p><p id="209c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个模型使用的预处理步骤非常简单:缺失的注释用<code class="fe oa ob oc nq b">UNKNOWN</code>文本进行估算，所有注释都转换成小写。</p><h1 id="c205" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">建模过程</h1><p id="86ff" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">文本分类器是使用 Keras 库构建的。</p><h2 id="3dc4" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">对文本进行标记</h2><p id="9be6" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">标记化是提取每个唯一标记(这里，我们基于空格分隔来确定标记)并将其映射到唯一数字/向量的过程。</p><p id="1308" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个模型使用的标记化非常简单。每个令牌被任意分配给一个整数。虽然保留了令牌的序列，但是没有映射提供关于令牌的显式信息。使用预先训练的 GloVe/word2vec 嵌入可能会给我们带来性能优势，但它会增加这些嵌入存储位置的复杂性。</p><p id="39b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，记号赋予器也被限制为前 10，000 个最常用的记号(这是由<code class="fe oa ob oc nq b">max_features</code>参数设置的)。</p><p id="b712" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑一个玩具例子:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="89dc" class="nu lj it nq b gy nv nw l nx ny">tokenizer.word_index = {<br/>    'the': 1,<br/>    'brown': 2,<br/>    'fox': 3,<br/>    'jumped': 4,<br/>    'over': 5,<br/>    'lazy': 6,<br/>    'dog': 7,<br/>    'quick': 8}</span></pre><p id="16e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">短语<em class="kz">快速的棕色狐狸跳过懒惰的狗</em>将被映射到<code class="fe oa ob oc nq b">[1, 8, 2, 3, 4, 5, 1, 6, 7]</code></p><h2 id="b8fa" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">填充标记化的文本</h2><p id="092f" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">可变长度序列必须转换成相同的长度。我们通常选择<code class="fe oa ob oc nq b">0</code>来填充每个标记化的向量，使得每个输入都是相同的长度。</p><p id="6e67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的模型中，我们设置了<code class="fe oa ob oc nq b">max_len = 100</code>，它将每个观察限制为 100 个令牌。少于 100 个标记的观察值将被填充，多于 100 个标记的观察值将被截断。</p><p id="13a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认是从前面(注释的开头)截断/填充。</p><p id="dd9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果<code class="fe oa ob oc nq b">max_len = 10.</code>，我们之前的标记化短语将被填充为<code class="fe oa ob oc nq b">[0, 1, 8, 2, 3, 4, 5, 1, 6, 7]</code></p><h2 id="4119" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">用于分类的递归神经网络</h2><p id="95e0" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">让我们一次看完每一层。</p><p id="02a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">嵌入层</strong></p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="c50c" class="nu lj it nq b gy nv nw l nx ny">model.add(Embedding(self.max_features, self.embed_size))</span></pre><p id="c183" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嵌入层只能用作第一层。标记化的文本被传递到这一层，并作为密集向量输出。我们将输入的形状定义为(词汇特征的数量，每个嵌入的大小)。除非另有说明，否则初始嵌入权重作为训练过程的一部分被随机化和细化。</p><p id="e712" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">轮回层</strong></p><p id="d269" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">注意:我减少了原始解决方案中的单元数量，以便在没有 GPU 的情况下更容易训练这个模型</em></p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="6eac" class="nu lj it nq b gy nv nw l nx ny">model.add(Bidirectional(LSTM(100, return_sequences=True)))</span></pre><p id="01bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自嵌入层的密集向量被传递到递归层。该循环图层使用 LSTM 单位。LSTM 单元使用三个门来调节来自新观测的信息:<em class="kz">输入门</em>调节传递到单元中的信息的范围，<em class="kz">存储门</em>调节保留多少信息，<em class="kz">输出门</em>调节从单元输出的信息。</p><p id="955e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顺序模型在每个时间步消耗一个令牌。第一个令牌(或本例中的单词)在第一个时间步长消耗，第二个令牌在第二个时间步长消耗，依此类推。</p><p id="6c0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们设置<code class="fe oa ob oc nq b">return_sequences=True</code>，那么将返回每个时间步长的输出。当此参数设置为 false 时，将仅返回最后一个时间步长的输出(在整个观察被处理后)。</p><p id="88ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">全局最大池层</strong></p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="3e33" class="nu lj it nq b gy nv nw l nx ny">model.add(GlobalMaxPooling1D())</span></pre><p id="7a3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">池是一种降采样技术，通过只保留最重要的信息来降低维数。全局最大池常用于自然语言处理的神经网络中。</p><p id="abf6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，全局最大池层吸收每个时间步长的输出，并选择每个步长的最大值来组合维数减少的输出。</p><p id="b8c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">密集层(输出)</strong></p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="1d01" class="nu lj it nq b gy nv nw l nx ny">model.add(Dense(2, activation='softmax'))</span></pre><p id="692d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">密集层使用 softmax 激活函数来输出类别概率。</p><h1 id="bf28" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">在本地部署模型</h1><p id="789f" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">TensorFlow 服务是部署 TensorFlow/Keras 模型的最简单方法之一。服务器使用<code class="fe oa ob oc nq b">SavedModel</code> API 来公开模型预测的推理端点。要了解更多关于 TensorFlow 服务的信息，我建议阅读以下资源:</p><ul class=""><li id="aa68" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated"><a class="ae la" href="https://medium.com/tensorflow/serving-ml-quickly-with-tensorflow-serving-and-docker-7df7094aa008" rel="noopener">https://medium . com/tensor flow/serving-ml-quickly-with-tensor flow-serving-and-docker-7df 7094 aa 008</a></li><li id="2c79" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><a class="ae la" href="https://github.com/tensorflow/serving" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/serving</a></li></ul><h2 id="c523" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">SavedModel API</h2><p id="debc" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated"><code class="fe oa ob oc nq b"><a class="ae la" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/README.md" rel="noopener ugc nofollow" target="_blank">SavedModel</a></code> API 将整个 TensorFlow 会话导出为包含在单个目录中的语言不可知格式。</p><p id="8db4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该目录具有以下结构:</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="7ed1" class="nu lj it nq b gy nv nw l nx ny">assets/<br/>assets.extra/<br/>variables/<br/>    variables.data-?????-of-?????<br/>    variables.index<br/>saved_model.pb</span></pre><ul class=""><li id="df47" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated"><strong class="kd iu"> saved_model.pb </strong>包含了<code class="fe oa ob oc nq b">MetaGraphDef</code>类，定义了数据流结构</li><li id="8baf" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><strong class="kd iu">资产</strong>子目录包含所有辅助模型文件</li><li id="ebe5" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><strong class="kd iu"> assets.extra </strong>子目录包含其他库生成的资产</li><li id="bc52" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><strong class="kd iu">变量</strong>子目录包含用于恢复推理模型的权重</li></ul><h2 id="0749" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">构建张量流图</h2><p id="022c" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">完整的代码可以在<a class="ae la" href="https://github.com/happilyeverafter95/toxic-comment-classifer/blob/master/profanity_detector/model.py#L52" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="ff7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">张量流图包含训练模型所需的所有计算。这包括用于预处理输入的任何步骤。通过在图形定义中定义标记化和填充步骤，客户机将能够向模型输入原始文本。</p><p id="ca88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然将标记化步骤合并到图中非常方便，但是在其他预处理步骤中这样做有几个缺点:</p><ul class=""><li id="003f" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">由于选项非常有限，并不是所有的预处理步骤都是可行的(我们实现的那些步骤经常会变得杂乱无章)</li><li id="369b" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">预处理变得难以并行化</li><li id="a394" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">代码变得非常混乱</li></ul><h2 id="9304" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">部署我们的 Keras 模型</h2><p id="44cf" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">在使用 Keras 库训练模型之后，我们可以提取模型权重并将它们加载到 TensorFlow 会话中定义的非常相似的模型中。可以使用<code class="fe oa ob oc nq b">get_weights()</code>方法提取重量。</p><p id="a5d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要创建一个查找表来标记原始文本。当令牌不存在于我们的词汇表中时，我们将它映射到 0。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e37f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们为客户端输入定义一个占位符。输入被标记化(由单个空格分隔的标记)、整形并评估填充/截断。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d9d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用<code class="fe oa ob oc nq b">InputLayer.</code>重新定义模型</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bfdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义了代表输入和模型输出的<code class="fe oa ob oc nq b">x_info, y_info</code>。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="ca54" class="nu lj it nq b gy nv nw l nx ny">x_info = tf.saved_model.utils.build_tensor_info(x_input)        y_info = tf.saved_model.utils.build_tensor_info(serving_model.output)</span></pre><p id="1e70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可选地，我们可以将元数据作为模型有效负载的一部分。在这里，我们将模型版本包装成一个张量。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="df3e" class="nu lj it nq b gy nv nw l nx ny">model_version_tensor = tf.saved_model.utils.build_tensor_info(tf.constant(version))</span></pre><p id="6e1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用它来创建预测签名:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="c027" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">要在本地设置 TensorFlow 服务器:</h2><ol class=""><li id="e7f8" class="mm mn it kd b ke nf ki ng km oq kq or ku os ky nz ms mt mu bi translated">安装<a class="ae la" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">对接器</a></li><li id="291e" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky nz ms mt mu bi translated">使用<code class="fe oa ob oc nq b">docker pull tensorflow/serving:latest</code>获取 TensorFlow 服务 docker 映像的最新版本</li><li id="4add" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky nz ms mt mu bi translated">导出包含<code class="fe oa ob oc nq b">SavedModel</code>文件的目录。这应该是<code class="fe oa ob oc nq b">/model</code>目录:<code class="fe oa ob oc nq b">ModelPath="$(pwd)/model"</code></li><li id="0bcc" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky nz ms mt mu bi translated">通过公开 REST API 端点的端口 8501 来启动服务器</li></ol><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="649c" class="nu lj it nq b gy nv nw l nx ny">docker run -t --rm -p 8501:8501 \<br/>    -v "$ModelPath/:/models/toxic_comment_classifier" \<br/>    -e MODEL_NAME=toxic_comment_classifier \<br/>    tensorflow/serving</span></pre><p id="adb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">会出现一堆日志。每个日志中的第一个字符将指示进程的状态。</p><ul class=""><li id="9ab2" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated"><strong class="kd iu"> E =错误</strong></li><li id="8e6e" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><strong class="kd iu"> W =警告</strong></li><li id="195c" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><strong class="kd iu"> I =信息</strong></li></ul><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="4e17" class="nu lj it nq b gy nv nw l nx ny">docker run -t --rm -p 8501:8501    -v "$<!-- -->ModelPath<!-- -->/:/models/<!-- -->toxic_comment_classifier<!-- -->"    -e MODEL_NAME=<!-- -->toxic_comment_classifier<!-- -->    tensorflow/serving</span><span id="c5cd" class="nu lj it nq b gy ot nw l nx ny">I tensorflow_serving/model_servers/server.cc:82] Building single TensorFlow model file config:  model_name: <!-- -->toxic_comment_classifier<!-- --> model_base_path: /models/<!-- -->toxic_comment_classifier</span><span id="c5e1" class="nu lj it nq b gy ot nw l nx ny">I tensorflow_serving/model_servers/server_core.cc:461] Adding/updating models.</span></pre><p id="d976" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果每个日志都以<strong class="kd iu"> I、</strong>开头，那么恭喜您——该模型已经成功提供了！</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="ou oe l"/></div></figure><h2 id="dcca" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated"><strong class="ak">版本控制</strong></h2><p id="b404" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">TensorFlow 服务基于子目录名称管理模型版本。子目录名称必须是整数值。默认情况下，它将总是获取最新版本。</p><h2 id="0ffe" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">有用的 Docker 命令</h2><p id="dd01" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">TensorFlow Serving 拥有自己的 Docker 映像，用于打包模型及其依赖项。这里有两个有用的 Docker 命令，在使用服务器时可能会派上用场:</p><ul class=""><li id="29b9" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated"><code class="fe oa ob oc nq b">docker ps</code> -这显示哪些 Docker 容器当前正在运行；这对于获取容器 id 以便进一步操作非常有用</li><li id="e747" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><code class="fe oa ob oc nq b">docker kill [container id]</code> -如果您构建了错误的模型，您可以终止当前容器来释放端口并重启服务器</li></ul><h2 id="fe4e" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">发布请求</h2><p id="f14a" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">既然我们的模型服务器已经在本地机器上启动并运行，我们就可以发送一个示例 POST 请求了。发布请求可以通过<a class="ae la" href="https://curl.haxx.se/docs/manpage.html" rel="noopener ugc nofollow" target="_blank"> curl </a>发送，这是一个用于在服务器之间传输数据的简单工具，也可以通过 Python 中的<code class="fe oa ob oc nq b">request</code>库发送。</p><p id="8da7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">样本卷曲命令:</strong></p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="6f22" class="nu lj it nq b gy nv nw l nx ny">curl -d '{"signature_name": "predict","inputs":{"input": "raw text goes here"}}' \<br/>  -X POST <a class="ae la" href="http://localhost:8501/v1/models/division_inference:predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8501/v1/models/toxic_comment_classifier:predict</a></span></pre><p id="c6b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出将如下所示。预测输出是一个概率列表。第一个索引将始终对应于第一类，第二个索引对应于第二类，依此类推。在这种情况下，第一个指数 0.996 表示评论为 0 级/无毒的概率。</p><pre class="nl nm nn no gt np nq nr ns aw nt bi"><span id="8efc" class="nu lj it nq b gy nv nw l nx ny">{<br/>    "outputs": {<br/>        "prediction": [<br/>            [<br/>                0.996692061,<br/>                0.00330786966<br/>            ]<br/>        ],<br/>        "model_version": "20191005180917"<br/>    }</span></pre><h1 id="6aa3" class="li lj it bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">后续步骤(第 2 部分的路线图)</h1><h2 id="59b2" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">预处理输入</h2><p id="2895" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">我们当前实现的一个最大缺陷是，客户端输入的处理方式不同于训练数据。没有特征工程步骤应用于客户端输入。</p><p id="18de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用辅助服务器来应用这些处理步骤。辅助服务器将接收输入，对其进行处理，调用张量流服务器进行预测，并返回处理后的张量流输出。</p><h2 id="4428" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">TensorFlow 服务配置</h2><p id="ac84" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">我们可以选择包含一个<code class="fe oa ob oc nq b">yml</code>文件来配置我们的服务器。这个配置文件可以用来指定模型名称、模型路径、版本策略(我们是想使用特定的版本还是总是最新的版本？)，记录配置以及服务器检查新型号版本的频率。这一步在每个生产环境中都是绝对重要的。</p><h2 id="4d82" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">模型改进</h2><p id="4bee" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">第 1 部分为部署构建了一个快速模型，但没有关注性能改进。在第 2 部分中，我们将探索早期停止、预训练向量的有效性以及模型改进的其他潜在领域。</p><h2 id="e56c" class="nu lj it bd lk of og dn lo oh oi dp ls km oj ok lw kq ol om ma ku on oo me op bi translated">张量板</h2><p id="8ab4" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">TensorBoard 是一套用于可视化和理解机器学习实验的 web 应用程序。它非常容易设置，但是解释起来有点棘手。</p><p id="d01b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">敬请关注第二部分</em></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h1 id="b3ad" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">感谢您的阅读！</h1><p id="3246" class="pw-post-body-paragraph kb kc it kd b ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku nj kw kx ky im bi translated">如果你喜欢这篇文章，可以看看我关于数据科学、数学和编程的其他文章。<a class="ae la" href="https://medium.com/@mandygu" rel="noopener">通过 Medium </a>关注我的最新动态。😃</p><p id="c4c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一个业余爱好项目，我还在 www.dscrashcourse.com<a class="ae la" href="http://www.dscrashcourse.com/" rel="noopener ugc nofollow" target="_blank">建立了一套全面的<strong class="kd iu">免费</strong>数据科学课程和练习题。</a></p><p id="fb9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想支持我的写作，下次你报名参加 Coursera 课程时，可以考虑使用我的<a class="ae la" href="https://click.linksynergy.com/fs-bin/click?id=J2RDo*Rlzkk&amp;offerid=759505.198&amp;type=3&amp;subid=0" rel="noopener ugc nofollow" target="_blank">会员链接</a>。完全公开—我从每一次注册中获得佣金，但不会对您产生额外费用。</p><p id="99bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次感谢您的阅读！📕</p></div></div>    
</body>
</html>