<html>
<head>
<title>Functional Programming Features In Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala 中的函数式编程特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/functional-programming-features-in-scala-e770c7f31a6c?source=collection_archive---------21-----------------------#2019-07-02">https://towardsdatascience.com/functional-programming-features-in-scala-e770c7f31a6c?source=collection_archive---------21-----------------------#2019-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="dbe0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据工程</h2><div class=""/><div class=""><h2 id="7520" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Scala 语言的特性和模式</h2></div><p id="0e07" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在过去的几个月里，我一直在探索使用 Scala 及其 eco 系统进行函数式编程。</p><p id="51b2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我将重点介绍该语言的一些特性，这些特性支持为分布式系统和数据操作直观地创建功能代码。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/c87a2b5e8aec59f80247e8489b7ee961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MckCtWhMkl6h-wbn"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Photo by <a class="ae md" href="https://unsplash.com/@aprvm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">apoorv mittal</a> on <a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2219" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">高阶函数</h1><p id="e28f" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">根据<a class="ae md" href="https://docs.scala-lang.org/tour/higher-order-functions.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，函数是 Scala 中的第一类对象，这意味着它们可以-</p><ul class=""><li id="0860" class="nb nc it kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">把另一个函数作为参数，或者…</li><li id="ff75" class="nb nc it kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">返回一个函数</li></ul><p id="9ac7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一个函数将另一个函数作为参数的例子是 Scala 的标准集合库中的<code class="fe np nq nr ns b">map()</code>函数。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="0943" class="nx mf it ns b gy ny nz l oa ob">val examplelist: List[Int] = List(2,9,8,14)</span><span id="58cf" class="nx mf it ns b gy oc nz l oa ob">examplelist.map(x=&gt; x * 2) // anonymous function as argument</span></pre><p id="3af3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当使用标准的 Scala 集合时，链操作符也非常直观，尤其是使用中缀符号时。在下面的小代码示例中，我定义了一个从 1 到 20 的数字列表，过滤偶数，然后对它们求和。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="acfa" class="nx mf it ns b gy ny nz l oa ob">(1 to 20).toList filter (_%2 == 0) reduce (_ + _)</span></pre><p id="8bfb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe np nq nr ns b">_</code>是通配符——在地图和过滤器的情况下，它指的是集合中的值。</p><h1 id="9aa7" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">递归</h1><p id="51fe" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">对集合中的所有项目进行操作的推荐方式是使用操作符<code class="fe np nq nr ns b">map</code>、<code class="fe np nq nr ns b">flatMap</code>或<code class="fe np nq nr ns b">reduce</code>。</p><p id="ab43" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果这些操作符不能满足用例的需求，那么写一个尾递归函数来操作集合中的所有条目是非常有用的。</p><p id="b2df" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面的代码示例显示了计算一个数的阶乘的尾递归函数定义。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="b3b5" class="nx mf it ns b gy ny nz l oa ob">import scala.annotation.tailrec</span><span id="5d83" class="nx mf it ns b gy oc nz l oa ob">@tailrec<br/>// Factorial Function Implementation that uses Tail Recursion<br/>def factorial(in_x: Double, prodsofar: Double = 1.0): Double = {<br/>    if (in_x==0) prodsofar<br/>    else factorial(in_x-1, prodsofar*in_x)<br/>}</span><span id="c62d" class="nx mf it ns b gy oc nz l oa ob">factorial(5)</span></pre><p id="6800" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 Scala 中，一个尾部递归函数，如上所述，可以被编译器优化(使用上面的<code class="fe np nq nr ns b">@tailrec</code>注释),只占用一个堆栈帧——所以即使是多层递归也不会出现 stackoverflow 错误。这是可能的开箱即用，不需要任何框架或插件。</p><p id="82a2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如上所述，推荐的方式是使用集合运算符(如<code class="fe np nq nr ns b">reduce</code>等)。).作为集合 API 简单性的演示，上面的阶乘函数也可以由下面的 1-liner 实现</p><p id="f63b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe np nq nr ns b">(1 to 5).toList reduce (_*_)</code></p><p id="d934" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了从概念上理解<code class="fe np nq nr ns b">reduce</code>，看看这个<a class="ae md" href="http://allaboutscala.com/tutorials/chapter-8-beginner-tutorial-using-scala-collection-functions/scala-reduce-example/" rel="noopener ugc nofollow" target="_blank">伟大的链接</a>！</p><p id="ca38" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">(还要做查看<code class="fe np nq nr ns b">foldLeft</code>、<code class="fe np nq nr ns b">foldRight</code>、<code class="fe np nq nr ns b">map</code>、<code class="fe np nq nr ns b">flatMap</code>的解释，了解一些常用的数据操作！)</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi od"><img src="../Images/0a1bcf04c17951838da0c796d1c1e388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rZMrM5vLoRbcgObz"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Photo by <a class="ae md" href="https://unsplash.com/@gecko81de?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Patrick Baum</a> on <a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f6e6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">案例类别</h1><p id="3267" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">Case 类可以非常容易地实例化，不需要 boiler plate 代码，如下例所示。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="a3c6" class="nx mf it ns b gy ny nz l oa ob">case class BusinessTransaction(sourceaccountid: Long, targetaccountid: Long, amount: Long)</span><span id="b766" class="nx mf it ns b gy oc nz l oa ob">// create some transactions now to demo case classes</span><span id="0cd7" class="nx mf it ns b gy oc nz l oa ob">// I lend my friend<br/>val 1_xaction = BusinessTransaction(112333L, 998882L, 20L)<br/>// My friend pays me back <br/>val 2_xaction = BusinessTransaction(998882L, 112333L, 20L)</span></pre><p id="7a29" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">仅仅上面的 1 <code class="fe np nq nr ns b">case class ..</code>行做了以下有用的事情——</p><ul class=""><li id="acd1" class="nb nc it kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">定义了 3 个不可变的值<code class="fe np nq nr ns b">sourceaccountid</code>、<code class="fe np nq nr ns b">targetaccountid</code>和<code class="fe np nq nr ns b">amount</code></li><li id="16e7" class="nb nc it kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">定义 get 方法来访问构造函数参数(例如:<code class="fe np nq nr ns b">1_xaction.amount</code>)</li></ul><p id="60e2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然易用性很好，但 case 类是在 Scala 中存储不可变数据实例的推荐方式。例如，在大数据应用程序中，大数据文件的每一行都可以通过 case 类建模并存储。</p><p id="74d4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用 case 类存储数据的一个例子是这里的<a class="ae md" href="https://github.com/kevvo83/scala-spark-ln/blob/2c4b7b9cc6d3d19118bd71360f1c36584444ebff/coursera-hmiller-week2/src/main/scala/stackoverflow/StackOverflow.scala#L57" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1688" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在链接的示例中，函数<code class="fe np nq nr ns b">rawPostings</code>将数据文件的每一行建模为 case 类<code class="fe np nq nr ns b">Posting</code>的一个实例。最终，它返回一个类型为<code class="fe np nq nr ns b">RDD[Posting]</code>的数据集。</p><h1 id="01e5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">模式匹配</h1><p id="97ce" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">在 Scala 中，case 类、常规类和集合等对象可以通过模式匹配进行分解。</p><p id="8d1f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以使用模式匹配来-</p><ul class=""><li id="7c43" class="nb nc it kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">分解对象的类型(如下例)</li><li id="fdf9" class="nb nc it kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">获取集合的头(例如一个<code class="fe np nq nr ns b">List</code>或一个<code class="fe np nq nr ns b">Seq</code>)</li></ul><p id="9386" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面的代码示例展示了如何使用模式匹配来分解一个<code class="fe np nq nr ns b">Seq</code>。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="4c4d" class="nx mf it ns b gy ny nz l oa ob">val seq1: Seq[Int] = Seq(1,3,4,5,5)</span><span id="90c1" class="nx mf it ns b gy oc nz l oa ob">seq1 match {<br/>    case x::y =&gt; println(s"The first element in the sequence is ${x}")<br/>    case Nil =&gt; println("The sequence is empty")<br/>}</span></pre><p id="e55f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">cons 操作符(<code class="fe np nq nr ns b">::</code>)创建一个由头部(<code class="fe np nq nr ns b">x</code>)和列表其余部分(称为尾部，<code class="fe np nq nr ns b">y</code>)组成的列表。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oe"><img src="../Images/8124602059279230e6354cae1c570a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sEfFpti65rtwYE09"/></div></div></figure><h1 id="af63" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">伴随物体</h1><p id="045c" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">在 OOP 中，一个静态变量有时被用在一个类中来存储多个实例化对象的状态或属性。</p><p id="36e6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是 Scala 中没有<code class="fe np nq nr ns b">static</code>关键字。相反，我们使用的是伴随对象，也称为单例对象。伴随对象是使用<code class="fe np nq nr ns b">object</code>关键字定义的，并且与伴随对象的类具有完全相同的名称。</p><p id="2c4e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">伴随对象可以定义不可变的值，这些值可以被类中的方法引用。</p><p id="3343" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 Scala 中有两种使用伴随对象的常见模式</p><ul class=""><li id="9c4b" class="nb nc it kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">作为工厂方法</li><li id="6c21" class="nb nc it kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">提供类共有的功能(即 Java 中的静态函数)</li></ul><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="ce62" class="nx mf it ns b gy ny nz l oa ob">// The 'val specie' straightaway defines an immmutable parameter abstract class Animal(val specie: String) {<br/>    import Animal._</span><span id="0c4e" class="nx mf it ns b gy oc nz l oa ob">    // Common Behaviour to be mixed-in to Canine/Feline classes<br/>    def getConnectionParameters: String = Animal.connectionParameter }</span><span id="bb58" class="nx mf it ns b gy oc nz l oa ob">object Animal {</span><span id="baa2" class="nx mf it ns b gy oc nz l oa ob">    // .apply() is the factory method<br/>    def apply(specie: String): Animal = specie match {<br/>        case "dog" =&gt; new Canine(specie)<br/>        case "cat" =&gt; new Feline(specie)<br/>    }</span><span id="c895" class="nx mf it ns b gy oc nz l oa ob">    val connectionParameter:String = System.getProperty("user.dir") }</span><span id="9413" class="nx mf it ns b gy oc nz l oa ob">class Canine(override val specie: String) extends Animal(specie) {   <br/>    override def toString: String = s"Canine of specie ${specie}"<br/>}</span><span id="149b" class="nx mf it ns b gy oc nz l oa ob">class Feline(override val specie: String) extends Animal(specie) {<br/>    override def toString: String = s"Feline of specie ${specie}"<br/>} </span><span id="ea35" class="nx mf it ns b gy oc nz l oa ob">// syntactic sugar, where we don't have to say new Animal<br/>val doggy = Animal("dog")<br/>val kitty = Animal("cat")</span><span id="54ed" class="nx mf it ns b gy oc nz l oa ob">doggy.getConnectionParameters</span></pre><h1 id="9e41" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">选择</h1><p id="fa79" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">大多数应用程序代码检查 Null/None 类型。Scala 对空类型的处理略有不同——使用的构造称为<code class="fe np nq nr ns b">Option</code>。最好用一个例子来说明这一点。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="10ba" class="nx mf it ns b gy ny nz l oa ob">val customermap: Map[Int, String] = Map(<br/>    11-&gt; "CustomerA", 22-&gt;"CustomerB", 33-&gt;"CustomerC"<br/>)</span><span id="22e1" class="nx mf it ns b gy oc nz l oa ob">customermap.get(11)         // Map's get() returns an Option[String]<br/>customermap.get(11).get     // Option's get returns the String<br/>customermap.get(999).get    // Will throw a NoSuchElementException<br/>customermap.get(999).getOrElse(0) // Will return a 0 instead of throwing an exception</span></pre><p id="f82a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 Python 这样的语言中，<code class="fe np nq nr ns b">if None:</code>检查在整个代码库中很常见。在 Java 中，会有 try-catch 块来处理抛出的异常。<code class="fe np nq nr ns b">Option</code> s 允许关注逻辑流程，对类型或异常检查进行最小的转移。</p><p id="94ac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 Scala 中使用<code class="fe np nq nr ns b">Option</code> s 的一个标准方式是让你的自定义函数返回<code class="fe np nq nr ns b">Option[String]</code>(或者<code class="fe np nq nr ns b">Int</code>、<code class="fe np nq nr ns b">Long</code>等等。).让我们看看<code class="fe np nq nr ns b">Map</code>结构的<code class="fe np nq nr ns b">get()</code>函数签名-</p><p id="cc84" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe np nq nr ns b">def get(key: A): Option[B]</code></p><p id="61ad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用它的一个(直观的)方法是用如下所示的<code class="fe np nq nr ns b">getOrElse()</code>函数链接它</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="5926" class="nx mf it ns b gy ny nz l oa ob">// Map of IDs vs Names</span><span id="1ab1" class="nx mf it ns b gy oc nz l oa ob">val customermap: Map[Int, String] = Map(<br/>    11-&gt; "CustomerA", 22-&gt;"CustomerB", 33-&gt;"CustomerC"<br/>)</span><span id="ba09" class="nx mf it ns b gy oc nz l oa ob">customermap.get(11).getOrElse("No customer found for the provided ID")</span></pre><p id="5955" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用<code class="fe np nq nr ns b">Option</code> s 的一个非常有用的方法是使用像<code class="fe np nq nr ns b">flatMap</code>这样的集合操作符，它直接透明地为你处理类型。</p><pre class="lo lp lq lr gt nt ns nu nv aw nw bi"><span id="bc00" class="nx mf it ns b gy ny nz l oa ob">// Map of IDs vs Names</span><span id="4003" class="nx mf it ns b gy oc nz l oa ob">val customermap: Map[Int, String] = Map(<br/>    11-&gt; "CustomerA", 22-&gt;"CustomerB", 33-&gt;"CustomerC"<br/>)</span><span id="a986" class="nx mf it ns b gy oc nz l oa ob">val listofids: List[Int] = List(11,22,33,99)</span><span id="f682" class="nx mf it ns b gy oc nz l oa ob">listofids flatMap (id=&gt; customermap.get(id)) //flatMap magic</span></pre><p id="876b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这就是我这篇文章的全部内容！我正在研究 Akka 和 Actor 模型的并发系统。在以后的文章中，我将分享我在这个主题上的心得(以及它与 Scala 函数式编程方法的关系)。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="8a36" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="om">原载于</em><a class="ae md" href="https://gist.github.com/kevvo83/05d2f6cca40d9a5336722c3d52a14873" rel="noopener ugc nofollow" target="_blank"><em class="om">http://github.com</em></a><em class="om">。</em></p></div></div>    
</body>
</html>