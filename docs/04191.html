<html>
<head>
<title>Deploying Models to Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将模型部署到 Flask</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-models-to-flask-fb62155ca2c4?source=collection_archive---------10-----------------------#2019-07-01">https://towardsdatascience.com/deploying-models-to-flask-fb62155ca2c4?source=collection_archive---------10-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/eb9db5dd210611b5d9cc3aad6335f94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thIp0urhxWpEHF2ufPtuSQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@olloweb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Agence Olloweb</a> on <a class="ae jg" href="https://unsplash.com/search/photos/website?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="becb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">关于如何使用 Python 和 Flask 为用户交互部署机器学习模型的演练</h2></div><p id="c811" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个项目的代码可以在<a class="ae jg" href="https://github.com/jeremyrchow/Harassment-Classifier-App" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="ad50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">你已经用熊猫、Sci-kit Learn 和 Jupyter 笔记本建立了一个模型。结果在您的笔记本上看起来很棒，但是您如何与他人分享您的成果呢？</p><p id="f070" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了共享模型，我们需要<strong class="la jk">部署</strong>它们，最好是部署到某个网站，或者至少使用 Python 文件。今天，我将以我的<a class="ae jg" rel="noopener" target="_blank" href="/quantifying-chatroom-toxicity-e755dd2f9ccf">聊天室毒性分类器</a>模型为例，向您介绍使用 Python 和 Flask 将模型部署到网站的过程。本文假设您知道如何编写 Python 代码，了解 HTML 的基础知识，并且安装了 Flask】或<code class="fe md me mf mg b">conda install flask</code>)。我们将从文件结构开始！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="d905" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">Flask 文件结构</h1><p id="1791" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Flask 希望东西在一个特定的文件夹布局中，以便正确加载。我为这个项目的文件结构拍了一个快照，但是下面只列出了几个重要的元素:</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/68170bc5c5998885566f89141ae5549d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*qNRNIE0MjHkmRIc7ZivulQ.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Example of deployed Flask and Heroku file structure</figcaption></figure><p id="08d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">必要的要素是:</p><ol class=""><li id="f1a2" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><strong class="la jk">静态</strong>文件夹—存在于根目录中。这包含了所有的静态资产，如 css 文件、图像、字体和压缩模型。</li><li id="e1f6" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la jk">模板</strong>文件夹——存在于根目录中。这是模板 HTML 文件<strong class="la jk">必须</strong>在的默认位置，以便 Flask 正确地渲染它们。任何与你的模型交互的页面都会在这里。</li><li id="d34a" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la jk">predictor.html</strong>—这是用户可以与之交互的前置 HTML 文件，您的模型将向其输出结果。这是一个需要放在 Templates 文件夹中的文件示例。</li><li id="26e0" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la jk"> predictor_api.py </strong> —存在于根目录中。该文件包含运行模型和数据预处理的函数。</li><li id="929e" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la jk"> predictor_app.py </strong> —存在于根目录中。这个文件充当调用模型的 API 文件和显示结果并接受用户输入的 HTML 文件之间的链接。</li></ol><p id="f695" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上图中的所有内容对于 Flask 的正常运行都不是必需的，在本文的其余部分可以忽略。让我们来看看你是如何设置这些文件的！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="7041" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">设置 API.py 文件</h1><p id="8d98" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">首先，您需要创建一个 API Python 文件。这是一个包含所有方法的文件，这些方法预处理您的数据，加载您的模型，然后根据用户提供的数据输入运行您的模型。请注意，这是独立于 Flask 的<strong class="la jk">，</strong>，因为这只是一个 python 文件，运行您的模型，没有 Flask 功能。下面是我的 predictor_api.py 文件的框架，其中包含运行我的模型的所有函数:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="682c" class="oi mp jj mg b gy oj ok l ol om"># predictor_api.py - contains functions to run model</span><span id="570a" class="oi mp jj mg b gy on ok l ol om">def clean_word(text):<br/>    # Removes symbols, numbers, some stop words    <br/>    return cleaned_text</span><span id="9381" class="oi mp jj mg b gy on ok l ol om">def raw_chat_to_model_input(raw_input_string):<br/>    # Converts string into cleaned text, converts it to model input<br/>    return word_vectorizer.transform(cleaned_text)</span><span id="4b6e" class="oi mp jj mg b gy on ok l ol om">def predict_toxicity(raw_input_string):<br/>    # Takes in a user input string, predict the toxicity levels<br/>    model_input = raw_chat_to_model_input(raw_input_string)<br/>    results = []<br/>    # I use a dictionary of multiple models in this project<br/>    for key,model in model_dict.items():<br/>        results.append(round(model.predict_proba(model_input)))<br/>    return results</span><span id="0a0d" class="oi mp jj mg b gy on ok l ol om">def make_prediction(input_chat):<br/>    '''<br/>    Given string to classify, returns the input argument and the    <br/>    dictionary of model classifications in a dict so that it may be<br/>    passed back to the HTML page.<br/>    '''</span><span id="7a78" class="oi mp jj mg b gy on ok l ol om">    # Calls on previous functions to get probabilities of toxicity<br/>    pred_probs = predict_toxicity(input_chat)</span><span id="61cf" class="oi mp jj mg b gy on ok l ol om">    probs = [{'name': list(model_dict.keys())[index], 'prob': \    <br/>            pred_probs[index]} \<br/>            for index in np.argsort(pred_probs)[::-1]]    <br/>return (input_chat, probs)</span></pre><p id="3a42" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是个人偏好，您的数据处理步骤将因您正在做的模型类型以及您正在处理的数据而异，但我将这个有毒聊天分类器中的功能分为:</p><ol class=""><li id="ff8e" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">字符串清洗</li><li id="f264" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">对字符串进行矢量化，以将其输入到模型中</li><li id="7b1a" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">使用步骤 2 的输出建立预测模型</li><li id="b187" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">最终<code class="fe md me mf mg b">make_predictions</code>函数，在一次函数调用中调用从原始输入到模型预测的管道中的所有先前步骤。</li></ol><p id="6ee7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">旁注:您将希望以<strong class="la jk">字典格式</strong>传递您的预测，因为这是 Flask 在其模板和 python 文件之间传递信息的格式。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="0c71" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">测试 API.py 文件</h2><p id="c8e7" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">一旦你设置好了你的函数，你需要一些方法来测试它们。这是我们为脚本设置主要部分的时候:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="d239" class="oi mp jj mg b gy oj ok l ol om">if __name__ == '__main__':<br/>    from pprint import pprint<br/>    print("Checking to see what empty string predicts")<br/>    print('input string is ')<br/>    chat_in = 'bob'<br/>    pprint(chat_in)</span><span id="8b93" class="oi mp jj mg b gy on ok l ol om">x_input, probs = make_prediction(chat_in)<br/>    print(f'Input values: {x_input}')<br/>    print('Output probabilities')<br/>    pprint(probs)</span></pre><p id="9f6f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有当我们使用<code class="fe md me mf mg b">python script_name.py</code>在命令行上启动脚本时，<code class="fe md me mf mg b">__name__=='__main__'</code>部分才会运行。这允许我们调试我们的功能，并在一旦我们的应用程序或网站启动就不会运行的文件区域中添加任何单元测试。<strong class="la jk">这部分代码纯粹是给程序员看的，以确保你的函数正常工作</strong>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="f2b7" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">设置 Flask Python app.py 文件</h1><p id="e7c4" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">现在您的 API 文件应该可以工作了。酷，我们怎么把它放到网站上？这就是弗拉斯克的用武之地。Flask 是一个 Python 框架，它使用<a class="ae jg" href="http://jinja.pocoo.org/docs/2.10/intro/#basic-api-usage" rel="noopener ugc nofollow" target="_blank"> Jinja2 HTML 模板</a>来允许你使用 Python 轻松地创建网页。Flask 框架处理大量的后端 web 内容，因此您只需几行 Python 代码就可以做更多的事情。首先，您需要创建应用程序 Python 文件:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="f255" class="oi mp jj mg b gy oj ok l ol om"># predictor_app.py<br/>import flask<br/>from flask import request<br/>from predictor_api import make_prediction</span><span id="3a47" class="oi mp jj mg b gy on ok l ol om"># Initialize the app</span><span id="f0f5" class="oi mp jj mg b gy on ok l ol om">app = flask.Flask(__name__)</span><span id="cf49" class="oi mp jj mg b gy on ok l ol om"># An example of routing:<br/># If they go to the page "/" (this means a GET request<br/># to the page <a class="ae jg" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a>)</span><span id="7517" class="oi mp jj mg b gy on ok l ol om"><a class="ae jg" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/", methods=["GET","POST"])<br/>def predict():<br/>    # request.args contains all the arguments passed by our form<br/>    # comes built in with flask. It is a dictionary of the form<br/>    # "form name (as set in template)" (key): "string in the    <br/>    # textbox" (value)<br/>    print(request.args)<br/>    if(request.args):<br/>        x_input, predictions = \   <br/>            make_prediction(request.args['chat_in'])<br/>        print(x_input)<br/>        return flask.render_template('predictor.html',<br/>                                     chat_in=x_input,<br/>                                     prediction=predictions)<br/>    else: <br/>        #For first load, request.args will be an empty ImmutableDict<br/>        # type. If this is the case we need to pass an empty string<br/>        # into make_prediction function so no errors are thrown.<br/>        <br/>        x_input, predictions = make_prediction('')<br/>        return flask.render_template('predictor.html',<br/>                                     chat_in=x_input,<br/>                                     prediction=predictions)</span><span id="96da" class="oi mp jj mg b gy on ok l ol om"># Start the server, continuously listen to requests.</span><span id="76fc" class="oi mp jj mg b gy on ok l ol om">if __name__=="__main__":<br/>    # For local development, set to True:<br/>    app.run(debug=False)<br/>    # For public web serving:<br/>    #app.run(host='0.0.0.0')<br/>    app.run()</span></pre><p id="c431" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里发生了很多事情，所以我会试着把它分成容易理解的部分。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="8a61" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">进口</h2><p id="95d6" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">首先我们导入 flask，并明确地导入<code class="fe md me mf mg b">request</code>以提高生活质量。接下来，我们有</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="8af1" class="oi mp jj mg b gy oj ok l ol om">from predictor_api import make_prediction</span></pre><p id="c899" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将转到我们之前编写的 API 文件并导入<code class="fe md me mf mg b">make_prediction</code>函数，该函数接收用户输入并运行所有数据预处理，然后输出我们的预测。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="a55f" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">托管网页</h2><p id="ca3e" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我将简单地跳到底层代码。如前所述，</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="0a12" class="oi mp jj mg b gy oj ok l ol om">if __name__=="__main__":</span></pre><p id="e99c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过命令行运行 Python 脚本时运行。为了托管我们的网页，我们需要运行<code class="fe md me mf mg b">python your_app_name.py</code>。这将调用<code class="fe md me mf mg b">app.run()</code>并在本地运行我们的网页，托管在您的计算机上。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="aea8" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">按指定路线发送</h2><p id="a65e" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">初始化应用程序后，我们必须告诉 Flask 当网页加载时我们要做什么。行<code class="fe md me mf mg b">@app.route("/", methods = ["GET","POST"]) </code>告诉 Flask 当我们加载我们网站的主页时该做什么。GET 方法是 web 浏览器在访问网页的 URL 时向网站发送的请求类型。不要担心 POST 方法，因为它是用户想要更改网站时通常使用的请求，在这个部署过程中它与我们没有太大的相关性。如果您想在网站上添加另一个页面，您可以添加:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="02d1" class="oi mp jj mg b gy oj ok l ol om">@app.route("/page_name", methods = ["GET","POST"])<br/>def do_something():<br/>    flask.render_template('page_name.html',var_1 = v1, var_2 = v2)</span></pre><p id="75da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">路由下的函数名没有任何意义，它只包含用户到达该页面时运行的代码。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="755c" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">运行模型</h2><p id="c9d3" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在路由下面的函数中，我们有<code class="fe md me mf mg b">request.args</code>。这是一个 dictionary ( <a class="ae jg" href="https://www.w3schools.com/js/js_json_syntax.asp" rel="noopener ugc nofollow" target="_blank"> JSON </a>)对象，它包含当有人单击我们表单上的“提交”按钮时提交的信息。下面我将展示我们如何分配<code class="fe md me mf mg b">request.args </code>对象中的内容。一旦我们有了参数，我们就使用从其他文件导入的函数将它传递给我们的模型，然后<strong class="la jk">使用我们的模型通过返回的预测值来呈现模板</strong>:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="1483" class="oi mp jj mg b gy oj ok l ol om">return flask.render_template('predictor.html',<br/>                              chat_in=x_input,<br/>                              prediction=predictions)</span></pre><p id="78f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数接收我们的网站运行的 html 文件，然后传入从模型<code class="fe md me mf mg b">x_input, predictions</code>输出的变量，并将它们作为<code class="fe md me mf mg b">chat_in, prediction</code>发送到 HTML 模板。从这里开始，模型的工作就完成了，现在我们只需要担心向用户显示结果！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="4c2f" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">烧瓶模板</h1><h2 id="c226" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">将用户输入传递到 app.py 文件</h2><p id="e189" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">首先，我们需要为用户提供一种方法，将他们的输入传递给我们的模型。因为我们接受聊天输入，所以让我们创建一个文本框和一个提交按钮。</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="f9e1" class="oi mp jj mg b gy oj ok l ol om">HTML Code<br/>&lt;input type="text" name="chat_in" maxlength="500" &gt;</span><span id="a34f" class="oi mp jj mg b gy on ok l ol om">&lt;!-- Submit button --&gt;<br/>&lt;input type="submit" value="Submit" method="get" &gt;</span></pre><p id="24b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当用户输入一个值并点击 submit 按钮时，它将向模板发送一个 get 请求，并用文本框中的<code class="fe md me mf mg b">name</code>标志填充<code class="fe md me mf mg b">request.args </code>字典。为了访问用户的输入，我们将在 Python 应用程序文件中使用<code class="fe md me mf mg b">request.args['chat_in']</code>。我们可以将它传递到模型中，如上面这行所示:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="3437" class="oi mp jj mg b gy oj ok l ol om">make_prediction(request.args['chat_in'])</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="d917" class="oi mp jj bd mq oo op dn mu oq or dp my lh os ot na ll ou ov nc lp ow ox ne oy bi translated">将模型输出传递给 HTML 模板</h2><p id="3a93" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">因此，我们已经使用 python 文件做出了预测，但现在是时候使用 HTML 模板显示它们了。模板只是改变 HTML 代码的一种方式，这样我们就可以用新的值(比如我们的预测)来更新用户。我的目标不是在这里教你 HTML，所以我不打算详细说明 HTML 代码(但是如果你好奇，你可以在 github 链接中找到它)，但是基本上你会使用下面的语法显示传递的变量:</p><pre class="nm nn no np gt oe mg of og aw oh bi"><span id="0565" class="oi mp jj mg b gy oj ok l ol om">&lt;!-- predictor.html file --&gt;<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="b393" class="oi mp jj mg b gy on ok l ol om">&lt;p&gt; Here are my predictions!</span><span id="a8b3" class="oi mp jj mg b gy on ok l ol om">&lt;br&gt;<br/>{{ chat_in }}<br/>{{ prediction[0]['prob'] }} </span><span id="79e8" class="oi mp jj mg b gy on ok l ol om">&lt;/p&gt;</span></pre><p id="d0a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我显示了在上面的<code class="fe md me mf mg b">render_template</code>函数中传递的<code class="fe md me mf mg b">chat_in</code>变量。我还显示了传递给模板的字典<code class="fe md me mf mg b">prediction</code>中的第一个元素，它包含多个模型。从功能的角度来看，我们完成了！从这里开始，你可以专注于让你的应用程序看起来漂亮，反应灵敏。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/4dfbd0b31e48ac69e23250980ee40ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4-7zKmDjf__BtlF1IvlgUw.gif"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Website example using chat toxicity classifier</figcaption></figure><p id="ec28" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">烧瓶到此为止！通过一些额外的 HTML 代码和可能的 JavaScript，你可以拥有一个在你的电脑上运行的漂亮的交互式网站。从这里，你可以将网站部署到你选择的平台上，可以是 Heroku、Amazon Web Services 或 Google Cloud。</p><p id="45a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读，请关注我的下一篇关于部署到 Heroku 的文章！</p></div></div>    
</body>
</html>