<html>
<head>
<title>Vectorization: How to speed up your Machine Learning algorithm by x78</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">矢量化:如何用 x78 加速你的机器学习算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vectorisation-how-to-speed-up-your-machine-learning-algorithm-by-x78-times-faster-e330df8c9b27?source=collection_archive---------13-----------------------#2019-10-09">https://towardsdatascience.com/vectorisation-how-to-speed-up-your-machine-learning-algorithm-by-x78-times-faster-e330df8c9b27?source=collection_archive---------13-----------------------#2019-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4245395eccba6d2837ad29f8824a7dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jlzhVYdnBsd7ivGvD3aoA.png"/></div></div></figure><div class=""/><div class=""><h2 id="a2e1" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">给定一个等式，我们将看到 step by step 如何不仅在速度方面实现 x78 倍的更高效代码，而且仅使用 3 行代码！让我们深入了解一下…</h2></div><h1 id="21dc" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">介绍</h1><p id="02f7" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">作为一种<strong class="ln jf">解释语言，</strong> Python <code class="fe mh mi mj mk b">for</code> loops 天生就比 C 语言慢。这对臭名昭著的编程语言来说是一个很大的瓶颈，因为深度学习和机器学习算法严重依赖于矩阵运算，它们通过<code class="fe mh mi mj mk b">for</code>循环来执行。</p><p id="3d53" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">这就是开发人员开发包的原因，比如<code class="fe mh mi mj mk b">numpy</code>，他们在<code class="fe mh mi mj mk b">numpy</code>数组上提供<strong class="ln jf">矢量化</strong>动作。这意味着它将通常在 Python 中完成的<code class="fe mh mi mj mk b">for</code>循环推到了更快的<strong class="ln jf"> C 层</strong>。</p><blockquote class="mq"><p id="a679" class="mr ms je bd mt mu mv mw mx my mz mg dk translated">Python + C 级速度=天堂</p></blockquote><h1 id="409e" class="kt ku je bd kv kw kx ky kz la lb lc ld kk na kl lf kn nb ko lh kq nc kr lj lk bi translated">问题是</h1><p id="4e76" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><em class="nd">(如果你能理解 EM 算法，你可以跳过解释部分)</em></p><p id="4d9e" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我们希望将<strong class="ln jf">期望最大化</strong> (EM)算法用于无监督学习任务(例如，识别 MNIST 数据集中的手写数字)，并且我们的数据是二进制的(例如二进制图像)。一个自然的方法是将我们的数据建模为一个伯努利混合模型。伯努利分布的加权和，其中每个分布具有其自己的标量权重<code class="fe mh mi mj mk b"><strong class="ln jf">π</strong></code>和其自己的均值向量<code class="fe mh mi mj mk b"><strong class="ln jf">μ</strong></code> <strong class="ln jf"> </strong>，并且表示数据的聚类(例如，如果我们的数据是数字 2、3 &amp; 4 的图像，并且我们使用 3 个伯努利来对它们建模，一个伯努利将是数字 2，另一个是数字 4，等等)。总的来说，前者是一个向量，后者是一个矩阵。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/69108a575dd6ef68bb291cfd3f235fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SofYwCWMO52fZe3Lud9xdQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Bernoulli mixture model<strong class="bd nn"> (1)</strong></figcaption></figure><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/5d51ece41096cf8537664badf11ab25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJcxpjX-JlB9ZtIaNRqqzw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Distribution of one observation x given the cluster k <strong class="bd nn">(2)</strong></figcaption></figure><p id="9685" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">设 N =观察值的数量，D =一个观察值的维数，K =聚类的数量。因为这对我们的问题很重要，所以我们的随机变量类型有:<br/><code class="fe mh mi mj mk b"><strong class="ln jf">X</strong></code>；我们的数据 a NxD 矩阵<br/> (N 是图像的数量，D 是图像的维数→ 5 张 28*28 的图像会组成一个 5x784 的矩阵 X)<br/><code class="fe mh mi mj mk b">π</code>；一个向量 K，一个代表权重的标量。<br/>(例如三个伯努利可以有π=[0.2，0.75，0.05]加权向量)<br/><code class="fe mh mi mj mk b"><strong class="ln jf">μ</strong></code>；每个聚类的平均 KxD 矩阵。<br/>(一幅图像的维数为 D=28*28=784，其中每一幅图像代表一个像素值。对属于同一聚类的图像的每个像素取平均值，比如数字 2，我们得到 784 的平均向量。因此，<code class="fe mh mi mj mk b"><strong class="ln jf">μ</strong></code>将是 KxD 的矩阵)</p><p id="8915" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">在<strong class="ln jf"> E 步骤</strong>中，我们特别感兴趣的是潜在变量后验的期望值，或者所谓的责任</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/e611284713a1bf5267cbe49871276efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fc9rcssehDsGoh4pOLRGtQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">E-step of EM algorithm <strong class="bd nn">(3)</strong></figcaption></figure><p id="7c3b" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated"><code class="fe mh mi mj mk b">γ</code>实际返回期望值的观测值(图像)<code class="fe mh mi mj mk b">n</code>属于聚类<code class="fe mh mi mj mk b">k</code>。<br/> <code class="fe mh mi mj mk b">γ</code> <strong class="ln jf"> </strong>是一个<strong class="ln jf"> NxK 矩阵</strong>；对于每个观察值，我们分配一个属于每个聚类的概率。具有最大值的是我们分配给。</p><p id="8002" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我为什么要说这些？</p><blockquote class="mq"><p id="6b74" class="mr ms je bd mt mu mv mw mx my mz mg dk translated">"矢量化中最重要的事情是理解变量的维数."</p></blockquote><p id="0889" class="pw-post-body-paragraph ll lm je ln b lo nq kf lq lr nr ki lt lu ns lw lx ly nt ma mb mc nu me mf mg im bi translated">责任的计算是我们要向量化的内容</p><p id="fa23" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">总结一下:<br/><code class="fe mh mi mj mk b"><strong class="ln jf">X</strong></code>:NxD 矩阵<br/><code class="fe mh mi mj mk b"><strong class="ln jf">π</strong></code>:1xK 向量<br/><code class="fe mh mi mj mk b"><strong class="ln jf">μ</strong></code>:KxD 矩阵<br/><code class="fe mh mi mj mk b"><strong class="ln jf">γ</strong></code><strong class="ln jf"/>:<strong class="ln jf"/>NxK 矩阵</p><h1 id="6087" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">管道</h1><p id="7503" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">我们将创建一个函数<code class="fe mh mi mj mk b">E_step</code>来运行计算上面的表达式，并用下面的代码测试它</p><pre class="nf ng nh ni gt nv mk nw nx aw ny bi"><span id="02c8" class="nz ku je mk b gy oa ob l oc od">observations = [5, 10, 20, 50, 100, 200, 500, 1000]<br/>for n in observations:<br/>    X_test = bin_train_data[:n]<br/>    D_test, K_test = X_test.shape[1], 10</span><span id="f12a" class="nz ku je mk b gy oe ob l oc od">    mu_test = np.random.uniform(low=.25, high=.75, <br/>                                size=(K_test,D_test))<br/>    pi_test = np.ones(K_test) / K_test</span><span id="1cd5" class="nz ku je mk b gy oe ob l oc od">    t0 = time.time()<br/>    gamma_test = E_step_1(X_test, mu_test, pi_test)<br/>    runtime = time.time() - t0<br/>    <strong class="mk jf">assert</strong> gamma_test.shape == (n, K_test)</span></pre><p id="4328" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">放心先自己试一试吧！</p><h1 id="99cf" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">尝试№1</h1><p id="280e" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在我们的第一次尝试中，我们将使用 for 循环编写所有内容；在向量/矩阵运算中，只有标量。</p><p id="e96e" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">通过看方程，我们可以看到有 3 个循环；每个例子一个<code class="fe mh mi mj mk b">N</code>，每个集群一个<code class="fe mh mi mj mk b">K</code>，每个物体的每个维度一个<code class="fe mh mi mj mk b">D</code>，我们将按这个顺序循环。所以我们要一次用一个元素填充矩阵<code class="fe mh mi mj mk b">γ</code>。</p><pre class="nf ng nh ni gt nv mk nw nx aw ny bi"><span id="810c" class="nz ku je mk b gy oa ob l oc od">def E_step(X, mu, pi):<br/>    N, D = X.shape<br/>    K = pi.shape[0]<br/>    gamma = np.zeros((N, K))<br/>    for n in range(N):<br/>        for k in range(K):<br/>            m = 1<br/>            for i in range(D):<br/>                m *= mu[k][i]**X[n][i] * (1-mu[k][i])**(1-X[n][i])<br/>            gamma[n][k] = m * pi[k]<br/>        gamma[n] /= gamma[n].sum()<br/>    return gamma</span></pre><p id="346c" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我们的结果可以在下图中看到。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/b6b5bdd56de7edff025541d797b0c059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tg9vj_xv6amGOngE7qzT8A.png"/></div></div></figure><p id="be7e" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我们肯定能做得更好！</p><h1 id="7505" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">尝试 2</h1><p id="a6e1" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">最好从内部循环开始，然后向外部循环推进。这正是我们要做的！</p><p id="f5d5" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我们想摆脱 for 循环<code class="fe mh mi mj mk b">D</code>。因此，依赖于<code class="fe mh mi mj mk b">D</code>的每一项现在都应该变成一个向量。在这个 for 循环中，我们有两个变量；<code class="fe mh mi mj mk b">μ</code>和<code class="fe mh mi mj mk b">x</code>(见等式。<code class="fe mh mi mj mk b">(2)</code>)。因此<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">μ</code> →矢量。问题；这是<code class="fe mh mi mj mk b">μ**x</code>，向量到另一个向量的幂，很难计算。如果我们能绕过这个…</p><p id="e5ab" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">有一个函数可以将乘幂运算转化为乘法运算。没错，就是<strong class="ln jf">对数</strong>！让我们对表达式取对数，然后取结果的指数！</p><blockquote class="mq"><p id="92d9" class="mr ms je bd mt mu mv mw mx my mz mg dk translated">对数概率上的运算是优选的，因为它们提供了数值稳定性</p></blockquote><p id="ce28" class="pw-post-body-paragraph ll lm je ln b lo nq kf lq lr nr ki lt lu ns lw lx ly nt ma mb mc nu me mf mg im bi translated">尽管在我们的例子中它没有任何影响，但是每次使用 log 时，在表达式中使用一个常量<code class="fe mh mi mj mk b">epsilon</code>以保持稳定性(为了不归零，使用 is <code class="fe mh mi mj mk b">-inf</code>)。</p><p id="bbbf" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">因此，我们将不得不进行逐元素的向量乘法。容易；)</p><pre class="nf ng nh ni gt nv mk nw nx aw ny bi"><span id="bb1d" class="nz ku je mk b gy oa ob l oc od">def E_step(X, mu, pi):<br/>    N, D = X.shape<br/>    K = pi.shape[0]<br/>    gamma = np.zeros((N, K))<br/>    for n in range(N):<br/>        for k in range(K):<br/>            log_gamma = np.log(pi[k]) + (X[n] * np.log(mu[k]) \<br/>                        + (1 - X[n])*np.log(1 - mu[k])).sum()<br/>            gamma[n][k] = np.exp(log_gamma)<br/>        gamma[n] /= gamma[n].sum()<br/>    return gamma</span></pre><p id="e88e" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我们的结果是…</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/a42603e2e4595603cb9d05ae739cb790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxMf8RblQfmHO3q6sdX-fg.png"/></div></div></figure><p id="39aa" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">这是一个巨大的胜利！似乎 x 轴比得上<code class="fe mh mi mj mk b">Algor. 1</code>！但是，我们可以做得更好；)</p><h1 id="23a2" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">尝试№3</h1><p id="6b9f" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">一次一圈:轮到<code class="fe mh mi mj mk b">K</code>了！</p><p id="2ecb" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">在矢量化过程中，我们的移动如下:</p><blockquote class="og oh oi"><p id="2c6f" class="ll lm nd ln b lo ml kf lq lr mm ki lt oj mn lw lx ok mo ma mb ol mp me mf mg im bi translated">标量→矢量→矩阵</p></blockquote><p id="a9b3" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">随着我们用<code class="fe mh mi mj mk b">numpy</code>数组替换越来越多的循环，越来越多的代码将在<strong class="ln jf"> C 上运行→更快的&amp;更干净的代码。</strong></p><p id="befb" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">我们采用之前的实现，希望移除循环的<code class="fe mh mi mj mk b">K</code>。因此，每一个依赖于<code class="fe mh mi mj mk b">K</code>的标量都会变成一个<code class="fe mh mi mj mk b">vector</code>，而每一个<code class="fe mh mi mj mk b">vector</code>都会变成一个<code class="fe mh mi mj mk b">matrix</code>。这意味着<code class="fe mh mi mj mk b">X</code>将保持不变，而<code class="fe mh mi mj mk b">μ</code>将变成矩阵，而<code class="fe mh mi mj mk b">π</code>和<code class="fe mh mi mj mk b">γ</code>将变成向量。注意最后一条；随着<code class="fe mh mi mj mk b">γ</code>字段的一行一行，我们表达式的结果现在必须是一个向量！所以<code class="fe mh mi mj mk b">μ</code>和<code class="fe mh mi mj mk b">X</code>的操作必须产生一个<code class="fe mh mi mj mk b">1xK</code>向量，快速指示器是(I)它们必须与向量<code class="fe mh mi mj mk b">π</code>相加，向量也是<code class="fe mh mi mj mk b">1xK</code> (ii)结果是矩阵<code class="fe mh mi mj mk b">γ</code>的一行，向量也是<code class="fe mh mi mj mk b">1xK</code>。</p><p id="1c86" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">将我们的结果编码成:</p><pre class="nf ng nh ni gt nv mk nw nx aw ny bi"><span id="b268" class="nz ku je mk b gy oa ob l oc od">def E_step(X, mu, pi):<br/>    N, D = X.shape<br/>    K = pi.shape[0]<br/>    gamma = np.zeros((N, K))<br/>    for n in range(N):<br/>        log_gamma = np.log(pi) + np.log(mu) @ X[n] \<br/>                    + np.log(1 - mu) @ (1 - X[n])<br/>        gamma[n] = np.exp(log_gamma)<br/>        gamma[n] /= gamma[n].sum()<br/>    return gamma</span></pre><p id="9c06" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">结果是:</p><div class="nf ng nh ni gt ab cb"><figure class="om iv on oo op oq or paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/18c58c20d0e26271d7400a5aedc20db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kA6NJCkn1Yv-PhNa-S24Sg.png"/></div></figure><figure class="om iv on oo op oq or paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/8439bd1b44214e3e295d4566d2c80cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*v6zqQyix6X9jtm8GJLtdXg.png"/></div></figure></div><p id="cebd" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">太神奇了！我们已经为<code class="fe mh mi mj mk b">n=1000</code>争取到了一半的时间！跟<code class="fe mh mi mj mk b">Algor. 1</code>真的没法比。但是，我们能做得更好吗？</p><h1 id="d137" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">尝试№4</h1><p id="2bac" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">我们还有一个循环。我们能有一个计算<em class="nd">循环-python-free </em>吗？<code class="fe mh mi mj mk b">N</code>，你的时间到了！</p><p id="79db" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">由于我们要将一个<code class="fe mh mi mj mk b">matrix * vector</code>运算转化为一个<code class="fe mh mi mj mk b">matrix @ matrix</code>运算，我们需要取前者的传输矩阵(<code class="fe mh mi mj mk b">@</code>是正则矩阵乘法)。请记住，现在我们的输出必须是整个γ矩阵。我想现在你已经知道它是怎么回事了；).</p><p id="d696" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">所以我们的代码应该是</p><pre class="nf ng nh ni gt nv mk nw nx aw ny bi"><span id="5848" class="nz ku je mk b gy oa ob l oc od">def E_step(X, mu, pi):<br/>    gamma = np.exp(np.log(pi) + X @ np.log(mu.T) \<br/>            + (1 - X) @ np.log(1 - mu.T))    <br/>    gamma /= gamma.sum(axis=1)[:, np.newaxis]<br/>    return gamma</span></pre><p id="d7d3" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">没有一个循环！代码看起来很优雅，而且只有三行长！现在是结果，鼓声…</p><div class="nf ng nh ni gt ab cb"><figure class="om iv on oo op oq or paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/f1962ff07accd9b33cb102a5cac68d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Y89FX6szzxZZPTFnKrCs4Q.png"/></div></figure><figure class="om iv on oo op oq or paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/7f4bf241154c4c43e4b9ef38cc0b8412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZtAFkuIcwIYZy9p95wtBrg.png"/></div></figure></div><p id="5f38" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated">就是这样，不能再好了！对于<code class="fe mh mi mj mk b">n=1000</code>，我们只用了三行代码就从运行时的<code class="fe mh mi mj mk b">11.688</code> → <code class="fe mh mi mj mk b">0.012</code>！</p><h1 id="356f" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">摘要</h1><p id="0b2b" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">那么，当你想对一个表达式进行矢量化时，你需要做什么呢？</p><p id="df6c" class="pw-post-body-paragraph ll lm je ln b lo ml kf lq lr mm ki lt lu mn lw lx ly mo ma mb mc mp me mf mg im bi translated"><strong class="ln jf">了解矩阵的尺寸</strong>。<br/><strong class="ln jf">纸笔</strong>:记下公式，从求和到求和，化为等价矩阵运算<br/><strong class="ln jf">数学是你的朋友</strong>；总是考虑任何表达式必须返回的维数；观察邻居求和运算，因为它们具有相同的维数<br/>逐循环、逐步进行:<strong class="ln jf">标量→向量→矩阵<br/> </strong>取<strong class="ln jf">对数</strong>并确保引入归一化常数ε<br/><strong class="ln jf">代码</strong>您的方法的矢量化版本并闪耀:D</p></div></div>    
</body>
</html>