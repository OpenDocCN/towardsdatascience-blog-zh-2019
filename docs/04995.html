<html>
<head>
<title>Foundations of ML: Parameterized Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML 基础:参数化函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/foundations-of-ml-parameterized-functions-d2951a62272e?source=collection_archive---------12-----------------------#2019-07-27">https://towardsdatascience.com/foundations-of-ml-parameterized-functions-d2951a62272e?source=collection_archive---------12-----------------------#2019-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对参数化函数的软介绍，这是机器学习和统计学中的一个基础话题，通过小的编程例子来解释。</h2></div><h1 id="a786" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">本文的目标</h1><p id="6aed" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇文章的结尾，我希望下面的句子有意义:</p><blockquote class="lw lx ly"><p id="3134" class="la lb lz lc b ld ma ju lf lg mb jx li mc md ll lm me mf lp lq mg mh lt lu lv im bi translated">我最喜欢的<strong class="lc iu">参数化函数</strong>的可视化来自于高阶函数的几何解释。</p></blockquote><p id="0724" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">为了实现这个目标，我将解释<strong class="lc iu">参数化函数</strong>、<strong class="lc iu">高阶函数</strong>和<strong class="lc iu">功能几何</strong>。如果你已经知道这些并且上面的句子已经有意义，这篇文章可能不适合你。如果以上任何(或全部)听起来很吓人，希望我能帮上忙！</p><h2 id="9841" class="mi kj it bd kk mj mk dn ko ml mm dp ks lj mn mo ku ln mp mq kw lr mr ms ky mt bi translated">什么是函数？</h2><p id="8399" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这听起来很基本，但我想从同一页开始，所以请允许我简单地解释一下我说的功能这个词的意思。</p><p id="4609" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">在编程中，函数只是一个接受一些参数并返回一些东西的过程。示例:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f836a2d203d9a82b373e772d35b2457d.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*ZUE_29l7n-fJu3y9fm5hvg.png"/></div></figure><p id="865c" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">在数学中，我们对函数的定义更严格一些。所以让我们在定义中增加一个限制。</p><blockquote class="lw lx ly"><p id="5e28" class="la lb lz lc b ld ma ju lf lg mb jx li mc md ll lm me mf lp lq mg mh lt lu lv im bi translated">对于任何给定的输入<code class="fe nc nd ne nf b">x</code>，只能有一个输出<code class="fe nc nd ne nf b">y</code>。</p></blockquote><p id="2d0b" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">用反例的方式解释:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9ac895ce20d908658c4a68cb80bf8b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*ynNNFNT6Xec_GghlrPGoxg.png"/></div></figure><p id="b115" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">为什么这不是一个函数？因为如果我连续两次通过<code class="fe nc nd ne nf b">x = 0</code>，我将不会得到相同的答案。也就是说，对于给定的输入(<code class="fe nc nd ne nf b">x = 0</code>)，我得到了不同的输出(<code class="fe nc nd ne nf b">x + random()</code>)。</p><h2 id="ff0f" class="mi kj it bd kk mj mk dn ko ml mm dp ks lj mn mo ku ln mp mq kw lr mr ms ky mt bi translated">什么是高阶函数？</h2><p id="757a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">高阶函数还是函数。它接受一些参数并返回一个东西。在这种情况下，它返回的“东西”也是函数！示例:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/fa7421c468ef45c32161b8b948ee765e.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*GhPLyhPUqENJ8nVaDRjH-g.png"/></div></figure><p id="ce97" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">事情变得有点复杂；让我解释一下。每次我们调用我们的高阶函数<code class="fe nc nd ne nf b">buildAdder</code>，我们都会基于参数<code class="fe nc nd ne nf b">a</code>创建一个<em class="lz">新的</em>函数。</p><p id="6ec5" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">在本例中，<code class="fe nc nd ne nf b">addOne</code>仍然是一个接受一个数字并返回该数字加 1 的函数。但是由于我们的高阶函数，我们可以通过向<code class="fe nc nd ne nf b">buildAdder</code>传递不同的参数来生成许多这样的加法函数。</p><h2 id="cbad" class="mi kj it bd kk mj mk dn ko ml mm dp ks lj mn mo ku ln mp mq kw lr mr ms ky mt bi translated">什么是参数化函数？</h2><p id="ff6c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在最后一个例子中，<code class="fe nc nd ne nf b">addA</code>是一个参数化函数！参数化函数是作用于某些参数的函数，但它的作用方式是基于外部常数的。例如，在<code class="fe nc nd ne nf b">addA</code>的上下文(范围)中，<code class="fe nc nd ne nf b">a</code>是外部设置的常量值。在<code class="fe nc nd ne nf b">addOne</code>的情况下，<code class="fe nc nd ne nf b">a</code>是不变的<em class="lz">一个</em>。</p><p id="d3fb" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">这里的关键点是<code class="fe nc nd ne nf b">addA</code>可以是许多不同函数中的一个(这里是无限个)。我们通过其<strong class="lc iu">参数</strong>、<code class="fe nc nd ne nf b">a</code>来确定我们正在处理的众多函数中的哪一个。</p><p id="7700" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">因为<code class="fe nc nd ne nf b">a</code>的值决定了<code class="fe nc nd ne nf b">addA</code>承担的精确功能，我们需要一些语言来讨论<code class="fe nc nd ne nf b">addA</code>可以创建的所有可能功能的集合。为了具体说明这一点，我们来看一些例子:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/7e9ce97e2551bf23e83a9c13e86b3d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Su4zfkjJIofs6KkIBb5rKA.png"/></div></figure><p id="75fe" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">函数的<strong class="lc iu">类</strong>是一个参数化函数可以采用的所有函数的集合。在这个例子中，我们看到<code class="fe nc nd ne nf b">class1</code>是包含每个整数值的函数的集合。我们可以更简洁地这样写:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/f3240ca1f0997fdfe6d4897c4bf87e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZxqYi2y5Tbnl7axfReSbw.png"/></div></div></figure><p id="dc57" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">第一类函数包含所有的<code class="fe nc nd ne nf b">addA</code>，其中<code class="fe nc nd ne nf b">a</code>是一个整数。下一个类包含所有的<code class="fe nc nd ne nf b">addA</code>，其中<code class="fe nc nd ne nf b">a</code>是一个实数。第三类包含所有的<code class="fe nc nd ne nf b">addA</code>，其中<code class="fe nc nd ne nf b">a</code>是一个正实数。</p><p id="0da8" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">如果我们比较这些集合的大小，我们会发现<code class="fe nc nd ne nf b">class2</code>比<code class="fe nc nd ne nf b">class1</code>大。我们之所以知道这一点，是因为实数比整数多，并且<code class="fe nc nd ne nf b">a</code>的值与类中的函数有一对一的映射。</p><h2 id="d30e" class="mi kj it bd kk mj mk dn ko ml mm dp ks lj mn mo ku ln mp mq kw lr mr ms ky mt bi translated">我们如何几何地看待参数化函数？</h2><p id="2e30" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了更容易形象化，让我们看一个也有两个参数的二元函数。我们可以把这两个变量当作一个数组变量，也可以把这两个变量独立处理；这在很大程度上是一种风格选择。下面是一个<code class="fe nc nd ne nf b">x</code>的函数示例，其中<code class="fe nc nd ne nf b">x</code>是一个包含两个元素的数组:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/788f2900e62d5d2da638debe6a6def97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEXk_fY2GAJf4SkEGMwOdg.png"/></div></div></figure><p id="c2f2" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">我们指向这个网格上的任何地方，都会产生一个新的函数。该函数将由其<code class="fe nc nd ne nf b">a</code>、<code class="fe nc nd ne nf b">b</code>坐标定义，并且对于<code class="fe nc nd ne nf b">x</code>的值表现不同。这种解释的一个有价值的用途是定义函数类的约束。例如，也许我们只想查看阴影区域中包含的函数。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi np"><img src="../Images/468508122bdb101dfea7f29987c735ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPhe8ZqAMOR8BrgEeynLQg.png"/></div></div></figure><h1 id="2521" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">那么这和机器学习有什么关系呢？</h1><p id="0b70" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在机器学习<em class="lz">中做的大量工作是</em>寻找特定的函数。我们选择一个模型类(参数化的函数类)并优化它(为参数找到某个值)。</p><p id="df15" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">通过这个镜头来观察机器学习，很明显我们所做的就是在<strong class="lc iu">参数空间</strong>中搜索与我们的数据相匹配的函数！为了让这个说法更清楚，我们来想象一个例子。假设我被赋予了这个功能:</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nq"><img src="../Images/579a8aa3c485b3c1d1700f36e2df8b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwyUjDb8qxHqNualZ7Q9SA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">I am no artist..</figcaption></figure><p id="f9e4" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">如果我摆弄<code class="fe nc nd ne nf b">a</code>、<code class="fe nc nd ne nf b">b</code>和<code class="fe nc nd ne nf b">c</code>足够长的时间，我应该能够找到一条非常接近我得到的曲线。如何找到正确的<code class="fe nc nd ne nf b">a</code>、<code class="fe nc nd ne nf b">b</code>和<code class="fe nc nd ne nf b">c</code>？答案就在优化文献中，但那是另外一个故事了。现在，只要知道我们正在搜索这个类定义的所有可能函数的集合，直到我们找到一个看起来与我们的数据相似的函数。</p><p id="f34f" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">在机器学习中，我们通常不会被告知用来生成我们的数据的函数类。相反，我们必须使用足够通用的函数类来模拟许多不同的函数。例如，函数类<code class="fe nc nd ne nf b">y = a*x + b</code>可以模拟任何线，但是一条线绝对不足以近似生命的复杂函数。所以我们想得更大更深。这导致了最流行的函数类:神经网络。神经网络可以模拟任何函数！</p><p id="28e4" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj md ll lm ln mf lp lq lr mh lt lu lv im bi translated">神经网络的一个普遍紧张的事实是它们是<strong class="lc iu">通用函数逼近器</strong>。这意味着，给定足够多的隐藏节点，它们可以逼近任何函数。该函数的近似精度取决于网络中隐藏节点的数量。这意味着神经网络是一类足够通用的函数，可以模拟任意复杂的函数。然而，让他们这样做本身就是一门艺术！</p></div></div>    
</body>
</html>