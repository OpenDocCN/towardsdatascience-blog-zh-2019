<html>
<head>
<title>Crop: Plant Disease Identification Using Mobile App.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作物:使用移动应用程序进行植物病害识别。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/crop-plant-disease-identification-using-mobile-app-aef821d1a9bc?source=collection_archive---------4-----------------------#2019-10-18">https://towardsdatascience.com/crop-plant-disease-identification-using-mobile-app-aef821d1a9bc?source=collection_archive---------4-----------------------#2019-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="a898" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">植物疾病可以通过利用深度学习的力量来检测。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/826d788b8a0cde7c20cf6a3ed5225167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTBHmiYbWB13_hOxlUnuow.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Demo of Crop App.</figcaption></figure><p id="200c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi ll translated">在这篇文章中，我将解释我们如何使用深度学习模型来检测和分类植物的疾病，并通过视频指导农民，并给出即时补救措施，以克服植物和田地的损失。首先，我们必须了解</p><ol class=""><li id="9e63" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr lz ma mb mc bi translated">原因是什么，如何克服原因？</li></ol><p id="bd1b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">2.这样做有什么好处？</p><p id="3745" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">3.我们能用<strong class="jw iu">“深度学习技术”解决这个问题吗？</strong></p><p id="e207" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">4.在深度学习“<strong class="jw iu">中，哪个算法“</strong>被用来解决这个问题？如何做到这一点？。</p><blockquote class="md"><p id="dad6" class="me mf it bd mg mh mi mj mk ml mm kr dk translated">注意:我只对番茄和土豆植物这样做。你可以通过收集该植物的数据来为其他植物做这件事。</p></blockquote><h1 id="fc3f" class="mn mo it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">它也部署到 Web 应用程序。查看下面的链接。</h1><div class="nl nm gp gr nn no"><a href="https://cropify.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">作物:植物病害标识符</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">想知道你的植物感染了什么类型的疾病，然后上传(番茄、土豆)植物的图片并进入…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">cropify.herokuapp.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lc no"/></div></div></a></div><h1 id="3e47" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">1.起因及简介。</h1><blockquote class="jq jr js"><p id="7458" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">过去和现在，农民通常用肉眼检测作物病害，这使得他们在使用哪种肥料上做出艰难的决定。它需要疾病类型的详细知识和大量经验来确保实际的疾病检测。一些疾病看起来和农民很相似，经常让他们感到困惑。请看下图以获得更多的理解。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi og"><img src="../Images/a525ce4f6fe9a4e022ba21c514fbcde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCn6lY6f9OMdbcKbwRmrpg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><strong class="bd oh">Similar Symptoms but different diseases.</strong></figcaption></figure><p id="bb56" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">他们看起来一样，几乎相似。如果农民作出错误的预测，使用错误的肥料或超过正常剂量(或)阈值或限制(每种植物都有一些阈值肥料喷洒要遵循)，它将搞乱整个植物(或)土壤，并对植物和田地造成足够的损害。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/edb3d4e6db0a0f7e78d15a3072574886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*QiKmn2lkrvRXGQHdts8PlQ.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Cause of overdose of fertilizers. (Source: jainsusa.com)</figcaption></figure><h2 id="18b3" class="oj mo it bd mp ok ol dn mt om on dp mx li oo op nb lj oq or nf lk os ot nj ou bi translated">那么，如何防止这种情况的发生呢？</h2><p id="72a0" class="pw-post-body-paragraph jt ju it jw b jx ov jz ka kb ow kd ke li ox kh ki lj oy kl km lk oz kp kq kr im bi translated">为了防止这种情况，我们需要更好和更完善的指导来使用哪种肥料，以正确识别疾病，并能够在视觉上区分两种或更多种相似类型的疾病。</p><p id="5ef1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">这就是人工神经网络派上用场的地方。简言之，安</p><h1 id="2033" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">2.安是什么？</h1><blockquote class="jq jr js"><p id="db9a" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">人工神经网络是基于生物神经网络结构的计算模型，设计用于模拟存在于我们大脑中的生物神经网络的实际行为。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pa"><img src="../Images/de396f2a48b021f4b834feb7057cec0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mzH4WwxrAn-FJGpRgdX5iw.gif"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Combining the Multiple ANN’s.</figcaption></figure><p id="ba39" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi ll translated">所以我们可以分配一些东西给它，它完成我们的工作。人工神经网络帮助我们对疾病做出正确的识别，并指导正确的施肥量。</p><p id="08cc" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">只有一个安不能完成我们的工作。因此，我们将它们一个接一个地堆叠起来，形成一个层，我们可以在输入层(给出权重和数据)和输出层(结果)之间形成多个层，这些多个层称为隐藏层，然后它会形成一个<strong class="jw iu"> <em class="jv">深度神经网络，对它的研究称为深度学习。</em>T3】</strong></p><h1 id="4631" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">2.1 深度神经网络看起来怎么样。</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pb"><img src="../Images/116507b55c26cab8ef09b5cb1e3dc19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-_6fT1j1QzLsgTGPXwMuQ.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Simple vs Deep Neural Nets.</figcaption></figure><p id="74f5" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">简单的神经网络善于学习输入和输出层之间的一个隐藏层的权重。但是，它不擅长复杂的特征学习。</p><p id="1fa2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">另一方面，深度学习神经网络，输入和输出层之间的一系列层被称为隐藏层，可以执行特征识别，并从数据中创建新的一系列特征，就像我们的大脑一样。我们推进的层越多，它将学习和执行复杂操作的功能就越多。输出图层组合所有要素并进行预测。</p><p id="91d5" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">因此，简单的神经网络用于简单的任务，不需要大量数据来训练自己。而在深度学习中，神经网络可能很昂贵，并且需要大量数据集来训练自己。我不想讨论这个话题，因为它超出了本文的范围。</p><blockquote class="jq jr js"><p id="05be" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">如果你是深度学习概念的绝对初学者，下面的链接将有助于获得所有基础知识。</p></blockquote><div class="nl nm gp gr nn no"><a rel="noopener follow" target="_blank" href="/the-basics-of-deep-neural-networks-4dc39bff2c96"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">深度神经网络的基础</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">随着 Tensorflow 2.0 和 Fastai 等库的兴起，实现深度学习已经变得触手可及</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="pc l nz oa ob nx oc lc no"/></div></div></a></div><h1 id="6bae" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">2.2 什么类型的深度学习模型最适合这种场景？？</h1><p id="ea7b" class="pw-post-body-paragraph jt ju it jw b jx ov jz ka kb ow kd ke li ox kh ki lj oy kl km lk oz kp kq kr im bi translated">这就是<strong class="jw iu">卷积神经网络(CNN 或 Conv 网)</strong>。它被广泛应用于图像和视频识别、推荐系统和自然语言处理等领域。然而，<strong class="jw iu">卷积</strong>比<strong class="jw iu">更</strong>有效，因为它减少了参数的数量，这与其他深度学习模型不同。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pd"><img src="../Images/c7b9c7d255be8e7e57814dad3518a66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY5W4FmGgBsu_5wbaNECCw.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><strong class="bd oh">CNN Architecture.</strong></figcaption></figure><p id="333a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">为了简单起见，我将仅解释对该模型的简要理解以及用于构建卷积神经网络的步骤。</p><h1 id="0b97" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">构建 CNN(或)Conv 网络的主要步骤:</h1><ol class=""><li id="296b" class="lu lv it jw b jx ov kb ow li pe lj pf lk pg kr lz ma mb mc bi translated">卷积运算</li><li id="d029" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr lz ma mb mc bi translated">ReLU 层(整流线性单元)</li><li id="aff5" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr lz ma mb mc bi translated">池层(最大池)</li><li id="ce69" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr lz ma mb mc bi translated">变平</li><li id="1252" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr lz ma mb mc bi translated">全连接层</li></ol><p id="f8ff" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">开始写代码。</p><p id="a48b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated"><strong class="jw iu"> 1。卷积</strong>是从输入图像中提取特征的第一层，它使用输入图像的<strong class="jw iu">内核或过滤器</strong>来学习特征之间的关系。</p><p id="395a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">2.<strong class="jw iu"> ReLU 层:</strong> ReLU 代表非线性操作的整流线性单元。输出为<strong class="jw iu"><em class="jv">(x)= max(0，x)。</em> </strong>我们用这个是因为要给 CNN 引入非线性。</p><p id="9820" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">3.<strong class="jw iu">池层:</strong>通过下采样减少参数数量，只保留有价值的信息做进一步处理。共有几种类型:</p><ul class=""><li id="743a" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">最大池(选择此项)。</li><li id="0a4a" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">平均池和总和池。</li></ul><p id="3eae" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">4.<strong class="jw iu">展平:</strong>我们将整个矩阵展平成一个垂直的向量。因此，它将被传递到输入层。</p><p id="1937" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">5.<strong class="jw iu">完全连接层:</strong>我们将展平后的矢量传递给输入层。我们将这些特征结合起来创建了一个模型。最后，我们有一个激活函数，如 softmax 或 sigmoid 来对输出进行分类。</p><h1 id="1e69" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">3.了解了 CNN 的运作。接下来呢？？</h1><ol class=""><li id="005c" class="lu lv it jw b jx ov kb ow li pe lj pf lk pg kr lz ma mb mc bi translated"><strong class="jw iu">收集数据(图像)</strong></li></ol><p id="ef8c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">收集尽可能多的数据集，包括受疾病影响的图像和健康的图像。您应该需要批量数据。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/83ca08c8b209297991f98fb797c2082a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*PTOVUfDZfymZ12sgWAyE6g.jpeg"/></div></figure><p id="c3af" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated"><strong class="jw iu"> 2。建设 CNN。</strong></p><p id="0e85" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">使用一些流行的开源库构建 CNN，用于开发人工智能、机器学习和深度学习。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi po"><img src="../Images/574fb5b7ce54d0b67ad64cb4e6dd3e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07pPlP1a8heoVmUsaCz8Sg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Open Source Libraries.</figcaption></figure><p id="6383" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated"><strong class="jw iu"> 3。选择任何基于云的数据科学 IDE。</strong></p><p id="53b1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">在云中训练模型是很好的，因为它需要巨大的计算能力，我们的普通机器笔记本电脑和计算机无法承受。如果你有一个好的 GPU 配置笔记本电脑，你可以在你的本地机器上训练。我选择 Google colab 你可以选择任何你喜欢的云。</p><p id="8572" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated"><strong class="jw iu">谷歌 Colab: </strong></p><blockquote class="jq jr js"><p id="9e74" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">Google colab 是一个免费的云服务，提供免费的 GPU(12Gb 内存)。这是训练我们的模型的最便捷的方法，不需要在我们的机器上安装任何库。它完全在云上工作。它预装了所有的依赖项。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pp"><img src="../Images/e2d522bbe09e574a760474f38dd839c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AMf0X9CZf5xwDE6nbg1Wg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Google Colab offers free GPU.</figcaption></figure><p id="3743" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">登录 colab 并创建一个新的 python 笔记本(ipynb)切换到 GPU 模式并开始编写代码。</p><h2 id="e294" class="oj mo it bd mp ok ol dn mt om on dp mx li oo op nb lj oq or nf lk os ot nj ou bi translated">4.开始写代码。</h2><blockquote class="md"><p id="3a49" class="me mf it bd mg mh mi mj mk ml mm kr dk translated">在编写代码之前，数据应该存储在 Google drive 中。</p></blockquote><p id="34df" class="pw-post-body-paragraph jt ju it jw b jx pq jz ka kb pr kd ke li ps kh ki lj pt kl km lk pu kp kq kr im bi translated">源代码可以在这里找到我的 GitHub <a class="ae pv" href="https://github.com/Manikanta-Munnangi/CROP---Plant-Disease-Identification-Using-App" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><blockquote class="jq jr js"><p id="b91e" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第一步:从 google drive 挂载数据</em>。</strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="266b" class="oj mo it px b gy qb qc l qd qe">from google.colab import drive<br/>drive.mount(‘/content/your path’)</span></pre><blockquote class="jq jr js"><p id="7efd" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第二步:导入库。</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="3821" class="oj mo it px b gy qb qc l qd qe"># Import Libraries<br/>import os<br/>import glob<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="8c12" class="oj mo it px b gy qf qc l qd qe"># Keras API<br/>import keras<br/>from keras.models import Sequential<br/>from keras.layers import Dense,Dropout,Flatten<br/>from keras.layers import Conv2D,MaxPooling2D,Activation,AveragePooling2D,BatchNormalization<br/>from keras.preprocessing.image import ImageDataGenerator</span></pre><blockquote class="jq jr js"><p id="d60b" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第三步:将训练和测试数据加载到单独的变量中。</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="2f0f" class="oj mo it px b gy qb qc l qd qe"># My data is in google drive.<br/>train_dir ="drive/My Drive/train_set/"<br/>test_dir="drive/My Drive/test_data/"</span></pre><blockquote class="jq jr js"><p id="17c6" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第四步:获取训练和测试数据中图像数量的函数。</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="86ed" class="oj mo it px b gy qb qc l qd qe"># function to get count of images<br/>def get_files(directory):<br/>  if not os.path.exists(directory):<br/>    return 0<br/>  count=0<br/>  for current_path,dirs,files in os.walk(directory):<br/>    for dr in dirs:<br/>      count+= len(glob.glob(os.path.join(current_path,dr+"/*")))<br/>  return count</span></pre><blockquote class="jq jr js"><p id="9236" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第五步:查看每张中的图片数量。</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="5c34" class="oj mo it px b gy qb qc l qd qe">train_samples =get_files(train_dir)<br/>num_classes=len(glob.glob(train_dir+"/*"))<br/>test_samples=get_files(test_dir)<br/>print(num_classes,"Classes")<br/>print(train_samples,"Train images")<br/>print(test_samples,"Test images")</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qg"><img src="../Images/45025e072f671245287d8ad934c6f17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fh-dcgpRftRgYDIe94WXXQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">5.Output.</figcaption></figure><ul class=""><li id="669c" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">收集 12 类= 12 种类型的疾病图像。</li><li id="7a88" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">14955 张火车图片</li><li id="e8c7" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">432 张测试图片(我只错拍了几张图片测试)。</li><li id="9efd" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">为了预测，我只从看不见的数据中提取了一些样本。我们可以使用作为训练数据一部分的验证数据进行评估。</li></ul><blockquote class="jq jr js"><p id="309b" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第六步:将我们的原始数据预处理成可用的格式。</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="faec" class="oj mo it px b gy qb qc l qd qe"># Pre-processing data with parameters.<br/>train_datagen=ImageDataGenerator(rescale=1./255,<br/>                                   shear_range=0.2,<br/>                                   zoom_range=0.2,<br/>                                   horizontal_flip=True)<br/>test_datagen=ImageDataGenerator(rescale=1./255)</span></pre><ul class=""><li id="abbd" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">在(0–1)之间重新调整图像值称为标准化。</li><li id="f174" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">无论您对训练做什么预处理，都应该进行并行测试。</li><li id="3206" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">所有这些参数都存储在变量“<strong class="jw iu"> train_datagen 和 test_datagen”中。</strong></li></ul><blockquote class="jq jr js"><p id="a026" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">步骤 7:从训练和测试目录中生成扩充数据。</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="87ee" class="oj mo it px b gy qb qc l qd qe"># set height and width and color of input image.<br/>img_width,img_height =256,256<br/>input_shape=(img_width,img_height,3)<br/>batch_size =32</span><span id="c42b" class="oj mo it px b gy qf qc l qd qe">train_generator =train_datagen.flow_from_directory(train_dir,<br/>                                target_size=(img_width,img_height),                                                    batch_size=batch_size)<br/>test_generator=test_datagen.flow_from_directory(test_dir,shuffle=True,target_size=(img_width,img_height),                                               batch_size=batch_size)</span></pre><ul class=""><li id="9ba1" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">获取一个目录的路径，并生成批量的扩充数据。在无限循环中无限期生成批次。</li><li id="460f" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">批量指的是在一次迭代中使用的训练样本的数量。</li></ul><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qh"><img src="../Images/e793879216a9d8b65bdda426f471d32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DG30cNRP67QCyZ02NETKJQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">7.Output.</figcaption></figure><blockquote class="jq jr js"><p id="7d87" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第八步:获取 12 个疾病名称/类别。</em>T9】</strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="3cba" class="oj mo it px b gy qb qc l qd qe"># The name of the 12 diseases.<br/>train_generator.class_indices</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qi"><img src="../Images/98fd97ecaaecf9e2144255953a8b35cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GtXcXmkRsGvUgHvFAdb-w.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">8.Disease Names.</figcaption></figure><blockquote class="jq jr js"><p id="8431" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第九步:建立 CNN 模型</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="665e" class="oj mo it px b gy qb qc l qd qe"># CNN building.<br/>model = Sequential()<br/>model.add(Conv2D(32, (5, 5),input_shape=input_shape,activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(3, 3)))<br/>model.add(Conv2D(32, (3, 3),activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Conv2D(64, (3, 3),activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))   <br/>model.add(Flatten())<br/>model.add(Dense(512,activation='relu'))<br/>model.add(Dropout(0.25))<br/>model.add(Dense(128,activation='relu'))          <br/>model.add(Dense(num_classes,activation='softmax'))<br/>model.summary()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi po"><img src="../Images/e736e3bcbff27b141fe1f3d55b7a49ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9CDUqI5vUFzECyrfzHRZQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">9.Summary of layers.</figcaption></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qj"><img src="../Images/52abe59703bcda8078e6ed6fd5a9e104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nCDPR5by5ejy56uvugk3Q.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">9. Output.</figcaption></figure><p id="27f7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">CNN 收缩参数，学习特征，存储有价值的信息，输出形状在每一层后递减。<strong class="jw iu">我们能看到每一层的输出吗？是啊！！我们可以。</strong></p><blockquote class="jq jr js"><p id="e983" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">步骤 10:每一层之后的图像可视化。</em>T19】</strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="2beb" class="oj mo it px b gy qb qc l qd qe">from keras.preprocessing import image<br/>import numpy as np<br/>img1 = image.load_img('/content/drive/My Drive/Train_d/Tomato___Early_blight/Tomato___Early_blight/<br/>(100).JPG')<br/>plt.imshow(img1);<br/>#preprocess image<br/>img1 = image.load_img('/content/drive/MyDrive/Train_d/<br/>Tomato___Early_blight/Tomato___Early_blight(100).JPG', target_size=(256, 256))<br/>img = image.img_to_array(img1)<br/>img = img/255<br/>img = np.expand_dims(img, axis=0)</span></pre><ul class=""><li id="b417" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">从训练数据集获取样本图像，并在每一层后可视化输出。</li><li id="f8c4" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated"><strong class="jw iu">注意:新样本图像需要预处理。</strong></li></ul><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="20db" class="oj mo it px b gy qb qc l qd qe">from keras.models import Model<br/>conv2d_1_output = Model(inputs=model.input, outputs=model.get_layer('conv2d_1').output)<br/>max_pooling2d_1_output = Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_1').output)</span><span id="246a" class="oj mo it px b gy qf qc l qd qe">conv2d_2_output=Model(inputs=model.input,outputs=model.get_layer('conv2d_2').output)<br/>max_pooling2d_2_output=Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_2').output)</span><span id="267a" class="oj mo it px b gy qf qc l qd qe">conv2d_3_output=Model(inputs=model.input,outputs=model.get_layer('conv2d_3').output)<br/>max_pooling2d_3_output=Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_3').output)</span><span id="c7e2" class="oj mo it px b gy qf qc l qd qe">flatten_1_output=Model(inputs=model.input,outputs=model.get_layer('flatten_1').output)</span><span id="a9cd" class="oj mo it px b gy qf qc l qd qe">conv2d_1_features = conv2d_1_output.predict(img)<br/>max_pooling2d_1_features = max_pooling2d_1_output.predict(img)<br/>conv2d_2_features = conv2d_2_output.predict(img)<br/>max_pooling2d_2_features = max_pooling2d_2_output.predict(img)<br/>conv2d_3_features = conv2d_3_output.predict(img)<br/>max_pooling2d_3_features = max_pooling2d_3_output.predict(img)<br/>flatten_1_features = flatten_1_output.predict(img)</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qk"><img src="../Images/2b6837612bbfa09941358f29c8db1788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZeZMrCiX1nSDe-Rpqzkgg.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">10. Visualization</figcaption></figure><blockquote class="jq jr js"><p id="0d2f" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第十一步。开始用参数训练 CNN。</em>T25】</strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="f114" class="oj mo it px b gy qb qc l qd qe">validation_generator = train_datagen.flow_from_directory(<br/>                       train_dir, # same directory as training data<br/>                       target_size=(img_height, img_width),<br/>                       batch_size=batch_size)</span><span id="fb88" class="oj mo it px b gy qf qc l qd qe">opt=keras.optimizers.Adam(lr=0.001)<br/>model.compile(optimizer=opt,loss='categorical_crossentropy',metrics=['accuracy'])<br/>train=model.fit_generator(train_generator,nb_epoch=20,                             steps_per_epoch=train_generator.samples//batch_size,                        validation_data=validation_generator,nb_val_samples=validation_generator.samples // batch_size,verbose=1)</span></pre><ul class=""><li id="69fd" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">Adam 优化器与学习率=0.001 一起使用</li><li id="d12a" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">损失函数 categorical _ crossentropy 用于我们的<strong class="jw iu">多类分类问题</strong>。度量标准是<strong class="jw iu">“准确性”。</strong></li><li id="e45c" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">Fit_generator 用于训练 CNN 模型。使用验证数据参数对<strong class="jw iu">模型进行微调。</strong></li></ul><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ql"><img src="../Images/e5d57df38c490cac9568497d5f05422e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vj5ikQuTK1mNLX-mfyP_w.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">11. Train and validation Accuracy and Loss.</figcaption></figure><blockquote class="jq jr js"><p id="5dbf" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu">第 12 步:保存模型权重。</strong></p></blockquote><ul class=""><li id="c6b8" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">保存模型权重以防止模型的重新训练。</li></ul><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="944d" class="oj mo it px b gy qb qc l qd qe"># Save model<br/>from keras.models import load_model<br/>model.save('crop.h5')</span></pre><blockquote class="jq jr js"><p id="a488" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu">步骤 13:从保存的权重加载模型。</strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="6d03" class="oj mo it px b gy qb qc l qd qe"># Loading model and predict.<br/>from keras.models import load_model<br/>model=load_model('crop.h5')</span><span id="c710" class="oj mo it px b gy qf qc l qd qe"># Mention name of the disease into list.<br/>Classes = ["Potato___Early_blight","Potato___Late_blight","Potato___healthy","Tomato___Bacterial_spot","Tomato___Early_blight","Tomato___Late_blight","Tomato___Leaf_Mold","Tomato___Septoria_leaf_spot","Tomato___Spider_mites Two-spotted_spider_mite","Tomato___Target_Spot","Tomato___Tomato_mosaic_virus","Tomato___healthy"]</span></pre><ul class=""><li id="79c7" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">提到这个名字是因为我们的输出是<strong class="jw iu">数字格式。我们把它铸造成字符串。</strong></li></ul><blockquote class="jq jr js"><p id="10ec" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">第十四步:预测</em> </strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="b927" class="oj mo it px b gy qb qc l qd qe">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="f5c0" class="oj mo it px b gy qf qc l qd qe"># Pre-Processing test data same as train data.<br/>img_width=256<br/>img_height=256<br/>model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])</span><span id="7cfe" class="oj mo it px b gy qf qc l qd qe">from keras.preprocessing import image</span><span id="a63a" class="oj mo it px b gy qf qc l qd qe">def prepare(img_path):<br/>    img = image.load_img(img_path, target_size=(256, 256))<br/>    x = image.img_to_array(img)<br/>    x = x/255<br/>    return np.expand_dims(x, axis=0)<br/>    <br/>    <br/>result = model.predict_classes([prepare('/content/drive/My Drive/Test_d/Tomato_BacterialSpot/Tomato___Bacterial_spot (901).JPG')])<br/>disease=image.load_img('/content/drive/My Drive/Test_d/Tomato_BacterialSpot/Tomato___Bacterial_spot (901).JPG')<br/>plt.imshow(disease)<br/>print (Classes[int(result)])</span></pre><ul class=""><li id="0aed" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">我们需要预处理我们的图像，以传入一个模型来预测</li><li id="abbe" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">首先，我们调整图像的大小=== &gt;图像(150，150)</li><li id="b704" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">将图像转换为数组，这将增加通道=== &gt;图像(150，150，3) RGB</li><li id="87cd" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">Tensorflow 处理批量图像我们需要指定图像样本===&gt;(1，150，150，3)。</li><li id="279b" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">Predict_classes 帮助预测新图像属于各自的类。</li></ul><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qk"><img src="../Images/35c933ecb9f9cf762390e608ebed336e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hUe6ZQWpz-0Y7CiE0vIPw.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">14.Predictions on test data, different diseases.</figcaption></figure><blockquote class="jq jr js"><p id="691b" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu"> <em class="it">最后一步:将模型转换成“tflite”。</em>T45】</strong></p></blockquote><pre class="kt ku kv kw gt pw px py pz aw qa bi"><span id="7185" class="oj mo it px b gy qb qc l qd qe">from tensorflow.contrib import lite<br/>converter = lite.TFLiteConverter.from_keras_model_file( 'crop.h5' ) <br/>model = converter.convert()<br/>file = open( 'output.tflite' , 'wb' ) <br/>file.write( model )</span></pre><ul class=""><li id="5345" class="lu lv it jw b jx jy kb kc li lw lj lx lk ly kr pm ma mb mc bi translated">为了让我们的模型与应用程序通信，我们必须转换为 TensorFlow lite 版本，tflite 是为移动版本而设计的。</li><li id="aeda" class="lu lv it jw b jx ph kb pi li pj lj pk lk pl kr pm ma mb mc bi translated">因此，您可以构建或创建一个移动应用程序，并使该应用程序与模型进行通信。</li></ul><p id="1577" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">你可以使用 Google flutter 框架来构建具有漂亮用户界面的应用程序。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qm"><img src="../Images/9f67c4c3cc8943c1b6cc2d3a277d56cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIwMiB8T4Co8R2dOXgG5qg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Google flutter framework.</figcaption></figure></div><div class="ab cl qn qo hx qp" role="separator"><span class="qq bw bk qr qs qt"/><span class="qq bw bk qr qs qt"/><span class="qq bw bk qr qs"/></div><div class="im in io ip iq"><blockquote class="jq jr js"><p id="6369" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu">在</strong>进入 App 部分之前，您需要从<a class="ae pv" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu">官网将颤振环境安装到您的机器上。</strong> </a></p></blockquote><p id="0dc1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">打开 flutter 编辑器，无论是 Android studio 还是 visual studio，都可以进行编码。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qu"><img src="../Images/4d31ccc23b56454aaa316f11bcaab46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rffl5IYDF5tUNVqUlrAMuA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Editors of Flutter.</figcaption></figure><blockquote class="jq jr js"><p id="81d9" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">创建一个新的 flutter 项目，并将项目文件中的一个文件夹拖放到我们的 flutter 项目的 assets 文件夹中。以下名称已更改，但 tflite 文件是相同的。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi po"><img src="../Images/ea280f349a3f60b303bbb82f4f6fe1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtFjDxf6gw-sLdh1ZDR3VQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Flutter Assets folder.</figcaption></figure><p id="fa20" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">App 用户界面可以自己选择，可以通过学习 flutter 做一个，也可以直接用我的 flutter app 界面。可以在我的 Github 里找到。</p><p id="7a87" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke li kg kh ki lj kk kl km lk ko kp kq kr im bi translated">完成将“output.tflite”放入 assets 文件夹后，开始在仿真器和<strong class="jw iu">测试模型中运行应用程序，使用测试文件夹中的一些图片以及模型之前未见过的真实图像。</strong></p><h1 id="abc8" class="mn mo it bd mp mq mr ms mt mu mv mw mx my od na nb nc oe ne nf ng of ni nj nk bi translated">结论:</h1><p id="6eeb" class="pw-post-body-paragraph jt ju it jw b jx ov jz ka kb ow kd ke li ox kh ki lj oy kl km lk oz kp kq kr im bi translated">植物疾病是主要的食物威胁，在它导致整个田地的进一步损失之前，应该被克服。但是，通常情况下，制定者不能区分相似的症状，但面对不同的疾病。这将误导错误或过量施肥。在这里，我们采用卷积神经网络(CNN)多层人工神经网络，称为深度学习算法，以减少这种损失，并通过视频课程指导农民。这可以通过手机应用程序来完成，“不是所有的农民，但有些人确实使用它。”</p><blockquote class="md"><p id="f304" class="me mf it bd mg mh mi mj mk ml mm kr dk translated">我希望以上内容对阅读这篇文章的每个人都有用。我肯定会提出与数据科学、ML 和 DL 相关的话题。快乐学习:)</p></blockquote><h1 id="92e9" class="mn mo it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">感谢您的阅读…</h1><p id="a50e" class="pw-post-body-paragraph jt ju it jw b jx ov jz ka kb ow kd ke li ox kh ki lj oy kl km lk oz kp kq kr im bi translated"><a class="ae pv" href="https://github.com/Manikanta-Munnangi" rel="noopener ugc nofollow" target="_blank">我的 Github 个人资料。</a></p></div></div>    
</body>
</html>