<html>
<head>
<title>Introducing Lathe: Pipelines For Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍车床:朱莉娅的管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-lathe-pipelines-for-julia-57d7d7c07349?source=collection_archive---------34-----------------------#2019-11-05">https://towardsdatascience.com/introducing-lathe-pipelines-for-julia-57d7d7c07349?source=collection_archive---------34-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/09fe9e8419034ed3c9f18f9185e1179f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*M-wIWWz5rPyxifO3NwXaRw.png"/></div></figure><p id="2c33" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在 Julia 语言中，我最想念的工具之一是 SKlearn 管道。与 SKlearn 相比，Lathe 本质上是一个非常不同的东西，不仅是基于函数式编程语言构建的，而且还具有像 fit-initialization 这样的初学者友好的属性。我非常想实现的是车床内部 Sklearn 管道的替代方案，随着即将发布的车床 0.0.5，我已经做到了！</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><p id="e740" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae lc" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Lathe%20pipelines%20example.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">笔记本</strong> </a></p><h1 id="0d5b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">数据</h1><p id="441f" class="pw-post-body-paragraph jx jy it jz b ka mb kc kd ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku im bi translated">为了开始我们的小管道演示，我们需要读入一些数据。由于这不一定是一个项目，我将从我的<a class="ae lc" rel="noopener" target="_blank" href="/deep-sea-correlation-27245959ccfa">深海相关项目</a>中回收数据。当然，第一步是使用 CSV 读取我们的数据:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="5d7d" class="mp le it ml b gy mq mr l ms mt">using CSV<br/>df = CSV.read("bottle.csv")</span></pre><p id="3cbd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们快速清洗！</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="eab8" class="mp le it ml b gy mq mr l ms mt">using DataFrames<br/>df = DataFrame(:TempC =&gt; df.T_degC, :Salinity =&gt; df.R_SALINITY, :Depth =&gt; df.Depthm)<br/># We're going to drop the missing values now, if we did that prior, # we would<br/>#    have likely dropped a-lot more data.<br/>df = dropmissing(df)</span></pre><blockquote class="mu"><p id="da20" class="mv mw it bd mx my mz na nb nc nd ku dk translated">轻松点。</p></blockquote><p id="2bcd" class="pw-post-body-paragraph jx jy it jz b ka ne kc kd ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku im bi translated">现在我们可以进入主题的实质，从选择我们的特性和目标开始。这对我来说并不重要，因为我们不追求准确性，而只是新模块的演示。对于我的特征，我选择了盐度和我的目标温度。让我们对测试和训练集做一个快速分割，然后我们可以设置我们的 x 和 y…</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e028" class="mp le it ml b gy mq mr l ms mt">using Lathe.preprocess: TrainTestSplit<br/>train,test = TrainTestSplit(df)</span></pre><p id="a4c1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以及 X 和 Y 设置:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a22d" class="mp le it ml b gy mq mr l ms mt">trainX = train.Salinity<br/>trainy = train.TempC<br/>testX = test.Salinity<br/>testy = test.TempC</span></pre></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="0a15" class="ld le it bd lf lg nj li lj lk nk lm ln lo nl lq lr ls nm lu lv lw nn ly lz ma bi translated">管道</h1><p id="ad2d" class="pw-post-body-paragraph jx jy it jz b ka mb kc kd ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku im bi translated">为了在车床中建立管道，首先要建立一个模型。虽然在 Sklearn 中也可以这样做，但是这里的不同之处在于，管道的其他部分依赖于在模型中构造的 X 和 Y。考虑到这一点，我们仍然可以按照 Sklearn 的方式来做，但拟合模型的方式必须与我们在外部做的方式相同。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4877" class="mp le it ml b gy mq mr l ms mt">using Lathe.preprocess: StandardScalar<br/>using Lathe.models: LinearRegression<br/>using Lathe: pipelines</span></pre><p id="c5a5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们可以调用函数，它接受一个构造好的车床模型、一个方法或数组中的方法，然后接受一个类型参数。将来，除了原始的管道之外，可能会有不同类型的管道用于不同类型的特性，并且可能到 0.0.5 发布时，会有一个管道能够与其他 Julia 模型通用地工作。现在我们可以构建我们的管道。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9a9c" class="mp le it ml b gy mq mr l ms mt">pipl = pipelines.Pipeline(LinearRegression(trainX,<br/>trainy),StandardScalar,:CON)</span></pre><p id="7a99" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后一部分，“:CON”告诉 predict 方法要运行哪个算法，这可能会改变，所以我不会太关注这一部分，因为它基本上不重要。</p><p id="e04b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了预测，我们使用来自车床的函数 pipe _ predict . pipelines:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7ed9" class="mp le it ml b gy mq mr l ms mt"><a class="ae lc" href="http://twitter.com/time" rel="noopener ugc nofollow" target="_blank">@time</a> pipelines.pipe_predict(pipl,testX)</span></pre><blockquote class="mu"><p id="f778" class="mv mw it bd mx my mz na nb nc nd ku dk translated">恭喜你！</p></blockquote><p id="98bf" class="pw-post-body-paragraph jx jy it jz b ka ne kc kd ke nf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku im bi translated">现在我们已经正式创建了一个 fit 管道来保存我们的训练值、预处理方法和模型类型！一个巨大的好处是即将到来的管道系列化。我不仅计划在 Julia 中序列化这些模型，还计划用 PyPi 包将它们读入 Python，以便在 Flask 和 Django 管道和 web 应用程序中使用，这不是很酷吗？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3297" class="mp le it ml b gy mq mr l ms mt">pipelines.save(pipl,"My-Pipeline")</span></pre><p id="4678" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我真的很兴奋的未来，这部分车床，和车床整体举行！车床 0.0.5 中有很多新的统计数据、模型和更多的东西，之后还会有更多！</p></div></div>    
</body>
</html>