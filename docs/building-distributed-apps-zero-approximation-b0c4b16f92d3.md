# 构建分布式应用程序:零近似值

> 原文：<https://towardsdatascience.com/building-distributed-apps-zero-approximation-b0c4b16f92d3?source=collection_archive---------31----------------------->

![](img/9a72f45dfa483033c389161cc0b79ee8.png)

如今，世界发展迅速。进步不断带来新的技术挑战。信息系统架构应该足够灵活，能够响应新的需求并不断发展。在本文中，我们将讨论事件驱动的架构、并发性、并行性、异步性，以及如何与 Erlang 中的所有这些和平共处。

# 介绍

作为开发人员，我们根据系统的规模和需求选择这种或那种类型的信息交换。在大多数情况下，可以用来协调服务的是一个带有代理的模式，例如，基于 RabbitMQ 或 kafka。有时，事件流、SLA 和对系统的控制级别使得现成的消息传递不适合我们。当然，你可以把系统稍微复杂一点，使用 ZeroMQ 或者 nanomsg。通过这样做，您将负责传输层和集群的形成。但是，如果系统缺乏吞吐量或标准的 Erlang 集群容量，那么添加额外实体的问题就需要检查和经济合理性。

反应式分布式应用的主题相当广泛。为了符合本文的格式，今天我们将重点讨论基于 Erlang/Elixir 构建的同构环境。Erlang/OTP 生态系统使我们能够以最少的时间和精力实现反应式架构。无论如何，我们需要一个消息传递层。

# 理论框架

工程从定义目标和限制开始。主要目的不在于为了发展而发展。我们需要的是得到一个安全的、可伸缩的工具，让我们创建和开发各种层次的现代应用程序。这些应用可能从服务于一小部分受众的单个服务器应用到 50–60 个节点的集群或集群联盟。因此，我们的主要目标是通过降低系统开发和拥有成本来实现利润最大化。

让我们强调一下目标系统的 4 个要求:

*   可计算性。独立单元可以垂直和水平缩放。还应该有机会无限制地横向扩展整个系统；
*   **E** 发泄驱使的天性。系统总是准备好处理事件流并对其进行处理；
*   **L** 有保证的热情。时间就是金钱，所以用户不应该等待太久；
*   故障容差。所有级别和服务都必须在出现故障时自动恢复。

如果该系统的基础满足 **SELF** 的最低要求，则该系统可以从 MVP 阶段前进并且是渐进的。消息传递作为基础设施工具和所有服务的基础，其特点是对程序员也很有用。

# 事件驱动的性质

为了让一个应用程序可以从一个服务器扩展到一个集群，它的架构应该提供松散耦合。异步模型满足了这一要求。在这样的模型中，发送者和接收者都关心他们的消息的信息负载，而不担心消息传递或路由。

# 可量测性

可伸缩性和系统性能通常是密切相关的。应用程序组件必须能够利用所有可用的资源。我们利用产能的效率越高，加工方法越优化，我们在设备上的花费就越少。在一台机器中，Erlang 创建了高度并发的环境。可以通过选择 Erlang VM 可访问的操作系统线程数量以及利用这些线程的调度程序数量来平衡并行性和并发性。

Erlang 进程没有共享状态，并且以非阻塞模式工作。这比传统的阻塞同步应用程序提供了相对较低的延迟和更高的吞吐量。Erlang 调度程序负责公平的 CPU 和 IO 分配。没有阻塞使应用程序即使在峰值负载或故障的情况下也能做出响应。

在集群级别，也存在利用率问题。重要的是在集群中的机器之间均匀地分配负载，并且不要使网络过载。想象一下:用户流量正在登陆负载平衡器(例如 haproxy、nginx 等)。这些平衡器在服务器池中的可用处理程序之间分发请求。在应用基础设施中，实现所需接口的服务只是最后一英里。它必须请求许多其他服务来响应初始查询。内部请求也需要路由和平衡。
为了正确管理数据流，消息传递应该为开发人员提供一个控制路由和负载分布的接口。因此，开发人员将能够使用微服务模式，解决常规任务和非标准任务。

从商业角度来看，可伸缩性是风险管理的工具之一。这里的关键是满足客户的需求并高效地使用硬件:

*   如果你通过进步来提高硬件的性能，硬件就不会因为软件的不完善而闲置。Erlang 可以完美地垂直扩展，并且能够利用所有 CPU 内核和可用内存；
*   在云环境中，我们可以根据当前或预测的负载来管理硬件数量，并确保 SLA。

# 容错

让我们考虑两个公理:“失败是不可接受的。”和“总会有失败。”对任何企业来说，软件故障都意味着金钱损失，更糟糕的是名誉损失。即使在潜在损失和容错软件的开发成本之间徘徊，通常也有可能达成妥协。

从短期来看，容错架构节省了购买现成集群解决方案的资金。它们可能会让你付出昂贵的代价，并且包含错误。

从长远来看，容错体系结构在开发的所有阶段都可以获得数倍的回报。

代码库内部的消息传递使您能够在开发阶段阐述系统中的组件关系。这有助于管理故障的任务，因为所有负责的组件都处理故障，并且具有自动故障转移的目标系统知道如何在故障后通过设计将其自身恢复到正常状态。

# 响应性

不管有什么错误，你的应用都应该响应查询并遵守 SLA。现实是现在的人还没有做好等待的准备。因此，企业必须进行调整。预计会有越来越多的应用程序响应速度很快。

响应式应用以接近实时的模式工作。Erlang VM 在软实时模式下运行。然而，对于某些领域，如证券交易、医药或工业设备，硬实时模式至关重要。响应系统提高了 UX 并有助于商业。

# 初步结论

当我计划这篇文章时，我想分享我创建消息代理的经验，并在此基础上进一步构建复杂的系统。然而，理论和激励部分被证明是太广泛了。

在文章的第二部分，我们将讨论交换点实现和消息交换模式的细微差别。

第三部分将致力于服务安排、路由和平衡的一般问题。此外，我们将讨论可伸缩性和容错的实际方面。

第一部分的结尾。

卢卡·布拉沃拍摄的照片