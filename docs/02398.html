<html>
<head>
<title>Collaborative filtering using fastai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 fastai 的协同过滤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/collaborative-filtering-using-fastai-a2ec5a2a4049?source=collection_archive---------18-----------------------#2019-04-19">https://towardsdatascience.com/collaborative-filtering-using-fastai-a2ec5a2a4049?source=collection_archive---------18-----------------------#2019-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7801" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用 fastai 库构建推荐引擎</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/fea81408ce2600903a4203fa15a702bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gjHGC5uhqt6NW7d6vkSHXg.jpeg"/></div></figure><h2 id="5f27" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">介绍</h2><p id="1cb0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">协同过滤是机器学习的一种应用，我们试图预测用户是否会喜欢特定的电影或产品。我们通过查看用户以前的购买习惯来做到这一点。在其最简单的形式中，协同过滤只涉及 3 列，用户 ID、歌曲 ID 和用户对该歌曲的评价。这正是我们将在本文中使用的。</p><p id="5f22" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated"><a class="ae mh" href="https://www.kaggle.com/dipam7/collaborative-filtering-with-fastai?scriptVersionId=13121727" rel="noopener ugc nofollow" target="_blank"> <em class="mi">全朱庇特笔记本。</em> </a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/8f84d024f8cfec420e0e814d2a25b7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*AzJUtkpf2X99UzyIX0mMwA.png"/></div></figure><h2 id="5061" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">数据存储</h2><p id="1e98" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">有两种方法可以存储协同过滤的数据。我们可以将它存储在如上所示的<code class="fe mk ml mm mn b">.csv</code>中，也可以使用<code class="fe mk ml mm mn b">matrix.</code>矩阵的行代表用户，列代表项目，特定单元格的值代表用户对特定项目的评分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/be594a139749e415f527523f4d62d84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZebClM3UHPCCcHJUC7dWhA.png"/></div></div></figure><p id="983f" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">然而，如果我们以这种方式存储它，我们将最终得到一个非常稀疏的矩阵，因为大多数用户不会观看大多数电影或购买大多数产品。此外，矩阵将是巨大的，浪费了大量的存储空间。因此，我们将仅将其存储为<code class="fe mk ml mm mn b">.csv</code>。</p><h2 id="424a" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">嵌入</h2><p id="fa7a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">我们处理协同过滤问题的方法是，我们给每个用户分配一组权重，给每个项目分配一组权重，这些权重的点积就是用户对该项目的评分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/3b86c4b3141113b94660c6ac98daa109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3J2A0lGxfT2C_T9zI1VF-g.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">image source: fast.ai</figcaption></figure><p id="9edc" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">对于每个用户，我们查找相应的权重，这个东西被称为<strong class="ll ir"><em class="mi"/></strong>嵌入，将代表宋立科流派或用户口味的特征。</p><p id="7ee5" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">但是这些还不够。也许有一些用户喜欢很多歌曲或者大多数人喜欢的歌曲。因此，我们不是只取点积，而是将用户偏差和歌曲偏差添加到我们的预测中，以说明这一点。然后，我们使用梯度下降来更新我们的权重，直到我们得到足够好的结果。</p><p id="b11b" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">让我们看看如何在代码中做到这一点。</p><h2 id="1ba1" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">解决办法</h2><p id="1d73" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">和往常一样，我们从导入 fast.ai 库开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi my"><img src="../Images/7126b5adc3c9a7ccc1e696a99b30940e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdTvwkM5ygIVMGKeX8umtQ.png"/></div></div></figure><p id="667b" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">我们检查数据集的长度和收视率的分布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mz"><img src="../Images/6e91bb7e6fcb51452c68ea30803c3f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5m8KWuHmnnKLXKtuV9Lrw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d49d5d7233ecf9302d50e2cb6bb65218.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*X1I4kheZaxRzc3MjLwWIIA.png"/></div></figure><p id="2527" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">然后，我们创建一个数据集群，并使用 20%的数据作为验证集的一部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nb"><img src="../Images/dc7581796a4f71dd919515fb180c9054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7H4gI81J-D84_84OmtI_Q.png"/></div></div></figure><p id="cf04" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">请注意 DataBunch 创建步骤中的种子参数。</p><p id="3ac0" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">当我们希望我们的结果可重复时，我们使用种子。这意味着我们随机抽取 20%的数据作为验证集的一部分，但是，我们希望确保下次运行代码时，我们得到相同的(随机)分割。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nc"><img src="../Images/5622b05d839ffdc36666d9195a27cfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5ZPTQXooTntp2tSfjfYLQ.png"/></div></div></figure><p id="48af" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">一旦我们创建了一个数据束，我们就初始化一个<strong class="ll ir"> <em class="mi">学习器</em> </strong>。点积和偏差会给我们一些分数。这些分数可以是负数，也可以是正数。我们希望确保这些预测在我们期望的 0-5 范围内。经过大量的训练后，模型可以自己学习，但是我们希望节省一些工作，并告诉它我们希望预测的范围。因此我们把参数<code class="fe mk ml mm mn b">y_range</code>传递给它。这将在最后添加一个 s 形层。</p><p id="dc29" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">我们选择稍微高于和低于最小值和最大值的值，以保持预测在范围内。</p><p id="3008" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated"><code class="fe mk ml mm mn b">n_factors</code>参数决定了我们嵌入的大小。我们也传递了一点重量衰减。</p><p id="43ad" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">最后，我们找到学习率并训练我们的模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ff75d4f0aeb75361ecb5492d3c94b222.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*jufHXB35rocOo-ODkoJ5hA.png"/></div></figure><h2 id="7cdd" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结果</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ne"><img src="../Images/e50a4b4c31309bd699061089a94f8088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0JTvTPB7hgcqFbnCfiuMw.png"/></div></div></figure><p id="94e8" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">数据集是一个相对简单的数据集，我们得到了很好的结果。此外，由于我们的嵌入大小只是一个参数，我们可以运行一个<code class="fe mk ml mm mn b">for loop</code>并传递不同大小的嵌入来检查哪一个给出最好的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nf"><img src="../Images/0e4250acfe648354ad67c9d51d9893f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USPC4oNq2zz3sEDZO1GP9g.png"/></div></div></figure><p id="2479" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">这就是我们解决协同过滤问题的方法。我们可以解释模型，找到最有偏见的歌曲或最没有偏见的用户。然而，为此，我们需要另一个<code class="fe mk ml mm mn b">csv</code>来告诉我们哪个 id 对应于哪个歌曲或用户。</p><p id="dbe1" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated"><em class="mi">根据歌曲偏好对歌曲进行评级会很有趣，因为如果我们仔细想想，当我们去掉用户偏好和我们的嵌入时，歌曲偏好仍然存在。这意味着它代表了歌曲的无偏见的观点，去除了可能影响它的所有其他因素(基于歌曲和用户)。</em></p><p id="6fed" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">我们还可以看看嵌入。然而，我们可能有很多(在这个例子中是 50 个)，看 50 个影响我们选择歌曲的因素是不直观的。因此，我们可以做的是应用类似 PCA(主成分分析)的东西，将其降低到一个合理的数字，然后可以进行分析。</p><h2 id="f0c4" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">协同过滤的问题:冷启动</h2><p id="9b3e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">当我们有足够的关于用户或歌曲的数据时，我们可以很好地预测结果。但是，我们真正想给用户推荐歌曲的时候，是有新用户加入我们平台的时候。或者某个艺人发布新歌的时候。在这种情况下，我们没有以前的数据可以依赖，因此推荐是困难的。公司采取各种方法来解决这个问题，比如让用户选择他喜欢的电影类型，但目前还没有明确的解决方案。</p><h2 id="264c" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h2><p id="2135" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">最后，我想敦促我的读者真正提高他们的数据准备技能。当我们参加 Kaggle 比赛或在线下载数据集时，所有的数据清洗和预处理步骤都已经为我们完成了。然而在现实世界中，你将不得不处理原始数据，你将不得不处理多个数据源。你如何处理这些资源将决定你是否会成为一名优秀的数据科学家。</p><p id="0183" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">所以努力学习这些技能，因为建模只是过程的一部分(而且是很小的一部分。)</p><p id="730b" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">这就是本文的全部内容。</p><p id="b649" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">如果你想了解更多关于深度学习的知识，可以看看我在这方面的系列文章:</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/@dipam44/deep-learning-series-30ad108fbe2b" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">深度学习系列</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">我所有关于深度学习的文章的系统列表</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kl nj"/></div></div></a></div><p id="2957" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">~快乐学习</p></div></div>    
</body>
</html>