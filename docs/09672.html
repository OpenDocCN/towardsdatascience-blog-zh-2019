<html>
<head>
<title>Geoparsing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 进行地理解析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geoparsing-with-python-c8f4c9f78940?source=collection_archive---------6-----------------------#2019-12-19">https://towardsdatascience.com/geoparsing-with-python-c8f4c9f78940?source=collection_archive---------6-----------------------#2019-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56c5" class="pw-subtitle-paragraph jr is it bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">挖掘文本中的地理地名并绘制它们</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/707cda5c06f550bb1705aad45ba147e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjiHbVgR4ZRJvz2OfMznvQ.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">“The Quaker City in a Storm,” frontispiece from Mark Twain’s <em class="jq">The Innocent’s Abroad; Source: Project Gutenberg</em></figcaption></figure><p id="6957" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">地理解析是指从文本中提取地名，并将这些名称与专有名词和空间坐标明确匹配的过程。然后可以将这些坐标标绘在地图上，以便可视化所讨论文本的空间覆盖区。地理分析是一种在地理学中称为<em class="lv">地名解析</em>的特殊程序:然而，尽管地理分析和地名解析都处理文本中具体地理实体的识别，但地名解析通常涉及从结构化、明确的引用中简单推导地理；例如，邮局使用地理编码的州缩写进行路由。另一方面，Geoparsing 表示输入文本包含非结构化歧义；例如，一个文本可能引用美国南部的一个国家和一个州——乔治亚州，而解决这种模糊性是地质公园研究者的任务。</p><p id="f269" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在信息科学、文学分析和数字人文领域，<a class="ae lw" href="http://groups.inf.ed.ac.uk/geoparser/documentation/v1.1/html/intro.html" rel="noopener ugc nofollow" target="_blank">爱丁堡地质公园</a>自 2015 年以来一直作为开源工具使用，严格用于地质公园历史文献和经典作品的任务。爱丁堡地质公园可以在网上免费获得，它让研究人员不仅可以在纸上，还可以在电脑屏幕上追踪约翰·斯坦贝克的《T4 与查理的旅行》或乔治·奥威尔的《通往威根码头之路》。该程序获取输入文本，精确定位位置名称，用地名词典(类似地图集的地理目录)交叉引用这些名称，并在谷歌地图上绘制输出结果。通过这种方式，学者们可以用上帝的视角看到寄信人或小说主角的旅行，每个离散的目的地都在互动的全景中。</p><p id="49ea" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助于几个现成的软件包，我们可以很容易地用 Python 构建我们自己的初级爱丁堡地质公园。以下是这样做的尝试。举个例子，我将解析马克·吐温的<em class="lv">国外的无辜者</em>。对于这项任务来说，这是一个恰当的文本:这部小说出版于 1859 年，是吐温一生中最著名的作品之一，也是有史以来最畅销的游记之一。从美国到法国，从敖德萨到耶路撒冷，吐温和来自 15 个不同州的 60 位同胞走遍了全球，到处都是地名。</p><p id="542f" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个地质分析器，需要下面的包。我会在下面的脚本中清楚地说明每个人在做什么。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="1289" class="mc md it ly b gy me mf l mg mh">&gt;import numpy as np<br/>&gt;import matplotlib.pyplot as plt<br/>&gt;%matplotlib inline<br/>&gt;<br/>&gt;import pandas as pd<br/>&gt;import geopandas as gpd<br/>&gt;<br/>&gt;from urllib import request<br/>&gt;from geotext import GeoText<br/>&gt;<br/>&gt;from geopy.geocoders import Nominatim<br/>&gt;from geopy.exc import GeocoderTimedOut<br/>&gt;<br/>&gt;from shapely.geometry import Point, Polygon<br/>&gt;import descartes</span></pre><p id="c6cd" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要做的是抓住<em class="lv">无辜者</em>。全文可通过古腾堡项目免费在线获得。Python 的自然语言处理库 NLTK 原生提供了 18 个古腾堡文本用于练习。不幸的是，<em class="lv">无辜者</em>不在其中，所以我将使用来自<code class="fe mi mj mk ly b">urllib</code>模块的<code class="fe mi mj mk ly b">requests</code>对象，传递原始数据的 url。txt，然后用 utf-8 解码。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="f255" class="mc md it ly b gy me mf l mg mh">&gt;url = "<a class="ae lw" href="http://www.gutenberg.org/files/3176/3176-0.txt" rel="noopener ugc nofollow" target="_blank">http://www.gutenberg.org/files/3176/3176-0.txt</a>"<br/>&gt;response = request.urlopen(url)<br/>&gt;raw = response.read().decode('utf8')<br/>&gt;print(f'{type(raw)}, \n{len(raw)}, \n{raw[:501]}')</span><span id="0f97" class="mc md it ly b gy ml mf l mg mh">&lt;class 'str'&gt;, <br/>1145397, <br/>﻿Project Gutenberg's The Innocents Abroad, by Mark Twain (Samuel Clemens)<br/><br/>This eBook is for the use of anyone anywhere at no cost and with<br/>almost no restrictions whatsoever.  You may copy it, give it away or<br/>re-use it under the terms of the Project Gutenberg License included<br/>with this eBook or online at www.gutenberg.net<br/><br/><br/>Title: The Innocents Abroad<br/><br/>Author: Mark Twain (Samuel Clemens)<br/><br/>Release Date: August 18, 2006 [EBook #3176]<br/>Last Updated: February 23, 2018<br/><br/>Language: English</span></pre><p id="4d36" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">印在我的 Jupyter 笔记本控制台上的是这本书的扉页；整个文本只是一个由 1145397 个字符组成的大字符串。该字符串包含我将尝试挖掘的所有地理参考。NLP 包空间的自动处理管道包括名称实体识别，给国家、州和城市分配“地缘政治实体”标签然而，我无法在 SpaCy 中找到一种简单的方法来只提取<em class="lv">城市——除了编写一个交叉引用维基百科摘要的迭代函数——所以我改用 GeoText，它有一个容易提取城市名称的属性。</em></p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="c86e" class="mc md it ly b gy me mf l mg mh">&gt;places = GeoText(raw)<br/>&gt;cities = list(places.cities)<br/>&gt;cities</span><span id="c1fc" class="mc md it ly b gy ml mf l mg mh">['Tangier',<br/> 'Paris',<br/> 'Temple',<br/> 'Como',<br/> 'Garibaldi',<br/> 'Rome',<br/> 'Roman',<br/> 'Naples',<br/> 'Naples',<br/> ...]</span></pre><p id="4b54" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像 SpaCy 一样，GeoText 可以识别地理命名的实体，但是在 GeoText 中调用<code class="fe mi mj mk ly b">.cities</code>只会返回城市名称。请注意，我没有删除重复的城市条目；我想保留这些，这样当我绘制它们时，我的地图就包含了参考频率。</p><p id="c03e" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我需要一本地名词典，以便用明确的空间坐标具体地标出这些城市的名称。爱丁堡地质公园有专门的历史地名词典，但我没有权限查阅。相反，<a class="ae lw" href="https://www.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank"> OpenStreetMap </a>是一个受维基百科模式启发的合作地图:它是免费的，任何人都可以编辑。OSM 有一个名为“命名”的搜索工具，给定一个城市或州的名称，它会对该名称进行反向地理编码，并返回其地理坐标。所以我只需要给 nomim 一份城市名的列表。有许多方法可以做到这一点，但一种方法是通过 Python 包<a class="ae lw" href="https://pypi.org/project/geopy/" rel="noopener ugc nofollow" target="_blank"> GeoPy </a>，它抽象出了 nomim 的 API，并返回包含在输入搜索的第一个结果中的坐标。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="204f" class="mc md it ly b gy me mf l mg mh">&gt;geolocator = Nominatim(timeout=2)<br/>&gt;<br/>&gt;lat_lon = []<br/>&gt;for city in cities: <br/>&gt;    try:<br/>&gt;        location = geolocator.geocode(city)<br/>&gt;        if location:<br/>&gt;            print(location.latitude, location.longitude)<br/>&gt;            lat_lon.append(location)<br/>&gt;    except GeocoderTimedOut as e:<br/>&gt;        print("Error: geocode failed on input %s with message %s"%&gt;<br/>&gt;             (city, e))<br/>&gt;lat_lon</span><span id="314f" class="mc md it ly b gy ml mf l mg mh">35.7642313 -5.81862599789511<br/>48.8566101 2.3514992<br/>31.098207 -97.3427847<br/>45.9394759 9.14941014540895<br/>-29.2562253 -51.5269167<br/>41.894802 12.4853384<br/>49.67887 4.31419<br/>40.8359336 14.2487826<br/>40.8359336 14.2487826</span></pre><p id="1393" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将 API 的超时设置为 2 秒，并包含一个错误处理语句，如果 API 超时，该语句将跳过当前搜索。我的希望是，如果单个搜索时间超过 2 秒，它就不是一个真正的城市名称，因此脚本会从最终的地图中剔除非名称。我把城市名称和坐标输入熊猫数据框:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="eeb0" class="mc md it ly b gy me mf l mg mh">&gt;df = pd.DataFrame(lat_lon, columns=['City Name', 'Coordinates'])<br/>&gt;df.head(7)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mm"><img src="../Images/015b1d2bbb35fbebd0b2d3b67b625e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUUBWJm650WEC-RRl_shEg.png"/></div></div></figure><p id="ad47" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前被格式化为元组的坐标需要被转换成点对象，因为每个城市将由地图上的一个点来表示。Python 包<a class="ae lw" href="https://pypi.org/project/Shapely/" rel="noopener ugc nofollow" target="_blank"> Shapely </a>就是这么做的。下面，我正在遍历包含坐标元组的 dataframe 系列，将它们分别转换为点，并切换纬度和经度的顺序，因为这是我下载的地图对象使用的顺序<a class="ae lw" href="https://hub.arcgis.com/datasets/a21fdb46d23e4ef896f31475217cbb08_1" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="9f8c" class="mc md it ly b gy me mf l mg mh">&gt;geometry = [Point(x[1], x[0]) for x in df['Coordinates']]<br/>&gt;geometry[:7]</span><span id="9778" class="mc md it ly b gy ml mf l mg mh">[&lt;shapely.geometry.point.Point at 0x116fe3b10&gt;,<br/> &lt;shapely.geometry.point.Point at 0x116ff9190&gt;,<br/> &lt;shapely.geometry.point.Point at 0x116fe0c10&gt;,<br/> &lt;shapely.geometry.point.Point at 0x116fe0a10&gt;,<br/> &lt;shapely.geometry.point.Point at 0x116fe0250&gt;,<br/> &lt;shapely.geometry.point.Point at 0x116fe0850&gt;,<br/> &lt;shapely.geometry.point.Point at 0x116fe0210&gt;]</span></pre><p id="c349" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些点对象放回数据帧将使我们能够轻松地绘制它们。现在，我将使用一个<a class="ae lw" href="http://geopandas.org/" rel="noopener ugc nofollow" target="_blank"><em class="lv">geo pandas</em></a>data frame 来代替 pandas dataframe，它可以轻松处理这些类型的对象。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="7f09" class="mc md it ly b gy me mf l mg mh">&gt;## coordinate system I'm using<br/>&gt;crs = {'init': 'epsg:4326'}<br/>&gt;<br/>&gt;## convert df to geo df<br/>&gt;geo_df = gpd.GeoDataFrame(df, crs=crs, geometry=geometry)<br/>&gt;geo_df.head()</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mn"><img src="../Images/78fe6ba9eba4d24712b2db943e241d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04EBYtDWjKuqsGp2o5G3sw.png"/></div></div></figure><p id="a270" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是在地图上标出位置。我没有删除重复的位置条目这一事实意味着，如果我设置了标记的透明度，那么引用频率较高的位置会比只引用一次的位置看起来更不透明。这是通过<code class="fe mi mj mk ly b">plot</code>对象中的<code class="fe mi mj mk ly b">alpha</code>参数完成的。不透明的标记应该大致对应于贵格城号实际航行过的城市，透明的标记对应于仅仅提到过的城市。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="5c3a" class="mc md it ly b gy me mf l mg mh">&gt;## world map .shp file I downloaded<br/>&gt;countries_map =gpd.read_file('Countries_WGS84/<br/>&gt;                              Countries_WGS84.shp')<br/>&gt;<br/>&gt;f, ax = plt.subplots(figsize=(16, 16))<br/>&gt;countries_map.plot(ax=ax, alpha=0.4, color='grey')<br/>&gt;geo_df['geometry'].plot(ax=ax, markersize = 30, <br/>&gt;                        color = 'b', marker = '^', alpha=.2)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/7db3b45c16e8cfe6bb6f04f6af2d7880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rL53kwOxVWWpVEFLzxm3TQ.png"/></div></div></figure><p id="4fcc" class="pw-post-body-paragraph kz la it lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是马克·吐温的《国外的无辜者》，地质公园。</p></div></div>    
</body>
</html>