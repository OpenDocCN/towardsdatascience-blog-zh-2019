<html>
<head>
<title>Wondering how to build an anomaly detection model?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想知道如何构建异常检测模型？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/wondering-how-to-build-an-anomaly-detection-model-87d28e50309?source=collection_archive---------2-----------------------#2019-02-10">https://towardsdatascience.com/wondering-how-to-build-an-anomaly-detection-model-87d28e50309?source=collection_archive---------2-----------------------#2019-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="601e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用 python 从头开始创建自己的异常检测模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/362b69da283e6db6e14b715d88f9d4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LKcbiEjgf4s51xJw"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jefflssantos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jefferson Santos</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="afed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿伙计们！你有没有想过银行是如何识别欺诈账户的？或者，如何检测网络中的一些故障服务器？或者你如何解决机器学习中的问题，你没有足够的关于你的正面例子的知识？</p><p id="b47e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你来对地方了。异常检测是一种用于识别不符合预期行为的异常模式的技术，称为<strong class="ky ir">异常值</strong>。它在商业中有许多应用，从入侵检测(识别网络流量中可能预示黑客攻击的奇怪模式)到系统健康监控(在 MRI 扫描中发现恶性肿瘤)，从信用卡交易中的欺诈检测到操作环境中的故障检测。</p><h1 id="a54c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">完成后你会学到什么</h1><ul class=""><li id="f101" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">你会明白如何使用 numpy，以及如何使用它做矩阵乘法。</li><li id="076a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">您将使用<strong class="ky ir"> matplot </strong>库来绘制和可视化异常。</li><li id="0ca8" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">您将使用<strong class="ky ir">高斯分布</strong>来寻找数据集的概率。</li><li id="4fa2" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">您可以应用<strong class="ky ir">矢量化</strong>来提高代码效率。</li><li id="f5cf" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">你将学习 F1 分数的概念，并用它来计算精确度和召回率，使你的预测更加准确。</li><li id="963a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">您可以使用<strong class="ky ir"> try-except 学习 python 中的错误处理。</strong></li></ul><p id="84f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯…激动？让我们开始吧。</p><h1 id="6570" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们在做什么？</h1><p id="ac07" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因此，我们正在制作一个异常检测模型，并应用它来检测网络上的故障服务器。在进入原始数据集之前，让我们首先想象一下如何进行和执行不同的功能。让我们从导入几个库开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fe97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用一个虚拟数据集来检查所有函数是否正常工作，然后我们将在原始数据集上使用这些函数。我们和好了吗？现在，我们将导入数据集，需要注意的一点是<strong class="ky ir">这里的</strong>数据集应该位于脚本所在的同一个目录中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1c84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">sio.loadmat()将我们的数据集(' anomalyData.mat ')加载到变量 dataset 中。变量“X”包含训练数据集，“Xval”包含交叉验证集，“yval”包含“Xval”的相应输出。让我们看看数组“X ”,我们将使用它来拟合高斯模型，以检测异常示例。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="9ef8" class="nk lt iq ng b gy nl nm l nn no">print(X.shape)<br/>(307, 2)</span></pre><p id="8436" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，有<strong class="ky ir"> 307 </strong>个训练示例，每个都有 2 个特征。这些特性测量每个服务器的<strong class="ky ir">吞吐量(mb/s)和响应延迟(ms)。</strong>当您的服务器运行时，您收集了 m = 307 个关于它们如何运行的示例，因此有一个未标记的数据集{x(1)，。。。，x(m)}。您怀疑这些示例中的绝大多数都是服务器正常运行的“正常”(非异常)示例，但是在这个数据集中也可能有一些服务器异常运行的示例。现在，让我们将数据集可视化，以便有一个清晰的画面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/aa381a7a8275d5b5c8a5a911776f4feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*se2opZUO7XJMeKIbUTc7gw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Fig.1</figcaption></figure><h1 id="21cb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">高斯分布</h1><p id="e8d9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">要执行异常检测，首先需要使模型符合数据的分布。给定一个训练集{x(1)，…，x(m)}(其中 x(i) ∈ R^n，这里 n = 2)，您想要估计每个特征的高斯分布。对于每个特征(i = 1。。。n)，你需要找到参数均值和方差(mu，sigma)。为此，让我们写下计算数组(或者你可以称之为矩阵)x 的均值和方差的函数。</p><p id="9b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数学表达式是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4237df95ab28285587429c3e17642ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*yk62uZvpbpnCVXDq4e7wJw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Fig.2</figcaption></figure><p id="d4bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须计算每个特征的平均值，在此帮助下，我们计算相应特征的方差。让我们把它写成代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="aa5a" class="nk lt iq ng b gy nl nm l nn no">mu, sigma2 = estimateGaussian(X)<br/>print('mean: ',mu,' variance: ',sigma2)<br/> mean:  [[14.11222578 14.99771051]]  variance:  [[1.83263141 1.70974533]]</span></pre><p id="5689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了均值和方差，我们需要计算训练样本的概率，以确定哪些样本是异常的。我们可以通过使用<strong class="ky ir">多元高斯</strong>模型来实现。</p><h1 id="39a1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">多元高斯分布</h1><p id="cd19" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">多元高斯函数用于计算每个例子的概率，并根据某个阈值<strong class="ky ir">决定是否标记异常。计算高斯模型参数的表达式为:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/7ad6d61e5dbde4379877e2060906e5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97fovaMFYHD5bW4vTWonAQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Fig.3</figcaption></figure><p id="82c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，μ是每个特征的平均值，变量 sigma 计算协方差矩阵。这两个参数用于计算概率<strong class="ky ir"> p(x)。“e”是我们将进一步详细讨论的阈值</strong>。一旦理解了表达式，代码实现起来就非常简单了。让我们看看如何把它变成代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="87e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数内部，首先，我们将 sigma2 向量转换为协方差矩阵，然后简单地应用多元分布公式来获得概率向量。如果你在 sigma2 中传递了一个<strong class="ky ir">向量</strong>，你必须将它转换成一个矩阵，向量作为对角线，元素的其余部分为零(第 6 行)。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="81db" class="nk lt iq ng b gy nl nm l nn no">p = multivariateGaussian(X, mu, sigma2)<br/>print(p.shape)<br/>(307, 1)</span></pre><p id="0644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，你已经成功地计算出了概率。接下来，你必须使用一些带标签的数据来计算阈值。让我们看看如何做到这一点。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="0310" class="nk lt iq ng b gy nl nm l nn no">pval = multivariateGaussian(Xval, mu, sigma2)</span></pre><p id="eea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们找到“Xval”的概率，将其与“yval”进行比较，以确定阈值。让我们找出阈值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="70d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们发现步长有一个很宽的阈值范围来决定最好的一个。我们使用<strong class="ky ir"> F1 得分</strong>方法来确定最佳参数，即<strong class="ky ir">bestε和 bestF1。</strong>预测异常如果<strong class="ky ir"> pval &lt; epsilon </strong>在变量<strong class="ky ir">中给出一个二进制值的向量预测。F1 </strong>分数考虑了<strong class="ky ir">精度和召回率。</strong></p><p id="0a3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在第 19 行，我实现了一个 for 循环来计算 tp、fp 和 fn。如果你能拿出一些逻辑的矢量化实现，我很想听听你的意见。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8549b250adb24d678266d80dd0538ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*UKPPze8OXLLrK8lkxvQrtg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Fig.4</figcaption></figure><p id="3f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">精度=真阳性/(真阳性+假阳性)</p><p id="2dad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回忆=真阳性/(真阳性+假阴性)</p><p id="9f0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最佳参数是 F1 分数值最大的参数。</p><p id="7a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>我们将需要一个<strong class="ky ir"> try-except </strong>块，因为在某些情况下，我们可能会除以零来计算精度和召回率。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="7acd" class="nk lt iq ng b gy nl nm l nn no">F1, epsilon = selectThreshHold(yval, pval)<br/>print('Epsilon and F1 are:',epsilon, F1)</span><span id="138d" class="nk lt iq ng b gy nt nm l nn no">Output:</span><span id="7227" class="nk lt iq ng b gy nt nm l nn no">Warning dividing by zero!!<br/>Epsilon and F1 are: 8.990852779269493e-05 0.8750000000000001</span></pre><p id="16a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们有了最佳的ε值，并且我们现在能够计算训练数据的异常概率。我们也将异常称为<strong class="ky ir">异常值。</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="831c" class="nk lt iq ng b gy nl nm l nn no">outl = (p &lt; epsilon)</span></pre><p id="3008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要返回离群值的索引来识别故障服务器。这给了我们一个带有二进制条目的向量，其中 1 表示异常，0 表示正常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="384d" class="nk lt iq ng b gy nl nm l nn no">Output:<br/>Number of outliers: 6<br/><br/> [300, 301, 303, 304, 305, 306]</span></pre><p id="8bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，故障服务器如上所述。我们还可以用图形方式找出异常值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2a74653f6269967a54d347a078833797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkLnOri_lAirjDb7w4eaMw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The red circle shows the faulty servers in the network</figcaption></figure><p id="72d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">恭喜</strong>！！我们已经成功地测试了我们所有的函数，我们可以在一些真实的数据集上使用它们来找出异常。让我们完成我们已经开始的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="dee6" class="nk lt iq ng b gy nl nm l nn no">Output:<br/>(1000, 11)<br/>(100, 11)<br/>(100, 1)</span></pre><p id="d3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新数据集有 1000 个例子，每个例子有 11 个特征。“Xvaltest”是测试样本的交叉验证集，而“yvaltest”是相应的标签。现在，执行与虚拟数据集相同的操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="8511" class="nk lt iq ng b gy nl nm l nn no">Output:<br/>Warning dividing by zero!!<br/><br/>Best epsilon and F1 are<br/> 1.3772288907613575e-18 0.6153846153846154</span></pre><p id="9adb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ptest 包含测试样本的预测，pvaltest 包含交叉验证集的预测。最佳的ε值是 exp 的阶(-18)。</p><p id="e0a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查<strong class="ky ir">异常值:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="4659" class="nk lt iq ng b gy nl nm l nn no">Outliers are:<br/> [9, 20, 21, 30, 39, 56, 62, 63, 69, 70, 77, 79, 86, 103, 130, 147, 154, 166, 175, 176, 198, 209, 212, 218, 222, 227, 229, 233, 244, 262, 266, 271, 276, 284, 285, 288, 289, 290, 297, 303, 307, 308, 320, 324, 338, 341, 342, 344, 350, 351, 353, 365, 369, 371, 378, 398, 407, 420, 421, 424, 429, 438, 452, 455, 456, 462, 478, 497, 518, 527, 530, 539, 541, 551, 574, 583, 587, 602, 613, 614, 628, 648, 674, 678, 682, 685, 700, 702, 705, 713, 721, 741, 750, 757, 758, 787, 831, 834, 836, 839, 846, 870, 885, 887, 890, 901, 911, 930, 939, 940, 943, 951, 952, 970, 975, 992, 996]</span><span id="3003" class="nk lt iq ng b gy nt nm l nn no">Number of outliers are:  117</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ca47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，有 117 个异常值，它们相应的指数如上所示。</p><h1 id="a2a4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="81dd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我知道从零开始有时会很麻烦，但是如果你从零开始做，你会学到很多细节。你可以在这里找到上述项目的<a class="ae kv" href="https://gist.github.com/abhishek-Kumar009/6f3788a511a9694dca01f1b04af8b940" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">笔记本</strong> </a>。我希望我可以教你一些新的东西，并确保你检查我的<a class="ae kv" href="https://github.com/abhishek-Kumar009/Machine-Learning" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">知识库</strong> </a>我已经做了其他项目，如<strong class="ky ir">最小化数据中心的成本(使用深度强化学习)，数字识别</strong>，聚类一只鸟的图像等。</p><p id="ab93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献:</strong> <a class="ae kv" href="https://www.coursera.org/learn/machine-learning/" rel="noopener ugc nofollow" target="_blank">机器学习通过<strong class="ky ir">吴恩达</strong> </a></p></div></div>    
</body>
</html>