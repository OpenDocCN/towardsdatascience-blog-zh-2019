<html>
<head>
<title>JuMPing into Puzzle Solving with Linear Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用线性规划解决难题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jumping-into-puzzle-solving-with-linear-programming-57852609d516?source=collection_archive---------30-----------------------#2019-10-29">https://towardsdatascience.com/jumping-into-puzzle-solving-with-linear-programming-57852609d516?source=collection_archive---------30-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习如何在类似数独的数字游戏中使用 Julia 语言制定和解决线性程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c55d3e10ba9bc87002a712cf2b8d1ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_aB-cyZyz066293khDaHg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@arstyy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Austin Neill</a> on <a class="ae ky" href="https://unsplash.com/s/photos/jump?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线性规划(LP)是一种解决优化问题的强大技术，您将经常看到它被应用于从航班调度、车辆路线到收入管理的问题。在这篇文章中，我想探索一个更异想天开的应用——如何使用线性编程来解决一个难题？</p><p id="a4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个谜题类似于数独，所以我将为这个新的脑筋急转弯扩展众所周知的<a class="ae ky" href="https://www.mathworks.com/help/optim/examples/solve-sudoku-puzzles-via-integer-programming.html" rel="noopener ugc nofollow" target="_blank">数独 LP 公式</a>。我建议你在继续之前先理解数独解决方案，因为它会有一些类似的逻辑(<a class="ae ky" rel="noopener" target="_blank" href="/using-integer-linear-programming-to-solve-sudoku-puzzles-15e9d2a70baa">这里有一个关于它的中型帖子</a>)。</p><h2 id="0757" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">介绍谜题</h2><p id="d989" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个谜题是一个朋友介绍给我的，他推测可以用 LP 解决。这个问题出现在简街拼图上，你可以在这里阅读描述<a class="ae ky" href="https://www.janestreet.com/puzzles/twenty-four-seven-2-by-2/" rel="noopener ugc nofollow" target="_blank"/>。仅从约束条件来看，它似乎与数独非常相似——对出现次数有约束，但对首次/最后一次出现、值的总和等也有一些其他约束条件。能用 LP 解决吗？答案是肯定的，且看如何。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5c6b5ca945ee6e139bdf7102aea20a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*1K-aVh6-SgvGoJH0WHgG6w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The first puzzle that I will use for my example</figcaption></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="c4d4" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">公式化问题</h1><h2 id="c2bf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">定义变量</h2><p id="90ca" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在阅读了你的问题并对目标有了深刻的理解后，你应该从定义变量开始。决策会是什么样的？是连续的，整数的，二进制的？它有边界吗？从技术上来说，这是一个约束，但在开始时考虑这一点可能会有所帮助，这样你就不会忘记在以后添加它。</p><p id="3198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个谜题，决定很简单:<em class="nm">给定的单元格中应该放入什么数字？</em></p><p id="b499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的变量名将是<em class="nm"> x </em>，它将是二进制的，它将由三个值索引:</p><ul class=""><li id="5253" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">v 是我们正在考虑的从 1 到 7 的数值</li><li id="c9ee" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><em class="nm"> r </em>是从 1 到 7 的行索引</li><li id="38f8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><em class="nm"> c </em>是从 1 到 7 的列索引</li></ul><p id="a11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数学符号中，这是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b4803eaeb76ea5ff802395e4f804dc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*QKwUuEPhEZIiWRObZVOaiQ.png"/></div></figure><p id="79c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由此产生的解将告诉我们哪个数字应该进入哪个单元格。例如，如果解指定 x_{1，1，1}=1，那么这意味着数字 1 进入位置(1，1)的单元格。如果 x_{3，4，7}=0，那么这意味着数字 3 不会进入位置(4，7)的单元格。当我们知道每个数字和单元格组合的所有这些 1 和 0 时，我们就有了解决方案。</p><p id="cd2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建 777 = 343 个二进制变量。对于 LP 问题，二元变量总是比连续值变量更难解决。幸运的是，如今这只是很少的变量，而拥有成千上万个变量的更大的问题可以由如今的<a class="ae ky" href="https://www.math.uni-bielefeld.de/documenta/vol-ismp/25_bixby-robert.pdf" rel="noopener ugc nofollow" target="_blank">解算器</a>来解决。在本地解决这个问题应该没有问题。</p><h2 id="1743" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">定义目标</h2><p id="451a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个问题很不寻常——没有客观性！将其设置为常数，如 0。我们的目标只是找到一个满足所有约束的解决方案；没有衡量一个解决方案比另一个更好的标准。只要结果可行，我们就已经达到了目标。因此我们不需要目标函数。</p><h2 id="af66" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">定义约束</h2><p id="2f44" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这就是举重的切入点。让我们一次解决一个。</p><p id="27ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">每个单元格只能包含一个数字，也可以为空。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/aa4a30ba1349d771072a82bf09333433.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*Tpg5y5iPXyqvQKSEb2kakA.png"/></div></figure><p id="aa2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个给定的单元格，如果<em class="nm"> v=1，2，…7 </em>的二进制变量之和等于零，那么我会把它解释为单元格是空白的。我们应该在约束中使用一个不等式来允许这些空单元格，并将阈值上限设置为 1，因为我们不希望每个单元格有多个数字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/16e43a65179a6cbaafdd6bf92b26c0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*rlvliIJzh3Mj1BPi0StmrQ.png"/></div></figure><p id="689f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">每个值 v(不包括空值)出现的次数必须等于值 v。</strong>这确保了整个网格中 5 的数量是 5，6 的数量是 6，等等。我们知道这个数的值，因为它等于索引<em class="nm"> v </em>，所以这将是约束的右边。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/97f1428d8f0b697880003e85575473da.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*SYWRYXVr7q_OjQBMBLVTcw.png"/></div></figure><p id="c218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">每行有 4 个数字。</strong>同样，每列有 4 个数字。所以只需对所有列(行)和所有可能的值求和。这必须小于 4，因为必须有 4 个数字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e3a3ffe59b58127113c6ca67364b7f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*mgrMU85xi1hV-CBzBaBN3g.png"/></div></figure><p id="bc2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">每行数字之和应为 20。</strong>此外，每列的总和应为 20。这类似于上面的约束，除了我们需要乘以数字的值，<em class="nm"> v. </em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1afd5ce291765eecfb2579ba958f1f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*rKk5c-PeQf3-tKIxDhSjbQ.png"/></div></figure><p id="5e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">每个 2x2 子正方形必须包含至少一个空单元格。</strong>因此，不是每个单元格都可以被填充，所以子正方形中应该有 3 个或更少的数字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/ead3ad01a5692be2a9d362279eec08ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*DuxI38nl4Lj8Cm-5NEBLsg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Need to check that each subsquare (yellow region) cannot have at most 3 numbers.</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e58c61f0ab21b384e5343ad49b54ff77.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*_4ObAZTS3YDkO9wRql2JcA.png"/></div></figure><p id="36db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果应该有一个连通区域。</strong>这也意味着一个数字不应该被空值包围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/aa9caa75c77bbe1d58d1d0c4fa1ded90.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*-15_S4tiqoHuYpQkR4csgw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The question mark should not contain a value if the surrounding cells are empty.</figcaption></figure><p id="9a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们观察与给定位置相邻的单元格(想象在一个数字周围画一个方框)，就可以实现这一点。如果该区域完全充满了空值，那么该边界的二进制变量之和将为零。在这种情况下，为了满足规则，我们要强制中心数也为空。如果边框中非空值的计数大于零，则允许中间有一个数字。</p><p id="c287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">约束需要根据它们在网格中出现的位置来编写。对于我们可以在单元格周围绘制一个 3x3 框(见下图)的点，将应用以下等式</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/28ecb7c32efb54c3d4441c51460331fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQxKOjaBeFznAHg3xsTrdQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/36e788e5fe7c6db5358565a66d6829be.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*6W6aEnkd5get6BK_Qqg5pw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The equation above applies to these cells.</figcaption></figure><p id="5d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个等式被修改以适应网格的剩余区域。例如，对于顶行中的单元格，将针对从 1 到 2 的行修改等式(因为没有 0 行)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d88e574d04bff72c6e8a04820b717dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*gOxkm6qWM6nT-DQR0zupjw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e4bfdb49b39cf6b69edc11c42f8c1eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*ebpIb9Y2Rmr14xJK6xuGCw.png"/></div></div></figure><p id="4090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一列和最后一列以及角落中的单元，可以类似地修改等式的其余部分。</p><p id="3d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">行/列的开始应以特定的数字</strong>开始/结束。对于第 2 行需要从 3 开始的情况，这意味着第 2 行的第一列可以为空或 3。应用后，如果我们在第 2 行一个接一个地移动，那么一个单元格只能有一个数字，如果它左边的单元格有一个 3。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/57b6617c9a8760aa73e51fa6a197a2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*kvXzeB6QobZa0LSpg7TabA.png"/></div></figure><p id="51f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的开始/结束约束遵循类似的公式。</p><p id="1828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">就是这样！这些都是定义问题所需的步骤。干得好，很高兴你还和我在一起。现在，下一步是编写代码。</strong></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="502a" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">使用跳转进行线性编程</h1><p id="c9d8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我在研究生院学习了最优化，在那里<a class="ae ky" href="https://julialang.org/" rel="noopener ugc nofollow" target="_blank"> Julia 语言</a>被热情地使用。你需要的软件包是<a class="ae ky" href="https://github.com/JuliaOpt/GLPK.jl" rel="noopener ugc nofollow" target="_blank"> GLPK </a>和<a class="ae ky" href="http://www.juliaopt.org/JuMP.jl/v0.19.2/" rel="noopener ugc nofollow" target="_blank">茱莉亚数学编程(跳转)</a>——这就是本文的标题。这是一个了不起的包裹；编写 LP 问题非常快速、直观，在各种求解器之间切换也很简单。如果你不熟悉 Julia 和 JuMP，那么我强烈建议你去看看。即使不理解语言，代码也应该是可以理解的。我用的是茱莉亚 1.1.1，JuMP 0.19.2，GLPK 0.10.0</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="b94e" class="lv lw it ol b gy op oq l or os">using GLPK<br/>using JuMP</span><span id="7a6a" class="lv lw it ol b gy ot oq l or os"># Set variable for number of rows/cols/numbers<br/>N = 7</span><span id="d0f5" class="lv lw it ol b gy ot oq l or os">function solve_puzzle(start_grid::Array{Int64,2}, edge_constraints::Array{Int64,2})<br/>    model = Model(with_optimizer(GLPK.Optimizer, Presolve=0, OutputFlag=0));<br/>    # Since we don't care about the objective just set it to something arbitrary<br/>    <a class="ae ky" href="http://twitter.com/objective" rel="noopener ugc nofollow" target="_blank">@objective</a>(model, Min, 0);</span><span id="df8e" class="lv lw it ol b gy ot oq l or os"># Define variables which will be 7x7x7 matrix<br/>    # Use integer instead of binary because I was having trouble fixing Binary values in step below<br/>    <a class="ae ky" href="http://twitter.com/variable" rel="noopener ugc nofollow" target="_blank">@variable</a>(model, 0 &lt;= x[1:N, 1:N, 1:N] &lt;= 1, integer=true);</span><span id="59ff" class="lv lw it ol b gy ot oq l or os"># Initialize values<br/>    for idx in 1:size(start_grid)[1]<br/>        v = start_grid[idx, 1]<br/>        r = start_grid[idx, 2]<br/>        c = start_grid[idx, 3]<br/>        # Fix value to 1<br/>        fix(x[v, r, c], 1, force=true)<br/>    end</span><span id="dcde" class="lv lw it ol b gy ot oq l or os"># Create the constraints<br/>    # At most one value per cell<br/>    for c in 1:N<br/>        for r in 1:N<br/>            <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(x[v, r, c] for v in 1:N) &lt;= 1)<br/>        end<br/>    end</span><span id="83af" class="lv lw it ol b gy ot oq l or os"># The number of occurrences of a number should equal the value of that number<br/>    for v in 1:N<br/>      <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(x[v, r, c] for r in 1:N for c in 1:N) == v)<br/>    end</span><span id="0831" class="lv lw it ol b gy ot oq l or os"># Each row has 4 non-null numbers<br/>    for r in 1:N<br/>      <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(x[v, r, c] for c in 1:N for v in 1:N) == 4)<br/>    end</span><span id="7708" class="lv lw it ol b gy ot oq l or os"># Each column has 4 non-null numbers<br/>    for c in 1:N<br/>      <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(x[v, r, c] for r in 1:N for v in 1:N) == 4)<br/>    end</span><span id="08ed" class="lv lw it ol b gy ot oq l or os"># Each row numbers sums to 20<br/>    for r in 1:N<br/>      <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(v*x[v, r, c] for c in 1:N for v in 1:N) == 20)<br/>    end     <br/>    # Each column numbers sums to 20<br/>    for c in 1:N<br/>      <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(v*x[v, r, c] for r in 1:N for v in 1:N) == 20)<br/>    end</span><span id="e41d" class="lv lw it ol b gy ot oq l or os"># Every 2x2 subsquare must contain one or more empty square<br/>    for p in 1:(N-1)<br/>        for q in 1:(N-1)<br/>            <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, sum(x[v, r, c] for r in p:(p+1) for c in q:(q+1) for v in 1:N) &lt;= 3)<br/>        end<br/>    end</span><span id="87ac" class="lv lw it ol b gy ot oq l or os"># Connected region = no islands<br/>    for c in 1:N<br/>        for r in 1:N<br/>            <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, 2*sum(x[v, r, c] for v in 1:N) &lt;= sum(x[v, i, j] for v in 1:N for i in (r-1):(r+1) if i in 1:7 for j in (c-1):(c+1) if j in 1:7  ))<br/>        end<br/>    end</span><span id="cc56" class="lv lw it ol b gy ot oq l or os"># Edge constraints                                                                                                     <br/>    val_set = Set(1:N)  # define all possible values<br/>    for idx in 1:size(edge_constraints)[1]<br/>        v = edge_constraints[idx, 1]  # value<br/>        k = edge_constraints[idx, 2]  # affected row/col<br/>        is_col = Bool(edge_constraints[idx, 3])  # row/col<br/>        is_last = Bool(edge_constraints[idx, 4])</span><span id="9950" class="lv lw it ol b gy ot oq l or os">v_prime = setdiff(Set(1:7), v)</span><span id="eef3" class="lv lw it ol b gy ot oq l or os">for j in 1:(N-1)<br/>            for not_v in v_prime<br/>                if is_col<br/>                    if is_last<br/>                        # last in column k must be v or null<br/>                        fix(x[not_v, 7, k], 0; force=true)<br/>                        # cell is non-null if the values after cell in column have number<br/>                        <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, x[not_v, j, k] &lt;= sum(x[v, r, k] for r in (j+1):N ))<br/>                    else<br/>                        # first in column k must be v or null<br/>                        fix(x[not_v, 1, k], 0; force=true)<br/>                        # cell is non-null if values before cell in column have number<br/>                        <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, x[not_v, j+1, k] &lt;= sum(x[v, r, k] for r in 1:j) )<br/>                    end<br/>                else<br/>                    if is_last<br/>                        # last in row k must be v or null<br/>                        fix(x[not_v, k, 7], 0; force=true)<br/>                        # cell is non-null if values after cell in row have number<br/>                        <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, x[not_v, k, j] &lt;= sum(x[v, k, c] for c in (j+1):N ))<br/>                    else<br/>                        # first col in row k must be v or null<br/>                        fix(x[not_v, k, 1], 0; force=true)<br/>                        # cell is non-null if values before cell in row have number<br/>                        <a class="ae ky" href="http://twitter.com/constraint" rel="noopener ugc nofollow" target="_blank">@constraint</a>(model, x[not_v, k, j+1] &lt;= sum(x[v, k, c] for c in 1:j) )<br/>                    end<br/>                end<br/>            end<br/>        end<br/>    end</span><span id="aa76" class="lv lw it ol b gy ot oq l or os">optimize!(model)<br/>    # want to see the code 1                                                                                                                                <br/>    println(termination_status(model)) <br/>    primal_status(model)</span><span id="b4c1" class="lv lw it ol b gy ot oq l or os"># Create results<br/>    results = zeros(N,N)<br/>    for i in 1:N<br/>        vals = reshape(value.(x[i,:,:]), N, N)<br/>        multiplier = ones(N,N)*i<br/>        results += multiplier.*vals<br/>    end<br/>    return results                                                                                                                            <br/>end</span></pre><p id="8a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行它，只需指定边约束和起始网格值，并调用函数。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="0ce8" class="lv lw it ol b gy op oq l or os"># Initialize starting values<br/># column 1 specifies number, column 2 is the row number, column 3 is the column number<br/>values = [7 1 2;<br/>          6 1 3;<br/>          6 2 4;<br/>          6 2 5;<br/>          5 3 1;<br/>          6 4 2;<br/>          4 4 6;<br/>          6 5 7;<br/>          4 6 3;<br/>          7 6 4;<br/>          7 7 5;<br/>          7 7 6]<br/># Encode the first/end row/col constraints (counter-clockwise)<br/># column 1 specifies the number<br/># column 2 specifies the affected row/col<br/># column 3 has values 0 for row and 1 for col<br/># column 4 has values 0 for start and 1 for end<br/>start_end_constraints = [3 2 0 0;<br/>                         5 5 0 0;<br/>                         1 7 0 0;<br/>                         7 1 1 1;<br/>                         2 2 1 1;<br/>                         2 6 0 1;<br/>                         4 3 0 1;<br/>                         4 1 0 1;<br/>                         7 7 1 0;<br/>                         5 6 1 0];<br/>results = solve_puzzle(values, start_end_constraints)</span></pre><p id="4177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些想要解决方案的人:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2974c13c1ed0efdc4a31a0a67e61bf3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*Vq_oMTFjY8tm5Qp73UDAUg.png"/></div></figure><p id="2cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我会试着关注评论中的问题。</p></div></div>    
</body>
</html>