<html>
<head>
<title>Counting No. of Parameters in Deep Learning Models by Hand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">手动计算深度学习模型中的参数数量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/counting-no-of-parameters-in-deep-learning-models-by-hand-8f1716241889?source=collection_archive---------3-----------------------#2019-01-21">https://towardsdatascience.com/counting-no-of-parameters-in-deep-learning-models-by-hand-8f1716241889?source=collection_archive---------3-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5b5cfe418644012c1b4b6392f8158fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBU8KjBpPsaAzArLD3Cq5w.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/photos/TqfrYn9lDSA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Andrik Langfield</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="b160" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">计算 FFNN、RNN 和 CNN 模型参数的 5 个简单例子</h2></div><p id="98fb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di"> W </span>为什么我们需要再次计算深度学习模型中的参数数量？我们没有。但是，如果我们需要减少模型的文件大小，甚至减少模型推断所需的时间，了解模型量化前后的参数数量将会派上用场。(看视频<a class="ae jd" href="https://www.youtube.com/watch?v=eZdOkDtYMoo" rel="noopener ugc nofollow" target="_blank">这里</a>关于深度学习的高效方法和硬件。)</p><p id="baf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">计算深度学习模型的<em class="ma">可训练</em>参数的数量被认为是太琐碎了，因为你的代码已经可以为你做到这一点。但是我想把我的笔记留在这里，供我们偶尔参考。以下是我们将浏览的模型:</p><ol class=""><li id="ce0b" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq mg mh mi mj bi translated"><a class="ae jd" href="#9fe4" rel="noopener ugc nofollow">前馈神经网络</a></li><li id="7e84" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq mg mh mi mj bi translated"><a class="ae jd" href="#192e" rel="noopener ugc nofollow">递归神经网络(RNN) </a></li><li id="637a" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq mg mh mi mj bi translated"><a class="ae jd" href="#5137" rel="noopener ugc nofollow">卷积神经网络(CNN) </a></li></ol><p id="f1aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与此同时，我将使用 Keras 的 API 构建模型，以实现简单的原型制作和简洁的代码，因此让我们在这里快速导入相关对象:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="709b" class="my mz jg mu b gy na nb l nc nd"><strong class="mu jh">from</strong> keras.layers <strong class="mu jh">import</strong> Input, Dense, SimpleRNN, LSTM, GRU, Conv2D<br/><strong class="mu jh">from</strong> keras.layers <strong class="mu jh">import</strong> Bidirectional<br/><strong class="mu jh">from</strong> keras.models <strong class="mu jh">import</strong> Model</span></pre><p id="ef52" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">建立<code class="fe ne nf ng mu b">model</code>后，调用<code class="fe ne nf ng mu b">model.count_params()</code>验证有多少参数是可训练的。</p><h2 id="9fe4" class="my mz jg bd nh ni nj dn nk nl nm dp nn le no np nq li nr ns nt lm nu nv nw nx bi translated">1.FFNNs</h2><ul class=""><li id="ffef" class="mb mc jg kx b ky ny lb nz le oa li ob lm oc lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong>，输入尺寸</li><li id="a0af" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"><em class="ma"/></strong>，隐藏层尺寸</li><li id="a9ba" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong>，输出尺寸</li></ul><p id="24d9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于一个隐藏层，</p><p id="e1d0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma"> num_params <br/> = </em>层间连接+每层偏置<br/>=<strong class="kx jh">(<em class="ma">I×h+h×o</em>)<em class="ma">+</em>(<em class="ma">h+o</em>)</strong></p><p id="9c3e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例 1.1:输入尺寸 3，隐藏层尺寸 5，输出尺寸 2 </strong></p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9386a9192c176c14c98178457f4820d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*sTV2UIv76WQiHt4JfCqk9g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 1.1: FFNN with input size 3, hidden layer size 5, output size 2. The graphics reflect the actual no. of units.</figcaption></figure><ul class=""><li id="86dd" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong> = 3</li><li id="3a6c" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> h </em> </strong> = 5</li><li id="2583" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong> = 2</li></ul><p id="3732" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params</em><br/><em class="ma">=</em>层间连接+各层偏置<br/>=<strong class="kx jh">(3×5+5×2)+(5+2)<br/></strong>=<strong class="kx jh">32</strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f205" class="my mz jg mu b gy na nb l nc nd"> input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">3</strong>))<br/> dense = <strong class="mu jh">Dense</strong>(<strong class="mu jh">5</strong>)(input)<br/>output = <strong class="mu jh">Dense</strong>(<strong class="mu jh">2</strong>)(dense)<br/> model = <strong class="mu jh">Model</strong>(input, output)</span></pre><p id="1334" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例 1.2:输入尺寸 50，隐藏层尺寸[100，1，100]，输出尺寸 50 </strong></p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e43b93acb6ad8d6041d561f1612cb868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*FafEaBfSOXVodvdC_l6gXw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 1.2: FFNN with 3 hidden layers. The graphics do not reflect the actual no. of units.</figcaption></figure><ul class=""><li id="a14d" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma">我</em> </strong> = 50</li><li id="67b7" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> h </em> </strong> = 100，1，100</li><li id="dde9" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong> = 50</li></ul><p id="6912" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma"> num_params </em> <br/> =层间连接+各层偏置<br/>=<strong class="kx jh">(50×100+100×1+1×100+100×50)+(100+1+100+50)<br/></strong>=<strong class="kx jh">10451</strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8615" class="my mz jg mu b gy na nb l nc nd"> input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">50</strong>))<br/> dense = <strong class="mu jh">Dense</strong>(<strong class="mu jh">100</strong>)(input)<br/> dense = <strong class="mu jh">Dense</strong>(<strong class="mu jh">1</strong>)(dense)<br/> dense = <strong class="mu jh">Dense</strong>(<strong class="mu jh">100</strong>)(dense)<br/>output = <strong class="mu jh">Dense</strong>(<strong class="mu jh">50</strong>)(dense)<br/> model = <strong class="mu jh">Model</strong>(input, output)</span></pre><h2 id="192e" class="my mz jg bd nh ni nj dn nk nl nm dp nn le no np nq li nr ns nt lm nu nv nw nx bi translated">2.RNNs</h2><ul class=""><li id="dbe1" class="mb mc jg kx b ky ny lb nz le oa li ob lm oc lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> g </em> </strong>，单位内人数(RNN 1 人，GRU 3 人，LSTM 4 人)</li><li id="ebcb" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> h </em> </strong>，隐藏单位尺寸</li><li id="7e1c" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong>，输入的尺寸/大小</li></ul><p id="0a70" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于每个 FFNN 都有<strong class="kx jh"><em class="ma">h</em>(<em class="ma">h</em>+<em class="ma">I</em>)+<em class="ma">h</em></strong>参数，所以我们有</p><p id="d797" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params =</em><strong class="kx jh"><em class="ma">g</em>×【<em class="ma">h</em>(<em class="ma">h</em>+<em class="ma">I</em>)+<em class="ma">h</em></strong></p><p id="aacb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例 2.1:具有 2 个隐藏单元和输入维度 3 的 LSTM。</strong></p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/8503b1f17e3ca5ad34cc1be203df0f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ht2-sUJHi65wDwnR276k3A.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 2.1: An LSTM cell. Taken from <a class="ae jd" rel="noopener" target="_blank" href="/animated-rnn-lstm-and-gru-ef124d06cf45">here</a>.</figcaption></figure><ul class=""><li id="bcf1" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> g </em> </strong> = 4 (LSTM 有 4 个 FFNNs)</li><li id="4864" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> h </em> </strong> = 2</li><li id="f345" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong> = 3</li></ul><p id="754b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params</em><br/>=<strong class="kx jh"><em class="ma">g</em>×【<em class="ma">h</em>(<em class="ma">h</em>+<em class="ma">I</em>)+<em class="ma">h</em></strong><br/>=<strong class="kx jh">4</strong><strong class="kx jh">×【2(2+3)+2】<br/></strong>=<strong class="kx jh"/></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a693" class="my mz jg mu b gy na nb l nc nd">input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">3</strong>))<br/> lstm = <strong class="mu jh">LSTM</strong>(<strong class="mu jh">2</strong>)(input)<br/>model = <strong class="mu jh">Model</strong>(input, lstm)</span></pre><p id="1225" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例 2.2:具有 5 个隐藏单元、输入大小为 8(其输出被连接)的堆叠式双向 GRU+具有 50 个隐藏单元的 LSTM</strong></p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/dffedc5eae436d1a6b987408dfc5f556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*j195JvybYSseQFvws7k-JA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 2.2: A stacked RNN consisting of BiGRU and LSTM layers. The graphics do not reflect the actual no. of units.</figcaption></figure><p id="3078" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具有 5 个隐藏单元和输入大小 8 的双向 GRU</p><ul class=""><li id="7b58" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> g </em> </strong> = 3 (GRU 有 3 个 FFNNs)</li><li id="79ab" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> h </em> </strong> = 5</li><li id="437c" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma">我</em> </strong> = 8</li></ul><p id="2d8b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params _ layer 1<br/>=</em><strong class="kx jh">2</strong><em class="ma"/><strong class="kx jh">×<em class="ma">g</em>×【<em class="ma">h</em>(<em class="ma">h</em>+<em class="ma">I</em>)+<em class="ma">h</em></strong>(第一项因双向为 2)<strong class="kx jh"><br/></strong>=)</p><p id="b137" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有 50 个隐藏单位的 LSTM</p><ul class=""><li id="12a4" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"><em class="ma">g</em></strong>= 4(LSTM 有 4 个 FFNNs)</li><li id="7c24" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> h </em> </strong> = 50</li><li id="6921" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong> = 5+5(双向 GRU 输出串接；GRU 的输出大小为 5，与隐藏单元的数量相同)</li></ul><p id="4232" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params _ layer 2<br/>=</em><strong class="kx jh"><em class="ma">g</em>×【<em class="ma">h</em>(<em class="ma">h</em>+<em class="ma">I</em>)+<em class="ma">h</em>]<br/></strong>=<strong class="kx jh">4×【50(50+10)+50】<br/></strong></p><p id="27b0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">total _ params</em>= 420+12200 = 12620</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a459" class="my mz jg mu b gy na nb l nc nd"> input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">8</strong>))<br/>layer1 = <strong class="mu jh">Bidirectional</strong>(<strong class="mu jh">GRU</strong>(<strong class="mu jh">5</strong>, return_sequences=<strong class="mu jh">True</strong>))(input)<br/>layer2 = <strong class="mu jh">LSTM</strong>(<strong class="mu jh">50</strong>)(layer1)<br/> model = <strong class="mu jh">Model</strong>(input, layer2)</span></pre><p id="20b7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ne nf ng mu b">merge_mode</code>默认为串联。</p><h2 id="5137" class="my mz jg bd nh ni nj dn nk nl nm dp nn le no np nq li nr ns nt lm nu nv nw nx bi translated">CNN</h2><p id="98d0" class="pw-post-body-paragraph kv kw jg kx b ky ny kh la lb nz kk ld le oi lg lh li oj lk ll lm ok lo lp lq ij bi translated">对于一层来说，</p><ul class=""><li id="d93a" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong>，输入地图(或频道)号</li><li id="82fd" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> f </em> </strong>，滤镜尺寸(只是长度)</li><li id="109b" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong>，输出地图(或通道)数量。这也由使用多少个过滤器来定义)</li></ul><p id="ac13" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个过滤器应用于每个输入映射。</p><p id="aa8a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma"> num_params <br/> =权重+偏差<br/>=</em><strong class="kx jh">[<em class="ma">I×</em>(<em class="ma">f×f</em>)<em class="ma">×o</em>】<em class="ma">+o</em></strong></p><p id="d31b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例 3.1:使用 2 个<em class="ma"> ×2 个</em>滤镜的灰度图像，输出 3 个通道</strong></p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/5244239fb923cb874938a69ed2321903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LYDEKf6LcpC2CNX05UG2w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 3.1: Convolution of a greyscale image with 2<em class="om">×2</em> filter to output 3 channels. Here, there are 15 parameters — 12 weights and 3 biases.</figcaption></figure><ul class=""><li id="5f97" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong> = 1(灰度只有 1 个通道)</li><li id="ca7f" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> f </em> </strong> = 2</li><li id="6f80" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong> = 3</li></ul><p id="d5d2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params<br/>=</em><strong class="kx jh">[<em class="ma">I×</em>(<em class="ma">f×f</em>)<em class="ma">×o</em>】<em class="ma">+o<br/></em></strong><em class="ma">=</em><strong class="kx jh">【1<em class="ma">×</em>(2<em class="ma">×</em>3】<em class="ma">+</em></strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3fd3" class="my mz jg mu b gy na nb l nc nd"> input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">None</strong>, <strong class="mu jh">1</strong>))<br/>conv2d = <strong class="mu jh">Conv2D</strong>(kernel_size=<strong class="mu jh">2</strong>, filters=<strong class="mu jh">3</strong>)(input)<br/> model = <strong class="mu jh">Model</strong>(input, conv2d)</span></pre><p id="474b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例 3.2:使用 2×2 滤镜的 RGB 图像，1 个通道的输出</strong></p><p id="4e6a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个输入要素地图有一个过滤器。得到的卷积是逐元素相加的，并且偏置项被加到每个元素上。这给出了具有 1 个特征图的输出。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/057a9afaf12a22aa386962909bb77518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jp3T7CYyRcRxBDMsATDvg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 3.2: Convolution of an RGB image with 2<em class="om">×2</em> filter to output 1 channel. Here, there are 13 parameters — 12 weights and 1 bias.</figcaption></figure><ul class=""><li id="9325" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong> = 3 (RGB 图像有 3 个通道)</li><li id="308c" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> f </em> </strong> = 2</li><li id="0384" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong> = 1</li></ul><p id="b6e9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params<br/>=</em><strong class="kx jh">[<em class="ma">I×</em>(<em class="ma">f×f</em>)<em class="ma">×o</em>]<em class="ma">+o<br/></em></strong><em class="ma">=</em><strong class="kx jh">【3</strong><strong class="kx jh">×(2×2)×1]+1<br/></strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5a73" class="my mz jg mu b gy na nb l nc nd"> input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">None</strong>, <strong class="mu jh">3</strong>))<br/>conv2d = <strong class="mu jh">Conv2D</strong>(kernel_size=<strong class="mu jh">2</strong>, filters=<strong class="mu jh">1</strong>)(input)<br/> model = <strong class="mu jh">Model</strong>(input, conv2d)</span></pre><p id="251d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例 3.3:2 通道图像，2×2 滤波器，3 通道输出</strong></p><p id="836e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个输入要素地图有 3 个过滤器(紫色、黄色、青色)。得到的卷积是逐元素相加的，并且偏置项被加到每个元素上。这给出了具有 3 个特征图的输出。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/52c2daf21b219e0d94b051d416b6e7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoykZQfNiVpy4q3f8D1BwQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig. 3.1: Convolution of a 2-channel image with 2<em class="om">×2</em> filter to output 3 channels. Here, there are 27 parameters — 24 weights and 3 biases.</figcaption></figure><ul class=""><li id="2ebf" class="mb mc jg kx b ky kz lb lc le md li me lm mf lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> i </em> </strong> = 2</li><li id="c682" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> f </em> </strong> = 2</li><li id="e59f" class="mb mc jg kx b ky mk lb ml le mm li mn lm mo lq od mh mi mj bi translated"><strong class="kx jh"> <em class="ma"> o </em> </strong> = 3</li></ul><p id="6688" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">num _ params<br/>=</em><strong class="kx jh">[<em class="ma">I×</em>(<em class="ma">f×f</em>)<em class="ma">×o</em>】<em class="ma">+o<br/></em></strong><em class="ma">=</em><strong class="kx jh">【2</strong><em class="ma"/><strong class="kx jh">×(2×3】)</strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="cbbd" class="my mz jg mu b gy na nb l nc nd"> input = <strong class="mu jh">Input</strong>((<strong class="mu jh">None</strong>, <strong class="mu jh">None</strong>, <strong class="mu jh">2</strong>))<br/>conv2d = <strong class="mu jh">Conv2D</strong>(kernel_size=<strong class="mu jh">2</strong>, filters=<strong class="mu jh">3</strong>)(input)<br/> model = <strong class="mu jh">Model</strong>(input, conv2d)</span></pre><p id="f264" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">暂时就这样吧！如果您有任何反馈，请在下面留下您的评论！</p><h2 id="20b9" class="my mz jg bd nh ni nj dn nk nl nm dp nn le no np nq li nr ns nt lm nu nv nw nx bi translated">深度学习相关文章</h2><p id="f3d2" class="pw-post-body-paragraph kv kw jg kx b ky ny kh la lb nz kk ld le oi lg lh li oj lk ll lm ok lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/animated-rnn-lstm-and-gru-ef124d06cf45">动画版 RNN、LSTM 和 GRU </a></p><p id="7124" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/step-by-step-tutorial-on-linear-regression-with-stochastic-gradient-descent-1d35b088a843">带随机梯度下降的线性回归分步指南</a></p><p id="7232" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/10-gradient-descent-optimisation-algorithms-86989510b5e9"> 10 种梯度下降优化算法+备忘单</a></p><p id="698e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/attn-illustrated-attention-5ec4ad276ee3">经办人:图文并茂的关注</a></p><p id="7dad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/illustrated-self-attention-2d627e33b20a">图文并茂:自我关注</a></p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="826c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">关注我上</em><a class="ae jd" href="https://www.twitter.com/remykarem" rel="noopener ugc nofollow" target="_blank"><em class="ma">Twitter</em></a><em class="ma">@ remykarem 或者</em><a class="ae jd" href="http://www.linkedin.com/in/raimibkarim" rel="noopener ugc nofollow" target="_blank"><em class="ma">LinkedIn</em></a><em class="ma">。你也可以通过 raimi.bkarim@gmail.com 联系我。欢迎访问我的网站</em><a class="ae jd" href="https://remykarem.github.io/" rel="noopener ugc nofollow" target="_blank"><em class="ma">remykarem . github . io</em></a><em class="ma">。</em></p></div></div>    
</body>
</html>