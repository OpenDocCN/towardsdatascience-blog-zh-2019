<html>
<head>
<title>Classification of Signature and Text images using CNN and Deploying the model on Google Cloud ML Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 CNN 对签名和文本图像进行分类，并在 Google Cloud ML 引擎上部署该模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/classification-of-signature-and-text-images-using-cnn-and-deploying-the-model-on-google-cloud-ml-30bf6f4e3207?source=collection_archive---------12-----------------------#2019-01-15">https://towardsdatascience.com/classification-of-signature-and-text-images-using-cnn-and-deploying-the-model-on-google-cloud-ml-30bf6f4e3207?source=collection_archive---------12-----------------------#2019-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="91e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知，对于任何具有法律重要性的文件，无论是合同、货物还是简单的表格，签名都是重要的组成部分。签名提供了识别和确认。目前，从印刷文本数据中识别签名的模型还不可用。所以这里介绍的工作是关于签名和文本数据的分类。</p><p id="27b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<em class="kl"> TensorFlow </em>的高级 API<em class="kl">Keras</em>构建分类模型，TensorFlow 是用于机器学习的开源库<em class="kl"> </em>。该分类模型还可以帮助建立文档图像的签名检测模型。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="ab44" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数据准备</h1><p id="ac47" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">数据集是通过从文档中提取文本并从不同的文档中捕获签名样本而生成的。数据由两类组成:签名(类标签 0)和文本(类标签 1)。</p><p id="d307" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文本图像的数据包含具有不同背景、高度、宽度和笔划粗细的独立单词的图像。文本的图像不限于一种独特的语言，还涉及多语言文本。该数据包含大约 2000 张不同的图像。</p><p id="5bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">签名图像数据包含大约 1300 个不同背景、高度、宽度和笔画粗细的签名图像。</p><p id="a276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据已经存储在谷歌云存储上。数据清理的初步步骤包括丢弃模糊的图像，并用适当的填充和边距重新排列文本。为了增加数据的大小，执行了一些运行时数据扩充，如旋转、重新缩放和缩放操作。数据集分为 70%用于训练，30%用于验证。除此之外，还有一个单独的看不见的数据集，在其上测试模型的准确性。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="ab gu cl mb"><img src="../Images/70a803e6e2bf6f9b607724fa3ea83552.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-PBC1VUkHMQHJLuGEyc-yQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">The sample of images in dataset</figcaption></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="dbd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">博客组织如下:</p><p id="bc5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一部分:独立的分类模型，可以在单独的系统上运行。</p><p id="f1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二部分</strong>:通过在 GCP ML-Engine 上部署模型，使模型公开。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="e572" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一.分类模式</h1><p id="49d3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">深度卷积神经网络采用序列模型构建。有三个卷积图层以及一个完全连接的图层，后跟一个输出图层。CNN 参数，如最大池大小被设置为(2，2)，内核大小被设置为(3，3)。最初，过滤器的数量设置为 32。在随后的卷积层中，过滤器的数量加倍。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ff7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用的激活函数是 ReLU，最后一层激活函数是 Sigmoid。添加一个丢弃概率为 0.5 的丢弃层。该模型的架构如下:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模型概要给出了每一层的详细情况以及每一层中的参数总数。模型总结如下:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c2f0c48e548c64ec83f0f4ba329148c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*IDV-W_AxRKFTW0JINHhQEw.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Summary of the model</figcaption></figure><p id="e2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，以准确性作为评价指标，以损失作为二元交叉熵，以优化器作为 adam 优化器，对模型进行编译。</p><p id="54f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于训练数据大小有限，在<em class="kl"> ImageDataGenerator() </em>函数的帮助下增加了运行时图像扩充。在训练数据集中添加了图像增强，如旋转、缩放和缩放。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f80b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了预测模型对测试数据集的输出，使用了 predict 方法。然后使用 sklearn.metrics 从预测中计算精度、召回率和测试准确度。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ae57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加图像增强和剔除图层后的最终测试准确率为 94.29%。签名图像的准确率为 96.55%，召回率为 97.22%。下表给出了通过添加增强层和下降层的结果升级。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="ab gu cl mb"><img src="../Images/a073af0c2a759620d13691df50b28f3c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gZRCR3QybNd0OZ7SwqwRoA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Results of various experiments</figcaption></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="666c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">二。在 Google Cloud ML 引擎上训练和部署模型</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="ab gu cl mb"><img src="../Images/36e39778023c7f37bd0dc7b85fc33fe1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FqwmIWa7DtnTjMb9TLqpjQ.png"/></div></figure><p id="28f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cloud ML Engine 有助于大规模训练您的机器学习模型，在云端托管训练好的模型，并使用模型对新数据进行预测。</p><h2 id="befe" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">数据</h2><p id="cfd2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">通过拍摄不同语言和不同背景的签名图像和文本图像来准备数据。如前所述，对数据进行同样的预处理。有两个类，签名和文本。</p><h2 id="0bcf" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">包装模型</h2><p id="492e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">准备在 ML 引擎上部署的模型的包架构如下所示。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="ab gu cl mb"><img src="../Images/3fc55f5be37b02f6f6d8a008c3a50225.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jurJN0OiR8Ia9jWk1iJbuQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Project structure for ML Engine</figcaption></figure><h2 id="3680" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">a) setup.py</h2><p id="66c4" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">setup.py 文件包含模型在 cloud ML 引擎上运行所需安装的依赖项和版本。云 ML 引擎内置 tensorflow 支持。需要安装所有其他要求。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h2 id="4f83" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">b)任务. py</h2><p id="1c4a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">task.py 文件是模型的入口点。它包含运行模型时需要解析的参数列表。它还调用模型和其他相关文件(如果有的话)。训练好的模型以. hdf5 格式保存。task.py 文件的代码如下所示:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>保存的模型为. hdf5 格式。为了部署模型，我们需要。模型的 pb 格式。为此，我们需要导出带有 TensorFlow 服务的模型。</p><h2 id="73b2" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">c)模型. py</h2><p id="2bab" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">model.py 包含要训练的实际模型。它将编译后的模型返回给调用函数。模型函数的代码如下所示。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h2 id="2836" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">utils.py</h2><p id="6223" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这个文件包含数据预处理的代码。传递包含图像文件的目录的位置，并生成可以提供给模型的带标签的数据。数据保存在中。npy 文件，然后用于模型训练。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="58f2" class="kt ku iq bd kv kw mx ky kz la my lc ld le mz lg lh li na lk ll lm nb lo lp lq bi translated">训练模型</h1><p id="fc57" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><strong class="jp ir"> a)本地培训</strong></p><p id="ebc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本地机器上训练模型有两种方法:使用 python 命令和使用 gcloud 命令。</p><pre class="lw lx ly lz gt nc nd ne nf aw ng bi"><span id="9ef2" class="ml ku iq nd b gy nh ni l nj nk">$ export JOB_DIR=/path/to/job/dir<br/>$ export TRAIN_DIR=/path/to/training/data/dir   #either local or GCS</span><span id="dc82" class="ml ku iq nd b gy nl ni l nj nk">#Train using python</span><span id="f596" class="ml ku iq nd b gy nl ni l nj nk">python -m trainer.task \<br/> --train-dir=$TRAIN_DIR \<br/> --job-dir=$JOB_DIR</span><span id="b850" class="ml ku iq nd b gy nl ni l nj nk">#Train using gcloud command line tool</span><span id="d610" class="ml ku iq nd b gy nl ni l nj nk">$ gcloud ml-engine local train --module-name=trainer.task \<br/>   --package-path=trainer/ \<br/>   --train-dir=$TRAIN_DIR \<br/>   --job-dir=$JOB_DIR</span></pre><p id="d93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> b)向谷歌云提交作业</strong></p><p id="8252" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本地成功训练模型后，下一步是将作业提交给云 ml-engine。从您的教练包所在的目录运行下面给出的命令。</p><pre class="lw lx ly lz gt nc nd ne nf aw ng bi"><span id="14f2" class="ml ku iq nd b gy nh ni l nj nk">$ export BUCKET_NAME="your GCS bucket name"<br/>$ export JOB_NAME="name of your job"<br/>$ export OUTPUT_PATH=gs://$BUCKET_NAME/$JOB_NAME<br/>$ export TRAIN_DATA=/path/to/dataset</span><span id="fcb3" class="ml ku iq nd b gy nl ni l nj nk">#gcloud command line</span><span id="8073" class="ml ku iq nd b gy nl ni l nj nk">$ gcloud ml-engine jobs submit training $JOB_NAME \<br/>    --job-dir $OUTPUT_PATH \<br/>    --runtime-version 1.10 \<br/>    --module-name trainer.task \<br/>    --package-path trainer/ \<br/>    --region $REGION \<br/>    -- \<br/>    --train-dir $TRAIN_DATA \<br/>    --verbosity DEBUG</span></pre><p id="5e29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以从 Google cloud ML engine 的仪表盘上查看日志。在作业成功提交之后，您可以在 GCS bucket 的 OUTPUT_PATH 中找到一个文件夹导出。</p><h1 id="a449" class="kt ku iq bd kv kw mx ky kz la my lc ld le mz lg lh li na lk ll lm nb lo lp lq bi translated">部署模型</h1><p id="21aa" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">培训之后，是时候为生产部署模型了。第一步是将保存的模型从. hdf5 格式转换为。pb(张量流模型格式)。分步指南以及必要的代码和 shell 命令可以在<a class="ae nm" href="https://github.com/Krishna-Parekh/signClassify/blob/master/signature_model_deploy.ipynb" rel="noopener ugc nofollow" target="_blank">本</a>笔记本中找到。</p><h2 id="fbe6" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">步骤 1 →创建模型</h2><p id="5c97" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">创建模型的 gcloud 命令如下。</p><pre class="lw lx ly lz gt nc nd ne nf aw ng bi"><span id="0e0f" class="ml ku iq nd b gy nh ni l nj nk">$ export MODEL_NAME=&lt;Name of the model&gt;<br/>$ export MODEL_PATH=/gcs/path/to/the/model</span><span id="be80" class="ml ku iq nd b gy nl ni l nj nk">#CREATE MODEL<br/>$ gcloud ml-engine models create $MODEL_NAME</span></pre><h2 id="efd0" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">步骤 2 →为您刚刚创建的模型创建版本</h2><p id="42be" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">运行下面的命令来创建模型的版本 version_1。</p><pre class="lw lx ly lz gt nc nd ne nf aw ng bi"><span id="2c1e" class="ml ku iq nd b gy nh ni l nj nk">$ gcloud ml-engine versions create "version_1" --model $MODEL_NAME \ --origin $MODEL_PATH \<br/>--python-version 3.5 --runtime-version 1.10</span></pre><h2 id="54b5" class="ml ku iq bd kv mm mn dn kz mo mp dp ld jy mq mr lh kc ms mt ll kg mu mv lp mw bi translated">步骤 3 →为预测模型服务</h2><p id="c000" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">对模型的预测请求可以作为 test.json 发送。为此，您需要将图像转换成. json 格式的请求，如下所示。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在线预测可以在 gcloud 命令的帮助下完成。</p><pre class="lw lx ly lz gt nc nd ne nf aw ng bi"><span id="a0b0" class="ml ku iq nd b gy nh ni l nj nk">$ gcloud ml-engine predict — model $MODEL_NAME — version version_3 — json-instances test_data.json</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="e0c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到代码文件<a class="ae nm" href="https://github.com/Krishna-Parekh/signClassify" rel="noopener ugc nofollow" target="_blank"/>。希望这篇文章对你有所帮助，并为你提供了一些有意义的见解！非常欢迎您的宝贵反馈。快乐学习！！！</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="aa65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于 2019 年 1 月 9 日</em><a class="ae nm" href="https://medium.com/searce/classification-of-signature-and-text-images-using-cnn-and-deploying-the-model-on-google-cloud-ml-73ec6c7f7e8" rel="noopener"><em class="kl">medium.com</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>