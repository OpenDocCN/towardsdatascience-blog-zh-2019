<html>
<head>
<title>Image Classification with Tensorflow 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Tensorflow 2.0 的影像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-classification-with-tensorflow-2-0-7696e4aa5ca7?source=collection_archive---------8-----------------------#2019-05-17">https://towardsdatascience.com/image-classification-with-tensorflow-2-0-7696e4aa5ca7?source=collection_archive---------8-----------------------#2019-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对自定义图像进行分类的端到端流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0b8217a0f0b775739fb80fbd9c6d55ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*xh1NwzmRrzb86EMeV0tQbQ.png"/></div></figure><p id="c3b3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章中，我们将解决一个最常见的人工智能问题。场景是这样的:你正在酒吧上网，喝着啤酒，吃着鸡翅，这时你开始想“我能使用 Tensorflow 2.0 和迁移学习编写一个图像分类器吗？”本文将展示实现这一点的端到端过程。注意，我不会深入研究这个模型是如何工作的，那将是另外一篇文章。本文将向您展示如何使用 Tensorflow 2.0。一旦我们有了它，我们就可以回过头来使用参数，这可能会使代码更有效。</p><p id="2a4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">唯一的先决条件是:</p><ol class=""><li id="b375" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">一台电脑(显然)。我在一台没有 GPU 的小型笔记本电脑上运行我的程序。</li><li id="e8d9" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">带摄像头的手机。我们将会生成我们自己的图像。</li><li id="afaf" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">(可选)云图像存储。我用了亚马逊照片。</li><li id="fdea" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">Docker，我们将用它来托管我们的 Tensorflow 2.0 环境。如果你没有，安装说明可以在<a class="ae ma" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">这里</a>找到</li></ol><p id="4319" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将遵循的步骤是:</p><ol class=""><li id="ed73" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">安装 Tensorflow 2.0 Docker 镜像。</li><li id="00b0" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">获取一组图像来训练/验证/测试我们的模型。</li><li id="a495" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">将我们的图像组织成适合我们模型的目录结构。</li><li id="e766" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">下载一个预先训练好的深度学习模型。</li><li id="ce45" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">为我们的特定用例(啤酒或鸡翅)定制我们的模型。</li><li id="9070" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">训练我们的定制模型。</li><li id="b601" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">可视化模型预测。</li></ol><h1 id="3f9f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">安装 Tensorflow 2.0 Docker 映像</h1><p id="372c" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">我按照 T2 页面上的指示做了。以下是我使用的具体命令。注意，对于本教程，图像必须包含 Jupyter。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="ff9c" class="nd mc it mz b gy ne nf l ng nh">docker pull tensorflow/tensorflow:<!-- -->2.0.0a0-py3-jupyter</span></pre><p id="a196" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，cd 到您将存储源代码的目录。从那里，我们将启动我们的映像。我创建了一个简单的 shell 脚本(注意，我是在 Linux 上运行的，如果你在 Mac 或 Windows 上，你可能不需要 sudo 命令:</p><p id="44e9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">sudo docker run-it-p 8888:8888-v $ PWD:/TF/data-w/TF/data tensor flow/tensor flow:2 . 0 . 0 A0-py3-jupyter</p><p id="2575" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里需要知道的最重要的事情是:</p><ul class=""><li id="f116" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll ni ls lt lu bi translated">-p 是端口映射，我们的 Jupyter 笔记本在 Docker 中的端口 8888 上运行，因此我们将在我们的机器上映射端口 8888 以进行匹配。只有当端口 8888 已经在您的机器上使用时，您才应该更改它。</li><li id="3d61" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll ni ls lt lu bi translated">-v 是如何在 docker 中挂载一个卷。在本例中，我们将当前目录($ term)挂载为/tp/data。这个 Docker 映像中的 jupyter 笔记本运行在/tp 目录中，因此当您打开 Jupyter 时，应该会看到以下内容:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/3c37c8e027b8ddcc7db34e34f0b9c700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4z_g2c0fct-L5n-NRmmGg.png"/></div></div></figure><p id="6d10" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其中数据目录映射到机器上的当前目录。</p><p id="3639" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">运行上述命令后，您将在命令提示符下看到类似这样的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/4f775a99d4adaf3c433814f5ac5a8928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rz4HQOn-Vua1ISzbuwo-kQ.png"/></div></div></figure><p id="c7d1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里重要的一行是“Jupyter 笔记本运行于”之后的一行。您需要复制以“:8888”开头的那一行。然后在你的浏览器中输入<a class="ae ma" href="http://localhost" rel="noopener ugc nofollow" target="_blank"> http://localhost </a>并粘贴你复制的行。在这种情况下:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="9896" class="nd mc it mz b gy ne nf l ng nh">http://localhost:8888/?token=cd37ab44fab55bce5e44ac6f4bb187a4b34b713c5fbeac9e</span></pre><p id="c833" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">至此，Tensorflow 2.0 已经在 Docker 容器中启动并运行，可以访问您的本地文件系统。</p><h1 id="e587" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">获取一组图像来训练/验证/测试我们的模型</h1><p id="c1e6" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">这一步很容易。我用手机从不同角度拍了大约 30 张啤酒杯的照片，从不同角度拍了 30 张鸡翅的照片。我是亚马逊 Prime 的大用户，所以我把手机设置成把我的照片备份到亚马逊照片。你可以使用任何你喜欢的云环境(ICloud，Google photos 等)，甚至可以用电子邮件给自己发照片。这里的重点是把照片复制到你的电脑上。</p><h1 id="b571" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">将我们的图像组织成适合我们模型的目录结构</h1><p id="d977" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">第一步是给我们的图像贴标签。有几种方法可以做到这一点，但最终，你会想把所有的“啤酒”图片复制到一个名为“啤酒”的目录中，把你的“翅膀”图片复制到一个名为“翅膀”的目录中。从这里开始，您需要创建一个如下所示的目录结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/fb5e5465e8382dddf8c0982bfc1ae823.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*XVF7Sw68A3nbBdB43YylYQ.png"/></div></figure><p id="0380" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是我在 Linux 中使用的命令:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="3fd2" class="nd mc it mz b gy ne nf l ng nh">mkdir train<br/>mkdir test<br/>mkdir val<br/>mkdir train/beer<br/>mkdir train/wings<br/>mkdir test/beer<br/>mkdir test/wings<br/>mkdir val/beer<br/>mkdir val/wings</span></pre><p id="25dd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此时，您需要将数据的子集移动到 val 和 test 目录中。经过一些谷歌搜索，我找到了这个命令:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c04f" class="nd mc it mz b gy ne nf l ng nh">shuf -n 6 -e * | xargs -i mv {} target-directory</span></pre><p id="add6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我使用以下命令实现了这一点:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="0b8e" class="nd mc it mz b gy ne nf l ng nh">cd beer<br/>shuf -n 6 -e * | xargs -i mv {} ../test/beer<br/>shuf -n 6 -e * | xargs -i mv {} ../val/beer<br/>mv * ../train/beer<br/>cd ..<br/>cd wings<br/>shuf -n 6 -e * | xargs -i mv {} ../test/wings<br/>shuf -n 6 -e * | xargs -i mv {} ../val/wings<br/>mv * ../train/wings</span></pre><p id="f8b2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这段代码将 6 幅图像分别移动到我们的 val 和 test 文件夹，其余的移动到我们的 train 文件夹。完成这些步骤后，您的目录结构应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fc0c8bbf5160f7075ae1bba1f16e54bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*huO7SVsLbAxbHjrDVztqXA.png"/></div></figure><h1 id="deac" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">下载预先训练好的深度学习模型</h1><p id="7297" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">此时，在浏览器中返回到 Jupyter 笔记本，并创建一个新笔记本。首先，我们需要导入将要使用的 Python 库:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="24d7" class="nd mc it mz b gy ne nf l ng nh">import numpy as np<br/>import tensorflow.keras<br/>from tensorflow.keras.models import Sequential, Model<br/>from tensorflow.keras.layers import  Dropout, Input<br/>from tensorflow.keras.layers import Dense, Flatten<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.metrics import categorical_crossentropy<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>import itertools<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><p id="f12e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">重要的故障排除步骤:</strong>您可能会得到缺少库的错误。根据 Docker 映像的版本，您可能需要运行以下步骤:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="5c53" class="nd mc it mz b gy ne nf l ng nh">!pip install --upgrade pip<br/>!pip install pillow<br/>!pip install scipy<br/>!pip install pandas</span></pre><p id="7ee8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">运行之后，您需要点击重启内核按钮并重新运行导入语句。</p><p id="f1ed" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们已经完成了 Python 导入，我们需要为每个图像文件夹生成 ImageGenerator 对象。图像生成器获取输入图像，并对其稍加修改，以提供一致性和形状来训练神经网络。请注意，我们的图片将是 224x224。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="3fed" class="nd mc it mz b gy ne nf l ng nh">train_path = '/tf/data/beer_wings/train'<br/>valid_path = '/tf/data/beer_wings/val'<br/>test_path = '/tf/data/beer_wings/test'<br/>train_batches = ImageDataGenerator().flow_from_directory(train_path, target_size=(224,224), classes=['beer', 'wings'], batch_size=32)<br/>valid_batches = ImageDataGenerator().flow_from_directory(valid_path, target_size=(224,224), classes=['beer', 'wings'], batch_size=32)<br/>test_batches = ImageDataGenerator().flow_from_directory(test_path, target_size=(224,224), classes=['beer', 'wings'], batch_size=32)</span></pre><p id="e451" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是一个有用的函数，可以看看我们的图像生成器在做什么。我从一个非常有用的<a class="ae ma" href="https://www.youtube.com/watch?v=LhEMXbjGV_4" rel="noopener ugc nofollow" target="_blank"> Youtube 系列</a>中找到了这个函数:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="8949" class="nd mc it mz b gy ne nf l ng nh"># plots images with labels within jupyter notebook<br/>def plots(ims, figsize=(24,12), rows=4, interp=False, titles=None):<br/>    if type(ims[0]) is np.ndarray:<br/>        ims = np.array(ims).astype(np.uint8)<br/>        if (ims.shape[-1] != 3):<br/>            ims = ims.transpose((0,2,3,1))<br/>    f = plt.figure(figsize=figsize)<br/>    cols = len(ims)//rows if len(ims) % 2 == 0 else len(ims)//rows + 1<br/>    for i in range(len(ims)):<br/>        sp = f.add_subplot(rows, cols, i+1)<br/>        sp.axis('Off')<br/>        if titles is not None:<br/>            sp.set_title(titles[i], fontsize=32)<br/>        plt.imshow(ims[i], interpolation=None if interp else 'none')<br/>imgs, labels = next(train_batches)<br/>plots(imgs, titles=labels)</span></pre><p id="4c41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nr"><img src="../Images/2a7b782965d08728de21e37f86d8a7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jq90MwhZkd66E15WYSL8bA.png"/></div></div></figure><p id="d588" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注[0，1] =鸡翅，[1，0] =啤酒。</p><p id="eeca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我们准备下载我们的预训练模型。在这种情况下，我们将使用 VGG16 型号。Tensorflow 2.0 内置了众多模型。它们在这里被定义为<a class="ae ma" href="https://github.com/keras-team/keras-applications" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="ccbb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是导入预训练 VGG16 模型的代码:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="313f" class="nd mc it mz b gy ne nf l ng nh">vgg16_model = tensorflow.keras.applications.vgg16.VGG16(weights='imagenet', include_top=False, input_tensor=Input(shape=(224,224,3)))</span></pre><p id="c34a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就这么简单！嗯，差不多吧，重要的是我们设置 include_top = False，因为我们要创建自己的最终层，还要注意我们的输入形状是(224，224，3)。(224，224)与上面的图像生成器相匹配。多出来的 3 个是颜色通道(红、蓝、绿)。</p><h1 id="c13c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为我们的特定用例(啤酒或鸡翅)定制我们的模型</h1><p id="4470" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">现在我们已经下载了一个预训练的模型，它通常可以预测图像分类，让我们根据自己的需要定制它。从理论上讲，像这样的前几层模型简化了图像的部分，并识别出其中的形状。那些早期的标签非常普通(线条、圆环、正方形等等)，所以我们不想重新训练它们。我们希望只训练网络的最后几层以及我们添加的新层。</p><p id="9f32" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们禁用预训练模型中除最后 4 层以外的所有层的训练。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="06e2" class="nd mc it mz b gy ne nf l ng nh">for layer in vgg16_model.layers[:-4]:<br/>    layer.trainable = False</span></pre><p id="6bea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我们将自己的最后几层添加到网络中:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="4187" class="nd mc it mz b gy ne nf l ng nh"># Create the model<br/>model = Sequential()<br/> <br/># Add the vgg convolutional base model<br/>model.add(vgg16_model)<br/> <br/># Add new layers<br/>model.add(Flatten())<br/>model.add(Dense(1024, activation='relu'))<br/>model.add(Dropout(0.5))<br/>model.add(Dense(2, activation='softmax'))<br/> <br/># Show a summary of the model. Check the number of trainable parameters<br/>model.summary()</span></pre><p id="fb0d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就是我们基于 VGG16 定制的模型！</p><h1 id="1706" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">训练我们的定制模型</h1><p id="4bde" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">现在我们已经定义了模型，让我们编译它并训练它。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="5970" class="nd mc it mz b gy ne nf l ng nh">model.compile(loss='categorical_crossentropy',<br/>              optimizer=tensorflow.keras.optimizers.RMSprop(lr=1e-4),<br/>              metrics=['acc'])<br/>history = model.fit_generator(<br/>      train_batches,<br/>      steps_per_epoch=train_batches.samples/train_batches.batch_size ,<br/>      epochs=5,<br/>      validation_data=valid_batches,<br/>      validation_steps=valid_batches.samples/valid_batches.batch_size,<br/>      verbose=1)</span></pre><h1 id="c98c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">可视化模型预测</h1><p id="e8b6" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">现在，让我们给训练好的模型输入一组它从未见过的图像。代码中最重要的部分是这两行:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="1cd8" class="nd mc it mz b gy ne nf l ng nh">test_imgs, test_labels = next(test_batches)</span><span id="41f7" class="nd mc it mz b gy ns nf l ng nh">predictions = model.predict(test_imgs)</span></pre><p id="4699" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一个生成一批新的以前没有见过的图像。让我们看看我们的模型对这些图像的预测:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="69e3" class="nd mc it mz b gy ne nf l ng nh">import pandas as pd</span><span id="f17d" class="nd mc it mz b gy ns nf l ng nh">def to_label(value):<br/>    if value==0:<br/>        return 'beer'<br/>    else:<br/>        return 'wings'</span><span id="4777" class="nd mc it mz b gy ns nf l ng nh">test_imgs, test_labels = next(test_batches)<br/>predictions = model.predict(test_imgs)<br/><br/>df = pd.DataFrame()<br/>df['actual'] = test_labels[:,1]<br/>df['predicted'] = np.round(predictions[:,1])</span><span id="cc70" class="nd mc it mz b gy ns nf l ng nh">df['predicted_labels']=df['predicted'].map(lambda x: to_label(x))<br/>plots(test_imgs, titles=df['predicted_labels'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nt"><img src="../Images/196422198d1a01f860a408cd014aca38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h40f-HxtFUSeJEAxz2KeaQ.png"/></div></div></figure><h1 id="b6f6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="1607" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">显然，这是一个实现图像分类的无意义的例子，但它确实提供了一些有价值的信息，可以应用于未来的项目。即数据获取、迁移学习和模型评估。请注意，代码可以很容易地修改，以允许多种分类(我们的例子只有 2 个)。</p></div></div>    
</body>
</html>