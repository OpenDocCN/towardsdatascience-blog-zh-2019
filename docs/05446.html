<html>
<head>
<title>4 Tips for Advanced Feature Engineering and Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级特征工程和预处理的 4 个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-tips-for-advanced-feature-engineering-and-preprocessing-ec11575c09ea?source=collection_archive---------11-----------------------#2019-08-12">https://towardsdatascience.com/4-tips-for-advanced-feature-engineering-and-preprocessing-ec11575c09ea?source=collection_archive---------11-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="025b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">特征工程</h2><div class=""/><div class=""><h2 id="6914" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">创建新要素、检测异常值、处理不平衡数据和估算缺失值的技术。</h2></div></div><div class="ab cl kr ks hx kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="im in io ip iq"><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/2971da1c322313e524aee0b64f76f083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*637kim0dxEy5AouQ2chsNQ.jpeg"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk"><a class="ae lo" href="https://www.analyticsvidhya.com/blog/2018/11/data-engineer-comprehensive-list-resources-get-started/data-engineer/" rel="noopener ugc nofollow" target="_blank">https://www.analyticsvidhya.com/blog/2018/11/data-engineer-comprehensive-list-resources-get-started/</a></figcaption></figure><p id="4f02" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi ml translated">显然，开发机器学习模型的两个最重要的步骤是<strong class="lr jd">特征工程</strong>和<strong class="lr jd">预处理</strong>。特征工程包括创建特征，而预处理包括清理数据。</p><blockquote class="mu mv mw"><p id="ebde" class="lp lq mx lr b ls lt kd lu lv lw kg lx my lz ma mb mz md me mf na mh mi mj mk im bi translated">折磨数据，它会承认任何事情<em class="it">。—罗纳德·科斯</em></p></blockquote><p id="94fc" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们经常花费大量时间将数据提炼为对建模有用的东西。为了使这项工作更有效，我想分享 4 个技巧和诀窍，可以帮助你工程和预处理这些功能。</p><p id="eccf" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我应该注意到，尽管这可能是老生常谈，<strong class="lr jd">领域知识</strong>可能是工程特性中最重要的东西之一。通过更好地理解您所使用的功能，它可能有助于您防止欠拟合和过拟合。</p><p id="c620" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">你可以在这里找到带分析的笔记本<a class="ae lo" href="https://github.com/MaartenGr/feature-engineering" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="50bb" class="nb nc it bd nd ne nf ng nh ni nj nk nl ki nm kj nn kl no km np ko nq kp nr ns bi translated">1.重采样不平衡数据</h1><p id="1e1a" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">在实践中，您经常会遇到不平衡的数据。如果你的目标只是有轻微的不平衡，这不一定是个问题。然后，您可以通过使用适当的数据验证措施来解决这个问题，例如<em class="mx">平衡精度</em>、<em class="mx">精确召回曲线</em>或<em class="mx"> F1 得分</em>。</p><p id="9a23" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">不幸的是，情况并非总是如此，您的目标变量可能会非常不平衡(例如，10:1)。相反，您可以使用称为<strong class="lr jd">击打</strong>的技术对少数目标进行过采样，以引入平衡。</p><h2 id="1f83" class="ny nc it bd nd nz oa dn nh ob oc dp nl ly od oe nn mc of og np mg oh oi nr iz bi translated">重击</h2><p id="cca7" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated"><a class="ae lo" href="https://jair.org/index.php/jair/article/view/10302" rel="noopener ugc nofollow" target="_blank"> SMOTE </a> <strong class="lr jd"> </strong>代表<em class="mx">合成少数过采样技术</em>，是一种用于增加少数类样本的过采样技术。</p><p id="38f0" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">它通过查看目标的<em class="mx">特征空间</em>并检测最近的邻居来生成新的样本。然后，它简单地选择相似的样本，并在相邻样本的<em class="mx">特征空间</em>内随机地一次改变一列。</p><p id="eddd" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">实现 SMOTE 的模块可以在<a class="ae lo" href="https://imbalanced-learn.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">不平衡学习</a>包中找到。您可以简单地导入包并应用 fit_transform:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ol"><img src="../Images/d5ed4d06cb5844b4b6536d028aebc363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ju5Wc4YGzdZd22q4KUlUQQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Original data (LEFT) versus oversampled data (RIGHT).</figcaption></figure><p id="1a8a" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如您所见，该模型成功地对目标变量进行了过采样。使用 SMOTE 进行过采样时，您可以采取几种策略:</p><ul class=""><li id="6132" class="om on it lr b ls lt lv lw ly oo mc op mg oq mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">'minority'</strong></code>:只对少数类重新采样；</li><li id="9f82" class="om on it lr b ls oz lv pa ly pb mc pc mg pd mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">'not minority'</strong></code>:对除少数类以外的所有类进行重新采样；</li><li id="b915" class="om on it lr b ls oz lv pa ly pb mc pc mg pd mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">'not majority'</strong></code>:对除多数类以外的所有类进行重新采样；</li><li id="6527" class="om on it lr b ls oz lv pa ly pb mc pc mg pd mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">'all'</strong></code>:对所有类进行重采样；</li><li id="8fee" class="om on it lr b ls oz lv pa ly pb mc pc mg pd mk or os ot ou bi translated">当<code class="fe ov ow ox oy b"><strong class="lr jd">dict</strong></code>时，按键对应目标类别。这些值对应于每个目标类所需的样本数。</li></ul><p id="d313" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我选择使用字典来指定我想要对数据进行过采样的程度。</p><p id="9f74" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">附加提示 1 </strong>:如果您的数据集中有分类变量，SMOTE 可能会为那些不可能发生的变量创建值。例如，如果有一个名为 isMale 的变量，它只能取 0 或 1，那么 SMOTE 可能会创建 0.365 作为值。</p><p id="1b02" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">相反，您可以使用考虑到分类变量性质的 SMOTENC。该版本也可在<a class="ae lo" href="https://imbalanced-learn.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">不平衡学习</a>包中获得。</p><p id="ff7f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">附加提示 2: </strong>确保在创建训练/测试分割后进行过采样，以便只对训练数据进行过采样。您通常不希望在合成数据上测试您的模型。</p><h1 id="85db" class="nb nc it bd nd ne nf ng nh ni nj nk nl ki nm kj nn kl no km np ko nq kp nr ns bi translated">2.创建新功能</h1><p id="b0cd" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">为了提高模型的质量和预测能力，通常会从现有变量中创建新的特征。我们可以在每对变量之间创建一些交互(例如，乘或除)，希望找到一个有趣的新特征。然而，这是一个漫长的过程，需要大量的编码。幸运的是，这可以通过使用<strong class="lr jd">深度特征合成</strong>来实现自动化。</p><h2 id="6d62" class="ny nc it bd nd nz oa dn nh ob oc dp nl ly od oe nn mc of og np mg oh oi nr iz bi translated">深度特征合成</h2><p id="cef0" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">深度特征合成(DFS)是一种算法，使您能够快速创建具有不同深度的新变量。例如，您可以将多对列相乘，但也可以选择先将 A 列与 B 列相乘，然后再将 c 列相加。</p><p id="0203" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">首先，让我介绍一下我将在这个例子中使用的数据。我选择使用<a class="ae lo" href="https://www.kaggle.com/lnvardanyan/hr-analytics" rel="noopener ugc nofollow" target="_blank">人力资源分析数据</a>，因为这些功能很容易理解:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi pe"><img src="../Images/78d2aa985105c880a0f3089c50be566f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLsjksR5yZ0TlMMbMshkkw.png"/></div></div></figure><p id="dca1" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">简单地基于我们的直觉，我们可以将<code class="fe ov ow ox oy b"><strong class="lr jd">average_monthly_hours</strong></code>除以<code class="fe ov ow ox oy b"><strong class="lr jd">number_project</strong></code>识别为一个有趣的新变量。然而，如果我们只遵循直觉，可能会错过更多的关系。</p><p id="97d5" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><a class="ae lo" href="https://github.com/Featuretools/featuretools" rel="noopener ugc nofollow" target="_blank">包</a>确实需要理解它们对实体的使用。但是，如果您使用单个表，您可以简单地遵循下面的代码:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0fd4" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">第一步是创建一个<code class="fe ov ow ox oy b"><strong class="lr jd">entity</strong></code>，如果需要的话，可以从它创建与其他表的关系。接下来，我们可以简单地运行<code class="fe ov ow ox oy b"><strong class="lr jd">ft.dfs</strong></code>来创建新的变量。我们用参数<code class="fe ov ow ox oy b"><strong class="lr jd">trans_primitives</strong></code>指定如何创建变量。<strong class="lr jd"> </strong>我们选择了数字变量相加或者相乘。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi pf"><img src="../Images/d4c508aeddd695457fbcd66ae77f2818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NmYQho56xc4JtA_ZBfncZA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">The output of DFS if verbose = True</figcaption></figure><p id="6bfb" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">正如你在上面的图片中看到的，我们只用了几行代码就创建了额外的 668 个特性。创建的功能的几个示例:</p><ul class=""><li id="71f5" class="om on it lr b ls lt lv lw ly oo mc op mg oq mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">last_evaluation</strong></code> <strong class="lr jd"> </strong>乘以<code class="fe ov ow ox oy b"><strong class="lr jd">satisfaction_level</strong></code></li><li id="da33" class="om on it lr b ls oz lv pa ly pb mc pc mg pd mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">left</strong></code> <strong class="lr jd"> </strong>乘以<code class="fe ov ow ox oy b"><strong class="lr jd">promotion_last_5years</strong></code></li><li id="284e" class="om on it lr b ls oz lv pa ly pb mc pc mg pd mk or os ot ou bi translated"><code class="fe ov ow ox oy b"><strong class="lr jd">average_monthly_hours</strong></code> <strong class="lr jd"> </strong>乘以<code class="fe ov ow ox oy b"><strong class="lr jd">satisfaction_level</strong></code> <strong class="lr jd"> </strong>加上<code class="fe ov ow ox oy b"><strong class="lr jd">time_spend_company</strong></code></li></ul><p id="e819" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">附加提示 1: </strong>注意，这里的实现比较基础。DFS 的伟大之处在于它可以从表之间的聚合创建新的变量(例如，事实和维度)。参见此<a class="ae lo" href="https://docs.featuretools.com/loading_data/using_entitysets.html" rel="noopener ugc nofollow" target="_blank">链接</a>的示例。</p><p id="a39a" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">附加提示 2: </strong>运行<code class="fe ov ow ox oy b"><strong class="lr jd">ft.list_primitives()</strong></code>以查看您可以执行的聚合的完整列表。它甚至处理时间戳、空值和经度/纬度信息。</p><h1 id="2ead" class="nb nc it bd nd ne nf ng nh ni nj nk nl ki nm kj nn kl no km np ko nq kp nr ns bi translated">3.处理缺失值</h1><p id="7908" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">和往常一样，没有处理缺失值的最佳方式。根据您的数据，简单地用某些组的平均值或模式填充它们可能就足够了。然而，有一些先进的技术可以使用已知的数据部分来估算缺失值。</p><p id="a931" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">一个这样的方法叫做<strong class="lr jd">iterative inputr</strong>这是 Scikit-Learn 中的一个新包，它基于流行的 R 算法，用于输入缺失变量 MICE。</p><h2 id="7e9f" class="ny nc it bd nd nz oa dn nh ob oc dp nl ly od oe nn mc of og np mg oh oi nr iz bi translated">迭代估算器</h2><p id="4237" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">尽管 python 是开发机器学习模型的一种很好的语言，但仍有相当多的方法在 R 中工作得更好。一个例子是 R 中完善的插补包:missForest、mi、mice 等。</p><p id="a57c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">迭代估算器</strong>由 Scikit-Learn 开发，将每个缺失值的特征建模为其他特征的函数。它以此作为估算值。在每一步，选择一个特征作为输出<code class="fe ov ow ox oy b">y</code>，所有其他特征作为输入<code class="fe ov ow ox oy b">X</code>。然后在<code class="fe ov ow ox oy b">X</code>和<code class="fe ov ow ox oy b">y</code>上安装一个回归变量，用于预测<code class="fe ov ow ox oy b">y</code>的缺失值。对每个特征都这样做，并在几轮插补中重复。</p><p id="3193" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">让我们看一个例子。我使用的数据是众所周知的泰坦尼克号数据集。在这个数据集中，列<code class="fe ov ow ox oy b">Age</code>有我们想要填充的缺失值。代码一如既往地简单明了:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2537" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这种方法的好处在于它允许你使用自己选择的估计量。我使用了一个 RandomForestRegressor 来模拟 r 中常用的 missForest 的行为。</p><p id="6abb" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">附加提示 1: </strong>如果您有足够的数据，那么简单地删除缺失数据的样本可能是一个有吸引力的选择。但是，请记住，这可能会在您的数据中产生偏差。也许丢失的数据遵循一种你错过的模式。</p><p id="201e" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">附加提示 2 </strong>:迭代估算器允许使用不同的估算器。经过一些测试，我发现你甚至可以使用<strong class="lr jd"> Catboost </strong>作为一个估算器！不幸的是，LightGBM 和 XGBoost 不起作用，因为它们的随机状态名不同。</p><h1 id="f177" class="nb nc it bd nd ne nf ng nh ni nj nk nl ki nm kj nn kl no km np ko nq kp nr ns bi translated">4.离群点检测</h1><p id="5e6f" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">如果对数据没有很好的理解，离群值是很难发现的。如果您非常了解数据，您可以更容易地指定数据仍然有意义的阈值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/663ac897c00052fd7354fd11b12bc699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*SQIReDivrH0jioqhfvOelA.png"/></div></figure><p id="9b3d" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">有时这是不可能的，因为很难实现对数据的完美理解。相反，你可以利用离群点检测算法，比如流行的<strong class="lr jd">隔离森林</strong>。</p><h2 id="a514" class="ny nc it bd nd nz oa dn nh ob oc dp nl ly od oe nn mc of og np mg oh oi nr iz bi translated">隔离森林</h2><p id="03ae" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">在隔离森林算法中，关键字是<em class="mx">隔离</em>。本质上，该算法检查样本分离的难易程度。这将产生一个隔离数，该隔离数通过在随机决策树中隔离样本所需的分裂数来计算。然后对所有树的隔离数进行平均。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ph"><img src="../Images/37c2c86aea39e9d45fd48a518aedb241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSec0Fhf8bX--c7IRnK5Qw.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Isolation Forest Procedure. Retrieved from: <a class="ae lo" href="https://donghwa-kim.github.io/iforest.html" rel="noopener ugc nofollow" target="_blank">https://donghwa-kim.github.io/iforest.html</a></figcaption></figure><p id="ce43" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如果算法只需要做几次分裂就能找到一个样本，那么它更有可能是一个离群值。分割本身也是随机分割的，从而为异常产生更短的路径。因此，当所有树的隔离数较低时，该样本极有可能是异常。</p><p id="b985" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">为了展示一个例子，我再次使用了我们之前使用过的信用卡数据集:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi pi"><img src="../Images/5770c4717799f883d11ef698f3957222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TViPCoOxfc3Nc4gDl4TAZA.png"/></div></div></figure><p id="d965" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">额外提示 1 :有一个<a class="ae lo" href="https://github.com/sahandha/eif" rel="noopener ugc nofollow" target="_blank">扩展</a>版本的隔离森林，它改进了一些缺点。然而，T4 的评论褒贬不一。</p><h1 id="2e4b" class="nb nc it bd nd ne nf ng nh ni nj nk nl ki nm kj nn kl no km np ko nq kp nr ns bi translated">感谢您的阅读！</h1><p id="fedd" class="pw-post-body-paragraph lp lq it lr b ls nt kd lu lv nu kg lx ly nv ma mb mc nw me mf mg nx mi mj mk im bi translated">如果你和我一样，对人工智能、数据科学或心理学充满热情，请随时在<a class="ae lo" href="https://www.linkedin.com/in/mgrootendorst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上添加我，或者在<a class="ae lo" href="https://twitter.com/MaartenGr" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="790e" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">有代码的笔记本可以在这里找到<a class="ae lo" href="https://github.com/MaartenGr/feature-engineering/blob/master/Engineering%20Tips.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2acd" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">任何反馈和意见，一如既往，非常感谢！</p></div></div>    
</body>
</html>