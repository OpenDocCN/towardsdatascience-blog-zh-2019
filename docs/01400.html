<html>
<head>
<title>Learn Python from the Fake Album Covers Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从假专辑封面游戏中学习 Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-python-from-the-fake-album-covers-game-b8459e83c268?source=collection_archive---------19-----------------------#2019-03-05">https://towardsdatascience.com/learn-python-from-the-fake-album-covers-game-b8459e83c268?source=collection_archive---------19-----------------------#2019-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e827" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">网页抓取、字符串处理、图像处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ecf4b27fba5e958662a6f3697331f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOBmn2PAMPUtQkidXEPjtg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Web Scraping with Python (<a class="ae ky" href="https://pixabay.com/photos/books-door-entrance-culture-1655783/" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="677d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将学习如何使用 python 进行基本的网页抓取、图像处理和字符串处理，同时玩一个名为“<a class="ae ky" href="https://fakealbumcovers.com/" rel="noopener ugc nofollow" target="_blank">假专辑封面</a>”的游戏。这个游戏的想法是按照下面的步骤为你自己乐队的 CD 制作一个假封面</p><ol class=""><li id="ec83" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从<a class="ae ky" href="https://picsum.photos/" rel="noopener ugc nofollow" target="_blank"> Lorem Picsum </a>中获得任意一张图片，作为封面专辑。</li><li id="b16b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">封面上的乐队名称将使用任何随机维基页面标题中的标题生成。</li><li id="af77" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">专辑名将是<a class="ae ky" href="http://www.quotationspage.com/" rel="noopener ugc nofollow" target="_blank">语录页</a>中任意一页中最后一句语录的最后四个单词。随机链接不再起作用了，我查看了 reddit，发现设计师们现在使用 wikiquote 页面。所以在这篇文章中，我使用了随机生成的维基百科页面的标题。</li></ol><p id="4b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了开始游戏，我们需要从上面提到的网站获取图像，这里我们需要非常简单的 python 网页抓取技术。<em class="mj">简而言之，网页抓取的思想是，代替人类浏览和复制粘贴文档中的相关信息，计算机程序做同样的事情，更快更正确，以节省时间和精力。</em>尽管我们在这里没有使用 web 抓取来进行数据分析，但是记住这些网站大部分是使用 HTML 编写的，并且这些是结构化文档，不像我们熟悉的 CSV 或 JSON 格式，可以直接使用数据框库来处理，就像使用<code class="fe mk ml mm mn b">pandas</code>一样。</p><p id="e5f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，第一个问题是什么库可以帮助我们使用 Python 进行 web 抓取？最常用的三个库是<a class="ae ky" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> <em class="mj"> BeautifulSoup、</em></a><em class="mj"/><a class="ae ky" href="http://docs.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank">Requests、</a>和<a class="ae ky" href="http://doc.scrapy.org/en/latest/intro/install.html" rel="noopener ugc nofollow" target="_blank"> Scrapy </a>。在这里，我们将学习使用<em class="mj">请求和</em>请求，这将允许我们发送 HTTP 请求来获取 HTML 文件。</p><p id="1b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以从 Lorem Picsum 网站获取一张随机图片开始</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="c81b" class="ms mt it mn b gy mu mv l mw mx">import requests </span><span id="beb0" class="ms mt it mn b gy my mv l mw mx">response_obj = requests.get('<a class="ae ky" href="https://picsum.photos/g/500/?random'" rel="noopener ugc nofollow" target="_blank">https://picsum.photos/g/500/?random'</a>) </span></pre><p id="5d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们通过使用<code class="fe mk ml mm mn b">requests.get</code>创建了一个响应对象‘raw _ pic’。现在要从这个对象中获取信息，我们需要访问响应体，为此我们将使用<code class="fe mk ml mm mn b">content</code>。下面是一个将响应对象保存为. png 图像的示例—</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="ddf2" class="ms mt it mn b gy mu mv l mw mx">name = 'first_pic.png'</span><span id="bbdd" class="ms mt it mn b gy my mv l mw mx">with open(name1,'wb') as raw_file: <br/><em class="mj"># 'wb': write binary, binary is necessary because it is a png file</em><br/>       raw_file.write(response_obj.content)</span></pre><p id="127e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到了一个随机图像如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0fbaddfa51e60a6b761cbcef0e77773e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*OBasuVv5oympWw_ImWkWuQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Scraping images with Python from <a class="ae ky" href="https://picsum.photos/" rel="noopener ugc nofollow" target="_blank">Lorem Picsum</a>.</figcaption></figure><p id="200f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在作为游戏规则，我们需要把专辑名和乐队名放在这张图片上，为此我们将使用<a class="ae ky" href="https://pillow.readthedocs.io/en/3.0.x/index.html" rel="noopener ugc nofollow" target="_blank"> python 图像库</a> <em class="mj"> (PIL)。</em></p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="aecb" class="ms mt it mn b gy mu mv l mw mx">from PIL import Image</span></pre><p id="304b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先使用<code class="fe mk ml mm mn b">Image.open</code>打开并识别图像文件</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="cee8" class="ms mt it mn b gy mu mv l mw mx">img = Image.open("first_pic.png")</span></pre><p id="e368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们想在这张图片上绘制(书写)文字来完成封面，我们将使用 PIL 图书馆的<code class="fe mk ml mm mn b">ImageDraw</code>模块。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="1991" class="ms mt it mn b gy mu mv l mw mx">from PIL import ImageDraw<br/>draw = ImageDraw.Draw(img)</span></pre><p id="2cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个对象<code class="fe mk ml mm mn b">'draw’</code>以后可以用来插入文本。</p><p id="c737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个目标是指定我们将用来写乐队名称和专辑的字体的字体目录路径，我要求你发挥字体风格和创造性。为了加载一个字体文件并创建一个字体对象，我们将再次使用 PIL 库的<code class="fe mk ml mm mn b">ImageFont</code>模块。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="79ed" class="ms mt it mn b gy mu mv l mw mx">from PIL import ImageFont</span><span id="ede2" class="ms mt it mn b gy my mv l mw mx">band_name_font = ImageFont.truetype("path_to_font/font1.ttf", 25)</span><span id="9d25" class="ms mt it mn b gy my mv l mw mx">album_name_font = ImageFont.truetype("path_to_font/font2.ttf", 20)</span></pre><p id="7941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们放置文本并使用这些字体书写之前，我们需要再次使用 web 抓取来从网站中提取文本，这些文本是使用 HTML 编写的。</p><p id="4b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像之前的图片一样，我们为随机维基页面创建了一个响应对象</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="e4ac" class="ms mt it mn b gy mu mv l mw mx">wikipedia_link='<a class="ae ky" href="https://en.wikipedia.org/wiki/Special:Random'" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Special:Random'</a></span><span id="d59d" class="ms mt it mn b gy my mv l mw mx">r_wiki = requests.get(wikipedia_link)</span></pre><p id="12fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要阅读响应的内容，可以使用下面的<code class="fe mk ml mm mn b">text</code></p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="3d03" class="ms mt it mn b gy mu mv l mw mx">wiki_page  = r_wiki.text</span></pre><p id="724d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">请求</em>库将自动解码来自服务器的内容。当我们发出请求时，<em class="mj"> Requests </em>库将根据 HTTP 头对响应的编码进行有根据的猜测，我们可以在这里使用<code class="fe mk ml mm mn b">r_wiki.headers</code>看到这一点。当我们运行<code class="fe mk ml mm mn b">r_wiki.text</code>时，使用由<em class="mj">请求</em>猜测的测试编码。让我们检查编码类型</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="d737" class="ms mt it mn b gy mu mv l mw mx">print "encoding type", r_wiki.encoding</span><span id="62ab" class="ms mt it mn b gy my mv l mw mx">&gt;&gt;&gt; encoding type UTF-8</span><span id="de15" class="ms mt it mn b gy my mv l mw mx">print type(wiki_page)</span><span id="f7cd" class="ms mt it mn b gy my mv l mw mx">&gt;&gt;&gt; &lt;type 'unicode'&gt;</span></pre><p id="b645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看解码后的内容是什么样的</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="bb94" class="ms mt it mn b gy mu mv l mw mx">print (wiki_page)</span></pre><p id="e461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到如下所示的输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/1f1f3382cee841e68265a94571b4d19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAvhX6BIG-N1lyx01wuxNw.png"/></div></div></figure><p id="19f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的想法是用维基页面的标题作为乐队的标题。在上面的输出中可以看到，文章的标题被 XML 节点包围，如下所示<em class="mj">&lt;title&gt;Menyamya District—Wikipedia&lt;/title&gt;。这是任何维基页面<em class="mj"> &lt;标题&gt;标题——维基百科&lt;/标题&gt;，</em>的通常格式，如果我们考虑文章的标题。我们提取标题的第一项工作，是找到 XML 节点<em class="mj"> &lt; title &gt; </em>和<em class="mj"> &lt; /title &gt;。</em>我们将使用<a class="ae ky" href="https://docs.python.org/2/library/string.html#string.find" rel="noopener ugc nofollow" target="_blank"> string.find() </a>函数来查找这些节点，但在此之前，由于我使用了 python 2.7，我需要将 unicode 转换为字符串，如下所示</em></p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="0bd0" class="ms mt it mn b gy mu mv l mw mx">wiki_page = wiki_page.encode("ascii", errors='ignore')</span><span id="f5b8" class="ms mt it mn b gy my mv l mw mx">print type(wiki_page)</span><span id="0411" class="ms mt it mn b gy my mv l mw mx">&gt;&gt;&gt; &lt;type 'str'&gt;</span></pre><p id="06f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，我们准备好使用<a class="ae ky" href="https://docs.python.org/2/library/string.html#string.find" rel="noopener ugc nofollow" target="_blank"> string.find() </a>，并最终选择 XML 的特定部分，如下所示</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="c2c6" class="ms mt it mn b gy mu mv l mw mx">xml_e = wiki_page.find('&lt;/title&gt;')<br/>xml_b = wiki_page.find('&lt;title&gt;')<br/>title_b_len = len('&lt;/title&gt;')<br/>total_len = xml_e + title_b_len</span><span id="b2ab" class="ms mt it mn b gy my mv l mw mx">title_wiki = wiki_page[xml_b:total_len]<br/>print "title including wiki: ", title_wiki</span><span id="0399" class="ms mt it mn b gy my mv l mw mx">&gt;&gt;&gt; title including wiki:  &lt;title&gt;Menyamya District - Wikipedia&lt;/title&gt;</span></pre><p id="4240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的任务是去掉不必要的部分，我们将只剩下标题。你可以把这当成用 python 进行字符串操作的一个小任务，因为有很多方法可以做到这一点，稍后查看 github 页面比较解决方案。对于 wikiquote 页面，我们遵循相同的过程，提取标题，这将是我们的相册名称。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="6b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，一旦我们从网络搜集中获得了乐队名和专辑名，我们将把它们作为文本写入(绘制)到图像文件中。为此，我们将在之前定义的 draw 对象上使用<code class="fe mk ml mm mn b">text</code>。因为我只处理灰度图像，所以我可以用文字颜色来玩，但是如果你想用彩色图像作为假封面，那么最好的选择是用某种方式来写文字，这样它在任何颜色的背景下都是可见的。这样的格式是由亚历克·班尼特提供的，你可以遵循它并随机应变。一旦完成，我们准备检查我们的假 CD 封面，并记住图像，乐队名称和专辑名称都可能在每次运行时发生变化。所以玩得开心点！下面是我在一次这样的跑步中得到的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/59c7e19d9e7f01bc3325622024cf8806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*sRkWHFSYhTXAie6b4jMCNA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fake CD Cover !</figcaption></figure><p id="9004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在玩这个有趣的游戏时，我们学到了什么</p><ol class=""><li id="7d73" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">网页抓取使用<em class="mj">请求</em>模块。</li><li id="587b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">字符串处理；基本操作，如替换，剥离等(为您分配)。</li><li id="bb61" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用 PIL 图书馆的图像处理。</li></ol><p id="77a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当多，不是吗？完整的笔记本可以在我的 github 页面上找到。这整个游戏是 Coursera 应用数据科学课程<a class="ae ky" href="https://www.coursera.org/learn/python-for-applied-data-science" rel="noopener ugc nofollow" target="_blank"> Python 期末作业的一部分，和往常一样，这些课程包含一些精彩的实验环节，可以用 Python 进行游戏和学习。然而，为了生成专辑和乐队名，我们两次使用了维基百科页面，而不是维基百科页面。</a></p><p id="7eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敬请关注更多内容！</p><p id="3606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">关于我:我参与了</em><a class="ae ky" href="https://calet.jp/" rel="noopener ugc nofollow" target="_blank"><em class="mj">CALET</em></a><em class="mj">电子光谱的科学分析，寻找暗物质签名。在</em><a class="ae ky" href="https://www.linkedin.com/in/saptashwa/" rel="noopener ugc nofollow" target="_blank"><em class="mj">Linkedin</em></a><em class="mj">找我。</em></p></div></div>    
</body>
</html>