<html>
<head>
<title>How to Create an Interactive Dash Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建交互式 Dash Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-an-interactive-dash-web-application-11ea210aa6d9?source=collection_archive---------22-----------------------#2019-12-09">https://towardsdatascience.com/how-to-create-an-interactive-dash-web-application-11ea210aa6d9?source=collection_archive---------22-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5f097d438276481f3cda7d2a615a8956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*u8fQnBm7NkuAuXXqcbGwYg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="2566" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">使用 Dash、Heroku、XGBoost 和 Pickling 创建预测性 Web 应用程序</h2></div><p id="6fba" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您已经完成了数据科学，现在您需要向全世界展示结果！<a class="ae lp" href="https://dash.plot.ly/introduction" rel="noopener ugc nofollow" target="_blank"> Dash </a>是一个用于构建 web 应用的 python 框架。Dash 基于 Flask、Plotly.js 和 React.js 编写，非常适合快速构建定制的 web 应用程序。一旦构建完成，网络应用程序可以很容易地部署在云平台上，如<a class="ae lp" href="https://www.heroku.com/what" rel="noopener ugc nofollow" target="_blank"> Heroku </a>。</p><p id="c70f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">先说最终产品。下面这个简单的 web 应用程序使用户能够确定一个面临竞价大战的房屋的预计价格。预测价格基于 2015 年至 2019 年在加利福尼亚州马林县出售的所有单户住宅的历史数据，收到两个或更多报价。用户可以选择面积，卧室数量，浴室数量，预期报价和上市价格的数量，应用程序将提供预测的销售价格。</p><p id="416a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要使用 web 应用程序，只需选择预测选项卡，选择标准，应用程序将返回预测的报价。有关目标、数据、评估协议和模型选择的说明，请使用解释选项卡。“评估”选项卡提供了用于评估预测相对于实际中标报价的准确性的指标。</p><p id="8eda" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae lp" href="https://multiple-offers.herokuapp.com" rel="noopener ugc nofollow" target="_blank">预测竞价战中标价格的互动网络应用</a></p><p id="42d4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您想了解如何开发自己的交互式 web 应用程序，请跟随我一步一步地指导您完成这个过程。</p><p id="70bb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">关于代码的一句话</strong></p><p id="c2e1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该项目的所有代码、数据和相关文件都可以在 my <a class="ae lp" href="https://github.com/JimKing100/Multiple_Offers" rel="noopener ugc nofollow" target="_blank"> GitHub </a>访问。安装 Dash 后，从代码所在的目录运行本地计算机上的代码，并从您的终端运行<strong class="kv jf"> python app.py </strong>。这将在您的本地主机(127.0.0.1:8050)上运行应用程序。</p><p id="507f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">数据科学</strong></p><p id="02bc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由于本文的重点是交互式 web 应用程序的创建，我将简要描述用于预测最佳投标价格的数据科学。详情请看 colab 笔记本<a class="ae lp" href="https://github.com/JimKing100/Multiple_Offers/blob/master/model/XGBoost.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="605e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">原始数据是 2015 年至 2019 年在加利福尼亚州马林县出售的所有收到两个或更多报价的单户住宅的历史数据。导入原始数据并将区域映射到城市名称后，数据如下所示:</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/c0f20d9594851f30cdc9bfd3e5e548b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*UoT4h0QBe7TJ5eSRwfEMJQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">All Multiple Offer Sales in Marin County, CA 2015–2019</figcaption></figure><p id="71c4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">数据分为培训(2015 年至 2017 年)和验证(2018 年)以及测试(2019 年)，培训和验证分别涉及 2，973 次销售和 991 次销售，测试涉及 776 次销售。该测试集包含 2019 年约 11 个月的数据。</p><pre class="lr ls lt lu gt lz ma mb mc aw md bi"><span id="cb18" class="me mf je ma b gy mg mh l mi mj"># Split into train and test - 2015-2018 in train, 2019 in test<br/>low_cutoff = 2015<br/>high_cutoff = 2019<br/>train = df[(df['Year'] &gt;= low_cutoff) &amp; (df['Year'] &lt; high_cutoff)]<br/>test  = df[df['Year'] &gt;= high_cutoff]</span><span id="ac1a" class="me mf je ma b gy mk mh l mi mj"># Split train into train and validation - 2015-2017 in train and 2018 in validation<br/>cutoff = 2018<br/>temp=train.copy()<br/>train = temp[temp['Year'] &lt; cutoff]<br/>val  = temp[temp['Year'] &gt;= cutoff]</span></pre><p id="b8b7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最初进行了简单的线性回归，结果非常好。然后运行一个 XGBoost 模型，它有稍微好一点的指标，因此被选为模型。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/4eb1336f4a2a9422ca3fcd81ea19f1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*IogTsO_F51zR1EhnwUdPcQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">XGBoost Metrics</figcaption></figure><p id="5ccd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">腌制</strong></p><p id="8f9e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Pickling 用于序列化和反序列化 Python 对象(也称为编组或扁平化)。当您想要保存过程以便在以后进行预测而不必重新训练您的模型时，Pickling 在使用机器学习算法时非常有用。在我们的例子中，我们将清理管道，并在我们的 web 应用程序中使用它来进行预测。</p><p id="0e74" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，我们从 joblib 导入 dump:</p><pre class="lr ls lt lu gt lz ma mb mc aw md bi"><span id="5e09" class="me mf je ma b gy mg mh l mi mj">from joblib import dump</span></pre><p id="271a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，我们运行 XGBoost 模型并转储管道。这实际上是将管道保存到本地磁盘上一个名为 pipeline.joblib 的文件中。然后，这个文件被加载到 GitHub 中，并在 web 应用程序的 predict.py 代码中使用。</p><pre class="lr ls lt lu gt lz ma mb mc aw md bi"><span id="4e40" class="me mf je ma b gy mg mh l mi mj"># Encode and fit a XGBoost model<br/>target = 'Selling Price'</span><span id="7409" class="me mf je ma b gy mk mh l mi mj">features = train.columns.drop(target)<br/>X_train = train[features]<br/>y_train = train[target]<br/>X_val = val[features]<br/>y_val = val[target]<br/>X_test = test[features]<br/>y_test = test[target]</span><span id="7fab" class="me mf je ma b gy mk mh l mi mj">pipeline = make_pipeline(<br/>    ce.OneHotEncoder(use_cat_names=True), <br/>    XGBRegressor(n_estimators=200, n_jobs=-1)<br/>)</span><span id="24d1" class="me mf je ma b gy mk mh l mi mj">pipeline.fit(X_train, y_train)<br/>dump(pipeline, 'pipeline.joblib')<br/>y_pred = pipeline.predict(X_val)</span></pre><p id="c8ba" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">Dash App</strong></p><p id="1314" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Dash 应用由定义应用外观的“布局”和创建交互性的“回调”组成。我们的基本 Dash 应用程序由 app.py 和 index.py 文件组成。如果你用过<a class="ae lp" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>，那么这段代码看起来会很熟悉！</p><p id="c5d9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> app.py </strong></p><pre class="lr ls lt lu gt lz ma mb mc aw md bi"><span id="93de" class="me mf je ma b gy mg mh l mi mj">import dash</span><span id="fc68" class="me mf je ma b gy mk mh l mi mj">external_stylesheets = ['<a class="ae lp" href="https://codepen.io/chriddyp/pen/bWLwgP.css'" rel="noopener ugc nofollow" target="_blank">https://codepen.io/chriddyp/pen/bWLwgP.css'</a>]</span><span id="0dba" class="me mf je ma b gy mk mh l mi mj">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)<br/>app.config.suppress_callback_exceptions = True<br/>server = app.server</span></pre><p id="1e81" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">app.py 文件只是初始化和实例化 Dash 应用程序。</p><p id="39d5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> index.py </strong></p><pre class="lr ls lt lu gt lz ma mb mc aw md bi"><span id="c74f" class="me mf je ma b gy mg mh l mi mj">from dash.dependencies import Input, Output<br/>import dash_core_components as dcc<br/>import dash_html_components as html</span><span id="0838" class="me mf je ma b gy mk mh l mi mj">from app import app, server<br/>from tabs import intro, predict, explain, evaluate</span><span id="fb96" class="me mf je ma b gy mk mh l mi mj">style = {'maxWidth': '960px', 'margin': 'auto'}</span><span id="2772" class="me mf je ma b gy mk mh l mi mj">app.layout = html.Div([<br/>    dcc.Markdown('# Multiple Offer Calculator'),<br/>    dcc.Tabs(id='tabs', value='tab-intro', children=[<br/>        dcc.Tab(label='Intro', value='tab-intro'),<br/>        dcc.Tab(label='Predict', value='tab-predict'),<br/>        dcc.Tab(label='Explain', value='tab-explain'),<br/>        dcc.Tab(label='Evaluate', value='tab-evaluate'),<br/>    ]),<br/>    html.Div(id='tabs-content'),<br/>], style=style)</span><span id="7d1a" class="me mf je ma b gy mk mh l mi mj"><a class="ae lp" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(Output('tabs-content', 'children'),<br/>              [Input('tabs', 'value')])<br/>def render_content(tab):<br/>    if tab == 'tab-intro': return intro.layout<br/>    elif tab == 'tab-predict': return predict.layout<br/>    elif tab == 'tab-explain': return explain.layout<br/>    elif tab == 'tab-evaluate': return evaluate.layout</span><span id="7dbc" class="me mf je ma b gy mk mh l mi mj">if __name__ == '__main__':<br/>    app.run_server(debug=True)</span></pre><p id="a15e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">index.py 文件是应用程序的主要可执行文件。它分为两个主要部分:布局和回调。我们先来看一下布局。</p><p id="c163" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">布局</strong></p><p id="a816" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Dash 提供了两套可视化组件:<strong class="kv jf"> dash_html_components </strong>和<strong class="kv jf"> dash_core_components </strong>。dash_hml_components 库为每个 HTML 标签提供了一个组件。dash_core_components 库是更高级别的组件，如选项卡、下拉列表、降价模块、图表等。</p><p id="8156" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于我们的应用程序的布局，我们将使用 html 保持简单。dcc 部门。app.layout 定义了我们在 html 中的布局。Div(在 HTML 文档中定义一个部分)dcc。Markdown 使用<a class="ae lp" href="https://commonmark.org/help/" rel="noopener ugc nofollow" target="_blank"> Markdown </a>和 dcc 创建标题。Tab 创建四个标签，标签在标签中可见，一个值用于编码。就这样——我们基本上已经创建了主页！</p><p id="9f4d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">回调</strong></p><p id="e90b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Dash 使用<strong class="kv jf"> @app.callback </strong> decorator 告诉应用程序如何处理输入和输出。在我们的应用程序中，输入是布局 dcc 中定义的<strong class="kv jf"> id='tabs </strong>。有四个子项的选项卡—介绍、预测、解释和评估。输出是在 html.Div 中定义的<strong class="kv jf"> id='tabs-content </strong>'。当用户单击一个选项卡时，输入识别该选项卡，调用<strong class="kv jf"> render_content(tab) </strong>构造函数(函数)将选项卡更改为被单击的选项卡，然后结果输出到 html.Div。就这样——一个非常简单的回调！</p><p id="af25" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">预测选项卡</strong></p><p id="14f8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">了解了基础知识之后，让我们用预测选项卡来看看一个更复杂的例子。在 predict.py 代码中，我们将使用一个下拉菜单和四个滑动标签来获取我们的预测输入。然后，输入将用于运行我们的 pickled 预测并输出结果。</p><pre class="lr ls lt lu gt lz ma mb mc aw md bi"><span id="4cd5" class="me mf je ma b gy mg mh l mi mj">style = {'padding': '1.5em'}</span><span id="975e" class="me mf je ma b gy mk mh l mi mj">layout = html.Div([<br/>    dcc.Markdown("""<br/>        ### Predict<br/>        Use the controls below to update your predicted offer, based on city,<br/>        beds, baths, number of offers, and list price.<br/>    """),</span><span id="0c6a" class="me mf je ma b gy mk mh l mi mj">html.Div(id='prediction-content', style={'fontWeight': 'bold'}),</span><span id="ed1e" class="me mf je ma b gy mk mh l mi mj">html.Div([<br/>        dcc.Markdown('###### Area'),<br/>        dcc.Dropdown(<br/>            id='area',<br/>            options=[{'label': city, 'value': city} for city in cities],<br/>            value=cities[10]<br/>        ),<br/>    ], style=style),</span><span id="9412" class="me mf je ma b gy mk mh l mi mj">html.Div([<br/>        dcc.Markdown('###### Bedrooms'),<br/>        dcc.Slider(<br/>            id='bedrooms',<br/>            min=1,<br/>            max=7,<br/>            step=1,<br/>            value=3,<br/>            marks={n: str(n) for n in range(1, 7, 1)}<br/>        ),<br/>    ], style=style),</span><span id="f7c9" class="me mf je ma b gy mk mh l mi mj">html.Div([<br/>        dcc.Markdown('###### Baths'),<br/>        dcc.Slider(<br/>            id='baths',<br/>            min=1,<br/>            max=9,<br/>            step=1,<br/>            value=2,<br/>            marks={n: str(n) for n in range(1, 9, 1)}<br/>        ),<br/>    ], style=style),</span><span id="0554" class="me mf je ma b gy mk mh l mi mj">html.Div([<br/>        dcc.Markdown('###### Number of Offers'),<br/>        dcc.Slider(<br/>            id='offers',<br/>            min=2,<br/>            max=15,<br/>            step=1,<br/>            value=3,<br/>            marks={n: str(n) for n in range(2, 15, 1)}<br/>        ),<br/>    ], style=style),</span><span id="d7e8" class="me mf je ma b gy mk mh l mi mj">html.Div([<br/>        dcc.Markdown('###### Listing Price'),<br/>        dcc.Slider(<br/>            id='list_price',<br/>            min=1000000,<br/>            max=3000000,<br/>            step=100000,<br/>            value=1500000,<br/>            marks={n: f'{n/1000:.0f}k' for n in range(1000000, 3000000, 100000)}<br/>        ),<br/>    ], style=style),</span><span id="6662" class="me mf je ma b gy mk mh l mi mj">])</span><span id="7934" class="me mf je ma b gy mk mh l mi mj"><a class="ae lp" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(<br/>    Output('prediction-content', 'children'),<br/>    [Input('area', 'value'),<br/>     Input('bedrooms', 'value'),<br/>     Input('baths', 'value'),<br/>     Input('offers', 'value'),<br/>     Input('list_price', 'value')])<br/>def predict(area, bedrooms, baths, offers, list_price):</span><span id="66b4" class="me mf je ma b gy mk mh l mi mj">year = 2019<br/>    df = pd.DataFrame(<br/>        columns=['Year', 'Area', 'Total Bathrooms', 'Bedrooms', 'Curr List Price', 'Number of Offers'],<br/>        data=[[year, area, baths, bedrooms, list_price, offers]]<br/>    )</span><span id="e227" class="me mf je ma b gy mk mh l mi mj">pipeline = load('model/pipeline.joblib')<br/>    y_pred_log = pipeline.predict(df)<br/>    y_pred = y_pred_log[0]<br/>    percent_over = ((y_pred - list_price) / list_price) * 100<br/>    per_offer = percent_over / offers<br/>    results = f'The predicted winning bid is ${y_pred:,.0f} which is {percent_over:.2f}% over the asking price or \<br/>                {per_offer:.2f}% per offer.'</span><span id="9f5e" class="me mf je ma b gy mk mh l mi mj">return results</span></pre><p id="257a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然这看起来可能有很多代码，但实际上非常简单。该布局仅由四个组件组成——html。dcc 部门。降价，dcc。我们的布局由六个 html 组成。Div (sections ),预测在第一节，组件在接下来的五节。五个组件提供输入。</p><p id="96b9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每当任何单个输入发生变化时，都会调用回调函数，调用预测函数并将结果输出到第一部分。</p><p id="a96d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意在预测函数中:</p><p id="066b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">pipeline = load(' model/pipeline . joblib ')<br/></strong><br/>这将加载转储的管道，允许使用很少的代码非常快速地进行预测。</p><p id="680c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是对 Dash 的一个非常简单的介绍。如需了解更多详情，请查看 Dash 文档<a class="ae lp" href="https://dash.plot.ly/introduction" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="2b0f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> Heroku 部署</strong></p><p id="74af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一旦你让交互式网络应用在本地运行，你就可以让其他人通过使用公共托管服务(比如 Heroku)来访问它。Heroku 将托管该应用程序，允许您链接到它或使用 iframe。</p><p id="e944" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在 Heroku 上托管的基本步骤是:</p><p id="4606" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">1.创建一个 Procfile 和 requirements.txt 文件。在我的[GitHub][4]里看到我的。</p><p id="00dc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">2.创建一个 Heroku 应用程序并连接到您的 GitHub 存储库。</p><p id="ce46" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">3.运行应用程序！</p><p id="a6cf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我欢迎建设性的批评和反馈，请随时给我发私信。</p><p id="4c1a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有关 web 应用程序的更多背景信息，请参见配套文章“<a class="ae lp" rel="noopener" target="_blank" href="/how-to-win-a-bidding-war-in-real-estate-49ef50903449">如何赢得房地产投标战</a>”。</p><p id="0e59" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这篇文章最初出现在我的 GitHub Pages 网站上。</p><p id="8d1a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在推特上关注我</p><p id="f113" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="mm">马林房地产数据来源:马林 MLS (BAREIS)，2015–2019 数据</em></p></div></div>    
</body>
</html>