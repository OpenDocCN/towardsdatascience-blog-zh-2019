<html>
<head>
<title>Network analysis of Prisoners of Zenda book with Spacy and Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Spacy 和 Neo4j 对《证大囚徒》的网络分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/network-analysis-of-prisoners-of-zenda-book-with-spacy-and-neo4j-b0839a640105?source=collection_archive---------21-----------------------#2019-09-01">https://towardsdatascience.com/network-analysis-of-prisoners-of-zenda-book-with-spacy-and-neo4j-b0839a640105?source=collection_archive---------21-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="314c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多年来，互联网已经成为一种社交网络:联系和关系隐藏在众目睽睽之下——等待被发现。由于数据量巨大，这种关系很难用肉眼发现。然而，这并不意味着它们不存在或者不可能找到它们。</p><p id="69be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博客的想法是在我和来自<a class="ae kl" href="https://www.signalfish.io/" rel="noopener ugc nofollow" target="_blank"> Signalfish.io </a>的<a class="ae kl" href="https://uk.linkedin.com/in/jeremydavies" rel="noopener ugc nofollow" target="_blank">杰瑞米·戴维斯</a>进行头脑风暴时产生的。他们在生产中使用 SpaCy、Neo4j 和 Golang 来提供精选的新闻提要。SpaCy 具有实体识别系统。它提供了一个默认的 NLP 模型，可以识别各种命名实体，包括个人、组织等等。Neo4j 是一个原生图形数据库，从头开始设计用于处理关系和图形。</p><p id="bfbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">《T4 权力网》的分析给了我巨大的启发。如果我没记错的话，安德鲁·贝弗里奇在《权力的游戏》一书中用文本中人与人之间的距离来推断人与人之间的关系。我决定用 Spacy 和 Neo4j 做一些类似的事情。</p><h2 id="0fb6" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">要求</h2><ul class=""><li id="9162" class="lf lg iq jp b jq lh ju li jy lj kc lk kg ll kk lm ln lo lp bi translated"><a class="ae kl" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank">空间</a></li><li id="41ac" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="http://neo4j.com" rel="noopener ugc nofollow" target="_blank"> Neo4j </a></li><li id="3ed6" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated"><a class="ae kl" href="https://neo4j.com/docs/graph-algorithms/3.5/" rel="noopener ugc nofollow" target="_blank"> Neo4j 图形算法</a></li></ul><h2 id="5f98" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">议程</h2><ul class=""><li id="76ae" class="lf lg iq jp b jq lh ju li jy lj kc lk kg ll kk lm ln lo lp bi translated">预处理文本</li><li id="746c" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">从文本中提取关系</li><li id="5ab8" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">导入到 Neo4j</li><li id="2262" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">运行 Louvain 和 Pagerank 算法</li><li id="cd55" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">结果可视化</li></ul><h2 id="d638" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">数据</h2><p id="e742" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我在找一些没有版权的书，这样每个人都可以遵循这个教程。一路走来，我发现了古腾堡项目，该项目提供大部分版权过期的免费书籍。我们将使用安东尼·霍普写的《曾达的囚徒》一书。</p><h2 id="ba08" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">图形模型</h2><p id="1f3a" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">图模型由带有标签 Person 的节点组成。每个人可以有一个或多个与其他人相关的关系。每个关系都有一个属性分数。在我们的例子中，它代表了两个人在文本中的互动次数。另一个需要注意的重要事情是，我们将把这些关系视为无向的。查看此<a class="ae kl" href="https://dzone.com/articles/modelling-data-neo4j" rel="noopener ugc nofollow" target="_blank">文章</a>了解更多详情。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/e286fa09979e7cd2278e883abdee2a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*s3c-FHOTsga2_ARYmq2vHQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Graph model</figcaption></figure><h2 id="4748" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">预处理</h2><p id="a48c" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">古腾堡计划很好地为我们提供了《曾达的囚徒》一书的文本版本。我们将获取文本文件，删除特殊字符，并将文本分成章节。</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="6ea5" class="km kn iq mp b gy mt mu l mv mw"># <a class="ae kl" href="https://www.gutenberg.org/ebooks/95" rel="noopener ugc nofollow" target="_blank">https://www.gutenberg.org/ebooks/95</a> Prisoner of Zelda</span><span id="46f0" class="km kn iq mp b gy mx mu l mv mw"># Fetch the data<br/>target_url = 'https://www.gutenberg.org/files/95/95-0.txt'<br/>import urllib.request<br/>data = urllib.request.urlopen(target_url)<br/>raw_data = data.read().decode('utf8').strip()</span><span id="04ba" class="km kn iq mp b gy mx mu l mv mw"># Preprocess text into chapters <br/>import re<br/>chapters = re.sub('[^A-z0-9 -]', ' ', raw_data).split('CHAPTER')[1:]<br/>chapters[-1] = chapters[-1].split('End of the Project Gutenberg EBook')[0]</span></pre><p id="e897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们准备运行 Spacy 的命名实体识别。为了简化我们的分析，我们将只使用这本书的第一章。否则，我们将需要拿出一些名称映射系统，因为有时会使用一个人的全名，有时不会。这需要更多的手动方法，我们将在这里避免。</p><p id="abb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将在文本中用单个单词的 id 替换人名，以简化我们的算法。</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="2582" class="km kn iq mp b gy mt mu l mv mw"># import spacy and load a NLP model<br/>import spacy<br/>nlp = spacy.load("en_core_web_lg", disable=["tagger", "parser"])</span><span id="5c97" class="km kn iq mp b gy mx mu l mv mw"># Analyze the first chapter<br/>c = chapters[0]<br/># Get a list of persons <br/>doc=nlp(c)<br/>involved = list(set([ent.text for ent in doc.ents if ent.label_=='PERSON']))<br/># replace names of involved in the text<br/># with an id and save the mapping<br/>decode = dict()<br/>for i,x in enumerate(involved):<br/>    # Get mapping    <br/>    decode['$${}$$'.format(i)] = x<br/>    # Preprocess text<br/>    c = c.replace(x,' $${}$$ '.format(i))</span></pre><p id="b776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常简单的 SpaCy 操作演示。我们只分析了一小段文字。如果你想分析更大的数据集，你应该使用<em class="my"> nlp.pipe(texts) </em>函数。在<a class="ae kl" href="https://spacy.io/usage/processing-pipelines#processing" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多信息。</p><p id="d798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如前面我们的图模型所描述的，下面是它的 cypher 查询。</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="a6d3" class="km kn iq mp b gy mt mu l mv mw">save_query ="""<br/>    MERGE (p1:Person{name:$name1})<br/>    MERGE (p2:Person{name:$name2})<br/>    MERGE (p1)-[r:RELATED]-(p2)<br/>    ON CREATE SET r.score = 1<br/>    ON MATCH SET r.score = r.score + 1"""</span></pre><p id="50e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法设计简单。如果一对人在文本中相距不到 14 个单词，我们就推断出他们之间的关系。配对之间这种出现的次数被存储为关系的属性。</p><p id="8d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法遍历搜索人的单词。当它找到一个单词时(请记住单个单词的 id 系统)，它会检查接下来的 14 个单词以查找任何其他人。</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="320d" class="km kn iq mp b gy mt mu l mv mw"># Get an array of words<br/>ws = c.split()<br/>l = len(ws) <br/># Iterate through words<br/>for wi,w in enumerate(ws):<br/>    # Skip if the word is not a person<br/>    if not w[:2] == '$$':<br/>        continue<br/>    # Check next x words for any involved person<br/>    x = 14<br/>    for i in range(wi+1,wi+x):<br/>        # Avoid list index error<br/>        if i &gt;= l:<br/>            break<br/>        # Skip if the word is not a person<br/>        if not ws[i][:2] == '$$':<br/>            continue<br/>        # Store to Neo4j<br/>        params = {'name1':decode[ws[wi]],'name2':decode[ws[i]]}<br/>        session.run(save_query, params)<br/>        print(decode[ws[wi]],decode[ws[i]])</span></pre><h2 id="2760" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">图形算法</h2><p id="a7d7" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我们将在分析中运行<a class="ae kl" href="https://neo4j.com/docs/graph-algorithms/current/algorithms/page-rank/" rel="noopener ugc nofollow" target="_blank"> PageRank </a>和<a class="ae kl" href="https://neo4j.com/docs/graph-algorithms/current/algorithms/louvain/" rel="noopener ugc nofollow" target="_blank"> Louvain </a>算法。Pagerank 是通常用于表示图中节点的重要性的中心性度量。Louvain 算法是一种社区检测算法，它在我们的图中找到社区。</p><p id="6de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Neo4j 图形算法引擎区分有向和无向图。我们必须使用参数<em class="my"> direction: 'BOTH' </em>来告诉引擎将关系视为无向关系。</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="18d7" class="km kn iq mp b gy mt mu l mv mw">pagerank ="""<br/>CALL algo.pageRank('Person','RELATED',{direction:'BOTH'})<br/>"""<br/>louvain = """<br/>CALL algo.louvain('Person','RELATED',{direction:'BOTH'})<br/>"""<br/>with driver.session() as session:<br/>    session.run(pagerank)<br/>    session.run(louvain)</span></pre><h2 id="45ac" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">形象化</h2><p id="ed59" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我认为对于小型网络来说，一张图片胜过 1000 个字。我们将使用<a class="ae kl" href="https://github.com/neo4j-contrib/neovis.js/" rel="noopener ugc nofollow" target="_blank"> NeovisJS </a>来可视化我们的分析结果。可视化的代码是无耻地从马克·李约瑟的<a class="ae kl" href="https://github.com/neo4j-graph-analytics/graph-algorithms-notebooks" rel="noopener ugc nofollow" target="_blank"> Neo4j 图表笔记本</a>库中复制的。</p><p id="869c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> NeovisJS 配置</strong></p><p id="4315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要为生成 NeovisJS 可视化的函数提供一个配置文件。它由 Neo4j 的连接参数(主机、用户、密码)和定义可视化的三个参数组成。</p><p id="1ea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可视化参数:</p><ul class=""><li id="765e" class="lf lg iq jp b jq jr ju jv jy mz kc na kg nb kk lm ln lo lp bi translated">cypher:定义要从 Neo4j 获取的(子)图的 Cypher 查询</li><li id="70aa" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">labels_json:定义节点的可视化(标题、大小和颜色)</li><li id="eb9f" class="lf lg iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">relationships_json:定义关系的可视化(标题，大小)</li></ul><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="2122" class="km kn iq mp b gy mt mu l mv mw">cypher = "MATCH (p1:Person)-[r:RELATED]-&gt;(p2:Person) RETURN *"</span><span id="43e5" class="km kn iq mp b gy mx mu l mv mw">labels_json = {<br/>    "Person": {<br/>        "caption": "name",<br/>        "size": "pagerank",<br/>        "community": "community"<br/>    }<br/>}</span><span id="7477" class="km kn iq mp b gy mx mu l mv mw">relationships_json = {<br/>    "RELATED": {<br/>        "thickness": "score",<br/>        "caption": False<br/>    }<br/>}</span><span id="1509" class="km kn iq mp b gy mx mu l mv mw">generate_vis(host, user, password, cypher, labels_json, relationships_json)</span></pre><p id="763a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结果</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f9f1d0471e8ba2c0a63b9b8cb672b39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*a5vuCyuioh3wzR-KVCVRCw.png"/></div></figure><p id="e44e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鲁道夫似乎是第一章的主角。另一个重要人物是伯利斯顿。有趣的是，他和鲁道夫没有任何关系。右角是鲁道夫三世。我不知道这和鲁道夫是不是同一个人，因为我没读过这本书。在这个示例中，一些手动的名称清理会有所帮助。我们可以在图表中找到四个社区，它们的规模都差不多。</p><h2 id="a59f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">数据丰富</h2><p id="5c26" class="pw-post-body-paragraph jn jo iq jp b jq lh js jt ju li jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">这仅仅是我们所能实现的开始。我们可以添加 SpaCy 在我们的文本中找到的其他类型的标签。例如，让我们将组织添加到我们的图表中。我们简单地看一下课文中的组织，检查一下人物的前五个和后五个单词。数字 5 是完全随意选择的，你可以使用任何你认为最有效的数字。</p><p id="312b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据预处理</strong></p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="a6bd" class="km kn iq mp b gy mt mu l mv mw">c = chapters[0]<br/>doc = nlp(c)</span><span id="26bf" class="km kn iq mp b gy mx mu l mv mw"># Define the mapping<br/>persons = list(set([ent.text for ent in doc.ents if ent.label_=='PERSON']))<br/>orgs = list(set([ent.text for ent in doc.ents if ent.label_=='ORG']))<br/>decode_org = dict()<br/>decode_person = dict()</span><span id="0a61" class="km kn iq mp b gy mx mu l mv mw"># Replace person with an id<br/>for i,p in enumerate(persons):<br/>    decode_person['$${}$$'.format(i)] = p<br/>    c = c.replace(p,' $${}$$ '.format(i))</span><span id="e7dc" class="km kn iq mp b gy mx mu l mv mw"># Replace organizations with an id<br/>for i,o in enumerate(orgs):<br/>    decode_org['&amp;&amp;{}&amp;&amp;'.format(i)] = o<br/>    c = c.replace(o,' &amp;&amp;{}&amp;&amp; '.format(i))</span></pre><p id="ba10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将像以前一样使用类似的 cypher 查询，只是现在我们存储的是个人和组织之间的关系。</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="df9f" class="km kn iq mp b gy mt mu l mv mw">save_org_query = """</span><span id="8c19" class="km kn iq mp b gy mx mu l mv mw">MERGE (p:Person{name:$person})<br/>MERGE (o:Organization{name:$org})<br/>MERGE (p)-[r:PART_OF]-&gt;(o)<br/>ON CREATE SET r.score = 1<br/>ON MATCH SET r.score = r.score + 1</span><span id="214c" class="km kn iq mp b gy mx mu l mv mw">"""</span></pre><p id="77d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行算法并存储到 Neo4j</p><pre class="lz ma mb mc gt mo mp mq mr aw ms bi"><span id="a308" class="km kn iq mp b gy mt mu l mv mw">ws = c.split()<br/>l = len(ws)<br/>for wi,w in enumerate(ws):<br/>    # Skip if the word is not a organization<br/>    if not w[:2] == '&amp;&amp;':<br/>        continue<br/>    # Check previous and next x words for any involved person<br/>    x = 5<br/>    for i in range(wi-x,wi+x):<br/>    # Avoid list index error<br/>        if i &gt;= l:<br/>            break<br/>        # Skip if the word is not a person<br/>        if (ws[i][:2]!='$$') or (i==wi):<br/>            continue<br/>        # Store to Neo4j<br/>        params = {'org':decode_org[ws[wi]],'person':decode_person[ws[i]]}<br/>        session.run(save_org_query, params)<br/>        print(decode_org[ws[wi]],decode_person[ws[i]])</span></pre><p id="1c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组织对结果并不感兴趣，但是使用这种技术，您可以存储您喜欢的 NLP 引擎返回的所有不同类型的标签。这允许您构建一个知识图，表示任何给定文本中实体之间的关系。我们还可以使用不同的相似性度量，如 Jaccard 指数或重叠相似性来推断实体之间的关系。</p><p id="f469" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，你可以在这里找到 Ipython 笔记本的所有代码<a class="ae kl" href="https://github.com/tomasonjo/blogs/tree/master/Spacy_Neo4j_Gutenberg_Book" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5dc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my">如果你对更多的网络分析感兴趣我推荐:</em></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><a href="https://neo4j.com/graph-algorithms-book/?utm_source=tbgraph"><div class="gh gi nd"><img src="../Images/3b70f3c824aae4dfbe3b6f254e5825d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klgdxI1y_hSUUx-gsaU_Dw.png"/></div></a></figure></div></div>    
</body>
</html>