<html>
<head>
<title>Predicting the Number of Wildfires in the Amazon Rainforest Using Random Forests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用随机森林预测亚马逊雨林的野火数量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-the-number-of-wildfires-in-the-amazon-rainforest-using-random-forests-6a6680606801?source=collection_archive---------28-----------------------#2019-10-16">https://towardsdatascience.com/predicting-the-number-of-wildfires-in-the-amazon-rainforest-using-random-forests-6a6680606801?source=collection_archive---------28-----------------------#2019-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/267c5291df53845dfd0299c9f3a390c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l60V2tWod9d5WPnc4z3TvQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">Pixabay</a> on <a class="ae kf" href="https://www.pexels.com/photo/ash-blaze-burn-burning-266487/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="4dd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://medium.com/@spierre91/analyzing-amazon-wildfire-data-a4f9122a8877" rel="noopener">之前</a>，我们分析了巴西野火数据集。我们查看了数据集的特征，例如每个州野火的平均数量、每个州野火数量的标准偏差以及所有州野火数量的分布。我们还观察了每个州在特定月份的野火数量与全年的对比。</p><p id="5213" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将建立一个机器学习模型，我们将使用它来预测任何给定年份一个州的野火数量。</p><p id="cd31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构建我们的机器学习模型的工作流程如下:</p><ol class=""><li id="10d1" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">数据准备和清理</li><li id="89db" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">功能选择和工程</li><li id="5baf" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">型号选择</li><li id="c82f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">模型调整和测试</li></ol><p id="78b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，巴西数据集是结构化的，经过清理和标记的，因此我们基本上完成了第一步(在许多情况下，您将不得不处理非结构化和未标记的数据，这印证了一句谚语“数据科学家花费 80%的时间来寻找、清理和结构化数据”)。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="e6b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们建立这个模型！</p><p id="eade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要做的第一件事是导入必要的 python 包:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4a7c" class="mi mj it me b gy mk ml l mm mn">import numpy as np<br/>import pandas as pd<br/>from sklearn.metrics import mean_absolute_error<br/>from sklearn.ensemble import RandomForestRegressor</span></pre><p id="7a46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们可以写一个函数来初始化我们的数据。您可以自由选择如何预处理数据。对于这个例子，我们将保持简单，说我们根据感兴趣的特定状态初始化数据。我们还设计了一个月类别功能，我们将在我们的模型中包括:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f160" class="mi mj it me b gy mk ml l mm mn">def initialize_data(state):<br/>    df = pd.read_csv("amazon.csv",  encoding = "ISO-8859-1")<br/>    df['month_cat'] = df['month'].astype('category')<br/>    df['month_cat'] = df['month_cat'].cat.codes    <br/>    df = df[df['state'] == state]<br/>    return df</span></pre><p id="78b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们定义一个函数，该函数允许我们分割数据用于训练和测试:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a60b" class="mi mj it me b gy mk ml l mm mn">def train_test_split(year, df):    <br/>    df_train = df[df['year'] &lt; year]<br/>    df_test = df[df['year'] == year]<br/>    X_train  = np.array(df_train[['year', 'month_cat']])<br/>    y_train  = np.array(df_train['number'])<br/>    X_test  = np.array(df_test[['year', 'month_cat']])<br/>    y_test  = np.array(df_test['number'])    <br/>    return X_train, X_test, y_train, y_test</span></pre><p id="e37a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数“train_test_split”使用“year”来拆分模型训练和测试的数据。例如，如果“year”= 2015，则训练集被定义为 2015 年之前的所有 wildfire 数据，测试集被定义为 2015 年期间的所有 wildfire 数据。接下来，我们定义特征和目标变量，其中特征是年份和月份类别，输出是野火的数量。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="9828" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在定义一个函数，它指定随机森林算法的模型参数。该函数可用于在测试过程中优化模型参数，从而将误差降至最低。我们通过改变 N_ESTIMATORS 和 MAX_DEPTH 值来做到这一点，直到我们最小化误差度量。这个过程称为超参数调整:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="75d8" class="mi mj it me b gy mk ml l mm mn">def model_tuning(N_ESTIMATORS, MAX_DEPTH):<br/>    model = RandomForestRegressor(n_estimators = N_ESTIMATORS, max_depth = MAX_DEPTH, random_state = 42)<br/>    return model</span></pre><p id="7c9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们接下来要做的是定义一个函数，使模型符合训练数据，并预测野火的数量:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6a5b" class="mi mj it me b gy mk ml l mm mn">def predict_fire(model, X_train, X_test, y_train, y_test):<br/>    model.fit(X_train, y_train)<br/>    y_pred = model.predict(X_test).astype(int)<br/>    mae = mean_absolute_error(y_pred, y_test)<br/>    print("Mean Absolute Error: ", mae)   <br/>    df_results = pd.DataFrame({'Predicted': y_pred, 'Actual': y_test})<br/>    print(df_results.head())</span></pre><p id="39d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们定义一个“主”函数，用不同的输入值来测试模型。下面，我们对“初始化数据”、“模型调整”和“预测火灾”函数进行了两次调用。我们对 2017 年的“Sergipe”和“Distrito Federal”州进行预测，并计算平均绝对误差(MAE):</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="85ed" class="mi mj it me b gy mk ml l mm mn">def main():<br/>    df = initialize_data('Sergipe')<br/>    X_train, X_test, y_train, y_test = train_test_split(2017, df)<br/>    model = model_tuning(50, 50)<br/>    predict_fire(model, X_train, X_test, y_train, y_test)<br/>    <br/>    df = initialize_data('Distrito Federal')<br/>    X_train, X_test, y_train, y_test = train_test_split(2017, df)<br/>    model = model_tuning(50, 50)<br/>    predict_fire(model, X_train, X_test, y_train, y_test)</span><span id="4b05" class="mi mj it me b gy mo ml l mm mn">if __name__ == "__main__":     <br/>    main()</span></pre><p id="400c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/31809a8c57b460ca61263d9767597bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*MysuAaJbjqzjrhQw6Ikwog.png"/></div></figure><p id="8ad8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以分析模型在所有状态下的性能，如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c70f" class="mi mj it me b gy mk ml l mm mn">def main():<br/>    df = pd.read_csv("amazon.csv",  encoding = "ISO-8859-1")<br/>    for i in list(set(df['state'].values)):   <br/>        df = initialize_data(i)<br/>        X_train, X_test, y_train, y_test = train_test_split(2017, df)<br/>        model = model_tuning(50, 50)<br/>        predict_fire(model, X_train, X_test, y_train, y_test)  <br/>        print(i)</span><span id="ca29" class="mi mj it me b gy mo ml l mm mn">if __name__ == "__main__":     <br/>    main()</span></pre><p id="685f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将输出每个状态的预测值、实际值、状态名称和 MAE 值。可以通过超参数调整、尝试其他基于树的方法(XGBoost、lightgbm、catboost)和尝试神经网络时间序列模型(<a class="ae kf" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank"> LSTM </a>、<a class="ae kf" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank"> RNN </a>、<a class="ae kf" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank"> CNN </a>、<a class="ae kf" href="https://jeddy92.github.io/JEddy92.github.io/ts_seq2seq_conv/" rel="noopener ugc nofollow" target="_blank"> WaveNet CNN </a>)来改进模型。我鼓励你尝试一下这个模型，看看随机森林的 MAE 有多低。然后尝试应用我建议的一些其他方法，看看你是否在准确性上有所提高。所有的代码都可以在 GitHub 上找到。祝好运，机器学习快乐！</p></div></div>    
</body>
</html>