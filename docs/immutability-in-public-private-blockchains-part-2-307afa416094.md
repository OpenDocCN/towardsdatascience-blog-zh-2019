# 公共/私人区块链中的不变性—第 2 部分

> 原文：<https://towardsdatascience.com/immutability-in-public-private-blockchains-part-2-307afa416094?source=collection_archive---------13----------------------->

![](img/d28a0d54a5721f09b17ecf18ef345984.png)

Photo by [marcos mayer](https://unsplash.com/photos/8_NI1WTqCGY?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/search/photos/trust?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

在第 1 部分中，我们讨论了什么是不变性，在什么情况下它是重要的，以及所有这些与区块链的关系。

关于区块链不变性的进一步讨论涉及到具体的实现。在这一部分，我要谈一谈公共的和私人的区块链；具体来说，比特币和 Hyperledger Fabric。公共与私人的区别更丰富了讨论。

# 比特币不变性

根据我们设定的起点，分析比特币不变性时会涉及很多内容。试图从零开始涵盖这个主题将导致一篇文章的一个真正情有可原的解释。

关于比特币不变性，最常见的困惑之一是，既然区块被链接在一起，那么区块链就是不可变的。这不是真正正确的；真正让比特币不可改变的是工作证明。

## 工作证明

工作证明(PoW)，你可能知道，不是为比特币发明的东西。顾名思义，工作证明是工作被执行的证明。一个非常抽象的定义将是:一个工具，证明足够的努力致力于某事。特别是，防止*拒绝服务*攻击很有意义。

所以有三个有趣的问题:

*   为什么比特币需要能量？
*   谁在工作？
*   他们为什么这么做？

要理解这些问题，我们应该记住，比特币是一个公共区块链，因此任何人都可以在网络中扮演任何角色。正如在任何一种公共系统中一样，参与者之间的信任程度是有限的。在比特币中，执行 PoW 算法的节点被称为*矿工*，他们的角色是为链提出新的区块。

因为任何人都可以成为*矿工*、在任何时间点都有多个竞争区块被开采。由于每个*挖掘器*可以决定在块中包含哪些未确认的事务，因此我们将有许多可能的块，每个块都有不同的事务。那么，如果网络有多种可能的选择，它如何决定哪一个是下一个块呢？换句话说，网络如何达成*共识*？一个解决办法是让创造过程足够艰难。

如果生成一个有效的块足够困难，以至于所有的*矿工*作为一个整体只能生成一个，比如说，在几分钟的时间里，那么我们就不会有从许多中选择一个的问题。这就像一个硬彩票，检查 102 个中奖者比检查 3000 个中奖者更容易。此外，这不仅是一个难题，寻找解决方案也很昂贵。既然也贵，*矿工*在向网络广播无效块之前会三思。此外，矿工 T21 可以证明工作已经完成，这是无可争议的。

这并没有以确定性的方式解决一致性问题，但足以在网络中提供可靠的一致性保证。选择正确的硬度是分叉概率、网络负载和确认速度之间的权衡。

但是对于一个矿工来说，权力到底意味着什么呢？在比特币方面，*矿工*应该找到通常被称为*密码难题*的解决方案。这个*难题*包括找到一个*数*，使得新的块散列值低于某个阈值。这个*号*是的一个证明*矿工*按预期执行了 PoW。当验证一个新的块时，这个*号*不满足这个条件的事实足以认为它是无效的。

为什么是这个*谜题*而不是另一个？因为我们很确定唯一的解决方法就是暴力。它没有捷径；是骗不了的。此外，网络将自动调整其难度，即前面提到的*阈值*，以响应网络散列能力的增加或减少，从而保持块创建的定义速度。

我们可以想象，也许*矿工*会为了在网络中达成共识而解决这个昂贵的问题，但这太天真了，不是因为*矿工*邪恶，而是因为他们理性。激励*矿工*的真正原因是**激励**。

当*采矿者*成功开采一个区块时，它将获得*奖励*以及该区块内包含的交易的*交易费用*的总和；都在*比特币*里。这些激励在供应链的生命周期内是动态的。

*奖励*是确定性的，每 210.000 个块减半，*交易费用*可以根据受未决交易池的大小或某种外源*交易紧急程度*影响的需求而变化。

关于激励和权力是如何交织在一起使系统变得安全和可持续的，有很多话要说。这部分制度设计更多的是心理学，经济学，博弈论。在一个不可信的网络中，你不能假设网络参与者总是按照预期行事，或者有不同于他们自己的其他兴趣。

PoW 作为一种共识机制，但是它和不可变性有什么关系呢？为了理解这一点，我们应该考虑比特币*中的节点*应该遵循的一个重要规则:**最长的链是当前链**。*当前*链是什么概念？。

假设链中的最后一个块是 100 号。由于在*矿工*之间没有任何协调来生成块号 101，事实上，他们在比赛/抽奖成为奖励的所有者，所以有可能他们中的两个大约同时生成有效的 101 块(比如 101a 和 101b)。我所说的“同时”是指两个块都被广播到网络，并且对于附加到其当前链的其他节点来说是完全有效的选项。

在这种情况下，网络中的节点可以接收这两个有效块，在链中有一个分叉。挡块 *101a* 是指 *a* 叉中的挡块编号 101， *101b* 是指 *b* 叉中的挡块编号 101。

起初，这个节点持有两条链并等待一段时间。如果几分钟后生成了一个 *102a* 块(带有父块 *101a* ，则发生以下情况:

*   包含块 *102a* 的链被认为是当前链，因为它是已知的最长的链。(链条长度也称为*高度*
*   具有 *101b* 的前叉被分开放置，不被视为当前链条。

这对*矿工*来说有着重要的意义，因为他们可以选择在现有的链条上采矿，也可以尝试在叉子上继续挖掘。因为最长的链是当前的链，所以在另一个分支上提交工作是有风险的，因为采矿的任何回报在现实中没有任何价值。

最明显的选择是在最长的链上挖掘，因为这个链更有可能继续是最长的。如果矿工坚持在滞后的*叉/链上采矿，则该叉有可能永远赶不上当前的链长度。因此，为获得*奖励*和收取*费用*而参与发电区块发电的所有工作都完全浪费了。*

此外，由于每个理性的矿工会选择这个选项，有更多的*矿工*开采最长的链，因此新块的当前链速度比任何其他链快几个数量级的可能性更高。你可以计算一下，发现追上最长链的概率随着链间长度的不同而呈指数下降。

决定在哪里挖掘未来的块与不变性无关，因为我们考虑的是追加，而不是修改历史。但事实证明，试图修改历史是在有意构建当前链条的分叉。

同样，如果当前区块是 100 号，并且我们试图生成另一个有效区块 90，我们应该与具有 11 个区块滞后的最长链竞争，并且让每个矿工联合起来反对我们在最长链上采矿。所以这是一个巨大的挑战。

我们应该对 11 个街区(从 90 号街区到 100 号街区)供电。这意味着我们自己解决电力问题，导致大量的电力成本，并在这个过程中，在一个仍然不被认为是当前的链上产生回报，因此在现实中仍然没有价值。

当我们再次生成第 100 个块时，我们意识到在这段时间内，其他矿工在开采原始链，现在链长度差异很可能比我们开始时更大。

我们应该有超过 50%的网络散列能力，以真正最终赶上一个分叉链，成为当前链。这取决于我们的散列能力超过网络的散列能力多少，以及你想要修改的块有多旧。这叫做 *51%攻击*。

如果我们只有不到 50%的网络散列能力，那么我们很可能永远也赶不上，因此所有投入到分叉点的电力(因此，成本)*都将被完全浪费。*

*当然，我这里是简化；在[中本聪](https://en.wikipedia.org/wiki/Satoshi_Nakamoto)撰写的[原创比特币论文](https://bitcoin.org/bitcoin.pdf)第 11 章中有更详细的计算。个人推荐[这篇](https://arxiv.org/pdf/1701.03977.pdf)优秀的论文，更详细的了解中本聪的计算和验证。*

*从整体上考虑网络的哈希能力，任何种类的实体都有能力攻击网络的不变性，这种可能性微乎其微。这就是为什么有时你可能会听，这是一个很好的做法，等待 6 块，大约 1 小时，在您的交易确认后，以确保它是不可变的。你想更安全吗？等 12 个，或者更多。如果你对确切的概率感兴趣，这个计算器很有用。*

## *超分类帐结构不变性*

*在织物的情况下，不变性分析要简单得多，因为它是一个*许可的*区块链。由于在网络中有更多的信任，解决这个问题需要更少的工件。*

*In 结构块由*订购服务*生成。它的职责是建立网络中交易的*总秩序*。与比特币一样，块包含交易，每个块包含前一个块的哈希值。*

*一个通用的生产就绪*订购服务*由一个 *Apache Kafka* 集群和一个或多个*订购者组成。*每个想要发送交易提议的参与者通过 *broadcast* 接口将其发送给任何一个*order*，然后*order*将其作为 Kafka 中的一个消息推送到一个映射到交易的*通道*的*分区主题*中。*

*Kafka 完成了为每个通道建立事务总排序的繁重工作，因为每个通道都有一个到*主题*的一对一映射，而主题只有一个分区。在 Kafka 中，每个分区每个主题的消息保证有一个定义良好的顺序。*

*在事务在*主题*上之后，*排序器*读取分区以生成下一个块。块生成在*通道*配置中定义了一些确定性规则，它基于块的总大小或基于时间的标准。在后者中，使用来自 Kafka 的元数据，因此不同的排序者将选择包含在块中的相同的有序交易集。*

*你可能认为这是一个*事件源*系统，其中任何规则都是基于确定性数据和函数的。事实上，如果所有节点从 Fabric 中消失，但 Kafka 集群仍然存在，我们可以从头开始重建所有块。你的 Kafka 集群是网络安全最重要的组成部分。*

*然后一个*排序器*创建一个包含一定数量事务的块，但是这里没有 PoW。为了使该块有效，它应该由一个*订购者*签名。如果块由来自*订购服务*的任何*订购者*签名，则块被视为有效。*

**对等点*是网络中通过*交付*接口与*排序器接收块的节点。*他们验证事务并将其标记为有效或无效(考虑到*读写*集，以及一系列其他标准)，然后修改 *CouchDB* 或 *LevelDB* 中的*世界状态*，并明显地将块附加到分类帐。*

*通过*通道*配置，维护*通道*分类帐副本的*对等方*知道哪个是*订购服务*的 *CAs* ，因此它可以检查新块是否来自可信来源。如您所见，块生成依赖于对来自*订购服务*的 *CA* 的信任。*

*很明显，如果任何一个*订购者*或 *CA* 的私钥被泄露，或者不知何故凭空产生了一个新的订购者，那么我们就有大麻烦了。*

*首先，我们可以想象恶意方可能会生成新的块，并开始混淆网络中的不同对等点，使它们的分类帐出现分歧。此外，如果恶意方作为*对等*节点参与，那么它可以修改自己的分类帐，因为制作新块就像制作签名一样容易。这包括修改以前存在的任何块。它有改写账本历史的力量。可以进行的修改是块内交易的审查或重组，因为每笔交易都是由客户签名的，不能被篡改。*

*这听起来很严重…但是如果我们有足够的时间和大量的现金来支付电费，我们也可以改写历史。那有什么区别呢？。在织物中，如果我能以某种方式破解任何订购者的私钥，那么与比特币中永恒而昂贵的程序相比，重写历史是非常便宜和快速的；但是如何让其他同事相信我修改过的账本是真正的账本呢？如果我不能说服别人，我在现实世界中也不能产生太大的影响。在织物如果你是唯一一个有一个有效的，但不同的分类帐相比，世界上其他地方，有些事情听起来很不对劲。*

*在比特币中，这涉及到以某种方式拥有比当前更长的链，如果我们没有接近网络散列能力的 50%，这将是非常困难的。在 Fabric 的情况下，这实际上是不可能的，原因很简单:分类帐中的分叉被认为是关键情况，节点不会接受它们。这种情况被认为是恶意攻击或系统中的错误。*

*您可能会想:既然这与块篡改的难度无关，那么在 Fabric 中链接块的目的是什么？在比特币中，区块链是必须的，因为它迫使恶意节点不仅挖掘修改过的区块，还挖掘所有后续的区块。*

*事实证明，在 Fabric 中，块链接对于保持分类帐的不变性并不重要。该实用程序使分类帐*变得显窃启*，这意味着很容易检查分类帐是否被修改。如果一个诚实的节点从另一个节点接收到一个块，而它的 hash 与另一个块不匹配(在同一高度)，那么我们可以确定它对应的是一个不同的分类帐，出现了危急情况。我们可以进一步调查哪个块是真正的差异，但这个问题可以通过简单快速的检查来检测。*

# *结论*

*比特币实现不变性的方式与 Hyperledger Fabric 完全不同。当我们谈到区块链时，我们看到一个重要的特性，那就是数据块是用哈希链接起来的。*

*在比特币中，它对账本不变性的重要性是显而易见的，因为它与不变性的硬度直接相关。我想要修改的块越老，就越难生成足够高的链来说服网络的其余部分。*

*在 Fabric 中，块链接与篡改分类帐的难度无关；考虑到一个*订购者*的私钥被泄露，这可以在几秒钟内完成。尽管如此，说服另一个节点改变它的分类帐是不被设计所接受的；叉子是不被接受的，应该需要人工干预，因为这是出了问题的征兆。*

*本系列涵盖了许多值得更详细讨论的主题，但我希望您会发现它很有用。*