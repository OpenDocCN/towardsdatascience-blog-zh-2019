<html>
<head>
<title>Random Matrix Theory: The Best Classifier for prediction of Drug Binding?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机矩阵理论:预测药物结合的最佳分类器？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/random-matrix-theory-the-best-classifier-for-prediction-of-drug-binding-f82613fb48ed?source=collection_archive---------12-----------------------#2019-07-02">https://towardsdatascience.com/random-matrix-theory-the-best-classifier-for-prediction-of-drug-binding-f82613fb48ed?source=collection_archive---------12-----------------------#2019-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a95a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">预测潜在候选药物的结合亲和力只是目前被人工智能破坏的药物发现渠道的一个组成部分。随机矩阵理论提供了一种 AUC 非常高的分类算法，优于现有的其他方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35dcdd043b125f8ffe48ef35d0f00506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XePoW4byovFyV87YSmHDVw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">ROC Curve for the RMT Algorithm; note the high AUC!</figcaption></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="443a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">以下两种算法反复显示了一致的结果(AUC 约为 0.7-0.8):</p><ul class=""><li id="62a6" class="mb mc it lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated"><strong class="lh iu">随机森林</strong>(【https://www.youtube.com/watch?v=J4Wdy0Wc_xQ】T2&amp;VL = en)</li><li id="0074" class="mb mc it lh b li ml ll mm lo mn ls mo lw mp ma mg mh mi mj bi translated"><strong class="lh iu">朴素贝叶斯</strong>(<a class="ae mk" href="https://machinelearningmastery.com/naive-bayes-for-machine-learning/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/Naive-Bayes-for-machine-learning/</a>)</li></ul><p id="6692" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然而，一个相对较新的受随机矩阵理论启发的算法在几年前由天才的阿尔法·李在 PNAS 的论文中报道。<strong class="lh iu">它获得了好得多的~0.9 的 AUC！</strong></p><h2 id="bb1c" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">这篇中型博客文章旨在解释该算法，并为其实现提供一个高级 Python 包。</h2><p id="134d" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated"><em class="no">跳到 3。如果你已经知道如何生成分子的位向量矩阵。</em></p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="0a3b" class="np mr it bd ms nq nr ns mv nt nu nv my jz nw ka nb kc nx kd ne kf ny kg nh nz bi translated">1.获取数据并清理数据(如果您知道如何做，请跳过本节)</h1><p id="4250" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">我们需要 2 个数据集，即:</p><ul class=""><li id="aa4b" class="mb mc it lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">一组<strong class="lh iu">将</strong>绑定到特定目标的药物(在我们的案例中为<a class="ae mk" href="https://en.wikipedia.org/wiki/Beta-1_adrenergic_receptor" rel="noopener ugc nofollow" target="_blank"> ADR </a> B1)(这组成了<strong class="lh iu">培训</strong>和<strong class="lh iu">验证</strong>组)</li><li id="b3a6" class="mb mc it lh b li ml ll mm lo mn ls mo lw mp ma mg mh mi mj bi translated">一组<strong class="lh iu">不会将</strong>结合到特定目标的药物(这构成了<strong class="lh iu">诱饵</strong>组)</li></ul><p id="3402" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为了获得这些数据集，我们前往<a class="ae mk" href="https://www.ebi.ac.uk/chembl/" rel="noopener ugc nofollow" target="_blank"> ChEMBL </a>数据库，下载 ADR1B 受体的所有配体。或者，数据集在我的 GitHub 上。对于<strong class="lh iu">诱饵</strong>组，我们将使用来自另一个任意受体的配体(尽管该受体与 ADRB1 不具有同源性)。我们将从 5HT1A 受体中选择配体，因为它与 ADRB1 几乎没有同源性。或者，我们可以使用来自 ChEMBL 的随机配体的选择，这是在<a class="ae mk" href="https://www.pnas.org/content/pnas/113/48/13564.full.pdf" rel="noopener ugc nofollow" target="_blank"> PNAS 论文</a>中所做的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/8c2eb66bb751605241b3ba7841d919bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o3ThBy5RgOpk5jz9HM6zw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">After selecting all ligands for ADR1B, click on the right to download the CSV file</figcaption></figure><p id="88f6" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">一旦我们获得了用于训练和验证集以及诱饵集的 CSV 文件，我们就将它加载到 Python 中并清理它。下面是实现这一点的代码——您可以随意复制它，因为细节相对来说没什么意思。需要注意的最重要的一点是<strong class="lh iu">对于 train_validation 集合，我们只选择结合亲和力小于 1000nM </strong>的分子，即这些分子是结合物。对于诱饵组，结合亲和力(对 5HT1A)是不相关的，因为我们假设对 ADR1B 的结合亲和力非常差(合理的假设)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c2f4704980463c9e8b0f795714f23196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJ5FRzx490OflMF-3IfSzg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Imports and function to load the dataset</figcaption></figure><p id="3dab" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们来看看数据集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/fc9e37860ad66512ce32fad17af3b4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuXveG9TqWUtVqJmt1qDIg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The datasets — take note of the standard value/binding affinity column</figcaption></figure><p id="8f9c" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果你向右滚动，有一列包含分子的微笑串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/4b2288a4e8facf3c29bfafc6c5e6ebe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fViTOZvZGweRIevZeMJqeQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">SMILES column located in the middle of the dataframe</figcaption></figure><p id="efb2" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们最后选择相关的列。我们实际上不需要 affinity 列，因为我们已经知道整个 train_test 集合只包含绑定器，而 decoy 集合只包含非绑定器。我们只是为了完成而包含了关联变量(此外，我们可以使用 sklearn 的 train_test_split 函数来方便地将 train_test 集合划分为训练和测试/验证集合)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/708506569c24951812b72a7b51a06d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VSLVRj5J1qs3j5mYh1tPQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Selecting</figcaption></figure><p id="59ee" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将使用 SMILES 列生成每个分子的<strong class="lh iu">分子指纹</strong>。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="f93d" class="np mr it bd ms nq nr ns mv nt nu nv my jz nw ka nb kc nx kd ne kf ny kg nh nz bi translated">2.生成分子指纹(如果需要，跳过这一部分)</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bea8a858df577167946ab57d70cbe4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVv2qp4miVfK9rZaHHAQZw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Morgan/Extended-Connectivity fingerprinting is one of the most popular types of fingerprinting</figcaption></figure><p id="dd40" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们本质上想把<strong class="lh iu">分子结构</strong>转换成<strong class="lh iu">数学对象</strong>，对其进行机器学习。我们可以使用化学信息学库<strong class="lh iu"> RDKit </strong>来完成这项工作，将 SMILES 字符串转换为分子结构，再转换为长度为 2048 的<strong class="lh iu"> Morgan 位向量</strong>。我们可以认为每一个条目对应于一个特定化学亚结构的存在或不存在。</p><blockquote class="og oh oi"><p id="997e" class="lf lg no lh b li lj ju lk ll lm jx ln oj lp lq lr ok lt lu lv ol lx ly lz ma im bi translated">这本身就是一个大话题，所以如果你想了解更多，请参考我的另一篇关于<a class="ae mk" href="https://medium.com/@lakshaithani/a-practical-introduction-to-the-use-of-molecular-fingerprints-in-drug-discovery-7f15021be2b1" rel="noopener"> <em class="it">指纹</em> </a>的博文。</p></blockquote><p id="9436" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">将分子转换成指纹的代码在这里——你可以随意复制它，因为它与这篇文章的核心并不特别相关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/e80242513d360f883ea9491fb74c45a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaAvrh14Mis__PakOmQYkg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Code to generate the Morgan matrix</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d6fdbbd73a08b4ac5fa50171ac5f90c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*7Be4rNmddxY5lsOkw_cAgQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Generating the N x p Morgan matrix; N is the number of molecules in the dataset and p is the number of bit features</figcaption></figure><p id="e131" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">最后，我们将我们的 train_test 集合分成一个<strong class="lh iu"> train </strong>绑定集合和<strong class="lh iu">测试/验证</strong>绑定集合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/8c7c2ab898e0fa924a09f616ed1d8d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOuzC84mbufWMPdeX0bp1Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Feel free to use the same random_state if you want to reproduce the results, or use a different one if you’re feeling adventurous</figcaption></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="5167" class="np mr it bd ms nq nr ns mv nt nu nv my jz nw ka nb kc nx kd ne kf ny kg nh nz bi translated">3.RMT 算法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/3bf6fec43a107fd36a0b7bb073fbc227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5vf-yQdIVi5gXGW4d_ngw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The <strong class="bd oq"><em class="or">Marchenko-Pastur (MP) </em>distribution</strong> of eigenvalues of a random correlation matrix; note the cutoff of eigenvalues after a certain point</figcaption></figure><h2 id="2391" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">3.1 简要提醒我们的数据格式</h2><p id="ccbc" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">这与你的标准机器学习问题略有不同，所以请注意这一点。我们有:</p><ol class=""><li id="7fd3" class="mb mc it lh b li lj ll lm lo md ls me lw mf ma os mh mi mj bi translated"><strong class="lh iu">列车</strong>组——该组仅由<strong class="lh iu">粘合剂</strong>组成(不包含非粘合剂)</li><li id="2769" class="mb mc it lh b li ml ll mm lo mn ls mo lw mp ma os mh mi mj bi translated"><strong class="lh iu">测试/验证</strong>集—这也包含<strong class="lh iu">公正绑定</strong></li><li id="42bc" class="mb mc it lh b li ml ll mm lo mn ls mo lw mp ma os mh mi mj bi translated"><strong class="lh iu">诱饵</strong>集合——它只包含<strong class="lh iu">被认为是非结合剂的分子</strong></li></ol><h2 id="c1a7" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">3.2 在训练集中寻找特征之间的相关性</h2><p id="e419" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">我们希望了解训练集中最重要的特征或特征组合是什么。我们可以通过<strong class="lh iu">主成分分析</strong>来做到这一点。</p><h2 id="d2bf" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">对数据进行缩放</h2><p id="09f1" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">在此之前，我们需要记住<strong class="lh iu">将训练集的所有列缩放为 0 均值和单位标准偏差</strong>。一个额外的要求是<strong class="lh iu">保留列平均值和标准偏差</strong>，因为我们也将使用这些来衡量测试/验证和诱饵集。Sklearn 的 StandardScaler 函数会做到这一点。<em class="no">然后，我们使用列均值和 stds 来缩放训练矩阵，缩放测试和诱饵配体。</em>这也很容易做到。最后，我们删除所有矩阵中对应于训练矩阵中标准偏差为 0 的列的列。这段代码可以做到这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/d8f387b0f3aa41239c06a680a9738828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogIm-ol0UOGd_Gae799PPw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Scaling the data, deleting relevant columns</figcaption></figure><h2 id="bac5" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">3.2.2 形成相关矩阵并将其对角化</h2><p id="7045" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">所有需要的是形成相关矩阵，然后对角化它。对应于最大特征值的特征向量将占训练集中最大的方差。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/1b0bd4234b25bc32f4c1d678fd1e05f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*xWlJiaael36o9b01LA7qfA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">PCA: Eigendecomposition of the correlation matrix</figcaption></figure><p id="4e15" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后我们注意到来自<strong class="lh iu">随机矩阵理论</strong>的一个关键结果——马尔琴科-帕斯图分布。它指出，对于随机矩阵(条目来自均值和单位方差均为 0 的高斯分布)，其相关矩阵具有以下特征值分布:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/04aba640932195841765d04f726c4315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zdiHPbcDDpde98cYDaqYA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Marchenko-Pastur distribution</figcaption></figure><p id="6ba9" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu"> Gamma = p/N </strong>描述数据集的采样程度。回想一下，训练矩阵的维数为 N×p。正下标表示我们只考虑正括号。这意味着大于 MP 阈值(如下所示)的特征值在随机相关矩阵中不太可能出现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/69e6c6bc9aa0b4205a3236aab0543f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*AA1BVnrj0__gflnxHvC0oQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The MP threshold</figcaption></figure><blockquote class="og oh oi"><p id="1d68" class="lf lg no lh b li lj ju lk ll lm jx ln oj lp lq lr ok lt lu lv ol lx ly lz ma im bi translated">因此，通过创建由相关矩阵的特征向量组成的向量空间，其对应的特征值大于 MP 阈值，我们找到了有助于与特定受体结合的化学特征空间。 </p></blockquote><h1 id="f4d8" class="np mr it bd ms nq ox ns mv nt oy nv my jz oz ka nb kc pa kd ne kf pb kg nh nz bi translated">4.将未知配体分类为结合物或非结合物</h1><p id="7e2a" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">我们现在有了受体的结合向量空间。我们可以用这个向量空间来分类未知的配体。方法简单。</p><h2 id="f3b9" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">4.1 标定未知配体</h2><p id="1f56" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated"><em class="no">这里需要注意的重要一点是，我们使用训练集的列均值和 stds。</em>这是必需的——直觉上，未知数据应使用用于缩放训练数据的相同参数进行缩放。这在之前的代码中已经完成了——sk learn 的 StandardScaler 使这变得很容易。</p><h2 id="ee4d" class="mq mr it bd ms mt mu dn mv mw mx dp my lo mz na nb ls nc nd ne lw nf ng nh ni bi translated">4.2 将缩放的未知配体投影到化学特征空间上，并比较配体与其投影的距离</h2><p id="e3f3" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">这很容易做到。见下文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/e2131f137b8b5854482cabf4b2dad409.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*ejF3NWKn_tkP3RGlVeurrw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Projection of ligand onto chemical feature space</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/4fb46c4602ad02c69dd39f607faaaa68.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*i6c7UH_3wrC0IumUKi6vow.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Measure the euclidean distance of molecule and projection</figcaption></figure><p id="537d" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们可以用代码实现一个简单的函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/30ea725015a39f618f249020d8c9681c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xofeocHrEuRIqkYiVGD9RQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Projecting any molecule onto the chemical feature space</figcaption></figure><p id="3754" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这里，dim_V 是向量空间 V 的维数，由 MP 阈值控制。p 是我们指纹的特征数量，feature_vecs 是一个矩阵，其中列是相关矩阵的特征向量。都相当标准。</p><p id="c930" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">最重要的问题是:<em class="no">我们如何选择ε？</em>这是任意的，事实上，epsilon 可用于调整假阳性/真阳性比率，并生成 ROC 曲线。</p><blockquote class="og oh oi"><p id="7fad" class="lf lg no lh b li lj ju lk ll lm jx ln oj lp lq lr ok lt lu lv ol lx ly lz ma im bi translated">作为ε的默认值<!-- -->,我们将选择它，使得 95%的训练矩阵被分类为绑定(因此在训练集中需要 5%的错误率)。</p></blockquote><p id="2b78" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">RMT 算法到此结束，下面是它在 Python 中的简短代码实现。</p><h1 id="438d" class="np mr it bd ms nq ox ns mv nt oy nv my jz oz ka nb kc pa kd ne kf pb kg nh nz bi translated">5.RMT 算法的 Python 实现</h1><p id="eb5e" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">我们将做一个 sklearn 分类器类型的 OOP 实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/ddd3aed0cc10752639d6862f044c341a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*NInq5VUqTjPcJnajom6xBw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Initiatlising</figcaption></figure><p id="d767" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">threshold_multiple 参数用于通过改变 MP 阈值来扩展或收缩我们的向量空间。然而，我不建议更改这个值，因为 MP 阈值是最佳值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/3cd8bb1fe814569c41e36e94fefa0f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*By_5k-BFEcuE9Y5a8L0UDw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fitting</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/908ca6039ec754640a7aec0931653cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoNlmPI4uwSfHBFCNBQxew.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Prediction</figcaption></figure><p id="11ad" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">就是这样。我们完了。我们现在可以使用我们的算法对数据集进行预测，数据集已经被方便地清理并转换成正确的格式。</p><h1 id="d2dd" class="np mr it bd ms nq ox ns mv nt oy nv my jz oz ka nb kc pa kd ne kf pb kg nh nz bi translated">6.做一个预测</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/cebedf12fb781c02e1d891cee695f9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*H_RvMIbytT93-2fnqtH0ZQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Not bad indeed!</figcaption></figure><p id="701a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">请注意，predict 函数返回一个由 1 和 0 组成的数组，指示绑定或非绑定的预测。因为我们知道测试/验证集只包含绑定器，所以我们可以取 test_preds 的平均值来获得真阳性率。</p><p id="fcc5" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">类似地，由于诱饵组由非结合物组成，decoy_preds 的平均值给出了假阳性率。</p><h1 id="b522" class="np mr it bd ms nq ox ns mv nt oy nv my jz oz ka nb kc pa kd ne kf pb kg nh nz bi translated">7.绘制 ROC 曲线</h1><p id="9056" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">ROC 曲线绘制了假阳性率对真阳性率的曲线。更好的分类器具有非常高的曲线下面积(AUC)。模型中需要一些参数来调整 fp/tp 速率，在我们的例子中，就是参数 epsilon。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/93fa6fa40f1c39aab0379a578485b8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgFYJJPfF4KXtyv9tkOh0w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Code for generating data points for the ROC curve</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/9a4f379b41ecc102826ef4d2de4e94d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*YgGWbch4Jn8FEft-Gs-J2A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">AUC, and code to plot and save the graph</figcaption></figure><p id="b2be" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这是最后一个单元格的输出，这是介绍性的图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35dcdd043b125f8ffe48ef35d0f00506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XePoW4byovFyV87YSmHDVw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">ROC Curve</figcaption></figure><h1 id="e6b7" class="np mr it bd ms nq ox ns mv nt oy nv my jz oz ka nb kc pa kd ne kf pb kg nh nz bi translated">8.下次改进(RMD 算法)</h1><p id="80bb" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">一个显而易见的想法可能是，我们正在检查未知配体与受体的正相关，但<strong class="lh iu">我们没有检查未知配体的负相关</strong>。例如，某个亚结构或部分可能完全破坏配体与结合口袋的结合。</p><p id="5722" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们可以使用上述算法的一个微小的变体来自然地解决这个问题。我们重复 RMT 过程，但是是在一组已知不与目标结合的分子上。直觉是这组分子具有阻碍结合的化学特征，当试图预测未知分子时，我们可以针对这些特征进行选择。</p><blockquote class="og oh oi"><p id="b175" class="lf lg no lh b li lj ju lk ll lm jx ln oj lp lq lr ok lt lu lv ol lx ly lz ma im bi translated">这将是下一篇博客文章的重点，实际上几个月前阿尔法·李和他的同事在 PNAS 的一篇论文中也有描述。</p><p id="450c" class="lf lg no lh b li lj ju lk ll lm jx ln oj lp lq lr ok lt lu lv ol lx ly lz ma im bi translated">这种算法名为随机矩阵判别式，优于 RMT 和所有其他常用方法，如下所示。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/bf0545b567ff07b37bc1e2cedd18bc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8390hWcT8Ksna-wmDryJjw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Not bad at all, to say the least</figcaption></figure><h1 id="fac1" class="np mr it bd ms nq ox ns mv nt oy nv my jz oz ka nb kc pa kd ne kf pb kg nh nz bi translated">9.后续步骤</h1><p id="6f64" class="pw-post-body-paragraph lf lg it lh b li nj ju lk ll nk jx ln lo nl lq lr ls nm lu lv lw nn ly lz ma im bi translated">如果你喜欢阅读这篇文章，和/或想了解下一个算法，请跟随我。</p><p id="02a1" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">请随时通过 LinkedIn 与我联系，并告诉我您是否会在研究/工作中使用这些代码。</p><p id="416d" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在那之前，祝你愉快。</p><p id="b530" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="no">拉克什</em></p></div></div>    
</body>
</html>