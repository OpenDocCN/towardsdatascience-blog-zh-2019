<html>
<head>
<title>Time Series Forecasting — A Getting Started Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测—入门指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-a-getting-started-guide-c435f9fa2216?source=collection_archive---------4-----------------------#2019-05-13">https://towardsdatascience.com/time-series-forecasting-a-getting-started-guide-c435f9fa2216?source=collection_archive---------4-----------------------#2019-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="922b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多元时间序列预测导论</h2></div><h1 id="c06e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="8757" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我开始写这篇文章时，我想解释如何用一个“简单”的时间序列(也就是单变量时间序列)进行预测。然而，我所参与的项目中最具挑战性的部分是预测需要结合多个变量。出于这个原因，我决定让这个指南更接近现实，并使用多元时间序列。</p><h2 id="0ce7" class="lw kj it bd kk lx ly dn ko lz ma dp ks lj mb mc ku ln md me kw lr mf mg ky mh bi translated">让我们先搞清楚一些概念…</h2><p id="8ae1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个<a class="ae mi" href="https://www.analyticsvidhya.com/blog/2018/09/multivariate-time-series-guide-forecasting-modeling-python-codes/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">多变量 TS </strong> </a>是一个具有多个时间相关变量的时间序列。每个变量依赖于它过去的值，但也依赖于其他变量。预测值时会考虑这种依赖性。这些变量可以是内生的，也可以是外生的。在这里，我将重点关注外生变量。</p><p id="4f0d" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated"><strong class="lc iu">外生变量</strong>是其值在模型之外确定并强加于模型的变量。换句话说，影响模型而不受其影响的变量。点击阅读更多关于外生变量<a class="ae mi" href="http://www.businessdictionary.com/definition/exogenous-variable.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="c565" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">许多模型可以用来解决这样的任务，但我们将与<strong class="lc iu"> SARIMAX </strong>合作。SARIMAX 代表带有外生回归量的<a class="ae mi" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html" rel="noopener ugc nofollow" target="_blank">季节性自回归综合移动平均线。</a></p><p id="dbe6" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">一切都好！现在，我们将介绍建立销售预测者可以遵循的步骤。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="2992" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">正如我在之前解释的那样，处理时间序列会带来一些挑战，比如让它保持平稳。如果你想知道更多关于我为什么在 dataframe 上执行一些转换的细节，去看看我以前的帖子。本文的重点是预测方法。</p><p id="ca86" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">在这个机会中，我们有两个文件:一个包含过去销售的数据，另一个包含当地公共假日的信息。可以想象，任务将是通过组合这两个数据集来预测销售额。加载文件后，数据帧看起来像这样:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/6e26403b3ae3bee189117e3f90bb03ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsM4dZ0R9VYLIItoJL61eQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">feriados_df — Holidays dataframe</figcaption></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/25120d3632368c4e3a6b380291de82a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*kYVAZk35EccgGOuMelQTlw.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">ventas_df — past sales dataframe</figcaption></figure><p id="7c07" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">我们的两个数据集的粒度都是在天的级别，也就是说,‘Date’和‘fecha’列都是具有每日频率的索引。如果我们想设置数据集的频率，我们可以运行下面一行:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="e502" class="lw kj it nn b gy nr ns l nt nu">ventas_df = ventas_df.resample(‘D’).mean() # 'D' for daily frequency</span></pre><p id="02a8" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">我们将需要连接这两个数据集，以便用我们拥有的所有数据来拟合我们的模型。' ventas_df '有我们要预测的变量。‘feria dos _ df’包含我们的外生变量。</p><p id="a09d" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">为了让我们的生活更轻松，最好在加入 feriados_df 之前先站起来 ventas_df。我用来使序列更加平稳的方法包括应用对数变换和<a class="ae mi" href="https://otexts.com/fpp2/stationarity.html" rel="noopener ugc nofollow" target="_blank">差分</a>。固定化系列存储在“ts_log_diff”数据帧中。</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="2c41" class="lw kj it nn b gy nr ns l nt nu">test_stationarity(ts_log_diff)</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2259111ab4ace4a9615e8309c09bdc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*IYjyXjfYle1ueFRtKe8OJQ.png"/></div></figure><p id="8d37" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">现在我们可以加入 feriados_df 和 ts_log_diff，这是我们改造后的 ventas_df。</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="01e8" class="lw kj it nn b gy nr ns l nt nu">data_df = ts_log_diff.join(feriados_df, how='left')<br/>data_df.head()</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nw"><img src="../Images/d5d3acd816549351d5f0a904f826caa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIS1H99AVXjweLP41_3tIQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">data_df — joined dataframe</figcaption></figure><p id="1661" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">有时在对熊猫进行一些操作后，我们得到的数据帧会丢失频率。为了解决这个问题，我们可以做到:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="d952" class="lw kj it nn b gy nr ns l nt nu">data_df = data_df.asfreq('D')</span></pre><h1 id="2d97" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">是时候来点特色工程了！</h1><p id="9156" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">人们可以从现有的特性中想出多种创造新特性的方法。为了简单起见，让我们计算下面的列。<br/> -假日 _ 工作日:公共假日是否在工作日<br/> -假日 _ 周末:公共假日是在星期六还是星期天<br/> -是星期几:日期是否在工作日<br/> -是星期几:如果是周末<br/> -在 25 日和 5 日之间:工资通常在这几天发放</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="200f" class="lw kj it nn b gy nr ns l nt nu"><strong class="nn iu">data_df['isweekday']</strong> = [1 if d &gt;= 0 and d &lt;= 4 else 0 for d in data_df.index.dayofweek]<br/><strong class="nn iu">data_df['isweekend']</strong> = [0 if d &gt;= 0 and d &lt;= 4 else 1 for d in data_df.index.dayofweek]<br/><strong class="nn iu">data_df['inbetween25and5']</strong> = [1 if d &gt;= 25 or d &lt;= 5 else 0 for d in data_df.index.day]<br/><strong class="nn iu">data_df['holiday_weekend']</strong> = [1 if (we == 1 and h not in [np.nan]) else 0 for we,h in data_df[['isweekend','Holiday']].values]<br/><strong class="nn iu">data_df['holiday_weekday']</strong> = [1 if (wd == 1 and h not in [np.nan]) else 0 for wd,h in data_df[['isweekday','Holiday']].values]</span></pre><p id="a179" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">让我们对列“Holiday”也应用一次热编码。</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="b8e6" class="lw kj it nn b gy nr ns l nt nu">data_df = pd.get_dummies(data_df, columns=['Holiday'], prefix=['holiday'], dummy_na=True)</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nw"><img src="../Images/3eb17921eea7a7f22c9981ac1b46d49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMx4JIgv6xQWtq0j11CItg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">feature-engineered data_df</figcaption></figure><h2 id="60e0" class="lw kj it bd kk lx ly dn ko lz ma dp ks lj mb mc ku ln md me kw lr mf mg ky mh bi translated">请我们已经可以预测了！？</h2><p id="4963" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">亚斯。有点……首先，我们必须将数据分成训练和测试数据。你知道，为了良好的实践和避免过度拟合的东西；)</p><p id="51bc" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">我们不能仅仅使用 k-folding 方法来将我们的数据集分成训练和测试。这是因为对于 TS，我们必须考虑时间因素。我们可以应用一些技术，其中包括:</p><ol class=""><li id="d710" class="nx ny it lc b ld mj lg mk lj nz ln oa lr ob lv oc od oe of bi translated"><strong class="lc iu">训练测试分割</strong>尊重观察的时间顺序。</li><li id="5c88" class="nx ny it lc b ld og lg oh lj oi ln oj lr ok lv oc od oe of bi translated"><strong class="lc iu">多重训练测试分割</strong>尊重观察的时间顺序。</li><li id="e366" class="nx ny it lc b ld og lg oh lj oi ln oj lr ok lv oc od oe of bi translated"><strong class="lc iu">前推验证</strong>，每次收到新数据时更新一个模型。</li></ol><p id="27db" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">在这种情况下，将使用 1 号。从系列开始到 2019 年 2 月的数据点将用作训练数据。其余的数据点将用于测试。</p><h1 id="b613" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">生成和可视化预测</h1><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="a4be" class="lw kj it nn b gy nr ns l nt nu">result_daily = my_train_sarimax(data_df[:'2019-02-28'], i_order=(2,1,2), i_freq='D', i_seasonorder=(2, 1, 1, 12))</span></pre><p id="355a" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">在上面的行中，训练数据点' data _ df[:' 2019–02–28 ']被传递给函数。值得注意的是，dataframe 中的第一列必须包含要预测的值。其余列是我们的外生变量(即假期和工程特征)。数据帧的频率在“i_freq”参数中给出。参数“i_order”和“i_seasonorder”指定训练模型所需的参数，请查看 SARIMAX 的文档以了解有关这些参数的更多信息。</p><p id="9a80" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">my_train_sarimax()函数定义如下。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ol"><img src="../Images/8d8e04c580db25dee3077d48ee543168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1WY1npnAvHN9wsAb-kfMQ.png"/></div></div></figure><p id="744e" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">现在是时候验证我们的预测了。为此，我们将使用一个函数来检索预测值，然后将它们与测试数据点中的真实值进行比较。</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="94b9" class="lw kj it nn b gy nr ns l nt nu">ypred, ytruth = compare_pred_vs_real(result_daily, data_df, ‘2019–03–01’, exog_validation=data_df[‘2019–03–01’:].iloc[:,1:])</span></pre><p id="ef36" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">值得一提的是，必须向模型提供要预测的时间范围的外生变量。请记住，这些是模型外部的变量，它需要这些变量来进行预测。</p><p id="67bd" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">如果我们查看“compare_pred_vs_real()”定义，我们可以看到预测是使用“get_prediction()”函数进行的。可以通过使用“预测平均值”方法来提取这些值。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi om"><img src="../Images/82aac9909b177006cc67cfb34018b96e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQEai1xPe_ovv3PdFz4ylg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Performance of our model</figcaption></figure><p id="6b3b" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">我们可以说我们的模型在 MSE 和 RMSE 方面有相当不错的表现。让我们看看我们的预测与实际售出的商品数量<em class="on">相差有多远。</em></p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="00f9" class="lw kj it nn b gy nr ns l nt nu">ypred - ytruth</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/0cc750da73876f80bb69ead3a4acdad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*UvSRTGvne6ZY58yc432oIQ.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">predictions minus true values</figcaption></figure><p id="ad58" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">但是，等等…为什么我们会看到十进制数值？出售的商品数量必须是整数！</p><h1 id="77a5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">预测的(反)转换</h1><p id="8869" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请记住，我们进行了对数转换，然后对数据集应用了差分。为了看到我们的模型估计的实际销售数字，我们必须恢复这些转换。</p><p id="afd6" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">由于差异操作，TS 中的原始第一个日期丢失。我们需要从“data_df”中填充缺失的值。接下来，我们需要将预测之前的所有日期<em class="on">追加到‘y _ pred’中。这些日期也来自‘data _ df’。完成所有这些后，我们可以用 cumsum()恢复差异，然后应用 exp()恢复对数转换。</em></p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="c904" class="lw kj it nn b gy nr ns l nt nu">#create a series with the dates that were dropped with differencing<br/>restore_first_values = pd.Series([6.008813], index=[pd.to_datetime(‘2014–01–01’)])</span><span id="d258" class="lw kj it nn b gy op ns l nt nu">#get the values that the prediction does not have<br/>missing_part = data_df[‘cantidad’][:’2019–02–28']<br/>rebuilt = restore_first_values.append(missing_part).append(ypred)</span><span id="6eca" class="lw kj it nn b gy op ns l nt nu">#revert differencing:<br/>rebuilt = rebuilt.cumsum()</span><span id="f663" class="lw kj it nn b gy op ns l nt nu">#revert log transformation:<br/>rebuilt = np.exp(rebuilt).round() # apply round() to have integers</span></pre><p id="71b7" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">我们终于可以看到我们的预测值，并与实际值进行比较。耶！</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="148f" class="lw kj it nn b gy nr ns l nt nu"># Check how far were the predictions from the actual values<br/>rebuilt['2019-03-01':] - ventas_df['cantidad']['2019-03-01':]</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/39e8b66af00bb4791153607643a1852d.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*NQ-_qFAH5l5-NP6X2LbJFw.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Looks like we got it right most of the time :)</figcaption></figure><h1 id="1941" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">最终意见</h1><p id="985e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请记住，可以使用许多方法来实现 TS 中的平稳性。此外，SARIMAX 不是唯一一个对时间序列进行预测的模型，进一步的参数调整有助于提高模型的准确性。</p><p id="57d8" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">请随意在我的 github <a class="ae mi" href="https://github.com/osbarge/salesforecaster" rel="noopener ugc nofollow" target="_blank"> repo </a>上查看该指南的全部代码。</p><p id="c687" class="pw-post-body-paragraph la lb it lc b ld mj ju lf lg mk jx li lj ml ll lm ln mm lp lq lr mn lt lu lv im bi translated">感谢阅读！</p></div></div>    
</body>
</html>