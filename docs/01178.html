<html>
<head>
<title>SQL Joins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 连接</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-joins-55cbbffb2002?source=collection_archive---------8-----------------------#2019-02-23">https://towardsdatascience.com/sql-joins-55cbbffb2002?source=collection_archive---------8-----------------------#2019-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用 pandas 数据框架展示不同类型的 SQL 连接</h2></div><p id="afa3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你以前从未使用过 SQL，它可能会有点吓人。您会听到人们谈论表之间的复杂连接，但不知道他们在谈论什么。在过去的几年里，我已经教了很多人如何编写 SQL 查询，我想我可以在互联网上与大众分享一些知识。</p><h1 id="c420" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">首先，什么是 join？</h1><p id="ad23" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">在关系数据库中，如果表共享一个键，它们可以相互连接。主键是一个<strong class="kh ir">不能在一个表中</strong>重复的值。这意味着一个值在主键列中只能出现一次。该键可以作为外键存在于另一个创建关系的表中。外键<strong class="kh ir">在一个表中可以有重复的实例。</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/d7e59c31d6ccc1d199ff52dce78ca721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H76__kl10y-FO6uiD1pyA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">ERD example for relationships below</figcaption></figure><h2 id="2d46" class="mo lc iq bd ld mp mq dn lh mr ms dp ll ko mt mu ln ks mv mw lp kw mx my lr mz bi translated">表关系</h2><p id="16ae" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">表之间的关系类型有一对一、一对多和多对多。</p><p id="7c44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">一对一</strong>类似于拥有一张顾客表和一张 SSN 表。一个客户只能有一个 SSN，一个 SSN 只能分配给一个人。Customer 表上的主键是 CustomerId，它是 SSN 表上的外键。</p><p id="3d51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">一对多</strong>就像有一个客户表和一个订单表。一个客户可以有多个订单，但是这些订单只能与一个客户相关联。在本例中，主键和外键是相同的。</p><p id="efc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">多对多</strong>看起来就像有一个订单表和一个产品表。一个订单可以包含许多产品，一个产品可以包含在许多订单中。这些关系通常会有另一个表，您需要使用该表将主 Order 表和 Product 表连接在一起。您将在上面的图表中看到，该表名为 Product_Order。ProductId 和 OrderId 都是 Product_Order 表上的外键，但它们是各自表中的主键。</p><h1 id="5761" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">连接的类型</h1><p id="e7d1" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">有 4 种类型的联接:内联接、左联接、右联接和全外联接。我将使用上面客户和订单表的一对多示例，通过一个非常简单的 pandas 数据框架向您展示这些内容，但是我还将展示 SQL 语法。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi na"><img src="../Images/8beba5b9d8185a1e75a13a44e5a0b13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2H8Fha64eL0CaIwDLhiEUQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Using python pandas to create dataframes</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nb"><img src="../Images/c0a148351527ccdd106fec79d5b68c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsakGwQvPMfYgYc-QpKVGQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Customer table</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/460c1c7ccb47b86a4ddaa144a68393e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*kxVlGEfqWTFKrJU8vCW_kw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Order table</figcaption></figure><p id="5d2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提醒一下，CustomerId 是 Customer 表的主键，也是 Order 表上的外键。OrderId 是订单表上的主键。</p><h2 id="03fa" class="mo lc iq bd ld mp mq dn lh mr ms dp ll ko mt mu ln ks mv mw lp kw mx my lr mz bi translated">内部连接</h2><p id="9205" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">内部联接将返回两个表中都存在所联接字段的值的行。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e7f471b8933a7d6614a13b9dbbbf2df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*PAkdz6U8Vg2GAO9VbpLbWQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Image from dofactory</figcaption></figure><p id="80f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 SQL 中，您可以使用 JOIN，因为它默认为内部连接。或者可以包含内部联接。</p><p id="e08c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 SQL 中，这可以写成:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="d663" class="mo lc iq nf b gy nj nk l nl nm">SELECT *<br/>FROM Customer<br/>JOIN Order ON Customer.CustomerId = Order.CustomerId;</span></pre><p id="54cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Pandas 中，你可以使用合并功能。</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="2b84" class="mo lc iq nf b gy nj nk l nl nm">pd.merge(Customer, Order, how='inner', on='CustomerId')</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nn"><img src="../Images/6c87a403ef3df02c077bf3bd926f5067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BOyYHgnsdlltCwETgk6tw.png"/></div></div></figure><p id="5293" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Order 表中存在的唯一 CustomerId 值是[1，2，4]，因此在内部连接的结果中，CustomerId [3，5]不返回。</p><h2 id="4317" class="mo lc iq bd ld mp mq dn lh mr ms dp ll ko mt mu ln ks mv mw lp kw mx my lr mz bi translated">左连接</h2><p id="c2e8" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">左连接将返回第一个表(在本例中为 Customer)中的所有行，并且只填充第二个表中存在键值的字段。它将在第二个表中不存在的地方返回 NULLs(或者 python 中的 NaNs)。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi no"><img src="../Images/aa19e84bdfc57c18cdc9baa16e8b1692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Joyw5oaVt5i4RNXSdimOfA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Image from dofactory</figcaption></figure><p id="e789" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 SQL 中，这将被写成:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="9291" class="mo lc iq nf b gy nj nk l nl nm">SELECT *<br/>FROM Customer<br/>LEFT JOIN Order ON Customer.CustomerId = Order.CustomerId;</span></pre><p id="42e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于熊猫来说:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="2292" class="mo lc iq nf b gy nj nk l nl nm">pd.merge(Customer, Order, how='left', on='CustomerId')</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi np"><img src="../Images/291045975843ed9a187a1c91ba254d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AD0AbxUYw1TbPDQZ6gGQqA.png"/></div></div></figure><p id="c2da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这个连接，我们可以看到所有的 customerid[1，2，3，4，5]，但是这些 customerid 有重复，因为它们有多个订单。CustomerId [3，5]没有任何订单，因此 OrderId 和 OrderDate 返回 NaN。</p><h2 id="b964" class="mo lc iq bd ld mp mq dn lh mr ms dp ll ko mt mu ln ks mv mw lp kw mx my lr mz bi translated">右连接</h2><p id="5ca4" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">右连接将返回写入的第二个表中的所有行，在这个实例中排序，并且只填充存在键值的第一个表的字段。它将在第一个表中不存在的地方返回 NULLs(或者 python 中的 NaNs)。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ce5ae87e68b9e272dc46eb04d2d0d5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LcAKBtRKMo25nYLief4m7A.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Image from dofactory</figcaption></figure><p id="eb25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 SQL 中，这将被写成:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="844b" class="mo lc iq nf b gy nj nk l nl nm">SELECT *<br/>FROM Customer<br/>RIGHT JOIN Order ON Customer.CustomerId = Order.CustomerId;</span></pre><p id="1131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于熊猫来说:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="936a" class="mo lc iq nf b gy nj nk l nl nm">pd.merge(Customer, Order, how='right', on='CustomerId')</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nr"><img src="../Images/c64d14c60a3ab6e4387d1b6a6dde0025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PX1TStjw1SSIhbcHKk0PEQ.png"/></div></div></figure><p id="d5b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这个连接，我们可以看到 Order 表中的所有订单，但是由于 CustomerId 6 在 Customer 表中不存在，所以我们得到了 Name、Address 和 Phone 的 NaN 值。</p><h2 id="fed5" class="mo lc iq bd ld mp mq dn lh mr ms dp ll ko mt mu ln ks mv mw lp kw mx my lr mz bi translated">完全外部连接</h2><p id="1840" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">您还会听到这种称为外部连接(没有完整连接)的方法，因为您不必在编写的 SQL 中包含完整连接。</p><p id="b3af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将返回所有行，无论您要联接的字段中的值是否存在于两个表中。如果该值在另一个表中不存在，则该表的字段将返回空值。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5a1057b5e17d853bc95690e955bce6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*kfogmEJ1IsgkTgC225Scfw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Image from dofactory</figcaption></figure><p id="4cd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 SQL 中，这将被写成:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="c70d" class="mo lc iq nf b gy nj nk l nl nm">SELECT *<br/>FROM Customer<br/>OUTER JOIN Order ON a.col1 = b.col1;</span></pre><p id="6ff9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于熊猫来说:</p><pre class="lz ma mb mc gt ne nf ng nh aw ni bi"><span id="4d20" class="mo lc iq nf b gy nj nk l nl nm">pd.merge(Customer, Order, how='outer', on='CustomerId')</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nr"><img src="../Images/7bf64570d98afb8fdb02356bbfb318b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9ApNjMtgICM1y5MT7ZooQ.png"/></div></div></figure><p id="89f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该联接的结果显示所有 CustomerId 和所有 OrderId。其中 CustomerId 为[3，5]，订单字段为 NaN，OrderId 为 6，客户字段为 NaN。</p><h1 id="b690" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">结论</h1><p id="eeb2" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">在 SQL 和 Python 中，使用 pandas dataframes 用一个表中的一些数据补充另一个表中的数据，连接确实非常有用。在返回 NaN 或 NULL 值时必须小心，尤其是在向可能不允许 NULL 值的新表中插入数据时。理解要连接的表之间的关系也很重要，这样就不会返回不期望的结果。</p><p id="ef11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这些信息是有帮助的，我很乐意连接并回答您可能有关于 SQL 查询的任何问题！</p><p id="a818" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我在我写的 SQL 例子中使用了显式连接，但是有些人认为隐式连接也可以。根据我的经验，使用显式连接总是更安全，因为您确切地知道结果会是什么。隐式连接并不总是如你所愿。</p></div></div>    
</body>
</html>