<html>
<head>
<title>Pre-Processing in OCR!!!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OCR 中的预处理！！！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pre-processing-in-ocr-fc231c6035a7?source=collection_archive---------0-----------------------#2019-03-25">https://towardsdatascience.com/pre-processing-in-ocr-fc231c6035a7?source=collection_archive---------0-----------------------#2019-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c71f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">OCR 系统最广泛使用的预处理技术的基本解释。</h2></div><p id="c250" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎来到关于 OCR 系统工作的<strong class="kh ir">系列<strong class="kh ir"> <em class="lb"> </em> </strong>第二部分 </strong>。在<a class="ae lc" href="https://medium.com/@susmithreddyvedere/what-is-ocr-7d46dc419eb9" rel="noopener"> <em class="lb">之前的文章</em> </a>中，我们简要讨论了 OCR 系统的不同阶段。</p><p id="50b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 OCR 的所有阶段中，<strong class="kh ir"> <em class="lb">预处理</em> </strong>和<strong class="kh ir"> <em class="lb">分割</em> </strong>是最重要的阶段，因为 OCR 系统的准确性很大程度上取决于<em class="lb">预处理</em>和<em class="lb">分割</em>的执行情况。因此，在这里我们将学习一些最基本和最常用的图像预处理技术。</p><h2 id="4011" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">我们走吧…</h2><p id="9887" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated"><em class="lb">预处理</em>阶段的主要目的是<strong class="kh ir"> <em class="lb">使 OCR 系统尽可能容易地</em> </strong>从背景中辨别出字符/单词。</p><p id="a63e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些最基本和最重要的<em class="lb"> </em> <strong class="kh ir"> <em class="lb">预处理</em> </strong>技术有</p><p id="8876" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 1)二值化</strong> <br/> <strong class="kh ir"> 2) </strong> <strong class="kh ir">倾斜校正</strong> <br/> <strong class="kh ir"> 3) </strong> <strong class="kh ir">去噪</strong> <br/> <strong class="kh ir"> 4) </strong> <strong class="kh ir">细化和骨架化</strong></p><p id="43b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在讨论这些技术之前，让我们先了解一下 OCR 系统是如何理解图像的。对于 OCR 系统，<em class="lb">图像</em>是多维数组(如果图像是灰度(或)二进制，则为 2D 数组，如果图像是彩色的，则为 3D 数组)。矩阵中的每个单元称为一个像素，它可以存储 8 位整数，这意味着像素范围是 0-255。</p><div class="mb mc md me gt ab cb"><figure class="mf mg mh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/eaaaaa0db641d3cca037a88867d65cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*h1ymqblIpie7VE4DixE4Ow.png"/></div></figure><figure class="mf mg ms mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/b19cb7255dd6c06f406382c853cada9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*8MyklIr2SZI38xVpXkl5GQ.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk mx di my mz">Internal Representation of RGB image with Red, Green and Blue Channels. <strong class="bd na">Source: left image from </strong><a class="ae lc" href="https://www.semanticscholar.org/paper/Content-Based-Image-Retrieval-using-Color-Brunda-Chaitra/04ecb35b02e6060916bf05d5f56a925eff0e332e" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">semantics scholar</strong></a><strong class="bd na">, right image from </strong><a class="ae lc" href="https://www.researchgate.net/figure/A-three-dimensional-RGB-matrix-Each-layer-of-the-matrix-is-a-two-dimensional-matrix_fig6_267210444" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">researchgate</strong></a><strong class="bd na">.</strong></figcaption></figure></div><figure class="mb mc md me gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nb"><img src="../Images/3131a6dad851195883d735856f76174a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fzya3mkn5pKPDL6AuexwnA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Internal Representation of Grayscale image. It has only one channel. <strong class="bd na">Source: </strong><a class="ae lc" href="https://ekababisong.org/gcp-ml-seminar/cnn/" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">ekababisong.org</strong></a></figcaption></figure><p id="91fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们逐一检查上面提到的每一种预处理技术</p><ol class=""><li id="82b1" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated"><strong class="kh ir"> <em class="lb">二值化:</em> </strong>通俗地说<em class="lb">二值化</em>就是将彩色图像转换成只由黑白像素组成的图像(黑色像素值=0，白色像素值=255)。作为一个基本规则，这可以通过固定一个<em class="lb">阈值</em>来实现(通常阈值=127，因为它正好是像素范围 0–255 的一半)。如果像素值大于阈值，则认为是白色像素，否则认为是黑色像素。</li></ol><figure class="mb mc md me gt mg gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/aae4009e74a82dc07900b335b92adfa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*mRQqWN7Ctu9Ahga4lZH05A.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Binarization conditions. <strong class="bd na">Source: Image by author</strong></figcaption></figure><p id="6c9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这种策略并不总是给我们想要的结果。在图像中光照条件不均匀的情况下，这种方法会失败。</p><figure class="mb mc md me gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nm"><img src="../Images/ae4898ca5a88f6e4f5cabd5bb2c1e525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTMCWiv4WZRlIpZSs5kupw.jpeg"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Binarization using a threshold on the image captured under non-uniform lighting. <strong class="bd na">Source: left image from this </strong><a class="ae lc" href="https://www.researchgate.net/post/How_to_have_uniform_intensity_on_non-uniform_illuminated_image" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">post</strong></a><strong class="bd na"> and right image binarised by author.</strong></figcaption></figure><p id="a588" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，二值化的关键部分是确定<strong class="kh ir"> <em class="lb">阈值</em> </strong>。这可以通过使用各种技术来完成。</p><p id="a2ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">→ <em class="lb">局部最大最小值法</em>:</p><figure class="mb mc md me gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nn"><img src="../Images/2480cea0bc3cbb37eb32513bc1ff9fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N2Csg0aJQUaJEx-DJC-Yw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Imax= Maximum pixel value in the image, Imin= Minimum pixel value in the image, E = Constant value <strong class="bd na">Source: Reference [2]</strong></figcaption></figure><p id="4531" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> C(i，j) </em>是图像中局部<strong class="kh ir"> <em class="lb">定义尺寸</em> </strong>的<em class="lb">阈值</em>(如 10x10 尺寸的零件)。使用这种策略，我们将为图像的不同部分设置不同的阈值，这取决于周围的光照条件，但是过渡并不平滑。</p><p id="b498" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">→ <em class="lb"> Otsu 的二值化</em>:该方法考虑到整个图像的各种特征(如光照条件、对比度、锐度等)，为整个图像给出一个<em class="lb">阈值，该阈值用于二值化图像。<br/>这可以通过以下方式使用 OpenCV python 来实现:</em></p><pre class="mb mc md me gt no np nq nr aw ns bi"><span id="2104" class="ld le iq np b gy nt nu l nv nw">ret, imgf = cv2.threshold(img, 0, 255,cv2.THRESH_BINARY,cv2.THRESH_OTSU) #imgf contains Binary image</span></pre><p id="d180" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">-&gt; <em class="lb">自适应阈值处理</em>:这种方法根据图像的局部和邻居的特征，为图像的一小部分给出一个阈值，也就是说，对于整个图像没有单一的固定阈值，但是图像的每一小部分根据局部都有不同的阈值，并且还提供平滑过渡。</p><pre class="mb mc md me gt no np nq nr aw ns bi"><span id="e5bd" class="ld le iq np b gy nt nu l nv nw">imgf = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2) #imgf contains Binary image</span></pre><p id="21b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<strong class="kh ir"> <em class="lb">歪斜校正:</em> </strong>扫描文件时，有时可能会出现轻微歪斜(图像与水平面成一定角度)。从扫描图像中提取信息时，检测&amp;校正倾斜是至关重要的。<br/>多种技术用于倾斜校正。</p><p id="2b88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">→投影轮廓法<br/> →霍夫变换法<br/> →背线法<br/> →扫描线法</p><p id="e410" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，<em class="lb">投影轮廓</em>方法是确定文件倾斜的最简单、最容易和最广泛使用的方法。</p><p id="4227" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个方法中，首先，我们将二进制图像，然后</p><ul class=""><li id="88c7" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nx ni nj nk bi translated">将其水平投影(取图像矩阵各行的像素总和)以获得图像高度的像素直方图，即每行的前景像素计数。</li><li id="41a2" class="nc nd iq kh b ki ny kl nz ko oa ks ob kw oc la nx ni nj nk bi translated">现在，图像以各种角度旋转(以称为<em class="lb"> Delta </em>的小角度间隔)，并且将计算峰值之间的差异(<em class="lb">方差</em>也可以用作度量之一)。找到峰值之间的<strong class="kh ir">最大</strong>差(或<em class="lb">方差</em>)的角度，该对应角度将是图像的<em class="lb">倾斜角度</em>。</li><li id="d12f" class="nc nd iq kh b ki ny kl nz ko oa ks ob kw oc la nx ni nj nk bi translated">找到歪斜角后，我们可以通过在歪斜的<strong class="kh ir"> <em class="lb">相反方向</em> </strong>旋转图像一个等于歪斜角的角度来校正歪斜。</li></ul><figure class="mb mc md me gt mg gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5de8fd25a8b7d06e266ff09137ae7ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/1*b76nvNcSUNwMnBdm1rd7WQ.gif"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Correcting skew using the Projection Profile method. <strong class="bd na">Source: Reference[1]</strong></figcaption></figure><pre class="mb mc md me gt no np nq nr aw ns bi"><span id="940b" class="ld le iq np b gy nt nu l nv nw">import sys<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>from PIL import Image as im<br/>from scipy.ndimage import interpolation as inter</span><span id="ee01" class="ld le iq np b gy oe nu l nv nw">input_file = sys.argv[1]</span><span id="32d7" class="ld le iq np b gy oe nu l nv nw">img = im.open(input_file)</span><span id="93d7" class="ld le iq np b gy oe nu l nv nw"># convert to binary<br/>wd, ht = img.size<br/>pix = np.array(img.convert('1').getdata(), np.uint8)<br/>bin_img = 1 - (pix.reshape((ht, wd)) / 255.0)<br/>plt.imshow(bin_img, cmap='gray')<br/>plt.savefig('binary.png')</span><span id="7e89" class="ld le iq np b gy oe nu l nv nw">def find_score(arr, angle):<br/>    data = inter.rotate(arr, angle, reshape=False, order=0)<br/>    hist = np.sum(data, axis=1)<br/>    score = np.sum((hist[1:] - hist[:-1]) ** 2)<br/>    return hist, score</span><span id="5694" class="ld le iq np b gy oe nu l nv nw">delta = 1<br/>limit = 5<br/>angles = np.arange(-limit, limit+delta, delta)<br/>scores = []<br/>for angle in angles:<br/>    hist, score = find_score(bin_img, angle)<br/>    scores.append(score)</span><span id="3bed" class="ld le iq np b gy oe nu l nv nw">best_score = max(scores)<br/>best_angle = angles[scores.index(best_score)]<br/>print('Best angle: {}'.formate(best_angle))</span><span id="d8c8" class="ld le iq np b gy oe nu l nv nw"># correct skew<br/>data = inter.rotate(bin_img, best_angle, reshape=False, order=0)<br/>img = im.fromarray((255 * data).astype("uint8")).convert("RGB")<br/>img.save('skew_corrected.png')</span></pre><figure class="mb mc md me gt mg gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2ae25be1460c8fbfa406e9fdda1b6b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DrSYdqDG_BPQOeuDHiG5zQ.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Skew Correction. <strong class="bd na">Source: </strong><a class="ae lc" href="https://www.pyimagesearch.com/" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">pyimagesearch.com</strong></a><strong class="bd na"> by </strong><a class="ae lc" href="https://www.pyimagesearch.com/author/adrian/" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">Adrian Rosebrock</strong></a></figcaption></figure><p id="9d02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<strong class="kh ir"> <em class="lb">噪声去除:</em></strong><em class="lb">噪声去除</em>阶段的主要目的是通过去除比图像其余部分具有更高亮度的小点/小块来平滑图像。可以对<em class="lb">彩色</em>和<em class="lb">二进制图像</em>进行噪声去除。<br/>使用 OpenCV<em class="lb">fastNlMeansDenoisingColored</em>函数<em class="lb">进行去噪的一种方法。</em></p><pre class="mb mc md me gt no np nq nr aw ns bi"><span id="72d2" class="ld le iq np b gy nt nu l nv nw">import numpy as np <br/>import cv2 <br/>from matplotlib import pyplot as plt <br/># Reading image from folder where it is stored <br/>img = cv2.imread('bear.png') <br/># denoising of image saving it into dst image <br/>dst = cv2.fastNlMeansDenoisingColored(img, None, 10, 10, 7, 15) <br/># Plotting of source and destination image <br/>plt.subplot(121), plt.imshow(img) <br/>plt.subplot(122), plt.imshow(dst) <br/>plt.show()</span></pre><figure class="mb mc md me gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi og"><img src="../Images/0bc0ca0d19fd086c6f2c8504c4013b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crnrIqenyAUPs1IbNuprqg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Smoothening and Denoising of image. <strong class="bd na">Source: Reference [4]</strong></figcaption></figure><p id="ff2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多关于<em class="lb">去噪&amp;图像平滑</em>的技巧可以在<a class="ae lc" rel="noopener" target="_blank" href="/image-filters-in-python-26ee938e57d2"> <strong class="kh ir"> <em class="lb">这篇</em> </strong> </a>的精彩文章中找到</p><p id="3a08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<strong class="kh ir"> <em class="lb">细化和骨架化</em> </strong>:这是一个可选的预处理任务，取决于使用 OCR 的上下文。<br/> →如果我们对打印文本使用 OCR 系统，则无需执行此任务，因为打印文本始终具有统一的笔画宽度。<br/> →如果我们使用 OCR 系统处理手写文本，则必须执行此任务<em class="lb">，因为不同的书写者有不同的书写风格，因此笔画宽度也不同</em>。所以为了使笔画的宽度一致，我们必须执行<em class="lb">细化和</em>。</p><p id="e77c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以通过以下方式使用 OpenCV 来实现</p><pre class="mb mc md me gt no np nq nr aw ns bi"><span id="01b5" class="ld le iq np b gy nt nu l nv nw">import cv2<br/>import numpy as np</span><span id="2023" class="ld le iq np b gy oe nu l nv nw">img = cv2.imread('j.png',0)<br/>kernel = np.ones((5,5),np.uint8)<br/>erosion = cv2.erode(img,kernel,iterations = 1)</span></pre><p id="3e01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，图像的<em class="lb">细化</em>取决于内核大小和迭代次数。</p><figure class="mb mc md me gt mg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/5a1351ff8a03af0d201532465c3cc43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*GOMy8rbbwlP5Zy4FD-Oltg.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Before and After Thinning and Skeletonization. <strong class="bd na">Source: </strong><a class="ae lc" href="https://campus.datacamp.com/courses/image-processing-in-python/filters-contrast-transformation-and-morphology?ex=13" rel="noopener ugc nofollow" target="_blank"><strong class="bd na">datacamp</strong></a></figcaption></figure><p id="057d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们看到了一些基本的和最广泛使用的<strong class="kh ir"> <em class="lb">预处理</em> </strong>技术，这让我们对 OCR 系统内部发生的事情有了一个基本的了解。下图是<strong class="kh ir"> <em class="lb">预处理</em> </strong>工作流程的一个例子。</p><figure class="mb mc md me gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oi"><img src="../Images/d61da0ac99e268bf67a77dec380ca9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yajazz-a5PwbFOYS9w7nlg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk"><strong class="bd na">Source: Reference [5]</strong></figcaption></figure><p id="2cfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你已经了解了在 OCR 中<strong class="kh ir"> <em class="lb">预处理</em> </strong>是如何执行的。</p><h1 id="b029" class="oj le iq bd lf ok ol om li on oo op ll jw oq jx lo jz or ka lr kc os kd lu ot bi translated">延伸阅读:</h1><p id="b56e" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">在<a class="ae lc" href="https://medium.com/@susmithreddyvedere/segmentation-in-ocr-10de176cf373" rel="noopener"><strong class="kh ir"><em class="lb">part-III</em></strong></a>中，我们将看到 OCR 系统所使用的<strong class="kh ir"><em class="lb"/></strong>分割技术。</p><p id="8740" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快乐学习！！！！</p><p id="5f0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎任何疑问、建议和更正。😃</p><h1 id="480d" class="oj le iq bd lf ok ol om li on oo op ll jw oq jx lo jz or ka lr kc os kd lu ot bi translated">参考资料:</h1><p id="cec8" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">[1] Shafii，m .，Sid-Ahmed，m .基于轴平行包围盒的倾斜检测和校正。<em class="lb">伊达尔</em> <strong class="kh ir"> 18，</strong>59–71(2015)。<a class="ae lc" href="https://doi.org/10.1007/s10032-014-0230-y" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1007/s10032-014-0230-y</a></p><p id="8be9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2] Jyotsna，S. Chauhan，E. Sharma 和 A. Doegar，“退化文档图像的二值化技术——综述”，<em class="lb"> 2016 年第五届可靠性、信息通信技术和优化国际会议(趋势和未来方向)(I rito)</em>，诺伊达，2016，第 163–166 页，doi:10.11109/I rito . 20136106</p><p id="b11e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3] A. Papandreou 和 B. Gatos，“一种基于垂直投影的新型倾斜检测技术”，<em class="lb"> 2011 年国际文档分析与识别会议</em>，北京，2011，第 384–388 页，doi: 10.1109/ICDAR.2011.85</p><p id="46fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[4] K. Lin，T. H. Li，S. Liu 和 G. Li，“使用噪声域适应和注意力生成对抗网络的真实照片去噪”，<em class="lb"> 2019 年 IEEE/CVF 计算机视觉和模式识别研讨会会议(CVPRW) </em>，美国加利福尼亚州长滩，2019 年，第 1717-1721 页，doi: 10.1109/CVPRW.2019.00221</p><p id="388c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[5] Choudhary，Amit &amp; Rishi，Rahul &amp; Savita，Ahlawat。(2013).一种新的脱机手写草书字符分割方法。计算机科学。17.88–95.10.1016 年 5 月 13 日</p></div></div>    
</body>
</html>