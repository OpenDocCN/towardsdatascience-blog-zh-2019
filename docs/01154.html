<html>
<head>
<title>Getting Started with Reinforcement Learning and Open AI Gym</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习入门，开放 AI 健身房</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-reinforcement-learning-and-open-ai-gym-c289aca874f?source=collection_archive---------2-----------------------#2019-02-22">https://towardsdatascience.com/getting-started-with-reinforcement-learning-and-open-ai-gym-c289aca874f?source=collection_archive---------2-----------------------#2019-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/35995e81464f001adfdb8c792f17d058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DrKc7wEs4O5q6mwUCy0dCg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="72b3" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">使用 Q-learning 解决山地汽车环境。</h2></div><p id="9025" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是强化学习和开放 AI 健身房系列文章的第三篇。第一部可以在这里找到<a class="ae lp" rel="noopener" target="_blank" href="/the-other-type-of-machine-learning-97ab81306ce9">，而第二部可以在这里</a>找到<a class="ae lp" rel="noopener" target="_blank" href="/how-to-install-openai-gym-in-a-windows-environment-338969e24d30">。</a></p><h1 id="6f8e" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">介绍</h1><p id="eb1c" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">强化学习(RL)是机器学习的一个分支，它通过与反馈可能延迟的环境进行交互来处理学习。</p><p id="cbd0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然 RL 是一个非常强大的工具，已经成功地应用于从优化化学反应到教计算机玩视频游戏的各种问题，但由于缺乏有趣和具有挑战性的实验环境，它在历史上一直很难开始。</p><p id="f4a9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是 OpenAI 健身房的用武之地。</p><p id="e244" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">OpenAI Gym 是一个 Python 包，包含一系列 RL 环境，从简单的“玩具”环境到更具挑战性的环境，包括模拟机器人环境和 Atari 视频游戏环境。</p><p id="831f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它的开发目标是成为 RL 研究的标准化环境和基准。</p><p id="3c91" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本文中，我们将使用 OpenAI Gym 山地汽车环境来演示如何开始使用这个令人兴奋的工具，并展示如何使用 Q-learning 来解决这个问题。</p><p id="4c31" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">本教程假设您的计算机上已经安装了 OpenAI Gym。如果你还没有这样做，安装说明可以在<a class="ae lp" rel="noopener" target="_blank" href="/how-to-install-openai-gym-in-a-windows-environment-338969e24d30">这里</a>找到 Windows，在<a class="ae lp" href="https://github.com/openai/gym#installation" rel="noopener ugc nofollow" target="_blank">这里</a>找到 Mac 或 Linux。</p><h1 id="3e05" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">山地汽车问题</h1><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/05a20b172a26a2abd3d6f496ed86da49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*JjBfoFrKCoBxlraVZaEshw.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">The OpenAI Gym Mountain Car environment</figcaption></figure><p id="0d76" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在 OpenAI 健身房网站上，对山地车问题描述如下:</p><blockquote class="mw mx my"><p id="e2a9" class="kt ku mz kv b kw kx kf ky kz la ki lb na ld le lf nb lh li lj nc ll lm ln lo im bi translated"><em class="je">汽车在一维轨道上，定位在两座“山”之间。目标是开车上右边的山；然而，这辆车的引擎不够强劲，不足以单程爬上这座山。所以，成功的唯一方法就是来回开车造势。</em></p></blockquote><p id="c860" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">汽车在任何时间点的状态都由一个包含其水平位置和速度的向量给出。汽车在两山之间的山谷底部(大约在-0.5 的位置)静止不动地开始每一集，当汽车到达旗子(位置&gt; 0.5)或移动 200 次后，该集结束。</p><p id="6985" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在每次移动时，汽车有三个可用的动作:向左推、向右推或什么都不做，每次移动(包括什么都不做)都要罚 1 个单位。这意味着，除非他们能在不到 200 步的时间内找到爬山的方法，否则他们总的“奖励”将是-200 个单位。</p><p id="cb1b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从这个环境开始，按如下方式导入并初始化它:</p><pre class="mo mp mq mr gt nd ne nf ng aw nh bi"><span id="7573" class="ni lr je ne b gy nj nk l nl nm">import gym<br/>env = gym.make(‘MountainCar-v0’)<br/>env.reset()</span></pre><h1 id="4493" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">探索环境</h1><p id="b86a" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">一旦导入了山地汽车环境，下一步就是探索它。所有 RL 环境都有一个状态空间(即环境中所有可能状态的集合)和一个动作空间(即环境中可以采取的所有动作的集合)。</p><p id="00d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以使用以下方式查看这些空间的大小:</p><pre class="mo mp mq mr gt nd ne nf ng aw nh bi"><span id="cd43" class="ni lr je ne b gy nj nk l nl nm">&gt; print(‘State space: ‘, env.observation_space)<br/>State space: Box(2,)</span><span id="de3e" class="ni lr je ne b gy nn nk l nl nm">&gt; print(‘Action space: ‘, env.action_space)<br/>Action space: Discrete(3)</span></pre><p id="ceda" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这告诉我们，状态空间表示一个 2 维的盒子，所以每个状态观察是 2 个(浮点)值的向量，并且动作空间包括三个离散的动作(这是我们已经知道的)。</p><p id="d1ce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">默认情况下，这三个动作由整数 0、1 和 2 表示。但是，我们不知道状态向量的元素可以取什么值。这可以通过以下方法找到:</p><pre class="mo mp mq mr gt nd ne nf ng aw nh bi"><span id="f83b" class="ni lr je ne b gy nj nk l nl nm">&gt; print(env.observation_space.low)<br/>[-1.2  -0.07]</span><span id="3aa7" class="ni lr je ne b gy nn nk l nl nm">&gt;print(env.observation_space.high)<br/>[0.6  0.07]</span></pre><p id="9537" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由此我们可以看出，状态向量的第一个元素(代表小车的位置)可以取-1.2 到 0.6 范围内的任何值，而第二个元素(代表小车的速度)可以取-0.07 到 0.07 范围内的任何值。</p><p id="dd85" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我们在本系列的第一篇文章中介绍 Q-learning 算法时，我们说过，只要每个状态-动作对被访问足够多的次数，它就能保证收敛<em class="mz">。然而，在这种情况下，我们处理的是一个连续的状态空间，这意味着有无限多的状态-行动对，因此不可能满足这一条件。</em></p><p id="db83" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">解决这个问题的一种方法是使用深度 Q 网络(dqn)。DQNs 通过使用深度神经网络作为 Q 函数的近似器，将深度学习与 Q 学习结合起来。dqn 已经成功应用于开发能够玩 Atari 视频游戏的人工智能。</p><p id="b047" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，对于像山地车问题这样简单的问题，这可能有点矫枉过正。</p><p id="0335" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另一种方法是将状态空间离散化。一种简单的方法是将状态向量的第一个元素四舍五入到最接近的 0.1，将第二个元素四舍五入到最接近的 0.01，然后(为了方便起见)将第一个元素乘以 10，将第二个元素乘以 100。</p><p id="25b2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这将状态-动作对的数量减少到 855 个，这使得满足 Q 学习收敛所需的条件成为可能。</p><h1 id="60fb" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">q-学习回顾</h1><p id="61bb" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">在本系列的第一篇文章中，我们详细介绍了 Q-learning 算法。在执行该算法时，我们假设了一维状态空间，因此我们的目标是找到最优的 Q 表，<em class="mz"> Q </em> ( <em class="mz"> s </em>，<em class="mz"> a </em>)。</p><p id="2213" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这个问题中，由于我们处理的是二维状态空间，我们用<em class="mz"> Q </em> ( <em class="mz"> s1 </em>，<em class="mz"> s2 </em>，<em class="mz"> a </em>)代替了<em class="mz"> Q </em> ( <em class="mz"> s </em>，<em class="mz"> a </em>)，但除此之外，Q 学习算法基本保持不变。</p><p id="2e62" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">概括地说，算法如下:</p><ol class=""><li id="1934" class="no np je kv b kw kx kz la lc nq lg nr lk ns lo nt nu nv nw bi translated">初始化<em class="mz"> Q </em> ( <em class="mz"> s1 </em>、<em class="mz"> s2 </em>、<em class="mz"> a </em>)，将所有元素设置为小随机值；</li><li id="8bda" class="no np je kv b kw nx kz ny lc nz lg oa lk ob lo nt nu nv nw bi translated">观察当前状态，(<em class="mz"> s1 </em>，<em class="mz">S2</em>)；</li><li id="c4fd" class="no np je kv b kw nx kz ny lc nz lg oa lk ob lo nt nu nv nw bi translated">根据探索策略，选择要采取的行动，<em class="mz">a</em>；</li><li id="472b" class="no np je kv b kw nx kz ny lc nz lg oa lk ob lo nt nu nv nw bi translated">采取行动<em class="mz"> a </em>并观察产生的奖励<em class="mz"> r </em>，以及环境的新状态(<em class="mz">S1’</em>，<em class="mz">S2’</em>)；</li><li id="ada9" class="no np je kv b kw nx kz ny lc nz lg oa lk ob lo nt nu nv nw bi translated">根据更新规则更新<em class="mz"> Q </em> ( <em class="mz"> s1 </em>、<em class="mz"> s2 </em>、<em class="mz"> a </em>):</li></ol><p id="4587" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="mz"> Q'(s1，s2，a) = (1 — w)*Q(s1，s2，a) + w*(r+d*Q(s1 '，s2 '，argmax a' Q(s1 '，s2 '，a '))</em></p><p id="6f37" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">其中<em class="mz"> w </em>为学习率<em class="mz"> d </em>为折现率；</p><p id="2ecb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">6.重复步骤 2–5，直到收敛。</p><h1 id="b8cc" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">开放式健身房的 Q-Learning</h1><p id="7e7f" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">要在开放人工智能健身房实施 Q-learning，我们需要观察当前状态的方法；采取行动并观察行动的结果。这些可以按如下方式完成。</p><p id="b21c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">重置环境时，会返回环境的初始状态:</p><pre class="mo mp mq mr gt nd ne nf ng aw nh bi"><span id="7a4d" class="ni lr je ne b gy nj nk l nl nm">&gt; print(env.reset())<br/>array([-0.50926558, 0. ])</span></pre><p id="a8d9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要采取行动(例如，<em class="mz"> a </em> = 2)，必须使用<code class="fe oc od oe ne b">step()</code>方法通过该行动“向前推进”环境。这将返回一个 4-ple，给出新的状态，奖励，一个布尔值，指示该情节是否已经终止(由于目标已经达到或 200 步已经过去)，以及任何附加信息(对于这个问题，它总是为空)。</p><pre class="mo mp mq mr gt nd ne nf ng aw nh bi"><span id="0be2" class="ni lr je ne b gy nj nk l nl nm">&gt; print(env.step(2))<br/>(array([-0.50837305, 0.00089253]), -1.0, False, {})</span></pre><p id="55b3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们假设一个ε-贪婪的探索策略，其中ε在总集数上线性衰减到指定的最小值(<code class="fe oc od oe ne b">min_eps</code>)，我们可以将上述所有内容与上一节中的算法放在一起，并产生以下用于实现 Q-学习的函数。</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d98f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">出于跟踪目的，该函数返回一个列表，其中包含 100 集每集的平均总奖励。它还使用<code class="fe oc od oe ne b">env.render()</code>方法可视化了最后 10 集的山地车运动。</p><p id="7d53" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">环境只在最后 10 集可视化，而不是所有集，因为可视化环境会显著增加代码运行时间。</p><p id="6776" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">假设我们假设学习率为 0.2，贴现率为 0.9，初始ε值为 0.8，最小ε值为 0。如果我们运行 500 集的算法，在这些集的结尾，汽车已经开始明白它需要来回摇摆以获得爬山所必需的动量，但只能做到大约一半。</p><p id="e312" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，如果我们将剧集数量增加一个数量级至 5000 集，到 5000 集结束时，汽车几乎每次都能完美地爬山。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d217797b81e60ebb4ca2376817411781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*gbPuSvVhCm997WMcUfytWA.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Success!</figcaption></figure><p id="e614" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">绘制 5000 集的平均奖励与集数的关系图，我们可以看到，最初，平均奖励相当平稳，一旦达到最大 200 次移动，每次运行就终止。这是算法的探索阶段。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/48185d72ae727fc0560766a8a48c4653.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*30vQuPlU1VeW6Tj4S5Sbyw.jpeg"/></div></figure><p id="5ae5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，在最后的 1000 集里，该算法采用了它通过探索学到的东西，并利用它来增加平均奖励，随着汽车学习爬山，这集现在以不到 200 个动作结束。</p><p id="7686" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个开发阶段是唯一可能的，因为给了算法足够的时间来探索环境，这就是为什么当算法只运行 500 集时，汽车不能爬山。</p><h1 id="a943" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">摘要</h1><p id="9e8c" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">在本文中，我们展示了 RL 如何用于解决 OpenAI Gym 山地车问题。为了解决这个问题，有必要对我们的状态空间进行离散化，并对 Q-learning 算法进行一些小的修改，但是除此之外，所使用的技术与本系列第一篇文章中用于解决简单网格世界问题的技术相同。</p><p id="1f53" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但这只是 Open AI Gym 中可供用户使用的众多环境之一。对于有兴趣尝试自己在本文中学到的技能的读者，我建议尝试其他任何经典控制问题(此处提供),然后继续讨论 2D 盒子问题。</p><p id="0217" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">通过不断修改和构建 Q-learning 算法，应该有可能解决 OpenAI Gym 用户可用的任何环境。然而，和所有事情一样，第一步是学习基础知识。这就是我们今天成功做到的。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="b118" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">想了解更多关于价值驱动的数据科学的信息吗？</strong> <a class="ae lp" href="http://www.genevievehayes.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">加入我的邮件列表，让我的最新文章和建议直接发送到你的收件箱。</strong> </a></p></div></div>    
</body>
</html>