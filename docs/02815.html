<html>
<head>
<title>Insight to the Fourier Transform and The Simple Implementation of It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对傅里叶变换的理解及其简单实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/insight-to-the-fourier-transform-and-the-simple-implementation-of-it-eee293317efd?source=collection_archive---------13-----------------------#2019-05-07">https://towardsdatascience.com/insight-to-the-fourier-transform-and-the-simple-implementation-of-it-eee293317efd?source=collection_archive---------13-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b817f1ef672cf7b7fee047f419599954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/1*NKg3K1tJKi-c2i6B9OMILw.gif"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">source: <a class="ae kb" href="https://pa1.narvii.com/6397/fbeec74f0468cf51eb46f4f869190563cf50829b_hq.gif" rel="noopener ugc nofollow" target="_blank">https://pa1.narvii.com/6397/fbeec74f0468cf51eb46f4f869190563cf50829b_hq.gif</a></figcaption></figure><p id="fb78" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这篇文章中，我不会给你一个傅立叶变换或傅立叶级数的推导细节。相反，我们将探索这种转换的输出以及它是如何工作的。</p><p id="b368" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">因此，我们将在这个故事中讨论的傅里叶变换公式被称为离散傅里叶变换(DFT)。公式是这样的。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi la"><img src="../Images/24dfcbfa8441847a0d54e36753025882.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*oyV-LsyKilD_7mlHC2FK6w.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">X is the output of DFT (signal in frequency spectrum), x is signal input (signal in time spectrum), N is a number of sample and k is frequency (limited in 0 to N-1 Hz). Source: <a class="ae kb" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Discrete_Fourier_transform</a></figcaption></figure><p id="098e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">它用于<strong class="ke iu">将信号的有限样本从时间频谱转换到频率频谱</strong>。坚持住！时间谱和频率谱中的信号是什么？我所指的时间频谱中的信号<strong class="ke iu">只是一个时间序列数据</strong>，如随时间变化的股价、随时间变化的降雨率等。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/c3045b12d2aebbb0cc6fe6bc71eb1a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*P85KRp4kKUE34OrLkOtBOw.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">example of time series data: USGS streamflow over time data. Source: <a class="ae kb" href="https://d32ogoqmya1dw8.cloudfront.net/images/geoinformatics/steps/1354035151.png" rel="noopener ugc nofollow" target="_blank">https://d32ogoqmya1dw8.cloudfront.net/images/geoinformatics/steps/1354035151.png</a></figcaption></figure><p id="8168" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果我们在 2d 图中绘制时间序列数据，我们将在 x 轴上得到<strong class="ke iu">时间</strong>，在 y 轴上得到幅度(或在波的情况下的振幅)。因此，与频谱中的信号不同的是，如果我们将其绘制在 2d 图中，我们将在 x 轴获得<strong class="ke iu">频率，在 y 轴获得幅度。</strong></p><p id="4351" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">好了，现在我们知道了 DFT 的实际输出，但是它是如何工作的？你知道你可以用 DFT 公式的一部分产生任意频率的周期正弦波吗？你可以用这个零件来生产那个。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/3226fce825f51e5c927b6a41ce5a1c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*HzaP_KOGrrklntTSncU2YQ.png"/></div></figure><p id="90f3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您可以使用下面的脚本来可视化这个公式生成的波。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="4114" class="lm ln it li b gy lo lp l lq lr">#!/usr/bin/python3</span><span id="6417" class="lm ln it li b gy ls lp l lq lr">import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="c703" class="lm ln it li b gy ls lp l lq lr">#setting<br/>k = 2<br/>res = 400</span><span id="1b56" class="lm ln it li b gy ls lp l lq lr">t = np.linspace(0, res, res)</span><span id="ea01" class="lm ln it li b gy ls lp l lq lr">time = np.linspace(0, 1, res)<br/>hz = np.exp(-2j * np.pi * k * t / len(t))</span><span id="1258" class="lm ln it li b gy ls lp l lq lr">plt.ylabel("Amplitude")<br/>plt.xlabel("Time")<br/>plt.plot(t, hz)<br/>plt.show()</span></pre><p id="4d49" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你会得到这样的东西</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/f8cee45571f01bae1b1fdaa02430ab34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mG7Zpk0dFc5aVoS3s9UhHQ.png"/></div></div></figure><p id="a7d0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">对于 k =2，我们得到一个 2 Hz 正弦波，如果我们设置 k = 10</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/e1af87844f7a14db6283ac7ec37db9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJ-Ovvy5xj-o9UgqzR48aA.png"/></div></div></figure><p id="90d3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们得到了一个 10 赫兹的正弦波。</p><p id="9d60" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">(再)坚持住！这个公式有一个“I”，这意味着输出必须有一个虚部。是，右边这个部分公式的输出是幅度+(相位)I。在这个上下文中，相位大约是正弦波的一个角度。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/36812ed2557fccaea9b2dee79aaecbb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/1*Z0G6U4_MfCcDNjEP8mw-XA.gif"/></div></figure><p id="ae9e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这个故事中，为了简单起见，我们将忽略虚部，也就是所谓的相位，并且我们不会在这个故事中使用它作为我们的实现示例。</p><p id="ee36" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在 DFT 的完整公式中，你要在你的实信号和 k Hz 的正弦信号之间做一个<strong class="ke iu">点运算。这就是为什么<strong class="ke iu">你可以从真实信号</strong>中提取 k Hz 正弦波的一个分量。你将<strong class="ke iu">从 0 Hz 提取到 k-1 Hz </strong>。但是，有一个情节转折？在现实世界中，我们不会使用普通的 DFT 来提取它，而是使用快速傅立叶变换(FFT)来提取。FFT 只是一种更有效的计算 DFT 的方法。我们不会在这个故事中讨论 FFT 算法，但是为了你的信息，普通 DFT 和 FFT 的<strong class="ke iu">结果几乎是相同的</strong>。</strong></p><p id="ac81" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这就是理论，现在我们将实施它。通过傅立叶变换，<strong class="ke iu">我们将尝试计算出哔哔声的频率</strong>。我们将在这个实验中使用<a class="ae kb" href="https://freesound.org/people/GowlerMusic/sounds/264862/" rel="noopener ugc nofollow" target="_blank">这个声音</a>。让我们用这个脚本来看看这个声音的“形状”。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="daba" class="lm ln it li b gy lo lp l lq lr">#!/usr/bin/python3</span><span id="89ab" class="lm ln it li b gy ls lp l lq lr">from scipy.io import wavfile<br/>from matplotlib import pyplot as plt<br/>import numpy as np</span><span id="e6c7" class="lm ln it li b gy ls lp l lq lr">#setting<br/>datasound = '7detik.wav'</span><span id="05db" class="lm ln it li b gy ls lp l lq lr">fs, data = wavfile.read(datasound)<br/>data = np.array(data, dtype=float)</span><span id="cbbc" class="lm ln it li b gy ls lp l lq lr">#normalize<br/>data = (data - np.mean(data)) / np.std(data)</span><span id="6a6c" class="lm ln it li b gy ls lp l lq lr">time = range(len(data))</span><span id="7742" class="lm ln it li b gy ls lp l lq lr">plt.ylabel("Amplitude")<br/>plt.xlabel("Time")<br/>plt.plot(time, data)</span></pre><p id="d55b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们得到了这个。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lz"><img src="../Images/45e832a8b321978bf1b1a389bcaabd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8T8kWsfZdJIQu3OVgutfEA.png"/></div></div></figure><p id="aa53" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要将这些数据从时间频谱转换到频率频谱，也就是 FFT，让我们运行下面的脚本。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="f0f7" class="lm ln it li b gy lo lp l lq lr">#!/usr/bin/python3</span><span id="2966" class="lm ln it li b gy ls lp l lq lr">from scipy.io import wavfile<br/>from matplotlib import pyplot as plt<br/>import numpy as np</span><span id="435b" class="lm ln it li b gy ls lp l lq lr">#setting<br/>datasound = '7detik.wav'</span><span id="e886" class="lm ln it li b gy ls lp l lq lr">fs, data = wavfile.read(datasound)<br/>data = np.array(data, dtype=float)<br/>#print(len(data), np.shape(data), fs)</span><span id="7b41" class="lm ln it li b gy ls lp l lq lr">#normalize<br/>data = (data - np.mean(data)) / np.std(data)</span><span id="de80" class="lm ln it li b gy ls lp l lq lr">time = range(len(data))</span><span id="42ce" class="lm ln it li b gy ls lp l lq lr">fftdata = np.fft.fft(data)<br/>fftdatafreq = np.zeros((len(data)))<br/>for i in range(len(fftdata)):<br/> fftdatafreq[i] = abs(fftdata[i].real)</span><span id="5cf6" class="lm ln it li b gy ls lp l lq lr">plt.ylabel("Amplitude")<br/>plt.xlabel("Frequency")<br/>plt.plot(time, fftdatafreq)<br/><br/>plt.show()</span></pre><p id="f198" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你会得到这样一个图表。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ma"><img src="../Images/938366cc48d22ffda7601d6342ed8eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hshhVoELQ1nCui304gBauw.png"/></div></div></figure><p id="5eb0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">哇，在一些或一个频率和另一个频率之间有一个巨大的差异振幅。其实，<strong class="ke iu">FFT 的输出是对称的</strong>(看看上图就知道了，)。这意味着我们只需要一半的频率来显示。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="204f" class="lm ln it li b gy lo lp l lq lr">plt.plot(time[:len(fftdatafreq) // 2], fftdatafreq[:len(fftdatafreq) // 2])</span></pre><p id="7237" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们得到了下图。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/e1c73be64b09744c863ec0dd0a535d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPEgzED-xMGx_E78kymCUQ.png"/></div></div></figure><p id="9649" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">好了，现在是有趣的部分。我们将尝试计算出这种哔哔声的频率。让我们用这个代码检查具有最高振幅的 bin。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="557c" class="lm ln it li b gy lo lp l lq lr">maxfreq = np.argmax(fftdatafreq)<br/>print('dominant freq ', maxfreq)</span></pre><p id="8039" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">结果是</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="79ae" class="lm ln it li b gy lo lp l lq lr">dominant freq  6009</span></pre><p id="5390" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">6009?这是不是意味着这个嘟嘟声的频率是 6009？没那么快！我们在这里使用的 FFT 函数</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="e872" class="lm ln it li b gy lo lp l lq lr">fftdata = np.fft.fft(data)</span></pre><p id="8a27" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">假设我们数据的总持续时间是 1 秒，尽管实际上并不是这样。让我们检查一下哔哔声的实际持续时间。该功能</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="0b86" class="lm ln it li b gy lo lp l lq lr">fs, data = wavfile.read(datasound)</span></pre><p id="65e3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">返回 1 秒(fs)内的<strong class="ke iu">采样率</strong>和<strong class="ke iu">声音(data)的数组真实数据</strong>。让我们检查 fs 的值和数据数组的长度。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="9d74" class="lm ln it li b gy lo lp l lq lr">print(len(data), fs)</span></pre><p id="b270" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">是回归</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="2db2" class="lm ln it li b gy lo lp l lq lr">265039 44100</span></pre><p id="0378" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">所以数组的长度是 265039，采样率是 44100。并且查看声音的持续时间是 265039 / 44100 = 6.009954648526077 秒。</p><p id="54f0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">表示在这 6.009954648526077 秒中，我们的主频已经形成了 6009 个当时的正弦波</strong>。从逻辑上思考，所以主频是<strong class="ke iu">6009/6.009954648526077 = 999.8411554525939Hz</strong>或者我们可以把这个数四舍五入到<strong class="ke iu"> 1000 Hz </strong>。总结一下，我们的嘟嘟声的频率是 1000 Hz。要验证它<strong class="ke iu">只需谷歌“1000 赫兹声音”</strong>。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mb"><img src="../Images/10de6020608ec7e04e0ec197494f5842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxKMhglfU-ORyg5iAcUYdQ.png"/></div></div></figure><p id="16c6" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">播放视频并与我们的哔哔声进行比较。非常相似不是吗？</p><p id="0772" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">仅此而已。FFT 的应用非常广泛，尤其是在电气工程中。最初的计划是我想用 FFT 计算出每日降雨量的模式，但是我的降雨量数据并不充分。另一篇文章再见。</p></div></div>    
</body>
</html>