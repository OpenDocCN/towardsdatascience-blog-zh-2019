<html>
<head>
<title>PyTorch Fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch 基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytorch-fundamentals-50af6121d4a3?source=collection_archive---------22-----------------------#2019-04-15">https://towardsdatascience.com/pytorch-fundamentals-50af6121d4a3?source=collection_archive---------22-----------------------#2019-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyTorch 是最著名的深度学习框架之一。我个人更喜欢 PyTorch，因为它的 pythonic 性质。很容易将每一行代码都视为一个函数，有清晰的输入和输出。</p><p id="c64c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将讨论在使用 PyTorch 进行深度学习时起关键作用的以下基本结构和操作。</p><ol class=""><li id="0188" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">矩阵或张量</li><li id="d9b7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">张量运算</li><li id="4bd5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">变量和梯度</li></ol><h1 id="ea83" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">矩阵或张量</h1><p id="7d34" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">矩阵被正式定义为“数字的矩形阵列”。在 numpy 图书馆，他们被称为“ndarrays ”,而在 PyTorch，他们被称为“男高音”。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/95231fa18b94cedd132b32e971a1b65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*vSGkF47ePwkirS73dgN_eg.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Taken from <a class="ae mo" href="https://www.onlinemathlearning.com/matrices-rows-columns.html" rel="noopener ugc nofollow" target="_blank">https://www.onlinemathlearning.com/matrices-rows-columns.html</a></figcaption></figure><p id="77e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图所示的张量是一个 3 行 2 列的 2D 张量。让我们看看如何在 PyTorch 中创建张量。</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="1434" class="mu la iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>numpy <strong class="mq ir">as </strong>np<br/><strong class="mq ir">import </strong>torch<br/><br/><em class="mz"># 1) Create a PyTorch Tensor an array<br/><br/></em>arr = [[3, 4], [8, 5]] <em class="mz"># python array<br/></em>pyt_tensor = torch.Tensor(arr) <em class="mz"># PyTorch tensor<br/><br/># 2) Create a tensor<br/><br/></em>ones_tensor = torch.ones((2, 2)) <em class="mz"># tensor containing all ones<br/></em>torch.manual_seed(0)             <em class="mz"># to have same values for random generation<br/></em>rand_tensor = torch.rand((2, 2)) <em class="mz"># tensor containing random values<br/><br/># if running on GPU, set random seed value as follows<br/></em><strong class="mq ir">if </strong>torch.cuda.is_available():<br/>    torch.cuda.manual_seed_all(0)<br/><br/><em class="mz"># 3) Create a tensor from numpy array (dtype must be either double, float, int64, int32, or uint8)<br/><br/></em>np_arr = np.ones((2, 2))<br/>pyt_tensor = torch.from_numpy(np_arr)<br/>np_arr_from_tensor = pyt_tensor.numpy() <em class="mz"># convert tensor to numpy array</em></span></pre><h1 id="d77e" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">张量运算</h1><p id="1d4c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">所有适用于数组的运算也适用于张量。下面是 PyTorch 中的做法。</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="4900" class="mu la iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>numpy <strong class="mq ir">as </strong>np<br/><strong class="mq ir">import </strong>torch<br/><br/><em class="mz"># 1) Resizing a tensor<br/><br/></em>pyt_tensor = torch.ones((2, 2))<br/>print(pyt_tensor.size())        <em class="mz"># shows the size of this tensor<br/></em>pyt_tensor = pyt_tensor.view(4) <em class="mz"># resizing 2x2 tensor to 4x1<br/><br/># 2) Mathematical Operations<br/><br/></em>pyt_tensor_a = torch.ones((2, 2))<br/>pyt_tensor_b = torch.ones((2, 2))<br/>res_tensor = pyt_tensor_a + pyt_tensor_b               <em class="mz"># simple element wise addidtion<br/></em>res_tensor = torch.add(pyt_tensor_a, pyt_tensor_b)     <em class="mz"># another way of addidtion<br/></em>pyt_tensor_a.add_(pyt_tensor_b)                         <em class="mz"># In-place addition<br/><br/># Operation     operator    function_name<br/>#  =&gt; Addition        +           add<br/>#  =&gt; Subtraction     -           sub<br/>#  =&gt; Multiplication  *           mul<br/>#  =&gt; Divide          /           div<br/><br/># 3) Mean and Standart deviation<br/><br/></em>pyt_tensor = torch.Tensor([1, 2, 3, 4, 5])<br/>mean = pyt_tensor.mean(dim=0)                        <em class="mz"># if multiple rows then dim = 1<br/></em>std_dev = pyt_tensor.std(dim=0)                        <em class="mz"># if multiple rows then dim = 1</em></span></pre><h1 id="3ced" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">变量和梯度</h1><p id="843b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">梯度计算是<strong class="jp ir"/><strong class="jp ir"/>深度学习中的关键事情之一。在 PyTorch 中，变量用于计算梯度。本质上，变量只是张量的包装，具有梯度计算的功能。</p><p id="df8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是用于管理变量的 python 代码</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="3aa8" class="mu la iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>numpy <strong class="mq ir">as </strong>np<br/><strong class="mq ir">import </strong>torch<br/><strong class="mq ir">from </strong>torch.autograd <strong class="mq ir">import </strong>Variable<br/><br/>pyt_var = Variable(torch.ones((2, 2)), requires_grad = <strong class="mq ir">True</strong>)<br/><br/><em class="mz"># behaves exactly the same as tensors, so we can apply all operations in the same way</em></span></pre><p id="5ccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们来看看如何在 PyTorch 中使用变量来计算梯度。</p><pre class="md me mf mg gt mp mq mr ms aw mt bi"><span id="a444" class="mu la iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>numpy <strong class="mq ir">as </strong>np<br/><strong class="mq ir">import </strong>torch<br/><strong class="mq ir">from </strong>torch.autograd <strong class="mq ir">import </strong>Variable<br/><br/><em class="mz"># let's consider the following equation<br/># y = 5(x + 1)^2<br/><br/></em>x = Variable(torch.ones(1), requires_grad = <strong class="mq ir">True</strong>)<br/>y = 5 * (x + 1) ** 2        <em class="mz"># implementing the equation.<br/></em>y.backward()                <em class="mz"># calculate gradient<br/></em>print(x.grad)               <em class="mz"># get the gradient of variable x<br/># differentiating the above mentioned equation<br/># =&gt; 5(x + 1)^2 = 10(x + 1) = 10(2) = 20</em></span></pre><p id="578e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章中提到的事情非常简单直接，但也非常重要。如果基础知识以正确的方式学习，框架的知识会增长得很快。我自己发现偶尔回顾一下这些基础知识是很有用的，可以避免在实际编写代码时不必要的时间延迟。</p></div></div>    
</body>
</html>