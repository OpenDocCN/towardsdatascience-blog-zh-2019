<html>
<head>
<title>Exporting Pandas Data to Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将熊猫数据导出到 Elasticsearch</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exporting-pandas-data-to-elasticsearch-724aa4dd8f62?source=collection_archive---------8-----------------------#2019-02-24">https://towardsdatascience.com/exporting-pandas-data-to-elasticsearch-724aa4dd8f62?source=collection_archive---------8-----------------------#2019-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b38ba3bfae0a4f5fb7885edbfb81d243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wJFOvN0DMd9GGhom"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">CHUTTERSNAP</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="be2e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何将您的数据帧行发送到 elasticsearch 数据库。</p><h1 id="a57a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="9d58" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因此，您已经完成了数据的下载和分析，并准备好将其转移到 Elasticsearch 数据库中。本文介绍了如何准备数据并将其发送到 elasticsearch 端点。</p><h2 id="6f89" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">要求</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="efb5" class="me lc jg mv b gy mz na l nb nc">Python 3.6.5<br/>numpy==1.15.0<br/>pandas==0.23.4<br/>elasticsearch==6.3.1</span><span id="3648" class="me lc jg mv b gy nd na l nb nc">import numpy as np<br/>import pandas as pd</span><span id="7d80" class="me lc jg mv b gy nd na l nb nc">from elasticsearch import Elasticsearch<br/>from elasticsearch import helpers<br/>es = Elasticsearch(http_compress=True)</span></pre><h1 id="0039" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">清理您的数据</h1><p id="bd5e" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Pandas dataframes 很乐意在您的数据中保存 NaN 值，但是对 null 值的容忍不是 elasticsearch 的特性。仔细想想，这是有道理的；您要求索引器不索引任何内容。您可以通过一些简单的函数运行数据来避免这种情况。</p><h2 id="2c77" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">空白日期</h2><p id="962a" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您的数据框架有空白日期，您需要将其转换为 elasticsearch 接受的值。elasticsearch 中的日期可以是格式化的日期字符串(例如“6–9–2016”)、自 Unix 纪元以来的毫秒数或自 Unix Epoc 以来的秒数(<a class="ae jd" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html" rel="noopener ugc nofollow" target="_blank"> elastic docs </a>)。使用毫秒的空日期，因为 Unix 纪元是 1970 年 1 月 1 日。如果你有包括 70 年代早期的历史日期，你可能要考虑一些其他的。</p><p id="8282" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个可以和 dataframe 一起使用的简单函数。apply()清理日期列。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f88c" class="me lc jg mv b gy mz na l nb nc">from datetime import datetime</span><span id="007b" class="me lc jg mv b gy nd na l nb nc">def safe_date(date_value):<br/>    return (<br/>        pd.to_datetime(date_value) if not pd.isna(date_value)<br/>            else  datetime(1970,1,1,0,0)<br/>    )</span><span id="1012" class="me lc jg mv b gy nd na l nb nc">df['ImportantDate'] = df['ImportantDate'].apply(safe_date)</span></pre><h2 id="70fb" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">避免其他空白值</h2><p id="7e5c" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">任何包含空值的字段都是有问题的，因为空日期。字符串值比日期更容易，但是您需要提供一个值。下面的代码使用 df.apply()函数将空格替换为安全字符串。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="397c" class="me lc jg mv b gy mz na l nb nc">def safe_value(field_val):<br/>    return field_val if not pd.isna(field_val) else "Other"</span><span id="14fb" class="me lc jg mv b gy nd na l nb nc">df['Hold'] = df['PossiblyBlankField'].apply(safe_value)</span></pre><h2 id="1bd3" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">创建文档</h2><p id="d293" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一旦您确信您的数据已经准备好发送到 Elasticsearch，就该将行转换为文档了。Panda dataframes 有一个方便的“iterrows”函数可以直接实现这一点。它返回行的索引和包含行值的对象。这是一个“pandas.core.series.Series”对象，但其行为类似于传统的 python 字典。这个代码片段演示了如何将 iter 响应分配给变量。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9008" class="me lc jg mv b gy mz na l nb nc">df_iter = df.iterrows()</span><span id="80fb" class="me lc jg mv b gy nd na l nb nc">index, document = next(df_iter)</span></pre><p id="c48f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Elasticsearch 需要 python 格式的数据，使用。Series 对象的 to_dict()方法。但是，您可以选择要发送到数据库的数据，并使用简单的过滤函数。注意下面的函数返回一个字典理解。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1bb4" class="me lc jg mv b gy mz na l nb nc">use_these_keys = ['id', 'FirstName', 'LastName', 'ImportantDate']</span><span id="a2d0" class="me lc jg mv b gy nd na l nb nc">def filterKeys(document):<br/>    return {key: document[key] for key in use_these_keys }</span></pre><h2 id="9400" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">发电机</h2><p id="7f55" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们终于准备好使用 python 客户机和助手向 Elasticsearch 发送数据了。helper.bulk api 需要一个 Elasticsearch 客户端实例和一个生成器。如果你不熟悉发电机，去了解他们的记忆尊重的好处。如果你没有时间做这个，只需要理解神奇的是<code class="fe ne nf ng mv b">yield</code>，当 bulk.helpers 函数请求数据时，a 会给出数据。下面是遍历数据框架并将其发送到 Elasticsearch 的代码。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="57c3" class="me lc jg mv b gy mz na l nb nc">from elasticsearch import Elasticsearch<br/>from elasticsearch import helpers<br/>es_client = Elasticsearch(http_compress=True)</span><span id="94c2" class="me lc jg mv b gy nd na l nb nc">def doc_generator(df):<br/>    df_iter = df.iterrows()<br/>    for index, document in df_iter:<br/>        yield {<br/>                "_index": 'your_index',<br/>                "_type": "_doc",<br/>                "_id" : f"{document['id']}",<br/>                "_source": filterKeys(document),<br/>            }<br/>    raise StopIteration</span><span id="61f6" class="me lc jg mv b gy nd na l nb nc">helpers.bulk(es_client, doc_generator(your_dataframe))</span></pre><h2 id="b7a9" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">分解生成的字典</h2><p id="0a63" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">doc_generator 的工作只是提供一个带有特定值的字典。这里有一些关于这里发生的事情的细节的评论。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="18df" class="me lc jg mv b gy mz na l nb nc">"_index": 'your_index',</span></pre><p id="f74d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是您在 Elasticsearch 中的索引名称。如果没有索引，可以在这里使用任何有效的索引名。Elasticsearch 会尽最大努力自动索引你的文档。但是，提前创建索引是避免拒绝文档和优化索引过程的好主意。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3c1f" class="me lc jg mv b gy mz na l nb nc">"_type": "_doc",</span></pre><p id="6c81" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意:<code class="fe ne nf ng mv b">_type</code>已被 Elasticsearch 弃用。版本 6.3.1 仍然支持命名类型，但这是开始转换为' _doc '的好时机。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f1c4" class="me lc jg mv b gy mz na l nb nc">“_id” : f”{document[‘id’]}”,</span></pre><p id="1ed5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng mv b">_id </code>是 Elasticsearch 的唯一 id。不要把它和你文档中自己的“id”字段混淆。这可能是添加 itterows()中的<code class="fe ne nf ng mv b">index</code>变量的好地方，通过类似<code class="fe ne nf ng mv b">f”{document['id']+index}".</code>的东西使文档更加独特</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1b59" class="me lc jg mv b gy mz na l nb nc">"_source": filterKeys(document),</span></pre><p id="795d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">_source 是这个练习的核心:要保存的文档。使用<code class="fe ne nf ng mv b">document.to_dict()</code>或任何其他有效的 python 字典都可以。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="146a" class="me lc jg mv b gy mz na l nb nc">raise StopIteration</span></pre><p id="fda0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于礼貌，我加入了这一行。bulk.helpers 函数将处理生成器的突然终止。但是提高 StopIteration 可以省去这个麻烦。</p><h1 id="1318" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0b87" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">注意一些细节，把你的熊猫数据转移到一个弹性搜索数据库是没有戏剧性的。只要记住空值是 elasticsearch 的一个问题。剩下的就是创建一个生成器，将您的行处理成 python 字典。</p></div></div>    
</body>
</html>