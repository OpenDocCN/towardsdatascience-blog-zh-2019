<html>
<head>
<title>How to Find Shortest Dependency Path with spaCy and StanfordNLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 spaCy 和 StanfordNLP 寻找最短依赖路径</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-shortest-dependency-path-with-spacy-and-stanfordnlp-539d45d28239?source=collection_archive---------7-----------------------#2019-06-26">https://towardsdatascience.com/how-to-find-shortest-dependency-path-with-spacy-and-stanfordnlp-539d45d28239?source=collection_archive---------7-----------------------#2019-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ccab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最短依赖路径是关系抽取中常用的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce7a99e1b74d394a4deaca45a8c81ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9StquWH4P2JiJ6cuWuKpMw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@gcalebjones?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Caleb Jones</a> on <a class="ae ky" href="https://unsplash.com/search/photos/path?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e466" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="49bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">考虑到文档和依赖解析的准确性，我推荐使用 spaCy 而不是 StanfordNLP。</p><p id="0e73" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">内容结构如下。</p><ul class=""><li id="5549" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">什么是最短依赖路径(SDP)？</li><li id="6f9e" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">用空间寻找最短依赖路径</li><li id="1a51" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">用 StanfordNLP 查找最短依赖路径</li></ul><h1 id="f630" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是最短依赖路径(SDP)？</h1><p id="b0cd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">语义依存句法分析曾被频繁地用于剖析句子和捕获单词<strong class="lt iu">的语义信息，这些语义信息在上下文中靠近</strong>，而在句子距离较远的地方靠近<strong class="lt iu">。</strong></p><p id="653f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要提取两个实体之间的关系，最直接的方法是使用 SDP。使用 SDP 的动机是基于这样的观察<strong class="lt iu">实体之间的 SDP 通常包含识别它们关系的必要信息。</strong><a class="ae ky" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4963603/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"/></a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/6cc57c7c935cdb4cae9198535142c514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*NjVrMud1U_ZUsgDxdYK6EQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">A dependency tree example</figcaption></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3282" class="nm la it ni b gy nn no l np nq">Convulsions that occur after DTaP are caused by a fever.</span></pre><p id="3ccc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上图中，方括号中的单词是标记的实体。<strong class="lt iu">红色虚线箭头表示两个实体之间的 SDP</strong>。</p><h1 id="1089" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用空间寻找最短依赖路径</h1><p id="e967" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，在终端中安装必要的库。为了清晰起见，我添加了版本号。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="10b5" class="nm la it ni b gy nn no l np nq">pip install spacy==2.1.4<br/>python -m spacy download en_core_web_sm</span><span id="1f55" class="nm la it ni b gy nr no l np nq">pip install <!-- -->stanfordnlp==<!-- -->0.2.0<br/>pip install networkx==2.3</span></pre><p id="e17a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们按照官方教程打印出所有的依赖标签。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="af2a" class="nm la it ni b gy nn no l np nq">import spacy<br/>import networkx as nx</span><span id="d8b5" class="nm la it ni b gy nr no l np nq">nlp = spacy.load("en_core_web_sm")</span><span id="24c7" class="nm la it ni b gy nr no l np nq">doc = nlp(u'Convulsions that occur after DTaP are caused by a fever.')</span><span id="3957" class="nm la it ni b gy nr no l np nq">for token in doc:<br/>    print((token.head.text, token.text, token.dep_))</span><span id="f125" class="nm la it ni b gy nr no l np nq"># output: (head, current_token, dep_relation)<br/>('caused', 'Convulsions', 'nsubjpass')<br/>('occur', 'that', 'nsubj')<br/>('Convulsions', 'occur', 'relcl')<br/>('occur', 'after', 'prep')<br/>('caused', 'DTaP', 'nsubjpass')<br/>('caused', 'are', 'auxpass')<br/>('caused', 'caused', 'ROOT')<br/>('caused', 'by', 'agent')<br/>('fever', 'a', 'det')<br/>('by', 'fever', 'pobj')<br/>('caused', '.', 'punct')</span></pre><p id="3ad1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过<a class="ae ky" href="https://explosion.ai/demos/displacy?text=Convulsions%20that%20occur%20after%20DTaP%20are%20caused%20by%20a%20fever.&amp;model=en_core_web_sm&amp;cpu=1&amp;cph=1" rel="noopener ugc nofollow" target="_blank">方便的空间可视化工具</a>绘制整个依赖树。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/2b375758410c79b139d94e60964a8f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sROQ6jegfA58X0iYIEiX2A.png"/></div></div></figure><p id="40cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面的代码可以给 SDP</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="908a" class="nm la it ni b gy nn no l np nq">import spacy<br/>import networkx as nx</span><span id="9903" class="nm la it ni b gy nr no l np nq">nlp = spacy.load("en_core_web_sm")</span><span id="d87b" class="nm la it ni b gy nr no l np nq">doc = nlp(u'Convulsions that occur after DTaP are caused by a fever.')</span><span id="ef3c" class="nm la it ni b gy nr no l np nq">print('sentence:'.format(doc))</span><span id="e017" class="nm la it ni b gy nr no l np nq"># Load spacy's dependency tree into a networkx graph<br/>edges = []<br/>for token in doc:<br/>    for child in token.children:<br/>        edges.append(('{0}'.format(token.lower_),<br/>                      '{0}'.format(child.lower_)))</span><span id="7486" class="nm la it ni b gy nr no l np nq">graph = nx.Graph(edges)</span><span id="6937" class="nm la it ni b gy nr no l np nq"># Get the length and path<br/>entity1 = 'Convulsions'.lower()<br/>entity2 = 'fever'</span><span id="2d25" class="nm la it ni b gy nr no l np nq">print(nx.<strong class="ni iu">shortest_path_length</strong>(graph, source=entity1, target=entity2))<br/>print(nx.<strong class="ni iu">shortest_path</strong>(graph, source=entity1, target=entity2))</span></pre><p id="59d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nt nu nv ni b">edges</code>如下图所示。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7cd7" class="nm la it ni b gy nn no l np nq">In [6]: edges<br/>Out[6]:<br/>[('convulsions', 'occur'),<br/> ('occur', 'that'),<br/> ('occur', 'after'),<br/> ('caused', 'convulsions'),<br/> ('caused', 'dtap'),<br/> ('caused', 'are'),<br/> ('caused', 'by'),<br/> ('caused', '.'),<br/> ('by', 'fever'),<br/> ('fever', 'a')]</span></pre><p id="2b4f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">输出如下</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="86f3" class="nm la it ni b gy nn no l np nq">3<br/>['convulsions', 'caused', 'by', 'fever']</span></pre><p id="efe7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着从“抽搐”到“发烧”的 SDP 长度为 3。</p><p id="6117" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你不想使用 networkx 库，而只使用 spaCy，你可以查看我的另一个帖子，<a class="ae ky" rel="noopener" target="_blank" href="/find-shortest-dependency-path-with-spacy-only">用 spaCy 找到最低公共祖先最短依赖路径</a></p><h1 id="a25c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用 StanfordNLP 查找最短依赖路径</h1><p id="7220" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们按照官方教程打印出所有的依赖标签。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b5b7" class="nm la it ni b gy nn no l np nq">import stanfordnlp</span><span id="832d" class="nm la it ni b gy nr no l np nq">stanfordnlp.download('en')<br/>nlp = stanfordnlp.Pipeline()</span><span id="a278" class="nm la it ni b gy nr no l np nq">doc = nlp('Convulsions that occur after DTaP are caused by a fever.')<br/>doc.sentences[0].print_dependencies()</span><span id="80cc" class="nm la it ni b gy nr no l np nq"># output: (current_token, head_index, dep_relation)<br/>('Convulsions', '0', 'root')<br/>('that', '3', 'nsubj')<br/>('occur', '1', 'acl:relcl')<br/>('after', '7', 'mark')<br/>('DTaP', '7', 'nsubj:pass')<br/>('are', '7', 'aux:pass')<br/>('caused', '3', 'advcl')<br/>('by', '10', 'case')<br/>('a', '10', 'det')<br/>('fever', '7', 'obl')</span></pre><p id="b53e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了遵循 networkx 图的<code class="fe nt nu nv ni b">[(token, children), (token, children),...]</code>格式，我们需要根据<a class="ae ky" href="https://github.com/stanfordnlp/stanfordnlp/blob/8d1383a3c067dc07a50d5087462f53ff81f964ce/stanfordnlp/pipeline/doc.py#L128" rel="noopener ugc nofollow" target="_blank">源代码</a>修改代码。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d666" class="nm la it ni b gy nn no l np nq">import stanfordnlp</span><span id="518a" class="nm la it ni b gy nr no l np nq">stanfordnlp.download('en')<br/>nlp = stanfordnlp.Pipeline()</span><span id="2704" class="nm la it ni b gy nr no l np nq">doc = nlp('Convulsions that occur after DTaP are caused by a fever.')</span><span id="4896" class="nm la it ni b gy nr no l np nq"># Load stanfordnlp's dependency tree into a networkx graph<br/>edges = []<br/>for token in doc.sentences[0].dependencies:<br/>    if token[0].text.lower() != 'root':<br/>        edges.append((token[0].text.lower(), token[2].text))</span><span id="f72a" class="nm la it ni b gy nr no l np nq">graph = nx.Graph(edges)</span><span id="b1ab" class="nm la it ni b gy nr no l np nq"># Get the length and path<br/>entity1 = 'Convulsions'.lower()<br/>entity2 = 'fever'<br/>print(nx.shortest_path_length(graph, source=entity1, target=entity2))<br/>print(nx.shortest_path(graph, source=entity1, target=entity2))</span></pre><p id="aa0c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nt nu nv ni b">edges</code>如下图所示。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="dc00" class="nm la it ni b gy nn no l np nq">In [19]: edges<br/>Out[19]:<br/>[('occur', 'that'),<br/> ('convulsions', 'occur'),<br/> ('caused', 'after'),<br/> ('caused', 'DTaP'),<br/> ('caused', 'are'),<br/> ('occur', 'caused'),<br/> ('fever', 'by'),<br/> ('fever', 'a'),<br/> ('caused', 'fever'),<br/> ('convulsions', '.')]</span></pre><p id="b0c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">输出如下</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2121" class="nm la it ni b gy nn no l np nq">3<br/>['convulsions', 'occur', 'caused', 'fever']</span></pre><p id="cef8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">即使是 StanfordNLP 计算的 SDP 长度也与 spaCy 相同。<strong class="lt iu">但在 SDP 中两个实体之间的词语应该是</strong> <code class="fe nt nu nv ni b"><strong class="lt iu">'caused', 'by'</strong></code> <strong class="lt iu">。因此，spaCy 的依赖解析精度优于 StanfordNLP。</strong></p><blockquote class="nw nx ny"><p id="1c21" class="lr ls nz lt b lu mn ju lw lx mo jx lz oa mp mc md ob mq mg mh oc mr mk ml mm im bi translated"><strong class="lt iu"> <em class="it">查看我在</em> </strong> <a class="ae ky" href="https://medium.com/@bramblexu" rel="noopener"> <strong class="lt iu"> <em class="it">中的其他帖子</em> </strong> </a> <strong class="lt iu"> <em class="it">同</em> </strong> <a class="ae ky" href="https://bramblexu.com/posts/eb7bd472/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> <em class="it">一个归类视图</em> </strong> </a> <strong class="lt iu"> <em class="it">！<br/>git hub:</em></strong><a class="ae ky" href="https://github.com/BrambleXu" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">BrambleXu</strong></a><strong class="lt iu"><em class="it"><br/>LinkedIn:</em></strong><a class="ae ky" href="https://www.linkedin.com/in/xu-liang-99356891/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"><em class="it">徐亮</em></strong><strong class="lt iu"><em class="it">Blog:</em></strong><strong class="lt iu">BrambleXu</strong>T58】</a></p></blockquote><h1 id="fac4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">参考</strong></h1><div class="od oe gp gr of og"><a href="https://stackoverflow.com/questions/32835291/how-to-find-the-shortest-dependency-path-between-two-words-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">如何在 Python 中找到两个单词之间的最短依赖路径？</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">您的问题可以很容易地想象成一个图形问题，我们必须找到两个节点之间的最短路径。去…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">stackoverflow.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4963603/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">基于最短依赖路径的蛋白质-蛋白质关系卷积神经网络…</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">生物医学关系在生物过程中起着重要的作用，在生物医学领域得到了广泛的研究。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.ncbi.nlm.nih.gov</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>