<html>
<head>
<title>Using FunctionTransformer and Pipeline in SkLearn to Predict Chardonnay Ratings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 SkLearn 中使用 FunctionTransformer 和 Pipeline 预测 Chardonnay 评级</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-functiontransformer-and-pipeline-in-sklearn-to-predict-chardonnay-ratings-9b13fdd6c6fd?source=collection_archive---------7-----------------------#2019-11-29">https://towardsdatascience.com/using-functiontransformer-and-pipeline-in-sklearn-to-predict-chardonnay-ratings-9b13fdd6c6fd?source=collection_archive---------7-----------------------#2019-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/90708dd50762bd35467f901cf45f36a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*957CF4ztyE2eVId5IbEiow.png"/></div></figure><h1 id="40dd" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">发现管道</h1><p id="62e1" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">学习编码的最大好处之一是，当你发现新概念时，你会掉进无数个兔子洞。我在 DataCamp 上做的一个练习让我接触到了 Scikit-Learn 中的 Pipeline，它让我大吃一惊！<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">管道</a>允许你顺序转换数据，实现<em class="lu"> fit() </em>。做完练习后，我就开始应用我所学到的知识，精心制作了一个管道来清理葡萄酒评论数据集，并预测霞多丽的评级。这是对我在创建管道和预测模型时所经历的过程的深入回顾。<strong class="kx iu">我讨论创建特征、应用分类编码器、构建管道和生成预测。完整的代码和 github repo 的链接可以在文章的底部找到</strong>:</p><h1 id="0bee" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">导入从属关系和数据</h1><p id="925e" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">数据来源于 Kaggle 上的<a class="ae lt" href="https://www.kaggle.com/zynicide/wine-reviews" rel="noopener ugc nofollow" target="_blank">葡萄酒评论数据集。我已经写了几篇关于探索数据集的文章，并且已经将它存储在一个 SQLite 数据库中。数据仅被部分清理，并且需要被转换，以便可以在机器学习模型中使用。</a></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5a2b" class="me jy it ma b gy mf mg l mh mi">import numpy as np<br/>import pandas as pd<br/>import sqlite3<br/>import category_encoders as ce<br/>import re</span><span id="6392" class="me jy it ma b gy mj mg l mh mi">from sklearn.feature_selection import chi2, SelectKBest<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.feature_extraction.text import HashingVectorizer</span><span id="0908" class="me jy it ma b gy mj mg l mh mi">from sklearn.pipeline import Pipeline, FeatureUnion<br/>from sklearn.impute import SimpleImputer</span><span id="0d61" class="me jy it ma b gy mj mg l mh mi">from sklearn import ensemble</span><span id="ac9d" class="me jy it ma b gy mj mg l mh mi">from sklearn.preprocessing import MaxAbsScaler<br/>from sklearn.preprocessing import FunctionTransformer</span><span id="ddf2" class="me jy it ma b gy mj mg l mh mi">conn = sqlite3.connect('db/wine_data.sqlite')<br/>c = conn.cursor</span><span id="cc61" class="me jy it ma b gy mj mg l mh mi">#create Dataframe<br/>df = pd.read_sql("select country  \<br/>                 ,description     \<br/>                 ,rating          \<br/>                 ,price           \<br/>                 ,province        \<br/>                 ,title           \<br/>                 ,winery from wine_data where variety = 'Chardonnay'", conn)<br/>df.head(2)</span></pre><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/93a366689aebf82c8819b62468568d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crxfZTS4n3Tid7wln8LE4w.png"/></div></div></figure><blockquote class="mp"><p id="7d19" class="mq mr it bd ms mt mu mv mw mx my ls dk translated">注意有多少列包含文本数据。</p></blockquote><p id="7574" class="pw-post-body-paragraph kv kw it kx b ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated">为了在机器学习模型中使用它们，必须使用编码来转换文本。对葡萄酒厂、国家、省份和头衔等分类数据进行编码有几种策略，我将在类别编码器一节中介绍它们。在我对它们进行编码之前，我需要创建一些可能有助于预测模型的特征。</p><h1 id="ae8e" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">创建新功能</h1><p id="1813" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">可以进行特征工程来提取数据中潜在的预测质量，并将其作为一列添加到数据集中。我已经创建了一组函数，接收数据帧并输出转换后的数据帧。使用<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html" rel="noopener ugc nofollow" target="_blank"> Scikit Learn 的函数转换器</a>，我可以使用管道中的函数来转换数据帧。我试图使用全局变量让函数动态化。</p><h2 id="7e67" class="me jy it bd jz ne nf dn kd ng nh dp kh lg ni nj kl lk nk nl kp lo nm nn kt no bi translated">从标题中提取年份</h2><p id="45cf" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我想添加的一个特性是在<strong class="kx iu"> <em class="lu">标题</em> </strong>列中找到的葡萄酒年份。函数<strong class="kx iu"> extract_year </strong>接收一个数据帧并返回一个添加了<strong class="kx iu"> <em class="lu"> year </em> </strong>列的数据帧。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="cc30" class="me jy it ma b gy mf mg l mh mi">def extract_year(dataframe):</span><span id="545b" class="me jy it ma b gy mj mg l mh mi">#set the column name containing the year using a global variable<br/>    global year_column<br/>    years = dataframe[year_column]<br/>    #years.reset_index(inplace=False)<br/>    #years.fillna("", inplace=True)<br/>    l = []<br/>    i = 0 </span><span id="228a" class="me jy it ma b gy mj mg l mh mi">#use for loop to extract the year from each title row<br/>    for year in range(len(dataframe)):<br/>        temp = re.findall(r'\d+', years[i]) <br/>        res = list(map(int, temp)) <br/>        try: <br/>            if len(str(res[0])) == 4:<br/>                l.append(res[0])<br/>            elif len(str(res[0])) != 4:<br/>                l.append(0)<br/>        except:<br/>            l.append(0)<br/>        #print(res[0])<br/>        i+=1<br/>    dataframe['year'] = l</span><span id="e7b3" class="me jy it ma b gy mj mg l mh mi">return dataframe</span></pre><h2 id="367f" class="me jy it bd jz ne nf dn kd ng nh dp kh lg ni nj kl lk nk nl kp lo nm nn kt no bi translated">统计描述中的单词</h2><p id="e954" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在浏览数据集时，我注意到评论较短的葡萄酒往往评级较低。正因为如此，我将把描述的字数添加到模型中，看看它是否是一个预测器。我使用一个依赖于名为 word_count_column 的全局变量的函数来指示使用数据帧的哪一列。它接收一个数据帧并返回一个添加了<strong class="kx iu"> <em class="lu"> word_count </em> </strong>列的数据帧。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="20a0" class="me jy it ma b gy mf mg l mh mi">def word_count(dataframe):<br/>    global word_count_column<br/>    dataframe['word_count'] = dataframe[text].apply(lambda word: len(str(word).split(" ")))<br/>    return dataframe</span></pre><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi np"><img src="../Images/027b8ff0833b3342708cbb69f33c636b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZV3hh3NgUiL3NiJJRmd_A.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Data Frame with Added Features</figcaption></figure><p id="d9b4" class="pw-post-body-paragraph kv kw it kx b ky nu la lb lc nv le lf lg nw li lj lk nx lm ln lo ny lq lr ls im bi translated">我们可以看到这两个函数工作并产生了所需的数据帧。</p><blockquote class="mp"><p id="66c0" class="mq mr it bd ms mt nz oa ob oc od ls dk translated">添加了这两个数字特性后，就该考虑对列<strong class="ak"> <em class="oe">【国家】</em></strong><strong class="ak"><em class="oe">省</em></strong><strong class="ak"><em class="oe">职称</em> </strong>和<strong class="ak"> <em class="oe">酒厂</em> </strong> <em class="oe">中的分类数据进行编码了。</em></p></blockquote><h1 id="2e2d" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki of kk kl km og ko kp kq oh ks kt ku bi translated">类别编码器</h1><p id="c3a0" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">由于机器学习模型将数字作为输入，因此必须对文本进行转换。用于编码数据的策略会对模型的准确性产生很大影响。为了轻松尝试各种编码策略，我推荐使用与 Scikit Learn 一起工作的<a class="ae lt" href="http://contrib.scikit-learn.org/categorical-encoding/index.html" rel="noopener ugc nofollow" target="_blank">类别编码器包</a>。</p><blockquote class="mp"><p id="5d40" class="mq mr it bd ms mt nz oa ob oc od ls dk translated">包中可用的类别编码器与 Pipeline 兼容，因为它们是转换器。</p></blockquote><pre class="oi oj ok ol om lz ma mb mc aw md bi"><span id="c8bb" class="me jy it ma b gy mf mg l mh mi">pip install category_encoders<br/>OR<br/>conda install -c conda-forge category_encoders</span></pre><p id="40c8" class="pw-post-body-paragraph kv kw it kx b ky nu la lb lc nv le lf lg nw li lj lk nx lm ln lo ny lq lr ls im bi translated">包里有 15 个左右的编码器。我建议在模型管道中尝试这些方法，看看不同的策略如何影响模型的准确性。</p><ul class=""><li id="2c81" class="on oo it kx b ky nu lc nv lg op lk oq lo or ls os ot ou ov bi translated"><a class="ae lt" href="http://contrib.scikit-learn.org/categorical-encoding/jamesstein.html" rel="noopener ugc nofollow" target="_blank">詹姆斯-斯坦编码器</a></li><li id="5e30" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><a class="ae lt" href="http://contrib.scikit-learn.org/categorical-encoding/leaveoneout.html" rel="noopener ugc nofollow" target="_blank">漏掉一个</a></li><li id="a26b" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><a class="ae lt" href="http://contrib.scikit-learn.org/categorical-encoding/mestimate.html" rel="noopener ugc nofollow" target="_blank">M-估计值</a></li><li id="6d2f" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><a class="ae lt" href="http://contrib.scikit-learn.org/categorical-encoding/ordinal.html" rel="noopener ugc nofollow" target="_blank">序数</a></li><li id="75fd" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><a class="ae lt" href="http://contrib.scikit-learn.org/categorical-encoding/targetencoder.html" rel="noopener ugc nofollow" target="_blank">目标编码器</a></li></ul><p id="61c0" class="pw-post-body-paragraph kv kw it kx b ky nu la lb lc nv le lf lg nw li lj lk nx lm ln lo ny lq lr ls im bi translated">尽管它们与 Pipeline 兼容，但我创建了一个函数，这样我就可以传入额外的逻辑。我传入一个数据框和两个全局变量来控制在转换中使用哪个类别和目标列。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="15a8" class="me jy it ma b gy mf mg l mh mi"># encoder = ce.JamesSteinEncoder(cols=[...]) --maybe <br/># encoder = ce.LeaveOneOutEncoder(cols=[...]) --maybe<br/># encoder = ce.MEstimateEncoder(cols=[...]) --maybe<br/># encoder = ce.OrdinalEncoder(cols=[...]) --maybe<br/># encoder = ce.TargetEncoder(cols=[...]) --maybe</span><span id="4528" class="me jy it ma b gy mj mg l mh mi">def category_encode(dataframe):<br/>    global category_columns<br/>    global category_target<br/>    x = dataframe[category_columns]<br/>    y = dataframe[target]<br/>    ce_ord = ce.OrdinalEncoder(cols=category_columns)<br/>    dataframe[category_columns] = ce_ord.fit_transform(x, y)<br/>    return dataframe</span></pre><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pb"><img src="../Images/7627c8124914e189f788d53d8a2b4934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyBSbAyfQRbRajr7g_Sxaw.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Example of Ordinal Encoder</figcaption></figure><blockquote class="mp"><p id="d7ea" class="mq mr it bd ms mt mu mv mw mx my ls dk translated">请注意，分类文本列已经转换为数字列。</p></blockquote><p id="c630" class="pw-post-body-paragraph kv kw it kx b ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated"><strong class="kx iu"> <em class="lu">描述</em> </strong>列可以在模型中使用，但是需要经过不同的转换方法。相反，我将使用一个函数从数据帧中选择数字列，并忽略<strong class="kx iu"> <em class="lu">描述</em> </strong>列。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8d95" class="me jy it ma b gy mf mg l mh mi">get_numeric_data = FunctionTransformer(lambda x: x[numeric], validate=False)</span></pre><h1 id="2992" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">建造管道</h1><p id="d776" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">管道很棒，因为它们在转换过程中强制执行顺序，使得工作流紧凑且易于理解。这也可以使作品更容易复制。</p><blockquote class="mp"><p id="32b7" class="mq mr it bd ms mt nz oa ob oc od ls dk translated">请记住，pipeline 使用转换器，因此我们需要在函数上使用 FunctionTransformer，以使它们兼容。</p></blockquote><h2 id="667f" class="me jy it bd jz ne pc dn kd ng pd dp kh lg pe nj kl lk pf nl kp lo pg nn kt no bi translated">创建转换函数</h2><p id="9854" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用 FunctionTransformer，很容易使特征工程和列选择过程中使用的函数与管道兼容。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1b2d" class="me jy it ma b gy mf mg l mh mi">get_year = FunctionTransformer(extract_year, validate=False)<br/>get_word_count = FunctionTransformer(word_count, validate=False)<br/>get_encoded_text = FunctionTransformer(category_encode, validate=False)<br/>get_numeric_data = FunctionTransformer(lambda x: x[numeric], validate=False)</span></pre><p id="32ec" class="pw-post-body-paragraph kv kw it kx b ky nu la lb lc nv le lf lg nw li lj lk nx lm ln lo ny lq lr ls im bi translated">因为有些函数依赖于索引值，所以我需要创建一个函数来重置索引，以便在将数据分成训练集和测试集之后管道能够正常工作。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="635f" class="me jy it ma b gy mf mg l mh mi">def reset_index(dataframe):<br/>    dataframe = dataframe.reset_index(inplace = False)<br/>    return dataframe</span><span id="0d9a" class="me jy it ma b gy mj mg l mh mi">get_reset_index = FunctionTransformer(reset_index, validate=False)</span></pre><h2 id="f9a2" class="me jy it bd jz ne nf dn kd ng nh dp kh lg ni nj kl lk nk nl kp lo nm nn kt no bi translated">设置全局变量</h2><p id="4305" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我创建的函数使用全局变量而不是硬编码的值，因此它们更容易重用。因此，需要设置所有的全局变量:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f61c" class="me jy it ma b gy mf mg l mh mi">year_column = 'title'<br/>word_count_column = 'description'<br/>category_columns = ['country','province','title','winery']<br/>target = 'price'<br/>numeric= ['price', 'year', 'word_count', 'country', 'province', 'title', 'winery']</span></pre><h2 id="d433" class="me jy it bd jz ne nf dn kd ng nh dp kh lg ni nj kl lk nk nl kp lo nm nn kt no bi translated">选择模型</h2><p id="b476" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">管道可用于选择您想要使用的模型。要了解更多关于建立模型选择渠道的信息，我推荐阅读 Rebecca Vickery 的这篇文章。为了简单起见，我只使用 Scikit Learn 中的<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html" rel="noopener ugc nofollow" target="_blank">梯度提升回归器。</a></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5485" class="me jy it ma b gy mf mg l mh mi">#create Gradient Boosting Regressor model <br/>model = ensemble.GradientBoostingRegressor(<br/>    n_estimators = 100, #how many decision trees to build<br/>    learning_rate = 0.5, #controls rate at which additional decision trees influes overall prediction<br/>    max_depth = 6, <br/>    min_samples_split = 21,<br/>    min_samples_leaf = 19, <br/>    max_features = 0.9,<br/>    loss = 'huber'<br/>)</span></pre><h2 id="4579" class="me jy it bd jz ne nf dn kd ng nh dp kh lg ni nj kl lk nk nl kp lo nm nn kt no bi translated">把它放到管道里</h2><p id="9c39" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一旦选择了模型，设置了全局变量，并且所有函数都已转换并与管道兼容，就该将这些部分组合在一起了:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="de9e" class="me jy it ma b gy mf mg l mh mi">pl = Pipeline(memory=None,<br/>    steps=[<br/>        ('reset_index', get_reset_index),<br/>        ('year', get_year),<br/>        ('word_count', get_word_count),<br/>        ('encode', get_encoded_text),<br/>        ('selector', get_numeric_data),<br/>        ('model', model)<br/>    ], verbose=True)</span></pre><blockquote class="mp"><p id="e82b" class="mq mr it bd ms mt mu mv mw mx my ls dk translated">注意，我设置了 Verbose = True。这样打印步骤就完成了。这使得调试过程更加透明。</p></blockquote><figure class="oi oj ok ol om ju gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/a64c4219d45bacb86de60a86f38dfb9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*jD6g23QE3qHRA4MhwL4fFg.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Verbose = True output</figcaption></figure><h2 id="2781" class="me jy it bd jz ne nf dn kd ng nh dp kh lg ni nj kl lk nk nl kp lo nm nn kt no bi translated">把所有的放在一起</h2><p id="b056" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">要测试管道，使用列车测试分割来分割数据，并通过管道运行:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2fea" class="me jy it ma b gy mf mg l mh mi">features = df.drop(['rating'], axis=1)</span><span id="c791" class="me jy it ma b gy mj mg l mh mi">X = features<br/>y = df['rating']<br/>X_train, X_test, y_train, y_test = train_test_split(X, y<br/>                                                   , test_size = .3<br/>                                                   #, stratify=y<br/>                                                   )<br/>pl.fit(X_train, y_train)<br/>pl.score(X_test, y_test)</span></pre><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/3a0dec58e7328c3b8bc742cf0ea5f9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*ZKJ_ShO0CAXTOt6w2rZI1w.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Score</figcaption></figure><h1 id="c42d" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">完整的代码</h1><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ee3f" class="me jy it ma b gy mf mg l mh mi">import numpy as np<br/>import pandas as pd<br/>import sqlite3<br/>import category_encoders as ce<br/>import re</span><span id="816b" class="me jy it ma b gy mj mg l mh mi">from sklearn.feature_selection import chi2, SelectKBest<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.feature_extraction.text import HashingVectorizer</span><span id="2c3f" class="me jy it ma b gy mj mg l mh mi">from sklearn.pipeline import Pipeline, FeatureUnion<br/>from sklearn.impute import SimpleImputer</span><span id="b72e" class="me jy it ma b gy mj mg l mh mi">from sklearn.linear_model import LogisticRegression</span><span id="9d8f" class="me jy it ma b gy mj mg l mh mi">from sklearn.preprocessing import MaxAbsScaler<br/>from sklearn.preprocessing import FunctionTransformer</span><span id="33fb" class="me jy it ma b gy mj mg l mh mi">conn = sqlite3.connect('db/wine_data.sqlite')<br/>c = conn.cursor</span><span id="9e21" class="me jy it ma b gy mj mg l mh mi">#create Dataframe<br/>df = pd.read_sql("select country  \<br/>                 ,description     \<br/>                 ,rating          \<br/>                 ,price           \<br/>                 ,province        \<br/>                 ,title           \<br/>                 ,winery from wine_data where variety = 'Chardonnay'", conn)<br/>#df.head(2)</span><span id="06d8" class="me jy it ma b gy mj mg l mh mi">def extract_year(dataframe):<br/>    global year_column<br/>    years = dataframe[year_column]<br/>    #years.reset_index(inplace=False)<br/>    #years.fillna("", inplace=True)<br/>    l = []<br/>    i = 0 <br/>    for year in range(len(dataframe)):<br/>        temp = re.findall(r'\d+', years[i]) <br/>        res = list(map(int, temp)) <br/>        try: <br/>            if len(str(res[0])) == 4:<br/>                l.append(res[0])<br/>            elif len(str(res[0])) != 4:<br/>                l.append(0)<br/>        except:<br/>            l.append(0)<br/>        #print(res[0])<br/>        i+=1<br/>    dataframe['year'] = l</span><span id="5e13" class="me jy it ma b gy mj mg l mh mi">return dataframe<br/>#df = extract_year(df)</span><span id="57b4" class="me jy it ma b gy mj mg l mh mi">def word_count(dataframe):<br/>    global word_count_column<br/>    dataframe['word_count'] = dataframe[word_count_column].apply(lambda word: len(str(word).split(" ")))<br/>    return dataframe<br/># df = word_count(df)<br/># df.head(3)</span><span id="49af" class="me jy it ma b gy mj mg l mh mi"># encoder = ce.JamesSteinEncoder(cols=[...]) --maybe (best score)<br/># encoder = ce.LeaveOneOutEncoder(cols=[...]) --maybe<br/># encoder = ce.MEstimateEncoder(cols=[...]) --maybe (good)<br/># encoder = ce.OrdinalEncoder(cols=[...]) --maybe<br/># encoder = ce.TargetEncoder(cols=[...]) --maybe</span><span id="f281" class="me jy it ma b gy mj mg l mh mi">year_column = 'title'<br/>word_count_column = 'description'<br/>category_columns = ['country','province','title','winery']<br/>target = 'price'<br/>combine_text = ['country','province','title','winery', 'description']<br/>numeric= ['price', 'year', 'word_count','country','province','title','winery']</span><span id="0408" class="me jy it ma b gy mj mg l mh mi">def category_encode(dataframe):<br/>    global category_columns<br/>    global category_target<br/>    x = dataframe[category_columns]<br/>    y = dataframe[target]<br/>    ce_ord = ce.OrdinalEncoder(cols=category_columns)<br/>    dataframe[category_columns] = ce_ord.fit_transform(x, y)<br/>    return dataframe</span><span id="f88c" class="me jy it ma b gy mj mg l mh mi"># df = category_encode(df)<br/># df.head()</span><span id="ea6a" class="me jy it ma b gy mj mg l mh mi">get_year = FunctionTransformer(extract_year, validate=False)</span><span id="399c" class="me jy it ma b gy mj mg l mh mi">get_word_count = FunctionTransformer(word_count, validate=False)</span><span id="4a03" class="me jy it ma b gy mj mg l mh mi">get_encoded_text = FunctionTransformer(category_encode, validate=False)</span><span id="1272" class="me jy it ma b gy mj mg l mh mi">get_numeric_data = FunctionTransformer(lambda x: x[numeric], validate=False)</span><span id="5dbb" class="me jy it ma b gy mj mg l mh mi">def reset_index(dataframe):<br/>    dataframe = dataframe.reset_index(inplace = False)<br/>    return dataframe</span><span id="aa4c" class="me jy it ma b gy mj mg l mh mi">get_reset_index = FunctionTransformer(reset_index, validate=False)</span><span id="3973" class="me jy it ma b gy mj mg l mh mi">from sklearn import ensemble <br/>model = ensemble.GradientBoostingRegressor(<br/>    n_estimators = 100, #how many decision trees to build<br/>    learning_rate = 0.5, #controls rate at which additional decision trees influes overall prediction<br/>    max_depth = 6, <br/>    min_samples_split = 21,<br/>    min_samples_leaf = 19, <br/>    max_features = 0.9,<br/>    loss = 'huber'<br/>)</span><span id="1f57" class="me jy it ma b gy mj mg l mh mi">pl = Pipeline(memory=None,<br/>    steps=[<br/>        ('reset_index', get_reset_index),<br/>        ('year', get_year),<br/>        ('word_count', get_word_count),<br/>        ('encode', get_encoded_text),<br/>        ('selector', get_numeric_data),<br/>        ('model', model)<br/>    ], verbose=False)</span><span id="3f73" class="me jy it ma b gy mj mg l mh mi">features = df.drop(['rating'], axis=1)</span><span id="f608" class="me jy it ma b gy mj mg l mh mi">X = features<br/>y = df['rating']<br/>X_train, X_test, y_train, y_test = train_test_split(X, y<br/>                                                   , test_size = .3<br/>                                                   #, stratify=y<br/>                                                   )<br/>pl.fit(X_train, y_train)</span><span id="df8c" class="me jy it ma b gy mj mg l mh mi">pl.score(X_test, y_test)</span></pre><h1 id="12c5" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">开源代码库</h1><div class="pj pk gp gr pl pm"><a href="https://github.com/bendgame/wine_rating_predictions" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">bend game/wine _ rating _ 预测</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa jv pm"/></div></div></a></div><h1 id="8359" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">谢谢大家！</h1><ul class=""><li id="c4c6" class="on oo it kx b ky kz lc ld lg qb lk qc lo qd ls os ot ou ov bi translated"><em class="lu">如果你喜欢这个，</em> <a class="ae lt" href="https://medium.com/@erickleppen" rel="noopener"> <em class="lu">在 Medium 上关注我</em> </a> <em class="lu">了解更多</em></li><li id="890c" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><a class="ae lt" href="https://erickleppen.medium.com/membership" rel="noopener"> <em class="lu">通过订阅</em> </a>获得对我的内容的完全访问和帮助支持</li><li id="276c" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><em class="lu">我们连线上</em> <a class="ae lt" href="https://www.linkedin.com/in/erickleppen01/" rel="noopener ugc nofollow" target="_blank"> <em class="lu"> LinkedIn </em> </a></li><li id="9395" class="on oo it kx b ky ow lc ox lg oy lk oz lo pa ls os ot ou ov bi translated"><em class="lu">用 Python 分析数据？查看我的</em> <a class="ae lt" href="https://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lu">网站</em> </a></li></ul><p id="3f61" class="pw-post-body-paragraph kv kw it kx b ky nu la lb lc nv le lf lg nw li lj lk nx lm ln lo ny lq lr ls im bi translated"><a class="ae lt" href="http://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> —埃里克·克莱本</strong> </a></p></div></div>    
</body>
</html>