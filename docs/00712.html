<html>
<head>
<title>Python Basics: Mutable vs Immutable Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 基础:可变对象与不可变对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a?source=collection_archive---------2-----------------------#2019-02-03">https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a?source=collection_archive---------2-----------------------#2019-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/044252366a12e97c6c494bd9dbcff312.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WWrXceae4H_klzpPU6h7Hg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Source: <a class="ae jy" href="https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman</a></figcaption></figure><p id="7d2f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">读完这篇博客后，你会知道:</p><ul class=""><li id="723f" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">什么是对象的<strong class="kb ir">身份</strong>、<strong class="kb ir">类型</strong>和<strong class="kb ir">值</strong></li><li id="7e16" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">什么是<strong class="kb ir">可变</strong>和<strong class="kb ir">不可变</strong> <strong class="kb ir">对象</strong></li></ul><h1 id="3d72" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">简介(对象、值和类型)</h1><p id="ce7b" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">Python 代码中的所有数据都由对象或对象之间的关系来表示。每个对象都有标识、类型和值。</p><h2 id="df55" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">身份</h2><blockquote class="na nb nc"><p id="e106" class="jz ka nd kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ij bi translated">一个对象的<em class="iq">标识</em> <strong class="kb ir">一旦被创建</strong>就不会改变<strong class="kb ir">；你可能认为它是内存中<strong class="kb ir">对象的地址</strong>。<code class="fe nh ni nj nk b"><a class="ae jy" href="https://docs.python.org/3/reference/expressions.html#is" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir">is</strong></a></code> <strong class="kb ir">运算符</strong>比较两个对象的身份；<code class="fe nh ni nj nk b"><a class="ae jy" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir">id()</strong></a></code> <strong class="kb ir">函数</strong>返回一个表示其身份的整数。</strong></p></blockquote><h2 id="71db" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">类型</h2><p id="1379" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">一个对象的类型定义了<strong class="kb ir">可能的值</strong> <strong class="kb ir">和操作</strong>(例如“它有长度吗？”)该类型支持。<code class="fe nh ni nj nk b"><a class="ae jy" href="https://docs.python.org/3/library/functions.html#type" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir">type()</strong></a></code> <strong class="kb ir">函数</strong>返回对象的类型。像身份一样，对象类型<strong class="kb ir">是不可改变的</strong>。</p><h2 id="0a98" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">价值</h2><blockquote class="na nb nc"><p id="b280" class="jz ka nd kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ij bi translated">某些对象的<em class="iq">值</em>可以改变。值可以变化的对象<strong class="kb ir">被称为</strong>可变<strong class="kb ir"><em class="iq"/></strong>；一旦被创建，其值不可改变的对象<strong class="kb ir"/>称为<strong class="kb ir"><em class="iq"/></strong>。</p></blockquote><p id="fbd2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">对象的可变性是由其类型决定的。</p><p id="3c82" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">重要提示<br/> </strong>有些对象包含对其他对象的引用，这些对象被称为<strong class="kb ir">容器</strong>。容器的一些例子有<strong class="kb ir">元组</strong>、<strong class="kb ir">列表</strong>和<strong class="kb ir">字典</strong>。如果可变对象被改变，包含对可变对象 <strong class="kb ir">的<strong class="kb ir">引用的不可变容器</strong>的<strong class="kb ir">值可以被改变</strong>。然而，容器仍然被认为是不可变的，因为当我们谈论容器</strong>的<strong class="kb ir">可变性时，只有被包含对象的<strong class="kb ir">身份</strong>是隐含的。</strong></p><p id="bc8b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在下一节中，我们将看到更多的信息和详细的例子来理解可变和不可变对象之间的区别。</p><h1 id="d831" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Python 中的可变和不可变数据类型</h1><ul class=""><li id="5044" class="kx ky iq kb b kc mj kg mk kk nl ko nm ks nn kw lc ld le lf bi translated">Python 中的一些<strong class="kb ir">可变</strong>数据类型有<strong class="kb ir">列表、字典、集合</strong>和<strong class="kb ir">用户自定义类</strong>。</li><li id="ce6a" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">另一方面，一些<strong class="kb ir">不可变的</strong>数据类型是<strong class="kb ir"> int、float、decimal、bool、string、tuple 和 range </strong>。</li></ul><p id="f571" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">是时候举些例子了。先来比较一下<strong class="kb ir">元组</strong> ( <strong class="kb ir">不可变</strong>)和<strong class="kb ir">列表</strong> ( <strong class="kb ir">可变</strong>)的数据类型。我们可以像这样用<strong class="kb ir">方括号</strong> <code class="fe nh ni nj nk b"><strong class="kb ir">[]</strong></code>定义一个列表:<code class="fe nh ni nj nk b">numbers = [1, 2, 3]</code>。定义一个 tuple，我们只需要把括号替换成<strong class="kb ir">圆括号</strong> <code class="fe nh ni nj nk b"><strong class="kb ir">()</strong></code> <strong class="kb ir"> </strong>就像这样:<code class="fe nh ni nj nk b">numbers = (1, 2, 3)</code>。从这两种数据类型中，我们可以通过索引访问元素，并且可以对它们进行迭代。主要区别在于元组一旦定义就不能更改。</p><h2 id="f249" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">索引列表和元组</h2><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c487" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="d93b" class="mo lm iq nk b gy ny nz l oa ob">1<br/>10</span></pre><h2 id="3e1b" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">改变值:列表与元组</h2><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="21a5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="2fc8" class="mo lm iq nk b gy ny nz l oa ob">[100, 2, 3]</span><span id="6df4" class="mo lm iq nk b gy oc nz l oa ob"><strong class="nk ir">--------------------------------------------------------------------</strong><br/><strong class="nk ir">TypeError</strong>                         Traceback (most recent call last)<br/><strong class="nk ir">&lt;ipython-input-2-286c46a29f5d&gt;</strong> in &lt;module&gt;<strong class="nk ir">()</strong><br/>      3 list_values<strong class="nk ir">[0]</strong> <strong class="nk ir">=</strong> <strong class="nk ir">100</strong><br/>      4 print<strong class="nk ir">(</strong>list_values<strong class="nk ir">)</strong><br/><strong class="nk ir">----&gt; 5 </strong>set_values<strong class="nk ir">[0]</strong> <strong class="nk ir">=</strong> <strong class="nk ir">100</strong><br/><br/><strong class="nk ir">TypeError</strong>: 'tuple' object does not support item assignment</span></pre><p id="f0e6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们可以看到，当我们试图改变元组时，我们得到了一个错误，但我们没有这个问题的列表。</p><h2 id="d336" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">元组与列表扩展</h2><p id="2d40" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">现在，我们可以尝试使用<code class="fe nh ni nj nk b">+=</code>操作符来扩展我们的列表和元组。这将对两种数据类型都起作用。让我们看看会发生什么。</p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8e88" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="48d8" class="mo lm iq nk b gy ny nz l oa ob">2450343168136<br/>2450343205552<br/><br/>2450343168136<br/>2450341742248</span></pre><p id="71a9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们可以看到，列表标识没有改变，而元组标识改变了。这意味着<strong class="kb ir">扩展了我们的列表</strong>，但是<strong class="kb ir">创建了</strong>一个完全<strong class="kb ir">的新元组</strong>。列表比元组更节省内存。</p><h2 id="df4f" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">其他不可变数据类型示例</h2><p id="019e" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">我们已经看到其他一些不可变的数据类型是整数和字符串。一旦它们被初始化，<strong class="kb ir">它们的值就不能被改变</strong>。</p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="60a8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="5890" class="mo lm iq nk b gy ny nz l oa ob">1657696608<br/>1657696640</span></pre><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ac31" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="3bab" class="mo lm iq nk b gy ny nz l oa ob">2450343168944<br/>2450343426208</span></pre><p id="ab6d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们看到，对于数字和文本变量，它们的<strong class="kb ir">标识都发生了变化</strong>。这意味着<strong class="kb ir">新变量</strong>在两种情况下都被创建。</p><h2 id="2536" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">通过引用复制可变对象</h2><p id="a1ec" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">让我们看看，如果我们为一个可变数据类型给同一个对象的两个名字<strong class="kb ir">会发生什么。</strong></p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ddb5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="81d7" class="mo lm iq nk b gy ny nz l oa ob">2450343166664<br/>2450343166664<br/>True<br/>[4, 5, 6, 7]<br/>[4, 5, 6, 7]</span></pre><p id="6ad5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们可以看到变量名具有相同的标识，这意味着它们引用了计算机内存中相同的对象。提醒:<code class="fe nh ni nj nk b"><a class="ae jy" href="https://docs.python.org/3/reference/expressions.html#is" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir">is</strong></a></code> <strong class="kb ir">运算符</strong>比较两个对象的身份。</p><p id="c0cd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">所以，当我们改变第二个变量的值时，第一个变量的值也会改变。这只发生在可变对象上。你可以在我之前的博客文章中看到如何避免这种情况。</p><h2 id="c7d6" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">复制不可变对象</h2><p id="2dac" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">让我们尝试用一个不可变的对象做一个类似的例子。我们可以尝试复制两个字符串，并更改其中任何一个字符串的值。</p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="809b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="c99e" class="mo lm iq nk b gy ny nz l oa ob">3063511450488<br/>3063511450488<br/>True<br/><br/>3063551623648<br/>3063511450488<br/>False<br/><br/>Python is awesome<br/>Python</span></pre><p id="0c10" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">每次当我们试图用<strong class="kb ir">更新一个不可变对象</strong>的值时，一个新的<strong class="kb ir">对象就会被创建</strong>。当我们更新第一个字符串时，第二个字符串的值不会改变。</p><h2 id="a3b8" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">==运算符</h2><p id="2728" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">有时候我们不是要比较两个对象的同一性，而是要比较这些对象的价值。我们可以使用<code class="fe nh ni nj nk b">==</code>操作符来做到这一点。</p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b6fa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="34ab" class="mo lm iq nk b gy ny nz l oa ob">True<br/>False</span></pre><p id="9778" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们可以清楚地看到这两个对象具有相同的值，但是它们的身份不同。</p><h2 id="f441" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kk mt mu lz ko mv mw md ks mx my mh mz bi translated">不可变对象改变它的值</h2><p id="e662" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">正如我们之前所说的，如果可变对象被改变，包含对可变对象的引用的<strong class="kb ir">不可变容器</strong>的值可以被改变。让我们来看一个例子。</p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="848a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="3c7d" class="mo lm iq nk b gy ny nz l oa ob">&lt;class 'tuple'&gt;<br/>(129392130, ['Programming', 'Machine Learning', 'Statistics'])<br/>(129392130, ['Programming', 'Machine Learning', 'Maths'])</span></pre><p id="95be" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们已经改变了<code class="fe nh ni nj nk b">skills</code>变量的值。另一个变量<code class="fe nh ni nj nk b">person</code>包含对<code class="fe nh ni nj nk b">skills</code>变量的引用，这也是它的值被更新的原因。</p><p id="a071" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">提醒</strong> <br/>对象仍然被认为是不可变的，因为当我们谈论容器的<strong class="kb ir">可变性时，只有被包含对象的<strong class="kb ir">标识</strong>是隐含的。</strong></p><p id="8da3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然而，如果你的不可变对象只包含不可变对象，我们不能改变它们的值。让我们看一个例子。</p><figure class="no np nq nr gt jq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="aad3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="no np nq nr gt nu nk nv nw aw nx bi"><span id="dabb" class="mo lm iq nk b gy ny nz l oa ob">1657696608<br/>1657696032<br/>(42, 24, ('Python', 'pandas', 'scikit-learn'))<br/>1657696864<br/>1657696064<br/>(42, 24, ('Python', 'pandas', 'scikit-learn'))</span></pre><p id="371b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">请记住，当您试图更新一个不可变对象的值时，会创建一个新的对象。</p><h1 id="3729" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><ul class=""><li id="d11f" class="kx ky iq kb b kc mj kg mk kk nl ko nm ks nn kw lc ld le lf bi translated">Python 代码中所有的<strong class="kb ir">数据</strong>都是用对象或对象之间的<strong class="kb ir">关系</strong>来表示的<strong class="kb ir">。</strong></li><li id="e3f9" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">每个对象都有一个<strong class="kb ir">标识</strong>，一个<strong class="kb ir">类型</strong>，以及一个<strong class="kb ir">值</strong>。</li><li id="cab6" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">对象的标识<strong class="kb ir">一旦被创建就不会改变</strong> <strong class="kb ir">。</strong>你可以认为它是<strong class="kb ir">对象在内存</strong>中的地址。</li><li id="7f7d" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">一个对象的类型定义了<strong class="kb ir">可能的值</strong> <strong class="kb ir">和操作</strong>。</li><li id="26b0" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">值可以改变的对象<strong class="kb ir">称为</strong>可变的<strong class="kb ir"> <em class="nd">。</em> </strong>对象<strong class="kb ir">一旦被创建，其值就不可改变</strong>的对象称为<strong class="kb ir"><em class="nd"/></strong>。</li><li id="029c" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">当我们谈论容器的<strong class="kb ir">可变性时，只有被包含对象的<strong class="kb ir">身份</strong>是隐含的。</strong></li></ul><h1 id="5c9a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">资源</h1><ul class=""><li id="40f4" class="kx ky iq kb b kc mj kg mk kk nl ko nm ks nn kw lc ld le lf bi translated"><a class="ae jy" href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects/" rel="noopener ugc nofollow" target="_blank">https://www . python forthe lab . com/blog/mutable-and-immutable-objects/</a></li><li id="5d97" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://standupdev.com/wiki/doku.php?id=python_tuples_are_immutable_but_may_change" rel="noopener ugc nofollow" target="_blank">https://standupdev.com/wiki/doku.php?id = python _ tuples _ are _ immutable _ but _ may _ change</a></li><li id="f922" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://www.geeksforgeeks.org/mutable-vs-immutable-objects-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/mutable-vs-immutable-objects-in-python/</a></li><li id="9e1b" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/datamodel.html</a></li><li id="9099" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/functions.html#id</a></li></ul><h1 id="7d22" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我的其他博客文章</h1><p id="9803" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">你也可以看看我以前的博文。</p><ul class=""><li id="0b50" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><a class="ae jy" href="https://medium.com/@ventsislav94/jypyter-notebook-shortcuts-bf0101a98330" rel="noopener"> Jupyter 笔记本快捷键</a></li><li id="4c37" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/python-basics-for-data-science-6a6c987f2755">数据科学的 Python 基础知识</a></li><li id="4b70" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/python-basics-iteration-and-looping-6ca63b30835c"> Python 基础:迭代、可迭代、迭代器和循环</a></li><li id="fab8" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/python-basics-list-comprehensions-631278f22c40"> Python 基础:列表理解</a></li><li id="9664" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-data-visualization-and-matplotlib-5f799b7c6d82">Python 数据科学:Matplotlib 数据可视化简介</a></li><li id="1ad2" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-loading-and-subsetting-data-with-pandas-9f26895ddd7f">使用 Python 的数据科学:使用 pandas 加载、子集化和过滤数据简介</a></li><li id="1833" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="http://Introduction to Natural Language Processing for Text" rel="noopener ugc nofollow" target="_blank">文本自然语言处理导论</a></li></ul><h1 id="b1d6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">时事通讯</h1><p id="eb95" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">如果你想在我发表新的博客文章时得到通知，你可以订阅<a class="ae jy" href="https://buttondown.email/Ventsislav" rel="noopener ugc nofollow" target="_blank">我的简讯</a>。</p><h1 id="6d42" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">商务化人际关系网</h1><p id="517f" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">这是我在 LinkedIn 上的简介，如果你想和我联系的话。我将很高兴与你联系在一起。</p><h1 id="f04d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最后的话</h1><p id="a0da" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">谢谢你的阅读。我希望你喜欢这篇文章。如果你喜欢，请按住拍手键，分享给你的朋友。我很高兴听到你的反馈。如果你有什么问题，尽管问。😉</p></div></div>    
</body>
</html>