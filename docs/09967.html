<html>
<head>
<title>Creating Graphs in Python using Networkx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Networkx 在 Python 中创建图表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-to-graphs-in-python-using-networkx-cfc84d1df31f?source=collection_archive---------11-----------------------#2019-12-30">https://towardsdatascience.com/intro-to-graphs-in-python-using-networkx-cfc84d1df31f?source=collection_archive---------11-----------------------#2019-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7ece" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/graphs-and-data-science" rel="noopener" target="_blank">图表和数据科学</a></h2><div class=""/><div class=""><h2 id="604e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用 Python 构建第一个图表的介绍</h2></div><p id="8321" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你对用 Python 做图论分析感兴趣，并且想知道从哪里开始，那么这是给你的博客。我们将首先介绍几个关键概念，然后使用方便的 Networkx 包在 Python 中实现它们。</p><h2 id="2556" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">一些图论术语</h2><ul class=""><li id="f48f" class="mf mg it kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">一个<strong class="kt jd">图</strong> <em class="mq"> G </em> ( <em class="mq"> V </em>，<em class="mq"> E </em>)是由一组顶点(<em class="mq"> V </em>)和一组边(<em class="mq"> E </em>)定义的数据结构。</li><li id="a378" class="mf mg it kt b ku mr kx ms la mt le mu li mv lm mm mn mo mp bi translated"><strong class="kt jd">顶点</strong> ( <em class="mq"> v </em>)或节点是一个不可分割的点，由下图中的字母组件表示</li><li id="0dfb" class="mf mg it kt b ku mr kx ms la mt le mu li mv lm mm mn mo mp bi translated">一条<strong class="kt jd">边</strong> ( <em class="mq"> vu </em>)将顶点<em class="mq"> v </em>和顶点<em class="mq"> u </em>连接在一起。</li><li id="d16c" class="mf mg it kt b ku mr kx ms la mt le mu li mv lm mm mn mo mp bi translated">由 n 个顶点组成的完全图是这样一个图，其中每个顶点与其他所有顶点共享一条边，因此包含最多的边。</li><li id="aadc" class="mf mg it kt b ku mr kx ms la mt le mu li mv lm mm mn mo mp bi translated">任何有<em class="mq"> n </em>个顶点的简单图的<strong class="kt jd">最大可能边集</strong>的大小等于(<em class="mq"> n </em> *( <em class="mq"> n </em> -1))/2。这是因为它相当于顶点对组合的数量，即。(<em class="mq"> n </em>选 2) = <em class="mq"> n </em>！/( ( <em class="mq"> n </em> -2)！(2!)).</li><li id="0c6c" class="mf mg it kt b ku mr kx ms la mt le mu li mv lm mm mn mo mp bi translated">图<em class="mq"> G </em> ( <em class="mq"> V </em>，<em class="mq"> E </em>)的顶点 s 上的一个<strong class="kt jd">诱导子图</strong><em class="mq">g</em><em class="mq">g</em><em class="mq">s</em>是这样一个图，使得<em class="mq"> S </em> ⊂ <em class="mq"> V </em>和<em class="mq"> G </em> [ <em class="mq"> S </em>的边集合由</li><li id="d2a6" class="mf mg it kt b ku mr kx ms la mt le mu li mv lm mm mn mo mp bi translated">图<em class="mq"> G </em>的一个<strong class="kt jd">团</strong> C 是 G 的任何诱导子图，它也是一个完全图</li></ul><h2 id="24e3" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">安装软件包并创建您的第一个图表</h2><p id="3759" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">您需要做的第一件事是在您的机器上安装 Networkx 包。使用 Pip 非常简单:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5bf7" class="ln lo it ne b gy ni nj l nk nl">pip install networkx</span></pre><p id="1a81" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">安装完成后，导入包并初始化图形对象</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="a3a2" class="ln lo it ne b gy ni nj l nk nl">import networkx as nx</span><span id="6bc9" class="ln lo it ne b gy nm nj l nk nl">G = nx.Graph()</span></pre><p id="3df6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">添加前两个节点以及它们之间的边</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b621" class="ln lo it ne b gy ni nj l nk nl">G.add_node(1)<br/>G.add_node(2)<br/>G.add_edge(1, 2)</span></pre><p id="f826" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这一点上，我们的图只是两个相连的节点</p><figure class="mz na nb nc gt no gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nn"><img src="../Images/5efe482d1f659377bf1525626180f98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRg5do-kcmCZLkyuelSUvw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Fig. 1 A two vertex Graph</figcaption></figure><p id="b3d3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一次添加一条边非常慢，但幸运的是，我们还可以添加节点列表和边列表，其中每条边由一个节点元组表示。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="26bc" class="ln lo it ne b gy ni nj l nk nl">G.add_nodes_from([2,3,4,5,6])<br/>G.add_edges_from([(1,2),(4,5),(3,5),(2,3),(5,6)])</span></pre><p id="58d6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的图表现在应该看起来像这样</p><figure class="mz na nb nc gt no gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nn"><img src="../Images/6b7ffeb1305bd96dc68a87d3029e94c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0hNmcQ9KgthuJXWJr9kSg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Fig 2. Our graph now has seven vertices</figcaption></figure><h2 id="53de" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">访问和存储信息</h2><p id="5154" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">通过打印图形的这些属性，我们可以看到节点或边的列表。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0ad9" class="ln lo it ne b gy ni nj l nk nl">print(G.nodes())<br/>&gt;&gt;&gt;[0, 1, 2, 3, 4, 5, 6]<br/>print(G.edges())<br/>&gt;&gt;&gt;[(0, 1), (1, 2), (2, 3), (3, 4), (3, 5), (5, 6)]</span></pre><p id="9f45" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">也可以将节点定义为字符串。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f637" class="ln lo it ne b gy ni nj l nk nl">G.add_node('ib')<br/>G.add_edge(3,'ib')</span></pre><p id="9589" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最重要的是，可以为每个节点分配任意数量的属性，然后存储在字典中。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="cd9d" class="ln lo it ne b gy ni nj l nk nl">G.nodes[1]['color'] = 'red'<br/>G.nodes[1]['count'] = 10<br/>print(G.nodes.data())<br/>&gt;&gt;&gt;[(0, {}), (1, {'color': 'red', 'count': 10}), (2, {}), (3, {}), (4, {}), (5, {}), (6, {}), ('ib', {})]</span></pre><p id="a7c6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了使这些数据更易于管理，将 nodes.data()的输出提供给一个 dict()函数，让它进入一个可爱的嵌套字典，其中每个节点都是一个键。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="95db" class="ln lo it ne b gy ni nj l nk nl">print(dict(G.nodes.data()))<br/>{0: {}, 1: {'color': 'red', 'count': 10}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 'ib': {}}</span></pre><h2 id="c39b" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">最大团估计</h2><p id="8fa9" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">为了找到最大团，我们需要从 networkx 导入近似包，因为它不包含在默认导入中</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2aa9" class="ln lo it ne b gy ni nj l nk nl">from networkx.algorithms import approximation as aprx</span></pre><p id="c97b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，为了测试最大团，我们将通过添加边(4，6)在当前图中创建一个大小为 3 的团</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d5f5" class="ln lo it ne b gy ni nj l nk nl">G.add_edge(4,6)</span></pre><figure class="mz na nb nc gt no gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nn"><img src="../Images/3129368c90225a9a426b07b75893a640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1--d_j3uKVaw4kt8GC5NA.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Fig 3. Now with 8 vertices and a clique of size 3</figcaption></figure><p id="10e5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，顶点集{4，5，6}包含我们的最大团大小为 3，该顶点集正是 max_clique 函数将返回的。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f449" class="ln lo it ne b gy ni nj l nk nl">print(aprx.max_clique(G))<br/>&gt;&gt;&gt;{4, 5, 6}<br/>print(len(approximation.max_clique(G)))<br/>&gt;&gt;&gt;3</span></pre><p id="d6a2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要查看该顶点集的诱导子图，我们需要将上述与子图方法结合起来</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8154" class="ln lo it ne b gy ni nj l nk nl">max_clique = G.subgraph(approximation.max_clique(G))</span></pre><p id="5a81" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这将为我们提供以下完整的 3 顶点图。</p><figure class="mz na nb nc gt no gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nn"><img src="../Images/8b3d194b6f7e16d020afd36e2521891a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjruYdTLd7rC9pKFzjqktA.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">The induced subgraph of the maximum clique</figcaption></figure><p id="2ba1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">最后的想法和问题</strong></p><p id="3e3e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Python 有很多图形库，但我选择了 Networkx，因为它可读性强、易于设置，尤其是因为它有出色的文档。如果您有任何进一步的问题或希望更多地探索图书馆，请参考<a class="ae nz" href="https://networkx.github.io/documentation/stable/index.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="0aec" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">来源</strong></p><p id="271b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae nz" href="https://networkx.github.io/" rel="noopener ugc nofollow" target="_blank">https://networkx.github.io/</a><br/><a class="ae nz" href="https://en.wikipedia.org/wiki/Induced_subgraph" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Induced_subgraph</a><br/><a class="ae nz" href="https://en.wikipedia.org/wiki/Clique_(graph_theory)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Clique _(graph _ theory)</a></p></div></div>    
</body>
</html>