<html>
<head>
<title>3 techniques to make your Python code faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高 Python 代码速度的 3 种技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-techniques-to-make-your-python-code-faster-193ffab5eb36?source=collection_archive---------6-----------------------#2019-12-28">https://towardsdatascience.com/3-techniques-to-make-your-python-code-faster-193ffab5eb36?source=collection_archive---------6-----------------------#2019-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="030f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你甚至不会流汗</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0e03e0ade3e74c434c3e7ef18ea5e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61rQGzv3je-93T5_XyHd-w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://pixabay.com/images/id-332857/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="e74c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将分享你在日常脚本中可能用到的 3 种 Python 效率技巧，以及如何衡量 2 种解决方案之间的性能提升。我们开始吧！</p><h1 id="d3fa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们如何比较两个候选解决方案的性能？</h1><p id="0bd3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">性能可能指解决方案中的许多不同因素(例如，执行时间、CPU 使用率、内存使用率等)。).不过，在本文中，我们将重点关注执行时间。</p><p id="7909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新解决方案在执行时间上的改进可以像除法一样简单地计算出来。也就是说，我们将旧的(或未优化的)解决方案的执行时间除以新的(或优化的)解决方案:tell/Tnew。这个指标通常被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Speedup" rel="noopener ugc nofollow" target="_blank">加速</a>。例如，如果我们的加速因子为 2，我们改进的解决方案将花费原始解决方案一半的时间。</p><p id="0676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了比较我们函数的性能，我们将创建一个函数来接收这两个函数，计算它们的执行时间，并计算获得的加速比:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3ef6" class="mx lw it mt b gy my mz l na nb">import time</span><span id="94b0" class="mx lw it mt b gy nc mz l na nb">def compute_speedup(slow_func, opt_func, func_name, tp=None):<br/>  x = range(int(1e5))<br/>  if tp: x = list(map(tp, x))</span><span id="611a" class="mx lw it mt b gy nc mz l na nb">  slow_start = time.time()<br/>  slow_func(x)<br/>  slow_end = time.time()<br/>  slow_time = slow_end - slow_start</span><span id="d4ae" class="mx lw it mt b gy nc mz l na nb">  opt_start = time.time()<br/>  opt_func(x)<br/>  opt_end = time.time()<br/>  opt_time = opt_end - opt_start</span><span id="32aa" class="mx lw it mt b gy nc mz l na nb">  speedup = slow_time/opt_time<br/>  print('{} speedup: {}'.format(func_name, speedup))</span></pre><p id="d747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得有意义的结果，我们将使用一个相对较大的数组(100.000 个元素)，并将其作为参数传递给两个函数。然后，我们将使用时间模块计算执行时间，并最终交付获得的加速。</p><p id="eb3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们还传递了一个可选参数，允许我们更改列表元素的类型。</p><h1 id="6a2b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.避免用+运算符连接字符串</h1><p id="da22" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可能会发现的一种常见情况是必须用多个子部分组成一个字符串。Python 有一个方便的+运算符，允许我们以如下方式轻松地连接字符串:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6f57" class="mx lw it mt b gy my mz l na nb">def slow_join(x):<br/>  s = ''<br/>  for n in x:<br/>    s += n</span></pre><p id="eba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管对我们来说这是一个干净的方法，Python 的字符串是不可变的，因此不能被修改。这意味着每次我们使用+操作符时，Python 实际上是基于两个子字符串创建一个新字符串，并返回新字符串。考虑一下，在我们的例子中，这个操作将被执行 100.000 次。</p><p id="03f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法显然是有代价的，我们可以使用<a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="noopener ugc nofollow" target="_blank"> join() </a>找到一个更便宜的解决方案，如下例所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="472a" class="mx lw it mt b gy my mz l na nb">def opt_join(x):<br/>  s = ''.join(x)</span></pre><p id="bdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案采用子字符串数组，并用空字符串分隔符将它们连接起来。让我们检查一下我们的性能改进:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8034" class="mx lw it mt b gy my mz l na nb">compute_speedup(slow_join, opt_join, 'join', tp=str)</span></pre><p id="6d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到了 7.25 倍的加速系数！考虑到实现这项技术所需的少量工作，我认为还不错。</p><h1 id="5c33" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.使用地图功能</h1><p id="620a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们需要对列表中的每个元素进行操作时，我们通常可以这样做:我们应用生成器理解并处理当前元素。然后，我们可以在必要时迭代它:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8326" class="mx lw it mt b gy my mz l na nb">def slow_map(x):<br/>  l = (str(n) for n in x)<br/>  for n in l:<br/>    pass</span></pre><p id="6ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在许多情况下，您可能更喜欢使用<a class="ae ky" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank"> Python 的内置映射函数</a>，它对 iterable 中的每个元素应用相同的操作并产生结果。它可以简单地实现如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0e26" class="mx lw it mt b gy my mz l na nb">def opt_map(x):<br/>  l = map(str, x)<br/>  for n in l:<br/>    pass</span></pre><p id="40f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候检查一下我们在执行时间上提高了多少了！如下运行我们的 compute_speedup 函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ab4b" class="mx lw it mt b gy my mz l na nb">compute_speedup(slow_map, opt_map, 'map')</span></pre><p id="13e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我获得了 155 的加速。可能有人会说理解更易读，但是我会说，适应<a class="ae ky" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank"> map 的</a>语法也不需要什么，至少在简单的场景中是这样(例如，不需要 iterable 上的任何条件)。</p><h1 id="fde5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.避免重新评估函数</h1><p id="5a86" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每当您发现自己在循环块中的元素上重复使用相同的函数时，例如:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="209b" class="mx lw it mt b gy my mz l na nb">y = []<br/>for n in x:<br/>  y.append(n)<br/>  y.append(n**2)<br/>  y.append(n**3)</span></pre><p id="cd68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…或者只是在循环块中使用一次这样的函数，但是是在一个很大的列表上，例如下面的情况:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e552" class="mx lw it mt b gy my mz l na nb">def slow_loop(x):<br/>  y = []<br/>  for n in x:<br/>    y.append(n)</span></pre><p id="23f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…您可以利用另一种优化技术。</p><p id="cde6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您以前将函数作为变量保存，并在循环块中重用它，则可以节省重新计算函数的成本。以下片段显示了这种行为:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7ceb" class="mx lw it mt b gy my mz l na nb">def opt_loop(x):<br/>  y = []<br/>  append = y.append<br/>  for n in x:<br/>    append(n)</span></pre><p id="f784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果需要将当前元素添加到不同的列表中，就必须为每个列表的 append 函数创建一个新变量。</p><p id="0ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用 compute_speedup 来检查加速:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8d40" class="mx lw it mt b gy my mz l na nb">compute_speedup(slow_loop, opt_loop, 'loop')</span></pre><p id="1a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我获得了 2.07 的加速比！同样，我们不需要做任何重大的改变来获得这样的改进。</p><p id="6089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">—</p><p id="577b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">想要更多提高效率的技巧吗？看看这些文章吧！</strong></p><p id="7319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/3-simple-python-efficiency-tips-f7c35b511503"> 3 个简单的 Python 效率技巧</a></p><p id="17ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/finding-performance-bottlenecks-in-python-4372598b7b2c">在 Python 中寻找性能瓶颈</a></p></div></div>    
</body>
</html>