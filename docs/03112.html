<html>
<head>
<title>The Hitchhiker’s Guide to Feature Extraction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《搭车人特征提取指南》</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-hitchhikers-guide-to-feature-extraction-b4c157e96631?source=collection_archive---------5-----------------------#2019-05-19">https://towardsdatascience.com/the-hitchhikers-guide-to-feature-extraction-b4c157e96631?source=collection_archive---------5-----------------------#2019-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="863e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kaggle 和日常工作的一些技巧和代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c021ca7fd8b39df23540dea7a5232415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGtACZSU6AxT3ugiNr-WGg.png"/></div></div></figure><p id="b813" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的特征是任何机器学习模型的支柱。</p><p id="38bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的特性创建通常需要领域知识、创造力和大量时间。</p><p id="5eef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将谈论:</p><ul class=""><li id="a285" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">特征创建的各种方法——自动和手动</li><li id="9fd2" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">处理分类特征的不同方法</li><li id="5840" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">经度和纬度特征</li><li id="9499" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">一些骗人的把戏</li><li id="b273" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">以及其他一些关于特征创建的想法。</li></ul><p id="789c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"><em class="me">TLDR；这个帖子是关于有用的</em> </strong> <a class="ae mf" href="https://amzn.to/2Y4kd9Z" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="me">特征工程</em> </strong> </a> <strong class="kw iu"> <em class="me">方法和技巧，我学到了，最后经常使用。</em> </strong></p><h1 id="df1f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.使用特征工具自动创建特征:</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/467393b78cca7b87c2353b0434537bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FRmHSsl9HYtuL2jW"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Automation is the future</figcaption></figure><p id="34b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你读过 featuretools 吗？如果没有，那么你会很高兴。</p><p id="f06a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">特征工具</strong>是一个执行自动化特征工程的框架。它擅长将时态和关系数据集转换为机器学习的特征矩阵。</p><p id="708e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">怎么会？让我们用一个玩具示例向您展示 featuretools 的强大功能。</p><p id="fef1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们的数据库中有三个表:<strong class="kw iu">客户、会话和事务。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/01582df280cdf2461f599cbab6656aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*hZBU699byYPkwJ16fsWyVw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Datasets and relationships</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/34b6c0162d0e11e0218ddb6dc3e1074e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8my-hPdkNkfwvP2b2TeAw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b43ac4822427791c32cd2801f01d4942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06TStW8-zc3ZztVyETziPA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e2bd5352c8e756ce8e903ff98688563f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyUVRItKh2uxr1dLoVSzig.png"/></div></div></figure><p id="0ee7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个相当不错的玩具数据集，因为它有基于时间的列以及分类和数字列。</p><p id="5e8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们要在这些数据上创建特征，我们将需要使用 Pandas 进行大量的合并和聚合。</p><p id="9f75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Featuretools 让我们变得如此轻松。尽管有一些事情，在我们的生活变得更容易之前，我们需要学习。</p><p id="2eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Featuretools 使用 entitysets。</p><p id="98fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以把一个 entityset 理解为一个数据帧的桶以及它们之间的关系。T25】</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/7d5614b3bd94546618c0c21926778c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*shOWKhbI-SxBGNXI"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Entityset = Bucket of dataframes and relationships</figcaption></figure><p id="1ac4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以事不宜迟，让我们创建一个空的 entityset。我只是以顾客的身份给出了名字。您可以在这里使用任何名称。现在只是一个空桶。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7ea6" class="nn mh it nj b gy no np l nq nr"># Create new entityset<br/>es = ft.EntitySet(id = 'customers')</span></pre><p id="278f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加我们的数据框架。添加数据帧的顺序并不重要。要将数据帧添加到现有的 entityset，我们需要执行以下操作。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8da4" class="nn mh it nj b gy no np l nq nr"># Create an entity from the customers dataframe</span><span id="2550" class="nn mh it nj b gy ns np l nq nr">es = es.entity_from_dataframe(entity_id = 'customers', dataframe = customers_df, index = 'customer_id', time_index = 'join_date' ,variable_types = {"zip_code": ft.variable_types.ZIPCode})</span></pre><p id="9d0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里做了一些事情，将数据帧添加到空的 entityset 桶中。</p><ol class=""><li id="0c0d" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nt lw lx ly bi translated">提供了一个<code class="fe nu nv nw nj b">entity_id</code>:这只是一个名字。把它当成客户。</li><li id="c5a9" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nt lw lx ly bi translated"><code class="fe nu nv nw nj b">dataframe</code>名称设置为 customers_df</li><li id="0990" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nt lw lx ly bi translated"><code class="fe nu nv nw nj b">index</code>:该参数将表中的主键作为输入</li><li id="1a17" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nt lw lx ly bi translated"><code class="fe nu nv nw nj b">time_index</code>:<strong class="kw iu">时间索引</strong>被定义为第一次可以使用一行中的任何信息。对于客户来说，这是加入日期。对于交易，它将是交易时间。</li><li id="6760" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nt lw lx ly bi translated"><code class="fe nu nv nw nj b">variable_types</code>:用于指定某一特定变量是否必须进行不同的处理。在我们的 Dataframe 中，我们有一个<code class="fe nu nv nw nj b">zip_code</code>变量，我们想区别对待它，所以我们使用它。这些是我们可以使用的不同变量类型:</li></ol><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c101" class="nn mh it nj b gy no np l nq nr">[featuretools.variable_types.variable.Datetime,<br/> featuretools.variable_types.variable.Numeric,<br/> featuretools.variable_types.variable.Timedelta,<br/> featuretools.variable_types.variable.Categorical,<br/> featuretools.variable_types.variable.Text,<br/> featuretools.variable_types.variable.Ordinal,<br/> featuretools.variable_types.variable.Boolean,<br/> featuretools.variable_types.variable.LatLong,<br/> featuretools.variable_types.variable.ZIPCode,<br/> featuretools.variable_types.variable.IPAddress,<br/> featuretools.variable_types.variable.EmailAddress,<br/> featuretools.variable_types.variable.URL,<br/> featuretools.variable_types.variable.PhoneNumber,<br/> featuretools.variable_types.variable.DateOfBirth,<br/> featuretools.variable_types.variable.CountryCode,<br/> featuretools.variable_types.variable.SubRegionCode,<br/> featuretools.variable_types.variable.FilePath]</span></pre><p id="2bfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们的 entityset bucket 现在的样子。它只有一个数据帧。也没有关系</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/a609c674bb64aa87c58a0867a795d80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7D7xvGv8n4px268nPWZAOQ.png"/></div></div></figure><p id="be65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加所有的数据帧:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2890" class="nn mh it nj b gy no np l nq nr"># adding the transactions_df<br/>es = es.entity_from_dataframe(entity_id="transactions",<br/>                                 dataframe=transactions_df,<br/>                                 index="transaction_id",<br/>                               time_index="transaction_time",<br/>                               variable_types={"product_id": ft.variable_types.Categorical})</span><span id="57cf" class="nn mh it nj b gy ns np l nq nr"># adding sessions_df<br/>es = es.entity_from_dataframe(entity_id="sessions",<br/>            dataframe=sessions_df,<br/>            index="session_id", time_index = 'session_start')</span></pre><p id="4457" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们的实体集桶现在的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/274c1fd07fffcdf0994da857401614f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKSci_30YZuyFmAwMLL5CQ.png"/></div></div></figure><p id="e222" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有三个数据帧，但没有关系。我所说的关系是指我的 bucket 不知道 customers_df 和 session_df 中的 customer_id 是相同的列。</p><p id="cbd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以向我们的 entityset 提供以下信息:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6893" class="nn mh it nj b gy no np l nq nr"># adding the customer_id relationship<br/>cust_relationship = ft.Relationship(es["customers"]["customer_id"],<br/>                       es["sessions"]["customer_id"])</span><span id="bb12" class="nn mh it nj b gy ns np l nq nr"># Add the relationship to the entity set<br/>es = es.add_relationship(cust_relationship)</span><span id="7553" class="nn mh it nj b gy ns np l nq nr"># adding the session_id relationship<br/>sess_relationship = ft.Relationship(es["sessions"]["session_id"],<br/>                       es["transactions"]["session_id"])</span><span id="3664" class="nn mh it nj b gy ns np l nq nr"># Add the relationship to the entity set<br/>es = es.add_relationship(sess_relationship)</span></pre><p id="5342" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此之后，我们的 entityset 看起来像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7dcb54428e89ca6e8952befd921bbc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zv6lGp-luh9RHovkivRVjQ.png"/></div></div></figure><p id="850b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到数据集和关系。我们这里的大部分工作已经完成了。我们已经准备好做特色菜了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/561498bcfc1ecd3e674918c4ee346c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xv-df8fBMbdY-x3M"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Cooking is no different from feature engineering. Think of features as ingredients.</figcaption></figure><p id="3cc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建特征非常简单:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6c87" class="nn mh it nj b gy no np l nq nr">feature_matrix, feature_defs = ft.dfs(entityset=es, target_entity="customers",max_depth = 2)</span><span id="fe6a" class="nn mh it nj b gy ns np l nq nr">feature_matrix.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/23695e3a74ece50a49e448e273f0656c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdLwDOxzSMG8JdaS_Gd7CQ.png"/></div></div></figure><p id="35d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们最终得到了 73 个新特性。  <em class="me">你可以从</em> <code class="fe nu nv nw nj b"><em class="me">feature_defs.</em></code> <em class="me">中看到特征名称，我们最终创建的一些特征是:</em></p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="25d9" class="nn mh it nj b gy no np l nq nr">[&lt;Feature: NUM_UNIQUE(sessions.device)&gt;,<br/> &lt;Feature: MODE(sessions.device)&gt;,<br/> &lt;Feature: SUM(transactions.amount)&gt;,<br/> &lt;Feature: STD(transactions.amount)&gt;,<br/> &lt;Feature: MAX(transactions.amount)&gt;,<br/> &lt;Feature: SKEW(transactions.amount)&gt;,<br/> &lt;Feature: DAY(join_date)&gt;,<br/> &lt;Feature: YEAR(join_date)&gt;,<br/> &lt;Feature: MONTH(join_date)&gt;,<br/> &lt;Feature: WEEKDAY(join_date)&gt;,<br/> &lt;Feature: SUM(sessions.STD(transactions.amount))&gt;,<br/> &lt;Feature: SUM(sessions.MAX(transactions.amount))&gt;,<br/> &lt;Feature: SUM(sessions.SKEW(transactions.amount))&gt;,<br/> &lt;Feature: SUM(sessions.MIN(transactions.amount))&gt;,<br/> &lt;Feature: SUM(sessions.MEAN(transactions.amount))&gt;,<br/> &lt;Feature: SUM(sessions.NUM_UNIQUE(transactions.product_id))&gt;,<br/> &lt;Feature: STD(sessions.SUM(transactions.amount))&gt;,<br/> &lt;Feature: STD(sessions.MAX(transactions.amount))&gt;,<br/> &lt;Feature: STD(sessions.SKEW(transactions.amount))&gt;,<br/> &lt;Feature: STD(sessions.MIN(transactions.amount))&gt;,<br/> &lt;Feature: STD(sessions.MEAN(transactions.amount))&gt;,<br/> &lt;Feature: STD(sessions.COUNT(transactions))&gt;,<br/> &lt;Feature: STD(sessions.NUM_UNIQUE(transactions.product_id))&gt;]</span></pre><p id="157f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以得到类似于<strong class="kw iu"> <em class="me">金额的 std 之和(</em></strong><code class="fe nu nv nw nj b">SUM(sessions.STD(transactions.amount))</code><strong class="kw iu"><em class="me">)</em></strong><em class="me">或者</em> <strong class="kw iu"> <em class="me">金额的 std 之和(</em></strong><code class="fe nu nv nw nj b">STD(sessions.SUM(transactions.amount))</code><strong class="kw iu"><em class="me">)</em></strong>这就是<code class="fe nu nv nw nj b">max_depth</code>参数在函数调用中的含义。在这里，我们将其指定为 2，以获得两个级别的聚合。</p><p id="009c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">如果我们将</em> </strong> <code class="fe nu nv nw nj b"><em class="me">max_depth</em></code> <em class="me">改为 3，我们可以得到如下特征:</em> <code class="fe nu nv nw nj b">MAX(sessions.NUM_UNIQUE(transactions.YEAR(transaction_time)))</code></p><p id="7d2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">试想一下，如果您必须编写代码来获得这些功能，您将需要花费多少时间。另外，需要注意的是，增加<code class="fe nu nv nw nj b">max_depth</code>可能需要更长的时间。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="b7ab" class="mg mh it bd mi mj oj ml mm mn ok mp mq jz ol ka ms kc om kd mu kf on kg mw mx bi translated">2.处理分类特征:标签/二进制/散列和目标/均值编码</h1><p id="c0e6" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">创建自动化功能有它的好处。但是如果一个简单的库可以完成我们所有的工作，为什么还需要我们这些数据科学家呢？</p><p id="f5a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一节中，我将讨论如何处理分类特征。</p><h2 id="5214" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">一个热编码</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/ef9801fb5dc0d63820413b31f1ca1f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V9vuk3_sYDeZy-3B"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">One Hot Coffee</figcaption></figure><p id="00f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用<strong class="kw iu"> <em class="me">一个热编码</em> </strong>来编码我们的分类特征。因此，如果我们在一个类别中有 n 个级别，我们将获得 n-1 个特征。</p><p id="ad58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 sessions_df 表中，我们有一个名为<code class="fe nu nv nw nj b">device,</code>的列，它包含三个级别——桌面、移动或平板。我们可以从这样的列中得到两列，使用:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="116c" class="nn mh it nj b gy no np l nq nr">pd.get_dummies(sessions_df['device'],drop_first=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/0cc74cfd8f4ae8a196b6b1ba1fc6ac11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNDscxYMHZyYbdiWv7MnEA.png"/></div></div></figure><p id="faa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是谈论分类特征时想到的最自然的事情，并且在许多情况下都很有效。</p><h2 id="8653" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">普通编码</h2><p id="d254" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">有时有一个与类别相关联的顺序。在这种情况下，我通常在 pandas 中使用一个简单的 map/apply 函数来创建一个新的序数列。</p><p id="b819" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我有一个包含三个温度级别的数据帧:高、中、低，我会将其编码为:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="391a" class="nn mh it nj b gy no np l nq nr">map_dict = {'low':0,'medium':1,'high':2}<br/>def map_values(x):<br/>    return map_dict[x]<br/>df['Temperature_oe'] = df['Temperature'].apply(lambda x: map_values(x))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/9de621ea23bd8840df3bf553cc3f11f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X73Y2_aPj5SQuqVWaR2Jrg.png"/></div></div></figure><p id="77d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用这个我保存了低位的信息<medium/></p><h2 id="b6ef" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">LabelEncoder</h2><p id="f1e9" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">We could also have used <strong class="kw iu"> <em class="me"> LabelEncoder </em> </strong>把我们的变量编码成数字。标签编码器主要做的是，它看到列中的第一个值，并将其转换为 0，下一个值转换为 1，依此类推。这种方法在树模型中工作得相当好，当分类变量中有很多级别时，我最终会使用它。 我们可以用这个作为:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2efd" class="nn mh it nj b gy no np l nq nr">from sklearn.preprocessing import LabelEncoder<br/># create a labelencoder object<br/>le = LabelEncoder()<br/># fit and transform on the data<br/>sessions_df['device_le'] = le.fit_transform(sessions_df['device'])<br/>sessions_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/f25dd244be603d7ea3c9d5d8e12ab2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qJ2AsLbBf89Pvbar6HhkQ.png"/></div></div></figure><h2 id="fe2d" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">二进制编码器</h2><p id="0648" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">BinaryEncoder 是另一种可以用来编码分类变量的方法。如果一列中有许多级别，这是一个很好的方法。虽然我们可以使用一个热编码使用 1023 个列来编码具有 1024 个级别的列，但是使用二进制编码我们可以仅使用十个列来实现。</p><p id="30fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们的 FIFA 19 球员数据中有一列包含所有俱乐部名称。该列有 652 个唯一值。一个热编码意味着创建 651 列，这意味着大量内存使用和大量稀疏列。</p><p id="5252" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们使用二进制编码器，我们将只需要 10 列作为 2⁹ &lt;652 &lt;2¹⁰.</p><p id="5e85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">We can binaryEncode this variable easily by using BinaryEncoder object from category_encoders:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2d26" class="nn mh it nj b gy no np l nq nr">from category_encoders.binary import BinaryEncoder<br/># create a Binaryencoder object<br/>be = BinaryEncoder(cols = ['Club'])<br/># fit and transform on the data<br/>players = be.fit_transform(players)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/ea316787194967b72f9a18b0156667da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7mzV3fcBysu_MbISR8GsA.png"/></div></div></figure><h2 id="61ff" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">HashingEncoder</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f3067b6ac9bfe86a2d3c5bfc80cde85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNhqAZ9abKogZs4Zc7We2w.png"/></div></div></figure><p id="9aeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">人们可以把散列编码器想象成一个黑盒函数，它把一个字符串转换成 0 到某个预先指定的值之间的一个数。</em>T11】</strong></p><p id="5c4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不同于二进制编码，因为在二进制编码中，两个或多个俱乐部参数可能是 1，而在散列中只有一个值是 1。</p><p id="7091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用哈希函数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="edbf" class="nn mh it nj b gy no np l nq nr">players = pd.read_csv("../input/fifa19/data.csv")</span><span id="459c" class="nn mh it nj b gy ns np l nq nr">from category_encoders.hashing import HashingEncoder<br/># create a HashingEncoder object<br/>he = HashingEncoder(cols = ['Club'])<br/># fit and transform on the data<br/>players = he.fit_transform(players)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/81e8f8f5457d7e9d15cbb5a3714c2365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBGqvCxwcbOoWFDLfrQzMw.png"/></div></div></figure><p id="4be6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">必然会有冲突(两个俱乐部具有相同的编码。例如，尤文图斯和 PSG 有相同的编码)但有时这种技术工作得很好。</p><h2 id="4c33" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">目标/均值编码</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/3f8e80b31f9d3b378f8eabea0b861e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KdK7p69iT3HGPOsN"/></div></div></figure><p id="e050" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个我发现在 Kaggle 比赛中非常有效的技巧。如果两个训练/测试都来自同一时间段(横截面)的同一数据集，我们可以对特征进行巧妙处理。</p><p id="a8ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比如:泰坦尼克号知识挑战赛中，测试数据是从训练数据中随机抽取的。在这种情况下，我们可以使用不同分类变量的平均目标变量作为特征。</p><p id="1262" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Titanic 中，我们可以在 PassengerClass 变量上创建一个目标编码特征。</p><p id="f126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">我们在使用目标编码时必须小心，因为它可能会导致我们的模型过度拟合。</em> </strong>这样我们在使用的时候就使用了 k 倍目标编码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="5e32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以创建一个平均编码特征，如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2f4f" class="nn mh it nj b gy no np l nq nr">targetc = KFoldTargetEncoderTrain('Pclass','Survived',n_fold=5)<br/>new_train = targetc.fit_transform(train)</span><span id="e587" class="nn mh it nj b gy ns np l nq nr">new_train[['Pclass_Kfold_Target_Enc','Pclass']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/8902c1f68f720e9a0ac3c0171b5353ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*5LrsMQcnKS17-ihdAG7GJw.png"/></div></figure><p id="641f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到，根据从中获取平均值的折叠，乘客类别 3 如何被编码为 0.261538 和 0.230570。</p><p id="b85f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个特性非常有用，因为它对类别的目标值进行了编码。仅看这个特征，我们可以说，与等级 3 相比，等级 1 中的乘客具有较高的幸存倾向。</p><h1 id="616a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.一些骗人的把戏:</h1><p id="267d" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">虽然不一定是特色创建技术，但您可能会发现一些有用的后处理技术。</p><h2 id="0947" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">测井损耗削波技术；</h2><p id="5796" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">这是我在杰瑞米·霍华德的神经网络课上学到的。它基于一个基本的想法。</p><p id="25a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们非常自信和错误，日志丢失会对我们不利。</p><p id="d5bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在分类问题的情况下，我们必须预测 Kaggle 中的概率，最好将我们的概率限制在 0.05-0.95 之间，这样我们就永远不会非常确定我们的预测。反过来，受到的惩罚也更少。可以通过简单的<code class="fe nu nv nw nj b">np.clip</code>来完成</p><h2 id="3aec" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">gzip 格式的 Kaggle 提交:</h2><p id="53fa" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">一小段代码将帮助你节省无数的上传时间。享受吧。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ae6d" class="nn mh it nj b gy no np l nq nr">df.to_csv(‘submission.csv.gz’, index=False, compression=’gzip’)</span></pre><h1 id="33be" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.使用纬度和经度功能:</h1><p id="e80f" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">这一部分将讨论如何很好地使用经纬度特性。</p><p id="c7bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个任务，我将使用操场竞赛的数据:<a class="ae mf" href="https://www.kaggle.com/c/nyc-taxi-trip-duration/data" rel="noopener ugc nofollow" target="_blank">纽约市出租车旅行持续时间</a></p><p id="424c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">训练数据看起来像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/44f0315694ce149da708ceca025282fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chSBQW7qZYCbY_lHfvknxg.png"/></div></div></figure><p id="8563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在这里要写的大部分函数都是受 Beluga 写的 Kaggle 上的一个<a class="ae mf" href="https://www.kaggle.com/gaborfodor/from-eda-to-the-top-lb-0-368" rel="noopener ugc nofollow" target="_blank">内核</a>的启发。</p><p id="c08c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个竞赛中，我们必须预测旅行持续时间。我们得到了许多功能，其中的纬度和经度的接送也有。我们创造了如下特色:</p><h2 id="9880" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">A.两个纬度之间的哈弗线距离:</h2><blockquote class="pp pq pr"><p id="4e45" class="ku kv me kw b kx ky ju kz la lb jx lc ps le lf lg pt li lj lk pu lm ln lo lp im bi translated">给定经度和纬度，哈弗辛公式确定了球体上两点之间的大圆距离</p></blockquote><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c210" class="nn mh it nj b gy no np l nq nr">def haversine_array(lat1, lng1, lat2, lng2): <br/>    lat1, lng1, lat2, lng2 = map(np.radians, (lat1, lng1, lat2, lng2)) <br/>    AVG_EARTH_RADIUS = 6371 # in km <br/>    lat = lat2 - lat1 <br/>    lng = lng2 - lng1 <br/>    d = np.sin(lat * 0.5) ** 2 + np.cos(lat1) * np.cos(lat2) *      np.sin(lng * 0.5) ** 2 <br/>    h = 2 * AVG_EARTH_RADIUS * np.arcsin(np.sqrt(d)) <br/>    return h</span></pre><p id="f14b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以使用该函数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="4f4a" class="nn mh it nj b gy no np l nq nr">train['haversine_distance'] = train.apply(lambda x: haversine_array(x['pickup_latitude'], x['pickup_longitude'], x['dropoff_latitude'], x['dropoff_longitude']),axis=1)</span></pre><h2 id="f2c6" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">B.两个纬度之间的曼哈顿距离:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0fbe51be9862c871a641d142822fbed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ht_1K-u6He2mpRFGKV3qiA.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Manhattan Skyline</figcaption></figure><blockquote class="pp pq pr"><p id="0970" class="ku kv me kw b kx ky ju kz la lb jx lc ps le lf lg pt li lj lk pu lm ln lo lp im bi translated">沿直角轴测量的两点之间的距离</p></blockquote><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="46e1" class="nn mh it nj b gy no np l nq nr">def dummy_manhattan_distance(lat1, lng1, lat2, lng2): <br/>    a = haversine_array(lat1, lng1, lat1, lng2) <br/>    b = haversine_array(lat1, lng1, lat2, lng1) <br/>    return a + b</span></pre><p id="a72b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以使用该函数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="79b0" class="nn mh it nj b gy no np l nq nr">train['<!-- -->manhattan<!-- -->_distance'] = train.apply(lambda x: <!-- -->dummy_manhattan_distance<!-- -->(x['pickup_latitude'], x['pickup_longitude'], x['dropoff_latitude'], x['dropoff_longitude']),axis=1)</span></pre><h2 id="3923" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">C.两个纬度之间的方位:</h2><p id="91d6" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">一个<strong class="kw iu">方位</strong>用来表示<strong class="kw iu">一点</strong>相对于另一个<strong class="kw iu">点</strong>的方向。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="25dd" class="nn mh it nj b gy no np l nq nr">def bearing_array(lat1, lng1, lat2, lng2): <br/>    AVG_EARTH_RADIUS = 6371 # in km <br/>    lng_delta_rad = np.radians(lng2 - lng1) <br/>    lat1, lng1, lat2, lng2 = map(np.radians, (lat1, lng1, lat2, lng2)) <br/>    y = np.sin(lng_delta_rad) * np.cos(lat2) <br/>    x = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(lng_delta_rad) <br/>    return np.degrees(np.arctan2(y, x))</span></pre><p id="bc20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以使用该函数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="de80" class="nn mh it nj b gy no np l nq nr">train['bearing'] = train.apply(lambda x: <!-- -->bearing_array<!-- -->(x['pickup_latitude'], x['pickup_longitude'], x['dropoff_latitude'], x['dropoff_longitude']),axis=1)</span></pre><h2 id="d0a6" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">D.接送点之间的中心纬度和经度:</h2><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="486f" class="nn mh it nj b gy no np l nq nr">train.loc[:, 'center_latitude'] = (train['pickup_latitude'].values + train['dropoff_latitude'].values) / 2 <br/>train.loc[:, 'center_longitude'] = (train['pickup_longitude'].values + train['dropoff_longitude'].values) / 2</span></pre><p id="b9e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些是我们创建的新列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/4fc63b75b7d9f3c0e1befdf183943839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4vJ-MQTYgms5GbohWuaLg.png"/></div></div></figure><h1 id="ca63" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.自动编码器:</h1><p id="b5f9" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">有时人们也使用自动编码器来创建自动特征。</p><p id="6fd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">什么是自动编码器？</em> </strong></p><p id="0d63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编码器是<a class="ae mf" href="https://amzn.to/2Lv2hU0" rel="noopener ugc nofollow" target="_blank">深度学习</a>函数，近似从 X 到 X 的映射，即输入=输出。他们首先将输入特征压缩成低维的<em class="me">表示</em>，然后从该表示中重建输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pw"><img src="../Images/dd71d5476ea46e936e7579ed3ceb2a03.png" data-original-src="https://miro.medium.com/v2/format:webp/1*C6Z6i1_2EJn13jVEsAOkRQ@2x.png"/></div></figure><p id="daec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用这个<em class="me">表示</em>向量作为我们模型的一个特征。</p><h1 id="2d4d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.您可以对要素执行的一些常规操作:</h1><ul class=""><li id="3615" class="lq lr it kw b kx oo la op ld px lh py ll pz lp lv lw lx ly bi translated"><strong class="kw iu"/></li><li id="6d7e" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu"> <em class="me">使用标准偏差进行标准化:</em> </strong>这是一种很好的方法，通常需要对线性模型、神经网络进行预处理</li><li id="abc7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu"> <em class="me">基于日志的特征/目标:</em> </strong>使用基于日志的特征或基于日志的目标功能。如果使用假设要素呈正态分布的线性模型，对数变换可以使要素呈正态分布。在收入等扭曲变量的情况下，这也很方便。</li></ul><p id="5fc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者在我们的例子中是旅行持续时间。下图是未进行对数变换的行程持续时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/8e3a511fe82c1c769631006040cfe2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjjJt_dyKCAF8kXtR8g18A.png"/></div></div></figure><p id="3199" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过对数变换:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9895" class="nn mh it nj b gy no np l nq nr">train['log_trip_duration'] = train['trip_duration'].apply(lambda x: np.log(1+x))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/b7461c888b2c9873807dd6735f7e9112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NikbaGCzCn253b0wN1qmiw.png"/></div></div></figure><p id="40fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">行程持续时间的对数变换偏差更小，因此对模型更有帮助。</p><h1 id="2c14" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">7.一些基于直觉的附加功能:</h1><h2 id="7872" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">日期时间特征:</h2><p id="a0c4" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">人们可以基于领域知识和直觉创建附加的日期时间特征。例如，基于时间的特征，如“晚上”、“中午”、“晚上”、“上个月的购买量”、“上个星期的购买量”等。可以适用于特定的应用。</p><h2 id="dd77" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">特定于领域的功能:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/66a4f8cd330e4c6dc1613b90745cc7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zj6nT2aQ1pNRVEuz"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Style matters</figcaption></figure><p id="09c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您已经获得了一些购物车数据，并且想要对 TripType 进行分类。这正是沃尔玛招聘中的问题:Kaggle 上的旅行类型分类。</p><p id="ca9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">旅行类型的一些例子:客户可能进行一次小的每日晚餐旅行，一次每周大型杂货旅行，一次为即将到来的假期购买礼物的旅行，或者一次购买衣服的季节性旅行。</p><p id="357a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要解决这个问题，您可以考虑创建一个类似“时尚”的功能，通过将属于男性时尚、女性时尚、青少年时尚类别的项目数量相加来创建这个变量。</p><p id="ea4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">或者你可以创建一个类似“稀有”</em> </strong>的功能，它是通过根据我们拥有的数据将一些物品标记为稀有，然后计算购物车中这些稀有物品的数量来创建的。</p><p id="8409" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些功能可能有效，也可能无效。从我的观察来看，它们通常提供了很多价值。</p><p id="30c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">感觉这就是塔吉特的《怀孕少女模特》的制作方式。</em> </strong>他们会有一个变量，保存一个怀孕少女可以购买的所有物品，并将它们放入一个分类算法中。</p><h2 id="7672" class="nn mh it bd mi ot ou dn mm ov ow dp mq ld ox oy ms lh oz pa mu ll pb pc mw pd bi translated">互动功能:</h2><p id="1959" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">如果您有特征 A 和 B，您可以创建特征 A*B、A+B、A/B、A-B 等。</p><p id="b47b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，要预测房子的价格，如果我们有两个特征长度和宽度，更好的办法是创建一个面积(长度 x 宽度)特征。</p><p id="4793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者在某些情况下，一个比率可能比只有两个特征更有价值。示例:信用卡利用率比信用额度和已用额度变量更有价值。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="e1d0" class="mg mh it bd mi mj oj ml mm mn ok mp mq jz ol ka ms kc om kd mu kf on kg mw mx bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3cbda22e33aadc4d56a605eeadb740a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eu11uV6mRzmE3YPk3javbw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Creativity is vital!!!</figcaption></figure><p id="eec8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些只是我用来创建特征的一些方法。</p><p id="c70c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">但是说到</em> </strong> <a class="ae mf" href="https://amzn.to/2Y4kd9Z" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="me">特色工程</em> </strong> </a> <strong class="kw iu"> <em class="me">肯定是没有限制的，限制你的只是你的想象力。</em> </strong></p><p id="ec83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这一点而言，我总是在考虑特征工程的同时记住我将使用什么模型。适用于随机森林的要素可能不适用于逻辑回归。</p><p id="1dd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">特征创建是反复试验的领域。在尝试之前，你无法知道什么样的转换有效，或者什么样的编码效果最好。永远是时间和效用的权衡。</p><p id="399e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时，特征创建过程可能需要很长时间。在这种情况下，你可能想要<a class="ae mf" href="https://medium.com/me/stats/post/1c04f41944a1" rel="noopener">并行化你的熊猫函数</a>。</p><p id="177d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我已经尽力保持这篇文章尽可能详尽(这很可能是我在 medium 上最大的一篇文章)，但我可能已经错过了一些有用的方法。请在评论中让我了解他们。</p><p id="dff1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以找到这篇文章的所有代码，并在这个<a class="ae mf" href="https://www.kaggle.com/mlwhiz/feature-creation/" rel="noopener ugc nofollow" target="_blank"> Kaggle 内核</a>中运行它</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="9452" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看一下 Google Cloud Specialization 上的<a class="ae mf" href="https://coursera.pxf.io/5bDx3b" rel="noopener ugc nofollow" target="_blank">高级机器学习。本课程将讨论模型的部署和生产。绝对推荐。</a></p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="58a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将来我也会写更多初学者友好的帖子。让我知道你对这个系列的看法。在<a class="ae mf" href="https://medium.com/@rahul_agarwal" rel="noopener"><strong class="kw iu"/></a>关注我或者订阅我的<a class="ae mf" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae mf" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p></div></div>    
</body>
</html>