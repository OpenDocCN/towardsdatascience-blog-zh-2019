<html>
<head>
<title>Basic data analysis techniques every data analyst should know using Python, part II.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据分析师都应该知道的使用 Python 的基本数据分析技术，第二部分。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basic-data-analysis-techniques-every-data-analyst-should-know-part-ii-412e28af849d?source=collection_archive---------13-----------------------#2019-05-23">https://towardsdatascience.com/basic-data-analysis-techniques-every-data-analyst-should-know-part-ii-412e28af849d?source=collection_archive---------13-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bfd3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/basic-analysis-techniques" rel="noopener" target="_blank">基本分析技巧</a></h2><div class=""/><div class=""><h2 id="5b04" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">迈向经验丰富的分析师的第一步</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0749b21817251c9694a95b12e8ec94b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKXC0FeXQc5LVmqhJ8HnVg.png"/></div></div></figure><p id="04e8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是<em class="lz">基础数据分析技术系列的后续，每个数据分析师都应该知道。对于那些还没有读过第一部分的人，可以在这里找到它。T12】</em></p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="acec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在第一部分中，我们介绍了初级数据分析师应该掌握的第一套技术，我们回顾了这些技术:基本过滤、多条件过滤、聚合和连接。</p><p id="7c13" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这一部分中，我们将在第一部分的基础上，引入一组新的技术:</p><ol class=""><li id="4ce5" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">转换数据类型</li><li id="d648" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">透视数据</li><li id="1bca" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">创建条件列</li><li id="50fd" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">多功能聚合</li></ol></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="5949" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将再次使用两个 Python 库进行分析，它们是:<code class="fe mw mx my mz b"><a class="ae ma" href="http://pandas.pydata.org/pandas-docs/stable/" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">pandas</strong></a></code> &amp; <code class="fe mw mx my mz b"><a class="ae ma" href="https://docs.scipy.org/doc/numpy/reference/" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">numpy</strong></a><strong class="lf jd">.</strong></code> <strong class="lf jd"> </strong>如果您还没有安装这两个包，请使用下面的代码来安装它们:</p><p id="7194" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">蟒蛇:</strong></p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="549f" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">conda install -c anaconda numpy</strong></span><span id="384d" class="ne nf it mz b gy nk nh l ni nj"><strong class="mz jd">conda install -c anaconda pandas</strong></span></pre><p id="8284" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> PIP: </strong></p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="4758" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">pip install pandas</strong></span><span id="d157" class="ne nf it mz b gy nk nh l ni nj"><strong class="mz jd">pip install numpy</strong></span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b731" class="nl nf it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">熊猫简介<em class="oc"> dtypes </em>。</h1><p id="a729" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">pandas 中的每一列(系列)都有一个分配给它的<em class="lz">类型</em>，这是指存储在该列中的数据类型。</p><p id="0f88" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">熊猫最基本的类型如下:</p><ul class=""><li id="0823" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly oi mo mp mq bi translated"><strong class="lf jd">对象</strong>，即文本数据，通常被称为<code class="fe mw mx my mz b"><strong class="lf jd">string.</strong></code></li><li id="c740" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated"><strong class="lf jd">浮点数</strong>，是具有小数精度的数(分数)，通常称为浮点数。</li><li id="ccfb" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated"><strong class="lf jd">整数</strong>，均为整数。</li></ul><p id="cebc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为什么在每一列中使用正确的类型至关重要？因为它将定义您可以对数据执行哪些操作。</p><p id="f734" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，每当一个列被定义为<code class="fe mw mx my mz b"><strong class="lf jd">string</strong></code>时，您就不能对它们执行计算。例如，我们可以创建一个 pandas DataFrame，它有一个包含数字的<em class="lz"> values </em>列，但是作为<em class="lz"> object </em> dtype。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="eb3a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们用下面的代码检查这个数据帧的数据类型:</p><p id="0fe3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe mw mx my mz b"><strong class="lf jd">print(df.types)</strong></code></p><p id="8b2d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们得到以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/04fe9f46c6c9afc6421c1014f703903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*U67qbcts-_nBfJLZofZIew.png"/></div><figcaption class="om on gj gh gi oo op bd b be z dk">dtypes</figcaption></figure><p id="7808" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们所看到的，我们的<em class="lz">值</em>列位于字符串形式的<em class="lz">对象 dtype </em>中。因此，如果我们试图对这些值进行计算，我们将得到一个错误或错误的输出:</p><p id="03c7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，取这些值的平方:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="cfda" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">df[‘Value’] ** 2</strong></span></pre><p id="caaf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">会给出一个<em class="lz">类型错误:</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/3d7f6667fc6c9e686f39134aa1b45864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCkqce0HJv05E5G1Pe24oA.png"/></div></div></figure><p id="45c7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">乘以 2 不会产生错误，但会给出错误的输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/881761143d907a8c5f983d12440862fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*H_KEEnHjVIGPnVq4PMoLWA.png"/></div></figure><p id="5bd6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它不会引发错误的原因是，在 Python 中，我们可以通过相乘来连接字符串:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5164023e781bdd220d79d961bd7af3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*IndS-TpdGNDkLLDQ2G4oGw.png"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c4ef" class="nl nf it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">1.转换数据类型</h1><p id="2b13" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">因此，为了防止这些错误或错误的输出，我们必须将列的类型转换为正确的类型。在熊猫身上，我们有<code class="fe mw mx my mz b"><a class="ae ma" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.astype.html" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">Series.astype</strong></a></code>的方法。</p><p id="46c8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此方法将您要转换成的 dtype 作为参数:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="0260" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">df[‘Value’].astype(int)</strong></span></pre><p id="7173" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">将该列转换为<code class="fe mw mx my mz b"><strong class="lf jd">int32</strong></code>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/f5ce892e9849d99dc393b03fe7cd247d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*F4Dc6u6hmiAMUkR9F055QQ.png"/></div></div></figure><p id="d0e0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">重要提示:</strong>这不是<em class="lz">【原地】</em>。所以我们没有覆盖数据帧中的原始列。为此，我们需要以下代码:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="e35e" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">df[‘Value’] = df[‘Value’].astype(int)</strong></span></pre><p id="d175" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们再次检查数据帧的数据类型，我们可以看到转换正确进行:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8ea1f08bfa22b57519e53045062cea12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*mGBPR0yXsQxxfSJiTdHypA.png"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h2 id="f9d8" class="ne nf it bd nm ov ow dn nq ox oy dp nu lm oz pa nw lq pb pc ny lu pd pe oa iz bi translated"><strong class="ak"> 1.1 转换日期时间</strong></h2><p id="40a9" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">datetime 的转换不同于 pandas 中的其他 dtypes，因为您有许多不同的格式来存储日期:</p><ul class=""><li id="924e" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly oi mo mp mq bi translated">29–04–2019，格式:日-月-年</li><li id="e962" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated">29/04/2019 18:23:09，格式:日/月/年时:分:秒</li><li id="c3f0" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated">04–29–2019，格式:年-月-日</li></ul><p id="26c5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些只是许多可能性中的几种，还有一些格式会变得相当复杂。我们不会在这些系列中讨论这些，但是我们会在我的另一个系列中讨论，这个系列叫做<em class="lz">用 Python 处理时间序列</em>，它将很快出版。</p><p id="ef2c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 pandas 中，有几种方法可以将对象类型转换为日期时间，现在我们来看两种最常用的方法:</p><ul class=""><li id="25d8" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly oi mo mp mq bi translated"><code class="fe mw mx my mz b"><a class="ae ma" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">pandas.to_datetime</strong></a></code></li><li id="659e" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated"><code class="fe mw mx my mz b"><a class="ae ma" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.astype.html" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">Series.astype</strong></a></code></li></ul><p id="d6f4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们深入一些例子之前，我们必须首先用一个 datetime 列扩展我们的数据帧，我们可以用一个表示日期的字符串列表来做到这一点:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="4bf4" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">df[‘Date’] = [‘2019–04–23’, ‘2019–04–24’, ‘2019–04–25’, ‘2019–04–26’]</strong></span></pre><p id="7024" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这给了我们下面的数据框架:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7aa4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们看看<code class="fe mw mx my mz b"><strong class="lf jd">print(df.dtypes)</strong></code>的产量。我们看到我们的<code class="fe mw mx my mz b"><strong class="lf jd">Date</strong></code>列是对象类型(字符串)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/636696626fc64f1254ed7cb411b6602b.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*OTEmqB1BHPEhfv-rcihXnQ.png"/></div></figure><h2 id="f73b" class="ne nf it bd nm ov ow dn nq ox oy dp nu lm oz pa nw lq pb pc ny lu pd pe oa iz bi translated">方法 1: pd.to_datetime</h2><p id="e7ee" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated"><code class="fe mw mx my mz b"><strong class="lf jd">to_datetime</strong></code>函数接受一列作为输入，所以在我们的例子中是<code class="fe mw mx my mz b"><strong class="lf jd">df['Date']</strong></code>。总代码如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/3df7ce4104ccf9dea552d7618537b58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*kXveBUnu5FD1f07TZmblVA.png"/></div></figure><h2 id="f42a" class="ne nf it bd nm ov ow dn nq ox oy dp nu lm oz pa nw lq pb pc ny lu pd pe oa iz bi translated">方法 2: Series.astype</h2><p id="618b" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">在前面的例子中，我们使用了<code class="fe mw mx my mz b"><strong class="lf jd">astype</strong></code>将字符串转换成整数。这次我们想要的是 numpy 模块中的日期时间类型<code class="fe mw mx my mz b"><strong class="lf jd">datetime64[ns]</strong></code>，在这里可以找到<a class="ae ma" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.datetime.html" rel="noopener ugc nofollow" target="_blank">。</a>所以我们可以将它传递给我们的<code class="fe mw mx my mz b"><strong class="lf jd">astype</strong></code>方法，并将我们的字符串转换成日期时间:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/59e9e4a4f6ebcbd09f92b425293616dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*UdKlb5iAt4zBIwAqRdXa0g.png"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="74f0" class="nl nf it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">2.透视数据</h1><p id="7e4b" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">有时，需要创建特定的概视图，并以特定的方式汇总数据，以便提高可读性，此外，由于数据是聚合的，因此更容易看到有价值的信息。</p><p id="6063" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">旋转是上述场景中经常使用的技术之一。它使您能够聚合数据，同时转换数据，以便索引和列被原始数据帧中两列的分类数据所替换。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/63e0bfccef039a149fbe56b3f9f4601a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RrnZvQQDumdLm9A23C7Hw.png"/></div></div><figcaption class="om on gj gh gi oo op bd b be z dk">source: <a class="ae ma" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank">pandas docs</a></figcaption></figure><p id="ff2f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">说够了，让我们在熊猫身上试试这个方法。首先，我们需要一个新的数据框架，这是我们自己创造的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1a09" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们在数据框架中看到的，每个公司的每个部门都重复了三次，同样也重复了三次。我们可以在熊猫身上用<code class="fe mw mx my mz b"><a class="ae ma" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">pivot_table</strong></a></code>的方法汇总这个数据。</p><p id="5130" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该方法采用了许多参数，您可以在文档中找到这些参数，但是现在我们将研究其中的三个参数:</p><ul class=""><li id="1434" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly oi mo mp mq bi translated"><strong class="lf jd">索引:</strong>要设置为索引的列</li><li id="506a" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated"><strong class="lf jd">列:</strong>对于每个唯一值，将被转换为新的<strong class="lf jd">列的列。</strong></li><li id="0dd6" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated"><strong class="lf jd">值:</strong>哪一列将是每个单元格中的值。</li></ul><p id="d8df" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，在我们的示例中，它将如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/f87697b3bdf3c47a049fa50389e671e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*zcwW_5Ov63vTueoCSnRAKA.png"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f499" class="nl nf it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated"><strong class="ak"> 3。创建条件列</strong></h1><p id="e4e1" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">处理数据时，可能需要根据表中已有的列向表中添加更多信息。这些列被称为<em class="lz">条件列</em>，因为它们的信息依赖于其他列。</p><p id="da6a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们看一下关于公司和部门规模的表格:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/40c42654ecb9eb0eaa89b1ee1814ac26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*53dA5WOtoau9ssctMqWaEw.png"/></div></figure><p id="4445" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可能想要区分大的<em class="lz">部门和小的</em>部门，并在名为<em class="lz"> size_indicator 的新列中对其进行定义。</em></p><p id="8972" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们把大部门的门槛定在 100。因此，如果我们用<a class="ae ma" href="https://en.wikipedia.org/wiki/Pseudocode" rel="noopener ugc nofollow" target="_blank"> <em class="lz">伪代码</em> </a>写出我们的逻辑，它将如下所示:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="16f7" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">if Employee &gt;= 100, then "Big"<br/>else "Small"</strong> </span></pre><p id="37ba" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 Python 中，我们可以以多种方式应用这种逻辑，我们将看看两种最常用的方法:</p><ul class=""><li id="d863" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly oi mo mp mq bi translated">numpy 在哪</li><li id="d76e" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated">列表理解</li></ul><h2 id="9f28" class="ne nf it bd nm ov ow dn nq ox oy dp nu lm oz pa nw lq pb pc ny lu pd pe oa iz bi translated">3.1 带有<em class="oc"> numpy.where </em>的条件列</h2><p id="adae" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">因为我们要使用 numpy 模块，所以我们必须首先导入这个模块:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="aad7" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">import numpy as np</strong></span></pre><p id="deea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 numpy 中有一个<code class="fe mw mx my mz b"><strong class="lf jd">.where</strong></code>方法，工作方式如下:</p><pre class="ks kt ku kv gt na mz nb nc aw nd bi"><span id="80d2" class="ne nf it mz b gy ng nh l ni nj"><strong class="mz jd">np.where(condition, value if true, value if false)</strong></span></pre><p id="1b50" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以在我们的例子中我们必须传递下面的方法:</p><ul class=""><li id="45df" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly oi mo mp mq bi translated">条件:<code class="fe mw mx my mz b"><strong class="lf jd">df['Employees'] &gt;= 100</strong></code></li><li id="c7e8" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated">值为真:<code class="fe mw mx my mz b"><strong class="lf jd">"Big"</strong></code></li><li id="88b0" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly oi mo mp mq bi translated">假值:<code class="fe mw mx my mz b"><strong class="lf jd">"Small"</strong></code></li></ul><p id="b39f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，这将导致以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/9c9cf4707751ba6a796613c11d4fda5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJiJNXs7Hoxhu6pabBCCvg.png"/></div></div></figure><h2 id="a424" class="ne nf it bd nm ov ow dn nq ox oy dp nu lm oz pa nw lq pb pc ny lu pd pe oa iz bi translated">3.2 列表理解的条件列</h2><p id="c222" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">列表理解是一种方法，与创建列表时使用和<em class="lz"> if 循环</em>的<em class="lz">相比，这种方法可以显著提高代码速度。</em></p><p id="561c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">and if 循环示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/1c2e2f2a398733bf57e1532c667f211d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*VRiE34W6NwUt3uJc4fiBlg.png"/></div></figure><p id="86f6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">相同的列表创建，但是具有列表理解:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/2ecd143a04918ae35c77acea8b40852b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vw1fQmPYSJ9E7qqio0mOQw.png"/></div></div></figure><p id="8d23" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">回到我们的数据，我们可以对 list comprehension 应用相同的逻辑来创建我们的<em class="lz"> Size_indicator </em>列:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/fbd4c37d86ca1e9596007081696ed265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79oQQ2JHa_-K3W0uUpDj3Q.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="4c77" class="nl nf it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">4.多功能聚合</h1><p id="30c7" class="pw-post-body-paragraph ld le it lf b lg od kd li lj oe kg ll lm of lo lp lq og ls lt lu oh lw lx ly im bi translated">在第一部分的<a class="ae ma" rel="noopener" target="_blank" href="/basic-data-analysis-techniques-every-data-analyst-should-know-using-python-4de80ab52396">中，我们已经用熊猫的<em class="lz"> groupby </em>函数查看了聚合数据。我们能够在应用 groupby 时应用单个函数，例如组的<code class="fe mw mx my mz b">max</code>或<code class="fe mw mx my mz b">mean</code>。</a></p><p id="2455" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 pandas 中，当应用 groupby 来创建更广泛的概览时，您必须能够应用多种功能。</p><p id="ddac" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这可以通过使用<a class="ae ma" href="https://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.core.groupby.DataFrameGroupBy.agg.html" rel="noopener ugc nofollow" target="_blank"> <em class="lz">聚合</em> </a> <em class="lz"> </em>方法来实现。我们可以向该方法传递一个字典，其中包含我们想要应用的列名和函数:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/8102598f4da672a9967281b81938dfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEJ1AcZPk8ShGV3iDS3J6g.png"/></div></div></figure><p id="7906" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如上所述，我们按<em class="lz">公司</em>分组，取<em class="lz">员工</em>的<em class="lz">总和</em>和<em class="lz">平均值</em>以及<em class="lz">尺码指标的<em class="lz">计数</em>。</em></p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="71fc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">这就是第二部分的</strong>:<em class="lz">每个数据分析师都应该知道的使用 Python 的基本数据分析技术。</em></p><p id="38b6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以在我的 GitHub 上以 Jupyter 笔记本的形式找到这篇文章的代码:<a class="ae ma" href="https://github.com/ErfPy/MediumArticles" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="afde" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于任何问题或其他讨论，请随时评论！</p><p id="9ae0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">期待第三部分，在那里我们会看到一些新的技术！</p></div></div>    
</body>
</html>