<html>
<head>
<title>Javascript New Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 新特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/javascript-new-features-part-1-f1a4360466?source=collection_archive---------4-----------------------#2019-09-19">https://towardsdatascience.com/javascript-new-features-part-1-f1a4360466?source=collection_archive---------4-----------------------#2019-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="648f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Javascript 已经从仅仅是一个 web 浏览器扩展到了编程的所有领域。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0bb38f359513d972a14aacd1b13d9fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zYCOUo9LH121aNGMhLlqIg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Private Class Field, String.matchAll(), Numeric Separators BigInt, Local String BigInt, GlobalThis, Promise.allSettled(), Dynamic Import</figcaption></figure><p id="2590" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Javascript 已经从 web 浏览器扩展到所有编程领域。</p><ol class=""><li id="19b9" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">Node.js —用于 CLI 和服务器。</li><li id="36ad" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">电子—用于跨平台桌面应用。</li><li id="c0aa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">React native —用于跨平台移动应用。</li><li id="d4b6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">物联网——低成本物联网设备，现在支持 javascript。</li></ol><p id="2834" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近对 v8 引擎的更新大大提高了性能。从节点版本 8 到节点版本 11，javascript 解析速度提高了 2 倍，promise on an 速度提高了 11 倍。内存消耗降低了 20%。因此在性能和可用性方面有所改进。</p><p id="104f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看到一些可以在 chrome 浏览器(版本≥76)或 Node.js(版本≥11) CLI 中测试的现有和预定功能。</p><h1 id="5f69" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">私有类字段👇</h1><p id="5cb2" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">直到 ES6，我们才能够直接声明<code class="fe nf ng nh ni b">private</code>属性。是的，有像下划线约定(<code class="fe nf ng nh ni b">_propertyName</code>)、<a class="ae nj" href="https://curiosity-driven.org/private-properties-in-javascript" rel="noopener ugc nofollow" target="_blank">闭包、符号或 weak map</a>这样的方式。</p><p id="0b23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是现在私有类字段使用哈希<code class="fe nf ng nh ni b">#</code>前缀。让我们通过一个例子来学习它。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="46c4" class="no mj it ni b gy np nq l nr ns">class Test {</span><span id="ad22" class="no mj it ni b gy nt nq l nr ns">  a = 1;          // .a is public<br/>  #b = 2;         // .#b is private<br/>  static #c = 3;  // .#c is private and static</span><span id="13d9" class="no mj it ni b gy nt nq l nr ns">  incB() {<br/>    this.#b++;<br/>  }</span><span id="dd2d" class="no mj it ni b gy nt nq l nr ns">}</span><span id="26c2" class="no mj it ni b gy nt nq l nr ns">const testInstance = new Test();</span><span id="32e2" class="no mj it ni b gy nt nq l nr ns">// runs OK<br/>testInstance.incB();</span><span id="c547" class="no mj it ni b gy nt nq l nr ns">// error - private property cannot be modified outside class<br/>testInstance.#b = 0;</span></pre><blockquote class="nu nv nw"><p id="68b3" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:目前还没有办法定义私有函数，尽管一个<a class="ae nj" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank"> TC39 第三阶段:草案提案</a>建议在名字上使用散列前缀<code class="fe nf ng nh ni b"><em class="it">#</em></code>。🤞</p></blockquote><h1 id="3ca1" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">String.matchAll()👇</h1><p id="edb4" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如果我有一个字符串，带有一个包含许多捕获组的全局正则表达式，我经常想遍历所有的组。目前，我的选择如下:</p><ol class=""><li id="eab3" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la iu">string . prototype . match()with/g—</strong>如果我们将<code class="fe nf ng nh ni b">.match()</code>与一个设置了标志<code class="fe nf ng nh ni b">/g</code>的正则表达式一起使用，您将在一个数组中获得它的所有完全匹配。</li><li id="c9ea" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">string . prototype . split()—</strong>如果我们使用拆分字符串和正则表达式来指定分隔符，并且如果它包含至少一个捕获组，那么<code class="fe nf ng nh ni b">.split()</code>返回子字符串交错的数组。</li></ol><p id="940e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述方法的问题在于，只有在正则表达式上设置了<code class="fe nf ng nh ni b">/g</code>并且正则表达式的属性<code class="fe nf ng nh ni b">.lastIndex</code>在每次匹配发生时都发生了变化的情况下，它们才有效。这使得在多个位置使用相同的正则表达式很危险。</p><p id="461d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">matchAll() 有助于解决上述所有问题。让我们看看它的定义和用法</p><p id="02ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定一个字符串和一个正则表达式，<code class="fe nf ng nh ni b">.matchAll()</code>返回所有匹配一个<em class="nx">字符串</em>和一个<em class="nx">正则表达式</em>的结果，包括捕获组。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="7c5b" class="no mj it ni b gy np nq l nr ns">let regexp = /t(e)(st(\d?))/g;<br/>let str = 'test1test2';</span><span id="0a21" class="no mj it ni b gy nt nq l nr ns">let array = [...str.matchAll(regexp)];</span><span id="c975" class="no mj it ni b gy nt nq l nr ns">console.log(array[0]);<br/>// expected output: Array ["test1", "e", "st1", "1"]</span></pre><blockquote class="nu nv nw"><p id="cc4e" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:<code class="fe nf ng nh ni b"><em class="it">.matchAll()</em></code>返回一个迭代器，不是真正的可重启 iterable。也就是说，一旦结果用尽，就需要再次调用方法并创建一个新的迭代器。</p></blockquote><h1 id="3f16" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">数字分隔符👇</h1><p id="7403" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如果你很难读懂一长串数字，这就是你搜索的终点。</p><p id="d90f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数字分隔符允许人眼快速解析，尤其是当有大量重复数字时:</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="830b" class="no mj it ni b gy np nq l nr ns">1000000000000 -&gt; 1_000_000_000_000<br/>1019436871.42 -&gt; 1_019_436_871.42</span></pre><p id="4fe4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在更容易分辨第一个数字是万亿，第二个数字是 10 亿量级。</p><p id="06ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它也适用于其他基础，例如:</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="c7b1" class="no mj it ni b gy np nq l nr ns"><strong class="ni iu">const</strong> fileSystemPermission = 0b111_111_000;<br/><strong class="ni iu">const</strong> bytes = 0b1111_10101011_11110000_00001101;<br/><strong class="ni iu">const</strong> words = 0xFAB_F00D;</span></pre><p id="378e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以在分数和指数中使用分隔符:</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="8ee4" class="no mj it ni b gy np nq l nr ns"><strong class="ni iu">const</strong> massOfElectronInKg = 9.109_383_56e-31;<br/><strong class="ni iu">const</strong> trillionInShortScale = 1e1_2;</span></pre><blockquote class="nu nv nw"><p id="5df1" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:解析由<code class="fe nf ng nh ni b"><em class="it">_</em></code>分隔的整数可能有些棘手，因为<code class="fe nf ng nh ni b"><em class="it">Number('123_456')</em></code>给出 NAN，而<code class="fe nf ng nh ni b"><em class="it">parseInt('123_456')</em></code>给出<code class="fe nf ng nh ni b"><em class="it">123</em></code>。</p></blockquote><h1 id="d72d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">BigInt 的👇</h1><p id="f5de" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe nf ng nh ni b">BigInts</code>是 JavaScript 中一个新的数字原语，可以表示精度大于 2⁵-1 的整数。有了<code class="fe nf ng nh ni b">BigInts</code>，你可以安全地存储和操作大整数，甚至超过<code class="fe nf ng nh ni b">Numbers</code>的安全整数限制。</p><p id="fdd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">BigInts</code>正确执行整数运算，不溢出。让我们通过一个例子来理解:-</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="f2ea" class="no mj it ni b gy np nq l nr ns">const max = Number.MAX_SAFE_INTEGER;<br/>// <!-- -->9007199254740991<br/>max+1;<br/>// 9007199254740992<br/>max+2;<br/>// 9007199254740991</span></pre><p id="ec69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到<code class="fe nf ng nh ni b">max + 1</code>产生的结果与<code class="fe nf ng nh ni b">max + 2</code>相同。</p><p id="48d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对超出安全整数范围(即从<code class="fe nf ng nh ni b">Number.MIN_SAFE_INTEGER</code>到<code class="fe nf ng nh ni b">Number.MAX_SAFE_INTEGER</code>的整数)的任何计算都可能会失去精度。为此，我们只能依赖安全范围内的数字整数值。</p><p id="8f7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">于是，<code class="fe nf ng nh ni b">BigInts</code>应运而生，<code class="fe nf ng nh ni b">BigInts</code>可以通过在任意整数文字上加上<code class="fe nf ng nh ni b">n</code>后缀来创建。例如，<code class="fe nf ng nh ni b">123</code>变成<code class="fe nf ng nh ni b">123n</code>或者全局<code class="fe nf ng nh ni b">BigInt(number)</code>功能可以用来将<code class="fe nf ng nh ni b">Number</code>转换成<code class="fe nf ng nh ni b">BigInts.</code></p><p id="8f61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用<code class="fe nf ng nh ni b">BigInt</code> s 重新看看上面的例子</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="dd05" class="no mj it ni b gy np nq l nr ns">BigInt(Number.MAX_SAFE_INTEGER) + 2n;<br/>// <!-- -->9007199254740993n</span><span id="879f" class="no mj it ni b gy nt nq l nr ns">typeof 123n<br/>// "bigint2"</span></pre><blockquote class="nu nv nw"><p id="880f" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:数字分隔符对 BigInts 特别有用，例如:</p><p id="df0f" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated"><code class="fe nf ng nh ni b"><strong class="la iu"><em class="it">const</em></strong><em class="it"> massOfEarthInKg = 6_000_000_000_000_000_000_000_000n;</em></code></p></blockquote><p id="ee34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">BigInts</code>支持最常用的运算符。二进制<code class="fe nf ng nh ni b">+</code>、<code class="fe nf ng nh ni b">-</code>、<code class="fe nf ng nh ni b">*</code>、<code class="fe nf ng nh ni b">**</code>都按预期工作。<code class="fe nf ng nh ni b">/</code>和<code class="fe nf ng nh ni b">%</code>工作，根据需要向零方向舍入。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="4ced" class="no mj it ni b gy np nq l nr ns">(7 + 6 - 5) * 4 ** 3 / 2 % 3;<br/>// → 1<br/>(7n + 6n - 5n) * 4n ** 3n / 2n % 3n;<br/>// → 1n</span></pre><blockquote class="nu nv nw"><p id="6928" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:一个问题是不允许在<code class="fe nf ng nh ni b"><em class="it">BigInts</em></code>和<code class="fe nf ng nh ni b"><em class="it">Numbers</em></code>之间混合操作</p></blockquote><h1 id="1714" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">带 BigInt 的区域设置字符串👇</h1><p id="efff" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe nf ng nh ni b"><strong class="la iu">toLocaleString()</strong></code>方法返回一个带有 BigInt 的语言敏感表示的字符串。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="4d64" class="no mj it ni b gy np nq l nr ns">let bigint = 123456789123456789n;</span><span id="69be" class="no mj it ni b gy nt nq l nr ns">// German uses period for thousands<br/>console.log(bigint.toLocaleString('de-DE'));<br/>// → 123.456.789.123.456.789</span><span id="1477" class="no mj it ni b gy nt nq l nr ns">// Arabic in most Arabic speaking countries uses Eastern Arabic digits<br/>console.log(bigint.toLocaleString('ar-EG'));<br/>// → ١٢٣٬٤٥٦٬٧٨٩٬١٢٣٬٤٥٦٬٧٨٩</span><span id="4bc4" class="no mj it ni b gy nt nq l nr ns">// India uses thousands/lakh/crore separators<br/>console.log(bigint.toLocaleString('en-IN'));<br/>// → 1,23,45,67,89,12,34,56,789</span><span id="ce40" class="no mj it ni b gy nt nq l nr ns">// the nu extension key requests a numbering system, e.g. Chinese decimal<br/>console.log(bigint.toLocaleString('zh-Hans-CN-u-nu-hanidec'));<br/>// → 一二三,四五六,七八九,一二三,四五六,七八九</span><span id="f8f9" class="no mj it ni b gy nt nq l nr ns">// when requesting a language that may not be supported, such as<br/>// Balinese, include a fallback language, in this case Indonesian<br/>console.log(bigint.toLocaleString(['ban', 'id']));<br/>// → 123.456.789.123.456.789</span></pre><h1 id="56f3" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">globalThis 关键字👇</h1><p id="2a81" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">JavaScript 的变量作用域是嵌套的，形成一棵树，它的根是全局作用域，<code class="fe nf ng nh ni b">this</code>关键字的值是对“拥有”当前正在执行的代码或函数的对象的引用。</p><p id="6820" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要了解更多关于这个关键字和全球范围的信息，请阅读我下面的文章</p><blockquote class="nu nv nw"><p id="55e2" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener">Javascript 中的作用域</a></p><p id="3aa7" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解 Javascript“this”关键字(上下文)</a></p></blockquote><p id="b155" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常我们用一个函数来计算全局，比如</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="453e" class="no mj it ni b gy np nq l nr ns">const getGlobalThis = () =&gt; {<br/>  <br/>  // in webworker or service worker<br/>  if (typeof self !== 'undefined') return self;<br/>  <br/>  // in browser <br/>  if (typeof window !== 'undefined') return window;<br/>  <br/>  // in Node.js<br/>  if (typeof global !== 'undefined') return global;<br/>  <br/>  // Standalone javascript shell<br/>  if (typeof this !== 'undefined') return this;<br/>  <br/>  throw new Error('Unable to locate global object');<br/>};</span><span id="b22a" class="no mj it ni b gy nt nq l nr ns">const theGlobalThis = getGlobalThis();</span></pre><p id="a510" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的函数并没有涵盖我们需要全局这个值时的所有情况。</p><ol class=""><li id="9bb5" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在<code class="fe nf ng nh ni b">use strict</code>的情况下，该值为<code class="fe nf ng nh ni b">undefined</code></li><li id="2fa9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">当我们在 javascript 中形成一个包时，它通常被一些可能与全局不同的代码所包裹。</li><li id="4abd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在独立的 javascript 引擎外壳环境中，上述代码将不起作用</li></ol><p id="344d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决上述问题，引入了关键字<code class="fe nf ng nh ni b">globalThis</code>,它可以在任何时候任何环境下返回全局对象。</p><blockquote class="nu nv nw"><p id="2fd8" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:由于向后兼容性，全局对象现在被认为是 JavaScript 无法摆脱的错误。它会对性能产生负面影响，并且通常会引起混淆。</p></blockquote><h1 id="173d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Promise.allSettled()👇</h1><p id="85bf" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如果你想知道 javascript 中的承诺是什么，那么看看这个— <a class="ae nj" href="https://developers.google.com/web/fundamentals/primers/promises" rel="noopener ugc nofollow" target="_blank"> JavaScript 承诺:介绍</a>。</p><p id="287e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一点要点，承诺是 JavaScript 向您承诺工作将会完成(或者如果工作无法完成可能会失败)的方式。</p><p id="da27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新方法返回一个承诺，该承诺在所有给定承诺都已解决(即解决或拒绝)后解决，并带有一个对象数组，每个对象描述每个承诺的结果。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="b05b" class="no mj it ni b gy np nq l nr ns">const promise1 = Promise.resolve(3);<br/>const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'foo'));<br/>const promises = [promise1, promise2];</span><span id="89a3" class="no mj it ni b gy nt nq l nr ns">Promise.allSettled(promises).<br/>  then((results) =&gt; results.forEach((result) =&gt; console.log(result.status)));</span><span id="2bfe" class="no mj it ni b gy nt nq l nr ns">// expected output:<br/>// "fulfilled"<br/>// "rejected"</span></pre><p id="9af3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这与<code class="fe nf ng nh ni b">Promise.all</code>不同，因为一旦 iterable 对象中的承诺被拒绝，它就会拒绝。</p><p id="22e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是当前支持的承诺方法的比较</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="3118" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">动态导入👇</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a745f9fba2feb6bbe40b10e06af8948f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLIWjtxHOyGnYbDlRliAJQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Static vs Dynamic Import</figcaption></figure><p id="1498" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个很疯狂在我们深入之前，我们先来看看什么是静态导入。</p><p id="fbe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">静态导入只接受字符串作为模块说明符，并通过运行前“链接”过程将绑定引入局部范围。</p><p id="da77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">静态的<code class="fe nf ng nh ni b">import</code>语法只能在文件的顶层使用。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="292a" class="no mj it ni b gy np nq l nr ns">import * as module from './utils.mjs';</span></pre><p id="dbcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">静态<code class="fe nf ng nh ni b">import</code>支持重要的用例，比如静态分析、捆绑工具和树抖动。</p><p id="4270" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是关于什么</p><ul class=""><li id="ee06" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt oe ma mb mc bi translated">按需(或有条件地)导入模块</li><li id="2786" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">在运行时计算模块说明符</li><li id="dbaf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">从常规脚本中导入模块(与模块相对)</li></ul><p id="1d3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是不可能的，直到<strong class="la iu">动态导入</strong> — <code class="fe nf ng nh ni b">import(moduleSpecifier)</code>为所请求模块的模块名称空间对象返回一个承诺，这是在获取、实例化和评估模块的所有依赖项以及模块本身之后创建的。</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="6d7a" class="no mj it ni b gy np nq l nr ns">&lt;script type="module"&gt;<br/>  (async () =&gt; {<br/>    const moduleSpecifier = './utils.mjs';<br/>    const module = await import(moduleSpecifier)<br/>    module.default();<br/>    // → logs 'Hi from the default export!'<br/>    module.doStuff();<br/>    // → logs 'Doing stuff…'<br/>  })();<br/>&lt;/script&gt;</span></pre><blockquote class="nu nv nw"><p id="e510" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:使用静态的<code class="fe nf ng nh ni b"><em class="it">import</em></code>作为初始的绘制依赖，特别是对于折叠内容。在其他情况下，考虑用动态<code class="fe nf ng nh ni b"><em class="it">import()</em></code>按需加载依赖项。</p></blockquote><h1 id="a091" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">稳定的分类—(现在获得一致可靠的结果)👇</h1><p id="5f1c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">在<a class="ae nj" href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" rel="noopener ugc nofollow" target="_blank">算法意义上的稳定</a>是指:<em class="nx">它是否保持顺序或者“相等”的项目</em>？</p><p id="f15d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过一个例子来理解</p><pre class="kj kk kl km gt nk ni nl nm aw nn bi"><span id="0740" class="no mj it ni b gy np nq l nr ns">const people = [<br/>  {name: 'Gary', age: 20},<br/>  {name: 'Ann', age: 20},<br/>  {name: 'Bob', age: 17},<br/>  {name: 'Sue', age: 21},<br/>  {name: 'Sam', age: 17},<br/>];</span><span id="532e" class="no mj it ni b gy nt nq l nr ns">// Sort people by name<br/>people.sort( (p1, p2) =&gt; {<br/>  if (p1.name &lt; p2.name) return -1;<br/>  if (p1.name &gt; p2.name) return 1;<br/>  return 0;<br/>});</span><span id="8a6e" class="no mj it ni b gy nt nq l nr ns">console.log(people.map(p =&gt; p.name));<br/>// ['Ann', 'Bob', 'Gary', 'Sam', 'Sue']</span><span id="42f6" class="no mj it ni b gy nt nq l nr ns">// Re-sort people by age<br/>people.sort( (p1, p2) =&gt; {<br/>  if (p1.age &lt; p2.age) return -1;<br/>  if (p1.age &gt; p2.age) return 1;<br/>  return 0;<br/>});</span><span id="ebda" class="no mj it ni b gy nt nq l nr ns">console.log(people.map(p =&gt; p.name));<br/>// We're expecting people sorted by age, then by name within age group:<br/>// ['Bob', 'Sam', 'Ann', 'Gary', 'Sue']</span><span id="af28" class="no mj it ni b gy nt nq l nr ns">// But we might get any of these instead, depending on the browser:<br/>// ['Sam', 'Bob', 'Ann', 'Gary', 'Sue']<br/>// ['Bob', 'Sam', 'Gary', 'Ann', 'Sue']<br/>// ['Sam', 'Bob', 'Gary', 'Ann', 'Sue']</span></pre><p id="06e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你得到的是最后三个结果中的一个，那么你可能正在使用 Google Chrome，或者可能是没有实现 Array.sort()作为“稳定”算法的各种浏览器中的一个。</p><p id="f3a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为不同的 JS 引擎(跨不同的浏览器)采用不同的路线来实现排序，另外，一些 javascript 引擎对短数组使用稳定排序，而对长数组使用不稳定排序。</p><p id="ab0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这导致不一致的排序稳定性行为和许多混乱。这就是为什么在开发环境中，与排序相关的一切似乎都可以工作，但在生产环境中，由于测试排序的阵列大小不同，我们开始看到其他情况。</p><blockquote class="nu nv nw"><p id="add8" class="ky kz nx la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:有第三方库，我强烈推荐<a class="ae nj" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>，它有稳定的排序</p></blockquote><p id="6847" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是现在这个问题已经解决了，我们在大多数浏览器上都有一个稳定的排序。语法保持不变。</p><p id="ebdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这篇文章有很多需要消化和测试的特性，我们将在下一篇文章中继续介绍更多的新特性。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="e30c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想加入我的电子邮件列表，请考虑在这里输入您的电子邮件地址<a class="ae nj" href="https://goo.gl/forms/MOPINWoY7q1f1APu2" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"/></a><strong class="la iu">关注我在</strong><a class="ae nj" href="https://medium.com/@ideepak.jsd" rel="noopener"><strong class="la iu">medium</strong></a><strong class="la iu">上阅读更多关于 javascript 的文章，在</strong><a class="ae nj" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">github</strong></a><strong class="la iu">上查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="018b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="860a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/better-programming/vs-code-extension-for-web-dev-productivity-fa541654161f" rel="noopener">VS Web 开发生产力的代码扩展</a></li><li id="af03" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://levelup.gitconnected.com/javascript-execution-context-and-hoisting-c2cc4993e37d" rel="noopener ugc nofollow" target="_blank"> Javascript 执行上下文和提升</a></li><li id="a19b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="67f8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解 Javascript 'this '关键字(上下文)</a>。</li><li id="2351" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://levelup.gitconnected.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener ugc nofollow" target="_blank"> Javascript 数据结构与映射、归约、过滤</a></li><li id="042b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="b4aa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="2a5b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a></li><li id="84cf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nj" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li></ol><h1 id="deb5" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">如果你喜欢这篇文章，请随意分享，以帮助他人找到它！</h1><h1 id="535b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">谢谢！</strong></h1></div></div>    
</body>
</html>