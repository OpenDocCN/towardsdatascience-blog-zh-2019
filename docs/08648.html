<html>
<head>
<title>Image Geometric Transformation In Numpy and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy 和 OpenCV 中的图像几何变换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-geometric-transformation-in-numpy-and-opencv-936f5cd1d315?source=collection_archive---------4-----------------------#2019-11-21">https://towardsdatascience.com/image-geometric-transformation-in-numpy-and-opencv-936f5cd1d315?source=collection_archive---------4-----------------------#2019-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2781" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">图像变形背后的数学和代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/135b57de9854537117e1bb05fcdf71da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMz19VKei5ZsvNAVmv_OMQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Source: <a class="ae ky" href="https://www.semanticscholar.org/paper/Computer-Vision-Algorithms-and-Applications-Szeliski/4282a344671189e17c9c9e00e329fe2d0fa71769/figure/263" rel="noopener ugc nofollow" target="_blank">Geometric Transformations</a></figcaption></figure><h2 id="528c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">几何变换在计算机视觉中普遍存在</h2><p id="279e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">几何变换是一种重要的图像处理技术，有着广泛的应用。例如，在计算机图形学中，一个简单的用例是在桌面和移动设备上显示图形内容时简单地重新缩放图形内容。</p><p id="74b6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">它还可以应用于将图像投影扭曲到另一个图像平面。例如，我们希望从另一个角度看一个场景，而不是直直地看着它，在这个场景中应用了透视变换来实现这一点。</p><p id="72f9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">另一个令人兴奋的应用是训练深度神经网络。训练深度模型需要大量数据。几乎在所有情况下，随着训练数据的增加，模型都会受益于更高的泛化性能。人工生成更多数据的一种方法是对输入数据随机应用仿射变换。这种技术也被称为<strong class="lx iu">增强</strong>。</p><p id="5fee" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在本文中，我将带您了解一些转换，以及我们如何在 Numpy 中执行它们，首先从基本原则上理解这个概念。然后如何使用 OpenCV 轻松实现。如果你像我一样喜欢从基础理论中理解概念，这篇文章会让你感兴趣！</p><p id="d9d9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我将特别关注<strong class="lx iu"> 2D 仿射变换</strong>。你需要的是一些线性代数的基础知识，你应该能跟上。附带的代码可以在<a class="ae ky" href="https://github.com/darylclimb/image_affine_transform" rel="noopener ugc nofollow" target="_blank">这里</a>找到，如果你喜欢自己尝试的话！</p><h2 id="2839" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">仿射变换的类型</strong></h2><p id="6bc2" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在不深入数学细节的情况下，变换的行为由仿射<strong class="lx iu"> A </strong>中的一些参数控制。</p><p id="79d8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> x' = Ax </strong></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9124" class="kz la it mu b gy my mz l na nb">where A = [[a_11, a_12, a_13],<br/>           [a_21, a_22, a_23],<br/>           [  0 ,   0 ,   1 ]]</span></pre><p id="0388" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">是齐次坐标中的 2x3 矩阵或 3x3，并且<strong class="lx iu"> x </strong>是齐次坐标中形式为<code class="fe nc nd ne mu b">[x, y]</code>或<code class="fe nc nd ne mu b">[x, y, 1]</code>的向量。上面的公式说<strong class="lx iu"> A </strong>取任意向量<strong class="lx iu"> x </strong>并将其映射到另一个向量<strong class="lx iu">x’。</strong></p><p id="6a38" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">通常，仿射变换具有 6 个自由度，在逐像素矩阵相乘之后，将任何图像扭曲到另一个位置。变换后的图像保留了原图像中的<strong class="lx iu">平行线</strong>和<strong class="lx iu">直线</strong>(想想剪切)。满足这两个条件的任何矩阵<strong class="lx iu"> A </strong>都被认为是仿射变换矩阵。</p><p id="a5d2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">缩小我们的讨论，有一些特殊形式的 A，这是我们感兴趣的。这包括如下图所示的<strong class="lx iu">旋转</strong>、<strong class="lx iu">平移</strong>和<strong class="lx iu">缩放</strong>矩阵。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/3f71f089f02dc5c40dffbd6f8a5a740b.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*HUrMHLry6d8lxcB7qGjFTA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 1: 2D Coordinate Transformations. Note that rotation is about z-axis</figcaption></figure><p id="429f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">上述仿射变换的一个非常有用的特性是它们是线性函数。它们保留了乘法和加法的运算，遵守叠加原理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/cb5fa040c83c40551d43819d0e2264e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xdjm6iDdzobZUvcOT1a60A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">source: <a class="ae ky" href="https://en.wikipedia.org/wiki/Linear_map" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="7bc7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">换句话说，我们可以组合两个或更多的变换:向量加法来表示平移，矩阵乘法来表示线性映射，只要我们在齐次坐标中表示它们。例如，我们可以将旋转后的平移表示为</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="69a0" class="kz la it mu b gy my mz l na nb">A = array([[cos(angle),  -sin(angle), tx],<br/>            [sin(angle), cos(angle),  ty],<br/>            [0,          0,           1]])</span></pre><h2 id="ac50" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">图像表示</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1ce6c99ea0f262c8f8952aa5a8b0bde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*LyEfrmfXDeHTgWupIVclQg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 2: <a class="ae ky" href="https://learn.adafruit.com/assets/1264" rel="noopener ugc nofollow" target="_blank">Pixel Coordinates</a></figcaption></figure><p id="44ce" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在 Python 和 OpenCV 中，2D 矩阵的原点位于左上角，从 x，y= (0，0)开始。坐标系是左手坐标系，其中 x 轴指向正右侧，y 轴指向正下方。</p><p id="650e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是你在教科书和文献中找到的大多数变换矩阵，包括上面显示的 3 个矩阵，都遵循右手坐标系。所以必须做一些小的调整来对齐轴的方向。</p><h2 id="182d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">欧氏空间中的常见变换</strong></h2><p id="c73e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在我们对图像进行变换实验之前，让我们看看如何在点坐标上进行变换。因为它们本质上与图像是网格中的 2D 坐标阵列是一样的。</p><p id="0a83" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">利用我们在上面学到的知识，下面的代码可以用来转换点<code class="fe nc nd ne mu b">[0, 0], [0, 1], [1, 0], [1,1]</code>。图 3 中的蓝点。</p><p id="87b8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Python 提供了一个有用的速记运算符，<code class="fe nc nd ne mu b">@</code> <strong class="lx iu"> </strong>来表示矩阵乘法。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e806" class="kz la it mu b gy my mz l na nb"># Points generator<br/>def get_grid(x, y, homogenous=False):<br/>    coords = np.indices((x, y)).reshape(2, -1)<br/>    return np.vstack((coords, np.ones(coords.shape[1]))) if homogenous else coords</span><span id="827b" class="kz la it mu b gy ni mz l na nb"># Define Transformations<br/>def get_rotation(angle):<br/>    angle = np.radians(angle)<br/>    return np.array([<br/>        [np.cos(angle), -np.sin(angle), 0],<br/>        [np.sin(angle),  np.cos(angle), 0],<br/>        [0, 0, 1]<br/>    ])<br/>def get_translation(tx, ty):<br/>    return np.array([<br/>        [1, 0, tx],<br/>        [0, 1, ty],<br/>        [0, 0, 1]<br/>    ])<br/>def get_scale(s):<br/>    return np.array([<br/>        [s, 0, 0],<br/>        [0, s, 0],<br/>        [0, 0, 1]<br/>    ])</span><span id="15a5" class="kz la it mu b gy ni mz l na nb">R1 = get_rotation(135)<br/>T1 = get_translation(-2, 2)<br/>S1 = get_scale(2)</span><span id="aca6" class="kz la it mu b gy ni mz l na nb"># Apply transformation x' = Ax<br/>coords_rot = R1 @ coords<br/>coords_trans = T1 @ coords<br/>coords_scale = S1 @ coords<br/>coords_composite1 = R1 @ T1 @ coords<br/>coords_composite2 = T1 @ R1 @ coords</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/d7b939f43532956dec4be97ae5c1de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcuPoejvaUK_nVDbo_sTqg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 3: Transforming points: (0,0), (0,1), (1,0), (1,1)</figcaption></figure><p id="3a86" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">重要的是要注意，除了少数例外，矩阵通常不<strong class="lx iu">交换</strong>。即</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d134" class="kz la it mu b gy my mz l na nb">A1 @ A2 != A2 @ A1</span></pre><p id="a6d3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">因此，对于转换来说</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8791" class="kz la it mu b gy my mz l na nb"># Translation and then rotation<br/>coords_composite1 = R1 @ T1 @ coords</span><span id="0195" class="kz la it mu b gy ni mz l na nb"># Rotation and then translation<br/>coords_composite2 = T1 @ R1 @ coords</span></pre><p id="5d6c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您将在图 3 中观察到，它们不会导致相同的映射，并且<strong class="lx iu">顺序</strong>很重要。函数如何应用可以从右到左理解。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="69ab" class="nr la it bd lb ns nt nu le nv nw nx lh jz ny ka ll kc nz kd lp kf oa kg lt ob bi translated">数字转换</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c52418b2c4ba7558601d1dfbc177379a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOEAHMZOvsd3M_bxKDr_VQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Source: Kitti Dataset</figcaption></figure><p id="7364" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在对于图像，有几件事需要注意。首先，如前所述，我们必须重新调整垂直轴。其次，变换后的点必须投影到图像平面上。</p><p id="ec73" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">本质上，需要采取的步骤是:</p><ol class=""><li id="1361" class="od oe it lx b ly mo mb mp li of lm og lq oh mn oi oj ok ol bi translated">创建一个新的图像 I'(x，y)来输出变换点</li><li id="750f" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">应用转换<strong class="lx iu">一个</strong></li><li id="60d6" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">将这些点投影到一个新的图像平面上，只考虑那些位于图像边界内的点。</li></ol><h2 id="e06b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">示例:关于图像中心的旋转、缩放和平移</strong></h2><p id="dbf8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们来看一个变换，我们希望<strong class="lx iu">放大 2 倍</strong>并将图像围绕其中心位置旋转<strong class="lx iu"> 45 度</strong>。</p><p id="5b9e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这可以通过应用以下复合矩阵来实现。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="94ef" class="kz la it mu b gy my mz l na nb">height, width = image.shape[:2]<br/>tx, ty = np.array((width // 2, height // 2))<br/>angle = np.radians(45)<br/>scale = 2.0</span><span id="1f58" class="kz la it mu b gy ni mz l na nb">R = np.array([<br/>    [np.cos(angle), np.sin(angle), 0],<br/>    [-np.sin(angle), np.cos(angle), 0],<br/>    [0, 0, 1]<br/>])</span><span id="6af5" class="kz la it mu b gy ni mz l na nb">T = np.array([<br/>    [1, 0, tx],<br/>    [0, 1, ty],<br/>    [0, 0, 1]<br/>])</span><span id="57c6" class="kz la it mu b gy ni mz l na nb">S = np.array([<br/>    [scale, 0, 0],<br/>    [0, scale, 0],<br/>    [0, 0, 1]<br/>])</span><span id="ae49" class="kz la it mu b gy ni mz l na nb">A = T @ R @ S @ np.linalg.inv(T)</span></pre><p id="e72a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><em class="or">应用于图像</em></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b43f" class="kz la it mu b gy my mz l na nb"># Grid to represent image coordinate<br/>coords = get_grid(width, height, True)<br/>x_ori, y_ori = coords[0], coords[1] </span><span id="09df" class="kz la it mu b gy ni mz l na nb"># Apply transformation<br/>warp_coords = np.round(A@coords).astype(np.int)<br/>xcoord2, ycoord2 = warp_coords[0, :], warp_coords[1, :]</span><span id="231d" class="kz la it mu b gy ni mz l na nb"># Get pixels within image boundary<br/>indices = np.where((xcoord &gt;= 0) &amp; (xcoord &lt; width) &amp;<br/>                   (ycoord &gt;= 0) &amp; (ycoord &lt; height))</span><span id="c8bf" class="kz la it mu b gy ni mz l na nb">xpix2, ypix2 = xcoord2[indices], ycoord2[indices]</span><span id="5a04" class="kz la it mu b gy ni mz l na nb">xpix, ypix = x_ori[indices], y_ori[indices]</span><span id="2aed" class="kz la it mu b gy ni mz l na nb"># Map the pixel RGB data to new location in another array<br/>canvas = np.zeros_like(image)<br/>canvas[ypix, xpix] = image[yy, xx]</span></pre><p id="a4d4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在上面的两个代码片段中有几点需要注意。</p><ol class=""><li id="0932" class="od oe it lx b ly mo mb mp li of lm og lq oh mn oi oj ok ol bi translated">左手坐标系旋转通过交换符号来解决。</li><li id="90ab" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">因为点是围绕原点旋转的，所以在进行旋转和缩放之前，我们首先将中心平移到原点。</li><li id="850f" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">然后，点被转换回图像平面</li><li id="c4fa" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">变换点被四舍五入为整数以表示离散的像素值。</li><li id="a771" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">接下来，我们只考虑位于图像边界内的像素</li><li id="1f9d" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">映射对应 I(x，y)和 I'(x，y)</li></ol><p id="d6bf" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">正如你所看到的，由于步骤 4，结果图像(图 4)将有几个锯齿和漏洞。为了消除这一点，开源库使用插值技术来填充转换后的缺口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/988993fd4f5e08327facd0b2be21c0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUcj0-rnw5ny_eEG-9EPyg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 4: Image rotated by 45 degrees counter-clockwise and scale by 2x. Aliasing effect is significant</figcaption></figure><p id="33ee" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">逆翘曲</strong></p><p id="5a79" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">另一种防止混叠的方法是在给定扭曲点 X’的情况下，将扭曲公式化为从源图像 I(x，y)重采样的扭曲。这可以通过将 X '乘以 a 的倒数来实现。注意，变换必须是可逆的。</p><ol class=""><li id="a0a6" class="od oe it lx b ly mo mb mp li of lm og lq oh mn oi oj ok ol bi translated">对 X '进行逆变换。</li></ol><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="400a" class="kz la it mu b gy my mz l na nb">X = np.linalg.inv(A) @ X'</span></pre><p id="cf28" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">注意:对于图像，X '的逆变形只是将 I'(x，y)重新投影到 I(x，y)上。所以我们简单地对 I'(x，y)像素坐标进行逆变换，如下图所示。</p><p id="06ca" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2.确定它在原始图像平面中的位置</p><p id="f616" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">3.从 I(x，y)重新采样 RGB 像素，并将其映射回 I'(x，y)</p><p id="fa40" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">代码</strong></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="97e4" class="kz la it mu b gy my mz l na nb"># set up pixel coordinate I'(x, y)<br/>coords = get_grid(width, height, True)<br/>x2, y2 = coords[0], coords[1]</span><span id="9d84" class="kz la it mu b gy ni mz l na nb"># Apply inverse transform and round it (nearest neighbour interpolation)<br/>warp_coords = (Ainv@coords).astype(np.int)<br/>x1, y1 = warp_coords[0, :], warp_coords[1, :]</span><span id="1686" class="kz la it mu b gy ni mz l na nb"># Get pixels within image boundaries<br/>indices = np.where((x1 &gt;= 0) &amp; (x1 &lt; width) &amp;<br/>                   (y1 &gt;= 0) &amp; (y1 &lt; height))</span><span id="12c8" class="kz la it mu b gy ni mz l na nb">xpix1, ypix1 = x2[indices], y2[indices]<br/>xpix2, ypix2 = x1[indices], y1[indices]</span><span id="5bb8" class="kz la it mu b gy ni mz l na nb"># Map Correspondence<br/>canvas = np.zeros_like(image)<br/>canvas[ypix1, xpix1] = image[ypix2,xpix2]</span></pre><p id="a77c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">运行上面的代码应该会给你一个密集的、没有孔洞的图像:)可以随意下载代码并使用参数来应用其他的转换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/7cab4a0d7a545606d6f52a9ad6c4a7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Efyal9BZB9y2duMC310Tiw.png"/></div></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="50b8" class="nr la it bd lb ns nt nu le nv nw nx lh jz ny ka ll kc nz kd lp kf oa kg lt ob bi translated">OpenCV 中的转换</h1><p id="eeac" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">既然您对几何变换有了更好的理解，大多数开发人员和研究人员通常会省去编写所有这些变换的麻烦，只需依靠优化的库来执行任务。在 OpenCV 中做<a class="ae ky" href="https://docs.opencv.org/2.4/modules/imgproc/doc/geometric_transformations.html" rel="noopener ugc nofollow" target="_blank">仿射变换非常简单。</a></p><p id="6a76" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有几种方法可以做到。</p><ol class=""><li id="d007" class="od oe it lx b ly mo mb mp li of lm og lq oh mn oi oj ok ol bi translated">自己写仿射变换，调用<code class="fe nc nd ne mu b">cv2.<strong class="lx iu">warpAffine</strong>(image, A, output_shape)</code></li></ol><p id="4a3e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面的代码显示了整个仿射矩阵，它将给出与上面相同的结果。一个很好的练习就是自己推导公式！</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f018" class="kz la it mu b gy my mz l na nb">def get_affine_cv(t, r, s):<br/>    sin_theta = np.sin(r)<br/>    cos_theta = np.cos(r)<br/>    <br/>    a_11 = s * cos_theta<br/>    a_21 = -s * sin_theta<br/>    <br/>    a_12 = s * sin_theta<br/>    a_22 = s * cos_theta<br/>        <br/>    a_13 = t[0] * (1 - s * cos_theta) - s * sin_theta * t[1]<br/>    a_23 = t[1] * (1 - s * cos_theta) + s * sin_theta * t[0]</span><span id="446a" class="kz la it mu b gy ni mz l na nb">return np.array([[a_11, a_12, a_13],<br/>                 [a_21, a_22, a_23]])</span><span id="84bd" class="kz la it mu b gy ni mz l na nb">A2 = get_affine_cv((tx, ty), angle, scale)<br/>warped = cv2.warpAffine(image, A2, (width, height))</span></pre><p id="716b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2.依靠 OpenCV 使用<code class="fe nc nd ne mu b">cv2.<strong class="lx iu">getRotationMatrix2D</strong>(center, angle, scale)</code>返回仿射变换矩阵。</p><p id="efb4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该功能将图像绕点<em class="or">中心旋转</em>角度，并用<em class="or">标尺</em>对其进行缩放</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="97af" class="kz la it mu b gy my mz l na nb">A3 = cv2.getRotationMatrix2D((tx, ty), np.rad2deg(angle), scale)</span><span id="240a" class="kz la it mu b gy ni mz l na nb">warped = cv2.warpAffine(image, b3, (width, height), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, borderValue=0)</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="6b95" class="nr la it bd lb ns nt nu le nv nw nx lh jz ny ka ll kc nz kd lp kf oa kg lt ob bi translated">摘要</h1><p id="ea0d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在本文中，我介绍了几何变换的基本概念，以及如何将它应用于图像。许多先进的计算机视觉，如使用视觉里程计的 slam 和多视图合成依赖于首先理解变换。</p><p id="b0a0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我相信，作为一名计算机视觉从业者，当我们使用 imgaug 和 albumentation 等强大的库时，理解这些转换是如何工作的肯定是有益的。</p><p id="c365" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">感谢阅读！我希望您已经更好地理解了这些公式是如何在库中编写和使用的。请关注查看更多关于计算机视觉和机器学习的帖子:)如果你发现任何错误或任何不清楚的地方，请在评论中指出来！</p><p id="08cd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">更多文章</strong></p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/depth-estimation-1-basics-and-intuition-86f2c9538cd1"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">深度估计:基础和直觉</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">理解事物相对于相机有多远仍然是困难的，但对于激动人心的…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://medium.com/swlh/camera-lidar-projection-navigating-between-2d-and-3d-911c78167a94" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">相机-激光雷达投影:在 2D 和 3D 之间导航</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">激光雷达和相机是感知和场景理解的两个必不可少的传感器。他们建立了一个环境…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>