<html>
<head>
<title>TDD shouldn’t be TDDious</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDD 不应该是 TDDious</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tdd-shouldnt-be-tddious-e8d6f34cb9d8?source=collection_archive---------24-----------------------#2019-10-11">https://towardsdatascience.com/tdd-shouldnt-be-tddious-e8d6f34cb9d8?source=collection_archive---------24-----------------------#2019-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ecda" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/data-science-in-the-real-world/home">现实世界中的数据科学</a></h2><div class=""/><div class=""><h2 id="36eb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我仍然会遇到古老的“如何测试”的争论，但是我们能让测试变得有趣吗？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a0a952a23eb9d217b785cbc9477493ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTyM3pg9bZEJK0foxKMXcQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk"><em class="lh">(Image by author)</em></figcaption></figure><p id="62eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我作为一名工程师已经工作了十多年，仍然会遇到“如何测试”的争论。我是首席工程师，这意味着我要和我的团队一起研究如何建造东西，所以我总是乐于接受不同的观点。但是我喜欢的一个话题是我们是否应该使用测试驱动开发或者 TDD。我认为这可以归结为一个根本性的误解，即为什么你应该享受 TDD 而不是憎恨它…</p><blockquote class="me mf mg"><p id="1725" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">TDD 以一种清晰的方式让我明白我应该写什么代码。</p></blockquote><p id="2990" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对我来说，TDD 很有趣。我喜欢用测试驱动的方式编码，我无法想象为什么有人会想用其他方式编码。当我不知道如何为某个东西写一个简洁的测试时，我会很难过。这就把我们带到了通常对 TDD 的第一个抱怨——“我不能只编码”。这很有趣，因为 TDD 以一种清晰的方式让我明白我应该写什么代码。如果没有它，我可能会迷失在边缘案例中，或者在我并不打算进行的重构中。另一件事是 TDD 实际上让我“只写代码”，因为我可以写任何我喜欢的可怕的代码，只要测试通过。那种自由太神奇了！我写了一些可怕的代码来通过测试，测试我的假设，证明我的方法，或者看看我是否能过度优化。以连接到数据库为例:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="4d9f" class="mq mr it mm b gy ms mt l mu mv">from mocks import mock_database</span><span id="f1c7" class="mq mr it mm b gy mw mt l mu mv">def test_query_database():<br/>  expected_customer = {<br/>    'id': 32,<br/>    'name': 'woof'<br/>  }</span><span id="a010" class="mq mr it mm b gy mw mt l mu mv">  mock_database()<br/>  customer = get_customer('woof')<br/>  assert customer == expected_customer</span></pre><p id="ceae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以通过多种方式实现。我很快就把这些放在一起:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="6678" class="mq mr it mm b gy ms mt l mu mv">import database</span><span id="9938" class="mq mr it mm b gy mw mt l mu mv">def get_customer(user):<br/>  return database.connect().query(f'SELECT id,name FROM customers WHERE name="{user}"').fetch()</span></pre><p id="db35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">TDD 允许我专注于我希望我的代码实现的事情。遵循红色-&gt;绿色-&gt;重构的循环，我可以在任何时候返回以使代码更整洁:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="450e" class="mq mr it mm b gy ms mt l mu mv">import database</span><span id="e70c" class="mq mr it mm b gy mw mt l mu mv">customer_query = 'SELECT id,name FROM customers WHERE name="{}"'</span><span id="1193" class="mq mr it mm b gy mw mt l mu mv">def get_customer(user):<br/>  conn = database.connect()<br/>  cursor = conn.query(customer_query.format(user))<br/>  return cursor.fetch()</span></pre><blockquote class="me mf mg"><p id="0696" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">测试给你一个安全网，你之前写的功能仍然在运行和工作。</p></blockquote><p id="c562" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这证明了在测试通过后重写代码的想法。对此，我经常采用删除的方法；如果我可以删除代码并且测试仍然通过，那么我可以很高兴地重构它。我也将这种技术作为教学工具，向人们展示他们编写了多少额外的代码。删除代码有助于证明它不是不需要的，就是覆盖度量是误导的。带着“最大化未完成的工作”的敏捷思维，你应该为测试编写尽可能少的代码。这种代码的不断减少是有益的，它本身就是一个游戏，增加了乐趣！请注意，测试代码的成本可能过高；例如，我们在 AWS Lambda 处理函数之外初始化框架。这个初始化比处理程序更难测试，因为它在导入时运行。所以删除代码是有一定的背景的，但是一般来说一些测试层可以覆盖所有的东西。</p><p id="f220" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">令人兴奋的是，如果我不立即重构，在我有几个测试用例之后，我的代码仍然会很糟糕。重构并不总是发生在每次测试之后。测试给你一个安全网，你之前写的功能仍然在运行和工作。您可以继续沿着一条通往其自然结论的道路前进，而不用担心其他东西被破坏或者您稍后需要做的深入重构。通过评估代码，尽可能多地删除代码，您可以在测试保护您的情况下积极地进行大量重构。</p><p id="511d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个常见的抱怨是在做出改变时“我必须改变所有的测试”。在测试领域也有一些争论，关于你应该在什么水平上测试多少。我个人的哲学是，你应该测试你想要达到的目标。在数据管道的情况下，这可能是:从 S3 拉一个文件，对它做一些工作，然后把它放回 S3 的另一个位置。因为我重视 TDD 中的乐趣，这类测试比成百上千的说着同样事情的单元测试更让我高兴。这种数据处理测试的一个例子可能是:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="80ac" class="mq mr it mm b gy ms mt l mu mv">import pandas<br/>import moto <br/>from pandas.testing import assert_frame_equal</span><span id="fefd" class="mq mr it mm b gy mw mt l mu mv">from functions.cake_mixer import mix_ingredients</span><span id="a7eb" class="mq mr it mm b gy mw mt l mu mv">@pytest.fixture<br/>def bucket_fixture():    <br/>  with moto.mock_s3():        <br/>    s3_resource = boto3.resource("s3")        <br/>    bucket = s3_resource.Bucket("test")<br/>    bucket.create()<br/>    yield bucket</span><span id="1f11" class="mq mr it mm b gy mw mt l mu mv">def test_processing_cake(bucket_fixture):<br/>  input_fixture = pandas.read_csv('fixtures/mixture.csv')<br/>  output_fixture = pandas.read_csv('fixtures/cake.csv')</span><span id="8c1e" class="mq mr it mm b gy mw mt l mu mv">  input_fixture.to_parquet('s3://test/ingredients/mixture.parquet')<br/>  mix_ingredients({<br/>    'bucket': 'test_bucket',<br/>    'mixture_key': 'ingredients/mixture.parquet',<br/>    'cake_key': 'cake/chocolate.parquet'<br/>  })<br/>  output = pandas.read_parquet('s3://test/cake/chocolate.parquet')<br/>  assert_frame_equal(output, output_fixture)</span></pre><p id="258d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这做了很多:</p><ul class=""><li id="59aa" class="mx my it lk b ll lm lo lp lr mz lv na lz nb md nc nd ne nf bi translated">为 S3 设置固定装置</li><li id="4a4c" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">上传测试示例文件</li><li id="d8e5" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">运行一些代码来处理这个例子</li><li id="3b24" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">读出结果文件</li><li id="2194" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">断言您的预期输出与处理后的输出相匹配</li></ul><p id="b12c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个例子说明了在这种测试中你可能采取的步骤。要采取更小的步骤，您可以在涉及 S3 之前就开始处理数据:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="d496" class="mq mr it mm b gy ms mt l mu mv">import pandas<br/>from pandas.testing import assert_frame_equal</span><span id="337a" class="mq mr it mm b gy mw mt l mu mv">from functions.cake_mixer import mix_ingredients</span><span id="2b3c" class="mq mr it mm b gy mw mt l mu mv">def test_processing_cake():<br/>  input_fixture = pandas.read_csv('fixtures/mixture.csv')<br/>  output_fixture = pandas.read_csv('fixtures/cake.csv')</span><span id="8947" class="mq mr it mm b gy mw mt l mu mv">  output = mix_ingredients(input_fixture)<br/>  assert_frame_equal(output, output_fixture)</span></pre><p id="fca0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您编写一个不断发展的测试时，您可以感觉到代码在一起。希望这能解决“我必须改变所有的测试”的问题，因为您只完成了实际的需求。紧密耦合的单元不容易改变。一个警告是，当一个单元有一组复杂的输入和输出时，单元测试可以帮助定义它们。</p><p id="f51e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">重要的是，不要试图一次实现太多，要朝着更大的结果努力。有时你想要使用多个测试循环来帮助构建一个更大的目标。对于数据管道，您可以为管道编写一个测试，然后为每个步骤编写一组更小的测试。也就是说，您可以测试管道的输出和概念证明管道是否匹配。然而，管道中的各个阶段都有针对具体的、可解释的转换的测试。从 pandas 概念验证到大规模 Spark 数据管道可以使用相同的端到端测试数据。</p><blockquote class="me mf mg"><p id="af12" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">测试本质上是一个有趣的游戏，你可以设计自己的挑战，然后找到最好、最令人愉快的方式来完成它们。</p></blockquote><p id="0208" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，人们发现考试很单调，对此我无能为力。测试本质上是一个有趣的游戏，你可以设计自己的挑战，然后找到最好、最令人愉快的方式来完成它们。让这一点变得更清楚的最好方法是给自己找一个搭档，用乒乓球的方式进行练习。在乒乓球比赛中，一个人写一个测试，另一个人让它通过。竞相编写更好的测试和代码。有趣的是找到让代码做意想不到的事情的方法，或者找到让你的伙伴多思考一点来解决的边缘情况。例如，如果有一个函数要返回传递的值，您可以很容易地编写以下代码:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="2c4f" class="mq mr it mm b gy ms mt l mu mv">def test_identity():<br/>  assert identity(1) == 1</span></pre><p id="9312" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以很容易地从中获得乐趣，如下所示:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="6610" class="mq mr it mm b gy ms mt l mu mv">def identity(x):<br/>  return 1</span></pre><p id="82cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着您的合作伙伴现在必须实现预期的功能。下一次，技巧可能是检查 x 的两个不同值，以防止您玩得太开心:</p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="8424" class="mq mr it mm b gy ms mt l mu mv">def test_identity():<br/>  assert identity(1) == 1<br/>  assert identity(404) == 404</span></pre><p id="5aab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您已经介绍了几个额外的案例，并设法确保代码完全按照您的意图运行。</p><p id="de69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我真的希望这篇文章向你展示，TDD 给你的不是负担，而是:</p><ul class=""><li id="a481" class="mx my it lk b ll lm lo lp lr mz lv na lz nb md nc nd ne nf bi translated">理解你要写的代码和它应该做什么</li><li id="26ba" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">这是一张继续编写糟糕代码的安全网，直到你想重构为止</li><li id="fd6d" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">工作生活的游戏化，包括多人游戏！</li></ul><p id="c771" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，就算你以前试过，再试试 TDD，因为大家应该会玩得更开心:-)。</p></div></div>    
</body>
</html>