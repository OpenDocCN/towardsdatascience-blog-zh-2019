<html>
<head>
<title>Time Series Hierarchical Clustering using Dynamic Time Warping in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中使用动态时间弯曲的时间序列层次聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-hierarchical-clustering-using-dynamic-time-warping-in-python-c8c9edf2fda5?source=collection_archive---------5-----------------------#2019-11-13">https://towardsdatascience.com/time-series-hierarchical-clustering-using-dynamic-time-warping-in-python-c8c9edf2fda5?source=collection_archive---------5-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8141" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">让我们考虑下面的任务</strong>:我们有一堆均匀分布的不同长度的时间序列。目标是通过定义数据中呈现的一般模式来对时间序列进行聚类。</p><p id="9500" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我想介绍一种解决这个问题的方法。我们将使用层次聚类和 DTW 算法作为时间序列的比较度量。该解决方案在人力资源数据(员工历史得分)上运行良好。对于其他类型的时间序列，DTW 函数可能比其他指标更差，如 CID(复杂性不变距离)，MAE 或相关性。</p><p id="45d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将跳过对层次聚类和 DTW 算法的理论解释，而专注于我为什么选择这样的组合:</p><ol class=""><li id="df20" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">层次聚类简单、灵活、可调(链接标准),并允许我们不聚类所有轨迹</li><li id="9b03" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">DTW 方法让我们可以比较不同长度的时间序列，根据我的经验，它非常适用于不频繁的时间序列</li></ol><p id="94cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我们开始吧！我们的进口:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="310b" class="ll lm it lh b gy ln lo l lp lq">import random<br/>from copy import deepcopy<br/>from scipy import interpolate<br/>import numpy as np<br/>from dtaidistance import dtw</span><span id="2c89" class="ll lm it lh b gy lr lo l lp lq">import matplotlib.pyplot as plt</span><span id="a2cc" class="ll lm it lh b gy lr lo l lp lq">from _plotly_future_ import v4_subplots<br/>import plotly.graph_objects as go<br/>from plotly.subplots import make_subplots</span></pre><p id="fbe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间序列生成的一些参数和我们的阈值:</p><ul class=""><li id="e8f3" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ls ku kv kw bi translated"><em class="lt">轨迹数量</em>我们必须聚类的轨迹数量</li><li id="8175" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ls ku kv kw bi translated"><em class="lt">最小轨迹长度</em>和<em class="lt">最大轨迹长度</em>任何轨迹的长度下限和上限</li><li id="c771" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ls ku kv kw bi translated"><em class="lt">门槛</em>我们 DTW 的门槛</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4504" class="ll lm it lh b gy ln lo l lp lq">NUM_OF_TRAJECTORIES = 200<br/>MIN_LEN_OF_TRAJECTORY = 16<br/>MAX_LEN_OF_TRAJECTORY = 40</span><span id="2738" class="ll lm it lh b gy lr lo l lp lq">THRESHOLD = 0.50</span></pre><p id="1afb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为简单起见，我们所有的轨迹将位于-1 和 1 之间。此外，我添加了一些平滑。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="0d34" class="ll lm it lh b gy ln lo l lp lq">for item in range(NUM_OF_TRAJECTORIES):<br/>   length = random.choice(list(range(MIN_LEN_OF_TRAJECTORY, MAX_LEN_OF_TRAJECTORY + 1)))<br/>   tempTrajectory = np.random.randint(low=-100, high=100, size=int(length / 4)).astype(float) / 100<br/>   <br/>   oldScale = np.arange(0, int(length / 4))<br/>   interpolationFunction = interpolate.interp1d(oldScale, tempTrajectory)<br/>   <br/>   newScale = np.linspace(0, int(length / 4) - 1, length)<br/>   tempTrajectory = interpolationFunction(newScale)<br/>   <br/>   trajectoriesSet[(str(item),)] = [tempTrajectory]</span></pre><p id="d3a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，所有轨迹都存储为列表类型的字典值(为了方便，我们将开始把它们组合成组)。出于同样的原因，轨迹的名称存储为元组。</p><p id="1892" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的算法如下:</p><ol class=""><li id="5804" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">我们找到一对最接近的实体(轨迹-轨迹或轨迹-簇或簇-轨迹或簇-簇)</li><li id="63bc" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">如果它们的距离低于<em class="lt">阈值</em>，则将它们分组到单个簇中</li><li id="0442" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">重复步骤 1</li><li id="fed7" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">如果我们在步骤 2 失败或者我们得到一个大的集群，我们就停止我们的算法(所以我们所有的轨迹都进入其中——这意味着我们的<em class="lt">阈值</em>非常大)</li></ol><p id="be6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">算法的第一部分:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f460" class="ll lm it lh b gy ln lo l lp lq">trajectories = deepcopy(trajectoriesSet)<br/>distanceMatrixDictionary = {}</span><span id="6026" class="ll lm it lh b gy lr lo l lp lq">iteration = 1<br/>while True:<br/>   distanceMatrix = np.empty((len(trajectories), len(trajectories),))<br/>   distanceMatrix[:] = np.nan<br/>   <br/>   for index1, (filter1, trajectory1) in enumerate(trajectories.items()):<br/>      tempArray = []<br/>      <br/>      for index2, (filter2, trajectory2) in enumerate(trajectories.items()):<br/>         <br/>         if index1 &gt; index2:<br/>            continue<br/>         <br/>         elif index1 == index2:<br/>            continue<br/>         <br/>         else:<br/>            unionFilter = filter1 + filter2<br/>            sorted(unionFilter)<br/>            <br/>            if unionFilter in distanceMatrixDictionary.keys():<br/>               distanceMatrix[index1][index2] = distanceMatrixDictionary.get(unionFilter)<br/>               <br/>               continue<br/>            <br/>            metric = []<br/>            for subItem1 in trajectory1:<br/>               <br/>               for subItem2 in trajectory2:<br/>                  metric.append(dtw.distance(subItem1, subItem2, psi=1))<br/>            <br/>            metric = max(metric)<br/>            <br/>            distanceMatrix[index1][index2] = metric<br/>            distanceMatrixDictionary[unionFilter] = metric</span></pre><p id="dee9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">字典<em class="lt">距离矩阵字典</em>帮助我们保持已经计算好的距离。</p><p id="2999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Numpy 数组<em class="lt"> distanceMatrix </em>在每一步开始时用<em class="lt"> np.nan </em>填充。只需要保持索引对和计算的距离之间的表示。向<em class="lt"> distanceMatrixDictionary 添加相同功能后，可能会被删除。</em></p><p id="d618" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这部分代码允许我们比较所有可能的选项——轨迹-轨迹或轨迹-簇或簇-轨迹或簇-簇:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="208c" class="ll lm it lh b gy ln lo l lp lq">metric = []<br/>for subItem1 in trajectory1:<br/>   <br/>   for subItem2 in trajectory2:<br/>      metric.append(dtw.distance(subItem1, subItem2))</span><span id="5f5b" class="ll lm it lh b gy lr lo l lp lq">metric = max(metric)</span></pre><p id="bb1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面最后一行— <em class="lt"> metric = max(metric) </em> —是称为“完全关联”的关联标准。它对我来说更好，但你可以尝试其他标准，甚至定制它。</p><p id="c43b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，距离已经计算好了，让我们继续分组。</p><p id="4997" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们找到最低的距离和一对提供这个距离的指数。</p><p id="cf8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里为了简单起见，我们将只使用一对(第一对)。甚至，如果我们对于相同的距离有两个、三个或更多对，其余的将在下一次迭代中逐步处理。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="abf3" class="ll lm it lh b gy ln lo l lp lq">minValue = np.min(list(distanceMatrixDictionary.values()))</span><span id="e7b5" class="ll lm it lh b gy lr lo l lp lq">if minValue &gt; THRESHOLD:<br/>   break</span><span id="7727" class="ll lm it lh b gy lr lo l lp lq">minIndices = np.where(distanceMatrix == minValue)<br/>minIndices = list(zip(minIndices[0], minIndices[1]))</span><span id="1d91" class="ll lm it lh b gy lr lo l lp lq">minIndex = minIndices[0]</span></pre><p id="5e6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获得一对索引后，我们只需定义实体名称和值，组合它们，将组合放入字典中，并从字典中删除这些单个实体:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="0127" class="ll lm it lh b gy ln lo l lp lq">filter1 = list(trajectories.keys())[minIndex[0]]<br/>filter2 = list(trajectories.keys())[minIndex[1]]</span><span id="2714" class="ll lm it lh b gy lr lo l lp lq">trajectory1 = trajectories.get(filter1)<br/>trajectory2 = trajectories.get(filter2)</span><span id="7f09" class="ll lm it lh b gy lr lo l lp lq">unionFilter = filter1 + filter2<br/>sorted(unionFilter)</span><span id="4b23" class="ll lm it lh b gy lr lo l lp lq">trajectoryGroup = trajectory1 + trajectory2</span><span id="5ca9" class="ll lm it lh b gy lr lo l lp lq">trajectories = {key: value for key, value in trajectories.items()<br/>                if all(value not in unionFilter for value in key)}</span><span id="853c" class="ll lm it lh b gy lr lo l lp lq">distanceMatrixDictionary = {key: value for key, value in distanceMatrixDictionary.items()<br/>                            if all(value not in unionFilter for value in key)}</span><span id="25b8" class="ll lm it lh b gy lr lo l lp lq">trajectories[unionFilter] = trajectoryGroup</span></pre><p id="ba90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们重复上一步，直到我们没有任何集群。</p><p id="3325" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经描述了一般的方法，但是这个算法可以被简化、增强和修改以避免任何重新计算。</p><p id="0ae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果，我们得到这样的分组:</p><figure class="lc ld le lf gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/2f9d50a9b0094024597af9ea87cb8a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IaLUQLr3fNqwHzK98oFmg.png"/></div></div></figure><p id="b0e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个集群中，我们看到 3 个不同长度的时间序列。它们都有相同的一般模式:前三分之一是局部最小值，后半部分是全局峰值，最后是全局最小值。</p><p id="061d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多结果(此处，对于每个聚类，左边的子图表示原始轨迹长度，右边的子图——重新缩放到<em class="lt"> MAX_LEN_OF_TRAJECTORY </em>用于比较):</p><figure class="lc ld le lf gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/0752ed24953c30f769e6c4e2200786bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tb4JGLF7VJahTA2xOdVDtA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Cluster #1–2 items</figcaption></figure><figure class="lc ld le lf gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/d27ede65d4de894f31c212ec2101cbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1490g5Ply9UVAC3Pg_qEQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Cluster #2–2 items</figcaption></figure><figure class="lc ld le lf gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/5911ac0455a67e699d280690989484ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NFb7ENs9p39F5B-e_LJpg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Cluster #3–3 items</figcaption></figure><figure class="lc ld le lf gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/7ba1688c9beeb5d852ea6f6527b95d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IDtNA7h9monMf1IKIVPHA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Cluster #4–3 items</figcaption></figure><figure class="lc ld le lf gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/edff08273bbce2ed2e121f67959c64de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qafO_8RsSaCflJmD_4BE7A.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Cluster #5–3 items</figcaption></figure><p id="7d50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据<em class="lt">阈值</em>的值，我们可以使我们的集群更大(更一般化)或更小(更详细)。</p><p id="fe5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果当前方法在另一个数据集上表现不佳，我们可以改进什么？</p><ol class=""><li id="c3ef" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">我们可以尝试用另一种距离度量来代替 DWT</li><li id="b87d" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">我们可以尝试对时间序列进行额外的处理:缩放/重新缩放、平滑或去除异常值</li><li id="98f6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">我们可以尝试使用不同的阈值</li><li id="cac3" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">我们可以尝试改变联系标准</li></ol><p id="927c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">找到最佳超参数后，可以重构代码并加快计算速度。</p><p id="e579" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有可以使用的代码:<br/><a class="ae mg" href="https://github.com/avchauzov/_articles/blob/master/1.1.trajectoriesClustering.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/avchauzov/_ articles/blob/master/1.1 . trajectoriesclustering . ipynb</a></p></div></div>    
</body>
</html>