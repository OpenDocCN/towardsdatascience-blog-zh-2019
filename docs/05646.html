<html>
<head>
<title>The Ultimate Guide to using the Python regex module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 正则表达式模块的最终指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-ultimate-guide-to-using-the-python-regex-module-69aad9e9ba56?source=collection_archive---------8-----------------------#2019-08-19">https://towardsdatascience.com/the-ultimate-guide-to-using-the-python-regex-module-69aad9e9ba56?source=collection_archive---------8-----------------------#2019-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/80244cc23844fbf9826840f55056916d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-yPBlu1NMREEwoQ-hjmYw.png"/></div></div></figure><div class=""/><div class=""><h2 id="43aa" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">原始模式查找器</h2></div><p id="6297" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">处理文本数据的主要任务之一是创建大量基于文本的要素。</p><p id="a484" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">人们可能希望找出文本、电子邮件(如果在文本中出现的话)以及大文本中的电话号码中的某些模式。</p><p id="63b1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然实现这样的功能听起来很简单，但是如果我们使用 Python 的 regex 模块，就会简单得多。</p><p id="f134" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，假设你的任务是找出一段特定文本中标点符号的数量。这里引用了狄更斯的文字。</p><p id="55c7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你通常是怎么做的？</p><p id="e8f6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个足够简单的方法是这样做:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3b8a" class="ly lz je lu b gy ma mb l mc md">target = [';','.',',','–']</span><span id="ddcc" class="ly lz je lu b gy me mb l mc md">string = "<strong class="lu jf">It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way – in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.</strong>"</span><span id="4726" class="ly lz je lu b gy me mb l mc md">num_puncts = 0<br/>for punct in target:<br/>    if punct in string:<br/>        num_puncts+=string.count(punct)</span><span id="3c35" class="ly lz je lu b gy me mb l mc md">print(num_puncts)<br/>------------------------------------------------------------------<br/>19</span></pre><p id="af52" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们没有 re 模块的话，那就太好了。对于 re，它只有两行代码:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="e9b2" class="ly lz je lu b gy ma mb l mc md">import re<br/>pattern = r"[;.,–]"<br/>print(len(re.findall(pattern,string)))<br/>------------------------------------------------------------------<br/>19</span></pre><p id="f677" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这篇文章是关于一个最常用的正则表达式模式和一些我经常使用的正则表达式函数。 </p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="805c" class="mn lz je bd mo mp mq mr ms mt mu mv mw kk mx kl my kn mz ko na kq nb kr nc nd bi translated">什么是<code class="fe ne nf ng lu b">regex</code>？</h1><p id="51e3" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">更简单地说，正则表达式(regex)用于在给定的字符串中查找模式。</p><p id="4431" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们想找到的模式可能是任何东西。</p><p id="029c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以创建类似电子邮件或手机号码的模式。我们可以创建模式，从字符串中找出以 a 开头以 z 结尾的单词。</p><p id="78eb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在上面的例子中:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b89d" class="ly lz je lu b gy ma mb l mc md">import re</span><span id="36e4" class="ly lz je lu b gy me mb l mc md">pattern = r'[,;.,–]'<br/>print(len(re.findall(pattern,string)))</span></pre><p id="03da" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们想要找出的模式是<code class="fe ne nf ng lu b">r’[,;.,–]’</code>。这个模式捕获了我们想要捕获的 4 个字符中的任何一个。我发现<a class="ae nm" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> regex101 </a>是测试模式的好工具。这是模式应用于目标字符串时的样子。</p><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/b2cc92225f205617a7bf7bdf35cf26b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoRNtShLFaoGZ_CAMHdQAw.png"/></div></div></figure><p id="5800" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如我们所看到的，我们能够根据需要在目标字符串中找到所有出现的<code class="fe ne nf ng lu b">,;.,–</code>。</p><p id="3bac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每当我需要测试一个正则表达式时，我都会使用上面的工具。比一遍又一遍地运行 python 程序要快得多，调试也容易得多。</p><p id="2b4c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们知道我们可以在目标字符串中找到模式，但是我们如何真正创建这些模式呢？</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c50c" class="mn lz je bd mo mp mq mr ms mt mu mv mw kk mx kl my kn mz ko na kq nb kr nc nd bi translated">创建模式</h1><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/da6a1d2636f6837de5ca5c7ab04a2d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RtWgenGIaDQbjtjr.png"/></div></div></figure><p id="3663" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">使用 regex 时，我们需要学习的第一件事是如何创建模式。</p><p id="3afe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我将逐一介绍一些最常用的模式。</p><p id="8828" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如您所想的，最简单的模式是一个简单的字符串。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="01e6" class="ly lz je lu b gy ma mb l mc md">pattern = r'times'</span><span id="5332" class="ly lz je lu b gy me mb l mc md">string = "<strong class="lu jf">It was the best of times, it was the worst of times.</strong>"</span><span id="79df" class="ly lz je lu b gy me mb l mc md">print(len(re.findall(pattern,string)))</span></pre><p id="b9f0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但这不是很有用。为了帮助创建复杂的模式，regex 提供了特殊的字符/操作符。让我们一个一个地看一下这些操作符。请等待加载 gif 文件。</p><h2 id="7e76" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">1.<code class="fe ne nf ng lu b">[] </code>操作员</h2><p id="cf0d" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">这是我们在第一个例子中使用的。<strong class="kv jf"> <em class="mf">我们想在这些方括号中找到任意字符的一个实例。</em> </strong></p><p id="78c4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">[abc]</code> -将找到 a 或 b 或 c 的所有出现</p><p id="4119" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">[a-z]</code> -将查找 a 到 z 的所有事件。</p><p id="f473" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">[a-z0–9A-Z]</code> -将查找 A 到 Z、A 到 Z 和 0 到 9 的所有事件。</p><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/295d65aebe12fffead1942075778999b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rZvRtZio3uMiWkFSpvVNTg.gif"/></div></div></figure><p id="680f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在 Python 中，我们可以很容易地使用如下模式:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4738" class="ly lz je lu b gy ma mb l mc md">pattern = r'[a-zA-Z]'</span><span id="a529" class="ly lz je lu b gy me mb l mc md">string = "<strong class="lu jf">It was the best of times, it was the worst of times.</strong>"</span><span id="9780" class="ly lz je lu b gy me mb l mc md">print(len(re.findall(pattern,string)))</span></pre><p id="c9a5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">除了<code class="fe ne nf ng lu b">.findall</code>之外，regex 中还有其他功能，但我们稍后会谈到。</p><h2 id="9c6f" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">2.点运算符</h2><p id="5055" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">点运算符(。)用于匹配除换行符以外的任何字符<em class="mf">的单个实例。</em></p><p id="f1bc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">关于操作符最好的部分是我们可以把它们结合在一起使用。</p><p id="7a73" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，我们想找出字符串中以小写 D 或大写 D 开头，以长度为 6 的 e 结尾的子字符串。</p><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/8a58233c9dc194435b0a434e31180a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EcVWBu18uDQCGlhcqTVoww.gif"/></div></div></figure><h2 id="ee99" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">3.一些元序列</h2><p id="e7ca" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">在使用 regex 时，有一些模式我们会反复使用。所以 regex 为它们创建了一些快捷方式。最有用的快捷方式是:</p><p id="de95" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">\w</code>，匹配任何字母、数字或下划线。相当于<code class="fe ne nf ng lu b">[a-zA-Z0–9_]</code></p><p id="59ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">\W</code>，匹配除字母、数字或下划线以外的任何内容。</p><p id="c9ab" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">\d</code>，匹配任意十进制数字。相当于<code class="fe ne nf ng lu b">[0–9]</code>。</p><p id="efa9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">\D</code>，匹配除十进制数字以外的任何数字。</p><h2 id="4daa" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">4.加号和星号运算符</h2><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/ac83597a12f51b1974247a6c5d6ab37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tzkvhxeeMVASRkGy"/></div></div></figure><p id="1d55" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">点字符用于获取任何字符的单个实例。如果我们想找到更多。</p><p id="4204" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">加号字符<code class="fe ne nf ng lu b">+</code>，用于表示最左边字符的一个或多个实例。</p><p id="af90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">星形字符<code class="fe ne nf ng lu b">*</code>，用于表示最左边字符的 0 个或多个实例。</p><p id="c2ff" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">比如我们想找出所有以 d 开头以 e 结尾的子串，我们可以在 d 和 e 之间有<strong class="kv jf"> <em class="mf">零个字符或者更多的字符</em> </strong>我们可以用:<code class="fe ne nf ng lu b">d\w*e</code></p><p id="fa80" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们想找出所有以 d 开头以 e 结尾的子串，并且在 d 和 e 之间至少有一个字符，我们可以使用:<code class="fe ne nf ng lu b">d\w+e</code></p><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a74fbd3fde3d9492369a65fe2f3cce82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*eHeZdKyr_VinWPylpYaIQw.gif"/></div></figure><h2 id="2c72" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">我们也可以通过{}使用更通用的方法</h2><p id="6df4" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated"><code class="fe ne nf ng lu b">\w{n}</code> -重复<code class="fe ne nf ng lu b">\w</code>n 次。</p><p id="42ae" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">\w{n,}</code> -重复<code class="fe ne nf ng lu b">\w</code>至少 n 次以上。</p><p id="3ddd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng lu b">\w{n1, n2}</code> -重复<code class="fe ne nf ng lu b">\w</code>至少 n1 次，但不超过 n2 次。</p><h2 id="96ae" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">5.<code class="fe ne nf ng lu b">^</code>脱字符和<code class="fe ne nf ng lu b">$ </code>美元符。</h2><p id="c595" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">^匹配字符串的开头，$匹配字符串的结尾。</p><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1ae92e1131a69e5c38b78269df36e510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*1WSgcSPztTCNC9of3vJdXw.gif"/></div></figure><h2 id="5aa9" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">6.单词边界</h2><p id="98a0" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">这是一个重要的概念。</p><p id="5b5b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你有没有注意到在上面的例子中我总是匹配子串而不是一个单词？</p><p id="41b7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那么，如果我们想找到所有以 d 开头的单词呢？</p><p id="312d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">可以用<code class="fe ne nf ng lu b">d\w*</code>做图案吗？让我们看看如何使用网络工具。</p><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6228c2ea6a8fa347f41ae2f1578cce36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*8BBjpa-qtbHu5VGoaAKFAg.gif"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="af54" class="mn lz je bd mo mp mq mr ms mt mu mv mw kk mx kl my kn mz ko na kq nb kr nc nd bi translated">正则表达式函数</h1><p id="0187" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">到目前为止，我们只使用了<code class="fe ne nf ng lu b">re</code>包中的<code class="fe ne nf ng lu b">findall</code>函数，但是它还支持更多的函数。让我们一个一个地研究这些函数。</p><h2 id="6841" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">1.<code class="fe ne nf ng lu b">findall</code></h2><p id="9372" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">我们已经用了<code class="fe ne nf ng lu b">findall</code>。这是我最常使用的正则表达式函数之一。让我们更正式地理解它。</p><p id="0998" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mf">输入:</em> </strong>模式和测试字符串</p><p id="32d7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mf">输出:</em> </strong>字符串列表。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="15b3" class="ly lz je lu b gy ma mb l mc md">#USAGE:</span><span id="b305" class="ly lz je lu b gy me mb l mc md">pattern = r'[iI]t'<br/>string = "<strong class="lu jf">It was the best of times, it was the worst of times.</strong>"</span><span id="b425" class="ly lz je lu b gy me mb l mc md">matches = re.findall(pattern,string)</span><span id="1b6c" class="ly lz je lu b gy me mb l mc md">for match in matches:<br/>    print(match)</span><span id="5289" class="ly lz je lu b gy me mb l mc md">------------------------------------------------------------<br/>It<br/>it</span></pre><h2 id="136f" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">2.搜索</h2><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/5ef1e08abdd3613834c6e7beec069f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*25g0hfgFiekjqJOh"/></div></div></figure><p id="5ce2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mf">输入:</em> </strong>模式和测试字符串</p><p id="7845" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mf">输出:</em> </strong>定位第一个匹配的对象。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a75d" class="ly lz je lu b gy ma mb l mc md">#USAGE:</span><span id="f436" class="ly lz je lu b gy me mb l mc md">pattern = r'[iI]t'<br/>string = "<strong class="lu jf">It was the best of times, it was the worst of times.</strong>"</span><span id="b803" class="ly lz je lu b gy me mb l mc md">location = re.search(pattern,string)<br/>print(location)</span><span id="2056" class="ly lz je lu b gy me mb l mc md">------------------------------------------------------------<br/>&lt;_sre.SRE_Match object; span=(0, 2), match='It'&gt;</span></pre><p id="1b7c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以使用以下方法获取这个位置对象的数据</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f2e0" class="ly lz je lu b gy ma mb l mc md">print(location.group())<br/>------------------------------------------------------------<br/>'It'</span></pre><h2 id="bd31" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">3.代替者</h2><p id="46a2" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">这是另一个伟大的功能。当你使用 NLP 时，有时你需要用 X 来代替整数。或者你可能需要编辑一些文件。在任何文本编辑器中只有基本的查找和替换。</p><p id="324b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mf">输入:</em> </strong>搜索模式、替换模式和目标字符串</p><p id="d03c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mf">输出:</em> </strong>被替换的字符串</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="2ea4" class="ly lz je lu b gy ma mb l mc md">string = "It was the best of times, it was the worst of times."<br/>string = re.sub(r'times', r'life', string)<br/>print(string)<br/>------------------------------------------------------------<br/>It was the best of life, it was the worst of life.</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="11fc" class="mn lz je bd mo mp mq mr ms mt mu mv mw kk mx kl my kn mz ko na kq nb kr nc nd bi translated">一些案例研究:</h1><p id="d32c" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">当需要验证时，在许多情况下使用正则表达式。你可能在网站上看到过类似“这不是一个有效的电子邮件地址”的提示。虽然可以使用多个 if 和 else 条件来编写这样的提示，但是 regex 可能是这种用例的最佳选择。</p><h2 id="6910" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">1.PAN 编号</h2><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/0d7c007df06ee7a3e7e97177d58a3293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DnxX5UIx8fYxbTcT.jpg"/></div></div></figure><p id="fb39" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在印度，我们用 PAN 号而不是美国的 SSN 号来识别税号。PAN 的基本验证标准是所有字母必须大写，字符必须按以下顺序排列:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6e3b" class="ly lz je lu b gy ma mb l mc md">&lt;char&gt;&lt;char&gt;&lt;char&gt;&lt;char&gt;&lt;char&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;char&gt;</span></pre><p id="8cfe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以问题是:</p><p id="6777" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">“ABcDE1234L”是有效的 PAN 吗？</p><p id="5a19" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果没有正则表达式，你通常会如何解决这个问题？您很可能会编写一个 for 循环，并在字符串中保留一个索引。使用正则表达式，就像下面这样简单:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0e97" class="ly lz je lu b gy ma mb l mc md">match=re.search(r’[A-Z]{5}[0–9]{4}[A-Z]’,'ABcDE1234L')<br/>if match:<br/>    print(True)<br/>else:<br/>    print(False)<br/>-----------------------------------------------------------------<br/>False</span></pre><h2 id="f104" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">2.查找域名</h2><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/c8738048779a7f37ebc95c74daf67f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KddSNVboVsQ-1phX.png"/></div></div></figure><p id="c24e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有时我们有一个大的文本文档，我们必须从这个大的文本文档中找出电话号码或电子邮件 id 或域名的实例。</p><p id="dcc6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，假设您有以下文本:</p><figure class="lp lq lr ls gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="726a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你需要从这篇文章中找出所有的主要领域- <code class="fe ne nf ng lu b">askoxford.com;bnsf.com;hydrogencarsnow.com;mrvc.indianrail.gov.in;web.archive.org</code></p><p id="8ec1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你会怎么做？</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b25f" class="ly lz je lu b gy ma mb l mc md">match=re.findall(r'http(s:|:)\/\/(<a class="ae nm" href="http://www.|ww2.|)([0-9a-z.A-Z-]*\.\w{2,3})',string)" rel="noopener ugc nofollow" target="_blank">www.|ww2.|)([0-9a-z.A-Z-]*\.\w{2,3})',string)</a><br/>for elem in match:<br/>    print(elem)<br/>--------------------------------------------------------------------<br/>(':', 'www.', 'askoxford.com')<br/>(':', 'www.', 'hydrogencarsnow.com')<br/>(':', 'www.', 'bnsf.com')<br/>(':', '', 'web.archive.org')<br/>(':', 'www.', 'mrvc.indianrail.gov.in')<br/>(':', 'www.', 'mrvc.indianrail.gov.in')</span></pre><p id="cdf4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">|在这里是 or 运算符，match 返回元组，其中保存了()内的模式部分。</p><h2 id="2ea6" class="ly lz je bd mo np nq dn ms nr ns dp mw lc nt nu my lg nv nw na lk nx ny nc nz bi translated">3.查找电子邮件地址:</h2><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/f762f09e498241caf07027c8034ec665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tbhq1AhYgur_dKvT"/></div></div></figure><p id="4cfa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面是一个在长文本中查找电子邮件地址的正则表达式。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="d54b" class="ly lz je lu b gy ma mb l mc md">match=re.findall(r'([\w0-9-._]+@[\w0-9-.]+[\w0-9]{2,3})',string)</span></pre><p id="367b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些都是高级的例子，但是如果你试着自己理解这些例子，你应该对提供的信息很满意。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5dcc" class="mn lz je bd mo mp mq mr ms mt mu mv mw kk mx kl my kn mz ko na kq nb kr nc nd bi translated">结论</h1><figure class="lp lq lr ls gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/75ac6c56522c2884c37f5e76ef2d23d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wa8X7N6E-zEUpSnH"/></div></div></figure><p id="68af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然乍一看可能有点令人生畏，但在数据操作、创建特性和寻找模式方面，regex 提供了很大程度的灵活性。</p><p id="deb7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我处理文本数据时，我经常使用它，在处理数据验证任务时，也可以包含它。</p><p id="f342" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我也是 regex101 工具的粉丝，经常用它来检查我的正则表达式。我想知道如果没有这个令人敬畏的工具，我是否还会使用正则表达式。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="fe3e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另外，如果你想在<a class="ae nm" href="https://coursera.pxf.io/9WjZo0" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">了解更多关于 NLP </strong>的知识，这里的</a>是一门很好的课程。您可以免费开始 7 天的免费试用。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="4707" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae nm" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"> <strong class="kv jf">媒体</strong> </a>关注我，或者订阅我的<a class="ae nm" href="http://eepurl.com/dbQnuX?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter<a class="ae nm" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"><strong class="kv jf">@ ml whiz</strong></a>联系。</p></div></div>    
</body>
</html>