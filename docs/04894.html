<html>
<head>
<title>BigQuery: SQL on Nested Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery:嵌套数据上的 SQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/https-medium-com-martin-weitzmann-bigquery-sql-on-nested-data-cf9589c105f4?source=collection_archive---------3-----------------------#2019-07-24">https://towardsdatascience.com/https-medium-com-martin-weitzmann-bigquery-sql-on-nested-data-cf9589c105f4?source=collection_archive---------3-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="81ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 BigQuery 中运行分析可能非常强大，因为嵌套数据和数组基本上意味着处理预连接的表。查询它们可能非常有效，但许多分析师不熟悉半结构化、嵌套的数据，并努力利用其全部潜力。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/567f0b8fd5e3d29c9f97735f2fd4cfd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA1Clq8hynyzBVMYS7S98A.png"/></div></div></figure><h1 id="1acb" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">“半结构化”到底是什么意思？</h1><p id="be60" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这意味着我们可以定义一个复杂的嵌套结构，但它必须在整个表中保持一致。要创建它，我们需要两样东西:<a class="ae md" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct-type" rel="noopener ugc nofollow" target="_blank">结构</a>和<a class="ae md" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#array-type" rel="noopener ugc nofollow" target="_blank">数组</a>。定义结构的一种方法是使用 struct()函数:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="de17" class="mj lb it mf b be mk ml l mm mn">SELECT<br/>  STRUCT(42 as answer, 'Hello World!' as greeting) as info</span></pre><p id="7c53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果的 JSON 表示如下:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="0f32" class="mj lb it mf b be mk ml l mm mn">{<br/>  "info": {<br/>    "answer": "42",<br/>    "greeting": "Hello World!"<br/>  }<br/>}</span></pre><p id="eea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定义数组也相当容易。请注意，在定义结构时，您只需要在第一个实例中定义字段名称。所有其他结构都继承这些名称。</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="f925" class="mj lb it mf b be mk ml l mm mn">SELECT<br/>  [1, 4, 832] as integers,<br/>  ['a', 'b', 'c', 'xyz', 'Hallo!'] as strings,<br/>  [true, true, false, true ] as booleans,<br/>  [<br/>    STRUCT(1 as int, false as bools), <br/>    STRUCT(25, false), <br/>    STRUCT(620, true) <br/>  ] as structs1,<br/>  [<br/>    STRUCT( [5, 2, 9] as arr ), <br/>    STRUCT( [7, 2] ), <br/>    STRUCT( [15, 0, 94] ) <br/>  ] as structs2</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/bceda1a1d4782ed5b07f4c90981cdd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*2rTcif3EyzevOEldqvWyYg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">A couple of arrays … and arrays in an array — everything in one row! (screenshot by author)</figcaption></figure><p id="21c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在<code class="fe mt mu mv mf b">structs2</code>中看到的，为了在一个数组中列出数组，你需要将它们放入一个结构中。这样他们可以有一个名字，也可以在以后得到解决。</p><h1 id="dce7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">但是这些数组是如何预先连接到表中的呢？</h1><p id="a540" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">请这样想:通常信息分布在多个表中以节省存储空间，只有在需要时才组合在一起，如下例所示:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="0c01" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 1 AS id, 'spaghetti napoli' AS meal<br/>  UNION ALL<br/>    SELECT 2, 'soljanka'<br/>  ),<br/>t2 AS (<br/>    SELECT 1 AS id, 'spaghetti' AS ingredient  <br/>  UNION ALL<br/>    SELECT 1, 'tomatoes'<br/>  UNION ALL<br/>    SELECT 2, 'pickles'<br/>  UNION ALL<br/>    SELECT 2, 'lecsó'<br/>  )<br/>  <br/>SELECT * FROM t1 LEFT JOIN t2 USING(id)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/531a9d8d478a526a6c3eab45cc4c1623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*XhydCUgDjQ1pIHDyXJ52OQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Yummy result of a join (screenshot by author)</figcaption></figure><p id="5b23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在嵌套数据中，相同的场景看起来更像这样:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="3038" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 'spaghetti napoli' as meal, ['spaghetti', 'tomatoes'] as ingredient<br/>  UNION ALL<br/>    SELECT 'soljanka', ['pickles', 'lecsó']<br/>  )<br/>  <br/>SELECT * FROM t1 </span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/cbe2da53cab32eacbc5279c857ff615b.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*xfPd33MbDGnHSwAr8WHJRA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Nested result in two rows (screenshot by author)</figcaption></figure><p id="3ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将两个表合并为一个—数据放在一起，节省了存储空间，并且不需要 id。</p><h1 id="c2ae" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">好的，但是我如何查询数组呢？</h1><p id="da09" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">公平的问题—让我们看看选项…</p><h2 id="9f89" class="my lb it bd lc mz na dn lg nb nc dp lk kb nd ne lo kf nf ng ls kj nh ni lw nj bi translated">Unnest 阵列</h2><p id="f9e5" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">允许我们查询数组的神奇函数叫做<code class="fe mt mu mv mf b">UNNEST()</code>。它将一个<em class="nk">数组作为输入</em>，并将它的内容作为<em class="nk">表行作为输出</em>。如果数组由<em class="nk">结构</em>组成，它会很方便地将它们转换成<em class="nk">列</em>。</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="884b" class="mj lb it mf b be mk ml l mm mn">SELECT id, name FROM UNNEST( [ <br/>    STRUCT(12 as id, 'Hannah' as name),<br/>    (13, 'Simone'),<br/>    (14, 'Ada')<br/>  ] )</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9bf74e2f2eccf833dc862c90bab070c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*KFASGpX1erJBebsgB6mm9g.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">3 important personalities in 3 rows from one array (screenshot by author)</figcaption></figure><p id="0ea6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe mt mu mv mf b">UNNEST()</code>有两种方法:<em class="nk">展平</em>表格或者使用<em class="nk">子查询</em>。这在很大程度上取决于您的用例。</p><ul class=""><li id="6db2" class="nm nn it js b jt ju jx jy kb no kf np kj nq kn nr ns nt nu bi translated">扁平化大大增加了表格的大小</li><li id="1932" class="nm nn it js b jt nv jx nw kb nx kf ny kj nz kn nr ns nt nu bi translated">子查询聚集数组</li></ul><p id="78b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着，如果你能避免扁平化，那么尽一切办法避免它！</p><h2 id="6c43" class="my lb it bd lc mz na dn lg nb nc dp lk kb nd ne lo kf nf ng ls kj nh ni lw nj bi translated">子查询未嵌套数组</h2><p id="e6a7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果要聚合数组，应该使用子查询。只需将您的查询括在括号中并选择<code class="fe mt mu mv mf b">FROM UNNEST()</code>:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="5830" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 'spaghetti napoli' AS meal, ['spaghetti', 'tomatoes'] AS ingredient<br/>  UNION ALL<br/>    SELECT 'soljanka', ['pickles', 'lecsó']<br/>  )<br/>  <br/>SELECT <br/>  meal,<br/>  (SELECT COUNT(*) FROM UNNEST(ingredient)) AS numIngr,<br/>  (SELECT STRING_AGG(i, '; ' ORDER BY i) FROM UNNEST(ingredient) AS i) AS listIngr,<br/>  (SELECT i FROM UNNEST(ingredient) i ORDER BY LENGTH(i) DESC LIMIT 1) AS longestIngr<br/>FROM t1 </span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/00fc80ca6c04a23e8368d99311545296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blXRXrfukiOaliyBv3NQBQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Go ahead and add your own sub-query! (screenshot by author)</figcaption></figure><p id="5b18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像嵌套在 for 循环中的 for 循环一样，子查询在每行执行<strong class="js iu">。您可以使用 SQL 提供的大多数东西。无论是排序、分组、开窗还是甚至与当前行中的其他数组相结合。</strong></p><p id="dcbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您甚至可以通过将子查询输出反馈给函数<code class="fe mt mu mv mf b">ARRAY()</code>来准备数据和创建自己的数组。如果您想用多列的结构填充它，只需<code class="fe mt mu mv mf b">SELECT AS STRUCT</code>。</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="0624" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 'spaghetti napoli' AS meal, ['spaghetti', 'tomatoes'] AS ingredient<br/>  UNION ALL<br/>    SELECT 'soljanka', ['pickles', 'lecsó']<br/>  )<br/>  <br/>SELECT <br/>  meal,<br/>  ARRAY(<br/>    SELECT AS STRUCT <br/>      i, <br/>      substr(upper(i),1,3) as ui, <br/>      length(i) as len <br/>    FROM UNNEST(ingredient) i<br/>  ) myIngred<br/>FROM t1 </span></pre><p id="74eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 BigQuery 中试试吧！添加您自己的子字段！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/c245b94ed5abd45c2d62c56eb80ab196.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*HcZWvP53KEE6f_5wQeg8gQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Write your own sub-tables! (screenshot by author)</figcaption></figure><p id="0333" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">子查询也非常适合快速查看非常大的表。在 Google Analytics 数据上尝试这个查询——它只显示特定事件的选定字段。</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="b4fa" class="mj lb it mf b be mk ml l mm mn">SELECT <br/>  event_name,<br/>  -- Create an array with selected columns only (literally)<br/>  array(<br/>    select as struct item_id, item_name, item_category, item_list_index, promotion_name <br/>    from unnest(items) <br/>    order by item_list_index<br/>  ) as items<br/><br/>FROM `bigquery-public-data.ga4_obfuscated_sample_ecommerce.events_20210131` <br/>WHERE<br/>  ARRAY_LENGTH(items)&gt;1<br/>  AND event_name='view_item'<br/>LIMIT 1000</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1fb7cedcecf87442def888527676db33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b9ggpYNvAY6jiDv4.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Better exploration with less sub-columns (screenshot by author)</figcaption></figure><p id="b9f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我提到过你可以在<code class="fe mt mu mv mf b">WHERE</code>子句中运行子查询吗？不要混淆哪个<code class="fe mt mu mv mf b">WHERE</code>适用于整个桌子，哪个适用于<code class="fe mt mu mv mf b">UNNEST(hits)</code>。每个<code class="fe mt mu mv mf b">WHERE</code>都有它的<code class="fe mt mu mv mf b">FROM</code>！小心瞄准镜！</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="d009" class="mj lb it mf b be mk ml l mm mn">SELECT <br/>  event_name,<br/>  items<br/>FROM `bigquery-public-data.ga4_obfuscated_sample_ecommerce.events_20210131` <br/>WHERE<br/>  -- Only show events with "Charcoal" in their product name<br/>  exists(select 1 from unnest(items) where item_name like '%Charcoal%')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/71b5f7f1a4c027bb589cd9690c59c33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/0*i89g51FFyqPSlxUx.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Filter events with conditions on items (screenshot by author)</figcaption></figure><h2 id="9173" class="my lb it bd lc mz na dn lg nb nc dp lk kb nd ne lo kf nf ng ls kj nh ni lw nj bi translated">通过在非嵌套数组上使用联接来拼合表格</h2><p id="fccd" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">由于<code class="fe mt mu mv mf b">UNNEST()</code>为我们提供了表格行，我们不仅可以查询它们，还可以在<code class="fe mt mu mv mf b">JOINs</code>中使用它们！</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="5491" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 'spaghetti napoli' AS meal, ['spaghetti', 'tomatoes'] AS ingredient<br/>  UNION ALL<br/>    SELECT 'soljanka', ['pickles', 'lecsó']<br/>  )<br/>  <br/>SELECT <br/>  meal,<br/>  i<br/>FROM t1 CROSS JOIN UNNEST(ingredient) AS i </span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d8a20f9f35db74765d98a6d4ceec7766.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*hyN7q432YCpd2lQvcApd-A.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">This is called lateral joining — a separate join per row (screenshot by author)</figcaption></figure><p id="f1c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情是这样的:</p><ol class=""><li id="2918" class="nm nn it js b jt ju jx jy kb no kf np kj nq kn of ns nt nu bi translated">将数组转换成表格行</li><li id="e520" class="nm nn it js b jt nv jx nw kb nx kf ny kj nz kn of ns nt nu bi translated"><em class="nk">将它们与数组父行交叉连接</em></li></ol><p id="6b49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有效地为来自未嵌套数组的每一行重复父行。</p><p id="33b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这也意味着，从技术上讲，我们也在重复数组。因此，如果我们没有选择正确的列，整个事情看起来会有点混乱。试着用<code class="fe mt mu mv mf b">*</code>替换<code class="fe mt mu mv mf b">meal, i</code>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/fa639f0d7b6020162c76c0efdba9718b.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*NSyWiIVGUmw5I0RqTYbyZQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Not so flat anymore … (screenshot by author)</figcaption></figure><p id="e530" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对“扁平化”表格有更深的了解，你可以充分利用这个事实。例如，在这个查询中，我们使用展平的子行的信息在该行所在的数组中进行查找！</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="a076" class="mj lb it mf b be mk ml l mm mn">SELECT <br/>  event_name,<br/>  itm.item_name,<br/>  -- Count Google items within the duplicated items array!<br/>  (select COUNT(1) from unnest(items) where item_name like '%Google%') anzahl_Google_items_im_elternevent<br/>-- Cross Join with the items array!<br/>FROM `bigquery-public-data.ga4_obfuscated_sample_ecommerce.events_20210131` t, t.items as itm<br/>WHERE<br/>  -- Only show items whose event-products have "Charcoal" in their product name<br/>  exists(select 1 from unnest(items) where item_name like '%Charcoal%')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/244c1a00177bdaab1d8d86b26c61ce0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/0*4r04F6-0-2U995AE.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Items that are “adjacent” to charcoal items (screenshot by author)</figcaption></figure><p id="8384" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在关系表中，这相当于连接两个表 t1 和 t2，但仍然编写子查询来检查 t2 中的某些内容。</p><h1 id="62bb" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用非嵌套数组的高效查询</h1><p id="01ee" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们回顾一下:</p><ul class=""><li id="1c0a" class="nm nn it js b jt ju jx jy kb no kf np kj nq kn nr ns nt nu bi translated">子查询有利于集合数组</li><li id="aec9" class="nm nn it js b jt nv jx nw kb nx kf ny kj nz kn nr ns nt nu bi translated">交叉连接有利于根据表中包含的数组的大小来加长表</li></ul><p id="cc30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是交叉连接也意味着大量的计算——所以如果你能避免它们:<em class="nk">避免它们</em>。</p><p id="4a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一般准则:</p><p id="ce16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要通过数组中的值来扩展您的表<strong class="js iu">，请使用<code class="fe mt mu mv mf b">cross join</code>。例如，您想要<code class="fe mt mu mv mf b">group by</code>我们示例表中的成分。</strong></p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="fef2" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 'spaghetti napoli' AS meal, ['spaghetti', 'tomatoes'] AS ingredient<br/>  UNION ALL<br/>    SELECT 'soljanka', ['pickles', 'lecsó', 'tomatoes']<br/>  )<br/>  <br/>SELECT <br/>  i, count(*) qty<br/>FROM t1 CROSS JOIN UNNEST(ingredient) AS i <br/>GROUP BY 1</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/93b1ff4b50e1b7f1699bce2d2cbf644c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*KHjKfXNL7kytobryEFuFIQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Group by ingredient from the array — no way around cross joining (screenshot by author)</figcaption></figure><p id="6768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您只需要来自数组的<strong class="js iu">聚合值</strong>，使用<strong class="js iu">子查询</strong>。当然，您也可以在聚合中使用它们:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="dbfe" class="mj lb it mf b be mk ml l mm mn">WITH t1 AS (<br/>    SELECT 'spaghetti napoli' AS meal, ['spaghetti', 'tomatoes'] AS ingredient<br/>  UNION ALL<br/>    SELECT 'soljanka', ['pickles', 'lecsó', 'tomatoes']<br/>  )<br/>  <br/>SELECT <br/>  -- sum the length-sums over all meals<br/>  SUM(<br/>    -- sum lengths of all ingredients in this meal/array<br/>    (SELECT SUM(LENGTH(i)) FROM UNNEST(ingredient) AS i)<br/>  ) AS sumLenIngred<br/>FROM t1</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/7a814f0815d8d2981fb0c18cae9d4fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*Dt0eGxeKa4uk6nX5ieutMw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Aggregations all the way down (screenshot by author)</figcaption></figure><p id="5247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着您应该<strong class="js iu">避免这个版本的查询</strong>以节省金钱、资源和时间:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="2556" class="mj lb it mf b be mk ml l mm mn">SELECT <br/>  SUM(length(i)) AS sumLenIngred<br/>FROM t1 cross join unnest(ingredient) i<br/>-- Please don't do this</span></pre><p id="abf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道它比较短——但只供你阅读。特别是对于 BigQuery，这个版本是对结果的<strong class="js iu">更长的方式</strong> <em class="nk"> </em>，因为它必须先<em class="nk">扩展</em>表，然后才聚合它。而在子查询版本中，它只是聚合而没有额外的<code class="fe mt mu mv mf b">cross join</code>步骤。</p><p id="1553" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这对您有所帮助，并让您开始使用嵌套数据中的 SQL！让我知道，如果你有问题或需要更多的阐述！</p><p id="55a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编辑于 2023 年 2 月。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="f839" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">阅读如何主动创建嵌套数据 BigQuery 中数据清理和数据准备所需的技能:</p><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/bigquery-creating-nested-data-with-sql-727b761f1755"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">BigQuery:使用 SQL 创建嵌套数据</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在 BigQuery 中对嵌套数据使用 SQL 是非常高效的。但是，如果您的数据出现在平面表中，比如…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ky ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/@martin.weitzmann/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">通过我的推荐链接加入 Medium-Martin Weitzmann</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">阅读马丁·威茨曼(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph ky ot"/></div></div></a></div></div></div>    
</body>
</html>