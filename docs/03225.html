<html>
<head>
<title>Conv net — Image Classification Tensorflow Keras Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Conv 网络-影像分类张量流 Keras 示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-image-classification-kaggle-competition-aerial-cactus-identification-3f720aa9e51c?source=collection_archive---------12-----------------------#2019-05-23">https://towardsdatascience.com/machine-learning-image-classification-kaggle-competition-aerial-cactus-identification-3f720aa9e51c?source=collection_archive---------12-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/80988c6a644dced69291f997a56d499d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gupk3TStAP-jTKec"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@davidsola?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Sola</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="ec5d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kaggle 是一家公司，其商业模式是让来自世界各地的数据科学家竞争，为给定的问题建立最佳性能模型。换句话说，为了收费，Kaggle 为希望使用众包来解决数据问题的企业举办比赛。</p><p id="70cd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Kaggle 比赛中，你会得到一套训练装备和一套测试装备。提供了测试集的功能，但隐藏了标签。目标是训练训练集，并使用它来预测测试集的目标标签。预测结果存储在<em class="le">提交文件</em>中，并上传到 Kaggle 进行评估。参赛者可以看到他们的模型如何与其他竞争者相抗衡，并相应地调整他们的模型。当比赛结束时，第三套，其特征和标签的参赛者从来没有接触过，被用来确定赢家。通常情况下，这将惩罚那些模型倾向于过度拟合(即高方差)的团队。</p><p id="c61c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个著名的例子，网飞提供了 100 万美元的奖金，但最终获胜的模型对他们来说太复杂了，无法投入生产。除此之外，Kaggle 的竞赛已经产生了一些好的结果。例如，保险公司好事达(Allstate)发布了一项挑战，在给定驾驶员属性的情况下，该模型近似于车祸的概率。202 名竞争者最终将好事达的模式提高了 271%。</p><p id="2194" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在接下来的文章中，我们将通过一个 kaggle 竞赛来确定一个给定的图像是否包含一个<strong class="ki jk"> <em class="le">仙人掌。</em> </strong>比赛可以在这里找到<a class="ae jg" href="https://www.kaggle.com/c/aerial-cactus-identification" rel="noopener ugc nofollow" target="_blank"><strong class="ki jk"/></a>。</p><h1 id="7a78" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">密码</h1><p id="494b" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在机器学习中，每当你在处理图像时，你应该自动思考卷积神经网络。幸运的是，Keras，一个运行在 Tensorflow 之上的高级 API，抽象出了构建神经网络的大量复杂性。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f28c" class="mr lg jj mn b gy ms mt l mu mv">import cv2<br/>import os<br/>import pandas as pd<br/>import numpy as np<br/>from matplotlib import pyplot as plt<br/>from keras.models import Sequential<br/>from keras.layers import Flatten, Conv2D, MaxPool2D, Activation, Dense, Dropout<br/>from keras.optimizers import Adam<br/>from keras.preprocessing.image import ImageDataGenerator</span></pre><p id="4d46" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想继续，继续从<a class="ae jg" href="https://www.kaggle.com/c/aerial-cactus-identification" rel="noopener ugc nofollow" target="_blank"> <strong class="ki jk"> Kaggle </strong> </a>下载训练和测试集，并将它们复制/解压缩到你的工作目录中。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="cc5d" class="mr lg jj mn b gy ms mt l mu mv">train_directory = 'train'<br/>test_directory = 'test'</span></pre><p id="1d6a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们得到一个文件，其中包含每个图像的 id，以及它是否由仙人掌组成。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3610" class="mr lg jj mn b gy ms mt l mu mv">df = pd.read_csv('train.csv')<br/>df.head()</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/93152082fe25cde29dc16a5c8f3233b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*ij6oCoaOlZ2Bbig7hv63Pg.png"/></div></figure><p id="1844" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看我们在做什么。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b9d0" class="mr lg jj mn b gy ms mt l mu mv">img = cv2.imread('train/0004be2cfeaba1c0361d39e2b000257b.jpg')<br/>plt.imshow(img)</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a76474a2ddbbfe512ca27f7701569bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*wV_SR9_JYJBw1RbkpL_j5Q.png"/></div></figure><p id="8a7b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个图像的高度和宽度分别为 32 像素和 32 像素。第三维度是指色彩。值 1 意味着它是灰度图像，其中每个像素的亮度范围从 0 到 255。值为 3 意味着它是一个 RGB 图像。在 RGB 图像中，每个像素都有红色、绿色和蓝色属性，每个属性的范围从 0 到 255。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d202" class="mr lg jj mn b gy ms mt l mu mv">img.shape</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8d4dbd65bc48efb133f25d12a0fc798e.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*cr4mTgGkxjD590q9gpNKnA.png"/></div></figure><p id="1cd6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Keras ImageDataGenerator 对象可用于应用数据扩充。执行数据扩充是正则化的一种形式，使我们的模型能够更好地泛化。在训练阶段，根据提供给 ImageDataGenerator 的参数随机调整每批新数据。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="be7a" class="mr lg jj mn b gy ms mt l mu mv">train_datagen = ImageDataGenerator(<br/>    rescale=1./255,<br/>    validation_split=0.15,<br/>    shear_range=0.2,<br/>    zoom_range=0.2,<br/>    horizontal_flip=True<br/>)</span></pre><p id="caaa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们仔细分析一下这些论点的含义。</p><ul class=""><li id="ad2a" class="mz na jj ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><strong class="ki jk">重新缩放</strong>:重新缩放像素，使其亮度范围从 0 到 1</li><li id="f06a" class="mz na jj ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki jk"> validation_split </strong>:为验证而留出的图像部分</li><li id="833d" class="mz na jj ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki jk"> shear_range </strong>:在固定方向随机移动每个点</li><li id="8850" class="mz na jj ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki jk"> zoom_range </strong>:随机放大图片内部。如果你传递一个浮点数，那么<code class="fe nn no np mn b">[lower, upper] = [1-zoom_range, 1+zoom_range]</code></li><li id="8317" class="mz na jj ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki jk">horizontal _ flip</strong>:随机水平翻转图像</li></ul><p id="3cf1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常情况下，您将要处理的图像要么放在具有各自类名的文件夹中，要么放在 CSV 或 JSON 文件中的一个文件夹中，该文件将每个图像映射到其标签。例如，在第一个场景中，所有包含仙人掌的图像都放在名为<strong class="ki jk"> <em class="le"> cactus </em> </strong>的目录中，所有不包含仙人掌的图像都放在名为<strong class="ki jk"> <em class="le"> no_cactus </em> </strong>的单独目录中。在这种情况下，我们会在图像旁边看到一个 CSV。我们可以使用<code class="fe nn no np mn b">flow_from_dataframe</code>方法将每个图像与其标签关联起来。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="edb8" class="mr lg jj mn b gy ms mt l mu mv">df['has_cactus'] = df['has_cactus'].astype(str)</span><span id="103b" class="mr lg jj mn b gy nq mt l mu mv">train_generator = train_datagen.flow_from_dataframe(<br/>    df,<br/>    directory = train_directory,<br/>    subset = 'training',<br/>    x_col = 'id',<br/>    y_col = 'has_cactus',<br/>    target_size = (32,32),<br/>    class_mode = 'binary'<br/>)<br/>val_generator = train_datagen.flow_from_dataframe(<br/>    df,<br/>    directory = train_directory,<br/>    subset = 'validation',<br/>    x_col = 'id',<br/>    y_col = 'has_cactus',<br/>    target_size = (32,32),<br/>    class_mode = 'binary'<br/>)</span></pre><p id="f401" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们可以着手构建我们的模型。我们网络的最后一层只有一个神经元，因为我们正在执行二元分类。在隐藏层中使用卷积和最大池来尝试和学习底层模式(例如，仙人掌看起来像什么)。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fb11" class="mr lg jj mn b gy ms mt l mu mv">model = Sequential()</span><span id="0692" class="mr lg jj mn b gy nq mt l mu mv">model.add(Conv2D(32, (3,3) ,activation = 'relu', input_shape = (32,32,3)))<br/>model.add(Conv2D(32, (3,3), activation = 'relu'))<br/>model.add(MaxPool2D(2,2))<br/>model.add(Conv2D(64, (3,3), activation='relu'))<br/>model.add(Conv2D(64, (3,3), activation='relu'))<br/>model.add(MaxPool2D(2,2))<br/>model.add(Conv2D(128, (3,3), activation='relu'))<br/>model.add(MaxPool2D(2,2))</span><span id="7d78" class="mr lg jj mn b gy nq mt l mu mv">model.add(Flatten())<br/>model.add(Dense(512, activation = 'relu'))<br/>model.add(Dropout(0.2))<br/>model.add(Dense(1, activation = 'sigmoid'))</span></pre><p id="fd65" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe nn no np mn b">binary_crossentropy</code>作为我们的损失函数，因为它是一个二进制分类问题，我们基于准确度来测量我们的模型的性能，并且我们使用<code class="fe nn no np mn b">Adam</code>来最小化损失函数。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="289b" class="mr lg jj mn b gy ms mt l mu mv">model.compile(<br/>    loss = 'binary_crossentropy',<br/>    optimizer = Adam(), <br/>    metrics = ['accuracy']<br/>)</span></pre><p id="434d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在机器学习的背景下，每个训练步骤我们都会计算梯度。如果我们使用小批量梯度下降，那么在一个步骤中，<strong class="ki jk"> <em class="le"> x </em> </strong>个例子被处理，其中<strong class="ki jk"> <em class="le"> x </em> </strong>等于批量大小。例如，如果您有 2，000 个图像，并且批次大小为 10，则一个时期由 2，000 个图像/ (10 个图像/步骤)= 200 个步骤组成。</p><p id="dc27" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，我们会将批量大小作为参数传递给<strong class="ki jk"> <em class="le"> fit </em> </strong>函数。然而，由于 Keras 数据发生器意味着无限循环，Keras 无法确定一个时期何时开始，另一个时期何时开始。因此，我们使用<code class="fe nn no np mn b">steps_per_epoch</code>和<code class="fe nn no np mn b">validation_steps</code>，它们简单地等于<code class="fe nn no np mn b">ceil(num_samples / batch_size)</code>。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="79a5" class="mr lg jj mn b gy ms mt l mu mv">history = model.fit_generator(<br/>    train_generator,<br/>    steps_per_epoch = 2000,<br/>    epochs = 10,<br/>    validation_data = val_generator,<br/>    validation_steps = 64<br/>)</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/eaf1f29f6aa36258d54a0c4553b6858f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6stEQ0t1JPYV4hrANAJ02A.png"/></div></div></figure><p id="047f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们加载测试样本，确保标准化数据，使每个像素的亮度范围从 0 到 1。然后，我们使用我们的模型来预测图像是否包含仙人掌。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1e1b" class="mr lg jj mn b gy ms mt l mu mv">ids = []<br/>X_test = []</span><span id="0b12" class="mr lg jj mn b gy nq mt l mu mv">for image in os.listdir(test_directory):<br/>    ids.append(image.split('.')[0])<br/>    path = os.path.join(test_directory, image)<br/>    X_test.append(cv2.imread(path))<br/>    <br/>X_test = np.array(X_test)<br/>X_test = X_test.astype('float32') / 255</span><span id="b707" class="mr lg jj mn b gy nq mt l mu mv"><br/>predictions = model.predict(X_test)</span></pre><p id="aeae" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们创建提交文件。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7b48" class="mr lg jj mn b gy ms mt l mu mv">submission = pd.read_csv('sample_submission.csv')<br/>submission['has_cactus'] = predictions<br/>submission['id'] = ids</span><span id="ead1" class="mr lg jj mn b gy nq mt l mu mv">submission.head(10)</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/488659d1f9748893292ccba6342b6d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*thfomUEm4CZ0SzBSzLuv6Q.png"/></div></figure><p id="1f91" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<strong class="ki jk"> <em class="le"> index </em> </strong>设置为 false，否则，它将为每一行添加一个索引作为第一列。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="235d" class="mr lg jj mn b gy ms mt l mu mv">submission.to_csv('submission.csv', index = False)</span></pre></div></div>    
</body>
</html>