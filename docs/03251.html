<html>
<head>
<title>Neural Networks Intuitions: 4. Connectionist Temporal Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络直觉:4。联结主义时间分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-networks-intuitions-4-connectionist-temporal-classification-9bd042bdcb3a?source=collection_archive---------17-----------------------#2019-05-24">https://towardsdatascience.com/neural-networks-intuitions-4-connectionist-temporal-classification-9bd042bdcb3a?source=collection_archive---------17-----------------------#2019-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="93f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乡亲们！</p><p id="9998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我要讲一个我花了很长时间(真的很长时间)才理解的话题，包括使用的动机和作用- <em class="kl">联结主义时间分类(CTC) </em>。</p><p id="f836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在讲<em class="kl"> CTC </em>之前，我们先来了解一下什么是序对序模型:-)</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="76a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">序列对序列模型:</em> </strong>这些是神经网络，它们接受任何序列——字符、单词、图像像素，并给出输出序列，该输出序列可以与输入序列在同一域或不同域。</p><p id="9c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">序列到序列模型的几个例子:</p><ol class=""><li id="a8b1" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><strong class="jp ir"> <em class="kl">语言翻译问题</em> </strong> —其中输入是一种语言的单词序列(一个句子)，输出是另一种语言的单词序列。</li><li id="f95d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><strong class="jp ir"/></li><li id="619f" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><strong class="jp ir"> <em class="kl">语音转文本问题— </em> </strong>其中输入是音频序列，输出是音素序列。</li></ol><p id="6981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">递归神经网络</em>通常用于此类<em class="kl">序列到序列</em>问题，因为网络不仅要考虑当前输入，还要考虑之前和之后的输入，以便进行预测。</p><blockquote class="lh"><p id="23dd" class="li lj iq bd lk ll lm ln lo lp lq kk dk translated">那么，序列到序列模型与连接主义时间分类(CTC)有什么关系呢？嗯，CTC 是一种算法，用于解决训练 seq-2-seq 模型时面临的一个关键问题，即当输入和输出序列的长度不匹配时的<strong class="ak">。</strong></p></blockquote><p id="bdf2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我深入一个我以前处理过的问题来揭开 CTC 的细节:-)</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="2038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">单词识别</em> : </strong>问题是预测一幅图像中存在的单词。解决这一问题的一种方法是将其视为序列间问题，并使用卷积和递归神经网络的混合架构。CRNN 的架构如下:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/3727336f7e6e5790a0efc18f08ea8f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*Uof8K-rRMKJTCtAtO1LypQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">An End-to-End Trainable Neural Network for Image-based Sequence Recognition and Its Application to Scene Text Recognition - Baoguang Shi et al.</figcaption></figure><blockquote class="lh"><p id="fd24" class="li lj iq bd lk ll mi mj mk ml mm kk dk translated">这里，输入序列是卷积特征图，输出将是字符序列。</p></blockquote><p id="48fc" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为了更好地理解到底发生了什么，让我来解释一下流程:</p><ol class=""><li id="d750" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">Conv 网接受输入单词图像，比如大小为 WxHx3，并产生卷积特征量，比如大小为 W/2×H/2×D，其中 D 是特征量的深度。</li><li id="479e" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">现在，大小为 1 x H/2 x D 的每一列都作为输入(注意，有 W/2 个这样的列)提供给 RNN，后者又从词汇表集中产生一个字符作为输出。</li><li id="4152" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">因此，CRNN 试图预测出现在特征图的每一列中的字符。请注意，一个列可能包含也可能不包含字符，这就是为什么多使用了一个输出标签—空白'-'(检查上图的输出)。</li></ol><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/1b32c453c0e2180f9a65bdf10f4de069.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*o9QGIW0pypQXyjnBROpGzg.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Baoguang Shi et al.</figcaption></figure><blockquote class="mo mp mq"><p id="ae46" class="jn jo kl jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">有人可能会问，在图像的情况下，时间依赖性是什么。因为特征图是分开的，并且对每一列都进行预测，所以一个完整的字符不太可能落在一列中。因此，字符的模式学习不仅依赖于当前列，还依赖于它之前和之后的列。</p></blockquote><p id="ea2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下 RNN 的输出，以便搞清楚。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7e209a34b7a0b81f37d53be869b83977.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*0kKuBBwTv8y3GkcuBNhMRQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">1. input image</figcaption></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bd40fdeced0e5abad22d16240e089292.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*Hlb7xrkn6tOfSqfFTM58xg.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">2. predicted sequence from RNN</figcaption></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/a109b8fb5ba851d51e203d472ece192e.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/format:webp/1*JLOzuou2dGcuziXqbXIwMw.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">3. decoded output</figcaption></figure><p id="8e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，<strong class="jp ir">解码输出(3)是通过折叠重复字符并从来自 RNN 的预测序列(2)中移除空白字符(如果有的话)而形成的。</strong></p><p id="876c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了清楚起见，让我先定义一些东西:</p><p id="aad7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a.<strong class="jp ir"> <em class="kl">输入 _ 序列</em> </strong>:长度为<strong class="jp ir"> W/2 </strong>的<strong class="jp ir"> <em class="kl">输入</em> </strong>序列，反馈给 RNN。</p><p id="d87f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b.<strong class="jp ir"> <em class="kl">预测 _ 序列</em></strong>:RNN 输出的<strong class="jp ir"> <em class="kl">预测输出</em> </strong>长度为<strong class="jp ir"> W/2 </strong>的序列。</p><p id="74ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">c.<strong class="jp ir"> <em class="kl">目标 _ 序列:</em></strong><strong class="jp ir"><em class="kl">地面实况输出</em> </strong>序列长度<strong class="jp ir"> W/2。</strong></p><p id="19d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">d.<em class="kl"> </em> <strong class="jp ir"> <em class="kl">解码 _ 序列:</em></strong><strong class="jp ir"><em class="kl">解码输出</em> </strong>序列的长度<strong class="jp ir"> ≤ W/2。</strong></p><p id="9d3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而训练这样一个网络，我们有的只是<strong class="jp ir"> &lt; 1。输入图像，请按 3。解码输出&gt; </strong>对作为训练实例。但是神经网络给出<em class="kl">预测序列</em>作为输出，其长度不等于解码输出的长度。</p><blockquote class="lh"><p id="984a" class="li lj iq bd lk ll lm ln lo lp lq kk dk translated">在计算损失时，长度为 W/2 的预测序列不能与长度≤ W/2 的解码序列进行比较。</p></blockquote><ul class=""><li id="e8c9" class="kt ku iq jp b jq lr ju ls jy mx kc my kg mz kk na kz la lb bi translated">注意:我们假设输入和预测序列是同步的。即顺序将是相同的。</li></ul></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="0c41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">问题:</em> </strong>所以为了训练这个网，我们需要知道<strong class="jp ir"><em class="kl">target _ sequence</em></strong>是什么。但是我们如何得到那个<em class="kl">目标序列</em>？我们当然不能注释长度为 W/2 的序列中的每个时间步长(那是不可能的！).</p><p id="f0a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">解法:</em> </strong>使用合理的启发式猜测<em class="kl">目标 _ 序列</em>。是的，你没看错。对<em class="kl">目标 _ 序列</em>进行初步猜测。考虑上面的输入图像，该输入的解码输出是什么？</p><blockquote class="mo mp mq"><p id="8ca7" class="jn jo kl jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">解码输出→ <strong class="jp ir">“状态”</strong></p></blockquote><p id="66c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设<em class="kl">目标序列/预测序列</em>(即 RNN 的输出)的长度为 14。现在我们来猜猜<em class="kl"> target_sequence </em>是<strong class="jp ir">【SSSTTAAAATTEEE】</strong>(后面再看<em class="kl">空白</em>字符)。</p><blockquote class="lh"><p id="e16d" class="li lj iq bd lk ll lm ln lo lp lq kk dk translated">假设我们有一个 target_sequence，我们可以在第一步使用该序列训练网络，然后使用网络的预测作为新的 target_sequence(用于下一步),并在训练期间反复迭代它——迭代和估计。</p></blockquote><p id="b648" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">但是这里有一个关键问题。我们如何确保网络预测的<em class="kl">目标序列</em>在解码时给出我们想要的输出，在我们的例子中是<strong class="jp ir">状态</strong>？</p><p id="c27f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果 RNN 输出“<strong class="jp ir"> RRRRAAAEEELLLL </strong>”会怎样？我们不能将该输出序列用作训练过程下一步的新<em class="kl">目标序列</em>。因此，我们需要对 RNN 预测的序列施加一些限制。</p><p id="855b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">约束 1: </em> </strong>不考虑整个词汇(字母 A 到 Z)的预测，只考虑作为解码输出一部分的字母。</p><p id="a498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，字母 T，A，E 是解码输出“状态”的一部分。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/05cb5f9c032c4b134519b3bfaa06b394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2O-eLr8_mJhmnhH1exHpA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Considering only target alphabets. Most probable character for a given timestep is highlighted in orange. For example sake, I have highlighted only 5 steps(decoded output for this eg. is SATAE)</figcaption></figure><p id="07eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，这确保了我们的网络产生一个<em class="kl">预测序列</em>，它只包含解码输出中的字母。但是对字母输出的顺序没有限制。</p><p id="dee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如:RNN 输出“<strong class="jp ir"> SSAAAATTTAAEEE </strong>”，它仍然只包含目标字母，但是当解码时产生<em class="kl"> SATAE </em>而不是<em class="kl">状态。</em></p><p id="de3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">约束 2: </em> </strong>为了确保网络输出一个序列，该序列在解码时给出我们想要的折叠输出，让我们施加以下约束:</p><p id="5fd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不仅要考虑字母 S、T、A、E，还要按照各个字母在解码输出中出现的顺序对它们进行排序(即使这些字母必须重复)。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/eb5fa2652bed2c0041963275b592d3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJ5InRn7-FiMN0VR9jqaRw.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Use Viterbi algorithm(dynamic programming) to compute the best path from a set of all possible paths starting from S ending with E.</figcaption></figure><p id="6153" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，修复第一个输出应该始终是左上角的符号，最后一个输出应该始终是右下角的符号，并且顺序应该始终严格地从上到下，即没有向上移动。<em class="kl">从左上符号到右下符号的每条路径都被认为是有效的序列/对齐，因为它总是解码为有效的“解码序列”。</em></p><p id="cd0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将每个时间步长的每个输出符号可视化为图中的一个节点，边用箭头表示。每个节点的分数是它在该时间步来自网络的概率，边分数是 1。序列(或路径)的分数是包含在其中的所有节点的概率的乘积。</p><p id="d60e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">子问题:</em> </strong> <em class="kl">给定一组这样的有效序列，找出最可能的序列？</em></p><p id="345d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">解</em> : </strong> <em class="kl">这个问题是用维特比算法(动态规划)解决的。</em></p><blockquote class="lh"><p id="7dba" class="li lj iq bd lk ll lm ln lo lp lq kk dk translated">一旦我们确保预测的序列是有效的序列(或比对)，我们可以使用<strong class="ak"> <em class="ng">迭代和估计</em> </strong>方法来训练网络。也可以使用在类似任务上受过训练的预训练的 RNN，以使训练过程更加稳健。</p></blockquote><p id="aa9a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">但所有这些都严重依赖于如何猜测初始目标序列以及如何在训练期间计算<em class="kl"> target_sequence </em>(使用维特比算法的最大可能序列)。因此这种方法不是最佳的。</p><p id="23b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不是选择最可能的序列，而是对所有可能的有效序列使用一个期望值。这同样可以使用动态编程来计算，并且所使用的算法被称为<strong class="jp ir"><em class="kl">CTC-前向-后向算法</em> </strong>。我不打算进入向前-向后/维特比算法的细节，因为它对我来说仍然是一个灰色地带。</p><p id="3e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，考虑输出有重复字符的情况。设输出字为<strong class="jp ir"> <em class="kl">【字母】</em></strong><em class="kl">预测 _ 序列</em>为<strong class="jp ir"><em class="kl">llleetttteerr</em>。</strong>现在，当这个<em class="kl">预测序列</em>折叠时会发生什么？</p><p id="0091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到的解码输出为<strong class="jp ir"><em class="kl">【LETER】</em></strong>，这是不可取的。</p><blockquote class="mo mp mq"><p id="84f9" class="jn jo kl jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">因此，为了考虑输出域中的重复字符，将空白字符(-)作为词汇表的一部分。基本上，当词汇表中没有符号出现在该时间步长时，神经网络输出一个空白字符。</p></blockquote><p id="e7c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，代替产生"<strong class="jp ir"><em class="kl">llleetttteerr</em>"，</strong>一个带有空白作为词汇一部分的 RNN 现在可能输出"--<strong class="jp ir"><em class="kl">L-EE-TT-T-E-R "</em></strong>，当解码时产生<strong class="jp ir"> <em class="kl">"字母"</em> </strong> <em class="kl">。</em></p><p id="be0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于包含了一个空白字符，它可能出现在<strong class="jp ir"><em class="kl">target _ sequence</em></strong>的任何地方，我们将目标字母+空白排列如下:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/dd979f32fe4163a00f30bb31ffc24aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2W0Wtw6mFEyRQHaqHRH19g.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Blanks are inserted before and after every target alphabet. Note that only few timesteps are shown in the above diagram.</figcaption></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="a43b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我来分解一下术语<strong class="jp ir"> <em class="kl">【连接主义者时态分类】</em> </strong>看看它到底是什么意思？</p><blockquote class="lh"><p id="1ec6" class="li lj iq bd lk ll lm ln lo lp lq kk dk translated">我们的解决方案现在可以标记(或预测)序列中的每个时间步长。标记未分段数据序列的任务称为时间分类，因为我们使用 RNNs 来标记未分段数据，所以它被称为连接主义时间分类[1]。</p></blockquote><p id="180a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">[1]如<em class="kl">连接主义时间分类中所述:用递归神经网络标记未分段的序列数据— Graves 等人</em></p><blockquote class="mo mp mq"><p id="b238" class="jn jo kl jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated">为了更清楚，这里未分段的数据序列是我们的解码输出，分段的数据序列将是目标序列，我们使用 RNN 来标记它。</p></blockquote><p id="bef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你们都有直觉，对于输入和输出序列长度不匹配的序列间问题，神经网络是如何训练的。</p><p id="d292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的博客文章是从这个关于 CTC 的精彩的 CMU 演讲中得到启发的:<a class="ae nh" href="https://www.youtube.com/watch?v=c86gfVGcvh4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=c86gfVGcvh4</a>。看一看吧！</p><p id="c070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯:-)</p></div></div>    
</body>
</html>