<html>
<head>
<title>Building a text classifier with NaturalLanguage framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用自然语言框架构建文本分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-text-classifier-with-naturallanguage-framework-5e4c1ce8e4e?source=collection_archive---------20-----------------------#2019-04-15">https://towardsdatascience.com/building-a-text-classifier-with-naturallanguage-framework-5e4c1ce8e4e?source=collection_archive---------20-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6984d4b5d685bca295e8ede913a199fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3huaAEmmlmObiuqIRWxK7w.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="aacf" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">了解如何为所有 Apple 平台上的应用程序构建文本分类器。</h2></div><h2 id="2da3" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">介绍</h2><p id="45bd" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">你可能知道或者至少听说过像 Siri、Cortana 和 Alexa 这样的虚拟助手。也许你和某个公司的聊天机器人聊过天？如果你不是像我一样以英语为母语，你可能会经常使用谷歌翻译来帮助你阅读像这样的开发材料。</p><p id="4d1c" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">这些都是<strong class="lr jf">自然语言处理</strong>的应用。NLP 有很多定义，但本质上，它指的是任何一种由计算机执行的自然语言操作，通常使用<strong class="lr jf">机器学习</strong>的技术。我所说的自然语言是指人类交流中使用的任何一种非结构化或无限制的语言。</p><p id="db50" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">去年，苹果发布了<strong class="lr jf">natural language Framework</strong>(NLF ),为那些愿意让他们的应用程序更具 NLP 智能的开发者提供更简单的体验。该框架提供了一个 API，它隐藏了文本处理任务中通常涉及的大部分复杂性。</p><p id="a484" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">NLF 是我在第 21 届佛罗里达会议上演讲的主题，在那里我详细介绍了 NLP 用例、其通用管道以及 NLF 的使用。根据这些建议，我决定写这篇博文来讨论这次演讲的主要部分。因此，我将介绍 NLP 的一些基本概念，并解释如何构建一个文本分类器。</p><h2 id="2706" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">自然语言框架</h2><p id="7751" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">NLF 可以在所有苹果平台上使用，它是从 iOS 11 开始出现在<code class="fe mo mp mq mr b">Foundation</code>中的实用程序类<code class="fe mo mp mq mr b">NSLinguisticTagger</code>的演变。像它的前身一样，NLF 提供了以下内置功能:</p><ul class=""><li id="97aa" class="ms mt je lr b ls mi lv mj lc mu lg mv lk mw mh mx my mz na bi translated"><strong class="lr jf">语言识别</strong>:该框架承诺识别近 60 种不同的语言。</li><li id="9c5c" class="ms mt je lr b ls nb lv nc lc nd lg ne lk nf mh mx my mz na bi translated"><strong class="lr jf">标记化</strong>:可以将文本分解成代表基本意义单位(即单词)的字符序列。NLF 处理像日语这样的语言，这个任务不仅仅是用空格分割句子。</li><li id="f9b4" class="ms mt je lr b ls nb lv nc lc nd lg ne lk nf mh mx my mz na bi translated"><strong class="lr jf">词性(PoS)标注</strong>:框架能够用来自某个方案的标签来标注每个标记。例如，我们可以根据词汇类别(如名词、动词、形容词等)对标记进行分类。</li><li id="5e5a" class="ms mt je lr b ls nb lv nc lc nd lg ne lk nf mh mx my mz na bi translated"><strong class="lr jf">词汇化</strong>:这其实是一种特殊的词性标注方案。它用于减少单词的屈折形式(例如，将复数形式变为单数)。</li><li id="9e8d" class="ms mt je lr b ls nb lv nc lc nd lg ne lk nf mh mx my mz na bi translated"><strong class="lr jf">命名实体识别(NER) </strong>:这是另一个词性标注方案。它用于识别感兴趣的实体，如位置、人员、组织、日期等。</li></ul><p id="17f9" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">这些内置函数允许我们执行许多很酷的文本处理任务，而无需任何进一步的机器学习算法。例如，我们可以通过一个基本的词汇化调整来改进文本搜索。</p><p id="21fb" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">在这篇博客文章中，我不会详述语言识别和标记化(但是你可以在这里找到一篇关于它们的很棒的文章<a class="ae mn" href="https://www.swiftbysundell.com/daily-wwdc/a-first-look-at-the-natural-language-framework" rel="noopener ugc nofollow" target="_blank"/>)。相反，我将集中讨论词性标注。</p><h2 id="a72d" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">词性标注</h2><p id="fcea" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated"><code class="fe mo mp mq mr b">NLTagger</code>是负责词性标注任务的班级。它有一个<code class="fe mo mp mq mr b">enumerateTags(in:unit:scheme:options:block:)</code>函数，用于列出给定文本中的标签，如<strong class="lr jf">清单 1 </strong>所示。<code class="fe mo mp mq mr b">block</code>参数是一个闭包，每个令牌调用一次，传递它的范围和相应的标签。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Listing 1</strong>: Using NLTagger for PoS tagging.</figcaption></figure><p id="5873" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">为了实例化一个<code class="fe mo mp mq mr b">NLTagger</code>对象，我们应该提供一个<code class="fe mo mp mq mr b">NLTagScheme</code>数组来告诉标记者需要哪组标记。<strong class="lr jf">清单 1 </strong>使用了<code class="fe mo mp mq mr b">.nameTypeOrLexicalClass</code>，因此只返回词法类和命名实体。您可以在<strong class="lr jf">输出 1 </strong>中看到结果。其他常用的方案有<code class="fe mo mp mq mr b">.lexicalClass</code>、<code class="fe mo mp mq mr b">.nameType</code>和<code class="fe mo mp mq mr b">.lemma</code>。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Output 1</strong>: Result of Listing 1.</figcaption></figure><p id="1b9f" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">unit</code>是另一个重要参数。它告诉标记者应该标记哪个文本块。除了<code class="fe mo mp mq mr b">.word</code>，我们还可以用<code class="fe mo mp mq mr b">.sentence</code>、<code class="fe mo mp mq mr b">.paragraph</code>和<code class="fe mo mp mq mr b">.document</code>。但是，对于某些方案和单元的组合，标记器可能不会返回任何结果。例如，使用<code class="fe mo mp mq mr b">.lemma</code>作为 scheme 和<code class="fe mo mp mq mr b">.sentence</code>作为 unit 是没有意义的，因为您只能在每个单词的基础上进行词汇化。</p><p id="fb7e" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">最后一个参数是<code class="fe mo mp mq mr b">option</code>。它只是告诉标记者补充信息，并不要求标记者工作。例如，我们可以用它来告诉标记者省略空格和标点符号，不要把粒子当作单独的标记。</p><h2 id="f0a2" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">定制模型</h2><p id="e49e" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">所有这些贴吧标签都很酷，但是如果我们想在文本中识别口袋妖怪的名字或者根据它们的类型对文本进行分类呢？好吧，那 NLF 默认做不到。我们需要建立一个自定义模型。</p><p id="4164" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">这可能是 NLF 最酷的部分:它可以与 CoreML 集成来构建定制的<strong class="lr jf">单词标签</strong>和<strong class="lr jf">文本分类器</strong>。这还不是全部。苹果还发布了 CreateML 框架，用于构建直接进入 NLF 的定制 CoreML 模型。机器学习开始了。</p><p id="de78" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">NLP 通常是一个<strong class="lr jf">分类问题</strong>，目标是在有限的可能性集合中为给定的输入分配一个标签。它还通常使用<strong class="lr jf">监督学习</strong>算法，其中我们提供一个包含文本及其相应标签的训练集，算法使用该训练集进行学习。我不会深入讨论这些细节，因为这超出了讨论范围(不过，你可能想要查看<a class="ae mn" href="https://machinelearningmastery.com/supervised-and-unsupervised-machine-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章</a>)。相反，让我们关注 NLF 如何通过构建一个定制的文本分类器来隐藏大部分的复杂性。</p><p id="27de" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">在下一节中，我将通过构建一个餐馆评论分类器来演示定制模型是如何工作的。目标是将输入文本标记为正面或负面评论。</p><h2 id="79c7" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">构建分类器</h2><p id="307f" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">培训工作流程如<strong class="lr jf">图 1 所示。</strong>我们将训练数据传递给 CreateML，这样它就可以使用 NLF 从这些数据中提取特征，学习模式并将这些知识保存为 CoreML 模型。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/cf209fc6aa42b4054e8fe5b2157a7310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mh_lIGxtd-1BVc0dTpohbg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="bd nr">Image 1</strong>. Model training workflow.</figcaption></figure><p id="d2bb" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated"><strong class="lr jf">清单 2 </strong>是我们将用来构建分类器的数据集的摘录。这是一个众所周知的数据集，它包含一千条评论及其相应的标签，可以是<code class="fe mo mp mq mr b">POSITIVE</code>或<code class="fe mo mp mq mr b">NEGATIVE</code>。你可以在这里找到完整的 JSON 文件<a class="ae mn" href="https://github.com/alanpaivaa/CocoaheadsFloripa21/blob/master/Training/TextClassification.playground/Pages/RestaurantReviews.xcplaygroundpage/Resources/RestaurantReviews.json" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Listing 2</strong>: Excerpt of the restaurant reviews dataset.</figcaption></figure><p id="f516" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">我们还需要一个 macOS 平台来训练模型，因为 CreateML 在其他平台上不可用。所以启动游戏并运行清单 3 中的代码。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Listing 3</strong>: Snippet for training the model.</figcaption></figure><p id="90f9" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">第一步是将数据集加载到一个<code class="fe mo mp mq mr b">MLDataTable</code>中，这是 CreateML 使用的一个表格表示。这个类实际上非常强大。您可以使用它在数据集中执行额外的预处理步骤，例如创建和删除列。</p><p id="842b" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">下一步，我们使用<code class="fe mo mp mq mr b">randomSplit(by:seed:)</code>函数将数据集随机分成训练集和测试集。该函数需要一个随机操作的种子和一个比率来确定用于训练和测试的数据集的百分比。种子可以是我们想要的任何整数。这个比例通常在 70%到 90%之间。如果你用更多的数据进行训练，就不会有足够的数据来评估模型；如果您使用较少的数据进行训练，您将无法执行良好的训练，您的大型测试集将会显示这一点。这是一个权衡，80%通常是一个好的选择。</p><p id="2ac7" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">第 3 步是我们实际构建模型的地方。为此，我们初始化<code class="fe mo mp mq mr b">MLTextClassifier</code>,传递训练集和对应于 JSON 文件的文本和标签列。请注意，这个过程可能需要很长时间，这取决于许多因素，如类的数量和训练集的大小。返回的对象是我们用来做预测的分类器。</p><p id="816d" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">下一步是评估我们的分类器的性能。我们通过将测试集传递给<code class="fe mo mp mq mr b">evaluation(on:)</code>函数来做到这一点。它对测试集中的每个文本进行预测，并记录分类器是对还是错。然后，我们使用这些记录来计算一些指标，比如清单 3 中使用的准确性，给出了正确预测的百分比。CreateML 还提供了精度、召回和混淆矩阵，用于观察各个类的性能。评估是机器学习中一个非常广泛的话题，因为我们在这里仅仅触及了表面，我强烈推荐关于这个主题的进一步阅读。</p><p id="3dad" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">评估过程是一个非常重要的步骤，因为它为如何改进模型提供了指导。例如，显示某个类的高错误率的混淆矩阵可能是一个警告，表明我们需要将该类的更多示例添加到训练集中。</p><p id="61e8" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">最后，如果模型足够令人满意，我们就直接保存它。这是第 5 步，我们将<code class="fe mo mp mq mr b">.mlmodel</code>输出到文件系统。</p><h2 id="b1f3" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">CoreML 集成</h2><p id="7ad5" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">现在我们已经有了模型文件，我们可以将它拖放到 Xcode 项目中。这一次不再有仅限 macOS 的限制，因为 CoreML 和 NLF 可以在所有苹果平台上使用。</p><p id="7826" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">Xcode 自动生成一个与<code class="fe mo mp mq mr b">.mlmodel</code>文件同名的<code class="fe mo mp mq mr b">MLModel</code>子类。因此，可以在独立模式下使用该文件，但是我们实际上对 NLF 如何与它集成感兴趣，如清单 4 所示。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Listing 4</strong>: Integrating NLF with CoreML model.</figcaption></figure><p id="aeb8" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">该代码的主要部分位于<code class="fe mo mp mq mr b">tagger</code>属性定义中，我们在前面部分创建的模型和一个定制标记方案之间建立了关联。这是必要的，这样标记者就知道何时调用我们的定制模型。</p><p id="cf44" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">注意，我们不能直接使用 CoreML 模型。我们首先需要通过传递模型的 URL 将其包装在一个<code class="fe mo mp mq mr b">NLModel</code>对象中。至于自定义标记方案，我们只需要提供一个标识符。并在标签上把我们称之为<code class="fe mo mp mq mr b">setModels(_:forTagScheme:)</code>的人联系起来。</p><p id="2f6d" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">因此，当我们传递一个自定义方案来枚举标签时，标记器知道它应该使用自定义模型。该工作流程如<strong class="lr jf">图 2 </strong>所示。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/8e797656b01c0777269aa9b651530a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZapAyKsh8ECIkb4AQXFpw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="bd nr">Image 2</strong>: Text classification workflow.</figcaption></figure><p id="a0ee" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">最后，<code class="fe mo mp mq mr b">prediction(for:)</code>使用<code class="fe mo mp mq mr b">tags(in:unit:scheme:options)</code>来获得标签和范围元组的列表。因为我们正在评估整个文本，所以我们只为<code class="fe mo mp mq mr b">unit</code>参数传递<code class="fe mo mp mq mr b">.document</code>，导致 tagger 只返回一个标签，这个标签要么是<code class="fe mo mp mq mr b">POSITIVE</code>要么是<code class="fe mo mp mq mr b">NEGATIVE</code>。</p><p id="d944" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated"><strong class="lr jf">清单 5 </strong>和<strong class="lr jf">输出 1 </strong>描述了分类器的用法和结果。请注意，它正确地标记了大多数评论，除了最后一条，它预测<code class="fe mo mp mq mr b">POSITIVE</code>甚至不是评论。由于机器学习的概率性质，这是意料之中的。为了解决这个问题，我们可以在我们的训练数据中增加非评论的例子，但是我会把这个留给读者。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Listing 5</strong>: Using the custom tagger.</figcaption></figure><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><strong class="ak">Output 1</strong>: Print logs from Listing 5.</figcaption></figure><h2 id="a2a7" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h2><p id="1059" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">在这篇博文中，我通过介绍 NaturalLanguage 框架的主要概念并展示如何构建一个定制的文本分类器，详细探讨了它。然而，还有更多需要了解的。在<a class="ae mn" href="https://github.com/alanpaivaa/CocoaheadsFloripa21" rel="noopener ugc nofollow" target="_blank">这个 Github 仓库</a>中，你可以找到所有的文本分类器代码和许多其他使用内置函数的例子，组织数据集的不同方式，以及如何构建自定义单词标签(这与我在这里介绍的非常相似)。</p><p id="4c7f" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">我希望你喜欢这个，请离开你的掌声。再见！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="5663" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">[1]伯德、克莱因和洛珀(2009 年)。<em class="oa">用 Python 进行自然语言处理:用自然语言工具包分析文本</em>。奥莱利媒体公司。</p><p id="38b1" class="pw-post-body-paragraph lp lq je lr b ls mi kf lu lv mj ki lx lc mk lz ma lg ml mc md lk mm mf mg mh im bi translated">[2]乔希特，H. (2017)。餐馆评论数据集。【在线】可在:<a class="ae mn" href="https://www.kaggle.com/hj5992/restaurantreviews/version/1" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/hj5992/restaurantreviews/version/1</a>？[2019 年 4 月 14 日]</p></div></div>    
</body>
</html>