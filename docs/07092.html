<html>
<head>
<title>Using PaaS to Accelerate Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PaaS 加速数据科学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/paas-to-accelerate-data-science-dc-os-data-science-engine-656842dd7ba8?source=collection_archive---------17-----------------------#2019-10-07">https://towardsdatascience.com/paas-to-accelerate-data-science-dc-os-data-science-engine-656842dd7ba8?source=collection_archive---------17-----------------------#2019-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">试用 DC/操作系统数据科学引擎</h2></div><p id="c04b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名专注于向市场提供新产品的全栈机器学习工程师，我经常发现自己处于数据科学、数据工程和开发运营的交叉点。因此，我一直怀着极大的兴趣关注着数据科学平台即服务(PaaS)的兴起。在这一系列帖子中，我将评估不同的平台即服务(PaaS)及其自动化数据科学运营的潜力。我将探索他们的能力，然后自动设置和执行我即将出版的书<em class="le">中的代码</em> (O'Reilly，2020 年)，为这本书的读者找到阅读这本书的最佳方式。</p><p id="8696" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的上一本书<a class="ae lf" href="https://www.amazon.com/Agile-Data-Science-2-0-Applications/dp/1491960116" rel="noopener ugc nofollow" target="_blank">敏捷数据科学 2.0 </a> (4.5 星:D)中，我为读者构建了自己的平台，使用 bash 脚本、AWS CLI、<a class="ae lf" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>、vagger 和 EC2 运行代码。虽然这使得这本书对那些运行代码有困难的初学者来说更有价值，但是维护和保持运行是非常困难的。旧软件从互联网上脱落，平台腐烂。这个项目已经出现了 85 个问题，虽然许多问题已经通过读者的贡献得到了解决，但它仍然占据了我在开源软件上花费的大量时间。这次会有所不同。</p><p id="cce2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注:本岗位代码可在</em><a class="ae lf" href="https://github.com/rjurney/paas_blog" rel="noopener ugc nofollow" target="_blank"><em class="le">github.com/rjurney/paas_blog</em></a>获得</p><h1 id="1071" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">DC/操作系统数据科学引擎</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/49dea0e9091342a615315ead6552eed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*srige4k8z6mlB0CMRA5R_A.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">DC/OS is a highly scalable PaaS</figcaption></figure><p id="4642" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我评估的第一个数据科学 PaaS 是新推出的 DC/OS 数据科学引擎。在这篇文章中，我将通过 GUI 向您介绍我对 DC/OS(注意:我过去曾使用过它)及其数据科学引擎的初步实验，然后我们将讲述如何用几行代码来自动化相同的过程。事实证明，这实际上比使用 AWS CLI 创建等效资源更简单，这给我留下了深刻的印象。我们将设置我们的环境和软件先决条件，使用 Terraform 和<a class="ae lf" href="https://docs.d2iq.com/mesosphere/dcos/1.13/installing/evaluation/aws/" rel="noopener ugc nofollow" target="_blank">通用安装程序</a>初始化 DC/操作系统集群，安装<a class="ae lf" href="https://universe.dcos.io/#/package/data-science-engine/version/latest" rel="noopener ugc nofollow" target="_blank">数据科学引擎包</a>，然后通过运行标记堆栈溢出帖子的模型来评估环境。</p><p id="f86e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些警告:我们将一步一步地介绍如何引导安装了 JupyterLab 的 DC/OS 集群，但是如果您遇到麻烦，您可以随时参考<a class="ae lf" href="https://docs.d2iq.com/mesosphere/dcos/1.13/installing/evaluation/aws/" rel="noopener ugc nofollow" target="_blank">通用安装程序文档</a>来解决 DC/OS 平台问题，或者参考<a class="ae lf" href="https://docs.d2iq.com/mesosphere/dcos/services/data-science-engine/1.0.0/quick-start/" rel="noopener ugc nofollow" target="_blank">数据科学引擎文档</a>来解决部署该服务的问题。</p><h1 id="772e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么选择 DC/操作系统数据科学引擎？</h1><p id="de1f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在任何给定的云环境中，如亚马逊网络服务(AWS)、谷歌云平台(GCP)和 Azure，为个人数据科学家工作设置一个 Jupyter 笔记本已经变得相当容易。对于创业公司和小型数据科学团队来说，这是一个很好的解决方案。没有什么需要维护的，笔记本可以保存在 Github 中以便持久化和共享。</p><p id="50ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于大企业来说，事情没有这么简单。在这种规模下，跨多个云的临时资产上的临时环境可能会造成混乱而不是秩序，因为环境和建模变得不可复制。企业跨多个云和在本地工作，具有特定的访问控制和身份验证要求，并且需要提供对内部资源的访问以获得数据、源控制、流和其他服务。</p><p id="c24d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">对于这些组织，DC/操作系统数据科学引擎提供了一个统一的系统，该系统提供 Python ML 堆栈、Spark、Tensorflow 和其他 DL 框架，包括</em><a class="ae lf" href="https://github.com/yahoo/TensorFlowOnSpark" rel="noopener ugc nofollow" target="_blank"><em class="le">TensorFlowOnSpark</em></a><em class="le">以支持分布式多节点、多 GPU 模型训练。</em>这是一个非常引人注目的设置，开箱即用，可以结束大型数据科学团队和公司的许多挫折和复杂性。</p><h1 id="ac9c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">软件和平台先决条件</h1><p id="ee2b" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">DC/操作系统通用安装程序可以在 Linux、Mac OS X 和 Windows 上运行。对于所有平台，你都需要<a class="ae lf" href="https://www.python.org/about/gettingstarted/" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae lf" href="https://pip.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> pip </a>、<a class="ae lf" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html" rel="noopener ugc nofollow" target="_blank"> AWS 命令行界面(CLI) </a>和<a class="ae lf" href="https://www.terraform.io/intro/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform </a>。如果您正在测试数据科学引擎，您可能已经安装了 Python，但是如果没有，我们将安装<a class="ae lf" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Anaconda Python </a>。</p><p id="bc4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">您还需要在运行 DC/操作系统数据科学引擎的地区授权 5 个 GPU 实例(在本文中，我们使用“us-west-2”)。让我们一步一步来。</em></p><h1 id="26c5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">安装 Anaconda Python</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/bd19aa31d0cad937f362921f57e1d59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*EUDp20vvW6WdT2vSICxYUA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Anaconda Python</figcaption></figure><p id="86c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的机器上已经安装了 Python，就没有必要安装 Anaconda Python。如果您不知道，我推荐 Anaconda Python，因为它易于安装，位于您的主目录中，并且具有优秀的 conda 包管理器。</p><p id="bfab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下载蟒蛇 Python 3。x 为您的平台<a class="ae lf" href="https://www.anaconda.com/distribution/#download-section" rel="noopener ugc nofollow" target="_blank">这里</a>，然后按照说明安装<a class="ae lf" href="https://docs.anaconda.com/anaconda/install/linux/" rel="noopener ugc nofollow" target="_blank"> Linux </a>、<a class="ae lf" href="https://docs.anaconda.com/anaconda/install/mac-os/" rel="noopener ugc nofollow" target="_blank"> Mac OS X </a>和<a class="ae lf" href="https://docs.anaconda.com/anaconda/install/windows/" rel="noopener ugc nofollow" target="_blank"> Windows </a>。</p><h1 id="0b8a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">通过安装和配置 Amazon Web Services CLI 进行 AWS 身份验证</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/e60352c3a3f47cceea3c73a0f1513fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*FWY2XGQIGl4r9ve23BdYkg.png"/></div></figure><p id="082b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为<a class="ae lf" href="https://www.terraform.io/docs/providers/aws/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform AWS 提供者</a>设置 AWS 访问有两种方式:通过<a class="ae lf" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>或通过编辑(来自 Github 项目根的路径)<em class="le">PAAs _ blog/dcos/terra form/terra form . TF</em>。</p><p id="ff7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将为 Terraform 设置要使用的 AWS 凭证。要使用 PyPI <a class="ae lf" href="https://pypi.org/project/awscli/" rel="noopener ugc nofollow" target="_blank"> awscli 包</a>:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="f670" class="mu lh it mq b gy mv mw l mx my"># Install using conda<br/>conda install -c conda-forge awscli</span><span id="4f40" class="mu lh it mq b gy mz mw l mx my"># OR…</span><span id="db4b" class="mu lh it mq b gy mz mw l mx my"># Install using pip<br/>pip install awscli --upgrade --user</span></pre><p id="6f01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在<a class="ae lf" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html" rel="noopener ugc nofollow" target="_blank">使用您的访问密钥 ID 和秘密访问密钥设置</a>您的 AWS 凭证，您可以在<a class="ae lf" href="https://console.aws.amazon.com/iam/home#/security_credentials" rel="noopener ugc nofollow" target="_blank"> IAM 控制台</a>中找到它们。您可以将区域更改为您自己的默认值。Terraform 的 AWS 模块将默认使用这些凭证。它们存放在<em class="le"> ~/中。aws/ </em>目录。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="82cc" class="mu lh it mq b gy mv mw l mx my">aws configure</span><span id="c379" class="mu lh it mq b gy mz mw l mx my">AWS Access Key ID [None]: **AKIAIOSAODNN7EXAMPLE**<br/>AWS Secret Access Key [None]: **wJalrXUtnFEMI/K7MBENG/bPxRfiCYEXAMPLEKEY**<br/>Default region name [None]: **us-west-2**<br/>Default output format [None]: **json**</span></pre><p id="4e6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在验证设置是否有效:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="e15b" class="mu lh it mq b gy mv mw l mx my">aws sts get-caller-identity</span></pre><p id="8769" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到类似这样的内容:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="82bf" class="mu lh it mq b gy mv mw l mx my">{<br/>  “UserId”: “123456789101”,<br/>  “Account”: “109876543210”,<br/>  “Arn”: “arn:aws:iam::123456789101:root”<br/>}</span></pre><h1 id="bce1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">通过编辑 terraform.tf 进行 AWS 身份验证</h1><p id="e40e" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">您可以通过编辑(从项目根目录)<em class="le">PAAs _ blog/dcos/terra form/terra form . TF</em>来显式设置 AWS 身份验证，以便在调用 AWS 提供者时包含您的凭证。只需添加您的访问密钥/秘密密钥和默认区域。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="c608" class="mu lh it mq b gy mv mw l mx my">provider “aws” {<br/>  access_key = “foo”<br/>  secret_key = “bar”<br/>  region = “us-west-2”<br/>}</span></pre><h1 id="8a16" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">安装 Terraform</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/3a543272b73eea43fba006d82988c010.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*Ll9a1pXIp9fM2hBNWh0Xyw.png"/></div></figure><blockquote class="na nb nc"><p id="d1c8" class="ki kj le kk b kl km ju kn ko kp jx kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">Terraform 使用户能够使用一种称为 Hashicorp 配置语言(HCL)的高级配置语言来定义和配置数据中心基础架构。<br/> <br/> —维基百科，Terraform(软件)</p></blockquote><p id="384c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DC/OS 通用安装程序需要安装 Terraform 11.x. Ubuntu 用户可以像这样安装 Terraform 11.x:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="63b7" class="mu lh it mq b gy mv mw l mx my">wget <a class="ae lf" href="https://releases.hashicorp.com/terraform/0.11.14/terraform_0.11.14_linux_386.zip" rel="noopener ugc nofollow" target="_blank">https://releases.hashicorp.com/terraform/0.11.14/terraform_0.11.14_linux_386.zip</a><br/>sudo apt-get install unzip<br/>unzip terraform_0.11.14_linux_386.zip<br/>sudo mv terraform /usr/local/bin/</span></pre><p id="6279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Mac 上，使用<a class="ae lf" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="4292" class="mu lh it mq b gy mv mw l mx my">brew unlink terraform || true<br/>brew install tfenv<br/>tfenv install 0.11.14</span></pre><p id="4ac1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Windows 用户可以使用<a class="ae lf" href="https://chocolatey.org/" rel="noopener ugc nofollow" target="_blank"> Chocolatey </a>:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="bea2" class="mu lh it mq b gy mv mw l mx my">choco install terraform --version 0.11.14 -y</span></pre><p id="9ad3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验证 terraform 是否有效:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="6fa9" class="mu lh it mq b gy mv mw l mx my">terraform --version</span></pre><p id="b3e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该看到:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="b574" class="mu lh it mq b gy mv mw l mx my">Terraform v0.11.14</span></pre><p id="7ce2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以走了！忽略任何关于升级的消息。既然已经安装了 Terraform，我们就可以在 AWS 上配置和启动我们的 DC/操作系统集群了。</p><h1 id="031f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为 GPU 实例授权 AWS 服务限制</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/50455a39b4f8a0123daf797aec45a8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*yei2FaU33MB_G5j2WiKHZA.png"/></div></figure><p id="bc29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lf" href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html" rel="noopener ugc nofollow" target="_blank"> AWS 服务限制</a>定义您在任何给定地区可以使用多少 AWS 资源。我们将启动 5 个 p 3.2x 大型 GPU 实例，作为运行笔记本电脑的 DC/操作系统集群的私有代理。<strong class="kk iu">p 3.2x 大型实例类型的默认服务配额为 0。为了运行本教程，您需要请求 AWS 将这个值增加到 5 或更多。</strong></p><p id="e644" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过登录 AWS Web 控制台并访问此处的服务配额控制台来完成此操作:<a class="ae lf" href="https://us-west-2.console.aws.amazon.com/servicequotas/home?region=us-west-2#!/services/ec2/quotas" rel="noopener ugc nofollow" target="_blank">https://us-west-2 . Console . AWS . Amazon . com/Service Quotas/home？区域=美国-西部-2#！/services/ec2/quotas </a>(您可以在 url 中替换您首选的<a class="ae lf" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions" rel="noopener ugc nofollow" target="_blank"> AWS 区域</a>，只要确保将其替换在 url 中出现的 _both_ places 中即可)。在搜索框中搜索<em class="le"> p3.2xlarge </em>，点击右侧橙色<em class="le">请求配额增加</em>按钮。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/528bc748bf9d8d3aed8ee5b3839f385b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQ-chbBO410z9dNTzmHt7w.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">AWS Service Limit Quota Increase for p3.2xlarge instances</figcaption></figure><p id="1875" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le">更改配额值</em>字段中输入<em class="le"> 5 </em>。然后点击右下角的橙色<em class="le">请求</em>按钮。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/dc849f8e64b841c5ecd3bd2e90e2eb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9ocEah4TmF_gGqKpOnPkA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Quota Increase Submit Form</figcaption></figure><p id="987d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您必须等待 12-48 小时，请求才能获得批准。我有一个基本的 AWS 帐户，当我在下午请求增加时，它在第二天早上被批准。如果您需要加快速度，您可以前往 AWS <a class="ae lf" href="https://console.aws.amazon.com/support/home?region=us-west-2" rel="noopener ugc nofollow" target="_blank">支持中心</a>请求代理致电。他们通常可以加速很多事情。</p><h1 id="9162" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">带通用安装程序的 AWS 上的 DC/操作系统</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/49dea0e9091342a615315ead6552eed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*srige4k8z6mlB0CMRA5R_A.png"/></div></figure><p id="04f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae lf" href="http://docs.d2iq.com" rel="noopener ugc nofollow" target="_blank">d2iq.com</a>上有很好的<a class="ae lf" href="https://docs.d2iq.com/mesosphere/dcos/1.13/installing/evaluation/aws/" rel="noopener ugc nofollow" target="_blank">文档</a>用于 DC/操作系统通用安装程序，但是我将在这篇文章中提供“正常工作”的代码。我们将使用 Terraform 来配置和启动我们的集群，然后我们将安装<a class="ae lf" href="https://universe.dcos.io/#/package/data-science-engine/version/latest" rel="noopener ugc nofollow" target="_blank">数据科学引擎包</a>，并开始使用 JupyterLab！</p><p id="de2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注:将目录改为</strong> <a class="ae lf" href="https://github.com/rjurney/paas_blog" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="le"> Github 项目</em> </strong> </a> <strong class="kk iu">子目录</strong><a class="ae lf" href="https://github.com/rjurney/paas_blog/tree/master/dcos/terraform" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="le">PAAs _ blog/dcos/terraform</em></strong></a><strong class="kk iu">以了解教程的剩余内容。</strong></p><h1 id="83b8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">配置 DC/操作系统</h1><p id="ab75" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">配置 DC/操作系统集群的第一步是创建一个特定于集群的 ssh 密钥。我们把这个键叫做<em class="le"> my_key.pub </em>。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="3334" class="mu lh it mq b gy mv mw l mx my">ssh-keygen -t rsa -f my_key</span></pre><p id="be26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按两次回车键创建没有密码的密钥。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="1913" class="mu lh it mq b gy mv mw l mx my">Generating public/private rsa key pair.<br/>Enter passphrase (empty for no passphrase):<br/>Enter same passphrase again:<br/>Your identification has been saved in my_key.<br/>Your public key has been saved in my_key.pub.<br/>The key fingerprint is:<br/>SHA256:OCOfrIzrTznoMqKOJ2VD2r6YPQp8jFFKIbe/BDyhWuI rjurney@Hostname.local<br/>The key’s randomart image is:<br/>+ — -[RSA 2048] — — +<br/>|..o                |<br/>|.+.o               |<br/>|o.*.               |<br/>|+o++ .             |<br/>|.E + + S           |<br/>|o Oo * +           |<br/>|.*.+= +            |<br/>|B==+ o             |<br/>|XOB=+              |<br/>+ — — [SHA256] — — -+</span></pre><p id="0240" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要把<em class="le"> my_key </em>的权限改成只对我们的用户<em class="le"> 0600 </em>可读，不然以后 ssh 会抱怨的。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="3447" class="mu lh it mq b gy mv mw l mx my">chmod 0600 ./my_key</span></pre><p id="6092" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在运行<code class="fe nm nn no mq b">ssh-agent</code>(如果它没有运行)并将密钥添加到代理中。</p><p id="6baa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:如果没有这个步骤，在创建集群时会出现 ssh 错误。请参见下面的常见错误部分。</em></p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="e8fe" class="mu lh it mq b gy mv mw l mx my">eval "$(ssh-agent -s)"<br/>ssh-add ./my_key</span></pre><p id="483f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，验证是否已经添加了密钥:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="16ba" class="mu lh it mq b gy mv mw l mx my">ssh-add -l</span></pre><p id="2e34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该显示:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="a7ca" class="mu lh it mq b gy mv mw l mx my">2048 SHA256:1234567891234567891234567891234567891234567 ./my_key (RSA)</span></pre><h1 id="8757" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">通过脚本创建超级用户密码哈希</h1><p id="df05" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在我们将使用 Python 的<a class="ae lf" href="https://docs.python.org/3/library/hashlib.html" rel="noopener ugc nofollow" target="_blank"> hashlib </a>模块为集群创建一个超级用户密码散列文件。我们将调用我们的<em class="le">dcos _ super user _ password _ hash</em>。</p><p id="0ebc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经创建了一个命令行脚本，它将生成、打印一个名为<em class="le">PAAs _ blog/dcos/terra form/generate _ password _ hash . py</em>的密码散列并写入磁盘。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="1bfe" class="mu lh it mq b gy mv mw l mx my">usage: generate_password_hash.py [-h] PASSWORD</span><span id="063d" class="mu lh it mq b gy mz mw l mx my">Generate an SHA512 password hash for the given password</span><span id="8e87" class="mu lh it mq b gy mz mw l mx my">positional arguments:<br/> PASSWORD A password to generate a SHA512 hash of</span><span id="a487" class="mu lh it mq b gy mz mw l mx my">optional arguments:<br/> -h, — help show this help message and exit</span></pre><p id="bf9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要运行它，只需运行:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="967c" class="mu lh it mq b gy mv mw l mx my">python ./generate_password_hash.py my_password</span></pre><p id="6c91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到类似这样的输出:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="a7b3" class="mu lh it mq b gy mv mw l mx my">Wrote SHA512 digest: '1234567891011121314151617181920212223242526…' for password 'my_password' to ./dcos_superuser_password_hash</span></pre><p id="4d38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验证写入文件<em class="le">dcos _ super user _ password _ hash</em>是否成功:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="64ab" class="mu lh it mq b gy mv mw l mx my">cat dcos_superuser_password_hash</span></pre><p id="5cbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Python 中创建超级用户密码散列</p><p id="cc71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要手动创建散列，请打开 Python shell(考虑使用<a class="ae lf" href="https://ipython.org/" rel="noopener ugc nofollow" target="_blank"> ipython </a>):</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="2daf" class="mu lh it mq b gy mv mw l mx my">python # or ipython</span></pre><p id="bbef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在运行以下代码:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="1e84" class="mu lh it mq b gy mv mw l mx my">import hashlib</span><span id="7a3a" class="mu lh it mq b gy mz mw l mx my">with open('dcos_superuser_password_hash', 'w') as f:<br/>  m = hashlib.sha512('my_password'.encode())<br/>  f.write( m.hexdigest() )</span></pre><p id="81f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将密码散列的权限更改为仅对您的用户可读，<em class="le"> 0600 </em>，否则 DC/操作系统 CLI 将报错:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="8623" class="mu lh it mq b gy mv mw l mx my">chmod 0600 ./dcos_superuser_password_hash</span></pre><p id="7db2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验证密码已成功保存:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="b5fc" class="mu lh it mq b gy mv mw l mx my">cat dcos_superuser_password_hash</span></pre><p id="a603" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到类似这样的内容:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="b0fc" class="mu lh it mq b gy mv mw l mx my">dda8c3468860dcb2aa228ab8ee44208d43eb2f5fd2a3a538bafbd8860dcb24e228ab8ee44208d43eb2f5a2f8b143eb2f5a2f8b17eccc87ffe79d8459e2df294fb01</span></pre><h1 id="3ee4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">创建许可证文件—(仅限企业版)</h1><p id="e23f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">由于我们将使用开放版本的 DC 操作系统，我通过<code class="fe nm nn no mq b">touch license.txt</code>创建了一个空的<em class="le"> license.txt </em>文件。它需要存在，但可以是空的。它已经致力于 Github，所以对于 DC/OS 的开放版本，一旦你签出了<a class="ae lf" href="https://github.com/rjurney/paas_blog" rel="noopener ugc nofollow" target="_blank"> GitHub 项目</a>，你就不需要创建它了。如果您使用的是企业版，您需要将您的实际许可证放在<em class="le"> license.txt </em>中。</p><h1 id="accb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">配置我们的 DC/操作系统集群</h1><p id="6e8d" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我已经编辑了文件<em class="le">PAAs _ blog/dcos/terra form/desired _ cluster _ profile . TF vars</em>以个性化超级用户帐户名称，从我们上面创建的密码哈希文件中加载超级用户密码哈希，以指定空的许可证字符串并指向空的<em class="le"> license.txt </em>文件。DC/操作系统版本设置为<em class="le"> open </em>，DC/操作系统版本设置为<em class="le"> 1.13.3 </em>，我们将使用一个<em class="le"> m5.xlarge </em>作为我们的引导实例类型，我们将使用<em class="le"> p3.2xlarge </em>实例来运行 JupyterLab。我们将 GPU 代理的数量设置为 5，这足以运行 Spark 和 JupyterLab。最后，我们指定我们之前生成的公钥，<em class="le"> my_key.pub </em>。记住使用公钥，而不是私钥。</p><p id="c2e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注:你可以在<a class="ae lf" href="https://dcos.io/releases/" rel="noopener ugc nofollow" target="_blank">发布页面</a>找到最新版本的 DC/OS，点击其<a class="ae lf" href="https://github.com/dcos-terraform/terraform-aws-dcos" rel="noopener ugc nofollow" target="_blank"> Github repo </a>上的<em class="le">标签</em>可以找到最新版本的通用安装程序。如果遇到问题，通过编辑<em class="le"> terraform.tf </em>中的<em class="le">版本</em>键，使用最高的<em class="le"> 0.2.x </em>标签。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="7db6" class="mu lh it mq b gy mv mw l mx my">cluster_owner = "rjurney"<br/>dcos_superuser_password_hash = "${file("dcos_superuser_password_hash")}"<br/>dcos_superuser_username = "rjurney"<br/>dcos_license_key_contents = ""<br/>dcos_license_key_file = "./license.txt"<br/>dcos_version = "1.13.4"<br/>dcos_variant = "open"<br/>bootstrap_instance_type = "m5.xlarge"<br/>gpu_agent_instance_type = "p3.2xlarge"<br/>num_gpu_agents = "5"<br/>ssh_public_key_file = "./my_key.pub"</span></pre><p id="31f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:如果您使用的是 DC 操作系统的<strong class="kk iu">企业版</strong>，您需要填写<strong class="kk iu"><em class="le">dcos _ license _ key _ contents</em></strong>，对于开放版本，我们会将其留空。您还需要更改配置，使<code class="fe nm nn no mq b">dcos_variant = </code>“ee”。</p><h1 id="e6da" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">初始化地形</h1><p id="202c" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">首先，我们需要<a class="ae lf" href="https://www.terraform.io/docs/commands/init.html" rel="noopener ugc nofollow" target="_blank">用我们将要使用的所有模块初始化</a> Terraform:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="d7de" class="mu lh it mq b gy mv mw l mx my">terraform init -upgrade</span></pre><p id="9a10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该看到:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="2a06" class="mu lh it mq b gy mv mw l mx my">Upgrading modules...</span><span id="3d3e" class="mu lh it mq b gy mz mw l mx my">&lt;list of modules&gt;<br/>Initializing provider plugins…<br/>&lt;list of plugins&gt;</span><span id="9ea6" class="mu lh it mq b gy mz mw l mx my">Terraform has been successfully initialized!</span></pre><h1 id="f839" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">生成地形图</h1><p id="f468" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在我们需要使用我们在<em class="le">PAAs _ blog/dcos/terraform/desired _ cluster _ profile . TF vars</em>中定义的变量来生成一个<a class="ae lf" href="https://www.terraform.io/docs/commands/plan.html" rel="noopener ugc nofollow" target="_blank">行动计划</a>供 terra form 执行。我们将计划保存到<em class="le">PAAs _ blog/dcos/terra form/plan . out</em>。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="ece5" class="mu lh it mq b gy mv mw l mx my">terraform plan -var-file desired_cluster_profile.tfvars -out plan.out</span></pre><p id="27b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到很多没有错误的输出，结尾是:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="39db" class="mu lh it mq b gy mv mw l mx my">Plan: 75 to add, 3 to change, 0 to destroy.</span><span id="2b34" class="mu lh it mq b gy mz mw l mx my"> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </span><span id="7dac" class="mu lh it mq b gy mz mw l mx my">This plan was saved to: plan.out</span><span id="f1cf" class="mu lh it mq b gy mz mw l mx my">To perform exactly these actions, run the following command to apply:<br/> terraform apply "plan.out"</span></pre><p id="a37a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有一个计划，让 Terraform 在<em class="le"> plan.out </em>中创建我们的 DC/操作系统集群，它是二进制的，不太容易检查。</p><h1 id="8b7b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">启动我们的 DC/操作系统集群</h1><p id="f130" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在我们已经有了一个包含自定义变量的计划，我们不需要在 apply 命令中再次包含它们。我们可以按照*plan*命令输出末尾的指示去做。注意，我们没有将<code class="fe nm nn no mq b">--var-file</code>与 apply 一起使用，因为 plan 已经将我们的变量插入到计划中。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="cf91" class="mu lh it mq b gy mv mw l mx my">terraform apply plan.out</span></pre><p id="14b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该命令可能需要长达 15 分钟的时间来执行，因为在初始化 AWS 资源序列，然后执行命令来初始化 EC2 实例上的服务时会有延迟。您应该会看到很多输出，开始是:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="9e05" class="mu lh it mq b gy mv mw l mx my">module.dcos.module.dcos-infrastructure.module.dcos-lb.module.dcos-lb-masters.module.masters.tls_private_key.selfsigned: Creating...</span><span id="b5fd" class="mu lh it mq b gy mz mw l mx my">&lt;lots more stuff&gt;</span></pre><p id="a772" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您看到任何错误，最好是销毁集群并重试。AWS 资源延迟初始化中的定时问题有时会导致引导问题。</p><h1 id="3948" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">摧毁我们的 DC/操作系统集群</h1><p id="69e4" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">当您完成集群时，如果有错误，或者如果您需要重新创建它，您可以使用下面的命令销毁所有相关的资源。注意，我们确实需要将<code class="fe nm nn no mq b">--var-file</code>与<code class="fe nm nn no mq b">destroy</code>一起使用。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="070c" class="mu lh it mq b gy mv mw l mx my">terraform destroy --auto-approve --var-file desired_cluster_profile.tfvars</span></pre><p id="317c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能需要一点时间，因为有许多资源要删除。一旦销毁完成，你可以自由地计划和再次申请。</p><h1 id="687d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">登录我们的 DC/操作系统集群</h1><p id="0100" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">“terraform apply”命令的最终输出为我们提供了要连接的主节点的地址，应该如下所示:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="aae5" class="mu lh it mq b gy mv mw l mx my">Apply complete! Resources: 75 added, 0 changed, 0 destroyed.</span><span id="3a26" class="mu lh it mq b gy mz mw l mx my">Outputs:</span><span id="2eed" class="mu lh it mq b gy mz mw l mx my">masters-ips = [<br/>  54.XX.XXX.XXX<br/>]<br/>public-agents-loadbalancer = ext-jupyter-gpu-12a9-abcde6g1234.elb.us-west-2.amazonaws.com</span></pre><p id="a298" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览器中打开主 ip 地址，您应该会看到一个登录窗口。请注意，唯一授权连接到这台机器的 IP 是您的源 IP。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/cd74951ff5388a99dbef7bce7ffa548e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UK3DJ6izcKYJlmulrnVYCA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">DC/OS Cluster Authentication Page</figcaption></figure><p id="6c61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择你的认证方式——我用谷歌。一旦您通过验证，它会将您返回到主页。</p><h1 id="71ec" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">安装数据科学引擎服务</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/315ef78a57e473928f9b12b8b41a37f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7Acqp5XRDZHapCfwdMS4A.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">DC/OS Dashboard</figcaption></figure><p id="9082" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在左侧菜单中，从顶部往下数第四个，在此图中用橙色圈出的是*Catalog*项目。点击它，DC/操作系统服务菜单将出现。当我这样做的时候，数据科学引擎服务就出现在第二行，如果没有的话，可以使用左上角的搜索框来找到它。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nq"><img src="../Images/d15183d3a8456593736c87ea92e5c612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsUpGqYo18S-IWGWUFwhew.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">The DC/OS Service Catalog — Every Package a One Click Instasll</figcaption></figure><p id="541b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击<em class="le">数据-科学-引擎</em>服务，其服务页面就会出现。点击<em class="le">查看&amp;运行</em>安装服务。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/120fd1018c51b41fedeb05335b297550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IYwpHBS7Hsl6dq7gfOaJA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">The Data Science Engine Catalog Page</figcaption></figure><p id="947b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打开一个窗口，您可以在其中编辑数据科学引擎的配置。您需要使用字母和破折号来命名集群，但是您如何命名并不重要，除非名称是唯一的。因为我们使用的是<em class="le"> p3.2xlarge </em>实例，所以将服务配置为使用<strong class="kk iu"> 58GB 内存和 8 个 CPU</strong>。选中 Nvidia GPU 分配配置已启用复选框，并为 GPU 数量键入 1。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/f48c70bec8797dd3f29d323778f17dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Nd6tpnnK3qCqe8BjuGjUg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Data Science Engine Service Configuration</figcaption></figure><p id="274b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击右上角的紫色<em class="le">审查&amp;运行</em>按钮。这将带您进入最终审查屏幕。点击右上角的紫色<em class="le">运行服务</em>按钮。</p><p id="82a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">请注意，您可以将服务配置作为 JSON 下载，以便稍后使用 DC/OS CLI 运行，从而使您能够自动部署服务，例如作为您的持续集成系统的一部分。为此，请单击下载配置。</em></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/2052fa8af2250cc0f91ec8929a6a9321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLphVuAkodDc8A3CraSaJg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Data Science Engine Run Confirmation Page</figcaption></figure><p id="f024" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到一个弹出窗口，宣布系统成功启动。点击<em class="le">打开服务</em>。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/cc327bf8206959896af4c727790648d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*PS4VlALrRx72j-JSg6Ah-g.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Service Confirmation Popup</figcaption></figure><p id="692f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将带您进入数据科学引擎服务页面。起初，页面的状态会显示服务正在加载，但很快健康样本会变成绿色，状态会显示<em class="le">正在运行</em>。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/9d178a6febe6acc94ebe51788216595c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrHM_pMyeDiznObUAGmftw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Data Science Engine Service Page</figcaption></figure><h1 id="2f39" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用数据科学引擎</h1><p id="69ab" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在点击文本<em class="le">服务</em>，在屏幕白色区域的顶部显示<em class="le">服务&gt;数据科学引擎</em>。这将带您进入服务列表。您应该会看到列出了<em class="le">数据科学引擎</em>。单击下图中用橙色圈出的启动图标。这将打开与 JupyterLab 的连接。默认的 Jupyter 密码是<em class="le"> jupyter </em>，但是您可以使用我们用来启动服务的服务配置窗口来设置它。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/008ee80714206a11702999c220bc6a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoidUnUEEtZmG8CjMuHg1Q.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Running Services Page — Click on the open icon to open JupyterLab</figcaption></figure><p id="28c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦输入<em class="le"> jupyter </em>的默认 Jupyter 密码(可以在<em class="le">desired _ cluster _ profile . TF vars</em>中更改)，就会看到 JupyterLab 的主页。第一页加载可能需要一点时间。Tada！</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/97019f3b9b554f32a3d6ec8b059fe574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjFc9uASyKoPDf9eeVGPTg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">JupyterLab Dashboard</figcaption></figure><h1 id="7a21" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">用一些自然语言处理来锻炼我们的 GPU</h1><p id="2d1b" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在我们已经启动了集群和服务，让我们通过训练一个神经网络来标记堆栈溢出问题来练习它。我们将此视为一个多类别、多标签的问题。通过对至少有一个答案、一个投票并且至少有一个标签出现超过 2000 次的问题的完整转储进行上采样，来平衡训练数据。大约 600MB。这个数据集是<a class="ae lf" href="https://github.com/rjurney/deep_products/blob/master/code/stackoverflow/get_questions.spark.py" rel="noopener ugc nofollow" target="_blank">之前计算的</a>，文件可以在 Github repo 的<em class="le"> paas_blog/data </em>目录中找到。</p><p id="96c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在 github.com/rjurney/paas_blog/DCOS_Data_Science_Engine.ipynb<a class="ae lf" href="https://github.com/rjurney/paas_blog/blob/master/DCOS_Data_Science_Engine.ipynb" rel="noopener ugc nofollow" target="_blank">的 Github 上查看 Jupyter 笔记本的代码。我们将使用 JupyterLab Github 接口打开它，但是如果你愿意，你可以将它的内容逐块粘贴到新的 Python 3 笔记本中。</a></p><h1 id="4730" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">加载教程笔记本</h1><p id="24fa" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">JupyterLab 的 Github 模块超级棒，让加载教程笔记本变得很容易。点击屏幕最左边的 Github 图标，在文件和跑男图标之间。在显示<em class="le"> &lt;的地方输入<em class="le"> rjurney </em>编辑用户&gt; </em>。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/9a6c4050d1e8ddf1ebfde114dab33537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVeOoTTqWIdR3WynX4-ZGQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">JupyterLab’s Github Browser</figcaption></figure><p id="c802" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的公共 Github 项目将会出现。选择<em class="le"> paas_blog </em>然后双击<em class="le">DCOS _ 数据 _ 科学 _ 引擎. ipynb </em> Jupyter 笔记本打开。它使用 S3 的数据，所以你不必下载任何数据。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/19df3d3e640d69a857b475cd41073287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0zQ8uHRUmR3b9ywL2X1qQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Example Notebook from Github Loaded in JupyterLab</figcaption></figure><h1 id="d1bc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">验证 GPU 支持</h1><p id="adfa" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">要做的第一件事是验证我们的数据科学引擎 EC2 实例上的 JupyterLab Python 环境是否正确配置为与其板载 GPU 一起工作。我们使用<code class="fe nm nn no mq b">tensorflow.test.is_gpu_available</code>和<code class="fe nm nn no mq b">tensorflow.compat.v2.config.experimental.list_physical_devices</code>来验证 GPU 是否与 Tensorflow 一起工作。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="7499" class="mu lh it mq b gy mv mw l mx my">gpu_avail = tf.test.is_gpu_available(<br/>  cuda_only=False,<br/>  min_cuda_compute_capability=None<br/>)<br/>print(f'1 or more GPUs is available: {gpu_avail}')</span><span id="59e8" class="mu lh it mq b gy mz mw l mx my">from tensorflow.python.client import device_lib<br/>local_devices = device_lib.list_local_devices()<br/>gpu = local_devices[3]<br/>print(f"{gpu.name} is a {gpu.device_type} with {gpu.memory_limit / 1024 / 1024 / 1024:.2f}GB RAM")</span></pre><p id="620c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到类似这样的内容:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="0ae4" class="mu lh it mq b gy mv mw l mx my">1 or more GPUs is available: True<br/>/device:GPU:0 is a GPU with 10.22GB RAM</span></pre><h1 id="3294" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">从 S3 加载数据</h1><p id="80eb" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">您可以使用<em class="le"> pandas.read_parquet </em>加载本教程的数据。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="cebe" class="mu lh it mq b gy mv mw l mx my"># Load the Stack Overflow questions right from S3<br/>s3_parquet_path = f's3://{BUCKET}/08–05–2019/Questions.Stratified.Final.2000.parquet'<br/>s3_fs = s3fs.S3FileSystem()</span><span id="edbb" class="mu lh it mq b gy mz mw l mx my"># Use pyarrow.parquet.ParquetDataset and convert to pandas.DataFrame<br/>posts_df = ParquetDataset(<br/>  s3_parquet_path,<br/>  filesystem=s3_fs,<br/>).read().to_pandas()</span><span id="213a" class="mu lh it mq b gy mz mw l mx my">posts_df.head(3)</span></pre><p id="fa69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们加载索引，在标签索引和文本标记之间来回转换。我们将使用这些来查看教程最后预测的实际结果标签。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="d0d9" class="mu lh it mq b gy mv mw l mx my"># Get the tag indexes<br/>s3_client = boto3.resource('s3')</span><span id="3c94" class="mu lh it mq b gy mz mw l mx my">def json_from_s3(bucket, key):<br/>  """Given a bucket and key for a JSON object, return the parsed object"""<br/>  obj = s3_client.Object(bucket, key)<br/>  obj.get()['Body'].read().decode('utf-8')<br/>  json_obj = json.loads(obj.get()[‘Body’].read().decode('utf-8'))<br/>  return json_obj</span><span id="7df8" class="mu lh it mq b gy mz mw l mx my">tag_index = json_from_s3(BUCKET, '08–05–2019/tag_index.2000.json')<br/>index_tag = json_from_s3(BUCKET, '08–05–2019/index_tag.2000.json')</span><span id="3098" class="mu lh it mq b gy mz mw l mx my">list(tag_index.items())[0:5], list(index_tag.items())[0:5]</span></pre><p id="2f15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们验证加载的记录数量:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="73c6" class="mu lh it mq b gy mv mw l mx my">print(<br/>  ‘{:,} Stackoverflow questions with a tag having at least 2,000 occurrences’.format(<br/>    len(posts_df.index)<br/>  )<br/>)</span></pre><p id="9501" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该看到:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="a61c" class="mu lh it mq b gy mv mw l mx my">1,554,788 Stackoverflow questions with a tag having at least 2,000 occurrences</span></pre><h1 id="a14c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">准备数据</h1><p id="ee11" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们需要将之前标记化的文本连接回字符串，以便在标记化器中使用，标记化器提供了有用的属性。此外，Tensorflow/Keras 需要将文档数量设为批量的倍数，以便在多个 GPU 之间分配工作，并使用某些模型，如 Elmo。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="c6db" class="mu lh it mq b gy mv mw l mx my">import math</span><span id="2c54" class="mu lh it mq b gy mz mw l mx my">BATCH_SIZE = 64<br/>MAX_LEN = 200<br/>TOKEN_COUNT = 10000<br/>EMBED_SIZE = 50<br/>TEST_SPLIT = 0.2</span><span id="9fdd" class="mu lh it mq b gy mz mw l mx my"># Convert label columns to numpy array<br/>labels = posts_df[list(posts_df.columns)[1:]].to_numpy()</span><span id="1f3f" class="mu lh it mq b gy mz mw l mx my"># Training_count must be a multiple of the BATCH_SIZE times the MAX_LEN<br/>highest_factor = math.floor(len(posts_df.index) / (BATCH_SIZE * MAX_LEN))<br/>training_count = highest_factor * BATCH_SIZE * MAX_LEN<br/>print(f'Highest Factor: {highest_factor:,} Training Count: {training_count:,}')</span><span id="2c4e" class="mu lh it mq b gy mz mw l mx my"># Join the previously tokenized data for tf.keras.preprocessing.text.Tokenizer to work with<br/>documents = []<br/>for body in posts_df[0:training_count]['_Body'].values.tolist():<br/>  words = body.tolist()<br/>  documents.append(' '.join(words))</span><span id="0acb" class="mu lh it mq b gy mz mw l mx my">labels = labels[0:training_count]</span><span id="6660" class="mu lh it mq b gy mz mw l mx my"># Conserve RAM<br/>del posts_df<br/>gc.collect()</span><span id="b0a5" class="mu lh it mq b gy mz mw l mx my"># Lengths for x and y match<br/>assert( len(documents) == training_count == labels.shape[0] )</span></pre><p id="c9ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该看到:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="55cc" class="mu lh it mq b gy mv mw l mx my">Highest Factor: 121 Training Count: 1,548,800</span></pre><h1 id="1018" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">填充序列</h1><p id="32bf" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">数据已经被删减到每篇 200 字，但在一些文档中，使用 10K 顶级词汇的标记化将这一数据缩减到 200 字以下。如果任何文件超过 200 字，这些数据就不能正确地转换成下面的<em class="le">数字矩阵。</em></p><p id="afec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了用一个键将文本转换成数字序列，Keras' <em class="le"> Tokenizer </em>类对于通过<code class="fe nm nn no mq b"><a class="ae lf" href="https://keras.io/preprocessing/text/#tokenizer" rel="noopener ugc nofollow" target="_blank">keras.preprocessing.text.Tokenizer.sequences_to_texts</a></code>方法生成模型的最终结果也很方便。然后，我们使用 Keras' <code class="fe nm nn no mq b"><a class="ae lf" href="https://keras.io/preprocessing/sequence/#pad_sequences" rel="noopener ugc nofollow" target="_blank">keras.preprocessing.sequence.pad_sequences</a></code>方法并检查输出，以确保序列的长度都是 200 项，否则它们不会正确地转换为矩阵。字符串<code class="fe nm nn no mq b">__PAD__</code>以前已经被用来填充文档，所以我们在这里重用它。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="faab" class="mu lh it mq b gy mv mw l mx my">from tf.keras.preprocessing.text import Tokenizer<br/>from tf.keras.preprocessing.sequence import pad_sequences</span><span id="afbf" class="mu lh it mq b gy mz mw l mx my">tokenizer = Tokenizer(<br/>  num_words=TOKEN_COUNT,<br/>  oov_token='__PAD__'<br/>)<br/>tokenizer.fit_on_texts(documents)<br/>sequences = tokenizer.texts_to_sequences(documents)</span><span id="4daf" class="mu lh it mq b gy mz mw l mx my">padded_sequences = pad_sequences(<br/>  sequences,<br/>  maxlen=MAX_LEN,<br/>  dtype='int32',<br/>  padding='post',<br/>  truncating='post',<br/>  value=1<br/>)</span><span id="5b2d" class="mu lh it mq b gy mz mw l mx my"># Conserve RAM<br/>del documents<br/>del sequences<br/>gc.collect()</span><span id="ba8f" class="mu lh it mq b gy mz mw l mx my">print( max([len(x) for x in padded_sequences]), min([len(x) for x in padded_sequences]) )<br/>assert( min([len(x) for x in padded_sequences]) == MAX_LEN == max([len(x) for x in padded_sequences]) )</span><span id="b5cf" class="mu lh it mq b gy mz mw l mx my">padded_sequences.shape</span></pre><h1 id="322a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">分成测试/训练数据集</h1><p id="82c3" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们需要一个数据集来训练，一个单独的数据集来测试和验证我们的模型。经常使用的<code class="fe nm nn no mq b"><a class="ae lf" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">sklearn.model_selection.train_test_split</a></code>使它如此。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="d51c" class="mu lh it mq b gy mv mw l mx my">from sklearn.model_selection import train_test_split</span><span id="bf47" class="mu lh it mq b gy mz mw l mx my">X_train, X_test, y_train, y_test = train_test_split(<br/>  padded_sequences,<br/>  labels,<br/>  test_size=TEST_SPLIT,<br/>  random_state=1337<br/>)</span><span id="4313" class="mu lh it mq b gy mz mw l mx my"># Conserve RAM<br/>del padded_sequences<br/>del labels<br/>gc.collect()</span><span id="9a79" class="mu lh it mq b gy mz mw l mx my">assert(X_train.shape[0] == y_train.shape[0])<br/>assert(X_train.shape[1] == MAX_LEN)<br/>assert(X_test.shape[0] == y_test.shape[0]) <br/>assert(X_test.shape[1] == MAX_LEN)</span></pre><h1 id="d124" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">计算类别权重</h1><p id="5d74" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">虽然已经对数据进行了过滤和上采样，以将其限制在至少有一个标签出现超过 2000 次的问题样本中，但常见标签和不常见标签之间的比率仍然不均衡。如果没有类权重，最常见的标签比最不常见的标签更有可能被预测到。类别权重将使损失函数更多地考虑不常用的类别，而不是常用的类别。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="8583" class="mu lh it mq b gy mv mw l mx my">train_weight_vec = list(np.max(np.sum(y_train, axis=0))/np.sum(y_train, axis=0))<br/>train_class_weights = {i: train_weight_vec[i] for i in range(y_train.shape[1])}</span><span id="5b56" class="mu lh it mq b gy mz mw l mx my">sorted(list(train_class_weights.items()), key=lambda x: x[1])[0:10]</span></pre><h1 id="b345" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">训练分类器模型来标记堆栈溢出帖子</h1><p id="34f2" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在，我们准备训练一个模型，用标签类别对问题进行分类/标记。该模型基于<a class="ae lf" href="https://arxiv.org/abs/1408.5882" rel="noopener ugc nofollow" target="_blank"> Kim-CNN </a>，一种常用于句子和文档分类的卷积神经网络。我们使用函数式 API，并对代码进行了大量参数化处理，以便于实验。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="0faf" class="mu lh it mq b gy mv mw l mx my">from tensorflow.keras.initializers import RandomUniform<br/>from tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping, ModelCheckpoint<br/>from tensorflow.keras.layers import (<br/>  Dense, Activation, Embedding, Flatten, MaxPool1D, GlobalMaxPool1D, Dropout, Conv1D, Input, concatenate<br/>)<br/>from tensorflow.keras.losses import binary_crossentropy<br/>from tensorflow.keras.models import Model<br/>from tensorflow.keras.optimizers import Adam</span><span id="b0a2" class="mu lh it mq b gy mz mw l mx my">FILTER_LENGTH = 300<br/>FILTER_COUNT = 128<br/>FILTER_SIZES = [3, 4, 5]<br/>EPOCHS = 4<br/>ACTIVATION = 'selu'<br/>CONV_PADDING = 'same'<br/>EMBED_SIZE = 50<br/>EMBED_DROPOUT_RATIO = 0.1<br/>CONV_DROPOUT_RATIO = 0.1<br/>LOSS = 'binary_crossentropy'<br/>OPTIMIZER = 'adam'</span></pre><p id="7186" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Kim-CNN 中，我们首先使用<em class="le">嵌入</em>对序列进行编码，然后使用<em class="le">去除</em>层以减少过度拟合。接下来，我们将图形分割成多个宽度不同的<em class="le"> Conv1D </em>层，每个层后面跟有<em class="le"> MaxPool1D </em>。它们通过串联连接在一起，旨在表征文档中不同大小序列长度的模式。接下来是另一个<em class="le">Conv1D</em>/<em class="le">globalmaxpool 1d</em>层来总结这些模式中最重要的模式。接下来是展平成一个<em class="le">密集</em>层，然后到最后的<em class="le">s 形</em>输出层。否则我们通篇使用<em class="le">卢瑟</em>。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="ee4e" class="mu lh it mq b gy mv mw l mx my">padded_input = Input(<br/>  shape=(X_train.shape[1],), <br/>  dtype=’int32'<br/>)</span><span id="e452" class="mu lh it mq b gy mz mw l mx my"># Create an embedding with RandomUniform initialization<br/>emb = Embedding(<br/>  TOKEN_COUNT, <br/>  EMBED_SIZE, <br/>  input_length=X_train.shape[1],<br/>  embeddings_initializer=RandomUniform()<br/>)(padded_input)<br/>drp = Dropout(EMBED_DROPOUT_RATIO)(emb)</span><span id="4802" class="mu lh it mq b gy mz mw l mx my"># Create convlutions of different kernel sizes<br/>convs = []<br/>for filter_size in FILTER_SIZES:<br/>  f_conv = Conv1D(<br/>    filters=FILTER_COUNT,<br/>    kernel_size=filter_size,<br/>    padding=CONV_PADDING,<br/>    activation=ACTIVATION<br/>  )(drp)<br/>  f_pool = MaxPool1D()(f_conv)<br/>  convs.append(f_pool)</span><span id="f420" class="mu lh it mq b gy mz mw l mx my">l_merge = concatenate(convs, axis=1)<br/>l_conv = Conv1D(<br/>  128,<br/>  5,<br/>  activation=ACTIVATION<br/>)(l_merge)<br/>l_pool = GlobalMaxPool1D()(l_conv)<br/>l_flat = Flatten()(l_pool)<br/>l_drop = Dropout(CONV_DROPOUT_RATIO)(l_flat)<br/>l_dense = Dense(<br/>  128,<br/>  activation=ACTIVATION<br/>)(l_drop)<br/>out_dense = Dense(<br/>  y_train.shape[1],<br/>  activation='sigmoid'<br/>)(l_dense)</span><span id="c488" class="mu lh it mq b gy mz mw l mx my">model = Model(inputs=padded_input, outputs=out_dense)</span></pre><p id="3590" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们编译我们的模型。我们使用各种各样的度量标准，因为没有一个度量标准可以概括模型性能，我们需要深入研究真的和假的肯定和否定。我们还使用<em class="le"> ReduceLROnPlateau </em>、<em class="le"> EarlyStopping </em>和<em class="le"> ModelCheckpoint </em>回调来提高性能，一旦达到稳定状态，我们就提前停止，并且只保留在验证分类准确性方面最好的模型。</p><p id="cd15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分类准确性是衡量我们模型性能的最佳方式，因为它为我们分类的每个类的每一行分别给出了分数。这意味着，如果我们错过了一个，但得到了其他的权利，这是一个伟大的结果。对于二进制精度，整行都被标记为不正确。</p><p id="a3b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后就是拟合模型的时候了。我们给它我们之前计算的类权重。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="ae24" class="mu lh it mq b gy mv mw l mx my">model.compile(<br/>  optimizer=OPTIMIZER,<br/>  loss=LOSS,<br/>  metrics=[<br/>    tf.keras.metrics.CategoricalAccuracy(),<br/>    tf.keras.metrics.Precision(),<br/>    tf.keras.metrics.Recall(),<br/>    tf.keras.metrics.Accuracy(),<br/>    tf.keras.metrics.TruePositives(),<br/>    tf.keras.metrics.FalsePositives(),<br/>    tf.keras.metrics.TrueNegatives(),<br/>    tf.keras.metrics.FalseNegatives(),<br/>  ]<br/>)<br/>model.summary()</span><span id="eb87" class="mu lh it mq b gy mz mw l mx my">callbacks = [<br/>  ReduceLROnPlateau(<br/>    monitor='val_categorical_accuracy',<br/>    factor=0.1,<br/>    patience=1,<br/>  ), <br/>  EarlyStopping(<br/>    monitor='val_categorical_accuracy',<br/>    patience=2<br/>  ), <br/>  ModelCheckpoint(<br/>    filepath='kim_cnn_tagger.weights.hdf5',<br/>    monitor='val_categorical_accuracy',<br/>    save_best_only=True<br/>  ),<br/>]</span><span id="5fa5" class="mu lh it mq b gy mz mw l mx my">history = model.fit(X_train, y_train,<br/>  class_weight=train_class_weights,<br/>  epochs=EPOCHS,<br/>  batch_size=BATCH_SIZE,<br/>  validation_data=(X_test, y_test),<br/>  callbacks=callbacks<br/>)</span></pre><h1 id="3efb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">从训练时期加载最佳模型</h1><p id="0b5f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">因为我们使用了<code class="fe nm nn no mq b">ModelCheckpoint(save_only_best-True)</code>，就<code class="fe nm nn no mq b">CategoricalAccuracy</code>而言，最好的纪元是被保存的。我们想用它来代替上一个纪元的模型，它存储在上面的<code class="fe nm nn no mq b">model</code>中。所以我们在评估模型之前加载文件。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="da06" class="mu lh it mq b gy mv mw l mx my">model = tf.keras.models.load_model('kim_cnn_tagger.weights.hdf5')<br/>metrics = model.evaluate(X_test, y_test)</span></pre><h1 id="6de6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">解析并打印最终指标</h1><p id="0d28" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">度量包括像<em class="le"> precision_66 </em>这样的名字，它们在运行之间是不一致的。我们修复这些来清理我们关于训练模型的报告。我们还添加了一个 f1 分数，然后制作一个数据帧来显示日志。这可以在重复实验中推广。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="b919" class="mu lh it mq b gy mv mw l mx my">def fix_metric_name(name):<br/>  """Remove the trailing _NN, ex. precision_86"""<br/>  if name[-1].isdigit():<br/>    repeat_name = '_'.join(name.split('_')[:-1])<br/>  else:<br/>    repeat_name = name<br/>    return repeat_name</span><span id="3fa8" class="mu lh it mq b gy mz mw l mx my">def fix_value(val):<br/>  """Convert from numpy to float"""<br/>  return val.item() if isinstance(val, np.float32) else val</span><span id="0ab5" class="mu lh it mq b gy mz mw l mx my">def fix_metric(name, val):<br/>  repeat_name = fix_metric_name(name)<br/>  py_val = fix_value(val)<br/>  return repeat_name, py_val</span><span id="a168" class="mu lh it mq b gy mz mw l mx my">log = {}<br/>for name, val in zip(model.metrics_names, metrics):<br/>  repeat_name, py_val = fix_metric(name, val)<br/>  log[repeat_name] = py_val<br/>log.update({'f1': (log['precision'] * log['recall']) / (log['precision'] + log['recall'])})</span><span id="6068" class="mu lh it mq b gy mz mw l mx my">pd.DataFrame([log])</span></pre><h1 id="e246" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">绘制历元精度</h1><p id="2196" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们想知道每个时期的性能，这样我们就不会不必要地训练大量的时期。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="b668" class="mu lh it mq b gy mv mw l mx my">%matplotlib inline</span><span id="0462" class="mu lh it mq b gy mz mw l mx my">new_history = {}<br/>for key, metrics in history.history.items():<br/>  new_history[fix_metric_name(key)] = metrics</span><span id="2e93" class="mu lh it mq b gy mz mw l mx my">import matplotlib.pyplot as plt</span><span id="bb91" class="mu lh it mq b gy mz mw l mx my">viz_keys = ['val_categorical_accuracy', 'val_precision', 'val_recall']</span><span id="c439" class="mu lh it mq b gy mz mw l mx my"># summarize history for accuracy<br/>for key in viz_keys:<br/>  plt.plot(new_history[key])<br/>plt.title('model accuracy')<br/>plt.ylabel('metric')<br/>plt.xlabel('epoch')<br/>plt.legend(viz_keys, loc='upper left')<br/>plt.show()</span><span id="c391" class="mu lh it mq b gy mz mw l mx my"># summarize history for loss<br/>plt.plot(history.history['loss'])<br/>plt.plot(history.history['val_loss'])<br/>plt.title('model loss')<br/>plt.ylabel('loss')<br/>plt.xlabel('epoch')<br/>plt.legend(['train', 'test'], loc='upper left')<br/>plt.show()</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ns"><img src="../Images/7179bef5da3cffe17b5e364928f1c85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wNriAVxCvgGvn58TnlqQQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Categorical Accuracy, Precision and Recall Across Epochs. Note that recall climbs even on the 8th Epoch</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/a5f8cc58786cd9895063df0612b90487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcjUH6VyZlgOKwHWbRZ39w.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Test / Train Loss</figcaption></figure><h1 id="4ac5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">检查实际预测输出</h1><p id="85cf" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">光知道理论性能是不够的。我们需要看到标记者在不同置信度阈值下的实际输出。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="7ff0" class="mu lh it mq b gy mv mw l mx my">TEST_COUNT = 1000</span><span id="480d" class="mu lh it mq b gy mz mw l mx my">X_test_text = tokenizer.sequences_to_texts(X_test[:TEST_COUNT])</span><span id="68b7" class="mu lh it mq b gy mz mw l mx my">y_test_tags = []<br/>for row in y_test[:TEST_COUNT].tolist():<br/>   tags = [index_tag[str(i)] for i, col in enumerate(row) if col == 1]<br/>   y_test_tags.append(tags)</span><span id="9a12" class="mu lh it mq b gy mz mw l mx my">CLASSIFY_THRESHOLD = 0.5</span><span id="3b54" class="mu lh it mq b gy mz mw l mx my">y_pred = model.predict(X_test[:TEST_COUNT])<br/>y_pred = (y_pred &gt; CLASSIFY_THRESHOLD) * 1</span><span id="984e" class="mu lh it mq b gy mz mw l mx my">y_pred_tags = []<br/>for row in y_pred.tolist():<br/>  tags = [index_tag[str(i)] for i, col in enumerate(row) if col &gt; CLASSIFY_THRESHOLD]<br/>  y_pred_tags.append(tags)</span></pre><p id="9580" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看在<em class="le">数据帧</em>中带有实际标签和预测标签的句子:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="6461" class="mu lh it mq b gy mv mw l mx my">prediction_tests = []<br/>for x, y, z in zip(X_test_text, y_pred_tags, y_test_tags):<br/>  prediction_tests.append({<br/>    'Question': x,<br/>    'Predictions': ' '.join(sorted(y)),<br/>    'Actual Tags': ' '.join(sorted(z)),<br/> })</span><span id="e177" class="mu lh it mq b gy mz mw l mx my">pd.DataFrame(prediction_tests)</span></pre><p id="efb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从这三个记录中看出，该模型做得相当不错。这讲述了一个不同于单独的性能指标的故事。奇怪的是，大多数机器学习的例子只是计算性能，并没有真正使用“predict()”方法！归根结底，统计性能是无关紧要的，重要的是真实世界的性能——它不包含在简单的汇总统计中！</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nu"><img src="../Images/30af2e74680e31a1cca8fe700c4a39d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtuOAwEuKkpMdpjSFSZPBw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Questions along with Actual Labels and Predicted Labels</figcaption></figure><h1 id="0f7e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">自动化 DC/操作系统数据科学引擎设置</h1><p id="ec66" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这涵盖了如何手动使用平台，但这是关于 PaaS 自动化。那么我们如何加快速度呢？</p><p id="5300" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DC/操作系统的图形用户界面和 CLI 共同支持各类用户通过数据科学引擎轻松访问 JupyterLab:试图在笔记本上查看报告的非技术管理人员和希望自动化流程的开发运营/数据工程师。如果手动 GUI 过程似乎很复杂，我们可以在将服务配置作为 JSON 文件后，通过几行代码将其自动化，方法是通过 Terraform 命令启动 DC/操作系统集群，从 Terraform 获取集群地址，然后使用 DC/操作系统 CLI 验证集群并运行服务。</p><p id="26e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注:查看 DC/OS CLI 的</em> <a class="ae lf" href="https://github.com/dcos/dcos-cli" rel="noopener ugc nofollow" target="_blank"> <em class="le"> Github 页面</em> </a> <em class="le">了解更多关于它如何工作的信息。</em></p><h1 id="de59" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">安装 DC/操作系统命令行界面</h1><p id="6f05" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">使用 Terraform 启动集群并在用户界面中手动安装 Data Science 引擎时，不需要 DC/操作系统 CLI，但需要它来自动执行该过程。如果您遇到了麻烦，请查看<a class="ae lf" href="https://docs.d2iq.com/mesosphere/dcos/1.12/cli/install/" rel="noopener ugc nofollow" target="_blank"> CLI 安装文档</a>。你将需要<a class="ae lf" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank">卷发</a>。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="1c25" class="mu lh it mq b gy mv mw l mx my"># Optional: make a /usr/local/bin if it isn’t there. Otherwise change the install path.<br/>[ -d usr/local/bin ] || sudo mkdir -p /usr/local/bin</span><span id="3102" class="mu lh it mq b gy mz mw l mx my"># Download the executable<br/>curl <a class="ae lf" href="https://downloads.dcos.io/binaries/cli/linux/x86-64/dcos-1.13/dcos" rel="noopener ugc nofollow" target="_blank">https://downloads.dcos.io/binaries/cli/linux/x86-64/dcos-1.13/dcos</a> -o dcos</span></pre><p id="5607" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，您也可以使用打印的命令下载 CLI，方法是单击右上方标题为<em class="le"> jupyter-gpu-xxxx </em>(或您为集群命名的任何名称)的下拉菜单，然后单击下方橙色框中的 Install CLI 按钮。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/ef7b698bc22804f577613924522538b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSLXu0Jf1AsfcI0NVZ8W_g.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Note the <strong class="bd nv">Install CLI</strong> button in the dropdown at top right</figcaption></figure><p id="e7ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将出现一个弹出窗口，显示 Windows、OS X 和 Linux 的安装代码。将代码复制/粘贴到终端以完成安装。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nw"><img src="../Images/57f1383ae71853e3a01b13612bc1e5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHsHGTImVc1IzTl3pAm32A.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Install Commands for DC/OS CLI</figcaption></figure><p id="e74f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果您运行<code class="fe nm nn no mq b">dcos</code>，您应该会看到以下内容:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="16f6" class="mu lh it mq b gy mv mw l mx my">Usage:<br/>  dcos [command]</span><span id="f8fa" class="mu lh it mq b gy mz mw l mx my">Commands:<br/>  auth<br/>  Authenticate to DC/OS cluster<br/>  cluster<br/>  Manage your DC/OS clusters<br/>  config<br/>  Manage the DC/OS configuration file<br/>  help<br/>  Help about any command<br/>  plugin<br/>  Manage CLI plugins</span><span id="7b63" class="mu lh it mq b gy mz mw l mx my">Options:<br/>  — version<br/>  Print version information<br/>  -v, -vv<br/>  Output verbosity (verbose or very verbose)<br/>  -h, — help<br/>  Show usage help</span><span id="f687" class="mu lh it mq b gy mz mw l mx my">Use "dcos [command] — help" for more information about a command.</span></pre><h1 id="2a58" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用 GUI 手动导出软件包配置</h1><p id="aab9" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">为了自动安装数据科学引擎包，我们首先需要以 JSON 文件的形式获取它的配置。这可以通过两种方式完成:通过 GUI 或通过 DC/操作系统 CLI 或通过 Terraform CLI。我们将介绍这两种方法。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/66e7b301d3b799e77a00742e034f9fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DXj2nfsxZrU7-s5D5Iq0A.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Note the <strong class="bd nv">Download Config</strong> button below the dividing line at the top right</figcaption></figure><p id="78bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 GUI，我们可以通过从<em class="le">数据-科学-引擎</em>服务页面的<em class="le">配置</em>选项卡下载 JSON 来获得包配置。点击该行右上方紫色的<em class="le">下载配置</em>。</p><p id="4198" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，您可以通过点击右上角的紫色<em class="le">编辑</em>按钮来编辑数据科学引擎服务。您可以使用菜单或 JSON 编辑器来更改服务——例如增加 RAM 或 GPUs 它会根据该配置自动重新部署。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/7b81e8bac55fee3f9adb8be7de2e0a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rX4JXiy7W2-Qa8uJSToTXw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Editing the Data Science Engine Service Config</figcaption></figure><h1 id="187a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">向群集验证 DC/操作系统 CLI</h1><p id="4ffe" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">要使用 CLI，我们需要向群集进行身份验证。这可以通过 Google、用户名或其他适合您组织的方法来完成。为此，首先我们需要来自 Terraform 的服务器地址。我们可以通过<code class="fe nm nn no mq b">terraform output -json</code>和<a class="ae lf" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> <em class="le"> jq </em> </a> json 实用程序提取集群主机 IP 地址。一旦我们有了这些，我们可以使用任何我们喜欢的方法，包括谷歌，来进行认证。这也可以是便于自动化的用户名。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="f481" class="mu lh it mq b gy mv mw l mx my"># Get the cluster address from Terraform’s JSON output and Authenticate CLI to Cluster<br/>export CLUSTER_ADDRESS=`terraform output -json | jq -r '.["masters-ips"].value[0]'`<br/>dcos cluster setup <a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/$CLUSTER_ADDRESS">http://$CLUSTER_ADDRESS</a> # add whatever arguments you need for automated authentication</span></pre><p id="1468" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看<code class="fe nm nn no mq b">dcos cluster setup</code>的<a class="ae lf" href="https://docs.d2iq.com/mesosphere/dcos/1.13/cli/command-reference/dcos-cluster/dcos-cluster-setup/" rel="noopener ugc nofollow" target="_blank">文档</a>，了解不同认证方法的信息。</p><h1 id="a309" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用 CLI 导出程序包配置</h1><p id="d7c2" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">一旦我们通过了身份验证，我们就可以使用 CLI 来生成包配置文件，供以后重用。</p><p id="93ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于麦克·OS X 来说，指挥旗<code class="fe nm nn no mq b">base64</code>是一个大写字母<code class="fe nm nn no mq b">-D</code>:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="9f0f" class="mu lh it mq b gy mv mw l mx my">dcos marathon app show data-science-engine | jq -r .labels.DCOS_PACKAGE_OPTIONS | base64 -D | jq &gt; my-data-science-engine.json</span></pre><p id="5679" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于 Linux，<code class="fe nm nn no mq b">base64</code>的标志是小写的<code class="fe nm nn no mq b">-d</code>:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="74a2" class="mu lh it mq b gy mv mw l mx my">dcos marathon app show data-science-engine | jq -r .labels.DCOS_PACKAGE_OPTIONS | base64 -d | jq &gt; my-data-science-engine.json</span></pre><p id="d4f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，导出的选项涵盖了每一个选项，这并不理想，因为选项可能会在平台的不同版本之间发生变化，如果您不更改值，最好依赖系统默认值。例如，我将该导出编辑为:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="8460" class="mu lh it mq b gy mv mw l mx my">{<br/>  "service": {<br/>    "name": "data-science-engine",<br/>    "cpus": 8,<br/>    "mem": 51200,<br/>    "gpu": {<br/>      "enabled": true,<br/>      "gpus": 1<br/>      }<br/>   }<br/>}</span></pre><p id="75c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以编辑该文件以满足您的需要，或者使用 GUI 来完成，并下载和编辑配置。</p><h1 id="eede" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用 CLI 安装数据科学引擎</h1><p id="7ad8" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在，我们可以使用 CLI 安装数据科学引擎包:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="57c9" class="mu lh it mq b gy mv mw l mx my">dcos package install data-science-engine --options=./data-science-engine.json --yes </span></pre><h1 id="15a1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">完整的集群/服务自动化示例</h1><p id="6a57" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">总之，这使得整个过程使用导出的 JSON 包配置:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="198f" class="mu lh it mq b gy mv mw l mx my"># Boot DC/OS Cluster<br/>terraform init -upgrade<br/>terraform plan -var-file desired_cluster_profile.tfvars -out plan.out<br/>terraform apply plan.out</span><span id="2758" class="mu lh it mq b gy mz mw l mx my"># Get the cluster address from Terraform’s JSON output<br/>export CLUSTER_ADDRESS = `terraform output -json | jq -r '.["masters-ips"].value[0]'`</span><span id="170c" class="mu lh it mq b gy mz mw l mx my"># Authenticate CLI to Cluster using its address and Install the Data Science Engine Package<br/>dcos cluster setup <a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/$CLUSTER_ADDRESS">http://$CLUSTER_ADDRESS</a> # add whatever arguments you need for automated authentication<br/>dcos package install data-science-engine --options=data-science-engine-options.json</span></pre><h1 id="e8e9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="b3bb" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在这篇文章中，我们启动了一个 DC/操作系统集群，并以可重复的方式部署了数据科学引擎，然后执行了一个测试笔记本来创建一个堆栈溢出标记。这展示了如何使用 PaaS 来提高数据科学团队的生产力。请继续关注该系列的下一篇文章！</p><p id="b744" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:教程中的每一步都经过严格测试，所以如果你遇到任何问题，请在评论中告诉我。</em></p><h1 id="076c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">附录:常见错误</h1><p id="0f9c" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我在写这篇文章的时候遇到了一些错误，你可能会在这篇文章中的例子中遇到，所以我已经包括了这些错误以及如何修复它们！:)</p><h1 id="360c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><code class="fe nm nn no mq b">ssh-agent</code>问题</h1><p id="5358" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如果您忘记通过<code class="fe nm nn no mq b">eval "$(ssh-agent -s)"</code>和<code class="fe nm nn no mq b">ssh-add</code>您的密钥运行 ssh-agent，您将看到下面的错误。如果您打开一个新的 shell 并从中运行 terraform 命令，这将非常容易。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="f10b" class="mu lh it mq b gy mv mw l mx my">Error: Error applying plan:</span><span id="3fda" class="mu lh it mq b gy mz mw l mx my">1 error occurred:<br/>  * module.dcos.module.dcos-install.module.dcos-install.null_resource.run_ansible_from_bootstrap_node_to_install_dcos: timeout — last error: ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain<br/>```</span></pre><p id="47b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是来自<em class="le"> paas_blog/dcos/terraform </em>目录的<code class="fe nm nn no mq b">ssh-add ./my_key</code>。为了避免将来出现这种情况，您可以编辑<em class="le">desired _ cluster _ profile . TF vars</em>中的密钥字段，以便在您的<em class="le"> ~ /中使用公钥。ssh/ </em>目录，当 shell 启动时，使用<em class="le"> ~/自动添加到 ssh-agent 中。简介</em>、<em class="le"> ~/。bash_profile </em>或者<em class="le"> ~/。bashrc </em>。</p><p id="09ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，验证是否已经添加了密钥:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="bbe6" class="mu lh it mq b gy mv mw l mx my">ssh-add -l</span></pre><p id="107b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该显示:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="3491" class="mu lh it mq b gy mv mw l mx my">2048 SHA256:1234567891234567891234567891234567891234567 ./my_key (RSA)</span></pre><h1 id="c735" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">超时问题</h1><p id="c035" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">有时，当 DC/操作系统启动时，事情不会正确同步，您会得到一个关于 Ansible bootstrap 或负载平衡器超时的错误。要做的事情就是破坏，然后计划/应用再创造。第二次会成功的。</p><p id="b9da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您看到以下任一错误，这就是正在发生的情况。</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="b5d6" class="mu lh it mq b gy mv mw l mx my">Error: Error applying plan:</span><span id="38b3" class="mu lh it mq b gy mz mw l mx my">1 error occurred:<br/> * module.dcos.module.dcos-infrastructure.module.dcos-lb.module.dcos-lb-public-agents.module.public-agents.aws_lb.loadbalancer: 1 error occurred:<br/> * aws_lb.loadbalancer: timeout while waiting for state to become 'active' (last state: ‘provisioning’, timeout: 10m0s)</span></pre><p id="f0ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="lz ma mb mc gt mp mq mr ms aw mt bi"><span id="6ab1" class="mu lh it mq b gy mv mw l mx my">Error: Error applying plan:</span><span id="c788" class="mu lh it mq b gy mz mw l mx my">1 error occurred:<br/> * module.dcos.module.dcos-install.module.dcos-install.null_resource.run_ansible_from_bootstrap_node_to_install_dcos: timeout — last error: dial tcp 34.221.233.243:22: i/o timeout</span></pre><h1 id="b4a2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">数据综合症</h1><p id="fbb3" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我叫拉塞尔·朱尼。我是<a class="ae lf" href="http://datasyndrome.com" rel="noopener ugc nofollow" target="_blank"> Data Syndrome </a>的首席数据科学家，在那里我构建端到端的机器学习和可视化产品、推荐系统、线索生成系统、数据工程，并专注于<a class="ae lf" href="https://www.snorkel.org/blog/weak-supervision" rel="noopener ugc nofollow" target="_blank">弱监督学习</a>，或用更少的数据做更多的事情。我在 http://blog.datasyndrome.com<a class="ae lf" href="http://blog.datasyndrome.com" rel="noopener ugc nofollow" target="_blank">写博客</a></p><p id="c49d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我正在写一本将于明年出版的新书，书名是《T21:弱监督学习》。敬请关注更多内容！</p></div></div>    
</body>
</html>