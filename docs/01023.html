<html>
<head>
<title>Monte Carlo Tree Search in Reinforcement Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习中的蒙特卡罗树搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/monte-carlo-tree-search-in-reinforcement-learning-b97d3e743d0f?source=collection_archive---------7-----------------------#2019-02-17">https://towardsdatascience.com/monte-carlo-tree-search-in-reinforcement-learning-b97d3e743d0f?source=collection_archive---------7-----------------------#2019-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Deep Mind 的 Alpha Zero AI 的核心搜索算法的配方。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3caed6d0a4110f8056d51dd4793ca14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-F0evvZudQwAMDUb9ygC8Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://unsplash.com/photos/waAAaeC9hns" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/waAAaeC9hns</a></figcaption></figure><p id="2c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更新</strong>:学习和练习强化学习的最好方式是去 http://rl-lab.com<a class="ae ky" href="http://rl-lab.com/" rel="noopener ugc nofollow" target="_blank"/></p><blockquote class="lv lw lx"><p id="a4b8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">AlphaZero 使用通用的蒙特卡罗树搜索(MCTS)算法，而不是具有特定领域增强功能的 alpha-beta 搜索。每个搜索由一系列模拟的自我游戏组成，这些游戏从根状态根遍历树，直到到达叶子状态。(<a class="ae ky" href="https://deepmind.com/research/publications/general-reinforcement-learning-algorithm-masters-chess-shogi-and-go-through-self-play/" rel="noopener ugc nofollow" target="_blank">查看来源</a>)</p></blockquote><h1 id="8ad5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概观</h1><p id="020e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">蒙特卡罗树搜索(MCTS)算法包括四个阶段:选择、扩展、展示/模拟、反向传播。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a60018e6ca110169d0e70f3c93e2c87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*NyQqAZ6QnvkC6HeZd2cZSQ.png"/></div></figure><p id="6084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。选择<br/> </strong>算法从根节点<em class="ly"> R </em>开始，然后通过选择最佳子节点沿着树向下移动，直到到达叶节点<em class="ly"> L </em>(到目前为止没有已知的子节点)。</p><p id="fc81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。扩展<br/> </strong>如果<em class="ly"> L </em>不是一个终端节点(它不会终止游戏)那么根据当前状态(节点)的可用动作创建一个或多个子节点，然后选择这些新节点中的第一个<em class="ly"> M </em>。</p><p id="d331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。模拟<br/> </strong>从<em class="ly"> M </em>开始运行模拟卷展栏，直到找到终端状态。终端状态包含一个结果(值),该结果将在反向传播阶段向上返回。<br/> NB。卷展栏经过的状态或节点不被视为已访问。</p><p id="9454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。在模拟阶段之后，返回一个结果。从 M 到 R 的所有节点将通过将结果加到它们的值上来更新，并增加每个节点的访问计数。</strong></p><h1 id="126a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">选择和扩展</h1><p id="fce5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该算法从被认为是根的节点或状态开始，然后选择要移动到的子节点。<br/>选择基于置信上限(UCB1)公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9ed357f3a9ac706de18964de5903df3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*7z7nxY4O1cZbD91L5zz99A.png"/></div></figure><p id="a40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<strong class="lb iu"><em class="ly">【vᵢ】</em></strong>是状态 Si 的值，<strong class="lb iu"><em class="ly">【nᵢ】</em></strong>是状态 Si 的访问次数，n 是同级节点的总访问次数(或者换句话说是 Si 的父节点的访问次数)，c 是用于微调的常数。<br/>在为当前节点的每个子节点计算 UCB1 后，选择具有最高值的一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/58cfa1fadce2a0fcf03ebb343563f74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JX0DK_Wr9kdV-MihFEiaTg.png"/></div></div></figure><p id="cdca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果选定的节点是新的，这意味着它还没有被访问过，则调用 Rollout 来查找具有值的终端状态。否则，如果它被访问，则为当前节点上可用的所有动作创建子节点，移动到第一个子节点并开始卷展栏。</p><h1 id="76e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">展示或模拟</h1><p id="839f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">展示或模拟是采取随机动作的阶段，检索着陆状态，然后采取另一个随机动作，以便在新状态着陆。重复这个过程，直到到达一个终端状态，此时返回终端状态的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/15111f3311ba8f2258865e68e0760e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yePmtrpRHZsQrX-TfTbfeQ.png"/></div></div></figure><h1 id="4b0e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反向传播</h1><p id="dd25" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">反向传播获取卷展栏的值，并更新从卷展栏开始直到根节点的节点。更新包括将卷展结果添加到每个节点的当前值，并将每个节点的访问计数增加 1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/6e7137c59ae77d6be4a8b267b087564d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8vz5FnarSGj8FLfGKONtA.png"/></div></div></figure><h1 id="dd9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例子</h1><p id="5829" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面的例子展示了 MCTS 算法的所有不同阶段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/be07ae54bf3084cd4b356a492dd660f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzmbMvF1dxXqBN7c0xwKeA.png"/></div></div></figure><p id="8472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从根节点 S0 开始。我们假设它以前被访问过，所以它不是新的。所以我们需要扩大它。我们假设在这个状态下有 2 个动作(A1，A2)。<br/>我们通过添加由动作 A1、A2 产生的两个状态 S1 和 S2 来扩展该树。<br/>因为 S1 和 S2 的 UCB1 都是无穷大(因为 N1=0，N2=0)，所以我们选择先用 A1。</p><p id="59d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0e6d4bff4db443753008703cc9c21935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBLh0Do7TI8BZJTmEhYoPA.png"/></div></div></figure><p id="4859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在 S1 是新的，因为它还没有被访问过(N1 = 0)。该算法说，在这种情况下，我们应该推出，直到我们达到一个终端状态。<br/>让我们假设我们这样做了，并且找到了一个值为 20 的终端节点。我们将此值从 S1 向上传播到 S0(蓝色文本)。因此，S1 和 S0 的值都等于 20，访问次数等于 1。</p><p id="f222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">.</p><p id="21b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">.</p><p id="08b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2b041feb114253ede865d6d828bfa73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lOIeYsVBQkZR9WKY7MpSQ.png"/></div></div></figure><p id="b11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在第二次迭代中，UCB1(S1) = 20，UCB1(S2) =无穷大，所以我们采取行动 A2。<br/>我们还注意到，S2 是新的(N2=0)，所以我们推出，直到我们找到一个终端状态。<br/>我们假设终端状态的值为 10。我们将其从 S2 反向传播到 S0(蓝色文本)。最后我们得到 S2 (V2=10，N2=1)和 S0(V0 = 30，N0=2)</p><p id="585a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">.</p><p id="b9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/bb0661a3aee90dbe84dba937db23cc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gykTKQDjYEqyqnHt-8MlqA.png"/></div></div></figure><p id="2fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第三次迭代中，UCB1(S1) = 20，UCB1(S2) = 10，所以我们选择去 S1。因为现在它不再是新的了(N1 &gt; 0)，我们通过添加可用的动作和它们的登陆状态来扩展它。我们假设有两个动作 A3、A4，分别对应于 S3 和 S4。<br/>由于 S3 和 S4 都有 UCB1 infinity，我们通过跟随 actin A3 选择 S3。S3 是新的，所以我们推出，直到我们找到值为 15 的终端状态。我们将这个值反向传播到节点 S3，S1，S0。可以在蓝色文本中看到更新后的值。</p><h1 id="c1ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">优势</h1><ul class=""><li id="1a0e" class="ni nj it lb b lc mu lf mv li nk lm nl lq nm lu nn no np nq bi translated">MCTS 不需要任何关于给定领域的知识。除了游戏规则和条件，不需要知道任何战略或战术，这使得它可以在其他游戏中重复使用。</li><li id="e407" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">不对称</strong> <br/> MCTS 更频繁地访问更有趣的节点，并将其搜索时间集中在树的更相关的部分。</li><li id="61c1" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">随时</strong> <br/>可以随时停止算法，返回当前最佳估计值。</li><li id="9d92" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">优雅</strong>优雅<br/>算法不复杂，易于实现。</li></ul><h1 id="8012" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不足之处</h1><ul class=""><li id="c7d4" class="ni nj it lb b lc mu lf mv li nk lm nl lq nm lu nn no np nq bi translated"><strong class="lb iu">游戏实力</strong> <br/> MCTS，就其基本形态而言，即使是中等复杂程度的游戏，也无法在合理的时间内找到合理的走法。</li><li id="c91f" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">速度</strong></li></ul><h1 id="827b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">丰富</h1><ul class=""><li id="23b3" class="ni nj it lb b lc mu lf mv li nk lm nl lq nm lu nn no np nq bi translated">特定于当前游戏的领域知识可以帮助过滤掉不太可能的移动或者产生更类似于人类对手之间发生的<em class="ly">滚动</em>。这有利于展示比随机模拟更真实的结果，并且节点需要更少的迭代来产生真实的奖励值。</li><li id="6424" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">与领域无关<br/> </strong>与领域无关的增强并不将实现绑定到特定的领域，保持了通用性，因此是该领域大多数当前工作的焦点。</li></ul></div></div>    
</body>
</html>