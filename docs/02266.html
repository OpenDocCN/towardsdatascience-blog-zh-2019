<html>
<head>
<title>Variational Autoencoder In Finance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">金融中的变分自动编码器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/variational-autoencoder-in-finance-53ee5eb9ed98?source=collection_archive---------7-----------------------#2019-04-15">https://towardsdatascience.com/variational-autoencoder-in-finance-53ee5eb9ed98?source=collection_archive---------7-----------------------#2019-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe14" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">金融时间序列的降维与指数构建</h2></div><p id="0ff6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文通过 Keras 和 Python 探讨了使用可变自动编码器来降低金融时间序列的维数。我们将进一步检测不同市场中金融工具之间的相似性，并将使用获得的结果来构建自定义指数。</p><p id="847c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">免责声明:</strong>本文介绍的研究来自我们在多伦多大学继续教育学院的<a class="ae lb" href="https://learn.utoronto.ca/programs-courses/courses/3546-deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习课程</a>的 2019 年冬季学期项目。这是与<a class="ae lb" href="https://www.linkedin.com/in/humbertors" rel="noopener ugc nofollow" target="_blank">温贝托·里贝罗·德·索萨</a>合作完成的。概念和想法是我们自己的。我们绝不代表我们现在或以前的雇主。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="a59a" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">第 1 部分:使用变分自动编码器降维</h2><p id="ac1b" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在本节中，我们将讨论:</p><ul class=""><li id="be83" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">创建几何移动平均数据集</li><li id="4f65" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">用随机模拟扩充数据</li><li id="dfd7" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">建立变分自动编码器模型</li><li id="83cd" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">获得预测。</li></ul><p id="6067" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">创建几何移动平均数据集</strong></p><p id="4119" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了比较不同价格范围的时间序列，我们选择计算收益的几何移动平均时间序列，定义如下:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/3cdb36aecaab02e76d6a51d7765e5764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*ySf1S92Gz5_9fejH1Qdl7A.png"/></div></figure><p id="d3d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择了<strong class="kh ir"> d=5 </strong>，因为它代表了 5 个工作日的典型交易周。</p><p id="ef43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文使用的数据集包含 2016 年 1 月 4 日至 2019 年 3 月 1 日期间的 423 个几何移动平均时间序列。</p><p id="ed6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读者可以按照<a class="ae lb" href="https://github.com/MarieImokoyende/vae-dimRedFinance/blob/master/3546%20Deep%20Learning%20Project%20-%20Data%20Treatment.ipynb" rel="noopener ugc nofollow" target="_blank">数据处理笔记本</a>中描述的步骤构建自己的数据集。应该和这个差不多:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/987d1f760a877515918b1dc973ec674f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flzgTrvQtJiuD-cfpyBbIQ.png"/></div></div></figure><p id="fdaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以通过绘制一些样本股票价格时间序列及其几何移动平均线来验证结果:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/345daeeb18a8b6aeabc78baed8bf5546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ULtacWLxbysYlxekokA8A.png"/></div></div></figure><p id="a591" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，可以将刚刚构建的数据帧分成两个长度相等的时间段，只将第一个时间段的数据帧进行置换。周期 1 从 2016 年 1 月 12 日到 2017 年 8 月 4 日。周期 2，从 2017 年 8 月 7 日至 2019 年 3 月 1 日。</p><p id="038d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将仅使用周期 1 的数据来获得预测。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="f4f4" class="lj lk iq nk b gy no np l nq nr"># Divide in two<br/>geoMA_5d_stocks_p1 = geoMA_5d_stocks.head(int(len(geoMA_5d_stocks)/2))<br/>geoMA_5d_stocks_p2 = geoMA_5d_stocks.tail(int(len(geoMA_5d_stocks)/2))</span><span id="675e" class="lj lk iq nk b gy ns np l nq nr"># Transpose the dataframe for period 1<br/>geoMA_5d_stocks_p1_T = geoMA_5d_stocks_p1.T</span></pre><p id="7efd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们转置数据帧，以便每行代表给定股票的时间序列:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nt"><img src="../Images/366b8d31ca50dc5d311426c07fefc0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nxie3BBk7Rp1srTahyKOZg.png"/></div></div></figure><p id="dcb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">用随机模拟增加数据</strong></p><p id="6f3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用随机模拟来生成合成的几何移动平均线。目标不是精确地模拟回报，而是获得与真实数据行为相似的曲线。通过仅用模拟曲线训练模型，我们可以保留真实数据来获得预测。</p><p id="e395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用几何布朗运动生成合成曲线。我们遵循以下步骤:</p><ul class=""><li id="47ab" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">使用第一期数据框架，随机选择 100 个分笔成交点</li><li id="02ed" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">对于每个选定的报价器，计算一个对数回报向量，如下所示:</li></ul><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9cb1d1f20867dc963750dd6566a77b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*gMXbZsEthCynJR4uv5fPzQ.png"/></div></figure><ul class=""><li id="d0b2" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">然后，对于选择的每个股票，我们将生成 100 条路径，这样:</li></ul><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nv"><img src="../Images/ca3eaf1bea86c3ed6ec9b1cddd2d856e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCOOkI-UDeuF_ed8irxH2A.png"/></div></div></figure><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a753" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是模拟曲线和真实曲线的示例:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1ddd3880ccf8164b13f1ed7f73f04d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*vCdx_BQPcLt4dzpo2WlZ-Q.png"/></div></figure><p id="f743" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将 423 个时间序列的数据集扩展为 100*100 = 10，000 个与股票数据集相似(但不相等)的新时间序列。</p><p id="1644" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将允许我们保留实际的股票数据集用于预测，甚至不必使用它进行验证。</p><p id="62bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在建立 VAE 模型之前，创建训练集和测试集(使用 80%-20%的比率):</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="203a" class="lj lk iq nk b gy no np l nq nr"># Shuffle the generated curves<br/>shuffled_array = np.random.permutation(sim_paths_matrix)</span><span id="e6c6" class="lj lk iq nk b gy ns np l nq nr"># Split the simulated time series into a training and test set<br/>x_train = shuffled_array[0:8000]<br/>x_test = shuffled_array[8000:]</span></pre><p id="ba26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读者还应该注意，在训练模型之前，不需要删除时间序列的季节性和趋势。</p><p id="fbd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">建立变分自动编码器(VAE)模型</strong></p><p id="779f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用变分自动编码器将具有 388 个项目的时间序列向量的维度降低到二维点。</p><p id="b1f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自动编码器是用于压缩数据的无监督算法。它们由一个编码器、一个解码器和一个损失函数构成，以测量压缩和解压缩数据表示之间的信息损失。</p><p id="f177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的目标不是再写一篇关于 autoencoder 的文章。不熟悉自动编码器的读者可以在<a class="ae lb" href="https://blog.keras.io/building-autoencoders-in-keras.html" rel="noopener ugc nofollow" target="_blank"> Keras 博客</a>和<a class="ae lb" href="https://arxiv.org/abs/1312.6114" rel="noopener ugc nofollow" target="_blank"> <em class="nz">自动编码变分贝叶斯</em>论文</a>上阅读更多，作者是 Diederik Kingma 和 Max Welling。</p><p id="9117" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用一个简单的 VAE 架构，类似于 Keras 博客<a class="ae lb" href="https://blog.keras.io/building-autoencoders-in-keras.html" rel="noopener ugc nofollow" target="_blank">中描述的架构。</a></p><p id="6165" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码器型号具有:</p><ol class=""><li id="9955" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la oa mn mo mp bi translated">一个长度为 388 的输入向量</li><li id="6530" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated">一个长度为 300 的中间层，具有整流线性单元(ReLu)激活功能</li><li id="3ad8" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated">一个二维编码器。</li></ol><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/33b91407641e8251e3d79c6196657449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*owBoHTwS4hf6ppnLnKxFYQ.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Encoder Model Summary</figcaption></figure><p id="6bc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解码后的模型具有:</p><ol class=""><li id="dd23" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la oa mn mo mp bi translated">一个二维输入向量(从潜在变量中取样)</li><li id="8412" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated">一个长度为 300 的中间层，具有整流线性单元(ReLu)激活功能</li><li id="604d" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated">具有 sigmoid 激活函数的长度为 388 的解码向量。</li></ol><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dff3c143f0e1194a770dec6656bedec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*q-vfTpx2I0I3ZXwcV6BbsA.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Decoder Model Summary</figcaption></figure><p id="4854" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下代码改编自 Keras team Github 上的<a class="ae lb" href="https://github.com/keras-team/keras/blob/master/examples/variational_autoencoder.py" rel="noopener ugc nofollow" target="_blank">variable _ auto encoder . py</a>。它用于构建和训练 VAE 模型。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c5a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">训练后，我们绘制训练和验证损失曲线:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/92e99a52c20bace7b43fc17a6a206fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*2uCti-QB2mRHPimS9qk_3Q.png"/></div></figure><p id="0e11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">获得预测</strong></p><p id="b6d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将只使用编码器来获得预测。我们将使用一个实值矩阵，包括股票数据集和一个或多个感兴趣的时间序列。</p><p id="22c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的项目中，我们针对在另一个国家以不同货币上市的近月期货合约测试了一个股票数据集。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="0519" class="lj lk iq nk b gy no np l nq nr"># Obtaining the predictions:<br/>encoded_p1 = encoder.predict(matrix_to_test_p1, batch_size=batch_size)</span><span id="d20c" class="lj lk iq nk b gy ns np l nq nr"># Convert the predictions into a dataframe<br/>encoded_p1_df = pd.DataFrame(data = encoded_p1, columns = ['x','y'], index = dataframe_to_test_p1.T.index)</span></pre><p id="9af4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获得了以下结果:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ee7ba000414e57cdb545b4cdfb532d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*TzKN3rvmQUw8C7nCzo61mA.png"/></div></figure><p id="51fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在绘制结果之前，我们必须:</p><ol class=""><li id="af72" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la oa mn mo mp bi translated">计算期货合约点和数据框架中所有其他股票之间的距离</li><li id="fcc8" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated">选择最接近期货合约的 50 品脱</li></ol><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="a0fc" class="lj lk iq nk b gy no np l nq nr"># Calculate the distances between the futures contract point and all other points in the stocks dataset</span><span id="aca8" class="lj lk iq nk b gy ns np l nq nr">ref_point = encoded_p1_df.loc['Futures'].values<br/>encoded_p1_df['Distance'] = scipy.spatial.distance.cdist([ref_point], encoded_p1_df, metric='euclidean')[0]</span><span id="ac14" class="lj lk iq nk b gy ns np l nq nr"># Get the 50 closest points:<br/>closest_points = encoded_p1_df.sort_values('Distance', ascending = True)<br/>closest_points_top50 = closest_points.head(51)[1:] #We take head(51), because the Futures reference point is the first entry<br/>closest_points_top50['Ticker'] = closest_points_top50.index</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cd619ac4aaa3508ce8ff034ca0b1a4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*iU3IJ7kTURownFNRkvPslQ.png"/></div></figure><p id="aa02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以绘制所获得的结果，以直观显示最接近的 50 只股票:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ok"><img src="../Images/7544b8e68f130b5a36a58b4fc7036b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxBrWNfsPnJy23SoX0DpEg.png"/></div></div></figure><p id="8e99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经对另一个国家上市的期货合约进行了分析。然而，对于来自同一交易所的股票，可以遵循第 1 部分中的相同步骤。</p><h2 id="dec7" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">第 2 部分:索引构建</h2><p id="34ca" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">让我们使用第 1 部分中获得的结果来创建一个索引。</p><p id="0227" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于 VAE 模型的随机性，我们不会在每次运行中获得相同的前 50 名股票的精确列表。为了获得最接近的 50 个点的公平表示，我们将运行 VAE 模型 10 次(每次运行时重新初始化和重新训练它)。然后，我们将采用每次运行中找到的 50 个最近点来创建长度为 500 的数据帧<strong class="kh ir"><em class="nz">closest _ points _ df</em></strong>。</p><p id="18f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦建立了<strong class="kh ir"> <em class="nz">最近点 _df </em> </strong>数据帧:</p><ol class=""><li id="3124" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la oa mn mo mp bi translated">按距离对点进行排序</li><li id="32c2" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated">丢弃重复的代码，只保留第一个出现的代码</li></ol><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="39fc" class="lj lk iq nk b gy no np l nq nr">sorted_by_dist = results_df.sort_values('Distance', ascending = True)</span><span id="33cf" class="lj lk iq nk b gy ns np l nq nr">sorted_by_dist.drop_duplicates(subset='Ticker', keep='first', inplace = True)</span></pre><p id="ac5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">删除重复的点后，我们将只保留 50 个最接近的点。</p><p id="4b9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">计算每只股票的权重</strong></p><p id="429e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在指数构建中，股票权重是通过使用不同的方法计算的，如市场资本总额或股票价格。</p><p id="fba5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们将计算每只股票的权重，这样最接近期货合约点的点将比远离期货合约点的点获得更高的权重。</p><p id="f97a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">对于非匿名的股票数据，在计算股票权重之前过滤</strong> <strong class="kh ir">获得的结果非常重要。</strong>离群值应剔除，市值范围应细化。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="832a" class="lj lk iq nk b gy no np l nq nr"># Calculate the weights<br/>top50 = sorted_by_dist.head(50).copy() # Keep the closest 50 points<br/>top50['Weight'] = (1/top50['Distance'])/np.sum(1/top50['Distance'])</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d949ae0e5c37f8f5c9cf47448f4a90f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*0j-zPrnignsoOuAehssdCw.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Sample of weights calculated</figcaption></figure><p id="89c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">计算每只股票的股数</strong></p><p id="2e11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算完权重后，我们计算每只股票在我们的自定义指数中的股份数。我们需要:</p><ul class=""><li id="35fd" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">获取每只股票在 2016 年 1 月 4 日(周期 1 的第一天)的价格</li><li id="bf75" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">定义净资产金额</li><li id="be14" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">计算股份的数量</li></ul><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="9bf7" class="lj lk iq nk b gy no np l nq nr">#Get the stock prices on January 4th 2016</span><span id="46ee" class="lj lk iq nk b gy ns np l nq nr">jan4_2016_stockPrice = np.zeros(len(stock_data_top50.columns))<br/>for i in range(len(jan4_2016_stockPrice)):<br/>  if stock_data_top50.columns[i] == top50['Ticker'].iloc[i]:<br/>    jan4_2016_stockPrice[i] = stock_data_top50[stock_data_top50.columns[i]].iloc[0]</span><span id="87a0" class="lj lk iq nk b gy ns np l nq nr">top50['Price Jan4_2016'] = jan4_2016_stockPrice</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi om"><img src="../Images/dbba2e3929b42f7d4970f9c0ff091ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*1F4nMyZXu_8qjDqFdPrrhg.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">We add a column for the stock prices on January 4th, 2016</figcaption></figure><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="efc7" class="lj lk iq nk b gy no np l nq nr"># We compute the number of shares</span><span id="b4bd" class="lj lk iq nk b gy ns np l nq nr">net_assets = 10000000 # We chose net assets = 10 million (in the currency of the stock market)</span><span id="611c" class="lj lk iq nk b gy ns np l nq nr">numShares = np.zeros(len(stock_data_top50.columns))<br/>for i in range(len(jan4_2016_stockPrice)):<br/>  if stock_data_top50.columns[i] == top50['Ticker'].iloc[i]:<br/>    numShares[i] = int(net_assets*top50['Weight'].iloc[i]/top50['Price Jan4_2016'].iloc[i])<br/>    <br/>top50['numShares'] = numShares</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi on"><img src="../Images/74c3cd132280b0d3f5fe6e2e2794e5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*CMEUiZrfDP1EKYjHyRyzcg.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">We add a column for the number of shares</figcaption></figure><p id="4275" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">构建索引</strong></p><p id="f8e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了构建该指数，我们将使用<a class="ae lb" href="https://en.wikipedia.org/wiki/Price_index#Paasche_and_Laspeyres_price_indices" rel="noopener ugc nofollow" target="_blank">拉斯派尔斯指数</a>计算如下:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/069a9473e1d8542199fd00fb5e6b5863.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*w3InDrjDWlhbFDvIuRzH9w.png"/></div></figure><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="45a9" class="lj lk iq nk b gy no np l nq nr">stock_index = np.zeros(len(stock_data_top50))</span><span id="5055" class="lj lk iq nk b gy ns np l nq nr">for i in range(len(stock_data_top50)):<br/>  sum_num = 0<br/>  sum_denom = 0<br/>  for j in range(len(stock_data_top50.columns)):<br/>    sum_num = sum_num + stock_data_top50[stock_data_top50.columns[j]].iloc[i]*top50['numShares'].iloc[j]<br/>    sum_denom = sum_denom + stock_data_top50[stock_data_top50.columns[j]].iloc[0]*top50['numShares'].iloc[j]<br/>  stock_index[i] = sum_num /sum_denom</span><span id="e40f" class="lj lk iq nk b gy ns np l nq nr"># We arbitrarily start the index at 100<br/>stock_index_df = pd.DataFrame(stock_index*100, columns =  ['stock_index'], index = stock_data_top50.index)</span></pre><p id="6d61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们绘制了自定义索引:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi op"><img src="../Images/94c1faa802b8304012401843dcde23b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwgjE-ekUf_GZ40jaRF14w.png"/></div></div></figure><p id="45fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">比较我们的定制指数和期货时间序列</strong></p><p id="231e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须缩放期货价格数据，以便将其绘制在与自定义指数相同的图表中。为此，我们必须:</p><ul class=""><li id="e655" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">计算期货价格数据的每日百分比变化</li><li id="df45" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">设置 S_0 = 100</li></ul><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="6e43" class="lj lk iq nk b gy no np l nq nr"># Calculate the percentage change<br/>futures_data_stock_data_pct_change = futures_data_stock_data.pct_change()<br/>futures_data_stock_data_pct_change.dropna(inplace = True)</span><span id="cb3b" class="lj lk iq nk b gy ns np l nq nr"># Scale the time series<br/>futures_theoretical = np.zeros(len(stock_index_df))<br/>futures_theoretical[0] = stock_index_df.iloc[0]<br/>for i in range(len(futures_theoretical)-1):<br/>  futures_theoretical[i+1] = (1+futures_data_stock_data_pct_change.iloc[i])*futures_theoretical[i]</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b9b069e2022c0a61be52539bb02951dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*e_dJY5MNVrB_vPfHS8sajQ.png"/></div></figure><p id="f7cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在在同一张图中绘制两条曲线:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi op"><img src="../Images/456fc6c17b4033ac79dc63bec571a9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alKWthhVU6oN5-UKDPxZaw.png"/></div></div></figure><p id="bbfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的指数除了 2018 年下半年之外，大部分趋势与参考期货时间序列相同。因为我们使用匿名数据，我们没有过滤股票的异常值和市值限制。此外，在观察到的两个时间段内没有重新平衡，我们忽略了分布。</p><p id="1f00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果识别出报价器并剔除异常值，自定义指数完全有可能跑赢期货指数。</p><p id="cc91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们鼓励我们的读者利用在线免费的 GPU 实例来创建他们自己的索引。这对我们来说是一个有趣的实验，我们发现了一些有趣的股票模式。</p><p id="7239" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意下载 GitHub 上的两款笔记本:</p><ol class=""><li id="b31f" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la oa mn mo mp bi translated"><a class="ae lb" href="https://github.com/MarieImokoyende/vae-dimRedFinance/blob/master/3546%20Deep%20Learning%20Project%20-%20Data%20Treatment.ipynb" rel="noopener ugc nofollow" target="_blank"> 3546 深度学习项目—数据处理. ipynb </a></li><li id="9f53" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la oa mn mo mp bi translated"><a class="ae lb" href="https://github.com/MarieImokoyende/vae-dimRedFinance/blob/master/3546%20Deep%20Learning%20Project%20-%20VAE%20_%20Index%20Construction.ipynb" rel="noopener ugc nofollow" target="_blank"> 3546 深度学习项目— VAE &amp;索引构建. ipynb </a></li></ol><p id="1839" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论</strong></p><p id="4d4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用可变自动编码器可以加快外国股票市场新指数的开发，即使分析师对它们并不熟悉。此外，可以创建利基指数或投资组合来满足客户的兴趣。</p><p id="4105" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这种方法可以用来创建 ETF，但我们相信它也可以为全球的直接指数和 Robo Advisors 公司创造新的投资机会。</p></div></div>    
</body>
</html>