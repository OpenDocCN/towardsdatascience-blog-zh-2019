<html>
<head>
<title>ML Design Pattern #5: Repeatable sampling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML 设计模式#5:可重复采样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ml-design-pattern-5-repeatable-sampling-c0ccb2889f39?source=collection_archive---------10-----------------------#2019-11-08">https://towardsdatascience.com/ml-design-pattern-5-repeatable-sampling-c0ccb2889f39?source=collection_archive---------10-----------------------#2019-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="562d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用分布良好的列将数据分为训练/有效/测试</h2></div><p id="c379" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给 ML 工程师的一系列偶然的设计模式。 <a class="ae lc" href="https://medium.com/@lakshmanok/machine-learning-design-patterns-58e6ecb013d7" rel="noopener"> <em class="lb">完整列表在此。</em> </a></p><p id="84a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多机器学习教程会建议您将数据随机分成训练、验证和测试数据集:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="ed6f" class="lm ln iq li b gy lo lp l lq lr">df = pd.DataFrame(...)</span><span id="8cf1" class="lm ln iq li b gy ls lp l lq lr">rnd = np.random.rand(len(df))<br/>train = df[ rnd &lt; 0.8  ]<br/>valid = df[ rnd &gt;= 0.8 &amp; rnd &lt; 0.9 ]<br/>test  = df[ rnd &gt;= 0.9 ]</span></pre><p id="4a30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是，这在许多现实世界的情况下都失败了。原因是这些行很少是独立的。例如，如果您正在训练一个预测航班延误的模型，则同一天航班的到达延误将彼此高度相关。这叫做<em class="lb">漏</em>，是做机器学习时要避免的重要问题。</p><figure class="ld le lf lg gt lu gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/ef5381de72c00d1f5d44c1181817a0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*DyV7JiLL2yLqu60I8ZmtLA.jpeg"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Use the Farm Fingerprint hashing algorithm on a well-distributed column to split your data into train/valid/test</figcaption></figure><p id="047e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案是基于日期列拆分数据集:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="50ef" class="lm ln iq li b gy lo lp l lq lr">SELECT<br/>  airline,<br/>  departure_airport,<br/>  departure_schedule,<br/>  arrival_airport,<br/>  arrival_delay<br/>FROM<br/>  `bigquery-samples`.airline_ontime_data.flights<br/>WHERE<br/>  ABS(MOD(FARM_FINGERPRINT(date), 10)) &lt; 8 -- 80% for TRAIN</span></pre><p id="07ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了解决最初的问题(数据泄漏)，这还为您提供了可重复性:</p><ol class=""><li id="fc17" class="mb mc iq kh b ki kj kl km ko md ks me kw mf la mg mh mi mj bi translated"><a class="ae lc" href="https://github.com/google/farmhash" rel="noopener ugc nofollow" target="_blank"> FARM_FINGERPRINT </a>是一种开源哈希算法，在 C++(因此:Java 或 Python)和 BigQuery SQL 中实现一致。</li><li id="8af5" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">任何给定日期的所有航班都属于同一个分段——列车、有效或测试。这是可重复的，与随机种子无关。</li></ol><h2 id="5752" class="lm ln iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">选择拆分列</h2><p id="ad47" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">如何选择要拆分的列？日期列必须具有几个特征，以便我们能够将其用作拆分列:</p><ol class=""><li id="4268" class="mb mc iq kh b ki kj kl km ko md ks me kw mf la mg mh mi mj bi translated">相同日期的行往往是相关的，这也是我们希望确保相同日期的所有行都在相同的拆分中的主要原因。</li><li id="139f" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">日期不是模型的输入(从日期中提取的要素(如 dayofweek 或 hourofday)可以是输入，但不能使用实际输入进行分割，因为经过训练的模型不会看到 20%的可能输入值)。</li><li id="c66a" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">必须有足够的日期值。因为您正在计算散列值并寻找相对于 10 的模，所以您至少需要 10 个唯一的散列值。当然，你拥有的独特价值观越多越好。为了安全起见，取模的分母为 3–5 倍，因此在这种情况下，您需要 50 个或更多的唯一日期。</li><li id="a231" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">标签必须在日期之间分布均匀。如果结果是所有的延迟都发生在 1 月 1 日和一年中的其他时间，没有延迟，这将不起作用，因为分割的数据集将是倾斜的。为了安全起见，请查看一个图表，并确保所有三个拆分都具有相似的标签分布(根据出发延误或其他输入值)。您可以使用<a class="ae lc" href="http://www.physics.csbsju.edu/stats/KS-test.html" rel="noopener ugc nofollow" target="_blank"> Kolomogorov-Smirnov 测试</a>来实现自动化。</li></ol><h2 id="5533" class="lm ln iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">变体 1:单一查询</h2><p id="4b5e" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">您不需要三个单独的查询来生成训练、验证和测试分割。您可以在一个查询中完成，如下所示:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="29e7" class="lm ln iq li b gy lo lp l lq lr">CREATE OR REPLACE TABLE mydataset.mytable AS</span><span id="586b" class="lm ln iq li b gy ls lp l lq lr">SELECT<br/>  airline,<br/>  departure_airport,<br/>  departure_schedule,<br/>  arrival_airport,<br/>  arrival_delay,<br/>  <strong class="li ir">CASE(ABS(MOD(FARM_FINGERPRINT(date), 10)))<br/>      WHEN 9 THEN 'test'<br/>      WHEN 8 THEN 'validation'<br/>      ELSE 'training' END AS split_col</strong><br/>FROM<br/>  `bigquery-samples`.airline_ontime_data.flights</span></pre><figure class="ld le lf lg gt lu gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/153ad829e2d2a56cc6e480572b551ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*bHrMnhlAIT8i85S87imICA.png"/></div></figure><h2 id="ecab" class="lm ln iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">变体 2:随机拆分</h2><p id="64f3" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">如果你想要一个随机的分裂，但只需要可重复性呢？在这种情况下，您可以简单地散列行数据本身。这里有一个简单的方法:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="084a" class="lm ln iq li b gy lo lp l lq lr">SELECT<br/>  airline,<br/>  departure_airport,<br/>  departure_schedule,<br/>  arrival_airport,<br/>  arrival_delay<br/>FROM<br/>  `bigquery-samples`.airline_ontime_data.flights <strong class="li ir">f</strong><br/>WHERE<br/>  ABS(MOD(FARM_FINGERPRINT(<strong class="li ir">TO_JSON_STRING(f))</strong>, 10)) &lt; 8</span></pre><p id="1f5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，如果您有重复的行，那么它们将总是以相同的拆分结束。如果这是一个问题，请在选择查询中添加一个唯一 id 列。</p></div></div>    
</body>
</html>