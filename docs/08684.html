<html>
<head>
<title>How to Replace Values by Index in a Tensor with TensorFlow-2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 TensorFlow-2.0 替换张量中的索引值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-replace-values-by-index-in-a-tensor-with-tensorflow-2-0-510994fe6c5f?source=collection_archive---------6-----------------------#2019-11-22">https://towardsdatascience.com/how-to-replace-values-by-index-in-a-tensor-with-tensorflow-2-0-510994fe6c5f?source=collection_archive---------6-----------------------#2019-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NumPy 中一个看似简单的操作如何在一些不幸的情况下变成 TensorFlow 的噩梦</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f4a70cd9f47d53fc92af01a2a7857aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78KMHVVecnTzkLbN7xW0tQ.png"/></div></div></figure><p id="636f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有没有尝试过根据数组的索引只替换数组的某些值？</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="9f87" class="lv lw it lr b gy lx ly l lz ma">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; a = np.array( [1,2,3,4,5] )<br/>&gt;&gt;&gt; print(a)</span><span id="d33f" class="lv lw it lr b gy mb ly l lz ma">[1 2 3 4 5]</span><span id="0226" class="lv lw it lr b gy mb ly l lz ma">&gt;&gt;&gt; i = [ 0, 1, 3 ]<br/>&gt;&gt;&gt; a[i] = -1<br/>&gt;&gt;&gt; print(a)</span><span id="1b01" class="lv lw it lr b gy mb ly l lz ma">[-1 -1  3 -1  5]</span></pre><p id="397f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个更复杂的用例可能是，例如，将某个阈值以上的所有值削波到最大值:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="1caa" class="lv lw it lr b gy lx ly l lz ma">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; a = np.array( [1,2,3,4,5] )<br/>&gt;&gt;&gt; print(a)</span><span id="813b" class="lv lw it lr b gy mb ly l lz ma">[1 2 3 4 5]</span><span id="4e96" class="lv lw it lr b gy mb ly l lz ma">&gt;&gt;&gt; a_max = 3<br/>&gt;&gt;&gt; i = np.where( a &gt; a_max)<br/>&gt;&gt;&gt; a[i] = a_max<br/>&gt;&gt;&gt; print(a)</span><span id="e0c2" class="lv lw it lr b gy mb ly l lz ma">[ 1  2  3  3  3]</span></pre><p id="23f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，如果数组由一个<strong class="kw iu">张量</strong>表示，这种明显简单的操作在 TensorFlow 中是不允许的(但如果数组是一个<a class="ae mc" href="https://www.tensorflow.org/api_docs/python/tf/Variable" rel="noopener ugc nofollow" target="_blank"> tf，这种操作是允许的。变量</a>对象)。如果您尝试，最有可能的结果是这样的错误:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="2370" class="lv lw it lr b gy lx ly l lz ma">AttributeError: 'tensorflow.python.framework.ops.EagerTensor' object has no attribute 'assign'</span></pre><p id="c77d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，我必须承认，我花了很长时间才想出如何解决这个经常出现的问题。在 StackOverflow 上有很多问题，人们在那里讨论同一个问题(例如，见<a class="ae mc" href="https://stackoverflow.com/questions/42883415/how-to-replace-a-value-within-a-tensor-by-indices?noredirect=1&amp;lq=1" rel="noopener ugc nofollow" target="_blank">这个</a>)。我认为从 TensorFlow 操作的角度来看，最简单的方法是过滤希望<em class="md">将</em>保留在一个向量中的元素，创建另一个向量，用希望替换的屏蔽值来“填充空白”(<em class="md">例如</em>零、无穷大、一些其他默认值)，最后给出两者之和的结果。</p><p id="f621" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在这里给出一个例子来过滤一个向量的前 k 个元素，但是这个过程是非常通用的，包括以下步骤:</p><ol class=""><li id="9dea" class="me mf it kw b kx ky la lb ld mg lh mh ll mi lp mj mk ml mm bi translated">确定要删除的索引。通常，它们由布尔值向量表示，如<strong class="kw iu">【真、假、假、…、真】</strong></li><li id="2390" class="me mf it kw b kx mn la mo ld mp lh mq ll mr lp mj mk ml mm bi translated">将这个向量转换成包含实际索引的两个数组(<strong class="kw iu"> idx_keep </strong>，<strong class="kw iu"> idx_replace </strong>)。这可以用很多方法来实现，但是我相信使用<strong class="kw iu"> tf.where </strong>是最简洁的方法。</li><li id="c76e" class="me mf it kw b kx mn la mo ld mp lh mq ll mr lp mj mk ml mm bi translated">用要替换的值创建一个向量。在这个例子中，新值将是<em class="md"> -inf </em>，复制<em class="md"> N </em>次，其中<em class="md"> N </em> =要替换的元素的数量= <strong class="kw iu"> len(idx_replace) </strong></li><li id="48d9" class="me mf it kw b kx mn la mo ld mp lh mq ll mr lp mj mk ml mm bi translated">用要保留的值创建一个向量。我通过使用函数<strong class="kw iu"> tf.gather( a，idx_keep ) </strong>来完成这个任务，这个函数几乎相当于类似于<strong class="kw iu"> a[[0，1，3]] </strong>的东西</li><li id="5e05" class="me mf it kw b kx mn la mo ld mp lh mq ll mr lp mj mk ml mm bi translated">创建上面两个集合的稀疏向量。恼人的部分是稀疏向量的索引必须是 2D，即使只有一维。我做的方法是创建零向量，然后我把它们和索引向量“堆叠”在一起。</li><li id="cc59" class="me mf it kw b kx mn la mo ld mp lh mq ll mr lp mj mk ml mm bi translated">将两个稀疏向量转换为密集向量，并将它们相加。</li><li id="45b2" class="me mf it kw b kx mn la mo ld mp lh mq ll mr lp mj mk ml mm bi translated">返回结果。</li></ol><p id="b780" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8d6ed38f5a0b020b078bee0a30f01808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*NiyWVV7V6OnwmNhRDxrbCw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">A graphical representation of the workflow</figcaption></figure><p id="a76f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不可否认，至少对于一些特定的情况，比如上面描述的裁剪，存在一个基于三参数版本的<code class="fe mz na nb lr b">tf.where</code>的更快的解决方案:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="3792" class="lv lw it lr b gy lx ly l lz ma">result = tf.where(condition, x, y)</span></pre><p id="518a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">返回的张量包含条件为<code class="fe mz na nb lr b">True</code>的<code class="fe mz na nb lr b">x</code>元素和条件为<code class="fe mz na nb lr b">False</code>的<code class="fe mz na nb lr b">y</code>元素。因此，在我们的例子中，上述函数可以简化为:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="ead9" class="lv lw it lr b gy lx ly l lz ma">a = tf.where(tf.less_equal(a, a_max), a, a_max)</span></pre><p id="eadf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者更明确地说:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="7d9c" class="lv lw it lr b gy lx ly l lz ma">def top_k_filtering(logits, top_k=5):<br/>   "Set values less than the k'th largest to -Inf."<br/>   kth_largest = tf.math.top_k(logits, top_k)[0][-1]<br/>   return tf.where(logits &lt; kth_largest, -Inf, logits)</span></pre><p id="5a85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">跟 TensorFlow 玩得开心！</p></div></div>    
</body>
</html>