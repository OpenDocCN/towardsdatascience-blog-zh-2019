<html>
<head>
<title>Passing Data Between React Components — Parent, Children, Siblings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 组件(父组件、子组件、兄弟组件)之间传递数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/passing-data-between-react-components-parent-children-siblings-a64f89e24ecf?source=collection_archive---------1-----------------------#2019-05-25">https://towardsdatascience.com/passing-data-between-react-components-parent-children-siblings-a64f89e24ecf?source=collection_archive---------1-----------------------#2019-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c91cf9a0601d31c0613f9cd32ee239a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WA_9JsyqFkge2HwYKcdJQw.png"/></div></div></figure><p id="8657" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React 是由 T2·脸书创建的一个 JavaScript 库。React 中的数据处理可能有点棘手，但并没有看上去那么复杂。我目前在 React 中编译了三种数据处理方法</p><ol class=""><li id="6261" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">从父母到孩子使用道具</li><li id="da23" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">使用回调从子进程到父进程</li><li id="61d2" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">兄弟姐妹之间:<br/>(一)结合以上两种方法<br/>(二)使用 Redux <br/>(三)使用 React 的上下文 API</li></ol><p id="f2bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个博客主要包含了这些概念的实现的汇编，这对于任何试图一目了然地掌握事物的初学者来说肯定是有益的。</p><h1 id="4e6d" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">从父母到孩子使用道具</strong></h1><p id="a4a1" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">让我们考虑这样的目录结构，即父组件在应用程序中呈现子组件。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="759b" class="mz lo it mv b gy na nb l nc nd">App<br/>└── Parent<br/>    ├── Child1<br/>    └── Child2</span></pre><p id="1a8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是 React 中最简单的数据流方向，也是最基本的方向。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7362" class="mz lo it mv b gy na nb l nc nd">class Parent extends React.Component {</span><span id="4d06" class="mz lo it mv b gy ne nb l nc nd">state = { data : "Hello World" } <br/>render() {<br/>        <br/>        return (<br/>            &lt;div&gt;<br/>                 &lt;Child1/&gt;            //no data to send             <br/>                 &lt;Child2 dataFromParent = {this.state.data} /&gt;<br/>            &lt;/div&gt;<br/>        );</span><span id="fc96" class="mz lo it mv b gy ne nb l nc nd">    }<br/>}<br/>//It is no compulsion to use the data to send as a state, simple vars or const variables could also be used to send data from Parent to Child.</span></pre><p id="5edf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只需使用 this.props.dataFromParent(只是一个用于发送 props 的变量)来访问从父节点发送到子节点的数据。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="eae9" class="mz lo it mv b gy na nb l nc nd">class Child2 extends React.Component {<br/>render() {<br/>        <br/>        return (<br/>            &lt;div&gt;<br/>                The data from parent is:{this.props.dataFromParent}<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span></pre><h1 id="8a53" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用回调从子进程到父进程</h1><p id="2da2" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">让我们假设我需要从 Child1 向 Parent 发送一条消息——“嗨，Popsie，最近怎么样？”。为此，我需要遵循一系列步骤。</p><p id="afc4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nf">第一步:</em> </strong>定义一个回调函数，该函数接受一个我们认为是从 Parent.js 中的 child 访问的参数<br/> <strong class="kd iu"> <em class="nf">第二步:</em> </strong>同样，将定义好的回调函数作为道具发送给 Child1.js</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="37b6" class="mz lo it mv b gy na nb l nc nd">class Parent extends React.Component {</span><span id="4517" class="mz lo it mv b gy ne nb l nc nd">state = { message: "" }</span><span id="8a59" class="mz lo it mv b gy ne nb l nc nd">callbackFunction = (childData) =&gt; {</span><span id="f843" class="mz lo it mv b gy ne nb l nc nd">      this.setState({message: childData})</span><span id="95ae" class="mz lo it mv b gy ne nb l nc nd">},</span><span id="9942" class="mz lo it mv b gy ne nb l nc nd">render() {<br/>        return (<br/>            &lt;div&gt;<br/>                 &lt;Child1 parentCallback = {this.callbackFunction}/&gt;<br/>                 &lt;p&gt; {this.state.message} &lt;/p&gt;<br/>            &lt;/div&gt;<br/>        );</span><span id="19a6" class="mz lo it mv b gy ne nb l nc nd">}<br/>}</span></pre><p id="586e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nf">第三步:</em> </strong>在 Child1.js 中使用 this . props . callback(data to parent)发送数据</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ce99" class="mz lo it mv b gy na nb l nc nd">class Child1 extends React.Component{</span><span id="64ab" class="mz lo it mv b gy ne nb l nc nd">sendData = () =&gt; {<br/>         this.props.parentCallback("Hey Popsie, How’s it going?");<br/>    },</span><span id="8bcc" class="mz lo it mv b gy ne nb l nc nd">render() { <br/>//you can call function sendData whenever you'd like to send data from child component to Parent component.<br/>    }<br/>};</span></pre><h1 id="803f" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">兄弟姐妹之间</h1><p id="374c" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">当我还是初学者时，我很难决定选择哪种方法在兄弟姐妹之间共享数据，我知道有三种方法在兄弟姐妹之间共享数据，它们都有自己的优缺点。<br/> <strong class="kd iu">方法一:</strong> <em class="nf">将以上两种共享数据的方法结合起来。然而，这种方法不适用于复杂的目录结构，因为人们将不得不编写大量代码来在彼此相距甚远的组件之间发送数据。然后，数据将不得不通过每个中间层被推和拉。</em></p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/af2dba5b6709ad7afb3b56d803aa3765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*TRjMRAgIbh1-LgwiOjsNBg.gif"/></div></figure><p id="a5f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">方法 2: </strong> <em class="nf">使用一个全局存储来维护所有子组件的状态，这些子组件需要从存储中交互和消费所需的数据— </em> <strong class="kd iu"> <em class="nf"> Redux </em> </strong></p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ca3c1abdcf3bba818c234c9783917c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*61TB2qL8BddRUyVSsT_9_A.gif"/></div></figure><p id="023d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">方法 3: </strong> <em class="nf">使用 React 的 Context API <br/> </em>关于 React 为什么升级到 Context API 以及哪一个在哪些方面更好，已经有大量的文章和博客，这两篇文章将有助于理解这一切:</p><div class="ni nj gp gr nk nl"><a href="https://blog.bitsrc.io/react-context-api-a-replacement-for-redux-6e20790492b3" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">React 上下文 API——Redux 的替代品？</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">将使用 Redux 进行状态管理的 React 应用程序转换为使用 React 的新上下文 API</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">blog.bitsrc.io</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jz nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">你可能不需要 Redux</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">人们往往在需要之前就选择 Redux。“如果没有它，我们的应用无法扩展怎么办？”后来，开发商皱眉…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div></div></a></div><p id="ea8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用过这种方法，并且已经稍微倾向于在 Redux 上使用这种方法。</p><blockquote class="oa ob oc"><p id="90c6" class="kb kc nf kd b ke kf kg kh ki kj kk kl od kn ko kp oe kr ks kt of kv kw kx ky im bi translated">Context API 的主要优势在于它将开发者从钻柱中解救出来。(Prop-drilling 指的是将变量传递给子组件的技术。主要思想是函数式编程，将参数传递给下一个函数，依此类推)</p></blockquote><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/48fa1810e76077673ac8b5706baccf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DZamBh-Un-_xZq--FsVgg.png"/></div></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk">Image source: Google</figcaption></figure><p id="5cb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑目录结构，我们需要在 Child1 和 Child2 之间传递数据。[ Child1 必须发送消息—“SSup 兄弟？?"to Child2 ] <br/>我们使用上下文 API 通过以下方法实现这一点:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9189" class="mz lo it mv b gy na nb l nc nd">App<br/>├── Child1<br/>└── Child2</span></pre><p id="fde3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤 1: </strong> <em class="nf">为两个孩子创建一个提供者组件。这个提供者维护状态(组件和一些用于操作状态的回调所使用的数据)并返回一个 contextObject。提供商 JSX 组件)</em></p><p id="21c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第二步:</strong> <em class="nf">将状态和回调函数作为道具传递给 Provider 组件内部的所有子组件。</em></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b0c8" class="mz lo it mv b gy na nb l nc nd">export const MContext = React.createContext();  //exporting context object</span><span id="7f60" class="mz lo it mv b gy ne nb l nc nd">class MyProvider extends Component {</span><span id="5650" class="mz lo it mv b gy ne nb l nc nd">state = {message: ""}</span><span id="556a" class="mz lo it mv b gy ne nb l nc nd">render() {</span><span id="4790" class="mz lo it mv b gy ne nb l nc nd">        return (</span><span id="cbb9" class="mz lo it mv b gy ne nb l nc nd">            &lt;MContext.Provider value={</span><span id="082d" class="mz lo it mv b gy ne nb l nc nd">            {   state: this.state,</span><span id="68d9" class="mz lo it mv b gy ne nb l nc nd">                setMessage: (value) =&gt; this.setState({</span><span id="f661" class="mz lo it mv b gy ne nb l nc nd">                            message: value })}}&gt;</span><span id="25d2" class="mz lo it mv b gy ne nb l nc nd">            {this.props.children}   //this indicates that the global store is accessible to all the child tags with MyProvider as Parent</span><span id="2d82" class="mz lo it mv b gy ne nb l nc nd">            &lt;/MContext.Provider&gt;)</span><span id="40d6" class="mz lo it mv b gy ne nb l nc nd">    }</span><span id="4dbc" class="mz lo it mv b gy ne nb l nc nd">}</span></pre><blockquote class="oa ob oc"><p id="9a83" class="kb kc nf kd b ke kf kg kh ki kj kk kl od kn ko kp oe kr ks kt of kv kw kx ky im bi translated">提供者是其子代的老板(所有状态和操作这些状态的回调函数的全局存储)。需要任何东西的人必须首先联系提供者才能访问对象。</p></blockquote><p id="dee5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(a)要通过 Child1 设置或操作消息，它必须访问提供者并设置提供者的状态。</p><p id="91d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(b)要按 Child2 查看/访问数据，它必须访问 Provider 以获取状态。</p><p id="bb3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第三步:</strong> <em class="nf">使用 MyProvider 组件作为两个子组件——child 1、child 2——的父组件。</em></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7a6b" class="mz lo it mv b gy na nb l nc nd">class App extends React.Component {</span><span id="ab25" class="mz lo it mv b gy ne nb l nc nd">render() {<br/>        return (<br/>            &lt;div&gt;<br/>                 &lt;MyProvider&gt;</span><span id="3faf" class="mz lo it mv b gy ne nb l nc nd">                      &lt;div className="App"&gt;</span><span id="359c" class="mz lo it mv b gy ne nb l nc nd">                      &lt;Child1/&gt;</span><span id="f24f" class="mz lo it mv b gy ne nb l nc nd">                      &lt;Child2/&gt;</span><span id="1377" class="mz lo it mv b gy ne nb l nc nd">                      &lt;/div&gt;</span><span id="84ad" class="mz lo it mv b gy ne nb l nc nd">               &lt;/MyProvider&gt;</span><span id="1cd3" class="mz lo it mv b gy ne nb l nc nd">            &lt;/div&gt;<br/>        );<br/>}<br/>}</span></pre><p id="c4e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第四步:<em class="nf"> </em> </strong> <em class="nf">以同样的方式实现想要的结果，但是这一次，使用 ContextObject。消费者如下所述:</em> <br/>两个孩子——孩子 1 和孩子 2 都是提供者的消费者。从今以后，它们在消费者标签中访问提供者。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8325" class="mz lo it mv b gy na nb l nc nd">import MContext<br/>class Child1 extends React.Component {</span><span id="ebda" class="mz lo it mv b gy ne nb l nc nd">render() {</span><span id="0bbf" class="mz lo it mv b gy ne nb l nc nd">    return (</span><span id="7d44" class="mz lo it mv b gy ne nb l nc nd">        &lt;div&gt;</span><span id="4c83" class="mz lo it mv b gy ne nb l nc nd">        &lt;Mcontext.Consumer&gt;</span><span id="ac49" class="mz lo it mv b gy ne nb l nc nd">        {(context) =&gt; (</span><span id="6476" class="mz lo it mv b gy ne nb l nc nd">       &lt;button onClick={()=&gt;{context.setMessage("New Arrival")}}&gt;Send&lt;/button&gt;</span><span id="e2ac" class="mz lo it mv b gy ne nb l nc nd">       )}</span><span id="a412" class="mz lo it mv b gy ne nb l nc nd">        &lt;/Mcontext.Consumer&gt;</span><span id="fc50" class="mz lo it mv b gy ne nb l nc nd">        &lt;/div&gt;</span><span id="fe51" class="mz lo it mv b gy ne nb l nc nd">    ) }</span><span id="d2f2" class="mz lo it mv b gy ne nb l nc nd">}</span></pre><p id="4ff9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在 Child2 是如何接收数据的？<br/>简单来说，就是使用消费者标签访问提供商。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="45c7" class="mz lo it mv b gy na nb l nc nd">import MContext<br/>class Child2 extends React.Component {</span><span id="dcc9" class="mz lo it mv b gy ne nb l nc nd">render() {</span><span id="24f1" class="mz lo it mv b gy ne nb l nc nd">       return (</span><span id="14ea" class="mz lo it mv b gy ne nb l nc nd">         &lt;div&gt;</span><span id="b3d4" class="mz lo it mv b gy ne nb l nc nd">            &lt;Mcontext.Consumer&gt;</span><span id="a03a" class="mz lo it mv b gy ne nb l nc nd">             {(context) =&gt; (</span><span id="8be1" class="mz lo it mv b gy ne nb l nc nd">              &lt;p&gt;{context.state.message}}&lt;/p&gt;)}</span><span id="017c" class="mz lo it mv b gy ne nb l nc nd">            &lt;/Mcontext.Consumer&gt;</span><span id="7147" class="mz lo it mv b gy ne nb l nc nd">         &lt;/div&gt;</span><span id="c68c" class="mz lo it mv b gy ne nb l nc nd">   )}</span><span id="6a55" class="mz lo it mv b gy ne nb l nc nd">}</span></pre><p id="1bde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这为 React 中不同组件之间的数据传递提供了清晰的实现细节。<br/>推荐:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/@wisecobbler/using-context-in-react-56a8e7da5431" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">在 React 中使用上下文</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">我有机会在 React Conf 2018 上谈论 React 中使用上下文的新方法。这篇博文是一篇文字…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="ol l nw nx ny nu nz jz nl"/></div></div></a></div></div></div>    
</body>
</html>