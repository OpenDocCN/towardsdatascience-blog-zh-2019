<html>
<head>
<title>Feature Transformation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apache-spark-mllib-tutorial-7aba8a1dce6e?source=collection_archive---------2-----------------------#2019-05-27">https://towardsdatascience.com/apache-spark-mllib-tutorial-7aba8a1dce6e?source=collection_archive---------2-----------------------#2019-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="efd9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Apache Spark ML 教程</h2><div class=""/><div class=""><h2 id="5aff" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何处理数据集中的不同要素类型</h2></div><p id="9eed" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意:本文是系列文章的一部分。查看完整系列: <a class="ae lo" rel="noopener" target="_blank" href="/apache-spark-mllib-tutorial-ec6f1cb336a9"> <em class="ln">第 1 部分:回归</em> </a> <em class="ln">，</em> <strong class="kt jd"> <em class="ln">第 2 部分:特征转化</em> </strong> <em class="ln">，</em> <a class="ae lo" rel="noopener" target="_blank" href="/apache-spark-mllib-tutorial-part-3-complete-classification-workflow-a1eb430ad069"> <em class="ln">第 3 部分:分类</em> </a> <em class="ln">，第 4 部分及以上即将推出。</em></p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="86af" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在之前的文章中，我们谈到了 Spark ML 以及如何用它来训练回归模型。本文关注<strong class="kt jd">特性转换。</strong>我们会了解概念，以及如何在 Spark ML 中直接实现。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/17e3bf668ecb3d55dbe6d45872d91cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loqHrtWcH4lX-C9eEgX3Tw.jpeg"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk"><a class="ae lo" href="https://unsplash.com/photos/VMKBFR6r_jg" rel="noopener ugc nofollow" target="_blank">Photo by Suzanne D. Williams</a></figcaption></figure><h1 id="2356" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">特征转换</h1><p id="02d4" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">特征变换只是将特征从一种表示形式变换到另一种表示形式的函数。但是我们为什么要改变我们的特征呢？原因有很多，比如:</p><ol class=""><li id="6346" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm no np nq nr bi translated">数据类型不适合输入到机器学习算法中，例如文本、类别</li><li id="de7d" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">特征值可能会在学习过程中造成问题，例如，数据以不同的尺度表示</li><li id="13a5" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">我们希望减少用于绘制和可视化数据的要素数量，加快训练速度或提高特定模型的准确性</li></ol><p id="b8a9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我们将关注三种主要的转换技术:</p><ul class=""><li id="c77f" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm nx np nq nr bi translated">处理分类变量</li><li id="7fc2" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm nx np nq nr bi translated">特征缩放</li><li id="f738" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm nx np nq nr bi translated">主成分分析</li></ul><h1 id="18bb" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">处理分类变量</h1><h2 id="df7f" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">分类数据</h2><p id="03e4" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">分类值是可以表示为类别或组的值。它们可以分为两种主要类型:<em class="ln">标称</em>和<em class="ln">序数</em>。</p><ul class=""><li id="88ff" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm nx np nq nr bi translated">标称值只是没有定义顺序的名称或标签。例子:性别，颜色。</li><li id="8187" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm nx np nq nr bi translated">序数值是顺序很重要的类别。例如:t 恤尺寸、等级、级别。</li></ul><p id="958f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">机器学习算法无法处理以类别或标签表示的数据。因此，我们需要将这些值转换成更相关的格式。</p><h2 id="1385" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">资料组</h2><p id="abb6" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们将使用一个非常简单的数据集，这样我们就可以将全部注意力放在我们将要学习的技术上。数据集只是一个 CSV 文件，包含两个字段:<em class="ln"> ID </em>和<em class="ln"> Color </em>。[从<a class="ae lo" href="https://drive.google.com/open?id=1cgZG_6HdI92ThuFxt7V14qUN7n5b5ZoB" rel="noopener ugc nofollow" target="_blank">这里</a>下载]</p><h2 id="30b5" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">设置环境</h2><p id="de72" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">对于本文的其余部分，以下是设置开发环境的常见步骤:</p><ol class=""><li id="94cc" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm no np nq nr bi translated">打开一本<em class="ln"> Jupyter </em>笔记本</li><li id="90f3" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">导入<em class="ln"> findspark </em>并初始化它</li><li id="bd6b" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">创建一个<em class="ln"> spark 会话</em></li><li id="872a" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">加载并显示数据</li></ol><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="ddf2" class="ny mn it ok b gy oo op l oq or">import findspark<br/>findspark.init('/opt/spark')<br/>from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.getOrCreate()<br/>data = spark.read.csv('./datasets/colors.csv', header=True, inferSchema=True)<br/>data.show()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi os"><img src="../Images/c7a3a2c0d5a2ea0d2e52b7364e32962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:218/format:webp/1*8U5VMgq947YRVpAElf2YsQ.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Data</figcaption></figure><p id="ae5e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">即使数据非常简单，我们也不能处理颜色列，因为它包含分类数据。</p><p id="779d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了解决这个问题，我们将介绍两种主要的方法以及如何在 Spark ML 中实现:<em class="ln">字符串索引</em>和<em class="ln">一热编码</em>。</p><h2 id="db34" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">字符串索引</h2><p id="b305" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated"><em class="ln">字符串索引</em>背后的概念非常直观。我们只是用一个数字来代替每个类别。然后我们在模型中使用这个数字来代替标签。</p><p id="249b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们是这样做的。首先，我们需要定义一个<strong class="kt jd"> StringIndexer </strong>。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="9c40" class="ny mn it ok b gy oo op l oq or">from pyspark.ml.feature import StringIndexer<br/>indexer = StringIndexer(inputCol="color", outputCol="color_indexed")</span></pre><p id="2ac3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意这里的<em class="ln">索引器</em>是一个类型为<strong class="kt jd">估算器</strong>的对象。</p><blockquote class="ot ou ov"><p id="df29" class="kr ks ln kt b ku kv kd kw kx ky kg kz ow lb lc ld ox lf lg lh oy lj lk ll lm im bi translated"><strong class="kt jd">估算器</strong>抽象了学习算法或任何适合或训练数据的算法的概念。从技术上来说，<strong class="kt jd">估算器</strong>实现了一个方法<strong class="kt jd"> fit() </strong>，它接受一个数据帧并产生一个<strong class="kt jd">模型</strong>，这是一个<strong class="kt jd">转换器</strong>。<br/>来源:<a class="ae lo" href="https://spark.apache.org/docs/1.6.1/ml-guide.html#estimators" rel="noopener ugc nofollow" target="_blank">https://spark . Apache . org/docs/1 . 6 . 1/ml-guide . html # estimators</a></p></blockquote><p id="683f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里估计器的目标是学习从颜色标签到颜色索引的映射。</p><p id="e16e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来我们调用<strong class="kt jd"><em class="ln">fit()</em></strong><em class="ln"/>方法来启动学习过程。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="4424" class="ny mn it ok b gy oo op l oq or">indexer_model = indexer.fit(data)</span></pre><p id="53e9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">返回的<em class="ln"> indexer_model </em>是类型<strong class="kt jd"> Transformer </strong>的对象。</p><blockquote class="ot ou ov"><p id="90b7" class="kr ks ln kt b ku kv kd kw kx ky kg kz ow lb lc ld ox lf lg lh oy lj lk ll lm im bi translated"><strong class="kt jd">转换器</strong>是一个抽象，包括特性转换器和学习模型。它实现了一个方法<strong class="kt jd"> transform() </strong>，该方法将一个数据帧转换成另一个数据帧，通常通过追加一个或多个列来实现。<br/>来源:<a class="ae lo" href="https://spark.apache.org/docs/1.6.1/ml-guide.html#transformers" rel="noopener ugc nofollow" target="_blank">https://spark . Apache . org/docs/1 . 6 . 1/ml-guide . html # transformers</a></p></blockquote><p id="d20f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在拟合估计器并得到我们的转换器之后，是时候通过调用<strong class="kt jd"> <em class="ln"> transform() </em> </strong>对我们的数据使用它了。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="7e51" class="ny mn it ok b gy oo op l oq or">indexed_data= indexer_model.transform(data)<br/># to view the data<br/>indexed_data.show()</span></pre><p id="d8a5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请注意如何在我们的<em class="ln"> outputCol </em>字段中添加一个新列<em class="ln">“color _ indexed”</em><em class="ln"/>。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oz"><img src="../Images/0f754cd8f2c60c66f8bb7cb3cc58ab07.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*mHzdAb5jwvFG5eYPBc67-w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Data after running the StringIndexer</figcaption></figure><p id="b5ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">新列代表每个颜色值的索引。相似的颜色值具有相似的索引。这里我们看到红色、白色、橙色和蓝色分别被赋予数字 0、1、2 和 3。</p><p id="90b0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些数字将通过<strong class="kt jd"> VectorAssembler </strong>收集到特征向量中，并传递给机器学习算法。</p><p id="c6a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是等等！我们还有一个问题。颜色是名义值，而不是序数。这意味着颜色名称之间没有顺序。比如:红色不大于，小于等于绿色。然而，基于当前的表示，机器学习模型可能以某种方式认为存在基于给定值的顺序。别担心，我们会用另一种叫做<strong class="kt jd"> One Hot Encoding </strong>的技术来解决这个问题。</p><h2 id="6c07" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">一个热编码</h2><p id="24f5" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们使用<strong class="kt jd">一个热编码(OHE) </strong>来打破分类列中的排序。应用 OHE 的过程如下:</p><ol class=""><li id="968f" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm no np nq nr bi translated">将分类列分成<em class="ln"> n </em>个不同的列，其中<em class="ln"> n </em>是列中唯一类别的数量</li><li id="29d9" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">在每一列中指定一个二进制值(0 或 1 ),表示数据点中颜色的存在</li></ol><p id="f1ad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">回到我们的例子，我们有四种独特的颜色:<em class="ln">红色，白色，橙色</em>和<em class="ln">蓝色</em>。因此，我们需要四列。我们将它们命名为:红色、白色、橙色和蓝色。现在，我们将把<em class="ln"> 1 </em>放在 is_red 列中，把<em class="ln"> 0 </em>放在其他列中，而不是给颜色<em class="ln">红色</em>设置一个值<em class="ln"> x </em>。然后，我们将对数组中的值进行分组，以用作颜色特征，而不是由 StringIndexer 计算的单值索引。[参见下表以获得更好的想法]</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi pa"><img src="../Images/85da973f2fb1443746bb54f285c56280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sx1SGZ7CocSg3HUjkVmL0w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">One Hot Encoding Process</figcaption></figure><p id="1602" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了应用 OHE，我们首先导入<strong class="kt jd"> OneHotEncoderEstimator </strong>类并创建一个估计变量。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="b9a9" class="ny mn it ok b gy oo op l oq or">from pyspark.ml.feature import OneHotEncoderEstimator<br/>ohe = OneHotEncoderEstimator(inputCols=["color_indexed"], outputCols=["color_ohe"])</span></pre><p id="7467" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们对数据进行估计，以了解需要对多少类别进行编码。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="e87c" class="ny mn it ok b gy oo op l oq or">ohe_model = ohe.fit(indexed_data)</span></pre><p id="8290" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们得到了训练好的模型，是时候把它应用到我们的数据上了。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="dac4" class="ny mn it ok b gy oo op l oq or">encoded_data = ohe_model.transform(indexed_data)<br/>encoded_data.show()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/33f649be614879d2a86099f9634762f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*C-Jm0pr8OFsbXVSTGsvyNA.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Data after applying the One Hot Encoder</figcaption></figure><p id="31cc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">搞定了。我们有一个<em class="ln"> color_ohe </em>列，它包含了我们的一次性编码数据。但是这个奇怪的表示是什么呢？它被称为<strong class="kt jd"> DenseVector </strong>数据类型，用于减少存储空间。例如，数字<strong class="kt jd"> (3，[0]，[1]) </strong>意味着我们有一个<strong class="kt jd"> 3 </strong>值的数组，这样我们在索引<strong class="kt jd"> 0 </strong>处得到值<strong class="kt jd"> 1 </strong>，在所有其他位置得到值 0。但是，我们有四个独特的类别，为什么有三个值呢？这就是 Spark ML 的工作方式。它省略了最后一个类别，以打破特征之间的相关性。通常你不必为此担心。但是如果您想强制 Spark ML 不删除最后一列，只需在构造函数中添加<strong class="kt jd"> dropLast=False </strong>。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="fb95" class="ny mn it ok b gy oo op l oq or">ohe = OneHotEncoderEstimator(inputCols=["color_indexed"], outputCols=["color_ohe"], dropLast=False)</span></pre><p id="07e3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在<em class="ln"> color_ohe </em>列已经准备好被您的<strong class="kt jd"> VectorAssembler </strong>收集，而不用担心颜色之间的顺序关系。</p><h1 id="fb6d" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">特征缩放</h1><p id="698f" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">让我们从分类值转移到数字值。但是我们为什么需要烦恼呢？这种数据已经是数字了，可以直接用在机器学习模型中，对吗？不幸的是，情况并非总是如此。接下来，我们将了解什么是特征缩放，以及它如何改进我们的模型。</p><h2 id="9ed8" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">资料组</h2><p id="8c9e" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们将使用流行的<a class="ae lo" href="https://archive.ics.uci.edu/ml/datasets/wine" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">葡萄酒数据集</strong> </a> <strong class="kt jd"> </strong>【从<a class="ae lo" href="https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data" rel="noopener ugc nofollow" target="_blank">这里下载</a>】。让我们装上看看。</p><p id="9fe3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意:为了节省空间，我省略了列名。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="32b4" class="ny mn it ok b gy oo op l oq or">data = spark.read.csv('./datasets/wine.csv', header=False, inferSchema=True)<br/>data.show()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi pc"><img src="../Images/514044a8faecc796f368bfba15a99f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mL9y3ffc8QRfvZnaW-9Y-A.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Wine dataset</figcaption></figure><p id="256c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可能会问数据有什么问题？那么，仔细看看每一列中的值。有些值是小分数&lt; 1, some range between 10 and 20 and others are in thousands. Notice for each column, the difference in means, standard deviations, minimum and maximum values. [Calculated with <strong class="kt jd"> <em class="ln"> data.describe()。</em>显示()</strong>方法】</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi pd"><img src="../Images/7d7870f4284a571f775c43179a73da30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiQdgxe8gfrNMnsf4KEmiw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Wine data statistics</figcaption></figure><p id="ed45" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这种规模上的多样性可能会在一些机器学习算法(如 KMeans)中导致许多问题。这是因为算法可能会根据变量的取值范围将某些变量视为更重要的变量。例如:考虑一个关于雇员的数据集。我们可能有一个范围在 0 → 30 之间的<em class="ln">年资</em>列和一个以千为单位的<em class="ln">薪水</em>列。但这并不意味着薪资一栏更占优势！</p><p id="c4cc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了解决这个问题，我们将这些值转换为相同的比例。有很多转换方法，我们将研究其中的两种。</p><p id="6329" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请注意，缩放器应用于<strong class="kt jd"> <em class="ln">矢量数据类型</em> </strong>这就是为什么我们需要首先使用<strong class="kt jd">矢量汇编器</strong>来收集特征:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="c59d" class="ny mn it ok b gy oo op l oq or">from pyspark.ml.feature import VectorAssembler<br/>assembler = VectorAssembler(inputCols=data.columns[1:], outputCol="features")<br/>data_2 = assembler.transform(data)</span></pre><p id="74ad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">重要提示</strong>:我们省略了<em class="ln"> _c0 </em>列，因为它是一个分类列。Scaler 应该只应用于数值。</p><p id="72be" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里我们得到了我们的<em class="ln">特性</em>专栏。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi pe"><img src="../Images/829e4aa9f2fe499f3a3d9c887c8bbe7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wiw7jVW0pFklqyB9V4d2cQ.png"/></div></div></figure><h2 id="0fe2" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">标准缩放器</h2><p id="45fb" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated"><strong class="kt jd">标准定标器</strong>使用<em class="ln">列-汇总-统计，通过移除平均值并定标到单位标准偏差来标准化特征。</em></p><p id="aa32" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">定义一个<strong class="kt jd">标准定标器</strong>:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="73f0" class="ny mn it ok b gy oo op l oq or">from pyspark.ml.feature import StandardScaler<br/>scaler = StandardScaler(inputCol="features", outputCol="scaled_features")</span></pre><p id="3087" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">标准缩放器</strong>可以接受两个附加参数:</p><ul class=""><li id="c9e0" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm nx np nq nr bi translated"><em class="ln">经受</em>:默认为真。将数据缩放到单位标准偏差。</li><li id="bce6" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm nx np nq nr bi translated"><em class="ln"> withMean </em>:默认为假。缩放前将数据以平均值为中心。</li></ul><p id="eff1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们在数据集上拟合我们的估计量。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="f975" class="ny mn it ok b gy oo op l oq or">scaler_model = scaler.fit(data_2)</span></pre><p id="484b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我们将我们的转换器应用于数据，以获得我们的缩放特征。</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="3244" class="ny mn it ok b gy oo op l oq or">scaled_data = scaler_model.transform(data_2)</span></pre><p id="8d98" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">搞定了。我们已经准备好了我们的缩放功能。</p><h2 id="c616" class="ny mn it bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc iz bi translated">最小最大缩放器</h2><p id="95f8" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">应用任何其他定标器的过程与上面完全相同，但是使用不同的类名及其相关参数。</p><p id="e42a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> MinMaxScaler </strong>将数据值转换到特定的范围内(默认为[0，1])。</p><p id="8f88" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">完整示例:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="8f25" class="ny mn it ok b gy oo op l oq or">from pyspark.ml.feature import MinMaxScaler<br/>scaler = MinMaxScaler(min=0, max=1, inputCol='features', outputCol='features_minmax')<br/>scaler_model = scaler.fit(data_2)<br/>data_3 = scaler_model.transform(data_2)</span></pre><h1 id="defe" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">主成分分析</h1><p id="6e90" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated"><strong class="kt jd">主成分分析</strong> (PCA)是在分析变量的相关特征后，将一组观测值从<em class="ln"> m </em>转换到<em class="ln"> n </em>维<em class="ln"> (m &gt; n) </em>的过程。它用于将数据从高维移动到低维，以实现可视化或降维的目的。我不会说太多细节，因为我的目标是教你如何应用它。</p><p id="2899" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">应用 PCA 与应用其他估计量没有什么不同:</p><ol class=""><li id="f2b0" class="nj nk it kt b ku kv kx ky la nl le nm li nn lm no np nq nr bi translated">创建一个<em class="ln">估算器</em>，</li><li id="b091" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">把它安装在模型上，得到一个变压器，</li><li id="8a36" class="nj nk it kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">将转换器应用于数据。</li></ol><p id="4b0c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了看看<strong class="kt jd"> PCA </strong>有多强大，我们将把它应用于手写图像数据集【从<a class="ae lo" href="https://drive.google.com/open?id=1SPQS2tD4khaixSHGtTIORN4w11z1zjEo" rel="noopener ugc nofollow" target="_blank">这里</a>下载】。该数据有 785 列。第一列表示定义数字类(0 →9)的标签，其他 784 列表示 28*28 图像的像素值。</p><p id="797e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的大脑很难想象比三维更高的东西。这里我们的数据有 784 个维度！所以在这个表示中，use 不可能理解它。幸运的是，我们可以使用<strong class="kt jd"> PCA </strong>将尺寸减少到只有 2！</p><p id="01b0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，我们读取数据并将像素收集到特征列中:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="ba9d" class="ny mn it ok b gy oo op l oq or">data = spark.read.csv('./datasets/digits.csv', header=True, inferSchema=True)<br/>from pyspark.ml.feature import VectorAssembler<br/>assembler = VectorAssembler(inputCols=data.columns[1:], outputCol='features')<br/>data_2 = assembler.transform(data)</span></pre><p id="931b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">给定<strong class="kt jd"> k = 2 </strong>(输出维数)，我们创建 PCA 模型:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="5688" class="ny mn it ok b gy oo op l oq or">from pyspark.ml.feature import PCA<br/>pca = PCA(k=2, inputCol='features', outputCol='features_pca')</span></pre><p id="31fd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们训练评估者:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="065b" class="ny mn it ok b gy oo op l oq or">pca_model = pca.fit(data_2)</span></pre><p id="ffec" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我们将模型应用于数据:</p><pre class="lx ly lz ma gt oj ok ol om aw on bi"><span id="bf4c" class="ny mn it ok b gy oo op l oq or">pca_data = pca_model.transform(data_2).select('features_pca')</span></pre><p id="1fab" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意<em class="ln"> features_pca </em>列只有两个值。这些值是从 784 → 2 减少的维数。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/67c7cbf4ccee1b6682b2221177841cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*PJry3jxeLF6HVa74XSHKtg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">PCA features with K = 2</figcaption></figure><p id="6295" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，请注意，当我们绘制这些值并用每个数字标签标注时会发生什么。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/9d96fb0aa3b3dc1d6efc63b4c0786875.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*OkLe7PQVjf1wGdlo6DMthw.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Digits plotted with 2 dimensions</figcaption></figure><p id="c9c2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看看我们如何漂亮地只用二维来绘制数字的分布。我们看到相似的数字形成了一个簇，这种洞察力对于后面的处理非常有用。</p><p id="7c55" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> PCA </strong>使用得当是非常强大的。它可以帮助你可视化数据，或者为其他机器学习算法做准备。</p><h1 id="6d4d" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">最后的想法</h1><p id="df16" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">在本文中，我们介绍了<strong class="kt jd">特性转换</strong>的基础知识。一套帮助将我们的数据转换为更相关或优化的格式以用于机器学习算法的技术。我们讨论了最常见的方法以及如何在 Spark ML 中实现它们。接下来，我们将学习如何将这些技术付诸实践，以及如何在完整的工作流程中组织它们。敬请关注…</p><p id="2c20" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你喜欢这篇文章，请点击“鼓掌”按钮，我将不胜感激👏所以可能会传染给他人。也可以在 <a class="ae lo" href="https://twitter.com/alimasri1991" rel="noopener ugc nofollow" target="_blank"> <em class="ln">推特</em></a><em class="ln"/><a class="ae lo" href="https://www.facebook.com/alimasri91" rel="noopener ugc nofollow" target="_blank"><em class="ln">脸书</em></a><em class="ln"/><a class="ae lo" href="mailto:alimasri1991@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="ln">上关注我直接发邮件给我</em> </a> <em class="ln">或者在</em><a class="ae lo" href="https://www.linkedin.com/in/alimasri/" rel="noopener ugc nofollow" target="_blank"><em class="ln">LinkedIn</em></a><em class="ln">上找到我。</em></p></div></div>    
</body>
</html>