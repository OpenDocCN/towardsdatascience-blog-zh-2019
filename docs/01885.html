<html>
<head>
<title>How to Win in the NFL with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用机器学习在 NFL 中获胜</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-win-in-the-nfl-b2b441ca8f5d?source=collection_archive---------12-----------------------#2019-03-28">https://towardsdatascience.com/how-to-win-in-the-nfl-b2b441ca8f5d?source=collection_archive---------12-----------------------#2019-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="51b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">预测足球比赛</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43d1886adddddd389965c8f18ed4df11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umjUayUT874zSb6OBaxpnA.jpeg"/></div></div></figure><p id="5c7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你被达拉斯牛仔队聘为防守协调员，你将在超级碗比赛中执教新英格兰爱国者队。我意识到这是一个极不可能的场景，因为牛仔队看起来一点也不像超级碗的竞争者。然而，我们仍然可以使用它作为创建 AI/ML 模型的步骤的示例项目。</p><p id="edee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在过去的二十年中，爱国者队一直是 NFL 中最好的球队，而爱国者队的四分卫汤姆·布拉迪可以说是同一时期 NFL 中最好的球员。作为防守协调官，阻止爱国者将是一项巨大的任务。但是，我们这边有优势:AI/ML。让我们设计一个流程，看看我们是否能在事情发生之前预测到，这将使我们能够相应地调整我们的防御方案。对于这个例子，我们将使用 Python 和<a class="ae lq" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> sklearn </a>。我们将遵循以下流程:</p><ol class=""><li id="6019" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">获取或生成数据</li><li id="5595" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">为探索性数据分析(EDA)准备数据。</li><li id="ca8a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">分析数据以寻找潜在的模式。</li><li id="6340" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">为 AI/ML 模型准备数据。</li><li id="d82f" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">训练和评估你选择的 AI/ML 模型。</li></ol><h1 id="1252" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">获取或生成数据</h1><p id="6e08" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">你首先需要的是一个数据集。如果您无法访问相关的数据集，您可以使用类似于<a class="ae lq" rel="noopener" target="_blank" href="/data-science-with-no-data-b3c21acee17c">本文</a>的流程生成一个样本数据集。对于我们的例子，我们将使用这个数据集，其中包含自 2009 年以来运行的每场 NFL 比赛的信息。它在<a class="ae lq" href="https://www.kaggle.com/maxhorowitz/nflplaybyplay2009to2016" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上主持。如果你不熟悉 Kaggle，它是一个编码竞赛网站，有许多不同的数据集；当我想找到一些数据时，这通常是我首先检查的地方。</p><p id="964d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们下载并解压缩了文件，我们需要它的格式能够让我们探索数据。为此，我们将使用 Pandas，这是一个 Python 库，其中包含许多修改和探索数据集的函数。下面是从我们的 CSV 文件加载数据帧的代码:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7769" class="nh mg it nd b gy ni nj l nk nl">import pandas as pd<br/>import matplotlib<br/>from sklearn import preprocessing<br/>%matplotlib inline<br/>df = pd.read_csv('data/nfl_plays.csv')</span></pre><h1 id="0240" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">为探索性数据分析(EDA)准备数据</h1><p id="3273" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">EDA 是探索数据问题(缺失值、错误输入的数据等)的过程，希望我们可以看到数据中的一些趋势。</p><p id="0483" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们看看已经加载了多少行和列:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="516c" class="nh mg it nd b gy ni nj l nk nl">df.shape</span></pre><p id="b7c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给出了:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1599" class="nh mg it nd b gy ni nj l nk nl">(449371, 255)</span></pre><p id="5a38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，这个数据集中有很多信息(255 列)。如果能知道每个字段代表什么就好了。经过一番挖掘，我最终找到了这个页面，它描述了所有的栏目以及它们的含义。我对这些领域感兴趣:</p><ul class=""><li id="a1fe" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp nm lx ly lz bi translated">posteam —拥有控球权的球队(在这种情况下，我们只需要 NE)</li><li id="cf18" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">game_seconds_remaining —游戏还剩多少时间</li><li id="2e5a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">yardline_100 —团队在哪个码线上(比例为 100)</li><li id="28c3" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">下降—我们处于什么水平(1.0、2.0、3.0、4.0)</li><li id="263b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">ydstogo——第一次进攻所需的码数</li><li id="6d5b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">散弹枪——他们排成散弹枪队形了吗？</li><li id="b187" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">分数差异—他们的分数—我们的分数</li><li id="0d31" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">比赛类型——比赛的类型(跑动、传球等)</li><li id="c699" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">run_location —他们朝哪个方向跑了(左、中、右)</li><li id="a3d4" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">pass_location —他们朝哪个方向走了(左、中、右)</li></ul><p id="20ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以使用其他字段来帮助预测，但是让我们先使用这些字段。下面是根据这些行和列进行过滤的代码</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9813" class="nh mg it nd b gy ni nj l nk nl">#filter rows<br/>nedf = df[(df.posteam=='NE') &amp; (df.down.isin([1.0, 2.0, 3.0, 4.0])) &amp; ((df.play_type=='run') | (df.play_type == 'pass'))]</span><span id="4b37" class="nh mg it nd b gy nn nj l nk nl">#filter columns<br/>nedf = nedf[['game_seconds_remaining', 'yardline_100', 'down', 'ydstogo', 'shotgun', 'score_differential', 'play_type', 'pass_length', 'pass_location', 'run_location']]</span><span id="5041" class="nh mg it nd b gy nn nj l nk nl">nedf.head()</span></pre><p id="11f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，在开始 EDA 之前，我们还有一个步骤。我们试图预测的值由依赖于 play_type 的四列表示。例如:</p><ul class=""><li id="83a8" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp nm lx ly lz bi translated">如果玩法类型是“跑步”，则会填充跑步位置，但不会填充传球位置。</li><li id="6c63" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nm lx ly lz bi translated">如果玩法类型是“传球”，则传球位置将被填充，而跑动位置不会被填充。</li></ul><p id="4e36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要将所有这些值合并到一个字段中。下面是实现这一点的代码(注意，我们还过滤掉了 location='unknown '):</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="d091" class="nh mg it nd b gy ni nj l nk nl">import numpy as np<br/>def get_full_play_type(play):<br/>    play_type, pass_location, run_location = play<br/>    if(play_type == 'run'):<br/>        return play_type+'_'+ run_location<br/>    else:<br/>        return play_type+'_'+ pass_location<br/>nedf = nedf.replace(np.nan, 'unknown', regex=True)    <br/>nedf['full_play_type'] = nedf[['play_type','pass_location', 'run_location']].apply(get_full_play_type, axis=1)<br/>nedf = nedf[(nedf.full_play_type.isin(['pass_left', 'pass_middle','pass_right','run_left', 'run_middle', 'run_right']))]</span></pre><p id="5d63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码将创建一个名为 full_play_type 的列，这就是我们试图预测的。让我们最后看一下我们的数据，以确保一切正常:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="300a" class="nh mg it nd b gy ni nj l nk nl">nedf.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/09a494b9b642ea5aa54aaec4165dfa5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGld5sa6VFhp_2_PBM5pQw.png"/></div></div></figure><h1 id="b8f0" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">分析数据以寻找潜在的模式</h1><p id="47f6" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">首先，让我们看看我们的 full_play_type 包含哪些值:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5616" class="nh mg it nd b gy ni nj l nk nl">nedf.groupby(['full_play_type']).count()[['play_type']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/815f6bb756705bd9636763ff482179e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*gBffEi4tmOwKfTetb9M5LQ.png"/></div></div></figure><p id="e467" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，如果我们随机猜测下一出戏，我们有六分之一的机会(16.66%)是正确的。我们将以此为基准，看看我们是否可以改进。</p><p id="5a53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时以图表形式查看会有所帮助:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7ee0" class="nh mg it nd b gy ni nj l nk nl">nedf.groupby(['full_play_type']).count()[['play_type']].plot(kind='bar')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/04209ac186788c9c82d8e60b87248980.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*IqUAdsdIora6EKQM7TTw5A.png"/></div></figure><p id="c1d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们来了解一下哪些重头戏按占总数的百分比被调用:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1adc" class="nh mg it nd b gy ni nj l nk nl">nedf.groupby(['full_play_type']).count()[['play_type']].apply(lambda x:100 * x / float(x.sum()))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/b0636b44dac0af93d780319802745dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*hJmN-YDFuv2ntLQ-Rp1gUw.png"/></div></div></figure><p id="5f2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的预测已经有所改进了！如果我们预测每场比赛的 pass_left，我们的正确率是 23%对 16.66%。我们还可以做得更好。</p><h1 id="3073" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">为 AI/ML 模型准备数据</h1><p id="eb1f" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">AI/ML 模型需要数字输入和输出。当数字规模相似时，它们也能更好地工作。在本节中，我们将利用一些不同的技术来实现这一点。</p><p id="755d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将使用 sklearn 的<strong class="kw iu">预处理</strong>库将我们的 full_play_types 转换为 numeric:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9930" class="nh mg it nd b gy ni nj l nk nl">le = preprocessing.LabelEncoder()<br/>le.fit(nedf.full_play_type)<br/>nedf['full_play_type_code'] = le.transform(nedf['full_play_type'])</span></pre><p id="b29b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建一个名为 full_play_type_code 的列，它是 full_play_type 的数字表示。让我们看看 full_play_type_code 数据，确保它仍然与 full_play_type 匹配。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="c441" class="nh mg it nd b gy ni nj l nk nl">nedf.groupby(['full_play_type_code']).count()[['down']].plot(kind='bar')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fb03556ed27bef2d1838d42befbd2fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*aZAvDKeWQ0Egv-Cou5KnDw.png"/></div></figure><p id="a552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，图表与上面的图表相匹配，但是现在 x 轴是一个数值，而不是文本。</p><p id="9408" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我想简化 ydstogo 值。从技术上讲，这可以是 1 到 99 之间的一个值。但是，我想将这个距离放入一些桶中(1-4 码、5-8 码、9-12 码、13-16 码、≥17 码)，这将使我们的模型能够识别模式。我选择的范围是任意的，可以很容易地修改。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="de6a" class="nh mg it nd b gy ni nj l nk nl">def bucketize(val, size, count):<br/>    i=0<br/>    for i in range(count):<br/>        if val &lt;= (i+1)*size:<br/>            return i<br/>    return i</span><span id="152c" class="nh mg it nd b gy nn nj l nk nl">def bucketize_df(df):<br/>    df['ydstogo'] = [bucketize(x, 4, 5) for x in df['ydstogo']]<br/>    return df</span><span id="8ec8" class="nh mg it nd b gy nn nj l nk nl">nedf = bucketize_df(nedf)</span></pre><p id="d81b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我想对 down 和 ydstogo 列进行热编码，这意味着我们将把行“透视”到列，并用“1”填充包含我们正在编码的值的列，否则为 0。例如，足球比赛中有四个回合。当我们对 down 列进行热编码时，我们将得到四列，其中 1 只被填充一次。如果我们要对一个表示第三个向下的行进行热编码，我们将得到新列的这些值[0，0，1，0]。请注意，第三列是唯一包含 1 的列。这样做的好处是，我们的 down 和 ydstogo 数据现在表示为 0 和 1，这也应该有助于我们的模型学习。sklearn 中的代码非常简单:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="2982" class="nh mg it nd b gy ni nj l nk nl">nedf = pd.concat([nedf, pd.get_dummies(nedf['down'], prefix='down')], axis=1)<br/>nedf = pd.concat([nedf, pd.get_dummies(nedf['ydstogo'], prefix='ydstogo')], axis=1)</span></pre><p id="7ab8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我们的数据样本此时的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/94ea002ed6ffd14ca7dfb32416846711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiQIiX7Trwgx7Iy0OKGOdg.png"/></div></div></figure><p id="1f5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，你可以看到 ydstogo_*和 down_*用 0 和 1 表示。但是，game_seconds_remaining、yardline_100 和 score differential 列仍然与零和一处于不同的刻度。例如,“游戏剩余秒数”包含 0 到 3600 之间的值。</p><p id="fcf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过在列中添加一些数学来解决这个问题。首先，让我们看看这些列包含的值的范围。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0eb1" class="nh mg it nd b gy ni nj l nk nl">nedf.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/4acbed0fe2a667198eae24fd90d9c5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E2QLKIVBxnEU4rA5y5E7Q.png"/></div></div></figure><p id="921a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本练习中，我们将查看最小值和最大值，并使用它们将数据标准化为介于 0 和 1 之间的值。game_seconds_remaining 的最小值是 3，而最大值是 3600。我们将游戏剩余时间除以 3600。Yardline_100 将除以 100。对于分数差异，我们将应用以下公式:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f347" class="nh mg it nd b gy ni nj l nk nl">(score_diff + min_diff) / (max_diff-min_diff)</span></pre><p id="e593" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，为了简化，我们将对 min_diff 使用-50，对 max_diff 使用 50。我们的逻辑是，如果你赢了或输了超过 50 分，此时你脑子里想的是别的事情。下面是我们应用这些公式的代码:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5bad" class="nh mg it nd b gy ni nj l nk nl">nedf['game_seconds_remaining']/=3600<br/>nedf['yardline_100']/=100<br/>nedf['score_differential']=(nedf['score_differential']+50)/100</span></pre><p id="b4af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们看看我们的数据集，这是我们得到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5f825d99c880f43e15e6c7abb467cd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgpzYKYQttBRV2iRLoRZFA.png"/></div></div></figure><p id="4a27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在已经将所有的输入字段转换为 0 到 1 之间的值，所以我们准备在模型上进行试验。</p><h1 id="0716" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">训练和评估你选择的人工智能/人工智能模型</h1><p id="8158" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在本教程中，我们将使用 RandomForestClassifier 来看看我们能否预测下一场比赛。但是首先，我们需要去掉我们的模型中不需要的所有列。然后，我们需要将数据分成一个训练集和一个测试集，每个测试集包含一个 X(输入数据)和 y(结果数据)。这可以用三行 Python 快速完成。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="bbd3" class="nh mg it nd b gy ni nj l nk nl">from sklearn.model_selection import train_test_split</span><span id="5106" class="nh mg it nd b gy nn nj l nk nl">#select important columns for input<br/>X=nedf[['yardline_100', 'shotgun', 'score_differential', 'game_seconds_remaining', 'down_1.0', 'down_2.0', 'down_3.0', 'down_4.0','ydstogo_0','ydstogo_1','ydstogo_2','ydstogo_3','ydstogo_4']]</span><span id="0829" class="nh mg it nd b gy nn nj l nk nl">#select result column for output<br/>Y=nedf['full_play_type_code']</span><span id="e8f1" class="nh mg it nd b gy nn nj l nk nl">#split data for train and test<br/>train_x, test_x, train_y, test_y = train_test_split(X, Y, random_state = 0)</span></pre><p id="28f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，我们可以训练我们的模型来拟合输入数据。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="eb13" class="nh mg it nd b gy ni nj l nk nl">from sklearn.ensemble import RandomForestClassifier<br/>the_clf=RandomForestClassifier(max_depth=8, n_estimators=64)<br/>the_clf.fit(train_x, train_y)</span></pre><p id="ad75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的模型已经被训练好了，让我们看看它在我们的测试数据上得分如何。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="a6a5" class="nh mg it nd b gy ni nj l nk nl">from sklearn.metrics import accuracy_score<br/>pred = the_clf.predict(test_x)<br/>acc =accuracy_score(test_y, pred)<br/>print(acc)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/35f70cf4a11958405c83c6c3b8fffaf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*d95OqibBemVEnOZCGR23PQ.png"/></div></figure><p id="d79a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在能够在 31%的时间里预测正确的打法，这听起来可能不太好，但请记住，这几乎是我们开始随机猜测的两倍(16.66%)，比仅仅猜测他们最喜欢的打法好 25%(pass _ left，23%)。</p><h1 id="4c75" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">后续步骤</h1><p id="f81d" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">仅用几行 Python 代码，我们的教练技能几乎提高了一倍。然而，您可能已经注意到，我们编写的大部分代码都与组织和管理我们的数据有关。现在我们已经完成了，我们可以使用这些数据来训练更复杂的模型。</p><p id="5f65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的下一篇文章中，我们将探索四种技术，利用我们处理过的数据生成更好的预测:</p><ol class=""><li id="7784" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">过采样/数据扩充</li><li id="8184" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">型号选择</li><li id="b11b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">模型评估</li><li id="d809" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">模型调整</li></ol><p id="b5cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读，本文的代码将托管在 github 上。</p></div></div>    
</body>
</html>