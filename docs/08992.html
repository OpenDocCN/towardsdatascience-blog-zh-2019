<html>
<head>
<title>The Hidden Peculiarities of Realtime Data Streaming Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实时数据流应用程序隐藏的特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-hidden-peculiarities-of-realtime-data-streaming-applications-23b6484d2307?source=collection_archive---------20-----------------------#2019-11-30">https://towardsdatascience.com/the-hidden-peculiarities-of-realtime-data-streaming-applications-23b6484d2307?source=collection_archive---------20-----------------------#2019-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/45918af72148838d371dea94e8f51111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WEDMq1SE1Qge5Bly"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lysanderyuen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lysander Yuen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bedc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着开源框架(如 Apache Flink、Apache Spark、Apache Storm)和云框架(如 Google Dataflow)的不断增加，创建实时数据处理作业变得非常容易。API 定义良好，Map-Reduce 等标准概念在所有框架中都遵循几乎相似的语义。</p><p id="2623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，直到今天，在实时数据处理领域起步的开发人员还在为这个领域的一些特性而奋斗。因此，他们不知不觉地创建了一个路径，导致应用程序中相当常见的错误。</p><p id="fb66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看在设计实时应用程序时可能需要克服的一些奇怪的概念。</p><h1 id="d89b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件时间</h1><p id="241c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">数据源生成数据的时间戳称为<strong class="kf ir">事件时间</strong>，而应用程序处理数据的时间戳称为<strong class="kf ir">处理时间</strong>。不区分这些时间戳是实时数据流应用程序中最常见陷阱的原因。</p><p id="5687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面就来细说一下。</p><p id="fd03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于几个问题，例如代理中的高 GC 或导致背压的过多数据，数据队列容易延迟。我将用(E，P)表示一个事件，其中 E 是事件时间戳(HH:MM:SS 格式)，P 是处理时间戳。在理想世界中，E==P，但这不会发生在任何地方。</p><p id="79d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设我们收到以下数据</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d649" class="mn lc iq mj b gy mo mp l mq mr">('05:00:00', '05:00:02'), ('05:00:01', '05:00:03'),      ('05:00:01', '05:00:03'), ('05:00:01', '05:00:05'),<br/>('05:00:02', '05:00:05'), ('05:00:02', '05:00:05')</span></pre><p id="6e3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们假设有一个程序计算每秒收到的事件数。根据事件时间，程序返回</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4a13" class="mn lc iq mj b gy mo mp l mq mr">[05:00:00, 05:00:01) = 1<br/>[05:00:01, 05:00:02) = 3<br/>[05:00:02, 05:00:03) = 2</span></pre><p id="2213" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，根据处理时间，输出是</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6bf3" class="mn lc iq mj b gy mo mp l mq mr">[05:00:00, 05:00:01) = 0<br/>[05:00:01, 05:00:02) = 0<br/>[05:00:02, 05:00:03) = 1<br/>[05:00:03, 05:00:04) = 2<br/>[05:00:04, 05:00:05) = 0<br/>[05:00:05, 05:00:06) = 3</span></pre><p id="aba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，这两者是完全不同的结果。</p><h1 id="f62a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据流中不寻常的延迟</h1><p id="456e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大多数实时数据应用程序都使用分布式队列中的数据，如 Apache Kafka、RabbitMQ、Pub/Sub 等。队列中的数据由其他服务生成，如来自消费者应用程序的点击流或来自数据库的日志。</p><p id="c349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题队列容易受到延迟的影响。生成的事件甚至可以在几十毫秒内到达您的作业，或者在最坏的情况下可能需要一个多小时(极端背压)。数据可能会由于以下原因而延迟—</p><ul class=""><li id="acb6" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">卡夫卡的高负荷</li><li id="9dde" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">生产者在其服务器中缓冲数据</li><li id="e001" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">由于应用程序中的反压力，消耗速度较慢</li></ul><p id="eb7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不假设数据会有延迟是一个陷阱。开发人员应该始终拥有测量数据延迟的工具。例如，在卡夫卡中，你应该检查一下偏移滞后。</p><p id="c5e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还应该监控作业中的背压和延迟(即事件时间和处理时间之间的差异)。没有这些将导致意外的数据丢失，例如 10 分钟。时间窗口可以显示为无数据，窗口为 10 分钟。之后的值是期望值的两倍。</p><h1 id="bb09" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">连接</h1><p id="e825" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在批处理数据处理系统中，连接两个数据集相对来说比较简单。在流式世界中，情况变得有点麻烦。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c967" class="mn lc iq mj b gy mo mp l mq mr">//The dataset is in the format (timestamp, key, value)</span><span id="88e9" class="mn lc iq mj b gy ng mp l mq mr">//Datasteam 1<br/>(05:00:00, A, value A), (05:00:01, B, value B),<br/>(05:00:04, C, value C), (05:00:04, D, value D)</span><span id="babe" class="mn lc iq mj b gy ng mp l mq mr">//Datastream 2<br/>(05:00:00, A, value A'), (05:00:02, B, value B'), <br/>(05:00:00, C, value C')</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f16754859120d6d12c13084cf6e9e39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*O2D3eDUiED-rfiuWo_OyeA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Both data streams represented on a single time scale</figcaption></figure><p id="4192" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在在它们的键上连接两个数据流。为了简单起见，我们将做一个内部连接。</p><p id="3d90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">键 A </strong> —两个值 A &amp;值 A’同时到达。因此，我们可以很容易地将它们组合成一个函数并输出结果</p><p id="098b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">键 B</strong>—B 值比 B 值早 1 秒。因此，我们需要在数据流 1 上等待至少 1 秒钟，以使连接工作。因此，你需要考虑以下几点-</p><ul class=""><li id="9b99" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">你会把这一秒钟的数据存储在哪里？</li><li id="9d50" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果这 1 秒钟不是固定的延迟，而是不规则地变化，在最坏的情况下上升到 10 分钟，那该怎么办？</li></ul><p id="5c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">C 键</strong>—C 值比 C 值晚 4 秒到达。这与之前的情况相同，但现在数据流 1 和 2 都有不规则的延迟，没有固定的模式来确定哪个流将给出值 1。</p><p id="e90f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">键 D </strong> —值 D 到达，但没有观察到值 D’。考虑以下情况-</p><ul class=""><li id="d243" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">你要等多久才能得到 d `?</li><li id="5735" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果值 d '可以在从至少 5 秒到接近 1 小时的任何时间出现呢？</li><li id="d1fe" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果这是一个外部连接，并且您必须决定何时单独发出值 D，该怎么办？</li><li id="7b76" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果在前一种情况下，在发出值 D 1 分钟后，值 D `到达，会怎样？</li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3b2c70a966f089a78a9a09ab4a4d1402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*hbkooGqmNcfjSw2aILyz2w.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Join in a streaming application</figcaption></figure><p id="8934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上所有问题的答案将取决于您的使用案例。重要的是考虑所有这些问题，而不是忽视流媒体系统的复杂性。</p><h1 id="b00d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置</h1><p id="efcc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在标准微服务中，配置存在于作业内部或数据库中。在数据流应用程序中也可以这样做。但是，在使用这种方法之前，您需要考虑以下几点。</p><h2 id="2dc7" class="mn lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">您访问配置的频率是多少？</h2><p id="a9eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果需要为每个事件访问配置，并且事件的数量很多(超过一百万 RPM)，那么您也可以尝试其他方法。一种是将配置存储在作业状态中。这可以在 Flink 和 Spark 中使用有状态处理来完成。可以使用文件阅读器或 Kafka 中的另一个流在状态中填充配置。</p><p id="fee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在流式世界中，对每个事件进行 DB 调用会降低应用程序的速度并导致背压。选择是要么使用快速数据库，要么通过在应用程序中存储状态来消除网络调用。</p><h2 id="e79e" class="mn lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">你的配置有多大？</h2><p id="7a7f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果配置非常大，您应该只使用应用程序内状态，如果配置可以跨多个服务器拆分，例如，配置为每个用户保存一些阈值。这种配置可以根据用户 id 键在几台机器上进行分割。这有助于减少每台服务器的存储量。</p><p id="5ba3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果配置不能跨节点拆分，则首选 DB。否则，所有数据将需要被路由到包含配置的单个服务器，然后再次重新分发。在这个场景中，唯一包含配置的服务器充当了瓶颈。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/fb04bc038d8919c004b44ae87c93acb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjPCcJgCT0cEHK5LyM1ZAA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Config present in a single server leading to a bottleneck</figcaption></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="3ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设计实时数据流应用程序似乎很容易，但开发人员会犯很多类似上面提到的错误，特别是如果他们来自微服务领域。</p><p id="b221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的部分是理解数据流的基础，以及如何处理单个数据流，然后转到处理多个连接、实时配置更新等的复杂应用程序。</p><p id="57be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个领域最重要的书籍之一是<br/> <a class="ae kc" href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321" rel="noopener ugc nofollow" target="_blank">设计数据密集型应用程序:可靠、可伸缩和可维护系统背后的伟大思想</a>。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="b227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="oc">联系我</em> </strong> <a class="ae kc" href="http://www.linkedin.com/in/kartik-khare" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="oc">领英</em> </strong> </a> <strong class="kf ir"> <em class="oc">或</em> </strong> <a class="ae kc" href="https://www.facebook.com/KK.corps" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="oc">脸书</em> </strong> </a> <strong class="kf ir"> <em class="oc">或如有任何疑问，请发邮件至</em></strong><a class="ae kc" href="mailto:kharekartik@gmail.com" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="oc">kharekartik@gmail.com</em></strong></a></p></div></div>    
</body>
</html>