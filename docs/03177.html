<html>
<head>
<title>4 easy steps to improve your machine learning code performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高机器学习代码性能的 4 个简单步骤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-easy-steps-to-improve-your-machine-learning-code-performance-88a0b0eeffa8?source=collection_archive---------9-----------------------#2019-05-21">https://towardsdatascience.com/4-easy-steps-to-improve-your-machine-learning-code-performance-88a0b0eeffa8?source=collection_archive---------9-----------------------#2019-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9093627bca4ca729b054dde2760b726f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXDn5JnRI8LnV3B5NkyHRQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="1bf0" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">我想向你展示 4 个简单的步骤，这将帮助你，在没有任何优化知识的情况下，至少将你的代码加速两次，并使它更有效和可读。</h2></div><p id="f1f2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每天有多少新的机器学习库和模型被创建出来，这真的令人震惊。但令人失望的是，它们中的大部分都没有经过适当的设计。实际上，有时背后有好想法的好东西只是没有被使用，因为它没有被很好地记录，有困难或不直观的 API，或者只是因为它没有很好地执行并且对于生产环境来说太慢。一个很好的例子就是我在上一篇文章中提到的库— <a class="ae lm" href="https://github.com/EFord36/normalise" rel="noopener ugc nofollow" target="_blank"> normalize </a>。这是一个美丽的想法，它产生的结果确实可以在一些 nlp 任务中产生影响，但其中有一些意想不到的错误，API 不够灵活。好吧，你说，这两件事并不重要，实际上，你可以挺过去。但是你不能忍受的是它的性能很糟糕，它只是<strong class="ks jc">慢</strong>，所以不能在生产环境中使用。</p><p id="b90d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我想鼓励每个人，那些创建机器学习库或只是展示自己的可重用代码片段的人，尽可能地优化它。因为每个人，或多或少都想有所作为或让这个世界变得更好一点，帮助其他人缩短他们走过的路，并立即获得更好的结果。我想向你展示 4 个简单的步骤，这将帮助你，在没有任何优化知识的情况下，至少将你的代码加速两次，并使它更有效和可读。</p><h1 id="dd1c" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">高效地计算你的数学</h1><p id="299d" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">船长明显说:“使用你的工作与图书馆的数学函数或只是使用 numpy，你会一直没事”。他是对的，因为在大多数情况下，库的作者在某种程度上优化了所有的函数，使他的代码尽可能的快。但是几乎每个 python ML 库都是基于 numpy 的。Numpy <a class="ae lm" href="https://www.numpy.org/" rel="noopener ugc nofollow" target="_blank">官方网页</a>上写着:</p><blockquote class="mk ml mm"><p id="4a56" class="kq kr mn ks b kt ku kc kv kw kx kf ky mo la lb lc mp le lf lg mq li lj lk ll ij bi translated">NumPy 是使用 Python 进行科学计算的基础包。除其他外，它包含:</p><p id="a35a" class="kq kr mn ks b kt ku kc kv kw kx kf ky mo la lb lc mp le lf lg mq li lj lk ll ij bi translated">一个强大的 N 维数组对象</p><p id="b805" class="kq kr mn ks b kt ku kc kv kw kx kf ky mo la lb lc mp le lf lg mq li lj lk ll ij bi translated">复杂的(广播)功能</p><p id="a5c6" class="kq kr mn ks b kt ku kc kv kw kx kf ky mo la lb lc mp le lf lg mq li lj lk ll ij bi translated">集成 C/C++和 Fortran 代码的工具</p><p id="37f0" class="kq kr mn ks b kt ku kc kv kw kx kf ky mo la lb lc mp le lf lg mq li lj lk ll ij bi translated">有用的线性代数、傅立叶变换和随机数功能</p></blockquote><p id="8a34" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">实际上，在 ML 中我们只是不断地做一些矩阵运算。Numpy 使用你能想到的所有可能的最先进的优化技术来提高所有这些操作的效率。所以规则一:</p><blockquote class="mr"><p id="e20f" class="ms mt jb bd mu mv mw mx my mz na ll dk translated">用 numpy 代替 python math，用 numpy 数组代替 python 数组。</p></blockquote><p id="d76d" class="pw-post-body-paragraph kq kr jb ks b kt nb kc kv kw nc kf ky kz nd lb lc ld ne lf lg lh nf lj lk ll ij bi translated">如果你遵循这第一条简单的规则，你很快就会感觉到不同。</p><h1 id="d6f9" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">向量化您的函数</h1><p id="c838" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">如何摆脱恼人的 for 循环，它只是在一组输入上应用相同的函数？把这个函数矢量化就行了！Numpy 允许您向量化一个函数，这意味着新创建的函数将应用于列表输入并产生一个函数结果数组。根据这篇<a class="ae lm" rel="noopener" target="_blank" href="/data-science-with-python-turn-your-conditional-loops-to-numpy-vectors-9484ff9c622e">帖子</a>，它可能会让你的计算速度提高至少两倍。我强烈推荐阅读它，因为作者展示了 forloops 和 numpy 矢量化的漂亮对比，并展示了测量结果，证明 numpy 矢量化工作更快！让我们来看一些简单的代码片段，来展示它是如何工作的:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="572b" class="np lo jb nl b gy nq nr l ns nt">import numpy as np<br/>from math import sin, cos, gamma</span><span id="505f" class="np lo jb nl b gy nu nr l ns nt">def func(x):<br/>    if x &gt; 10 * sin(x) * cos(x):<br/>        return sin(x) * cos(x)<br/>    elif x**100 &lt; (x-1)**101:<br/>        return x**89<br/>    elif x**100 - gamma(x) &lt; (x-1)**101 * gamma(x):<br/>        return gamma(x)<br/>    else:<br/>        return x**56</span><span id="a3a7" class="np lo jb nl b gy nu nr l ns nt">arr = np.random.randn(10000)</span><span id="0f9d" class="np lo jb nl b gy nu nr l ns nt"># FoorLoop method<br/>res = []</span><span id="efbf" class="np lo jb nl b gy nu nr l ns nt">for i in arr:<br/>    res.append(func(i))</span><span id="9731" class="np lo jb nl b gy nu nr l ns nt"># Numpy Vectorization</span><span id="b47f" class="np lo jb nl b gy nu nr l ns nt">func_vect = np.vectorize(func)<br/>res_vet = func_vect(arr)</span></pre><p id="d733" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，Numpy 矢量化代码的运行速度提高了 2 倍！矢量化不仅有助于加快代码速度，还能使代码更加整洁。例如，使 nltk 中的词干处理在所有令牌上运行，而不是只在一个令牌上运行:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="4f4c" class="np lo jb nl b gy nq nr l ns nt">import numpy as np<br/>from nltk.stem import PorterStemmer<br/>from nltk.tokenize import word_tokenize</span><span id="e9ba" class="np lo jb nl b gy nu nr l ns nt">tokens = word_tokenize(text)<br/>porter = PorterStemmer()</span><span id="d9d1" class="np lo jb nl b gy nu nr l ns nt"># vectorizing function to able to call on list of tokens<br/>stem_words = np.vectorize(porter.stem)</span><span id="2faf" class="np lo jb nl b gy nu nr l ns nt">tokens_stems = stem_words(tokens)</span></pre><p id="b2fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它看起来比一个看起来更好的选择:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="ab52" class="np lo jb nl b gy nq nr l ns nt">import numpy as np<br/>from nltk.stem import PorterStemmer<br/>from nltk.tokenize import word_tokenize</span><span id="8cd2" class="np lo jb nl b gy nu nr l ns nt">tokens = word_tokenize(text)<br/>porter = PorterStemmer()</span><span id="a4b9" class="np lo jb nl b gy nu nr l ns nt">def stem_words(tokens):<br/>    stems = []<br/>    for t in tokens:<br/>        stems.append(porter.stem(t))<br/>    return stems</span><span id="3ff8" class="np lo jb nl b gy nu nr l ns nt">tokens_stems = stem_words(tokens)</span></pre><p id="ac2e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">总之，矢量化是一种非常强大的机制，它不仅可以帮助您加快代码速度，还可以让代码看起来更整洁。</p><h1 id="f8b9" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">sklearn 中的 n_jobs</h1><p id="e7a2" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">现在几乎每台计算机都有不止一个内核。不使用所有的，如果你付了钱，对我来说是一种犯罪。事实上，你必须从你的电脑上拿走它能给你的一切。对于 ML 开发者来说，他的计算机不必是一个漂亮和花哨的东西，首先，它是一个勤奋的矿工，必须像苏联的 Stakhanov 一样分三班工作。你只需要从你的电脑上拿走它能给你的一切，如果你仍然不明白为什么，只要记住一件简单的事情:“你已经为此付出了代价”。ML 开发者在他的管道中使用更多内核的最简单方法就是不要忘记在他使用的每个 sklearn 模型中设置<strong class="ks jc"> n_jobs </strong>参数。<strong class="ks jc"> n_jobs </strong>告诉 sklearn 并行运行多少个作业来拟合和预测模型。大多数 sklearn 模型支持并行训练和转换。这将有助于您在大型或高维数据集上搜索最佳参数或训练模型时节省大量时间。注意不要将<strong class="ks jc"> n_jobs </strong>设置为<strong class="ks jc"> -1 </strong>，因为并行化节省的是你的时间，而不是 RAM。是的，实际上并行化可能会占用大量内存，但是使用至少 2 个作业而不是 1 个作业已经可以帮助您优化模型训练和预测性能。</p><h1 id="902e" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">MapReduce</h1><p id="3496" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">维基百科说:</p><blockquote class="mr"><p id="cf1a" class="ms mt jb bd mu mv mw mx my mz na ll dk translated"><strong class="ak"> MapReduce </strong>是一种编程模型和相关实现，用于在集群上使用并行分布式算法处理和生成大数据集。</p></blockquote><p id="7fa6" class="pw-post-body-paragraph kq kr jb ks b kt nb kc kv kw nc kf ky kz nd lb lc ld ne lf lg lh nf lj lk ll ij bi translated">看起来很复杂，就像只能在大型集群或大型数据集上使用的东西，对吗？但是这很简单，我将用几句话和一个例子来解释。</p><p id="9ded" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">MapReduce 分为两部分:</p><ol class=""><li id="b908" class="nv nw jb ks b kt ku kw kx kz nx ld ny lh nz ll oa ob oc od bi translated">map——函数，它以某种方式将输入修改为输出。这个函数在每个需要处理的数据样本上被调用。这一步是并行的，因为对于每个样本，事实上，你做同样的操作。</li><li id="885a" class="nv nw jb ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Reduce 函数，聚合 map 函数的所有输出。这一步通常是连续的。</li></ol><p id="f285" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">例如，您必须计算一组数据的平方和。顺序实施看起来像这样:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="78a7" class="np lo jb nl b gy nq nr l ns nt">arr = [1, 2, 3, 4, 5]</span><span id="a84c" class="np lo jb nl b gy nu nr l ns nt">result = 0<br/>for i in arr:<br/>    result += i**2</span></pre><p id="9fc0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们将这个任务转换成 MapReduce:</p><ol class=""><li id="dc93" class="nv nw jb ks b kt ku kw kx kz nx ld ny lh nz ll oa ob oc od bi translated">地图—计算数字的平方</li><li id="57a0" class="nv nw jb ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">减少-计算地图结果的总和</li></ol><p id="a850" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">python 中的顺序实现:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="fdca" class="np lo jb nl b gy nq nr l ns nt">from functools import reduce</span><span id="1a2d" class="np lo jb nl b gy nu nr l ns nt">arr = [1, 2, 3, 4, 5]</span><span id="6f93" class="np lo jb nl b gy nu nr l ns nt">map_arr = map(lambda x: x**2, arr)<br/>result = reduce(lambda x, y: x + y, map_arr)</span></pre><p id="71a7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如前所述，map 部分将被并行化，reduce 将保持顺序。让我们看一下并行化实施:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f244" class="np lo jb nl b gy nq nr l ns nt">import multiprocessing as mp<br/>from functools import reduce</span><span id="2fa4" class="np lo jb nl b gy nu nr l ns nt">def pow2(x):<br/>    return x**2</span><span id="7b34" class="np lo jb nl b gy nu nr l ns nt">arr = [1, 2, 3, 4, 5]</span><span id="caf4" class="np lo jb nl b gy nu nr l ns nt"># count of avaliable cores, of course you can use less for computations<br/>cores = mp.cpu_count()<br/>pool = mp.Pool(cores)</span><span id="2a90" class="np lo jb nl b gy nu nr l ns nt">map_arr = pool.map(pow2, arr)<br/>result = reduce(lambda x, y: x + y, map_arr)</span><span id="03b6" class="np lo jb nl b gy nu nr l ns nt">pool.close()<br/>pool.join()</span></pre><p id="0a32" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以现在对于这个任务，你使用你的计算机的所有力量！<strong class="ks jc">。map 池对象的</strong>方法假设 map 函数只有一个参数，有一个等价的<strong class="ks jc">。星图</strong>、<strong class="ks jc">、</strong>其中假设了不止一个自变量的星图函数，这些函数的完整描述你可以在这里找到<a class="ae lm" href="https://docs.python.org/3.7/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">。值得一提的是，两者都是<strong class="ks jc">。映射</strong>和<strong class="ks jc">。starmap </strong>按照与输入参数相同的顺序返回映射值。</a></p><p id="5760" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有时，不仅在一个样本上，而且在一批样本上计算 map 函数更有效。如果计算任务足够简单和快速，多处理计算的主要开销将是在进程间传输数据，这会大大降低进程速度。在我的帖子的前一部分，我们讨论了 sklearn 模型的<strong class="ks jc"> n_jobs </strong>参数，让我们创建 base transformer 的通用代码片段，它可以并行化其转换过程，在这种情况下，批处理将是最佳选择。</p><p id="8752" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是 pandas 在基本 sklearn 转换器中应用并行化的代码片段，您可以在以后的管道中使用它:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="5ff4" class="np lo jb nl b gy nq nr l ns nt">import multiprocessing as mp<br/>from sklearn.base import TransformerMixin, BaseEstimator</span><span id="853a" class="np lo jb nl b gy nu nr l ns nt">class ParallelTransformer(BaseEstimator, TransformerMixin):<br/>    def __init__(self,<br/>                 n_jobs=1):<br/>        """<br/>        n_jobs - parallel jobs to run<br/>        """<br/>        self.variety = variety<br/>        self.user_abbrevs = user_abbrevs<br/>        self.n_jobs = n_jobs</span><span id="1d2e" class="np lo jb nl b gy nu nr l ns nt">    def fit(self, X, y=None):<br/>        return self</span><span id="8591" class="np lo jb nl b gy nu nr l ns nt">    def transform(self, X, *_):<br/>        X_copy = X.copy()</span><span id="aa1d" class="np lo jb nl b gy nu nr l ns nt">        cores = mp.cpu_count()<br/>        partitions = 1<br/>        <br/>        if self.n_jobs &lt;= -1:<br/>            partitions = cores<br/>        elif self.n_jobs &lt;= 0:<br/>            partitions = 1<br/>        else:<br/>            partitions = min(self.n_jobs, cores)<br/>        <br/>        if partitions == 1:<br/>            # transform sequentially<br/>            return X_copy.apply(self._transform_one)<br/>        <br/>        # splitting data into batches<br/>        data_split = np.array_split(X_copy, partitions)<br/>        <br/>        pool = mp.Pool(cores)<br/>        <br/>        # Here reduce function - concationation of transformed batches<br/>        data = pd.concat(<br/>            pool.map(self._preprocess_part, data_split)<br/>        )<br/>        <br/>        pool.close()<br/>        pool.join()</span><span id="c4b8" class="np lo jb nl b gy nu nr l ns nt">        return data</span><span id="4d45" class="np lo jb nl b gy nu nr l ns nt">    def _transform_part(self, df_part):<br/>        return df_part.apply(self._transform_one)</span><span id="d6ce" class="np lo jb nl b gy nu nr l ns nt">    def _transform_one(self, line):</span><span id="7c05" class="np lo jb nl b gy nu nr l ns nt">        # some kind of transformations here<br/>        return line</span></pre><p id="9998" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我来总结一下这段代码。确定是并行还是顺序处理数据集。如果是并行的，将所有数据分成<strong class="ks jc"> n_jobs </strong>批并并行转换，然后连接回数据集的转换批。仅此而已！我希望这个代码片段能够帮助您提升您的转换管道。</p><p id="b6a8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我希望你喜欢我的帖子，如果你有进一步的问题，请在评论中提问，我很乐意回答。期待您的反馈！</p><p id="ed92" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">附言:如果你是一个有经验的开发人员，想要为开源做贡献，你可能的任务之一就是帮助好的但未优化的库变得更快并准备好生产。如果不知道，从哪里入手，可以帮助<a class="ae lm" href="https://github.com/EFord36/normalise" rel="noopener ugc nofollow" target="_blank">规格化</a>库，优化其性能。我和这个库的作者没有任何联系，他们不付我钱，它也不是一个广告。只是另一个图书馆，需要你的帮助；)</p></div></div>    
</body>
</html>