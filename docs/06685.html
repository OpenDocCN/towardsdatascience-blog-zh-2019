<html>
<head>
<title>Primary Keys and Group By’s — A Brief SQL Investigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主键和分组依据——简单的 SQL 调查</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/primary-keys-and-group-bys-a-brief-sql-investigation-e0c3a8b20a6e?source=collection_archive---------19-----------------------#2019-09-24">https://towardsdatascience.com/primary-keys-and-group-bys-a-brief-sql-investigation-e0c3a8b20a6e?source=collection_archive---------19-----------------------#2019-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a8b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索 SQL 主键和“Group By”语句之间交互的复杂性</h2></div><p id="a7f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天一个熟人问了我一个有趣的 SQL 问题，但不是典型的查询意义上的；他的问题更多地围绕着对 SQL 底层框架的理解。以下是背景:</p><h1 id="fb56" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">1.问题是</h1><p id="051f" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">该练习来自此<a class="ae mb" href="https://pgexercises.com/questions/aggregates/payback.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL 练习页面</a>，其模式如下:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/cce83e1c962ed316f75d7339fe3a5226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beQkP3YQnt7jxQVGulLRIQ.png"/></div></div></figure><p id="51b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网站询问的 SQL 问题并不重要，但他们公布的解决方案是这样的:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="11e8" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT</strong>  facs.name <strong class="mp iu">AS</strong> name,<br/> facs.initialoutlay/((sum(<br/> <strong class="mp iu">CASE<br/></strong>  <strong class="mp iu">WHEN</strong> memid = 0 <br/>  <strong class="mp iu">THEN</strong> slots * facs.guestcost<br/> <strong class="mp iu">ELSE</strong> slots * membercost<br/> <strong class="mp iu">END</strong>)/3) - facs.monthlymaintenance) <strong class="mp iu">AS</strong> months  <br/><strong class="mp iu">FROM</strong> cd.bookings bks  <br/><strong class="mp iu">INNER JOIN</strong> cd.facilities facs   <br/> <strong class="mp iu">ON</strong> bks.facid = facs.facid  <br/><strong class="mp iu">GROUP BY</strong> facs.facid <br/><strong class="mp iu">ORDER BY</strong> name;</span></pre><p id="7747" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的朋友尝试将线路<code class="fe my mz na mp b"><strong class="kk iu">GROUP BY</strong> facs.facid</code>切换到<code class="fe my mz na mp b"><strong class="kk iu">GROUP BY</strong> facs.name</code>，这中断了查询，并显示消息:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="d262" class="mt lf it mp b gy mu mv l mw mx">column "facs.initialoutlay" must appear in the GROUP BY clause or be used in an aggregate function</span></pre><p id="70da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我朋友问的问题是:</p><blockquote class="nb nc nd"><p id="d66c" class="ki kj ne kk b kl km ju kn ko kp jx kq nf ks kt ku ng kw kx ky nh la lb lc ld im bi translated">为什么上面的查询不适用于交换的行，即使<strong class="kk iu">两列对于每一行都是唯一的？</strong></p></blockquote><p id="ec82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你知道答案，恭喜你，你应该回答我贴在最后的问题！如果你想跳到答案，请滚动到本文的“答案”部分。不然我们就进入解决这个问题的思维过程吧！</p><h1 id="ec75" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">2.方法</h1><p id="cf0d" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">首先，让我们检查一下显而易见的问题——这些列真的是惟一的吗？我们的查询(<code class="fe my mz na mp b">name, facid, initialoutlay, monthlymaintenance</code>)中使用的列有多种组合吗？为了检查这一点，我们在<code class="fe my mz na mp b">facilities</code> <em class="ne"> </em>表中查看这些列的不同组合。</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="eea3" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT DISTINCT</strong> facs.name as name, facs.facid, facs.initialoutlay, facs.monthlymaintenance<br/>    <strong class="mp iu">FROM</strong> cd.bookings bks<br/>    <strong class="mp iu">INNER JOIN</strong> cd.facilities facs<br/>        <strong class="mp iu">ON</strong> bks.facid = facs.facid<br/><strong class="mp iu">ORDER BY</strong> facid;</span><span id="8b1e" class="mt lf it mp b gy ni mv l mw mx">Output:</span><span id="8534" class="mt lf it mp b gy ni mv l mw mx">╔═════════════════╦═══════╦═══════════════╦════════════════════╗<br/>║      name       ║ facid ║ initialoutlay ║ monthlymaintenance ║<br/>╠═════════════════╬═══════╬═══════════════╬════════════════════╣<br/>║ Tennis Court 1  ║     0 ║         10000 ║                200 ║<br/>║ Tennis Court 2  ║     1 ║          8000 ║                200 ║<br/>║ Badminton Court ║     2 ║          4000 ║                 50 ║<br/>║ Table Tennis    ║     3 ║           320 ║                 10 ║<br/>║ Massage Room 1  ║     4 ║          4000 ║               3000 ║<br/>║ Massage Room 2  ║     5 ║          4000 ║               3000 ║<br/>║ Squash Court    ║     6 ║          5000 ║                 80 ║<br/>║ Snooker Table   ║     7 ║           450 ║                 15 ║<br/>║ Pool Table      ║     8 ║           400 ║                 15 ║<br/>╚═════════════════╩═══════╩═══════════════╩════════════════════╝</span></pre><p id="8cb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mp b">Name</code>和<code class="fe my mz na mp b">facid</code>对于每一行都是唯一的，并且 1 对 1，每一对只有一个<code class="fe my mz na mp b">initialoutlay</code>和<code class="fe my mz na mp b">monthlymaintenance</code>值。直观地说，按这两列中的任何一列分组在功能上应该等同于按另一列分组。那么为什么按<code class="fe my mz na mp b">name</code>分组对这个查询不起作用呢？</p><h1 id="c580" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">3.主键</h1><p id="bbd7" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">如果你熟悉 SQL，你可能会有直觉，这是一个<strong class="kk iu">主键</strong>问题。对于那些不知道的人来说，<strong class="kk iu">主键是唯一标识表中每一行的值，</strong>并且对于一行来说它永远不能为“NULL”。但是我们如何找到一个表的指定主键呢？</p><p id="9d5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速的谷歌搜索会给我们以下来自<a class="ae mb" href="https://wiki.postgresql.org/wiki/Retrieve_primary_key_columns" rel="noopener ugc nofollow" target="_blank"> PostgreSQL wiki </a>的代码。在网站的查询部分运行该命令会得到以下结果:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="35fa" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT</strong> a.attname, format_type(a.atttypid, a.atttypmod) <strong class="mp iu">AS</strong> data_type<br/><strong class="mp iu">FROM</strong>   pg_index i<br/><strong class="mp iu">JOIN</strong>   pg_attribute a <strong class="mp iu">ON</strong> a.attrelid = i.indrelid<br/>                     <strong class="mp iu">AND</strong> a.attnum = ANY(i.indkey)<br/><strong class="mp iu">WHERE</strong>  i.indrelid = 'cd.facilities'::regclass<br/><strong class="mp iu">AND</strong>    i.indisprimary;</span><span id="c464" class="mt lf it mp b gy ni mv l mw mx">Output:</span><span id="a407" class="mt lf it mp b gy ni mv l mw mx">╔═════════╦═══════════╗<br/>║ attname ║ data_type ║<br/>╠═════════╬═══════════╣<br/>║ facid   ║ integer   ║<br/>╚═════════╩═══════════╝</span></pre><p id="91e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe my mz na mp b">facid</code>是<code class="fe my mz na mp b">facilities</code>表的主键！现在我们已经确认了可能的原因，但是什么原因使得通过主键分组可以像我们对<code class="fe my mz na mp b">facs.initialoutlay</code>和<code class="fe my mz na mp b">facs.monthlymaintenance</code>所做的那样，加入没有聚合函数的列呢？</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="9d5a" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT</strong>  facs.name <strong class="mp iu">AS</strong> name,<br/> facs.initialoutlay/((sum(        /* &lt;=========== */<br/> <strong class="mp iu">CASE<br/></strong>  <strong class="mp iu">WHEN</strong> memid = 0 <br/>  <strong class="mp iu">THEN</strong> slots * facs.guestcost<br/> <strong class="mp iu">ELSE</strong> slots * membercost<br/> <strong class="mp iu">END</strong>)/3) - facs.monthlymaintenance) <strong class="mp iu">AS</strong> months /* &lt;=========== */<br/><strong class="mp iu">FROM</strong> cd.bookings bks  <br/><strong class="mp iu">INNER JOIN</strong> cd.facilities facs   <br/> <strong class="mp iu">ON</strong> bks.facid = facs.facid  <br/><strong class="mp iu">GROUP BY</strong> facs.facid <br/><strong class="mp iu">ORDER BY</strong> name;</span><span id="44ea" class="mt lf it mp b gy ni mv l mw mx">/* Shouldn't these two columns be inside of an aggregation? */</span></pre><p id="e7d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了回答这个问题，我们看一下<a class="ae mb" href="https://www.postgresql.org/docs/current/sql-select.html#SQL-GROUPBY" rel="noopener ugc nofollow" target="_blank"> PostgreSQL 帮助文档</a>，专门针对<code class="fe my mz na mp b">GROUP BY</code>:</p><blockquote class="nb nc nd"><p id="7e54" class="ki kj ne kk b kl km ju kn ko kp jx kq nf ks kt ku ng kw kx ky nh la lb lc ld im bi translated">当<code class="fe my mz na mp b">GROUP BY</code>存在或任何集合函数存在时，<code class="fe my mz na mp b">SELECT</code>列表表达式引用未分组的列是无效的，除非在集合函数内或当未分组的列在功能上依赖于分组的列时，因为否则对于未分组的列将有不止一个可能的值返回。<strong class="kk iu">如果分组列(或其子集)是包含未分组列的表的主键</strong>，则存在函数依赖。</p></blockquote><p id="0e3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如<a class="ae mb" href="https://stackoverflow.com/questions/3913620/get-all-table-names-of-a-particular-database-by-sql-query" rel="noopener ugc nofollow" target="_blank">栈溢出用户 Tony L. </a>所说:</p><blockquote class="nb nc nd"><p id="8086" class="ki kj ne kk b kl km ju kn ko kp jx kq nf ks kt ku ng kw kx ky nh la lb lc ld im bi translated">按主键分组会在每个组中产生一条记录，这在逻辑上等同于根本不分组/按所有列分组，因此我们可以选择所有其他列。</p></blockquote><p id="8285" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本质上，这意味着按表的主键分组不会导致该表的行发生变化，因此<strong class="kk iu">如果我们按表的主键分组，我们可以调用该表的所有列，而不使用聚合函数</strong>。</p><p id="f279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们重申一下:<strong class="kk iu">假设我们正在查看一个表，按其主键分组与按所有内容分组是一样的，这与根本不分组是一样的</strong> —这些方法中的每一种都将导致每行一个组。一旦你明白了这一点，你就明白了这个问题的症结所在。</p><p id="03ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，类似这样的查询可以工作:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="e013" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">1. Group by everything:</strong></span><span id="0c61" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT</strong> *<br/><strong class="mp iu">FROM</strong> cd.facilities f<br/><strong class="mp iu">GROUP BY</strong> facid, name, membercost, guestcost, initialoutlay, monthlymaintenance<br/><strong class="mp iu">LIMIT</strong> 5</span><span id="2ce5" class="mt lf it mp b gy ni mv l mw mx">OUTPUT:</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/89f9e581b3feb8fb16bf7888dc8ca95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nq0oT4jHu9IIKIhE59jyyw.png"/></div></div></figure><p id="2cf0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其功能上等同于</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="2f18" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">2. Don't group by anything</strong></span><span id="1f30" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT</strong> * <br/><strong class="mp iu">FROM</strong> cd.facilities f<br/><strong class="mp iu">LIMIT 5</strong></span><span id="98a5" class="mt lf it mp b gy ni mv l mw mx">and </span><span id="9924" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">3. Group by primary key but don't aggregate</strong></span><span id="2882" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT</strong> * <br/><strong class="mp iu">FROM</strong> cd.facilities f<br/><strong class="mp iu">GROUP BY </strong>facid<br/><strong class="mp iu">LIMIT 5</strong></span></pre><p id="c45d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都输出相同的值！现在我们有了解决方案。</p><h1 id="7ab1" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">3.答案</h1><p id="c7c0" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">第一个查询有效的原因很简单，那就是<code class="fe my mz na mp b">facid</code>是主键，而<code class="fe my mz na mp b">name</code> <em class="ne"> </em>不是。尽管它们对于每一行都是唯一的，但是表<code class="fe my mz na mp b">facilities</code> <em class="ne"> </em>是用<code class="fe my mz na mp b">facid</code>作为主键创建的，因此当在上面提到的 group by 中使用时，它得到了特殊的处理。</p><p id="43d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们发布的一些替代解决方案如下:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="57e7" class="mt lf it mp b gy mu mv l mw mx"><strong class="mp iu">1. Group by name then aggregate everything else</strong></span><span id="1e73" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT </strong>facs.name as name,<br/> <strong class="mp iu">AVG(</strong>facs.initialoutlay)/((sum(case<br/>   when memid = 0 then slots * facs.guestcost<br/>   else slots * membercost<br/>  end)/3) - <strong class="mp iu">AVG</strong>(facs.monthlymaintenance) as months<br/> <strong class="mp iu">FROM </strong>cd.bookings bks<br/> <strong class="mp iu">INNER JOIN </strong>cd.facilities facs<br/>  <strong class="mp iu">ON</strong> bks.facid = facs.facid<br/> <strong class="mp iu">GROUP BY</strong> facs.name<br/><strong class="mp iu">ORDER BY</strong> name;</span><span id="382a" class="mt lf it mp b gy ni mv l mw mx">Why this works:<br/>Because <em class="ne">facs.name</em> is unique to each row in the <em class="ne">facilities</em> table just as <em class="ne">facid</em> was, we group by <em class="ne">facs.name</em> then add <em class="ne">AVG</em> calls around previously unaggregated <em class="ne">facilities</em> columns.</span><span id="173a" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">2. Group by all facility columns used in the select statement</strong></span><span id="4427" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT</strong>  facs.name as name,<br/> facs.initialoutlay/((sum(case<br/>   when memid = 0 then slots * facs.guestcost<br/>   else slots * membercost<br/>  end)/3) - facs.monthlymaintenance) as months<br/> from cd.bookings bks<br/> <strong class="mp iu">INNER JOIN </strong>cd.facilities facs<br/>  <strong class="mp iu">ON</strong> bks.facid = facs.facid<br/> <strong class="mp iu">GROUP BY</strong> facs.name, facs.initialoutlay, facs.guestcost,     <br/>   facs.monthlymaintenance <br/><strong class="mp iu">ORDER BY</strong> name;</span><span id="4286" class="mt lf it mp b gy ni mv l mw mx">Why this works:<br/>This includes all the values used in the <!-- -->SELECT<!-- --> statement in the <!-- -->GROUP BY<!-- -->, which is the normal <!-- -->GROUP BY<!-- --> logic and syntax.</span></pre><h1 id="c14e" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">4.附加问题</h1><p id="419f" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">主要问题到此结束，但是如果您有兴趣探索更多的怪癖，我在解决张贴的问题时遇到了以下问题。如果你们中的任何人知道为什么，请随时联系我或留下评论！</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="065c" class="mt lf it mp b gy mu mv l mw mx">/* This works (manually lists all columns in the group by)*/</span><span id="7b6c" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT</strong> *<br/><strong class="mp iu">FROM</strong> cd.facilities f<br/><strong class="mp iu">GROUP BY</strong> facid, name, membercost, guestcost, initialoutlay, monthlymaintenance<br/><strong class="mp iu">LIMIT</strong> 5</span><span id="dbf9" class="mt lf it mp b gy ni mv l mw mx">/* This does not (selecting all columns using f.*) */</span><span id="7552" class="mt lf it mp b gy ni mv l mw mx"><strong class="mp iu">SELECT</strong> *<br/><strong class="mp iu">FROM</strong> cd.facilities f<br/><strong class="mp iu">GROUP BY</strong> f.*<br/><strong class="mp iu">LIMIT</strong> 5</span></pre><p id="9617" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，希望这篇文章对你有所帮助！随时查看我的其他教程，并在未来发布新的教程！</p></div></div>    
</body>
</html>