<html>
<head>
<title>Titanic: Love in Data Analytics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">泰坦尼克号:数据分析中的爱情</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/titanic-love-in-data-analytics-1b38b40d7247?source=collection_archive---------24-----------------------#2019-02-25">https://towardsdatascience.com/titanic-love-in-data-analytics-1b38b40d7247?source=collection_archive---------24-----------------------#2019-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1f46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">《泰坦尼克号》一直是我最喜欢的电影之一。自从这部电影在 1997 年被搬上大银幕以来，我已经看过至少 10 遍了。这部电影本质上是一个爱情故事，围绕着 1912 年在这艘臭名昭著的船上的两个主角。一个 17 岁的贵族在一艘豪华的、命运多舛的船上爱上了一个善良但贫穷的艺术家。</p><p id="5aa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结局浪漫又悲伤。当我们为杰克和罗斯短暂的爱情悲伤时，1912 年泰坦尼克号上其余的 891 名乘客发生了什么？为了回答这个问题，我使用了 Kaggle 的乘客名单数据集，用机器学习算法预测生存或死亡困境。</p><p id="6649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这是一个比较两种机器学习算法应用结果的简单练习:</strong> <a class="ae ku" href="https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> K 近邻(KNN) </strong> </a> <strong class="jp ir">和</strong> <a class="ae ku" href="https://www.datascience.com/resources/notebooks/random-forest-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">随机森林</strong> </a> <strong class="jp ir">。</strong>你可以在这里 找到数据集<a class="ae ku" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">的副本来试用。</strong></a></p><p id="8e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么<a class="ae ku" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"> KNN </a>和<a class="ae ku" rel="noopener" target="_blank" href="/the-random-forest-algorithm-d457d499ffcd">随机森林</a>？两者都是<a class="ae ku" href="https://en.wikipedia.org/wiki/Binary_classification" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">二进制分类算法</strong> </a>根据一个对象是否具有某些定性属性的决定，将给定集合的元素标记为两组(预测每组属于哪一组)。两者都是这一类中最流行的算法；其他的只是 KNN 和兰登森林的衍生物。你可以在这里阅读其他二进制分类算法<a class="ae ku" href="https://www.google.com/search?q=types+of+binary+classification+models&amp;oq=types+of+binary+classi&amp;aqs=chrome.0.0j69i57j0l2.3784j1j4&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="kv kw kx"><p id="291d" class="jn jo ky jp b jq jr js jt ju jv jw jx kz jz ka kb la kd ke kf lb kh ki kj kk ij bi translated">当您的问题的答案落在一组有限的可能结果中时，二元分类在数据集上最有效。</p></blockquote><p id="cfc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个例子是确定患者是否患有某种疾病的医学测试——分类属性是疾病的存在。在泰坦尼克号数据集中，我的目标是根据一组属性，如年龄、性别、机票等级等，预测乘客是否在悲惨的事故中幸存。这是一个经典的二元分类，因为只有两种可能的结果:生存或死亡。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="c815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们深入研究代码。请注意，有许多方法可以执行 Python 代码。为了简单和易用，我更喜欢 Python 的 Jupyter 笔记本。</p><p id="a2a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据准备</strong></p><p id="9093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一项任务是从文件中加载训练数据集。Python 提供了一种使用 Pandas 库加载和操作数据集的简单方法。让我们从导入实用程序库和训练数据集开始。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="de7a" class="ls lt iq lo b gy lu lv l lw lx"><strong class="lo ir">import</strong> <strong class="lo ir">pandas</strong> <strong class="lo ir">as</strong> <strong class="lo ir">pd</strong></span><span id="b470" class="ls lt iq lo b gy ly lv l lw lx">df = pd.read_csv('titanic_dataset.csv')<br/>df.head()</span></pre><figure class="lj lk ll lm gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lz"><img src="../Images/94a86feb4ef0a1b382e32976d6ca0f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LCBfq4SNhUoSXyhvLUSdA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Top 5 rows of the data frame</figcaption></figure><p id="6e05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用数据集时，一些记录可能不完整。由于我们的示例包含几十年前的数据，因此会有一些信息丢失。</p><p id="6517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，有一些方法可以填补一些缺失的数据。对于所进行的分析，年龄是表征因素之一。因此，数据集包含所有记录的年龄非常重要。下面的代码将从数据集中计算平均年龄，然后用计算出的平均值填充任何缺失的记录。它还会将始发港未知的乘客的港口设置为“S”。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="a82e" class="ls lt iq lo b gy lu lv l lw lx"><em class="ky"># Fill the missing age with mean</em><br/>mean_age = df['Age'].mean()<br/>df['Age'] = df['Age'].fillna(mean_age)</span><span id="2b03" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># Fill the missing embarked port with S</em><br/>embarked_port = 'S'<br/>df['Embarked'] = df['Embarked'].fillna(embarked_port)</span></pre><p id="a0a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客舱位置可能会潜在地影响乘客存活率。但是，值的数量不太理想，最好删除。可能其他信息如 PassengerID 和 Name 可能不相关。因此，其他列可以从我们的数据集中删除，因为它们没有增加任何实际价值。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="833a" class="ls lt iq lo b gy lu lv l lw lx"><em class="ky"># Drop Cabin &amp; PassengerID columns</em><br/>df = df.drop(['PassengerId', 'Cabin', 'Name'], axis = 1)</span></pre><p id="efd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管人类更喜欢文字，但计算机喜欢和数字打交道。我们数据准备的下一个任务是将人类可读的标签转换成算法可以解释的数字。下面的代码将字符串转换为整数，为每个表示的值添加新列，并根据特定值是否在行中表示，将值 0 或 1 分配给每个列。这将把性别(Sex)和装载列从字符串更改为整数，并将它们作为男性/女性和 CQS(字母代表装载的始发港)添加回数据帧。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="6d42" class="ls lt iq lo b gy lu lv l lw lx">df_sex = pd.get_dummies(df['Sex'])<br/>df_em = pd.get_dummies(df['Embarked'])<br/>df2 = pd.concat([df, df_em, df_sex], axis = 1)</span><span id="cd39" class="ls lt iq lo b gy ly lv l lw lx">df2.head()</span></pre><figure class="lj lk ll lm gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ml"><img src="../Images/58832023217a6103cae2e1996b61d548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EI9VUzd-UidunJW1lFdBeQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Top 5 rows of data frame after data preparation</figcaption></figure><p id="c0de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上表中，我们可以看到第一排的乘客是一名男性，他从一个未知的始发港上船。因此，S 和男性列被设置为 1，C/Q/女性被设置为 0。</p><p id="d0fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">K-最近邻</strong></p><p id="bc36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将回顾的第一个算法是 K-最近邻算法。你可以在<a class="ae ku" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">维基百科</a>中找到更多关于该算法的信息。</p><p id="c2a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码中，我实例化了算法，并使用 StandardScaler 将数据转换为使用相同范围的值。接下来确定如何在不同的训练数据集之间拆分数据，随后使用 cross_val_score 函数调用算法，并在拆分的数据集中找到算法的准确性。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="e7ba" class="ls lt iq lo b gy lu lv l lw lx"><em class="ky"># instantiating a K Nearest Neighbor model</em><br/><strong class="lo ir">from</strong> <strong class="lo ir">sklearn.neighbors</strong> <strong class="lo ir">import</strong> KNeighborsClassifier<br/>clf = KNeighborsClassifier(n_neighbors = 5)</span><span id="2e39" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># import classes and functions from the library to be used in cross validation</em><br/><strong class="lo ir">from</strong> <strong class="lo ir">sklearn.preprocessing</strong> <strong class="lo ir">import</strong> StandardScaler<br/><strong class="lo ir">from</strong> <strong class="lo ir">sklearn.pipeline</strong> <strong class="lo ir">import</strong> Pipeline<br/><strong class="lo ir">from</strong> <strong class="lo ir">sklearn.model_selection</strong> <strong class="lo ir">import</strong> StratifiedKFold, cross_val_score</span><span id="fbe8" class="ls lt iq lo b gy ly lv l lw lx">ss = StandardScaler() </span><span id="165c" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># packages scaler and model together</em><br/>pipeline = Pipeline([('transformer', ss), ('estimator', clf)])</span><span id="8dae" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># how we want to split up the data</em><br/>skf = StratifiedKFold(n_splits=5,random_state=42)</span><span id="ee6e" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># using cross_val_score to train 80% of data and test remaining 20%. Generate 5 scores as it tests 5 different times</em><br/>scores = cross_val_score(pipeline, X, y, cv = skf)</span><span id="7fc2" class="ls lt iq lo b gy ly lv l lw lx">scores</span></pre><p id="e19e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:数组([0.79888268，0.78212291，0.82022472，0.84269663，0.83050847])</p><p id="7677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">cross_val_score 函数将我们之前从文件中加载的初始数据集分成 5 个子集，并对每个子集运行 KNN 算法。然后计算算法的精度。换句话说，它检查算法是否成功地计算出了实际发生的结果。阵列显示，对于每个子集，该算法的准确率为 79–84%。</p><p id="d7f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">何时使用 KNN:</p><ul class=""><li id="4dcb" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">数据被标记</li><li id="a67d" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">数据是无噪声的</li><li id="5f37" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">数据集很小，因为算法被认为是“懒惰的学习者”</li></ul><p id="d021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">随机森林</strong></p><p id="8594" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要讨论的下一个算法是随机森林。同样，你可以在<a class="ae ku" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">维基百科</a>中找到更多关于该算法的信息。</p><p id="4f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Python 中使用该算法非常简单。我们再次使用具有相同输入和预期输出的 cross_val_score 函数。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="09e7" class="ls lt iq lo b gy lu lv l lw lx"><em class="ky"># instantiating a K Random Forest model with the default arguments</em><br/><strong class="lo ir">from</strong> <strong class="lo ir">sklearn.ensemble</strong> <strong class="lo ir">import</strong> RandomForestClassifier<br/>clf_rf = RandomForestClassifier()</span><span id="f7ae" class="ls lt iq lo b gy ly lv l lw lx"><strong class="lo ir">from</strong> <strong class="lo ir">sklearn.model_selection</strong> <strong class="lo ir">import</strong> cross_val_score, StratifiedKFold  </span><span id="0d65" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># how we want to split up the data </em><br/>skf_rf = StratifiedKFold(n_splits = 5, shuffle = <strong class="lo ir">True</strong>, random_state = 42)</span><span id="f0f2" class="ls lt iq lo b gy ly lv l lw lx"><em class="ky"># using cross_val_score to train 80% of data and test remaining 20%. Generate 5 scores as it tests 5 different times</em><br/>score_rf = cross_val_score(clf_rf, X, y, cv = skf_rf)</span><span id="d06b" class="ls lt iq lo b gy ly lv l lw lx">score_rf</span></pre><p id="a922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:数组([0.81005587，0.77094972，0.80898876，0.85393258，0.82485876])</p><p id="3612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，对于 KNN，cross_val_score 函数对随机森林的作用类似。它分割初始数据集，对每个子集运行算法，然后计算算法的准确性。阵列显示，对于每个子集，该算法的准确率为 77–85%。</p><p id="a958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">何时使用随机福里斯特:</p><ul class=""><li id="8184" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">大型数据集</li><li id="9bbd" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">不要过度拟合</li><li id="495d" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">数据集包含缺失数据，因为算法可以自动估计它们。可以使用的其他度量是切比雪夫、余弦等。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="575a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">外卖:</strong></p><p id="3cb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的 KNN 模型中，一个值得注意的观察是<a class="ae ku" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank"> StandardScaler </a>的加入，这是包含不同规模变量的数据集中的一个必要步骤。在《泰坦尼克号》中，值为 5 到 50 的年龄列与 3 美元到 125 美元的票价列相比具有不同的比例。StandardScaler 执行<strong class="jp ir">标准化</strong>的任务。我发现这种利用极大地提高了我 KNN 模型的准确性，从基线的 62%提高到平均 81%。</p><p id="74fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有最小训练阶段的 KNN 对于像泰坦尼克号这样的较小数据集是理想的，因为 KNN 在测试阶段保留所有的训练数据。在超过 100k 行的大型数据集中，随机森林可能更理想。与 KNN 相比，随机森林模型建立标签/分类所需的初始训练时间更长。然而，应用程序要快得多，因为事实模型是在新对象通过时创建的。</p><p id="f289" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">海难导致如此多生命损失的原因之一是没有足够的救生艇容纳乘客和船员。虽然幸存有一些运气成分，但是一些群体比其他群体更有可能幸存。女性性别和存活率之间有很强的相关性。尽管男性乘客比女性乘客多 84%,但女性幸存者比男性多。</p><p id="978c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当面对种类繁多的机器学习算法时，初学者提出的一个典型问题是“我应该使用哪种算法？”这个问题的答案取决于许多因素，包括:(1)数据的大小、质量和性质；(2)可用的计算时间；(3)任务的紧迫性；以及(4)你想用这些数据做什么。</p><p id="1d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个有用的 scikit-learn 流程图为您提供了一个映射指南，帮助您根据数据大小、数据类型、预期结果和数据结构来确定最佳算法。</p><figure class="lj lk ll lm gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi na"><img src="../Images/0e09a67c871078a388d4af6a80231bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NR51X0FDjLB13u4WdYc4g.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Credit: © 2007–2018, scikit-learn developers (BSD License)</figcaption></figure><p id="bf38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><p id="04ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二元分类。在<em class="ky">维基百科</em>中。检索于 2019 年 2 月 23 日，来自 https://en.wikipedia.org/wiki/Binary_classification<a class="ae ku" href="https://en.wikipedia.org/wiki/Binary_classification" rel="noopener ugc nofollow" target="_blank"/></p><p id="66f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择正确的评估者。在<em class="ky"> Scitkit-Learn </em>中。检索于 2019 年 2 月 23 日，来自<a class="ae ku" href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/tutorial/machine _ learning _ map/index . html</a></p><p id="64e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ku" href="http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html" rel="noopener ugc nofollow" target="_blank">sci kit-learn:Python 中的机器学习</a>，Pedregosa <em class="ky">等人</em>，JMLR 12，第 2825–2830 页，2011 年。</p></div></div>    
</body>
</html>