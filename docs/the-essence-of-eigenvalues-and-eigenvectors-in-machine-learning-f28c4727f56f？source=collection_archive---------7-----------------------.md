# æœºå™¨å­¦ä¹ ä¸­ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡çš„æœ¬è´¨

> åŽŸæ–‡ï¼š<https://towardsdatascience.com/the-essence-of-eigenvalues-and-eigenvectors-in-machine-learning-f28c4727f56f?source=collection_archive---------7----------------------->

## äº†è§£å®žé™…åº”ç”¨

å•è¯ **Eigen** å¯èƒ½æœ€æœ‰ç”¨çš„ç¿»è¯‘æ˜¯å¾·è¯­ï¼Œæ„æ€æ˜¯**ç‰¹æ€§ã€‚**æ‰€ä»¥å½“æˆ‘ä»¬è°ˆè®ºçŸ©é˜µçš„ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡æ—¶ï¼Œæˆ‘ä»¬è°ˆè®ºçš„æ˜¯å¯»æ‰¾çŸ©é˜µçš„ç‰¹å¾ã€‚

åœ¨æ·±å…¥ç ”ç©¶ç‰¹å¾å‘é‡ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆäº†è§£ä»€ä¹ˆæ˜¯çŸ©é˜µé™¤äº†æ˜¯ä¸€ä¸ªæ•°å­—çš„çŸ©å½¢é˜µåˆ—ï¼Œå®ƒè¿˜ä»£è¡¨ä»€ä¹ˆï¼Ÿ

æ‰€ä»¥çŸ©é˜µåªæ˜¯åº”ç”¨äºŽå‘é‡çš„çº¿æ€§å˜æ¢ã€‚å¯ä»¥æœ‰ä¸åŒç±»åž‹çš„å˜æ¢åº”ç”¨äºŽå‘é‡ï¼Œä¾‹å¦‚-

è®©æˆ‘ä»¬æ¥çœ‹ä¸€äº›çŸ©é˜µå˜æ¢

```
img = cv2.imread(path_to_image,flags=cv2.IMREAD_UNCHANGED)
img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
rows,cols,_ = img.shape
M = np.float32([[1, -np.sin(.1), 0],[0,  np.cos(.1), 0]])
out = cv2.warpAffine(img,M,(cols,rows))
```

![](img/28082773fb369ae48e70ead1454d2ba1.png)

è¿™ä¸ªçŸ©é˜µ M å’Œå›¾åƒæœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿå®ƒç»™å›¾åƒä¸­çš„æ¯ä¸ªçŸ¢é‡å¼•å…¥äº†æ°´å¹³å‰ªåˆ‡ã€‚

```
#Let's try this one
M = cv2.getRotationMatrix2D((cols/2,rows/2),45,1)
out = cv2.warpAffine(img,M,(cols,rows))
print(M)
=> [[   0.70710678    0.70710678 -124.36235483]
 [  -0.70710678    0.70710678  501.76271632]]
```

![](img/5fb5648f4f5d3a27b9f174159df419b6.png)

é‚£ä¹ˆçŸ©é˜µ M å¯¹å›¾åƒåšäº†ä»€ä¹ˆï¼Ÿæ‰€ä»¥è¿™ä¸ªçº¿æ€§å˜æ¢ M å°†å›¾åƒä¸­çš„æ¯ä¸ªå‘é‡æ—‹è½¬äº† 45 åº¦ã€‚

```
M = [[  1\.   0\. 100.]
 [  0\.   1\. 100.]]
out = cv2.warpAffine(img,M,(cols,rows))
```

![](img/8cb96d544a9a622cfed9919b48217c8d.png)

å®ƒåœ¨æ°´å¹³å’Œåž‚ç›´æ–¹å‘ä¸Šå¹³ç§»å›¾åƒã€‚

æ—‹è½¬æ²¡æœ‰æœ¬å¾çŸ¢[180 åº¦æ—‹è½¬çš„æƒ…å†µé™¤å¤–]ã€‚å¯¹äºŽçº¯å‰ªåˆ‡ï¼Œæ°´å¹³å‘é‡æ˜¯ä¸€ä¸ªç‰¹å¾å‘é‡ã€‚å‘é‡é•¿åº¦æ”¹å˜çš„å› å­å«åšç‰¹å¾å€¼ã€‚

# åº”ç”¨ç¨‹åº

**ç‰¹å¾å€¼**å’Œ**ç‰¹å¾å‘é‡**çš„æ¦‚å¿µåœ¨å¾ˆå¤šå®žé™…åº”ç”¨ä¸­ä½¿ç”¨ã€‚æˆ‘å°†åªè®¨è®ºå…¶ä¸­çš„å‡ ä¸ªã€‚

## ä¸»æˆåˆ†åˆ†æž

PCA æ˜¯ä¸€ç§éžå¸¸æµè¡Œçš„ç»å…¸é™ç»´æŠ€æœ¯ï¼Œå®ƒä½¿ç”¨è¿™ä¸€æ¦‚å¿µé€šè¿‡é™ä½Žæ•°æ®çš„ç»´æ•°æ¥åŽ‹ç¼©æ•°æ®ï¼Œå› ä¸ºç»´æ•°ç¾éš¾ä¸€ç›´æ˜¯ç»å…¸è®¡ç®—æœºè§†è§‰å¤„ç†å›¾åƒç”šè‡³æœºå™¨å­¦ä¹ ä¸­éžå¸¸å…³é”®çš„é—®é¢˜ï¼Œå…·æœ‰é«˜ç»´æ•°çš„ç‰¹å¾å¢žåŠ äº†æ¨¡åž‹å®¹é‡ï¼Œè¿™åè¿‡æ¥éœ€è¦å¤§é‡çš„æ•°æ®æ¥è®­ç»ƒã€‚

è¿™æ˜¯ä¸€ç§ä½¿ç”¨ç®€å•çš„çŸ©é˜µè¿ç®—å’Œç»Ÿè®¡æ¥è®¡ç®—åŽŸå§‹æ•°æ®åœ¨ç›¸åŒæˆ–æ›´å°‘ç»´åº¦ä¸Šçš„æŠ•å½±çš„æ–¹æ³•ã€‚

è®¾æ•°æ®çŸ©é˜µ **ð—** ä¸ºð‘›Ã—ð‘å¤§å°ï¼Œå…¶ä¸­ n ä¸ºæ ·æœ¬æ•°ï¼Œp ä¸ºæ¯ä¸ªæ ·æœ¬çš„ç»´æ•°ã€‚åœ¨ PCA ä¸­ï¼Œæœ¬è´¨ä¸Šæˆ‘ä»¬é€šè¿‡**ç‰¹å¾å€¼**åˆ†è§£å¯¹è§’åŒ– X çš„åæ–¹å·®çŸ©é˜µï¼Œå› ä¸ºåæ–¹å·®çŸ©é˜µæ˜¯å¯¹ç§°çš„

```
***C = VLVáµ€******In Python-***from numpy import cov
from numpy.linalg import eigX = array([[-2, -2], [0, 0], [2, 2]])
C = cov(X)
#To do eigendecomposition of C
values, vectors = eig(C)
#Project data into pricipal directions
P = vectors.T.dot(X.T)
print(P.T)Output-
[[-2.82842712  0\.        ]
 [ 0\.          0\.        ]
 [ 2.82842712  0\.        ]]
```

å…¶ä¸­ **ð•** æ˜¯ä¸€ä¸ªç”±**ä¸ªç‰¹å¾å‘é‡**ç»„æˆçš„çŸ©é˜µ(æ¯ä¸€åˆ—éƒ½æ˜¯ä¸€ä¸ªç‰¹å¾å‘é‡)ï¼Œè€Œ **ð‹** æ˜¯ä¸€ä¸ªå¯¹è§’çŸ©é˜µï¼Œå…¶ä¸­**ä¸ªç‰¹å¾å€¼** ðœ†ð‘–åœ¨å¯¹è§’çº¿ä¸ŠæŒ‰é™åºæŽ’åˆ—ã€‚

> å¯¹ç§°çŸ©é˜µçš„ç‰¹å¾å‘é‡ï¼Œè¿™é‡Œæ˜¯åæ–¹å·®çŸ©é˜µï¼Œæ˜¯å®žçš„å’Œæ­£äº¤çš„ã€‚

æ•°æ®çš„**ç‰¹å¾å‘é‡**ç§°ä¸º*ä¸»è½´*æˆ–*ä¸»æ–¹å‘*ã€‚æ•°æ®åœ¨ä¸»è½´ä¸Šçš„æŠ•å½±ç§°ä¸º*ä¸»åˆ†é‡ã€‚*

æˆ‘ä»¬é€šè¿‡åœ¨æ¯”åŽŸå§‹ç»´åº¦æ›´å°‘çš„ä¸»æ–¹å‘ä¸ŠæŠ•å½±æ¥é™ä½Žæ•°æ®çš„ç»´åº¦ã€‚

## è°±èšç±»

K-Means æ˜¯æœ€æµè¡Œçš„èšç±»ç®—æ³•ï¼Œä½†å®ƒæœ‰å‡ ä¸ªç›¸å…³çš„é—®é¢˜ï¼Œå¦‚ä¾èµ–äºŽèšç±»åˆå§‹åŒ–å’Œç‰¹å¾çš„ç»´æ•°ã€‚åŒæ ·ï¼Œå¦‚æžœä½ çš„æ˜Ÿå›¢ä¸æ˜¯çƒå½¢çš„ï¼Œå®ƒä¹Ÿä¼šé¢ä¸´é—®é¢˜ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º

```
from sklearn.datasets import make_moons
X_mn, y_mn = make_moons(150, noise=.07, random_state=21)
fig, ax = plt.subplots(figsize=(9,7))
ax.set_title('Data with ground truth labels ', fontsize=18, fontweight='demi')
ax.scatter(X_mn[:, 0], X_mn[:, 1],c=y_mn,s=50, cmap='viridis')
```

![](img/1e6b3541ef593f8531be61e9cc81578f.png)

è°±èšç±»æ˜¯ä½¿ç”¨çŸ©é˜µçš„**ç‰¹å¾å‘é‡**æ¥å¯»æ‰¾ K ä¸ªèšç±»çš„ä¸€ç³»åˆ—æ–¹æ³•ã€‚å®ƒå¯ä»¥å¤„ç†è¿™äº›é—®é¢˜ï¼Œå¹¶è½»æ¾èƒœè¿‡å…¶ä»–èšç±»ç®—æ³•ã€‚

è¿™é‡Œæ•°æ®ä»¥å›¾è¡¨çš„å½¢å¼è¡¨ç¤ºã€‚çŽ°åœ¨ï¼Œèšç±»å¯ä»¥è¢«è®¤ä¸ºæ˜¯ç”Ÿæˆå›¾å‰²ï¼Œå…¶ä¸­ä¸¤ä¸ªèšç±» A å’Œ B ä¹‹é—´çš„å‰²(Aï¼ŒB)è¢«å®šä¹‰ä¸ºä¸¤ä¸ªèšç±»ä¹‹é—´çš„æƒé‡è¿žæŽ¥çš„æ€»å’Œã€‚æ¯”å¦‚è¯´-

![](img/e40657c4be03909225c12aeb37361002.png)

ä¸ºäº†æ‰¾åˆ°æœ€ä½³èšç±»ï¼Œæˆ‘ä»¬éœ€è¦æœ€å°å‰²ï¼Œæœ€å°å‰²æ–¹æ³•çš„ç›®æ ‡æ˜¯æ‰¾åˆ°å…·æœ‰æœ€å°æƒé‡å’Œè¿žæŽ¥çš„ä¸¤ä¸ªèšç±» A å’Œ Bã€‚

åœ¨è°±èšç±»ä¸­ï¼Œä½¿ç”¨ä»Žå›¾çš„é‚»æŽ¥çŸ©é˜µå’Œåº¦çŸ©é˜µè®¡ç®—çš„å›¾æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µæ¥è¿‘ä¼¼è¿™ä¸ªæœ€å°å‰²ç›®æ ‡ã€‚è¯æ®è§[æœ¬](https://sites.cs.ucsb.edu/~veronika/SpectralClustering.pdf)

## ç®—æ³•

ç»™å®š:ä¸€ä¸ªæœ‰ð‘›é¡¶ç‚¹å’Œè¾¹æƒé‡ð‘Šð‘–ð‘—çš„å›¾ï¼ŒæœŸæœ›èšç±»æ•°ð‘˜

*   æž„å»º(æ ‡å‡†åŒ–)å›¾æ‹‰æ™®æ‹‰æ–¯ð¿ ðº ð‘‰ï¼Œð¸=ð·ð‘Š
*   æ±‚ð¿çš„ð‘˜æœ€å°ç‰¹å¾å€¼å¯¹åº”çš„ð‘˜ç‰¹å¾å‘é‡
*   è®¾ u æ˜¯ç‰¹å¾å‘é‡çš„ n Ã— ð‘˜çŸ©é˜µ
*   ç”¨ð‘˜-means æ‰¾å‡ºð‘˜ç°‡ð¶â€²è®©ð‘¥ð‘–â€™æ˜¯ U 5 çš„è¡Œã€‚å¦‚æžœð‘¥ð‘–â€™è¢«åˆ†é…åˆ°èšç±» jï¼Œåˆ™å°†æ•°æ®ç‚¹ð‘¥ð‘–åˆ†é…åˆ°ð‘—'th èšç±»

```
from sklearn.neighbors import radius_neighbors_graph
from scipy.sparse import csgraph
from sklearn.cluster import KMeans#Create adjacency matrix from the dataset
A = radius_neighbors_graph(X_mn,0.4,mode='distance', metric='minkowski', p=2, metric_params=**None**, include_self=**False**)
A = A.toarray()'''Next find out graph Laplacian matrix, which is defined as the L=D-A where A is our adjecency matrix we just saw and D is a diagonal degree matrix, every cell in the diagonal is the sum of the weights for that point'''L = csgraph.laplacian(A, normed=**False**)
eigval, eigvec = np.linalg.eig(L)
```

> çŽ°åœ¨ï¼Œä½¿ç”¨ð‘˜-means æ‰¾åˆ°ð‘˜ç¾¤é›†ð¶è®©ð‘¥ð‘–æ˜¯ eigvec çš„è¡Œã€‚æœ€åŽï¼Œä¸ºäº†å°†æ•°æ®ç‚¹åˆ†é…åˆ°èšç±»ä¸­ï¼Œå¦‚æžœð‘¥ð‘–è¢«åˆ†é…åˆ°èšç±» jï¼Œåˆ™å°†ð‘¥ð‘–åˆ†é…åˆ°ð‘—'th èšç±»
> 
> ç¬¬äºŒå°ç‰¹å¾å‘é‡ï¼Œä¹Ÿç§°ä¸º Fiedler å‘é‡ï¼Œç”¨äºŽé€šè¿‡å¯»æ‰¾æœ€ä½³åˆ†è£‚ç‚¹æ¥é€’å½’åœ°äºŒåˆ†å›¾ã€‚

*å‚è§å®Œæ•´ç¤ºä¾‹ä»£ç * [*æ­¤å¤„*](https://github.com/ranjeetthakur/ml_codebase/blob/master/Spectral_clustering.ipynb)

[è°±èšç±»çš„å˜ä½“](https://repository.upenn.edu/cgi/viewcontent.cgi?article=1101&context=cis_papers)ç”¨äºŽè®¡ç®—æœºè§†è§‰ä¸­åŸºäºŽåŒºåŸŸæè®®çš„å¯¹è±¡æ£€æµ‹å’Œè¯­ä¹‰åˆ†å‰²ã€‚

## è®¡ç®—æœºè§†è§‰ä¸­çš„å…´è¶£ç‚¹æ£€æµ‹

æœ€åŽæˆ‘æ¥è®¨è®ºä¸€ä¸‹ AI ä¸‹æˆ‘æœ€å–œæ¬¢çš„é¢†åŸŸï¼Œå°±æ˜¯è®¡ç®—æœºè§†è§‰ã€‚åœ¨è®¡ç®—æœºè§†è§‰ä¸­ï¼Œå›¾åƒä¸­çš„å…´è¶£ç‚¹æ˜¯åœ¨å…¶é‚»åŸŸä¸­å”¯ä¸€çš„ç‚¹ã€‚è¿™äº›ç‚¹åœ¨ç»å…¸çš„è®¡ç®—æœºè§†è§‰ä¸­èµ·ç€é‡è¦çš„ä½œç”¨ï¼Œå®ƒä»¬è¢«ç”¨ä½œç‰¹å¾ã€‚

è§’ç‚¹æ˜¯æœ‰ç”¨çš„å…´è¶£ç‚¹ï¼Œä»¥åŠå…¶ä»–æ›´å¤æ‚çš„å›¾åƒç‰¹å¾ï¼Œå¦‚ SIFTã€SURF å’Œ HOG ç­‰ã€‚æˆ‘å°†è®¨è®ºä¸€ç§è¿™æ ·çš„è§’ç‚¹æ£€æµ‹æ–¹æ³•ã€‚

![](img/14a56b68ac68b9e76c68b6e26975d84b.png)

[http://www.cs.cmu.edu/~16385/s17/Slides/6.2_Harris_Corner_Detector.pdf](http://www.cs.cmu.edu/~16385/s17/Slides/6.2_Harris_Corner_Detector.pdf)

é€è¿‡ä¸€ä¸ªå°çª—å£å¾ˆå®¹æ˜“è®¤å‡ºè§’è½ã€‚

![](img/442c8197226fe7915bad50ea69bafbf6.png)

å¦‚æžœçª—å£å†…éƒ¨æœ‰ä¸€ä¸ªè§’ï¼Œç§»åŠ¨çª—å£åº”è¯¥ä¼šåœ¨å¼ºåº¦ E ä¸Šäº§ç”Ÿå¾ˆå¤§çš„å˜åŒ–ã€‚

## å“ˆé‡Œæ–¯è§’æŽ¢æµ‹å™¨

è¿™ä¸ªç®—æ³•-

*   è®¡ç®—å°åŒºåŸŸä¸Šçš„å›¾åƒæ¢¯åº¦

```
imggray = cv2.imread('checkerboard.png',0)
i_x = cv2.Sobel(imggray,cv2.CV_64F,1,0,ksize=5)
i_y = cv2.Sobel(imggray,cv2.CV_64F,0,1,ksize=5)
```

*   è®¡ç®—åæ–¹å·®çŸ©é˜µ

```
# Calculate the product of derivates in each direction
i_xx, i_xy, i_yy = multiply(i_x, i_x), multiply(i_x, i_y), multiply(i_y, i_y)# Calculate the sum of product of derivates
s_xx, s_xy, s_yy = cv2.GaussianBlur(i_xx, (5,5), 0), cv2.GaussianBlur(i_xy, (5,5), 0), cv2.GaussianBlur(i_yy, (5,5), 0)
```

*   è®¡ç®—**ç‰¹å¾å‘é‡**å’Œ**ç‰¹å¾å€¼ã€‚**

Harris æè¿°äº†ä¸€ç§æ›´å¿«çš„è¿‘ä¼¼æ–¹æ³•**â€”â€”é¿å…è®¡ç®—ç‰¹å¾å€¼ï¼Œåªéœ€è®¡ç®—è¿¹å’Œè¡Œåˆ—å¼ã€‚ç»“åˆè¿™ä¸¤ä¸ªå±žæ€§ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºä¸€ä¸ªåº¦é‡å€¼*è§’åº¦* -R**

> **çŸ©é˜µçš„è¡Œåˆ—å¼=ç‰¹å¾å€¼çš„ä¹˜ç§¯**
> 
> **çŸ©é˜µçš„è¿¹=ç‰¹å¾å€¼ä¹‹å’Œ**

```
# Compute the response of the detector at each point
k = .04 # Recommended value between .04 and .06
det_h = multiply(s_xx, s_yy) - multiply(s_xy, s_xy)
trace_h = s_xx + s_yy
R = det_h - k*multiply(trace_h, trace_h)
```

*   **ä½¿ç”¨**ç‰¹å¾å€¼**ä¸Šçš„é˜ˆå€¼æ¥æ£€æµ‹è§’ç‚¹**

```
ratio = .2 # Number to tweak
thresh = abs(R) > ratio * abs(R).max()
```

> **å¦‚æžœä»»ä¸€ä¸ª**ç‰¹å¾å€¼**æŽ¥è¿‘ 0ï¼Œé‚£ä¹ˆè¿™ä¸æ˜¯ä¸€ä¸ªè§’ç‚¹ï¼Œæ‰€ä»¥å¯»æ‰¾ä¸¤è€…éƒ½å¤§çš„ä½ç½®ã€‚e åœ¨æ‰€æœ‰æ–¹å‘ä¸Šå‡ ä¹Žéƒ½æ˜¯å¸¸æ•°ã€‚**
> 
> **Î»2 >> Î»1 æˆ–Î»1 >> Î»2 æç»˜äº†ä¸€æ¡è¾¹**
> 
> **Î»1 å’ŒÎ»2 è¾ƒå¤§ï¼ŒÎ»1 ~ Î»2 E åœ¨å„ä¸ªæ–¹å‘éƒ½å¢žå¤§**

***å‚è§å®Œæ•´ç¤ºä¾‹ä»£ç * [*æ­¤å¤„*](https://github.com/ranjeetthakur/ml_codebase/blob/master/Harris%20%26%20Stephens%20Corner%20Detector.ipynb)**

# **å‚è€ƒ**

> **å½’ä¸€åŒ–åˆ‡å‰²å’Œå›¾åƒåˆ†å‰²ã€‚å²å’Œé©¬åˆ©å…‹ï¼Œ2000 å¹´**
> 
> **ä¸€ä¸ªç»„åˆçš„ç»„åˆå’Œè¾¹ç¼˜æ£€æµ‹å™¨ï¼Œå…‹é‡Œæ–¯å“ˆé‡Œæ–¯å’Œè¿ˆå…‹æ–¯è’‚èŠ¬æ–¯ï¼Œ1988 å¹´**
> 
> **å›¾çš„ä»£æ•°è¿žé€šæ€§ M. Fiedlerï¼Œ1973**