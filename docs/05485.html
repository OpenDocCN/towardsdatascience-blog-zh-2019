<html>
<head>
<title>Plant Disease Detection Web Application using Fastai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Fastai 的植物病害检测 Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plant-disease-detection-web-application-using-fastai-b0c389b82371?source=collection_archive---------7-----------------------#2019-08-13">https://towardsdatascience.com/plant-disease-detection-web-application-using-fastai-b0c389b82371?source=collection_archive---------7-----------------------#2019-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用 fast.ai 实现最先进的结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d26005e709185c2210c5e8e70957b0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKUvZfHReYQvuh83B1CWPg.jpeg"/></div></figure><h1 id="964b" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="97dc" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用 FastAi 创建一个人工智能 web 应用程序，该应用程序可以检测<strong class="lk iu">植物</strong>中的<strong class="lk iu">疾病</strong>，FastAi 构建在脸书深度学习平台<strong class="lk iu"> PyTorch </strong>之上。据联合国粮食及农业组织(UN)称，跨境<strong class="lk iu">植物害虫</strong>和<strong class="lk iu">疾病</strong>影响粮食作物，给农民造成重大损失，威胁粮食安全。</p><blockquote class="me"><p id="9a6b" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">Resnet34 模型的准确率达到 99.654%</p></blockquote><h1 id="94c4" class="kq kr it bd ks kt ku kv kw kx ky kz la jz mo ka lc kc mp kd le kf mq kg lg lh bi translated">动机</h1><p id="84ff" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这个挑战，我使用了"<a class="ae mr" href="https://plantvillage.psu.edu/" rel="noopener ugc nofollow" target="_blank"><strong class="lk iu">plan village</strong></a><strong class="lk iu">"</strong>数据集。该数据集包含一个开放的植物健康图像库，以支持移动疾病诊断的开发。该数据集包含 54，309 幅图像。这些图像涵盖了 14 种作物:<em class="ms">苹果、蓝莓、樱桃、葡萄、橙子、桃子、甜椒、土豆、覆盆子、大豆、南瓜、草莓和番茄</em>。它包含 17 种基础疾病、4 种细菌性疾病、2 种霉菌(卵菌)疾病、2 种病毒性疾病和 1 种由螨虫引起的疾病的图像。12 种作物也有健康叶片的图像，这些叶片没有明显受到疾病的影响。</p><h1 id="549c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">平台</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/29c3ea8623381ab98348e2cf0e5cb222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tX5wuhfLPeinWsdEemi3Q.jpeg"/></div></div></figure><p id="6d72" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我用过<strong class="lk iu"> <em class="ms">谷歌云平台</em> </strong>，基础平台叫<code class="fe nd ne nf ng b">n1-highmem-8</code>，每小时收费 0.12 美元。安装一个 P4 图形处理器每小时要花费 0.26 美元，所以两者加起来总共是每小时 0.38 美元。以及建议的 200GB 标准磁盘存储大小，将会有每月 9.60 美元的<strong class="lk iu">额外费用</strong>。对于完整的演练，设置访问<a class="ae mr" href="https://course.fast.ai/start_gcp.html" rel="noopener ugc nofollow" target="_blank">这里</a>！</p><h1 id="3d80" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">培养</h1><p id="369c" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我使用的是建立在 Pytorch 之上的 fastai。数据集由来自<a class="ae mr" href="https://plantvillage.org/" rel="noopener ugc nofollow" target="_blank"> PlantVillage </a>数据集的 38 个疾病类别和来自斯坦福背景图像<a class="ae mr" href="http://dags.stanford.edu/projects/scenedataset.html" rel="noopener ugc nofollow" target="_blank"> DAGS </a>开放数据集的 1 个背景类别组成。<strong class="lk iu">数据集的 80%用于训练，20%用于验证。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/8d59977a26999ace42f9e317dd98b182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuMNJbzhEqQGEx2KlvvGcw.jpeg"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Source: Google Images</figcaption></figure><p id="c931" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们将使用预先培训的<strong class="lk iu"> resnet34 </strong>模型来解决培训中的问题。</p><p id="bbda" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">用下面三行开始每个笔记本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ac37" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">jupyter 笔记本中以' % '开头的线条称为<a class="ae mr" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk iu">线条魔法</strong> </a>。这些不是 Python 要执行的指令，而是 Jupyter notebook 的指令。</p><p id="a5de" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">前两行将确保每当您在库中进行任何更改时自动重新加载。第三行显示笔记本中的图表和图形。</p><p id="3417" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">导入所有导入库:</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="14ee" class="ns kr it ng b gy nt nu l nv nw">from fastai import *<br/>from fastai.vision import *<br/>from fastai.metrics import error_rate, accuracy</span></pre><p id="9e57" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">现在，给出数据集的路径(在我的例子中，它在根目录中):</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="77af" class="ns kr it ng b gy nt nu l nv nw">PATH_IMG = Path('PlantVillage/')</span></pre><p id="d27b" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">批量意味着我们将一次输入 x 张图像，以更新我们深度学习模型的参数。如果较小的 GPU 使用 16 或 32 而不是 64，则将批量大小设置为 64。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="9d42" class="ns kr it ng b gy nt nu l nv nw">bs = 64</span></pre><p id="c2ff" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated"><code class="fe nd ne nf ng b">ImageDataBunch</code>用于根据图像进行分类。</p><p id="d6bb" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated"><a class="ae mr" href="https://docs.fast.ai/vision.data#ImageDataBunch.from_folder" rel="noopener ugc nofollow" target="_blank">imagedata bunch . from _ folder</a>自动从文件夹名称中获取标签名称。fastai 库有<a class="ae mr" href="https://docs.fast.ai/" rel="noopener ugc nofollow" target="_blank">很棒的文档</a>来浏览他们的库函数，并附有如何使用它们的实例。一旦加载了数据，我们还可以通过使用。标准化为 ImageNet 参数。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="08d9" class="ns kr it ng b gy nt nu l nv nw">img_data = ImageDataBunch.from_folder(path=PATH_IMG, train='train', valid='val', ds_tfms=get_transforms(), size=224, bs=bs)</span><span id="f74f" class="ns kr it ng b gy nx nu l nv nw">img_data.normalize(imagenet_stats)</span></pre><ul class=""><li id="9ea4" class="ny nz it lk b ll my lo mz lr oa lv ob lz oc md od oe of og bi translated"><code class="fe nd ne nf ng b">path</code>图片目录的路径。</li><li id="749d" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated"><code class="fe nd ne nf ng b">ds_tfms</code>图像所需的变换。这包括图像的居中、裁剪和缩放。</li><li id="b98c" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated"><code class="fe nd ne nf ng b">size</code>图像要调整的大小。这通常是一个正方形的图像。这样做是因为 GPU 中的限制，即 GPU 只有在必须对所有图像进行类似计算(如矩阵乘法、加法等)时才会执行得更快。</li></ul><p id="9ca0" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">为了查看图像的随机样本，我们可以使用。show_batch()函数 ImageDataBunch 类。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="a076" class="ns kr it ng b gy nt nu l nv nw">img_data.show_batch(rows=3, figsize=(10,8))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi om"><img src="../Images/da21e6284ff2643ad7e4cf60d45d7960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtB3ApUfBp9Aui3Zm9LoVQ.png"/></div></div></figure><p id="c3f8" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">让我们打印数据中出现的所有数据类。如上所述，我们总共有 39 个类别的图像！</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="c7af" class="ns kr it ng b gy nt nu l nv nw">img_data.classes</span><span id="d5db" class="ns kr it ng b gy nx nu l nv nw">''' <br/>Output of img_data.classes:<br/>['Apple___Apple_scab',<br/> 'Apple___Black_rot',<br/> 'Apple___Cedar_apple_rust',<br/> 'Apple___healthy',<br/> 'Blueberry___healthy',<br/> 'Cherry_(including_sour)___Powdery_mildew',<br/> 'Cherry_(including_sour)___healthy',<br/> 'Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot',<br/> 'Corn_(maize)___Common_rust_',<br/> 'Corn_(maize)___Northern_Leaf_Blight',<br/> 'Corn_(maize)___healthy',<br/> 'Grape___Black_rot',<br/> 'Grape___Esca_(Black_Measles)',<br/> 'Grape___Leaf_blight_(Isariopsis_Leaf_Spot)',<br/> 'Grape___healthy',<br/> 'Orange___Haunglongbing_(Citrus_greening)',<br/> 'Peach___Bacterial_spot',<br/> 'Peach___healthy',<br/> 'Pepper,_bell___Bacterial_spot',<br/> 'Pepper,_bell___healthy',<br/> 'Potato___Early_blight',<br/> 'Potato___Late_blight',<br/> 'Potato___healthy',<br/> 'Raspberry___healthy',<br/> 'Soybean___healthy',<br/> 'Squash___Powdery_mildew',<br/> 'Strawberry___Leaf_scorch',<br/> 'Strawberry___healthy',<br/> 'Tomato___Bacterial_spot',<br/> 'Tomato___Early_blight',<br/> 'Tomato___Late_blight',<br/> 'Tomato___Leaf_Mold',<br/> 'Tomato___Septoria_leaf_spot',<br/> 'Tomato___Spider_mites Two-spotted_spider_mite',<br/> 'Tomato___Target_Spot',<br/> 'Tomato___Tomato_Yellow_Leaf_Curl_Virus',<br/> 'Tomato___Tomato_mosaic_virus',<br/> 'Tomato___healthy',<br/> 'background'] <br/>'''</span></pre><p id="a502" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">为了创建迁移学习模型，我们需要使用函数<code class="fe nd ne nf ng b">cnn_learner</code>，它接受数据、网络和<code class="fe nd ne nf ng b">metrics</code>。<code class="fe nd ne nf ng b">metrics</code>仅用于打印培训的执行情况。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="85f4" class="ns kr it ng b gy nt nu l nv nw">model = cnn_learner(img_data, models.resnet34, metrics=[accuracy, error_rate])</span></pre><p id="a98b" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们将训练 5 个纪元。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="d58b" class="ns kr it ng b gy nt nu l nv nw">model.fit_one_cycle(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/265a2f785a317a12bc78bb3a7f5cd90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*IdekR_x14sMLSpzI0EtKgw.png"/></div></figure><p id="a979" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">正如我们在上面看到的，通过在默认设置下运行五个时期，我们对这个细粒度分类任务的准确率大约是 99.10%。</p><p id="c67a" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">再训练两个纪元吧。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="4845" class="ns kr it ng b gy nt nu l nv nw">model.fit_one_cycle(2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6dbf19d69b4e8ff3107a8bedc8738ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*iPh-d77jVSWlyix8vGF82A.png"/></div></figure><p id="a1f4" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated"><strong class="lk iu"> <em class="ms">这次准确率 99.2%！</em>T19】</strong></p><p id="585b" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">现在用<code class="fe nd ne nf ng b">.save()</code>保存模型。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="e789" class="ns kr it ng b gy nt nu l nv nw">model.save('train_7_cycles')</span></pre><p id="22ab" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们也可以画出混淆矩阵。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="7fc3" class="ns kr it ng b gy nt nu l nv nw">interpret = ClassificationInterpretation.from_learner(model)<br/><br/>interpret.plot_confusion_matrix(figsize=(20,20), dpi=60)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi op"><img src="../Images/fe8d70443e947986648a6b5fa079b6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kz0ZEUS7Va2BQmhlhJa0Lw.png"/></div></div></figure><p id="b2c1" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们使用<code class="fe nd ne nf ng b">lr_find</code>方法来寻找最佳学习速率。<strong class="lk iu">学习率</strong>是一个重要的超参数。我们习惯用αα来表示这个参数。如果学习速度太慢，我们需要更多的时间来达到最准确的结果。如果它太高，我们甚至可能无法得到准确的结果。<a class="ae mr" href="https://arxiv.org/abs/1506.01186" rel="noopener ugc nofollow" target="_blank">学习率</a> Finder 的想法是自动获得幻数(接近完美)，以获得最佳学习率。这是在去年的快速人工智能课程中介绍的，现在仍然有用。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="c055" class="ns kr it ng b gy nt nu l nv nw">model.lr_find()</span></pre><p id="e7f5" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">运行 finder 之后，我们绘制了损失和学习率之间的图表。我们看到一个图表，通常选择损失最小的较高学习率。更高的学习速率确保机器最终学习得更快。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="93cd" class="ns kr it ng b gy nt nu l nv nw">model.recorder.plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e92ec79f3bf37d49a84805c2c8986ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*V6m64VLOvLN0CihXSMlm6Q.png"/></div></figure><p id="ce4d" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">考虑到我们使用的是一个预先训练好的<strong class="lk iu"> <em class="ms"> Resnet34 </em> </strong>模型，我们肯定知道这个神经网络的前几层将学习检测边缘，后几层将学习复杂的形状。我们不想破坏早期的图层，这些图层可能在检测边缘方面做得很好。但是希望在缩小图像分类范围方面改进该模型。</p><p id="40a3" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">因此，我们将为前面的层设置较低的学习速率，为最后的层设置较高的学习速率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi or"><img src="../Images/11f26e69226ce872d077531079e39a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*UKIHA2AHtB9WPG-KrfwSZg.png"/></div></div></figure><p id="5359" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated"><code class="fe nd ne nf ng b"><em class="ms">slice</em></code>用于提供学习率，这里我们只提供学习率的范围(它的最小值和最大值)。随着我们从较早的层移动到最新的层，学习速率被设置得逐渐更高。</p><p id="e245" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">让我们解冻所有层，以便我们可以使用 unfreeze()函数训练整个模型。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="4bcc" class="ns kr it ng b gy nt nu l nv nw">model.unfreeze() <br/>model.fit_one_cycle(3, max_lr=slice(1e-03, 1e-02))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/6a1d591e45e1318850bb940e8bbda5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*lbbB7oFB7_PtZdVOeUdrPw.png"/></div></figure><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="0be0" class="ns kr it ng b gy nt nu l nv nw">model.fit_one_cycle(5, max_lr=slice(1e-03, 1e-02))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/686f3983e97cd524f3dc72929a2a37ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*M_PfgWHUaObCKLPb3gEtoQ.png"/></div></figure><p id="d03d" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated"><strong class="lk iu"> <em class="ms">准确率接近 99.63%。保存模型！</em>T13】</strong></p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="47a6" class="ns kr it ng b gy nt nu l nv nw">model.save('train_lr_8_cycles')</span></pre><p id="d255" class="pw-post-body-paragraph li lj it lk b ll my ju ln lo mz jx lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">冻结模型，找到学习率，并微调模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f23eb37765fa49f1b8711858abeec4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*xVf8icQd0n49m82H8h6cMg.jpeg"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ou"><img src="../Images/abfd96f1091ec52f8e447ade1754f5b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5H53IIok5S-A_RxlmmGig.png"/></div></div></figure><blockquote class="me"><p id="37d2" class="mf mg it bd mh mi ov ow ox oy oz md dk translated">最后，我们使用 Resnet34 取得了接近 99.654%的准确率。</p></blockquote><figure class="pb pc pd pe pf kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/274d8200550f32f0f0e6b52961990a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*WLNZLS4nb3XOW9maLQLD1g.gif"/></div></figure><h1 id="cbcb" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">在 GitHub 上分叉或启动它:</h1><div class="pg ph gp gr pi pj"><a href="https://github.com/imskr/Plant_Disease_Detection" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">im skr/植物疾病检测</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">使用 pyTorch 训练和评估植物病害分类任务的最新深度架构。模型…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ko pj"/></div></div></a></div><h1 id="d71e" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">部署在 AWS 上:</h1><p id="4fd2" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae mr" href="http://plantdisease.ap-south-1.elasticbeanstalk.com/" rel="noopener ugc nofollow" target="_blank">访问这里！</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi py"><img src="../Images/df343616485933b843294f22512c6a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mNXotzOFsOO5atdtUIDRg.png"/></div></div></figure></div></div>    
</body>
</html>