<html>
<head>
<title>How to build a wide-and-deep model using Keras in TensorFlow 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 TensorFlow 2.0 中使用 Keras 建立宽深模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-wide-and-deep-model-using-keras-in-tensorflow-2-0-2f7a236b5a4b?source=collection_archive---------16-----------------------#2019-05-24">https://towardsdatascience.com/how-to-build-a-wide-and-deep-model-using-keras-in-tensorflow-2-0-2f7a236b5a4b?source=collection_archive---------16-----------------------#2019-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 Keras 函数式 API 中使用特性列</h2></div><p id="5e33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 TensorFlow 2.0 中，Keras 支持要素列，从而能够使用嵌入、分桶和要素交叉等标准要素工程技术来表示结构化数据。在本文中，我将首先向您展示一个使用 Functional API 构建使用 features 列的模型的简单示例。然后，我将更新代码来构建一个完整的宽而深的模型。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/c9ca899d62799e47b33b3454f8f90fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vY5dCXJKnyZEXG9_XijIWg.jpeg"/></div></div></figure><p id="0e01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使文章简短，我只关注模型，但是你可以在 GitHub 上看到<a class="ae ln" href="https://github.com/GoogleCloudPlatform/data-science-on-gcp/blob/master/updates/cloudml/flights_model_tf2.ipynb" rel="noopener ugc nofollow" target="_blank">完整的笔记本</a>(包括使用 tf.data 读取数据)。</p><h2 id="9df9" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">1.如有必要，安装 TensorFlow 2.0</h2><p id="3cef" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这里的代码假设您使用的是 TensorFlow 2.0。pip 在 Colab 中安装它，使用:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="cdb3" class="lo lp iq mn b gy mr ms l mt mu">!pip install -q tensorflow==2.0.0-alpha0`</span></pre><p id="d787" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者使用云 AI 平台(CAIP)笔记本获得 TensorFlow 2.0 Jupyter 实例:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f64ffbda0fcfd0305f45fa3819744809.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*YVVjX4Jqs3A2ncOovw43XQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Use TensorFlow 2.0 to try out this code</figcaption></figure><h2 id="8b0d" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">2.创建功能列</h2><p id="b5d4" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">为输入中的每个字段创建要素列:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="b2ce" class="lo lp iq mn b gy mr ms l mt mu">real = {<br/>    colname : fc.numeric_column(colname) \<br/>          for colname in \<br/>            (’dep_delay,taxiout,distance’).split(’,’)<br/>}<br/>sparse = {<br/>      'origin' : fc.categorical_column_with_hash_bucket(’origin’, hash_bucket_size=1000),<br/>      'dest'   : fc.categorical_column_with_hash_bucket(’dest’, hash_bucket_size=1000)<br/>}</span></pre><p id="840f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我为浮点型字段创建数字列，为分类字段创建哈希分类列。</p><h2 id="f97f" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">3.创建模型的输入</h2><p id="979f" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">对于每个输入，还要创建一个 Keras 输入图层，确保为每个输入字段设置 dtype 和名称:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="f8ea" class="lo lp iq mn b gy mr ms l mt mu">inputs = {<br/>    colname : tf.keras.layers.Input(name=colname, shape=(), dtype='float32') \<br/>          for colname in real.keys()<br/>}<br/>inputs.update({<br/>    colname : tf.keras.layers.Input(name=colname, shape=(), dtype='string') \<br/>          for colname in sparse.keys()<br/>})</span></pre><h2 id="3d52" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">4.做嵌入，一热编码等。</h2><p id="a7f7" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">为了在深度学习模型中使用分类变量，我们必须对其进行编码。稀疏变量必须是嵌入式的或一键编码的。所以，让我们双管齐下:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="5702" class="lo lp iq mn b gy mr ms l mt mu">embed = {<br/>       'embed_{}'.format(colname) : fc.embedding_column(col, 10) \<br/>          for colname, col in sparse.items()<br/>}<br/>real.update(embed)</span><span id="b610" class="lo lp iq mn b gy na ms l mt mu"># one-hot encode the sparse columns<br/>sparse = {<br/>    colname : fc.indicator_column(col) \<br/>          for colname, col in sparse.items()<br/>}</span></pre><h2 id="cc9f" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">5.使用函数式 API 构建 DNN 模型</h2><p id="10cf" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">关键是创建一个 DenseFeatures 图层来使用要素列转换输入:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="73c5" class="lo lp iq mn b gy mr ms l mt mu">deep = tf.keras.layers.DenseFeatures(real.values())(inputs)<br/>deep = tf.keras.layers.Dense(64, activation='relu')(deep)<br/>deep = tf.keras.layers.Dense(16, activation='relu')(deep)<br/>output = tf.keras.layers.Dense(1, activation='sigmoid')(deep)<br/>model = tf.keras.Model(inputs, output)</span></pre><p id="ff2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！调用 model.fit()等。像往常一样。</p><h2 id="064d" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">6.使用 Keras Functional API 构建广泛而深入的网络</h2><p id="bead" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">如果要构建一个宽而深的网络，需要将稀疏要素直接连接到输出结点，但要通过一组密集图层传递真实要素。这里有一个模型架构可以做到这一点:</p><pre class="lc ld le lf gt mm mn mo mp aw mq bi"><span id="9d69" class="lo lp iq mn b gy mr ms l mt mu">def wide_and_deep_classifier(inputs, linear_feature_columns, dnn_feature_columns, dnn_hidden_units):<br/>    deep = tf.keras.layers.DenseFeatures(dnn_feature_columns)(inputs)<br/>    for numnodes in dnn_hidden_units:<br/>        deep = tf.keras.layers.Dense(numnodes, activation='relu')(deep)        <br/>    wide = tf.keras.layers.DenseFeatures(linear_feature_columns)(inputs)<br/>    both = tf.keras.layers.concatenate([deep, wide])<br/>    output = tf.keras.layers.Dense(1, activation='sigmoid')(both)<br/>    model = tf.keras.Model(inputs, output)<br/>    model.compile(optimizer='adam',<br/>                  loss='binary_crossentropy',<br/>                  metrics=['accuracy'])<br/>    return model</span><span id="acc8" class="lo lp iq mn b gy na ms l mt mu">model = wide_and_deep_classifier(inputs, sparse.values(), real.values(), [64, 16])</span></pre><p id="4916" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这是 Keras，你可以很容易地加入 dropout、batch normalization 等。到模型中。</p><p id="2dbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽情享受吧！</p><h2 id="fb99" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">资源:</h2><ol class=""><li id="5c6f" class="nb nc iq kh b ki mh kl mi ko nd ks ne kw nf la ng nh ni nj bi translated">参见 GitHub 上的<a class="ae ln" href="https://github.com/GoogleCloudPlatform/data-science-on-gcp/blob/master/09_cloudml/flights_model_tf2.ipynb" rel="noopener ugc nofollow" target="_blank">完整笔记本</a>。</li><li id="5908" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">阅读我关于在 GCP 做<a class="ae ln" href="http://shop.oreilly.com/product/0636920057628.do" rel="noopener ugc nofollow" target="_blank">数据科学</a>的书</li></ol></div></div>    
</body>
</html>