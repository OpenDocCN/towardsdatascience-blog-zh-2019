<html>
<head>
<title>NLP Text Preprocessing and Cleaning Pipeline in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的 NLP 文本预处理和清理管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nlp-text-preprocessing-and-cleaning-pipeline-in-python-3bafaf54ac35?source=collection_archive---------21-----------------------#2019-11-05">https://towardsdatascience.com/nlp-text-preprocessing-and-cleaning-pipeline-in-python-3bafaf54ac35?source=collection_archive---------21-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/15913a0b98def3de967aa4265f10552b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4UPdm-xFSLENi7uDMWquw.png"/></div></div></figure><p id="4df4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">我们通过语言表达人类的经历。语言是我们交流、表达情感、倾听、思考和交谈的方式。在过去的十年中，自然语言处理(NLP)取得了巨大的进步，计算机可以像人类一样分类、生成和响应语言。这些模型和算法已经开始给计算机提供理解人类经验的工具。这些领域增长的最重要原因是因为可以进行特征工程设计然后输入模型的数据呈指数增长。</p><h1 id="27fe" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">特征工程:</h1><p id="4adf" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">站在自然语言处理前沿的数据科学家、博士、机器学习工程师和数据工程师花了大部分时间清理和探索数据集。</p><h2 id="b8a3" class="ml lj it bd lk mm mn dn lo mo mp dp ls km mq mr lw kq ms mt ma ku mu mv me mw bi translated">垃圾进垃圾出</h2><p id="c6ee" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">如果向模型提供最新的数据，它们将产生最新的结果；模型如果被喂以垃圾就会产生垃圾，因此数据清洗是整个机器学习过程中最重要的部分之一。如果你训练的是像 BERT 或老派 word2vec 这样的艺术级变形金刚，那也没关系。您提供给模型的数据质量将决定您获得的结果的质量。</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/79e8ff0f12c52c23af465dcdd25adbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mWa5GbHSNLaRaomzOQrAw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">garbage in garbage out; data on fire in data on fire out</figcaption></figure><p id="0a03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">特征工程和数据清理不是乏味和无意义的任务——它们是重要的过滤机制，其工作方式与人脑处理语言的方式相同。当人类年轻时，他们学会如何从一种语言中分离噪音，然后通过该语言中最重要的单词和短语找到该语言的意义。这个过程类似于文本预处理。文本预处理将语料库分解成更小的部分，然后从这些部分中提取最重要的信息，模型将从这些信息中获取意义。</p><p id="0767" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给我看看代码！</p><h1 id="49ca" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">管道中的步骤</h1><h2 id="b2dd" class="ml lj it bd lk mm mn dn lo mo mp dp ls km mq mr lw kq ms mt ma ku mu mv me mw bi translated">📜<strong class="ak">，</strong>👀,📊(加载、查看和分析数据)<strong class="ak"> : </strong></h2><p id="27e6" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">任何机器学习管道的第一步都是加载数据！为了更好地衡量，我们还将查看数据以确保所有内容都正确加载，并收集一些基本的统计数据，如字数、行数和字符数。这将让我们很好地了解我们在管道中的下一步工作是什么。我使用的是路透社的数据集，可以在<a class="ae ng" href="https://www.kaggle.com/nltkdata/reuters/download#1" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="0083" class="ml lj it ni b gy nm nn l no np">data_folder = Path("/Users/emilyelia/Downloads/reuters/reuters/reuters/training")<br/>file_to_open = data_folder / "104"<br/>f = open(file_to_open)</span><span id="177b" class="ml lj it ni b gy nq nn l no np">print(f.read())<br/>num_lines =0<br/>num_words =0<br/>num_chars =0<br/>with open(file_to_open, 'r') as f:<br/>    for line in f:<br/>        words = line.split()</span><span id="a36a" class="ml lj it ni b gy nq nn l no np">num_lines += 1<br/>        num_words += len(words)<br/>        num_chars += len(line)</span><span id="f2f7" class="ml lj it ni b gy nq nn l no np">print ("numbers of words", num_words)<br/>print("number of lines", num_lines)<br/>print("number of chars", num_chars)</span></pre><h2 id="e2d4" class="ml lj it bd lk mm mn dn lo mo mp dp ls km mq mr lw kq ms mt ma ku mu mv me mw bi translated">符号化:</h2><p id="cee1" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">标记化是下一个预处理步骤。它获取文本语料库，并将其拆分为“标记”(单词、句子等)。).</p><p id="443f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个过程不像使用某种分离器那么简单。分隔符在很多不同的情况下都不起作用，例如带点的缩写，如“Dr .”或句点。在句末。需要一个更复杂的模型来正确地进行标记化，但是不要担心，因为标记化是 nltk 等常用 NLP 库中的内置特性。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="8425" class="ml lj it ni b gy nm nn l no np">from nltk.tokenize import sent_tokenize, word_tokenize<br/>f = open(file_to_open)<br/>#use built in tokenize to seperate each indiviual word<br/>nltk_words = word_tokenize(f.read())<br/>print(f"Tokenized words: {nltk_words}")</span></pre><h1 id="0f31" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">清洁:</h1><p id="8ebe" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">清理是从语料库中删除所有不必要内容的过程。不必要的内容包括停用词和标点符号，因为它们不会给整个语料库增加任何价值或意义。</p><h2 id="06ec" class="ml lj it bd lk mm mn dn lo mo mp dp ls km mq mr lw kq ms mt ma ku mu mv me mw bi translated">标点</h2><p id="3a45" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">标点去除是一个重要的步骤，因为标点不提供任何附加的价值或对整个语料库和语料库的矢量化的洞察。最好在标记化步骤之后删除标点符号，因为之前这样做可能会导致一些不可预见的结果。</p><h2 id="2ff7" class="ml lj it bd lk mm mn dn lo mo mp dp ls km mq mr lw kq ms mt ma ku mu mv me mw bi translated"><strong class="ak">停止字</strong></h2><p id="d010" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">停用词是你正在使用的语言中最常见的词。根据您使用的库，有 50-100 个停用词，它们不像“the”、“an”和“it”那样增加意思。移除这些单词不会改变您正在处理的语料库的含义，并且会导致更好的结果，因为剩余的单词对于确定语料库的含义是最重要的。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="ba0e" class="ml lj it ni b gy nm nn l no np">print(nltk_words)<br/>punctuation = list(string.punctuation)<br/>stopWords = set(stopwords.words('english'))<br/>filter = []<br/>for w in nltk_words:<br/>    if w.lower()not in stopWords and w not in punctuation:<br/>        filter.append(w)</span></pre><h1 id="c509" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">正常化</h1><p id="17f1" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">正常化是返回到标准形式或状态的过程。就文本预处理而言，它意味着获取数字、缩写和特殊字符，并将其转换为文本。这一过程使用了我们的大脑在处理特殊字符、拼写错误和缩写时所使用的相同联想，即把它们与我们用自己选择的语言说、读或想的单词联系起来。我正在使用可以在<a class="ae ng" href="https://github.com/EFord36/normalise" rel="noopener ugc nofollow" target="_blank">这里</a>找到的库规格化。</p><p id="95b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最常见的标准化特征是日期、数字、缩写、货币、百分比和拼写错误。在 normalise 中，你必须列出你想要拼写的缩写，然后调用 normalise 函数来执行其余的规范化。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="29e4" class="ml lj it ni b gy nm nn l no np">from normalise import normalise<br/>abbr = {<br/>    "lb": "pounds",<br/>    "USDA": "United States Department of Agriculture",<br/>    "cts": "cents",<br/>    "U.S.": "United States"<br/>}<br/>normalise(text, user_abbrevs=abbr)<br/>nt =normalise(filter, user_abbrevs=abbr)<br/>display( ' '.join(nt))</span></pre><p id="c755" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些规范化确保模型能够理解所有必须处理的文本，因为数字、特殊字符、拼写错误和缩写将与语料库中的所有其他内容具有相同的表示。</p><p id="1b75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">点击这里查看整个项目！</p><div class="nr ns gp gr nt nu"><a href="https://github.com/emilyelia/Custom-NLP-Text-Preprocessing-Pipeline" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">emil yelia/自定义-NLP-文本-预处理-管道</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>