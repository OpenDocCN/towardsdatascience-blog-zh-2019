<html>
<head>
<title>Predicting Next Purchase Day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测下一个购买日</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-next-purchase-day-15fae5548027?source=collection_archive---------2-----------------------#2019-06-02">https://towardsdatascience.com/predicting-next-purchase-day-15fae5548027?source=collection_archive---------2-----------------------#2019-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6dd43489060cac9d1f95fc3069673666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4ohgor8-7h6263xDFYDyw.jpeg"/></div></div></figure><h2 id="9e32" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/data-driven-growth" rel="noopener" target="_blank">使用 Python 实现数据驱动的增长</a></h2><div class=""/><div class=""><h2 id="8e20" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">机器学习模型预测顾客下次购买的时间</h2></div><p id="9029" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这一系列文章旨在解释如何以一种简单的方式使用 Python，通过将预测方法应用于您的所有行动来推动您公司的发展。它将是编程、数据分析和机器学习的结合。</p><p id="dd7e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我将在以下九篇文章中讨论所有主题:</p><p id="1ef9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">1- <a class="ae lv" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-1-know-your-metrics-812781e66a5b?source=post_page---------------------------">了解你的衡量标准</a></p><p id="a43f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">2- <a class="ae lv" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-2-customer-segmentation-5c019d150444?source=post_page---------------------------">客户细分</a></p><p id="3753" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">3- <a class="ae lv" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-3-customer-lifetime-value-prediction-6017802f2e0f?source=post_page---------------------------">客户终身价值预测</a></p><p id="6d56" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">4- <a class="ae lv" rel="noopener" target="_blank" href="/churn-prediction-3a4a36c2129a?source=post_page---------------------------">流失预测</a></p><p id="5895" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl"> 5-预测下一个购买日</strong></p><p id="77dd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" rel="noopener" target="_blank" href="/predicting-sales-611cb5a252de?source=post_page---------------------------"> 6-预测销售额</a></p><p id="3b52" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" rel="noopener" target="_blank" href="/market-response-models-baf9f9913298"> 7-市场反应模型</a></p><p id="7259" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" rel="noopener" target="_blank" href="/uplift-modeling-e38f96b1ef60"> 8-隆起建模</a></p><p id="598a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" rel="noopener" target="_blank" href="/a-b-testing-design-execution-6cf9e27c6559"> 9- A/B 测试设计和执行</a></p><p id="8317" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">文章将有自己的代码片段，使您可以轻松地应用它们。如果你是编程的超级新手，你可以在这里很好地介绍一下<a class="ae lv" href="https://www.kaggle.com/learn/python?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae lv" href="https://www.kaggle.com/learn/pandas?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Pandas </a>(一个我们将在任何事情上使用的著名库)。但是仍然没有编码介绍，您可以学习概念，如何使用您的数据并开始从中产生价值:</p><blockquote class="lw"><p id="c15e" class="lx ly jb bd lz ma mb mc md me mf lu dk translated">有时候你得先跑，然后才能走——托尼·斯塔克</p></blockquote><p id="6f91" class="pw-post-body-paragraph kz la jb lb b lc mh kl le lf mi ko lh li mj lk ll lm mk lo lp lq ml ls lt lu ij bi translated">作为先决条件，确保你的电脑上安装了 J <a class="ae lv" href="https://jupyter.readthedocs.io/en/latest/install.html?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> upyter Notebook </a>和 P <a class="ae lv" href="https://www.python.org/downloads/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> ython </a>。代码片段只能在 Jupyter 笔记本上运行。</p><p id="e732" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">好吧，我们开始吧。</p><h1 id="33d0" class="mm mn jb bd mo mp mq mr ms mt mu mv mw kq mx kr my kt mz ku na kw nb kx nc nd bi translated">第 5 部分:预测下一个购买日</h1><p id="bd2d" class="pw-post-body-paragraph kz la jb lb b lc ne kl le lf nf ko lh li ng lk ll lm nh lo lp lq ni ls lt lu ij bi translated">我们在“数据驱动增长”系列中解释的大多数行动背后都有相同的思路:</p><p id="c259" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">在客户期望之前，以他们应得的方式对待他们(如 LTV 预测)，在不好的事情发生之前采取行动(如流失)。</strong></p><p id="b3cd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">预测分析在这一点上对我们帮助很大。它可以提供的众多机会之一是预测客户的下一个购买日。如果您知道客户是否可能在 7 天内再次购买，该怎么办？</p><p id="7bbc" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们可以在此基础上构建我们的战略，并提出许多战术行动，例如:</p><ul class=""><li id="2870" class="nj nk jb lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">此客户没有促销优惠，因为她/他无论如何都会购买</li><li id="aa30" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">如果在预测的时间窗口内没有购买，用集客营销来推动客户(或者解雇预测🦹‍♀️ 🦹‍♂️的人)</li></ul><p id="4948" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在本文中，我们将使用<a class="ae lv" href="https://www.kaggle.com/vijayuv/onlineretail" rel="noopener ugc nofollow" target="_blank">在线零售数据集</a>，并遵循以下步骤:</p><ul class=""><li id="9ddd" class="nj nk jb lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">数据争论(创建上一个/下一个数据集并计算购买日差异)</li><li id="14e3" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">特征工程</li><li id="b38a" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">选择机器学习模型</li><li id="f403" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">多分类模型</li><li id="16f4" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">超参数调谐</li></ul><h2 id="bda6" class="nx mn jb bd mo ny nz dn ms oa ob dp mw li oc od my lm oe of na lq og oh nc jh bi translated">数据争论</h2><p id="12a3" class="pw-post-body-paragraph kz la jb lb b lc ne kl le lf nf ko lh li ng lk ll lm nh lo lp lq ni ls lt lu ij bi translated">让我们从导入数据开始，并做初步的数据工作:</p><figure class="oi oj ok ol gt is"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="71f8" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">导入 CSV 文件和日期字段转换</strong></p><p id="3b5d" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们已经导入了 CSV 文件，将日期字段从字符串转换为日期时间以使其可用，并过滤掉了除英国以外的国家。</p><p id="2d9d" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为了构建我们的模型，我们应该将数据分成两部分:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/3e64904526fce022d22a1fa7b2453cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gu6ofw3_G8Pvv2Cyal_F4Q.png"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk"><strong class="bd ot">Data structure for training the model</strong></figcaption></figure><p id="c220" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们使用六个月的行为数据来预测客户未来三个月的首次购买日期。如果没有购买，我们也会预测。假设我们的截止日期是 2011 年 9 月 9 日，然后分割数据:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="ff0c" class="nx mn jb ov b gy oz pa l pb pc">tx_6m = tx_uk[(tx_uk.InvoiceDate &lt; date(2011,9,1)) &amp; (tx_uk.InvoiceDate &gt;= date(2011,3,1))].reset_index(drop=True)</span><span id="d97e" class="nx mn jb ov b gy pd pa l pb pc">tx_next = tx_uk[(tx_uk.InvoiceDate &gt;= date(2011,9,1)) &amp; (tx_uk.InvoiceDate &lt; date(2011,12,1))].reset_index(drop=True)</span></pre><p id="186e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl"> tx_6m </strong>代表六个月的业绩，而我们将使用<strong class="lb jl"> tx_next </strong>来找出 tx_6m 中最后一次购买日期和 tx_next 中第一次购买日期之间的天数。</p><p id="aceb" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">此外，我们将创建一个名为<strong class="lb jl"> tx_user </strong>的数据帧，以拥有预测模型的用户级特征集:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="9308" class="nx mn jb ov b gy oz pa l pb pc">tx_user = pd.DataFrame(tx_6m['CustomerID'].unique())<br/>tx_user.columns = ['CustomerID']</span></pre><p id="f2f5" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">通过使用 tx_next 中的数据，我们需要计算我们的<strong class="lb jl">标签</strong>(截止日期前最后一次购买和之后第一次购买之间的天数):</p><figure class="oi oj ok ol gt is"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f685" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，tx_user 看起来如下:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/fd079078b527b152edf00ba43e35be7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75dSP0yBYDfcqCklBT0q4w.png"/></div></div></figure><p id="abce" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">正如你很容易注意到的，我们有 NaN 值，因为那些客户还没有购买。我们用 999 填充 NaN，以便稍后快速识别它们。</p><p id="cbb5" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们在数据帧中有客户 id 和相应的标签。让我们用我们的功能集来丰富它，以建立我们的机器学习模型。</p></div><div class="ab cl pf pg hu ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="ij ik il im in"><h2 id="69fb" class="nx mn jb bd mo ny nz dn ms oa ob dp mw li oc od my lm oe of na lq og oh nc jh bi translated">特征工程</h2><p id="2819" class="pw-post-body-paragraph kz la jb lb b lc ne kl le lf nf ko lh li ng lk ll lm nh lo lp lq ni ls lt lu ij bi translated">对于这个项目，我们选择了如下候选功能:</p><ul class=""><li id="3b76" class="nj nk jb lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">RFM 分数和聚类</li><li id="d860" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">最近三次购买的间隔天数</li><li id="cca9" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">购买天数差异的均值和标准差</li></ul><p id="16c3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">添加这些特征后，我们需要通过应用<strong class="lb jl"> get_dummies </strong>方法来处理分类特征。</p><p id="167b" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">对于 RFM，为了不重复<a class="ae lv" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-2-customer-segmentation-5c019d150444">第 2 部分</a>，我们共享代码块并继续前进:</p><figure class="oi oj ok ol gt is"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk"><strong class="ak">RFM Scores &amp; Clustering</strong></figcaption></figure><p id="ef53" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们来关注如何添加接下来的两个特性。在这一部分我们将会大量使用<strong class="lb jl"> shift() </strong>方法。</p><p id="35ef" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">首先，我们用客户 ID 和发票日期(不是日期时间)创建一个 dataframe。然后，我们将删除重复的，因为客户可以在一天内多次购买，差异将成为 0。</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="afd1" class="nx mn jb ov b gy oz pa l pb pc">#create a dataframe with CustomerID and Invoice Date<br/>tx_day_order = tx_6m[['CustomerID','InvoiceDate']]</span><span id="7ac4" class="nx mn jb ov b gy pd pa l pb pc">#convert Invoice Datetime to day<br/>tx_day_order['InvoiceDay'] = tx_6m['InvoiceDate'].dt.date</span><span id="7bd7" class="nx mn jb ov b gy pd pa l pb pc">tx_day_order = tx_day_order.sort_values(['CustomerID','InvoiceDate'])</span><span id="7e08" class="nx mn jb ov b gy pd pa l pb pc">#drop duplicates<br/>tx_day_order = tx_day_order.drop_duplicates(subset=['CustomerID','InvoiceDay'],keep='first')</span></pre><p id="57f2" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">接下来，通过使用 shift，我们创建包含最近 3 次购买日期的新列，并查看我们的数据帧看起来是什么样的:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="48d6" class="nx mn jb ov b gy oz pa l pb pc">#shifting last 3 purchase dates<br/>tx_day_order['PrevInvoiceDate'] = tx_day_order.groupby('CustomerID')['InvoiceDay'].shift(1)<br/>tx_day_order['T2InvoiceDate'] = tx_day_order.groupby('CustomerID')['InvoiceDay'].shift(2)<br/>tx_day_order['T3InvoiceDate'] = tx_day_order.groupby('CustomerID')['InvoiceDay'].shift(3)</span></pre><p id="6716" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">输出:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pm"><img src="../Images/0ce165fa12ed975d1316b61025152528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQ-mEqrsfoP3je8_OQnFcQ.png"/></div></div></figure><p id="4905" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们开始计算每个发票日期的天数差异:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="cb2a" class="nx mn jb ov b gy oz pa l pb pc">tx_day_order['DayDiff'] = (tx_day_order['InvoiceDay'] - tx_day_order['PrevInvoiceDate']).dt.days</span><span id="3280" class="nx mn jb ov b gy pd pa l pb pc">tx_day_order['DayDiff2'] = (tx_day_order['InvoiceDay'] - tx_day_order['T2InvoiceDate']).dt.days</span><span id="5c72" class="nx mn jb ov b gy pd pa l pb pc">tx_day_order['DayDiff3'] = (tx_day_order['InvoiceDay'] - tx_day_order['T3InvoiceDate']).dt.days</span></pre><p id="ab7a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">输出:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/e726d0c0661ed02afc8aa40c8b23eeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0RiU6SSBFxYU5GATXmGZQ.png"/></div></div></figure><p id="04f3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">对于每个客户 ID，我们使用<strong class="lb jl">。agg() </strong>找出购买天数差异的平均值和标准差的方法:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="2223" class="nx mn jb ov b gy oz pa l pb pc">tx_day_diff = tx_day_order.groupby('CustomerID').agg({'DayDiff': ['mean','std']}).reset_index()</span><span id="8a60" class="nx mn jb ov b gy pd pa l pb pc">tx_day_diff.columns = ['CustomerID', 'DayDiffMean','DayDiffStd']</span></pre><p id="739d" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们要做一个艰难的决定。上面的计算对于有很多采购的客户来说相当有用。但是我们不能对那些购买 1-2 次的人说同样的话。例如，将一个客户标记为<strong class="lb jl"> <em class="po">频繁</em> </strong>还为时过早，他只有两次购买，但却是连续购买。</p><p id="f301" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们只保留购买次数超过 3 次的客户，使用以下热线:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="0513" class="nx mn jb ov b gy oz pa l pb pc">tx_day_order_last = tx_day_order.drop_duplicates(subset=['CustomerID'],keep='last')</span></pre><p id="27db" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最后，我们删除 NA 值，将新数据帧与 tx_user 合并，并应用<strong class="lb jl">。get_dummies() </strong> for <strong class="lb jl"> </strong>转换分类值:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="5e08" class="nx mn jb ov b gy oz pa l pb pc">tx_day_order_last = tx_day_order_last.dropna()</span><span id="7f77" class="nx mn jb ov b gy pd pa l pb pc">tx_day_order_last = pd.merge(tx_day_order_last, tx_day_diff, on='CustomerID')</span><span id="fb2a" class="nx mn jb ov b gy pd pa l pb pc">tx_user = pd.merge(tx_user, tx_day_order_last[['CustomerID','DayDiff','DayDiff2','DayDiff3','DayDiffMean','DayDiffStd']], on='CustomerID')</span><span id="dbc2" class="nx mn jb ov b gy pd pa l pb pc">#create tx_class as a copy of tx_user before applying get_dummies<br/>tx_class = tx_user.copy()<br/>tx_class = pd.get_dummies(tx_class)</span></pre><p id="fde9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们的特征集已准备好构建分类模型。但是有很多不同的型号，我们应该使用哪一种呢？</p></div><div class="ab cl pf pg hu ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="ij ik il im in"><h2 id="09f7" class="nx mn jb bd mo ny nz dn ms oa ob dp mw li oc od my lm oe of na lq og oh nc jh bi translated">选择机器学习模型</h2><p id="e317" class="pw-post-body-paragraph kz la jb lb b lc ne kl le lf nf ko lh li ng lk ll lm nh lo lp lq ni ls lt lu ij bi translated">在开始选择模型之前，我们需要采取两个行动。首先，我们需要识别标签中的类。一般来说，百分位数给出了这个权利。还是用<strong class="lb jl">吧。describe() </strong>方法在<strong class="lb jl"> NextPurchaseDay: </strong>中看到它们</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pp"><img src="../Images/989be24c03897bf09cebfbe5eec52361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNN4577zrl5HuupvtzjbHQ.png"/></div></div></figure><p id="c250" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">决定边界是一个统计和商业需求的问题。就第一点而言，它应该是有意义的，并且易于采取行动和沟通。考虑到这两个，我们将有三个类:</p><ul class=""><li id="08fc" class="nj nk jb lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">0–20:将在 0–20 天内购买的客户— <strong class="lb jl">类别名称:2 </strong></li><li id="0ec1" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">21–49:将在 21–49 天内购买的客户— <strong class="lb jl">类别名称:1 </strong></li><li id="1d22" class="nj nk jb lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">≥ 50:将在 50 天以上购买的客户— <strong class="lb jl">类别名称:0 </strong></li></ul><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="7920" class="nx mn jb ov b gy oz pa l pb pc">tx_class['NextPurchaseDayRange'] = 2<br/>tx_class.loc[tx_class.NextPurchaseDay&gt;20,'NextPurchaseDayRange'] = 1<br/>tx_class.loc[tx_class.NextPurchaseDay&gt;50,'NextPurchaseDayRange'] = 0</span></pre><p id="7c3a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最后一步是查看我们的特征和标签之间的相关性。<strong class="lb jl">相关矩阵</strong>是展示这一点的最简洁的方式之一:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="bc44" class="nx mn jb ov b gy oz pa l pb pc">corr = tx_class[tx_class.columns].corr()<br/>plt.figure(figsize = (30,20))<br/>sns.heatmap(corr, annot = True, linewidths=0.2, fmt=".2f")</span></pre><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pq"><img src="../Images/c47eb543a6de58139025d16db7ef3ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sS_wcgk5GfA1P9OoqOIvQA.png"/></div></div></figure><p id="7f62" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">看起来<strong class="lb jl">总分</strong>正相关度最高(0.45)，而<strong class="lb jl">新近度</strong>负相关度最高(-0.54)。</p><p id="f331" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">对于这个特殊的问题，我们希望使用精度最高的模型。让我们分开训练和测试测试，并测量不同模型的准确性:</p><figure class="oi oj ok ol gt is"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk"><strong class="ak">Selecting the ML model for the best accuracy</strong></figcaption></figure><p id="54f3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">每个型号的精度:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pr"><img src="../Images/988ba7c72354c5dcccd583e4c896ac31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ecyL1UqwNUiKjG4eHluXw.png"/></div></div></figure><p id="76bc" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">从这个结果中，我们看到朴素贝叶斯是性能最好的一个(大约 64%的准确率)。但在此之前，让我们看看我们到底做了什么。我们应用了机器学习中的一个基本概念，那就是<strong class="lb jl">交叉验证。</strong></p><p id="d8cb" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们如何确定我们的机器学习模型在不同数据集之间的稳定性？此外，如果我们选择的测试集中有噪声怎么办。</p><p id="4eb1" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">交叉验证是衡量这一点的一种方式。它通过选择不同的测试集来提供模型的得分。如果偏差较低，则表示模型稳定。在我们的例子中，分数之间的偏差是可以接受的(除了决策树分类器)。</p><p id="e068" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">通常，我们应该用朴素贝叶斯。但是对于这个例子，让我们用 XGBoost 来展示我们如何用一些先进的技术来改进一个现有的模型。</p><h2 id="f971" class="nx mn jb bd mo ny nz dn ms oa ob dp mw li oc od my lm oe of na lq og oh nc jh bi translated">多分类模型</h2><p id="9b25" class="pw-post-body-paragraph kz la jb lb b lc ne kl le lf nf ko lh li ng lk ll lm nh lo lp lq ni ls lt lu ij bi translated">为了构建我们的模型，我们将遵循前面文章中的步骤。但是为了进一步改进，我们将进行<strong class="lb jl">超参数调整</strong>。</p><p id="66b7" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">从程序上讲，我们将找出我们的模型的最佳参数，以使它提供最佳的准确性。</p><p id="5977" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们首先从编码我们的模型开始:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="da40" class="nx mn jb ov b gy oz pa l pb pc">xgb_model = xgb.XGBClassifier().fit(X_train, y_train)</span><span id="74a7" class="nx mn jb ov b gy pd pa l pb pc">print('Accuracy of XGB classifier on training set: {:.2f}'<br/>       .format(xgb_model.score(X_train, y_train)))<br/>print('Accuracy of XGB classifier on test set: {:.2f}'<br/>       .format(xgb_model.score(X_test[X_train.columns], y_test)))</span></pre><p id="f5f7" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在这个版本中，我们在测试集上的准确率是 58%:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ps"><img src="../Images/37471bc38de471cb9a75e1a49a42bc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUKrNitKwxqBxdrV0swt5g.png"/></div></div></figure><p id="b923" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">XGBClassifier 有许多参数。你可以在这里找到他们的名单<a class="ae lv" href="https://xgboost.readthedocs.io/en/latest/parameter.html" rel="noopener ugc nofollow" target="_blank">。对于这个例子，我们将选择<strong class="lb jl">最大 _ 深度</strong>和<strong class="lb jl">最小 _ 子 _ 重量。</strong></a></p><p id="e163" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">以下代码将为这些参数生成最佳值:</p><pre class="oi oj ok ol gt ou ov ow ox aw oy bi"><span id="a90d" class="nx mn jb ov b gy oz pa l pb pc">from sklearn.model_selection import GridSearchCV</span><span id="039b" class="nx mn jb ov b gy pd pa l pb pc">param_test1 = {<br/> 'max_depth':range(3,10,2),<br/> 'min_child_weight':range(1,6,2)<br/>}<br/>gsearch1 = GridSearchCV(estimator = xgb.XGBClassifier(), <br/>param_grid = param_test1, scoring='accuracy',n_jobs=-1,iid=False, cv=2)<br/>gsearch1.fit(X_train,y_train)<br/>gsearch1.best_params_, gsearch1.best_score_</span></pre><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pt"><img src="../Images/e75ed54b3cdee9be252bcb0cfed1b312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35VNX85acs4qSx_WhAeaKA.png"/></div></div></figure><p id="7cab" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">该算法认为最大深度和最小子权重的最佳值分别为 3 和 5。了解它如何提高精确度:</p><figure class="oi oj ok ol gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pu"><img src="../Images/940d7272e0fd029bf8f935e8037b76e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLeCUh9b01kBV86O7szRZQ.png"/></div></div></figure><p id="8fd0" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们的分数从 58%上升到 62%。这是相当大的进步。</p><p id="2f89" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">知道下一个购买日也是预测销售的一个很好的指标。我们将在第 6 部分中深入探讨这个话题。</p><p id="9f06" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你可以在这里找到这篇文章的笔记本。</p></div><div class="ab cl pf pg hu ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="ij ik il im in"><p id="6188" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">享受数据驱动增长系列？给我买杯咖啡<a class="ae lv" href="https://www.buymeacoffee.com/karamanbk" rel="noopener ugc nofollow" target="_blank">这里</a> …</p></div></div>    
</body>
</html>