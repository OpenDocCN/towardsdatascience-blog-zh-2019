<html>
<head>
<title>Minimal Pandas Subset for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的最小熊猫子集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/minimal-pandas-subset-for-data-scientists-6355059629ae?source=collection_archive---------5-----------------------#2019-07-17">https://towardsdatascience.com/minimal-pandas-subset-for-data-scientists-6355059629ae?source=collection_archive---------5-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bf09cb946a04feede117c6ba82fd6a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8dBf1Vy9mkDdcuwQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="aeec" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">您需要的所有熊猫功能</h2></div><p id="ad97" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">熊猫是一个巨大的图书馆。</p><p id="9b1b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于 pandas 来说，数据操作轻而易举，它已经成为 it 的一个标准，许多并行化库，如 Rapids 和 Dask，都是按照 Pandas 的语法创建的。</p><p id="8e31" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尽管如此，我总的来说还是有一些问题。</p><p id="80b1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在 Pandas 中有多种方法可以做同样的事情，这可能会给初学者带来麻烦。T9】</p><p id="7df6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这启发了我想出一个我在编码时使用的熊猫函数的最小子集。</p><p id="6de0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我都试过了，目前，我坚持一种特定的方式。它就像一个思维导图。</p><p id="ccb2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有时是因为它很快，有时是因为它更易读，有时是因为我可以用我现有的知识来做。而且有时候因为知道某个特定的方式长期下去会很头疼(想多指标) </p><p id="01a4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">这篇文章是关于用一种简单明了的方式来处理 Python 中的大多数数据操作。</em> </strong></p><p id="c72f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">通篇都是一些零星的建议。</p><p id="b499" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我将使用 IMDB 上过去十年中 1000 部流行电影的数据集。你也可以在<a class="ae lp" href="https://www.kaggle.com/mlwhiz/minimal-pandas-subset" rel="noopener ugc nofollow" target="_blank"> Kaggle 内核</a>中跟随。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="56d0" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">一些默认的熊猫要求</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/654ce7609e78f9dd5d9ca5176c577a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rR7NKjqyGMgeS3y9cY_1cA.png"/></div></div></figure><p id="badd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尽管 Jupyter 笔记本很好，但在与熊猫一起工作时，有些事情仍然需要详细说明。</p><p id="2871" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">有时候你的笔记本不会把所有栏目都给你看。如果你打印数据帧，有时它会显示所有的行。在导入熊猫时，您可以通过设置自己的一些默认值来控制这种行为。你可以使用<a class="ae lp" rel="noopener" target="_blank" href="/three-great-additions-for-your-jupyter-notebooks-cd7373b00e96">将这个</a>添加到你的笔记本上来实现自动化。</em></strong></p><p id="c125" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，这是我使用的设置。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f18b" class="na lz je mw b gy nb nc l nd ne">import pandas as pd<br/># pandas defaults<br/>pd.options.display.max_columns = 500<br/>pd.options.display.max_rows = 500</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="697c" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">用熊猫读取数据</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/f3f66ee9cab21027ba9cd901039f716e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H8pUDmJ7NqmmV-WQ.jpg"/></div></div></figure><p id="e0aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们做的第一件事是读取数据源，这是代码。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a8ee" class="na lz je mw b gy nb nc l nd ne">df = pd.read_csv("IMDB-Movie-Data.csv")</span></pre><p id="945f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">推荐:</em> </strong>我本来也可以用<code class="fe ng nh ni mw b">pd.read_table</code>来读文件的。问题是<code class="fe ng nh ni mw b">pd.read_csv</code>的默认分隔符是<code class="fe ng nh ni mw b">,</code>，这样可以节省一些代码。我也真心不明白<code class="fe ng nh ni mw b">pd.read_table</code>的用途</p><p id="699c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您的数据在某个 SQL 数据源中，您可以使用下面的代码。您将获得数据帧格式的结果。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f11f" class="na lz je mw b gy nb nc l nd ne"># Reading from SQL Datasource</span><span id="3d42" class="na lz je mw b gy nj nc l nd ne">import MySQLdb<br/>from pandas import DataFrame<br/>from pandas.io.sql import read_sql</span><span id="f3cc" class="na lz je mw b gy nj nc l nd ne">db = MySQLdb.connect(host="localhost",    # your host, usually localhost<br/>                     user="root",         # your username<br/>                     passwd="password",   # your password<br/>                     db="dbname")         # name of the data base</span><span id="e64e" class="na lz je mw b gy nj nc l nd ne">query = "SELECT * FROM tablename"</span><span id="3900" class="na lz je mw b gy nj nc l nd ne">df = read_sql(query, db)</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="73db" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">数据快照</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/f0563eab5989a2024639be638160bc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U7iLkiHLQ1dAYHqf"/></div></div></figure><p id="4eea" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">看到一些数据总是有用的。</p><p id="b309" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以使用带有选项的简单的<code class="fe ng nh ni mw b">head</code>和<code class="fe ng nh ni mw b">tail</code>命令来指定行数。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d1ad" class="na lz je mw b gy nb nc l nd ne"># top 5 rows<br/>df.head()</span><span id="12c5" class="na lz je mw b gy nj nc l nd ne"># top 50 rows<br/>df.head(50)</span><span id="1499" class="na lz je mw b gy nj nc l nd ne"># last 5 rows<br/>df.tail()</span><span id="5543" class="na lz je mw b gy nj nc l nd ne"># last 50 rows<br/>df.tail(50)</span></pre><p id="93eb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您还可以使用以下命令查看简单的数据帧统计信息。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="001b" class="na lz je mw b gy nb nc l nd ne"># To get statistics of numerical columns<br/>df.describe()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/8e4fecfebe4f95b1fdb6c4ed00a5ca96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ak1ntfm3t88iyT9S578zw.png"/></div></div></figure><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f22a" class="na lz je mw b gy nb nc l nd ne"># To get maximum value of a column. When you take a single column you can think of it as a list and apply functions you would apply to a list. You can also use min for instance.</span><span id="7a28" class="na lz je mw b gy nj nc l nd ne">print(max(df['rating']))</span><span id="a45b" class="na lz je mw b gy nj nc l nd ne"># no of rows in dataframe<br/>print(len(df))</span><span id="dfac" class="na lz je mw b gy nj nc l nd ne"># Shape of Dataframe<br/>print(df.shape)</span><span id="17a7" class="na lz je mw b gy nj nc l nd ne">---------------------------------------------------------------<br/>9.0<br/>1000<br/>(1000,12)</span></pre><p id="9be0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">推荐:</em> </strong>一般用 Jupyter 笔记本工作，<strong class="kv jf"> <em class="lq">我特别注意让笔记本的前几个单元格包含这些数据的快照</em> </strong>。这有助于我随时看到数据的结构。如果我不遵循这个实践，我注意到我在代码中重复了很多次<code class="fe ng nh ni mw b">.head()</code>命令。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6e6d" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">处理数据框架中的列</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/e5afe284ea859061dcdba9c2dc3b2d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dY5dUTWvkXWdfBvD.jpg"/></div></div></figure><h2 id="6e1e" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">a.选择列</h2><p id="6f0e" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">出于某种原因，Pandas 允许您以两种方式选择列。像<code class="fe ng nh ni mw b">df.Title</code>一样使用点运算符，像<code class="fe ng nh ni mw b">df['Title']</code>一样使用方括号</p><p id="b863" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我更喜欢第二个版本。为什么？</p><p id="5846" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从长远来看，使用方括号版本会更好，这有几个原因。</p><ul class=""><li id="9885" class="od oe je kv b kw kx kz la lc of lg og lk oh lo oi oj ok ol bi translated">如果您的列名包含空格，那么点版本将不起作用。比如<code class="fe ng nh ni mw b">df.Revenue (Millions)</code>不会工作而<code class="fe ng nh ni mw b">df['Revenue (Millions)]’</code>会。</li><li id="25b4" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">如果您的列名是<code class="fe ng nh ni mw b">count</code>或<code class="fe ng nh ni mw b">mean</code>或任何 pandas 预定义的函数，它也不会工作。</li><li id="712c" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">有时您可能需要在列名上创建一个 for 循环，其中列名可能在变量中。在这种情况下，点符号将不起作用。例如，这是可行的:</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="54df" class="na lz je mw b gy nb nc l nd ne">colname = 'height'<br/>df[colname]</span></pre><p id="62e4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然这不会:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3996" class="na lz je mw b gy nb nc l nd ne">colname = 'height'<br/>df.colname</span></pre><p id="835b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">相信我。省几个字不值得。</p><p id="c438" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">建议:停止使用点运算符</em> </strong>。它是一个源自不同语言(R)的结构，应该保留在那里。</p><h2 id="7ada" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">b.获取列表中的列名</h2><p id="d788" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">您可能需要一个列列表，以便进行后续处理。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c40f" class="na lz je mw b gy nb nc l nd ne">columnnames = df.columns</span></pre><h2 id="f3fb" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">c.指定用户定义的列名:</h2><p id="3938" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">有时您想根据自己的喜好更改列名。我不喜欢我的列名中有空格，所以我这样更改它们。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="996d" class="na lz je mw b gy nb nc l nd ne">df.columns = <!-- -->['Rank', 'Title', 'Genre', 'Description', 'Director', 'Actors', 'Year',<br/>       'Runtime_Minutes', 'Rating', 'Votes', 'Revenue_Millions',<br/>       'Metascore']</span></pre><p id="5f1e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我本可以用另一种方式。</p><p id="6f4d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，两个版本都很重要。当我必须更改许多列名时，我使用上面的方法。当我必须更改一两个列的名称时，我会使用:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="63fe" class="na lz je mw b gy nb nc l nd ne">df.rename(columns = {'Revenue (Millions)':'Rev_M','Runtime (Minutes)':'Runtime_min'},inplace=True)</span></pre><h2 id="5f0f" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">d.设置特定列的子集:</h2><p id="62ef" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">有时，您只需要处理数据帧中的特定列。例如，分离数字列和分类列，或者移除不必要的列。比如说在我们的例子中。我们不需要描述、导演和演员栏。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e777" class="na lz je mw b gy nb nc l nd ne">df = df[['Rank', 'Title', 'Genre', 'Year','Runtime_min', 'Rating', 'Votes', 'Rev_M', 'Metascore']]</span></pre><h2 id="4cef" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">e.查看列类型:</h2><p id="0378" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">调试时非常有用。如果您的代码抛出一个错误，说明您不能添加一个<code class="fe ng nh ni mw b">str</code>和<code class="fe ng nh ni mw b">int</code>，您将希望运行这个命令。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6ade" class="na lz je mw b gy nb nc l nd ne">df.dtypes</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ab05" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">在数据帧上应用函数:Apply 和 Lambda</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/ebf6a702259183104d625dd7ffc441c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FmnRCjp_pzLQ_iau.png"/></div></div></figure><p id="e42a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ng nh ni mw b">apply</code>和<code class="fe ng nh ni mw b">lambda</code>是我在熊猫身上学到的一些最好的东西。</p><p id="d1cb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每当我为一个新的列或过滤器构建复杂的逻辑时遇到困难，我就会使用<code class="fe ng nh ni mw b">apply</code>和<code class="fe ng nh ni mw b">lambda</code>。</p><h2 id="2615" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">a.创建列</h2><p id="78f1" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">您可以通过多种方式创建新列。</p><p id="6fda" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你想要一个列是列的和或差，你可以使用简单的基本算法。在这里，我得到了基于 IMDB 和标准化 Metascore 的平均评级。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7efc" class="na lz je mw b gy nb nc l nd ne">df['AvgRating'] = (df['Rating'] + df['Metascore']/10)/2</span></pre><p id="9fef" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是有时我们可能需要围绕新列的创建构建复杂的逻辑。</p><p id="575c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">举一个复杂的例子，假设我们想要基于各种因素构建一个自定义的电影评分。</p><p id="db82" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">比方说，如果电影是惊悚片，我想在 IMDB 评分保持小于或等于 10 的条件下，在 IMDB 评分上加 1。如果一部电影是喜剧，我想从评分中减去一分。T9】</p><p id="b80b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">我们怎么做呢？</em>T13】</strong></p><p id="76e9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每当我掌握了如此复杂的问题，我就使用<code class="fe ng nh ni mw b">apply/lambda</code>。让我首先向您展示我将如何做这件事。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1d13" class="na lz je mw b gy nb nc l nd ne">def custom_rating(genre,rating):<br/>    if 'Thriller' in genre:<br/>        return min(10,rating+1)<br/>    elif 'Comedy' in genre:<br/>        return max(0,rating-1)<br/>    else:<br/>        return rating<br/>        <br/>df['CustomRating'] = df.apply(lambda x: custom_rating(x['Genre'],x['Rating']),axis=1)</span></pre><p id="d648" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一般结构是:</p><ul class=""><li id="2384" class="od oe je kv b kw kx kz la lc of lg og lk oh lo oi oj ok ol bi translated">您定义了一个函数，该函数将接受您想要处理的列值，以得出您的逻辑。在这里，我们最终使用的两列是流派和评级。</li><li id="e682" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">沿着 axis=1 的行使用带有 lambda 的应用函数。一般语法是:</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8548" class="na lz je mw b gy nb nc l nd ne">df.apply(lambda x: func(x['col1'],x['col2']),axis=1)</span></pre><p id="180e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您应该能够使用 apply/lambda 创建几乎任何逻辑，因为您只需担心自定义函数。</p><h2 id="ab13" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">b.过滤数据帧</h2><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/60bb4a44e6281c71109e59af8d297010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RZE58BZHrIk_x_12"/></div></div></figure><p id="7781" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">熊猫使过滤和子集化数据框架变得相当容易。您可以使用普通运算符和<code class="fe ng nh ni mw b">&amp;,|,~</code>运算符对数据帧进行过滤和子集化。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3534" class="na lz je mw b gy nb nc l nd ne"># Single condition: dataframe with all movies rated greater than 8</span><span id="ed82" class="na lz je mw b gy nj nc l nd ne">df_gt_8 = df[df['Rating']&gt;8]</span><span id="e173" class="na lz je mw b gy nj nc l nd ne"># Multiple conditions: AND - dataframe with all movies rated greater than 8 and having more than 100000 votes</span><span id="555e" class="na lz je mw b gy nj nc l nd ne">And_df = df[(df['Rating']&gt;8) &amp; (df['Votes']&gt;100000)]</span><span id="722d" class="na lz je mw b gy nj nc l nd ne"># Multiple conditions: OR - dataframe with all movies rated greater than 8 or having a metascore more than 90</span><span id="abe1" class="na lz je mw b gy nj nc l nd ne">Or_df = df[(df['Rating']&gt;8) | (df['Metascore']&gt;80)]</span><span id="bcd9" class="na lz je mw b gy nj nc l nd ne"># Multiple conditions: NOT - dataframe with all emovies rated greater than 8 or having a metascore more than 90 have to be excluded</span><span id="e740" class="na lz je mw b gy nj nc l nd ne">Not_df = df[~((df['Rating']&gt;8) | (df['Metascore']&gt;80))]</span></pre><p id="a27d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">很简单的东西。</p><p id="1a6c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但有时我们可能需要进行复杂的过滤操作。</p><p id="93e6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有时我们需要做一些操作，而仅仅使用上面的格式是做不到的。</p><p id="ac56" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如:我们假设<strong class="kv jf"> <em class="lq">我们想要过滤电影标题中字数大于或等于 4 的那些行。</em> </strong></p><p id="2014" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">你会怎么做？</em> </strong></p><p id="f00f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尝试下面的会给你一个错误。显然，你不能做任何简单的事情，比如用一个系列分割。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f165" class="na lz je mw b gy nb nc l nd ne">new_df = df[len(df['Title'].split(" "))&gt;=4]<br/>-------------------------------------------<br/>AttributeError: 'Series' object has no attribute 'split'</span></pre><p id="da2e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一种方法是首先使用 apply 创建一个标题中包含字数的列，然后对该列进行过滤。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bf87" class="na lz je mw b gy nb nc l nd ne">#create a new column<br/>df['num_words_title'] = df.apply(lambda x : len(x['Title'].split(" ")),axis=1)</span><span id="2908" class="na lz je mw b gy nj nc l nd ne">#simple filter on new column<br/>new_df = df[df['num_words_title']&gt;=4]</span></pre><p id="63a8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是一个非常好的方法，只要你不需要创建很多列。但我更喜欢这个:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fb8d" class="na lz je mw b gy nb nc l nd ne">new_df = df[df.apply(lambda x : len(x['Title'].split(" "))&gt;=4,axis=1)]</span></pre><p id="4534" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我在这里做的是<strong class="kv jf"> <em class="lq">我的 apply 函数返回一个可以用来过滤的布尔值。</em>T25】</strong></p><p id="321b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，一旦你理解了你只需要创建一个布尔列来过滤，你就可以在你的<code class="fe ng nh ni mw b">apply</code>语句中使用任何函数/逻辑来得到你想要构建的复杂逻辑。</p><p id="0975" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们看另一个例子。我会试着做一些复杂的事情来展示这个结构。</p><p id="c56a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">我们想找到收入低于该年平均收入的电影？</em> </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f4ff" class="na lz je mw b gy nb nc l nd ne">year_revenue_dict = df.groupby(['Year']).agg({'Rev_M':np.mean}).to_dict()['Rev_M']</span><span id="5ec4" class="na lz je mw b gy nj nc l nd ne">def bool_provider(revenue, year):<br/>    return revenue&lt;year_revenue_dict[year]<br/>    <br/>new_df = df[df.apply(lambda x : bool_provider(x['Rev_M'],x['Year']),axis=1)]</span></pre><p id="4ef2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里有一个函数，可以用来写任何逻辑。只要我们能够处理简单的变量，这就为高级过滤提供了强大的功能。</p><h2 id="eaef" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">c.更改列类型</h2><p id="e6b5" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">我甚至使用 apply 来更改列类型，因为我不想记住更改列类型的语法，也因为它让我可以做更复杂的事情。</p><p id="4cd2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在 Pandas 中，更改列类型的常用语法是<code class="fe ng nh ni mw b">astype</code>。因此，如果我的数据中有一个<code class="fe ng nh ni mw b">str</code>格式的名为 price 的列。我可以这样做:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3f80" class="na lz je mw b gy nb nc l nd ne">df['Price'] = newDf['Price'].astype('int')</span></pre><p id="5ff0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但有时并不会如预期般奏效。</p><p id="1488" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可能会得到错误:<code class="fe ng nh ni mw b">ValueError: invalid literal for long() with base 10: ‘13,000’.</code>也就是说，你不能将一个带有<code class="fe ng nh ni mw b">“,”</code>的字符串转换为整型。要做到这一点，我们首先要去掉逗号。</p><p id="a498" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在一次又一次地面对这个问题之后，我现在已经完全停止使用<code class="fe ng nh ni mw b">astype </code>了，只使用 apply 来改变列类型。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c688" class="na lz je mw b gy nb nc l nd ne">df['Price'] = df.apply(lambda x: int(x['Price'].replace(',', '')),axis=1)</span></pre><h2 id="a065" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">最后，还有<code class="fe ng nh ni mw b">progress_apply</code></h2><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/cc3041d8c5d9f79d82b8a6dfbce307f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I3lgF9GqVRnJT7aT.png"/></div></div></figure><p id="7969" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ng nh ni mw b">progress_apply</code>是<code class="fe ng nh ni mw b">tqdm</code>包附带的单一功能。</p><p id="11f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这为我节省了很多时间。</p><p id="ddf4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有时，当您的数据中有很多行，或者您最终编写了一个非常复杂的 apply 函数时，您会发现 apply 可能需要很长时间。</p><p id="e186" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我见过应用程序在使用 Spacy 时花费数小时。在这种情况下，您可能希望看到带有<code class="fe ng nh ni mw b">apply</code>的进度条。</p><p id="dec1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可以使用<code class="fe ng nh ni mw b">tqdm</code>来实现。</p><p id="3e4a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在笔记本顶部进行初始导入后，只需将<code class="fe ng nh ni mw b">apply</code>替换为<code class="fe ng nh ni mw b">progress_apply</code>，一切都保持不变。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6003" class="na lz je mw b gy nb nc l nd ne">from tqdm import tqdm, tqdm_notebook<br/>tqdm_notebook().pandas()</span><span id="0911" class="na lz je mw b gy nj nc l nd ne">df.progress_apply(lambda x: custom_rating_function(x['Genre'],x['Rating']),axis=1)</span></pre><p id="9922" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你会看到进度条。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/4a7baf206a3e5e0cf579cd445640c153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z9Hz4SOKdfsUk5DO.png"/></div></div></figure><p id="5432" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">推荐:</em> </strong>每当看到要创建自定义复杂逻辑的列，就想到<code class="fe ng nh ni mw b">apply</code>和<code class="fe ng nh ni mw b">lambda</code>。也尝试使用<code class="fe ng nh ni mw b">progress_apply</code>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="64c8" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">数据帧上的聚合:g <code class="fe ng nh ni mw b">roupby</code></h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/2ca8928a4deccf3495077c63d5983342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jnIH3bDHnohz67MQ.jpg"/></div></div></figure><p id="3971" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ng nh ni mw b">groupby</code>会在你想汇总数据的时候出现很多次。Pandas 通过<code class="fe ng nh ni mw b">groupby</code>功能让你高效地完成这项工作。</p><p id="607e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有很多方法可以使用<code class="fe ng nh ni mw b">groupby</code>。我见过很多版本，但我更喜欢一种特定的风格，因为我觉得我使用的版本简单、直观，并且可以针对不同的用例进行扩展。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8209" class="na lz je mw b gy nb nc l nd ne">df.groupby(list of columns to groupby on).aggregate({'colname':func1, 'colname2':func2}).reset_index()</span></pre><p id="7abf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在你看到它是非常简单的。你只需要担心提供两个主要的信息。</p><ul class=""><li id="967d" class="od oe je kv b kw kx kz la lc of lg og lk oh lo oi oj ok ol bi translated">到<code class="fe ng nh ni mw b">groupby</code>的列列表，以及</li><li id="30fc" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">列和要应用于这些列的函数的字典</li></ul><p id="182b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ng nh ni mw b">reset_index()</code>是一个重置数据帧索引的函数。每当我执行 groupby 时，我总是应用这个函数，您可能会认为它是 groupby 操作的默认语法。</p><p id="2466" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们来看一个例子。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d285" class="na lz je mw b gy nb nc l nd ne"># Find out the sum of votes and revenue by year</span><span id="b5f8" class="na lz je mw b gy nj nc l nd ne">import numpy as np<br/>df.groupby(['Year']).aggregate({'Votes':np.sum, 'Rev_M':np.sum}).reset_index()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/7f20d56903a5073421610d4aaff8ebf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPYMtbenKY0ki509DVQrDw.png"/></div></div></figure><p id="de89" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可能还想按多列进行分组。这相当简单。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="eb2b" class="na lz je mw b gy nb nc l nd ne">df.groupby(['Year','Genre']).aggregate({'Votes':np.sum, 'Rev_M':np.sum}).reset_index()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/a0e6f84b6491c54772e190fd3ade8d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Drj1u1Wi-XkWKu9vpyr5w.png"/></div></div></figure><p id="18aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">推荐:</em> </strong>坚持一个语法对于<code class="fe ng nh ni mw b">groupby.</code>不喜欢我的就挑自己的但是坚持一个。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a7fd" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">处理多个数据帧:连接和合并:</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/c32449506f37e8ca098faf6d69167a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OncJPLIqxVl_Q6kp"/></div></div></figure><h2 id="f7b2" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated"><code class="fe ng nh ni mw b">a. concat</code></h2><p id="ba43" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">有时我们从不同的来源获得数据。或者有人带着多个文件来找你，每个文件都有特定年份的数据。</p><p id="85a7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">我们如何从单个数据帧创建单个数据帧？</em>T15】</strong></p><p id="4602" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里我们将人工创建我们的用例，因为我们只有一个文件。我们首先使用已知的基本过滤操作创建两个数据帧。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6a3c" class="na lz je mw b gy nb nc l nd ne">movies_2006 = df[df['Year']==2006]<br/>movies_2007 = df[df['Year']==2007]</span></pre><p id="aaed" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里我们从两个数据帧开始:<code class="fe ng nh ni mw b">movies_2006</code>包含 2006 年发行的电影的信息，而<code class="fe ng nh ni mw b">movies_2007</code>包含 2007 年发行的电影的信息。我们希望创建一个包含 2006 年和 2007 年电影的单一数据框架</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b6ed" class="na lz je mw b gy nb nc l nd ne">movies_06_07 = pd.concat([movies_2006,movies_2007])</span></pre><h2 id="ec3a" class="na lz je bd ma nn no dn me np nq dp mi lc nr ns mk lg nt nu mm lk nv nw mo nx bi translated">b.合并</h2><p id="63da" class="pw-post-body-paragraph kt ku je kv b kw ny kf ky kz nz ki lb lc oa le lf lg ob li lj lk oc lm ln lo im bi translated">您将遇到的大多数数据永远不会出现在单个文件中。其中一个文件可能包含特定电影的评级，另一个文件可能提供电影的投票数。</p><p id="2315" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，我们有两个需要合并的数据帧，这样我们就可以在一个视图中拥有所有的信息。</p><p id="65f4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里我们将人工创建我们的用例，因为我们只有一个文件。我们首先使用已知的基本列子集操作创建两个数据帧。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f45f" class="na lz je mw b gy nb nc l nd ne">rating_dataframe = df[['Title','Rating']]<br/>votes_dataframe =  df[['Title','Votes']]</span></pre><div class="mr ms mt mu gt ab cb"><figure class="ow iv ox oy oz pa pb paragraph-image"><img src="../Images/a05118a45802fb8b3362b6933a5b045f.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*01PIvRJIyUAW-5z1sduDRw.png"/></figure><figure class="ow iv pc oy oz pa pb paragraph-image"><img src="../Images/8f67e627d11b2c7b01aef0aacfc3852a.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*P8qcFbbT6z3kRpsybudPeA.png"/></figure></div><p id="4b0e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们需要在一个数据框架中包含所有这些信息。我们该怎么做？</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="eae1" class="na lz je mw b gy nb nc l nd ne">rating_vote_df = pd.merge(rating_dataframe,votes_dataframe,on='Title',how='left')</span><span id="c469" class="na lz je mw b gy nj nc l nd ne">rating_vote_df.head()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/50f9e985bbb8cc270b712ba39fca2360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*63uO6oKUzm15CSZawwpUTQ.png"/></div></figure><p id="64bd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们为这个合并函数提供了四个属性——第一个 DF、第二个 DF、在哪一列上连接以及连接标准:<code class="fe ng nh ni mw b">['left','right','inner','outer']</code></p><p id="cd75" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">推荐:</em> </strong>我通常最后总是用<code class="fe ng nh ni mw b">left</code> join。你将很少需要使用<code class="fe ng nh ni mw b">outer</code>或<code class="fe ng nh ni mw b">right.</code>来连接，实际上无论何时你需要做一个<code class="fe ng nh ni mw b">right </code>连接，你实际上只需要一个左连接，在合并函数中数据帧的顺序是相反的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8d4f" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">重塑数据框架:熔化和透视表(reverseMelt)</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/aef8f22605407e86821c9d10bdad297b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2-zEmQHUO-MpiP2q"/></div></div></figure><p id="93c1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">大多数时候，我们并没有得到我们想要的精确形式的数据。</p><p id="6ef5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，有时我们可能有列中的数据，而我们可能需要行中的数据。</p><p id="56aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们再创造一个人为的例子。你可以看看下面我用来创建这个例子的代码，但是真的没关系。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5bf8" class="na lz je mw b gy nb nc l nd ne">genre_set = set()<br/>for genre in df['Genre'].unique():<br/>    for g in genre.split(","):<br/>        genre_set.add(g)<br/>for genre in genre_set:<br/>    df[genre] = df['Genre'].apply(lambda x: 1 if genre in x else 0)</span><span id="afe5" class="na lz je mw b gy nj nc l nd ne">working_df = df[['Title','Rating', 'Votes',<br/>       'Rev_M']+list(genre_set)]</span><span id="8d76" class="na lz je mw b gy nj nc l nd ne">working_df.head()</span></pre><p id="acd8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以我们从这样一个<code class="fe ng nh ni mw b">working_df</code>开始:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/dfc18f7b7deab416cd6ba998814bda34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJzPnCtH0CdbgVXRuvzU5g.png"/></div></div></figure><p id="0ce1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，这并不是一个特别好的存放数据的结构。如果我们有一个只有一个列类型的数据帧，我们可能会更喜欢它，并且我们可以为同一部电影重复多行。所以电影《普罗米修斯》可能有三行，因为它有三种类型。我们如何做到这一点？</p><p id="f421" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们使用<code class="fe ng nh ni mw b">melt:</code></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a0d6" class="na lz je mw b gy nb nc l nd ne">reshaped_df = pd.melt(working_df,id_vars = ['Title','Rating','Votes','Rev_M'],value_vars = list(genre_set),var_name = 'Genre', value_name ='Flag')</span><span id="bdc5" class="na lz je mw b gy nj nc l nd ne">reshaped_df.head()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/e8d64ffdf5b291ef11dcf87e9191eb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9oV7gj-o-hXXO5EXL6FKg.png"/></div></div></figure><p id="8169" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以在这个融化函数中，我们提供了五个属性:</p><ul class=""><li id="ed80" class="od oe je kv b kw kx kz la lc of lg og lk oh lo oi oj ok ol bi translated">数据帧名称=工作数据帧</li><li id="53f2" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">id_vars:仅在当前表单中需要的变量列表。</li><li id="a6f5" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">value_vars:我们希望融合/放入同一列的变量列表</li><li id="afd8" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">for value _ vars 的列名</li><li id="4d54" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">value _ name:value _ vars 的值的列名</li></ul><p id="87cf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">还剩下一件事。对于普罗米修斯，我们看到它是一部惊悚片，旗帜为 0。标志 0 是我们可以过滤掉的不必要的数据，我们将得到我们的结果。我们只保留带有标志 1 的类型</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1c20" class="na lz je mw b gy nb nc l nd ne">reshaped_df  = reshaped_df[reshaped_df['Flag']==1]</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/89d5e6c79a78fd24a4aec69bd7e59126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVrmj0pf4tR0L8SX13ZgtQ.png"/></div></div></figure><p id="2b2a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">如果我们想回去呢？</em>T15】</strong></p><p id="4506" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们需要将一列中的值变成多列。怎么会？我们用<code class="fe ng nh ni mw b">pivot_table</code></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c753" class="na lz je mw b gy nb nc l nd ne">re_reshaped_df = reshaped_df.pivot_table(index=['Title','Rating','Votes','Rev_M'], columns='Genre', <br/>                    values='Flag', aggfunc='sum').reset_index()</span><span id="752a" class="na lz je mw b gy nj nc l nd ne">re_reshaped_df.head()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/1b56908ddbfa50faf35f70719a4687a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCYazRfLyW6IdiD4ntKTOA.png"/></div></div></figure><p id="f6f9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们为 pivot_table 函数提供了四个属性。</p><ul class=""><li id="cb3a" class="od oe je kv b kw kx kz la lc of lg og lk oh lo oi oj ok ol bi translated">索引:我们不想改变这些列结构</li><li id="8648" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">列:将该列分解为多个列</li><li id="9882" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">值:使用此列进行汇总</li><li id="4d82" class="od oe je kv b kw om kz on lc oo lg op lk oq lo oi oj ok ol bi translated">aggfunc:聚合函数。</li></ul><p id="06ae" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后我们可以使用<code class="fe ng nh ni mw b">fillna</code>用 0 填充缺失的值</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1b2d" class="na lz je mw b gy nb nc l nd ne">re_reshaped_df=re_reshaped_df.fillna(0)</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/3575f48a0debd383aa99867fa6cc0093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-YjVsFAIDB-krP7Z9YAUA.png"/></div></div></figure><p id="d94c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lq">推荐:</em> </strong>多列对一列:<code class="fe ng nh ni mw b">melt</code>和一列对多列:<code class="fe ng nh ni mw b">pivot_table</code>。做<code class="fe ng nh ni mw b">melt</code>——<code class="fe ng nh ni mw b">stack</code>还有其他方式做<code class="fe ng nh ni mw b">pivot_table</code> : <code class="fe ng nh ni mw b">pivot</code>、<code class="fe ng nh ni mw b">unstack.</code>不要管他们，只用<code class="fe ng nh ni mw b">melt</code>和<code class="fe ng nh ni mw b">pivot_table</code>。这有一些合理的原因，比如<code class="fe ng nh ni mw b">unstack</code>和<code class="fe ng nh ni mw b">stack</code>会创建多索引，我们不想处理这个问题，而且<code class="fe ng nh ni mw b">pivot</code>不能将多个列作为索引。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1292" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">结论</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/0dcfd5f78a4ca84206828a4276f7c7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LXYGDrHMezNhzYvW.jpg"/></div></div></figure><blockquote class="pk"><p id="9eb2" class="pl pm je bd pn po pp pq pr ps pt lo dk translated">有了熊猫，选择就越少</p></blockquote><p id="acb1" class="pw-post-body-paragraph kt ku je kv b kw pu kf ky kz pv ki lb lc pw le lf lg px li lj lk py lm ln lo im bi translated">在这里，我试着描述了熊猫中我最常用的一些最有用的功能。 </p><p id="5d4a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Pandas 是一个庞大的库，有很多功能和定制选项。这使得你必须有一个思维导图，在这个思维导图中，你要坚持使用特定的语法来处理特定的事情。</p><p id="38d9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我在这里分享了我的，你可以继续下去，随着你对这个库的理解的增长，它会变得更好。T25】</p><p id="f439" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我希望这篇文章对你有用，值得你花时间。我试图让这尽可能简单，但是你可能总是<strong class="kv jf">问我</strong>或者查看文档中的疑问。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="c572" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">全部代码和数据都发布在<a class="ae lp" href="https://www.kaggle.com/mlwhiz/minimal-pandas-subset" rel="noopener ugc nofollow" target="_blank"> Kaggle 内核</a>中。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="f0e3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另外，如果你想学习更多关于 Python 3 的知识，我想从密歇根大学调出一门关于学习<a class="ae lp" href="https://coursera.pxf.io/0JMOOY" rel="noopener ugc nofollow" target="_blank">中级 Python </a>的优秀课程。一定要去看看。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="e242" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我以后也会写更多这样的帖子。让我知道你对他们的看法。在<a class="ae lp" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="kv jf">媒体</strong> </a>关注我或者订阅我的<a class="ae lp" href="http://eepurl.com/dbQnuX" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae lp" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系到我。</p></div></div>    
</body>
</html>