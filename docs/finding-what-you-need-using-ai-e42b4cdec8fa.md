# 用人工智能找到你需要的东西

> 原文：<https://towardsdatascience.com/finding-what-you-need-using-ai-e42b4cdec8fa?source=collection_archive---------20----------------------->

## 路径搜索算法介绍

![](img/9c41e744e2dc19f5ac36c9ed8fbbf346.png)

大三的时候上了第一堂人工智能课。我神采奕奕地走进去。我期待着所有的热门词汇——神经网络、支持向量机、贝叶斯网络等等。第一堂课是我杜克经历中最令人失望的 75 分钟。我得到了深度优先搜索和递归，而不是听起来很酷的时髦词汇。

这是我最喜欢的课程之一，我的教授非常清楚他在做什么。我们必须先学习基础知识，然后才能做大事。如果我们不了解内部和外部的基本原理，我们就没有对抗深度学习的机会。宫城先生在教我们给汽车打蜡。路径搜索打开，路径搜索关闭…

![](img/292d90aaaa326597a93775b1e4e27709.png)

Copyright 1984 Columbia Pictures — [The Karate Kid](https://giphy.com/gifs/memecandy-kewtvhA4tgH30DYKZr)

**尽管如此，随着我了解的越来越多，我记得我对路径搜索算法嗤之以鼻。他们看起来一点也不聪明。**你是说你只是生成所有可能的路径，猜测其中最好的一条，然后探索那条路径？人类比这聪明多了。我们处于食物链的顶端是有原因的！

但那次演讲后我不得不去办点事。我得去吃午饭，买课本，然后去上另一节课。所以，我想“*我可以吃午饭，然后去上课，然后拿我的课本。啊，但是等等，那时候商店已经关门了。也许我会去拿书，然后吃午饭，然后去上课。但是，不，我现在饿了。好吧，我去吃午饭，拿书，然后去上课。*“如果你错过了这里的讽刺，再读一遍。

![](img/e5e8775e89f5d0fc1a9abdc834ae48b4.png)

要么是计算机非常聪明，要么是人类没有我们想象的那么聪明。我倾向于后者。

## 概观

在本文中，我们将介绍四种搜索算法来解决下面的问题。假设给你一个二维网格。你从左上角开始，只能向下或向右移动。网格中的每个单元格都有一个点值。收集路径上所有像元的点值。你的目标是收集尽可能多的分数。

![](img/ee55781d51ac36488b7711ef165b8e23.png)

## 递归

我们首先尝试一种递归方法。递归简单易行。我们的基本情况是到达右下角的单元格。否则，我们将递归调用向下向右移动。然后我们在每一步取这两个调用的最大值。这允许我们将问题分解成更小的子问题。这种方法的实现如下。

![](img/ba616e591e3e2a256d241213384710d4.png)

Code source [here](https://github.com/andrewjoliver/OptimalGridSearch/blob/master/RecursiveSearch.py).

## 深度优先搜索

这种方法可行，但是递归调用代价很高。随着网格的增长，我们可能会遇到堆栈溢出。当我们进行的递归调用超过内存中的堆栈所能处理的数量时，就会发生这种情况。因此，我们转向**一种深度优先搜索(DFS)方法**。

在 DFS 中，我们会先充分探索一条道路，然后再转向另一条。我们使用堆栈来跟踪我们的路径。我们尽可能向下移动，然后向右移动。我们仍然在探索与递归解决方案一样多的路径，但是我们使用了更少的内存并防止了堆栈溢出。对于长度为 2 的二维网格，我们的堆栈如下所示。

![](img/0a0b7acc80ce4e9d85bcae3f5bf0d5bc.png)

我们必须做一些跑腿的工作来编写我们的 DFS 算法。我们将定义一个 GridCell 类。对于每个单元格，我们将记录我们是从这个单元格向下还是向右。对于每个完整路径，我们将记录分数。如果它大于我们当前路径的分数，我们将把我们的最大值和最优路径更新为当前值和路径。这显示在下面的代码中。

![](img/3913f87bb0ee4e0b5dbc8d777898efe6.png)

Code source [here](https://github.com/andrewjoliver/OptimalGridSearch/blob/master/DFSSearch.py).

## 双向搜索

我们仍然没有解决算法中的一个主要问题。我们重复计算来自同一个单元的所有路径。这导致了许多重叠的子问题。例如，考虑下面大小为 *n = 5* 的网格。大致有 n*n*种方法可以到达中间的细胞。从中间的单元格，有大约 *n* 多种方式到达右下角的单元格。这意味着我们正在为此路径和所有其他路径进行 *n* 计算。这是非常低效的。

![](img/05b2c69bb68f36019bf091416275db52.png)

如果我们能从角落开始呢？如果我们从左上和右下开始工作，然后在中间相遇会怎么样？然后，我们可以从上半部分和下半部分分别选择最佳路径，并将它们配对。我们现在只做 *n* 计算，而不是 *n* 计算。这是一个巨大的进步，尤其是对于大 *n* 来说。这被称为**双向搜索**，如下图所示。注意箭头的方向。

![](img/3203f5b3cf2b5024779c367435fb4e36.png)

但是，我们可以做得更多。我们可以利用现代计算机的处理能力。当你的 Python 代码运行时，它被分解成你的 CPU 可以执行的代码。开箱即用，Python 代码不支持并行性。出于我们的目的，我们认为并行是功能的同时执行。现在，我们的代码线性运行。如果 *funcA()* 在 *funcB()* 之前， *funcA()* 需要在 *funcB()* 开始之前终止。

![](img/356383235a3b493807ace9ac5066b523.png)

然而，事实并非如此。如果 *funcA()* 和 *funcB()* 是独立的，我们可以同时运行。我们可以使用 Python 中的[多处理来利用并行性。这意味着我们可以同时计算左上和右下的路径。](https://docs.python.org/2/library/multiprocessing.html)

我们并行执行双向搜索，并在运行时看到了相当大的改进。这个实现的代码可以在[这里](https://github.com/andrewjoliver/OptimalGridSearch/blob/master/DSFBidirectionalSearch.py)找到。但是，对于非常大的 *n* ，这个问题还是需要一段时间。为了解决这个问题，我们求助于**启发式搜索**。

![](img/b674c37afe9dd29f49ba55e20a7b5a4b.png)

## 启发式搜索

我们的下一个算法利用了搜索和人工智能中的一个关键概念。 [**启发式**](https://data-flair.training/blogs/heuristic-search-ai/) 的想法。启发式是一种评估功能，帮助我们估计达到目标的最佳路径。在每次迭代中，我们将启发式算法应用于所有可能的未来状态。然后我们探索哪个状态具有最高启发值的路径。

我们需要为我们的问题定义一个试探法。假设我们位于网格的左上角。无论我们向右还是向下移动，所有灰色的单元格都是可以访问的。然而，如果我们向下移动，就会失去橙色细胞，如果我们向右移动，就会失去蓝色细胞。因此，我们可以查看橙色单元格和蓝色单元格的平均单元格值。我们将朝着更高的平均单元格值的方向移动。我们可以对每个细胞都这样做。

![](img/b0eae4feea8d4bb1092a57405f93bda6.png)

这个解决方案不精确。但是，它快得令人难以置信。我们也看到相对最优的解决方案。如果我们的单元格值范围从 1 到 5，我们会看到对于网格大小为 *n = 13* 的解决方案有 90%是最优的。随着单元格范围的增加，我们看到的最优解会越来越少。例如，在 1 到 100 的范围内，我们看到对于 *n = 13* 有 85%的最优解。这可能不会给你一条去月球的路，但会给你一条去杂货店的路。

这种启发式搜索算法的实现如下。如果你感兴趣，可以随意克隆[库](https://github.com/andrewjoliver/OptimalGridSearch)并尝试启发式方法。更精确的启发式方法会导致更优的解决方案。

![](img/abcc008736a5581cb53cb97798ae4225.png)

Code source [here](https://github.com/andrewjoliver/OptimalGridSearch/blob/master/HueristicSearch.py).

## 结束语

这个问题在现实世界中有很多应用。一个明显的例子是 GPS 应用程序规划路线。我们可以根据道路的速度限制除以距离来给道路赋值。在这里找到一个解决方案可以让我们找到一条快捷的路线。但是如果我们能给代表一个问题的状态分配点值，我们可以使用这些算法中的任何一个。我们可以很容易地使用这些完全相同的算法来为新 iPhone 的发布找到最佳的营销策略。

这也凸显了很多搜索问题的问题。随着这些问题越来越多，找到最佳解决方案需要太长时间。因此，我们必须在速度和优化之间做出权衡，正如我们在这里所做的那样。

# 感谢阅读！

*疑问？评论？在*[*【andrew.oliver.medium@gmail.com】*](mailto:andrew.oliver.medium@gmail.com?source=post_page---------------------------)*给我发邮件。我很想收到你的来信！*