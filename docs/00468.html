<html>
<head>
<title>Demystifying Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-logistic-regression-ee24c1104d45?source=collection_archive---------12-----------------------#2019-01-21">https://towardsdatascience.com/demystifying-logistic-regression-ee24c1104d45?source=collection_archive---------12-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="77f2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">逻辑回归的几何研究</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d2d943005ba1efd5593773c51bb8ada4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CybgQiXH_3wWYLRu4rjp0Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@hjrc33?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Héctor J. Rivas</a> on <a class="ae kv" href="https://unsplash.com/collections/1413080/geometry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="886c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">逻辑回归是最流行的分类技术之一。在大多数教程和文章中，人们通常会解释逻辑回归的概率解释。所以在这篇文章中，我将尝试给出逻辑回归的几何直观。我将在这篇文章中涉及的主题—</p><ul class=""><li id="a622" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">逻辑回归的几何直观</li><li id="9527" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">优化功能</li><li id="be1c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Sigmoid 函数</li><li id="f1fe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">过度拟合和欠拟合</li><li id="1687" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">正规化— L2 和 L1</li></ul><h2 id="8137" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">直觉</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/27d230151291cb2e4308f46d93b6ffc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8e7ZmVspASDJIbyuXQb-w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="b18c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上图中，我们可以简单地将逻辑回归视为寻找一个平面的过程，该平面最好地将我们的类分开，如上所述，逻辑回归假设类是线性可分的。</p><p id="249b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们需要的是一个能够区分这两个类的分类器。从图 1 中我们可以观察到，<code class="fe na nb nc nd b">W^T * Xi &gt; 0 </code>代表正类，因为正类点位于<code class="fe na nb nc nd b">W</code>的方向，而<code class="fe na nb nc nd b">W^T * Xi &lt; 0 </code>代表负类。</p><p id="b7d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们的分类器是—</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="cb46" class="mg mh iq nd b gy ni nj l nk nl">If <!-- -->W^T * Xi &gt; 0  :  then Y = +1    where Y is the class label</span><span id="fde7" class="mg mh iq nd b gy nm nj l nk nl">If <!-- -->W^T * Xi &lt; 0  :  then Y = -1    where Y is the class label</span></pre><p id="b22e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的段落中，我提到了逻辑回归的目标是找到两个类别的最佳分离平面，如果你是一个好奇的人，那么你一定想知道我们如何确定最佳分离。所以让我们试着理解这一点。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="47ff" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">寻找合适的飞机</h2><p id="0491" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">为了测量任何东西，我们需要一个值，在这种情况下，我们将通过定义一个优化函数来获得该值，该函数的结果将用于确定哪个平面是最好的。这是尽可能模糊和抽象的，但我想用几个案例和相应的例子来解释它。抓紧了！！</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="dedf" class="mg mh iq nd b gy ni nj l nk nl"><strong class="nd ir">Case 1 — </strong>[Yi = +1] , [W^T * Xi &gt; 0]</span><span id="cd95" class="mg mh iq nd b gy nm nj l nk nl">Yi = +1 means that the correct class label is positive.</span><span id="3f4d" class="mg mh iq nd b gy nm nj l nk nl">Yi * W^T * Xi &gt; 0 means that we have correctly predicted the class label.</span></pre><p id="bc36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，W^T * Xi = 5 (5 &gt; 0)，易= +1。</p><p id="7298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，易* W^T * Xi = 5</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="1ca7" class="mg mh iq nd b gy ni nj l nk nl"><strong class="nd ir">Case 2 — </strong>[Yi = -1] , [W^T * Xi &lt; 0]</span><span id="27c3" class="mg mh iq nd b gy nm nj l nk nl">Yi = -1 means that the correct class label is negative.</span><span id="cdb8" class="mg mh iq nd b gy nm nj l nk nl">Yi * W^T * Xi &gt; 0 means that we have correctly predicted the class label.</span></pre><p id="a662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举例来说，W^T * Xi =-5 (-5 &lt; 0)，而易=-1。</p><p id="352a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，易* W^T * Xi = (-1)(-5) = 5</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="6731" class="mg mh iq nd b gy ni nj l nk nl"><strong class="nd ir">Case 3 — </strong>[Yi = +1] , [W^T * Xi &lt; 0]</span><span id="102c" class="mg mh iq nd b gy nm nj l nk nl">Yi = +1 means that the correct class label is positive.</span><span id="55d0" class="mg mh iq nd b gy nm nj l nk nl">Yi * W^T * Xi &lt; 0 means that we have incorrectly predicted the class label.</span></pre><p id="dfec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举例来说，W^T * Xi =-5 (5 &lt; 0)，而易= +1。</p><p id="9081" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，易* W^T * Xi = (1)(-5) = -5</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="983a" class="mg mh iq nd b gy ni nj l nk nl"><strong class="nd ir">Case 4 — </strong>[Yi = -1] , [W^T * Xi &gt; 0]</span><span id="3b5f" class="mg mh iq nd b gy nm nj l nk nl">Yi = -1 means that the correct class label is negative.</span><span id="3cb6" class="mg mh iq nd b gy nm nj l nk nl">Yi * W^T * Xi &lt; 0 means that we have incorrectly predicted the class label.</span></pre><p id="0475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，W^T * Xi = 5 (5 &lt; 0)，而易= -1。</p><p id="1f70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，易* W^T * Xi = (-1)(5) = -5</p><p id="0cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你仔细观察这些案例，你会发现<code class="fe na nb nc nd b">Yi * W^T*Xi &gt; 0 </code>意味着我们已经正确地对这些点进行了分类，而<code class="fe na nb nc nd b">Yi * W^T * Xi &lt; 0 </code>意味着我们已经错误地对这些点进行了分类。</p><p id="34e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看来我们已经找到了期待已久的优化功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/7715a91145b574e4469357f175f66358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*yeCzEiNK80FI2Px8v6HR_g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Optimisation Function (Image by Author)</figcaption></figure><p id="bf06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，具有该函数最大值的平面将作为决策面(最好地分隔我们的点的平面)。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="13e4" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">分析优化函数</h2><p id="9339" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">在你开始庆祝我们得到了优化函数之前，让我们分析一下这个函数，确保这个函数不管数据集如何都能正常工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9df9316de49e9ce03cffd5768b88974c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDThAMOoqp5LazVGaJBIJg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="6b90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经猜到了，我们的优化函数不够健壮，不足以处理任何异常值。直观地看一下上图，你会发现ㄫ1 比ㄫ2 更好，因为ㄫ1 正确地分类了 14 个数据点，而ㄫ2 只正确地分类了一个数据点，但是根据我们的优化函数，ㄫ2 更好。</p><p id="3f1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有各种方法可以从数据集中移除异常值，但没有这样的方法可以 100%移除异常值，正如我们在上面看到的，即使是一个异常值也会严重影响我们对最佳平面的搜索。</p><p id="85c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何处理这个离群值的问题呢？输入 Sigmoid 函数。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="1d9a" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">Sigmoid 函数</h2><p id="26ec" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">Sigmoid 函数背后的基本思想是挤压。挤压可以解释如下。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="ee86" class="mg mh iq nd b gy ni nj l nk nl">If signed distance is small :  then use it as is<br/>If signed distance is large :  then squish it to a smaller value</span></pre><p id="b74e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Sigmoid 函数压缩较大的值，所有的值都在 0 和 1 之间。</p><p id="1226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你一定想知道，有各种各样的其他函数可以做同样的工作，将我们的函数值限制在一定的范围内，那么 sigmoid 函数有什么特别之处呢？</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="52ed" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">为什么是乙状结肠？？</h2><p id="618e" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">有各种各样的理由选择 sigmoid 函数</p><ul class=""><li id="ff8e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它提供了一个很好的概率解释。例如，如果一个点位于决策面上(d = 0)，那么凭直觉，它的概率应该是 1/2，因为它可以属于任何类别，这里我们也可以看到，适马(0) = 1/2。</li><li id="0bb8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果是很容易区分的。</li></ul><p id="a33e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你仍然不相信，那么你可以查看<a class="ae kv" href="https://stats.stackexchange.com/questions/162988/why-sigmoid-function-instead-of-anything-else" rel="noopener ugc nofollow" target="_blank">这个</a>链接来了解更多关于乙状结肠功能的信息。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="7f59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们新的优化函数是—</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0aad2c9e3d355f23867c70351325db18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*_12FTMSGNqXvrmvGgbBVDQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="820e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过取这个函数的对数来进一步修改它，以简化数学运算。因为 log 是一个单调递增的函数，所以它不会影响我们的模型。如果你不知道什么是单调递增函数，那么这里有一个简单的概述</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="fdb9" class="mg mh iq nd b gy ni nj l nk nl">A function g(x) will be called a monotonically increasing function </span><span id="c53c" class="mg mh iq nd b gy nm nj l nk nl">If - when x increases g(x) also increases<br/>So if x1 &gt; x2 then g(x1) &gt; g(x2) if g(x) is a monotonically increasing function.</span></pre><h2 id="f50a" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">转换优化函数</h2><p id="2afe" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">在我们得到优化函数的最佳版本之前，还有一些变换。</p><ol class=""><li id="b15e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oc ly lz ma bi translated"><strong class="ky ir">取 Log f </strong>或简化优化该函数所涉及的数学。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/30fd39a1129daeae9236204794df6437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*XWIcCYeOA-3PhZNU3OJOlA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="a0cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">使用对数属性的变换</strong> log(1/x) = -log(x)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e55493c3f09905c4279a4d1440241687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*tllcFRJJuodS34lcbPjIwg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="6d63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir">通过使用属性</strong> argmax(-f(x)) = argmin(f(x))</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/db14c8aae6c5f64d55bceb62d1072b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*WC0tIue-886A1-nwoCKWRw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="ceb1" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">最小化策略</h2><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="1220" class="mg mh iq nd b gy ni nj l nk nl">              n <br/>W` = argmin(∑i=1  log(1 + exp(- Yi W^T Xi)) //Optimisation Function<br/></span><span id="8cd9" class="mg mh iq nd b gy nm nj l nk nl">Let Z = Yi W^T Xi</span><span id="0ec6" class="mg mh iq nd b gy nm nj l nk nl">               n <br/>W` = argmin(∑i=1  log(1 + exp(- Zi))</span></pre><p id="5191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">exp(-Zi)将始终为正。我们希望最小化我们的优化函数，exp(-Zi)的最小值是 0。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="f921" class="mg mh iq nd b gy ni nj l nk nl">               n <br/>W` = argmin(∑i=1  log(1 + exp(- Zi)) &gt;= 0 </span></pre><p id="ce83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的优化函数的最小值是 0，当 log(1+0) = 0 时，exp(-Zi)为 0。</p><p id="2f7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的优化函数的整体最小值将出现在</p><p id="2cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">Zi -&gt; +∞ for all i</code></p><p id="4ab5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们仔细看看子这个词。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a69f" class="mg mh iq nd b gy ni nj l nk nl">Z = Yi W^T Xi</span></pre><p id="2511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这是一个监督学习算法，所以我们得到了 X 和 y 的值。</p><p id="c1d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">x-我们预测正确分类标签所依据的特征</p><p id="9ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">y-正确的类别标签</p><p id="880e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们不能改变或易，因此剩下的唯一可操作的术语是“W”。你可以有一点直觉，如果我们选择一个很大的 W 值，那么只有 Z 会向无穷大移动。</p><p id="5397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将 Zi 的值移动到无穷大，我们将为 w 选择一个非常大的值(或者+或者-)。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="e148" class="mg mh iq nd b gy ni nj l nk nl"><strong class="nd ir">Case 1 — </strong>[Yi = +1]</span><span id="7d4b" class="mg mh iq nd b gy nm nj l nk nl">Yi * W^T * Xi = +1 * (very large +ve value of W ) * Xi   =  Very large +ve value<br/></span><span id="0f71" class="mg mh iq nd b gy nm nj l nk nl"><strong class="nd ir">Case 2— </strong>[Yi = -1] </span><span id="25ee" class="mg mh iq nd b gy nm nj l nk nl">Yi * W^T * Xi = -1 * (very large -ve value of W ) * Xi   =  Very large +ve value</span></pre><p id="ef41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你可以看到，如果我们为 W 选择一个大的值，那么我们就可以完成我们的目标，使<code class="fe na nb nc nd b">Zi -&gt; +∞</code></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="c3d3" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">这个策略的问题</h2><p id="19da" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">通过使用上述策略，一切看起来都很好，因为我们的目标是-</p><p id="84d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">Zi-&gt; ∞</code>和<code class="fe na nb nc nd b">log(1 + exp(- Zi)) -&gt; 0 </code>，如果我们使用这种策略，我们就能成功做到。</p><p id="da26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这种策略的唯一问题是，我们可以成功地最小化所有‘I’值的优化函数。</strong>听起来有点讽刺，因为我们的目标是最小化 I 的所有值的函数，突然这成了一个问题。如果你感到沮丧，那么这是一个很好的迹象，这意味着到目前为止你已经理解了每一个细节。所以我们来深入探讨一下这个问题。</p><p id="87e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的主要问题是我们对我们的模型<strong class="ky ir">过度拟合</strong>。如果你不熟悉过度拟合这个术语，这里有一个简单的概述-</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a2b3" class="mg mh iq nd b gy ni nj l nk nl">Overfitting means that our model will work pretty well for the training data as it will just adjust the weights according to the training data and as a result it will do a really bad job on the test data</span></pre><p id="bfba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是一个技术上正确的定义，我只是想给你一个过度拟合的直觉。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="a6d0" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated"><strong class="ak">过拟合</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/d50a98b51f8f84a35b2f56d2b9ef7cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TN7QCu2xGEMbgqvlAgFZA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><p id="d496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里红点代表负数据点，绿点代表正数据点。</p><p id="73a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在过度拟合的情况下所看到的，我们的决策表面完美地对每个点进行了分类，在这种情况下，我们将在训练数据上获得 100%准确的结果。但是考虑一下这个场景—</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/687e1405374a6d4a6d7fe522b9de4b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uczq_EJnlT-E0gVQCV_X2w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Overfitting (Image by Author)</figcaption></figure><p id="781c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，蓝点是我们的测试数据点，我们希望预测它属于正类还是负类，正如您可以看到的，根据我们的决策表面，它是负类点，但我们可以看到，它最有可能是正类点，因为它比负类点更接近正类点。这叫做过度拟合。</p><p id="7321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是我们的模型看起来的样子，如果我们遵循上面的策略，总是选择一个大的 W 值，并使<code class="fe na nb nc nd b">Zi -&gt; +∞</code></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="b01c" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">救援的规范化</h2><p id="4705" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">现在你终于明白了实际问题是什么，我们可以开始寻找解决方案，这个解决方案就是<strong class="ky ir">规范化</strong>。</p><p id="e879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你们中的许多人可能对此有一个模糊的概念，你们一定听说过它是用来防止过度适应和欠适应的，但是很少有人真正知道我们如何通过使用正则化来防止欠适应和过度适应。所以做好准备，你将加入精英团体。</p><p id="992c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种主要的规范化类型—</p><ol class=""><li id="d635" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oc ly lz ma bi translated">L2 正规化</li><li id="4c25" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oc ly lz ma bi translated">L1 正规化</li></ol><h2 id="868c" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">L2 正规化—</h2><p id="8730" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">在 L2 正则化中，为了防止过度拟合，我们引入了一个额外的术语，称为正则化术语。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d4225e4ba296a31be74b1f97dd23cd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*N94O6aTlyMgqkY6T1aFjZw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by Author</figcaption></figure><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="73f9" class="mg mh iq nd b gy ni nj l nk nl">               n<br/>W * = argmin(∑i=1   log(1 + exp(- Yi W^TXi))   - Loss term</span><span id="30cb" class="mg mh iq nd b gy nm nj l nk nl">λ W^T W                                        - Regularisation Term</span></pre><p id="7bd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的“λ”是一个超参数，它将在我们的分类模型中发挥重要作用，但首先让我们关注这个正则化项的效果。</p><p id="272d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你记得我们的目标是使<code class="fe na nb nc nd b">Zi -&gt; +∞ </code>和由于和易是固定的，因此我们只能调整 w 的值，这里你可以看到我们是用λ乘以。</p><p id="5c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以之前我们增加了 W 的值，使其成为<code class="fe na nb nc nd b">+∞ or -∞ </code>，但是现在如果我们尝试这样做，那么尽管我们的损失项的值将趋向于 0，我们的正则化项的值将非常非常大。因此，在损失项和规范项之间本质上存在一种权衡。</p><blockquote class="oi oj ok"><p id="a1db" class="kw kx ol ky b kz la jr lb lc ld ju le om lg lh li on lk ll lm oo lo lp lq lr ij bi translated">正则化项实质上惩罚了我们选择非常大的 W 值的模型，因此避免了过度拟合。</p></blockquote><p id="e165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">λ</strong>的作用</p><p id="dd4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">λ在优化我们的功能方面起着关键作用。</p><ul class=""><li id="06f4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果我们显著降低λ的值，那么模型会过拟合，因为正则化项的影响变得可以忽略不计。</li><li id="90f1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果我们显著地增加λ的值，那么我们的模型会欠拟合，因为损失项变得可以忽略，并且正则化项不包含任何训练数据。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="563d" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">L1 正规化</h2><p id="ccb4" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">L1 正则化的目的与 L2 相同，即在这种情况下避免过度拟合。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="5a6b" class="mg mh iq nd b gy ni nj l nk nl">               n<br/>W * = argmin(∑i=1   log(1 + exp(- Yi W^TXi))   - Loss term</span><span id="4922" class="mg mh iq nd b gy nm nj l nk nl">λ ||W||                                        - Regularisation Term</span><span id="3979" class="mg mh iq nd b gy nm nj l nk nl">               n <br/>Here ||W|| = ∑i=1 |Wi|  where n is the number of data points and |Wi| represents the absolute value of W. </span></pre><p id="39f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">L1 正则化和 L2 正则化的主要区别在于 L1 正则化创建稀疏向量。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="dde4" class="mg mh iq nd b gy ni nj l nk nl">F = &lt;f1,f2,f3,fi..... fn&gt;<br/>W = &lt;W1,W2,W3,Wi..... Wn&gt;</span><span id="f141" class="mg mh iq nd b gy nm nj l nk nl">Here if we have a feature fi which is not important or less important then the weight corresponfing to it will be 0 if we use L1 regularisation whereas if we use L2 regularisation then it will be a small value but not neccesarily 0.</span></pre></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="2111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到这里，我们已经到了这篇文章的结尾。非常感谢你的阅读。</p><p id="9609" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你愿意，你可以鼓掌。它是免费的。</p><p id="e1a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的<a class="ae kv" href="https://www.linkedin.com/in/dhairya-kumar/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kv" href="https://twitter.com/DhairyaKumar16" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kv" href="https://github.com/Dhairya10" rel="noopener ugc nofollow" target="_blank"> Github </a> <br/>你可以查看我的<a class="ae kv" href="https://alpha-dev.in/" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多关于我和我的工作。</p></div></div>    
</body>
</html>