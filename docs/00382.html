<html>
<head>
<title>Solving Travelling Salesperson Problems with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 解决旅行推销员问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-travelling-salesperson-problems-with-python-5de7e883d847?source=collection_archive---------2-----------------------#2019-01-17">https://towardsdatascience.com/solving-travelling-salesperson-problems-with-python-5de7e883d847?source=collection_archive---------2-----------------------#2019-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/11c1a42a475e74a2a9e964fabd14db9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URJ7WiOt1cBQMyvv1KTVog.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="39da" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">如何使用随机优化算法通过 Python 的 mlrose 包解决旅行推销员问题</h2></div><p id="87b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">mlrose 提供实现一些最流行的随机化和搜索算法的功能，并将它们应用于一系列不同的优化问题领域。</p><p id="cec8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本教程中，我们将讨论旅行推销员问题的含义，并通过一个例子来说明如何使用<em class="lp"> mlrose </em>来解决这个问题。</p><p id="3df9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是关于使用<em class="lp"> mlrose </em>解决随机优化问题的三个系列教程中的第二个。第 1 部分可在此处找到<a class="ae lq" rel="noopener" target="_blank" href="/getting-started-with-randomized-optimization-in-python-f7df46babff0">，第 3 部分可在此处</a><a class="ae lq" href="https://medium.com/@gkhayes/fitting-a-neural-network-using-randomized-optimization-in-python-71595de4ad2d" rel="noopener">找到</a>。</p><h1 id="0423" class="lr ls je bd lt lu lv lw lx ly lz ma mb kk mc kl md kn me ko mf kq mg kr mh mi bi translated">什么是旅行推销员问题？</h1><p id="9bfa" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">旅行推销员问题(TSP)是一个经典的优化问题，其目标是确定一组<em class="lp"> n </em>“城市”(即节点)的最短旅行，在同一城市开始和结束，并且恰好访问所有其他城市一次。</p><p id="1390" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，一个解决方案可以用一个由<em class="lp"> n </em>个整数组成的向量来表示，每个整数都在 0 到<em class="lp"> n-1 </em>的范围内，指定了访问城市的顺序。</p><p id="8706" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">TSP 是一个 NP-hard 问题，这意味着，对于较大的<em class="lp"> n </em>值，在合理的时间内评估每个可能的问题解决方案是不可行的。因此，tsp 非常适合使用随机优化算法来解决。</p><h2 id="4013" class="mo ls je bd lt mp mq dn lx mr ms dp mb lc mt mu md lg mv mw mf lk mx my mh mz bi translated">例子</h2><p id="41e2" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">考虑以下包含 8 个城市的地图，编号为 0 到 7。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ab1ec5f59f37024feb3f04dd8489d352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*5TiP4gk_SkSNDGU-yhW3Sg.jpeg"/></div></figure><p id="dcf4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一名销售人员想去这些城市中的每一个，在同一个城市开始和结束，并且访问其他城市一次。</p><p id="7b47" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个可能的城市旅行如下图所示，可以用解向量<em class="lp"> x </em> = [0，4，2，6，5，3，7，1]来表示(假设旅行从城市 0 开始并结束)。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9ee9d5c018eeaa29d878e10ed22c9eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*H3085vrhsMYNURRPYVEw-g.jpeg"/></div></figure><p id="4162" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，这并不是这些城市中最短的游览。这个问题的目的是找出 8 个城市中最短的 T21 之旅。</p><h1 id="5318" class="lr ls je bd lt lu lv lw lx ly lz ma mb kk mc kl md kn me ko mf kq mg kr mh mi bi translated">用 mlrose 求解 tsp</h1><p id="d8ae" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">假设 TSP 的解可以用一个范围为 0 到 n-1 的整数向量来表示，我们可以定义一个离散状态优化问题对象，并使用一个随机优化算法来解决它，就像我们在之前的教程中对 8 皇后问题所做的那样。</p><p id="8bc7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">[回想一下，离散状态优化问题是状态向量的每个元素只能取一组离散的值。在<em class="lp"> mlrose </em>中，这些值被假定为 0 到(<em class="lp"> max_val </em> -1)范围内的整数，其中<em class="lp"> max_val </em>在初始化时定义。]</p><p id="4a2c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，通过这种方式定义问题，我们最终可能会考虑无效的“解决方案”，这涉及到我们不止一次地访问一些城市，而一些则根本不访问。</p><p id="8c12" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另一种方法是定义一个优化问题对象，该对象只允许我们将第<em class="lp"> n </em>个城市的有效旅游视为潜在的解决方案。这是一种更有效的解决 tsp 的方法，可以使用<code class="fe ng nh ni nj b">TSPOpt()</code>优化问题类在<em class="lp"> mlrose </em>中实现。</p><p id="ff8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将使用这种替代方法来解决上面给出的 TSP 示例。</p><p id="d10b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">解决该问题所需的步骤与解决<em class="lp"> mlrose </em>中任何优化问题的步骤相同。具体来说:</p><ol class=""><li id="d78e" class="nk nl je kv b kw kx kz la lc nm lg nn lk no lo np nq nr ns bi translated">定义一个适应度函数对象。</li><li id="582b" class="nk nl je kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated">定义一个优化问题对象。</li><li id="80f3" class="nk nl je kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated">选择并运行随机优化算法。</li></ol><p id="e263" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在开始这个例子之前，你需要导入<em class="lp"> mlrose </em>和<em class="lp"> Numpy </em> Python 包。</p><pre class="nb nc nd ne gt ny nj nz oa aw ob bi"><span id="c99e" class="mo ls je nj b gy oc od l oe of">import mlrose<br/>import numpy as np</span></pre><h1 id="2090" class="lr ls je bd lt lu lv lw lx ly lz ma mb kk mc kl md kn me ko mf kq mg kr mh mi bi translated">定义一个适应度函数对象</h1><p id="b8e5" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">对于示例中的 TSP，目标是找到八个城市中最短的行程。因此，适应度函数应该计算给定旅程的总长度。这是在<em class="lp"> mlrose </em>的预定义<code class="fe ng nh ni nj b">TravellingSales()</code>类中使用的适应性定义。</p><p id="f065" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">默认情况下，<code class="fe ng nh ni nj b">TSPOpt()</code>优化问题类假设<code class="fe ng nh ni nj b">TravellingSales()</code>类用于定义 TSP 的适应度函数。因此，如果要使用<code class="fe ng nh ni nj b">TravellingSales()</code>类来定义适应度函数对象，那么可以跳过这一步。然而，如果需要，也可以手动定义适应度函数对象。</p><p id="8811" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了初始化<code class="fe ng nh ni nj b">TravellingSales()</code>类的适应度函数对象，需要指定所有城市的(<em class="lp"> x </em>，<em class="lp"> y </em>)坐标或者每对可能旅行的城市之间的距离。如果指定了前者，则假设每对城市之间的旅行是可能的，并且城市对之间的距离是欧几里德距离。</p><p id="aff5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们选择指定坐标，那么这些应该作为对的有序列表输入(其中对<em class="lp"> i </em>指定城市<em class="lp"> i </em>的坐标)，如下所示:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="34b5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">或者，如果我们选择指定距离，那么这些应该作为一个三元组列表输入，给出所有城市对之间的距离<em class="lp"> d </em>，<em class="lp"> u </em>和<em class="lp"> v </em>，对于这些城市，旅行是可能的，每个三元组的形式为(<em class="lp"> u </em>，<em class="lp"> v </em>，<em class="lp"> d </em>)。</p><p id="75d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">指定城市的顺序并不重要(即，假设城市 1 和 2 之间的距离与城市 2 和 1 之间的距离相同)，因此每对城市只需要被包括在列表中一次。</p><p id="a51b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">使用距离方法，可以如下初始化适应度函数对象:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c787" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果在初始化适应度函数对象时指定了坐标列表和距离列表，则距离列表将被忽略。</p><h1 id="20a8" class="lr ls je bd lt lu lv lw lx ly lz ma mb kk mc kl md kn me ko mf kq mg kr mh mi bi translated">定义一个优化问题对象</h1><p id="3d30" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">如前所述，在<em class="lp"> mlrose </em>中解决 TSP 的最有效方法是使用<code class="fe ng nh ni nj b">TSPOpt()</code>优化问题类定义优化问题对象。</p><p id="e1d2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如前一步所示，如果已经手动定义了一个适应度函数，那么初始化<code class="fe ng nh ni nj b">TSPOpt()</code>对象所需的唯一附加信息就是问题的长度(即旅程中要访问的城市数量)以及我们的问题是最大化还是最小化问题。</p><p id="5fdd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们的例子中，我们想要解决长度为 8 的最小化问题。如果我们使用上面定义的<code class="fe ng nh ni nj b">fitness_coords</code>适应度函数，我们可以如下定义一个优化问题对象:</p><pre class="nb nc nd ne gt ny nj nz oa aw ob bi"><span id="6957" class="mo ls je nj b gy oc od l oe of">problem_fit = mlrose.TSPOpt(length = 8, fitness_fn = fitness_coords,<br/>                            maximize=False)</span></pre><p id="47af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">或者，如果我们先前没有定义适应度函数(并且我们希望使用<code class="fe ng nh ni nj b">TravellingSales()</code>类来定义适应度函数)，那么这可以作为优化问题对象初始化步骤的一部分，通过指定坐标列表或距离列表而不是适应度函数对象来完成，类似于手动初始化适应度函数对象时所做的。</p><p id="336a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们的例子中，如果我们选择指定一个坐标列表，而不是一个适应度函数对象，我们可以将优化问题对象初始化为:</p><pre class="nb nc nd ne gt ny nj nz oa aw ob bi"><span id="8a88" class="mo ls je nj b gy oc od l oe of">coords_list = [(1, 1), (4, 2), (5, 2), (6, 4), (4, 4), (3, 6), <br/>               (1, 5), (2, 3)]</span><span id="ca62" class="mo ls je nj b gy oi od l oe of">problem_no_fit = mlrose.TSPOpt(length = 8, coords = coords_list,<br/>                               maximize=False)</span></pre><p id="09d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">与手动定义适应度函数对象一样，如果在初始化优化问题对象时指定了坐标列表和距离列表，则距离列表将被忽略。此外，如果除了坐标列表和/或距离列表之外还指定了适应度函数对象，则坐标/距离列表将被忽略。</p><h1 id="668e" class="lr ls je bd lt lu lv lw lx ly lz ma mb kk mc kl md kn me ko mf kq mg kr mh mi bi translated">选择并运行随机优化算法</h1><p id="355a" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">一旦优化对象被定义，剩下要做的就是选择一个随机优化算法，并用它来解决我们的问题。</p><p id="9609" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这一次，假设我们希望使用一种遗传算法，其默认参数设置为群体大小(<em class="lp"> pop_size </em>)为 200，突变概率(<em class="lp"> mutation_prob </em>)为 0.1，每步最多尝试 10 次(<em class="lp"> max_attempts </em>)，并且对算法的最大总迭代次数没有限制(<em class="lp"> max_iters </em>)。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3a22" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这将返回以下解决方案:</p><pre class="nb nc nd ne gt ny nj nz oa aw ob bi"><span id="f3a7" class="mo ls je nj b gy oc od l oe of">The best state found is:  [1 3 4 5 6 7 0 2]</span><span id="30d5" class="mo ls je nj b gy oi od l oe of">The fitness at the best state is:  18.8958046604</span></pre><p id="dc57" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该算法找到的解决方案路线如下图所示，总长度为 18.896 个单位。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9fab7daac07b94c692ec827f559805ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*7IYXUBmFZ9kSuIAuIJBJkQ.jpeg"/></div></figure><p id="3c08" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">与上一教程中给出的 8 皇后示例一样，通过调整优化算法的参数，该解决方案有可能得到改进。</p><p id="3949" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，将每步的最大尝试次数增加到 100，并将变异概率增加到 0.2，会产生总长度为 17.343 个单位的旅程。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="og oh l"/></div></figure><pre class="nb nc nd ne gt ny nj nz oa aw ob bi"><span id="6b70" class="mo ls je nj b gy oc od l oe of">The best state found is:  [7 6 5 4 3 2 1 0]</span><span id="1d13" class="mo ls je nj b gy oi od l oe of">The fitness at the best state is:  17.3426175477</span></pre><p id="303e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该解决方案如下图所示，可以证明是解决该问题的最佳解决方案。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/293fef9d28ce2ee3cec58539bf0297d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*1yV8E5YsvgaIeIQWpM96Iw.jpeg"/></div></figure><h1 id="7fb5" class="lr ls je bd lt lu lv lw lx ly lz ma mb kk mc kl md kn me ko mf kq mg kr mh mi bi translated">摘要</h1><p id="2435" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">在本教程中，我们介绍了旅行推销员问题，并讨论了如何使用<em class="lp"> mlrose </em>有效地解决这个问题。这是一个关于<em class="lp"> mlrose </em>如何解决一个非常特殊的优化问题的例子。</p><p id="060b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">mlrose 致力于解决的另一种非常特殊的优化问题是机器学习权重优化问题。也就是为神经网络、回归模型等机器学习模型寻找最优权重的问题。</p><p id="a7a1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们接下来将讨论如何使用<em class="lp"> mlrose </em>来解决这个问题，在我们的第三篇也是最后一篇教程中，可以在这里找到<a class="ae lq" href="https://medium.com/@gkhayes/fitting-a-neural-network-using-randomized-optimization-in-python-71595de4ad2d" rel="noopener">。</a></p><p id="6ceb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lp">要了解更多关于 mlrose 的信息，请访问这个包的 GitHub 资源库，这里有</em></strong><a class="ae lq" href="https://github.com/gkhayes/mlrose" rel="noopener ugc nofollow" target="_blank"><strong class="kv jf"><em class="lp"/></strong></a><strong class="kv jf"><em class="lp">。</em> </strong></p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="1e96" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="lp">Genevieve Hayes 博士是数据科学家、教育家和人工智能及分析专家，拥有</em><a class="ae lq" href="https://www.genevievehayes.com/" rel="noopener ugc nofollow" target="_blank"><em class="lp">Genevieve Hayes Consulting</em></a><em class="lp">。你可以在</em><a class="ae lq" href="https://www.linkedin.com/in/gkhayes/" rel="noopener ugc nofollow" target="_blank"><em class="lp">LinkedIn</em></a><em class="lp">或者</em><a class="ae lq" href="https://twitter.com/genevievekhayes" rel="noopener ugc nofollow" target="_blank"><em class="lp">Twitter</em></a><em class="lp">上关注她。她还是</em> <a class="ae lq" href="https://www.genevievehayes.com/episodes/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">价值驱动数据科学</em> </a> <em class="lp">的主持人，这是一个每月两次的播客，面向希望最大化其数据和数据团队价值的企业。</em></p><p id="6735" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="lp">想要发掘企业数据的价值，但不知道从哪里开始？</em><strong class="kv jf"><em class="lp"/></strong><a class="ae lq" href="https://www.genevievehayes.com/discovery-guide/" rel="noopener ugc nofollow" target="_blank"><strong class="kv jf"><em class="lp">下载免费的数据科学项目发现指南。</em></strong>T37】</a></p></div></div>    
</body>
</html>