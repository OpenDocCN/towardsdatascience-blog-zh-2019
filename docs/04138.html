<html>
<head>
<title>Modelling with Tidymodels and Parsnip</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用潮汐模型和防风草建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modelling-with-tidymodels-and-parsnip-bae2c01c131c?source=collection_archive---------5-----------------------#2019-06-29">https://towardsdatascience.com/modelling-with-tidymodels-and-parsnip-bae2c01c131c?source=collection_archive---------5-----------------------#2019-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b9ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种解决分类问题的简洁方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6335daecb6684391075481f2bff05fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wh7tnGINVRxld3x6"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@kdghantous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Karim Ghantous</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e96a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">概观</h1><p id="92c3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最近，我完成了与 R  合作的<a class="ae ky" href="https://university.business-science.io/p/ds4b-101-r-business-analysis-r" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">业务分析在线课程，该课程侧重于与 R 合作的<em class="mn">应用数据和商业科学，向我介绍了一些新的建模概念和方法。特别引起我注意的一个是<code class="fe mo mp mq mr b">parsnip</code>，它试图实现一个统一的建模和分析接口(类似于<strong class="lt iu"> python 的</strong> <code class="fe mo mp mq mr b">scikit-learn</code>)来无缝访问 r 中的几个建模平台</em></strong></a></p><p id="7f06" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mo mp mq mr b">parsnip</code>是 RStudio 的<a class="ae ky" href="https://twitter.com/topepos" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> Max Khun </strong> </a>(因<code class="fe mo mp mq mr b">caret</code>成名)和<a class="ae ky" href="https://twitter.com/dvaughan32" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> Davis Vaughan </strong> </a>的产物，是<code class="fe mo mp mq mr b">tidymodels</code>的一部分，这是一个不断发展的工具集合，用于探索和迭代建模任务，与<code class="fe mo mp mq mr b">tidyverse</code>有着共同的理念(和一些库)。</p><p id="e8f3" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">尽管有许多软件包处于开发的不同阶段，我还是决定用<code class="fe mo mp mq mr b">tidymodels</code>来“兜一圈”，也就是说，创建并执行一个“整洁的”建模工作流来解决一个<strong class="lt iu">分类</strong>问题。我的目的是展示在 R 的<code class="fe mo mp mq mr b">glm</code>中安装一个简单的<strong class="lt iu">逻辑回归</strong>是多么容易，并且只需更改几行代码，就可以使用<code class="fe mo mp mq mr b">ranger</code>引擎快速切换到一个交叉验证的<strong class="lt iu">随机森林</strong>。</p><p id="9c87" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">对于这篇文章，我特别关注来自<code class="fe mo mp mq mr b">tidymodels</code>套件的四个不同的库:<code class="fe mo mp mq mr b">rsample</code>用于数据采样和交叉验证，<code class="fe mo mp mq mr b">recipes</code>用于数据预处理，<code class="fe mo mp mq mr b">parsnip</code>用于模型建立和估计，以及<code class="fe mo mp mq mr b">yardstick</code>用于模型评估。</p><p id="28a0" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">注意</strong>重点是建模工作流和库交互。出于这个原因，我将数据探索和特性工程保持在最低限度。</p><h1 id="cd6c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建立</h1><p id="f41b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我加载了这个分析所需的包。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="b110" class="nb la it mr b gy nc nd l ne nf"><strong class="mr iu">library</strong>(tidymodels)<br/><strong class="mr iu">library</strong>(skimr)<br/><strong class="mr iu">library</strong>(tibble)</span></pre><p id="6aa0" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">对于这个项目，我使用来自 IBM 分析社区之一的<a class="ae ky" href="https://www.ibm.com/communities/analytics/watson-analytics/" rel="noopener ugc nofollow" target="_blank"> IBM Watson Analytics </a>的<a class="ae ky" href="https://www.ibm.com/communities/analytics/watson-analytics-blog/predictive-insights-in-the-telco-customer-churn-data-set/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">电信客户流失</strong> </a>。该数据包含 7，043 行，每行代表一个客户，21 列代表潜在预测者，提供预测客户行为的信息，并帮助制定有针对性的客户保留计划。</p><p id="e020" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mo mp mq mr b">Churn</code>是<strong class="lt iu">因变量</strong>，显示上个月离开的客户。数据集还包括每个客户已经注册的<strong class="lt iu">服务</strong>的详细信息，以及<strong class="lt iu">客户账户</strong>和<strong class="lt iu">人口统计</strong>信息。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="d0b9" class="nb la it mr b gy nc nd l ne nf">telco &lt;- readr::<strong class="mr iu">read_csv</strong>("WA_Fn-UseC_-Telco-Customer-Churn.csv")</span><span id="ef81" class="nb la it mr b gy ng nd l ne nf">telco %&gt;% <br/>  skimr::<strong class="mr iu">skim</strong>()</span><span id="0dcf" class="nb la it mr b gy ng nd l ne nf">## Skim summary statistics<br/>##  n obs: 7043 <br/>##  n variables: 21 <br/>## <br/>## -- Variable type:character -------------<br/>##          variable missing complete    n min max empty n_unique<br/>##             Churn       0     7043 7043   2   3     0        2<br/>##          Contract       0     7043 7043   8  14     0        3<br/>##        customerID       0     7043 7043  10  10     0     7043<br/>##        Dependents       0     7043 7043   2   3     0        2<br/>##  DeviceProtection       0     7043 7043   2  19     0        3<br/>##            gender       0     7043 7043   4   6     0        2<br/>##   InternetService       0     7043 7043   2  11     0        3<br/>##     MultipleLines       0     7043 7043   2  16     0        3<br/>##      OnlineBackup       0     7043 7043   2  19     0        3<br/>##    OnlineSecurity       0     7043 7043   2  19     0        3<br/>##  PaperlessBilling       0     7043 7043   2   3     0        2<br/>##           Partner       0     7043 7043   2   3     0        2<br/>##     PaymentMethod       0     7043 7043  12  25     0        4<br/>##      PhoneService       0     7043 7043   2   3     0        2<br/>##   StreamingMovies       0     7043 7043   2  19     0        3<br/>##       StreamingTV       0     7043 7043   2  19     0        3<br/>##       TechSupport       0     7043 7043   2  19     0        3<br/>## <br/>## -- Variable type:numeric ---------------<br/>##        variable missing complete    n    mean      sd    p0    p25     p50<br/>##  MonthlyCharges      0    7043 7043   64.76   30.09 18.25  35.5    70.35<br/>##   SeniorCitizen      0    7043 7043    0.16    0.37  0      0      0   <br/>##          tenure      0    7043 7043   32.37   24.56  0      9     29   <br/>##    TotalCharges     11    7032 7043 2283.3  2266.77 18.8  401.45 1397.47<br/>##      p75    p100<br/>##    89.85  118.75<br/>##     0       1   <br/>##    55      72   <br/>##  3794.74 8684.8</span></pre><p id="36a0" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">这里有几件事需要注意:</p><ul class=""><li id="7b03" class="nh ni it lt b lu ms lx mt ma nj me nk mi nl mm nm nn no np bi translated"><strong class="lt iu"> customerID </strong>是每一行的唯一标识符。因此，它没有描述或预测能力，需要删除。</li><li id="74e2" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">鉴于<strong class="lt iu"> TotalCharges </strong>中缺失值相对较少(只有 11 个)，我将它们从数据集中删除。</li></ul><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="152b" class="nb la it mr b gy nc nd l ne nf">telco &lt;- <br/>  telco %&gt;%<br/>  <strong class="mr iu">select</strong>(-customerID) %&gt;%<br/>  <strong class="mr iu">drop_na</strong>()</span></pre><h1 id="4151" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用<code class="fe mo mp mq mr b">tidymodels</code>建模</h1><p id="0612" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了展示<code class="fe mo mp mq mr b">tidymodels</code>框架中的基本步骤，我正在拟合和评估一个简单的<strong class="lt iu">逻辑回归</strong>模型。</p><h1 id="1376" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">训练和测试分割</h1><p id="ad94" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mo mp mq mr b">rsample</code>提供了一种简化的方法来创建原始数据的随机训练和测试分割。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="ad5f" class="nb la it mr b gy nc nd l ne nf"><strong class="mr iu">set.seed</strong>(seed = 1972) </span><span id="a879" class="nb la it mr b gy ng nd l ne nf">train_test_split &lt;-<br/>  rsample::<strong class="mr iu">initial_split</strong>(<br/>    data = telco,     <br/>    prop = 0.80   <br/>  ) </span><span id="5fef" class="nb la it mr b gy ng nd l ne nf">train_test_split<br/>## &lt;5626/1406/7032&gt;</span></pre><p id="976d" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">在总共 7，043 个客户中，5，626 个被分配给训练集，1，406 个被分配给测试集。我将它们保存为<code class="fe mo mp mq mr b">train_tbl</code>和<code class="fe mo mp mq mr b">test_tbl</code>。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="e154" class="nb la it mr b gy nc nd l ne nf">train_tbl &lt;- train_test_split %&gt;% <strong class="mr iu">training</strong>() <br/>test_tbl  &lt;- train_test_split %&gt;% <strong class="mr iu">testing</strong>()</span></pre><h1 id="a933" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简单的食谱</h1><p id="8a64" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mo mp mq mr b">recipes</code>包使用了一个<strong class="lt iu">烹饪隐喻</strong>来处理所有的数据预处理，比如缺失值插补、移除预测值、居中和缩放、一次性编码等等。</p><p id="78e4" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">首先，我创建了一个<code class="fe mo mp mq mr b">recipe</code>，在这里我定义了我想要应用于我的数据的转换。在这种情况下，我创建了一个简单的方法，将所有的字符变量转换为因子。</p><p id="6f46" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">然后，我用<code class="fe mo mp mq mr b">prep</code>混合配料<em class="mn">“准备食谱”</em>。为了简洁起见，这里我在 recipe 函数中包含了 prep 位。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="0166" class="nb la it mr b gy nc nd l ne nf">recipe_simple &lt;- <strong class="mr iu">function</strong>(dataset) {<br/>  <strong class="mr iu">recipe</strong>(Churn ~ ., data = dataset) %&gt;%<br/>    <strong class="mr iu">step_string2factor</strong>(<strong class="mr iu">all_nominal</strong>(), -<strong class="mr iu">all_outcomes</strong>()) %&gt;%<br/>    <strong class="mr iu">prep</strong>(data = dataset)<br/>}</span></pre><p id="ec61" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">注意</strong>为了避免<em class="mn">数据泄漏</em>(例如:将信息从列车组传输到测试组)，数据应仅使用<code class="fe mo mp mq mr b">train_tbl</code>进行“准备”。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="6a14" class="nb la it mr b gy nc nd l ne nf">recipe_prepped &lt;- <strong class="mr iu">recipe_simple</strong>(dataset = train_tbl)</span></pre><p id="662f" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">最后，继续烹饪的比喻，我<em class="mn">“烘焙食谱”</em>将所有预处理应用于数据集。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="fe92" class="nb la it mr b gy nc nd l ne nf">train_baked &lt;- <strong class="mr iu">bake</strong>(recipe_prepped, new_data = train_tbl)<br/>test_baked  &lt;- <strong class="mr iu">bake</strong>(recipe_prepped, new_data = test_tbl)</span></pre><h1 id="a52d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">符合模型</h1><p id="7820" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mo mp mq mr b">parsnip</code>是<code class="fe mo mp mq mr b">tidymodels</code>套件中相对较新的一个，可能是我最喜欢的一个。这个包提供了一个统一的 API，允许访问几个机器学习包，而不需要学习每个单独包的语法。</p><p id="a819" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">通过 3 个简单的步骤，您可以:</p><ul class=""><li id="e852" class="nh ni it lt b lu ms lx mt ma nj me nk mi nl mm nm nn no np bi translated">设置您想要安装的<strong class="lt iu">型号</strong>(这里是一个<code class="fe mo mp mq mr b">logistic regression</code>)及其<strong class="lt iu">模式</strong> ( <code class="fe mo mp mq mr b">classification</code>)</li><li id="5032" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">决定使用哪种计算型<strong class="lt iu">引擎</strong>(本例中为<code class="fe mo mp mq mr b">glm</code>)</li><li id="59b8" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">拼出精确的模型规格以<strong class="lt iu">适合</strong>(我在这里使用所有变量)以及使用什么<strong class="lt iu">数据</strong>(烘焙的训练数据集)</li></ul><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="6cc5" class="nb la it mr b gy nc nd l ne nf">logistic_glm &lt;-<br/>  <strong class="mr iu">logistic_reg</strong>(mode = "classification") %&gt;%<br/>  <strong class="mr iu">set_engine</strong>("glm") %&gt;%<br/>  <strong class="mr iu">fit</strong>(Churn ~ ., data = train_baked)</span></pre><p id="7536" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">如果您想使用另一个引擎，您可以简单地切换<code class="fe mo mp mq mr b">set_engine</code>参数(对于<em class="mn">逻辑回归</em>，您可以从<code class="fe mo mp mq mr b">glm</code>、<code class="fe mo mp mq mr b">glmnet</code>、<code class="fe mo mp mq mr b">stan</code>、<code class="fe mo mp mq mr b">spark</code>和<code class="fe mo mp mq mr b">keras</code>中选择)，而<code class="fe mo mp mq mr b">parsnip</code>将负责在幕后为您更改所有其他内容。</p><h1 id="9434" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">性能评价</h1><p id="fd6b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mo mp mq mr b">yardstick</code>软件包提供了一种简单的方法来计算多个评估指标。但是在我评估我的模型的性能之前，我需要通过将<code class="fe mo mp mq mr b">test_baked</code>数据传递给<code class="fe mo mp mq mr b">predict</code>函数来计算一些预测。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="0f5d" class="nb la it mr b gy nc nd l ne nf">predictions_glm &lt;- logistic_glm %&gt;%<br/>  <strong class="mr iu">predict</strong>(new_data = test_baked) %&gt;%<br/>  <strong class="mr iu">bind_cols</strong>(test_baked %&gt;% <strong class="mr iu">select</strong>(Churn))</span><span id="5a49" class="nb la it mr b gy ng nd l ne nf">head(predictions_glm)<br/>## # A tibble: 6 x 2<br/>##   .pred_class Churn<br/>##   &lt;fct&gt;       &lt;fct&gt;<br/>## 1 Yes         No   <br/>## 2 No          No   <br/>## 3 No          No   <br/>## 4 No          No   <br/>## 5 No          No   <br/>## 6 No          No</span></pre><p id="340d" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">有几个度量可以用来调查分类模型的性能，但为了简单起见，我只关注其中的一个选择:<strong class="lt iu">准确性</strong>、<strong class="lt iu">精确度</strong>、<strong class="lt iu">召回</strong>和<strong class="lt iu"> F1_Score </strong>。</p><p id="9931" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">所有这些度量(以及更多)都可以通过<a class="ae ky" href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">混淆矩阵</strong> </a>导出，该表用于描述分类模型对一组真实值已知的测试数据的性能。</p><p id="8d30" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">就其本身而言，混淆矩阵是一个相对容易理解的概念，因为它显示了<em class="mn">假阳性</em>、<em class="mn">假阴性</em>、<em class="mn">真阳性</em>和<em class="mn">真阴性</em>的数量。然而，从它派生的一些度量可能需要一些推理来完全理解它们的意义和用途。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="315a" class="nb la it mr b gy nc nd l ne nf">predictions_glm %&gt;%<br/>  <strong class="mr iu">conf_mat</strong>(Churn, .pred_class) %&gt;%<br/>  <strong class="mr iu">pluck</strong>(1) %&gt;%<br/>  <strong class="mr iu">as_tibble</strong>() %&gt;%<br/>  <strong class="mr iu">ggplot</strong>(<strong class="mr iu">aes</strong>(Prediction, Truth, alpha = n)) +<br/>  <strong class="mr iu">geom_tile</strong>(show.legend = FALSE) +<br/>  <strong class="mr iu">geom_text</strong>(<strong class="mr iu">aes</strong>(label = n), colour = "white", alpha = 1, size = 8)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e3893f388dbce654dc649a866d5318f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNyS0GPTj7joCOb3R_T_pw.png"/></div></div></figure><p id="8b1b" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">模型的<strong class="lt iu">精度</strong>是模型正确预测的分数，可以通过将<code class="fe mo mp mq mr b">predictions_glm</code>传递给<code class="fe mo mp mq mr b">metrics</code>函数来轻松计算。然而，准确性并不是一个非常可靠的指标，因为如果数据集不平衡，它将提供误导性的结果。</p><p id="ee0d" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">仅通过基本的数据操作和特征工程，简单的逻辑模型已经达到 80%的准确度。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="d124" class="nb la it mr b gy nc nd l ne nf">predictions_glm %&gt;%<br/>  <strong class="mr iu">metrics</strong>(Churn, .pred_class) %&gt;%<br/>  <strong class="mr iu">select</strong>(-.estimator) %&gt;%<br/>  <strong class="mr iu">filter</strong>(.metric == "accuracy") </span><span id="5f02" class="nb la it mr b gy ng nd l ne nf">## .metric   .estimate<br/>## accuracy  0.8058321</span></pre><p id="ac59" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">精度</strong>显示模型对<em class="mn">误报</em>的敏感程度(即预测客户在他/她实际逗留时离开)，而<strong class="lt iu">召回</strong>查看模型对<em class="mn">误报</em>的敏感程度(即预测客户在他/她实际离开时仍在逗留)。</p><p id="1e3f" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">这些是非常相关的商业指标，因为组织对准确预测哪些客户真正有流失的风险特别感兴趣，这样他们就可以有针对性地制定保留策略。与此同时，他们希望尽最大努力留住那些被错误归类为离开的客户，因为他们会留下来。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="4c54" class="nb la it mr b gy nc nd l ne nf"><strong class="mr iu">tibble</strong>(<br/>  "precision" = <br/>     <strong class="mr iu">precision</strong>(predictions_glm, Churn, .pred_class) %&gt;%<br/>     <strong class="mr iu">select</strong>(.estimate),<br/>  "recall" = <br/>     <strong class="mr iu">recall</strong>(predictions_glm, Churn, .pred_class) %&gt;%<br/>     <strong class="mr iu">select</strong>(.estimate)<br/>) %&gt;%<br/>  <strong class="mr iu">unnest</strong>() %&gt;%<br/>  <strong class="mr iu">kable</strong>()</span><span id="c35d" class="nb la it mr b gy ng nd l ne nf">## precision   recall <br/>## 0.8466368   0.9024857</span></pre><p id="1551" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">另一个流行的性能评估指标是<a class="ae ky" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> F1 得分</strong> </a>，它是<a class="ae ky" href="https://en.wikipedia.org/wiki/Precision_(information_retrieval)" rel="noopener ugc nofollow" target="_blank">精度</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Recall_(information_retrieval)" rel="noopener ugc nofollow" target="_blank">召回</a>的调和平均值。F1 分数在 1 时达到最佳值，具有完美的<em class="mn">精度</em>和<em class="mn">召回</em>。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="014a" class="nb la it mr b gy nc nd l ne nf">predictions_glm %&gt;%<br/>  <strong class="mr iu">f_meas</strong>(Churn, .pred_class) %&gt;%<br/>  <strong class="mr iu">select</strong>(-.estimator) %&gt;%<br/>  <strong class="mr iu">kable</strong>()</span><span id="5fb7" class="nb la it mr b gy ng nd l ne nf">## .metric  .estimate <br/>## f_meas   0.8736696</span></pre><h1 id="3e37" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">随机森林</h1><p id="e1c4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这就是<code class="fe mo mp mq mr b">tidymodels</code>真正的魅力所在。现在，我可以使用这个整洁的建模框架，用<code class="fe mo mp mq mr b">ranger</code>引擎装配一个<strong class="lt iu">随机森林</strong>模型。</p><h1 id="a0ab" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">交叉验证设置</h1><p id="6481" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了进一步完善模型的预测能力，我使用来自<code class="fe mo mp mq mr b">rsample</code>的<code class="fe mo mp mq mr b">vfold_cv</code>实现了一个<strong class="lt iu"> 10 重交叉验证</strong>，它再次分割了初始训练数据。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="29fd" class="nb la it mr b gy nc nd l ne nf">cross_val_tbl &lt;- <strong class="mr iu">vfold_cv</strong>(train_tbl, v = 10)</span><span id="a838" class="nb la it mr b gy ng nd l ne nf">cross_val_tbl<br/>## #  10-fold cross-validation <br/>## # A tibble: 10 x 2<br/>##    splits             id    <br/>##    &lt;list&gt;             &lt;chr&gt; <br/>##  1 &lt;split [5.1K/563]&gt; Fold01<br/>##  2 &lt;split [5.1K/563]&gt; Fold02<br/>##  3 &lt;split [5.1K/563]&gt; Fold03<br/>##  4 &lt;split [5.1K/563]&gt; Fold04<br/>##  5 &lt;split [5.1K/563]&gt; Fold05<br/>##  6 &lt;split [5.1K/563]&gt; Fold06<br/>##  7 &lt;split [5.1K/562]&gt; Fold07<br/>##  8 &lt;split [5.1K/562]&gt; Fold08<br/>##  9 &lt;split [5.1K/562]&gt; Fold09<br/>## 10 &lt;split [5.1K/562]&gt; Fold10</span></pre><p id="61c6" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">如果我们进一步观察，我们应该认识到 5626 这个数字，这是初始<code class="fe mo mp mq mr b">train_tbl</code>中的观察总数。在每一轮中，将依次从估计中保留 563 个观察值，并用于验证该折叠的模型。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="3ada" class="nb la it mr b gy nc nd l ne nf">cross_val_tbl$splits %&gt;%<br/>  <strong class="mr iu">pluck</strong>(1)</span><span id="b461" class="nb la it mr b gy ng nd l ne nf">## &lt;5063/563/5626&gt;</span></pre><p id="38b0" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">为了避免混淆并区分<em class="mn">初始训练/测试分割</em>和那些用于交叉验证的分割，Max Kuhn<strong class="lt iu">的作者创造了两个新术语:<code class="fe mo mp mq mr b">analysis</code>和<code class="fe mo mp mq mr b">assessment</code>集合。前者是用于递归估计模型的训练数据部分，而后者是用于验证每个估计的部分。</strong></p><h1 id="d57b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">更新配方</h1><p id="d7a4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">注意</strong>一个随机森林需要<em class="mn">所有数字</em>变量被<em class="mn">居中并缩放</em>，所有<em class="mn">字符/因子</em>变量被<em class="mn">【虚拟化】</em>。这很容易通过用这些转换更新配方来完成。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="df95" class="nb la it mr b gy nc nd l ne nf">recipe_rf &lt;- <strong class="mr iu">function</strong>(dataset) {<br/>  <strong class="mr iu">recipe</strong>(Churn ~ ., data = dataset) %&gt;%<br/>    <strong class="mr iu">step_string2factor</strong>(<strong class="mr iu">all_nominal</strong>(), -<strong class="mr iu">all_outcomes</strong>()) %&gt;%<br/>    <strong class="mr iu">step_dummy</strong>(<strong class="mr iu">all_nominal</strong>(), -<strong class="mr iu">all_outcomes</strong>()) %&gt;%<br/>    <strong class="mr iu">step_center</strong>(<strong class="mr iu">all_numeric</strong>()) %&gt;%<br/>    <strong class="mr iu">step_scale</strong>(<strong class="mr iu">all_numeric</strong>()) %&gt;%<br/>    <strong class="mr iu">prep</strong>(data = dataset)<br/>}</span></pre><h1 id="6f7a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">评估模型</h1><p id="3edf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">切换到另一种模式再简单不过了！我所需要做的就是将<strong class="lt iu">型号</strong>改为<code class="fe mo mp mq mr b">random_forest</code>并添加其超参数，将<strong class="lt iu"> set_engine </strong>参数改为<code class="fe mo mp mq mr b">ranger</code>，我就准备好了。</p><p id="2b95" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">我将所有步骤捆绑到一个函数中，该函数估计所有褶皱的模型，运行预测，并返回一个包含所有结果的方便表格。我需要在配方“准备”之前添加一个额外的步骤，将交叉验证分割映射到<code class="fe mo mp mq mr b">analysis</code>和<code class="fe mo mp mq mr b">assessment</code>函数。这将引导 10 次折叠的迭代。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="1e5d" class="nb la it mr b gy nc nd l ne nf">rf_fun &lt;- <strong class="mr iu">function</strong>(split, id, try, tree) {<br/>   <br/>  analysis_set &lt;- split %&gt;% <strong class="mr iu">analysis</strong>()<br/>  analysis_prepped &lt;- analysis_set %&gt;% <strong class="mr iu">recipe_rf</strong>()<br/>  analysis_baked &lt;- analysis_prepped %&gt;% <strong class="mr iu">bake</strong>(new_data = analysis_set)</span><span id="95d9" class="nb la it mr b gy ng nd l ne nf">  model_rf &lt;-<br/>    <strong class="mr iu">rand_forest</strong>(<br/>      mode = "classification",<br/>      mtry = try,<br/>      trees = tree<br/>    ) %&gt;%<br/>    <strong class="mr iu">set_engine</strong>("ranger",<br/>      importance = "impurity"<br/>    ) %&gt;%<br/>    <strong class="mr iu">fit</strong>(Churn ~ ., data = analysis_baked)</span><span id="2466" class="nb la it mr b gy ng nd l ne nf">  assessment_set &lt;- split %&gt;% <strong class="mr iu">assessment</strong>()<br/>  assessment_prepped &lt;- assessment_set %&gt;% <strong class="mr iu">recipe_rf</strong>()<br/>  assessment_baked &lt;- assessment_prepped %&gt;% <strong class="mr iu">bake</strong>(new_data = assessment_set)</span><span id="cdbb" class="nb la it mr b gy ng nd l ne nf">  <strong class="mr iu">tibble</strong>(<br/>    "id" = id,<br/>    "truth" = assessment_baked$Churn,<br/>    "prediction" = model_rf %&gt;%<br/>      <strong class="mr iu">predict</strong>(new_data = assessment_baked) %&gt;%<br/>      <strong class="mr iu">unlist</strong>()<br/>  )<br/>  <br/>}</span></pre><h1 id="6f71" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">性能评价</h1><p id="fa43" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我剩下要做的就是将公式映射到数据框。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="4b79" class="nb la it mr b gy nc nd l ne nf">pred_rf &lt;- <strong class="mr iu">map2_df</strong>(<br/>  .x = cross_val_tbl$splits,<br/>  .y = cross_val_tbl$id,<br/>  ~ <strong class="mr iu">rf_fun</strong>(split = .x, id = .y, try = 3, tree = 200)<br/>)</span><span id="ec05" class="nb la it mr b gy ng nd l ne nf"><strong class="mr iu">head</strong>(pred_rf)<br/>## # A tibble: 6 x 3<br/>##   id     truth prediction<br/>##   &lt;chr&gt;  &lt;fct&gt; &lt;fct&gt;     <br/>## 1 Fold01 Yes   Yes       <br/>## 2 Fold01 Yes   No        <br/>## 3 Fold01 Yes   Yes       <br/>## 4 Fold01 No    No        <br/>## 5 Fold01 No    No        <br/>## 6 Fold01 Yes   No</span></pre><p id="79ac" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">我发现<code class="fe mo mp mq mr b">yardstick</code>有一个非常方便的混淆矩阵<code class="fe mo mp mq mr b">summary</code>函数，它返回一个由<strong class="lt iu"> 13 个不同指标</strong>组成的数组，但是在这种情况下，我想看看我在<code class="fe mo mp mq mr b">glm</code>模型中使用的四个指标。</p><pre class="kj kk kl km gt mx mr my mz aw na bi"><span id="e7bb" class="nb la it mr b gy nc nd l ne nf">pred_rf %&gt;%<br/>  <strong class="mr iu">conf_mat</strong>(truth, prediction) %&gt;%<br/>  <strong class="mr iu">summary</strong>() %&gt;%<br/>  <strong class="mr iu">select</strong>(-.estimator) %&gt;%<br/>  <strong class="mr iu">filter</strong>(.metric %in%<br/>    c("accuracy", "precision", "recall", "f_meas")) %&gt;%<br/>  <strong class="mr iu">kable</strong>()</span><span id="2ffa" class="nb la it mr b gy ng nd l ne nf">## .metric    .estimate <br/>##  accuracy  0.7979026 <br/>##  precision 0.8250436 <br/>##  recall    0.9186301 <br/>##  f_meas    0.8693254</span></pre><p id="94b6" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mo mp mq mr b">random forest</code>型号的性能与简单的<code class="fe mo mp mq mr b">logistic regression</code>不相上下。鉴于我已经完成的非常基本的特征工程，还有进一步改进模型的空间，但这超出了本文的范围。</p><h1 id="232e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">成交注意事项</h1><p id="1ab2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mo mp mq mr b">tidymodels</code>的最大优势之一是对分析工作流程每个阶段的灵活性和易用性。创建建模管道轻而易举，通过使用<code class="fe mo mp mq mr b">parsnip</code>改变模型类型和使用<code class="fe mo mp mq mr b">recipes</code>进行数据预处理，您可以轻松重用初始框架，并且很快就可以使用<code class="fe mo mp mq mr b">yardstick</code>检查新模型的性能。</p><p id="473e" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">在任何分析中，你通常会审计几个模型，而<code class="fe mo mp mq mr b">parsnip</code>让你不必学习每个建模引擎的独特语法，这样你就可以专注于寻找手头问题的最佳解决方案。</p><h1 id="926f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">代码库</h1><p id="53d7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">完整的 R 代码可以在<a class="ae ky" href="https://github.com/DiegoUsaiUK/Classification_Churn_with_Parsnip" rel="noopener ugc nofollow" target="_blank">我的 GitHub 简介</a>中找到</p><h1 id="667a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><ul class=""><li id="36bb" class="nh ni it lt b lu lv lx ly ma nw me nx mi ny mm nm nn no np bi translated">非常感谢<em class="mn"> Bruno Rodrigues </em>的文章，这篇文章为大评估公式<a class="ae ky" href="https://www.brodrigues.co/blog/2018-11-25-tidy_cv/" rel="noopener ugc nofollow" target="_blank">提供了灵感，这是一篇关于与 R 进行整齐交叉验证的教程</a></li><li id="59bc" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">更感谢<em class="mn">本杰明·索伦森</em>用 <code class="fe mo mp mq mr b"><a class="ae ky" href="https://www.benjaminsorensen.me/post/modeling-with-parsnip-and-tidymodels/" rel="noopener ugc nofollow" target="_blank">parsnip</a></code> <a class="ae ky" href="https://www.benjaminsorensen.me/post/modeling-with-parsnip-and-tidymodels/" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe mo mp mq mr b"><a class="ae ky" href="https://www.benjaminsorensen.me/post/modeling-with-parsnip-and-tidymodels/" rel="noopener ugc nofollow" target="_blank">tidymodels</a></code>对<a class="ae ky" href="https://www.benjaminsorensen.me/post/modeling-with-parsnip-and-tidymodels/" rel="noopener ugc nofollow" target="_blank">造型的深思熟虑</a></li><li id="856b" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">关于<code class="fe mo mp mq mr b"><a class="ae ky" href="https://www.tidyverse.org/articles/2018/11/parsnip-0-0-1/" rel="noopener ugc nofollow" target="_blank">parsnip</a></code>的介绍</li></ul></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="7554" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><em class="mn">原载于 2019 年 6 月 22 日</em><a class="ae ky" href="https://diegousai.io/2019/09/modelling-with-tidymodels-and-parsnip/" rel="noopener ugc nofollow" target="_blank"><em class="mn">https://diegousei . io</em></a><em class="mn">。</em></p></div></div>    
</body>
</html>