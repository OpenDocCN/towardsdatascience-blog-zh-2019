<html>
<head>
<title>Continuous Genetic Algorithm From Scratch With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 从头开始连续遗传算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/continuous-genetic-algorithm-from-scratch-with-python-ff29deedd099?source=collection_archive---------3-----------------------#2019-10-29">https://towardsdatascience.com/continuous-genetic-algorithm-from-scratch-with-python-ff29deedd099?source=collection_archive---------3-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2878" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遗传算法是一种受自然启发的强大优化技术。遗传算法模仿进化来寻找最佳解决方案。与大多数优化算法不同，遗传算法不使用导数来寻找最小值。遗传算法最显著的优点之一是它们能够找到全局最小值而不会陷入局部最小值。随机性在遗传算法的结构中起着重要的作用，这也是遗传算法不断搜索搜索空间的主要原因。标题中的连续意味着我们要创建的遗传算法将使用浮点数或整数作为优化参数，而不是二进制数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3a5b9beea0b1b9e30956d178e000d23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7YNgme2E0vv--NyW39B2A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Flowchart of genetic algorithms</figcaption></figure><p id="5770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遗传算法创建随机生成的候选解的初始群体，评估这些候选解，并计算它们的适应值。解的适应值是决定解有多好的数值，适应值越高，解越好。下图显示了一个有 8 个人的示例生成。每个个体由代表优化参数的 4 个基因组成，并且每个个体具有适应值，在这种情况下，适应值是基因值的总和。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/37e208137262f3e9c3ca7f4b9520b833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWoHbvSKG2mazwlIq6ZsWA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">An example of a generation</figcaption></figure><p id="b4d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果初始种群不满足终止准则的要求，遗传算法产生下一代。第一次遗传操作是选择；在这个操作中，将会进入下一代的个体被选择。在选择过程之后，配对操作开始。配对操作将选定的个体两两配对，以进行交配操作。交配操作采用配对的亲代个体并产生后代，后代将替换在选择操作中未被选择的个体，因此下一代具有与上一代相同数量的个体。重复该过程，直到满足终止标准。</p><p id="86e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，使用 Python 标准库和 Numpy 从头开始创建遗传算法代码。前面讨论的每一种遗传操作都是作为函数创建的。在我们开始遗传算法代码之前，我们需要导入一些库作为:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="feca" class="lk ll it lg b gy lm ln l lo lp">import numpy as np<br/>from numpy.random import randint<br/>from random import random as rnd<br/>from random import gauss, randrange</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="7bd0" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak"> <em class="mu">初始人口</em> </strong></h1><p id="bd37" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">遗传算法通过创建候选解的初始群体来开始优化过程，候选解的基因是随机生成的。为了创建初始群体，必须创建一个创建个体的函数；</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="a858" class="lk ll it lg b gy lm ln l lo lp">def individual(number_of_genes, upper_limit, lower_limit):<br/>    individual=[round(rnd()*(upper_limit-lower_limit)<br/>                +lower_limit,1) for x in range(number_of_genes)]<br/>    return individual </span></pre><p id="fd74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数将基因数量、基因的上限和下限作为输入，并创建个体。在创建了创建个体的函数之后，需要另一个函数来创建群体。创建群体的函数可以写成:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="8446" class="lk ll it lg b gy lm ln l lo lp">def population(number_of_individuals,<br/>               number_of_genes, upper_limit, lower_limit):<br/>    return [individual(number_of_genes, upper_limit, lower_limit) <br/>        for x in range(number_of_individuals)]</span></pre><p id="4f7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这两个函数，可以创建初始群体。在遗传算法产生第一代后，计算个体的适应值。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="854c" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">适合度计算</h1><p id="6140" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">适应度计算函数决定了个体的适应度值，如何计算适应度值取决于最优化问题。如果问题是优化一个函数的参数，那么该函数应该被实现为适应度计算函数。优化问题可能非常复杂，可能需要使用特定的软件来解决问题；在这种情况下，适应性计算功能应该运行模拟，并从正在使用的软件中收集结果。为了简单起见，我们将回顾文章开头给出的生成示例。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="016f" class="lk ll it lg b gy lm ln l lo lp">def fitness_calculation(individual);<br/>    fitness_value = sum(individual)<br/>    return fitness_value</span></pre><p id="72da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个非常简单的适应度函数，只有一个参数。可以为多个参数计算适应度函数。对于多个参数，归一化不同的参数是非常重要的，不同参数之间的幅度差异可能导致其中一个参数对于适应函数值变得过时。可以用不同的方法来优化参数，归一化方法之一是重新缩放。重新缩放可以表示为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/560432731236d7468031478fb8d48879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBdCaZ-4r6LZOs568LLS-g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Function for normalizing parameters</figcaption></figure><p id="78d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中 m_s 是参数的换算值，m_o 是参数的实际值。在此函数中，参数的最大值和最小值应根据问题的性质来确定。</p><p id="896d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在参数被归一化之后，参数的重要性由适应度函数中给予每个参数的偏差来确定。给定参数的偏差总和应为 1。对于多个参数，适应度函数可以写成:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/ede9c162716de0fb96119510dbbee570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2n7YmkBc3Kzzcl4engMGcA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Multi-parameter fitness function</figcaption></figure><p id="b1d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<em class="nc"> b </em>表示适应度函数的偏差，而<em class="nc"> p </em>表示归一化参数。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="3010" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">选择</h1><p id="eacb" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">选择函数获取候选解的群体及其适应度值(一代)，并输出将进入下一代的个体。可以将精英主义引入到遗传算法中，遗传算法会在一代中自动选择最佳个体，因此我们不会丢失最佳解。有几种选择方法可以使用。本文给出的选择方法有:</p><ul class=""><li id="205c" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">轮盘选择:</strong>在轮盘选择中，每个个体都有机会被选中。个体被选中的几率是基于个体的适合度值。更健康的人更有可能被选中。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/443467c25160a3ffca81ef32ea1fa5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgznZKVP-AskyXrJt_Da0g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Roulette wheel selection figure</figcaption></figure><p id="8875" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">轮盘游戏轮盘选择的函数获取累积和以及选择过程中随机生成的值，并返回所选个体的号码。通过计算累积和，每个个体都有一个介于 0 和 1 之间的唯一值。为了选择个体，随机产生一个 0 到 1 之间的数字，并且选择接近随机产生的数字的个体。轮盘赌函数可以写成:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="3e24" class="lk ll it lg b gy lm ln l lo lp">def roulette(cum_sum, chance):<br/>    veriable = list(cum_sum.copy())<br/>    veriable.append(chance)<br/>    veriable = sorted(veriable)<br/>    return veriable.index(chance)</span></pre><ul class=""><li id="016a" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">最适合的一半选择:</strong>在这种选择方法中，候选解中最适合的一半被选择出来进入下一代。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/3589486c83f823723a01e8d87e18e210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkn-rfv5YZAHiVsjz6YMcA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Fittest half selection figure</figcaption></figure><ul class=""><li id="acad" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">随机选择:</strong>在这种方法中，个体随机选择。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/f9e18dbdba503ead7eb642f5e5c98d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWSBPusehpJs64-uJvjToQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Random selection figure</figcaption></figure><p id="b6d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选择函数可以写成:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="1634" class="lk ll it lg b gy lm ln l lo lp">def selection(generation, method='Fittest Half'):<br/>    generation['Normalized Fitness'] = \<br/>        sorted([generation['Fitness'][x]/sum(generation['Fitness']) <br/>        for x in range(len(generation['Fitness']))], reverse = True)<br/>    generation['Cumulative Sum'] = np.array(<br/>        generation['Normalized Fitness']).cumsum()<br/>    if method == 'Roulette Wheel':<br/>        selected = []<br/>        for x in range(len(generation['Individuals'])//2):<br/>            selected.append(roulette(generation<br/>                ['Cumulative Sum'], rnd()))<br/>            while len(set(selected)) != len(selected):<br/>                selected[x] = \<br/>                    (roulette(generation['Cumulative Sum'], rnd()))<br/>        selected = {'Individuals': <br/>            [generation['Individuals'][int(selected[x])]<br/>                for x in range(len(generation['Individuals'])//2)]<br/>                ,'Fitness': [generation['Fitness'][int(selected[x])]<br/>                for x in range(<br/>                    len(generation['Individuals'])//2)]}<br/>    elif method == 'Fittest Half':<br/>        selected_individuals = [generation['Individuals'][-x-1]<br/>            for x in range(int(len(generation['Individuals'])//2))]<br/>        selected_fitnesses = [generation['Fitness'][-x-1]<br/>            for x in range(int(len(generation['Individuals'])//2))]<br/>        selected = {'Individuals': selected_individuals,<br/>                    'Fitness': selected_fitnesses}<br/>    elif method == 'Random':<br/>        selected_individuals = \<br/>            [generation['Individuals']<br/>                [randint(1,len(generation['Fitness']))]<br/>            for x in range(int(len(generation['Individuals'])//2))]<br/>        selected_fitnesses = [generation['Fitness'][-x-1]<br/>            for x in range(int(len(generation['Individuals'])//2))]<br/>        selected = {'Individuals': selected_individuals,<br/>                    'Fitness': selected_fitnesses}<br/>    return selected</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6247" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">配对</h1><p id="759b" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">配对和交配在大多数遗传算法应用中被用作单个操作，但是为了创建更简单的函数并且能够容易地使用不同的交配和配对算法，这两个遗传操作在该应用中被分开。如果在遗传算法中存在精英，精英必须是函数的输入以及被选择的个体。我们将讨论三种不同的配对方法；</p><ul class=""><li id="f47a" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">最适:</strong>在这种方法中，个体两两配对，从最适个体开始。通过这样做，健康的个体被配对在一起，但是不健康的个体也被配对在一起。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/4711e2e3a6793f87de204e15ae1a9be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_fNrS1br7P7Js23netMUw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Fittest pairing figure</figcaption></figure><ul class=""><li id="c77c" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">随机:</strong>在这种方法中，个体被两两随机配对。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/843d5fcdb8aa7b6f255fde6236b4d1fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXEBjxSa9S5evmtTpcKSew.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Random pairing figure</figcaption></figure><ul class=""><li id="9032" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">加权随机:</strong>在这种方法中，个体两两随机配对，但更适合的个体被选中配对的几率更高。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/b4e66272ade23cece60462e741a5f20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDegygnAiEnF7sgACcqyOA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Weighted random pairing</figcaption></figure><p id="712e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配对函数可以写成；</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="db97" class="lk ll it lg b gy lm ln l lo lp">def pairing(elit, selected, method = 'Fittest'):<br/>    individuals = [elit['Individuals']]+selected['Individuals']<br/>    fitness = [elit['Fitness']]+selected['Fitness']<br/>    if method == 'Fittest':<br/>        parents = [[individuals[x],individuals[x+1]] <br/>                   for x in range(len(individuals)//2)]<br/>    if method == 'Random':<br/>        parents = []<br/>        for x in range(len(individuals)//2):<br/>            parents.append(<br/>                [individuals[randint(0,(len(individuals)-1))],<br/>                 individuals[randint(0,(len(individuals)-1))]])<br/>            while parents[x][0] == parents[x][1]:<br/>                parents[x][1] = individuals[<br/>                    randint(0,(len(individuals)-1))]<br/>    if method == 'Weighted Random':<br/>        normalized_fitness = sorted(<br/>            [fitness[x] /sum(fitness) <br/>             for x in range(len(individuals)//2)], reverse = True)<br/>        cummulitive_sum = np.array(normalized_fitness).cumsum()<br/>        parents = []<br/>        for x in range(len(individuals)//2):<br/>            parents.append(<br/>                [individuals[roulette(cummulitive_sum,rnd())],<br/>                 individuals[roulette(cummulitive_sum,rnd())]])<br/>            while parents[x][0] == parents[x][1]:<br/>                parents[x][1] = individuals[<br/>                    roulette(cummulitive_sum,rnd())]<br/>    return parents</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="5c30" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">交配</h1><p id="ca41" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">我们将讨论两种不同的交配方法。在下面给出的 Python 代码中，两个选定的父个体创建了两个子个体。我们将要讨论两种交配方法。</p><ul class=""><li id="2859" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">单点:</strong>在这种方法中，单点之后的基因被另一个亲本的基因替换，从而产生两个后代。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6e0cd6d32a5af6b66dea0f01f92563d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*K1hfu6HgzeLpZL3BcBykWg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Single point mating</figcaption></figure><ul class=""><li id="ae27" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">两点:</strong>在这种方法中，两点之间的基因被替换为另一个亲本的基因，从而产生两个后代。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bac6d9df81b5049cc4e8721ec442be0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*rpLc2KJuB7HWFcerNhYUnQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Two points mating</figcaption></figure><p id="71a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">交配功能可编码为:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="36af" class="lk ll it lg b gy lm ln l lo lp">def mating(parents, method='Single Point'):<br/>    if method == 'Single Point':<br/>        pivot_point = randint(1, len(parents[0]))<br/>        offsprings = [parents[0] \<br/>            [0:pivot_point]+parents[1][pivot_point:]]<br/>        offsprings.append(parents[1]<br/>            [0:pivot_point]+parents[0][pivot_point:])<br/>    if method == 'Two Pionts':<br/>        pivot_point_1 = randint(1, len(parents[0]-1))<br/>        pivot_point_2 = randint(1, len(parents[0]))<br/>        while pivot_point_2&lt;pivot_point_1:<br/>            pivot_point_2 = randint(1, len(parents[0]))<br/>        offsprings = [parents[0][0:pivot_point_1]+<br/>            parents[1][pivot_point_1:pivot_point_2]+<br/>            [parents[0][pivot_point_2:]]]<br/>        offsprings.append([parents[1][0:pivot_point_1]+<br/>            parents[0][pivot_point_1:pivot_point_2]+<br/>            [parents[1][pivot_point_2:]]])<br/>    return offsprings</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="544c" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">突变</h1><p id="eb60" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">最后的遗传操作是随机突变。随机突变发生在被选择的个体及其后代中，以提高下一代的多样性。如果遗传算法中存在精英主义，精英个体不会经历随机突变，因此我们不会失去最佳解决方案。我们将讨论两种不同的突变方法。</p><ul class=""><li id="1851" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">高斯:</strong>在该方法中，经历突变的基因被替换为根据原始基因周围的高斯分布生成的数字。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/b3d44993f31ea814ebe59772e50c3b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoeMXtJReXK_XJQcA7Toeg.png"/></div></div></figure><ul class=""><li id="463a" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">重置:</strong>在该方法中，原始基因被随机生成的基因所替代。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/beba97ddc65e38914d580ac2aceaa0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CG2k9PNRt7yqnpK0SvsReA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Reset mutation figure</figcaption></figure><p id="15ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变异函数可以写成:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="1571" class="lk ll it lg b gy lm ln l lo lp">def mutation(individual, upper_limit, lower_limit, muatation_rate=2, <br/>    method='Reset', standard_deviation = 0.001):<br/>    gene = [randint(0, 7)]<br/>    for x in range(muatation_rate-1):<br/>        gene.append(randint(0, 7))<br/>        while len(set(gene)) &lt; len(gene):<br/>            gene[x] = randint(0, 7)<br/>    mutated_individual = individual.copy()<br/>    if method == 'Gauss':<br/>        for x in range(muatation_rate):<br/>            mutated_individual[x] = \<br/>            round(individual[x]+gauss(0, standard_deviation), 1)<br/>    if method == 'Reset':<br/>        for x in range(muatation_rate):<br/>            mutated_individual[x] = round(rnd()* \<br/>                (upper_limit-lower_limit)+lower_limit,1)<br/>    return mutated_individual</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4c84" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">创造下一代</h1><p id="6f43" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">下一代是用我们讨论过的遗传操作创造出来的。在产生下一代的过程中，精英主义可以被引入遗传算法。精英主义是创造下一代的 python 代码，可以写成；</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="b1c4" class="lk ll it lg b gy lm ln l lo lp">def next_generation(gen, upper_limit, lower_limit):<br/>    elit = {}<br/>    next_gen = {}<br/>    elit['Individuals'] = gen['Individuals'].pop(-1)<br/>    elit['Fitness'] = gen['Fitness'].pop(-1)<br/>    selected = selection(gen)<br/>    parents = pairing(elit, selected)<br/>    offsprings = [[[mating(parents[x])<br/>                    for x in range(len(parents))]<br/>                    [y][z] for z in range(2)] <br/>                    for y in range(len(parents))]<br/>    offsprings1 = [offsprings[x][0]<br/>                   for x in range(len(parents))]<br/>    offsprings2 = [offsprings[x][1]<br/>                   for x in range(len(parents))]<br/>    unmutated = selected['Individuals']+offsprings1+offsprings2<br/>    mutated = [mutation(unmutated[x], upper_limit, lower_limit) <br/>        for x in range(len(gen['Individuals']))]<br/>    unsorted_individuals = mutated + [elit['Individuals']]<br/>    unsorted_next_gen = \<br/>        [fitness_calculation(mutated[x]) <br/>         for x in range(len(mutated))]<br/>    unsorted_fitness = [unsorted_next_gen[x]<br/>        for x in range(len(gen['Fitness']))] + [elit['Fitness']]<br/>    sorted_next_gen = \<br/>        sorted([[unsorted_individuals[x], unsorted_fitness[x]]<br/>            for x in range(len(unsorted_individuals))], <br/>                key=lambda x: x[1])<br/>    next_gen['Individuals'] = [sorted_next_gen[x][0]<br/>        for x in range(len(sorted_next_gen))]<br/>    next_gen['Fitness'] = [sorted_next_gen[x][1]<br/>        for x in range(len(sorted_next_gen))]<br/>    gen['Individuals'].append(elit['Individuals'])<br/>    gen['Fitness'].append(elit['Fitness'])<br/>    return next_gen</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ba91" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">终止标准</h1><p id="feef" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">在一代被创建之后，终止标准被用于确定遗传算法是否应该创建另一代或者应该停止。可以同时使用不同的终止标准，并且如果遗传算法满足标准之一，则遗传算法停止。我们将讨论四个终止标准。</p><ul class=""><li id="f880" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">最大适应度</strong>:该终止标准检查当前世代中最适应的个体是否满足我们的标准。使用这种终端方法，可以获得期望的结果。如下图所示，最大适应度极限可以被确定为包括一些局部最小值。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/90b82c3ad75ce8322f0fcc8480b1ee5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNGuHInhJjVKLcPFnBTwHA.png"/></div></div></figure><ul class=""><li id="5f05" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><strong class="js iu">最大平均适应度:</strong>如果我们对一组解感兴趣，可以检查当前代中个体的平均值，以确定当前代是否满足我们的期望。</li><li id="e75f" class="nd ne it js b jt nw jx nx kb ny kf nz kj oa kn ni nj nk nl bi translated"><strong class="js iu">最大代数:</strong>我们可以限制遗传算法产生的最大代数。</li><li id="8a1d" class="nd ne it js b jt nw jx nx kb ny kf nz kj oa kn ni nj nk nl bi translated"><strong class="js iu">最大相似适应值:</strong>由于精英主义，一代中最优秀的个体可以不发生变异而进入下一代。这个个体也可以成为下一代中最好的个体。我们可以限制同一个体成为最佳个体的数量，因为这可能意味着遗传算法陷入了局部极小值。用于检查最大适应值是否已经改变的函数可以写成:</li></ul><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="28ca" class="lk ll it lg b gy lm ln l lo lp">def fitness_similarity_chech(max_fitness, number_of_similarity):<br/>    result = False<br/>    similarity = 0<br/>    for n in range(len(max_fitness)-1):<br/>        if max_fitness[n] == max_fitness[n+1]:<br/>            similarity += 1<br/>        else:<br/>            similarity = 0<br/>    if similarity == number_of_similarity-1:<br/>        result = True<br/>    return result</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8ccf" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">运行算法</h1><p id="b3c3" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">既然遗传算法所需的所有函数都准备好了，我们就可以开始优化过程了。以每代 20 个个体运行遗传算法；</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="add5" class="lk ll it lg b gy lm ln l lo lp"># Generations and fitness values will be written to this file<br/>Result_file = 'GA_Results.txt'</span><span id="d0d3" class="lk ll it lg b gy ob ln l lo lp"># Creating the First Generation<br/>def first_generation(pop):<br/>    fitness = [fitness_calculation(pop[x]) <br/>        for x in range(len(pop))]<br/>    sorted_fitness = sorted([[pop[x], fitness[x]]<br/>        for x in range(len(pop))], key=lambda x: x[1])<br/>    population = [sorted_fitness[x][0] <br/>        for x in range(len(sorted_fitness))]<br/>    fitness = [sorted_fitness[x][1] <br/>        for x in range(len(sorted_fitness))]<br/>    return {'Individuals': population, 'Fitness': sorted(fitness)}</span><span id="3bda" class="lk ll it lg b gy ob ln l lo lp">pop = population(20,8,1,0)<br/>gen = []<br/>gen.append(first_generation(pop))<br/>fitness_avg = np.array([sum(gen[0]['Fitness'])/<br/>                        len(gen[0]['Fitness'])])<br/>fitness_max = np.array([max(gen[0]['Fitness'])])<br/>res = open(Result_file, 'a')<br/>res.write('\n'+str(gen)+'\n')<br/>res.close()</span><span id="8ef2" class="lk ll it lg b gy ob ln l lo lp">finish = False<br/>while finish == False:<br/>    if max(fitness_max) &gt; 6:<br/>        break<br/>    if max(fitness_avg) &gt; 5:<br/>        break<br/>    if fitness_similarity_chech(fitness_max, 50) == True:<br/>        break<br/>    gen.append(next_generation(gen[-1],1,0))<br/>    fitness_avg = np.append(fitness_avg, sum(<br/>        gen[-1]['Fitness'])/len(gen[-1]['Fitness']))<br/>    fitness_max = np.append(fitness_max, max(gen[-1]['Fitness']))<br/>    res = open(Result_file, 'a')<br/>    res.write('\n'+str(gen[-1])+'\n')<br/>    res.close()</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="998f" class="lx ll it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><p id="0c0c" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">遗传算法可以用来解决多参数约束优化问题。像大多数优化算法一样，遗传算法可以直接从 sklearn 等一些库中实现，但从头创建算法提供了一个关于它如何工作的视角，并且该算法可以针对特定问题进行定制。</p><p id="24d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读，希望这篇文章对您有所帮助。</p><p id="92e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遗传算法是由约翰·h·霍兰德首先提出的，你可以在这里找到他的原著；</p><p id="2532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae oc" href="https://mitpress.mit.edu/books/adaptation-natural-and-artificial-systems" rel="noopener ugc nofollow" target="_blank">https://MIT press . MIT . edu/books/adaptation-natural-and-artificial-systems</a></p><p id="34ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你也想了解更多关于遗传算法的知识，你可以看看这两本书；</p><div class="od oe gp gr of og"><a href="https://www.springer.com/gp/book/9783319521558" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">遗传算法基础|奥利弗·克莱默|斯普林格</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这本书向读者介绍遗传算法，重点是使概念，算法，和…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.springer.com</p></div></div></div></a></div><p id="f814" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae oc" href="https://www.wiley.com/en-us/Practical+Genetic+Algorithms%2C+2nd+Edition-p-9780471455653" rel="noopener ugc nofollow" target="_blank">https://www . Wiley . com/en-us/Practical+Genetic+Algorithms % 2C+2nd+Edition-p-9780471455653</a></p></div></div>    
</body>
</html>