<html>
<head>
<title>Time-series Analysis with VAR &amp; VECM: Statistical approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 VAR &amp; VECM 的时间序列分析:统计方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vector-autoregressions-vector-error-correction-multivariate-model-a69daf6ab618?source=collection_archive---------0-----------------------#2019-11-13">https://towardsdatascience.com/vector-autoregressions-vector-error-correction-multivariate-model-a69daf6ab618?source=collection_archive---------0-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="685c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">股票市场数据的案例研究</h2><div class=""/><div class=""><h2 id="68e4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">时间序列随机数据建模</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bfd1ab1c3f04349577c392dbfaa7b6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aSHo7G6-Q3qCrVhu_VAGA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Image by author</figcaption></figure><p id="2a4e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae md" href="https://sarit-maitra.medium.com/membership" rel="noopener">https://sarit-maitra.medium.com/membership</a></p><p id="1f61" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> V </span> <strong class="lj jd"> ECTOR </strong>自回归(VAR)集成模型包含多个时间序列，是一种非常有用的预测工具。它可以被认为是自回归(ARIMA 的 AR 部分)模型的延伸。VAR 模型涉及多个独立变量，因此有多个方程。每个方程使用所有变量的滞后和可能的确定性趋势作为解释变量。VAR 的时间序列模型通常是基于将 VAR 应用于平稳序列，并对原始序列进行一阶差分，因此，总有可能丢失关于积分序列之间关系的信息。</p><p id="04b3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，对序列进行差分以使其稳定是一种解决方案，但代价是忽略了级别之间可能重要的(<em class="mn">“长期”</em>)关系。一个更好的解决方案是检验回归水平是否可信。)通常的做法是用 Johansen 的方法来检验是否存在协整。如果答案为“是”，则可以估计结合了级别和差异的<strong class="lj jd"><em class="mn">【VECM】</em></strong>向量误差校正模型，而不是级别中的 VAR。因此，我们将检查 VECM 是否能够超越我们现有系列的 VAR。</p><p id="fcb8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mn">这是我以前发表的</em> <a class="ae md" rel="noopener" target="_blank" href="/granger-causality-and-vector-auto-regressive-model-for-time-series-forecasting-3226a64889a6?source=friends_link&amp;sk=af3ee87ac5cac7dc52bcf551d9fcaa88"> <em class="mn">文章</em> </a> <em class="mn">的延伸。</em></p><h2 id="1b41" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">加载所有数据集(黄金、白银和原油)</h2><p id="aa6f" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">经过必要的清理和预处理(用以前的值填充丢失的值)，我们最终有了三个时间序列用于必要的分析。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/53e885534c2b4eed05b906759a308133.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*RGdcOwhw6vFqZIwR2JabaQ.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7e555812cc3aa49528629b69e5c605c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*lyUR77APjtjOsrAS-JLK1A.png"/></div></figure><p id="4708" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">快速测试是检查数据是否是随机的。随机数据在滞后图上不会显示出结构。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nn"><img src="../Images/d0d1528f2e3f3a6db02afb655096b67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfQYRCjXqTt1C7HRaz6KvQ.png"/></div></div></figure><p id="be81" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">时间序列图清楚地表明了序列之间的某种关系。滞后曲线的线性形状表明 ar 模型是更好的选择。我们也没有在数据中看到任何异常值。这里的数据显示线性模式，表明正自相关的存在。</p><blockquote class="no"><p id="eee6" class="np nq it bd nr ns nt nu nv nw nx mc dk translated">经济数据的时间序列通常是随机的，或者具有不稳定的趋势，这意味着数据有一个根单位</p></blockquote><pre class="ny nz oa ob oc od oe of og aw oh bi"><span id="25b9" class="mo mp it oe b gy oi oj l ok ol"># plots the autocorrelation plots at 75 lags<br/>for i in dataset:<br/> plot_acf(dataset[i], lags = 50)<br/> plt.title(‘ACF for %s’ % i) <br/> plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cdbd39f1f1d09eb5eb7c1e3e19429134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*Gx4qdnUhTUiVArmr9154kQ.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0e18583fd9828689e43c82ffd1d40b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*4T3qyiPuLV8brn_HVecKhw.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cdbd39f1f1d09eb5eb7c1e3e19429134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*Gx4qdnUhTUiVArmr9154kQ.png"/></div></figure><h2 id="4333" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">平稳性检查</h2><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="8082" class="mo mp it oe b gy oi oj l ok ol">def augmented_dickey_fuller_statistics(time_series):<br/>  result = adfuller(time_series.values)<br/>  print('ADF Statistic: %f' % result[0])<br/>  print('p-value: %f' % result[1])<br/>  print('Critical Values:')<br/>for key, value in result[4].items():<br/>  print('\t%s: %.3f' % (key, value))</span></pre><p id="2068" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过上面的函数，我们可以对所有列进行增广的 Dickey Fuller (ADF)检验，这清楚地表明原始序列是非平稳的并且包含单位根。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="c495" class="mo mp it oe b gy oi oj l ok ol">print('Augmented Dickey-Fuller Test: Gold Price Time Series')<br/>augmented_dickey_fuller_statistics(X_train['Gold'])<br/>print('Augmented Dickey-Fuller Test: Silver Price Time Series')<br/>augmented_dickey_fuller_statistics(X_train['Silver'])print('Augmente<br/>d Dickey-Fuller Test: Oil Price Time Series')<br/>augmented_dickey_fuller_statistics(X_train['Oil'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8cbb239b6a37d888039827b0b6ad06d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*xTDSdiLECy_h4cEmg9S-4Q.png"/></div></figure><h1 id="cd1f" class="oo mp it bd mq op oq or mt os ot ou mw ki ov kj mz kl ow km nc ko ox kp nf oy bi translated">向量自回归模型</h1><p id="268a" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">VAR 模型还可以用来分析使用格兰杰因果关系检验所涉及的变量之间的关系。格兰杰因果关系表明，如果 y1t 中的信息有助于改善 y2t 的预测，则变量 y1t 是变量 y2t 的因果关系。</p><p id="9adb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">格兰杰因果检验试图确定一个变量(x1)是否可以作为另一个变量(x2)的预测值，而另一个变量的过去值可能有帮助，也可能没有帮助。这意味着 x1 的解释超越了 x2 过去的值。这里有两个重要的假设-</p><ul class=""><li id="0137" class="oz pa it lj b lk ll ln lo lq pb lu pc ly pd mc pe pf pg ph bi translated">x1 和 x2 都是静止的</li><li id="e2e5" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc pe pf pg ph bi translated">它们的当前值和过去值之间存在线性关系。</li></ul><p id="7534" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这意味着，如果 x1 和 x2 是非平稳的，我们必须在检验格兰杰因果关系之前使它们平稳。</p><h2 id="0802" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">将序列拆分为训练和测试数据</h2><p id="4374" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我们将在 X_train 上拟合 VAR 模型，以预测接下来的 10 个观测值。这些预测将与测试数据(X_test)中的实际值进行比较。我们将使用多种预测准确性指标。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/c710273882ec38db3c0adaaa2282e3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*Rm3U850JPSH8mh5MKuDY4Q.png"/></div></figure><h2 id="be30" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">级数变换</h2><p id="6d75" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">差分变换是从时间序列中去除系统结构的一种简单方法。我们将通过从序列中的每个值减去前一个值来移除趋势，这是一阶差分。为了简单起见，我们将做一阶差分或季节差分。</p><p id="7e5e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们对 n 个时间序列进行积分排序，并且如果我们对差值和时间进行一次排序，我们将得到 0 个序列积分排序。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="aa96" class="mo mp it oe b gy oi oj l ok ol">X_train_log = np.log(X_train)<br/>X_train_log_diff =(X_train_log).diff().dropna()<br/>X_train_log_diff.describe()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/4e0b6b674cb1c7cf631ed30d54ec227f.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*3Q92hSf_hl1AeLabnjsGHA.png"/></div></figure><p id="7e96" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">查看该图，我们可以发现数据集看起来是标准化的</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/77e538df5b98f7e747c8ce6b76030e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fGR6eY2iVop-bFLjfoYQg.png"/></div></div></figure><h2 id="49f9" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">变换序列的自相关函数分析</h2><p id="1308" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">下面的函数绘制了每只股票的价格与前一个交易日的价格相差 75°的自相关图。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="efa7" class="mo mp it oe b gy oi oj l ok ol">fig, ax = plt.subplots(1,2, figsize=(10,5)) <br/>ax[0] = plot_acf(X_train_log_diff['Gold'], ax=ax[0])<br/>ax[1] = plot_pacf(X_train_log_diff['Gold'], ax=ax[1])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/c2ddf1c3f57e040f0ac87cfcc5fd3841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LA_BxBUBnmlM9FYLWPWZBA.png"/></div></div></figure><p id="1ef5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们已经展示了 ACF &amp; PACF 的变形金系列；同样，也可以绘制其他系列。</p><h2 id="7deb" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">ADF 测试转换系列</h2><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="d790" class="mo mp it oe b gy oi oj l ok ol">print('Augmented Dickey-Fuller Test: Gold Price Time Series')<br/>augmented_dickey_fuller_statistics(X_train_log_diff['Gold'])<br/>print('Augmented Dickey-Fuller Test: Silver Price Time Series')<br/>augmented_dickey_fuller_statistics(X_train_log_diff['Silver'])<br/>print('Augmented Dickey-Fuller Test: Oil Price Time Series')<br/>augmented_dickey_fuller_statistics(X_train_log_diff['Oil'])<br/>Augmented Dickey-Fuller Test on "Oil"    </span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/fa0c344e901ef84164e8e129ba9192c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*NNUaNtnRG3UjnPoALQORmw.png"/></div></figure><h1 id="8977" class="oo mp it bd mq op oq or mt os ot ou mw ki ov kj mz kl ow km nc ko ox kp nf oy bi translated">格兰杰因果检验</h1><p id="bd6e" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">格兰杰因果检验用于确定一个时间序列是否有助于预测另一个时间序列。如果通常通过对<em class="mn"> X </em>的滞后值(也包括<em class="mn"> Y </em>的滞后值)的一系列 t-检验和 f 检验可以表明，那些<em class="mn"> X </em>值提供了关于<em class="mn"> Y </em>的未来值的统计上有意义的信息，则称时间序列<em class="mn"> X </em>为格兰杰原因<em class="mn"> Y </em>。</p><h2 id="cf21" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">多变量分析</h2><p id="2dd7" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">这里，对于多变量格兰杰因果关系分析，通过对时间序列拟合一个 VAR 来进行。考虑下面是一个 d 维多元时间序列—</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/6c2647a665bb4750bf07a1def32ed582.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*Nkr5gFY1O7osivW48pdhBA.png"/></div></figure><p id="2237" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">格兰杰因果关系是通过拟合具有 L 个时滞的风险值模型来实现的，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/66cc6fc33ee3362a7f1f82c529202012.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*A3lwHiGnhP8K0EmBk8wnWQ.png"/></div></figure><p id="486c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中ε ( t)是白高斯随机向量，τ是每个τ的矩阵。一个时间序列 X i 称为另一个时间序列 Xi 的格兰杰原因，如果τ = 1，…，L 中至少有一个元素 A τ ( j，I)显著大于零。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="76a2" class="mo mp it oe b gy oi oj l ok ol">print(grangercausalitytests(X_train_log_diff[['Gold','Silver']], maxlag=15, addconst=True, verbose=True))<br/>print(grangercausalitytests(X_train_log_diff[['Gold','Oil']], maxlag=15, addconst=True, verbose=True))<br/>print(grangercausalitytests(X_train_log_diff[['Oil','Silver']], maxlag=15, addconst=True, verbose=True))</span></pre><p id="755e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面显示了黄金和石油的产量，这与滞后 4 之前的测试假设不同。</p><p id="bc80" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">VAR(p)过程的基本形式是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/ea3d1532631fdced2145da26a2dc2a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*M4QwjqzZ_us6lYU7vacPhw.png"/></div></figure><p id="180d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里 yt 表示一个向量中收集的一组变量，c 表示一个常数向量，a 是自回归系数矩阵，<em class="mn"> e </em> <em class="mn"> t </em>是白噪声。由于 a 的参数是未知的，我们必须估计这些参数。模型中的每个变量都有一个方程。每个变量的当前(时间<em class="mn"> t </em>)观察值取决于其自身的滞后值以及 VAR 中每个其他变量的滞后值。</p><h1 id="cd48" class="oo mp it bd mq op oq or mt os ot ou mw ki ov kj mz kl ow km nc ko ox kp nf oy bi translated">滞后订单选择</h1><p id="dc7f" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我已经通过 VAR (p)实现了 Akaike 的信息标准(AIC ),以确定滞后订单值。在 fit 函数中，我已经传递了最大数量的滞后和用于订单选择的订单标准。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="5ed8" class="mo mp it oe b gy oi oj l ok ol">#Initiate VAR model<br/>model = VAR(endog=X_train_log_diff)<br/>res = model.select_order(15)<br/>res.summary()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/48cdc2daf88f046160bd16a3860f3bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*wr_BqrXL6-SD5EEFXcYTqw.png"/></div></figure><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="acec" class="mo mp it oe b gy oi oj l ok ol">#Fit to a VAR model<br/>model_fit = model.fit(maxlags=3)<br/>#Print a summary of the model results<br/>model_fit.summary()</span></pre><h2 id="dc3c" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">预测 VAR 模型</h2><p id="25ce" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">预测是根据模型使用的训练数据生成的。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="4c2e" class="mo mp it oe b gy oi oj l ok ol"># Get the lag order<br/>lag_order = model_fit.k_ar<br/>print(lag_order)</span><span id="75bb" class="mo mp it oe b gy pw oj l ok ol"># Input data for forecasting<br/>input_data = X_train_log_diff.values[-lag_order:]<br/>print(input_data)</span><span id="7e22" class="mo mp it oe b gy pw oj l ok ol"># forecasting<br/>pred = model_fit.forecast(y=input_data, steps=nobs)<br/>pred = (pd.DataFrame(pred, index=X_test.index, columns=X_test.columns + '_pred'))<br/>print(pred)</span></pre><h2 id="ad9f" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">逆变换</h2><p id="dd2f" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">因此，要将其恢复到原始比例，我们需要对原始输入数据进行去差分。我们的数据是第一次对数转换，然后差分。因此，为了求逆，我们必须首先使用累积和去微分，然后使用指数。自然对数是 exp()的倒数。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="9697" class="mo mp it oe b gy oi oj l ok ol"># inverting transformation<br/>def invert_transformation(X_train, pred_df):<br/>  forecast = pred.copy()<br/>  columns = X_train.columns<br/>for col in columns:<br/>  forecast[str(col)+'_pred'] = X_train[col].iloc[-1] + forecast[str(col) +'_pred'].cumsum()<br/>  return forecast</span><span id="0d38" class="mo mp it oe b gy pw oj l ok ol">output = invert_transformation(X_train, pred)<br/>print(output)</span><span id="362b" class="mo mp it oe b gy pw oj l ok ol">output_original = np.exp(output)<br/>print(output_original)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/2ead1739e134cf79fa769e65333339a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*npdotWNj1GyjxzlC8y21sQ.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/52ed6e560dd608c1858c61ad0f1a3c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqdKqssURy8aJ91smN6pPA.png"/></div></div></figure><h2 id="9b54" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">VAR 预测评估</h2><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="03a6" class="mo mp it oe b gy oi oj l ok ol">#Calculate forecast bias<br/>forecast_errors = [X_test['Oil'][i]- output_original['Oil_pred'][i] for i in range(len(X_test['Oil']))]<br/>bias = sum(forecast_errors) * 1.0/len(X_test['Oil'])<br/>print('Bias: %f' % bias)</span><span id="5945" class="mo mp it oe b gy pw oj l ok ol">#Calculate mean absolute error<br/>mae = mean_absolute_error(X_test['Oil'],output_original['Oil_pred'])<br/>print('MAE: %f' % mae)</span><span id="7139" class="mo mp it oe b gy pw oj l ok ol">#Calculate mean squared error and root mean squared error<br/>mse = mean_squared_error(X_test['Oil'], output_original['Oil_pred'])<br/>print('MSE: %f' % mse)<br/>rmse = sqrt(mse)<br/>print('RMSE: %f' % rmse)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/9c3191ee15ba09b4dda585d8705ce1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*oygHFoXVeRn917YSEJS66w.png"/></div></figure><blockquote class="no"><p id="0fd0" class="np nq it bd nr ns qa qb qc qd qe mc dk translated">“众所周知，当数据相当持久时，动态回归模型的最小二乘参数估计在小样本中会表现出相当大的偏差”</p></blockquote><h1 id="b5a4" class="oo mp it bd mq op oq or mt os ot ou mw ki qf kj mz kl qg km nc ko qh kp nf oy bi translated">VECM 估计和分析</h1><p id="b6b2" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">由于存在非平稳但协整的数据形式，VECM 施加了额外的限制。它将协整限制信息应用到其规范中。在协整已知后，下一步的检验过程是通过使用误差修正方法来完成的。通过向量误差修正模型，我们可以解释长期和短期方程。我们需要确定协整关系的数量。VECM 相对于 VAR 的优势在于，从 VECM 表示得到的 VAR 具有更有效的系数估计。</p><h2 id="5c95" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">Johansen 协整</h2><p id="23ca" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">为了拟合向量误差修正模型，我们需要使用 VEC 秩检验来确定协整关系的数量。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="7ab2" class="mo mp it oe b gy oi oj l ok ol">vec_rank1 = vecm.select_coint_rank(X_train, det_order = 1, k_ar_diff = 1, method = 'trace', signif=0.01)<br/>print(vec_rank.summary())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/5a4aa61bb9395167c85f9a371b9011f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPcao96OXSy9yVDcXokn7g.png"/></div></div></figure><p id="ab8c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在第三列中找到λtrace 统计数据，以及相应的临界值。测试统计值 38.25 低于临界值(41.08)，因此至多一个协整合向量的零不能被拒绝。</p><p id="b969" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们采用另一种统计，最大特征值统计(λmax)。</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="4dcd" class="mo mp it oe b gy oi oj l ok ol">vec_rank2 = vecm.select_coint_rank(X_train, det_order = 1, k_ar_diff = 1, method = 'maxeig', signif=0.01)<br/>print(vec_rank2.summary())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qj"><img src="../Images/3a9d5b3525f3dc7746e75d2a247b451e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2DA4bpw_dPSIZwzeWqIow.png"/></div></div></figure><p id="d381" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">测试输出报告了λmax 统计信息的结果，该统计信息与 trace 统计信息相差不大；临界值(29.28)仍然高于测试统计值。</p><p id="04e6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们仍将继续估计 VECM，因为在缺乏协整的情况下，它对短期动态仍有价值。让我们用 9 个滞后、1 个协整关系和协整关系中的一个常数来估计价格的向量误差修正模型。我使用了<em class="mn">【慈利】</em><em class="mn">【ci】——协整关系</em>中的常数和<em class="mn">【李】——协整关系</em>中的线性趋势的组合</p><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="ce80" class="mo mp it oe b gy oi oj l ok ol">vecm = VECM(endog = X_train, k_ar_diff = 9, coint_rank = 3, deterministic = ‘ci’)<br/>vecm_fit = vecm.fit()<br/>vecm_fit.predict(steps=10)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/7d83198316d75bfb3f898f57732c57e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*hI84sg41a6TjVRDaxSCv2A.png"/></div></figure><pre class="ks kt ku kv gt od oe of og aw oh bi"><span id="8859" class="mo mp it oe b gy oi oj l ok ol">forecast, lower, upper = vecm_fit.predict(10, 0.05)<br/>print(“lower bounds of confidence intervals:”)<br/>print(lower.round(3))<br/>print(“\npoint forecasts:”)<br/>print(forecast.round(3))<br/>print(“\nupper bounds of confidence intervals:”)<br/>print(upper.round(3))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/ad41ab95dffeaf8b625d1f75f17b4881.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*ebTLqUExj2xvJsPQSB-73w.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/2fe02e8ea1d6be4ab64c29cee8c3ea1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4j3BmrsQBq8NyJ6hL3dPQ.png"/></div></div></figure><h2 id="208a" class="mo mp it bd mq mr ms dn mt mu mv dp mw lq mx my mz lu na nb nc ly nd ne nf iz bi translated">VECM 预测评估</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/28eabb49a4a8ab4c378366a27e5558bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4uqLgPQJBHjMQ8yNF3tIA.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/f542f118a62a6fd18c5d1d55ee55b6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LjDRx29Q4j6j9uiSQ7Ljg.png"/></div></div></figure><p id="b078" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然我们有迹象表明，VAR 将是我们的价格预测数据集的最佳选择；然而，我们出于实验和说明目的展示了 VECM。这是一个解释 VAR 的简单程序。然而，如果我们能够看到一个变量的冲击如何在随后的时期影响其他变量，也可以将脉冲响应分析和方差分解等其他程序引入实验。</p><h1 id="23c7" class="oo mp it bd mq op oq or mt os ot ou mw ki ov kj mz kl ow km nc ko ox kp nf oy bi translated">关键要点</h1><p id="fe40" class="pw-post-body-paragraph lh li it lj b lk ng kd lm ln nh kg lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">经济数据的时间序列通常是随机的，或者具有不稳定的趋势，这意味着数据有一个根单位。能够用数据来估计一个模型-</p><p id="6a26" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">VAR-的步骤</p><ol class=""><li id="ad70" class="oz pa it lj b lk ll ln lo lq pb lu pc ly pd mc qp pf pg ph bi translated">测试数据的平稳性和整合程度</li><li id="680c" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">滞后长度的确定</li><li id="1f37" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">检验格兰杰因果关系</li><li id="b0e2" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">风险值估计</li><li id="eee0" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">方差分解</li></ol><p id="6f1c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">VECM 的预测步骤-</p><ol class=""><li id="a7d6" class="oz pa it lj b lk ll ln lo lq pb lu pc ly pd mc qp pf pg ph bi translated">滞后长度的确定</li><li id="5fd4" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">检验格兰杰因果关系</li><li id="5dfd" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">协整度检验</li><li id="e076" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">向量误差修正模型估计</li><li id="0cdf" class="oz pa it lj b lk pi ln pj lq pk lu pl ly pm mc qp pf pg ph bi translated">方差分解</li></ol><p id="55f1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">我这里可以到达</strong><a class="ae md" href="https://www.linkedin.com/in/saritmaitra/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd"/></a>。</p><p id="1d7f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mn">注意:此处描述的程序是实验性的，应谨慎使用。所有此类使用风险自负。</em></p><p id="64e7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mn">参考文献:</em></p><p id="807a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mn"> (1)饶，B. (2007)。协整:应用经济学家斯普林格。</em></p><p id="7526" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mn"> (2) Ashley，r . a .&amp;Verbrugge，R. J. (2009)。差异还是不差异:向量自回归模型中推断的蒙特卡罗研究。国际数据分析技术和策略杂志，1(3)，242–274。</em></p><p id="f23b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">(3)吕特克波尔，H. (2011 年)。向量自回归模型。《国际统计科学百科全书》(第 1645-1647 页)。施普林格柏林海德堡。</p><p id="767d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mn"> (4)郭春英(2016)。向量误差修正模型在预测股价上比其他模型表现更好吗？剩余收益评估理论的一个应用。经济模型，52，772–789。</em></p></div></div>    
</body>
</html>