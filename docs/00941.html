<html>
<head>
<title>Learning from Graph data using Keras and Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Keras 和 Tensorflow 从图形数据中学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-from-graph-data-using-keras-and-tensorflow-5b54e3ddffbf?source=collection_archive---------12-----------------------#2019-02-12">https://towardsdatascience.com/learning-from-graph-data-using-keras-and-tensorflow-5b54e3ddffbf?source=collection_archive---------12-----------------------#2019-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fe4b41800dda7eb591e594f1a0c6a6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwAHRcw6QZ_SCxNWMi0JHA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Cora Data set Citation Graph</figcaption></figure><h1 id="e6a8" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">动机:</h1><p id="10d2" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在引用网络、社交网络(关注者图、朋友网络……)、生物网络或电信等现实应用中，有许多数据可以用图表的形式表示。<br/>使用图提取的特征可以通过依赖相邻节点之间的信息流来提高预测模型的性能。然而，表示图形数据并不简单，尤其是如果我们不打算实现手工制作的特性，因为大多数 ML 模型期望固定大小或线性的输入，而图形数据并非如此。<br/>在本帖中，我们将探索一些处理一般图形的方法，以便根据直接从数据中学习到的图形表示进行节点分类。</p><h1 id="c49e" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">数据集:</h1><p id="b56d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae ly" href="https://linqs-data.soe.ucsc.edu/public/lbc/cora.tgz" rel="noopener ugc nofollow" target="_blank"> Cora </a>引文网络数据集将作为贯穿本文的实现和实验的基础。每个节点代表一篇科学论文，节点之间的边代表两篇论文之间的引用关系。<br/>每个节点由一组二元特征(单词袋)以及一组将它与其他节点链接起来的边来表示。<br/>数据集具有被分类为七个类之一的<strong class="lc ir"> <em class="lz"> 2708 </em> </strong>节点。网络有<strong class="lc ir"> <em class="lz"> 5429 </em> </strong>个链接。每个节点也由指示相应单词存在的二进制单词特征来表示。总的来说，每个节点有<strong class="lc ir"> <em class="lz"> 1433 </em> </strong>个二元(稀疏)特征。下面我们<em class="lz">只</em>使用<strong class="lc ir"> <em class="lz"> 140 </em> </strong>样本进行训练，其余用于验证/测试。</p><h1 id="57a3" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">问题设置:</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a9c66efa5e1714d2a0ac918151eb8490.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*klF4yon9ZpP6oZ0kvO86QA.png"/></div></figure><p id="7174" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated"><strong class="lc ir">问题</strong>:在训练样本很少的情况下，给图中的节点分配类别标签。<br/> <strong class="lc ir">直觉</strong> / <strong class="lc ir">假设</strong>:图中距离较近的节点更有可能有相似的标签。<br/> <strong class="lc ir">解决方案</strong>:想办法从图中提取特征，帮助分类新节点。</p><h1 id="a112" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">提议的方法:</h1><p id="c16a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir">基线模型:</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/335b9c67a50c5cf62864a21fb0cdd3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*nlDeQPW2ABhtwjoSI2dvWQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Simple Baseline Model</figcaption></figure><p id="6a21" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">我们首先用最简单的模型进行实验，该模型学习仅使用二元特征并丢弃所有图信息来预测节点类。<br/>该模型是一个全连接的神经网络，将二元特征作为输入，输出每个节点的分类概率。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="6b21" class="mn kd iq bd ke mo mp dn ki mq mr dp km ll ms mt kq lp mu mv ku lt mw mx ky my bi translated"><strong class="ak">基线模型准确率:<em class="mz"> 53.28% </em> </strong></h2><p id="1938" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这是初始精度，我们将通过添加基于图形的功能来提高它。</p><p id="55ca" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated"><strong class="lc ir">添加图形特征:</strong></p><p id="f3dc" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">一种自动学习图形特征的方法是将每个节点嵌入到向量中，方法是在预测两个输入节点之间最短路径长度倒数的辅助任务上训练网络，如下图和代码片段所示:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/fe017d3fcee114a97354f19c11a5c784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*PP_y_YhkKFYpzkj7szhnaw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Learning an embedding vector for each node</figcaption></figure><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b5fd" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">下一步是使用预训练的节点嵌入作为分类模型的输入。我们还添加了一个额外的输入，它是使用学习嵌入向量的距离的相邻节点的平均二进制特征。</p><p id="40c8" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">下图描述了生成的分类网络:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/2639f5524ed471c86265d02fe1237db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xc99u2ejelSXNPKPmh-Nrw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Using pretrained embeddings to do node classification</figcaption></figure><h2 id="5df9" class="mn kd iq bd ke mo mp dn ki mq mr dp km ll ms mt kq lp mu mv ku lt mw mx ky my bi translated"><strong class="ak">图嵌入分类模型准确率:<em class="mz">73.06%</em>T3】</strong></h2><p id="d3d7" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们可以看到，与基线模型相比，将学习到的图特征作为输入添加到分类模型有助于显著提高分类精度，从<strong class="lc ir"> <em class="lz"> 53.28% </em> </strong> <em class="lz">到</em> <strong class="lc ir"> <em class="lz"> 73.06% </em> </strong>😄。</p><p id="3e01" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated"><strong class="lc ir">改进图形特征学习:</strong></p><p id="cbfe" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">我们可以通过进一步推动预训练并在节点嵌入网络中使用二进制特征，然后除了节点嵌入向量之外，再使用来自二进制特征的预训练权重，来进一步改进先前的模型。这导致模型依赖于从图结构中学习的二进制特征的更有用的表示。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/587d5b8e968695ed5e588b014335e7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEy9ua6jTBdkFGrrfvxpiA.png"/></div></div></figure><h2 id="b102" class="mn kd iq bd ke mo mp dn ki mq mr dp km ll ms mt kq lp mu mv ku lt mw mx ky my bi translated">改进的图嵌入分类模型准确率:<em class="mz"> 76.35 </em> %</h2><p id="c6a3" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">与以前的方法相比，这种额外的改进增加了几个百分点的准确性。</p><h1 id="20fe" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论:</h1><p id="ffcd" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在这篇文章中，我们看到，我们可以从图结构数据中学习有用的表示，然后使用这些表示来提高节点分类模型的泛化性能，从<strong class="lc ir"><em class="lz"/></strong><em class="lz">的 53.28%提高到</em> <strong class="lc ir"> <em class="lz"> </em>的 76.35% </strong>😎。</p><p id="c9c6" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">复制结果的代码可从这里获得:<a class="ae ly" href="https://github.com/CVxTz/graph_classification" rel="noopener ugc nofollow" target="_blank">https://github.com/CVxTz/graph_classification</a></p><p id="59dd" class="pw-post-body-paragraph la lb iq lc b ld mf lf lg lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx ij bi translated">如果您有任何建议或者您需要一些在您的机器上运行代码的指示，请随意评论😉</p></div></div>    
</body>
</html>