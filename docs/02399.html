<html>
<head>
<title>Market Basket Analysis — Multiple Support Frequent Item set Mining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">购物篮分析——多支持频繁项目集挖掘</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/market-basket-analysis-multiple-support-frequent-item-set-mining-584a311cae66?source=collection_archive---------19-----------------------#2019-04-19">https://towardsdatascience.com/market-basket-analysis-multiple-support-frequent-item-set-mining-584a311cae66?source=collection_archive---------19-----------------------#2019-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5523" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对缺省 MSApriori 算法的改进。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/46f55c22443ec6ce5a0d3237854f8ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TM7haXWdKMoZqwz1L00bZg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Pic credit: Upgrad</figcaption></figure><h1 id="7464" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">简介:</h1><p id="a78e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">从交易数据库(购物篮)中生成关联规则的问题是许多零售商感兴趣的。关联规则的形式是𝑋 → 𝑌，其中 x，y 是 I(所有产品(或项目)的集合)和𝑋 ∩ 𝑌 = ∅.的子集</p><p id="d92e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">可以将上述关联规则的含义理解为，如果顾客购买了集合 X 中的物品，那么他可能购买集合 y 中的物品。关联规则的一些众所周知的例子可以是{ Milk }--&gt; {Bread } 、{ Milk }--&gt; { Bread，Eggs} 、{ Bread，Butter }--&gt; { Jam }和幽默的{ Diapers }--&gt; { Beer }。请注意，关联规则是不可交换的，即𝑋 → 𝑌不等于𝑌 → 𝑋.</p><p id="8a09" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为给定的交易数据库(市场篮)寻找关联规则的问题定义如下:</p><p id="5588" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">a.给定一个大小为 z 的事务数据库，其中有 n 个不同的项目和一个输入支持度和置信度，找出满足给定支持度和置信度约束的所有规则𝑋 → 𝑌。</p><p id="a375" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">b.支持度是一个阈值，该阈值将确定 X 中的项目是否足够频繁以被考虑用于关联规则生成。更具体地说，如果{X}。count / Z &gt;= support，那么 X 被认为是一个频繁项集。</p><p id="fa92" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">c.置信度是决定购买 y 的条件概率的阈值。更具体地说，如果{𝑋⋃𝑌}.count / {X}。计数&gt; =置信度，则𝑋 → 𝑌被视为有效的关联规则。</p><p id="046c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">假设零售商销售了“N”种不同的商品/产品，那么计数和生成关联规则的强力方法的复杂度为 O(N！).</p><p id="fcc2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Apriori 算法是对蛮力算法的改进，它基于这样的观察:只有当 X 的所有真子集都是频繁项目集时，项目集 X 才是频繁项目集。这将减少为生成所有可能的关联规则而需要探索的状态/规则的数量。Apriori 算法根据这一原理工作，分两步执行</p><p id="a997" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">a.在大小为 1，2，3…k 的事务数据库中查找所有频繁项集。</p><p id="2160" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">b.从频繁项目集 2，3，4…k 中生成所有有效的关联规则。</p><p id="d003" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">c.如果不能再生成 k + 1 大小的频繁项集，则停止。</p><p id="6898" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Apriori 算法至少需要对事务数据库进行“k”次扫描。</p><h1 id="a798" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">MSApriori:</h1><p id="8ce8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">MSApriori 代表多重支持 Apriori，它是 Apriori 算法在现实生活场景中的一个更受约束的定义。Apriori 算法只考虑交易中所有项目的一个支持值，而不管项目是频繁销售的项目(如杂货)还是不太频繁销售的项目(高价项目，如家居装饰)。因此，要为经常/很少售出的商品建立称重方案，每件商品都有单独的支撑。MSApriori 算法的问题定义修改如下:</p><p id="4620" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">a.给定一个交易数据库和每个项目和置信度的不同最小输入支持(MIS ),找出满足给定支持和置信度约束的所有规则𝑋 → 𝑌。</p><p id="e9a2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">b.支持度是一个阈值，该阈值将确定 X 中的项目是否足够频繁以被考虑用于关联规则生成。由于 MSApriori 中对不同的项目有不同的支持，任何满足其集合中项目的最小 MIS 的项目集合都被认为是频繁的。更具体地说，如果</p><p id="2e9d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">a.|X| = 1，</p><ul class=""><li id="43fd" class="mo mp iq lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">{X}。count/n &gt; = miss(X)，那么 X 被认为是一个频繁项集。</li></ul><p id="bfb7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">b.|X| &gt;= 1，</p><ul class=""><li id="2342" class="mo mp iq lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">{X}。count / n &gt;= MIN (MIS(X1)，MIS(X2)，MIS(X3)…MIS(Xk))；Xi ∈ X，i=1 到 k</li></ul><p id="ecbd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">c.为了阻止非常频繁和不太频繁的项目一起出现在任何频繁项目集合中，在候选项目集合 X 上施加支持差异约束φ</p><p id="54e4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">a.|X| &gt;= 1，</p><ul class=""><li id="747a" class="mo mp iq lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">MAX(Supp(X1)，Supp(X2)…Supp(Xk))–MIN(Supp(X1)，Supp(X2) … Supp(Xk)) &lt;= Φ</li></ul><p id="0ae0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">The task of assigning MIS to items must be done in a meticulous manner. For highly moving items such as daily groceries, a high value of MIS is desired. For not so frequently sold items such as high end electronics, a less value of MIS is desired. One such assignment of MIS can be done using the following approximation.</p><p id="29ca" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">MIS (item) = δ * Supp (item); δ ∈ [0, 1]</p><p id="ec47" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">The above assignment is discussed in <a class="ae mx" href="https://www.cs.uic.edu/~liub/WebMiningBook.html" rel="noopener ugc nofollow" target="_blank">刘兵等人的网络挖掘</a>。求解 MSApriori 的算法也是刘兵在上面的书里提出的，姑且称之为默认的 MSApriori 算法。默认的 MSApriori 算法对每个候选项集 Ck 扫描事务数据库；k &gt; =2 来计算频繁项集 Fk。</p><p id="075c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">考虑到数据库中有“Z”个总事务和“N”个唯一项，默认的 MSApriori 算法需要计算对所有 C2 的支持；如果每个项目的 MIS 按上述等式定义，C2 将有 N*(N-1)/2 个项目集。</p><p id="b8e3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">总时间复杂度= N*(N-1)/2 * Z ~ O(n3)。</p><p id="68b2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">类似地，C3、C4… Ck 也会有相应的复杂性，这是基于项集的大小乘以数据库中的事务数量。</p><h1 id="ba02" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">对 MSApriori 的改进建议:</h1><p id="ba27" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对缺省 MSApriori 提出的改进是使用一种前瞻策略，在事务数据库扫描的第一遍中计算每个 Ck 的支持，将它们存储在哈希表(Hk)中，并在需要时检索它们。在事务数据库扫描的第一遍中，对于长度为“L”的每个事务，每个 Ck (k &lt;= L) is generated locally and the count of its support increased in Hk. So, for C2, the proposed modification would work as follows,</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="224c" class="nd kw iq mz b gy ne nf l ng nh">/* modified MSApriori Algorithm form Bing et al */</span><span id="b1ae" class="nd kw iq mz b gy ni nf l ng nh">Modificaiton-1: init-pass()</span><span id="f6eb" class="nd kw iq mz b gy ni nf l ng nh">For each item(i) in Transaction T:</span><span id="7f3c" class="nd kw iq mz b gy ni nf l ng nh">a. Compute/increment the support of item(i)</span><span id="8737" class="nd kw iq mz b gy ni nf l ng nh">b. For each item(j) in Transaction T: // (j&gt;i)<br/>       Compute the hashcode of itemset(i,j)<br/>       Retrieve the support of itemset(i,j) from the hash table(H2)<br/>       Initialize/Increment the support of itemset(i,j).</span><span id="f019" class="nd kw iq mz b gy ni nf l ng nh">Modificaiton-2: CandidateGen2() //Candidate generation function for 2-itemset</span><span id="18f0" class="nd kw iq mz b gy ni nf l ng nh">For each item(i) in list L/C2:<br/>    For each item(j) in list L: // (j&gt;i)<br/>        Compute the hashcode of itemset(i,j)<br/>        Retrieve the support of itemset(i,j) from the hash table(H2)<br/>        If support &gt; MIS(item(i)) // and other constrains like Φ<br/>            Return itemset(i,j) into F2.</span></pre><p id="47b5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">NOTE: CandidateGen2() directly returns the items into F2, no need for scanning the transaction database again!</p><p id="5c0c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">In the Modificaiton-1, an extra sub-loop is added for each transaction to compute the support for 2-itemsets, assuming the average length of transaction is ‘L’ then this step would add further processing time of L*(L-1)/2 for each transaction in the database. Assuming, there are ‘Z’ transactions in the database, the time required to complete the init-pass() is</p><p id="2bee" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Time complexity (init-pass) = L*(L-1)/2 * Z</p><p id="ab93" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">~= c * Z ~ O(Z) //for all practical reasons L &lt;&lt; Z</p><p id="57eb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">In the Modificaiton-2, I am adding an extra step for accessing the hash table (H2) which can be done in constant time (TH) in most library implementations. The time required to complete CandidateGen2() is given as</p><p id="0d41" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Time complexity = N*(N-1)/2*TH ~ O(n2).</p><p id="fe9e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Combining both modifications, total time complexity = O(Z) + O(n2) &lt; O(n3)! (from the default algorithm).</p><h1 id="3b1c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Verification of the result:</h1><p id="e00c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">The default MSApirioi algorithm is implemented by <a class="ae mx" href="http://www.philippe-fournier-viger.com/spmf/" rel="noopener ugc nofollow" target="_blank"> Phillipe et al in the 开源 java data mining library SPMF </a>)。我已经<a class="ae mx" href="https://github.com/cs17emds11029/MSApiori" rel="noopener ugc nofollow" target="_blank">用我在 MSAprori _ H.java 程序中提出的修改</a>修改了 SPMF 库中的默认 MSApriori 算法。MSApriori 和 MSApriori_H 的执行结果如下:</p><p id="9e23" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">考虑的数据集:retail1.txt</p><p id="28d1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">数据集中不同项目的数量:N = 2603。</p><p id="d45c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">数据集中的事务数量:Z = 541909。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/af384aecb76f1e373116c55a90366309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYSl-HsWZyHXU6lLAL-jzw.jpeg"/></div></div></figure><p id="6f22" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">关于此算法的哈希函数要求的注释。理想情况下，我们需要一个散列函数，它能为一组整数提供唯一的散列值，而不考虑给定集合中整数的顺序。生成这样一个散列函数肯定不是一件简单的任务，所以我在实现中将散列值放宽为一个 Java 对象。我选择了一个要在 MSApriori_H.java 中实现的 BitSet 对象。</p><p id="0b00" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">MSApriori_H.java 中的哈希函数:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="1a57" class="nd kw iq mz b gy ne nf l ng nh">/* Input k-item set in Integer[] items */</span><span id="4521" class="nd kw iq mz b gy ni nf l ng nh">BitSet hashcode = new BitSet(Integer.MAX_VALUE);</span><span id="15d4" class="nd kw iq mz b gy ni nf l ng nh">for(int i=0; i&lt;items.length; i++) {hashcode.set(items[i])};</span><span id="6c12" class="nd kw iq mz b gy ni nf l ng nh">return hashcode;</span></pre></div></div>    
</body>
</html>