<html>
<head>
<title>Introduction to TWO approaches of Content-based Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于内容推荐系统的两种方法介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-two-approaches-of-content-based-recommendation-system-fc797460c18c?source=collection_archive---------5-----------------------#2019-02-03">https://towardsdatascience.com/introduction-to-two-approaches-of-content-based-recommendation-system-fc797460c18c?source=collection_archive---------5-----------------------#2019-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决困惑的完整指南</h2></div><p id="3b45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于内容的过滤是构建推荐系统的常用方法之一。当我试图做一些研究来理解细节时，有趣的是看到有<strong class="kk iu"> 2 种方法</strong>声称是“基于内容的”。下面我将分享我的发现，如果你曾经对这个定义感到困惑，希望它能节省你的研究时间。</p><p id="aace" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将涵盖:</p><ol class=""><li id="5019" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">方法 1 —仅分析内容描述</li><li id="a115" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">方法 2——从用户评价的内容建立用户简档和项目简档</li><li id="835f" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">两种方法的利弊</li></ol><p id="3a07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将重点解释这两种方法的主要区别，可能不会详细讨论编码。请访问这里的<a class="ae ls" href="https://github.com/youonf/recommendation_system/tree/master/content_based_filtering" rel="noopener ugc nofollow" target="_blank">库</a>获取各自的 Jupyter 笔记本，你会发现这两种方法的 Python 实现！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/77685eb58f39717b444cfcdb81b30c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jrCf8btV-nHE2Tnr"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Content-based recommendation system (approach 2) simply analyses what you love — Photo Credit: <a class="ae ls" href="https://unsplash.com/@ninjason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Leung</a></figcaption></figure><h1 id="0028" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">方法 1:只分析内容的描述</h1><p id="d6f8" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">根据我的理解，方法 1 类似于<a class="ae ls" href="https://en.wikipedia.org/wiki/Item-item_collaborative_filtering" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">基于项目的协同过滤</strong> </a>。简而言之，系统会推荐任何与你之前喜欢的某个物品相似的东西。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ng"><img src="../Images/4c3d575a6ebba0694ebcc77fab182a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/0*RvaBE9dpX8bB8R3b"/></div></div></figure><p id="c3dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在建模阶段，系统首先找到所有项目对之间的相似性，然后在推荐阶段使用与用户已评分项目最相似的项目来生成推荐列表。</p><p id="7ac3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果有人观看《明日边缘》，系统可能会基于相似性推荐 Looper。</p><blockquote class="nh"><p id="efc7" class="ni nj it bd nk nl nm nn no np nq ld dk translated">H <!-- -->如何找到物品之间的相似性？</p></blockquote><p id="3cf7" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">通常相似性将从项目的<strong class="kk iu">描述</strong>中导出，并且将引入<strong class="kk iu"> TF-IDF </strong>的概念。那么每个项目将由一个<strong class="kk iu"> TF-IDF 向量</strong>来表示。</p><h2 id="5da4" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated"><strong class="ak">词频-逆文档频率(TF-IDF) </strong></h2><p id="8847" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated"><strong class="kk iu"> TF-IDF </strong>属于自然语言处理(NLP)的子领域。它在信息检索中用于特征提取目的。简而言之，你以某种方式计算每个单词在文档中的出现次数，衡量每个单词的重要性，并计算该文档的分数。</p><h2 id="7e43" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated"><strong class="ak">词频</strong></h2><p id="0a0a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">当前文档中单词占文档总字数的频率。它表示该单词在文档中出现的次数，当出现的次数越多，权重就越高，所以用它除以文档长度进行归一化。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/3ebddfbdb6ebd41419710d668d113d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*mKm8D8f8e5KEZVBQ"/></div></figure><h2 id="e557" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">逆文档频率</h2><p id="c027" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">文档总数与包含该单词的文档的出现频率之比。它表示单词的稀有性，因为文档中出现的单词越少，IDF 就越大。这有助于给文档中的罕见术语更高的分数。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f61d1aa8588b562fd5528ff1a1e10aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/0*OfOjmgkYDXYCZroo"/></div></figure><p id="5165" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，TF-IDF 是用于评估一个单词对文档语料库中的文档有多重要的度量。单词的重要性与单词在文档中出现的次数成比例地增加，但是被单词在语料库中的频率抵消。</p><p id="9465" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于方法<strong class="kk iu">严重依赖描述</strong>来区分每个项目，描述应深入到产品细节，即标题、摘要、标语、流派，以便提供更多关于项目的信息。</p><h2 id="9776" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">TF-IDF 载体</h2><p id="a1d4" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">在为标签定义了 TF-IDF 值之后，我们就可以为每个项目创建关键字向量了。下面每一行代表一个项目的关键字向量。关于 TF-IDF 的详细计算，你可以参考这里的一篇<a class="ae ls" href="https://www.analyticsvidhya.com/blog/2015/08/beginners-guide-learn-content-based-recommender-systems/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ok"><img src="../Images/2a758e6c4a6a17160241ff81016d5c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zVjZiNdfoNp079GELcE1A.png"/></div></div></figure><h2 id="8dc9" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">比较项目 TF-IDF 向量的相似性</h2><p id="1b66" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">为了计算项目向量的相似程度，我们可以使用各种方法，例如:</p><ul class=""><li id="6aa4" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld ol lk ll lm bi translated">余弦相似性</li><li id="aeae" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated">欧几里得距离</li><li id="bb85" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated">皮森相关</li></ul><p id="4345" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么推荐器将基于最相似的项目给出推荐。</p><p id="d5a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我试着实现了这三种方法，我发现在推荐的项目上没有明显的区别。你可以从这个<a class="ae ls" href="https://github.com/youonf/recommendation_system/blob/master/content_based_filtering/content_based_recommender_approach1.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>中找到我的全部代码。范例数据集——图书穿越数据集可点击<a class="ae ls" href="http://www2.informatik.uni-freiburg.de/~cziegler/BX/" rel="noopener ugc nofollow" target="_blank">此处</a>下载。</p><h1 id="e916" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">方法 2:从用户评价的内容建立用户简档和项目简档</h1><p id="d554" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">这种方法类似于维基百科<a class="ae ls" href="https://en.wikipedia.org/wiki/Recommender_system#Content-based_filtering" rel="noopener ugc nofollow" target="_blank">中的定义。</a></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi om"><img src="../Images/f8ed13f76e74fa50fdc242f7c804871a.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*4ap6ceRDbGCC-SbR"/></div></figure><p id="4e97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法 2 利用来自用户已经交互的项目的<strong class="kk iu">描述或属性</strong>来推荐相似的项目。它仅依赖于用户<strong class="kk iu">先前的选择</strong>，使得该方法对于<strong class="kk iu">避免冷启动问题</strong>具有鲁棒性。对于文本项目，如文章、新闻和书籍，很容易使用文章<strong class="kk iu">类别</strong>或<strong class="kk iu">原始文本</strong>来构建<strong class="kk iu">项目简档</strong>和<strong class="kk iu">用户简档</strong>。</p><p id="94a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我观看一部特定类型的电影，我将被推荐该特定类型的电影。片名、上映年份、导演、演员也有助于识别类似的电影内容。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi on"><img src="../Images/78a9c04d87543af34df4b50e756941b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*iJWVB_nx04Mx6Yp6EK5hSQ.png"/></div></figure><p id="56c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种方法中，产品的内容已经基于<strong class="kk iu">用户偏好(用户简档)</strong>被<strong class="kk iu">分级</strong>，而项目的类型是一个<strong class="kk iu">隐含特征</strong>，它将用于建立<strong class="kk iu">项目简档</strong>。然后通过使用两个简档来预测<strong class="kk iu">项目分数</strong>，并且可以进行推荐。与方法 1 相似，TF-IDF 技术也将用于该方法。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/64ef1d8321ce58eb589abd05e19993f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*prq2ZmEO0Lov_m9FAH871Q.png"/></div></figure><blockquote class="nh"><p id="2d61" class="ni nj it bd nk nl op oq or os ot ld dk translated">如何建立用户档案和物品档案？</p></blockquote><p id="9a88" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">通常<code class="fe ou ov ow ox b">rating table</code>(用户评分)<code class="fe ou ov ow ox b">item profile</code>(书籍类型)是我们仅有的资料。</p><ul class=""><li id="e02f" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld ol lk ll lm bi translated"><code class="fe ou ov ow ox b">rating table</code>:用户与图书的关系</li><li id="e70d" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated"><code class="fe ou ov ow ox b">item profile</code>:属性与账簿的关系</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oy"><img src="../Images/a6bbdd4800935554ca0887ebd829470f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U9P4EzJJnBaGJc6R"/></div></div></figure><p id="2ffb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将创建<code class="fe ou ov ow ox b">user profile</code>,这样我们就可以了解用户实际上更喜欢什么属性。</p><ul class=""><li id="5c9e" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld ol lk ll lm bi translated"><code class="fe ou ov ow ox b">user profile</code>:用户-属性关系</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oz"><img src="../Images/1988a13442a79e02d244127bfc978118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_aP-MnytRoBNsuZ3"/></div></div></figure><p id="3179" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，使用<code class="fe ou ov ow ox b">user profile</code>，我们可以根据他/她的<code class="fe ou ov ow ox b">user profile</code>和<code class="fe ou ov ow ox b">item profile</code>预测特定用户的所有项目得分。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pa"><img src="../Images/9e232b3e3a5fcf5bc300b984795cdc17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uDZ-SmClXifyknS5"/></div></div></figure><p id="b79e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以从这本<a class="ae ls" href="https://github.com/youonf/recommendation_system/blob/master/content_based_filtering/content_based_recommender_approach2_v2.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>中找到我的方法 2 的完整代码。虽然这种方法需要像书籍流派这样的信息，并且它不在图书交叉数据集中，但报废是使用<a class="ae ls" href="https://developers.google.com/books/docs/v1/using" rel="noopener ugc nofollow" target="_blank">谷歌图书 API </a>来检索附加信息。报废信息可以在这里<a class="ae ls" href="https://github.com/youonf/recommendation_system/blob/master/content_based_filtering/books_n_description.csv" rel="noopener ugc nofollow" target="_blank">找到。</a></p><h1 id="16b1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">两种方法的利弊</h1><h2 id="237d" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">方法 1</h2><h2 id="4f17" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">优点:</h2><ul class=""><li id="2902" class="le lf it kk b kl nb ko nc kr pb kv pc kz pd ld ol lk ll lm bi translated">与协同过滤不同，如果项目有足够的描述，我们就避免了“新项目问题”。</li><li id="8551" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated">内容表示是多种多样的，它们提供了使用不同方法的选择，如:文本处理技术、语义信息的使用、推理等</li><li id="c12c" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated">很容易建立一个更透明的系统:我们使用相同的内容来解释推荐。</li></ul><h2 id="e7cf" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">缺点:</h2><ul class=""><li id="b30d" class="le lf it kk b kl nb ko nc kr pb kv pc kz pd ld ol lk ll lm bi translated">基于内容的 RecSys 趋向于过度专业化:他们会推荐与已经消费过的商品相似的商品，并倾向于创建一个“<a class="ae ls" href="https://www.ted.com/talks/eli_pariser_beware_online_filter_bubbles?language=en" rel="noopener ugc nofollow" target="_blank">过滤气泡</a>”。</li></ul><h2 id="f7f1" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">方法 2</h2><h2 id="7a07" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">赞成的意见</h2><ul class=""><li id="cc93" class="le lf it kk b kl nb ko nc kr pb kv pc kz pd ld ol lk ll lm bi translated"><strong class="kk iu">用户独立性</strong>:协同过滤需要其他用户的评分来发现用户之间的相似性，然后给出建议。相反，基于内容的方法只需要分析项目和用户简档来进行推荐。</li><li id="4f2e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated"><strong class="kk iu">透明</strong>:协作式方法给你推荐是因为一些未知的用户和你有相同的品味，但是基于内容的方法可以告诉你他们是基于什么特征给你推荐的。</li><li id="58ff" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated"><strong class="kk iu">无冷启动</strong>:与协同过滤相反，新项目可以在被大量用户评级之前被建议。</li></ul><h2 id="a476" class="nw mk it bd ml nx ny dn mp nz oa dp mt kr ob oc mv kv od oe mx kz of og mz oh bi translated">骗局</h2><ul class=""><li id="4d2b" class="le lf it kk b kl nb ko nc kr pb kv pc kz pd ld ol lk ll lm bi translated"><strong class="kk iu">有限内容分析</strong>:如果内容没有包含足够的信息来精确区分项目，推荐将不会精确到最后。</li><li id="0b59" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated"><strong class="kk iu">过度专门化</strong>:基于内容的方法提供了有限程度的新颖性，因为它必须匹配简档和项目的特征。一个完全完美的基于内容的过滤可能没有什么“惊喜”</li><li id="504e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ol lk ll lm bi translated"><strong class="kk iu">新用户</strong>:当没有足够的信息为用户建立可靠的档案时，无法正确提供推荐。</li></ul><p id="e696" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> P.S. </strong>以上发现来自我在数据科学训练营的合作项目。如果你有兴趣了解更多关于其他推荐系统(协同过滤、潜在因素分析)的信息，请访问这个<a class="ae ls" href="https://github.com/youonf/recommendation_system" rel="noopener ugc nofollow" target="_blank">知识库</a>。</p><p id="1fc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="pe">参考</em><br/><a class="ae ls" href="https://www.analyticsvidhya.com/blog/2015/08/beginners-guide-learn-content-based-recommender-systems/" rel="noopener ugc nofollow" target="_blank"><em class="pe">https://www . analyticsvidhya . com/blog/2015/08/beginners-guide-learn-content-based-recommenders-systems/</em></a><em class="pe"><br/></em><a class="ae ls" rel="noopener" target="_blank" href="/learning-to-make-recommendations-745d13883951"><em class="pe">https://towardsdatascience . com/learning-to-make-recommenders-745d 13883951</em></a><em class="pe"><br/></em></p></div></div>    
</body>
</html>