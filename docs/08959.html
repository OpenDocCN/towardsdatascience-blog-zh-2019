<html>
<head>
<title>SQL — Substring with Negative Indexing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 带有负索引的子字符串</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-substring-with-negative-indexing-728c89603187?source=collection_archive---------17-----------------------#2019-11-29">https://towardsdatascience.com/sql-substring-with-negative-indexing-728c89603187?source=collection_archive---------17-----------------------#2019-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="52a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我讨论了 SQL 中一个非常重要的字符串相关操作——SUBSTR 和负索引的应用。</p><p id="3af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SUBSTR 用于从给定位置提取给定字符串的特定部分。我已经使用 SUBSTR 的 SQLite 实现来说明负索引的使用。</p><p id="c598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经使用<a class="ae ko" href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip" rel="noopener ugc nofollow" target="_blank"> movielens </a>数据库编写了 SUBSTR 的各种查询。这个数据库有四个表— <em class="kp">链接，电影，收视率，标签。</em>我们对<em class="kp">电影</em>表感兴趣。该表的前 20 行如下</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk"><strong class="ak">Table 1: movies table</strong></figcaption></figure><p id="f770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将详细介绍 SUBSTR 操作符及其参数。SUBSTR 接受三个参数，如表 1 所示。最后一个参数— <strong class="js iu"> Z </strong>，是可选的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/4919e8edc327e8689298e82838efb498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*hseEU-hmNsXcHpO_PZnnuQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk"><strong class="bd le">Figure 2: SQLite — SUBTSR</strong></figcaption></figure><p id="619e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Y </strong>和<strong class="js iu"> Z </strong>参数都可以取正负指标值。此外，<strong class="js iu"> Z </strong>是可选的，因此我们有以下六种可能性</p><pre class="kq kr ks kt gt lf lg lh li aw lj bi"><span id="7c0b" class="lk ll it lg b gy lm ln l lo lp">╔══════════╦══════════╗<br/>║    Y     ║    Z     ║<br/>╠══════════╬══════════╣<br/>║ Positive ║    -     ║<br/>║ Negative ║    -     ║<br/>║ Positive ║ Positive ║<br/>║ Positive ║ Negative ║<br/>║ Negative ║ Positive ║<br/>║ Negative ║ Negative ║<br/>╚══════════╩══════════╝</span></pre><p id="5240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们将为上述六种可能性中的每一种编写查询。在此之前，我们应该知道 SUBSTR 中的负索引是如何工作的。如图 3 所示，正索引从字符串中最左边的数字 1 开始，负索引从最右边的数字-1 开始。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/e833a27e18c86e868824b43192fb3117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLoTc5Q81n4yMesyOWjaKA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk"><strong class="bd le">Figure 3: SUBTSR — Positive and Negative Indexing</strong></figcaption></figure><p id="3a45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下表包含如何评估六种组合<strong class="js iu"> Y </strong>和<strong class="js iu"> Z </strong>的详细信息。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk"><strong class="ak">Table 2: SUBTSR — Combination of Y and Z with examples</strong></figcaption></figure><p id="2771" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们将执行一些查询，在这些查询中，我们可以使用来获得所需的结果。</p><blockquote class="lv lw lx"><p id="810a" class="jq jr kp js b jt ju jv jw jx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km kn im bi translated"><strong class="js iu">查询 1:编写一个查询，从电影标题中删除电影发行年份，只显示标题。</strong></p></blockquote><pre class="kq kr ks kt gt lf lg lh li aw lj bi"><span id="8786" class="lk ll it lg b gy lm ln l lo lp">SELECT TRIM(SUBSTR(TRIM(title), -6, (SELECT 6-MAX(LENGTH(title))<br/>                                     FROM movies)))<br/>FROM movies</span></pre><p id="f8f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在查询 1 中，我们为<strong class="js iu"> X，Y，Z</strong>T26】1 设置了以下值。<strong class="js iu"> X </strong> = <code class="fe mb mc md lg b">TRIM(title)</code> <br/>我们已经修剪了电影表格的标题列，以消除电影标题两端有空格的任何可能性。<strong class="js iu"> <br/> </strong> 2。<strong class="js iu"> Y </strong> = <code class="fe mb mc md lg b">-6</code> <br/>为什么-6？因为我们对所有的电影片名都有以下结构——<strong class="js iu">&lt;片名&gt; &lt;空间&gt; ( &lt;四位数电影上映年份&gt; ) </strong>。我们有最后 6 个字符作为<code class="fe mb mc md lg b">‘(‘, ‘&lt;digit&gt;’, ‘&lt;digit&gt;’, ‘&lt;digit&gt;’, ‘&lt;digit&gt;’, ‘)’</code>。</p><p id="6207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.由于标题的长度不同，我们必须确保每个标题都完整地出现在结果中。我们已经处理了具有最大标题长度的情况，它将适用于其他情况。我们可以将此操作分解为以下步骤— <br/> <strong class="js iu">首先是</strong>，计算所有电影标题的长度— <code class="fe mb mc md lg b">LENGTH(title)</code>。它产生一个包含每个电影标题长度的表格。<br/> <strong class="js iu">第二个</strong>，计算最大长度— <code class="fe mb mc md lg b">MAX(LENGTH(title))</code>。这导致标题的最大长度为 158。<br/> <strong class="js iu">第三个</strong>，<code class="fe mb mc md lg b">6-MAX(LENGTH(title))</code>结果为 6–158 =-152。<br/>因此我们有<strong class="js iu"> Z </strong> as -152。这里，Y 和 Z 都有负值。从第-6 个字符开始读取，即<strong class="js iu">'('，</strong>)，然后读取-152 的绝对值，即 152，即<strong class="js iu"> '(' </strong>之前的字符，不包括<strong class="js iu"> '(' </strong>字符。由于 152 是电影表中标题的最大长度，它将提取所有电影的标题。以<strong class="js iu"> </strong>为例，<strong class="js iu">《吉米·好莱坞(1994)》</strong>就会产生<code class="fe mb mc md lg b">‘<strong class="js iu">Jimmy Hollywood </strong>’</code>和《修整后》<code class="fe mb mc md lg b">‘<strong class="js iu">Jimmy Hollywood</strong>’</code>。</p><blockquote class="lv lw lx"><p id="c798" class="jq jr kp js b jt ju jv jw jx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km kn im bi translated"><strong class="js iu">查询 2:编写一个查询，从电影标题中删除标题，只显示年份。</strong></p></blockquote><p id="4d58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我们可以从标题列中提取电影上映年份。</p><pre class="kq kr ks kt gt lf lg lh li aw lj bi"><span id="10ad" class="lk ll it lg b gy lm ln l lo lp">SELECT TRIM(SUBSTR(TRIM(title), -5, 4))<br/>FROM movies</span></pre><p id="40fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此查询中，提取电影发行年份从电影发行年份的第一个数字-5 字符开始，然后提取其后的 4 个字符，包括-5 字符。</p><p id="07db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以利用负索引的力量来执行一些特定的操作。例如，我们可以根据电影发行年份的查询 2 的结果进行分组，并可以获得每年发行的电影数量。</p><blockquote class="lv lw lx"><p id="558a" class="jq jr kp js b jt ju jv jw jx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km kn im bi translated"><strong class="js iu">查询 3:写一个查询，找出电影《碟中谍》的上映年份。</strong></p></blockquote><pre class="kq kr ks kt gt lf lg lh li aw lj bi"><span id="b860" class="lk ll it lg b gy lm ln l lo lp">SELECT TRIM(SUBSTR(TRIM(title), -5, 4))<br/>FROM movies<br/>WHERE title LIKE "Mission: Impossible%"</span></pre><p id="bba8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我想强调的一点是，可以使用正则表达式以更加优雅和高效的方式执行上述操作，但在本文中，我尝试展示了 SUBSTR 中负索引的应用。</p></div></div>    
</body>
</html>