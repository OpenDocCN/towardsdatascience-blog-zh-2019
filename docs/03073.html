<html>
<head>
<title>The Universal Machine Learning Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通用机器学习工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/applying-the-universal-machine-learning-workflow-to-the-uci-mushroom-dataset-1939442d44e7?source=collection_archive---------12-----------------------#2019-05-17">https://towardsdatascience.com/applying-the-universal-machine-learning-workflow-to-the-uci-mushroom-dataset-1939442d44e7?source=collection_archive---------12-----------------------#2019-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5165c8664ee697a27d575987611dd85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MYwjpwXOlwC2j3Sy"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@phienix_han?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Phoenix Han</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="5631" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated"><span class="l ky kz la bm lb lc ld le lf di">一个</span>将弗朗索瓦·乔莱的通用机器学习工作流程应用于 UCI 蘑菇数据集</h2></div><p id="e097" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi mc translated"><span class="l ky kz la bm lb lc ld le lf di"> W </span> e 将使用来自<a class="ae jg" href="https://archive.ics.uci.edu/ml/index.php" rel="noopener ugc nofollow" target="_blank"> UCI 的机器学习库</a>的<a class="ae jg" href="https://archive.ics.uci.edu/ml/datasets/mushroom" rel="noopener ugc nofollow" target="_blank">蘑菇数据集</a>来执行我们的演示。本书面向至少对 Python 基础有基本了解并有一些机器学习经验的读者。也就是说，我将为门外汉提供大量支持来源的链接，以便任何人都可以利用所提供的信息。</p><p id="d68f" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我们开始之前，我想感谢我的 Lambdonian 同事 Ned H 对这篇文章的所有帮助。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="ee71" class="mm mn jj bd mo mp mq dn mr ms mt dp mu lp mv mw mx lt my mz na lx nb nc nd ne bi translated">通用机器学习工作流</h2><ol class=""><li id="1279" class="nf ng jj li b lj nh lm ni lp nj lt nk lx nl mb nm nn no np bi translated">定义问题并组装数据集</li><li id="69b8" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">选择衡量成功的标准</li><li id="079c" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">决定评估协议</li><li id="4096" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">准备数据</li><li id="68f0" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">开发一个比基线做得更好的模型</li><li id="7fcb" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">开发一个过度拟合的模型</li><li id="61d3" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">正则化模型并调整其超参数</li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="417c" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">1.定义问题并组装数据集</h1><p id="dd8f" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">简单地说，我们的问题是把蘑菇分为食用和有毒两类。我们得到了一个包含 23 个特征的数据集，其中包括蘑菇的类别(可食用或有毒)。</p><p id="cac4" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">根据数据信息文件中列出的特性，我们可以为数据集创建一个列名列表。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="6d05" class="mm mn jj oo b gy os ot l ou ov">column_names = ['class',<br/>                'cap-shape',<br/>                'cap-surface',<br/>                'cap-color',<br/>                'bruises?',<br/>                'odor',<br/>                'gill-attachment',<br/>                'gill-spacing',<br/>                'gill-size',<br/>                'gill-color',<br/>                'stalk-shape',<br/>                'stalk-root',<br/>                'stalk-surface-above-ring',<br/>                'stalk-surface-below-ring',<br/>                'stalk-color-above-ring',<br/>                'stalk-color-below-ring',<br/>                'veil-type',<br/>                'veil-color',<br/>                'ring-number',<br/>                'ring-type',<br/>                'spore-print-color',<br/>                'population',<br/>                'habitat']</span></pre><p id="a5b2" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们导入数据集，并从。数据文件使用<code class="fe ow ox oy oo b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank">pd.read_csv()</a></code></p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="4f45" class="mm mn jj oo b gy os ot l ou ov">import pandas as pd</span><span id="f25c" class="mm mn jj oo b gy oz ot l ou ov">url = '<a class="ae jg" href="https://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/agaricus-lepiota.data'" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/agaricus-lepiota.data'</a></span><span id="36eb" class="mm mn jj oo b gy oz ot l ou ov">mushrooms = pd.read_csv(url, header=None, names=column_names)</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="41a6" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">2.选择衡量成功的标准</h1><p id="d323" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">鉴于我们问题的性质；分类蘑菇是否有毒，我们将使用<a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html" rel="noopener ugc nofollow" target="_blank">精度</a>作为我们成功的衡量标准。精度是分类器不将有毒蘑菇标记为可食用蘑菇的能力。我们宁愿人们丢弃我们的模型归类为有毒的可食用蘑菇，而不是食用我们的分类器标记为可食用的有毒蘑菇。</p><figure class="oj ok ol om gt iv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/11ac51a5aeb93d90e907e5277fc1bd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*aqXLekm1AEyueWOkgo1qig.png"/></div></figure><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="7b48" class="mm mn jj oo b gy os ot l ou ov">from sklearn.metrics import precision_score</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="0040" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">3.决定评估协议</h1><p id="6e74" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">我们将使用 10 重交叉验证来评估我们的模型。虽然一个简单的拒绝验证集可能就足够了，但我怀疑它的可行性，因为我们有大约 8000 个样本。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="4bd9" class="mm mn jj oo b gy os ot l ou ov">from sklearn.model_selection import train_test_split, cross_validate</span></pre><p id="e895" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先让我们把数据分成一个特征矩阵(X)和一个目标向量(y)。我们将使用<code class="fe ow ox oy oo b"><a class="ae jg" href="http://contrib.scikit-learn.org/categorical-encoding/onehot.html" rel="noopener ugc nofollow" target="_blank">OneHotEncoder</a></code>来编码我们的分类变量。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="7501" class="mm mn jj oo b gy os ot l ou ov">import category_encoders as ce</span><span id="4cff" class="mm mn jj oo b gy oz ot l ou ov">#Drop target feature<br/>X = mushrooms.drop(columns='class') </span><span id="af0a" class="mm mn jj oo b gy oz ot l ou ov">#Encode categorical features<br/>X = ce.OneHotEncoder(use_cat_names=True).fit_transform(X)<br/> <br/>y = mushrooms['class'].replace({'p':0, 'e':1})</span><span id="ea65" class="mm mn jj oo b gy oz ot l ou ov">print('Feature matrix size:',X.shape)<br/>print('Target vector size:',len(y))</span><span id="9d72" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="ca10" class="mm mn jj oo b gy oz ot l ou ov">Feature matrix size: (8124, 117) Target vector size: 8124</span></pre><p id="c4f2" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">接下来，我们将把数据分成<a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">训练集和</a>测试集。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="7b1c" class="mm mn jj oo b gy os ot l ou ov">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, test_size=.2, stratify=y)</span><span id="92d4" class="mm mn jj oo b gy oz ot l ou ov">print('Training feature matrix size:',X_train.shape)<br/>print('Training target vector size:',y_train.shape)<br/>print('Test feature matrix size:',X_test.shape)<br/>print('Test target vector size:',y_test.shape)</span><span id="fd40" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="ad27" class="mm mn jj oo b gy oz ot l ou ov">Training feature matrix size: (6499, 117) <br/>Training target vector size: (6499,) <br/>Test feature matrix size: (1625, 117) <br/>Test target vector size: (1625,)</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="9e2d" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">4.准备数据</h1><p id="1225" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">我们几乎准备好开始训练模型，但是首先我们应该探索我们的数据，熟悉它的特征，并格式化它，以便它可以输入到我们的模型中。</p><p id="4147" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以使用<code class="fe ow ox oy oo b">.dtypes()</code>、<code class="fe ow ox oy oo b">.columns</code>和<code class="fe ow ox oy oo b">.shape</code>来检查我们的数据集，但是 Pandas 提供了一个<code class="fe ow ox oy oo b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html" rel="noopener ugc nofollow" target="_blank">.info</a></code>功能，允许我们在一个地方查看所有这些信息。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="7bcf" class="mm mn jj oo b gy os ot l ou ov">print(mushrooms.info())</span><span id="f2ce" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="c939" class="mm mn jj oo b gy oz ot l ou ov">&lt;class 'pandas.core.frame.DataFrame'&gt; <br/>RangeIndex: 8124 entries, 0 to 8123<br/>Data columns (total 23 columns):<br/>class                       8124 non-null object<br/>cap-shape                   8124 non-null object <br/>cap-surface                 8124 non-null object <br/>cap-color                   8124 non-null object <br/>bruises?                    8124 non-null object <br/>odor                        8124 non-null object <br/>gill-attachment             8124 non-null object <br/>gill-spacing                8124 non-null object <br/>gill-size                   8124 non-null object <br/>gill-color                  8124 non-null object <br/>stalk-shape                 8124 non-null object <br/>stalk-root                  8124 non-null object <br/>stalk-surface-above-ring    8124 non-null object <br/>stalk-surface-below-ring    8124 non-null object <br/>stalk-color-above-ring      8124 non-null object <br/>stalk-color-below-ring      8124 non-null object <br/>veil-type                   8124 non-null object <br/>veil-color                  8124 non-null object <br/>ring-number                 8124 non-null object <br/>ring-type                   8124 non-null object <br/>spore-print-color           8124 non-null object <br/>population                  8124 non-null object <br/>habitat                     8124 non-null object <br/>dtypes: object(23) memory usage: 1.4+ MB None</span></pre><p id="fdda" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">另一个有用的步骤是检查空值的数量以及它们在数据帧中的位置</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="0155" class="mm mn jj oo b gy os ot l ou ov">print(mushrooms.isna().sum())</span><span id="67ae" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="f9da" class="mm mn jj oo b gy oz ot l ou ov">class                       0 <br/>cap-shape                   0 <br/>cap-surface                 0 <br/>cap-color                   0 <br/>bruises?                    0 <br/>odor                        0 <br/>gill-attachment             0 <br/>gill-spacing                0 <br/>gill-size                   0 <br/>gill-color                  0 <br/>stalk-shape                 0 <br/>stalk-root                  0 <br/>stalk-surface-above-ring    0 <br/>stalk-surface-below-ring    0 <br/>stalk-color-above-ring      0 <br/>stalk-color-below-ring      0 <br/>veil-type                   0 <br/>veil-color                  0 <br/>ring-number                 0 <br/>ring-type                   0 <br/>spore-print-color           0 <br/>population                  0 <br/>habitat                     0 <br/>dtype: int64</span></pre><p id="d535" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一个也没有……这似乎好得令人难以置信。</p><p id="ee9a" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">由于我们勤奋好学，阅读了<a class="ae jg" href="https://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/agaricus-lepiota.names" rel="noopener ugc nofollow" target="_blank">数据集信息文件</a>。我们知道所有缺失的值都标有问号。一旦清楚了这一点，我们就可以使用<code class="fe ow ox oy oo b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html" rel="noopener ugc nofollow" target="_blank">df.replace()</a></code>来转换？敬 NaNs。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="8c44" class="mm mn jj oo b gy os ot l ou ov">import numpy as np<br/>mushrooms = mushrooms.replace({'?':np.NaN})<br/>print(mushrooms.isna().sum())<br/>____________________________________________________________________</span><span id="b88b" class="mm mn jj oo b gy oz ot l ou ov">class                       0 <br/>cap-shape                   0 <br/>cap-surface                 0 <br/>cap-color                   0 <br/>bruises?                    0 <br/>odor                        0 <br/>gill-attachment             0 <br/>gill-spacing                0 <br/>gill-size                   0 <br/>gill-color                  0 <br/>stalk-shape                 0 <br/>stalk-root               2480<br/>stalk-surface-above-ring    0 <br/>stalk-surface-below-ring    0 <br/>stalk-color-above-ring      0 <br/>stalk-color-below-ring      0 <br/>veil-type                   0 <br/>veil-color                  0 <br/>ring-number                 0 <br/>ring-type                   0 <br/>spore-print-color           0 <br/>population                  0 <br/>habitat                     0 <br/>dtype: int64</span></pre><p id="5ae1" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们到了，<code class="fe ow ox oy oo b">stalk_root</code>有 2480 个空白特征，让我们用<code class="fe ow ox oy oo b">m</code>替换它们。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="5730" class="mm mn jj oo b gy os ot l ou ov">mushrooms['stalk-root'] = mushrooms['stalk-root'].replace(np.NaN,'m')</span><span id="eae3" class="mm mn jj oo b gy oz ot l ou ov">print(mushrooms['stalk-root'].value_counts())</span><span id="6a57" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="3d40" class="mm mn jj oo b gy oz ot l ou ov">b    3776 <br/>m    2480 <br/>e    1120 <br/>c     556 <br/>r     192 <br/>Name: stalk-root, dtype: int64</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e71d" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">5.开发一个比基线做得更好的模型</h1><p id="19e4" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated"><strong class="li jk">基线模型</strong></p><p id="0c61" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用我们数据集中最常见的标签，我们将创建一个我们希望击败的基线模型。</p><p id="d64b" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先让我们看看如何使用<code class="fe ow ox oy oo b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.value_counts.html" rel="noopener ugc nofollow" target="_blank">df.value_counts()</a></code>来分配类</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="815b" class="mm mn jj oo b gy os ot l ou ov">mushrooms['class'].value_counts(normalize=True)</span><span id="02a9" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="2920" class="mm mn jj oo b gy oz ot l ou ov">e    0.517971 <br/>p    0.482029 <br/>Name: class, dtype: float64</span></pre><p id="943f" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将使用 class 属性的模式来创建基线预测。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="38f8" class="mm mn jj oo b gy os ot l ou ov">majority_class = y_train.mode()[0]</span><span id="3130" class="mm mn jj oo b gy oz ot l ou ov">baseline_predictions = [majority_class] * len(y_train)</span></pre><p id="0dab" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们看看我们的基线模型有多精确。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="1cf3" class="mm mn jj oo b gy os ot l ou ov">from sklearn.metrics import accuracy_score</span><span id="f121" class="mm mn jj oo b gy oz ot l ou ov">majority_class_accuracy = accuracy_score(baseline_predictions,<br/>                                         y_train)</span><span id="22d3" class="mm mn jj oo b gy oz ot l ou ov">print(majority_class_accuracy)</span><span id="9ae5" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________<br/></span><span id="c274" class="mm mn jj oo b gy oz ot l ou ov">0.5179258347438067</span></pre><p id="4e00" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">约 52%…这是给定初始数据集中类的分布后我们所期望的。</p><p id="5bf5" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li jk">决策树</strong></p><p id="6d26" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将尝试用<a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html" rel="noopener ugc nofollow" target="_blank">决策树</a>来拟合我们的训练数据，并产生大于 52%的准确率分数。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="db99" class="mm mn jj oo b gy os ot l ou ov">from sklearn.tree import DecisionTreeClassifier<br/>import graphviz<br/>from sklearn.tree import export_graphviz</span><span id="a178" class="mm mn jj oo b gy oz ot l ou ov">tree = DecisionTreeClassifier(max_depth=1)</span><span id="8a2f" class="mm mn jj oo b gy oz ot l ou ov"># Fit the model<br/>tree.fit(X_train, y_train)</span><span id="32f6" class="mm mn jj oo b gy oz ot l ou ov"># Visualize the tree<br/>dot_data = export_graphviz(tree, out_file=None, feature_names=X_train.columns, class_names=['Poisonous', 'Edible'], filled=True, impurity=False, proportion=True)</span><span id="2710" class="mm mn jj oo b gy oz ot l ou ov">graphviz.Source(dot_data)</span></pre><figure class="oj ok ol om gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/e17b0839cd27b2c62c40e09f7001a3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1O8rS4AaSEmM3GTx-V4Mg.png"/></div></div></figure><p id="a41f" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，我们已经将决策树与我们的数据相匹配，我们可以通过查看分类器的预测概率分布来分析我们的模型。简单来说，预测概率表示模型对其分类标签的确信程度。</p><p id="7cc0" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">除了预测概率，我们还会看我们决策树的精度得分。Sklearn 为我们提供了一个简单的方法，用<code class="fe ow ox oy oo b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html" rel="noopener ugc nofollow" target="_blank">classification_report</a></code>看到分类模型的很多相关分数。</p><p id="b6d3" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们还将使用 sklearn 的<code class="fe ow ox oy oo b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" rel="noopener ugc nofollow" target="_blank">confusion_matrix</a></code>生成混淆矩阵。混淆矩阵显示了真假阳性和阴性的数量。</p><p id="a999" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因为我们将再次使用这些工具，所以我们将编写一个函数来运行我们的模型分析。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="70a2" class="mm mn jj oo b gy os ot l ou ov">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from sklearn.metrics import classification_report, confusion_matrix</span><span id="9d61" class="mm mn jj oo b gy oz ot l ou ov">def model_analysis(model, train_X, train_y):<br/>  model_probabilities = model.predict_proba(train_X)</span><span id="f4c8" class="mm mn jj oo b gy oz ot l ou ov">  Model_Prediction_Probability = []</span><span id="927b" class="mm mn jj oo b gy oz ot l ou ov">  for _ in range(len(train_X)):<br/>      x = max(model_probabilities[_])<br/>      Model_Prediction_Probability.append(x)</span><span id="773a" class="mm mn jj oo b gy oz ot l ou ov">  plt.figure(figsize=(15,10)) <br/> <br/>  sns.distplot(Model_Prediction_Probability)</span><span id="059d" class="mm mn jj oo b gy oz ot l ou ov">  plt.title('Best Model Prediction Probabilities')</span><span id="b2b3" class="mm mn jj oo b gy oz ot l ou ov">  # Set x and y ticks<br/>  plt.xticks(color='gray')</span><span id="83f5" class="mm mn jj oo b gy oz ot l ou ov">  #plt.xlim(.5,1)<br/>  plt.yticks(color='gray')</span><span id="fa17" class="mm mn jj oo b gy oz ot l ou ov">  # Create axes object with plt. get current axes<br/>  ax = plt.gca()</span><span id="f4b0" class="mm mn jj oo b gy oz ot l ou ov">  # Set grid lines<br/>  ax.grid(b=True, which='major', axis='y', color='black', alpha=.2)</span><span id="e1df" class="mm mn jj oo b gy oz ot l ou ov">  # Set facecolor<br/>  ax.set_facecolor('white')</span><span id="47d1" class="mm mn jj oo b gy oz ot l ou ov">  # Remove box<br/>  ax.spines['top'].set_visible(False)<br/>  ax.spines['right'].set_visible(False)<br/>  ax.spines['bottom'].set_visible(False)<br/>  ax.spines['left'].set_visible(False)<br/>  ax.tick_params(color='white')</span><span id="678c" class="mm mn jj oo b gy oz ot l ou ov">  plt.show();<br/>  <br/>  model_predictions = model.predict(train_X)</span><span id="6607" class="mm mn jj oo b gy oz ot l ou ov">  # Classification Report<br/>  print('\n\n', classification_report(train_y, model_predictions, target_names=['0-Poisonous', '1-Edible']))</span><span id="ad3c" class="mm mn jj oo b gy oz ot l ou ov">  # Confusion Matrix<br/>  con_matrix = pd.DataFrame(confusion_matrix(train_y, model_predictions), columns=['Predicted Poison', 'Predicted Edible'], index=['Actual Poison', 'Actual Edible'])<br/>  <br/>  plt.figure(figsize=(15,10))</span><span id="2a2c" class="mm mn jj oo b gy oz ot l ou ov">  sns.heatmap(data=con_matrix, cmap='cool');</span><span id="5f5e" class="mm mn jj oo b gy oz ot l ou ov">  plt.title('Model Confusion Matrix')<br/>  plt.show();<br/>  <br/>  return con_matrix</span></pre><p id="dc87" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在将这个函数应用到我们的决策树中。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="3ff0" class="mm mn jj oo b gy os ot l ou ov">model_analysis(tree, X_train, y_train)</span></pre><figure class="oj ok ol om gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/81886a81f08d9940e285ff2e36fdffbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBKg3nu-emiPfS0JvUesEA.jpeg"/></div></div></figure><p id="b040" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将把我们的预测存储为一个<code class="fe ow ox oy oo b">tree_predictions</code>变量，用于解释我们模型的准确性。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="cef4" class="mm mn jj oo b gy os ot l ou ov">tree_predictions = tree.predict(X_train)</span><span id="256a" class="mm mn jj oo b gy oz ot l ou ov">accuracy_score(y_train, tree_predictions)</span><span id="a4cb" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="3bcc" class="mm mn jj oo b gy oz ot l ou ov">0.8862901984920757</span></pre><p id="de6e" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">88%的准确率已经不错了，但是让我们进入工作流程的下一步。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="2dc3" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">6.开发一个过度拟合的模型</h1><p id="c7b5" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">我们将使用<code class="fe ow ox oy oo b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">RandomForestClassifier</a></code>作为我们的过度拟合模型。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="9717" class="mm mn jj oo b gy os ot l ou ov">from sklearn.ensemble import RandomForestClassifier</span><span id="01f0" class="mm mn jj oo b gy oz ot l ou ov">random_forest = RandomForestClassifier(n_estimators=100, max_depth=5)</span><span id="3ef9" class="mm mn jj oo b gy oz ot l ou ov">cv = cross_validate(estimator = random_forest, X = X_train, y = y_train, scoring='accuracy', n_jobs=-1, cv=10, verbose=10, return_train_score=True)</span><span id="486a" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________<br/></span><span id="450a" class="mm mn jj oo b gy oz ot l ou ov">[Parallel(n_jobs=-1)]: Using backend LokyBackend with 2 concurrent workers.</span><span id="9a06" class="mm mn jj oo b gy oz ot l ou ov">[Parallel(n_jobs=-1)]: Done   1 tasks      | elapsed:    2.6s [Parallel(n_jobs=-1)]: Done   4 tasks      | elapsed:    3.2s [Parallel(n_jobs=-1)]: Done  10 out of  10 | elapsed:    4.7s finished</span></pre><p id="edae" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在我们可以看到我们的随机森林的准确性得分。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="4f4a" class="mm mn jj oo b gy os ot l ou ov">random_forest.fit(X_test, y_test)<br/>test_predictions = random_forest.predict(X_train)</span><span id="e511" class="mm mn jj oo b gy oz ot l ou ov">accuracy_score(y_train, test_predictions)</span><span id="2587" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________<br/></span><span id="eda1" class="mm mn jj oo b gy oz ot l ou ov">0.9924603785197723</span></pre><p id="39af" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">99%的准确率对我来说太过了。</p><p id="df0e" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以使用前面的<code class="fe ow ox oy oo b">model_analysis</code>函数来分析我们的模型。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="cb84" class="mm mn jj oo b gy os ot l ou ov">model_analysis(random_forest, X_train, y_train)</span></pre><figure class="oj ok ol om gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/131ccbb3bac2607a6e81bddc2c5cf148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9oJftYteUHNnHtOjd_DBA.jpeg"/></div></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f9e6" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">7.正则化模型并调整其超参数</h1><p id="5bcd" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">现在，我们将调整<code class="fe ow ox oy oo b">RandomForestClassifier</code>的超参数，并尝试在欠拟合和过拟合之间游走。我们可以使用 sklearn 的<code class="fe ow ox oy oo b"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.html" rel="noopener ugc nofollow" target="_blank">RandmoizedSearchCV</a></code>在我们的<code class="fe ow ox oy oo b">param_distributions</code>字典中搜索超参数。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="8c5b" class="mm mn jj oo b gy os ot l ou ov">from sklearn.model_selection import RandomizedSearchCV</span><span id="bb43" class="mm mn jj oo b gy oz ot l ou ov">param_distributions = {<br/>    'max_depth':[1, 2, 3, 4, 5],<br/>    'n_estimators': [10, 25, 50, 100, 150, 200]}</span><span id="ce55" class="mm mn jj oo b gy oz ot l ou ov">search = RandomizedSearchCV(estimator = RandomForestClassifier(), param_distributions = param_distributions, n_iter=100, scoring='precision', n_jobs=-1, cv=10, verbose=10, return_train_score=True)<br/> <br/>search.fit(X_train, y_train)</span></pre><p id="f5a7" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以用<code class="fe ow ox oy oo b">search.best_estimator_</code>来看看哪个模型的精度得分最高。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="faf7" class="mm mn jj oo b gy os ot l ou ov">best_model = search.best_estimator_<br/>best_model</span><span id="9dea" class="mm mn jj oo b gy oz ot l ou ov">____________________________________________________________________</span><span id="c05b" class="mm mn jj oo b gy oz ot l ou ov">RandomForestClassifier<br/>(bootstrap=True, class_weight=None, criterion='gini', max_depth=5, max_features='auto', max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2,             min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=None,             oob_score=False, random_state=None, verbose=0,             warm_start=False)</span></pre><p id="ac2e" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从模型描述中我们可以看到，具有 5 和 10 个估计量的<code class="fe ow ox oy oo b">max_depth</code>的<code class="fe ow ox oy oo b">RandomForestClassifier</code>是我们的最优模型。现在我们可以运行我们的分析功能。</p><pre class="oj ok ol om gt on oo op oq aw or bi"><span id="3860" class="mm mn jj oo b gy os ot l ou ov">model_analysis(best_model, X_test, y_test)</span></pre><figure class="oj ok ol om gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/07e0337b9121f43476aec317201a4577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyuIBpvDBi1ok-N9WBILiA.jpeg"/></div></div></figure><p id="66ed" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">3 次误报，不完美，但相当不错。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f775" class="nv mn jj bd mo nw nx ny mr nz oa ob mu kp oc kq mx ks od kt na kv oe kw nd of bi translated">结论</h1><p id="6ad0" class="pw-post-body-paragraph lg lh jj li b lj nh kk ll lm ni kn lo lp og lr ls lt oh lv lw lx oi lz ma mb im bi translated">重申我们的工作流程。</p><ol class=""><li id="3445" class="nf ng jj li b lj lk lm ln lp pd lt pe lx pf mb nm nn no np bi translated">定义问题并组装数据集</li><li id="c9c9" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">选择衡量成功的标准</li><li id="5e55" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">决定评估协议</li><li id="2a75" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">准备数据</li><li id="9f78" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">开发一个比基线做得更好的模型</li><li id="ba4a" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">开发一个过度拟合的模型</li><li id="869b" class="nf ng jj li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">正则化模型并调整其超参数</li></ol><p id="fdd3" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然 Chollet 将其描述为通用的机器学习工作流，但根据我们试图解决的具体问题，存在无限的变化。不过一般来说，你总是从定义你的问题和收集数据开始，(无论是从预先准备好的数据集还是自己收集的数据)。</p><p id="d587" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我希望这篇文章展示了 Chollet 的通用机器学习工作流程的详细介绍。</p><p id="d908" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感谢阅读！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="2ea8" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在 T <a class="ae jg" href="https://twitter.com/matt42kirby" rel="noopener ugc nofollow" target="_blank"> witter </a>、<a class="ae jg" href="https://github.com/mkirby1995" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae jg" href="https://www.linkedin.com/in/mathew-kirby-082062ba/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我</p><p id="f67f" class="pw-post-body-paragraph lg lh jj li b lj lk kk ll lm ln kn lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">附:这是我在这篇文章中使用的<a class="ae jg" href="https://colab.research.google.com/drive/1HztKbgWR-fZT3-Evc4t8ru16kOcueuH5" rel="noopener ugc nofollow" target="_blank"> Colab 笔记本</a>的链接。</p></div></div>    
</body>
</html>