<html>
<head>
<title>About Text Vectorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于文本矢量化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-magic-behind-embedding-models-part-1-974d539f21fd?source=collection_archive---------17-----------------------#2019-12-01">https://towardsdatascience.com/the-magic-behind-embedding-models-part-1-974d539f21fd?source=collection_archive---------17-----------------------#2019-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc16" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将文本转换成数字的魔力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50120b1cace6741141d297200332fe68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ODsAugR6UaFCETr_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by <a class="ae ky" href="https://unsplash.com/@art_maltsev" rel="noopener ugc nofollow" target="_blank">Artem Maltsev</a> — Unsplash</figcaption></figure><p id="d036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将带你了解文本矢量化的基础知识，即将文本转换成矢量(数字列表)。在本帖中，我们将展示单词包(BOW)及其风格:频率向量、一种热门编码(OHE)和术语频率/逆文档频率(TF/IDF)。</p><h1 id="380c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么要文本矢量化？</h1><p id="0acb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">用数字表示文本有很多好处，主要是:</p><ol class=""><li id="4160" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">计算机不理解文本以及单词和句子之间的关系，所以你需要一种用数字来表示这些单词的方法，这是计算机能够理解的。</li><li id="2e26" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">这种向量可以用在许多应用中，例如问题回答系统、推荐系统、情感分析、文本分类，并且它还使得搜索、返回同义词等更容易。</li></ol><h2 id="fa57" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak">包话(鞠躬)</strong></h2><p id="5f35" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">BOW 是一种解析文档特征的技术。特征的含义是你可以用来做决定的特征和属性(买房子时，你会寻找一些特征，比如有多少个房间和它的位置)。文本的特征是语料库中有多少独特的词以及每个词的出现次数等。BOW 是一种特征提取技术，其输出是表示语料库中每个文档的向量空间。这个向量的长度(维度)对应于语料库中唯一单词的数量(没有重复，每个单词只出现一次)。BOW 模型有不同的风格，每个都扩展或修改了基本 BOW。接下来将讨论三个不同的向量:频率向量(计数向量)、一个热编码和术语频率/逆文档频率。</p><h2 id="d896" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak">频率矢量</strong></h2><p id="a1fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是最简单的编码技术，但在某些用例中仍然有效。简单地说，我们用每个单词在文档中出现的次数来填充文档向量。例如，假设我们的语料库有两个文档。第一个文档包含“<strong class="lb iu">爱丽丝喜欢意大利面</strong>”，第二个文档包含“<strong class="lb iu">爱丽丝喜欢鱼。爱丽丝和鲍勃是朋友。为了表示计数，我们可以使用表格或 JavaScript 对象符号(JSON ),如下所示:</strong></p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6243" class="ng lw it nt b gy nx ny l nz oa"><br/>Table representation:</span><span id="688a" class="ng lw it nt b gy ob ny l nz oa">+-------+-------+-------+-------+------+-----+-----+-----+---------+<br/>|       | Alice | loves | pasta | fish | and | Bob | are | friends |<br/>+-------+-------+-------+-------+------+-----+-----+-----+---------+<br/>|  doc1 |   1   |   1   |   1   |   0  |  0  |  0  |  0  |    0    |<br/>+-------+-------+-------+-------+------+-----+-----+-----+---------+<br/>|  doc2 |   2   |   1   |   0   |   1  |  1  |  1  |  1  |    1    |  <br/>+-------+-------+-------+-------+------+-----+-----+-----+---------+</span><span id="68db" class="ng lw it nt b gy ob ny l nz oa">JSON representation:</span><span id="305d" class="ng lw it nt b gy ob ny l nz oa">doc1: {"Alice":1, "loves":1, "pasta":1}<br/>doc2: {"Alice":2, "loves":1, "fish":1, "and":1, "Bob":1,                "are":1, "friends":1}</span><span id="6d31" class="ng lw it nt b gy ob ny l nz oa">You can combine them: {"Alice":3, "loves":2, "pasta":1, "fish":1, "and":1, "Bob":1, "are":1, "friends":1}</span></pre><p id="a0de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们的语料库中有 8 个独特的单词。因此，我们的向量大小为 8。为了表示文档 1，我们只需取表中的第一行[1，1，1，0，0，0，0]。这个向量有助于比较文档。虽然这种技术在一些用例中是有帮助的，但是它具有一些限制，例如:不保持文档结构(不保持单词的顺序，而是仅仅计数)，并且它还具有稀疏性问题(向量中的大多数值都是零，这增加了时间复杂度并且增加了模型的偏差，以及停止词(例如‘and’，‘or’，‘is’，‘the’等)。)出现的次数比这句话多很多倍。因此，我们使用一些技术，如<strong class="lb iu">词干化和词汇化</strong>。我们还删除了停用词和在整个语料库中只出现过几次的罕见词。</p><h2 id="3bd4" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak">一个热编码</strong></h2><p id="edd5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如在频率向量中所讨论的，频繁出现的标记比较少出现的标记具有更大的幅度。因此，OHE 向量提供了一个布尔向量作为这个问题的解决方案，我们只用 1 和 0 填充向量。如果单词出现在文档中，我们放置 1(1 而不是计数)，否则放置 0。文档 2 可以表示为[1，1，0，1，1，1，1，1，1]。</p><p id="db13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种热编码也可以用来表示单词。1 代表我们想要表示的单词，0 代表其余的单词。单词“Alice”可以表示为[1，0，0，0，0，0，0，0]，或者我们也可以添加计数，因此“Alice”可以表示为[3，0，0，0，0，0，0，0](将在本博客的第 2 部分详细讨论这一点)。</p><h2 id="56b6" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak">词频/逆文档频</strong></h2><p id="e8ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，我们一直将每个文档视为一个独立的实体，而不考虑语料库的上下文。TF/IDF 是一种常见的技术，用于根据语料库上下文对文档中的标记频率进行归一化。TF/ID 代表两件事:</p><p id="7995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。术语频率</strong> <em class="oc"> tf(t，d): </em>术语(t)在文档(d)中出现的频率。如果我们用<code class="fe od oe of nt b"><em class="oc">f(t, d)</em></code>来表示原始计数，那么最简单的<em class="oc"> tf </em>方案就是<code class="fe od oe of nt b"><em class="oc">tf(t, d) = f(t, d)</em></code> <em class="oc"> </em>(下面讨论的其他技术)，让我们用<code class="fe od oe of nt b"><em class="oc">len(d)</em></code>来表示文档 d 中出现的总字数。例如，为了排列与查询“蓝天”最相关的文档，我们计算每个单词在每个文档中出现的次数。然而，由于每个文档的大小不同，所以比较一个单词在 10 个单词的文档和 1M 单词的文档中出现的次数是不公平的。因此，我们缩放<em class="oc"> tf </em>以防止长文档的偏差，如下<em class="oc"> : </em></p><p id="fc37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nt b"><strong class="lb iu"><em class="oc">tf(t, d) = f(t, d) / len(d)</em></strong></code></p><p id="1557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oc"> tf </em>调整和减少文档中最大重复字数<strong class="lb iu">计数</strong>的其他方法:</p><ul class=""><li id="5642" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu og my mz na bi translated">布尔频率:如果<em class="oc"> t </em>出现在<em class="oc"> d </em>中，则为<code class="fe od oe of nt b"><em class="oc">tf(t, d) = 1</em></code>，否则为 0</li><li id="2b3d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu og my mz na bi translated">根据文件长度调整的词频:<code class="fe od oe of nt b"><em class="oc">tf(t, d) = f(t, d)/len(d)</em></code></li><li id="fe95" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu og my mz na bi translated">对数标度频率:<code class="fe od oe of nt b"><em class="oc">tf(t, d) = log( 1 + f(t, d))</em></code></li><li id="9f53" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu og my mz na bi translated">增强频率:<code class="fe od oe of nt b"><em class="oc">tf(t, d) = 1 * f(t, d) / m</em></code>，其中 m 是在<em class="oc"> d </em>中出现次数最多的单词</li></ul><p id="ad79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2)逆文档频率:</strong>衡量一个术语的重要程度。IDF 减少出现在不同文档中的常用词的<strong class="lb iu">值</strong>。在我们前面的例子“蓝天”中，单词“the”是一个常用词，因此术语“频率”倾向于错误地强调具有较少值的重复单词的文档，例如“the”。作为一个解决方案，我们计算了文档总数<em class="oc"> (D) </em>除以<em class="oc"> n </em>的<em class="oc"> log() </em>，n 是带有<em class="oc"> t </em>的文档出现在:</p><p id="51cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nt b"><strong class="lb iu"><em class="oc">idf(t, D) = log(D / n)</em></strong></code></p><p id="af9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，TF/IDF 可以计算为:</p><p id="450f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nt b"><strong class="lb iu">tf-idf(t, d, D) = t(t, d) . idf(t, D)</strong></code></p><p id="ec2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只是在向量中添加 TF-IDF 分数，而不是频率计数或 OHE。</p><h2 id="4cd5" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">资源:</h2><ul class=""><li id="e6f4" class="ms mt it lb b lc mn lf mo li oh lm oi lq oj lu og my mz na bi translated"><a class="ae ky" href="https://www.oreilly.com/library/view/applied-text-analysis/9781491963036/ch04.html" rel="noopener ugc nofollow" target="_blank">Tony oje da、Rebecca Bilbro、Benjamin Bengfort 利用 Python 进行应用文本分析</a></li><li id="114d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu og my mz na bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf#:~:targetText=In%20information%20retrieval%2C%20tf%E2%80%93idf,in%20a%20collection%20or%20corpus." rel="noopener ugc nofollow" target="_blank">维基百科:TF-IDF </a></li><li id="51f3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu og my mz na bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Bag-of-words_model" rel="noopener ugc nofollow" target="_blank">维基百科:词汇袋</a></li></ul></div></div>    
</body>
</html>