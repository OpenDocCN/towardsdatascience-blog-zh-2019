<html>
<head>
<title>10 advanced concepts Python Intermediate Programmer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中级程序员应该知道的 10 个高级概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-topics-python-intermediate-programmer-should-know-3c865e8533d6?source=collection_archive---------1-----------------------#2019-04-30">https://towardsdatascience.com/10-topics-python-intermediate-programmer-should-know-3c865e8533d6?source=collection_archive---------1-----------------------#2019-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="57e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">想成为一名专业的 python 开发者，请阅读这篇博客，了解 python 中的 10 个高级概念。</h2></div><ol class=""><li id="5e84" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Python 中的 Everything Object 是怎样的？</li><li id="f736" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">理解(多重和嵌套)</li><li id="4e42" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">扩展关键字参数(*args，**kwargs)</li><li id="c363" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">闭包和装饰器</li><li id="44fe" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">生成器和迭代器协议</li><li id="a3b5" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">上下文管理器</li><li id="60a9" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">@staticmethod 和@classmethod</li><li id="6f8c" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">继承和封装</li><li id="d9b5" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">运算符重载</li><li id="dc8b" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">Python 包和程序布局</li></ol><p id="0852" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">我会逐一解释所有的话题。</p><blockquote class="lq lr ls"><p id="3b35" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">python 中的一切都是对象吗？</strong></p></blockquote><p id="3f26" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">字符串是对象。列表是对象。函数是对象。甚至模块也是对象。任何东西都是对象，因为它可以被赋给一个变量或者作为一个函数的参数传递。</p><p id="19b5" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">在 Python 中，任何可以(合法地)放在等号右边的东西都是(或创建)一个对象。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e859" class="mf mg iq mb b gy mh mi l mj mk">&gt; def hello():<br/>      print("say hello")</span><span id="0ce3" class="mf mg iq mb b gy ml mi l mj mk">&gt; hi = hello()</span><span id="5732" class="mf mg iq mb b gy ml mi l mj mk">&gt; hi()<br/>"say hello"</span><span id="541c" class="mf mg iq mb b gy ml mi l mj mk">&gt;hello()<br/>"say hello"</span></pre><h2 id="1005" class="mf mg iq bd mm mn mo dn mp mq mr dp ms km mt mu mv ko mw mx my kq mz na nb nc bi translated"><strong class="ak">对象:</strong></h2><ol class=""><li id="6195" class="kf kg iq kh b ki nd kk ne km nf ko ng kq nh ks kt ku kv kw bi translated">一个身份</li><li id="7f17" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks kt ku kv kw bi translated">一个值(可变或不可变)</li></ol><p id="2968" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> Mutable: </strong>当您更改项目时，id 仍然不变。字典，列表</p><p id="4ca1" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">不可变:</strong>字符串，整数，元组</p><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ni"><img src="../Images/bf3a1daad742d0ff7a1dfdc668e65071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ln1aDAYJ4R1BcSd7sGj7YA.png"/></div></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="a0ae" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">理解</strong></p></blockquote><p id="3ec7" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">创建集合和可迭代对象的简写语法。</p><ul class=""><li id="8524" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">列表理解:</em> </strong></li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8967" class="mf mg iq mb b gy mh mi l mj mk">[ expr(item) for item in iterable ]</span></pre><ul class=""><li id="544a" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">设定理解:</em> </strong></li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4bed" class="mf mg iq mb b gy mh mi l mj mk">{ expr(item) for item in iterable }</span></pre><ul class=""><li id="e479" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">字典理解:</em> </strong></li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c224" class="mf mg iq mb b gy mh mi l mj mk">{ key_expr:value_expr for item in iterable }</span></pre><ul class=""><li id="1584" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">生成器理解:</em> </strong></li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f3fe" class="mf mg iq mb b gy mh mi l mj mk">( expr(item) for item in iterable)</span></pre><ul class=""><li id="d4a3" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">用 If-从句理解:</em> </strong></li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b6a7" class="mf mg iq mb b gy mh mi l mj mk">[ expr(item) for item in iterable if predicate(item) ]</span></pre><ul class=""><li id="372a" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">多重理解:</em> </strong></li></ul><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5d93" class="mf mg iq mb b gy mh mi l mj mk">[(x,y) for x in range(10) for y in range(3)]</span></pre><ul class=""><li id="4cf3" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">嵌套理解:</em> </strong></li></ul><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="70a9" class="mf mg iq mb b gy mh mi l mj mk">[[y*3 for y in range(x)] for x in range(10)]</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="ea8e" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">扩展关键字参数</strong></p></blockquote><p id="287f" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">当在<strong class="kh ir"> Python </strong>中调用函数时，你经常不得不在使用<strong class="kh ir">关键字参数</strong>或位置参数<strong class="kh ir">参数</strong>之间做出选择。<strong class="kh ir">关键字参数</strong>经常可以用来使函数调用更加明确。当我们使用<strong class="kh ir">关键字参数</strong>时:我们经常会忽略<strong class="kh ir">参数</strong>的默认值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1da4" class="mf mg iq mb b gy mh mi l mj mk">Def function_name(arg1, arg2=1.0,):<br/>    BODY</span><span id="b294" class="mf mg iq mb b gy ml mi l mj mk">Arg1 =&gt; Positional Argument</span><span id="5c1f" class="mf mg iq mb b gy ml mi l mj mk">Arg2 =&gt; Keyword Argument</span></pre><ul class=""><li id="35fe" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">扩展的形式参数语法:</em> </strong></li></ul><p id="c7fa" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><em class="lp">自变量在功能</em> <strong class="kh ir"> <em class="lp">定义端。</em> </strong></p><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fcab" class="mf mg iq mb b gy mh mi l mj mk"><strong class="mb ir">How we use print, format function?</strong></span><span id="f33b" class="mf mg iq mb b gy ml mi l mj mk">Ex: <br/>&gt; print(“one”)</span><span id="26b5" class="mf mg iq mb b gy ml mi l mj mk">&gt; print(“one”, “two”)</span><span id="d80c" class="mf mg iq mb b gy ml mi l mj mk">We are passing any number of argument in print statement.</span></pre><p id="79c2" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">扩展参数的数据类型:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d0f2" class="mf mg iq mb b gy mh mi l mj mk">*args =&gt; tuple<br/>**kwargs =&gt; dict</span><span id="506b" class="mf mg iq mb b gy ml mi l mj mk"><strong class="mb ir">these arguments should be pass in sequence.</strong></span><span id="c38f" class="mf mg iq mb b gy ml mi l mj mk">Def func(arg1, arg2, *args, kwarg1, **kwargv):<br/>    print(type(*args))<br/>    print(*args)<br/>    print(type(**kwargv))<br/>    print(**kwargv)</span></pre><ul class=""><li id="da2a" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">扩展实际参数语法</em> </strong></li></ul><p id="290f" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><em class="lp">自变量在函数</em> <strong class="kh ir"> <em class="lp">调用方</em> </strong> <em class="lp">。</em></p><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9460" class="mf mg iq mb b gy mh mi l mj mk">&gt; print_args(*t)<br/>  1<br/>  2<br/>  (3, 4, 5)</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="7597" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">关闭和装饰</strong></p></blockquote><p id="b729" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">在开始闭包之前，我们应该了解局部函数。</p><ul class=""><li id="cb37" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">局部功能:</em> </strong></li></ul><p id="f151" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">函数内部的函数是局部函数。</p><ul class=""><li id="c477" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated">适用于专门的一次性功能</li><li id="7d34" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">有助于代码组织和可读性</li><li id="2bf4" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">类似于 lambdas，但更通用</li><li id="0a54" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">它可能包含多个表达式</li><li id="a3cc" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">可能包含语句</li></ul><p id="3c34" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">通过 LEGB 规则进行范围解析:</strong> <br/>在 Python 中，<strong class="kh ir"> LEGB 规则</strong>用于决定在范围解析中搜索名称空间的顺序。<br/>范围按照层级排列如下(最高到最低/最窄到最宽):</p><ul class=""><li id="25ac" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated">Local(L):在函数/类内部定义</li><li id="6730" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">Enclosed(E):在封闭函数内部定义(嵌套函数概念)</li><li id="04c0" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">全局(G):在最高层定义</li><li id="5041" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">内置(B):Python 内置模块中的保留名称</li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f0bf" class="mf mg iq mb b gy mh mi l mj mk">def func():    <br/>    def local_func():<br/>        a = 'hello, '<br/>        b = 'world'<br/>        return a + b<br/>    x = 1<br/>    y = 2<br/>    return x + y</span></pre><ul class=""><li id="43ac" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">返回功能:</em> </strong></li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="92b1" class="mf mg iq mb b gy mh mi l mj mk">def outer():<br/>    def inner():<br/>        print('inner')<br/>    return inner</span><span id="e004" class="mf mg iq mb b gy ml mi l mj mk">&gt; I = outer()<br/>&gt; I()<br/>"inner"</span></pre><ul class=""><li id="95de" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">闭包:</em> </strong></li></ul><p id="a519" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">维护对早期作用域中对象的引用。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9ac0" class="mf mg iq mb b gy mh mi l mj mk">def outer(x):<br/>    def inner(y):<br/>        return x+y<br/>    return inner<br/>&gt; add_plus3= outer(3)<br/>&gt; add_plus3(2)<br/>  5</span></pre><p id="34e4" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">我们可以使用 __closure__ 来验证函数是否是闭包。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ebc6" class="mf mg iq mb b gy mh mi l mj mk">i = outer()  <br/>&gt; i.__closure__</span></pre><ul class=""><li id="b2a3" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">装修工:</em> </strong></li></ul><p id="3810" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">修改和增强功能而不改变它们定义。实现为接受并返回其他可调用函数的可调用函数。</p><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oa"><img src="../Images/c8df8211522a22b2704bc500b47c6e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ta6RK3xP6GP8pYZ0SCW_yg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">decorator workflow</figcaption></figure><p id="144f" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">我们也可以创建作为装饰者的类和作为装饰者的实例。</p><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="0193" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">发生器和可迭代协议</strong></p></blockquote><ul class=""><li id="98c1" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp"> Iterable </em> : </strong>对象可以传递给内置的 iter()函数得到一个迭代器。</li><li id="edb3" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">迭代器</em> : </strong>对象可以传递给内置的 next()函数来获取下一项。</li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9709" class="mf mg iq mb b gy mh mi l mj mk">iterator = iter(iterable)</span><span id="ba77" class="mf mg iq mb b gy ml mi l mj mk">item = next(iterator)</span></pre><ul class=""><li id="4ec7" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">发电机:</em> </strong></li></ul><p id="2f91" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">Python 生成器是一种创建迭代器的简单方法。我们上面提到的所有开销都是由<strong class="kh ir"> Python </strong>中的<strong class="kh ir">生成器</strong>自动处理的。</p><p id="0fcd" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">一个<strong class="kh ir">生成器</strong>是一个函数，它返回一个我们可以迭代的对象(迭代器)(一次一个值)。</p><p id="32c1" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">如果一个函数包含至少一个<strong class="kh ir"> yield </strong>语句，它就成为一个生成器函数。</p><p id="e416" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">不同之处在于，当 return 语句完全终止一个函数时，yield 语句暂停该函数并保存其所有状态，然后在后续调用中继续执行。</p><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5692" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">为什么在 Python 中使用生成器？</strong></p><ul class=""><li id="efcf" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated">易于实施</li><li id="b2aa" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">内存高效</li><li id="c1f7" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">表示无限流</li><li id="a32e" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">流水线发电机</li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="acbb" class="mf mg iq mb b gy mh mi l mj mk">def PowTwoGen(max = 0):<br/>    n = 0<br/>    while n &lt; max:<br/>        yield 2 ** n<br/>        n += 1</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="915c" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir"> <em class="iq">上下文管理器</em> </strong></p></blockquote><p id="6332" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">上下文管理器</strong>是一个设计用于 with 语句的对象。</p><p id="8e0d" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">上下文管理器确保资源得到正确和自动的管理。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c922" class="mf mg iq mb b gy mh mi l mj mk">with context-manager:<br/>    context-manager.begin()<br/>    Body<br/>    context-manager.end()</span></pre><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi of"><img src="../Images/afcefaa989d687d3a515a4fe53362f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3awIGvbKdxa3mfdg9rX65w.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">context manager workflow</figcaption></figure><p id="cbb0" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">_ _ 回车 __() </strong></p><p id="e2e4" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">在进入 with 语句体之前调用</p><p id="373c" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">绑定到变量的返回值</p><p id="cd95" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">可以返回任何类型的值</p><p id="d87f" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">通常返回上下文管理器本身</p><p id="9d2c" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">_ _ 出口 __() </strong></p><p id="b7e1" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">当 with 语句体存在时调用</p><p id="026c" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">__exit__(self，exc_type，exc_val，exc_tb)</p><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="0719" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir"> @staticmethod，@classmethod </strong></p></blockquote><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7bc5" class="mf mg iq mb b gy mh mi l mj mk">class attributes versus instance attributes:</span><span id="cec4" class="mf mg iq mb b gy ml mi l mj mk">Class A:<br/>    CLASS_ATTRIBUTE = 1<br/>    Def __init__(slef, instance_attribute):<br/>        Self.instance_attribute = instance_attribute</span></pre><p id="bcd0" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">如果需要访问函数中的类属性，最好使用@classmethod。</p><p id="990b" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">如果你不需要使用 cls 对象，那么使用@static 方法。</p><p id="f4a7" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">与其他语言不同，在 python 中，静态方法可以在子类中被覆盖。</p><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi og"><img src="../Images/78dfd309296b185f44f674b617af9733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKYiUoqYXTAJIn7Ll1RnzQ.png"/></div></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="8c7a" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">继承和封装</strong></p></blockquote><ul class=""><li id="4bb9" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">传承</em> </strong>:</li></ul><p id="c727" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">继承</strong>是一个类获取另一个类的属性的机制。例如，一个孩子继承了他/她父母的特征。通过<strong class="kh ir">继承</strong>，我们可以重用现有类的字段和方法。因此，<strong class="kh ir">继承</strong>促进了可重用性，并且是 OOPs 的一个重要概念。</p><ul class=""><li id="6844" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">单一继承</em> : </strong></li></ul><p id="f19a" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">子类将拥有基类的所有功能，它还可以修改和增强。</p><p id="2e25" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">子类初始化器想要调用基类初始化器来使整个对象初始化有意义。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="194d" class="mf mg iq mb b gy mh mi l mj mk">class SubClass(BaseClass):</span></pre><p id="6710" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">调用其他类初始化器:</strong></p><ul class=""><li id="a50c" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated">其他语言自动调用基类初始化器</li><li id="0e3b" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">Python 对待 __init__()就像对待任何其他方法一样</li><li id="5a89" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">如果被覆盖，则不调用基类 __init__ ()</li><li id="4e8d" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">使用 super()调用基类 __init__()</li></ul><p id="962d" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> <em class="lp"> isinstance </em> </strong>(实例，类):判断一个对象是否属于指定的类型。</p><p id="ad45" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> <em class="lp"> Issubclass </em> ( </strong>子类，基类):确定一个类型是否是其他类型的子类。</p><ul class=""><li id="75ab" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir"> <em class="lp">多重继承:</em> </strong></li></ul><p id="504d" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">定义具有多个基类的类。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1eb9" class="mf mg iq mb b gy mh mi l mj mk">Class SubClass(Base1, Base2, …):</span></pre><p id="036f" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">python 怎么知道应该调用哪个基类函数？</p><p id="e545" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">Python 使用方法 Resolution Order 和 super 来做到这一点。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8cc7" class="mf mg iq mb b gy mh mi l mj mk">__bases__ =&gt; a tuple of base classes<br/>__mro__ =&gt; a tuple of mro ordering</span></pre><p id="e828" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">方法解析顺序</strong></p><p id="e7a4" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">确定方法名查找的顺序</p><ul class=""><li id="d5d4" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated">通常被称为“MRO”</li><li id="2443" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">方法可以在多个地方定义</li><li id="bff3" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">MRO 是继承图的一种排序</li><li id="06a4" class="kf kg iq kh b ki kx kk ky km kz ko la kq lb ks nx ku kv kw bi translated">其实很简单</li></ul><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oh"><img src="../Images/fcabf13c74745764ad3f67f423eda84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0l5A20SxbXY4BRGUqi1UTQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">MRO workflow</figcaption></figure><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oi"><img src="../Images/bc4305fd05835fc376b18407fd146813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDqghQ-GnkfTTXiLJ3bqdg.png"/></div></div></figure><ul class=""><li id="e120" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks nx ku kv kw bi translated"><strong class="kh ir">封装:封装:</strong></li></ul><p id="cedc" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">请参考本文，了解关于封装的更多细节。</p><div class="oj ok gp gr ol om"><a href="https://medium.com/@manjuladube/encapsulation-abstraction-35999b0a3911" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">python——封装存在吗？？</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">封装是将数据和对数据进行操作的功能打包到一个组件中，并限制…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div></div></a></div><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ov"><img src="../Images/ae549292044a7bab4e5165907e5448a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfZrDjgp5fB0t7A8hwdz_g.png"/></div></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="ef85" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir">操作员超载</strong></p></blockquote><p id="f49a" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">Python 运算符适用于内置类。但是同一个操作符对不同的类型表现不同。例如，+运算符将对两个数字执行算术加法，合并两个列表并连接两个字符串。</p><figure class="lw lx ly lz gt nj"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ow"><img src="../Images/ba9c633ed9a20e618d9317b0e2307b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6LJeXfYM2-SP0TK2Lc7pg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">Examples of operator overloading</figcaption></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><blockquote class="lq lr ls"><p id="f96e" class="lc ld lp kh b ki kj jr le kk kl ju lf lt lg lh li lu lj lk ll lv lm ln lo ks ij bi translated"><strong class="kh ir"> Python 包和程序布局</strong></p></blockquote><p id="2a74" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">包</strong>是一个可以包含其他模块的模块。</p><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ox"><img src="../Images/660438cb6f89bc7ed42070fa0dca964b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jO93j7pF7qVD1bq7a6Ey1Q.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">modules and packages</figcaption></figure><p id="fa05" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir">sys . path</strong>Python 搜索模块的目录列表。</p><p id="ccf5" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> PYTHONPATH </strong>列出添加到 sys.path 的路径的环境变量。</p><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oy"><img src="../Images/d063d2e32f96b05232909dd39b19f17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mbz1ejvwVyyacQA8I0QPQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">minimal package</figcaption></figure><p id="fb8b" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">1.包是包含其他模块的模块。</p><p id="025b" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">2.包通常被实现为包含特殊</p><p id="aecc" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">__init__。py 文件。</p><p id="e7f2" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">3.__init__。py 文件在导入包时执行。</p><p id="f2b6" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">4.包可以包含自己实现的子包</p><p id="5ec1" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">用 __init__。目录中的 py 文件。</p><p id="3e94" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">5.包的模块对象具有 __path__ 属性。</p><p id="01e4" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> <em class="lp">绝对导入:</em> </strong>使用完整路径导入模块。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="294a" class="mf mg iq mb b gy mh mi l mj mk">from test.test import Tester</span></pre><p id="0014" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> <em class="lp">相对导入:</em> </strong>使用相对路径导入同一个包中的模块。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a609" class="mf mg iq mb b gy mh mi l mj mk">from .test import Tester</span></pre><p id="4430" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated"><strong class="kh ir"> __all__: </strong>通过模块导入*导入的属性名称列表</p><figure class="lw lx ly lz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oz"><img src="../Images/7ac2c0a9ff92cfd496f8ef0a4477e7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Th01Wq7qu8WPF11SmfoX8w.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">Recommended project structure</figcaption></figure><p id="4081" class="pw-post-body-paragraph lc ld iq kh b ki kj jr le kk kl ju lf km lg lh li ko lj lk ll kq lm ln lo ks ij bi translated">如果你喜欢这篇文章，欢迎你来<a class="ae pa" href="https://medium.com/@agrawal-pulkit" rel="noopener">关注</a>，这样你就不会错过未来的新更新。</p></div></div>    
</body>
</html>