<html>
<head>
<title>Teach Yourself SQL — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自学 SQL —第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/teach-yourself-sql-part-ii-c0916dd8d17d?source=collection_archive---------21-----------------------#2019-11-03">https://towardsdatascience.com/teach-yourself-sql-part-ii-c0916dd8d17d?source=collection_archive---------21-----------------------#2019-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/44b2c66f3d6e3af4816609f0994b949e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wodIhZB17F96T37sMvZhdw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Bucketed data</figcaption></figure><div class=""/><p id="cd15" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">几周前，我决定写更多我作为数据分析师所学到的关于 SQL 和分析思维的东西。我在一家名为<a class="ae ld" href="http://springboard.com?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=teach_yourself_sql&amp;utm_term=riley_article" rel="noopener ugc nofollow" target="_blank">的教育科技初创公司</a>工作，该公司致力于让学生在数据科学和 UX 设计等热门领域找到工作。</p><p id="0f5d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文是这个系列的第二篇文章(见第一部分<a class="ae ld" href="https://medium.com/@rileypredum/teach-yourself-sql-part-i-b85cb95aade3" rel="noopener">此处</a>)。第一部分的目标是让您了解模式分析，并熟悉示例数据库中的基本 SQL。</p><p id="5325" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本文中，我将介绍以下内容:</p><ol class=""><li id="58b5" class="le lf ji kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">使用子查询更深入地研究 SQL。</li><li id="9fe2" class="le lf ji kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">将事情联系到业务示例案例，以及如何从战略上对查询结果采取行动。</li><li id="50a5" class="le lf ji kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">展示一些例子，说明如何有效地用可视化表达这些查询的结果。</li></ol><h2 id="8cb6" class="ls lt ji bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">目标 1:总结和更多 SQL</h2><p id="caf8" class="pw-post-body-paragraph kf kg ji kh b ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc im bi translated">回顾一下第一部分中的内容，我们在查询编辑器中设置了模式，并对 Yammer 实验表运行了一些基本的查询，使用了 SQL 的以下功能:SELECT、FROM、LIMIT、COUNT、GROUP BY、ORDER BY 以及 MIN 和 MAX。</p><p id="1558" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些对于获取汇总统计数据和理解您的数据非常有用。接下来让我们试着从数据中找出一个更复杂的商业问题！但是在我开始之前，我想分享一个提高效率的小技巧:</p><p id="3ea7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在大多数 SQL 编辑器和客户端(MySQL Workbench，我们一直使用的 GUI 模式分析平台，以及其他软件)中，查询的结尾用分号(；).在下一节中，我将写出几个查询，用注释(一个最佳实践)向您展示您可以在一个页面中有多个查询，并运行您想要的任何一个查询(在突出显示它或光标位于 SELECT 和分号之间的任何位置时运行<code class="fe mq mr ms mt b">CTRL + Enter</code>,将只运行那个查询)。</p><p id="3d5b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有一个例子来说明我的意思:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="ce87" class="ls lt ji mt b gy nc nd l ne nf">-- This subquery produces the event type counts<br/>SELECT <br/>      events.event_type AS event_type,<br/>      COUNT(1) AS number_of_occurrences<br/>FROM <br/>      tutorial.yammer_events AS events<br/>GROUP BY<br/>      events.event_type<br/>;</span><span id="960c" class="ls lt ji mt b gy ng nd l ne nf">-- This subquery produces the count of actions by location<br/>SELECT <br/>      events.location,<br/>      COUNT(1) AS number_of_occurrences<br/>FROM <br/>      tutorial.yammer_events AS events<br/>GROUP BY<br/>      events.location<br/>ORDER BY<br/>      COUNT(1) DESC<br/>;</span><span id="a4ce" class="ls lt ji mt b gy ng nd l ne nf">-- This grabs the count of actions by device<br/>SELECT <br/>      events.device,<br/>      COUNT(1) AS number_of_occurrences<br/>FROM <br/>      tutorial.yammer_events AS events<br/>GROUP BY<br/>      events.device<br/>ORDER BY<br/>      COUNT(1) DESC<br/>;</span></pre><p id="5c03" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">两个破折号是单行注释。若要注释掉多行，请以“/*”开始，以“*/”结束。运行上述查询并检查输出，我们看到大多数操作都是约定。在这些数据中，美国、日本和德国是行动的前三名。最常见的设备是 Macbook Pro，其次是联想 Thinkpad，最后是 Macbook Air。</p><h2 id="1a1f" class="ls lt ji bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">目标 2:将它与业务示例案例联系起来</h2><p id="bd76" class="pw-post-body-paragraph kf kg ji kh b ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc im bi translated">将这个问题与一个商业案例联系起来:如果有一个 bug 同时影响了 OS X 和 Windows 的用户，那么技术团队最好先修复 OS X 的 bug，然后在修复 Windows 的时候再推出，因为这是可能受到影响的最大的两个用户群。</p><p id="2079" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个更详细的表也可能存储操作系统版本，这可以帮助开发人员确切地知道要修补什么版本。如果那些数据是可用的，当优先考虑首先解决哪个 OS 版本时，可以应用与上述类似的逻辑。</p><p id="b272" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们想弄清楚打开电子邮件的用户是否会表现出其他行为呢？我们需要探索更多，然后才能尝试找出要寻找的模式。</p><p id="fed7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看看用户采取的平均行动次数是多少。这将让我们对预期的参与量有所了解:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="8991" class="ls lt ji mt b gy nc nd l ne nf">SELECT<br/>      user_id,<br/>      COUNT(1)<br/>FROM <br/>      tutorial.yammer_events AS events<br/>GROUP BY<br/>      user_id,<br/>      event_name<br/>;</span></pre><p id="e219" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请记住，事件表是一个实际的事件表。因此，我们需要做的就是统计用户 id 并按用户 id 分组。等等，我们不是想要普通的吗？</p><p id="ecf5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们引入子查询的概念来获得该值！</p><p id="9e4b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">子查询是查询中的一个查询。我花了一段时间才明白如何使用它们，直到我的同事解释了一个启发法，帮助我建立了正确的思维模式。之后就一拍即合了。</p><p id="dc32" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当您说 SELECT something FROM table 时，您正在查询该表并选择 SELECT 子句中指定的列。子查询返回所谓的<strong class="kh jj">派生表</strong>、<strong class="kh jj">、</strong>，这只是一种说法，即查询的输出是一个只在查询期间持续的表。就像查询任何表一样，您可以从该表进行查询，该表本身就是一个查询。我将从一个例子开始，这个例子在实践中没有意义，但是以一种简单的方式说明了这个概念。</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="9a3b" class="ls lt ji mt b gy nc nd l ne nf">SELECT<br/>      user_id<br/>FROM<br/>(<br/>      SELECT<br/>            user_id<br/>      FROM <br/>            tutorial.yammer_events AS events<br/>) AS example_derived_table</span><span id="d06c" class="ls lt ji mt b gy ng nd l ne nf">;</span></pre><p id="a075" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这应该是清楚的，并说明了为什么我学会了制表(即缩进)的方式。左括号和右括号在一条线上，所以你可以很容易地知道子查询从哪里开始和结束(相信我，有 10 或 20 个子查询，这是至关重要的！).</p><p id="74d1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个查询没有任何意义，但是它说明了这一点:我在 events 表中派生出一个用户 ID 表，并从中提取用户 ID。</p><p id="aea8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您能猜到我们如何使用它来获得用户使用我们之前的 COUNT 查询所采取的平均操作数吗？</p><p id="0b39" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">获取用户的动作计数，然后从中取这些计数的平均值！</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="afc4" class="ls lt ji mt b gy nc nd l ne nf">SELECT<br/>      AVG(action_count)<br/>FROM<br/>(<br/>      SELECT<br/>            user_id,<br/>            COUNT(1) AS action_count<br/>      FROM <br/>            tutorial.yammer_events AS events<br/>      GROUP BY<br/>            user_id<br/>) AS example_derived_table</span><span id="320b" class="ls lt ji mt b gy ng nd l ne nf">;</span></pre><p id="b40d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个返回 34.9！第一个用户只有几个，所以我怀疑有一个巨大的行动传播，实际上通常有高度参与和勉强参与的用户。所以让我们来数一数吧！</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="bcf5" class="ls lt ji mt b gy nc nd l ne nf">SELECT<br/>      action_count,<br/>      COUNT(1)<br/>FROM<br/>(<br/>      SELECT<br/>            user_id,<br/>            COUNT(1) AS action_count<br/>      FROM <br/>            tutorial.yammer_events AS events<br/>      GROUP BY<br/>            user_id<br/>) AS example_derived_table<br/>GROUP BY<br/>      action_count<br/>ORDER BY<br/>      action_count<br/>;</span></pre><p id="62f9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将返回给我们动作的数量。最常见的是单个行动，这很有意义，因为少行动比多行动更容易。</p><p id="6979" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的子查询示例中，我在 FROM 子句中进行了子查询。但是可以在任何子句中进行子查询。我通常会在 JOIN 子句中编写一个子查询，因为我想将一些被操作的数据连接回某个基表。</p><h2 id="1df5" class="ls lt ji bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">目标 3:有效的可视化</h2><p id="8b80" class="pw-post-body-paragraph kf kg ji kh b ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc im bi translated">通常，制作简单、易读的图表向企业的利益相关者传达信息是最有效的。假设你在一个产品分析团队工作，你的任务是展示用户参与度的分布。总共有多少用户执行 x 个操作？</p><p id="0f12" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经有了产生这个结果的查询。然后，您可以在模式下，或者在将数据提取为 CSV 格式并导入 Python、Excel 或您喜欢的任何其他工具之后，用结果数据制作一个条形图！</p><p id="b0a2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在模式下，您只需使用您编写的查询，然后单击图表按钮并选择一个条形图。将从查询中导出的列拖动到 X 轴和 Y 轴上，这就是您的图表！</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/665589581b66c7db6e99454a63c273c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40MmnUFIORGsXzpUlSBLdg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">The count of users who performed X number of actions</figcaption></figure><p id="83f0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这向我们展示了执行一个动作的用户数量巨大，而执行更多动作的用户数量却少得多。不过 X 轴并不理想，所以让我们重新查看一下查询，使用 CASE 语句和谓词逻辑为 X 轴创建更好的数据存储。这将允许我们为了可读性和简洁性而截断数据。</p><p id="194b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是在 X 轴上存储数据的 SQL 查询:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="e968" class="ls lt ji mt b gy nc nd l ne nf">SELECT<br/>      CASE<br/>        WHEN action_count BETWEEN 0 AND 10 THEN '[0-10]'<br/>        WHEN action_count BETWEEN 10 AND 20 THEN '[10-20]'<br/>        WHEN action_count BETWEEN 20 AND 30 THEN '[20-30]'<br/>        WHEN action_count BETWEEN 30 AND 40 THEN '[30-40]'<br/>        WHEN action_count BETWEEN 40 AND 50 THEN '[40-50]'<br/>        WHEN action_count BETWEEN 50 AND 60 THEN '[50-60]'<br/>        WHEN action_count BETWEEN 60 AND 70 THEN '[60-70]'<br/>        WHEN action_count BETWEEN 70 AND 80 THEN '[70-80]'<br/>        WHEN action_count BETWEEN 80 AND 90 THEN '[80-90]'<br/>        WHEN action_count BETWEEN 90 AND 100 THEN '[90-100]'<br/>      END AS action_count_bucketed,       <br/>      SUM(number_of_users)<br/>FROM<br/>(<br/>    SELECT<br/>          action_count,<br/>          COUNT(1) AS number_of_users<br/>    FROM<br/>    (<br/>          SELECT<br/>                user_id,<br/>                COUNT(1) AS action_count<br/>          FROM <br/>                tutorial.yammer_events AS events<br/>          GROUP BY<br/>                user_id<br/>    ) AS example_derived_table<br/>    GROUP BY<br/>          action_count<br/>    ORDER BY<br/>          action_count<br/>) AS case_table<br/>GROUP BY<br/>      action_count_bucketed<br/>LIMIT 10<br/>;</span></pre><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/44b2c66f3d6e3af4816609f0994b949e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wodIhZB17F96T37sMvZhdw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Bucketed data</figcaption></figure><p id="0a1a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好多了！使用 case 语句并捕获值的范围，我能够简化这个图表。没有必要知道大约 20 个用户执行了 98 个动作。说 120 执行了 90 到 100 个动作就“够好”了！永远记住 80/20 法则，多少是足够的信息。</p><p id="9cd8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这张图表背后的故事是，你可以看到大多数用户并不十分投入，只有少数核心群体处于 10-20 到 30-40 个行动区间。下一步是使用日期时间列<code class="fe mq mr ms mt b">occured_at</code>来讲述一个关于这些行为何时发生的更有趣的故事，并查看重要的产品参与度指标，如日活跃用户(DAU)、周活跃用户(WAU)等。</p><p id="94a7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本系列的下一部分中，我将更深入地研究如何使用日期时间值，敬请关注！</p><p id="a38c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你觉得这篇文章有用或者学到了新的东西，<a class="ae ld" href="https://www.patreon.com/rileypredum" rel="noopener ugc nofollow" target="_blank">考虑捐赠</a>任何数量来支付给下一个学习者！</p><p id="de5f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">感谢阅读和快乐编码！</p><p id="5eb4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">奢侈的生活</p></div></div>    
</body>
</html>