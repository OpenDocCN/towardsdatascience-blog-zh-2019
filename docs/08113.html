<html>
<head>
<title>Uncommon Data Cleaners for your Real-World Machine or Deep Learning Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于真实世界机器或深度学习项目的不寻常的数据清理器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/uncommon-data-cleaners-for-your-real-world-machine-or-deep-learning-project-f926d8ecb258?source=collection_archive---------36-----------------------#2019-11-06">https://towardsdatascience.com/uncommon-data-cleaners-for-your-real-world-machine-or-deep-learning-project-f926d8ecb258?source=collection_archive---------36-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/96857690612d0a9768f6f715708ffb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*Wk6ClyZebUvFC38s_UEBog.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Cleaning Tools</figcaption></figure><h1 id="3ac9" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="88b9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">数据清理是您的实体课程或在线课程中简要涉及的一个主题。然而，在您作为数据工程师或数据科学家的工作中，您将花费大量时间准备(预处理)数据，以便可以将数据输入到您的模型中。</p><div class="lx ly gp gr lz ma"><a rel="noopener follow" target="_blank" href="/what-70-of-data-science-learners-do-wrong-ac35326219e4"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">70%的数据科学学习者做错了什么</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">在大学工程课程中，我的头反复撞在 2 米长的金属杆上，从中吸取了教训</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">towardsdatascience.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo jv ma"/></div></div></a></div><blockquote class="mp"><p id="fcb7" class="mq mr it bd ms mt mu mv mw mx my lw dk translated">企业数据科学仍然是一个新领域。许多学者还没有为真正的企业解决真正的问题。因此，他们以一种脱离数据和商业背景的方式教授教科书算法。这可能是智力上的乐趣。但是，如果学生认为这些课程为他们成为数据科学家做好了准备，那他们就错了。</p></blockquote><p id="9bf7" class="pw-post-body-paragraph kz la it lb b lc mz le lf lg na li lj lk nb lm ln lo nc lq lr ls nd lu lv lw im bi translated"><strong class="lb iu"> Paso </strong>将提供你清理数据所需的许多工具，但不是全部。</p><p id="659f" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">仅仅因为<strong class="lb iu">帕索</strong>提供了一个工具并不意味着你应该在你的数据集上使用它。例如，删除具有高密度 nan 的行将导致更差的损失度量或不希望的偏差，但并非总是如此。</p><p id="fa4d" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">不同清洗策略(管道)的迭代是<strong class="lb iu"> Paso </strong>的基本目标。讨论分为以下几个主要部分:</p><ol class=""><li id="d4a3" class="nj nk it lb b lc ne lg nf lk nl lo nm ls nn lw no np nq nr bi translated">首先，我们用一个<strong class="lb iu"> Paso </strong>输入器加载<code class="fe ns nt nu nv b">boston</code>数据集。它具有相对少的行数，同时具有少于十个特征，以产生快速清洁。</li><li id="7201" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw no np nq nr bi translated">接下来，我通过管理相对干净的<code class="fe ns nt nu nv b">boston</code>数据集来演示每一个清理器。</li><li id="a226" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw no np nq nr bi translated">最后，我们总结一下<strong class="lb iu"> Paso'' </strong>数据清理器以及我们对未来文章和<strong class="lb iu"> Paso </strong>版本的计划。</li></ol><div class="lx ly gp gr lz ma"><a href="https://medium.com/@dr.bruce.cottman/pasos-offering-of-logging-and-parameter-services-for-your-python-project-c3ae2fd6869a" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">paso 为您的 Python 项目提供日志记录和参数服务</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">paso 为您的 Python 项目提供日志记录和参数服务</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">paso 为您的 Python Projectmedium.com 提供日志记录和参数服务</p></div></div><div class="mj l"><div class="ob l ml mm mn mj mo jv ma"/></div></div></a></div><p id="0c5f" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">正如我们在上面标题为<a class="ae oc" href="https://medium.com/@dr.bruce.cottman/pasos-offering-of-logging-and-parameter-services-for-your-python-project-c3ae2fd6869a" rel="noopener"> <strong class="lb iu"> <em class="od">的文章中看到的，paso 为您的 Python 项目</em></strong></a><strong class="lb iu"><em class="od"/></strong>提供日志记录和参数服务，我们应该启动<strong class="lb iu"> paso </strong>服务。</p><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="263f" class="om kc it nv b gy on oo l op oq">import pandas as pd<br/>from paso.base import Paso,Log,PasoError<br/>from loguru import logger<br/>session = Paso(parameters_filepath='../parameters/default-lesson.2.yaml').startup()</span></pre><p id="251e" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们将使用<code class="fe ns nt nu nv b">Inputer,</code>,只是说明它是一个通用类，用于将数据输入到<strong class="lb iu"> pandas </strong> dataframe 中。描述文件描述的数据集:<code class="fe ns nt nu nv b">city.yaml</code>。在下面的媒体文章中会更详细地讨论<code class="fe ns nt nu nv b">Inputer</code>和描述文件:</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/@dr.bruce.cottman/part-1-balancing-and-augmenting-structured-data-4ade0df38662" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">第 1 部分:平衡和扩充结构化数据</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">数据扩充很重要，因为它从我们当前现有的数据集生成(准确地)人工数据。的…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="or l ml mm mn mj mo jv ma"/></div></div></a></div><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="89ad" class="om kc it nv b gy on oo l op oq">from paso.pre.inputers import Inputers<br/>dataset_name = 'boston'<br/>inputer = Inputers(description_filepath='../descriptions/pre/inputers/'+dataset_name+'.yaml')<br/>dataset = inputer.transform()<br/>inputer.target</span><span id="e3b8" class="om kc it nv b gy os oo l op oq">'MEDV'</span></pre><h1 id="cf2f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">管理数据集</h1><p id="2cd7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">通常情况下，我们获取数据并必须清理它。这样的数据集是专有的。毕竟，没有人愿意向公众展示他们的肮脏数据(呻吟)。</p><p id="c20c" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">为了展示这些数据清理器是如何工作的，我们可以找点乐子，整理一个干净的数据集。</p><h1 id="9edb" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">清除程序:缺少值</h1><p id="379a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">检测和纠正缺失值和异常值(好的或坏的)是一个不断发展的研究领域。我们将在关于<strong class="lb iu">Paso</strong>T20】scaler 的文章中讨论异常值。对于本文，我们将只关注丢失的值。</p><p id="ebd9" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">不同的值可以表示缺少一个值。举个例子，</p><ul class=""><li id="9b01" class="nj nk it lb b lc ne lg nf lk nl lo nm ls nn lw ot np nq nr bi translated"><code class="fe ns nt nu nv b">999</code>在某些功能中可能表示“未回答”。</li><li id="2ac4" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw ot np nq nr bi translated"><code class="fe ns nt nu nv b">NA</code>可能表示不适用于此功能/记录。</li><li id="64b0" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw ot np nq nr bi translated"><code class="fe ns nt nu nv b">-1</code>可能意味着缺少此功能/记录。</li><li id="e3a9" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw ot np nq nr bi translated">诸如此类。</li></ul><p id="5485" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在这里你可以找到更多关于缺失数据的熊猫指南的细节。</p><p id="7053" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">对于第一个显示的 cleaner，我们添加了特性<code class="fe ns nt nu nv b">asv</code>，它具有所有相同的值<code class="fe ns nt nu nv b">999</code>。</p><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="bc93" class="om kc it nv b gy on oo l op oq">from paso.pre.cleaners import Cleaners<br/>c = Cleaners()<br/>dataset['asv'] = 999.0<br/>c.values_to_nan(dataset,values=[999.,11999.],inplace=True)<br/>dataset.head()</span></pre><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi ou"><img src="../Images/fddc2f303e9041f2d1b48c3c090ebfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aEE3I6GkTgJZOP61S0pnw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">c.values_to_nan on dataset</figcaption></figure><p id="04a6" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">该清洁剂，<code class="fe ns nt nu nv b">c.values_to_nan</code>将所有<code class="fe ns nt nu nv b">999</code>值更改为<code class="fe ns nt nu nv b">NaN</code>。还要注意的是，作为<code class="fe ns nt nu nv b">inplace=True</code>，数据集是自己改变的，通过避免复制<code class="fe ns nt nu nv b">dataset</code>来节省内存。</p><h1 id="b61d" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">清洁器:计算比率</h1><p id="82ef" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">缺失值(观察值)比率较大的行在统计上不相关。同样，您可能希望<strong class="lb iu">估算</strong>缺失值，即将缺失值更改为其他值。</p><p id="3718" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">每行缺失值的数量是信息，这本身表明它应该是该数据集的一个新特性。</p><p id="9c42" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">使用此<code class="fe ns nt nu nv b">Cleaner</code>，不删除带有<code class="fe ns nt nu nv b">NaN</code>的行，而是为每一行计算 number _ of _ nulls/total _ row _ count，并将一个新特征<code class="fe ns nt nu nv b">NaN_ratio</code>添加到返回的<strong class="lb iu"> pandas </strong>数据帧中。</p><p id="78c7" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们将再次使用同一个<code class="fe ns nt nu nv b">Cleaner</code>实例<code class="fe ns nt nu nv b">c</code>。同样，让我们通过将第一行的第一个和第二个特性设置为<code class="fe ns nt nu nv b">NaN</code>来对<code class="fe ns nt nu nv b">dataset</code>进行更多的修改。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi oz"><img src="../Images/0eb48f965e69a9916aa7cb51c4400f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HDiTE0WiipWm1S9bs5wlw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Cleaner calculate_NaN_ratio transforming dataset</figcaption></figure><p id="3222" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">注意这里有一个新的特性，<code class="fe ns nt nu nv b">NaN_ratio</code>。正如我们所料，第一行的<code class="fe ns nt nu nv b">NaN/total_row_count</code>比率不同于第二行和后面的行。</p><p id="3ce3" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated"><code class="fe ns nt nu nv b">Cleaner</code>属性<code class="fe ns nt nu nv b">column_missing_value_ratio</code>包含每个特征的缺失值比率。提示:您可以在堆叠合奏中使用这些。我们将在另一篇文章中讨论这个问题。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pa"><img src="../Images/2a7515b6f2c9dfe04de696f184a699a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwsBcDmg9BgGqJ4WSVUcCQ.png"/></div></div></figure><h1 id="f8e2" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">估算:将 NaN 更改为值</h1><p id="fcd8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">将<code class="fe ns nt nu nv b">NaN</code>设置为最佳近似值是您数据清理工作的关键，并进一步降低您的预测准确性和能力。关于这个主题的一篇流行文章:</p><div class="lx ly gp gr lz ma"><a rel="noopener follow" target="_blank" href="/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">弥补缺失数据的 6 种不同方法(数据插补，附实例)</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">统计估算数据集中缺失值的常用策略。</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">towardsdatascience.com</p></div></div><div class="mj l"><div class="pb l ml mm mn mj mo jv ma"/></div></div></a></div><blockquote class="pc pd pe"><p id="ffdd" class="kz la od lb b lc ne le lf lg nf li lj pf ng lm ln pg nh lq lr ph ni lu lv lw im bi translated">由于各种原因，许多现实世界的数据集可能包含缺失值。它们通常被编码为名词、空格或任何其他占位符。使用具有大量缺失值的数据集来训练模型会极大地影响机器学习模型的质量。一些算法，如 scikit-learn 估计器，假设所有的值都是数字的，并且拥有有意义的值。<br/>处理这个问题的一个方法是去掉有缺失数据的观测值。但是，您可能会丢失包含有价值信息的数据点。更好的策略是<strong class="lb iu">估算</strong>缺失值。换句话说，我们需要从数据的现有部分推断出那些缺失的值</p></blockquote><p id="fe54" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">另一篇关于归因的文章:</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/ibm-data-science-experience/missing-data-conundrum-exploration-and-imputation-techniques-9f40abe0fd87" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">缺失数据难题:探索和插补技术</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">为什么缺少数据</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="pi l ml mm mn mj mo jv ma"/></div></div></a></div><p id="36f0" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">各国:</p><blockquote class="pc pd pe"><p id="13e5" class="kz la od lb b lc ne le lf lg nf li lj pf ng lm ln pg nh lq lr ph ni lu lv lw im bi translated">为了让我们充分理解缺失数据的重要性，我们需要全面地确定缺失数据发生的原因。第一步是了解你的数据，更重要的是了解数据收集过程。这可以导致减少数据收集错误的可能性。缺失数据的性质或机制可以分为三大类。<br/> 1)完全随机缺失(MCAR) <br/> 2)随机缺失(MAR) <br/> 3)非随机缺失(MNAR</p></blockquote><p id="52fe" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们提供了估算策略的大杂烩，如<code class="fe ns nt nu nv b">Imputers().imputers()</code>所示。我建议您阅读这些和其他关于输入缺失值的文章，这样您就可以最好地使用这些工具。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pj"><img src="../Images/2611b0412b8b4d05f334423401b1f05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQ5mAooQjOpBeeNInXPsDg.png"/></div></div></figure><p id="340d" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们决定在给定的特性列表上进行转换，因为估算策略会随着特性子集的变化而变化。</p><p id="1a91" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">注意，极端梯度推进(<code class="fe ns nt nu nv b">xgboost</code>)将根据所用的训练损失函数，自动学习缺失数据的最佳(不能证明是最佳，但实际上<em class="od">良好</em> <em class="od">足够</em>)插补值。</p><p id="20c4" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">作者在其名称中使用了<code class="fe ns nt nu nv b">eXtreme </code>,主要是因为这种能力。它是一个工作非常好的黑匣子，你可以通过研究源代码来打开它。</p><p id="af6c" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我建议你先试试<code class="fe ns nt nu nv b">xgboost</code>,然后用这里显示的估算和其他数据清理器来提高你的预测。</p><p id="7733" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">这里，我将使用一个简单的<code class="fe ns nt nu nv b">most_frequent</code>策略，因为它处理分类和连续特征类型。</p><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="792a" class="om kc it nv b gy on oo l op oq">imputer_file = “../descriptions/pre/cleaners/most_frequent_impute.yaml”<br/>imp = Imputers(description_filepath = imputer_file)<br/>imp.transform(dataset)</span></pre><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pk"><img src="../Images/a134962d6f03d3ad6972e67e9f30f24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vi26UaF0pmu4HcKXit59-w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">first 4 rows of dataset after imputation. Notice, fist row of CRIM and ZN havechanged from NAN</figcaption></figure><h1 id="6ab6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">删除 _ 重复 _ 要素</h1><p id="713c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在机器学习竞赛中，你很少会看到两个或更多具有相同值的特征。然而，您几乎总是会在拥有大型和/或多个数据库和/或 ot 数据仓库和/或数据湖的企业中看到它。</p><p id="5b74" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">随着企业数据库或数据湖的老化，不同的人添加不同的数据源，重复的特性是相当标准的。</p><p id="c95b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">如果一个要素与另一个要素具有相同的索引值，则应删除其中一个要素。重复特征是多余的，并且没有预测能力。</p><p id="af05" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated"><code class="fe ns nt nu nv b">Cleaner delete_Duplicate_Features</code>将多余的特征减少为一个独特的特征。</p><p id="7260" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">注意，任何<code class="fe ns nt nu nv b">NaNs</code>在被传递给这个方法之前都会被从数据集中删除，根据定义，Python 中的<code class="fe ns nt nu nv b">NaN</code>不等于另一个<code class="fe ns nt nu nv b">NaN</code>。早先，我们遇到了可以删除、替换或<code class="fe ns nt nu nv b">Impute</code> <code class="fe ns nt nu nv b">NaN</code>值的数据清理器。</p><p id="5de3" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们将创建特征<code class="fe ns nt nu nv b">CRIM1</code>和<code class="fe ns nt nu nv b">CRIM2</code>，它们的值与<code class="fe ns nt nu nv b">CRIM</code>相同。</p><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="5fa3" class="om kc it nv b gy on oo l op oq">dataset['CRIM1'] = dataset['CRIM12'] = dataset['CRIM']<br/>dataset.head(n=2)</span></pre><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pa"><img src="../Images/2eddd8b785d80a76cfaeac9be1f9ebc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yh1QIhNP5rbVjGxPkJCpEQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Added CRIM1 and CRIM2 features</figcaption></figure><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="9c11" class="om kc it nv b gy on oo l op oq">c.delete_Duplicate_Features(dataset, inplace=True)<br/>dataset.head(n=2)</span></pre><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pl"><img src="../Images/afc61cd7ed33d09813225cd63a3af527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjVh97Oyh3BU0a1XEDZrTg.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Deleted CRIM1 and CRIM2 features</figcaption></figure><p id="c987" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">不出所料，<code class="fe ns nt nu nv b">delete_Duplicate_Features </code>删除了功能<code class="fe ns nt nu nv b">CRIM1 </code>和<code class="fe ns nt nu nv b">CRIM2.</code></p><h1 id="600e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">删除具有单一唯一值的要素</h1><p id="20e8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">将常数存储在数据中是常见的做法。常数显示为具有唯一值的特征/列。</p><p id="a785" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated"><code class="fe ns nt nu nv b">NaN</code>为空值，因此不是常量或值。</p><p id="74b1" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">该方法查找所有只有一个唯一值的特征。值之间的变化为零。所有这些特征都从数据帧中删除，因为它们没有预测能力。</p><p id="9181" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在这里，我将一个常量放入数据集中，并用<code class="fe ns nt nu nv b">delete_Features_with_Single_Unique_Value.</code>删除它</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pm"><img src="../Images/849477cf7f1951226ba10ab4b843691b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZlL9DFiZ4SPWwoY1bur-w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">delete_Features_with_Single_Unique_Value</figcaption></figure><h1 id="a2e5" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">删除具有所有唯一值的要素</h1><p id="9d11" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当一个要素的每个值都不相同时，它在回归任务中只具有预测值，并且这些值必须是浮点型或整数型。</p><p id="fffc" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">商品的 SKU、id 或名称是字符串或对象类型，没有预测能力，只会拖学习者的后腿。应该从数据集中移除这些要素。</p><p id="7f9b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在这个例子中，我将索引变成一个 ID，这样我就可以删除它。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pn"><img src="../Images/f7e654de60c0bedc2b147b1b43c89c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFhuIoGEHL7TOmvQYLH5rg.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">delete_Features_with_All_Unique_Values</figcaption></figure><h1 id="e54c" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">特征 _ 统计</h1><p id="3a8a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><code class="fe ns nt nu nv b">Cleaner.feature_Statistics</code>将计算每个特征的一组预定统计数据，并返回一个数据帧。</p><p id="7363" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">这组统计数据如下所示:</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi po"><img src="../Images/875fb647807be3e1e4868df74d132cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JZsjRmy6TjggQ9gkquq0w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk"><code class="fe ns nt nu nv b">Cleaner.feature_Statistics</code></figcaption></figure><p id="697c" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">这种方法是一种诊断工具(<code class="fe ns nt nu nv b">concat = False</code>)，用于确定标准偏差或任何其他统计数据是否太小，从而没有显著的预测能力。</p><p id="7351" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">它还可以添加到数据集(<code class="fe ns nt nu nv b">concat=True</code>)，其中统计信息部分描述了行值的分布。特征必须是数字(整数或浮点数)。</p><p id="820b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">您可能希望也可能不希望目标成为分布的一部分。由于<strong class="lb iu">测试</strong>没有目标，该目标不应该是<strong class="lb iu">训练</strong>数据集中分布的一部分，因为您正在将<em class="od">目标泄露</em>到<strong class="lb iu">训练</strong>数据集中。</p><p id="33e9" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">您可能希望移除目标要素，然后将其放回数据集中。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pp"><img src="../Images/0256c7cfac746ec81bb03638f41492b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5AZifBitfIfYsTJ0pgqxQ.png"/></div></div></figure><p id="c767" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">使用<code class="fe ns nt nu nv b">Cleaner.column_stats</code>您可以获得每个特性的统计数据。如果您想与其他学员进行叠加(合奏),可以稍后使用此功能。现在不要担心组装；我们将在后面的文章中讨论这一点。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pq"><img src="../Images/413c3d4fb57c460097eb46cf3cfbb032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnYTTwydfUSvT6uFnkvi7g.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk"><code class="fe ns nt nu nv b">Cleaner.column_stats</code></figcaption></figure><p id="e704" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">注意:在传递给这个方法之前，任何<code class="fe ns nt nu nv b">NaNs</code>都应该从数据集中删除，根据定义，Python 中的<code class="fe ns nt nu nv b">NaN</code>不等于另一个<code class="fe ns nt nu nv b">NaN</code>。</p><p id="edae" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">注意:我们已经介绍了可以删除、替换或<code class="fe ns nt nu nv b">Impute</code> <code class="fe ns nt nu nv b">NaN</code>值的数据清理器。</p><h1 id="9baa" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">布尔型到整数型</h1><p id="093c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">学习者，除了树，还有其他函数，需要将<code class="fe ns nt nu nv b">True/False</code>或<code class="fe ns nt nu nv b">value_1/value_0</code>的布尔值(特性将只有 2 个值)转换成整数<code class="fe ns nt nu nv b">1/0</code>才能正常工作..</p><p id="2302" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">类实例方法<code class="fe ns nt nu nv b">boolean_to_integer</code>转换所有布尔特征。因为它不影响非布尔特征，所以它可以在任何数据集上运行。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pr"><img src="../Images/654b2257cf236067d43ec50184a6b6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5G4ZdEr9XZkIsVYxIVnRQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">boolean_to_integer</figcaption></figure><h1 id="88d0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">特征 _ 特征 _ 相关性</h1><p id="664d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">通过使用<code class="fe ns nt nu nv b">seaboard.pairplot(dataset).</code>在数据集中绘制成对关系，可以直观地看到线性和/或非线性行为。您也可以使用<code class="fe ns nt nu nv b">dataset.profiling_report</code>来提供关于数据集的更多信息，这是开始 EDA 的好方法。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi ps"><img src="../Images/f7cd6e1b46d672e351cd179ca8945e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-kGhPDdRlBCdv4yFqTCPQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk"><code class="fe ns nt nu nv b">seaboard.pairplot(dataset)</code></figcaption></figure><p id="b939" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们可以用<code class="fe ns nt nu nv b">feature_Feature_Correlation</code>来计算一个数据集的关联矩阵，关联矩阵是与所有其他特征相关的所有特征。根据计算，相关性是线性相关性，并不量化任何两个特征之间的非线性行为。</p><p id="1d32" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">两个特征之间的相关性越高，相关系数越接近绝对值 1.0(开区间-1.0，1.0)。特征本身的值为 1.0，因为它与自身相关。如果它有负值，那么它是反相关的。反相关特征对意味着如果一个特征的值增加，那么另一个特征的值将减少</p><p id="6dc6" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">特征的线性预测强度是它与目标特征的相关程度。然而，特征对(非目标)的相关性越高，特征之一的预测值将降低。</p><p id="6fdf" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">通常，使用皮尔逊相关系数，其仅对两个特征之间的线性关系(或一阶)敏感。</p><p id="bfe8" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">皮尔逊相关系数-0.85 是强负相关，而相关系数 0.15 是弱正相关。此外，如果某个特征与目标的相关系数为|0.99|，那么它的预测值非常高，甚至可能太高。应检查该数据集，尤其是该特征是否有错误。</p><p id="b27b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">Spearman 的等级相关系数是衡量两个变量之间的关系能够被单调函数描述的程度。</p><p id="d981" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">肯德尔等级相关系数是用于测量两个测量特征之间的顺序关联的统计量。</p><p id="7ef7" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">Spearman 的等级相关系数是对单调函数如何描述两个变量之间关系的度量。</p><p id="3acc" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在大多数情况下，对 Kendall 和 Spearman 等级相关系数的解释与 Pearson 相关系数非常相似，因此通常会导致相同的诊断。feature_Feature_Correlation 类计算数据集所有要素对的皮尔逊、斯皮尔曼或肯德尔相关系数。</p><p id="3e91" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">同样，这个类实例方法是一个诊断工具，它指示一个特征是具有低预测能力还是与另一个特征具有高冗余。</p><p id="3174" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在移除任何特征之前，查看<strong class="lb iu"> SHAP </strong>值、相对方差和相关系数，以决定移除特征。</p><p id="3af2" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">阅读这篇文章可以很好地了解相关性:</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/fintechexplained/did-you-know-the-importance-of-finding-correlations-in-data-science-1fa3943debc2" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">了解数据科学项目中相关性的价值</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">探索数据科学的核心。理解计算相关性的重要性至关重要</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="pt l ml mm mn mj mo jv ma"/></div></div></a></div><p id="909c" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">您可以使用<code class="fe ns nt nu nv b">feature_Feature_Correlation.</code>计算数据集的特征-特征相关矩阵</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pu"><img src="../Images/18bfbf143d95707b270a85fef8d89eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pg6H5zMxgmRdcxYHRbF_CQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">feature_Feature_Correlation</figcaption></figure><p id="3c66" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">您可以使用 plot_corr <code class="fe ns nt nu nv b">.</code>绘制数据集的要素-要素相关性矩阵</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pv"><img src="../Images/9226b0b12c7b7bfa83f22cc477d7740e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n19F_hBjbqTtnstM_7ynuQ.png"/></div></div></figure><h1 id="74e6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">删除 _ 功能</h1><p id="b401" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我应该在这里提一下，<strong class="lb iu"> sklearn </strong>有一些不同的算法用于<a class="ae oc" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectKBest.html#examples-using-sklearn-feature-selection-selectkbest" rel="noopener ugc nofollow" target="_blank">特征选择</a>。在移除任何功能之前，您可能需要查看这些内容。</p><p id="8131" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">然而，我发现<strong class="lb iu"> paso </strong>中给出的特征诊断工具可以处理非线性数据。<strong class="lb iu"> SHAP </strong>在确定 2018 财年车型中某个特征的重要性方面是最先进的，而且据我所知仍然是最先进的</p><p id="009f" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">如果你有更好的了解，请告诉我们，我们可以添加到<strong class="lb iu">帕索</strong>。这个领域正在迅速发展。</p><p id="3c60" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">根据您的分析，您现在可以从<strong class="lb iu"> pandas </strong>数据框架中移除要素了。</p><p id="b0c3" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我将创建一个特征<code class="fe ns nt nu nv b">asv </code>，然后用<code class="fe ns nt nu nv b">delete_features.</code>移除它</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pv"><img src="../Images/ac54b53050d3938c4f0c818891a29fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j98w0s2ASV8EYGPUEe7pCQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">delete_Features</figcaption></figure><h1 id="b2f8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">移除训练和测试中不常见的功能</h1><p id="3019" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果训练或测试数据集具有特征，而另一个没有，则这些特征将没有预测能力，并从两个数据集中移除。例外情况是目标特征存在于<strong class="lb iu">训练</strong>数据集中，但不在监督问题的<strong class="lb iu">测试</strong>中。</p><p id="deab" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">一个数据集中的特征(<strong class="lb iu">训练</strong>或<strong class="lb iu">测试</strong>)而不是另一个数据集中的特征(<strong class="lb iu">训练</strong>或<strong class="lb iu">测试</strong>)可能指出这些数据集中的其他问题。您应该检查数据加载的步骤。</p><p id="8ae4" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我最常看到的是来自上游服务(Kafka、Google PubSub、Amazon Kinesis Stream、PySpark 和 RabbitMQ 等)的测试数据集。测试数据集的特征被改变，而预训练模型(以及训练集)不具有这些新特征。根据您的错误处理，通常会发生无法预测的情况。</p><p id="3ead" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">使用:</p><ol class=""><li id="5138" class="nj nk it lb b lc ne lg nf lk nl lo nm ls nn lw no np nq nr bi translated">移除了训练和测试数据集的特征差异。</li><li id="29bb" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw no np nq nr bi translated">删除的特征将被记录下来，以便以后进行协调。</li><li id="0588" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw no np nq nr bi translated">预训练模型成功处理了来自输入测试数据集的预测。数据流的一个很好的概述在:</li></ol><div class="lx ly gp gr lz ma"><a href="https://medium.com/analytics-vidhya/data-streams-and-online-machine-learning-in-python-a382e9e8d06a" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">Python 中的数据流和在线机器学习</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">数据已经不仅仅是一组二进制数字，而是每个人日常决策的必要组成部分…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="pw l ml mm mn mj mo jv ma"/></div></div></a></div><p id="795b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">为了创建测试和训练数据集，我们可以使用 30%的<code class="fe ns nt nu nv b">City</code>作为测试，剩下 70%的<code class="fe ns nt nu nv b">City</code>作为训练。</p><figure class="oe of og oh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi pp"><img src="../Images/2a2cf101ee65e1e9c0202023440f9a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ngh0YuQ49eqfuEPSDE5Cow.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Clean extra feature in test</figcaption></figure><h1 id="cbcf" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">摘要</h1><p id="de22" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">从 Python 3.6 ( <a class="ae oc" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP 484 </a>)开始，引入了类型提示。类型提示(注意:<em class="od">不是</em>强类型检查)使得对 Python 代码进行静态类型检查成为可能。</p><p id="ff4d" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">Python 语言解释器使用<strong class="lb iu"> <em class="od">而不是</em> </strong> <strong class="lb iu"> <em class="od">类型提示，除了检查正确的语法。类型提示更多地被下游工具使用，比如<code class="fe ns nt nu nv b">PyCharm</code>和<code class="fe ns nt nu nv b">Mypy.</code></em></strong></p><p id="7e21" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">更好的文档和在运行时发生类型错误之前将其捕获是您将从第一波工具中看到的一些好处。</p><p id="eb82" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">你可以打赌，有人正在为 Python 开发编译器，以使它在运行时更快。接下来，您可以想象用类型化符号转换动态类型化 Python 的工具。</p><p id="007b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">你可以打赌，有人正在为 Python 开发编译器，以使它在运行时更快。接下来，您可以想象用类型化符号转换动态类型化 Python 的工具。</p><p id="ce6d" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">真正美妙的是一种语言，它将输入放到下游工具中，使软件工程师能够专注于<em class="od">为什么</em>而将很大一部分<em class="od">如何</em>留给工具。</p><p id="108c" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">使用类型提示，<code class="fe ns nt nu nv b">Cleaners</code>和<code class="fe ns nt nu nv b">Imputers </code>类方法调用签名被总结如下:</p><pre class="oe of og oh gt oi nv oj ok aw ol bi"><span id="cf4b" class="om kc it nv b gy on oo l op oq">from paso.pre.cleaners import Cleaners<br/>c = Cleaners()</span><span id="4659" class="om kc it nv b gy os oo l op oq"># 1<br/>c.values_to_nan(self, X: pd.DataFrame, values: List[str]=[], inplace:bool=True, verbose:bool=True) -&gt;  pd.DataFrame:</span><span id="e8b7" class="om kc it nv b gy os oo l op oq">#2<br/>c.delete_NA_Features(self, X: pd.DataFrame, threshold:float =1.0, inplace:bool=True, verbose:bool=True) -&gt;  pd.DataFrame:</span><span id="f8f4" class="om kc it nv b gy os oo l op oq">#3<br/>c.calculate_NaN_ratio(self, X:pd.DataFrame, inplace:bool=True, verbose:bool=True) -&gt;  pd.DataFrame:</span><span id="ec12" class="om kc it nv b gy os oo l op oq">#4<br/>c.delete_Duplicate_Features(self, X:pd.DataFrame, ignore:List[str], inplace:bool=True, verbose:bool=True) -&gt;  pd.DataFrame:</span><span id="bb6f" class="om kc it nv b gy os oo l op oq">#5<br/>c.delete_Features_with_Single_Unique_Value(self, X:pd.DataFrame, ignore:List[str], inplace:bool=True, verbose:bool=True) -&gt;  pd.DataFrame:</span><span id="81d5" class="om kc it nv b gy os oo l op oq">#6<br/>c.delete_Features_with_All_Unique_Values(self, X:pd.DataFrame, ignore:List[str], inplace:bool=True, verbose:bool=True) -&gt;  pd.DataFrame:</span><span id="046d" class="om kc it nv b gy os oo l op oq">#7<br/>c.statistics() -&gt; List[str]</span><span id="1f8f" class="om kc it nv b gy os oo l op oq">#8<br/>c.feature_Statistics(self, X:pd.DataFrame, statistics:str="all", concat:bool=True, inplace:bool=True, verbose:bool=True<br/>) -&gt; pd.DataFrame:</span><span id="364d" class="om kc it nv b gy os oo l op oq">#9<br/>c.boolean_to_integer(self, X:pd.DataFrame, inplace:bool=True, verbose:bool=True) -&gt; pd.DataFrame:</span><span id="7331" class="om kc it nv b gy os oo l op oq">#10<br/>c.feature_Feature_Correlation(self, X:pd.DataFrame, method:str="pearson", verbose:bool=True) -&gt; pd.DataFrame</span><span id="e049" class="om kc it nv b gy os oo l op oq">#11<br/>c.plot_corr(self, X: pd.DataFrame, kind:str="numeric", mirror:bool=False, xsize:float=10, ysize:float=10)-&gt; None:</span><span id="cb52" class="om kc it nv b gy os oo l op oq">#12<br/>c.delete_Features(self, X:pd.DataFrame, features:List[str]=[], verbose:bool=True, inplace:bool=True) -&gt; pd.DataFrame:</span><span id="b94d" class="om kc it nv b gy os oo l op oq">#13<br/>c.delete_Features_not_in_train_or_test(self):self, train:pd.DataFrame, test:pd.DataFrame, ignore:List[str]=[], verbose:bool=True, inplace:bool=True) -&gt; pd.DataFrame:</span><span id="ad7e" class="om kc it nv b gy os oo l op oq">#14<br/>imputer_file = "../descriptions/pre/cleaners/most_frequent_impute.yaml<br/><strong class="nv iu">imp</strong> = <strong class="nv iu">Imputers</strong>(description_filepath: str = imputer_file)</span><span id="9367" class="om kc it nv b gy os oo l op oq"><strong class="nv iu">imp.imputers</strong>() -&gt; List[str]:</span><span id="2be6" class="om kc it nv b gy os oo l op oq">#15<strong class="nv iu"><br/>imp.transform</strong>(self, X: pd.DataFrame, verbose: bool = True, inplace: bool = True, features: List[str] = None, **kwargs) -&gt; pd.DataFrame</span></pre><p id="f3f3" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">本文的代码在<code class="fe ns nt nu nv b"><a class="ae oc" href="https://github.com/bcottman/paso/blob/master/lessons/lesson-2.ipynb" rel="noopener ugc nofollow" target="_blank">.ipynb </a></code>和<code class="fe ns nt nu nv b">.<a class="ae oc" href="https://github.com/bcottman/paso/blob/master/paso/pre/cleaners.py" rel="noopener ugc nofollow" target="_blank">p</a>y </code>文件中给出。</p><p id="faea" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">您已经看到<strong class="lb iu"> paso </strong>为生产数据工程师和研究数据科学家提供了数据清理方法。<strong class="lb iu"> paso </strong>支持流数据以及批量提取数据清理。你可以期待 paso 继续为数据清理提供最先进的工具。</p><p id="3efe" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">关于<strong class="lb iu">帕索</strong>的其他文章有:</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/@dr.bruce.cottman/pasos-offering-of-logging-and-parameter-services-for-your-python-project-c3ae2fd6869a" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">paso 为您的 Python 项目提供日志记录和参数服务</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">paso 为您的 Python 项目提供日志记录和参数服务</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">paso 为您的 Python Projectmedium.com 提供日志记录和参数服务</p></div></div><div class="mj l"><div class="ob l ml mm mn mj mo jv ma"/></div></div></a></div><div class="lx ly gp gr lz ma"><a href="https://medium.com/@dr.bruce.cottman/part-1-balancing-and-augmenting-structured-data-4ade0df38662" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">第 1 部分:平衡和扩充结构化数据</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">数据扩充很重要，因为它从我们当前现有的数据集生成(准确地)人工数据。的…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="or l ml mm mn mj mo jv ma"/></div></div></a></div><p id="d80b" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">将来，我们将会发表更多关于 paso 功能的文章。</p><ul class=""><li id="a5c1" class="nj nk it lb b lc ne lg nf lk nl lo nm ls nn lw ot np nq nr bi translated">第 2 部分:结构化数据的高级扩充。</li><li id="3097" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw ot np nq nr bi translated">第二部分:深度学习输入。</li><li id="8e41" class="nj nk it lb b lc nw lg nx lk ny lo nz ls oa lw ot np nq nr bi translated">还有更多…</li></ul><p id="ffdf" class="pw-post-body-paragraph kz la it lb b lc ne le lf lg nf li lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">如果你有一个服务或功能或看到一个错误，然后离开<strong class="lb iu">帕索</strong>项目一个<a class="ae oc" href="https://github.com/bcottman/paso/issues" rel="noopener ugc nofollow" target="_blank">注意</a>。</p></div></div>    
</body>
</html>