<html>
<head>
<title>Python Basics: Tuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 基础:元组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-basics-tuples-9bb3851257b5?source=collection_archive---------7-----------------------#2019-02-07">https://towardsdatascience.com/python-basics-tuples-9bb3851257b5?source=collection_archive---------7-----------------------#2019-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/60489d5700a9464e564611aa22aabd62.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7EUX9QIjq2x1JyFKcjhXsA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Source: <a class="ae jy" href="https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman</a></figcaption></figure><p id="17dc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">读完这篇博客后，你会知道:</p><ul class=""><li id="8f06" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">Python 中的元组数据类型是什么</li><li id="2d05" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如何初始化元组</li><li id="54ee" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如何迭代元组</li><li id="53cd" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">元组上的常见序列运算</li><li id="e537" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">什么是元组解包</li><li id="0a32" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">元组和列表有什么区别</li></ul><h1 id="3972" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">介绍</h1><blockquote class="mj mk ml"><p id="08c2" class="jz ka mm kb b kc kd ke kf kg kh ki kj mn kl km kn mo kp kq kr mp kt ku kv kw ij bi translated">元组是<strong class="kb ir">不可变序列</strong>，通常用于存储异构数据的集合(例如由<code class="fe mq mr ms mt b"><a class="ae jy" href="https://docs.python.org/3/library/functions.html#enumerate" rel="noopener ugc nofollow" target="_blank">enumerate()</a></code>内置产生的 2 元组)。</p></blockquote><p id="c2db" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">序列是<strong class="kb ir">可迭代</strong>中很常见的<strong class="kb ir">类型</strong>。内置序列类型的一些例子有<a class="ae jy" href="https://docs.python.org/3.3/library/stdtypes.html#list" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ir">列表</strong> </a>、<a class="ae jy" href="https://docs.python.org/3.3/library/stdtypes.html#str" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ir">字符串</strong> </a>和<a class="ae jy" href="https://docs.python.org/3.3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ir">元组</strong> </a>。它们使用整数索引支持高效的<strong class="kb ir">元素访问</strong>，并定义了一个返回序列长度的方法。</p><p id="91a8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">值可以改变的对象<strong class="kb ir">被称为<strong class="kb ir">可变的。</strong>对象<strong class="kb ir">一旦被创建，其值就不可改变</strong>称为<strong class="kb ir">不可变</strong>。</strong></p><p id="a774" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你想知道更多关于 Python 中序列和不可变对象的细节，你可以看看我以前的博文:</p><ul class=""><li id="c173" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/python-basics-iteration-and-looping-6ca63b30835c"> Python 基础:迭代、可迭代、迭代器和循环</a></li><li id="3f6f" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a"> Python 基础:可变与不可变对象</a></li></ul><p id="9978" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">元组看起来类似于列表。它们可以包含<strong class="kb ir">多个值</strong>。列表和元组的<strong class="kb ir">主要区别</strong>在于<strong class="kb ir">元组是不可变的</strong>，而<strong class="kb ir">列表是可变的</strong>。</p><h1 id="530f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">元组初始化</h1><p id="b7df" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">在 Python 中，我们可以用几种方式初始化元组</p><ul class=""><li id="f600" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">用一对<strong class="kb ir">括号</strong>来表示一个<strong class="kb ir">空元组</strong> : <code class="fe mq mr ms mt b"><strong class="kb ir">()</strong></code></li><li id="1b08" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">为具有一个值 : <code class="fe mq mr ms mt b"><strong class="kb ir">a,</strong></code>或<code class="fe mq mr ms mt b"><strong class="kb ir">(a,)</strong></code>的<strong class="kb ir">元组使用尾随逗号</strong></li><li id="a29b" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb ir">用逗号分隔项目</strong> : <code class="fe mq mr ms mt b"><strong class="kb ir">a, b, c</strong></code>或<code class="fe mq mr ms mt b"><strong class="kb ir">(a, b, c)</strong></code></li><li id="35d1" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">使用<a class="ae jy" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ir"> tuple() </strong> </a> <strong class="kb ir">内置</strong> : <code class="fe mq mr ms mt b"><strong class="kb ir">tuple()</strong></code>或<code class="fe mq mr ms mt b"><strong class="kb ir">tuple(iterable)</strong></code></li></ul><p id="9263" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">括号是可选的</strong>，除非在空元组的情况下，或者当需要它们来避免语法歧义时。例如，<code class="fe mq mr ms mt b">f(a, b)</code>是一个带有两个参数的函数调用，而<code class="fe mq mr ms mt b">f((a, b))</code>是一个带有一个作为两个元素的元组传递的参数的函数调用。</p><h2 id="fc3c" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">初始化空元组</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0610" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="c7fd" class="mz lm iq mt b gy nv nw l nx ny">&lt;class 'tuple'&gt;<br/>&lt;class 'tuple'&gt;<br/><br/>()<br/>()</span></pre><h2 id="62cf" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">用单个值初始化元组</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3565" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="25bf" class="mz lm iq mt b gy nv nw l nx ny">&lt;class 'tuple'&gt;<br/>&lt;class 'tuple'&gt;<br/><br/>('Python',)<br/>('Data Science',)</span></pre><h2 id="e81b" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">初始化具有多个值的元组</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1441" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="6197" class="mz lm iq mt b gy nv nw l nx ny">&lt;class 'tuple'&gt;<br/>&lt;class 'tuple'&gt;<br/><br/>(1, 2, 3)<br/>(1, 2, 3)</span></pre><h2 id="0a51" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">从 Iterables 初始化元组</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e029" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="a1b0" class="mz lm iq mt b gy nv nw l nx ny">&lt;class 'tuple'&gt;<br/>('Python', 'Maths', 'Machine Learning')</span></pre><h1 id="8de2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">迭代元组</h1><p id="724d" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">我们已经知道元组是<strong class="kb ir">序列数据类型</strong>，我们可以迭代序列，因为它们是<strong class="kb ir">可迭代的</strong>。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3109" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="0f81" class="mz lm iq mt b gy nv nw l nx ny">Pineapple<br/>orange<br/>banana<br/>apple</span></pre><h1 id="6eb3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">列举</h1><p id="abeb" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">Python 中的<code class="fe mq mr ms mt b"><a class="ae jy" href="https://docs.python.org/3/library/functions.html#enumerate" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir">enumerate(iterable, start=0)</strong></a></code> <strong class="kb ir">内置函数</strong>返回迭代器。当我们迭代这个迭代器时，它返回一个包含计数(从 0 开始)和通过迭代<code class="fe mq mr ms mt b"><strong class="kb ir">iterable</strong></code>获得的值的<strong class="kb ir">元组</strong>。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e338" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="7808" class="mz lm iq mt b gy nv nw l nx ny">0 Pineapple<br/>1 orange<br/>2 banana<br/>3 apple<br/><br/>0 pandas<br/>1 scikit-learn<br/>2 seaborn</span></pre><h1 id="a3d4" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">常见顺序操作</h1><p id="5783" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">在 Python 中，我们有一些常见的序列操作<a class="ae jy" href="https://docs.python.org/3/library/stdtypes.html#typesseq-common" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir"/></a>，它们被大多数序列类型支持，包括可变的和不可变的。</p><blockquote class="mj mk ml"><p id="ab6f" class="jz ka mm kb b kc kd ke kf kg kh ki kj mn kl km kn mo kp kq kr mp kt ku kv kw ij bi translated">该表列出了按优先级升序排序的<strong class="kb ir">序列操作。表中，<code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">s</em></strong></code><strong class="kb ir"/><code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">t</em></strong></code><strong class="kb ir">为同类型序列</strong>，<code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">n</em></strong></code> <strong class="kb ir">，</strong> <code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">i</em></strong></code> <strong class="kb ir">，</strong> <code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">j</em></strong></code> <strong class="kb ir">，</strong> <code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">k</em></strong></code> <strong class="kb ir">为整数</strong>，<code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">x</em></strong></code> <strong class="kb ir">为满足</strong> <code class="fe mq mr ms mt b"><strong class="kb ir"><em class="iq">s</em></strong></code>任意类型和值限制的任意对象。</strong></p><p id="bafd" class="jz ka mm kb b kc kd ke kf kg kh ki kj mn kl km kn mo kp kq kr mp kt ku kv kw ij bi translated"><code class="fe mq mr ms mt b">in</code>和<code class="fe mq mr ms mt b">not in</code>操作与比较操作具有相同的优先级。<code class="fe mq mr ms mt b">+</code>(连接)和<code class="fe mq mr ms mt b">*</code>(重复)运算与相应的数字运算具有相同的优先级。</p></blockquote><figure class="nl nm nn no gt jq gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/aa4440e39aea4e613baa98c8d1e03138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*2OYA-yZd6wJ-EkQk8njmEw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Source: <a class="ae jy" href="https://docs.python.org/3/library/stdtypes.html#typesseq-common" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/stdtypes.html#typesseq-common</a></figcaption></figure><p id="e790" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们看看如何对元组进行这些操作。</p><h2 id="af28" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">在，不在</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6df4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="6bed" class="mz lm iq mt b gy nv nw l nx ny">True<br/>False<br/><br/>False<br/>True</span></pre><h2 id="686a" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">串联</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2d7a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="70ea" class="mz lm iq mt b gy nv nw l nx ny">('Python', 'Web Development', 'Machine Learning', 'Communication', 'Courtesy', 'Flexibility', 'Integrity')</span></pre><h2 id="c2e6" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">增加</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6175" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="906b" class="mz lm iq mt b gy nv nw l nx ny">(['Communication', 'Courtesy'], ['Communication', 'Courtesy'], ['Communication', 'Courtesy'])</span></pre><p id="a4d6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这相当于给自己加了三次<code class="fe mq mr ms mt b">soft_skills</code>。但是，要小心！ <code class="fe mq mr ms mt b"><strong class="kb ir">soft_skills</strong></code> <strong class="kb ir">中的<strong class="kb ir">项不复制</strong>，<strong class="kb ir">被多次引用</strong>。让我们看看，如果我们向元组的第一个列表添加值，会发生什么。</strong></p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e0f8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="7ff7" class="mz lm iq mt b gy nv nw l nx ny">(['Communication', 'Courtesy'], ['Communication', 'Courtesy'], ['Communication', 'Courtesy'])<br/><br/>(['Communication', 'Courtesy', 'Responsibility'], ['Communication', 'Courtesy', 'Responsibility'], ['Communication', 'Courtesy', 'Responsibility'])</span></pre><p id="fd23" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">新添加的值被添加到三个列表中，因为它们引用同一个对象。</p><h2 id="ecd6" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">索引</h2><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="17fa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="500b" class="mz lm iq mt b gy nv nw l nx ny">Communication<br/>Responsibility</span></pre><p id="448e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">是的，在 Python 中我们可以使用负索引(我们可以使用<code class="fe mq mr ms mt b">-1</code>作为索引来获取最后一个元素)。当我们使用负指数时，应用此公式计算实际指数:<code class="fe mq mr ms mt b">len(sequence) + index</code>。</p><p id="cf69" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在我们的例子中，长度是 5，所以我们得到索引<code class="fe mq mr ms mt b">5 — 1 = 4</code>处的项目，这就是<em class="mm"/><strong class="kb ir"><em class="mm">责任</em></strong><em class="mm"/>项目。</p><h2 id="d706" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">限幅</h2><p id="a440" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">我们可以使用切片来选择序列对象中的一系列项目。语法是<code class="fe mq mr ms mt b">sliceable[start_index:end_index:step]</code>。</p><ul class=""><li id="0b7a" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><code class="fe mq mr ms mt b">start_index</code>是切片的起始索引，该索引处的元素将包含在结果中，默认值为<code class="fe mq mr ms mt b">0</code>。</li><li id="ee64" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe mq mr ms mt b">end_index</code>是切片的结束索引，此索引处的元素将<strong class="kb ir">不包括在结果中</strong>。默认值是<code class="fe mq mr ms mt b">len(sequence)</code>。</li><li id="cf0b" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe mq mr ms mt b">step</code>是指标增加的数量，<br/>默认为<code class="fe mq mr ms mt b">1</code>。如果我们为步长设置一个负值，我们将向后移动。</li></ul><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d86d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="6284" class="mz lm iq mt b gy nv nw l nx ny">('Courtesy', 'Flexibility', 'Integrity')<br/>('Communication', 'Courtesy', 'Flexibility', 'Integrity')<br/>('Communication', 'Courtesy', 'Flexibility', 'Integrity', 'Responsibility')<br/>('Communication', 'Flexibility', 'Responsibility')<br/>('Responsibility', 'Integrity', 'Flexibility', 'Courtesy', 'Communication')</span></pre><h2 id="775d" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">最小值、最大值和长度</h2><p id="8cdd" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">我们可以使用<code class="fe mq mr ms mt b">min()</code>、<code class="fe mq mr ms mt b">max()</code>和<code class="fe mq mr ms mt b">len()</code>内置函数来获得一个序列的最大值、最小值和长度。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7878" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="126f" class="mz lm iq mt b gy nv nw l nx ny">5<br/>Communication<br/>Responsibility<br/><br/>11<br/>7<br/>90</span></pre><h2 id="be64" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">索引和计数</h2><p id="ddf8" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">我们已经为元组提供了索引和计数方法。我们可以使用第一个来<strong class="kb ir">标识给定值</strong>的索引，使用第二个来<strong class="kb ir">标识这个值</strong>在我们的元组中出现了多少次。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="08b5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="57ac" class="mz lm iq mt b gy nv nw l nx ny">1</span><span id="d8d1" class="mz lm iq mt b gy oa nw l nx ny"><strong class="mt ir">--------------------------------------------------------------------</strong><br/><strong class="mt ir">ValueError</strong>                         Traceback (most recent call last)<br/><strong class="mt ir">&lt;ipython-input-21-f2447af847ce&gt;</strong> in &lt;module&gt;<strong class="mt ir">()</strong><br/>      3 <br/>      4 numbers <strong class="mt ir">=</strong> <strong class="mt ir">(10,</strong> <strong class="mt ir">22,</strong> <strong class="mt ir">53,</strong> <strong class="mt ir">53,</strong> <strong class="mt ir">8,</strong> <strong class="mt ir">9,</strong> <strong class="mt ir">11,</strong> <strong class="mt ir">45,</strong> <strong class="mt ir">90,</strong> <strong class="mt ir">7,</strong> <strong class="mt ir">26)</strong><br/><strong class="mt ir">----&gt; 5 </strong>print<strong class="mt ir">(</strong>numbers<strong class="mt ir">.</strong>index<strong class="mt ir">(100))</strong><br/><br/><strong class="mt ir">ValueError</strong>: tuple.index(x): x not in tuple</span></pre><p id="6248" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们可以看到，如果我们传递一个不在元组中的值，我们将得到一个<code class="fe mq mr ms mt b">ValueError</code>。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="826f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="868c" class="mz lm iq mt b gy nv nw l nx ny">1<br/>2<br/><br/>0</span></pre><p id="4675" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果我们传递一个在我们的元组中不存在的值，<strong class="kb ir">计数方法</strong>将返回 0。这一次没有错误。</p><h1 id="835d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">元组解包</h1><p id="70f9" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">我们还可以将元组中的值“解包”到变量中。此外，更通用的方法称为<strong class="kb ir">序列解包</strong>，因此这将适用于任何序列。我们已经看到了枚举内置函数的例子。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1abc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="c4a7" class="mz lm iq mt b gy nv nw l nx ny">10<br/>20<br/>30</span></pre><p id="d542" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">请注意，解包元组时，左侧变量的数量应该等于元组中值的数量。否则，我们会得到一个错误。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6607" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="51ae" class="mz lm iq mt b gy nv nw l nx ny"><strong class="mt ir">--------------------------------------------------------------------</strong><br/><strong class="mt ir">ValueError</strong>                         Traceback (most recent call last)<br/><strong class="mt ir">&lt;ipython-input-45-282b018b9602&gt;</strong> in &lt;module&gt;<strong class="mt ir">()</strong><br/><strong class="mt ir">----&gt; 1 </strong>a<strong class="mt ir">,</strong> b <strong class="mt ir">=</strong> <strong class="mt ir">(10,</strong> <strong class="mt ir">20,</strong> <strong class="mt ir">30)</strong><br/><br/><strong class="mt ir">ValueError</strong>: too many values to unpack (expected 2)</span></pre><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="546e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="6056" class="mz lm iq mt b gy nv nw l nx ny"><strong class="mt ir">--------------------------------------------------------------------</strong><br/><strong class="mt ir">ValueError</strong>                         Traceback (most recent call last)<br/><strong class="mt ir">&lt;ipython-input-43-c91a3d9d3fc4&gt;</strong> in &lt;module&gt;<strong class="mt ir">()</strong><br/><strong class="mt ir">----&gt; 1 </strong>a<strong class="mt ir">,</strong> b<strong class="mt ir">,</strong>c<strong class="mt ir">,</strong>d <strong class="mt ir">=</strong> <strong class="mt ir">(10,</strong> <strong class="mt ir">20,</strong> <strong class="mt ir">30)</strong><br/><br/><strong class="mt ir">ValueError</strong>: not enough values to unpack (expected 4, got 3)</span></pre><h1 id="7198" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">元组与列表</h1><p id="92f7" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">如前所述，列表和元组之间的<strong class="kb ir">主要区别</strong>在于<strong class="kb ir">元组是不可变的</strong>，而<strong class="kb ir">列表是可变的</strong>。</p><p id="e507" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">重要注意事项</strong> : <br/>如果可变对象被改变，包含对可变对象的<strong class="kb ir">引用的<strong class="kb ir">不可变容器</strong>的值可以被改变。当我们谈论容器</strong>的<strong class="kb ir">可变性时，只有被包含对象的<strong class="kb ir">身份</strong>是隐含的。然而，如果我们的不可变容器只包含不可变的数据类型，它的值就不能改变。参见这篇<a class="ae jy" rel="noopener" target="_blank" href="/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a">博文</a>中的例子。</strong></p><p id="fed8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">与列表不同，元组没有<code class="fe mq mr ms mt b">append()</code>、<code class="fe mq mr ms mt b">insert()</code>、<code class="fe mq mr ms mt b">remove()</code>、<code class="fe mq mr ms mt b">pop()</code>、<code class="fe mq mr ms mt b">extend()</code>等方法，因为它们具有不可变的性质。</p><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="77d1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="813f" class="mz lm iq mt b gy nv nw l nx ny">['Flexibility', 'Courtesy', 'Flexibility', 'Integrity', 'Responsibility']</span><span id="4b9c" class="mz lm iq mt b gy oa nw l nx ny"><strong class="mt ir">--------------------------------------------------------------------</strong><br/><strong class="mt ir">TypeError</strong>                         Traceback (most recent call last)<br/><strong class="mt ir">&lt;ipython-input-47-5d2973b1f2b4&gt;</strong> in &lt;module&gt;<strong class="mt ir">()</strong><br/>      4 <br/>      5 tuple_skills <strong class="mt ir">=</strong> <strong class="mt ir">("Communication",</strong> <strong class="mt ir">"Courtesy",</strong> <strong class="mt ir">"Flexibility",</strong> <strong class="mt ir">"Integrity",</strong> <strong class="mt ir">"Responsibility")</strong><br/><strong class="mt ir">----&gt; 6 </strong>tuple_skills<strong class="mt ir">[0]</strong> <strong class="mt ir">=</strong> <strong class="mt ir">"Flexibility"</strong><br/><br/><strong class="mt ir">TypeError</strong>: 'tuple' object does not support item assignment</span></pre><h2 id="b2e7" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">文档中的附加注释</h2><blockquote class="mj mk ml"><p id="f491" class="jz ka mm kb b kc kd ke kf kg kh ki kj mn kl km kn mo kp kq kr mp kt ku kv kw ij bi translated">尽管元组可能看起来类似于列表，但它们通常用于不同的情况和不同的目的。元组是<a class="ae jy" href="https://docs.python.org/3.7/glossary.html#term-immutable" rel="noopener ugc nofollow" target="_blank">不可变的</a>，并且通常包含通过解包或索引(或者甚至在<code class="fe mq mr ms mt b"><a class="ae jy" href="https://docs.python.org/3.7/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank">namedtuples</a></code>的情况下通过属性)访问的异构元素序列。列表是<a class="ae jy" href="https://docs.python.org/3.7/glossary.html#term-mutable" rel="noopener ugc nofollow" target="_blank">可变的</a>，它们的元素通常是同构的，通过遍历列表来访问。</p></blockquote><p id="a21d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">来源:<a class="ae jy" href="https://docs.python.org/3.7/tutorial/datastructures.html#tuples-and-sequences" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.7/tutorial/data structures . html # tuple-and-sequences</a></p><h2 id="94c0" class="mz lm iq bd ln na nb dn lr nc nd dp lv kk ne nf lz ko ng nh md ks ni nj mh nk bi translated">何时使用元组</h2><ul class=""><li id="f342" class="kx ky iq kb b kc mu kg mv kk ob ko oc ks od kw lc ld le lf bi translated"><strong class="kb ir">元组比列表快。如果你需要一组常量值，而你所要做的就是遍历它，那么使用元组而不是列表。</strong></li></ul><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="be79" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="4858" class="mz lm iq mt b gy nv nw l nx ny">0.034131127635760095<br/>0.11737610517116082</span></pre><p id="9a7d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe mq mr ms mt b">timeit</code>库允许我们以秒为单位测量经过的时间。我们可以清楚地看到元组初始化比列表初始化快。</p><ul class=""><li id="ce4a" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">仅包含不可变值<strong class="kb ir">的元组可以用作字典</strong>的键，而列表则不能。</li></ul><figure class="nl nm nn no gt jq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b9a8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出:</p><pre class="nl nm nn no gt nr mt ns nt aw nu bi"><span id="5872" class="mz lm iq mt b gy nv nw l nx ny">Introducton</span><span id="072a" class="mz lm iq mt b gy oa nw l nx ny"><strong class="mt ir">--------------------------------------------------------------------</strong><br/><strong class="mt ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mt ir">&lt;ipython-input-5-c18ababebf4d&gt;</strong> in &lt;module&gt;<strong class="mt ir">()</strong><br/>      2 print<strong class="mt ir">(</strong>book<strong class="mt ir">[(1,</strong> <strong class="mt ir">10)])</strong><br/>      3 <br/><strong class="mt ir">----&gt; 4 </strong>book <strong class="mt ir">=</strong> <strong class="mt ir">{[1,</strong> <strong class="mt ir">10]:</strong> <strong class="mt ir">"Introducton",</strong> <strong class="mt ir">[11,</strong> <strong class="mt ir">15]:</strong> <strong class="mt ir">"Notation and Definitions",</strong> <strong class="mt ir">[16,</strong> <strong class="mt ir">30]:</strong> <strong class="mt ir">"Fundamental Algorithms"}</strong><br/><br/><strong class="mt ir">TypeError</strong>: unhashable type: 'list'</span></pre><ul class=""><li id="bc38" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">如果我们的元组只包含不可变的对象，我们可以使用它们来确保我们的数据不会被改变。</li></ul><h1 id="69dc" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><ul class=""><li id="8583" class="kx ky iq kb b kc mu kg mv kk ob ko oc ks od kw lc ld le lf bi translated">元组是<strong class="kb ir">不可变序列</strong>，通常用于存储异构数据的集合(例如由<code class="fe mq mr ms mt b"><a class="ae jy" href="https://docs.python.org/3/library/functions.html#enumerate" rel="noopener ugc nofollow" target="_blank"><em class="mm">enumerate()</em></a></code>内置产生的 2 元组)。</li><li id="2990" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">列表和元组的<strong class="kb ir">主要区别</strong>在于<strong class="kb ir">元组是不可变的</strong>，而<strong class="kb ir">列表是可变的</strong>。</li><li id="1547" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们可以使用一对括号<strong class="kb ir"/><code class="fe mq mr ms mt b"><strong class="kb ir">()</strong></code>和<strong class="kb ir">来初始化一个元组，括号内的值用逗号</strong>隔开。</li><li id="57fa" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们可以使用<a class="ae jy" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir">tuple(iterable)</strong></a><strong class="kb ir">内置的</strong>函数来初始化一个 tuple。</li><li id="e88a" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们可以使用一个简单的 for 循环对元组进行迭代。</li><li id="3c62" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们可以对元组进行<a class="ae jy" href="https://docs.python.org/3.7/library/stdtypes.html#common-sequence-operations" rel="noopener ugc nofollow" target="_blank">常见的序列操作</a>，比如<strong class="kb ir">索引</strong>、<strong class="kb ir">切片</strong>、<strong class="kb ir">拼接</strong>、<strong class="kb ir">乘法</strong>，获取<strong class="kb ir"> min </strong>、<strong class="kb ir"> max </strong>值等等。</li><li id="f3a0" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们可以从元组中解包值</li><li id="dcab" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">当你需要一组<strong class="kb ir">常量值</strong>并且你所要做的就是<strong class="kb ir">遍历它</strong>时，使用元组而不是列表。</li></ul><h1 id="7701" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">时事通讯</h1><p id="eb95" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">如果你想在我发表新的博客文章时得到通知，你可以订阅我的时事通讯。</p><h1 id="6d42" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">商务化人际关系网</h1><p id="517f" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">这是我在 LinkedIn 上的简介，如果你想和我联系的话。我将很高兴与你联系在一起。</p><h1 id="f04d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最后的话</h1><p id="a0da" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">谢谢你的阅读。我希望你喜欢这篇文章。如果你喜欢，请按住拍手键，分享给你的朋友。我很高兴听到你的反馈。如果你有什么问题，尽管问。😉</p><h1 id="d31c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">资源</h1><ul class=""><li id="48aa" class="kx ky iq kb b kc mu kg mv kk ob ko oc ks od kw lc ld le lf bi translated"><a class="ae jy" href="https://www.datacamp.com/community/tutorials/python-tuples-tutorial" rel="noopener ugc nofollow" target="_blank">https://www . data camp . com/community/tutorials/python-tuples-tutorial</a></li><li id="cb04" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://www.tutorialspoint.com/python/python_tuples.htm" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/python/python_tuples.htm</a></li><li id="d4f4" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://stackoverflow.com/questions/1708510/python-list-vs-tuple-when-to-use-each" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1708510/python-list-vs-tuple-when-to-use-each</a></li><li id="a5e8" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/tutorial/data structures . html #元组和序列</a></li><li id="f0ec" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://docs.python.org/3/library/stdtypes.html#tuples" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/stdtypes.html#tuples</a></li><li id="e10c" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><a class="ae jy" href="https://docs.python.org/3.7/library/stdtypes.html#common-sequence-operations" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.7/library/stdtypes . html # common-sequence-operations</a></li></ul></div></div>    
</body>
</html>