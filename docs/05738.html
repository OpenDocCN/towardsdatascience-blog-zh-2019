<html>
<head>
<title>Independent Component Analysis (ICA) In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的独立分量分析(ICA)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/independent-component-analysis-ica-in-python-a0ef0db0955e?source=collection_archive---------2-----------------------#2019-08-22">https://towardsdatascience.com/independent-component-analysis-ica-in-python-a0ef0db0955e?source=collection_archive---------2-----------------------#2019-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4054be4ef7ce4c70801aaa82ba1559d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RcgZwlFJxxlYJK6l"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ThisisEngineering RAEng</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="c95e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你在一个家庭聚会上和一个可爱的女孩聊天。当你听的时候，你的耳朵会被屋子里不同人群之间的对话和背景音乐的声音所包围。然而，这并不妨碍你专注于女孩在说什么，因为人类拥有区分声音的天赋。</p><p id="010c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果这是电影场景的一部分，我们用来记录对话的麦克风将缺乏必要的能力来区分房间里的所有声音。这就是<strong class="ki jk">独立成分分析</strong>，或简称<strong class="ki jk"> ICA </strong>发挥作用的地方。ICA 是一种用于将多变量信号分离成其基本分量的计算方法。使用 ICA，我们可以从多个信号的融合中提取出想要的成分(即你和女孩之间的对话)。</p><h1 id="5b0c" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">独立分量分析(ICA)算法</h1><p id="8f88" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在高层次上，ICA 可以分为以下几个步骤。</p><ol class=""><li id="7217" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">通过减去平均值使<strong class="ki jk"> x </strong>居中</li><li id="aa6b" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">变白<strong class="ki jk"> x </strong></li><li id="499f" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">为去混合矩阵<strong class="ki jk"> w </strong>选择一个随机初始值</li><li id="9984" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">计算<strong class="ki jk"> w </strong>的新值</li><li id="6f0c" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">正常化<strong class="ki jk"> w </strong></li><li id="87c4" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">检查算法是否收敛，如果没有，返回步骤 4</li><li id="967e" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">取<strong class="ki jk"> w </strong>和<strong class="ki jk"> x </strong>的点积，得到独立的源信号</li></ol><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/9b5f561f82deb5857e84d4ee5f081044.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*fYL58KpGxsV7toXBolewhg.png"/></div></figure><h2 id="c2a1" class="na lf jj bd lg nb nc dn lk nd ne dp lo kr nf ng ls kv nh ni lw kz nj nk ma nl bi translated"><strong class="ak">美白</strong></h2><p id="b2c5" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在应用 ICA 算法之前，我们必须首先"<em class="nm">白化"</em>我们的信号。<em class="nm"/>“白化”一个给定的信号意味着我们以这样一种方式对其进行变换，即消除其分量之间的潜在相关性(协方差等于 0)，并且每个分量的方差等于 1。另一种看待它的方式是白化信号的协方差矩阵将等于单位矩阵。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e1fcd5658027974c25a8051b714e53d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*y5Ta6wvNODA60DX4NGIywA.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Identity Matrix</figcaption></figure><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/547d1ad5c6578a18db6ea848bda138e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*EuGjIkZzMXZrOXC5.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Covariance Matrix</figcaption></figure><p id="3c92" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们着手白化信号的实际方法包括协方差矩阵的<strong class="ki jk">特征值分解。相应的数学方程可以描述如下。</strong></p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9b5f32db0d312312f9aed8f43439923c.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*ITGr9CfhY0pHKt207JS_xw.png"/></div></figure><p id="f032" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<strong class="ki jk"> D </strong>是特征值的对角矩阵(每个λ是协方差矩阵的特征值)</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fc1df252a37919fa8fc0e008f93f62d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*TiTPvH33pitYaoW_H7QHwA.png"/></div></figure><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/34c8e6b68232aca0f606c10061a1b4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RLdbtj__RPDJfyeK.png"/></div></figure><p id="d149" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且<strong class="ki jk"> E </strong>是特征向量的正交矩阵</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c3bcff59365f1c5388b3eaad9f304e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uh-i5w7zRW5P61gY.png"/></div></figure><p id="4227" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们完成了对信号的预处理，对于每个分量，我们更新去混合矩阵<strong class="ki jk"> w </strong>的值，直到算法收敛或者达到最大迭代次数。当<strong class="ki jk"> w </strong>与其转置的点积大致等于 1 时，认为达到了收敛。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/71e07a788c64d077e58e2d27dc7e64e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCNU9oSDFo1bRvlBDQZXlQ.png"/></div></div></figure><p id="3e60" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在哪里</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/499c3183f627481387cc121fa2541631.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*yWFZAL2Q3LqdpHQO3z2mNw.png"/></div></figure><h1 id="4fbe" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python 代码</h1><p id="c3a3" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们看看如何使用 Numpy 在 Python 中从头开始实现 ICA。首先，我们导入以下库。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="a1fb" class="na lf jj nv b gy nz oa l ob oc">import numpy as np<br/>np.random.seed(0)<br/>from scipy import signal<br/>from scipy.io import wavfile<br/>from matplotlib import pyplot as plt<br/>import seaborn as sns<br/>sns.set(rc={'figure.figsize':(11.7,8.27)})</span></pre><p id="5b0e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们定义<code class="fe od oe of nv b">g</code>和<code class="fe od oe of nv b">g’</code>，我们将使用它们来确定 w 的新值。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="f5cc" class="na lf jj nv b gy nz oa l ob oc">def g(x):<br/>    return np.tanh(x)</span><span id="aa24" class="na lf jj nv b gy og oa l ob oc">def g_der(x):<br/>    return 1 - g(x) * g(x)</span></pre><p id="e0b2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建一个函数，通过减去平均值来确定信号的中心。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="6c4c" class="na lf jj nv b gy nz oa l ob oc">def center(X):<br/>    X = np.array(X)<br/>    <br/>    mean = X.mean(axis=1, keepdims=True)<br/>    <br/>    return X- mean</span></pre><p id="ef30" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用上述方法定义一个函数来白化信号。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="5e75" class="na lf jj nv b gy nz oa l ob oc">def whitening(X):<br/>    cov = np.cov(X)</span><span id="0acf" class="na lf jj nv b gy og oa l ob oc">    d, E = np.linalg.eigh(cov)</span><span id="a5f2" class="na lf jj nv b gy og oa l ob oc">    D = np.diag(d)</span><span id="e783" class="na lf jj nv b gy og oa l ob oc">    D_inv = np.sqrt(np.linalg.inv(D))</span><span id="0898" class="na lf jj nv b gy og oa l ob oc">    X_whiten = np.dot(E, np.dot(D_inv, np.dot(E.T, X)))</span><span id="343e" class="na lf jj nv b gy og oa l ob oc">    return X_whiten</span></pre><p id="b80a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义一个函数来更新去混合矩阵<strong class="ki jk"> w </strong>。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="9536" class="na lf jj nv b gy nz oa l ob oc">def calculate_new_w(w, X):<br/>    w_new = (X * g(np.dot(w.T, X))).mean(axis=1) - g_der(np.dot(w.T, X)).mean() * w</span><span id="49f2" class="na lf jj nv b gy og oa l ob oc">    w_new /= np.sqrt((w_new ** 2).sum())</span><span id="3220" class="na lf jj nv b gy og oa l ob oc">    return w_new</span></pre><p id="34e3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们定义调用预处理函数的 main 方法，将<strong class="ki jk"> w </strong>初始化为某个随机的值集，并迭代更新<strong class="ki jk"> w </strong>。同样，收敛可以通过理想的<strong class="ki jk"> w </strong>将是正交的这一事实来判断，因此<strong class="ki jk"> w </strong>乘以其转置将近似等于 1。在计算出每个分量的最佳值<strong class="ki jk"> w </strong>之后，我们将得到的矩阵与信号<strong class="ki jk"> x </strong>进行点积，从而得到信号源。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="3a59" class="na lf jj nv b gy nz oa l ob oc">def ica(X, iterations, tolerance=1e-5):<br/>    X = center(X)<br/>    <br/>    X = whitening(X)<br/>        <br/>    components_nr = X.shape[0]</span><span id="a13d" class="na lf jj nv b gy og oa l ob oc">W = np.zeros((components_nr, components_nr), dtype=X.dtype)</span><span id="9dc7" class="na lf jj nv b gy og oa l ob oc">for i in range(components_nr):<br/>        <br/>        w = np.random.rand(components_nr)<br/>        <br/>        for j in range(iterations):<br/>            <br/>            w_new = calculate_new_w(w, X)<br/>            <br/>            if i &gt;= 1:<br/>                w_new -= np.dot(np.dot(w_new, W[:i].T), W[:i])<br/>            <br/>            distance = np.abs(np.abs((w * w_new).sum()) - 1)<br/>            <br/>            w = w_new<br/>            <br/>            if distance &lt; tolerance:<br/>                break<br/>                <br/>        W[i, :] = w<br/>        <br/>    S = np.dot(W, X)<br/>    <br/>    return S</span></pre><p id="5f15" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义一个函数来绘制和比较原始信号、混合信号和预测信号。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="6d2f" class="na lf jj nv b gy nz oa l ob oc">def plot_mixture_sources_predictions(X, original_sources, S):<br/>    fig = plt.figure()</span><span id="b904" class="na lf jj nv b gy og oa l ob oc">    plt.subplot(3, 1, 1)<br/>    for x in X:<br/>        plt.plot(x)<br/>    plt.title("mixtures")</span><span id="970a" class="na lf jj nv b gy og oa l ob oc">    plt.subplot(3, 1, 2)<br/>    for s in original_sources:<br/>        plt.plot(s)<br/>    plt.title("real sources")</span><span id="370c" class="na lf jj nv b gy og oa l ob oc">    plt.subplot(3,1,3)<br/>    for s in S:<br/>        plt.plot(s)<br/>    plt.title("predicted sources")<br/>    <br/>    fig.tight_layout()<br/>    plt.show()</span></pre><p id="8876" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了前面的例子，我们创建了一个人工混合不同源信号的方法。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="a102" class="na lf jj nv b gy nz oa l ob oc">def mix_sources(mixtures, apply_noise=False):<br/>    for i in range(len(mixtures)):<br/>        <br/>        max_val = np.max(mixtures[i])<br/>        <br/>        if max_val &gt; 1 or np.min(mixtures[i]) &lt; 1:<br/>            <br/>            mixtures[i] = mixtures[i] / (max_val / 2) - 0.5<br/>            <br/>    X = np.c_[[mix for mix in mixtures]]<br/>    <br/>    if apply_noise:<br/>        <br/>        X += 0.02 * np.random.normal(size=X.shape)<br/>        <br/>    return X</span></pre><p id="50c0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们创建 3 个信号，每个信号都有自己独特的模式。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="771c" class="na lf jj nv b gy nz oa l ob oc">n_samples = 2000<br/>time = np.linspace(0, 8, n_samples)<br/>s1 = np.sin(2 * time)  # sinusoidal<br/>s2 = np.sign(np.sin(3 * time))  # square signal<br/>s3 = signal.sawtooth(2 * np.pi * time)  # saw tooth signal</span></pre><p id="8522" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的例子中，我们计算矩阵<strong class="ki jk"> A </strong>和信号的点积，以获得所有三者的组合。然后，我们使用独立分量分析将混合信号分离为原始源信号。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="3a67" class="na lf jj nv b gy nz oa l ob oc">X = np.c_[s1, s2, s3]<br/>A = np.array(([[1, 1, 1], [0.5, 2, 1.0], [1.5, 1.0, 2.0]]))<br/>X = np.dot(X, A.T)<br/>X = X.T<br/>S = ica(X, iterations=1000)<br/>plot_mixture_sources_predictions(X, [s1, s2, s3], S)</span></pre><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/a74a19edc29efa9decaa78bfe3536d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJ7gx4VZKGt4xBoijluJVw.png"/></div></div></figure><p id="d394" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用 ICA 分解实际音轨的混合，并绘制结果。如果你想亲自尝试，你可以在这里获得音频样本<a class="ae jg" href="https://github.com/corymaklin/ida" rel="noopener ugc nofollow" target="_blank">。我鼓励你实际尝试听不同的音轨。</a></p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="d1bf" class="na lf jj nv b gy nz oa l ob oc">sampling_rate, mix1 = wavfile.read('mix1.wav')<br/>sampling_rate, mix2 = wavfile.read('mix2.wav')<br/>sampling_rate, source1 = wavfile.read('source1.wav')<br/>sampling_rate, source2 = wavfile.read('source2.wav')<br/>X = mix_sources([mix1, mix2])<br/>S = ica(X, iterations=1000)</span><span id="5a6a" class="na lf jj nv b gy og oa l ob oc">plot_mixture_sources_predictions(X, [source1, source2], S)</span><span id="b713" class="na lf jj nv b gy og oa l ob oc">wavfile.write('out1.wav', sampling_rate, S[0])<br/>wavfile.write('out2.wav', sampling_rate, S[1])</span></pre><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/fed845d3a506aa368f08f1aae073b7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KISYvYWLl2NyNiH-l8OIlA.png"/></div></div></figure><h1 id="731b" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Sklearn</h1><p id="4529" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最后，我们看看如何使用 ICA 的<code class="fe od oe of nv b">scikit-learn</code>实现来达到同样的结果。</p><pre class="mw mx my mz gt nu nv nw nx aw ny bi"><span id="c99c" class="na lf jj nv b gy nz oa l ob oc">from sklearn.decomposition import FastICA</span><span id="11dd" class="na lf jj nv b gy og oa l ob oc">np.random.seed(0)<br/>n_samples = 2000<br/>time = np.linspace(0, 8, n_samples)</span><span id="39be" class="na lf jj nv b gy og oa l ob oc">s1 = np.sin(2 * time)<br/>s2 = np.sign(np.sin(3 * time))<br/>s3 = signal.sawtooth(2 * np.pi * time)</span><span id="4059" class="na lf jj nv b gy og oa l ob oc">S = np.c_[s1, s2, s3]<br/>S += 0.2 * np.random.normal(size=S.shape)<br/>S /= S.std(axis=0)<br/>A = np.array([[1, 1, 1], [0.5, 2, 1.0], [1.5, 1.0, 2.0]])<br/>X = np.dot(S, A.T)</span><span id="56ba" class="na lf jj nv b gy og oa l ob oc">ica = FastICA(n_components=3)<br/>S_ = ica.fit_transform(X)</span><span id="8d08" class="na lf jj nv b gy og oa l ob oc">fig = plt.figure()</span><span id="80f0" class="na lf jj nv b gy og oa l ob oc">models = [X, S, S_]</span><span id="3c3b" class="na lf jj nv b gy og oa l ob oc">names = ['mixtures', 'real sources', 'predicted sources']</span><span id="b393" class="na lf jj nv b gy og oa l ob oc">colors = ['red', 'blue', 'orange']</span><span id="b8d3" class="na lf jj nv b gy og oa l ob oc">for i, (name, model) in enumerate(zip(names, models)):<br/>    plt.subplot(4, 1, i+1)<br/>    plt.title(name)<br/>    for sig, color in zip (model.T, colors):<br/>        plt.plot(sig, color=color)<br/>        <br/>fig.tight_layout()        <br/>plt.show()</span></pre><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/14aa83f8a4ad8d74c33025ca575bf63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6IYD8OfXQBl71n05OTPNg.png"/></div></div></figure><p id="fa56" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">附带的 Jupyter 笔记本可以在<a class="ae jg" href="https://github.com/corymaklin/ida" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>