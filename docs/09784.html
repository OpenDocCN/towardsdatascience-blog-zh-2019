<html>
<head>
<title>Logistic Regression for malignancy prediction in cancer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于癌症中恶性预测的逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-for-malignancy-prediction-in-cancer-27b1a1960184?source=collection_archive---------8-----------------------#2019-12-23">https://towardsdatascience.com/logistic-regression-for-malignancy-prediction-in-cancer-27b1a1960184?source=collection_archive---------8-----------------------#2019-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="eb20" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/ml-for-bio-data" rel="noopener" target="_blank">生物医学数据的机器学习</a></h2><div class=""/><div class=""><h2 id="0ce8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">将逻辑回归应用于威斯康星州乳腺癌(诊断)数据集</h2></div><p id="17a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">在</span> <a class="ae lw" rel="noopener" target="_blank" href="/machine-learning-for-biomedical-data-linear-regression-7d43461cdfa9">一元或多元线性回归</a>中，我们引入了线性回归的概念，这是一种用于机器学习的统计模型，属于算法的监督学习类。此外，我们还讨论了线性回归对生物医学数据的可能应用，特别是在预测连续值输出方面。</p><p id="c9f4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我们将解释<strong class="kt jd">逻辑回归</strong>，另一个监督学习模型，用于预测离散值输出。</p><p id="ab86" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将介绍逻辑回归背后的数学概念，通过 Python，一步一步，我们将制作乳腺癌恶性肿瘤的预测器。我们将使用<a class="ae lw" href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29" rel="noopener ugc nofollow" target="_blank">“威斯康辛乳腺癌(诊断)”</a> (WBCD)数据集，由威斯康辛大学提供，由<a class="ae lw" href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)" rel="noopener ugc nofollow" target="_blank"> UCI 机器学习库</a>托管。</p><p id="434d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该数据库的创建者 Mangasarian、Street 和 Wolberg 博士打算利用从微创细针抽吸(FNA)获得的乳腺癌单个细胞的 30 个特征，使用机器学习来区分乳腺肿块的良性和恶性肿块[1]。</p><p id="1722" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">简而言之，FNA 是一种活检，医生使用连接到注射器的针头从可疑区域提取少量细胞。然后检查活检以确定癌症[2]。</p><p id="b4aa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用基于<em class="lx">曲线拟合算法</em>的图像分析软件<em class="lx"> Xcyt </em>，作者能够从 FNA 的数字化 640×400、每像素 8 位灰度图像中确定细胞核的边界。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/9d8d65761fda85cbb1227831f5319aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ih7lT_0hlcFbb7f57YVstg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 1: A magnified image of a malignant breast FNA. A curve-fitting algorithm was used to outline the cell nuclei. (Figure from Mangasarian OL., Street WN., Wolberg. WH. Breast Cancer Diagnosis and Prognosis via Linear Programming. Mathematical Programming Technical Report 94–10. 1994 Dec)</figcaption></figure><p id="c540" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这 30 个特征描述了扫描图像中存在的细胞核的特征。</p><p id="907d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如他们在论文中所报道的，作者已经使用机器学习和图像处理技术来完成恶性肿瘤预后预测。然而，对它们的计算方法的深入研究超出了本文的目的。</p><p id="6d03" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本帖中，我们不会翻拍曼加萨里安、斯特里特和沃尔伯格的作品。我们将使用他们的数据集，基于 WBCD 的 30 个要素中的一些要素，以 Python 语言实现逻辑回归预测器。我们将根据 FNA 数据，使用良性/恶性结果来预测新患者是否有可能发展为恶性肿瘤。此外，我们的预测器将是一个令人兴奋的场合，它揭示了<em class="lx">逻辑回归</em>的一些基本概念，并围绕生物医学问题实施了一个代码:<strong class="kt jd"> <em class="lx">哪些特征在预测恶性结果</em> </strong>中是必不可少的。</p><p id="3bef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">数据集的第一列对应于患者 ID，而最后一列代表诊断(根据报告的诊断类型，结果可以是“良性”或“恶性”)。结果数据集包括 569 名患者:212 名(37.2%)为恶性，357 名(62.7%)为良性。图 2 描述了数据集结构:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1f3fbf84a8806c204e4e77eaef8c24a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*pTYjcmErbU9tYOUHJ2gYvg.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 2: The Breast Cancer Wisconsin (Diagnostic), dataset structure.</figcaption></figure><p id="6506" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">详细地说，数据集由为每个细胞核计算的十个实值特征组成。分别是<strong class="kt jd"> 1) <em class="lx">半径</em> </strong>(中心到圆周上各点的平均距离)<strong class="kt jd"> 2) <em class="lx">纹理</em> </strong>(灰度值的标准差)<strong class="kt jd"> 3) <em class="lx">周长</em> </strong>，<strong class="kt jd"> 4) <em class="lx">面积</em> </strong>，<strong class="kt jd"> 5) <em class="lx">平滑度</em> </strong>(半径长度的局部变化)<strong class="kt jd"> 6】 <strong class="kt jd"> 8) <em class="lx">凹点</em> </strong>(轮廓的凹部个数)<strong class="kt jd"> 9) <em class="lx">对称性</em></strong><strong class="kt jd">10)<em class="lx">分维</em> </strong>【海岸线近似】-1)。 十个实值特征对应于平均值(第 2 列至第 11 列的值)、标准误差(第 12 列至第 21 列的值)和最差或最大值(三个最大值的平均值)(第 22 列至第 31 列)。列 32 包含良性/恶性结果。</strong></p><p id="5978" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了更加简单，我将 WBDC 格式化为逗号分隔值文件。你可以按照这个<a class="ae lw" href="https://raw.githubusercontent.com/lucazammataro/bioinsteps/master/wdbc.data.csv" rel="noopener ugc nofollow" target="_blank">链接</a>(文件名:<em class="lx"> wdbc.data.csv </em>)下载格式化版本。</p><p id="b827" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在开始之前，我建议读者关注一下 Andrew NG 在 Coursera 开设的有趣的机器学习课程[3]。本课程对这篇文章中讨论的所有论点提供了一个很好的解释。</p><p id="9c76" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">本文中的所有代码都是用 Python 2.7 编写的。对于实现环境，我推荐使用<a class="ae lw" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>。</p><h1 id="4e68" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">步骤 1:从 SciPy 导入包</h1><p id="2267" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">导入本文 Python 代码所需的所有包:Pandas、NumPy、matplotlib 和 SciPy。这些软件包属于 SciPy.org 的<a class="ae lw" href="http://scipy.org/" rel="noopener ugc nofollow" target="_blank">，这是一个基于 Python 的数学、科学和工程开源软件生态系统。此外，我们将导入</a><a class="ae lw" href="http://seaborn.pydata.org/generated/seaborn.pairplot.html" rel="noopener ugc nofollow" target="_blank"> seaborn </a>，这是一个基于 matplotlib 的 Python 数据可视化库。此外，来自<em class="lx"> scipy.optimize </em>包的对象<em class="lx"> op </em>将被创建，以对渐变进行优化。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 1: Import all the packages</figcaption></figure><h1 id="a705" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">步骤 2:上传数据</h1><p id="ca49" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">一旦我们下载了 wdbc.data.csv 文件，用它来创建一个使用<a class="ae lw" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>的数据帧:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 2: Create a pandas DataFrame.</figcaption></figure><p id="35d9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用<em class="lx"> pandas </em>我们可以使用。<em class="lx">头()</em>方法:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi no"><img src="../Images/7c366b0d8cec5adfb0555c3732f5d5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6oPc0ptbAlE3VEgKGloTPg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Table 1: Typing <em class="np">df.head()</em>, will display the DataFrame content (partial output)</figcaption></figure><h1 id="99f3" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">步骤 3:数据可视化和双变量分析</h1><p id="423f" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">现在我们有了一个包含数据的数据框架，我们想确定这 30 个特征中哪些对我们的预测模型是重要的。选择数据集的最佳特征是机器学习中的关键步骤，以获得有用的分类并避免预测偏差。</p><p id="1950" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">可视化每对</em> </strong></p><p id="324d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一种方法是每对的<em class="lx">可视化。正如 Ahmed Qassim 在他的文章<a class="ae lw" rel="noopener" target="_blank" href="/breast-cancer-cell-type-classifier-ace4e82f9a79">中所建议的，使用 seaborn 提供的 pairplot 函数集可以获得优雅的数据显示。</a></em>生成完整特征组合图的 Python 代码如下:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 3: Visualizing all the paired features.</figcaption></figure><p id="814f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里我们已经创建了<em class="lx">seaborn</em>object<em class="lx">SNS；</em>然后<em class="lx">，</em>我们使用了在步骤 2 中生成的<em class="lx">熊猫数据帧(df) </em>作为<em class="lx"> sns </em> <em class="lx"> pairplot </em>方法的参数。注意，指定参数“<em class="lx">色调=诊断，”</em><em class="lx">对绘图</em>方法可以访问包含诊断值(0，1)的<em class="lx"> df </em>列。此外，<em class="lx"> pairplot </em>将使用参数“调色板”根据诊断值用<em class="lx"> b </em>蓝色<em class="lx">或<em class="lx"> r </em>红色给点着色。</em></p><p id="8b02" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了简化可视化，由<em class="lx">代码 3 </em>生成的地图显示了前五对特征的组合。它们代表参数<em class="lx">半径</em>、<em class="lx">纹理</em>、<em class="lx">周长</em>、<em class="lx">面积</em>、<em class="lx">平滑度</em>的平均值。根据您的计算机性能，制作完整的功能图、运行<em class="lx">代码 3、</em>可能需要一些时间。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nq"><img src="../Images/de5b02caa95431bd0699e6154718aa2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0g0QXjsLBIz0c9N2Pv0dQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk"><em class="np">Figure 3: Visualization Per Pair</em></figcaption></figure><p id="4c7a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">每个图块代表一对参数的散点图。这种可视化使得分类的基本元素的识别更加容易。这些对中的一些，如<em class="lx">半径</em>对<em class="lx">纹理</em>或<em class="lx">周长</em>对<em class="lx">平滑度</em>，具有关于<em class="lx">诊断</em>的正确分离级别(蓝点=良性；红斑=恶性)。将成对图中的要素可视化是一个很好的工具，主要是因为它的即时性。</p><p id="ea63" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">双变量分析</em> </strong></p><p id="23a3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">除了可视化之外，用于选择非冗余特征的更有效的方法是<strong class="kt jd"> <em class="lx">双变量分析</em> </strong>，这是一种基于相关性的方法，其分析元素对之间的关系。在这里，我提出一个我从<a class="ae lw" href="https://datascience.stackexchange.com/a/10461" rel="noopener ugc nofollow" target="_blank"> AN6U5 </a>重新改编的代码，它实现了一个用于<em class="lx">双变量分析</em>的函数。此处称为<em class="lx">特征相关矩阵</em>的函数将 WBCD <em class="lx"> df </em>作为参数，并返回 30 个特征的相关矩阵:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 4: Bivariate Analysis: Features Correlation Matrix of the WBCD features</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nr"><img src="../Images/e40d321c0723d136cd832ca291832d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kyr6VeH6sUbIeH06LPoJ8w.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 4: Plotting the Correlation Matrix of the WBDC features</figcaption></figure><p id="daf6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看一看<em class="lx">图 4 中的结果图:我们的目标是</em>了解数据集的 30 个特征是如何相互关联的。在计算变量之间的相关性时，我们可以观察到其中一些变量导致显著相关(值大于 0.9)。<em class="lx">双变量分析</em>的一般假设是高度相关的特征提供冗余信息:出于这个原因，我们想要消除它们，避免预测偏差。</p><p id="df72" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如 Kalshtein Yael 在这篇致力于 R 的 WBCD 分析的文章中所建议的，我们应该删除所有相关性高于 0.9 的特征，保留那些具有较低均值的特征。<em class="lx">代码 5 </em>是一个 Python 代码示例的重新改编，来自<a class="ae lw" href="https://chrisalbon.com/machine_learning/feature_selection/drop_highly_correlated_features/" rel="noopener ugc nofollow" target="_blank">克里斯·阿尔邦</a>的书[4]:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 5: Dropping of features with a correlation greater than 0.9</figcaption></figure><p id="9e73" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">“<em class="lx">到 _ drop”</em>列表<em class="lx"> </em>包含相关性&gt;为 0.9 的十个冗余特征。它们列举如下:</p><pre class="lz ma mb mc gt ns nt nu nv aw nw bi"><span id="b7fe" class="nx mq it nt b gy ny nz l oa ob">['Perimeter',<br/> 'Area',<br/> 'Concave_points',<br/> 'Perimeter_SE',<br/> 'Area_SE',<br/> 'W_Radius',<br/> 'W_Texture',<br/> 'W_Perimeter',<br/> 'W_Area',<br/> 'W_Concave_points']</span></pre><p id="7b2a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们想从我们的<em class="lx">数据帧</em>中消除这些特征，并用剩余的 20 个<em class="lx"> : </em>重新绘制<em class="lx"> df </em></p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 6: Delete the redundant features from the DataFrame and re-plot only the not-redundant</figcaption></figure><p id="e3d0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">图 5 显示了由<em class="lx">代码 6 </em>产生的曲线图:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oc"><img src="../Images/5c70a49c4c19f9d7ad90063b0ff07eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yN3LYbo8Jrd-ajdHbd2gCg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 5: Plotting the Correlation Matrix of the 20 not-redundant features</figcaption></figure><p id="80e3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们现在已经删除了高度相关的特征对，所以只有低相关性的特征，如<em class="lx">半径</em>和<em class="lx">纹理</em>将被保留。我们可以直接访问相关矩阵值，在新的笔记本单元格中键入:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 7: Creating a correlation table of the not-redundant features</figcaption></figure><p id="e520" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">结果输出如下:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi od"><img src="../Images/c229581cf92ff52397d8b2367d86bc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA5dbdrtmsBTN3gzYnsrrQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Table 2: Correlation Matrix of the features (partially displayed)</figcaption></figure><p id="b6d8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">感谢 V <em class="lx">每对可视化</em>和<em class="lx">双变量分析</em> s，现在我们知道哪些特征值得在我们的分析中考虑，然后让我们继续构建我们的<em class="lx">逻辑回归</em>结果<em class="lx"> </em>预测器。在接下来的步骤中，我们将编写一个代码来预测基于非冗余性选择的一对特征的诊断结果。</p><h1 id="b45b" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">第四步:逻辑回归假设模型</h1><p id="e7d7" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">理论上，对于<em class="lx">逻辑回归</em>，我们可以使用与<em class="lx">线性回归相同的假设模型(</em>参见<em class="lx"> </em> <a class="ae lw" rel="noopener" target="_blank" href="/machine-learning-for-biomedical-data-linear-regression-7d43461cdfa9">一个或多个变量的线性回归</a> <em class="lx"> ) </em>)。尽管如此，我们还是有几个原因不能使用<em class="lx"> </em>线性<em class="lx"> </em>假设进行逻辑推理，现在我们来解释一下原因。瞟一眼<em class="lx">图 6 </em>:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oe"><img src="../Images/e611b0a648123b069b44a056996d440a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mK92aIwac1Y8cwTKY2bD3w.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 6. A: Example of binary classification of malignancy prediction in breast cancer. B: The Logistic Regression Hypothesis is a non-linear function.</figcaption></figure><p id="9409" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">图<em class="lx">中的图 6A </em>解释了为什么我们不能将线性假设应用于二元分类。想象一下，我们想用良性或恶性的结果(红圈)来绘制样本。我们可以应用线性假设模型将样本分成两个不同的组。在尝试将二进制值分类为 0 和 1 时，线性回归试图将大于 0.5 的值预测为“1”，将所有小于 0.5 的值预测为“0”，因为<em class="lx"> hθ(x) </em>的阈值分类器输出为 0.5。</p><p id="c74f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">理论上，我们选择的线性回归模型也可以很好地用于二元分类，如蓝线所示。但是让我们看看如果我们插入另一个恶性诊断样本会发生什么(图<em class="lx">中的绿色圆圈 6A </em>)。线性回归假设调整线条以包含新样本(洋红色线条)。</p><p id="d36f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管如此，这种假设模型并不能对我们将要上传的所有新样本都正确工作，因为线性假设似乎并没有给我们的预测增加更多的信息。这是因为分类不是线性函数。我们需要的是一个新的假设<em class="lx"> hθ(x) </em>可以计算出诊断输出可以是 0 或 1 的概率:这个新的假设模型就是<em class="lx">逻辑回归。</em></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi of"><img src="../Images/491c94c5cd90c5a50e7ff862a08aab13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTqPFiSm3UerkAOowm0yHQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 1: Logistic Regression model (Hypothesis)</figcaption></figure><p id="b01f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">等式 1 中的逻辑回归假设模型看起来类似于线性回归。但真正的区别是在<strong class="kt jd"> <em class="lx"> g </em> </strong>函数中，该函数使用翻译后的<em class="lx"> θ </em> <em class="lx">向量</em>与<strong class="kt jd"> <em class="lx"> x </em> </strong> <em class="lx">向量</em>的乘积(我们将该乘积称为<strong class="kt jd"> <em class="lx"> z </em> </strong>)作为参数。<strong class="kt jd"> <em class="lx"> g </em> </strong>函数的定义见<em class="lx">等式 2 </em>:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi og"><img src="../Images/fb0209a0817d56d15389271327ba2fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*THacCNgTjGR6h50u5FFk2g.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 2: Logistic Regression model (Hypothesis)</figcaption></figure><p id="4ffe" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">作为<em class="lx"> sigmoid 函数</em> ( <em class="lx">逻辑函数)</em>的<em class="lx"> g(z) </em>函数是非线性的。它计算诊断输出为 0 或 1 的概率(<em class="lx">图 6B </em>)。</p><p id="fa8d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">实现<em class="lx">逻辑功能</em>的 Python 代码如下:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 8: The Logistic Function (sigmoid function)</figcaption></figure><h1 id="91c1" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">第五步:成本函数</h1><p id="2f9e" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">这一步将回答问题:<em class="lx">Logistic 回归如何选择参数θ？</em>就像线性回归一样，选择θ的唯一方法是计算其成本函数，然后尝试使用复杂的梯度下降优化算法来优化搜索。(步骤 6 的参数)。</p><p id="fcf3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">同样，我们可以使用我们用于线性回归的相同的成本函数，并且它应该看起来像专用于线性回归的文章中的<a class="ae lw" rel="noopener" target="_blank" href="/machine-learning-for-biomedical-data-linear-regression-7d43461cdfa9">等式 4 的成本函数，除了表征假设模型<em class="lx"> hθ(x)的 sigmoid 函数的差异。</em></a></p><p id="9c60" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lx"> </em> <strong class="kt jd"> <em class="lx"> y 向量，</em> </strong>照常，<strong class="kt jd"> <em class="lx"> </em> </strong>表示输出，区别在于，这里的<strong class="kt jd"> <em class="lx"> y </em> </strong>是二元结果(0/1，或良性/恶性)的向量，而不是连续值输出的向量:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bbde7cdbd44c26e6356cfb50359da3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*pxwcrjdsXR8tY6nn62pOIA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 3: The Logistic Regression Cost Function</figcaption></figure><p id="9f87" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">具体地说，我们不能用线性回归成本函数来进行逻辑推理。处理<em class="lx"> hθ(x) </em>的 sigmoid 函数的非线性导致<em class="lx"> J(θ) </em>具有非凸模式，并且看起来像图 7A 中的曲线:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oi"><img src="../Images/feed06e79bc508b1bde9f0035391898a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x9dU2R6ICY3g6U0lQkGAQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 7: non-convex and convex Cost Function</figcaption></figure><p id="0321" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个非凸的<em class="lx"> J(θ) </em>是一个有很多局部最优的函数。不能保证梯度下降会收敛到全局最小值。我们想要的是一个如图 7B 所示的凸<em class="lx"> J(θ) </em>，它是一个收敛到全局最小值的函数。因此，我们必须以保证凸<em class="lx"> J(θ) </em>的方式来写成本函数:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d91ce918424b97cd15bac4460a9c3be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*bR_JOL343hgaa-jfLE7i_w.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 4: Logistic Regression Cost Function</figcaption></figure><p id="34cb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">实施<em class="lx">等式 4 </em>，成本函数计算为<em class="lx"> log(z) </em>，看起来像<em class="lx">图 8 </em>的红色曲线:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ok"><img src="../Images/0bc87da906f18b04491d7e9cad500410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md8lrBhVE8m9cgcqyv5pPQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 8: Plotting Logistic Regression Cost Function</figcaption></figure><p id="8135" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因为我们有两个良性或恶性结果的二元条件(<em class="lx">y</em>),<em class="lx">等式 4 </em>中的成本函数表示我们关于 y 的假设预测的成本为。</p><p id="c3da" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果<strong class="kt jd"> <em class="lx"> y = 1 </em> </strong>，但是我们预测<strong class="kt jd"> <em class="lx"> hθ(x) = 0 </em>，</strong>我们会以相当大的代价来惩罚学习算法(见图 8 中的<strong class="kt jd">红色曲线</strong>因为，在这种情况下，代价将趋于无穷大。相反，如果我们的预测是<strong class="kt jd"> <em class="lx"> hθ(x) = 1，</em> </strong> <em class="lx"> </em>(从而等于<em class="lx"> y </em>)，那么成本将为 0。</p><p id="4460" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<em class="lx"> </em> <strong class="kt jd"> <em class="lx"> y = 0 </em>，</strong>的情况下，我们有相反的情况:如果<em class="lx"/><strong class="kt jd"><em class="lx">y = 0</em></strong>并且我们预测<strong class="kt jd"> <em class="lx"> hθ(x) = 0 </em>，</strong>成本将会是 0，因为我们的假设与 y 匹配，而如果我们的预测是<strong class="kt jd"> <em class="lx"> hθ(x) = 1 </em> </strong>，我们</p><p id="d8cd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lx">成本函数</em>的简化版本如下:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ol"><img src="../Images/2bde5872b8cac280979e1577fb8144ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-E883h8fbjOFDH53cVDYvA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 5: Simplified Logistic Regression Cost Function</figcaption></figure><p id="d7d1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果<strong class="kt jd"> <em class="lx"> y = 0 </em> </strong>，则<em class="lx">代价函数</em>将等于<strong class="kt jd"><em class="lx">-(log(1-hθ(x))</em></strong>。如果<strong class="kt jd"> <em class="lx"> y = 1，</em> </strong>等式 5 的第二部分将为 0，那么代价将等于<strong class="kt jd"><em class="lx">-y * log(hθ(x))</em></strong>。简化和矢量化的<em class="lx">成本函数</em>的 Python 实现如下:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 9: The Logistic Regression Cost Function</figcaption></figure><h1 id="44b8" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">第六步:梯度函数及其优化</h1><p id="3d74" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">在<a class="ae lw" rel="noopener" target="_blank" href="/machine-learning-for-biomedical-data-linear-regression-7d43461cdfa9">致力于线性回归</a>的帖子中，我们介绍了<strong class="kt jd"> <em class="lx">梯度下降</em> </strong>，这是一种计算代价函数导数的算法，通过参数<em class="lx"> α、</em>即学习率来更新向量<em class="lx"> θ </em> <strong class="kt jd"> <em class="lx"> </em> </strong>。</p><p id="0360" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但在机器学习场景中，梯度下降并不是最小化成本函数的唯一算法:<strong class="kt jd"> <em class="lx">共轭梯度，例如 BFGS、L-BGFS、TNC、</em>、</strong>，代表了一些更复杂的用于最小化成本函数的<strong class="kt jd"> <em class="lx"> </em> </strong>算法，在自动化<em class="lx"> θ </em>的搜索中。</p><p id="2413" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">基于不同的统计，这些算法试图优化<em class="lx">梯度函数</em>，该函数是数据集的实际向量<em class="lx"> y </em>和<em class="lx"> h 向量(</em>预测<em class="lx">)</em>之间的差，以了解如何找到最小值<em class="lx"> J </em>。概括地说，一个优化算法将重复，直到它将收敛。重要的是:更新<em class="lx"> θ </em> <strong class="kt jd">总是</strong>必须同时进行。</p><p id="a086" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">优化算法是<em class="lx">数值优化</em>领域的争论点，对算法使用的深入研究超出了本文的范围。我们将要实现的梯度函数看起来与用于线性回归的函数相同。但是在这里，对于成本函数<em class="lx">，</em>来说，区别在于需要 sigmoid 函数的<em class="lx"> hθ(x) </em>的定义:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi om"><img src="../Images/c66132fa80fbb8cf3b8a6e7a641a358b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mku7jaGPmh-chn6kTZa9Iw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 6: Logistic Regression Gradient wrapped in a generic optimizing algorithm.</figcaption></figure><p id="45aa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">梯度函数的矢量化实现的等式为:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi on"><img src="../Images/4a63195d4f68c3f53b2c575b3cb33d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHLCMDmyBWVc7Maj3vjiAw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Equation 7: Vectorized Logistic Regression Gradient</figcaption></figure><p id="f049" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">计算<em class="lx">梯度</em>的 Python 代码如下:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 10: The Gradient Function</figcaption></figure><p id="ba36" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在第 9 步中，我们将看到如何优化梯度函数，使用<em class="lx"> scipy.optimize </em>提供的算法之一。</p><h1 id="12bd" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">步骤 7:特征缩放和标准化</h1><p id="4815" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">我们可能需要重新调整和标准化我们的数据。计算两个变量的<em class="lx">特征缩放和归一化</em>的 Python 代码如下:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 11: Feature Scaling and Normalization for two variables</figcaption></figure><h1 id="d422" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">第八步:计算准确度</h1><p id="704c" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">该函数计算我们算法的<em class="lx">精度</em>:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 12: The function for calculating the accuracy.</figcaption></figure><h1 id="6256" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">步骤 9:用两个变量实现逻辑回归</h1><p id="be1d" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">在前面的步骤中，我们已经为实施<em class="lx">逻辑回归创建了所有的基本函数。</em>让我们来简单总结一下:</p><pre class="lz ma mb mc gt ns nt nu nv aw nw bi"><span id="53bf" class="nx mq it nt b gy ny nz l oa ob">sigmoid(z)<br/>calcCostFunction(theta, X, y)<br/>calcGradient(theta, X, y)<br/>FeatureScalingNormalization(X)<br/>CalcAccuracy(theta, X)</span></pre><p id="d81c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们将编写包装所有这些函数的代码，根据我们数据集的 20 个非冗余特征中的两个来预测恶性肿瘤的结果。对于特征的选择，我们可以参考我们在步骤 3 中找到的一对，<em class="lx">半径，</em>和<em class="lx">纹理，</em>，它们的相关分数= 0.32。以下代码从<em class="lx">数据帧 df: </em>中产生特征 numpy 数组<em class="lx"> X </em>和输出 numpy 向量<em class="lx"> y，</em></p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 13: Make the X and y numpy arrays</figcaption></figure><p id="b9a6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们画出这两个特征:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 14: Plot the features</figcaption></figure><p id="1fe8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在图 7 中，显示了结果图:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oo"><img src="../Images/6fa55080a326118fc4c731c16dc7b8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRge6-A--oZxfkNG__LoAw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 7: Plotting Radius and Texture</figcaption></figure><p id="0f43" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">黄点代表良性，黑色，恶性。</p><p id="bf9f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们将<strong class="kt jd"><em class="lx"/></strong>的数据正常化并缩放。另外，我们需要收集<strong class="kt jd"> <em class="lx"> mu </em> </strong>，它是我们训练集中<em class="lx"> X </em>的平均值，以及<strong class="kt jd"> <em class="lx"> sigma </em> </strong>即<em class="lx">标准差。</em>在新的笔记本单元格中，让我们键入:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 15: Run Feature Scaling and Normalization</figcaption></figure><p id="8f7c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们必须用方法更新数组 X，添加一列“1”。<em class="lx"> vstack: </em></p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 16: Add a column of “ones” to the X matrix</figcaption></figure><p id="4399" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">测试</em> </strong></p><p id="2842" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们做一些测试:为了测试我们的代码，让我们试着计算<em class="lx">成本函数</em>和<em class="lx">梯度</em>，从一个<em class="lx"> θ = [0，0，0]: </em>开始</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 17: 1st test; compute Cost Function and Gradient starting with initial θ = 0</figcaption></figure><p id="dbe8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">新的<em class="lx"> θ </em>向量<em class="lx"> </em>为<em class="lx"> </em>现<em class="lx"> </em> = [ 0.12741652，-0.35265304，-0.20056252]，关联的<em class="lx"> J(θ) </em> = 0.69。</p><p id="617c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">此外，我们可以尝试非零值的<em class="lx"> θ，</em>并看看会发生什么:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 18: 2nd test; compute Cost Function and Gradient starting with initial not-zero θ</figcaption></figure><p id="e730" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">更新后的<em class="lx"> θ </em>向量现在是<em class="lx"> </em> = [-0.37258348，-0.35265304，-0.20056252]，关联的<em class="lx"> J(θ) </em> = 8.48。</p><p id="8831" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">渐变下降高级优化</em> </strong></p><p id="bc98" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将用于寻找<em class="lx"> θ </em>的优化算法是<strong class="kt jd"> <em class="lx"> BFGS </em> </strong>，它基于 Broyden、Fletcher、Goldfarb 和 Shanno [5]的拟牛顿法。<em class="lx">代码 19 </em>将实现函数<em class="lx"> Scypy </em> <em class="lx"> minimize，</em>将在内部调用<em class="lx"> BFGS </em>方法:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 19: Gradient Descent Advanced Optimization</figcaption></figure><p id="a42f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们不指定我们想要在参数“Method”中使用的<em class="lx">方法</em>的类型。<em class="lx">最小化</em>功能，默认使用 BFGS 算法。另一种方法，即<strong class="kt jd"> <em class="lx"> TNC </em> </strong>，使用截断牛顿算法来最小化变量受限的函数。用户可以尝试各种类型的优化算法。<em class="lx">最小化 Scypy 中的</em>功能。<a class="ae lw" href="https://www.coursera.org/learn/machine-learning/supplement/cmjIc/advanced-optimization" rel="noopener ugc nofollow" target="_blank">参见 Scypy 文档页面，了解更多关于所有优化方法和函数的信息</a>。<em class="lx">最小化</em>。<em class="lx">代码 18，</em>产生的输出如下:</p><pre class="lz ma mb mc gt ns nt nu nv aw nw bi"><span id="028d" class="nx mq it nt b gy ny nz l oa ob">fun: 0.2558201286363281<br/> hess_inv: array([[12.66527269, -1.22908954, -2.82539649],<br/>       [-1.22908954, 71.16261306,  7.07658929],<br/>       [-2.82539649,  7.07658929, 13.39777084]])<br/>      jac: array([7.36409258e-07, 3.24760454e-08, 9.55291040e-07])<br/>  message: 'Optimization terminated successfully.'<br/>     nfev: 20<br/>      nit: 19<br/>     njev: 20<br/>   status: 0<br/>  success: True<br/>        x: array([-0.70755981,  3.72528774,  0.93824469])</span></pre><p id="c3ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">决定边界</em> </strong></p><p id="08de" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">BFGS 算法找到了<em class="lx"> scypy.minimize </em>函数<em class="lx">的<em class="lx"> θ = [-0.70755981，3.72528774，0.93824469] </em>，对应一个包含<em class="lx"> Result.x </em>自变量的向量。</em>在步骤 3 中，我们提到，对于逻辑回归，假设<em class="lx"> hθ(x) </em>计算输出可以为 0 或 1 的概率<em class="lx">。</em>为了将这个概率映射到一个离散的类别(良性/恶性)，我们选择一个阈值 0.5，高于这个阈值的值将被分类为“1”，低于这个阈值的值将被分类为“0”。所以，我们要做的是跟踪所谓的<em class="lx">决策边界</em>。决策边界是假设及其参数<em class="lx"> θ，</em>的属性，而不是数据集的属性。让我们再次绘制<em class="lx">半径</em>和<em class="lx">纹理</em>特征，但是添加一条红线，代表找到的<em class="lx"> θ </em>的决定边界:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 20: Plot the data and the Decision Boundary</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi op"><img src="../Images/e67708d5e2f8d9a9b1e06c97678f07c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbNACk_8i1iKLRAth06xNw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Figure 8: Plotting Radius and Texture together to the decision boundary</figcaption></figure><p id="3cb3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我认为重要的是要强调，令人惊讶的是，尽管逻辑回归在其假设模型中使用了非线性(sigmoid)函数，但决策边界是线性的！</p><p id="7c67" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">计算精度</em> </strong></p><p id="2464" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们要计算我们算法的精度。步骤 8 中描述的函数 CalcAccuracy 将完成这项工作:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 21: calculate the accuracy</figcaption></figure><p id="ba9d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lx">计算精度</em>的输出是 89.1，这是一个很好的精度分数！</p><p id="d404" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="lx">做出预测</em> </strong></p><p id="1da0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们已经测试了我们的算法并评估了它的准确性，我们想要进行预测。下面的代码代表了一个可能的查询示例:我们想知道<em class="lx">半径</em> = 18.00 和<em class="lx">纹理</em> = 10.12 的结果是什么:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 22: Example of Query; predict the risk of malignancy for Radius = 18.00 and Texture = 10.12</figcaption></figure><p id="ac12" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请注意，我们必须使用<em class="lx"> mu </em>和<em class="lx"> sigma </em>来规范化查询，以便进行缩放和规范化。预测的结果是 0.79，这意味着对于半径= 18 和纹理=10.12，恶性肿瘤的风险接近 1。</p><h1 id="0b6b" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">步骤 10:如何为多个变量修改代码</h1><p id="0795" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">在这一步中，我们将修改前面的代码来处理多个变量。需要更新的内容很少:首先是关于特征缩放和归一化功能:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 23: The Feature Scaling and Normalization function for multiple variables</figcaption></figure><p id="90ef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其他小的修改涉及上传 X 向量的代码和查询的代码。下面的代码重新组合了我们到目前为止所做的工作，将所有函数扩展到使用多变量逻辑回归。将以下代码复制并粘贴到新的 Jupyter 笔记本单元格中:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Code 24: The complete Logistic Regression code for multiple variables</figcaption></figure><p id="54ee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">代码 24 将预测恶性肿瘤的风险:半径= 5.00，纹理= 1.10，W _ 凹面 _ 点= 0.4。在所有计算之后，它将产生以下输出:</p><pre class="lz ma mb mc gt ns nt nu nv aw nw bi"><span id="c491" class="nx mq it nt b gy ny nz l oa ob">Your Query is: 5.0, 1.1, 0.4<br/>BFGS Message: Optimization terminated successfully.<br/>Theta found: -1.40776926  3.13487429  1.52552603  4.02250701<br/>Train Accuracy: 95.43057996485061<br/>Prediction: 0.8154762110038786</span></pre><p id="67bc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些输入值的恶性肿瘤预测值接近 1。修改查询，您可以自己试验概率是如何变化的。</p><h1 id="89a8" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论和考虑</h1><p id="813e" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">逻辑回归是一种强大的机器学习工具，我们可以成功地使用它来预测生物医学数据的分类输出。数据争论和数据挖掘可以从 Python 及其库提供的出色性能中受益，社区对它们的支持非常好。线性代数编程在尽可能避免“while”和“for”循环方面具有内在优势。它可以通过 numpy 实现，numpy 是一个将矩阵矢量化的包。Numpy 使得在其上工作更加舒适，并保证对操作的更好控制，特别是对于大型数组。</p><p id="18b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">此外，Python 的机器学习场景因许多强大包的出现而变得丰富(即，<a class="ae lw" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow，</a> <a class="ae lw" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>，以及其他由于技术原因，我们在本文中没有提到的包)，这些包提供了对数据的出色优化分类和预测。</p><p id="b15e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然配备了 Python 及其所有附件的机器学习可以代表预防和诊断医学的未来之路，但理解生物变量的局限性可能会使这条道路变得尴尬。</p><p id="4464" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">威斯康星乳腺癌(诊断)数据集有 569 名患者和 30 个特征，提供了分类参数的详尽分类，因此代表了机器学习应用的完美示例。无论如何，这些特征中的许多似乎是多余的，并且它们中的一些对分类和预测的明确影响仍然是未知的。</p><p id="c757" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们在步骤 3 中引入了双变量分析，以减少冗余特征的数量。关于这些特征在预测中的作用的深入讨论应该值得一篇专门的文章。</p><p id="dbd6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">希望这篇帖子对你有用！</p><h1 id="efd8" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">参考资料:</h1><ol class=""><li id="9580" class="oq or it kt b ku nh kx ni la os le ot li ou lm ov ow ox oy bi translated">Mangasarian，Olvi &amp; Street，Nick &amp; Wolberg，William。(1970).基于线性规划的乳腺癌诊断和预后。运筹学 43.<a class="ae lw" href="https://pubsonline.informs.org/doi/pdf/10.1287/opre.43.4.570" rel="noopener ugc nofollow" target="_blank"/></li><li id="3118" class="oq or it kt b ku oz kx pa la pb le pc li pd lm ov ow ox oy bi translated"><a class="ae lw" href="https://www.cancer.org/cancer/breast-cancer/screening-tests-and-early-detection/breast-biopsy/fine-needle-aspiration-biopsy-of-the-breast.html" rel="noopener ugc nofollow" target="_blank">https://www . cancer . org/cancer/breast-cancer/screening-tests-and-early-detection/乳腺活检/乳腺细针穿刺活检. html#references </a></li><li id="f1c9" class="oq or it kt b ku oz kx pa la pb le pc li pd lm ov ow ox oy bi translated">Andrew NG，机器学习| Coursera。</li><li id="37bd" class="oq or it kt b ku oz kx pa la pb le pc li pd lm ov ow ox oy bi translated">Chris Albon,《Python 机器学习指南》, O'Really，ISBN-13:978–1491989388。</li><li id="9b14" class="oq or it kt b ku oz kx pa la pb le pc li pd lm ov ow ox oy bi translated">诺塞达尔，J .和 S J .赖特。2006.数值优化。斯普林格纽约。</li></ol></div></div>    
</body>
</html>