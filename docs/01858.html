<html>
<head>
<title>Dealing with Apply functions in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 R 中处理应用函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dealing-with-apply-functions-in-r-ea99d3f49a71?source=collection_archive---------9-----------------------#2019-03-27">https://towardsdatascience.com/dealing-with-apply-functions-in-r-ea99d3f49a71?source=collection_archive---------9-----------------------#2019-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/442f876122dbcc1ff406e73a97732ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*IBBn38qq8fXa2K63aYztdQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Apply functions in R</figcaption></figure><p id="e59a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">迭代控制结构(像 for、while、repeat 等循环。)允许多次重复指令。然而，在大规模数据处理中，使用这些循环会消耗更多的时间和空间。借助于<strong class="ka ir"> Apply </strong>函数，r 语言有一种更高效、更快速的方法来执行迭代。</p><p id="2272" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将从视觉角度讨论<code class="fe kw kx ky kz b"><strong class="ka ir">apply</strong></code>函数在循环中的效率，然后进一步讨论<code class="fe kw kx ky kz b"><strong class="ka ir">apply</strong></code> <strong class="ka ir"> </strong>家族的成员。</p><p id="53b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进一步讨论<code class="fe kw kx ky kz b"><strong class="ka ir">apply</strong></code>函数之前，让我们先看看与基本循环相比，使用<code class="fe kw kx ky kz b"><strong class="ka ir">apply</strong></code>函数的代码执行如何花费更少的迭代时间。</p><p id="29fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑在 r 的<code class="fe kw kx ky kz b">gamclass</code>包中可用的<code class="fe kw kx ky kz b"><strong class="ka ir">FARS(Fatality Analysis Recording System)</strong></code>数据集。它包含 17 个不同特征的 151158 个观察值。该数据集包括至少有一人死亡的所有事故，数据仅限于前排乘客座位有人的车辆。</p><p id="242e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们假设我们想要计算年龄列的平均值。这可以使用传统的循环和应用函数来完成。</p><p id="d9d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">方法 1:使用 for 循环</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9957" class="li lj iq kz b gy lk ll l lm ln">library("gamclass")<br/>data(FARS)<br/>mean_age &lt;- NULL<br/>total &lt;- NULL<br/>for(i in 1:length(FARS$age)){<br/>  total &lt;- sum(total, FARS$age[i])<br/> }<br/>mean_age &lt;- total/length(FARS$age)<br/>mean_age</span></pre><p id="6821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">方法 2:使用 apply()函数</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8d84" class="li lj iq kz b gy lk ll l lm ln">apply(FARS[3],2, mean)</span></pre><p id="40aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们借助<code class="fe kw kx ky kz b">Profvis</code>包，通过可视化模式来比较这两种方法。</p><p id="8a83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Profvis</code> <em class="lo"> </em>是一个代码剖析工具，它提供了一个交互式图形界面，用于可视化指令在整个执行过程中的内存和时间消耗。</p><p id="fa41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用<code class="fe kw kx ky kz b">profvis</code>，把指令放在<code class="fe kw kx ky kz b">profvis()</code>中，它在 R studio 的一个新标签中打开一个交互式的 profile visualizer。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6591" class="li lj iq kz b gy lk ll l lm ln">#for method 1<br/>profvis({<br/>mean_age &lt;- NULL<br/>total &lt;- NULL<br/>for(i in 1:length(FARS$age)){<br/>  total &lt;- sum(total, FARS$age[i])<br/> }<br/>mean_age &lt;- total/length(FARS$age)<br/>mean_age<br/>})</span></pre><p id="9c63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用方法 1 输出</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lp"><img src="../Images/99fb9085dc06c0317dabdb90503b0461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYc1TRYVdWF12frADChfdw.png"/></div></div></figure><p id="0762" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在火焰图选项卡下，我们可以检查指令所用的时间(毫秒)。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0949" class="li lj iq kz b gy lk ll l lm ln">#for method 2<br/>profvis({<br/>  apply(FARS[3],2, mean)<br/>})</span></pre><p id="c7b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用方法 2 输出</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lu"><img src="../Images/640ecddad073c8cecbdb9979594200bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M73olXQpqBR0ugOIzH99FA.png"/></div></div></figure><p id="d470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，人们可以很容易地注意到，使用方法 1 所花费的时间几乎是 1990 ms (1960 +30)，而对于方法 2，它仅仅是 20 ms。</p><h2 id="51b5" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">应用函数优于传统循环的优势</h2><ol class=""><li id="37ca" class="mm mn iq ka b kb mo kf mp kj mq kn mr kr ms kv mt mu mv mw bi translated">执行起来更有效率和更快。</li><li id="6049" class="mm mn iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">易于遵循的语法(而不是使用 apply 函数只编写一行代码来编写一组指令)</li></ol><h2 id="d3d5" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">在 R 中应用系列</h2><p id="b325" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">Apply family 包含各种不同的函数，适用于不同的数据结构，如列表、矩阵、数组、数据框等。apply 家族的成员有<code class="fe kw kx ky kz b">apply()</code>、<code class="fe kw kx ky kz b">lapply()</code>、<code class="fe kw kx ky kz b">sapply()</code>、<code class="fe kw kx ky kz b">tapply()</code>、<code class="fe kw kx ky kz b">mapply()</code>等。这些函数是循环的替代品。</p><p id="030d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个应用函数至少需要两个参数:一个对象和另一个函数。该函数可以是任何内置的(如平均值、总和、最大值等。)或用户自定义函数。</p><h1 id="eec3" class="nf lj iq bd lv ng nh ni ly nj nk nl mb nm nn no me np nq nr mh ns nt nu mk nv bi translated">浏览成员</h1><h2 id="b700" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">1.apply()函数</h2><p id="0fe0" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe kw kx ky kz b">apply()</code>的语法如下</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1fdddb1887ced2d4e9234ee4153a59fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*MU9DKWA6hmKpg1-VD3cS4A.png"/></div></figure><p id="b6fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe kw kx ky kz b">X </code>是一个输入数据对象，<code class="fe kw kx ky kz b">MARGIN</code>表示函数如何适用于行或列，margin = 1 表示行，margin = 2 表示列，<code class="fe kw kx ky kz b">FUN</code>指向一个内置或用户定义的函数。</p><p id="3505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出对象类型取决于输入对象和指定的函数。<code class="fe kw kx ky kz b">apply()</code>可以返回不同输入对象的向量、列表、矩阵或数组，如下表所述。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8c93a796461157f96e33af719e518674.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*V3juasHOzh-ew3POY8lqjw.png"/></div></figure><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="949b" class="li lj iq kz b gy lk ll l lm ln">#---------- apply() function ---------- <br/>#case 1. matrix as an input argument<br/>m1 &lt;- matrix(1:9, nrow =3)<br/>m1<br/>result &lt;- apply(m1,1,mean)   #mean of elements for each row<br/>result<br/>class(result)                #class is a vector<br/>result &lt;- apply(m1,2,sum)    #sum of elements for each column<br/>result<br/>class(result)                #class is a vector<br/>result &lt;- apply(m1,1,cumsum) #cumulative sum of elements for each row<br/>result                       #by default column-wise order<br/>class(result)                #class is a matrix<br/>matrix(apply(m1,1,cumsum), nrow = 3, byrow = T) #for row-wise order <br/>#user defined function <br/>check&lt;-function(x){<br/>  return(x[x&gt;5])<br/>}<br/>result &lt;- apply(m1,1,check)  #user defined function as an argument<br/>result<br/>class(result)                #class is a list</span><span id="f8b1" class="li lj iq kz b gy ny ll l lm ln">#case 2. data frame as an input<br/>ratings &lt;- c(4.2, 4.4, 3.4, 3.9, 5, 4.1, 3.2, 3.9, 4.6, 4.8, 5, 4, 4.5, 3.9, 4.7, 3.6)<br/>employee.mat &lt;- matrix(ratings,byrow=TRUE,nrow=4,dimnames = list(c("Quarter1","Quarter2","Quarter3","Quarter4"),c("Hari","Shri","John","Albert")))<br/>employee &lt;- as.data.frame(employee.mat)<br/>employee<br/>result &lt;- apply(employee,2,sum)     #sum of elements for each column<br/>result<br/>class(result)                       #class is a vector<br/>result &lt;- apply(employee,1,cumsum)  #cumulative sum of elements for each row<br/>result                              #by default column-wise order<br/>class(result)                       #class is a matrix<br/>#user defined function <br/>check&lt;-function(x){<br/>  return(x[x&gt;4.2])<br/>}<br/>result &lt;- apply(employee,2,check)   #user defined function as an argument<br/>result<br/>class(result)                       #class is a list</span></pre><h2 id="e27b" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">2.<code class="fe kw kx ky kz b">lapply()</code>功能</h2><p id="5df8" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe kw kx ky kz b">lapply()</code>总是返回一个列表，<code class="fe kw kx ky kz b">lapply()</code>中的‘l’指的是‘list’。<code class="fe kw kx ky kz b">lapply()</code>处理输入中的列表和数据帧。<code class="fe kw kx ky kz b">MARGIN</code>此处不需要参数，指定的函数仅适用于列。请参考下表了解输入对象和相应的输出对象。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f935d828aae11b1bbb64e11b031b3b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Pr-1xzu92CLbjge4DHK_OA.png"/></div></figure><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c8c5" class="li lj iq kz b gy lk ll l lm ln">#---------- lapply() function ---------- <br/>#case 1. vector as an input argument<br/>result &lt;- lapply(ratings,mean)<br/>result<br/>class(result)                       #class is a list</span><span id="f777" class="li lj iq kz b gy ny ll l lm ln">#case 2. list as an input argument<br/>list1&lt;-list(maths=c(64,45,89,67),english=c(79,84,62,80),physics=c(68,72,69,80),chemistry = c(99,91,84,89))<br/>list1<br/>result &lt;- lapply(list1,mean)<br/>result<br/>class(result)                       #class is a list<br/>#user defined function<br/>check&lt;-function(x){<br/>  return(x[x&gt;75])<br/>}<br/>result &lt;- lapply(list1,check)       #user defined function as an argument<br/>result<br/>class(result)                       #class is a list</span><span id="bfda" class="li lj iq kz b gy ny ll l lm ln">#case 3. dataframe as an input argument<br/>result &lt;- lapply(employee,sum)     #sum of elements for each column<br/>result<br/>class(result)                       #class is a list<br/>result &lt;- lapply(employee,cumsum)  #cumulative sum of elements for each row<br/>result                              <br/>class(result)                       #class is a list<br/>#user defined function <br/>check&lt;-function(x){<br/>  return(x[x&gt;4.2])<br/>}<br/>result &lt;- lapply(employee,check)   #user defined function as an argument<br/>result<br/>class(result)                      #class is a list</span></pre><p id="ee9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b"><strong class="ka ir">apply()</strong></code><strong class="ka ir">vs</strong><code class="fe kw kx ky kz b"><strong class="ka ir">lapply()</strong></code></p><ul class=""><li id="efd8" class="mm mn iq ka b kb kc kf kg kj oa kn ob kr oc kv od mu mv mw bi translated"><code class="fe kw kx ky kz b">lapply()</code>总是返回一个列表，而<code class="fe kw kx ky kz b">apply()</code>可以返回一个向量、列表、矩阵或数组。</li><li id="1b9b" class="mm mn iq ka b kb mx kf my kj mz kn na kr nb kv od mu mv mw bi translated"><code class="fe kw kx ky kz b">lapply()</code>中没有<code class="fe kw kx ky kz b">MARGIN</code>的范围。</li></ul><h2 id="971b" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">3.<code class="fe kw kx ky kz b">sapply()</code>功能</h2><p id="e848" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe kw kx ky kz b">sapply()</code>是<code class="fe kw kx ky kz b">lapply()</code>的简化形式。它有一个额外的参数<code class="fe kw kx ky kz b"><strong class="ka ir">simplify</strong></code> <strong class="ka ir"> </strong>，默认值为 true <strong class="ka ir">，</strong>如果<code class="fe kw kx ky kz b">simplify = F</code>那么<code class="fe kw kx ky kz b">sapply()</code>返回一个类似于<code class="fe kw kx ky kz b">lapply()</code>的列表，否则返回最简单的输出形式。</p><p id="8562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参考下表了解输入对象和相应的输出对象。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c040ceb3edccc4bb5b8be2c401c6e994.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*ALlwjH0drVjMJ5CnQdDiUw.png"/></div></figure><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8886" class="li lj iq kz b gy lk ll l lm ln">#---------- sapply() function ---------- <br/>#case 1. vector as an input argument<br/>result &lt;- sapply(ratings,mean)<br/>result<br/>class(result)                       #class is a vector<br/>result &lt;- sapply(ratings,mean, simplify = FALSE)<br/>result <br/>class(result)                       #class is a list<br/>result &lt;- sapply(ratings,range)<br/>result<br/>class(result)                       #class is a matrix</span><span id="c8a1" class="li lj iq kz b gy ny ll l lm ln">#case 2. list as an input argument<br/>result &lt;- sapply(list1,mean)<br/>result<br/>class(result)                       #class is a vector<br/>result &lt;- sapply(list1,range)<br/>result<br/>class(result)                       #class is a matrix<br/>#user defined function<br/>check&lt;-function(x){<br/>  return(x[x&gt;75])<br/>}<br/>result &lt;- sapply(list1,check)       #user defined function as an argument<br/>result<br/>class(result)                       #class is a list</span><span id="95e6" class="li lj iq kz b gy ny ll l lm ln">#case 3. dataframe as an input argument<br/>result &lt;- sapply(employee,mean)<br/>result<br/>class(result)                       #class is a vector<br/>result &lt;- sapply(employee,range)<br/>result<br/>class(result)                       #class is a matrix<br/>#user defined function<br/>check&lt;-function(x){<br/>  return(x[x&gt;4])<br/>}<br/>result &lt;- sapply(employee,check)    #user defined function as an argument<br/>result<br/>class(result)                       #class is a list</span></pre><h2 id="e04c" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">4.<code class="fe kw kx ky kz b">tapply()</code>功能</h2><p id="679f" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe kw kx ky kz b">tapply()</code>在处理分类变量时很有用，它将一个函数应用于分布在不同类别中的数字数据。<code class="fe kw kx ky kz b">tapply()</code>最简单的形式可以理解为</p><p id="61ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">tapply(column 1, column 2, FUN)</code></p><p id="8821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe kw kx ky kz b">column 1</code>是函数应用的数字列，<code class="fe kw kx ky kz b">column 2</code>是因子对象，<code class="fe kw kx ky kz b">FUN</code>是要执行的函数。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6bc9" class="li lj iq kz b gy lk ll l lm ln">#---------- tapply() function ---------- <br/>salary &lt;- c(21000,29000,32000,34000,45000)<br/>designation&lt;-c("Programmer","Senior Programmer","Senior Programmer","Senior Programmer","Manager")<br/>gender &lt;- c("M","F","F","M","M")<br/>result &lt;- tapply(salary,designation,mean)<br/>result<br/>class(result)                       #class is an array<br/>result &lt;- tapply(salary,list(designation,gender),mean)<br/>result<br/>class(result)                       #class is a matrix</span></pre><h2 id="85b6" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">5.by()函数</h2><p id="d743" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe kw kx ky kz b">by()</code>执行与<code class="fe kw kx ky kz b">tapply()</code>类似的工作，即对分布在不同类别中的数值向量值进行运算。<code class="fe kw kx ky kz b">by()</code>是<code class="fe kw kx ky kz b">tapply()</code>的一个包装函数。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="91d6" class="li lj iq kz b gy lk ll l lm ln">#---------- by() function ---------- <br/>result &lt;- by(salary,designation,mean)<br/>result<br/>class(result)                       #class is of "by" type<br/>result[2]                           #accessing as a vector element<br/>as.list(result)                     #converting into a list<br/>result &lt;- by(salary,list(designation,gender),mean)<br/>result<br/>class(result)                       #class is of "by" type<br/>library("gamclass")<br/>data("FARS")<br/>by(FARS[2:4], FARS$airbagAvail, colMeans)</span></pre><h2 id="52ad" class="li lj iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">6.<code class="fe kw kx ky kz b">mapply()</code>功能</h2><p id="b91b" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe kw kx ky kz b">mapply()</code>中的“m”是指“多元”。它将指定的函数逐个应用于参数。请注意，在这里，function 被指定为第一个参数，而在其他应用函数中，它被指定为第三个参数。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0cf1" class="li lj iq kz b gy lk ll l lm ln">#---------- mapply() function ---------- <br/>result &lt;- mapply(rep, 1:4, 4:1)<br/>result<br/>class(result)                       #class is a list<br/>result &lt;- mapply(rep, 1:4, 4:4)<br/>class(result)                       #class is a matrix</span></pre><p id="1f93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">结论</strong></p><p id="e4e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信我已经介绍了所有最有用和最流行的 apply 函数以及所有可能的输入对象组合。如果你认为缺少了什么或者需要更多的输入。在评论里告诉我，我会加进去的！</p></div></div>    
</body>
</html>