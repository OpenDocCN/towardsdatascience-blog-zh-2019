<html>
<head>
<title>Smoothing Data In SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平滑 SQL 中的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/smoothing-data-in-sql-c042ab0839a?source=collection_archive---------27-----------------------#2019-08-14">https://towardsdatascience.com/smoothing-data-in-sql-c042ab0839a?source=collection_archive---------27-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/89f655bab8e2bc6fde1081c938d0ee9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trao61zhG_XFDWBzreO2zA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">A teddy bear Western Bulldogs Australian Rules Football fan sitting on an Essendon Bombers beanie — by the end of the article we will judge how these two AFL teams’ seasons are going (photo: author)</figcaption></figure><div class=""/><div class=""><h2 id="ff4b" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated"><em class="kx">使用移动平均来平滑 SQL 中的数据</em></h2></div><p id="98d3" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据世界中发现的一个问题是如何区分信号和噪声。当处理序列中出现的数据时，例如时间序列数据(最熟悉的例子，但决不是唯一的例子)，处理该问题的一个常用方法是应用平滑器。</p><p id="f1e3" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">平滑器可以从非常简单的到非常复杂的，但是我们将集中在比较简单的一端。</p><p id="0a53" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些平滑器，不管多简单或多复杂，都有一个共同点，那就是它们依赖于以特定顺序出现的数据。为了计算平滑度，您需要能够引用焦点行周围的多行，SQL 并不总是很好地设置了这一点。</p><p id="371c" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">近年来，SQL 的主要实现(包括 MySQL、SQLite、PostgreSQL 和 SQL Server)已经添加了 Lead()和 Lag()函数，允许对出现在感兴趣的行之前和之后的行执行计算。我们可以利用这些函数在 SQL 中实现简单的平滑器，比如加权移动平均。</p><p id="d0f4" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像所有的窗口函数一样，SQL 让您可以灵活地使用“PARTITION”和“OVER”关键字来指定函数所应用的数据。从语义上来说</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0822" class="md me ji lz b gy mf mg l mh mi">SELECT Index, Classifier, Value, LAG(Value) OVER (Partition By Classifier ORDER BY Index)<br/>FROM YourTable</span></pre><p id="0e68" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，默认偏移量是一个位置，但是您可以在 Lag 函数中指定偏移量，例如 Lag(Value，2)是原始行后面的两行。</p><p id="9f20" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，我们不能在同一个列中返回多个窗口函数变量，所以我们不能做我们需要做的算术来计算加权移动平均本身。因此，我们需要创建一个公共表表达式来提供滞后列，并运行后续查询来计算加权移动平均值本身。再一次，用纯语义的术语来说:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0221" class="md me ji lz b gy mf mg l mh mi">WITH Base_Table<br/>AS<br/>(SELECT Index, Classifier, Value <br/>  ,LAG(Value) OVER (Partition By Classifier ORDER BY Index) as LagVal1<br/>  ,LAG(Value,2) OVER (Partition By Classifier ORDER BY Index) as LagVal2</span><span id="d69f" class="md me ji lz b gy mj mg l mh mi">FROM YourTable)</span><span id="e33f" class="md me ji lz b gy mj mg l mh mi">SELECT Index, Classifier<br/>            , (Value + LagVal1 + LagVal2)/3 as MovingAverage<br/>From Base_Table</span></pre><p id="e5a3" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，为了恰当地说明，我们需要一个好的例子。不管是好是坏，我是来自维多利亚的澳大利亚人，所以我遵循的足球准则是澳大利亚规则(如果我是来自新南威尔士州或昆士兰州的澳大利亚人，这不太可能是真的)。我的球队是埃森登轰炸机队，他们最近在与西部牛头犬队的比赛中遭遇了历史上最大的一次失败，只得到 33 分，而西部牛头犬队得到 137 分。</p><p id="1941" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过自我鞭笞的方式，我认为计算两个队在最近比赛中得分的移动平均值是有益的，以便更好地了解他们每个人的趋势。</p><p id="7bb8" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要创建一个包含最近几场比赛分数的表格。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5f50" class="md me ji lz b gy mf mg l mh mi">CREATE TABLE AFL_SCORES</span><span id="78c8" class="md me ji lz b gy mj mg l mh mi">(  Team VarChar(30)<br/>, RoundNum Int<br/>, Score Int<br/>)<br/>;</span><span id="02d2" class="md me ji lz b gy mj mg l mh mi">INSERT INTO AFL_SCORES</span><span id="1570" class="md me ji lz b gy mj mg l mh mi">VALUES<br/>  ('Essendon', 14, 71)<br/>, ('Essendon', 15, 77)<br/>, ('Essendon', 16, 76)<br/>, ('Essendon', 17, 86)<br/>, ('Essendon', 18, 96)<br/>, ('Essendon', 19, 106)<br/>, ('Essendon', 20, 67)<br/>, ('Essendon', 21, 33)<br/>, ('Western Bulldogs', 14, 73)<br/>, ('Western Bulldogs', 15, 66)<br/>, ('Western Bulldogs', 16, 71)<br/>, ('Western Bulldogs', 17, 74)<br/>, ('Western Bulldogs', 18, 89)<br/>, ('Western Bulldogs', 19, 113)<br/>, ('Western Bulldogs', 20, 80)<br/>, ('Western Bulldogs', 21, 137)</span><span id="cecb" class="md me ji lz b gy mj mg l mh mi">;</span></pre><p id="ea90" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们有了查询本身，按照上面介绍的模式，一个 CTE 创建滞后列，一个后续查询计算移动平均值本身。请注意，这是简单的移动平均线，但在许多情况下，使用加权移动平均线，有各种不同的加权方案，以适应不同的口味。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e188" class="md me ji lz b gy mf mg l mh mi">WITH LagsTable<br/>AS<br/>(SELECT   Team<br/>          , RoundNum<br/>          , Score<br/>          , Lag(Score)    OVER (Partition By Team Order By RoundNum) AS ScoreLag1<br/>          , Lag(Score,2)  OVER (Partition By Team Order By RoundNum) AS ScoreLag2</span><span id="e9cb" class="md me ji lz b gy mj mg l mh mi">FROM AFL_SCORES)</span><span id="7cb9" class="md me ji lz b gy mj mg l mh mi">SELECT   Team<br/>         , RoundNum<br/>         , (Score+ScoreLag1+ScoreLag2)/3 As MovingAverage</span><span id="3152" class="md me ji lz b gy mj mg l mh mi">FROM LagsTable</span></pre><p id="c987" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给出结果:</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/906a95ca9fb3e6a25c5abd1fc2999e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*WLQuTfnp0FQAaIXiyhEKXw.png"/></div></figure><p id="8664" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于埃森登的球迷来说，这可能是一点安慰，因为西部牛头犬队连续几轮都有所改善，这比埃森登最近的得分下降趋势更强。</p><p id="5d55" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，这是一个有用的、尽管对个人来说很痛苦的方法，来说明如何使用 SQL 通过窗口函数计算移动平均值。</p><p id="c708" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">罗伯特·德格拉夫的书《管理你的数据科学项目》<a class="ae mm" href="https://www.amazon.com/Managing-Your-Data-Science-Projects/dp/1484249062/ref=pd_rhf_ee_p_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=4X4S14FQEBKHZSDYYMZY" rel="noopener ugc nofollow" target="_blank"><em class="ml"/></a><em class="ml">》已经通过出版社出版。</em></p><p id="a7d4" class="pw-post-body-paragraph ky kz ji la b lb lc kj ld le lf km lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mm" href="https://twitter.com/RobertdeGraaf2" rel="noopener ugc nofollow" target="_blank"> <em class="ml">在 Twitter 上关注罗伯特</em> </a></p></div></div>    
</body>
</html>