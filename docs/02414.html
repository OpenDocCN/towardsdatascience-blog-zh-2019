<html>
<head>
<title>Audio Classification with Pre-trained VGG-19 (Keras)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用预训练的 VGG-19 (Keras)进行音频分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/audio-classification-with-pre-trained-vgg-19-keras-bca55c2a0efe?source=collection_archive---------10-----------------------#2019-04-20">https://towardsdatascience.com/audio-classification-with-pre-trained-vgg-19-keras-bca55c2a0efe?source=collection_archive---------10-----------------------#2019-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/138349d96673531483ed550a9a46a6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWKdIOwJRKZT2Yar8qNeUQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Taken from <a class="ae jd" href="https://www.semanticscholar.org/paper/Raw-Waveform-based-Audio-Classification-Using-CNN-Lee-Kim/09be9adf2a925da20db12918283c54a9044272af/figure/0" rel="noopener ugc nofollow" target="_blank">https://www.semanticscholar.org/paper/Raw-Waveform-based-Audio-Classification-Using-CNN-Lee-Kim/09be9adf2a925da20db12918283c54a9044272af/figure/0</a></figcaption></figure><div class=""/><p id="5796" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将针对音频分类的问题。我将根据预先训练的 VGG-19 从音频波形中提取的特征训练一个 SVM 分类器。这篇文章背后的主要思想是展示预训练模型的力量，以及应用它们的容易程度。</p><p id="fa00" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想在真实世界的数据上评估这种方法。于是我想到把超跑和重型自行车的音频分类。下面是我创建这个分类器的步骤:</p><h2 id="e11c" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">从 Youtube 下载音频文件</h2><p id="beb1" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，我选择了我想要音频的 youtube 视频，然后我使用下面这段代码下载了. mp3 格式的音频文件。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3dc9" class="lb lc jg me b gy mi mj l mk ml"><strong class="me jh">from </strong>__future__ <strong class="me jh">import </strong>unicode_literals<br/><strong class="me jh">import </strong>youtube_dl<br/><br/><br/>ydl_opts = {<br/>    <strong class="me jh">'format'</strong>: <strong class="me jh">'bestaudio/best'</strong>,<br/>    <strong class="me jh">'postprocessors'</strong>: [{<br/>        <strong class="me jh">'key'</strong>: <strong class="me jh">'FFmpegExtractAudio'</strong>,<br/>        <strong class="me jh">'preferredcodec'</strong>: <strong class="me jh">'mp3'</strong>,<br/>        <strong class="me jh">'preferredquality'</strong>: <strong class="me jh">'192'</strong>,<br/>    }],<br/>}<br/><strong class="me jh">with </strong>youtube_dl.YoutubeDL(ydl_opts) <strong class="me jh">as </strong>ydl:<br/>    ydl.download([&lt;youtube video link&gt;])<br/># for bike sounds : <a class="ae jd" href="https://www.youtube.com/watch?v=sRdRwHPjJPk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=sRdRwHPjJPk</a><strong class="me jh"><br/></strong>#<strong class="me jh"> </strong>for<strong class="me jh"> </strong>car sounds : <a class="ae jd" href="https://www.youtube.com/watch?v=PPdNb-XQXR8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=PPdNb-XQXR8</a></span></pre><p id="608b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">将音频文件从. mp3 转换为。wav </strong></p><p id="cbf8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下载了. mp3 文件后，我把它们转换成了。wav 文件，使用下面这段代码。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="854b" class="lb lc jg me b gy mi mj l mk ml"><strong class="me jh">from </strong>pydub <strong class="me jh">import </strong>AudioSegment<br/>sound = AudioSegment.from_mp3(<strong class="me jh">"car.mp3"</strong>)<br/>sound.export(<strong class="me jh">"car.wav"</strong>, format=<strong class="me jh">"wav"</strong>)</span></pre><p id="6bf2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">提取音频块</strong></p><p id="8ce4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步，我从。wav 文件。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="176a" class="lb lc jg me b gy mi mj l mk ml"><strong class="me jh">from </strong>pydub <strong class="me jh">import </strong>AudioSegment<br/><strong class="me jh">import </strong>os<br/><strong class="me jh">if not </strong>os.path.exists(<strong class="me jh">"bike"</strong>):<br/>    os.makedirs(<strong class="me jh">"bike"</strong>)<br/><br/>count=1<br/><strong class="me jh">for </strong>i <strong class="me jh">in </strong>range(1,1000,15):<br/>    t1 = i * 1000 <em class="mm">#Works in milliseconds<br/>    </em>t2 = (i+15) * 1000<br/>    newAudio = AudioSegment.from_wav(<strong class="me jh">"bikes.wav"</strong>)<br/>    newAudio = newAudio[t1:t2]<br/>    newAudio.export(<strong class="me jh">'bike/'</strong>+str(count)+<strong class="me jh">'.wav'</strong>, format=<strong class="me jh">"wav"</strong>) <em class="mm">#Exports to a wav file in the current path.<br/>    </em>print(count)<br/>    count+=1</span></pre><p id="5c66" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">绘制振幅波形</strong></p><p id="b019" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是绘制这些音频的波形。这是用下面的代码完成的。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="60de" class="lb lc jg me b gy mi mj l mk ml"><strong class="me jh">from </strong>scipy.io.wavfile <strong class="me jh">import </strong>read<br/><strong class="me jh">import </strong>matplotlib.pyplot <strong class="me jh">as </strong>plt<br/><strong class="me jh">from </strong>os <strong class="me jh">import </strong>walk<br/><strong class="me jh">import </strong>os<br/><strong class="me jh">if not </strong>os.path.exists(<strong class="me jh">"carPlots"</strong>):<br/>    os.makedirs(<strong class="me jh">"carPlots"</strong>)<br/>car_wavs = []<br/><strong class="me jh">for </strong>(_,_,filenames) <strong class="me jh">in </strong>walk(<strong class="me jh">'car'</strong>):<br/>    car_wavs.extend(filenames)<br/>    <strong class="me jh">break<br/>for </strong>car_wav <strong class="me jh">in </strong>car_wavs:<br/>    <em class="mm"># read audio samples<br/>    </em>input_data = read(<strong class="me jh">"car/" </strong>+ car_wav)<br/>    audio = input_data[1]<br/>    <em class="mm"># plot the first 1024 samples<br/>    </em>plt.plot(audio)<br/>    <em class="mm"># label the axes<br/>    </em>plt.ylabel(<strong class="me jh">"Amplitude"</strong>)<br/>    plt.xlabel(<strong class="me jh">"Time"</strong>)<br/>    <em class="mm"># set the title<br/>    # plt.title("Sample Wav")<br/>    # display the plot<br/>    </em>plt.savefig(<strong class="me jh">"carPlots/" </strong>+ car_wav.split(<strong class="me jh">'.'</strong>)[0] + <strong class="me jh">'.png'</strong>)<br/>    <em class="mm"># plt.show()<br/>    </em>plt.close(<strong class="me jh">'all'</strong>)</span></pre><p id="3dd6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">提取特征和训练直线 SVM </strong></p><p id="707f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我有了汽车和自行车的这些波形，我就从这些图像中提取特征，将它们输入 LinearSVM 进行分类。为了提取特征，我使用了 VGG-19 的预训练模型，并从展平层提取图像的抽象特征。提取这些特征后，我创建了一个 70-30 的训练测试分割，并训练了一个 LinearSVM。下面是代码。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c655" class="lb lc jg me b gy mi mj l mk ml"><strong class="me jh">import </strong>os<br/><strong class="me jh">from </strong>keras.applications.vgg19 <strong class="me jh">import </strong>VGG19<br/><strong class="me jh">from </strong>keras.preprocessing <strong class="me jh">import </strong>image<br/><strong class="me jh">from </strong>keras.applications.vgg19 <strong class="me jh">import </strong>preprocess_input<br/><strong class="me jh">from </strong>keras.models <strong class="me jh">import </strong>Model<br/><strong class="me jh">import </strong>numpy <strong class="me jh">as </strong>np<br/><br/>base_model = VGG19(weights=<strong class="me jh">'imagenet'</strong>)<br/>model = Model(inputs=base_model.input, outputs=base_model.get_layer(<strong class="me jh">'flatten'</strong>).output)<br/><br/><strong class="me jh">def </strong>get_features(img_path):<br/>    img = image.load_img(img_path, target_size=(224, 224))<br/>    x = image.img_to_array(img)<br/>    x = np.expand_dims(x, axis=0)<br/>    x = preprocess_input(x)<br/>    flatten = model.predict(x)<br/>    <strong class="me jh">return </strong>list(flatten[0])<br/><br/>X = []<br/>y = []<br/><br/>car_plots = []<br/><strong class="me jh">for </strong>(_,_,filenames) <strong class="me jh">in </strong>os.walk(<strong class="me jh">'carPlots'</strong>):<br/>    car_plots.extend(filenames)<br/>    <strong class="me jh">break<br/><br/>for </strong>cplot <strong class="me jh">in </strong>car_plots:<br/>    X.append(get_features(<strong class="me jh">'carPlots/' </strong>+ cplot))<br/>    y.append(0)<br/><br/>bike_plots = []<br/><strong class="me jh">for </strong>(_,_,filenames) <strong class="me jh">in </strong>os.walk(<strong class="me jh">'bikePlots'</strong>):<br/>    bike_plots.extend(filenames)<br/>    <strong class="me jh">break<br/><br/>for </strong>cplot <strong class="me jh">in </strong>bike_plots:<br/>    X.append(get_features(<strong class="me jh">'bikePlots/' </strong>+ cplot))<br/>    y.append(1)<br/><br/><strong class="me jh">from </strong>sklearn.model_selection <strong class="me jh">import </strong>train_test_split<br/><strong class="me jh">from </strong>sklearn.svm <strong class="me jh">import </strong>LinearSVC<br/><strong class="me jh">from </strong>sklearn.metrics <strong class="me jh">import </strong>accuracy_score<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42, stratify=y)<br/><br/>clf = LinearSVC(random_state=0, tol=1e-5)<br/>clf.fit(X_train, y_train)<br/><br/>predicted = clf.predict(X_test)<br/><br/><em class="mm"># get the accuracy<br/></em>print (accuracy_score(y_test, predicted))</span></pre><p id="e3fe" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个简单的模型在测试集<strong class="kf jh">上取得了<strong class="kf jh"> 97% </strong>的准确率。</strong>这显示了这些预先训练的模型有多么强大，以及任何人都可以使用它们来创建工具。</p><p id="5779" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我能想到的一个应用是创建一个 chrome 扩展，它可以判断网页上的视频音频是否包含明显的噪音。我鼓励阅读这篇文章的初学者思考一个新问题，并用这里介绍的方法解决它。</p></div></div>    
</body>
</html>