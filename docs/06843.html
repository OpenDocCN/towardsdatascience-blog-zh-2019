<html>
<head>
<title>Ultimate Setup for Your Next Golang Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一个 Golang 项目的终极设置</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ultimate-setup-for-your-next-golang-project-1cc989ad2a96?source=collection_archive---------8-----------------------#2019-09-29">https://towardsdatascience.com/ultimate-setup-for-your-next-golang-project-1cc989ad2a96?source=collection_archive---------8-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4f2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:这最初发布在</em><a class="ae kp" href="https://martinheinz.dev/blog/5" rel="noopener ugc nofollow" target="_blank"><em class="ko">martinheinz . dev</em></a></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/fbad0d9ad98adfc329eaa6261b06f20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QacPkqrEWBtjRTrbfrgV9g.png"/></div></div></figure><p id="e512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对我来说，当开始一个新项目时，最大的困难总是试图“完美地”完成这个项目。我总是试图使用最好的目录结构，这样一切都很容易找到，导入工作也很好，设置所有命令，这样我总是一次点击/命令就可以完成所需的操作，为我正在使用的语言/库找到最好的 linter、formatter、测试框架…</p><p id="8430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个清单还在继续，但我从来没有对这个设置感到满意过…除了这个最终的和最好的<em class="ko"> Golang </em>设置！</p><p id="2c90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:这个设置工作得很好，部分原因是它基于现有的项目，这些项目可以在</em> <a class="ae kp" href="https://github.com/thockin/go-build-template" rel="noopener ugc nofollow" target="_blank"> <em class="ko">这里</em> </a> <em class="ko">和</em> <a class="ae kp" href="https://github.com/qiangxue/golang-restful-starter-kit" rel="noopener ugc nofollow" target="_blank"> <em class="ko">这里</em> </a>找到。</p><p id="7991" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">TL；博士:这是我的知识库—</em><a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://github.com/MartinHeinz/go-project-blueprint</em></a></p><h1 id="689a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">目录结构</h1><p id="bb45" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">首先，让我们回顾一下我们的<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint" rel="noopener ugc nofollow" target="_blank">项目</a>的目录结构。有几个顶级文件和 4 个目录:</p><ul class=""><li id="8787" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">pkg</code> -让我们从简单的开始- <code class="fe mo mp mq mr b">pkg</code>是一个<em class="ko"> Go </em>包，它只包含全局版本字符串。这将替代在构建过程中根据提交哈希计算的实际版本。</li><li id="3869" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">config</code> -接下来，有一个配置目录，其中包含所有必要的环境变量。任何文件类型都可以使用，但是我推荐 YAML 的文件，因为它们可读性更好。</li><li id="a2c5" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">build</code> -该目录包含构建和测试应用程序以及为代码分析工具生成报告所需的所有 shell 脚本</li><li id="188a" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">cmd</code> -真实源代码！按照惯例，源目录被命名为<code class="fe mo mp mq mr b">cmd</code>，里面有另一个项目名称的目录——在本例中是<code class="fe mo mp mq mr b">blueprint</code>。接下来，在这个目录中有一个运行整个应用程序的<code class="fe mo mp mq mr b">main.go</code>,和它一起的还有所有其他被划分成模块的源文件(稍后会详细介绍)。</li></ul><p id="c30e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:从一些反馈中，我发现很多人更喜欢使用</em> <code class="fe mo mp mq mr b"><em class="ko">internal</em></code> <em class="ko">和</em> <code class="fe mo mp mq mr b"><em class="ko">pkg</em></code> <em class="ko">目录来存放他们所有的源代码。我个人觉得这是不必要和多余的，因此我把一切都放进</em> <code class="fe mo mp mq mr b"><em class="ko">cmd</em></code> <em class="ko">，但各归各的。</em></p><p id="3227" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了目录之外，还有相当多的文件，我们将在下面的章节中讨论它们。</p><h1 id="e586" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Go 模块实现完美的依赖性管理</h1><p id="f398" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">项目使用各种各样的依赖管理策略。然而，从版本 1.11 开始<em class="ko"> Go </em>有了官方的依赖管理解决方案。我们所有的依赖项都列在<code class="fe mo mp mq mr b">go.mod</code>文件中，这个文件可以在根目录中找到。这可能是它看起来的样子:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问<em class="ko">“文件是如何被依赖关系填充的？”</em>。很简单，你只需要一个命令:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c9e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令根据<code class="fe mo mp mq mr b">go.mod</code>文件和 Go 源代码的状态重置主模块的供应商目录，以包含构建和测试所有模块包所需的所有包。</p><h1 id="f539" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">实际源代码和配置</h1><p id="8ed0" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">现在我们终于开始讨论源代码了。如上所述，源代码被分成模块。每个模块都是源根目录下的一个目录。每个模块都有源文件和测试文件，例如:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e108" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种结构有助于提高可读性和可维护性，因为它将代码分成了更容易遍历合理的块。至于配置，在这个设置中我使用了<a class="ae kp" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank"> Viper </a>，它是<em class="ko"> Go </em>配置库，可以处理各种格式、命令行标志、环境变量等。</p><p id="4f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们这里怎么用(<em class="ko">蝰蛇</em>)呢？我们来看看<code class="fe mo mp mq mr b">config</code>套餐:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e0db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个包由一个文件组成。它声明了一个保存所有配置变量的函数<code class="fe mo mp mq mr b">struct</code>,还有一个加载配置的函数<code class="fe mo mp mq mr b">LoadConfig</code>。它采用配置文件的路径，在我们的例子中，我们将使用路径到<code class="fe mo mp mq mr b">config</code>目录，该目录位于项目根目录中，包含我们的<em class="ko"> YAML </em>文件(如上所述)。我们如何使用它？我们在<code class="fe mo mp mq mr b">main.go</code>中首先运行它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="9f07" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">简单快速的测试</h1><p id="dfb9" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">仅次于代码本身的第二重要的东西？质量测试。为了愿意编写大量好的测试，您需要一个能让您轻松做到这一点的设置。为了实现这一点，我们将使用名为<code class="fe mo mp mq mr b">test</code>的<code class="fe mo mp mq mr b">Makefile</code>目标，它收集并运行<code class="fe mo mp mq mr b">cmd</code>子目录中的所有测试(所有带有<code class="fe mo mp mq mr b">_test.go</code>后缀的文件)。这些测试也会被缓存，所以它们只有在相关代码发生变化时才会运行。这是至关重要的，如果测试太慢，你将(很可能)最终停止运行和维护它们。除了单元测试之外，<code class="fe mo mp mq mr b">make test</code>还可以帮助您维护一般的代码质量，因为它还会在每次测试运行时运行<code class="fe mo mp mq mr b">gofmt</code>和<code class="fe mo mp mq mr b">go vet</code>。<code class="fe mo mp mq mr b">go fmt</code>强制你正确格式化你的代码，而<code class="fe mo mp mq mr b">go vet</code>使用试探法发现任何可疑的代码结构。示例输出:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8510" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">总是在 Docker 中运行</h1><p id="ed35" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">人们经常说<em class="ko">“它在我的机器上工作(而不是在云中)……”</em>，为了避免这一点，我们有一个简单的解决方案——<em class="ko">总是</em>在 docker 容器中运行。当我说<em class="ko">总是</em>时，我是认真的——在容器中构建，在容器中运行，在容器中测试。其实上一节我没提，但是<code class="fe mo mp mq mr b">make test</code>真的是<em class="ko">“就】</em> <code class="fe mo mp mq mr b">docker run</code>。</p><p id="1ed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，这里是怎么运作的？让我们从项目根中的<code class="fe mo mp mq mr b">Dockerfiles</code>开始——我们有两个，一个用于测试(<code class="fe mo mp mq mr b">test.Dockerfile</code>)，一个用于运行应用(<code class="fe mo mp mq mr b">in.Dockerfile</code>):</p><ul class=""><li id="3397" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">test.Dockerfile</code> -在理想情况下，我们应该只有一个 docker 文件来运行和测试应用程序。然而，在运行测试时，可能需要对环境进行一些小的调整。这就是为什么我们在这里有这个图像——允许我们安装额外的工具和库，以防我们的测试需要它。例如，让我们假设我们有一个正在连接的数据库。我们不希望每次测试运行都启动整个 PostgreSQL 服务器，也不希望依赖主机上运行的一些数据库。因此，我们可以使用内存数据库进行测试。但是，你猜怎么着？<em class="ko"> SQLite </em>二进制要求。那么，我们该怎么办？我们只需安装<code class="fe mo mp mq mr b">gcc</code>和<code class="fe mo mp mq mr b">g++</code>，翻转<code class="fe mo mp mq mr b">CGO_ENABLED</code>标志，就可以开始了。</li><li id="3fa1" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">in.Dockerfile</code> -如果你在存储库中查看这个<code class="fe mo mp mq mr b">Dockerfile</code>，它只是一堆参数和将配置复制到映像中-那么，那里发生了什么？当我们运行<code class="fe mo mp mq mr b">make container</code>时，<code class="fe mo mp mq mr b">in.Dockerfile</code>仅在<code class="fe mo mp mq mr b">Makefile</code>中使用，在那里参数被填充。现在，是时候看看<code class="fe mo mp mq mr b">Makefile</code>本身了，它为我们做了所有的<code class="fe mo mp mq mr b">docker</code>事情。👇</li></ul><h1 id="e86f" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">用 Makefile 把它们结合在一起</h1><p id="cc6e" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">很长一段时间以来，<code class="fe mo mp mq mr b">Makefiles</code>对我来说似乎很可怕，因为我只见过它们与<code class="fe mo mp mq mr b">C</code>代码一起使用，但它们并不可怕，可以用于很多事情，包括这个项目！现在让我们探索一下<code class="fe mo mp mq mr b">Makefile</code>中的<em class="ko">目标</em>:</p><ul class=""><li id="d359" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">make test</code> -工作流中的第一步-应用构建-在<code class="fe mo mp mq mr b">bin</code>目录中构建二进制可执行文件:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><ul class=""><li id="79de" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">make test</code> -下一个是测试-它再次使用几乎相同的<code class="fe mo mp mq mr b">docker run</code>，唯一的区别是<code class="fe mo mp mq mr b">test.sh</code>脚本(仅相关部分):</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="91f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面几行是文件的重要部分。首先，它们使用给定的路径作为参数来收集测试目标。第二行运行测试并将输出打印到 std out。剩下的两行分别运行<code class="fe mo mp mq mr b">go fmt</code>和<code class="fe mo mp mq mr b">go vet</code>，收集错误(如果有)并打印出来。</p><ul class=""><li id="cac0" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">make container</code> -现在，最重要的部分-创建可部署的容器:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="023b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个目标的代码非常简单，它首先替换<code class="fe mo mp mq mr b">in.Dockerfile</code>中的变量，然后运行<code class="fe mo mp mq mr b">docker build</code>来生成带有<em class="ko">【dirty】</em>和<em class="ko">【latest】</em>标签的图像。最后，它将容器名打印到标准输出中。</p><ul class=""><li id="32e4" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">接下来，当我们有图像时，我们需要把它存储在某个地方，对吗？因此，<code class="fe mo mp mq mr b">make push</code>所做的就是将图像推送到<em class="ko"> Docker </em>注册表。</li><li id="620b" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">make ci</code>—<code class="fe mo mp mq mr b">Makefile</code>的另一个好用途是在我们的 CI/CD 管道中利用它(下一节)。这个目标与<code class="fe mo mp mq mr b">make test</code>非常相似——它也运行所有的测试，但是除此之外，它还生成覆盖报告，这些报告随后被用作代码分析工具的输入。</li><li id="a86e" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><code class="fe mo mp mq mr b">make clean</code> -最后，如果我们想要清理我们的项目，我们可以运行<code class="fe mo mp mq mr b">make clean</code>，这将删除由先前的目标生成的所有文件。</li></ul><p id="4939" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将省略其余的，因为正常工作流程不需要它们，或者它们只是其他<em class="ko">目标</em>的一部分。</p><h1 id="5e09" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">CI/CD 带来终极编码体验</h1><p id="4f33" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">最后，但绝对不是最不重要的— <em class="ko"> CI/CD </em>。有了这么好的设置(如果我自己这么说的话)，省略一些花哨的管道将是一种耻辱，这些管道可以为我们做大量的事情，对吗？我不会对管道中的内容进行过多的详细描述，因为您可以在这里自己查看<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank"/>(我还包括了几乎每一行的注释，所以一切都有解释)，但是我想指出几件事:</p><p id="17b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<em class="ko"> Travis </em>构建使用<em class="ko">矩阵构建</em>和 4 个并行作业来加速整个过程</p><ul class=""><li id="9147" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><em class="ko">构建和测试</em>我们验证应用程序是否按预期工作</li><li id="7192" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><em class="ko"> SonarCloud </em>生成覆盖报告，并将其发送到<em class="ko"> SonarCloud </em>服务器</li><li id="af87" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated">这里，和上一个一样，我们生成报告并发送给<em class="ko"> CodeClimate </em></li><li id="e80e" class="mf mg it js b jt ms jx mt kb mu kf mv kj mw kn mk ml mm mn bi translated"><em class="ko">推送到注册表</em> —最后，我们将容器推送到<em class="ko"> GitHub 注册表</em>(敬请关注关于此事的博文！)</li></ul><h1 id="f948" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="c45f" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我希望这篇文章能对你未来的编码冒险有所帮助。如果你想看到更多的细节，请点击查看仓库<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint" rel="noopener ugc nofollow" target="_blank">。此外，如果您有任何反馈或改进的想法，请不要犹豫，提交问题，签署回购协议或给一颗星，这样我知道再多做一点工作是有意义的。🙂</a></p><p id="00a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一部分中，我们将看看如何扩展这个蓝图来轻松构建 RESTful APIs，使用内存数据库进行测试，并设置 swagger 文档(您可以先睹为快，在库的<code class="fe mo mp mq mr b"><a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api" rel="noopener ugc nofollow" target="_blank">rest-api</a></code>分支中)。</p></div></div>    
</body>
</html>