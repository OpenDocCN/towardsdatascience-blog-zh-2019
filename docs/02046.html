<html>
<head>
<title>Neural Networks: Why do they work so well?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络:为什么它们工作得这么好？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-networks-why-do-they-work-so-well-part-i-22f0d3690511?source=collection_archive---------18-----------------------#2019-04-04">https://towardsdatascience.com/neural-networks-why-do-they-work-so-well-part-i-22f0d3690511?source=collection_archive---------18-----------------------#2019-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e37c4c64df66741f8544cef1be3e91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plK_zeZXqhV4LWGYPfAmZg.png"/></div></div></figure><h1 id="32d2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">先决条件</h1><p id="bcf8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这篇文章需要一些关键的数学对象和技术的知识。一般来说，了解这些要求是非常有用的，所以如果你不熟悉的话，我建议你研究一下。单击该主题中我最喜欢的资源的任何链接。</p><h2 id="e041" class="lu jz iq bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">线性代数</h2><ol class=""><li id="4dc3" class="mg mh iq ky b kz la ld le lh mi ll mj lp mk lt ml mm mn mo bi translated"><a class="ae mp" href="https://youtu.be/fNk_zzaMoSs" rel="noopener ugc nofollow" target="_blank">矢量</a></li><li id="6004" class="mg mh iq ky b kz mq ld mr lh ms ll mt lp mu lt ml mm mn mo bi translated"><a class="ae mp" href="https://youtu.be/kYB8IZa5AuE" rel="noopener ugc nofollow" target="_blank">矩阵</a></li></ol><h2 id="7609" class="lu jz iq bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">结石</h2><ol class=""><li id="2831" class="mg mh iq ky b kz la ld le lh mi ll mj lp mk lt ml mm mn mo bi translated"><a class="ae mp" href="https://youtu.be/AXqhWeUEtQU" rel="noopener ugc nofollow" target="_blank">偏导数</a></li><li id="e85d" class="mg mh iq ky b kz mq ld mr lh ms ll mt lp mu lt ml mm mn mo bi translated"><a class="ae mp" href="https://youtu.be/0T0QrHO56qg" rel="noopener ugc nofollow" target="_blank">链式法则</a></li></ol><h1 id="de4e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">基础知识:输入和输出</h1><p id="23ed" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">神经网络是一个函数。它接受一些输入并将其映射到输出。更具体地说，神经网络是一种旨在进行预测的功能。</p><p id="0eea" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">为了更好地理解这个定义，让我们看一个例子。假设我们希望根据我们掌握的关于您的一些数据来预测您是否患有心脏病:体重、身高、年龄、静息心率和胆固醇水平。</p><p id="2d04" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">首先，我们可以将您的特征堆叠成一个向量<strong class="ky ir"> x </strong>，如下所示:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/6d31cb93de991078560e1f198471bcb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fB4BpR9czApuA1SPQPWNXg@2x.png"/></div></div></figure><p id="bcbb" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">为了获得神经网络对你患心脏病概率的预测，我们将 x 输入到模型中。这将输出<strong class="ky ir"> y-hat </strong> —模型对 p(心脏病)的预测。我们可以这样写(其中<em class="nf"> N </em>是神经网络):</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/4549b1a1c490a50895c3b9c73e82d1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcMkfP9txA8mwkioeMM9Ow@2x.png"/></div></div></figure><p id="cfbb" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">这里，<strong class="ky ir"> y-hat </strong>是 0 和 1 之间的连续值，因为它是概率。然而，真实值<strong class="ky ir"> y </strong>是二进制的(即要么 1 要么 0)，因为你要么有心脏病(1)，要么没有(0)。</p><p id="05a3" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">好吧！您现在对神经网络的作用以及它为什么有用有了大致的了解。但是，你仍然不知道神经网络是如何预测 y 和 T21 的。让我们再深入一点。</p><h1 id="5952" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">图层:🍰</h1><p id="ced1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="nf">注意:在这一节中，我使用下划线后跟方括号来表示 Unicode 中没有的文本内下标字符。这里有一个例子:</em></p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/26d162d941fc593856e7f6fb44dc3985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJyLdgdqzrtGDJ087_s1jA@2x.png"/></div></div></figure><p id="28eb" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">如前所述，神经网络是一个函数。但是，更具体地说，它是多种功能的组合。在深度学习中，这些功能被称为层。稍后我们将更多地讨论这些层是如何组成的，但现在，让我们只关注一层。</p><p id="e359" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">因为层是一个函数，它只是接收输入并产生输出。我们称这个函数为ℓ.层的 _[ℓ按照惯例，<em class="nf"> f </em> _[ℓ】接收一个输入<strong class="ky ir">a _</strong>【ℓ-1】并产生一个输出<strong class="ky ir">a _</strong>【ℓ].】这里，<strong class="ky ir">a _</strong>【ℓ】被称为层ℓ.的<em class="nf">激活</em></p><p id="5d5f" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">我们已经标记了<em class="nf"> f </em> _[ℓ]'s 输入和输出，但是层<em class="nf"> f </em> _[ℓ具体做什么呢？嗯，<em class="nf"> f </em> _[ℓ】分三个阶段映射<strong class="ky ir">a _</strong>【ℓ-1】→<strong class="ky ir">a _</strong>【ℓ】。以下是每种情况下发生的情况:</p><ol class=""><li id="0e85" class="mg mh iq ky b kz mv ld mw lh ng ll nh lp ni lt ml mm mn mo bi translated">首先，权重矩阵<strong class="ky ir"> W </strong>应用线性变换→ <strong class="ky ir"> W a </strong> _[ℓ-1】</li><li id="ca12" class="mg mh iq ky b kz mq ld mr lh ms ll mt lp mu lt ml mm mn mo bi translated">然后，添加一个偏置向量<strong class="ky ir">b</strong>→<strong class="ky ir">w a</strong>_[ℓ-1】<strong class="ky ir"/>+<strong class="ky ir">b</strong></li><li id="6f66" class="mg mh iq ky b kz mq ld mr lh ms ll mt lp mu lt ml mm mn mo bi translated">最后，应用非线性激活函数σ→σ(<strong class="ky ir">w a</strong>_[ℓ-1】<strong class="ky ir"/>+<strong class="ky ir">b</strong>)</li></ol><p id="c997" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">这个序列可以用下面的等式来概括:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/ffee06dee60507c69d797d3af15bd3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4V-Ygbe_qCfAnBQOf8G5A@2x.png"/></div></div></figure><p id="27b2" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">好了，我们对图层的功能做了一些数学标记。但是我不确定我们是否真正理解了什么是层<em class="nf">在做</em>。让我们试着通过视觉化来更好地感受一下 _[ℓ是如何改变空间的。</p><p id="1b59" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">为了可视化<em class="nf"> f </em> _[ℓ】，我们将需要处理低维(1、2 或 3)输入和输出。对于这个可视化，我们将有一个 2D 输入和一个 2D 输出。这意味着输入<strong class="ky ir"> a </strong> _[ℓ-1] ∈ ℝ，输出<strong class="ky ir">a</strong>_[ℓ】∈ℝ。我们也可以说<em class="nf"> f </em> _[ℓ】映射ℝ → ℝ。视觉上，这意味着 2D 空间中的每个点都通过<em class="nf"> f </em> _[ℓ].映射到 2D 空间中的一个新点</p><p id="e113" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">为了绘制出<em class="nf"> f </em> _[ℓ】如何在 2D 空间中操纵每个点，我们需要为σ选择一个函数，为<strong class="ky ir"> W </strong>、<strong class="ky ir"> </strong>选择一个矩阵，为<strong class="ky ir"> b </strong>选择一个向量。对于这个可视化，我们将选择σ、<strong class="ky ir"> W、</strong>和<strong class="ky ir"> b </strong>，如下所示:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/8851bb27c138c50ad028ff365d6402cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9Tk1PmPIS1R3dlz59tRbQ@2x.png"/></div></div></figure><p id="1151" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">现在我们有了这个具体的函数，我们可以展示它如何影响 2D 空间中的每一点。为了了解发生了什么，我们将只显示位于网格上的点。考虑到这一点，让我们制作一个可视化:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/021c697a5060788df04cae226cfadc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KJa4OQZkcSsvutz4hruvdw@2x.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">A visualization of a layer <em class="no">f</em>_[ℓ] mapping ℝ² → ℝ².</figcaption></figure><p id="fc43" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">注意图层<em class="nf"> f </em> _[ℓ】是如何通过三种不同的变换得到ℝ的每一个点的。首先，<strong class="ky ir"> W </strong>拉伸 2D 空间，同时保持所有线条平行。然后，<strong class="ky ir"> b </strong>将空间从原点移开。最后，σ smooshes 空间不考虑保持网格线平行。当<em class="nf"> f </em> _[ℓ】完成其转换时，根据<em class="nf"> f </em> _[ℓ].，每个输入激活<strong class="ky ir"> a </strong> _[ℓ-1】将从其原始位置移动到其相应的输出激活<strong class="ky ir"> a </strong> _[ℓ】</p><p id="5dc9" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">很好，但是，为什么这很有用？嗯，就其本身而言，单一的一层并不一定有用。只有当我们组合它们的时候，层才真正变得有用。再来说说这是怎么做到的。</p><h1 id="587e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">组成:y = f(f(f(x)))</h1><p id="b5a0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，我们可以通过组成层来构建神经网络。组合层意味着我们将一个层的输出激活输入到下一个层的输入中。</p><p id="6451" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">一旦我们连接好每一层，我们就可以将输入<strong class="ky ir"> x </strong>(也称为<strong class="ky ir"> a </strong> _[0】)送入第一层<em class="nf"> f </em> _[1】。第一层<em class="nf"> f </em> _[1】将其输出激活<strong class="ky ir"> a </strong> _[1】馈入<em class="nf"> f </em> _[2】，后者将其激活<strong class="ky ir"> a </strong> _[2】馈入<em class="nf"> f </em> _[3】等等。直到最终到达网络的最后一层<em class="nf"> f </em> _[L】，并且产生输出<strong class="ky ir"> y-hat </strong>(也称为<strong class="ky ir"> a </strong> _[L】)作为对<strong class="ky ir"> y </strong>的预测。</p><p id="9f30" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">作为这个过程在数学上的一个例子，这里有一个三层神经网络</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/98da17bb51d7689b3ef1b42ef9b33ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Gd0zuFIeuCsTztghHbLcw@2x.png"/></div></div></figure><p id="b6b5" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">太好了！这就概括了什么是神经网络<em class="nf">和</em>。但是，仍然不清楚为什么一系列合成层对预测有用。为了获得更好的直觉，让我们做另一个可视化。</p><p id="4d39" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">像最后一个可视化一样，我们将在ℝ处理输入，在ℝ处理输出。这里的关键区别是，我们将展示整个神经网络如何改变ℝ，而不是展示一个层如何改变ℝ。为了保证整个过程可以可视化，每一层的<em class="nf"> N </em> ( <em class="nf"> f </em> _[1】，<em class="nf"> f </em> _[2】，<em class="nf"> f </em> _[3]，…，<em class="nf"> f </em> _[L])也会映射ℝ → ℝ。这让我们可以看到神经网络转变的每一步都发生了什么。</p><p id="0d12" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">对于这个可视化，我还将绘制两条属于橙色或蓝色类的螺旋。这些螺旋将有助于证明网络的有用性。考虑到所有这些，我们得出了以下结论:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/d6058914236d95b8fe9210b43e670642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8qAh0fYcXMrfw3tljEBSDA@2x.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">A visualization of a neural network separating 2 spirals by mapping ℝ² → ℝ².</figcaption></figure><p id="c314" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">很酷，对吧？让我们把这个再打开一点。</p><p id="bd69" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">首先，注意每一层是如何一层接一层地应用的。第一层<em class="nf"> f </em> _[1】映射<strong class="ky ir">a</strong>_[0】→<strong class="ky ir">a</strong>_[1】。第二层<em class="nf"> f </em> _[2】映射<strong class="ky ir">a</strong>_[1】→<strong class="ky ir">a</strong>_[2】。第三层<em class="nf"> f </em> _[3】映射<strong class="ky ir">a</strong>_[2】→<strong class="ky ir">a</strong>_[3】以此类推。直到最后<em class="nf">f</em>_【L】映射<strong class="ky ir">a</strong>_【L-1】→<strong class="ky ir">a</strong>_【L】(即<strong class="ky ir"> y 帽</strong>)。这只是遵循了神经网络的基本定义。</p><p id="1788" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">接下来，注意网络的每一层是如何一点一点地分离橙色和蓝色螺旋的。在每个阶段，当前的转换都建立在前一个转换的进度之上。通过这个过程，网络正在为橙色和蓝色点中的每一个点形成其<em class="nf">预测</em>。当映射最终结束时，输入点<strong class="ky ir"> x </strong>落在模型对<strong class="ky ir"> x </strong>的类别的预测上——橙色(-1，-1)或蓝色(1，1)。在这里，模型似乎做得相当不错。</p><p id="e6de" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">但是神经网络有用的原因与这个具体的例子无关。模型的威力在于它的<em class="nf">灵活性</em>。因为每一层ℓ都可以有它自己的σ_[ℓ]，<strong class="ky ir"> W </strong> _[ℓ】，<strong class="ky ir">t11】和<strong class="ky ir"> b </strong> _[ℓ】，所以理论上该模型可以采取无限的配置。</strong></p><p id="4684" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">这意味着神经网络可以做的不仅仅是分离这些橙色和蓝色的螺旋。事实上，它可以在所有不同的配置中分离大量不同的点。它不仅仅可以分离点。事实上，它几乎可以近似任何变换(即函数)。这使得该模型适用于大量的问题。</p><p id="1942" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">这是神经网络的另一个例子。这个把三个螺旋分开。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/7f6834cf5202ceb82a182446e6b1b8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WsyqBdBHI4kIQmkubCLPEg@2x.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">A visualization of a neural network separating 3 spirals by mapping ℝ² → ℝ².</figcaption></figure><p id="c607" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">但是等一下。一个模型<em class="nf">究竟如何知道</em>如何逼近一个给定的函数？当然，它使用了一系列的层。但是这些层如何知道如何使自己对给定的问题有用呢？更具体地说，神经网络中的每一层如何弄清楚如何设置其参数σ、<strong class="ky ir"> W、</strong>和<strong class="ky ir"> b </strong>来完成一些有用的事情？</p><p id="1920" class="pw-post-body-paragraph kw kx iq ky b kz mv lb lc ld mw lf lg lh mx lj lk ll my ln lo lp mz lr ls lt ij bi translated">我将把这个问题留到下一篇文章，在那里我们将开始探索神经网络如何学习它的σs、<strong class="ky ir"> W </strong> s <strong class="ky ir">、</strong>和<strong class="ky ir"> b </strong> s。</p><blockquote class="np nq nr"><p id="0daa" class="kw kx nf ky b kz mv lb lc ld mw lf lg ns mx lj lk nt my ln lo nu mz lr ls lt ij bi translated">如果你想知道我是如何在本文中创建可视化效果的，请查看我在 GitHub 上的<a class="ae mp" href="https://github.com/isaiahnields/machine-learning-from-scratch" rel="noopener ugc nofollow" target="_blank">机器学习模型</a>库。</p></blockquote></div></div>    
</body>
</html>