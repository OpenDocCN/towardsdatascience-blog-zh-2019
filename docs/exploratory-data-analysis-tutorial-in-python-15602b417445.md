# Python 中的探索性数据分析教程

> 原文：<https://towardsdatascience.com/exploratory-data-analysis-tutorial-in-python-15602b417445?source=collection_archive---------2----------------------->

## 了解数据的最佳方式是花时间去探索它。

**简介**

每个数据科学家必须掌握的最重要的技能之一是正确探索数据的能力。为了确保收集的数据和执行的分析的完整性，彻底的探索性数据分析(EDA)是必不可少的。本教程中使用的示例是对历史 SAT 和 ACT 数据的探索性分析，以比较不同州的 SAT 和 ACT 考试的参与情况和表现。在本教程结束时，我们将获得关于美国标准化考试潜在问题的数据驱动的洞察力。本教程的重点是演示探索性的数据分析过程，并为希望练习使用数据的 Python 程序员提供一个示例。为了进行这项分析，我在 Jupyter 笔记本上检查并处理了包含 2017 年和 2018 年 SAT 和 ACT 数据的可用 CSV 数据文件。通过构造良好的可视化和描述性统计来探索数据是熟悉您正在处理的数据并根据您的观察制定假设的一种很好的方式。

**探索性数据分析(EDA)目标**

1)快速描述数据集；行数/列数、缺失数据、数据类型、预览。

2)清理损坏的数据；处理丢失的数据、无效的数据类型、不正确的值。

3)可视化数据分布；条形图、直方图、箱线图。

4)计算和可视化变量之间的相关性(关系)；热图。

**数据驱动方法的优势**

众所周知，标准化测试程序多年来一直是一个有争议的话题。通过我自己的初步研究，我很快发现了 SAT 和 ACT 考试的一些明显问题。例如，有些州只要求 SAT，只要求 ACT，两种考试都要求，或者要求每个学生参加他们选择的一种标准化考试。由各州设定的标准化考试预期之间的这种可变性应被视为各州之间考试记录(如参与率和平均成绩)偏差的重要来源。研究可能很重要，但采用数据驱动的方法来支持基于定性研究的主张(假设)是至关重要的。采用数据驱动的方法可以验证以前提出的主张/假设，并基于对数据的彻底检查和处理开发新的见解。

**入门**

请随意下载我的代码和/或数据，跟随教程，链接到我的 GitHub:[https://github.com/cbratkovics/sat_act_analysis](https://github.com/cbratkovics/sat_act_analysis)

使用 Python 探索数据的第一步是确保导入正确的库。

对于这个介绍，我们需要的库是 NumPy、Pandas、Matplotlib 和 Seaborn。导入库时，可以为其指定一个别名，以减少使用每个库的属性所需的键入量。下面的代码显示了必要的导入语句:

![](img/01cb8f076cc1ff2fd567fd39f608feb9.png)

使用 Pandas 库，您可以将数据文件加载到一个容器对象中，称为数据框。顾名思义，这种类型的容器是一个框架，它保存使用 Pandas 方法 pd.read_csv()读入的数据，该方法专用于 csv 文件。每个 CSV 文件到 Pandas 数据框对象的转换如下所示:

![](img/fc881addea03f05db0be997a91ffed5c.png)

**探索数据&清理损坏的数据**

在执行探索性分析时，了解您正在处理的数据至关重要。幸运的是，数据框对象具有许多有用的属性，使这变得很容易。比较多个数据集中的数据时，标准做法是使用属性*检查每个数据框中的行数和列数。形状*，像这样:

![](img/c5e260c7615fad68d7431251e5a56401.png)

Note that number of rows is on the left and number of columns is on the right; (rows, columns).

我们关于数据的第一个问题是 ACT 2017 和 ACT 2018 数据框架之间的维度不一致。让我们使用*更好地查看数据。head()* 方法，该方法显示 Pandas 数据框对象中每一列的前五行，前五个索引值。我将以 2018 年法案为例:

![](img/eab0506155033e18ce664e499e665493.png)

在预览了其他数据框的前五行之后，我们可以推断出在如何将状态输入到数据集中可能存在问题。由于美国有 51 个州，因此 ACT 2017 和 ACT 2018“州”列中很可能存在不正确和/或重复的值。然而，在处理数据时，我们无法确定这种推断。我们需要检查有问题的数据来找出确切的问题。首先，让我们使用检查 2018 ACT 数据中“State”列的值。value_counts()方法，该方法以降序显示数据框中每个特定值出现的次数:

![](img/8efa64736e936c532cc67e54ebaabe0b.png)

请注意，值“缅因州”在 2018 年 ACT 数据中出现了两次。下一步是确定值是重复的还是数据输入不正确。我们将使用一种称为屏蔽的技术来实现这一点，它允许我们检查数据框中满足指定标准的行。例如，让我们使用屏蔽来查看 2018 ACT 数据中“州”值为“缅因州”的所有行:

![](img/fff9b5051ac12f16f0778b9d2bbd3944.png)

现在，损坏的值已被确认为重复条目。因此，我们可以使用*简单地删除该值。drop()* 方法，并重置数据帧索引，使用*。reset_index()* 方法，解决问题:

![](img/40e36ca630a555ae34f93ee0aa6609ed.png)

注意:act_18.index[52]指定要删除的索引，inplace=True 保存对原始数据框对象的更改，而不将其重新分配给原始数据框对象(act_18)。

现在我们已经解决了 ACT 数据帧之间行数不一致的问题，但是 SAT 和 ACT 数据帧之间的行数不一致的问题仍然存在(ACT 为 52 行，SAT 为 51 行)。为了比较各州之间的 SAT 和 ACT 数据，我们需要确保每个州在每个数据框中得到同等的表示。这是您发挥创造力的机会，您可以想出一种方法来检索数据框之间的“State”列值，比较这些值，并显示结果。我的解决方案显示在下面的函数中:

![](img/5894f562c2b5c59577d619ff688157a9.png)

函数 *compare_values()* 从两个不同的数据框中提取一列，临时存储这些值，并显示只出现在其中一个数据集中的任何值。让我们看看在比较 2017 年和 2018 年的 SAT/ACT“State”列值时它是如何工作的:

![](img/f7267b69b89778136e687971aa604919.png)

好吧！现在，我们知道需要移除两个 ACT 数据框中“州”列中的“国家”值。这可以通过使用我们用来定位和移除 ACT 2018 数据帧中重复的“Maine”值的相同代码来实现:

![](img/b6802c97ee1a75d47b00f596d5e73101.png)

然而，在 SAT 2018 和 ACT 2018 数据中，关于值“华盛顿特区”和“哥伦比亚特区”还有另一个错误。我们需要确定一个一致的值来表示四个数据框中的华盛顿特区/哥伦比亚特区。这两个选项之间的选择并不重要，但选择数据框中出现率最高的名称是一个好习惯。由于 SAT 2017 和 ACT 2017“州”数据之间的唯一区别是“国家”值，我们可以假设“华盛顿特区”和“哥伦比亚特区”在两个数据框的“州”列中是一致的。让我们使用屏蔽技术来检查值“华盛顿特区”和“哥伦比亚特区”中的哪一个在 ACT 2017“州”列中:

![](img/eae5fa91f6ca7c2dc561ba041f77164c.png)

现在，我们正式拥有足够的证据来证明在 ACT 2018 数据框中用“哥伦比亚特区”替换“华盛顿特区”值的合理性。使用熊猫数据帧*。replace()* 方法，我们可以做到这一点。然后，我们可以使用 compare_values 函数确认我们的更改是成功的:

![](img/65f777000f76a49dc120f4e8b2dfc392.png)

成功！现在，每个数据框中各状态的值是一致的。现在，我们可以解决 ACT 数据集之间列数不一致的问题。让我们使用*比较每个数据帧中的列名。列*属性:

![](img/4dd6827a4153e82c097a98e4a35fe7fa.png)

Note that adding the “\n” expression prints a new line after the output of print() is displayed.

由于此分析的目标是比较 SAT 和 ACT 数据，我们越能相似地表示每个数据集的值，我们的分析就越有帮助。因此，我将在每个数据框中只保留“州”、“参与”、“总计”(仅限 SAT)和“综合”(仅限 ACT)。请注意，如果你的分析目标不同，例如比较 2017 年和 2018 年的 SAT 成绩，保持每个成绩类别(如数学)的数据是必不可少的。与手头的任务保持一致，我们可以使用*删除多余的列。*法降()，如是:

![](img/9b555c3b110e96e87a3f21d76417bda8.png)

现在数据框都有相同的尺寸！不幸的是，仍有许多工作要做。让我们看看是否有数据丢失，并查看所有数据框的数据类型:

![](img/b324dd9347102eb23da51d126d9ee5d8.png)

Check for missing data using .isnull().sum()

![](img/e2b7660fe23b11ccdb301e0256af80a4.png)

Check data types with .dtypes

好消息是数据中不存在不存在的值。坏消息是数据类型中的错误，特别是每个数据框中的“参与”列是对象类型，这意味着它被视为字符串。这是有问题的，因为在探索数据时，许多有用的可视化需要数值类型变量才能起作用，例如相关热图、箱线图和直方图。在两个 ACT 数据帧的“复合”列中可以看到同样的问题。我们来看看 SAT 2018 和 ACT 2018 数据的前五行:

![](img/8a5841c55750ae6ba0c6c92346d34a9d.png)

First 5 rows of SAT 2018 data.

![](img/eab0506155033e18ce664e499e665493.png)

First 5 rows of ACT 2018 data.

你可以看到“复合”和“参与”应该是浮动类型。良好的做法是保持您想要比较的数字数据的类型一致，因此在不损害数据完整性的情况下将“Total”转换为 float 类型也是可以接受的(integer = 1166，float = 1166.0)。这种类型转换的第一步是从每个“Participation”列中删除“%”字符，这样就可以将它们转换成浮点数。下一步是将所有数据转换成浮点数，除了每个数据帧中的“State”列。这可能是乏味的，给我们另一个很好的机会来创建一个函数来节省时间！我的解决方案显示在下面的函数中:

![](img/4de35bd1de7e387fd7f76f5dc0908c3b.png)

Note: [https://stackabuse.com/lambda-functions-in-python/](https://stackabuse.com/lambda-functions-in-python/) is a great resource to learn more about using lambda functions in Python 3.

是时候让这些功能发挥作用了。首先让我们使用 *fix_participation()* 函数:

![](img/ebef41a964560a16b5ff3e24b3760732.png)

现在我们可以使用 *convert_to_float()* 函数转换所有列的数据类型:

![](img/be7ca4d22130ce1b493daa7e0fae2b3d.png)

但是等等！运行 *convert_to_float()* 函数应该会抛出一个错误。根据您使用的 IDE，错误消息可能非常有用。在 Jupyter Notebook 中，该错误清楚地将您导向 ACT 2017 数据框中的“复合”列。若要更仔细地查看这些值，请使用。 *value_counts()* 方法:

![](img/895892f1cc0d4a1a5c7311bed91547b3.png)

看起来我们的罪魁祸首是数据中的一个“x”字符，很可能是在将数据输入原始文件时输入错误的结果。要将其移除，请使用*。strip()* 方法在*内。应用()*方法，像这样:

![](img/518f960093d7a27f6d3e5fe8a99e06a7.png)

太好了！现在尝试再次运行这段代码，所有数据都将是正确的类型:

![](img/be7ca4d22130ce1b493daa7e0fae2b3d.png)

开始可视化数据之前的最后一步是将数据合并到单个数据框中。为此，我们需要重命名每个数据框中的列，以描述它们各自代表的内容。例如，SAT 2018 中“参与”栏的一个好名字应该是“sat_participation_17”。当数据被合并时，这个名称更具描述性。另一个注意事项是下划线符号，用于消除访问值时繁琐的空格错误，小写约定用于加快键入速度。数据的命名约定由开发人员决定，但是许多人认为这是一个好的实践。您可以像这样重命名列:

![](img/657bb507e76bcba160a360d17e1e6577.png)

为了合并没有错误的数据，我们需要对齐“state”列的索引，以便在数据帧之间保持一致。我们通过按每个数据框中的“状态”列排序，然后从零开始按顺序重置索引值来实现这一点:

![](img/ee486d87bc0e1ad58c5d7eb6dd46672c.png)

最后，我们可以合并数据。我没有一次合并所有四个数据帧，而是一年一次合并两个，并确认每次合并都没有出现错误。下面是每次合并的代码:

![](img/d1e267808dfb90388ba3e1764711db7b.png)

2017 SAT & ACT merged data frame.

![](img/a969b15221abc33a1ec49df0cd170d74.png)

2018 SAT & ACT merged data frames.

![](img/3cc5074b2bdf81b5813c81c24e511336.png)

Final merge of data frames.

清理完数据后，最好保存它，这样就不必再次清理数据。使用 Pandas 的 pd.to_csv()方法:

![](img/02c72624007fc1157273d43249128ed4.png)

Setting index = False saves the data without its index values.

是时候可视化数据了！现在，我们可以使用 Matplotlib 和 Seaborn 来仔细查看我们干净的组合数据框架。当检查直方图和箱线图时，我将着重于可视化参与率的分布。检查热图时，将考虑所有数据之间的关系。

**可视化数据分布— Seaborn 直方图**

![](img/c1641b54b0b259da7e1b25d23544d075.png)

直方图表示数据集中指定范围内数字数据值出现的频率(例如，数据中有多少值落在 40%-50%的范围内)。从直方图中，我们可以注意到，在 2017 年和 2018 年，有更多的州的 ACT 参与率为 90%-100%。相反，2017 年和 2018 年 SAT 的参与率为 0%-10%的州更多。我们可以推断，90%-100% ACT 参与率的州的较高频率可能是由一些要求采取 ACT 的法规引起的。

**可视化数据分布— Matplotlib 盒图**

![](img/ada2f9694e2e9551a9a13db73189abc3.png)

箱线图表示数据的分布，包括最小值、最大值和四分位间距(IQR)。四分位数范围由第一个分位数、中间值和第三个分位数组成。根据上面的方框图，我们可以看到，从 2017 年到 2018 年，SAT 参与率整体上升。另一个我们可以注意到的是 2017 年到 2018 年 ACT 参与率的一致性。这就提出了一个问题，为什么 SAT 的参与率总体上是上升的，尽管 ACT 的参与率没有显著变化。

**计算并可视化相关性——Seaborn 热图**

![](img/330703e4a2b1dcf9a44317b6cb28548e.png)

中更强的关系由热点图中更接近负值或正值的值表示。较弱的关系由更接近于零的值表示。正相关变量，即在零和正一之间相关的值，表示一个变量随着另一个变量的增加而增加。负相关变量，在负 1 和零之间具有相关性的值，表示一个变量随着另一个变量的增加而减少。需要进一步考察的关联性强的变量包括 2017 年 SAT 参与情况和 2018 年 SAT 参与情况，2017 年 ACT 综合成绩到 2017 年 ACT 参与情况，2018 年 ACT 参与情况和 2018 年 SAT 参与情况。还有更多的关系需要进一步研究，但这些都是引导研究为什么这些关系存在的良好起点。

**结论**

全面的探索性数据分析可确保您的数据干净、可用、一致且直观。请记住，没有干净的数据这种东西，因此在开始处理数据之前探索数据是一种很好的方式，可以在数据分析过程开始之前为其增加完整性和价值。通过对数据的深入研究来指导外部研究，你将能够有效且高效地获得可证明的见解。