<html>
<head>
<title>Creating a Dynamic UI Using Facial Emotions With ARKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过 ARKit 使用面部情绪创建动态用户界面</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-a-dynamic-ui-using-facial-emotions-with-arkit-d2f836010db7?source=collection_archive---------13-----------------------#2019-09-18">https://towardsdatascience.com/creating-a-dynamic-ui-using-facial-emotions-with-arkit-d2f836010db7?source=collection_archive---------13-----------------------#2019-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6d9bca334087816684b12918fee34c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUnWCRIXyIp-hXPvJ9_dKg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo from <a class="ae jd" href="https://unsplash.com/photos/tXz6g8JYYoI" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="31b5" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何创建一个美丽的，动画渐变视图，反应面部情绪</h2></div><p id="26be" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ARKit 和原深感摄像头为开发人员实现基于用户面部表情的直观和动态组件开辟了许多新的可能性。本教程的目标是创建一个动画渐变视图，其颜色对应于相关的情绪。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/322e3601c181b7bea08e584f85576258.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*Bivyp_FXmjOJ7vn-uKXA_A.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Emotion gradient</figcaption></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="aa95" class="md me jg bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">设置一个项目来检测面部运动</h2><p id="e0a7" class="pw-post-body-paragraph kv kw jg kx b ky mw kh la lb mx kk ld le my lg lh li mz lk ll lm na lo lp lq ij bi translated">在 Xcode 中创建一个新项目作为单视图应用程序，然后转到<code class="fe nb nc nd ne b">main.storyboard</code>。将 ARKit SceneKit 视图拖放到您的<code class="fe nb nc nd ne b">ViewController</code>中，并为视图设置任何约束。该视图将显示前摄像机视图。如果愿意，您可以将其设置为隐藏。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/424474578c188272fc90d0161a9c747b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C20Jr5WJ9mXMbJKamhNcnA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">ARKit SceneKit View</figcaption></figure><p id="e1e3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nb nc nd ne b">Import ARKit</code>，然后将<code class="fe nb nc nd ne b">ARSCNView</code>添加到<code class="fe nb nc nd ne b">ViewController</code>中。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/8f9de6f5f68715d341e1be521b2ff75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Fdfh0gASrphU7nyPaX5Dg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">ARSCNView tracking view</figcaption></figure><p id="2344" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在添加面部跟踪功能</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="21f3" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">override</strong> <strong class="ne jh">func</strong> viewDidLoad() { <br/>    <strong class="ne jh">super</strong>.viewDidLoad()<br/>    <strong class="ne jh">guard</strong> ARFaceTrackingConfiguration.isSupported <strong class="ne jh">else</strong> {<br/>        fatalError("Face tracking not available on this on this device model!")<br/>    }</span><span id="f905" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    let</strong> configuration = ARFaceTrackingConfiguration()<br/>    <strong class="ne jh">self</strong>.trackingView.session.run(configuration)<br/>    <strong class="ne jh">self</strong>.trackingView.delegate = <strong class="ne jh">self<br/></strong>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="d713" class="md me jg bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">情感跟踪</h2><p id="9a1b" class="pw-post-body-paragraph kv kw jg kx b ky mw kh la lb mx kk ld le my lg lh li mz lk ll lm na lo lp lq ij bi translated">创建一个名为<code class="fe nb nc nd ne b">Emotion</code>和<code class="fe nb nc nd ne b">import ARKit</code>的新文件。然后添加以下协议，带有后续扩展名。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="8580" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">import</strong> UIKit<br/><strong class="ne jh">import</strong> ARKit</span><span id="b575" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">protocol</strong> Emotion {</span><span id="a95c" class="md me jg ne b gy np nm l nn no"><em class="nq">    // The range between 0-1 where the emotion is considered active or not<br/>    </em><strong class="ne jh">var</strong> threshold: Double { <strong class="ne jh">get</strong> }</span><span id="a9ce" class="md me jg ne b gy np nm l nn no"><em class="nq">    // List of colors associated with the emotion<br/>    </em><strong class="ne jh">var</strong> colors: [UIColor] { <strong class="ne jh">get</strong> }</span><span id="3e23" class="md me jg ne b gy np nm l nn no"><em class="nq">    // Calculated from the the blendshapes to see if that face has the given emotion (for example smile is calculated from '.mouthSmileLeft' or '.mouthSmileRight' being over the threshold amount)<br/>    </em><strong class="ne jh">func</strong> isActive(for face: ARFaceAnchor) -&gt; Bool</span><span id="1182" class="md me jg ne b gy np nm l nn no">}</span><span id="f4ae" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">extension</strong> Emotion {<br/>    <em class="nq">// Set default threshold to 0.3, can be overriden by class to change value.<br/>    </em><strong class="ne jh">var</strong> threshold: Double {<br/>        <strong class="ne jh">return</strong> 0.3<br/>    }<br/>}</span></pre><p id="be9a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将创建想要跟踪的情感对象。对于这个教程，我只打算把中性，快乐，悲伤和愤怒。为了确定人脸的情绪，我们将分析人脸对象的混合形状。您可以在此查看所有<a class="ae jd" href="https://developer.apple.com/documentation/arkit/arfaceanchor/blendshapelocation" rel="noopener ugc nofollow" target="_blank">可用的混合形状。</a></p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="720e" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">struct</strong> NeutralEmotion: Emotion {</span><span id="7593" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    var</strong> colors: [UIColor] = [UIColor(hexString: "#9CC0E7"), UIColor(hexString: "#EEEEEE"), UIColor(hexString: "#FCFCFC"), UIColor(hexString: "#F7DBD7")]</span><span id="aede" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    func</strong> isActive(for face: ARFaceAnchor) -&gt; Bool {<br/>    <br/>        <strong class="ne jh">for</strong> blendshape <strong class="ne jh">in</strong> face.blendShapes {<br/>            <strong class="ne jh">if</strong> blendshape.value.doubleValue &gt; <strong class="ne jh">self</strong>.threshold {<br/>                <strong class="ne jh">return</strong> <strong class="ne jh">false<br/>            </strong>}<br/>        }<br/>        <strong class="ne jh">return</strong> <strong class="ne jh">true<br/>    </strong>}<br/>}</span><span id="3332" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">struct</strong> HappyEmotion: Emotion {<br/>    <strong class="ne jh">var</strong> colors: [UIColor] = [UIColor(hexString: "#01BEFE"), UIColor(hexString: "#FFDD00"), UIColor(hexString: "#ADFF02"), UIColor(hexString: "#E7B2FF")]</span><span id="fdd6" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    func</strong> isActive(for face: ARFaceAnchor) -&gt; Bool {<br/>        <strong class="ne jh">return</strong> face.blendShapes[.mouthSmileLeft]?.doubleValue ?? 0 &gt; <strong class="ne jh">self</strong>.threshold || face.blendShapes[.mouthSmileRight]?.doubleValue ?? 0 &gt; <strong class="ne jh">self</strong>.threshold<br/>    }<br/>}</span><span id="1758" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">struct</strong> SadEmotion: Emotion {<br/>    <strong class="ne jh">var</strong> colors: [UIColor] = [UIColor(hexString: "#345467"), UIColor(hexString: "#101442"), UIColor(hexString: "#1F6B65"), UIColor(hexString: "#1D4E7A")]</span><span id="ef00" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    func</strong> isActive(for face: ARFaceAnchor) -&gt; Bool {<br/>        <strong class="ne jh">return</strong> face.blendShapes[.mouthFrownLeft]?.doubleValue ?? 0 &gt; <strong class="ne jh">self</strong>.threshold || face.blendShapes[.mouthFrownRight]?.doubleValue ?? 0 &gt; <strong class="ne jh">self</strong>.threshold<br/>    }<br/>}</span><span id="20fb" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">struct</strong> AngryEmotion: Emotion {<br/>    <strong class="ne jh">var</strong> colors: [UIColor] = [UIColor(hexString: "#E72222"), UIColor(hexString: "#C92929"), UIColor(hexString: "#AB3232"), UIColor(hexString: "#963232")]</span><span id="da65" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    func</strong> isActive(for face: ARFaceAnchor) -&gt; Bool {<br/>        <strong class="ne jh">return</strong> face.blendShapes[.browDownRight]?.doubleValue ?? 0 &gt; <strong class="ne jh">self</strong>.threshold || face.blendShapes[.browDownLeft]?.doubleValue ?? 0 &gt; <strong class="ne jh">self</strong>.threshold<br/>    }<br/>}</span></pre><p id="2284" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，我还添加了一个 UIColor 扩展，它使用十六进制字符串代替 RGB 值。要将它添加到您的项目中，创建一个名为<code class="fe nb nc nd ne b">ColorExtensions</code>的文件，并添加以下代码。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="f71a" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">import</strong> UIKit</span><span id="3ffe" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">extension</strong> UIColor {<br/>    <strong class="ne jh">convenience</strong> <strong class="ne jh">init</strong>(hexString: String) {<br/>        <strong class="ne jh">let</strong> hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)<br/>        <strong class="ne jh">var</strong> int = UInt32()<br/>        Scanner(string: hex).scanHexInt32(&amp;int)<br/>        <strong class="ne jh">let</strong> a, r, g, b: UInt32<br/>        <br/>        <strong class="ne jh">switch</strong> hex.count {<br/>            <strong class="ne jh">case</strong> 3: <em class="nq">// RGB (12-bit)<br/>                </em>(a, r, g, b) = (255, (int &gt;&gt; 8) * 17, (int &gt;&gt; 4 &amp; 0xF) * 17, (int &amp; 0xF) * 17)<br/>            <strong class="ne jh">case</strong> 6: <em class="nq">// RGB (24-bit)<br/>                </em>(a, r, g, b) = (255, int &gt;&gt; 16, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)<br/>            <strong class="ne jh">case</strong> 8: <em class="nq">// ARGB (32-bit)<br/>                </em>(a, r, g, b) = (int &gt;&gt; 24, int &gt;&gt; 16 &amp; 0xFF, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)<br/>            <strong class="ne jh">default</strong>:<br/>                (a, r, g, b) = (255, 0, 0, 0)<br/>        }<br/>        <strong class="ne jh">self</strong>.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255)<br/>    }<br/>}</span></pre><p id="c194" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在想要创建一个名为<code class="fe nb nc nd ne b">EmotionManager</code>的新文件。这个类将分析一个<a class="ae jd" href="https://developer.apple.com/documentation/arkit/arfaceanchor" rel="noopener ugc nofollow" target="_blank"> ARFaceAnchor </a>对象，看看它是否匹配我们的任何情感对象规范，并将它们保存在一个列表中。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="dd02" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">import</strong> UIKit<br/><strong class="ne jh">import</strong> ARKit</span><span id="ab39" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">class</strong> EmotionManager {</span><span id="aa2c" class="md me jg ne b gy np nm l nn no"><em class="nq">    // List of all of the emotions we want to track<br/>    </em><strong class="ne jh">private</strong> <strong class="ne jh">var</strong> emotions: [Emotion] = [NeutralEmotion(), HappyEmotion(), SadEmotion(), AngryEmotion()]</span><span id="0f55" class="md me jg ne b gy np nm l nn no"><em class="nq">    // Current active emotions. Defaults to neutral.<br/>    </em><strong class="ne jh">var</strong> activeEmotions: [Emotion] = [NeutralEmotion()]</span><span id="4136" class="md me jg ne b gy np nm l nn no"><em class="nq">    // Gets the current emotions found in the given ARFaceAnchor object. If none are found then return neutral as default.<br/>    </em><strong class="ne jh">func</strong> refreshActiveEmotions(for face: ARFaceAnchor) {<br/>        <strong class="ne jh">var</strong> activeEmotions = [Emotion]()</span><span id="c4e1" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">        for</strong> emotion <strong class="ne jh">in</strong> <strong class="ne jh">self</strong>.emotions {<br/>            <strong class="ne jh">if</strong> emotion.isActive(for: face) {<br/>                activeEmotions.append(emotion)<br/>            }<br/>        }</span><span id="638d" class="md me jg ne b gy np nm l nn no"><em class="nq">        // If no active emotions are found then default to neutral<br/>        </em><strong class="ne jh">self</strong>.activeEmotions = activeEmotions.isEmpty ? [NeutralEmotion()] : activeEmotions<br/>    }</span><span id="4218" class="md me jg ne b gy np nm l nn no"><em class="nq">    // Return emotion colors from currently active face emotions. Shuffle the order so the gradient constantly changes.<br/>    </em><strong class="ne jh">func</strong> getEmotionColors() -&gt; [CGColor] {<br/>        <strong class="ne jh">return</strong> activeEmotions.flatMap { $0.colors.compactMap { $0.cgColor } }.shuffled()<br/>    }<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="294a" class="md me jg bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">动画渐变视图</h2><p id="279d" class="pw-post-body-paragraph kv kw jg kx b ky mw kh la lb mx kk ld le my lg lh li mz lk ll lm na lo lp lq ij bi translated">回到你的<code class="fe nb nc nd ne b">ViewController</code>，为我们刚刚创建的<code class="fe nb nc nd ne b">EmotionManager</code>添加一个实例变量和一个<a class="ae jd" href="https://developer.apple.com/documentation/quartzcore/cagradientlayer" rel="noopener ugc nofollow" target="_blank"> CAGradientLayer </a>(这将是我们的渐变)。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="7a9d" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">var</strong> emotionManager = EmotionManager()<br/><strong class="ne jh">var</strong> gradientView : CAGradientLayer?</span></pre><p id="290b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们需要两个函数，<code class="fe nb nc nd ne b">initialiseGradient()</code>和<code class="fe nb nc nd ne b">animateGradient()</code>，它们都将在<code class="fe nb nc nd ne b">viewDidLoad()</code>方法的末尾被调用。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="3f88" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">override</strong> <strong class="ne jh">func</strong> viewDidLoad() {<br/>    <strong class="ne jh">super</strong>.viewDidLoad()</span><span id="e4a1" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    guard</strong> ARFaceTrackingConfiguration.isSupported <strong class="ne jh">else</strong> {<br/>    fatalError("Face tracking not available on this on this device model!")<br/>    }</span><span id="fb7e" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    let</strong> configuration = ARFaceTrackingConfiguration()<br/>    <strong class="ne jh">self</strong>.trackingView.session.run(configuration)<br/>    <strong class="ne jh">self</strong>.trackingView.delegate = <strong class="ne jh">self</strong></span><span id="4fd3" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    self</strong>.initialiseGradient()<br/>    <strong class="ne jh">self</strong>.animateGradient()<br/>}</span><span id="beb0" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">func</strong> initialiseGradient() {<br/>    <em class="nq">// Create gradient view to take up whole of the background view<br/>    </em><strong class="ne jh">self</strong>.gradientView = CAGradientLayer()</span><span id="9ed3" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    self</strong>.gradientView?.startPoint = CGPoint(x: 0, y: 0) <em class="nq">// Starts in top left corner<br/>    </em><strong class="ne jh">self</strong>.gradientView?.endPoint = CGPoint(x: 1, y: 1) <em class="nq">// Ends in bottom right corner</em></span><span id="b5cf" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    self</strong>.gradientView?.frame = <strong class="ne jh">self</strong>.view.frame<br/>    <strong class="ne jh">self</strong>.gradientView?.colors = emotionManager.getEmotionColors()<br/>    view.layer.insertSublayer(<strong class="ne jh">self</strong>.gradientView!, at: 0)<br/>}</span><span id="5ca1" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">func</strong> animateGradient() {<br/>    <em class="nq">// Animates gradient from current gradient colors to current emotion colors<br/>    </em><strong class="ne jh">let</strong> colorArray = <strong class="ne jh">self</strong>.emotionManager.getEmotionColors()<br/>    <strong class="ne jh">let</strong> animation = CABasicAnimation(keyPath: "colors")<br/>    animation.duration = 1<br/>    animation.fromValue = <strong class="ne jh">self</strong>.gradientView!.colors<br/>    animation.toValue = colorArray<br/>    animation.delegate = <strong class="ne jh">self<br/>    self</strong>.gradientView?.add(animation, forKey: <strong class="ne jh">nil</strong>)<br/>    DispatchQueue.main.async {<br/>        CATransaction.setDisableActions(<strong class="ne jh">true</strong>)<br/>        <strong class="ne jh">self</strong>.gradientView?.colors = colorArray<br/>    }<br/>}</span></pre><p id="e36d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为了在当前动画完成后开始新的渐变动画，创建无休止的渐变运动效果，我们需要扩展<a class="ae jd" href="https://developer.apple.com/documentation/quartzcore/caanimationdelegate" rel="noopener ugc nofollow" target="_blank"> CAAnimationDelegate </a>并从<code class="fe nb nc nd ne b">animationDidStop</code>方法中调用<code class="fe nb nc nd ne b">animateGradient()</code>。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="7734" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">extension</strong> ViewController: CAAnimationDelegate {</span><span id="7fab" class="md me jg ne b gy np nm l nn no"><strong class="ne jh">    func</strong> animationDidStop(<strong class="ne jh">_</strong> anim: CAAnimation, finished flag: Bool) {<br/>        DispatchQueue.main.async {<br/>            <em class="nq">// Run new gradient animation once the previous has finished to create the endless gradient movement effect<br/>            </em><strong class="ne jh">self</strong>.animateGradient()<br/>        }<br/>    }<br/>}</span></pre><p id="5930" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们想要扩展 ARSCNViewDelegate 并在 renderer 方法内部检查一个包含面部表情数据的 ARFaceAnchor 。如果我们找到一个面部锚，我们可以将它传递给我们的<code class="fe nb nc nd ne b">emotionManager</code>来检查任何活跃的情绪，这将相应地改变颜色。</p><pre class="ls lt lu lv gt nh ne ni nj aw nk bi"><span id="f603" class="md me jg ne b gy nl nm l nn no"><strong class="ne jh">extension</strong> ViewController: ARSCNViewDelegate {</span><span id="4942" class="md me jg ne b gy np nm l nn no">    <strong class="ne jh">func</strong> renderer(<strong class="ne jh">_</strong> renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) {<br/>        <strong class="ne jh">guard</strong> <strong class="ne jh">let</strong> faceAnchor = anchor <strong class="ne jh">as</strong>? ARFaceAnchor <strong class="ne jh">else</strong> { <strong class="ne jh">return</strong> }<br/>        DispatchQueue.main.async {<br/>            <strong class="ne jh">self</strong>.emotionManager.refreshActiveEmotions(for: faceAnchor)<br/>        }<br/>    }<br/>}</span></pre><p id="c73c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！</p><p id="c66d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你喜欢这个教程，如果你把它应用到你自己的任何项目中，或者它启发你创造类似的东西，那么请联系我，因为我很想看看你做了什么。</p><p id="975f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://github.com/JakeHoldom/EmotionTrackingGradient" rel="noopener ugc nofollow" target="_blank">点击此处查看完整源代码。</a></p></div></div>    
</body>
</html>