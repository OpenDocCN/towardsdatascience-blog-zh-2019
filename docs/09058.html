<html>
<head>
<title>Handling Trees in Data Science Algorithmic Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在数据科学算法面试中处理树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handling-trees-in-data-science-algorithmic-interview-ea14dd1b6236?source=collection_archive---------28-----------------------#2019-12-02">https://towardsdatascience.com/handling-trees-in-data-science-algorithmic-interview-ea14dd1b6236?source=collection_archive---------28-----------------------#2019-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f52cd89900d371d5e286df77eb4a52dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwZlZcJR0tr1PDUhIrVVFA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/jplenio-7645255/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3120483" rel="noopener ugc nofollow" target="_blank">Johannes Plenio</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3120483" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h2 id="24cb" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/algorithms-interview" rel="noopener" target="_blank">算法面试</a></h2><div class=""/><div class=""><h2 id="d58f" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">不是那种树桩</h2></div><p id="0f11" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">算法和数据结构是数据科学不可或缺的一部分。虽然我们大多数数据科学家在学习时都没有上过适当的算法课程，但它们仍然至关重要。</p><p id="70b9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">许多公司在招聘数据科学家的面试过程中会询问数据结构和算法。</p><p id="8ef1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，许多人在这里问的问题是，问一个数据科学家这样的问题有什么用。<strong class="lj jt"> <em class="md">我喜欢这样描述，一个数据结构问题可以被认为是一个编码能力测试。</em> </strong></p><p id="b4d0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们都在人生的不同阶段进行过能力倾向测试，虽然它们不是判断一个人的完美代理，但几乎没有什么是真的。那么，为什么没有一个标准的算法测试来判断人的编码能力。</p><p id="b04f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但我们不要自欺欺人，他们需要像你的数据科学面试一样的热情，因此，你可能需要花一些时间来研究算法和数据结构问题。</p><p id="9798" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="md">这篇文章是关于快速跟踪这项研究，并为数据科学家解释树的概念，以便你下次在面试中被问到这些问题时轻松通过。</em>T11】</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ea3f" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">但是首先，为什么树对数据科学很重要？</h1><p id="bd49" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">对于数据科学家来说，树和软件工程师有着不同的含义。</p><p id="1cab" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于软件工程师来说，树只是一种简单的数据结构，他们可以用它来管理层次关系，而对于数据科学家来说，树是一些最有用的分类和回归算法的基础。</p><p id="3edd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那么这两个在哪里见面呢？</p><p id="4f74" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它们必然是同一件事。不要惊讶。下面是数据科学家和软件工程师对树的看法。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/9c86b5098ba27b96c634ec3ebb36a32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZ52oRUlHbGF3LpWCJ2Qng.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">They are essentially the same</figcaption></figure><p id="a980" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">唯一的区别是数据科学树节点保存了更多的信息，帮助我们确定如何遍历树。例如，在用于预测的数据科学树的情况下，我们将查看节点中的要素，并根据分割值确定我们要移动的方向。</p><p id="9500" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想从头开始写你的决策树，你可能也需要从软件工程的角度理解树是如何工作的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7787" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">树的类型:</h1><p id="7961" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">在这篇文章中，我将只讨论在数据科学面试问题中经常被问到的两种树。二叉树(BT)和称为二分搜索法树(BST)的二叉树的扩展。</p><h2 id="2331" class="nn mm jj bd mn no np dn mr nq nr dp mv lq ns nt mx lu nu nv mz ly nw nx nb jp bi translated">1.二叉树:</h2><p id="8669" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">二叉树是一种简单的树，其中每个节点最多有两个子节点。决策树是我们在日常生活中看到的一个例子。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/f58cbd8e055900007cd2df88f5b74dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8VoVECt3onUcyqSk.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Binary Tree: Each Node has up to 2 children</figcaption></figure><h2 id="7ae4" class="nn mm jj bd mn no np dn mr nq nr dp mv lq ns nt mx lu nu nv mz ly nw nx nb jp bi translated">2.二叉查找树(英国夏令时):</h2><p id="00dc" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">二叉查找树是一棵二叉树，其中:</p><ul class=""><li id="5d8c" class="nz oa jj lj b lk ll ln lo lq ob lu oc ly od mc oe of og oh bi translated">一个节点的所有左后代都小于或等于该节点，并且</li><li id="9c13" class="nz oa jj lj b lk oi ln oj lq ok lu ol ly om mc oe of og oh bi translated">该节点的所有右后代都大于该节点。</li></ul><p id="01e3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">谈到平等，这个定义有各种不同的说法。有时等式在右边或两边。有时树中只允许不同的值。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/300fc8ea6a59b9df3951de6b30a240b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4KN__GqViFvtu3B6"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://www.freecodecamp.org/news/data-structures-101-binary-search-tree-398267b6bff0/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="ab98" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">8 大于左侧子树中的所有元素，小于右侧子树中的所有元素。这同样适用于树中的任何节点。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b2c3" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">创建简单的树:</h1><p id="dc49" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">那么我们如何构造一棵简单的树呢？</p><p id="3a71" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据定义，树是由节点组成的。所以我们从定义用于创建节点的<code class="fe oo op oq or b">node</code>类开始。我们的节点类非常简单，因为它保存了节点的值、左侧子节点的位置和右侧子节点的位置。</p><pre class="nj nk nl nm gt os or ot ou aw ov bi"><span id="642a" class="nn mm jj or b gy ow ox l oy oz">class node:<br/>    def __init__(self,val):<br/>        self.val = val<br/>        self.left = None<br/>        self.right = None</span></pre><p id="e6e5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在可以创建一个简单的树，如下所示:</p><pre class="nj nk nl nm gt os or ot ou aw ov bi"><span id="ebee" class="nn mm jj or b gy ow ox l oy oz">root = node(1)<br/>root.left = node(2)<br/>root.right = node(3)</span></pre><p id="fb70" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我注意到，如果我们自己不做一些编码，我们就不能真正掌握基于树的问题。</p><p id="18a3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，让我们更深入地了解一下代码部分，我发现一些关于树的最有趣的问题。 </p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="aeb0" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">有序树遍历:</h1><p id="f523" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">有很多种方法可以遍历一棵树，但是我发现顺序遍历是最直观的。</p><p id="3a60" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们在二叉查找树的根节点上进行有序遍历时，它以升序访问/打印节点。</p><pre class="nj nk nl nm gt os or ot ou aw ov bi"><span id="6289" class="nn mm jj or b gy ow ox l oy oz">def inorder(node):<br/>    if node:<br/>        inorder(node.left)<br/>        print(node.val)<br/>        inorder(node.right)</span></pre><p id="3597" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上述方法非常重要，因为它允许我们访问所有节点。</p><p id="9827" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，如果我们想在任何二叉树中搜索一个节点，我们可以尝试使用 inorder 树遍历。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="03fc" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">从排序后的数组创建二叉查找树</h1><p id="4d6a" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">如果我们需要像上面那样手动创建一棵树，我们会是什么样的编码人员呢？</p><p id="705b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那么我们能从一个唯一元素的有序数组中创建一个 BST 吗？T12】</p><pre class="nj nk nl nm gt os or ot ou aw ov bi"><span id="9034" class="nn mm jj or b gy ow ox l oy oz">def create_bst(array,min_index,max_index):<br/>    if max_index&lt;min_index:<br/>        return None<br/>    mid = int((min_index+max_index)/2)<br/>    root = node(array[mid])<br/>    leftbst = create_bst(array,min_index,mid-1)<br/>    rightbst = create_bst(array,mid+1,max_index)<br/>    root.left = leftbst<br/>    root.right = rightbst<br/>    return root</span><span id="e73d" class="nn mm jj or b gy pa ox l oy oz">a = [2,4,5,6,7]<br/>root = create_bst(a,0,len(a)-1)</span></pre><p id="64e3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">树本质上是递归的，所以我们在这里使用递归。我们取数组的中间元素，并将其指定为节点。然后，我们将<code class="fe oo op oq or b">create_bst</code>函数应用到数组的左边部分，并将其分配给<code class="fe oo op oq or b">node.left</code>，对数组的右边部分做同样的操作。</p><p id="8fb3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们得到了 BST。</p><p id="c4b4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们做得对吗？我们可以通过创建 BST 然后进行有序遍历来检查它。</p><pre class="nj nk nl nm gt os or ot ou aw ov bi"><span id="3eb0" class="nn mm jj or b gy ow ox l oy oz">inorder(root)<br/>------------------------------------------------------------<br/>2<br/>4<br/>5<br/>6<br/>7</span></pre><p id="0f32" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好像没错！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5bac" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">让我们检查一下我们的树是否是有效的 BST</h1><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/a3288fd197d6d49cff89246ca032f148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rk7nkNFIpqThb9BY.jpg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Think Recursion!!!</figcaption></figure><p id="a64c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是，如果我们需要打印所有的元素并手动检查 BST 属性是否得到满足，那么我们是什么样的编码人员呢？</p><p id="65b4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里有一个简单的代码来检查我们的 BST 是否有效。我们假设在我们的二叉查找树中存在严格的不平等。</p><pre class="nj nk nl nm gt os or ot ou aw ov bi"><span id="76d7" class="nn mm jj or b gy ow ox l oy oz">def isValidBST(node, minval, maxval):<br/>    if node:<br/>        # Base case<br/>        if node.val&lt;=minval or node.val&gt;=maxval:<br/>            return False<br/>        # Check the subtrees changing the min and max values<br/>        return isValidBST(node.left,minval,node.val) &amp;    isValidBST(node.right,node.val,maxval)<br/>    return True</span><span id="d1eb" class="nn mm jj or b gy pa ox l oy oz">isValidBST(root,-float('inf'),float('inf'))<br/>--------------------------------------------------------------<br/>True</span></pre><p id="fd10" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们递归地检查子树是否满足二叉查找树性质。在每次递归调用时，我们改变调用的<code class="fe oo op oq or b">minval</code>或<code class="fe oo op oq or b">maxval</code>，为函数提供子树的允许值范围。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a959" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">结论</h1><p id="5191" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated"><strong class="lj jt"> <em class="md">在这篇帖子里，我从软件工程的角度谈论了树。如果你想从数据科学的角度看树，你可以看看这篇文章。</em> </strong></p><div class="is it gp gr iu pc"><a rel="noopener follow" target="_blank" href="/the-simple-math-behind-3-decision-tree-splitting-criterions-85d4de2a75fe"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd jt gy z fp ph fr fs pi fu fw js bi translated">3 个决策树分裂标准背后的简单数学</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">🌀理解分割标准</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ja pc"/></div></div></a></div><p id="5184" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">树构成了数据科学算法面试中一些最常见问题的基础。我过去常常对这种基于树的问题感到绝望，但现在我已经开始喜欢其中涉及的精神锻炼。我喜欢这类问题中的递归结构。</p><p id="198e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然您可以在不学习它们的情况下在数据科学中走得更远，但您可以为了一点乐趣而学习它们，也许是为了提高您的编程技能。</p><p id="a4d4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是给你的一个小笔记本,我把所有这些小概念都放在这里，让你尝试和运行。</p><p id="42c8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看看我在<a class="ae jg" href="https://towardsdatascience.com/tagged/algorithms-interview" rel="noopener" target="_blank">算法面试系列</a>的其他帖子，如果你想了解<a class="ae jg" rel="noopener" target="_blank" href="/three-programming-concepts-for-data-scientists-c264fc3b1de8">递归</a>、<a class="ae jg" rel="noopener" target="_blank" href="/dynamic-programming-for-data-scientists-bb7154b4298b">动态规划</a>或者<a class="ae jg" rel="noopener" target="_blank" href="/a-simple-introduction-of-linked-lists-for-data-scientists-a71f0eb31d87">链表</a>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ec7e" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">继续学习</h1><p id="de4a" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">如果你想阅读更多关于算法和数据结构的内容，我强烈推荐 UCSanDiego<strong class="lj jt"/>在 Coursera 上的<a class="ae jg" href="https://click.linksynergy.com/deeplink?id=lVarvwc5BD0&amp;mid=40328&amp;murl=https%3A%2F%2Fwww.coursera.org%2Fspecializations%2Fdata-structures-algorithms" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">算法专门化。</strong></a></p><p id="1860" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae jg" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"> <strong class="lj jt">媒体</strong> </a>关注我或者订阅我的<a class="ae jg" href="http://eepurl.com/dbQnuX?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p><p id="1416" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，一个小小的免责声明——这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p></div></div>    
</body>
</html>