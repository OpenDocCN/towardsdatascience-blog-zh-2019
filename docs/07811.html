<html>
<head>
<title>Five Python Moves that Make you Look Funcy Like James Brown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你看起来像詹姆斯·布朗的五个蟒蛇动作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-python-moves-that-make-you-look-funcy-like-james-brown-7da78a9c4050?source=collection_archive---------15-----------------------#2019-10-29">https://towardsdatascience.com/five-python-moves-that-make-you-look-funcy-like-james-brown-7da78a9c4050?source=collection_archive---------15-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0bef1f789d1d46efad313b9048a3d9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzwpVoafU0b4DwH3ograDw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@startdig?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Start Digital</a> on <a class="ae kf" href="https://unsplash.com/s/photos/funky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们作为数据科学家的日常生活中，我们经常使用各种 Python 数据结构，如列表、集合或字典，或者更一般地说，我们使用<em class="le"> iterables </em>和<em class="le"> mappings </em>。有时，转换或操作这些数据结构会变得非常代码化。这可能导致代码不可读，并增加引入错误的机会。幸运的是，有一个叫做<a class="ae kf" href="https://funcy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> funcy </a>的简洁的 Python 模块可以帮助我们简化这些任务。在这篇短文中，我向您展示了普通的 Python 代码和相应的 funcy 函数，这些函数允许您用可读性更好的代码更高效地完成五个不同的任务。读完这篇文章后，我相信你会变得更有趣:)</p><h2 id="4edd" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">省略/投影</h2><p id="5cb5" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">有时您得到了一个字典，而您想继续使用该字典的一个子集。例如，假设您正在构建一个 rest API 端点，并且您只想返回模型属性的子集。为此，funcy 提供了两个功能，即<em class="le">省略</em>和<em class="le">项目</em></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8f33" class="lf lg it mi b gy mm mn l mo mp"><strong class="mi iu">from</strong> funcy <strong class="mi iu">import</strong> project, omit</span><span id="6f80" class="lf lg it mi b gy mq mn l mo mp">data = {<strong class="mi iu">"this"</strong>: 1, <strong class="mi iu">"is"</strong>: 2, <strong class="mi iu">"the"</strong>: 3, <strong class="mi iu">"sample"</strong>: 4, <strong class="mi iu">"dict"</strong>: 5}</span><span id="ffb4" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># FUNCY<br/></strong>omitted_f = omit(data, (<strong class="mi iu">"is"</strong>, <strong class="mi iu">"dict"</strong>))<br/><strong class="mi iu"># PLAIN PYTHON</strong><br/>omitted_p = {k: data[k] <br/>             <strong class="mi iu">for</strong> k <strong class="mi iu">in</strong> set(data.keys()).difference({<strong class="mi iu">"is"</strong>, <strong class="mi iu">"dict"</strong>})<br/>            }</span><span id="8bbb" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># FUNCY<br/></strong>projected_f = project(data, (<strong class="mi iu">"this"</strong>, <strong class="mi iu">"is"</strong>))<br/><strong class="mi iu"># PLAIN PYTHON<br/></strong>projected_p = {k: data[k] <strong class="mi iu">for</strong> k <strong class="mi iu">in</strong> (<strong class="mi iu">"this"</strong>, <strong class="mi iu">"is"</strong>)}</span></pre><p id="0da6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 funcy，您不仅需要键入更少的字符，还可以获得可读性更好、更少出错的代码。但是为什么我们需要两个功能呢？如果您想要保留的关键点数量小于您想要移除的关键点数量，选择<em class="le">项目</em>否则选择<em class="le">忽略</em>。</p><h2 id="fe2b" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">展平嵌套的数据结构</h2><p id="9235" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">假设你有一个嵌套的数据结构，比如一个列表和列表的列表，你想把它变成一个列表。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3e94" class="lf lg it mi b gy mm mn l mo mp"><strong class="mi iu">from</strong> funcy <strong class="mi iu">import</strong> lflatten</span><span id="735a" class="lf lg it mi b gy mq mn l mo mp">data = [1, 2, [3, 4, [5, 6]], 7, [8, 9]]</span><span id="a9fe" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># FUNCY</strong><br/>flattened_f = lflatten(data)</span><span id="41c7" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># PLAIN PYTHON</strong><br/><strong class="mi iu">def</strong> flatter(in_):<br/>    for e in in_:<br/>        <strong class="mi iu">if</strong> isinstance(e, list):<br/>            <strong class="mi iu">yield</strong> <strong class="mi iu">from</strong> flatter(e)<br/>        <strong class="mi iu">else</strong>:<br/>            <strong class="mi iu">yield</strong> e</span><span id="c90c" class="lf lg it mi b gy mq mn l mo mp">flattend_p = [e <strong class="mi iu">for</strong> e <strong class="mi iu">in</strong> flatter(data)]</span></pre><p id="5b57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，funcy 版本只有一行代码，而普通 Python 版本看起来相当复杂。我也花了一些时间来想出解决方案，我仍然没有 100%的信心。所以，我会坚持使用 funcy:)除了 list 版本<strong class="ki iu"> l </strong> flatten，funcy 还为 iterables 提供了一个更通用的版本，称为 flatten，没有 l 前缀。你会发现对于不同的函数。</p><h2 id="de9c" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">分成块</h2><p id="df29" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">假设您有一个包含<em class="le"> n </em>个条目的 iterable，并且您想要将它分成包含<em class="le"> k &lt; n </em>个元素的块。如果 n 不能被 k 整除，则最后一个块可以小于 k。这就像有一个 n 个样本的训练集，您希望将其分成大小为 k 的批次来进行批处理</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="614a" class="lf lg it mi b gy mm mn l mo mp"><strong class="mi iu">from</strong> funcy <strong class="mi iu">import</strong> lchunks<br/>data = list(range(10100))</span><span id="4e91" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># FUNCY</strong><br/><strong class="mi iu">for</strong> batch <strong class="mi iu">in</strong> lchunks(64, data):<br/>    # process the batch<br/>    pass</span><span id="3952" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># PLAIN PYTHON<br/>from </strong>typing<strong class="mi iu"> import </strong>Iterable, Any, List</span><span id="b182" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu">def</strong> my_chunks(batch_size:int, data:Iterable[Any])-&gt;List[Any]:<br/>    res = []<br/>    <strong class="mi iu">for</strong> i, e <strong class="mi iu">in</strong> enumerate(data):<br/>        res.append(e)<br/>        <strong class="mi iu">if</strong> (i + 1) % batch_size == 0:<br/>            <strong class="mi iu">yield</strong> res<br/>            res = []<br/>    <strong class="mi iu">if</strong> res:<br/>        yield res<br/>        <br/><strong class="mi iu">for</strong> batch <strong class="mi iu">in</strong> my_chunks(64, data):<br/>    # process the batch<br/>    <strong class="mi iu">pass</strong></span></pre><p id="9672" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我使用了<em class="le"> lchunks </em>版本来进行列表分区，而不是更通用的<em class="le"> chunks </em>版本来对可重复项进行分区。您所要做的就是传递您想要的批处理/块大小，以及您想要分区的 iterable。还有另一个 funcy 函数，叫做<em class="le">分区</em>，它只返回那些正好有 k 个条目的块。因此，如果 n 不能被 k 整除，它将忽略最后一个。</p><h2 id="1643" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">组合多个词典</h2><p id="3670" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">假设您有多个保存不同日期但相同对象的数据的字典。您的目标是将所有这些字典合并成一个字典，并使用特定的函数合并来自相同关键字的数据。在这里，funcy 的<em class="le"> merge_with </em>函数派上了用场。你只需要传入合并函数和所有你想合并的字典。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7f7d" class="lf lg it mi b gy mm mn l mo mp"><strong class="mi iu">from</strong> funcy <strong class="mi iu">import</strong> merge_with, lcat<br/>d1 = {1: [1, 2], 2: [4, 5, 6]}</span><span id="2d6f" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># FUNCY VERSION</strong><br/>merged_f = merge_with(lcat, d1,d2)</span><span id="42fa" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># PYTHON VERSION</strong><br/><strong class="mi iu">from</strong> itertools <strong class="mi iu">import</strong> chain<br/><strong class="mi iu">from</strong> typing <strong class="mi iu">import</strong> Callable, Iterable, Any, Dict<br/><strong class="mi iu">def</strong> _merge(func: Callable[[Iterable], Any], *dics:List[Dict])-&gt;Dict:<br/>    # Get unique keys<br/>    keys = {k <strong class="mi iu">for</strong> d <strong class="mi iu">in</strong> dics <strong class="mi iu">for</strong> k <strong class="mi iu">in</strong> d.keys()}<br/>    return {k: func((d[k] <strong class="mi iu">for</strong> d <strong class="mi iu">in</strong> dics <strong class="mi iu">if</strong> k <strong class="mi iu">in</strong> d)) <strong class="mi iu">for</strong> k <strong class="mi iu">in</strong> keys}</span><span id="84f5" class="lf lg it mi b gy mq mn l mo mp">merged_p = _merge(lambda l: list(chain(*l)), d1, d2)</span></pre><p id="3cb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个函数<em class="le"> join_with </em>，它类似于 merge_with，但不是将每个字典作为单个参数传递，而是传递一个可迭代的字典。哦，我“偶然”潜入了另一个 funcy 函数<em class="le"> lcat，</em>它将不同的列表合并成一个。</p><h2 id="3acd" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">缓存属性</h2><p id="1b6b" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">最后但同样重要的是，完全不同但非常有用的东西；<em class="le"> cached_prope </em> rty 装饰器。顾名思义，它使您能够创建只执行一次的属性，而不是缓存该执行的结果并在所有后续调用中返回该结果。我在构建数据集类时经常使用它，因为它给了我非常干净和易读的接口，同时减少了加载时间。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6cb4" class="lf lg it mi b gy mm mn l mo mp"><strong class="mi iu">from</strong> funcy <strong class="mi iu">import</strong> cached_property<br/><strong class="mi iu">import</strong> pandas <strong class="mi iu">as</strong> pd</span><span id="2b02" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># Funcy Version</strong><br/><strong class="mi iu">class</strong> DatasetsF:<br/>    @cached_property<br/>    <strong class="mi iu">def</strong> movies(self) -&gt; pd.Dataframe:<br/>        <strong class="mi iu">return</strong> pd.read_csv(<strong class="mi iu">"the_biggest_movie_file.csv"</strong>)</span><span id="ee14" class="lf lg it mi b gy mq mn l mo mp"><strong class="mi iu"># PYTHON VERSION</strong><br/><strong class="mi iu">class</strong> DatasetsP:<br/>    <strong class="mi iu">def</strong> __init__(self):<br/>        self._movies = None</span><span id="d417" class="lf lg it mi b gy mq mn l mo mp">@property<br/>    <strong class="mi iu">def</strong> movies(self) -&gt; pd.Dataframe:<br/>        <strong class="mi iu">if</strong> self._movies <strong class="mi iu">is</strong> None:<br/>            self._movies = pd.read_csv(<strong class="mi iu">"the_biggest_movie_file.csv"</strong>)<br/>        <strong class="mi iu">return</strong> self._movies</span></pre><h1 id="38a3" class="mr lg it bd lh ms mt mu lk mv mw mx ln my mz na lq nb nc nd lt ne nf ng lw nh bi translated">结论</h1><p id="e986" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">在这篇文章中，我向您介绍了 funcy，向您展示了它提供的一个非常小但很方便的功能子集。要快速了解所有功能，请查看此备忘单。我希望这篇文章能激励你学习一些 funcy 动作。它比我在这里向你展示的要多得多。感谢您的关注，如果有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>