<html>
<head>
<title>Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-network-74f53424ba82?source=collection_archive---------9-----------------------#2019-08-02">https://towardsdatascience.com/neural-network-74f53424ba82?source=collection_archive---------9-----------------------#2019-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b57" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更简单直观的解释。</h2></div><p id="4c84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">神经网络是用于学习复杂的复杂学习算法，通常是非线性机器学习模型。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9a5f" class="ln lo it lj b gy lp lq l lr ls">A note on the notation. x_{i} means x subscript i and x_{^th} means x superscript th.</span></pre><h1 id="6bc7" class="lt lo it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">线性回归快速回顾</h1><ul class=""><li id="a25f" class="mk ml it kk b kl mm ko mn kr mo kv mp kz mq ld mr ms mt mu bi translated">线性回归用于预测+∞和-∞之间任何地方的实值输出。</li><li id="d62f" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">用于训练线性回归模型的每个示例由其属性或特征定义，这些属性或特征统称为特征向量。你的名字、年龄、联系电话、性别等等对应于描述你的特征向量。</li><li id="decd" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">一个线性回归模型<em class="na"> f(x) </em>、<em class="na">、</em>是输入实例<em class="na"> x </em>的特征的线性组合，用<em class="na"> f(x) = wx+b </em>表示。</li><li id="44ff" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">通过平方或立方来变换原始特征(考虑一维特征向量<em class="na"> x </em>)会产生多项式模型(例如<em class="na"> f(x) = wx +b </em>或<em class="na"> f(x) = wx +b </em>)。</li><li id="4b23" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">通常对于具有 R 维特征向量<em class="na"> x </em>和一维输出<em class="na"> y </em>的数据集，线性回归建模一个超平面作为决策边界。超平面在 2D 区域的情况下是一条线，在 3D 空间的情况下是一个平面，在 4D 空间的情况下是一个三维形状，例如一个球体，等等。超平面比它们周围的空间少了一个维度。</li><li id="90f0" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">均方误差成本函数用于找到线性回归模型的最佳值组<em class="na"> w* </em>和<em class="na"> b* </em>。</li></ul><h1 id="3233" class="lt lo it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">逻辑回归快速回顾</h1><ul class=""><li id="f411" class="mk ml it kk b kl mm ko mn kr mo kv mp kz mq ld mr ms mt mu bi translated">逻辑回归是一种分类算法。给定一个输入示例，逻辑回归模型将该示例分配给相关的类。</li><li id="0ee4" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">使用 sigmoid 函数在 0 和 1 之间处理从线性回归模型获得的实值输出，以获得逻辑回归模型。然后基于阈值对新的示例进行分类。</li><li id="fccf" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">一个逻辑回归模型表示为<em class="na">f(x)= 1/(1+exp(-(wx+b)))</em>，其中<em class="na"> exp </em>为指数函数。</li><li id="ed7d" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">对数似然函数成本函数用于查找逻辑回归模型的最佳值组<em class="na"> w* </em>和<em class="na"> b* </em>。</li><li id="bfbc" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">就像线性回归一样，我们可以将特征转换为包含二次或三次项的更高阶，以使非线性决策边界适合我们的数据集。</li></ul><h1 id="6ef5" class="lt lo it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">构建模块——神经元</h1><p id="7707" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">让我们来看看神经网络的构建模块。</p><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/cc5ede1d344d9533a2ef9424f0dba6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhyaH0Xbo4gP8PlnE-JZ7w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Elementary unit of a neural network: A neuron</figcaption></figure><p id="9858" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本单元中发生的操作可以用下面的等式来表示—</p><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nq"><img src="../Images/72891070d7a6d3e5eb48532617a49487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LdoxGVjnyrdDhuLq"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Output from a single neuron.</figcaption></figure><p id="a31b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看这个等式的各个组成部分，以及随之而来的<em class="na">神经元</em> —</p><ul class=""><li id="06ff" class="mk ml it kk b kl km ko kp kr nr kv ns kz nt ld mr ms mt mu bi translated"><em class="na"> x_{i}，i ∈ {1，2，…，n} </em>对应于馈入神经网络的输入特征向量，</li><li id="f62a" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated"><em class="na"> b </em>是偏置项，</li><li id="0eb6" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">对于每个输入特征<em class="na"> x_{i} </em>，都有一个对应的<strong class="kk iu">权重</strong> <em class="na"> w_{i}，</em>，这表示对应的输入<em class="na"> x_{i} </em>对输出的影响有多强。例如，考虑一个例子，在给定一个面的面积和立方体的颜色的情况下，计算立方体的总表面积。因为一个立方体有六个面，所以我们用一个面的面积乘以 6 来得到立方体的总表面积。然而，立方体的颜色对它的总表面积没有影响，所以我们把它乘以 0。这里 6 和 0 表示对应于输入特征的权重，一个面的面积<em class="na">和立方体的颜色<em class="na"/>。权重值越高，表示该要素对输出的影响越大。</em></li></ul><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nu"><img src="../Images/1858d70c873501c7483fe39887fa6537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yo0syJYE3QrN2fcD"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">The idea behind weights.</figcaption></figure><ul class=""><li id="a51e" class="mk ml it kk b kl km ko kp kr nr kv ns kz nt ld mr ms mt mu bi translated">请注意，神经元的输入是特征向量和附加偏差的线性组合。最后，该线性组合通过被称为激活函数的函数<em class="na"> f(x) </em>。</li></ul><h1 id="7e2c" class="lt lo it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">激活功能</h1><p id="ce25" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">在继续之前，让我们简单讨论一下激活函数。给定一个数据集，目标是找到适合我们数据集的最佳模型，或者我们可以说，在数据集的输入和输出之间逼近一个数学函数。事实证明，由于激活函数的存在，神经网络在逼近这些数学函数方面非常出色。就一会儿，想象一个没有任何激活函数的神经网络——它将只是一些线性回归模型。</p><p id="849a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像 sigmoid 这样的激活函数负责非线性转换，从而使神经网络能够学习复杂的假设。</p><p id="06bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的等式中，如果你用 sigmoid 函数替换函数<em class="na"> f </em>，你将得到一个逻辑单元。常用的激活函数有 Sigmoid、ReLU 和 Tanh。</p><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nv"><img src="../Images/1b05df02ffe5e6b32daa847214769b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_V6sG8fQydAz9Xx6YahYQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Activation functions : Left-to-Right: Rectified Linear Unit (ReLU), the Sigmoid function and the Tanh function.</figcaption></figure><h1 id="77d2" class="lt lo it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">神经网络</h1><h2 id="5020" class="ln lo it bd lu nw nx dn ly ny nz dp mc kr oa ob me kv oc od mg kz oe of mi og bi translated">体系结构</h2><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oh"><img src="../Images/cc44a35891f3e9d81f74aa8ffdca4c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBTiWzWqFQfuWQQwS8tGVw.png"/></div></div></figure><p id="77ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">神经网络基本上由三层组成——</p><ul class=""><li id="0239" class="mk ml it kk b kl km ko kp kr nr kv ns kz nt ld mr ms mt mu bi translated"><strong class="kk iu">输入层:</strong>它是一个被动层，也就是说它不执行任何计算，而是将其输入传播到后续层进行进一步处理。</li><li id="a568" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated">隐藏层:这是实际计算发生的层。每个圆圈代表一个神经元。每个神经元接收来自前一层的输入，进行所需的计算，并将结果传播到下一层。在单个隐藏层的情况下，隐藏层从<em class="na">输入层</em>接收输入，并将输出传播到<em class="na">输出层。</em>然而，在多个隐藏层的情况下，一个隐藏层可以从前一个隐藏层接收其输入，并且可以将其输出传递给下一个隐藏层。</li><li id="6e3b" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated"><strong class="kk iu">输出层:</strong>这是最后一层，给出我们想要的输出。在回归问题的输出层中有一个神经元，然而在分类问题的情况下存在多个神经元。</li><li id="83ac" class="mk ml it kk b kl mv ko mw kr mx kv my kz mz ld mr ms mt mu bi translated"><strong class="kk iu">箭头:</strong>箭头代表神经网络的参数，称为权重。学习算法的工作是找到一组好的参数，以便神经网络能够很好地泛化。</li></ul><h2 id="d297" class="ln lo it bd lu nw nx dn ly ny nz dp mc kr oa ob me kv oc od mg kz oe of mi og bi translated">培养</h2><p id="abe9" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">让我们为某个任意问题假设以下神经网络架构—</p><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oi"><img src="../Images/998e41b107f3f30743cd6581a091fd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kt0lVPYRVamwF_k23irFUQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Neural Network Architecture</figcaption></figure><p id="a01a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很明显，神经网络主要是由它的权重定义的。一旦找到最佳的权重集，网络就可以进行预测了。</p><p id="6fa6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">训练过程从随机初始化权重开始，通常在 0 和 1 之间。随机初始化设施<strong class="kk iu">对称破坏</strong>。考虑一个例子，其中<em class="na"> w_{1 </em> }、<em class="na"> w_{2 </em> }、<em class="na"> w_{3 </em> }和<em class="na"> w_{4 </em> }被初始化为相同的权重值。这将导致<em class="na"> h_{1} </em>和<em class="na"> h_{2} </em>产生相同的输出，从而通过引入冗余来降低隐藏层中存在的神经元的可用性。</p><p id="989d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">初始化权重后，接下来的步骤是将输入馈送到神经网络，并获得一些输出<em class="na">y’</em>。这个步骤被称为<strong class="kk iu">正向传播</strong>。</p><p id="d573" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，使用第一次向前传递获得的输出不是最准确的。诸如均方误差的误差函数可用于获取网络的成本。我们的目标是轻推神经网络的权重，以最小化这种误差。如果我们知道误差相对于权重如何变化，我们可以相应地更新权重以最小化误差。<em class="na"> </em>这就是<strong class="kk iu">反向传播</strong>方法派上用场的地方。它使用梯度下降，并决定网络的每个权重应该改变多少。</p><p id="9e0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为简化起见，考虑以下函数—</p><figure class="le lf lg lh gt nf gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6b844de17887136f4f5f81627fa3abeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*nLaDXFaTJoE-kB2nrXompA.png"/></div></figure><p id="cf4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述函数对<em class="na"> x </em>的偏导数为<em class="na"> 3 </em>，对<em class="na"> y </em>的偏导数为<em class="na"> 1 </em>。解释该结果的一种方式是，如果我们将<em class="na"> y </em>的值增加一个因子<em class="na"> k </em>，那么函数<em class="na"> f(x，y) </em>的值也会增加与∂ <em class="na"> f(x，y)/ </em> ∂ <em class="na"> y = 1 </em>相同的因子<em class="na"> k </em>，同样，如果我们将<em class="na"> x </em>的值减少一个因子<em class="na"> k`【也是如此因此，我们可以说一个函数对其变量的导数决定了该函数对该变量的敏感度。本质上，在神经网络的情况下，变量是网络的权重，并且<em class="na"> f(x，y) </em>对应于神经网络模型。</em></p><p id="ad52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导数的这一特性有助于我们确定为了使误差最小化并从网络中获得所需的输出，可能需要轻推一个权重的量。</p><p id="2a45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">反向传播因以下事实而得名:首先计算输出层的误差，然后通过隐藏层反向传播，在此过程中计算导数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="17f2" class="ln lo it lj b gy lp lq l lr ls">A detailed explanation of back-propagation is beyond the scope of this discussion as it can be overwhelming. However the following resource can be useful.</span></pre><div class="ok ol gp gr om on"><a href="https://google-developers.appspot.com/machine-learning/crash-course/backprop-scroll/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">反向传播演示</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">反向传播算法对于快速训练大型神经网络至关重要。这篇文章解释了如何…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">google-developers.appspot.com</p></div></div></div></a></div><h2 id="0f3d" class="ln lo it bd lu nw nx dn ly ny nz dp mc kr oa ob me kv oc od mg kz oe of mi og bi translated">对于分类问题</h2><p id="73b3" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">神经网络也可以用于分类问题。考虑将电子邮件标记为垃圾邮件或非垃圾邮件的二元分类的经典示例。为了使用神经网络来解决这个问题，输出类别被转换成二维向量，其中，如果电子邮件是垃圾邮件，则设置第一维度，如果电子邮件不是垃圾邮件，则设置第二维度。最后，输出的这种变换形式与输入特征向量一起用于训练神经网络。在<em class="na"> n-class </em>分类的情况下，每个输出被转换成一个<em class="na"> n </em>维向量，其中如果实例属于相应的类，则设置一个维。</p><figure class="le lf lg lh gt nf gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/51b01484f231505bcd4473eea628f7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:106/format:webp/1*NcOFzmsRQ-A3ukMKomoSaQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Transformed output variable in case of a spam email.</figcaption></figure><figure class="le lf lg lh gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ox"><img src="../Images/037d8410454541e371e60c2b6394dcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsFkM-8nvt7G_9_owODy4Q.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Architecture of neural network as a classifier.</figcaption></figure><p id="37c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出单元<em class="na"> y_{1} </em>预测电子邮件是垃圾邮件的可能性，而<em class="na"> y_{2} </em>预测电子邮件不是垃圾邮件的可能性。根据取较高值的输出单位对电子邮件进行分类。</p><h1 id="1911" class="lt lo it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">为什么是新算法？</h1><p id="cfb0" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">你一定已经学会了线性回归和逻辑回归，那么我们为什么需要训练一个神经网络呢？事实证明，神经网络非常擅长逼近非线性函数。</p><p id="4ec8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们对线性回归和逻辑回归的回顾中，我们讨论了包含更高次项来近似非线性假设，但是这样做并不能保证更好的假设。此外，假设将取决于我们对高次项的选择。考虑这样一种情况，我们有 10 个参数(比如 a，b，c，…，j)，我们决定包括所有平方项，这样做将创建 55 个参数(10+9+8+…+1)。此外，过度拟合的可能性也更高。</p><p id="6728" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">神经网络解决了这个问题。观察神经网络的隐含层，隐含层的输入不是简单的原始输入<em class="na"> x_{1} </em>和<em class="na"> x_{2} </em>，而是权重，将隐含层的输入转换为原始输入的某个函数。好像神经网络试图找到输入的最佳可能转换，从而解决我们选择更高次项的问题。包括更多的隐藏层允许网络学习甚至更复杂的特征。然而，对于大多数实际用途，两个隐藏层工作得相当好。</p></div></div>    
</body>
</html>