<html>
<head>
<title>Reverse Geocoding in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 R 中反向地理编码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reverse-geocoding-in-r-f7fe4b908355?source=collection_archive---------16-----------------------#2019-01-06">https://towardsdatascience.com/reverse-geocoding-in-r-f7fe4b908355?source=collection_archive---------16-----------------------#2019-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d69" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有谷歌或必应 API 的免费</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f07d104d13c0e7d96cebe02222ace733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*afusl08qRAqfq2MW"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lonely_planet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lonely Planet</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c2ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我继续写论文，我在执行 R 和 Python 中各种包的简单脚本时遇到了一些小故障。这个周末给自己的任务是反地理编码~ 100 万经纬度坐标。我在 R 中发现了一个名为 revgeo 的很棒的包，并认为这很容易实现。我只需要指定提供者和 API 键。谷歌和必应限制每天免费查询的数量，所以这不是一个可行的选择，但光子没有！唯一需要注意的是，像地址名称这样的详细位置并不总是可用的。以下是如何使用 revgeo 软件包的示例:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2bf3" class="lx ly iq lt b gy lz ma l mb mc">library(revgeo)</span><span id="79c6" class="lx ly iq lt b gy md ma l mb mc">revgeo(longitude=-77.0229529, latitude=38.89283435, provider = 'photon', output=’frame’)</span></pre><p id="8244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么问题出在哪里呢？嗯，正如光子网页上所说:</p><blockquote class="me mf mg"><p id="0608" class="kw kx mh ky b kz la jr lb lc ld ju le mi lg lh li mj lk ll lm mk lo lp lq lr ij bi translated">您可以在您的项目中使用 API，但是请注意公平——大量使用将会受到限制。我们不保证可用性和使用可能会在未来发生变化。</p></blockquote><p id="6fd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不确定在 Photon API 变慢之前需要多少次查询，但重要的是要注意我们向他们的服务器发送了多少请求。我决定从 500，000 坐标开始逆向地理编码，但这并不奏效。我运行了代码，离开了一段时间，当我回来时，我看到节流已经开始，所以我需要调整代码。此外，R 抛出了一个错误<code class="fe ml mm mn lt b">cannot allocate vector of size x.x Gb</code>，这意味着我的可用内存已经耗尽。</p><p id="889d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我有两个问题:1)节流和 2)内存分配。对于第 1 期，我需要在代码中加入睡眠时间，并处理已经子集化的数据帧的较小子集。对于第 2 期，我在 stackoverflow 上找到了一个有用的建议:</p><div class="mo mp gp gr mq mr"><a href="https://stackoverflow.com/questions/10917532/memory-allocation-error-cannot-allocate-vector-of-size-75-1-mb" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">内存分配“错误:无法分配大小为 75.1 Mb 的向量”</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">在对一些模拟代码进行矢量化的过程中，我遇到了内存问题。我使用的是 32 位 R 版本 2.15.0(通过…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">stackoverflow.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kp mr"/></div></div></a></div><p id="9ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">帮助我的一个解决方案是运行<code class="fe ml mm mn lt b">memory.limit(size = _ _ _ _ _ _)</code>。此外，我使用<code class="fe ml mm mn lt b">rm()</code>命令删除代码中不再需要的数据帧，并使用<code class="fe ml mm mn lt b">gc()</code>命令进行垃圾收集。如下所示，我加载了名为<code class="fe ml mm mn lt b">main</code>的大约一百万坐标的数据帧。我将数据细分为只有 100，000 行。正如您稍后将看到的，我在 while 循环中进一步对数据进行了子集化，以避免内存分配问题。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c1be" class="lx ly iq lt b gy lz ma l mb mc">library(revgeo)</span><span id="bcb5" class="lx ly iq lt b gy md ma l mb mc"># the dataframe called 'main' is where the 1 million coordinate points reside.</span><span id="0b9a" class="lx ly iq lt b gy md ma l mb mc">main &lt;- readRDS("main.rds"))</span><span id="4789" class="lx ly iq lt b gy md ma l mb mc">main_sub &lt;- main[0:100000,] # Working with a smaller initial subset</span><span id="e747" class="lx ly iq lt b gy md ma l mb mc">rm(main)<br/>gc()</span></pre><p id="9229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是完整的代码。该脚本包含了与本文主题无关的其他操作，但我想在这里发布它，以便您可以看到全貌，并希望在反向地理编码中获得一些有用的提示。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="4899" class="lx ly iq lt b gy lz ma l mb mc"># Step 1: Create a blank dataframe to store results.<br/>data_all = data.frame()</span><span id="8da3" class="lx ly iq lt b gy md ma l mb mc">start &lt;- Sys.time()</span><span id="518c" class="lx ly iq lt b gy md ma l mb mc"># Step 2: Create a while loop to have the function running until the # dataframe with 100,000 rows is empty.<br/>while (nrow(main_sub)&gt;0) {</span><span id="9948" class="lx ly iq lt b gy md ma l mb mc"># Step 3: Subset the data even further so that you are sending only # a small portion of requests to the Photon server.</span><span id="a580" class="lx ly iq lt b gy md ma l mb mc">  main_sub_t &lt;-  main_sub[1:200,]</span><span id="d407" class="lx ly iq lt b gy md ma l mb mc"># Step 4: Extracting the lat/longs from the subsetted data from<br/># the previous step (Step 3).</span><span id="dbea" class="lx ly iq lt b gy md ma l mb mc">  latlong &lt;- main_sub_t %&gt;% <br/>    select(latitude, longitude) %&gt;% <br/>    unique() %&gt;% <br/>    mutate(index=row_number())</span><span id="7ec8" class="lx ly iq lt b gy md ma l mb mc"> <br/> <br/># Step 5: Incorporate the revgeo package here. I left_joined the <br/># output with the latlong dataframe from the previous step to add <br/># the latitude/longitude information with the reverse geocoded data.</span><span id="62f9" class="lx ly iq lt b gy md ma l mb mc">cities &lt;- revgeo(latlong$longitude, latlong$latitude, provider =  'photon', output = 'frame')) %&gt;% <br/>    mutate(index = row_number(),country = as.character(country)) %&gt;%<br/>    filter(country == 'United States of America') %&gt;% <br/>    mutate(location = paste(city, state, sep = ", ")) %&gt;% <br/>    select(index, location) %&gt;% <br/>    left_join(latlong, by="index") %&gt;% <br/>    select(-index)</span><span id="f702" class="lx ly iq lt b gy md ma l mb mc">  <br/># Removing the latlong dataframe because I no longer need it. This <br/># helps with reducing memory in my global environment.<br/>rm(latlong)</span><span id="99dd" class="lx ly iq lt b gy md ma l mb mc"><br/>  <br/># Step 6: Adding the information from the cities dataframe to <br/># main_sub_t dataframe (from Step 3).<br/>  <br/>  data_new &lt;- main_sub_t %&gt;% <br/>    left_join(cities, by=c("latitude","longitude")) %&gt;% <br/>    select(X, text, location, latitude, longitude)<br/>  </span><span id="7e6c" class="lx ly iq lt b gy md ma l mb mc"><br/># Step 7: Adding data_new into the empty data_all dataframe where <br/># all subsetted reverse geocoded data will be combined.<br/>  <br/>  data_all &lt;- rbind(data_all,data_new) %&gt;% <br/>    na.omit()<br/>  </span><span id="cf31" class="lx ly iq lt b gy md ma l mb mc"><br/># Step 8: Remove the rows that were used in the first loop from the # main_sub frame so the next 200 rows can be read into the while # loop.<br/>  <br/>  main_sub &lt;- anti_join(main_sub, main_sub_t, by=c("X"))<br/>  print(nrow(main_sub))<br/>  <br/># Remove dataframes that are not needed before the while loop closes # to free up space.<br/>  rm(data_sub_t)<br/>  rm(data_new)<br/>  rm(latlong_1)<br/>  rm(cities)<br/>  <br/>  print('Sleeping for 10 seconds')<br/>  Sys.sleep(10)<br/>  <br/>}<br/>end &lt;- Sys.time()</span></pre><p id="00b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现这个代码后，大概花了 4 个小时反推地理编码 10 万坐标。在我看来，如果我有一百万个坐标要转换，这不是一个可行的选择。我可能不得不寻找另一种方法来实现我的目标，但我认为这对那些数据集较小的人会有所帮助。</p><p id="f1aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读和快乐编码！</p></div></div>    
</body>
</html>