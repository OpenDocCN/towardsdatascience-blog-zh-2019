<html>
<head>
<title>Recency, Frequency, Monetary Model with Python — and how Sephora uses it to optimize their Google and Facebook Ads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 的新近性、频率、货币模型——以及丝芙兰如何使用它来优化他们的谷歌和脸书广告</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recency-frequency-monetary-model-with-python-and-how-sephora-uses-it-to-optimize-their-google-d6a0707c5f17?source=collection_archive---------1-----------------------#2019-08-17">https://towardsdatascience.com/recency-frequency-monetary-model-with-python-and-how-sephora-uses-it-to-optimize-their-google-d6a0707c5f17?source=collection_archive---------1-----------------------#2019-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1660" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上次我们使用群组分析方法分析了我们的在线购物者数据集。我们围绕我们的队列数据集发现了一些有趣的观察结果。虽然群组分析为我们提供了长期的客户行为并了解了保留率，但我们还希望能够根据他们的行为对我们的数据进行细分。今天，我们将探索零售商使用的流行的 RFM 模式，如<a class="ae ko" href="https://data.luxola.com/post/2017-09-13-spider-updated-audiences/" rel="noopener ugc nofollow" target="_blank">丝芙兰</a>，将店内和网上购买相结合，以细分客户，获得更好的个性化广告内容。我强烈推荐关注丝芙兰博客的<a class="ae ko" href="https://data.luxola.com/post/2017-09-13-spider-updated-audiences/" rel="noopener ugc nofollow" target="_blank">数据科学，以获得更深入的数据见解。你也可以看看这篇由 Jimmy Joe 撰写的</a><a class="ae ko" href="https://iterable.com/blog/the-secret-to-customer-lifetime-value-rfm/" rel="noopener ugc nofollow" target="_blank">文章</a>，他在文章中深入探讨了利用 RFM 实现客户终身价值的<a class="ae ko" href="https://iterable.com/blog/the-secret-to-customer-lifetime-value-rfm/" rel="noopener ugc nofollow" target="_blank">秘密</a>。</p><h1 id="3aa9" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是 RFM？</h1><p id="102a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">通过 3 个重要特征进行行为细分:</p><ol class=""><li id="528b" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">最近——自上次购买以来的天数</li><li id="39c0" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">频率——特定时期内的交易数量</li><li id="1519" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">货币——在给定时间内花费的金额</li></ol><p id="3ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们必须按以下方式对这些功能进行分组:</p><ol class=""><li id="7a47" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">百分位数或分位数</li><li id="0a4b" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">帕累托法则——80/20</li><li id="b615" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">商业头脑</li></ol><p id="780f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将对我们的方法实施百分位数分组。</p><p id="25d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们继续学习 Python。</p><p id="557f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是我们今天分析所需要的库。稍后，我们将使用 squarify 将我们的分割绘制成树形图。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4004" class="mp kq it ml b gy mq mr l ms mt"># Import libraries<br/>import pandas as pd<br/>from datetime import timedelta<br/>import matplotlib.pyplot as plt<br/>import squarify</span></pre><p id="9530" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将再次分析我们的<a class="ae ko" href="https://www.kaggle.com/fabiendaniel/customer-segmentation/data" rel="noopener ugc nofollow" target="_blank">在线购物者数据集</a>，但这次是用我们的 RFM 模型。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b765" class="mp kq it ml b gy mq mr l ms mt"># Read dataset<br/>online = pd.read_csv('../data.csv', encoding = "ISO-8859-1")</span><span id="6063" class="mp kq it ml b gy mu mr l ms mt"># Convert InvoiceDate from object to datetime format<br/>online['InvoiceDate'] = pd.to_datetime(online['InvoiceDate'])</span></pre><p id="9bd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看我们需要处理的数据。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9a99" class="mp kq it ml b gy mq mr l ms mt"><strong class="ml iu">Input:</strong><br/>print('{:,} rows; {:,} columns'<br/>      .format(online.shape[0], online.shape[1]))</span><span id="78ba" class="mp kq it ml b gy mu mr l ms mt">print('{:,} transactions don\'t have a customer id'<br/>      .format(online[online.CustomerID.isnull()].shape[0]))</span><span id="b3e3" class="mp kq it ml b gy mu mr l ms mt">print('Transactions timeframe from {} to {}'.format(online['InvoiceDate'].min(),<br/>                                    online['InvoiceDate'].max()))</span><span id="af11" class="mp kq it ml b gy mu mr l ms mt"><strong class="ml iu">Output:</strong><br/>541,909 rows; 8 columns<br/>135,080 transactions don't have a customer id<br/>Transactions timeframe from 2010-12-01 08:26:00 to 2011-12-09 12:50:00</span><span id="ef61" class="mp kq it ml b gy mu mr l ms mt"><strong class="ml iu">Input:</strong><br/># Drop NA values from online<br/>online.dropna()</span></pre><p id="513a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要做的第一件事是根据最近、频率和货币价值对客户进行分类。为了计算最近，我们将把数据集的最后一个发票日期之后的一天作为快照日期'<strong class="js iu">2011–12–10 12:50:00 '</strong>。日期差异将告诉我们最近一次交易是什么时候完成的。这样，我们就可以根据客户 ID 对<strong class="js iu">‘在线’</strong>数据框进行分组，并将其分配给<strong class="js iu">‘数据处理’</strong>进行数据预处理。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bda1" class="mp kq it ml b gy mq mr l ms mt"># --Group data by customerID--</span><span id="9fb4" class="mp kq it ml b gy mu mr l ms mt"># Create TotalSum column for online dataset<br/>online['TotalSum'] = online['Quantity'] * online['UnitPrice']</span><span id="2846" class="mp kq it ml b gy mu mr l ms mt"># Create snapshot date<br/>snapshot_date = online['InvoiceDate'].max() + timedelta(days=1)<br/>print(snapshot_date)</span><span id="a4c8" class="mp kq it ml b gy mu mr l ms mt"># Grouping by CustomerID<br/>data_process = online.groupby(['CustomerID']).agg({<br/>        'InvoiceDate': lambda x: (snapshot_date - x.max()).days,<br/>        'InvoiceNo': 'count',<br/>        'TotalSum': 'sum'})</span><span id="8075" class="mp kq it ml b gy mu mr l ms mt"># Rename the columns <br/>data_process.rename(columns={'InvoiceDate': 'Recency',<br/>                         'InvoiceNo': 'Frequency',<br/>                         'TotalSum': 'MonetaryValue'}, inplace=True)</span></pre><p id="431d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看目前为止的进展。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7720" class="mp kq it ml b gy mq mr l ms mt"># Print top 5 rows and shape of dataframe<br/>print(data_process.head())<br/>print('{:,} rows; {:,} columns'<br/>      .format(data_process.shape[0], data_process.shape[1]))</span><span id="c67c" class="mp kq it ml b gy mu mr l ms mt"><strong class="ml iu">Output:</strong><br/>            Recency  Frequency  MonetaryValue<br/>CustomerID                                   <br/>12346.0         326          2           0.00<br/>12347.0           2        182        4310.00<br/>12348.0          75         31        1797.24<br/>12349.0          19         73        1757.55<br/>12350.0         310         17         334.40<br/>4,372 rows; 3 columns</span></pre><p id="75c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了，我们有 4，372 条客户记录，根据他们购买的最近时间、频率、数量和购买的货币价值进行分组。现在我们可以进入事物的内部，使用。qcut()方法将相对百分位数分配给他们的 RFM 特征。但在此之前，让我们检查一下我们的近因、频率和货币的分布。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="933c" class="mp kq it ml b gy mq mr l ms mt"><strong class="ml iu"># Plot RFM distributions</strong><br/>plt.figure(figsize=(12,10))</span><span id="aa18" class="mp kq it ml b gy mu mr l ms mt"># Plot distribution of R<br/>plt.subplot(3, 1, 1); sns.distplot(data_process['Recency'])</span><span id="5c63" class="mp kq it ml b gy mu mr l ms mt"># Plot distribution of F<br/>plt.subplot(3, 1, 2); sns.distplot(data_process['Frequency'])</span><span id="0688" class="mp kq it ml b gy mu mr l ms mt"># Plot distribution of M<br/>plt.subplot(3, 1, 3); sns.distplot(data_process['MonetaryValue'])</span><span id="d9b5" class="mp kq it ml b gy mu mr l ms mt"># Show the plot<br/>plt.show()</span></pre><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/0125311ec80d4c231e6f2ee673e9383d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXsKstpxUCUKjSDr4HQdrQ.png"/></div></div></figure><p id="15e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这张图为我们提供了一些非常有趣的见解，以及我们的数据是如何扭曲的。这里需要注意的重要一点是，我们将用分位数对这些值进行分组。然而，当我们在接下来使用 K-Means 检查我们的客户细分时，确保我们将数据调整到均值和标准差的中心是非常重要的。下次会有更多。让我们继续。qcut()为我们的 RFM。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0d6c" class="mp kq it ml b gy mq mr l ms mt"># --Calculate R and F groups--</span><span id="11e3" class="mp kq it ml b gy mu mr l ms mt"># Create labels for Recency and Frequency<br/>r_labels = range(4, 0, -1); f_labels = range(1, 5)</span><span id="7d52" class="mp kq it ml b gy mu mr l ms mt"># Assign these labels to 4 equal percentile groups <br/>r_groups = pd.qcut(data_process['Recency'], q=4, labels=r_labels)</span><span id="62a5" class="mp kq it ml b gy mu mr l ms mt"># Assign these labels to 4 equal percentile groups <br/>f_groups = pd.qcut(data_process['Frequency'], q=4, labels=f_labels)</span><span id="e81d" class="mp kq it ml b gy mu mr l ms mt"># Create new columns R and F <br/>data_process = data_process.assign(R = r_groups.values, F = f_groups.values)<br/>data_process.head()</span></pre><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9340a506772623a046e4b86d10b44452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*SaAtFNi6LtsfBSI-iOGSKQ.png"/></div></figure><p id="e677" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为 f_labels 创建了一个 4 标签，其中 4 是“最佳”分位数。我们为我们的 f_label 做同样的事情。然后，我们创建新的列“R”和“F ”,并分别为它们分配 r_group 和 f_group 值。</p><p id="f513" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们对货币值进行同样的操作，使用。qcut()方法。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6ea2" class="mp kq it ml b gy mq mr l ms mt"># Create labels for MonetaryValue<br/>m_labels = range(1, 5)</span><span id="57a4" class="mp kq it ml b gy mu mr l ms mt"># Assign these labels to three equal percentile groups <br/>m_groups = pd.qcut(data_process['MonetaryValue'], q=4, labels=m_labels)</span><span id="47e8" class="mp kq it ml b gy mu mr l ms mt"># Create new column M<br/>data_process = data_process.assign(M = m_groups.values)</span></pre><p id="629d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，有了这 3 个分数，R，F 和 M，我们可以通过将下面的值连接在一起来创建我们的第一个 RFM 线段。让我们将 data_process 数据帧分配给新创建的 rfm 数据帧。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3d0f" class="mp kq it ml b gy mq mr l ms mt"># Concat RFM quartile values to create RFM Segments<br/>def join_rfm(x): return str(x['R']) + str(x['F']) + str(x['M'])<br/>data_process['RFM_Segment_Concat'] = data_process.apply(join_rfm, axis=1)</span><span id="c450" class="mp kq it ml b gy mu mr l ms mt">rfm = data_process<br/>rfm.head()</span></pre><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ne"><img src="../Images/497495a89ad65ab02d8f50d1099ec33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmQsf7owx7SjUKFRSwNOpQ.png"/></div></div></figure><p id="2436" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从输出中，您可以看到我们已经准备好将连接的数据段用于分段，但是，等等，还有一个问题…</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="28ed" class="mp kq it ml b gy mq mr l ms mt"># Count num of unique segments<br/>rfm_count_unique = rfm.groupby('RFM_Segment_Concat')['RFM_Segment_Concat'].nunique()<br/>print(rfm_count_unique.sum())</span><span id="9f79" class="mp kq it ml b gy mu mr l ms mt"><strong class="ml iu">Output:<br/></strong>62</span></pre><p id="15a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用 concatenate 方法拥有 62 个不同的段对于任何实际应用来说都很快变得不实用。我们需要一种更简洁的方式来定义我们的细分市场。</p><h1 id="5a72" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">合计分数</h1><p id="e0e7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">最直接的方法之一是将我们的分数相加为一个数字，并为每个分数范围定义 RFM 等级。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7059" class="mp kq it ml b gy mq mr l ms mt"><strong class="ml iu"># Calculate RFM_Score<br/></strong>rfm['RFM_Score'] = rfm[['R','F','M']].sum(axis=1)<br/>print(rfm['RFM_Score'].head())</span><span id="cb59" class="mp kq it ml b gy mu mr l ms mt"><strong class="ml iu">Output:</strong></span><span id="74c9" class="mp kq it ml b gy mu mr l ms mt">CustomerID<br/>12346.0     3.0<br/>12347.0    12.0<br/>12348.0     8.0<br/>12349.0    10.0<br/>12350.0     4.0<br/>Name: RFM_Score, dtype: float64</span></pre><p id="5fa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以发挥创意，假设每个分数范围意味着什么，但在这个练习中，我将从一些常见的部分名称中获得灵感。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1473" class="mp kq it ml b gy mq mr l ms mt"># Define rfm_level function<br/>def rfm_level(df):<br/>    if df['RFM_Score'] &gt;= 9:<br/>        return 'Can\'t Loose Them'<br/>    elif ((df['RFM_Score'] &gt;= 8) and (df['RFM_Score'] &lt; 9)):<br/>        return 'Champions'<br/>    elif ((df['RFM_Score'] &gt;= 7) and (df['RFM_Score'] &lt; 8)):<br/>        return 'Loyal'<br/>    elif ((df['RFM_Score'] &gt;= 6) and (df['RFM_Score'] &lt; 7)):<br/>        return 'Potential'<br/>    elif ((df['RFM_Score'] &gt;= 5) and (df['RFM_Score'] &lt; 6)):<br/>        return 'Promising'<br/>    elif ((df['RFM_Score'] &gt;= 4) and (df['RFM_Score'] &lt; 5)):<br/>        return 'Needs Attention'<br/>    else:<br/>        return 'Require Activation'</span><span id="7278" class="mp kq it ml b gy mu mr l ms mt"># Create a new variable RFM_Level<br/>rfm['RFM_Level'] = rfm.apply(rfm_level, axis=1)</span><span id="2f7c" class="mp kq it ml b gy mu mr l ms mt"># Print the header with top 5 rows to the console<br/>rfm.head()</span></pre><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nf"><img src="../Images/318d646181aceab91104670520baba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZusHn42LM4viJ8b_QgaCw.png"/></div></div></figure><p id="c6b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们可以根据客户的 RFM 级别对他们进行分组。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f6ce" class="mp kq it ml b gy mq mr l ms mt"># Calculate average values for each RFM_Level, and return a size of each segment <br/>rfm_level_agg = rfm.groupby('RFM_Level').agg({<br/>    'Recency': 'mean',<br/>    'Frequency': 'mean',<br/>    'MonetaryValue': ['mean', 'count']<br/>}).round(1)</span><span id="33fb" class="mp kq it ml b gy mu mr l ms mt"># Print the aggregated dataset<br/>print(rfm_level_agg)</span></pre><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/84363671077449745e04d5b7e8ee83de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*E18o88uWKfJZ4N2q_l8LnA.png"/></div></figure><p id="cf44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这里，我们可以看到很大比例(~60%)的客户处于顶级 RFM 级别。商店必须做一些正确的事情来维持他们的忠诚度！</p><p id="323b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其余的 40%将需要一些工作。让我们探索使用一些广告来重新定位他们:</p><ol class=""><li id="f638" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">潜在客户——很有可能进入我们的忠诚客户群，为什么不在他们下次购买时赠送一些赠品，以显示您对他们的重视！</li><li id="ce14" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">有希望——对他们购买的数量和价值表现出有希望的迹象，但距离他们上次从你这里购买已经有一段时间了。让我们针对他们的愿望清单项目和限时优惠折扣。</li><li id="14e1" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">需要关注—初次购买了一些商品，但之后就再也没有见过。是糟糕的客户体验吗？还是产品市场契合度？让我们花一些资源与他们一起建立我们的品牌意识。</li><li id="4e44" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">需要激活——我们的 RFM 模式中表现最差的。他们现在可能已经选择了我们的竞争对手，需要不同的激活策略来赢回他们。</li></ol><p id="dfbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在我们结束之前，让我们为我们的数据创建一个漂亮的可视化。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4efe" class="mp kq it ml b gy mq mr l ms mt">rfm_level_agg.columns = rfm_level_agg.columns.droplevel()<br/>rfm_level_agg.columns = ['RecencyMean','FrequencyMean','MonetaryMean', 'Count']</span><span id="5606" class="mp kq it ml b gy mu mr l ms mt">#Create our plot and resize it.<br/>fig = plt.gcf()<br/>ax = fig.add_subplot()<br/>fig.set_size_inches(16, 9)</span><span id="5c8c" class="mp kq it ml b gy mu mr l ms mt">squarify.plot(sizes=rfm_level_agg['Count'], <br/>              label=['Can\'t Loose Them',<br/>                     'Champions',<br/>                     'Loyal',<br/>                     'Needs Attention',<br/>                     'Potential', <br/>                     'Promising', <br/>                     'Require Activation'], alpha=.6 )</span><span id="d7e2" class="mp kq it ml b gy mu mr l ms mt">plt.title("RFM Segments",fontsize=18,fontweight="bold")<br/>plt.axis('off')<br/>plt.show()</span></pre><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/71dffca474e1be77e24b31a4a3be3aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sg4vSpjx0ooR0i4YXEuQLQ.png"/></div></div></figure></div></div>    
</body>
</html>