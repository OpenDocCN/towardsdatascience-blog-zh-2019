<html>
<head>
<title>Build a user-based collaborative filtering recommendation engine for Anime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建基于用户的动漫协同过滤推荐引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-user-based-collaborative-filtering-recommendation-engine-for-anime-92d35921f304?source=collection_archive---------9-----------------------#2019-10-22">https://towardsdatascience.com/build-a-user-based-collaborative-filtering-recommendation-engine-for-anime-92d35921f304?source=collection_archive---------9-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b157" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于用户之间的统计相似性进行推荐</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f43ca3ef0f07aaeaa56bcf453236b5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNx09uv2uc2rl4_xaFCY4Q.jpeg"/></div></div></figure><p id="0328" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我们将为动画建立一个推荐引擎，由基于用户的协同过滤提供动力。这只是推荐系统的几种不同方法中的一种</p><h1 id="7248" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">介绍</h1><p id="e489" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在基于用户的协同过滤中:<br/> -如果用户喜欢相似的项目就被认为是相似的<br/> -我们首先发现哪些用户是相似的<br/> -然后推荐其他相似用户喜欢的项目</p><p id="abff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">看看我在上面(煞费苦心)画的图。</strong></p><p id="bf23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">桑尼喜欢莫奈、毕加索和达利的画。泰德喜欢莫奈和毕加索的画。</p><p id="6dda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">桑尼和泰德很相似，因为他们喜欢一些相同的艺术家。桑妮喜欢达利画，但泰德从未看过达利画。<br/>所以让我们向 Ted 推荐 Dali。</p><p id="8bf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">清澈如泥？现在我们已经了解了它是如何工作的，让我们来构建一个推荐器。</p><h1 id="8597" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">构建推荐器</h1><p id="2c72" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">从<a class="ae mn" href="https://www.kaggle.com/CooperUnion/anime-recommendations-database/download" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载数据并加载到 2 个数据帧中。</p><p id="0a99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">anime . CSV—我们数据库中关于动漫的详细信息<br/>rating . CSV—特定用户对特定动漫的评分</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="d74e" class="mt lr it mp b gy mu mv l mw mx">DIR = 'anime-recommendations-database/'</span><span id="4495" class="mt lr it mp b gy my mv l mw mx">import pandas as pd</span><span id="baa1" class="mt lr it mp b gy my mv l mw mx">animes = pd.read_csv(DIR + 'anime.csv')<br/>ratings = pd.read_csv(DIR + 'rating.csv')</span></pre><p id="589d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过阅读这些文档，我知道评分值为<code class="fe mz na nb mp b">-1</code>意味着用户已经观看了这部电影，但还没有对它进行评分。我假设这不会给我们任何有用的信息并删除那些记录。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="5ea6" class="mt lr it mp b gy mu mv l mw mx">ratings = ratings[ratings.rating != -1]<br/>ratings.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/204eec26259139b9c64eee99ad9f7174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWhAxlM7EULLm7Z-m2Nkpg.png"/></div></div></figure><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="26e9" class="mt lr it mp b gy mu mv l mw mx">animes.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/804c0c15b7e2b80b83b0613322e8af19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OtB57bSWN73gmRX3cAb2hA.png"/></div></div></figure><h1 id="c075" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">数据探索</h1><p id="abba" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">没有人比我更不喜欢花 75%的时间在数据探索上，所以让我们先了解一下数据的大小和分布。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="c00d" class="mt lr it mp b gy mu mv l mw mx"># number of ratings<br/>len(ratings)<br/>=&gt; 6337241</span><span id="1b21" class="mt lr it mp b gy my mv l mw mx"># number of users<br/>len(ratings['user_id'].unique())<br/>=&gt; 69600</span><span id="df4d" class="mt lr it mp b gy my mv l mw mx"># number of unique animes (in anime list, not ratings)<br/>len(animes['anime_id'].unique())<br/>#=&gt; 11200</span><span id="17ba" class="mt lr it mp b gy my mv l mw mx"># avg number of anime rated per user<br/>import statistics<br/>ratings_per_user = ratings.groupby('user_id')['rating'].count()<br/>statistics.mean(ratings_per_user.tolist())<br/>#=&gt; 91.05231321839081</span><span id="cc9b" class="mt lr it mp b gy my mv l mw mx"># distribution of ratings per user<br/># (we may want to exclude users without many data points)<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>ratings_per_user.hist(bins=20, range=(0,500))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c5c18e066a15ffc48233078e355d34ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY4OrCdP809FykG8zsIuBw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">most users have rated fewer than 100 anime</figcaption></figure><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="5e27" class="mt lr it mp b gy mu mv l mw mx"># avg number of ratings given per anime<br/>ratings_per_anime = ratings.groupby('anime_id')['rating'].count()<br/>statistics.mean(ratings_per_anime.tolist())<br/>=&gt; 638.3843054296364</span><span id="4f01" class="mt lr it mp b gy my mv l mw mx"># distribution of ratings per anime<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>ratings_per_anime.hist(bins=20, range=(0,2500))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/2f67834b207054f71d35a6648ab02d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCrz0R5kQ0_w9XUlqjnAPA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">most anime received less than 500 ratings</figcaption></figure><h1 id="316c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">回到推荐者</h1><p id="d67c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在基于用户的协同过滤中，代表用户的向量实际上是他们给出的评级列表。所以我们宇宙中的动漫越多，每个用户的维度就越多。</p><p id="f749" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过删除没有被很多用户评价的动画来减少数据量。根据 id 做一个动漫保留清单。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="4729" class="mt lr it mp b gy mu mv l mw mx"># counts of ratings per anime as a df<br/>ratings_per_anime_df = pd.DataFrame(ratings_per_anime)</span><span id="6835" class="mt lr it mp b gy my mv l mw mx"># remove if &lt; 1000 ratings<br/>filtered_ratings_per_anime_df = ratings_per_anime_df[ratings_per_anime_df.rating &gt;= 1000]</span><span id="ca22" class="mt lr it mp b gy my mv l mw mx"># build a list of anime_ids to keep<br/>popular_anime = filtered_ratings_per_anime_df.index.tolist()</span></pre><p id="39b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以及没怎么评价过动漫的用户。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2180" class="mt lr it mp b gy mu mv l mw mx"># counts ratings per user as a df<br/>ratings_per_user_df = pd.DataFrame(ratings_per_user)</span><span id="2fc9" class="mt lr it mp b gy my mv l mw mx"># remove if &lt; 500<br/>filtered_ratings_per_user_df = ratings_per_user_df[ratings_per_user_df.rating &gt;= 500]</span><span id="57c1" class="mt lr it mp b gy my mv l mw mx"># build a list of user_ids to keep<br/>prolific_users = filtered_ratings_per_user_df.index.tolist()</span></pre><p id="0e01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在过滤掉那些列表之外的动漫和用户。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="7828" class="mt lr it mp b gy mu mv l mw mx">filtered_ratings = ratings[ratings.anime_id.isin(popular_anime)]<br/>filtered_ratings = ratings[ratings.user_id.isin(prolific_users)]<br/>len(filtered_ratings)<br/>=&gt; 1005314</span></pre><p id="59dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的评级数据点从 600 万降至 100 万。很好。</p><p id="4b20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来建立一个用户和动漫之间的评分矩阵。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="1bc7" class="mt lr it mp b gy mu mv l mw mx">rating_matrix = filtered_ratings.pivot_table(index='user_id', columns='anime_id', values='rating')</span><span id="7a00" class="mt lr it mp b gy my mv l mw mx"># replace NaN values with 0<br/>rating_matrix = rating_matrix.fillna(0)</span><span id="66fc" class="mt lr it mp b gy my mv l mw mx"># display the top few rows<br/>rating_matrix.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a28a069f683c8221a1040b1ceb401f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sldtcwyWzBZ52128EUu0WQ.png"/></div></div></figure><p id="c599" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">写一个函数，用余弦相似度找出与 current_user 最相似的用户。我们随意决定找出 3 个最相似的用户。</p><p id="a975" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并选择“226”作为我们的当前用户，但我们可以选择任何人。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="c031" class="mt lr it mp b gy mu mv l mw mx">from sklearn.metrics.pairwise import cosine_similarity<br/>import operator</span><span id="dcc9" class="mt lr it mp b gy my mv l mw mx">def similar_users(user_id, matrix, k=3):<br/>    # create a df of just the current user<br/>    user = matrix[matrix.index == user_id]<br/>    <br/>    # and a df of all other users<br/>    other_users = matrix[matrix.index != user_id]<br/>    <br/>    # calc cosine similarity between user and each other user<br/>    similarities = cosine_similarity(user,other_users)[0].tolist()<br/>    <br/>    # create list of indices of these users<br/>    indices = other_users.index.tolist()<br/>    <br/>    # create key/values pairs of user index and their similarity<br/>    index_similarity = dict(zip(indices, similarities))<br/>    <br/>    # sort by similarity<br/>    index_similarity_sorted = sorted(index_similarity.items(), key=operator.itemgetter(1))<br/>    index_similarity_sorted.reverse()<br/>    <br/>    # grab k users off the top<br/>    top_users_similarities = index_similarity_sorted[:k]<br/>    users = [u[0] for u in top_users_similarities]<br/>    <br/>    return users<br/>    </span><span id="58c0" class="mt lr it mp b gy my mv l mw mx">current_user = 226</span><span id="8e3d" class="mt lr it mp b gy my mv l mw mx"># try it out<br/>similar_user_indices = similar_users(current_user, rating_matrix)</span><span id="6342" class="mt lr it mp b gy my mv l mw mx">print(similar_user_indices)<br/>#=&gt; [30773, 39021, 45603]</span></pre><p id="91cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在写一个函数来做推荐。我们已经设置了返回 5 部热门推荐动漫的功能。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="3c52" class="mt lr it mp b gy mu mv l mw mx">def recommend_item(user_index, similar_user_indices, matrix, items=5):<br/>    <br/>    # load vectors for similar users<br/>    similar_users = matrix[matrix.index.isin(similar_user_indices)]</span><span id="ee9b" class="mt lr it mp b gy my mv l mw mx">    # calc avg ratings across the 3 similar users<br/>    similar_users = similar_users.mean(axis=0)</span><span id="62f2" class="mt lr it mp b gy my mv l mw mx">    # convert to dataframe so its easy to sort and filter<br/>    similar_users_df = pd.DataFrame(similar_users, columns=['mean'])<br/>    <br/>    <br/>    # load vector for the current user<br/>    user_df = matrix[matrix.index == user_index]</span><span id="c64b" class="mt lr it mp b gy my mv l mw mx">    # transpose it so its easier to filter<br/>    user_df_transposed = user_df.transpose()</span><span id="c6cf" class="mt lr it mp b gy my mv l mw mx">    # rename the column as 'rating'<br/>    user_df_transposed.columns = ['rating']</span><span id="4811" class="mt lr it mp b gy my mv l mw mx">    # remove any rows without a 0 value. Anime not watched yet<br/>    user_df_transposed = user_df_transposed[user_df_transposed['rating']==0]</span><span id="17bd" class="mt lr it mp b gy my mv l mw mx">    # generate a list of animes the user has not seen<br/>    animes_unseen = user_df_transposed.index.tolist()<br/>    <br/>    # filter avg ratings of similar users for only anime the current user has not seen<br/>    similar_users_df_filtered = similar_users_df[similar_users_df.index.isin(animes_unseen)]</span><span id="4add" class="mt lr it mp b gy my mv l mw mx">    # order the dataframe<br/>    similar_users_df_ordered = similar_users_df.sort_values(by=['mean'], ascending=False)</span><span id="cbd8" class="mt lr it mp b gy my mv l mw mx">    # grab the top n anime   <br/>    top_n_anime = similar_users_df_ordered.head(items)<br/>    top_n_anime_indices = top_n_anime.index.tolist()</span><span id="6a98" class="mt lr it mp b gy my mv l mw mx">    # lookup these anime in the other dataframe to find names<br/>    anime_information = animes[animes['anime_id'].isin(top_n_anime_indices)]<br/>    <br/>    return anime_information #items<br/></span><span id="2b96" class="mt lr it mp b gy my mv l mw mx"># try it out<br/>recommend_item(226, similar_user_indices, rating_matrix)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/55d93d6fe52ab06285b870cf555bafc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71x83WKhlbCXk38CpSfyvg.png"/></div></div></figure><p id="5645" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们做到了！我们的当前用户尚未观看的来自最相似用户的最高评级的 5 部动画。</p><p id="0d4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，我们想要试验不同的相似性算法和不同数量的相似用户。但是我希望你把它当作一个基于用户的协作过滤的粗略框架。</p><p id="9e06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下次见。</p></div></div>    
</body>
</html>