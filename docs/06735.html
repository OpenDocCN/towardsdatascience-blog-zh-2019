<html>
<head>
<title>Where should I walk?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我应该去哪里？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/where-should-i-walk-e66b26735de5?source=collection_archive---------26-----------------------#2019-09-25">https://towardsdatascience.com/where-should-i-walk-e66b26735de5?source=collection_archive---------26-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">使用 NVIDIA RAPIDS 的新工具来确定到停车场的最短步行距离</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2122b362684da4e1a6f6142e7c4208d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AsnCrUufpBU-KioGF0M1QA.png"/></div></div></figure><h1 id="5c47" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">简介</strong></h1><p id="1947" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在<a class="ae mi" rel="noopener" target="_blank" href="/where-should-i-park-29e8da95265a">之前的故事</a>中，我们探索了西雅图市交通局提供的付费停车占用率数据集。你可以看到(并希望测试)使用<a class="ae mi" href="https://rapids.ai/" rel="noopener ugc nofollow" target="_blank"> NVIDIA RAPIDS </a>对这些数据进行的所有计算有多快。</p><p id="1200" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">简单回顾一下:我们使用的数据可以从<a class="ae mi" href="http://tomdrabas.com/data/seattle_parking/parking_MayJun2019.tar.gz" rel="noopener ugc nofollow" target="_blank">这里</a>下载。它是自 2019 年初以来发布的完整数据集的子集，包括 5 月和 6 月的所有交易。数据集的大小约为 7GB，非常适合配有 24GB VRAM 的 NVIDIA Titan RTX。要在 RAM 更少的 GPU 上使用这个数据集(如 11GB 的<a class="ae mi" href="https://www.nvidia.com/en-us/geforce/graphics-cards/rtx-2080-ti/" rel="noopener ugc nofollow" target="_blank">英伟达 RTX 2080 Ti </a>)，您可能只需要提取一个月的数据——我已经准备了一个更小的数据集，只包含 2019 年 5 月的交易，您可以在这里下载<a class="ae mi" href="http://tomdrabas.com/data/seattle_parking/parking_May2019.tar.gz" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="1c5d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">快速进行地理空间计算</strong></h1><p id="6954" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在我们继续讲这个故事之前，让我们谈一个小的话题。就在我发表我的故事一天后，NVIDIA 的 RAPIDS 团队<a class="ae mi" href="https://medium.com/rapids-ai/releasing-cuspatial-to-accelerate-geospatial-and-spatiotemporal-processing-b686d8b32a9" rel="noopener">宣布了数据科学难题中的另一个伟大作品:cuSpatial </a>！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/5f5126e9a94c4691b81d8a26700b0678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*32ARta14sMskVBt1"/></div></div></figure><p id="adf4" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">图一。cuSpatial 堆栈，经 NVIDIA 许可使用</p><p id="4977" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">顾名思义，cuSpatial 是一个专注于地理空间计算的库。它是一组通过 Python 接口公开的 C++/CUDA 内核，就像 RAPIDS 工具包中的其他工具一样。而且速度很快，就像其他人一样！</p><p id="f309" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">为了让我们感受一下它的计算速度，我们将使用上一个故事中的完整数据集(提醒一下，该数据包含 4800 万个地理编码交易),并测试如果我们使用 cuSpatial，我们的计算速度会快多少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/97f9b216bacea3a999a210f1f0fcbc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HsCSUsEG_pMzMbMN"/></div></div></figure><p id="a87a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在这个测试中，我们可以看到 4.8 倍于普通 Python 的加速，而且不费吹灰之力(代码也少得多！！).为了比较性能，我们重用了前面故事中的<em class="mq"> calculateDistance(…) </em>方法的(在语法上有所压缩)版本。</p><p id="ec7b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">注意，如果你运行<em class="mq">。apply_rows(…) </em>方法第一次运行时，您将遭受编译损失，因为 RAPIDS 需要首先 JIT 编译<em class="mq">计算距离(…) </em>方法:在我的机器上，单元的第一次运行通常报告大约 650 毫秒，但是如果您再次运行单元，执行时间将下降到大约 220 毫秒；假设您没有做任何更改，<em class="mq"> calculateDistance(…) </em>方法将在此时被缓存。当<a class="ae mi" href="https://twitter.com/tomekdrabas/status/1172350554229506048?s=20" rel="noopener ugc nofollow" target="_blank">我第一次报告我看到的令人印象深刻的速度提升</a>时，我发现了这一点。然而，接下来的讨论实际上导致了一个<a class="ae mi" href="https://github.com/rapidsai/cudf/issues/2805" rel="noopener ugc nofollow" target="_blank">额外性能挤压</a>的发现，它将很快来到 RAPIDS！</p><h1 id="b687" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">我们是坐飞机还是走路？！</h1><p id="c80b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">那么，现在回到我们故事的继续。上次我们计算的距离是直线距离，而不是步行距离。这导致了一些停车点的出现，如果步行的话，这些停车点实际上会超过 1000 英尺。</p><p id="a0af" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">令人欣慰的是，<a class="ae mi" href="https://fusiondatascience.com/" rel="noopener ugc nofollow" target="_blank">融合数据科学</a>的独一无二的约翰·默里获得了<a class="ae mi" href="https://catalog.data.gov/dataset/tiger-line-shapefile-2018-county-king-county-wa-all-roads-county-based-shapefile" rel="noopener ugc nofollow" target="_blank">国王县老虎/线道路网</a>的形状文件，并友好地创建和捐赠了一个国王县道路图，其形式为一个交叉点列表(带有地理坐标)和一个连接交叉点与计算长度(以码为单位)的边列表。数据可以在这里下载<a class="ae mi" href="http://tomdrabas.com/data/seattle_parking/king_county_road_graph_20190909.tar.gz" rel="noopener ugc nofollow" target="_blank">，但是如果你使用我们发布在 Github 上的代码，</a><a class="ae mi" href="https://github.com/drabastomek/rapids-notebooks/blob/master/codes/rapids_seattleParking_graph.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>还是会帮你做的。</p><h2 id="766a" class="mr kv it bd kw ms mt dn la mu mv dp le lv mw mx lg lz my mz li md na nb lk nc bi translated"><strong class="ak">将停车点连接到图表</strong></h2><p id="d85e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">很明显，停车位置没有出现在图表中，所以我们需要添加它们。在第一次尝试中，我们将遍历所有 1，500 个停车位置，计算到每个道路交叉口的距离，并选择 3 个最近的交叉口。这有点麻烦，会导致一些伪像(稍后在地图上显示),但现在可以了。在下一个故事中，我们将讨论如何添加新的节点，使停车点垂直于道路/边缘(再次感谢 John 提出这个建议并帮助编写代码！)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/1a01d768e598d26b222a18ef4dc6c732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ZSYf-VFnF0EVWEz"/></div></div></figure><p id="79ca" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://rapidsai.github.io/projects/cudf/en/0.9.0/api.html#cudf.dataframe.DataFrame.nsmallest" rel="noopener ugc nofollow" target="_blank"> <em class="mq">。nsmallest(…) </em> </a>方法(也有<a class="ae mi" href="https://rapidsai.github.io/projects/cudf/en/0.9.0/api.html#cudf.dataframe.DataFrame.nlargest" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> nlargest(…) </em> </a>可用)返回前 3 个最近的交点；我们使用<em class="mq">将这些边添加到<em class="mq"> road_graph_data </em>数据帧中。concat(…) </em>方法。最后，我们还向<em class="mq">parking _ locations _ nodes</em>数据帧添加了一个新节点，这样我们就可以稍后将它们添加到图节点的完整列表中。</p><p id="2d0d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">让我们在这里暂停一秒钟:我们刚刚使用 cuSpatial 计算了所有 1500 个停车位置到 127k 个道路交叉口的哈弗线距离(因此，这是大约 200 米的计算)，选择了 3 个最近的交叉口，并更新了数据集，所有这些都在大约 1 分钟内完成。如果这还不够快，我不知道什么是…</p><p id="a805" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">继续，我们还需要为空间针添加一个节点。然而，不是链接到最近的 3 个十字路口，在地图上的一瞥建议我们应该链接到 5。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/92814b8a8ce9ec26aba0a32fef239b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t1skop9QsFefS_vv"/></div></div></figure><p id="8928" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">就像之前一样，我们使用<a class="ae mi" href="https://geopy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> geopy </a>包中的 Nomatim geo 编码器来获取太空针的坐标。</p><h1 id="2caa" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">我们来建个图吧！</strong></h1><p id="8860" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们有了节点和边的完整列表，我们可以构建图表了。这在急流中超级容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/e0eb02b1b72552362cb3de3f5538e223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2K_dhl8l07_EPd0l"/></div></div></figure><p id="6815" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">查看<a class="ae mi" href="https://docs.rapids.ai/api/cugraph/stable/" rel="noopener ugc nofollow" target="_blank">文档</a>获取可用方法和算法的完整列表！</p><p id="95f6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">有了完整的图，我们现在可以使用单源最短路径(SSSP)来计算从太空针到每个停车位置的距离！该算法遍历该图并找到到所有 128k 个节点的最短路径；对于 SSSP 算法的概述，我发现这些笔记很有用。作为回报，我们得到一个数据帧，其中包含一系列顶点以及到这些顶点的相应最短距离。数据帧还显示了<em class="mq">的前任</em>，一个节点(或者顶点，如果你愿意的话)，你需要在之前访问<em class="mq">一个正在讨论的形成最短路径的特定节点。所有这些都在 174 毫秒内完成。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/c2c98e4f3714410c002432381798b78f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yTY6XQLE_4w7lQnS"/></div></div></figure><p id="b755" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们现在可以使用这些信息来创建从太空针到 1000 英尺步行距离内的每个停车点的完整路径。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/558c30ca753391ee34314b9e90ccd273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rkcG28PhYpxXlclF"/></div></div></figure><p id="5fd7" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在上面的代码片段中，我简单地从一个节点跳到另一个节点，并将边添加到<em class="mq">路径</em>数据帧中。大约 1 秒钟后，我们可以开始制图。从<em class="mq"> road_nodes </em>数据帧中，我们提取每个节点的坐标，这样我们以后就可以用它们在地图上绘制这些点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/e02767c88bd0e7f4ea0a76441ed03838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*--ybdg4Jdus1YAzu"/></div></div></figure><p id="f17b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这是最终的结果！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ea293bf0eda023655f27cf92dc9faae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BeKUbEr4lje34yOB"/></div></div></figure><p id="48d5" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">因此，考虑到所需的距离，距离太空针塔最近的停车点在南面和东面。现在，如果你仔细看，你可以看到我之前提到的人工制品以及将停车位分配到最近的 3 个十字路口的方法的不足之处:为了到达一些停车位，算法将<em class="mq">要求</em>你走过停车位，然后走回停车位。在下一个故事中，我们将解决这个问题。</p><h1 id="56c1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">总结</strong></h1><p id="2a7c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">与我们之前的<a class="ae mi" rel="noopener" target="_blank" href="/where-should-i-park-29e8da95265a">工作流</a>(在泰坦 RTX 上运行大约 20 秒)相比，这个端到端的过程需要大约 2 分钟才能完成。尽管如此，这些工作的大部分可以保存下来，然后在以后重用，将推断时间减少到仅仅一两秒钟。</p><p id="473e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">敬请关注 NVIDIA RAPIDS 的力量、速度和灵活性的更多示例！</p></div></div>    
</body>
</html>