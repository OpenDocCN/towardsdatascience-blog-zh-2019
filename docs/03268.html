<html>
<head>
<title>ARIMA Model Python Example — Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ARIMA 模型 Python 示例-时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-part-19-time-series-and-autoregressive-integrated-moving-average-model-arima-c1005347b0d7?source=collection_archive---------0-----------------------#2019-05-25">https://towardsdatascience.com/machine-learning-part-19-time-series-and-autoregressive-integrated-moving-average-model-arima-c1005347b0d7?source=collection_archive---------0-----------------------#2019-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/379ee04d2b711ea9aa0a219eeb5165d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U1A1dLFcUT_hbtLV"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://www.pexels.com/photo/white-printer-paper-590011/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/white-printer-paper-590011/</a></figcaption></figure><div class=""/><p id="ff5b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于历史观察做出预测的能力创造了竞争优势。例如，如果一个组织有能力更好地预测一种产品的销售量，它将在优化库存水平方面处于更有利的地位。这可以增加组织现金储备的流动性，减少营运资本，并通过减少积压订单来提高客户满意度。</p><p id="f3f8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在机器学习领域，有一组特定的方法和技术特别适合于根据时间预测因变量的值。在接下来的文章中，我们将讨论自回归综合移动平均(ARIMA)。</p><p id="b456" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将按时间顺序索引(或绘制)的一系列数据点称为<strong class="ki jk">时间序列</strong>。时间序列可以分解成 3 个部分。</p><ul class=""><li id="534e" class="le lf jj ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki jk">趋势:</strong>向上&amp;数据在很长一段时间内随时间的向下移动(即房屋升值)</li><li id="4221" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk">季节性:</strong>季节性差异(即夏季对冰淇淋的需求增加)</li><li id="1076" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk">噪声:</strong>尖峰信号&amp;随机间隔的低谷信号</li></ul><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/e3e959f2c30bece5d760196262b556e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nev5KvCFz7KhcDBO.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://commons.wikimedia.org/wiki/File:Mae.timeseries_decomposition.commonswiki.svg" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Mae.timeseries_decomposition.commonswiki.svg</a></figcaption></figure><p id="2449" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在对时间序列应用任何统计模型之前，我们希望确保它是平稳的。</p><p id="1c78" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据是静止的意味着什么？</p><p id="73c3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">序列的平均值不应该是时间的函数。下面的红色图表不是静止的，因为平均值会随着时间的推移而增加。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/e2986f44e85609ae46f970b0f525c5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R6A_ODIIBqUU1bIP"/></div></div></figure><p id="ef17" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">序列的方差不应该是时间的函数。这种性质称为同质性。请注意红色图表中数据随时间变化的分布。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/d1ece47cf5f632a86dc18f75fafb45fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Gqb2kRXjuV02hLN"/></div></div></figure><p id="1da2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，第(i+m)项的第 I 项的协方差不应该是时间的函数。在下图中，你会注意到随着时间的增加，传播变得越来越近。因此，对于红色系列，协方差随时间不是常数。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/20d416e757f2ab7920fdc1f2f4161f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m_b5uzSC0jJVBhbq"/></div></div></figure><p id="3671" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个时间序列是平稳的，并且在给定的时间间隔内具有特定的行为，那么可以有把握地假设它在以后的某个时间点将具有相同的行为。大多数统计建模方法假设或要求时间序列是平稳的。</p><h1 id="2b4a" class="ly lz jj bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">密码</h1><p id="c500" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated"><code class="fe nb nc nd ne b">statsmodels</code>库提供了一套处理时间序列数据的函数。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="08c9" class="nj lz jj ne b gy nk nl l nm nn">import numpy as np<br/>import pandas as pd<br/>from matplotlib import pyplot as plt<br/>from statsmodels.tsa.stattools import adfuller<br/>from statsmodels.tsa.seasonal import seasonal_decompose<br/>from statsmodels.tsa.arima_model import ARIMA<br/>from pandas.plotting import register_matplotlib_converters<br/>register_matplotlib_converters()</span></pre><p id="a2ed" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用一个包含某一天飞机乘客数量的数据集。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="6800" class="nj lz jj ne b gy nk nl l nm nn">df = pd.read_csv('air_passengers.csv', parse_dates = ['Month'], index_col = ['Month'])</span><span id="5eb4" class="nj lz jj ne b gy no nl l nm nn">df.head()</span><span id="ecdb" class="nj lz jj ne b gy no nl l nm nn">plt.xlabel('Date')<br/>plt.ylabel('Number of air passengers')<br/>plt.plot(df)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e72bf7c871ff22b94add3622c08dd9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*x2UcgDwvdsDcYb6xyT4ekw.png"/></div></figure><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fbe8adc45485f5a8ef9162279a3465e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*TvZpqvVkjn3Vhtwnr4KGrw.png"/></div></figure><p id="98ae" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，在我们建立模型之前，我们必须确保时间序列是平稳的。有两种主要方法来确定给定时间序列是否是平稳的。</p><ul class=""><li id="360d" class="le lf jj ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki jk">滚动</strong> <strong class="ki jk">统计</strong>:绘制滚动平均值和滚动标准差。如果时间序列随时间保持不变，则时间序列是静止的(用肉眼观察这些线是否是直的并且平行于 x 轴)。</li><li id="18cd" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk">扩展的 Dickey-Fuller 检验</strong>:如果 p 值较低(根据零假设),并且 1%、5%、10%置信区间的临界值尽可能接近 ADF 统计值，则认为时间序列是平稳的</li></ul><p id="1be4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些不理解平均价格和滚动平均价格之间区别的人来说，10 天的滚动平均价格是作为第一个数据点的前 10 天的收盘价的平均值。下一个数据点将删除最早的价格，添加第 11 天的价格并取平均值，依此类推，如下所示。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2c45b0ee241847b8bf0023b1af8435a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/0*ykG4mi5SAG_pO2O5"/></div></figure><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="a4d0" class="nj lz jj ne b gy nk nl l nm nn">rolling_mean = df.rolling(window = 12).mean()<br/>rolling_std = df.rolling(window = 12).std()</span><span id="d1c9" class="nj lz jj ne b gy no nl l nm nn">plt.plot(df, color = 'blue', label = 'Original')<br/>plt.plot(rolling_mean, color = 'red', label = 'Rolling Mean')<br/>plt.plot(rolling_std, color = 'black', label = 'Rolling Std')<br/>plt.legend(loc = 'best')<br/>plt.title('Rolling Mean &amp; Rolling Standard Deviation')<br/>plt.show()</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/43f1660646a5a1edec36d9f3a5db17e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*5Ul5yC0i3gmIH5z2NlTjLA.png"/></div></figure><p id="edc0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，滚动平均值和滚动标准差随着时间的推移而增加。因此，我们可以得出结论，时间序列不是平稳的。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="5f13" class="nj lz jj ne b gy nk nl l nm nn">result = adfuller(df['Passengers'])</span><span id="cb5a" class="nj lz jj ne b gy no nl l nm nn">print('ADF Statistic: {}'.format(result[0]))<br/>print('p-value: {}'.format(result[1]))<br/>print('Critical Values:')<br/>for key, value in result[4].items():<br/>    print('\t{}: {}'.format(key, value))</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6a7d7dccdf3931ccd8562b1d142d7b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*S70eu1FD6tGKNRAjgE7n6g.png"/></div></figure><p id="bb7a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ADF 统计值远离临界值，p 值大于阈值(0.05)。因此，我们可以得出结论，时间序列不是平稳的。</p><p id="b7bf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">取因变量的对数是降低滚动平均值增长率的简单方法。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="1089" class="nj lz jj ne b gy nk nl l nm nn">df_log = np.log(df)<br/>plt.plot(df_log)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2bd4e7c5056465f78dc4c684ad8dfaf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*_YNIKhnbuc1AwpKu4FCADw.png"/></div></figure><p id="6d03" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个函数来运行这两个测试，以确定给定的时间序列是否是平稳的。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="5e70" class="nj lz jj ne b gy nk nl l nm nn">def get_stationarity(timeseries):<br/>    <br/>    # rolling statistics<br/>    rolling_mean = timeseries.rolling(window=12).mean()<br/>    rolling_std = timeseries.rolling(window=12).std()<br/>    <br/>    # rolling statistics plot<br/>    original = plt.plot(timeseries, color='blue', label='Original')<br/>    mean = plt.plot(rolling_mean, color='red', label='Rolling Mean')<br/>    std = plt.plot(rolling_std, color='black', label='Rolling Std')<br/>    plt.legend(loc='best')<br/>    plt.title('Rolling Mean &amp; Standard Deviation')<br/>    plt.show(block=False)<br/>    <br/>    # Dickey–Fuller test:<br/>    result = adfuller(timeseries['Passengers'])<br/>    print('ADF Statistic: {}'.format(result[0]))<br/>    print('p-value: {}'.format(result[1]))<br/>    print('Critical Values:')<br/>    for key, value in result[4].items():<br/>        print('\t{}: {}'.format(key, value))</span></pre><p id="d058" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对时间序列进行多种变换，使其保持平稳。例如，我们减去滚动平均值。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="16c1" class="nj lz jj ne b gy nk nl l nm nn">rolling_mean = df_log.rolling(window=12).mean()<br/>df_log_minus_mean = df_log - rolling_mean<br/>df_log_minus_mean.dropna(inplace=True)</span><span id="c713" class="nj lz jj ne b gy no nl l nm nn">get_stationarity(df_log_minus_mean)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/31d18fb0389f21a7e44e1ceb6afadc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*7PqLEpHxaVFA80gQbqbpHw.png"/></div></figure><p id="90d4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，减去均值后，滚动均值和标准差是近似水平的。p 值低于阈值 0.05，ADF 统计值接近临界值。因此，时间序列是平稳的。</p><p id="94e8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用指数衰减是另一种转换时间序列使其稳定的方法。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="29e8" class="nj lz jj ne b gy nk nl l nm nn">rolling_mean_exp_decay = df_log.ewm(halflife=12, min_periods=0, adjust=True).mean()<br/>df_log_exp_decay = df_log - rolling_mean_exp_decay<br/>df_log_exp_decay.dropna(inplace=True)</span><span id="23d1" class="nj lz jj ne b gy no nl l nm nn">get_stationarity(df_log_exp_decay)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/184308f94d2b707e2d1f915b47424c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*gk3uUUexqLkxkSlndj4HXw.png"/></div></figure><p id="ee6f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">指数衰减比减去滚动平均值表现更差。然而，它仍然比原来更稳定。</p><p id="8008" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再尝试一种方法来确定是否存在更好的解决方案。当应用时移时，我们用前一个点减去每个点。</p><p id="3731" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> <em class="nx">空、(x1 x0)、(x2 x1)、(x3 x2)、(x4 x3)、……、(xn xn 1)</em></strong></p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="ef42" class="nj lz jj ne b gy nk nl l nm nn">df_log_shift = df_log - df_log.shift()<br/>df_log_shift.dropna(inplace=True)</span><span id="8474" class="nj lz jj ne b gy no nl l nm nn">get_stationarity(df_log_shift)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/186642aed535351db2f0e9247fccdbd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*GMpJ4vXHj8uaWzzSyI9Hqw.png"/></div></figure><p id="2a90" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">时间偏移的效果不如减去滚动平均值。然而，它仍然比原来更稳定。</p><h2 id="6f11" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">自回归模型</h2><p id="8361" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">自回归模型在过去的值对当前值有影响的前提下运行。AR 模型通常用于分析自然、经济和其他时变过程。只要假设成立，我们就可以建立一个线性回归模型，根据前几天的值，尝试预测因变量今天的值。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/ed657096c1cf5ffdac9a4943f28ff411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gC_rZqkmT8nBSDSpe-Kojw.png"/></div></div></figure><p id="eb5f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AR 模型的阶数对应于公式中包含的天数。</p><h2 id="cb62" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">移动平均模型</h2><p id="5139" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">假设当天因变量的值取决于前一天的误差项。该公式可以表示为:</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/3720fd616373187b5104760f61d73d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*pgsCNUO2xUij5NPBJWQRdQ.png"/></div></figure><p id="f1de" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你还会遇到这样的等式:</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/59884e71c8825c694de0f128d18c1c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*su9pYmAV8QMwgHihKhDeJQ.png"/></div></div></figure><p id="27ac" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中μ是级数的平均值，<em class="nx"> θ </em> 1、…、<em class="nx"> θq </em>是模型的参数，<em class="nx"> εt </em>、<em class="nx">εt</em>—1、…、<em class="nx">εt</em>—q 是白噪声误差项。<em class="nx"> q </em>的值称为 MA 模型的阶数。</p><h2 id="9e6a" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">自回归移动平均</h2><p id="ad77" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">ARMA 模型是 AR 和 MA 模型的简单组合。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/f8adf0e61684d83ad738e6792751966e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GW9_HmTcy7kUEkWNJgxHMQ.png"/></div></div></figure><h2 id="47a3" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">自回归综合移动平均模型(ARIMA)</h2><p id="3946" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">ARIMA(又名 Box-Jenkins)模型增加了 ARMA 模型的差异。差分从以前的值中减去当前值，可用于将时间序列转换为静态时间序列。例如，一阶差分处理线性趋势，并采用转换<code class="fe nb nc nd ne b">zi = yi — yi-1</code>。二阶差分处理二次趋势，并采用一阶差分的一阶差分，即<code class="fe nb nc nd ne b">zi = (yi — yi-1) — (yi-1 — yi-2)</code>，等等。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/6a151e49cfa078528cf59fcd64c7879e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YcMGmHZuq22pjM7n"/></div></div></figure><p id="80d2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">三个整数(p，d，q)通常用于参数化 ARIMA 模型。</p><ul class=""><li id="2a45" class="le lf jj ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki jk"><em class="nx">p:</em><em class="nx">自回归</em>项数(AR 顺序)</strong></li><li id="3877" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk"><em class="nx">d:</em><em class="nx">非季节性差异数(差异顺序)</em> </strong></li><li id="56b7" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk"> <em class="nx">问:</em><em class="nx">移动平均线数量</em>(MA 顺序)</strong></li></ul><h2 id="47a1" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">自相关函数</h2><p id="15f2" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">当前时间点的观测值与所有先前时间点的<strong class="ki jk">的观测值之间的相关性。我们可以使用 ACF 来确定<strong class="ki jk"> MA </strong>项的最佳数量。术语的数量决定了模型的顺序。</strong></p><h2 id="6e4c" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">部分自相关函数(PACF)</h2><p id="9fee" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">顾名思义，PACF 是 ACF 的一个子集。PACF 表示在<strong class="ki jk">两个时间点</strong>进行的观察之间的相关性，同时考虑来自其他数据点的任何影响。我们可以使用 PACF 来确定在<strong class="ki jk"> AR </strong>模型中使用的最佳项数。术语的数量决定了模型的顺序。</p><p id="615c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子。回想一下，PACF 可以用来计算 AR 模型的最佳阶数。水平蓝色虚线代表显著性阈值。垂直线代表在时间点的 ACF 和 PACF 值。只有超过水平线的垂直线被认为是显著的。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d7c84d5ff124452694ae1ec69db59b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*_XkYr07wDWox30jffL5h0w.png"/></div></figure><p id="d521" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们将在自回归方程中使用前两天。</p><p id="eeb9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回想一下，ACF 可以用来计算 MA 模型的最佳阶数。</p><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/77b3537fa70fee332e16a893ad62ce6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*y7jU7murVQQr78lFUPbXrw.png"/></div></figure><p id="f154" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们在移动平均方程式中只使用昨天。</p><p id="2921" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到我们的例子，我们可以用 2 阶 AR、1 阶差分和 2 阶 MA 来创建和拟合 ARIMA 模型。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="a919" class="nj lz jj ne b gy nk nl l nm nn">decomposition = seasonal_decompose(df_log) <br/>model = ARIMA(df_log, order=(2,1,2))<br/>results = model.fit(disp=-1)<br/>plt.plot(df_log_shift)<br/>plt.plot(results.fittedvalues, color='red')</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/271578cb02f4b45e02316cd2e7670367.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*_APiZXWZXSd68mkUpfit8g.png"/></div></figure><p id="c3c5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以看到该模型如何与原始时间序列进行比较。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="bb17" class="nj lz jj ne b gy nk nl l nm nn">predictions_ARIMA_diff = pd.Series(results.fittedvalues, copy=True)<br/>predictions_ARIMA_diff_cumsum = predictions_ARIMA_diff.cumsum()<br/>predictions_ARIMA_log = pd.Series(df_log['Passengers'].iloc[0], index=df_log.index)<br/>predictions_ARIMA_log = predictions_ARIMA_log.add(predictions_ARIMA_diff_cumsum, fill_value=0)<br/>predictions_ARIMA = np.exp(predictions_ARIMA_log)<br/>plt.plot(df)<br/>plt.plot(predictions_ARIMA)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cdcc40bf62d5255dccf748673fdc8794.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*TZm6guGsCIEiLU4GcDJcUQ.png"/></div></figure><p id="eea9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有过去 12 年每个月的数据，并希望预测未来 10 年的乘客数量，我们使用(12 x12)+ (12 x 10) = 264。</p><pre class="lt lu lv lw gt nf ne ng nh aw ni bi"><span id="aa5e" class="nj lz jj ne b gy nk nl l nm nn">results.plot_predict(1,264)</span></pre><figure class="lt lu lv lw gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/aca0e26e8e82b311e2043665824bfa9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*wXObFNwnODZIG5Nii9iXHA.png"/></div></figure><h2 id="0fb7" class="nj lz jj bd ma nz oa dn me ob oc dp mi kr od oe mm kv of og mq kz oh oi mu oj bi translated">最后的想法</h2><p id="7d95" class="pw-post-body-paragraph kg kh jj ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">在机器学习的领域中，有一套操作和解释依赖于时间的变量的技术。其中包括 ARIMA，它可以删除趋势成分，以准确预测未来值。</p></div></div>    
</body>
</html>