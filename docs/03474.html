<html>
<head>
<title>Introduction to Graphs (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图表介绍(第一部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-graphs-part-1-2de6cda8c5a5?source=collection_archive---------6-----------------------#2019-06-03">https://towardsdatascience.com/introduction-to-graphs-part-1-2de6cda8c5a5?source=collection_archive---------6-----------------------#2019-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="478f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/towards-data-science/inside-ai/home" rel="noopener">内线艾</a></h2><div class=""/><div class=""><h2 id="dda3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python 中的主要概念、属性和应用</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7e0c66efddc655cc34c6600b574b6253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSDVP6yKqOde0mGKn1CmBA.png"/></div></div></figure><p id="ce54" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> G </span>如今，raphs 正成为机器学习的核心，例如，无论你是想通过预测潜在的联系来了解社交网络的结构，检测欺诈，了解汽车租赁服务的客户行为，还是提出实时建议。</p><p id="cc8b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本文中，我们将讨论以下主题:</p><ul class=""><li id="fa20" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">什么是图？</li><li id="f400" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">如何存储一个图形？</li><li id="121c" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">图的类型和性质</li><li id="6efe" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">Python 中的示例</li></ul><p id="2783" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是致力于图论、图算法和图学习的三篇系列文章的第一篇。</p><p id="bd14" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本文最初发表于我的个人博客:<a class="ae mw" href="https://maelfabien.github.io/ml/#" rel="noopener ugc nofollow" target="_blank">https://maelfabien.github.io/ml/#</a></p><p id="4f5a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我在这个资源库上发布我所有的文章和相应的代码:</p><div class="mx my gp gr mz na"><a href="https://github.com/maelfabien/Machine_Learning_Tutorials" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">mael fabien/机器学习教程</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">本报告包含练习、代码、教程和我的个人博客文章</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lb na"/></div></div></a></div><p id="00c9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> NB </strong> : Part 2 和 Part 3 出来了！:)</p><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/graph-algorithms-part-2-dce0b2734a1d"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">图形算法(第二部分)</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">Python 中的主要概念、属性和应用</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="np l nl nm nn nj no lb na"/></div></div></a></div><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/learning-in-graphs-with-python-part-3-8d5513eef62d"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">用 Python 学习图形(第 3 部分)</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">Python 的概念、应用和示例</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="nq l nl nm nn nj no lb na"/></div></div></a></div></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="5d63" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来，打开 Jupyter 笔记本，导入以下包:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="266e" class="od oe it nz b gy of og l oh oi">import numpy as np<br/>import random<br/>import networkx as nx<br/>from IPython.display import Image<br/>import matplotlib.pyplot as plt</span></pre><p id="085b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">以下文章将使用最新版本的<code class="fe oj ok ol nz b">networkx</code><code class="fe oj ok ol nz b">2.x</code>。NetworkX 是一个 Python 包，用于创建、操作和研究复杂网络的结构、动态和功能。</p><p id="f3a1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我将尽量保持一种实用的方法，并举例说明每个概念。</p><h1 id="d2df" class="om oe it bd on oo op oq or os ot ou ov ki ow kj ox kl oy km oz ko pa kp pb pc bi translated">一、什么是图？</h1><blockquote class="pd pe pf"><p id="fd30" class="ld le pg lf b lg lh kd li lj lk kg ll ph ln lo lp pi lr ls lt pj lv lw lx ly im bi translated">图是相互连接的节点的集合。</p></blockquote><p id="bf0c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，一个非常简单的图形可以是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/e8e82fa5a7cc0d73812addcf9f440720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJTrFOaUi3zi0jKYl7PRNg.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Nodes in red, are linked by edges in black</figcaption></figure><p id="dc63" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">图表可用于表示:</p><ul class=""><li id="f341" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated"><strong class="lf jd">社交网络</strong></li><li id="a9a4" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated"><strong class="lf jd">网页</strong></li><li id="f874" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated"><strong class="lf jd">生物网络</strong></li><li id="e321" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi">…</li></ul><p id="7b22" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以对图表进行什么样的分析？</p><ul class=""><li id="4959" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">研究<strong class="lf jd">拓扑和连通性</strong></li><li id="1616" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated"><strong class="lf jd">社区</strong>检测</li><li id="9e79" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">确定<strong class="lf jd">中心节点</strong></li><li id="37a0" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">预测缺失节点</li><li id="671c" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">预测丢失的边</li><li id="63b7" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi">…</li></ul><p id="174a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所有这些概念在几分钟后会变得更加清晰。</p><p id="667a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们的笔记本中，让我们导入第一个预构建的图表:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="dae2" class="od oe it nz b gy of og l oh oi"># Load the graph<br/>G_karate = nx.karate_club_graph()<br/># Find key-values for the graph<br/>pos = nx.spring_layout(G_karate)<br/># Plot the graph<br/>nx.draw(G_karate, cmap = plt.get_cmap('rainbow'), with_labels=True, pos=pos)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/26fa6d8fa68c9b4290f0fabc82f97ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOPMYEHhudYc_IEcsIsLlw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Karate Graph</figcaption></figure><p id="743a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个“空手道”图代表什么？韦恩·w·扎卡里从 1970 年到 1972 年对一个空手道俱乐部的社交网络进行了为期三年的研究。该网络捕获了一个空手道俱乐部的 34 名成员，记录了在俱乐部外互动的成对成员之间的联系。在研究过程中，管理员“约翰 A”和指导员“嗨先生”(化名)之间发生了冲突，导致俱乐部一分为二。一半的成员在 Hi 先生周围组成了一个新的俱乐部；另一部分的成员找到了新的教练或者放弃了空手道。根据收集到的数据，扎卡里正确地将俱乐部中除了一名成员之外的所有成员分配到了他们在分裂后实际加入的小组中。</p><h1 id="9903" class="om oe it bd on oo op oq or os ot ou ov ki ow kj ox kl oy km oz ko pa kp pb pc bi translated">基本图形概念</h1><p id="b417" class="pw-post-body-paragraph ld le it lf b lg pq kd li lj pr kg ll lm ps lo lp lq pt ls lt lu pu lw lx ly im bi translated">一个<em class="pg">图</em> G=(V，E)由一组:</p><ul class=""><li id="6609" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated"><strong class="lf jd">节点</strong>(也叫<strong class="lf jd">顶点)</strong> V=1，…，n</li><li id="10ed" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated"><strong class="lf jd">棱角</strong> E⊆V×V</li><li id="b472" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">一条<strong class="lf jd">边</strong> (i，j) ∈ E 链接节点 I 和 j</li><li id="cf1c" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">据说我和 j 是<strong class="lf jd">邻居</strong></li><li id="b382" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">节点的<strong class="lf jd">度</strong>是其邻居的数量</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/3a4a9b84a0a5ec5b8cfd2cada13298c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfyW6YBKHk6S_z-3IKuRiw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Illustration of nodes, edges, and degrees</figcaption></figure><ul class=""><li id="3828" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">如果所有节点都有 n-1 个邻居，则图是<strong class="lf jd">完整的</strong>。这意味着所有节点都以各种可能的方式连接在一起。</li><li id="280f" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">从 I 到 j 的<strong class="lf jd">路径</strong>是从 I 到 j 的一系列边。该路径的<strong class="lf jd">长度</strong>等于它穿过的边数。</li><li id="949d" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">图的<strong class="lf jd">直径</strong>是连接任意两个节点的所有最短路径中最长路径的长度。</li></ul><p id="7511" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，在这种情况下，我们可以计算连接任意两个节点的一些最短路径。<em class="pg">直径</em>通常为 3，因为没有节点对，因此连接它们的最短路径长于 3。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/432bef7d10274536c6738af546cf3274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvvIFV0AWSwIyE7p2-9ZhA.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Diameter of 3</figcaption></figure><ul class=""><li id="918e" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated"><strong class="lf jd">测地线</strong> <em class="pg"> </em>路径是两个节点之间的最短路径。</li><li id="3adf" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">如果所有的节点都可以通过给定的路径相互到达，那么它们就形成了一个<strong class="lf jd">连通分量。</strong>一个图是<strong class="lf jd">连通的</strong>它有单个连通分量吗</li></ul><p id="823d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，下面是一个包含两个不同连接组件的图表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/dadc09bad514602b1465caa90a80910d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSAIHmfPs854oIlWKgZ9eQ.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">2 connected components</figcaption></figure><ul class=""><li id="2be8" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">如果边是有序对，则图是有向的。在这种情况下，I 的“入度”是到 I 的传入边的数量，“出度”是从 I 传出的边的数量。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/e017a58ea5d609d716706df0540f7cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PrOVFDN8u1tyfF_D2Hlmw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Directed Graph</figcaption></figure><ul class=""><li id="d2a7" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">一个图是<strong class="lf jd">循环的</strong>如果你能返回到一个给定的节点。另一方面，如果至少有一个节点不能返回，那么它就是<strong class="lf jd">非循环的</strong>。</li><li id="845e" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">如果我们给节点或者关系赋予权重，那么一个图就可以是<strong class="lf jd">加权的</strong>。</li><li id="ec46" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">如果边的数量比节点的数量多，那么图是稀疏的。另一方面，如果节点之间有许多边，则称其为<strong class="lf jd">密集</strong>。</li></ul><p id="9894" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Neo4J 关于图算法的书提供了一个清晰的总结:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/98590b37388d0bb54fc150aa729b4b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OufWH9l-H5NSh11MojJ5gw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Summary (Neo4J Graph Book)</figcaption></figure><p id="27a2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在让我们看看如何用 Python 从图表中检索这些信息:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="1f0f" class="od oe it nz b gy of og l oh oi">n=34</span><span id="03dc" class="od oe it nz b gy qa og l oh oi">G_karate.degree()</span></pre><p id="ffa8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">属性<code class="fe oj ok ol nz b">.degree()</code>返回图中每个节点的度数(邻居)列表:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="dc1c" class="od oe it nz b gy of og l oh oi">DegreeView({0: 16, 1: 9, 2: 10, 3: 6, 4: 3, 5: 4, 6: 4, 7: 4, 8: 5, 9: 2, 10: 3, 11: 1, 12: 2, 13: 5, 14: 2, 15: 2, 16: 2, 17: 2, 18: 2, 19: 3, 20: 2, 21: 2, 22: 2, 23: 5, 24: 3, 25: 3, 26: 2, 27: 4, 28: 3, 29: 4, 30: 4, 31: 6, 32: 12, 33: 17})</span></pre><p id="61ac" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，分离度数值:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="726a" class="od oe it nz b gy of og l oh oi"># Isolate the sequence of degrees<br/>degree_sequence = list(G_karate.degree())</span></pre><p id="8571" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">计算边的数量，以及度序列的度量:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="e6e2" class="od oe it nz b gy of og l oh oi">nb_nodes = n<br/>nb_arr = len(G_karate.edges())</span><span id="a8b6" class="od oe it nz b gy qa og l oh oi">avg_degree = np.mean(np.array(degree_sequence)[:,1])<br/>med_degree = np.median(np.array(degree_sequence)[:,1])</span><span id="7684" class="od oe it nz b gy qa og l oh oi">max_degree = max(np.array(degree_sequence)[:,1])<br/>min_degree = np.min(np.array(degree_sequence)[:,1])</span></pre><p id="0a40" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，打印所有这些信息:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="9a64" class="od oe it nz b gy of og l oh oi">print("Number of nodes : " + str(nb_nodes))<br/>print("Number of edges : " + str(nb_arr))</span><span id="6343" class="od oe it nz b gy qa og l oh oi">print("Maximum degree : " + str(max_degree))<br/>print("Minimum degree : " + str(min_degree))</span><span id="d5a9" class="od oe it nz b gy qa og l oh oi">print("Average degree : " + str(avg_degree))<br/>print("Median degree : " + str(med_degree))</span></pre><p id="0995" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个标题是:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="44d5" class="od oe it nz b gy of og l oh oi">Number of nodes : 34<br/>Number of edges : 78<br/>Maximum degree : 17<br/>Minimum degree : 1<br/>Average degree : 4.588235294117647<br/>Median degree : 3.0</span></pre><p id="b226" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">平均而言，图表中的每个人都与 4.6 个人有联系。</p><p id="5153" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们还可以绘制度数直方图:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="5482" class="od oe it nz b gy of og l oh oi">degree_freq = np.array(nx.degree_histogram(G_karate)).astype('float')</span><span id="cb19" class="od oe it nz b gy qa og l oh oi">plt.figure(figsize=(12, 8))<br/>plt.stem(degree_freq)<br/>plt.ylabel("Frequence")<br/>plt.xlabel("Degre")<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/7349ececdbf974a8992581f06f0f4f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0E5ZOrYE8tQQ7VlxTyounw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Degree Histogram</figcaption></figure><p id="3d30" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">稍后，我们将会看到，度数直方图对于确定我们所看到的图形的类型非常重要。</p><h1 id="3632" class="om oe it bd on oo op oq or os ot ou ov ki ow kj ox kl oy km oz ko pa kp pb pc bi translated">二。图表是如何存储的？</h1><p id="15f9" class="pw-post-body-paragraph ld le it lf b lg pq kd li lj pr kg ll lm ps lo lp lq pt ls lt lu pu lw lx ly im bi translated">你现在可能想知道我们如何存储复杂的图形结构？</p><p id="64a4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">根据我们想要的用途，有三种方法来存储图表:</p><ul class=""><li id="e4e6" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">在边缘列表中:</li></ul><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="ffe7" class="od oe it nz b gy of og l oh oi">1   2<br/>1   3<br/>1   4<br/>2   3<br/>3   4<br/>...</span></pre><p id="c293" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们存储由边链接的每对节点的 ID。</p><ul class=""><li id="8afb" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">使用邻接矩阵，通常加载到内存中:</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/7bc535862e576dfdbf8da691eb2ab03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdVVIX09Ooo5M-cEijW-LQ.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Adjacency matrix</figcaption></figure><p id="a924" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于图中的每个可能的对，如果两个节点由一条边链接，则将其设置为 1。如果图是无向的，则 a 是对称的。</p><ul class=""><li id="7ade" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">使用邻接表:</li></ul><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="930f" class="od oe it nz b gy of og l oh oi">1 : [2,3, 4]<br/>2 : [1,3]<br/>3:  [2, 4]<br/>...</span></pre><p id="d659" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最佳表现取决于使用情况和可用内存。图形通常可以保存为<code class="fe oj ok ol nz b">.txt</code>文件。</p><p id="30db" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">图形的一些扩展可能包括:</p><ul class=""><li id="1c17" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">加权边</li><li id="d362" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">节点/边上的标签</li><li id="2c0e" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">与节点/边相关联的特征向量</li></ul><h1 id="dd59" class="om oe it bd on oo op oq or os ot ou ov ki ow kj ox kl oy km oz ko pa kp pb pc bi translated">三。图形的类型</h1><p id="5ea1" class="pw-post-body-paragraph ld le it lf b lg pq kd li lj pr kg ll lm ps lo lp lq pt ls lt lu pu lw lx ly im bi translated">在这一节中，我们将介绍两种主要类型的图表:</p><ul class=""><li id="d0a4" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">鄂尔多斯-雷尼</li><li id="c70e" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">巴拉巴斯-艾伯特</li></ul><h2 id="afd7" class="od oe it bd on qd qe dn or qf qg dp ov lm qh qi ox lq qj qk oz lu ql qm pb iz bi translated">1.鄂尔多斯-雷尼模型</h2><p id="fe2d" class="pw-post-body-paragraph ld le it lf b lg pq kd li lj pr kg ll lm ps lo lp lq pt ls lt lu pu lw lx ly im bi translated"><strong class="lf jd"> a .定义</strong></p><blockquote class="pd pe pf"><p id="bdd3" class="ld le pg lf b lg lh kd li lj lk kg ll ph ln lo lp pi lr ls lt pj lv lw lx ly im bi translated"><em class="it">在一个 Erdos-Rényi 模型中，我们建立一个有 n 个节点的</em> <strong class="lf jd"> <em class="it">随机</em> </strong> <em class="it">图模型。该图是通过在一对节点(I，j)</em><strong class="lf jd"><em class="it"/></strong><em class="it">和</em> <strong class="lf jd"> <em class="it">概率</em> </strong> <em class="it"> p 之间画一条</em> <strong class="lf jd"> <em class="it">边</em> </strong> <em class="it">而生成的。因此我们有两个参数:节点数:n 和概率:p。</em></p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/561a633437a280f7597d6212b179c5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uefkjkA5mu84rSQhxxsteA.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Erdos-Rényi Graphs</figcaption></figure><p id="60fe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 Python 中，<code class="fe oj ok ol nz b">networkx</code>包有一个生成鄂尔多斯-雷尼图的内置函数。</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="4192" class="od oe it nz b gy of og l oh oi"># Generate the graph<br/>n = 50<br/>p = 0.2<br/>G_erdos = nx.erdos_renyi_graph(n,p, seed =100)</span><span id="56f5" class="od oe it nz b gy qa og l oh oi"># Plot the graph<br/>plt.figure(figsize=(12,8))<br/>nx.draw(G_erdos, node_size=10)</span></pre><p id="4904" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您将得到与此非常相似的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/6ca7c773e033b2a6efe2b9bc182e6743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QElcwoOZxCTOqVNK9WPegA.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Generated Graph</figcaption></figure><p id="7356" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> b .学位分布</strong></p><p id="cf83" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="pg">设 pk 随机选择的节点具有度 k 的概率</em>由于图的构建方式是随机的，所以图的度分布是<strong class="lf jd">二项式</strong>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/f34e50f09501975bb4dae52304aca0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VY51_o_xZV8sH8eqMzCtQg.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Binomial node degree distribution</figcaption></figure><p id="f6b6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个节点的度数分布应该非常接近平均值。观察到大量节点的概率呈指数下降。</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="35b9" class="od oe it nz b gy of og l oh oi">degree_freq = np.array(nx.degree_histogram(G_erdos)).astype('float')</span><span id="8940" class="od oe it nz b gy qa og l oh oi">plt.figure(figsize=(12, 8))<br/>plt.stem(degree_freq)<br/>plt.ylabel("Frequence")<br/>plt.xlabel("Degree")<br/>plt.show()</span></pre><p id="cf16" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了可视化分布，我在生成的图中将 n 增加到 200。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/19e3d9cd85b28c3d58ff203ab41447dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SiLik4ZgSzFxosVGLv8Jw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Degree Distribution</figcaption></figure><p id="842f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> c .描述性统计</strong></p><ul class=""><li id="3aa0" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">平均度数由 n×p 给出，p=0.2，n=200，我们以 40 为中心。</li><li id="feed" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">期望度数由(n1)×p 给出</li><li id="ead1" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">最大程度集中在平均值附近</li></ul><p id="179b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们用 Python 检索这些值:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="d88e" class="od oe it nz b gy of og l oh oi"># Get the list of the degrees<br/>degree_sequence_erdos = list(G_erdos.degree())<br/><br/>nb_nodes = n<br/>nb_arr = len(G_erdos.edges())<br/><br/>avg_degree = np.mean(np.array(degree_sequence_erdos)[:,1])<br/>med_degree = np.median(np.array(degree_sequence_erdos)[:,1])<br/><br/>max_degree = max(np.array(degree_sequence_erdos)[:,1])<br/>min_degree = np.min(np.array(degree_sequence_erdos)[:,1])<br/><br/>esp_degree = (n-1)*p<br/><br/>print("Number of nodes : " + str(nb_nodes))<br/>print("Number of edges : " + str(nb_arr))<br/><br/>print("Maximum degree : " + str(max_degree))<br/>print("Minimum degree : " + str(min_degree))<br/><br/>print("Average degree : " + str(avg_degree))<br/>print("Expected degree : " + str(esp_degree))<br/>print("Median degree : " + str(med_degree))</span></pre><p id="afe2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这应该会给你类似于:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="21ce" class="od oe it nz b gy of og l oh oi">Number of nodes : 200<br/>Number of edges : 3949<br/>Maximum degree : 56<br/>Minimum degree : 25<br/>Average degree : 39.49<br/>Expected degree : 39.800000000000004<br/>Median degree : 39.5</span></pre><p id="6675" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">平均学位和预期学位非常接近，因为两者之间只有一个很小的因素。</p><h2 id="8b3c" class="od oe it bd on qd qe dn or qf qg dp ov lm qh qi ox lq qj qk oz lu ql qm pb iz bi translated">2.巴拉巴斯-艾伯特模型</h2><p id="b6c7" class="pw-post-body-paragraph ld le it lf b lg pq kd li lj pr kg ll lm ps lo lp lq pt ls lt lu pu lw lx ly im bi translated"><strong class="lf jd"> a .定义</strong></p><p id="6221" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 Barabasi-Albert 模型中，我们建立了一个具有 n 个节点的<em class="pg">随机</em>图模型，该模型具有优先连接组件。该图由以下算法生成:</p><ul class=""><li id="4bbb" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">第一步:概率为 p，进入第二步。否则，转到第三步。</li><li id="0de6" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">第二步:将一个<strong class="lf jd">新节点</strong>连接到在<strong class="lf jd">随机选择的<strong class="lf jd">现有节点</strong></strong></li><li id="c76d" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">步骤 3:将新节点连接到 n 个现有节点，其概率<strong class="lf jd">与它们的度</strong>成比例</li></ul><p id="b533" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该图的目的是模拟在真实网络中经常观察到的<em class="pg">优先连接</em>。</p><p id="6781" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 Python 中，<code class="fe oj ok ol nz b">networkx</code>包还有一个生成 Barabasi-Albert 图的内置函数。</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="0baa" class="od oe it nz b gy of og l oh oi"># Generate the graph<br/>n = 150<br/>m = 3<br/>G_barabasi = nx.barabasi_albert_graph(n,m)</span><span id="3c39" class="od oe it nz b gy qa og l oh oi"># Plot the graph<br/>plt.figure(figsize=(12,8))<br/>nx.draw(G_barabasi, node_size=10)</span></pre><p id="e0dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您将得到与此非常相似的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qr"><img src="../Images/6a2c614d300c532ad694e1c9210e8dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTGzbCFI9WfWkPyk8Scbyw.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Barabasi-Albert Graph</figcaption></figure><p id="93bf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以很容易地注意到，现在一些节点的度数似乎比其他节点的度数大得多！</p><p id="191d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> b .学位分布</strong></p><p id="ee39" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">设 pk 随机选择的节点的度为 k 的概率。度分布遵循幂律:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qs"><img src="../Images/ccda00a84dfe181293a64e2e1f5a07af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXXbxvxJ3Rn5Na3bCnfv6Q.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Power-law degree distribution</figcaption></figure><p id="d913" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">分布现在是重尾的。有大量的节点具有较小的度数，但是有大量的节点具有较高的度数。</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="c5ed" class="od oe it nz b gy of og l oh oi">degree_freq = np.array(nx.degree_histogram(G_barabasi)).astype('float')</span><span id="aa25" class="od oe it nz b gy qa og l oh oi">plt.figure(figsize=(12, 8))<br/>plt.stem(degree_freq)<br/>plt.ylabel("Frequence")<br/>plt.xlabel("Degree")<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qt"><img src="../Images/15cb933dff482ce09e0746db2ea11f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucxPQG5sX62KqQOd-Q_vnA.png"/></div></div><figcaption class="pl pm gj gh gi pn po bd b be z dk">Degree Distribution</figcaption></figure><p id="d195" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这种分布被认为是无尺度的，也就是说，平均程度是没有信息的。</p><p id="38e9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> c .描述性统计</strong></p><ul class=""><li id="5cc8" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">如果α≤2，则平均度为常数，否则，平均度发散</li><li id="22c4" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">最大度数的顺序如下:</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/b02da75db2f741ae8065488433cc9dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*qdlY3c0aSOTG5abJn7Ab9w.png"/></div></figure><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="cb9e" class="od oe it nz b gy of og l oh oi"># Get the list of the degrees<br/>degree_sequence_erdos = list(G_erdos.degree())<br/><br/>nb_nodes = n<br/>nb_arr = len(G_erdos.edges())<br/><br/>avg_degree = np.mean(np.array(degree_sequence_erdos)[:,1])<br/>med_degree = np.median(np.array(degree_sequence_erdos)[:,1])<br/><br/>max_degree = max(np.array(degree_sequence_erdos)[:,1])<br/>min_degree = np.min(np.array(degree_sequence_erdos)[:,1])<br/><br/>esp_degree = (n-1)*p<br/><br/>print("Number of nodes : " + str(nb_nodes))<br/>print("Number of edges : " + str(nb_arr))<br/><br/>print("Maximum degree : " + str(max_degree))<br/>print("Minimum degree : " + str(min_degree))<br/><br/>print("Average degree : " + str(avg_degree))<br/>print("Expected degree : " + str(esp_degree))<br/>print("Median degree : " + str(med_degree))</span></pre><p id="c223" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这应该会给你类似于:</p><pre class="ks kt ku kv gt ny nz oa ob aw oc bi"><span id="1225" class="od oe it nz b gy of og l oh oi">Number of nodes : 200<br/>Number of edges : 3949<br/>Maximum degree : 56<br/>Minimum degree : 25<br/>Average degree : 39.49<br/>Expected degree : 39.800000000000004<br/>Median degree : 39.5</span></pre><h1 id="15a4" class="om oe it bd on oo op oq or os ot ou ov ki ow kj ox kl oy km oz ko pa kp pb pc bi translated">四。结论</h1><p id="f29b" class="pw-post-body-paragraph ld le it lf b lg pq kd li lj pr kg ll lm ps lo lp lq pt ls lt lu pu lw lx ly im bi translated">到目前为止，我们讨论了图的主要种类，以及描述图的最基本的特征。在下一篇文章中，我们将深入探讨图形分析/算法，以及分析图形的不同方式，用于:</p><ul class=""><li id="03f5" class="mi mj it lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">实时欺诈检测</li><li id="9026" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">实时推荐</li><li id="9cf3" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">简化法规遵从性</li><li id="e8cb" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">复杂网络的管理和监控</li><li id="f423" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">身份和访问管理</li><li id="1bae" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">社交应用/功能</li><li id="216f" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi">…</li></ul><p id="500c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您有任何问题或意见，请随时评论。</p><p id="fb6b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下一篇文章可以在这里找到:</p><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/graph-algorithms-part-2-dce0b2734a1d"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">图形算法(第二部分)</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">Python 中的主要概念、属性和应用</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="np l nl nm nn nj no lb na"/></div></div></a></div><h2 id="d73a" class="od oe it bd on qd qe dn or qf qg dp ov lm qh qi ox lq qj qk oz lu ql qm pb iz bi translated">来源:</h2><ul class=""><li id="0682" class="mi mj it lf b lg pq lj pr lm qv lq qw lu qx ly mn mo mp mq bi translated">Neo4j 中的图形算法综合指南</li><li id="326c" class="mi mj it lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">网络 x 文档，<a class="ae mw" href="https://networkx.github.io/documentation/stable/" rel="noopener ugc nofollow" target="_blank">https://networkx.github.io/documentation/stable/</a></li></ul><p id="7480" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你想从我这里读到更多，我以前的文章可以在这里找到:</p><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/markov-chains-and-hmms-ceaf2c854788"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">马尔可夫链和 hmm</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">在本文中，我们将关注马尔可夫模型，何时何地应该使用它们，以及隐马尔可夫模型。这个…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="qy l nl nm nn nj no lb na"/></div></div></a></div><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/a-guide-to-face-detection-in-python-3eab0f6b9fc1"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">Python 中的人脸检测指南</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">在本教程中，我们将看到如何使用 OpenCV 和 Dlib 在 Python 中创建和启动人脸检测算法。我们会…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="qz l nl nm nn nj no lb na"/></div></div></a></div><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/boosting-and-adaboost-clearly-explained-856e21152d3e"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">升压和 AdaBoost 解释清楚</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">直观的解释</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="ra l nl nm nn nj no lb na"/></div></div></a></div></div></div>    
</body>
</html>