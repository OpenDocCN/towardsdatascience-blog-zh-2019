<html>
<head>
<title>Python Exercise: Calculating All Possible Values Of A Hand of Aces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 练习:计算一手 A 牌的所有可能值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-exercise-calculating-all-possible-values-of-a-hand-of-aces-98a218dbd0f7?source=collection_archive---------22-----------------------#2019-09-26">https://towardsdatascience.com/python-exercise-calculating-all-possible-values-of-a-hand-of-aces-98a218dbd0f7?source=collection_archive---------22-----------------------#2019-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/488065b185cff379b504945c2096bffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mf3cGg078p8mq7PkJp4Njw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="50e2" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">这比我最初想的更有趣/复杂，因此写了这篇文章</h2></div><p id="6ef2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di">我</span>最近发表了一篇关于如何用 Python 模拟 21 点的博客。我仍然在做那个博客的后续工作，但是我想在那里得到这个免费的帖子。</p><p id="ee8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在<a class="ae ly" rel="noopener" target="_blank" href="/lets-play-blackjack-with-python-913ec66c732f">我发表了我最初的 21 点帖子</a>后不久，Twitter 用户@DonBeham 友好地指出，在某些情况下(因为 ace)，我的代码产生的手牌值将是错误的。</p><p id="5642" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以我去修复我的错误，并意识到计算 ace 值比我最初想象的要复杂得多。我们来探究一下原因。</p><p id="0336" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可以在我的 GitHub 上找到下面的代码以及我的 21 点代码<a class="ae ly" href="https://github.com/yiuhyuk/blackjack" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="49bb" class="mg mh je bd mi mj mk ml mm mn mo mp mq kk mr kl ms kn mt ko mu kq mv kr mw mx bi translated">挑战</h1><blockquote class="my"><p id="5ae1" class="mz na je bd nb nc nd ne nf ng nh lo dk translated">写一个函数来计算一手牌的 21 点数值。</p></blockquote><p id="4cef" class="pw-post-body-paragraph kt ku je kv b kw ni kf ky kz nj ki lb lc nk le lf lg nl li lj lk nm lm ln lo im bi translated">似乎很简单。</p><p id="a4aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">除了 a 可以值 1 分或 11 分，这取决于你手牌其余部分的价值。如果你的其他牌值 9 分，那么 a 值 11 分，这样你总共有 20 分。另一方面，如果你的其他牌值 19 分，a 现在值 1 分，这仍然给你 20 分。</p><p id="a5ec" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">听起来不算太糟，对吧。让我们看看复杂性是从哪里来的:</p><ol class=""><li id="3862" class="nn no je kv b kw kx kz la lc np lg nq lk nr lo ns nt nu nv bi translated">一手牌可以有任意数量的 a。鉴于赌场通常使用至少六副牌的牌叠，你最终可能拿到三张、四张甚至五张 a，这是非常不可能的，但肯定不是不可能的。所以我们需要逻辑来解释这些罕见的情况。</li><li id="05df" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo ns nt nu nv bi translated">你手中 a 的价值不仅取决于你拿到 a 时已经有的牌，还取决于你将来会拿到的牌。例如，如果你的手牌是[a，7]，那么它现在值 11+7=18 点。你得到一张王牌，这是一手更新的[王牌，7，王牌]——你的牌值增加到 11+7+1 = 19；不太复杂，因为我们知道，我们获得的每一个额外的 ace 都只值 1 分(因此我们不会超过 21 分)。现在，让我们把它变得更复杂一点——你拿到一张 5，给你[a，7，a，5]。保持之前的 ace 值 11 和 1，我们的手牌值为 11+7+1+5=24。这将超过 21，因此破产，所以现在我们拥有的每张 a 应该只值 1 分。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="351a" class="mg mh je bd mi mj mk ml mm mn mo mp mq kk mr kl ms kn mt ko mu kq mv kr mw mx bi translated">二十一点解决方案</h1><p id="c839" class="pw-post-body-paragraph kt ku je kv b kw ob kf ky kz oc ki lb lc od le lf lg oe li lj lk of lm ln lo im bi translated">针对 21 点的解决方案还不算太差。事情是这样的:</p><ul class=""><li id="fd6d" class="nn no je kv b kw kx kz la lc np lg nq lk nr lo og nt nu nv bi translated">如果我们手中没有 a，那么 a 的值显然为零——首先我们需要检查这一点。</li><li id="a8eb" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">我们知道我们手里的 a 只有一张能值 11 分。否则我们会破产——例如，11+11=22。</li><li id="81c5" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">因此，如果我们手里一张王牌值 11，其他值 1 的牌总数小于或等于 21，那么保留当前的王牌值(其中一张值 11，其余值 1)。</li><li id="f72a" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">否则，如果一张 a 值 11，其他值 1 的手牌总数大于 21，则将所有 a 值设为 1。</li></ul><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="45a6" class="oq mh je om b gy or os l ot ou">#Check if the value of non-ace cards plus aces with one ace worth 11 #and the rest worth 1 is less than or equal to 21</span><span id="b0a8" class="oq mh je om b gy ov os l ot ou">if num_aces &gt; 0:<br/>    if non_ace_total + 11 + (num_aces - 1)*1 &lt;= 21:<br/>        ace_value = 11 + (num_aces - 1)*1<br/>    else:<br/>        ace_value = num_aces*1<br/>else:<br/>    ace_value = 0<br/>    <br/>hand_total = non_ace_total + ace_value</span></pre><p id="641d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">很简单。但是，除了 21 点以外，还有什么更通用的解决方案呢？现在，我们知道只有一张 a 值 11，这对我们很有帮助。但是如果破产的门槛本身就是一个可变的变量呢？你也许仍然可以用一堆“如果语句”来做这件事，但是会很麻烦。相反，让我们写一个更一般的解决方案。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="32cc" class="mg mh je bd mi mj mk ml mm mn mo mp mq kk mr kl ms kn mt ko mu kq mv kr mw mx bi translated">广义解</h1><p id="3f7b" class="pw-post-body-paragraph kt ku je kv b kw ob kf ky kz oc ki lb lc od le lf lg oe li lj lk of lm ln lo im bi translated">让我们试着想出一个更通用的解决方案。我想到的是用树。</p><ul class=""><li id="0098" class="nn no je kv b kw kx kz la lc np lg nq lk nr lo og nt nu nv bi translated">我想找出 ace 值的所有排列。例如，对于两个 ace，它将是[1，1]，[1，11]，[11，1]，[11，11]。我实际上想找到 ace 值的所有组合，但我发现先得到排列，然后过滤掉重复的更容易。</li><li id="482a" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">然后我把它们加起来——2，12，12，22。</li><li id="99ca" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">最后，我想要唯一的值— 2，12，22。从这组值中，我可以选择最符合我的游戏规则的数字。</li></ul><p id="8e69" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那么我们如何得到所有的排列呢？我首先想到的是嵌套的 for 循环。但这只有在你预先知道有多少个 ace 的情况下才有效，例如，如果你有 3 个 ace，那么你需要循环 A，B 和 C，其中 C 嵌套在 B 中，B 又嵌套在 A 中。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="f60c" class="oq mh je om b gy or os l ot ou">ace_values = []</span><span id="6a52" class="oq mh je om b gy ov os l ot ou">for A in [1,11]:<br/>    for B in [1,11]:<br/>        for C in [1,11]:<br/>            ace_values.append(A+B+C)</span><span id="b887" class="oq mh je om b gy ov os l ot ou">unique_ace_values = set(ace_values)</span></pre><p id="db90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但关键是我们不知道会有多少个 a——所以我们不知道我们需要多少个 for 循环。</p><p id="5073" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我的回答是用一棵树。我们可以把每个 ace 看作两个分支(如果我的树术语不正确，我道歉)，其中第一个分支对应于 1，第二个分支对应于 11。如果我们持有第二张 a，那么每个分支再次分裂，因此总共有 4 个叶节点，对应于手牌值 2、12、12 和 22。下图显示了我刚才描述的两个 ace 案例。</p><figure class="oh oi oj ok gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/686261782002c977bf7f38718eda048a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*3xlg8a21uei6OP5ALXIJDw.jpeg"/></div><figcaption class="ox oy gj gh gi oz pa bd b be z dk">Using a tree to find all permutations for two aces</figcaption></figure><p id="e37f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">使用我们的树结构，我们可以通过遍历树直到到达每个叶节点来得到每个排列:</p><ol class=""><li id="734d" class="nn no je kv b kw kx kz la lc np lg nq lk nr lo ns nt nu nv bi translated">向上，向上—在第一次分割时获取 1，然后在叶节点再次获取 1。</li><li id="8b0d" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo ns nt nu nv bi translated">向上，向下—得到 1，然后是 11。</li><li id="7bbc" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo ns nt nu nv bi translated">向下，向上—得到 11，然后是 1。</li><li id="6cfc" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo ns nt nu nv bi translated">向下，向下——得到 11 个，然后 11 个。</li></ol><p id="7701" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那么如何用 Python 代码实现这一点呢？受过传统训练的计算机科学家可能会创建一个树类，然后递归地遍历它。但那是周日晚上，我不是递归的大师，所以我用快速而肮脏的方法遍历了我的树。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="22bc" class="mg mh je bd mi mj mk ml mm mn mo mp mq kk mr kl ms kn mt ko mu kq mv kr mw mx bi translated">遍历树</h1><p id="2c78" class="pw-post-body-paragraph kt ku je kv b kw ob kf ky kz oc ki lb lc od le lf lg oe li lj lk of lm ln lo im bi translated">下面是我的代码。我会一步一步地教你。</p><p id="edb4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第一个块是主要功能。它将 ace 的数量作为一个整数变量 num_aces，创建一个名为 temp_list 的列表，然后将该列表传递给一个助手函数 get_ace_values，该函数产生最终结果。在我传递给 get_ace_values 的列表变量 temp_list 中，每个 ace 都表示为[1，11] —所以如果有三个 ace，temp_list = [[1，11]，[1，11]，[1，11]]。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="a3d8" class="oq mh je om b gy or os l ot ou"># Convert num_aces, an int to a list of lists<br/># For example if num_aces=2, the output should be [[1,11],[1,11]]<br/># I require this format for the get_ace_values function</span><span id="5201" class="oq mh je om b gy ov os l ot ou">def ace_values(num_aces):<br/>    temp_list = []<br/>    for i in range(num_aces):<br/>        temp_list.append([1,11])<br/>    return get_ace_values(temp_list)</span></pre><p id="dff8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在该迭代了。我没有递归地遍历树，而是将树重新想象成一个数组，其中每一行对应于树的一次端到端遍历。这是三张 a 的情况:</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="4b0b" class="oq mh je om b gy or os l ot ou">[[ 1.  1.  1.]     # up, up, up<br/> [ 1.  1. 11.]     # up, up, down<br/> [ 1. 11.  1.]     # up, down, up<br/> [ 1. 11. 11.]     # up, down, down<br/> [11.  1.  1.]     # down, up, up<br/> [11.  1. 11.]     # down, up, down<br/> [11. 11.  1.]     # down, down, up<br/> [11. 11. 11.]]    # down, down, down</span></pre><p id="bd9d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你看到模式了吗？首先，遍历树有 2 = 8 种可能的方式(因为有三个 ace)。在我们的数组的第一列中，数字每四个元素切换一次(从 1 到 11)。在第二列中，它们每两个交换一次。在最后一栏，他们转换了所有元素。</p><p id="e1bd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面是我的 get_ace_values 函数的代码。这肯定不是最优雅的解决方案。我在下面的项目符号中解释了它是如何工作的。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="fe4f" class="oq mh je om b gy or os l ot ou">def get_ace_values(temp_list):<br/>    sum_array = np.zeros((2**len(temp_list), len(temp_list)))<br/>    # This loop gets the permutations<br/>    for i in range(len(temp_list)):<br/>        n = len(temp_list) - i<br/>        half_len = int(2**n * 0.5)<br/>        for rep in range(int(sum_array.shape[0]/half_len/2)):<br/>            sum_array[rep*2**n : rep*2**n+half_len, i]=1<br/>            sum_array[rep*2**n+half_len : rep*2**n+half_len*2, i]=11<br/>    return [int(s) for s in np.sum(sum_array, axis=1)]</span></pre><ul class=""><li id="6e7c" class="nn no je kv b kw kx kz la lc np lg nq lk nr lo og nt nu nv bi translated">第一个 for 循环运行的次数等于我们拥有的 ace 数 temp _ list 的长度等于我们拥有的 ace 数。for 循环的每一次运行都会产生 sum_array 的一列，即我上面描述的数组。</li><li id="fa3c" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">变量 n 只是从 ace 的数量开始向下计数，一直到 1。例如，如果有三个 ace，n 将从 3 开始，然后在第二次循环中减少到 2，最后在 1 结束。</li><li id="bbfd" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">变量 half_len 告诉我们在切换到打印 11 之前连续打印 1 的次数(相同的次数)。如果你还记得我在上面给你看的 sum_array 矩阵，在第一列，我们打印了四个 1 后面跟着四个 11。因此，对于 for 循环的第一次运行(对于三个 ace 的情况)，half_len 等于 2 * 0.5 = 4。在第二列中，我们每两个元素交换一次，因此 half_len 等于 2 * 0.5 = 2。</li><li id="7bf2" class="nn no je kv b kw nw kz nx lc ny lg nz lk oa lo og nt nu nv bi translated">对于三个 ace 的情况，第二个 For 循环(嵌套循环)在外部 for 循环的第一次运行时运行一次，在外部循环的第二次运行时运行两次，最后在外部循环的最后一次运行时运行四次。这个嵌套循环用于在我们需要的地方打印 1 和 11。</li></ul><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="9715" class="oq mh je om b gy or os l ot ou">THREE ACE CASE</span><span id="714d" class="oq mh je om b gy ov os l ot ou">In the first run of the outer loop, since half_len=4, the nested for loop runs once (8/half_len/2 = 1) and prints four 1s followed by four 11s onto sum_array:<br/>[[ 1.  0.  0.]<br/> [ 1.  0.  0.]<br/> [ 1.  0.  0.]<br/> [ 1.  0.  0.]<br/> [11.  0.  0.]<br/> [11.  0.  0.]<br/> [11.  0.  0.]<br/> [11.  0.  0.]]</span><span id="431c" class="oq mh je om b gy ov os l ot ou">In the second run of the outer loop, since half_len=2, the nested for loop runs twice (8/half_len/2 = 2), each time printing two 1s followed by two 11s onto sum_array:<br/>[[ 1.  1.  0.]<br/> [ 1.  1.  0.]<br/> [ 1. 11.  0.]<br/> [ 1. 11.  0.]<br/> [11.  1.  0.]<br/> [11.  1.  0.]<br/> [11. 11.  0.]<br/> [11. 11.  0.]]</span><span id="b332" class="oq mh je om b gy ov os l ot ou">In the third run of the outer loop, since half_len=1, the nested for loop runs four times (8/half_len/2 = 4), each time printing a 1 followed by a 11 onto sum_array:<br/>[[ 1.  1.  1.]<br/> [ 1.  1. 11.]<br/> [ 1. 11.  1.]<br/> [ 1. 11. 11.]<br/> [11.  1.  1.]<br/> [11.  1. 11.]<br/> [11. 11.  1.]<br/> [11. 11. 11.]]</span></pre><ul class=""><li id="1c3e" class="nn no je kv b kw kx kz la lc np lg nq lk nr lo og nt nu nv bi translated">差不多了 sum _ array 的每一行现在都可以用来表示我们的树的一个端到端遍历，这意味着每一行都是一个排列。所以我们要做的就是取 sum_array 中每行的和，得到所有可能的 ace 值。</li></ul><p id="3870" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们为三种 ace 情况运行 ace_values:</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="eb02" class="oq mh je om b gy or os l ot ou">Running:<br/>  ace_values(3)</span><span id="d536" class="oq mh je om b gy ov os l ot ou">Produces:<br/>  [3, 13, 13, 23, 13, 23, 23, 33]</span><span id="7c77" class="oq mh je om b gy ov os l ot ou">Taking the set of this:<br/>  set(ace_values(3))</span><span id="a7db" class="oq mh je om b gy ov os l ot ou">Produces what we want:<br/>  {3, 13, 23, 33}</span></pre><p id="c1df" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我很喜欢编码，但是我还有很多要学的，所以我会经常发表这样的散漫的文章。请原谅我。</p><p id="175a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">干杯，下次再见！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="f53c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"><em class="pb"/></strong>我最近的一些帖子，希望你能看看</p><p id="11ce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/lets-play-blackjack-with-python-913ec66c732f"> <em class="pb">让我们玩 21 点(用巨蟒)</em> </a></p><p id="3cba" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/is-your-company-truly-data-driven-2cf5feaa3cfb"> <em class="pb">你的公司真的是数据驱动的吗？</em>T3】</a></p><p id="eec7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/how-much-do-data-scientists-make-cbd7ec2b458"> <em class="pb">数据科学家挣多少钱？</em> </a></p><p id="bfd7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/how-much-do-data-scientists-make-part-2-cb959a0d05f"> <em class="pb">数据科学家挣多少钱第二部</em> </a></p><p id="5726" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/how-much-do-software-engineers-make-60565f50f579"> <em class="pb">软件工程师挣多少钱？</em>T15】</a></p><p id="fe54" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/a-better-way-to-skill-up-b2e5ee87dd0a"> <em class="pb">技能提升的更好方法</em> </a></p></div></div>    
</body>
</html>