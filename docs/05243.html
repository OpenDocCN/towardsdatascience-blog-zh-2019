<html>
<head>
<title>Logistic regression from very scratch in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中从头开始的逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-from-very-scratch-ea914961f320?source=collection_archive---------20-----------------------#2019-08-05">https://towardsdatascience.com/logistic-regression-from-very-scratch-ea914961f320?source=collection_archive---------20-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2ca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我一直在发表关于从零开始实现的文章。这一次是为了逻辑回归！让我们开始吧！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3f61f2fb5d47492f8768d947c648d42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GAozmYs0eK-TGTga"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@miklevasilyev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mikhail Vasilyev</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5c49" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">逻辑回归</h1><p id="415a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">逻辑回归用于二元分类。你可以训练你的模型来预测某人是否是癌症，或者你的模型可以被训练来预测照片中的人是否是猫。</p><h1 id="a20e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">等式实现</h1><p id="e1fd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">你还记得那个等式吗:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/615f7a51ee33c51a3d0729e7cc5eebd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*bwpj7VKRwJr2-YVdZzwE3g.png"/></div></figure><p id="c356" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是用于回归的。但是这产生了大的数字，而我们希望输出是 1 或 0(癌症与否)。在这种情况下，乙状结肠功能就发挥作用了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/f8ed2abf5a02c929358402f0c0eed116.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*Y_6HQdcTBWou0ObYvzV_gA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">sigmoid function graph</figcaption></figure><p id="c163" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您输入 z 时，sigmoid 函数产生 0 到 1 之间的值。上面给出了 z。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/0547c6a52170bf5ef93db95e2b83ce14.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*gyd9Tk_UnqP2wYq_nj_4_Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">sigmoid function</figcaption></figure><p id="f1eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是 sigmoid 函数在 Python 中的实现方式:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这个功能，我们的输出将在 0 和 1 之间。</p><h1 id="1daf" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">损失和成本函数</h1><p id="741c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">假设您的训练集有许多训练示例。你想计算你的模型做得有多好。损失和成本函数开始起作用。损失函数是仅用于训练示例的损失。代价函数是整个训练集的损失。</p><p id="10d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多损失函数可以选择使用。我会用这个:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/4b032ac4e11669aaddfeff4bf23a5808.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*QCZi0Fbt7yox_S1AXvA0OQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">s(z): sigmoid of z. p: predictions</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/4805d06084738d9a2b89f97ad35c1c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiimnwkdfwPBxLaGyRmzgw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">loss function</figcaption></figure><p id="721f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在损失函数中，<strong class="js iu"> p </strong>是我们的预测值，<strong class="js iu"> y </strong>是实际值。为了便于讨论，我们只有权重参数，成本函数的图形如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/054c08109873121470c8f543cde96228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jw0uVjr_Nu9PzZAQXDqUSA.png"/></div></div></figure><p id="0395" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望我们的成本尽可能低。从图中，我们想找到全局最小值。为此将使用梯度下降算法。我们将找到该图的斜率(导数),并更新我们的权重(w)和偏差(b ),以使成本最小。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a1d01f2c1cfd9d1dc3ac4367ba412090.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*90j4ZhcK7YjT--ZkN4TIHA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">updating parameters</figcaption></figure><p id="b0c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了更新权重和偏差，我们将使用上面的等式。(:=)是顺便更新的意思。我们知道 b 和 w，但是如何找到<strong class="js iu"> db </strong>和<strong class="js iu"> dw 呢？让我们做些数学计算。</strong></p><h1 id="e2b0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让我们找到 db 和 dw</h1><p id="2a37" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">记住我们的目标是使成本最小化。所以我们想找到使成本最小的参数。我们可以通过对损失函数关于参数求导来实现。那就更新我们的参数！我们将利用链式法则来计算损失函数对参数的导数。所以我们将首先找到损失函数对 p 的导数，然后是 z，最后是参数。</p><p id="d5eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们记住损失函数:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/4805d06084738d9a2b89f97ad35c1c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiimnwkdfwPBxLaGyRmzgw.png"/></div></div></figure><p id="20f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在取导数损失函数之前。让我告诉你如何取导数对数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/66d3b0278cf78e6927c29eb234e65e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*hm9p5Q1nwkaDh3uRjUn-QA.png"/></div></figure><p id="2da1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们首先找到损失函数相对于<strong class="js iu"> p </strong>(预测)<strong class="js iu"> </strong>的导数，以便能够对 dz 求导。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/6c3c0bf36d28d18e39da509f9da4917d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZg5V_UD-R19tqXM_fhfuA.png"/></div></div></figure><p id="a669" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们刚刚找到了关于 p 的导数，现在我们可以计算关于 z 的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/c02ea3b400abd3eeca5b5153b80d4007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW7shOJq-NtTpYgqKeqG6A.png"/></div></div></figure><p id="98ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还没完。我们找到了损失函数对 p 和 z 的导数，现在我们可以对 w 和 b 做同样的事情来更新参数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/58265fde6dad10c45ff3dd67a8fa8113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIJO3EAgZv84zB9GunwT4A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">db</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/930b1d312ddcdda4378ddded8472a9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALQZtIB3pIL_FwbUiSw_jw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">dw</figcaption></figure><p id="c189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们刚找到 db 和 dw。好消息…我们现在可以更新参数了。</p><h1 id="8e8c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">多合一</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5e0219f9f8ec77a02b093a2f6b7ac23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*iyHYnAHi-FoZVz8eCr-jmw.png"/></div></figure><p id="106d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用 Python 来实现它:</p><p id="c073" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将使用<a class="ae le" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> sci-kit learn </a>创建一个数据集。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/5a33ebb417d64a07a07437a6e462058b.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*feKx2eOu2mxNm0mhuxRTuA.png"/></div></div></figure><p id="b6db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它看起来像我们所期待的。</p><h1 id="20fd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">预言；预测；预告</h1><p id="193f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果你想让你的模型预测。你可以这样做。从上面的代码中，假设你找到了 p，它将在 0 和 1 之间。假设输出为 0.85。<strong class="js iu">是 0(不是癌症)还是 1(癌症)？</strong>由你决定。如果你说，你的门槛是 0.8。作为 0.85 &gt; 0.8(你的门槛)，你的模型说 1(癌症)。就像添加一个 if 条件一样简单。</p><p id="3d01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读！喜欢就鼓掌，跟着我上<a class="ae le" href="https://github.com/halilibrahim95" rel="noopener ugc nofollow" target="_blank"> github </a>。</p></div></div>    
</body>
</html>