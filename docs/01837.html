<html>
<head>
<title>Beat Cache Invalidation in ASP.NET Core Using Kafka and Debezium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Kafka 和 Debezium 的 ASP.NET 核心中的节拍缓存失效</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beat-cache-invalidation-in-asp-net-core-using-kafka-and-debezium-65cd1d80554d?source=collection_archive---------7-----------------------#2019-03-26">https://towardsdatascience.com/beat-cache-invalidation-in-asp-net-core-using-kafka-and-debezium-65cd1d80554d?source=collection_archive---------7-----------------------#2019-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构建 web 应用程序时，我们大部分时间使用缓存来存储(昂贵的)数据库查询的结果。一段时间后，由于我们的底层数据库状态发生了变化，我们希望删除或替换缓存条目。一个被称为<strong class="jp ir">缓存失效</strong>的过程。问题是<em class="kl">我们什么时候必须移除或替换缓存条目</em>？答案是每当底层数据库记录发生变化时。但是数据可能会被我们无法控制的过程所改变。</p><p id="a50b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们可以订阅数据库记录发生的任何更改事件(插入、更新和删除),那么我们就可以成功地实时使相关的缓存条目无效。好消息是大多数数据库都会发布它们的插入、更新和移除事件。这项功能称为变更数据捕获(CDC)。</p><h1 id="eefd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="381a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在本文中，我想向您展示我们如何使用 CDC 来订阅任何更改 MySQL 数据库记录的事件，并将每个事件作为单独的消息发布给 Apache Kafka。<a class="ae lp" href="https://debezium.io/" rel="noopener ugc nofollow" target="_blank"> Debezium </a>是一个让这一切成为可能的平台。然后，我们使用这些事件在 ASP.NET 核心中构建内存缓存。我们将看到如何基于我们的实时缓存构建我们的 REST API。</p><p id="f062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这类似于复制在数据库中的工作方式。在复制中，辅助副本订阅主副本上的任何事务(更改事件),并将该事务应用于自己的数据库记录，这样，辅助数据库状态最终将等同于主数据库状态。如图所示，我们将 Kafka 集群订阅为数据库的副本，并处理更改事件以构建我们的缓存:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/4cf4c380f4c1096232ec91bb769520a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsGuKwfElLHs3udHWUk5WQ.jpeg"/></div></div></figure><p id="4081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法不仅解决了缓存失效，还解决了其他问题，如竞争条件和缓存热启动，正如 Martin Kleppmann 在他的文章<a class="ae lp" href="https://martin.kleppmann.com/2015/03/04/turning-the-database-inside-out.html" rel="noopener ugc nofollow" target="_blank">Turning the database inside-out</a>中所描述的。</p><p id="c5a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的源代码可以在<a class="ae lp" href="https://github.com/Mousavi310/kafka-cache" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。</p><h1 id="9105" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">先决条件</h1><ul class=""><li id="013f" class="mc md iq jp b jq lk ju ll jy me kc mf kg mg kk mh mi mj mk bi translated">。网络核心 2.2</li><li id="aa38" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">docker 和 docker-撰写</li></ul><h1 id="f76f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">启动 Docker 服务</h1><p id="25c7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将使用 Docker 设置我们的 Apache Kafka 集群、MySQL 数据库和 Debezium 连接器(我们将很快讨论它)。首先，用以下内容创建一个<code class="fe mq mr ms mt b">docker-compose.yml</code>文件:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="31e4" class="my kn iq mt b gy mz na l nb nc">version: '3.1'</span><span id="0862" class="my kn iq mt b gy nd na l nb nc">services:</span><span id="f829" class="my kn iq mt b gy nd na l nb nc">mysql:<br/>    image: mysql:5.7<br/>    environment:<br/>      MYSQL_ROOT_PASSWORD: 123456<br/>      MYSQL_USER: mysql<br/>    volumes:<br/>      - ./my.cnf:/etc/mysql/my.cnf<br/>    ports:<br/>      - 3306:3306</span><span id="55b2" class="my kn iq mt b gy nd na l nb nc">zookeeper:<br/>    image: confluentinc/cp-zookeeper<br/>    ports:<br/>      - "2181:2181"<br/>    environment:<br/>      ZOOKEEPER_CLIENT_PORT: 2181</span><span id="43a8" class="my kn iq mt b gy nd na l nb nc">kafka:<br/>    image: confluentinc/cp-kafka<br/>    depends_on:<br/>      - zookeeper<br/>      - mysql<br/>    ports:<br/>      - "9092:9092"<br/>    environment:<br/>      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181<br/>      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092<br/>      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1<br/>      KAFKA_LOG_CLEANER_DELETE_RETENTION_MS: 5000<br/>      KAFKA_BROKER_ID: 1<br/>      KAFKA_MIN_INSYNC_REPLICAS: 1</span><span id="b436" class="my kn iq mt b gy nd na l nb nc">connector:<br/>    image: debezium/connect:0.10<br/>    ports:<br/>      - "8083:8083"<br/>    environment:<br/>      GROUP_ID: 1<br/>      CONFIG_STORAGE_TOPIC: my_connect_configs<br/>      OFFSET_STORAGE_TOPIC: my_connect_offsets<br/>      BOOTSTRAP_SERVERS: kafka:9092<br/>    depends_on:<br/>      - zookeeper<br/>      - mysql<br/>      - kafka</span></pre><p id="526b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lp" href="https://github.com/Mousavi310/kafka-cache/blob/master/my.cnf" rel="noopener ugc nofollow" target="_blank"> my.cnf </a>文件启用 MySQL 的 CDC 特性。现在启动所有 docker 服务:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="3409" class="my kn iq mt b gy mz na l nb nc">docker-compose up</span></pre><h1 id="5230" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建 MySQL 数据库</h1><p id="c1bd" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">打开同一路径中的另一个终端，连接到 MySQL 容器并运行 MySQL CLI:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="b079" class="my kn iq mt b gy mz na l nb nc">docker-compose exec mysql bash -c 'mysql -u root -p$MYSQL_ROOT_PASSWORD'</span></pre><p id="40ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们想在 MySQL 中创建一个数据库。运行下面的脚本来创建一个名为<code class="fe mq mr ms mt b">mystore</code>的数据库，一个名为<code class="fe mq mr ms mt b">products</code>的表，并在<code class="fe mq mr ms mt b">products</code>表中插入一个简单的记录:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="6ca5" class="my kn iq mt b gy mz na l nb nc">create database mystore;<br/>use mystore;<br/>create table products (id int unsigned auto_increment primary key, name varchar(50), price int, creation_time datetime default current_timestamp, modification_time datetime on update current_timestamp);<br/>insert into products(name, price) values("Red T-Shirt", 12);</span></pre><h1 id="e8a1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建 Debezium 连接器</h1><p id="bc47" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在，我们希望将 products 表中发生的所有更改都转移到 Kafka。为此，我们必须创建一个<strong class="jp ir">连接器</strong>。连接器是一个应用程序，负责将数据从数据库(或任何其他存储系统)移动到 Kafka 集群(反之亦然)。如果你不熟悉 Kafka connector，你可以阅读<a class="ae lp" href="https://www.confluent.io/connectors/" rel="noopener ugc nofollow" target="_blank">合流文档</a>。这里我们想将 MySQL 变更事件转移到 Apache Kafka 集群。Debezium 是一个 Kafka 连接器，可以从 MySQL(和其他一些数据库)中读取所有变更事件，并将它们发布到 Kafka:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ne"><img src="../Images/edf6f4b43523012e4a6e87aae5950c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fu-AmBOvNDU3aCXOxxu-A.jpeg"/></div></div></figure><p id="115f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Debezium 公开了一个 REST API 来创建连接器。因此，要创建一个 Debezium 连接器，打开另一个终端并运行下面的脚本(大部分配置是不言自明的，但要了解更多信息，请阅读<a class="ae lp" href="https://vladmihalcea.com/how-to-extract-change-data-events-from-mysql-to-kafka-using-debezium/" rel="noopener ugc nofollow" target="_blank"> Debezium MySQL 教程</a>):</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="6ebd" class="my kn iq mt b gy mz na l nb nc">curl -i -X POST -H "Accept:application/json"<!-- --> <!-- -->-H "Content-Type:application/json"<!-- --> localhost<!-- -->:8083/connectors/<!-- --> <!-- -->-d '{ "name": "mystore-connector", "config": { "connector.class": "io.debezium.connector.mysql.MySqlConnector", "tasks.max": "1", "database.hostname": "<!-- -->mysql<!-- -->", "database.port": "3306", "database.user": "root", "database.password": "123456", "database.server.id": "<!-- -->223345<!-- -->", "database.server.name": "<!-- -->mysql<!-- -->", "database.whitelist": "mystore", "database.history.kafka.bootstrap.servers": "kafka:9092", "database.history.kafka.topic": "dbhistory.mystore",<br/>"transforms":"unwrap","transforms.unwrap.type":"io.debezium.transforms.UnwrapFromEnvelope","transforms.unwrap.drop.tombstones":"false","key.converter": "org.apache.kafka.connect.json.JsonConverter","key.converter.schemas.enable": "false","value.converter": "org.apache.kafka.connect.json.JsonConverter","value.converter.schemas.enable": "false","include.schema.changes": "false"} }'</span></pre><p id="d05e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您收到<code class="fe mq mr ms mt b">HTTP/1.1 201 Created</code>，您的连接器已经成功创建。您还可以检查连接器的状态:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="0f00" class="my kn iq mt b gy mz na l nb nc">curl localhost:8083/connectors/mystore-connector/status</span><span id="d39a" class="my kn iq mt b gy nd na l nb nc">{<br/>  "name": "mystore-connector",<br/>  "connector": {<br/>    "state": "RUNNING",<br/>    "worker_id": "172.24.0.5:8083"<br/>  },<br/>  "tasks": [<br/>    {<br/>      "id": 0,<br/>      "state": "RUNNING",<br/>      "worker_id": "172.24.0.5:8083"<br/>    }<br/>  ],<br/>  "type": "source"<br/>}</span></pre><p id="e919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">state</code>字段中的<code class="fe mq mr ms mt b">Running</code>值表示您的连接器正在工作。现在让我们检查一下，任何数据库更改都将被同步到 Kafka。首先，连接到 Kafka 容器:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="ca6c" class="my kn iq mt b gy mz na l nb nc">docker-compose exec kafka bash</span></pre><p id="baf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并查看主题列表:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="26f0" class="my kn iq mt b gy mz na l nb nc">kafka-topics --zookeeper zookeeper:2181 --list</span><span id="5ae8" class="my kn iq mt b gy nd na l nb nc">__confluent.support.metrics<br/>__consumer_offsets<br/>connect-status<br/>dbhistory.mystore<br/>my_connect_configs<br/>my_connect_offsets<br/>mysql<br/>mysql.mystore.products</span></pre><p id="7bad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">mysql.mystore.products</code>主题存储<code class="fe mq mr ms mt b">products</code>表的变更事件。我们可以使用下面的脚本读取该主题中的消息(消息键由<code class="fe mq mr ms mt b">-</code>分隔):</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="1e16" class="my kn iq mt b gy mz na l nb nc">kafka-console-consumer --bootstrap-server kafka:9092 --from-beginning --topic mysql.mystore.products --property print.key=true --property key.separator="-"</span><span id="4c37" class="my kn iq mt b gy nd na l nb nc">{"id":1}-{"id":1,"name":"Red T-Shirt","price":12,"creation_time":1553595845000,"modification_time":null}</span></pre><p id="36ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查更改是否会(接近)实时同步，请在 MySQL 容器中添加另一条记录:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="cedb" class="my kn iq mt b gy mz na l nb nc">insert into products(name, price) values("Blue Hat", 5);</span></pre><p id="17c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更改将立即显示在用户终端上:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="825b" class="my kn iq mt b gy mz na l nb nc">{"id":1}-{"id":1,"name":"Red T-Shirt","price":12,"creation_time":1553595845000,"modification_time":null}<br/><strong class="mt ir">{"id":2}-{"id":2,"name":"Blue Hat","price":5,"creation_time":1553595958000,"modification_time":null}</strong></span></pre><p id="f7d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新“蓝帽子”记录:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="79c6" class="my kn iq mt b gy mz na l nb nc">update products set price = 17 where name = "Blue Hat";</span></pre><p id="f3a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发布更新事件:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="41ea" class="my kn iq mt b gy mz na l nb nc">{"id":1}-{"id":1,"name":"Red T-Shirt","price":12,"creation_time":1553595845000,"modification_time":null}<br/>{"id":2}-{"id":2,"name":"Blue Hat","price":5,"creation_time":1553595958000,"modification_time":null}<br/><strong class="mt ir">{"id":2}-{"id":2,"name":"Blue Hat","price":17,"creation_time":1553595958000,"modification_time":1553595986000}</strong></span></pre><p id="6bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除 id 为 1 的记录:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="44d7" class="my kn iq mt b gy mz na l nb nc">delete from products where id = 1;</span></pre><p id="f884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有空值的消息将被添加到主题:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="2f8a" class="my kn iq mt b gy mz na l nb nc">{"id":1}-{"id":1,"name":"Red T-Shirt","price":12,"creation_time":1553595845000,"modification_time":null}<br/>{"id":2}-{"id":2,"name":"Blue Hat","price":5,"creation_time":1553595958000,"modification_time":null}<br/>{"id":2}-{"id":2,"name":"Blue Hat","price":17,"creation_time":1553595958000,"modification_time":1553595986000}<br/><strong class="mt ir">{"id":1}-null</strong></span></pre><p id="c3ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> </em>空值表示记录被删除。让我们添加一个名为<code class="fe mq mr ms mt b">description</code>的列:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="d01d" class="my kn iq mt b gy mz na l nb nc">alter table products add column description nvarchar(1000);</span></pre><p id="c982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新产品记录:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="b766" class="my kn iq mt b gy mz na l nb nc">update products set description = "Can be used for the spring!" where id = 2;</span></pre><p id="94c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将会看到，即使是模式更改也会反映在消息中:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="fc9a" class="my kn iq mt b gy mz na l nb nc">{"id":1}-{"id":1,"name":"Red T-Shirt","price":12,"creation_time":1553595845000,"modification_time":null}<br/>{"id":2}-{"id":2,"name":"Blue Hat","price":5,"creation_time":1553595958000,"modification_time":null}<br/>{"id":2}-{"id":2,"name":"Blue Hat","price":17,"creation_time":1553595958000,"modification_time":1553595986000}<br/>{"id":1}-null<br/><strong class="mt ir">{"id":2}-{"id":2,"name":"Blue Hat","price":17,"creation_time":1553595958000,"modification_time":1553596044000,"description":"Can be used for the spring!"}</strong></span></pre><p id="d68b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，一些 RDBMSs 如 SQL Server <a class="ae lp" href="https://www.mssqltips.com/sqlservertip/4096/understanding-how-dml-and-ddl-changes-impact-change-data-capture-in-sql-server/" rel="noopener ugc nofollow" target="_blank">不会自动反映 CDC 数据中的模式变化。</a>但是 MySQL CDC 支持模式变更。</p><h1 id="7aef" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">缓存构建器项目</h1><p id="5199" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><code class="fe mq mr ms mt b">mysql.mystore.products</code>主题包含产品表的每次更改。为了构建我们的缓存，我们希望保留每条记录的最新值。为此，我们可以在名为<code class="fe mq mr ms mt b">products.cache</code>的单独主题中保存每个产品 id 的最新值。我们还创建了一个名为<em class="kl">缓存构建器</em>的项目，它将读取<code class="fe mq mr ms mt b">mysql.mystore.products</code>主题中的每条消息，并将它们生成到<code class="fe mq mr ms mt b">products.cache</code> <em class="kl"> </em>主题中。<code class="fe mq mr ms mt b">products.cache</code>主题是一个压缩的主题，这意味着每个键(在本例中为产品 id)将只包含一条消息。你可以在<a class="ae lp" href="http://cloudurable.com/blog/kafka-architecture-log-compaction/index.html" rel="noopener ugc nofollow" target="_blank"> Cloudurable </a>和<a class="ae lp" href="https://medium.com/@mousavi310/log-compacted-topics-in-apache-kafka-b1aa1e4665a7" rel="noopener">我最近的文章</a>中阅读更多关于压缩主题的内容。</p><p id="b73c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在 Kafka 容器中运行以下脚本，在 Kafka 中创建一个压缩主题:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="a381" class="my kn iq mt b gy mz na l nb nc">kafka-topics --create --zookeeper zookeeper:2181 --topic products.cache --replication-factor 1 --partitions 1 --config "cleanup.policy=compact" --config "delete.retention.ms=100"  --config "segment.ms=100" --config "min.cleanable.dirty.ratio=0.01"</span></pre><p id="afd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了从我们的应用程序连接到 Kafka broker，我们还需要将<code class="fe mq mr ms mt b">kafka</code>主机名添加到<code class="fe mq mr ms mt b">hosts</code>文件中(只需添加粗体行):</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="00b5" class="my kn iq mt b gy mz na l nb nc">sudo vi /etc/hosts<br/>127.0.0.1 localhost<br/># ...<br/><strong class="mt ir">127.0.0.1 kafka</strong></span></pre><p id="b591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个解决方案和 CacheBuilder 项目(你可以在<a class="ae lp" href="https://github.com/Mousavi310/kafka-cache" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中看到完整的代码):</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="7111" class="my kn iq mt b gy mz na l nb nc">mkdir src<br/>cd src/<br/>dotnet new sln --name KafkaCache<br/>dotnet new console -o KafkaCache.CacheBuilder<br/>dotnet sln add KafkaCache.CacheBuilder/KafkaCache.CacheBuilder.csproj</span></pre><p id="0c00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并安装<code class="fe mq mr ms mt b">Confluent.Kafka</code>和<code class="fe mq mr ms mt b">Newtonsoft.Json</code> NuGet 包:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="d08b" class="my kn iq mt b gy mz na l nb nc">dotnet add KafkaCache.CacheBuilder/KafkaCache.CacheBuilder.csproj  package Confluent.Kafka --version 1.0.0-RC1<br/>dotnet add KafkaCache.CacheBuilder/KafkaCache.CacheBuilder.csproj package Newtonsoft.Json --version 12.0.1</span></pre><p id="476d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里您可以看到 Program.cs 代码:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是 ProductKey 类:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="090d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Program.cs 中，我们只是从<code class="fe mq mr ms mt b">mysql.mystore.products</code>主题中读取消息，提取产品 id 字段并创建另一条消息，然后将其发布到<code class="fe mq mr ms mt b">products.cache</code>主题。现在运行 CacheBuilder 项目(在单独的终端中):</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="f386" class="my kn iq mt b gy mz na l nb nc">dotnet run --project KafkaCache.CacheBuilder/KafkaCache.CacheBuilder.csproj</span></pre><p id="5865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在 Kafka 容器中查看该主题:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="b697" class="my kn iq mt b gy mz na l nb nc">kafka-console-consumer --bootstrap-server kafka:9092 --from-beginning --topic products.cache</span></pre><h1 id="6319" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Web API 项目</h1><p id="9c01" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们创建一个 Web API 项目，它将公开简单的 REST API 来获取产品的详细信息(从缓存中检索)。此外，该项目负责消费来自<code class="fe mq mr ms mt b">products.cache</code>主题的缓存条目，并将它们存储在内存缓存中。运行以下脚本创建项目:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="c697" class="my kn iq mt b gy mz na l nb nc">dotnet new webapi -o KafkaCache.Api<br/>dotnet sln add KafkaCache.Api/KafkaCache.Api.csproj</span></pre><p id="df21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装<code class="fe mq mr ms mt b">Confluent.Kafka</code>和<code class="fe mq mr ms mt b">Newtonsoft.Json</code>包:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="8d56" class="my kn iq mt b gy mz na l nb nc">dotnet add KafkaCache.CacheBuilder/KafkaCache.CacheBuilder.csproj  package Confluent.Kafka --version 1.0.0-RC1<br/>dotnet add KafkaCache.CacheBuilder/KafkaCache.CacheBuilder.csproj package Newtonsoft.Json --version 12.0.1</span></pre><p id="6d81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启用<code class="fe mq mr ms mt b">Startup</code>类中的内存缓存:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="9a21" class="my kn iq mt b gy mz na l nb nc">services.AddMemoryCache();</span></pre><p id="25eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许我们使用<code class="fe mq mr ms mt b">IMemoryCache</code> <em class="kl"> </em>，它用于在 ASP.NET 内核的内存中存储和检索缓存条目。为了填充这个缓存，我们需要一个<code class="fe mq mr ms mt b">CacheUpdater</code>类，负责消费来自<code class="fe mq mr ms mt b">products.cache</code>主题的消息并更新我们的内存缓存:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有<code class="fe mq mr ms mt b">ProductItemCache</code>类:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0c4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们有一个负责更新缓存的 Run 方法。该方法接收一个<code class="fe mq mr ms mt b">returnOnLastOffset</code>参数，该参数用于返回关于该主题的最后一条消息。如果它有<code class="fe mq mr ms mt b">true</code> <em class="kl"> </em>值并且我们在主题/分区的末尾，我们从方法返回。这在启动过程中非常有用，因为我们希望在处理任何 REST API 请求之前预热缓存。我们现在在应用程序初始化中使用<code class="fe mq mr ms mt b">CacheUpdater</code>:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所示，我们调用了两次<code class="fe mq mr ms mt b">CacheUpdater.Run</code>方法。首先用于预热缓存，其次用于运行后台作业以连续读取<code class="fe mq mr ms mt b">products.cache</code>主题并更新内存缓存。</p><p id="8b69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，这是我们的控制器，它直接服务于来自缓存的请求:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f83c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行 API 项目:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="5d7e" class="my kn iq mt b gy mz na l nb nc">dotnet run --project KafkaCache.Api/KafkaCache.Api.csproj</span></pre><p id="b545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并检查您的 API:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="8f2c" class="my kn iq mt b gy mz na l nb nc">curl -k <a class="ae lp" href="https://localhost:5001/api/products/2" rel="noopener ugc nofollow" target="_blank">https://localhost:5001/api/products/2</a><br/>{"id":2,"name":"Blue Hat","price":17}</span></pre><p id="01d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更改 MySQL 容器中 id 为 2 的产品的价格:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="3af7" class="my kn iq mt b gy mz na l nb nc">update products set price = 56 where id = 2;</span></pre><p id="4303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并再次请求您的 API:</p><pre class="lr ls lt lu gt mu mt mv mw aw mx bi"><span id="9ee4" class="my kn iq mt b gy mz na l nb nc">curl -k <a class="ae lp" href="https://localhost:5001/api/products/2" rel="noopener ugc nofollow" target="_blank">https://localhost:5001/api/products/2</a><br/>{"id":2,"name":"Blue Hat","price":56}</span></pre><p id="2be7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，任何变化都会立即反映到我们的缓存中！</p><h1 id="1d18" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="05dd" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">使用 CDC，我们可以将数据库的变化近乎实时地反映到 Kafka 中。然后，我们可以通过消费卡夫卡的信息来创建内存缓存。现在我想指出这种方法的一些优点和缺点。</p><p id="55a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点:</strong></p><ul class=""><li id="de75" class="mc md iq jp b jq jr ju jv jy nh kc ni kg nj kk mh mi mj mk bi translated">减轻实现缓存中的 3 个问题:缓存失效、竞争条件和热启动性能。</li><li id="c064" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">将数据库更改实时同步到缓存。</li><li id="10a4" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">由于顺序 IO，缓存预热速度更快(从 Kafka 主题中读取消息)。</li></ul><p id="13ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点:</strong></p><ul class=""><li id="831a" class="mc md iq jp b jq jr ju jv jy nh kc ni kg nj kk mh mi mj mk bi translated">更复杂:您需要实现缓存构建器，使用 Debezium 连接器，为数据库启用 CDC，并从 Kafka 集群读取事件。</li><li id="5d7a" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">需要监控 Kafka，连接器和缓存生成器。</li><li id="6015" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">需要更多的知识:新开发人员必须学习更多的框架。</li></ul><h1 id="ae7b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><p id="4b17" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><a class="ae lp" href="https://vladmihalcea.com/how-to-extract-change-data-events-from-mysql-to-kafka-using-debezium/" rel="noopener ugc nofollow" target="_blank">https://vlamihalcea . com/how-to-extract-change-data-events-from-MySQL-to-Kafka-using-debezium/</a><br/><a class="ae lp" href="https://github.com/confluentinc/demo-scene/blob/master/ksql-workshop/ksql-workshop.adoc" rel="noopener ugc nofollow" target="_blank">https://github . com/confluent Inc/demo-scene/blob/master/ksql-workshop/ksql-workshop . adoc</a><br/><a class="ae lp" href="https://martin.kleppmann.com/2015/03/04/turning-the-database-inside-out.html" rel="noopener ugc nofollow" target="_blank">https://Martin . kleppmann . com/2015/03/04/turning-the-database-inside-out . https</a></p></div></div>    
</body>
</html>