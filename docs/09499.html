<html>
<head>
<title>Autoencoder neural networks: what and how?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动编码器神经网络:什么和如何？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/autoencoder-neural-networks-what-and-how-354cba12bf86?source=collection_archive---------5-----------------------#2019-12-14">https://towardsdatascience.com/autoencoder-neural-networks-what-and-how-354cba12bf86?source=collection_archive---------5-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何在 Keras 中为初学者建立一个自动编码器网络的清晰、基本的说明</h2></div><p id="2b41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">前言</strong></p><p id="13a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将通过使用<a class="ae le" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>和 Python 创建一个自动编码器。首先，我将说明什么是自动编码器，以及我们如何实现它。然后，我将通过步骤实际创建一个。可能会用<a class="ae le" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>，因为它很普通也很简单。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="d177" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">简介:什么是自动编码器？</strong></p><p id="0a8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自动编码器接受任何输入，将其分割成某种压缩版本，并使用它来重建输入内容。所以基本上，输入<em class="lm"> x </em>进入隐藏层<em class="lm"> h，</em> <strong class="kk iu"> <em class="lm"> h = f(x)，</em> </strong>出来就是重构<em class="lm"/><strong class="kk iu"><em class="lm">r = g(h)</em></strong><em class="lm">。</em>当<em class="lm"> r </em>接近<em class="lm"> x、</em>或输出看起来像输入时，自动编码器是好的。</p><p id="673c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，拥有一个精确输出输入内容的神经网络是一件好事吗？在许多情况下，并不是真的，但他们经常被用于其他目的。一个共同的目标是，隐藏层<em class="lm"> h </em>应该有一些限制，以便它提取关于<em class="lm"> x </em>的重要细节，而实际上不需要保留<em class="lm"> x </em>提供的所有信息，从而充当一种有损压缩，并且它应该根据示例自动完成此操作<em class="lm">，而不是由人类设计来识别显著特征(<a class="ae le" href="https://blog.keras.io/building-autoencoders-in-keras.html" rel="noopener ugc nofollow" target="_blank"> Chollet </a>，2016)。</em></p><p id="e6af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么是 tho？</p><p id="bba0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，当人们编写自动编码器时，希望中间层<em class="lm"> h </em>以某种压缩格式呈现有用的属性。在这里，我们将建立一个叫做<em class="lm">的不完全自动编码器</em>，这基本上意味着我们缩小隐藏层，这样它就无法存储输入给我们的相同数量的信息，我们试图从中获得一个良好的重建。构建这样的模型会迫使 autoencoder 找到您提供给它的数据的最显著的特征。在现实生活中，它可以用于降低数据集的维数，这有助于数据可视化，或潜在的去噪数据。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="3e6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">零件清单</strong></p><p id="da17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们需要创建的东西的基本列表。</p><ol class=""><li id="4414" class="ln lo it kk b kl km ko kp kr lp kv lq kz lr ld ls lt lu lv bi translated">输入数据——什么被编码和解码？</li><li id="d0a7" class="ln lo it kk b kl lw ko lx kr ly kv lz kz ma ld ls lt lu lv bi translated">编码功能——需要有一个接收输入并对其进行编码的层。</li><li id="3f16" class="ln lo it kk b kl lw ko lx kr ly kv lz kz ma ld ls lt lu lv bi translated">解码功能——需要有一个层来接收编码输入并对其进行解码。</li><li id="052f" class="ln lo it kk b kl lw ko lx kr ly kv lz kz ma ld ls lt lu lv bi translated">损失函数—当解码版本的输出非常接近原始输入数据(损失很小)时，自动编码器为<em class="lm">好</em>，当解码版本看起来与原始输入一点也不像时，自动编码器为<em class="lm">差</em>。</li></ol><p id="3ef9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">进场</strong></p><p id="3d60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最简单的自动编码器大概是这样的:x → h → r，其中函数<em class="lm"> f(x) </em>产生<em class="lm"> h </em>，函数<em class="lm"> g(h) </em>产生<em class="lm"> r </em>。我们将使用神经网络，所以我们不需要计算实际的函数。</p><p id="870e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从逻辑上来说，<strong class="kk iu">步骤 1 </strong>将是获取一些数据。我们将从 Keras 数据集库中获取 MNIST。它由 60，000 个训练样本和 10，000 个手写数字 0-9 的测试样本组成。接下来，我们将做一些基本的数据准备，以便我们可以将其作为输入集输入到我们的神经网络中，<em class="lm"> x. </em></p><p id="e3d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<strong class="kk iu">步骤 2 中，</strong>我们将建立基本的神经网络模型，从<em class="lm"> x. </em>中给我们隐藏层<em class="lm"> h </em></p><ol class=""><li id="42de" class="ln lo it kk b kl km ko kp kr lp kv lq kz lr ld ls lt lu lv bi translated">我们将把一个单一的<em class="lm">密集的</em>隐藏层与一个<em class="lm"> ReLU </em>激活层放在一起，它将<em class="lm"> x </em>作为输入。</li><li id="918e" class="ln lo it kk b kl lw ko lx kr ly kv lz kz ma ld ls lt lu lv bi translated">接下来，我们将把这一层的输出传递到另一个<em class="lm">密集</em>层，并通过一个 sigmoid 激活层运行输出。</li></ol><p id="1bbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们有了模型，我们将能够在<strong class="kk iu">步骤 3 </strong>中训练它，然后在<strong class="kk iu">步骤 4 </strong>中，我们将可视化输出。</p><p id="6e86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们把它放在一起:</p><p id="a917" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们不要忘记必要的导入来帮助我们创建我们的神经网络(keras)，做标准矩阵数学(numpy)，绘制我们的数据(matplotlib)。我们称之为<strong class="kk iu">步骤 0 </strong>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ada5" class="mk ml it mg b gy mm mn l mo mp"># Importing modules to create our layers and model.<br/>from keras.layers import Input, Dense<br/>from keras.models import Model</span><span id="9974" class="mk ml it mg b gy mq mn l mo mp"># Importing standard utils<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="2e0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第一步</strong>。导入我们的数据，做一些基础的数据准备。因为我们不打算在这里使用标签，我们只关心<em class="lm"> x </em>值。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="70fa" class="mk ml it mg b gy mm mn l mo mp">from keras.datasets import mnist</span><span id="072c" class="mk ml it mg b gy mq mn l mo mp">(train_xs, _), (test_xs, _) = mnist.load_data()</span></pre><p id="d472" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将在 0 和 1 之间对它们进行归一化。因为它们是灰度图像，值在 0 到 255 之间，我们将输入表示为 float32 并除以 255。这意味着如果值是 255，它将被规范化为 255.0/255.0 或 1.0，以此类推。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4eab" class="mk ml it mg b gy mm mn l mo mp"># Note the '.' after the 255, this is correct for the type we're dealing with. It means do not interpret 255 as an integer. <br/>train_xs = train_xs.astype('float32') / 255.<br/>test_xs = test_xs.astype('float32') / 255.</span></pre><p id="5408" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在想一想，我们有 28 x 28 的图像，值在 0 和 1 之间，我们想把它们作为输入向量传递到神经网络层。我们做什么呢我们可以使用卷积神经网络，但在这个简单的例子中，我们只使用密集层。那我们怎么把它放进去？我们将把每个图像展平成一个 784 x 1 值的一维向量(28 x 28 = 784)。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e5b3" class="mk ml it mg b gy mm mn l mo mp">train_xs = train_xs.reshape((len(train_xs), np.prod(train_xs.shape[1:])))</span><span id="3e95" class="mk ml it mg b gy mq mn l mo mp">test_xs = test_xs.reshape((len(test_xs), np.prod(test_xs.shape[1:])))</span></pre><p id="d6e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第二步。</strong>我们来拼凑一个基本网络。我们将简单地创建一个编码层和一个解码层。我们将把它们放在一起，形成一个名为 autoencoder 的模型。我们还将减小编码的大小，这样我们就可以得到一些数据压缩。为了简单起见，这里我们用 36。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b411" class="mk ml it mg b gy mm mn l mo mp"># Defining the level of compression of the hidden layer. Basically, as the input is passed through the encoding layer, it will come out smaller if you want it to find salient features. If I choose 784 for my encoding dimension, there would be a compression factor of 1, or nothing.<br/>encoding_dim = 36<br/>input_img = Input(shape=(784, ))</span><span id="9fa5" class="mk ml it mg b gy mq mn l mo mp"># This is the size of the output. We want to generate 28 x 28 pictures in the end, so this is the size we're looking for. <br/>output_dim = 784</span><span id="fc4b" class="mk ml it mg b gy mq mn l mo mp">encoded = Dense(encoding_dim, activation='relu')(input_img)<br/>decoded = Dense(output_dim, activation='sigmoid')(encoded)</span></pre><p id="23af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在创建一个模型，接受 input_img 作为解码器层的输入和输出。然后编译模型，在这种情况下用 adadelta 作为优化器，用 binary_crossentropy 作为损失。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0004" class="mk ml it mg b gy mm mn l mo mp">autoencoder = Model(input_img, decoded)</span><span id="0b3e" class="mk ml it mg b gy mq mn l mo mp">autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')</span></pre><p id="1a8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第三步。</strong>我们的模特已经准备好训练了。你不需要图形处理器就能运行这个，不会花很长时间。我们将在我们创建的 autoencoder 模型上调用 fit，为 15 个时期的输入和输出传递 x 值，使用相对较大的批处理大小(256)。这将有助于它训练得更快。我们将启用 shuffle 来防止每个批次中出现同质数据，然后我们将使用测试值作为验证数据。<em class="lm">注意:如果你想在不过度拟合的情况下训练更长时间，稀疏和正则化可能会被添加到你的模型中。</em></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b0aa" class="mk ml it mg b gy mm mn l mo mp">autoencoder.fit(train_xs, train_xs, epochs=15, batch_size=256, shuffle=True, validation_data=(test_xs, test_xs)</span></pre><p id="3961" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样。自动编码器完成。你会看到它应该有大约 0.69 的损失，这意味着我们创建的重建通常相当好地代表了来自高度压缩版本的输入。但是我们不能自己去看一下吗？</p><p id="921a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第四步。</strong>为此，我们将进行一些推理，从输入数据中获取我们的重构，然后我们将使用 matplotlib 显示它们。为此，我们想使用预测方法。</p><p id="b4b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">思维过程是这样的:获取我们的测试输入，通过 autoencoder.predict 运行它们，然后显示原始数据和重建数据。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="93c6" class="mk ml it mg b gy mm mn l mo mp"># Run your predictions and store them in a decoded_images list. <br/>decoded_images = autoencoder.predict(test_xs)</span></pre><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/e9a9286934459c9e6464903afdfddcc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4NyztKidpjXtr2cG2GQsw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">The top row is the inputs, and the bottom row is the reconstruction from our autoencoder model.</figcaption></figure><p id="2f6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是你如何得到上面的图像:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="895a" class="mk ml it mg b gy mm mn l mo mp"># We'll plot 10 images. <br/>n = 10<br/>plt.figure(figsize=(16, 3))<br/>for i in range(n):<br/>    # Show the originals<br/>    ax = plt.subplot(2, n, i + 1)<br/>    plt.imshow(test_xs[i].reshape(28, 28))<br/>    ax.get_xaxis().set_visible(False)<br/>    ax.get_yaxis().set_visible(False)</span><span id="4714" class="mk ml it mg b gy mq mn l mo mp"># Show the reconstruction<br/>    ax = plt.subplot(2, n, i + 1 + n)<br/>    plt.imshow(decoded_imgs[i].reshape(28, 28))<br/>    ax.get_xaxis().set_visible(False)<br/>    ax.get_yaxis().set_visible(False)</span><span id="dbb7" class="mk ml it mg b gy mq mn l mo mp">plt.show()</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="dc6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样。这是最基本的自动编码器。非常感谢<a class="nd ne ep" href="https://medium.com/u/7462d2319de7?source=post_page-----354cba12bf86--------------------------------" rel="noopener" target="_blank">Fran ois Chollet</a>，我从他的<a class="ae le" href="https://blog.keras.io/building-autoencoders-in-keras.html" rel="noopener ugc nofollow" target="_blank">文章</a>中学到了这一点，并启发了本教程的基础知识，并感谢 Goodfellow 等人将深度学习作为无价的参考。</p><p id="bf97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这个教程或者有什么建议，请在下面留言。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="108f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编辑:我在这里添加了查看隐藏层的功能，这绝对很有趣。你可以看到，从这些 6 x 6 的图像中，神经网络能够重建原始输入。你开始明白为什么这可能有用了吗？</p><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nf"><img src="../Images/45c5bff649bb7fb0eab4be3a5585e14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9ABq46kAyunwpvT7P9TGw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">The top row is the input, the middle row is the hidden encoding, and from that the bottom row is reconstructed.</figcaption></figure><p id="f003" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何得到中间一排？这很简单，我们用第一个隐藏层创建一个模型。为什么？我们这样做是为了运行预测功能，并将其结果添加到 python 中的列表中。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6200" class="mk ml it mg b gy mm mn l mo mp"># Create a Model from the layer. <br/>encoder = Model(input_img, encoded)</span><span id="53ea" class="mk ml it mg b gy mq mn l mo mp"># Save the results to encoded_imgs. This must be done after the autoencoder model has been trained in order to use the trained weights.<br/>encoded_imgs = encoder.predict(test_xs)</span></pre><p id="1948" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们稍微修改一下 matplotlib 指令，以包含新的图像:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="65b9" class="mk ml it mg b gy mm mn l mo mp"># We'll plot 10 images. <br/>n = 10<br/>plt.figure(figsize=(14, 4))<br/>for i in range(n):<br/>    # Show the originals<br/>    ax = plt.subplot(3, n, i + 1)<br/>    plt.imshow(test_xs[i].reshape(28, 28))<br/>    ax.get_xaxis().set_visible(False)<br/>    ax.get_yaxis().set_visible(False)</span><span id="3ea3" class="mk ml it mg b gy mq mn l mo mp">    # Show the middle layer<br/>    ax = plt.subplot(3, n, i + 1 + n)<br/>    plt.imshow(encoded_imgs[i].reshape(6, 6))<br/>    ax.get_xaxis().set_visible(False)<br/>    ax.get_yaxis().set_visible(False)</span><span id="a277" class="mk ml it mg b gy mq mn l mo mp">    # Show the reconstruction<br/>    ax = plt.subplot(3, n, i + 1 + n * 2)<br/>    plt.imshow(decoded_imgs[i].reshape(28, 28))<br/>    ax.get_xaxis().set_visible(False)<br/>    ax.get_yaxis().set_visible(False)</span><span id="5b05" class="mk ml it mg b gy mq mn l mo mp">plt.show()</span></pre><p id="9dc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">暂时就这样吧！我希望这篇教程能帮助你理解一些自动编码器背后的思维过程，以及如何在你的神经网络中使用它们。</p></div></div>    
</body>
</html>