<html>
<head>
<title>Smart Discounts with Logistic Regression | Machine Learning from Scratch (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归智能折扣|从零开始的机器学习(第一部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/smart-discounts-with-logistic-regression-machine-learning-from-scratch-part-i-3c242f4ded0?source=collection_archive---------7-----------------------#2019-03-31">https://towardsdatascience.com/smart-discounts-with-logistic-regression-machine-learning-from-scratch-part-i-3c242f4ded0?source=collection_archive---------7-----------------------#2019-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2aee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向选定的客户发送折扣代码以增加利润</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cd8b1fef3864eecb75a8e5a78b297917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8egswV6RqHnGsqGspxrJBQ.jpeg"/></div></div></figure><blockquote class="kr"><p id="d10f" class="ks kt iq bd ku kv kw kx ky kz la lb dk translated">TL；DR 在这一部分中，您将从头开始使用 Python 构建一个<em class="lc">逻辑回归</em>模型。在此过程中，您将了解梯度下降算法，并使用它来训练您的模型。</p></blockquote><h2 id="e1cd" class="ld le iq bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从零开始的机器学习系列:</h2><ol class=""><li id="a1e9" class="lz ma iq mb b mc md me mf lm mg lq mh lu mi lb mj mk ml mm bi translated"><strong class="mb ir">逻辑回归智能折扣</strong></li><li id="0cb0" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/predicting-house-prices-with-linear-regression-machine-learning-from-scratch-part-ii-47a0238aeac1" rel="noopener">用线性回归预测房价</a></li><li id="b577" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/building-a-decision-tree-from-scratch-in-python-machine-learning-from-scratch-part-ii-6e2e56265b19" rel="noopener">用 Python 从头开始构建决策树</a></li><li id="e01a" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/color-palette-extraction-with-k-means-clustering-machine-learning-from-scratch-part-iv-55e807407e53" rel="noopener">利用 K 均值聚类进行调色板提取</a></li><li id="3a55" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/movie-review-sentiment-analysis-with-naive-bayes-machine-learning-from-scratch-part-v-7bb869391bab" rel="noopener">用朴素贝叶斯进行电影评论情感分析</a></li><li id="cbe3" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/music-artist-recommender-system-using-stochastic-gradient-descent-machine-learning-from-scratch-5f2f1aae972c" rel="noopener">使用随机梯度下降的音乐艺术家推荐系统</a></li><li id="6d0b" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/fashion-product-image-classification-using-neural-networks-machine-learning-from-scratch-part-e9fda9e47661" rel="noopener">利用神经网络进行时尚产品图像分类</a></li><li id="e14e" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/build-a-taxi-driving-agent-in-a-post-apocalyptic-world-using-reinforcement-learning-machine-175b1edd8f69" rel="noopener">使用强化学习在后启示录世界中构建一个出租车驾驶代理</a></li></ol><p id="e520" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">假设你正在开发你的网上服装店。你的一些顾客已经付了全价。有些没有。您想要创建一个促销活动，并向一些客户提供折扣代码，希望这可能会增加您的销售额。但是，您不希望向可能会支付全价的客户提供折扣。您应该如何挑选将获得折扣的客户？</p><p id="9a4f" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated"><strong class="mb ir"> <em class="ni">完整源代码笔记本</em> </strong>(谷歌合作实验室):</p><div class="nj nk gp gr nl nm"><a href="https://colab.research.google.com/drive/1kmtjoULbyRtAtDPKYlhWSwATLpF7PQd8" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">物流回收</h2><div class="nt l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">colab.research.google.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nm"/></div></div></a></div><h1 id="76fb" class="oa le iq bd lf ob oc od li oe of og ll jw oh jx lp jz oi ka lt kc oj kd lx ok bi translated">数据</h1><p id="ffcb" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">您从数据库、分析包等中收集了一些数据。这是你可能会想到的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="10d4" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">让我们将数据加载到熊猫数据框中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="05d1" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">看一看它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/0555588dd0b72b9132e73c94a882677c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAa4oAxhrgGU6VYV0T64Rg.png"/></div></div></figure><blockquote class="or os ot"><p id="d300" class="mt mu ni mb b mc mv jr mw me mx ju my ou mz na nb ov nc nd ne ow nf ng nh lb ij bi translated">注意-显示的数据是您可能拥有的真实数据集的简化。如果您的数据非常简单，您可以尝试更简单的方法。</p></blockquote><h1 id="9a27" class="oa le iq bd lf ob oc od li oe of og ll jw oh jx lp jz oi ka lt kc oj kd lx ok bi translated">用逻辑回归做决策</h1><p id="b6a6" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">当因变量/目标变量为二元时，逻辑回归用于分类问题。即其值为真或假。<em class="ni">逻辑回归</em>是实践中最流行、最广泛使用的算法之一(<a class="ae ms" href="https://www.kaggle.com/surveys/2017" rel="noopener ugc nofollow" target="_blank">见此</a>)。</p><p id="cb25" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">可以用逻辑回归解决的一些问题包括:</p><p id="d0c1" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">- <strong class="mb ir">电子邮件</strong> —判定是否为垃圾邮件<br/> - <strong class="mb ir">网上交易</strong>-欺诈与否<br/> - <strong class="mb ir">肿瘤分类</strong>-恶性还是良性<br/> - <strong class="mb ir">客户升级</strong>-客户是否会购买高级升级</p><p id="ed05" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们想要预测变量<em class="ni"> y </em>的结果，例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/1e46c2955414702bd5751497c0bf7438.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*SnGi4zpchrjBRmwP6U5VCw.png"/></div></figure><p id="17fa" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">并设置 0:否定类(例如，电子邮件不是垃圾邮件)或 1:肯定类(例如，电子邮件是垃圾邮件)。</p><h2 id="efbf" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">就不能用线性回归吗？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/d9b15cc271633451fba7fe01d16ec01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgAlWcV-GwhipVkDwATUoA.jpeg"/></div></div><figcaption class="pe pf gj gh gi pg ph bd b be z dk">Source: <a class="ae ms" href="https://www.machinelearningplus.com/" rel="noopener ugc nofollow" target="_blank">machinelearningplus.com</a></figcaption></figure><p id="33b6" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">线性回归是另一个非常流行的模型。它的工作假设是观察到的现象(你的数据)可以用一条直线来解释。</p><p id="bc64" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">线性回归的响应变量<em class="ni"> y </em>在【0，1】区间内<em class="ni">不受</em>限制。这使得很难根据其输出做出二元决策。因此，不适合我们的需要。</p><h1 id="a802" class="oa le iq bd lf ob oc od li oe of og ll jw oh jx lp jz oi ka lt kc oj kd lx ok bi translated">逻辑回归模型</h1><p id="3933" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">考虑到我们的问题，我们想要一个使用 1 个变量(预测值)(<code class="fe pi pj pk pl b"><em class="ni">x_1</em></code><em class="ni">-amount _ spend</em>)的模型来预测我们是否应该向客户发送折扣。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/220b1ef813485adb11d902e770c55390.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*GVWrF-oFi1ghYXf-qN3Umg.png"/></div></figure><p id="1070" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">其中系数<code class="fe pi pj pk pl b"><em class="ni">w_i</em></code>是模型的参数。设系数向量<code class="fe pi pj pk pl b"><strong class="mb ir"><em class="ni">W</em></strong></code>为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/3e5bb8884fd7ba21554669b206d9af6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*6ClCApncNYoy0sI3ca2fEg.png"/></div></figure><p id="5198" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">那么我们可以用更简洁的形式来表示<code class="fe pi pj pk pl b"><em class="ni">h_w(x)</em></code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/a116ace7a8aa75cef188bbd58d746f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*VDrVQteNWwAMSIXLCuxZYA.png"/></div></figure><p id="993f" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">那就是<em class="ni">线性回归</em>模型。</p><p id="5cdd" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们希望构建一个输出值介于 0 和 1 之间的模型，因此我们希望提出一个满足以下条件的假设:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/44beae38e2d786daf3c67ecf111ad7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*MvmxRrAe079If_uTdq117w.png"/></div></figure><p id="18a5" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">对于<strong class="mb ir"> <em class="ni">逻辑回归</em> </strong>我们想要修改它并引入另一个函数<em class="ni"> g </em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/d8e7fa7a79db097aa1df1614e65fcd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*MJ-uIr130v95TJFT635kDQ.png"/></div></figure><p id="6911" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们将把<code class="fe pi pj pk pl b"><strong class="mb ir"><em class="ni">g</em></strong></code>定义为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/02579795b91e576a4f2f8afdc953a820.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*xEYsiOwf2ze0whm2FB89WQ.png"/></div></figure><p id="5d78" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">在哪里</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/8062c2f58d47a0e67a6e483baa543202.png" data-original-src="https://miro.medium.com/v2/resize:fit:202/format:webp/1*rGKmPNow6rSrjpyHLLMkmQ.png"/></div></figure><p id="9d0e" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated"><em class="ni"> g </em>又称<em class="ni">s 形函数</em>或<em class="ni">逻辑函数</em>。替换后，我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/00ee54c0c479650d312e9b8ac67ac55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*x41h-26s5wKimQVHDNPzSQ.png"/></div></figure><p id="6c2e" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">为了我们的假设。</p><h2 id="305c" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">仔细观察 sigmoid 函数</h2><p id="9a36" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">直观上，我们将使用 sigmoid 函数“超过”线性回归模型，将其限制在[0；+1].</p><p id="8f5a" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">回想一下，sigmoid 函数定义为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/02579795b91e576a4f2f8afdc953a820.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*xEYsiOwf2ze0whm2FB89WQ.png"/></div></figure><p id="df60" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">让我们将其转化为一个 Python 函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="be8d" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">sigmoid 函数的图形表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/2e33d468efd9acb24faaceb8d2c592ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0xhS0mHfL9oPeH1zSak7g.png"/></div></div></figure><p id="daf3" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">看起来很眼熟吧？注意它收敛到-1 或+1 的速度有多快。</p><h1 id="0885" class="oa le iq bd lf ob oc od li oe of og ll jw oh jx lp jz oi ka lt kc oj kd lx ok bi translated">我们如何找到模型的参数？</h1><p id="5daa" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">让我们检查一些方法，为我们的模型找到好的参数。但是在这个上下文中，好是什么意思呢？</p><h2 id="20d5" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">损失函数</h2><p id="3738" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">我们有一个模型可以用来做决策，但我们仍然需要找到参数<code class="fe pi pj pk pl b"><strong class="mb ir">W</strong></code>。要做到这一点，我们需要客观地衡量一组给定的参数有多好。为此，我们将使用损失(成本)函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/4d3de42de59bf4490af47496c7c8eca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*OFd-z7VTqRSnBr15ceASbw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/464d0e92577d847e19f2f04e39a071ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPch7a2TlPD92qzoWCzwCw.png"/></div></div></figure><p id="9155" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">这也被称为<a class="ae ms" href="https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html" rel="noopener ugc nofollow" target="_blank">对数损失或交叉熵损失</a>函数</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/171aa6f9a0a74e31330461a980d5f213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*Y_t5KT4tEVWWf64eY1WJjw.png"/></div><figcaption class="pe pf gj gh gi pg ph bd b be z dk">Source: <a class="ae ms" href="https://ml-cheatsheet.readthedocs.io" rel="noopener ugc nofollow" target="_blank">https://ml-cheatsheet.readthedocs.io</a></figcaption></figure><p id="32c9" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们可以把上面的函数压缩成一个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/e224aafe7f627c4738a0130699d44c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBAkoh-a6DoVx36kAltSkw.png"/></div></div></figure><p id="70a6" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">在哪里</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/73bd3a4926584282de3636231b3124bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*CxDqzRBCE9Oc40bxaeQekQ.png"/></div></figure><p id="26a8" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">让我们用 Python 来实现它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="3994" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">方法 1——尝试一个数字</h2><p id="8f5d" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">让我们想出 3 个数字来表示系数 w0、w1 和 w2。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="df5f" class="ld le iq pl b gy qc qd l qe qf">loss: 25.0 predicted: 0.999999999986112 actual: 0.0</span></pre><p id="ee24" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">不幸的是，我很懒，这种方法对我来说似乎有点太麻烦了。让我们看下一个:</p><h2 id="4cab" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">方法 2——尝试许多数字</h2><p id="7adf" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">好吧，现在的电脑速度非常快，6 核以上的笔记本电脑随处可见。智能手机也可以很有性能！让我们善用这种力量，通过尝试大量数字来找出那些讨厌的参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="c2d1" class="ld le iq pl b gy qc qd l qe qf">0.0 <br/>0.0 <br/>0.0 <br/>6.661338147750941e-16 <br/>9.359180097590508e-14<br/>1.3887890837434982e-11 <br/>2.0611535832696244e-09 <br/>3.059022736706331e-07 <br/>4.539889921682063e-05 <br/>0.006715348489118056 <br/>0.6931471805599397 <br/>5.006715348489103 <br/>10.000045398900186 <br/>15.000000305680194 <br/>19.999999966169824 <br/>24.99999582410784 <br/>30.001020555434774 <br/>34.945041100449046 <br/>inf <br/>inf</span></pre><p id="6985" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">令人惊讶的是，我们尝试的第一个参数值使我们的损失为 0。这是你的幸运日还是永远如此？答案留作读者练习:)</p><h2 id="52a1" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">方法 3——梯度下降</h2><p id="9322" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">梯度下降算法(是的，有很多)为我们提供了一种寻找某个函数<strong class="mb ir"> <em class="ni"> f </em> </strong>最小值的方法。它们通过沿梯度定义的下降方向迭代工作。</p><p id="1229" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">在机器学习中，我们使用梯度下降算法来为我们的模型(逻辑回归、线性回归、神经网络等)找到“好”的参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qg"><img src="../Images/a373ab7cbfb79b87635435bf2e27252d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16uR2JPzCtu2qSCGPe7kbw.jpeg"/></div></div><figcaption class="pe pf gj gh gi pg ph bd b be z dk">source: PyTorchZeroToAll</figcaption></figure><p id="056e" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">它是如何工作的？从某个地方开始，我们沿着负梯度指定的方向迈出第一步。接下来，我们重新计算负梯度，并在它指定的方向上再走一步。这个过程一直持续到我们不能再走下坡路的时候——一个局部最小值。</p><p id="bba7" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">好的，但是我们怎样才能找到梯度呢？我们必须找到我们的成本函数的导数，因为我们的例子相当简单。</p><h2 id="a9f0" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">sigmoid 函数的一阶导数</h2><p id="98e7" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">sigmoid 函数的一阶导数由以下等式给出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/73eea004bd1a01ec920e8e063296ecac.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*NZZnVX-maYN1MnG3YcAcRA.png"/></div></figure><p id="6af0" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">完整的推导可以在<a class="ae ms" href="https://math.stackexchange.com/a/1225116/499458" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="d57a" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">成本函数的一阶导数</h2><p id="47a2" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">回想一下，成本函数由以下等式给出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/e224aafe7f627c4738a0130699d44c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBAkoh-a6DoVx36kAltSkw.png"/></div></div></figure><p id="f85d" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">考虑到</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/73eea004bd1a01ec920e8e063296ecac.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*NZZnVX-maYN1MnG3YcAcRA.png"/></div></figure><p id="dde5" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们获得成本函数的一阶导数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qi"><img src="../Images/c99c1c11b0af2589ebdce3101833f7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkOfb1yi8MG4SIb0lwbEwQ.png"/></div></div></figure><h2 id="57cc" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">更新我们的参数 W</h2><p id="360c" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">现在我们有了导数，我们可以回到我们的更新规则，并在那里使用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/1c807afe49d9010eb68bbdf19e170d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*Lj-WtXkttbJ1G2Sam1fZrw.png"/></div></figure><p id="f572" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">参数<code class="fe pi pj pk pl b">a</code>被称为<em class="ni">学习率</em>。高学习率可以快速收敛，但有超过最低点的风险。低学习率允许在负梯度的方向上自信地移动。然而，这很费时间，所以我们要花很多时间去收敛。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qk"><img src="../Images/2f7c6f9221a7c4de4822d678874d5e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGhRddOUV8h0pdQek8T35A.png"/></div></div><figcaption class="pe pf gj gh gi pg ph bd b be z dk">Too big vs too small learning rate (source: <a class="ae ms" href="https://towardsdatascience.com/" rel="noopener" target="_blank">https://towardsdatascience.com/</a>)</figcaption></figure><h2 id="90b1" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">梯度下降算法</h2><p id="0618" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">我们要使用的算法如下:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="28c9" class="ld le iq pl b gy qc qd l qe qf">Repeat until convergence {<br/>  1. Calculate gradient average<br/>  2. Multiply by learning rate<br/>  3. Subtract from weights<br/>}</span></pre><p id="2a9a" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">让我们用 Python 来做这件事:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b9a0" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">关于那个<code class="fe pi pj pk pl b">until convergence part</code>。你可能会注意到，我们有点蛮力绕过它。也就是说，我们将运行该算法预设的迭代次数。另一个有趣的点是我们的权重<code class="fe pi pj pk pl b">W</code>的初始化——最初设置为零。</p><p id="0fc7" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">让我们来测试一下我们的实现。但是首先，我们需要一个函数，在给定一些数据<code class="fe pi pj pk pl b">X</code>的情况下，帮助我们预测<code class="fe pi pj pk pl b">y</code>(预测我们是否应该根据客户的消费向其发送折扣):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="2f23" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">现在进行我们的简单测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b9af" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">注意，我们使用<code class="fe pi pj pk pl b">reshape</code>向<code class="fe pi pj pk pl b">X</code>添加一个虚拟尺寸。此外，在我们调用<code class="fe pi pj pk pl b">predict</code>之后，我们对结果进行舍入。回想一下，sigmoid 函数在[0；1]范围。我们将对结果进行四舍五入，以获得 0 或 1(是或否)的答案。</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="e613" class="ld le iq pl b gy qc qd l qe qf">run_tests()</span></pre><p id="f937" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">下面是运行我们的测试用例的结果:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="084d" class="ld le iq pl b gy qc qd l qe qf">F</span></pre><p id="cc25" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">嗯，这并不好，经过这么多的努力，我们还没有达到为我们的模型找到好的参数的目标。但是，哪里出了问题？</p><p id="f74b" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">欢迎来到您的第一次模型调试会议！让我们从发现我们的算法是否随着时间的推移而改进开始。为此，我们可以使用我们的损失指标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="3a2d" class="ld le iq pl b gy qc qd l qe qf">run_tests()</span></pre><p id="08f6" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">除了每<em class="ni"> 10，000 </em>次迭代打印一次训练损失之外，我们几乎复制并粘贴了我们的训练代码。让我们来看看:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="e1e5" class="ld le iq pl b gy qc qd l qe qf">loss: 0.6931471805599453 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056<br/>loss: 0.41899283818630056</span><span id="ba86" class="ld le iq pl b gy ql qd l qe qf">F........</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/b5ebbf1bbd35ced8f9efb767706e8895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXTn0UerN68_mqZrOXMz6w.png"/></div></div></figure><p id="488f" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">够可疑的是，我们第一次尝试就找到了问题的可能原因！我们的损失不够低，换句话说，我们的算法在某个点卡住了，这个点对我们来说不是一个足够好的最小值。我们如何解决这个问题？也许，尝试不同的学习率或者用不同的值初始化我们的参数？</p><p id="e36b" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">第一，较小的学习率<code class="fe pi pj pk pl b">a</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="4580" class="ld le iq pl b gy qc qd l qe qf">run_tests()</span></pre><p id="cdb9" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">通过<code class="fe pi pj pk pl b">a=0.001</code>我们得到这个:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="a40e" class="ld le iq pl b gy qc qd l qe qf">loss: 0.42351356323845546 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056 	<br/>loss: 0.41899283818630056</span><span id="0971" class="ld le iq pl b gy ql qd l qe qf">F.......</span></pre><p id="e8b2" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">不太成功，是吗？为我们的模型增加一个参数来查找/学习怎么样？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="238b" class="ld le iq pl b gy qc qd l qe qf">run_tests()</span></pre><p id="0db0" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">结果是:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="cfcc" class="ld le iq pl b gy qc qd l qe qf">........<br/>---------------------------------------------------------<br/>Ran 8 tests in 0.686s  </span><span id="7bce" class="ld le iq pl b gy ql qd l qe qf">OK</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/8c022cccb438f058bcb06fbf2e2bf879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OSthkO73kXX2RZcrpAXAQ.png"/></div></div></figure><p id="23b2" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们在这里做了什么？我们向参数向量 W 添加了一个新元素，并将其初始值设为 1。看起来事情变得对我们有利了！</p><h1 id="e1ba" class="oa le iq bd lf ob oc od li oe of og ll jw oh jx lp jz oi ka lt kc oj kd lx ok bi translated">额外收获——打造自己的物流回收器</h1><p id="8ae7" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">知道梯度下降的内部工作的所有细节是好的，但是当在野外解决问题时，我们可能会时间紧迫。在这些情况下，一个简单易用的界面来拟合逻辑回归模型可能会节省我们很多时间。所以，我们来造一个吧！</p><p id="66a4" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">但是首先，让我们编写一些测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="355e" class="ld le iq pl b gy qc qd l qe qf">run_tests()</span></pre><p id="5c28" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">我们只是将所有以前编写的函数打包到一个小类中。这种方法的一个巨大优势是我们隐藏了梯度下降算法的复杂性和参数<code class="fe pi pj pk pl b"><strong class="mb ir"><em class="ni">W</em></strong></code>的使用。</p><h2 id="0b90" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">使用我们的回归量来决定谁应该收到折扣代码</h2><p id="ce33" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">既然您已经完成了“难”的部分，让我们使用模型来预测我们是否应该发送折扣代码。</p><p id="575b" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">让我们回忆一下最初的数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/0555588dd0b72b9132e73c94a882677c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAa4oAxhrgGU6VYV0T64Rg.png"/></div></div></figure><p id="05eb" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">现在，让我们根据从两个新客户那里获得的数据来尝试我们的模型:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="d823" class="ld le iq pl b gy qc qd l qe qf">Customer 1 - $10<br/>Customer 2 - $250</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="7d82" class="ld le iq pl b gy qc qd l qe qf">y_test</span></pre><p id="3424" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">回想一下，1 表示发送代码，0 表示不发送:</p><pre class="kg kh ki kj gt py pl pz qa aw qb bi"><span id="dab4" class="ld le iq pl b gy qc qd l qe qf">array([1., 0.])</span></pre><p id="36a5" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">看起来很合理。愿意尝试更多的案例吗？</p><p id="7681" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">您可以在以下位置找到完整的源代码并在浏览器中运行代码:</p><div class="nj nk gp gr nl nm"><a href="https://colab.research.google.com/drive/1kmtjoULbyRtAtDPKYlhWSwATLpF7PQd8" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">物流回收</h2><div class="nt l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">colab.research.google.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nm"/></div></div></a></div><h1 id="e282" class="oa le iq bd lf ob oc od li oe of og ll jw oh jx lp jz oi ka lt kc oj kd lx ok bi translated">结论</h1><p id="03d0" class="pw-post-body-paragraph mt mu iq mb b mc md jr mw me mf ju my lm ol na nb lq om nd ne lu on ng nh lb ij bi translated">干得好！您已经有了一个完整的(尽管简单的)LogisticRegressor 实现，您可以使用它。去吧，玩得开心点！</p><p id="ee4a" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">接下来，您将从头实现一个线性回归模型:)</p></div><div class="ab cl qm qn hu qo" role="separator"><span class="qp bw bk qq qr qs"/><span class="qp bw bk qq qr qs"/><span class="qp bw bk qq qr"/></div><div class="ij ik il im in"><h2 id="3241" class="ld le iq bd lf lg oy dn li lj oz dp ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">从零开始的机器学习系列:</h2><ol class=""><li id="2335" class="lz ma iq mb b mc md me mf lm mg lq mh lu mi lb mj mk ml mm bi translated"><strong class="mb ir">逻辑回归智能折扣</strong></li><li id="ffaa" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/predicting-house-prices-with-linear-regression-machine-learning-from-scratch-part-ii-47a0238aeac1" rel="noopener">用线性回归预测房价</a></li><li id="0364" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/building-a-decision-tree-from-scratch-in-python-machine-learning-from-scratch-part-ii-6e2e56265b19" rel="noopener">用 Python 从头开始构建决策树</a></li><li id="6a47" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/color-palette-extraction-with-k-means-clustering-machine-learning-from-scratch-part-iv-55e807407e53" rel="noopener">利用 K 均值聚类进行调色板提取</a></li><li id="9b1b" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/movie-review-sentiment-analysis-with-naive-bayes-machine-learning-from-scratch-part-v-7bb869391bab" rel="noopener">用朴素贝叶斯进行电影评论情感分析</a></li><li id="184e" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/music-artist-recommender-system-using-stochastic-gradient-descent-machine-learning-from-scratch-5f2f1aae972c" rel="noopener">使用随机梯度下降的音乐艺术家推荐系统</a></li><li id="da6c" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/fashion-product-image-classification-using-neural-networks-machine-learning-from-scratch-part-e9fda9e47661" rel="noopener">利用神经网络进行时尚产品图像分类</a></li><li id="edac" class="lz ma iq mb b mc mn me mo lm mp lq mq lu mr lb mj mk ml mm bi translated"><a class="ae ms" href="https://medium.com/@curiousily/build-a-taxi-driving-agent-in-a-post-apocalyptic-world-using-reinforcement-learning-machine-175b1edd8f69" rel="noopener">使用强化学习在后启示录世界中构建一个出租车驾驶代理</a></li></ol></div><div class="ab cl qm qn hu qo" role="separator"><span class="qp bw bk qq qr qs"/><span class="qp bw bk qq qr qs"/><span class="qp bw bk qq qr"/></div><div class="ij ik il im in"><p id="6dd9" class="pw-post-body-paragraph mt mu iq mb b mc mv jr mw me mx ju my lm mz na nb lq nc nd ne lu nf ng nh lb ij bi translated">喜欢你读的吗？你想了解更多关于机器学习的知识吗？</p><div class="nj nk gp gr nl nm"><a href="https://leanpub.com/hmls" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">从零开始实践机器学习</h2><div class="qt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">“我不能创造的东西，我不理解”——理查德·费曼这本书将引导你走向更深的…</h3></div><div class="nt l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">leanpub.com</p></div></div><div class="nu l"><div class="qu l nw nx ny nu nz kp nm"/></div></div></a></div></div></div>    
</body>
</html>