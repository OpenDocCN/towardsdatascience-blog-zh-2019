<html>
<head>
<title>A continuously updating k-means algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种不断更新的 k-means 算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-continuously-updating-k-means-algorithm-89584ca7ee63?source=collection_archive---------15-----------------------#2019-02-21">https://towardsdatascience.com/a-continuously-updating-k-means-algorithm-89584ca7ee63?source=collection_archive---------15-----------------------#2019-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ec98" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种改进的 k-means 模型，可以不断学习新的例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0b20b863a03997431b72b6879a09d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FtmjFHSbJMXO7vNb"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cdae" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">概述</strong></h1><p id="a2bf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们都听说过流行的 k-means 算法，该算法用于在我们的数据中查找聚类，它基本上是基于现有特征对相似的点进行分组。无论如何，我不会用算法的细节来烦你，你们大多数人可能已经很熟悉了。我有兴趣讨论的是 k-means 的扩展版:一个可以不时用新数据更新，变得更加信息丰富的 k-means 模型。比方说，今天我们有一个特定产品公司的用户行为的大约一百万个数据点。我们对我们的数据应用 k-means 算法，并使用肘图得出一些 k 聚类。一个月后，我们获得了额外的 10k 个数据点，其中包含我们希望包含在模型中的用户行为的最新信息。</p><p id="cb23" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们应该对整个数据运行 k-means 吗？请记住，在大规模数据集上运行 k-means 可能需要大量计算。我们正在讨论定期更新模型，以包含定期出现的新数据。聪明的做法是用新信息更新现有模型，我们称之为 delta 模型。</p><p id="b629" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">新型号=旧型号+ Delta 型号</p><p id="9a57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一种简单而强大的技术，用于在生产级别维护模型。我将详细讨论该算法，但让我们先看看经典的 k-means 算法。</p><h1 id="07f6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">经典 K 均值算法</strong></h1><p id="77a8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们试着从头开始编写 k-means 算法。以下是实现 k-means 算法的步骤:</p><ol class=""><li id="fd83" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">通过从数据中随机选择 k 个点来初始化被称为质心的 k 个聚类中心。还有一种用于初始化中心的技术叫做 k-means++我们在这里不讨论。</li><li id="fe8c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">计算每个数据点与这些中心的距离，并将它们分配给最近或距离最小的中心。</li><li id="147f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">通过取一个聚类中所有点的平均值来重新计算聚类中心。这些可能在数据集中，也可能不在数据集中。</li><li id="32b4" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">计算新中心到旧中心的距离总和，我们称之为误差。检查误差是否大于容许值，并重复步骤 2 和 3，直到误差低于容许值，这意味着算法已经收敛。这将是最终的聚类中心和各自的点。</li></ol><p id="8e0f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">python 中的实现看起来有点像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="8eb6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">改进的 k-means 算法</strong></h1><p id="6671" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">k-means 类可用于训练模型和对新数据进行预测。现在，让我们看看如何整合新的数据和更新我们的 k 均值模型。</p><ol class=""><li id="b90c" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">计算一个新数据点到所有聚类中心的距离，并找出这些距离中的最小值。</li><li id="2982" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">检查最小距离是否小于阈值。如果为真，我们将新的数据点分配给相应的集群。然后，更新该聚类的聚类中心。</li><li id="8f18" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">如果为 False，则创建一个新的聚类，并将该新数据点指定为其中心。此外，数据点成为集群的一部分。</li><li id="eab7" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">我们可以用一系列新数据点重复相同的步骤来更新我们的模型。我们的模型现在比以前更好，因为它看到了更多的数据。</li></ol><p id="3373" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们改进的具有更新功能的 k-means 类的代码可以写成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="df50" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">测试阵列中包含了一个示例。干杯！</p></div></div>    
</body>
</html>