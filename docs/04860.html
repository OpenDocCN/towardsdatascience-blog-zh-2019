<html>
<head>
<title>It’s merely a matter of time, Dr. Watson! Understanding date and time in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这只是时间问题，华生医生！理解 R 中的日期和时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/its-merely-a-matter-of-time-dr-watson-2fd74a648842?source=collection_archive---------35-----------------------#2019-07-22">https://towardsdatascience.com/its-merely-a-matter-of-time-dr-watson-2fd74a648842?source=collection_archive---------35-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">如何正确处理 R 中的时间——日期、时间、周期、持续时间、通量电容、时间旅行、时间间隔——什么？我在时间丛林里给你一些帮助。</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/029d714534818af0e9bc8d3180c62959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-LFQKScTes5FxWz17gcfA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The processing of time often appears weird. Photo by <a class="ae ky" href="https://unsplash.com/@jontyson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae ky" href="https://unsplash.com/search/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我需要用 R(和其他编程语言)处理日期和时间时，我通常会遇到困难——解析、打印、时区、夏令时、时差。也许你和我一样是那些可怜的人中的一员。所以这篇文章是写给那些总是忘记这些概念的人和我未来的自己的。这篇文章是提示、包和函数的松散连接，展示了如何处理日期和时间。</p><h1 id="46ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概观</h1><p id="5cff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">r 中时间点的标准表示(即日期和时间)使用所谓的 UNIX 纪元时间或<strong class="lb iu"> POSIX 时间</strong>，这是自<code class="fe ms mt mu mv b">1970–01–01T00:00:00Z</code>以来经过的秒数(这是 ISO8601^1 格式，表示 1970 年 1 月 1 日 00:00:00 AM，协调世界时 UTC)。对于 1970 年之前的时间点，此计数为负。这同样适用于自 1970 年 1 月 1 日以来的天数。</p><h1 id="1841" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基本日期和时间类</h1><p id="e09c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">基础包中用于表示日期、时间和时差的最重要的类是</p><ul class=""><li id="a898" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">base::Date</code> —没有时间和时区的日期，编码为自 1970-01-01 以来的有符号天数(负数表示该日期之前的年份)。</li><li id="d1b7" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">base::POSIXct</code> — <strong class="lb iu">日历时间</strong> —日期和时间，由 1970 年 1 月 1 日 00:00:00 以来的秒数和时区表示。通常，这是计算(如时差)的最佳表示。POSIXct 使用您平台上的系统实现。亚秒可以用这个类编码。请注意，闰秒通常在大多数平台上被忽略。</li><li id="ef58" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">base::POSIXlt</code> <strong class="lb iu"> —当地时间</strong> —日期和时间分为所有日期/时间部分(工作日、年份等)。).如果您需要处理例如工作日，这很有用。</li><li id="4f2b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">base::difftime</code> —用浮点数和一个单位(“秒”、“天”)表示的两个日期或日期/时间之间的差异。</li></ul><p id="ed15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 R 中键入<code class="fe ms mt mu mv b">?DateTimeClasses</code>来获取这些类的引用。</p><p id="3ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显示所有数据组件的<code class="fe ms mt mu mv b">unclass()</code>函数可以很容易地研究这些类的实例结构。用<code class="fe ms mt mu mv b">class(x)</code>你可以得到给定对象<code class="fe ms mt mu mv b">x</code>的类名。</p><p id="8ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，所有这些类的实例都是由相应的<code class="fe ms mt mu mv b">as.xxxx()</code>函数生成的，例如</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="87d1" class="no lw it mv b gy np nq l nr ns">base::as.POSIXct(“2019–01–01 00:00:00”, tz=”UTC”)</span></pre><p id="4df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解析日期时间字符串的示例</strong></p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="f43c" class="no lw it mv b gy np nq l nr ns">&gt; t1 &lt;- as.POSIXct(‘2019–01–01 15:00:00’, tz=’UTC’)</span><span id="2932" class="no lw it mv b gy nt nq l nr ns">&gt; class(t1)</span><span id="515a" class="no lw it mv b gy nt nq l nr ns">[1] “POSIXct” “POSIXt”</span><span id="ca3a" class="no lw it mv b gy nt nq l nr ns">&gt; unclass(t1)</span><span id="645d" class="no lw it mv b gy nt nq l nr ns">[1] 1546354800</span><span id="0d90" class="no lw it mv b gy nt nq l nr ns">attr(,”tzone”)</span><span id="584e" class="no lw it mv b gy nt nq l nr ns">[1] “UTC”</span></pre><h1 id="b799" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Lubridate 包</h1><p id="6d62" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> lubridate </strong> R 包(<a class="ae ky" href="https://lubridate.tidyverse.org" rel="noopener ugc nofollow" target="_blank">https://lubridate.tidyverse.org</a>)在日期和时间的处理上引入了一点舒适。尤其是带有日期和时间的计算更加简洁。除了日期(由<code class="fe ms mt mu mv b">base::Date</code>表示)和时间(由<code class="fe ms mt mu mv b">base::POSIXct</code>表示)<strong class="lb iu">之外，lubridate </strong>增加了以下类</p><ul class=""><li id="055c" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">lubridate::Duration</code> —两个日期/时间之间经过的确切时间。可以从日期/时间中增加或减少持续时间。使用从<code class="fe ms mt mu mv b">dnanoseconds()</code>到<code class="fe ms mt mu mv b">dweeks()</code>的<code class="fe ms mt mu mv b">lubridate::dxxxx</code>功能可以创建一个持续时间值。注意:持续时间<code class="fe ms mt mu mv b">dmonth()</code>和<code class="fe ms mt mu mv b">dyear()</code>是一个月/年的<strong class="lb iu">平均值</strong>。因此，有第二个类代表通常可以理解的月/年值:</li><li id="dc2f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">lubridate::Period</code> —周期是与公历相关联的时差的度量。因此，如果您将一个月添加到一个日期值中，即使这几个月的持续时间不同，也会出现相同的天数(见图 1 )!使用年()、月()、周()等。此处的功能。</li><li id="c70f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">lubridate::Interval</code> —对由两个日期/时间(开始和结束)组成的时间间隔进行编码。集合操作可以用这个类来执行(<code class="fe ms mt mu mv b">setdiff</code>、<code class="fe ms mt mu mv b">intersect</code>、<code class="fe ms mt mu mv b">union</code>)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/ecf7e4edf286d28ead010b40724b4ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuhGjnm2n5oTy5adcjDChg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig. 1: An overview showing all relevant date-time related objects. The <strong class="bd nv">duration </strong>of a <strong class="bd nv">period</strong> variates depending on the dates/times to which it is added. Intervals have a clear <strong class="bd nv">start</strong> and <strong class="bd nv">end date/time</strong>. Set operations can be performed with intervals such as intersection, difference, or containment using %within%.</figcaption></figure><p id="71b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lubridate 包有很多解析不同格式的日期和时间的函数，例如</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="ee19" class="no lw it mv b gy np nq l nr ns">time1 &lt;- lubridate::ymd_hms(“2019–01–01 14:45:00”)</span><span id="03b8" class="no lw it mv b gy nt nq l nr ns">date1 &lt;- lubridate::ymd(20190101)</span></pre><h2 id="427e" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">周期</h2><p id="9f48" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">周期是对年和月特别有用的常识性度量，如下所示:</p><p id="58bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，2016 年是闰年:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="5d3a" class="no lw it mv b gy np nq l nr ns">library(lubridate)</span><span id="e91d" class="no lw it mv b gy nt nq l nr ns">(ymd(20160101) + years(1)) — ymd(20160101)</span><span id="9958" class="no lw it mv b gy nt nq l nr ns">Time difference of 366 days</span></pre><p id="ed01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，2017 年不是闰年:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="ac83" class="no lw it mv b gy np nq l nr ns">(ymd(20170101) + years(1)) — ymd(20170101)</span><span id="7490" class="no lw it mv b gy nt nq l nr ns">Time difference of 365 days</span></pre><h2 id="8cf0" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">期间</h2><p id="1806" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">持续时间是基本单位(皮秒、微秒、毫秒、秒、分钟、小时、天、周)内的精确时间量。由于月份和年份不是同质的(有更短和更长的年份)，这些持续时间不适合用作精确的度量。</p><p id="56a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上面的例子相反，<code class="fe ms mt mu mv b">dyears(1)</code>是平均年正好有 365 天，所以在闰年你会得到以下结果(这通常不是你想要的):</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="330e" class="no lw it mv b gy np nq l nr ns">library(lubridate)<br/>(ymd(20170101) + dyears(1) — ymd(20170101)<br/>Time difference of 365 days</span></pre><h2 id="72d9" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">间隔</h2><p id="ade6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">间隔由两个日期组成，如下所示</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="45d4" class="no lw it mv b gy np nq l nr ns">library(lubridate)<br/>I1 &lt;- interval(<br/>        ymd(20170101),<br/>        ymd(20171231))</span></pre><p id="abfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者像这样的日期/时间点</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="df24" class="no lw it mv b gy np nq l nr ns">I2 &lt;- interval(<br/>         ymd_hms(“2019–01–01 14:30:00”),<br/>         ymd_hms(“2019–01–01 15:30:00”))</span></pre><p id="f24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里检查日期/时间是否包含在这样的间隔中</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="e875" class="no lw it mv b gy np nq l nr ns">ymd(20170317) %within% I1</span><span id="76ae" class="no lw it mv b gy nt nq l nr ns">[1] TRUE</span><span id="58e4" class="no lw it mv b gy nt nq l nr ns">ymd(20180317) %within% I1</span><span id="6167" class="no lw it mv b gy nt nq l nr ns">[1] FALSE</span></pre><p id="07cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">setdiff()</code>、<code class="fe ms mt mu mv b">union()</code>、<code class="fe ms mt mu mv b">intersect()</code>等操作与<code class="fe ms mt mu mv b">lubridate::Interval</code>类协同工作。</p><h1 id="82f3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">亚秒级分辨率的打印和解析</h1><p id="bc90" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">解析</strong>微秒级分辨率可以通过<code class="fe ms mt mu mv b">base::strptime()</code>函数完成(注意格式字符串中的“<code class="fe ms mt mu mv b">%OS</code>”参数允许解析亚秒级):</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="a59b" class="no lw it mv b gy np nq l nr ns">time1 &lt;- base::strptime(“2019–03–30 17:35:12.456789”,<br/>              format = “%Y-%m-%d %H:%M:%OS”, tz = “UTC”)</span></pre><p id="d865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，使用<strong class="lb iu">润滑</strong>方法可以更简单地获得相同的结果(这里我使用了日期-时间的 ISO8601 编码——见下一节):</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="0cad" class="no lw it mv b gy np nq l nr ns">time1 &lt;- lubridate::as_datetime(“2019–03–30T17:35:12.456789Z”)</span></pre><p id="bcdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用下面的 R 表达式执行返回字符串的转换:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="2433" class="no lw it mv b gy np nq l nr ns">print(base::strftime(time1, “%Y-%m-%d %H:%M:%OS6 %Z”))</span><span id="93ef" class="no lw it mv b gy nt nq l nr ns">[1] “2019–03–30 17:35:12.456789 UTC”</span></pre><p id="2602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意格式字符串中的“<code class="fe ms mt mu mv b">%OS6</code>”。这是为了打印小数秒的 6 位数字。</p><h1 id="55a5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">日期和时间的字符表示</h1><p id="662c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">“令人高兴的是”,日期和时间的文本 ASCII 表示存在巨大的可变性，这使得日期时间的处理和解析非常具有挑战性。每当你有机会决定使用哪种时间格式时，我都会推荐使用 UTC 的 ISO8601 格式。即使在其他时区处理，UTC 时间代码在全球范围内都是清晰的——您不必摆弄时区或夏令时(从而在时间线中引入一年两次跳跃:一次跳跃到未来，一次跳跃到过去——并且没有通量电容器)。</p><p id="1b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:字符串“<code class="fe ms mt mu mv b">2019–01–02T23:50:12.225Z</code>”是采用 UTC 时区的 ISO8601 时间代码(即字符串末尾的<code class="fe ms mt mu mv b">Z</code>)。可以像这样用<code class="fe ms mt mu mv b">lubridate::as_datetime()</code>函数解析</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="14c1" class="no lw it mv b gy np nq l nr ns">time1 &lt;- lubridate::as_datetime(‘2019–01–02T23:50:12.225Z’)</span></pre><h2 id="ae5e" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">从文件加载时间序列</h2><p id="993f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从文件中加载时间序列的一个非常好的包是<strong class="lb iu"> readr </strong>包(<a class="ae ky" href="https://readr.tidyverse.org" rel="noopener ugc nofollow" target="_blank">https://readr.tidyverse.org</a>)，它允许解析带有日期/时间列的表格。通过使用<code class="fe ms mt mu mv b">readr::col_date</code>、<code class="fe ms mt mu mv b">readr::col_time</code>和<code class="fe ms mt mu mv b">readr::col_datetime</code>给出一个列定义，可以给<strong class="lb iu"> readr </strong>一个解析<code class="fe ms mt mu mv b">readr::read_csv()</code>中日期的格式。寻找<code class="fe ms mt mu mv b"> readr::parse_date</code>和<code class="fe ms mt mu mv b"> readr::parse_datetime</code>功能。</p><h2 id="3ca6" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">加载带有日期列的 CSV 文件的示例</h2><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="eb42" class="no lw it mv b gy np nq l nr ns">library(readr)</span><span id="8636" class="no lw it mv b gy nt nq l nr ns">col_spec &lt;- cols(<br/>   x = col_double(),<br/>   y = col_date(format = “%Y-%m-%d”))</span><span id="7bbb" class="no lw it mv b gy nt nq l nr ns">df1 &lt;- read_csv(readr_example(“challenge.csv”),<br/>                col_types = col_spec)</span></pre><h1 id="69ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">绘制时间序列</h1><p id="0307" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">基础包提供了 ts()函数来创建一个规则的时间序列。一个<strong class="lb iu"> ts </strong>时间序列有一个起始点(有时解释为年份)和一个<code class="fe ms mt mu mv b">frequency</code>——或者是一个<code class="fe ms mt mu mv b">deltat</code> <strong class="lb iu"> </strong>，它们被设置为与起始点相关。</p><p id="89df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将日期和时间附加到数据帧的每一行(在<strong class="lb iu"> xts </strong>中称为<code class="fe ms mt mu mv b">index()</code>)，该概念被扩展为支持不规则采样时间序列的<strong class="lb iu"> xts </strong> package⁴。xts 套装基于<strong class="lb iu">动物园</strong> package^5.</p><p id="cc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就个人而言，我更喜欢使用【https://ggplot2.tidyverse.org】库<a class="ae ky" href="https://ggplot2.tidyverse.org" rel="noopener ugc nofollow" target="_blank">来绘制图形。通过一些简单的步骤，一个<strong class="lb iu"> ts </strong>或<strong class="lb iu"> xts </strong>时间序列可以转换成一个<strong class="lb iu">tible</strong>数据帧用于绘图。对于转换时间序列来说，重要的是<code class="fe ms mt mu mv b">generics::tidy()</code>函数将时间戳属性提取到一个<strong class="lb iu">索引</strong>列中。</a></p><p id="0074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/188f940e582f1817ff29fd450fe1fe67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*V6MnIx1CvRHNIMoJWywSCg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Time-series in <strong class="bd nv">xts</strong>.</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e7da40abfc7e6fec281ed6bb2acf2b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*zKbMDVRGrHg5AwIRr-n-EQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Time-series in <strong class="bd nv">ggplot</strong>.</figcaption></figure><p id="a6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关处理时间序列的更多资料，请参见[7，8]。</p><h1 id="4c10" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">松散的末端</h1><h2 id="4bfd" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">闰秒</h2><p id="3a45" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于这个世界在数学上(以及在许多其他方面)并不完美，所以有时会有闰秒(通常是正数)，因此有些日子会有 86401 秒，而不是 86400 秒。否则——迟早——由于平均太阳日并不完美，我们的挂钟会漂移。</p><p id="96ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全局变量. leap.seconds 包含当前时区的所有闰秒。对于另一个时区，您可以使用<code class="fe ms mt mu mv b">format(.leap.seconds, tz=’CET’)</code>打印闰秒。</p><p id="9f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，正如 POSIX 提出的那样，时差应该考虑闰秒。然而，由于这使得所有的时间计算过于复杂，它们通常在大多数系统中被忽略！在 R 的 DateTimeClasses 文档中，编写了以下提示:</p><blockquote class="oi oj ok"><p id="5122" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">在任何平台上，R do <strong class="lb iu">而非</strong>使用的[…]“posi xct”时间包括闰秒</p></blockquote><h2 id="7841" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">表示日期和时间的其他包装/R 类别</h2><p id="e272" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在其他常用的包中有一些额外的类代表日期和时间(这个小列表显然不是详尽的):</p><ul class=""><li id="273d" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">chron::chron</code> —按时间顺序排列的对象</li><li id="ce22" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">zoo::yearmon </code> —表示包括年份在内的月度数据</li><li id="725d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">zoo::yearqtr</code> —包括年度在内的季度数据表示</li><li id="2b2d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">timeDate::timeDate</code></li></ul><p id="6f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章有助于找到解决 r 中日期和时间处理困难的方法。</p><h2 id="a3b7" class="no lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">参考</h2><p id="efe5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">[1]日期和时间格式— ISO 8601。<a class="ae ky" href="https://www.iso.org/iso/iso8601" rel="noopener ugc nofollow" target="_blank">https://www.iso.org/iso/iso8601</a>，<a class="ae ky" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/ISO_8601</a></p><p id="68c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] R 代表数据科学— Ch。16 日期和时间，【https://r4ds.had.co.nz/dates-and-times.html】T4</p><p id="67dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【3】闰秒。维基百科。<a class="ae ky" href="https://en.wikipedia.org/wiki/Leap_second" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Leap_second</a></p><p id="5f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4] xts:可扩展时间序列，<a class="ae ky" href="https://cran.r-project.org/package=xts" rel="noopener ugc nofollow" target="_blank">https://cran.r-project.org/package=xts</a></p><p id="7948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[5] zoo:规则和不规则时间序列的 S3 基础设施(Z 的有序观测)，<a class="ae ky" href="https://cran.r-project.org/package=zoo" rel="noopener ugc nofollow" target="_blank">https://cran.r-project.org/package=zoo</a></p><p id="c40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[6] chron:可以处理日期和时间的时序对象，<a class="ae ky" href="https://cran.r-project.org/package=chron" rel="noopener ugc nofollow" target="_blank">https://cran.r-project.org/package=chron</a></p><p id="98a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[7]使用 dplyr 介绍时间序列分析，<a class="ae ky" href="https://blog.exploratory.io/introducing-time-series-analysis-with-dplyr-60683587cf8a" rel="noopener ugc nofollow" target="_blank">https://blog . explorative . io/Introducing-Time-Series-Analysis-with-DP lyr-60683587 cf8a</a></p><p id="69f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[8]时间序列分析，<a class="ae ky" href="http://r-statistics.co/Time-Series-Analysis-With-R.html" rel="noopener ugc nofollow" target="_blank">http://r-statistics.co/Time-Series-Analysis-With-R.html</a></p></div></div>    
</body>
</html>