<html>
<head>
<title>The Branch and Bound Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分支定界算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-branch-and-bound-algorithm-a7ae4d227a69?source=collection_archive---------4-----------------------#2019-08-17">https://towardsdatascience.com/the-branch-and-bound-algorithm-a7ae4d227a69?source=collection_archive---------4-----------------------#2019-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/890231bbe10d34d37855c922f6aca26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7kxYpZD75QYaRoTc"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@voodushevlyonniy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Valeriy Andrushko</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="d9f5" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">简单地说，这是优化中最常用的算法之一，是混合整数编程的支柱。</h2></div><p id="fb4d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你们大多数人可能听说过混合整数编程，或者更一般的离散优化。在本文中，我们将讨论混合整数编程背后的驱动力算法，即分支定界算法。</p><p id="2ab6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们一般地定义一个优化问题，这样我们就在同一页上了。优化问题可以非常简单地总结为一行:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/b5a2f82e9a56d66aed7622f19075c710.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/0*rloKOQsJ7Qzdgeer"/></div></figure><p id="5cc2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个等式中，我们实际上是说，我们希望通过来自集合<strong class="la jk"> X. </strong>的<strong class="la jk"> x </strong>来最小化函数<strong class="la jk"> f </strong>(也称为成本函数)。集合<strong class="la jk"> X </strong>可能是所有实数的集合，可能是整数的集合……也可能是包含实数和整数的向量的集合(这是混合整数编程的大多数情况)。需要记住的一点是<strong class="la jk"> X </strong>是<strong class="la jk">可行集</strong>。所以我们只需要关心这个集合中的解。</p><p id="1262" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分支定界算法的思想很简单。给定<strong class="la jk"> X </strong>的某些子集，它找到成本函数<strong class="la jk"> f </strong>的边界。我们如何准确地得到这些子集？例如，如果我们的解向量<strong class="la jk"> x </strong>的某些成员是整数，并且我们知道这些成员在 0 和 2 之间。然后，我们将从第一个成员开始，探索向量的该维度的每个值的解决方案。这种搜索过程产生如下所示的树形结构(假设不同的整数解在 1 和 5 之间枚举):</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/0ae210336019179a9a403b9970b59d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooFymk1qj9oENPck5XDKdA.png"/></div></div></figure><p id="c477" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可行集的不同子集包含在花括号中。从逻辑上讲，我们希望以最有效的方式搜索这棵树，在每个叶节点评估函数<strong class="la jk"> f </strong>可能会非常昂贵，并且可能涉及优化问题的连续变量。幸运的是，我们可以使用一些技巧来智能地限制父节点的成本，防止我们将它们一直扩展到叶节点，从而导致更有效的搜索策略。</p><p id="e12d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分支定界算法依赖于优化中的<strong class="la jk">边界原则</strong>，这只是一个用来描述非常直观的事物的花哨术语。想象可行集的子集，<strong class="la jk"> S1 </strong>和<strong class="la jk"> S2 </strong>。如果来自<strong class="la jk"> S1 </strong>的解的上界低于<strong class="la jk"> S2 </strong>的解的下界，那么显然不值得探究<strong class="la jk"> S2 </strong>的解。这就是分支定界算法背后的全部魔力。从这一点开始，为了简洁起见，我将用<strong class="la jk"> UB </strong>表示上限，用<strong class="la jk"> LB </strong>表示下限，用<strong class="la jk"> GUB </strong>表示全局上限。现在是时候动手实践一下这个算法的具体例子了。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/93375b72c574f897907d66d529835edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kD2JHp7LeSnJg0G3zSajXA.jpeg"/></div></div></figure><p id="9886" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用算法的方式如下。我们有一堆开放的节点，我们称之为<strong class="la jk">开放</strong>。开放只是意味着它们还没有被完全探索。我们还跟踪全球上限 T21。在每一步中，我们从开集中取出一个节点并展开它，我们还评估它是否是叶节点。如果节点有子节点，我们查看子节点的<strong class="la jk"> LB </strong>和<strong class="la jk"> UB </strong>。如果子节点的<strong class="la jk"> LB </strong>低于<strong class="la jk"> GUB </strong>，那么我们把它加到<strong class="la jk"> OPEN </strong>栈，如果高于全局<strong class="la jk"> UB </strong>那么就不值得探究了。此外，如果节点的<strong class="la jk"> UB </strong>低于全局<strong class="la jk"> UB </strong>，那么我们将全局<strong class="la jk"> UB </strong>更新为节点的<strong class="la jk"> UB </strong>。</p><p id="c1c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们给上图一些上下限来说明这一点:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/ec5370a5d7db09833a935c2f96d7e682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpVn5EvN9FZZ7w1Ka-_yvQ.png"/></div></div></figure><p id="dee9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从一个无限的 GUB 开始。红色表示每个节点的成本，此外，为了简单起见，我们用一个数字(黑色)枚举树的每个节点。那么，应用分支定界会发生什么呢？首先，<strong class="la jk"> OPEN </strong>栈将包含节点 1，因为它是根节点。我们从堆栈中弹出一个节点并展开它。我们现在看节点 2 和 3。我们看到节点 3 具有比当前<strong class="la jk"> GUB </strong>更低的<strong class="la jk"> UB </strong>，我们将<strong class="la jk"> GUB </strong>设置为 40 并将其添加到<strong class="la jk"> OPEN </strong>。节点 2 的<strong class="la jk"> LB </strong>仍然低于<strong class="la jk"> GUB </strong>，因此我们将其添加到<strong class="la jk"> OPEN </strong>堆栈中。我们再次从堆栈中弹出一个节点并查看子节点，现在我们查看节点 2 的子节点，我们看到节点 4 是一个叶节点，开销为 10。我们现在可以将<strong class="la jk"> GUB </strong>更新为 10 并进一步观察。节点 5 太贵了，所以没有提到。我们再次从堆栈中弹出一个节点(节点 3)，但是我们看到节点 3 的<strong class="la jk"> LB </strong>高于当前的<strong class="la jk"> GUB </strong> (10)，因此我们不做任何事情。</p><p id="77ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一点上，算法完成，我们设法修剪所有的解决方案，将导致从节点 3。自然地，在实践具有数千个节点的分支和界限算法时，这个例子在这里说明了它的机制。神奇之处在于有效地导出解集的上下界，这本身就是一个完整的研究领域。</p><p id="e68c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于分支定界算法的一个更有用的事实是，它以更紧的界限递增地给出更好的解。这意味着，当算法提前终止时，有时也会给出有意义的解。这通常用于优化，以有意义的起点引导其他一些方法。这篇文章的要点是:</p><blockquote class="mc"><p id="28d2" class="md me jj bd mf mg mh mi mj mk ml lt dk translated">如果下限大于全局上限，那么在那里寻找解决方案是没有好处的！</p></blockquote><p id="0854" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我希望我能够对分支和绑定的机制有所了解。继续优化！</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/4ff9e1ed614a19c9053c113f7131d03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGPCAx1OhR574Yp2GSMebA.jpeg"/></div></div></figure></div></div>    
</body>
</html>