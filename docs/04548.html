<html>
<head>
<title>Reducing Data Inconsistencies with POI Normalization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过兴趣点归一化减少数据不一致性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reducing-data-inconsistencies-with-poi-normalization-9febd62393c?source=collection_archive---------25-----------------------#2019-07-12">https://towardsdatascience.com/reducing-data-inconsistencies-with-poi-normalization-9febd62393c?source=collection_archive---------25-----------------------#2019-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c8688defe7d62104fef3b1b17a39a800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SpR1EAjK1V7P_-V4xUt3w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">By Franki Chamaki</figcaption></figure><p id="6873" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">数据规范化是一种减少数据不一致性的优雅技术。尤其是当我们处理一个巨大的数据集时。通过这篇文章，我将带你了解我在最近的一个项目中所做的一些选择。</p><p id="2dbb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先让我介绍一下问题，描述一下预期的结果，然后说明我达到目标的步骤。</p><p id="8a7d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请在这里找到我们将在本文中使用的虚拟数据。</p><h1 id="50ed" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">问题:</strong></h1><p id="00d7" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">假设我们希望通过重塑值的分布来规范化点列表(名称，值)。</p><p id="4594" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">预期目标将是:</p><p id="2566" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">1-限制最小常数值(标注为“Min ”)和最大常数值(标注为“Max ”)之间的值。<br/> 2-从“最小”值到“最大”值，点的密度应显著降低。<br/>这意味着我们应该让大多数点接近“最小值”,只有少数几个点接近“最大值”极限。</p><p id="2167" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将使用 Python 脚本从文件中读取点值，并根据上述标准对它们进行规范化。</p><h1 id="6979" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">我的策略:</strong></h1><p id="3342" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">首先，我从启动我的 Python 库和读取数据开始</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="119e" class="mq lf it mm b gy mr ms l mt mu">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from scipy import special<br/>import numpy as np<br/><br/><br/># Read the data<br/>data = pd.read_csv('raw_scores.txt',sep=' ', header=None)<br/>x = data[1]</span></pre><p id="dccd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在那之后，我执行一些标准的数据分析操作，检查数据形状，检查重复的线和检查异常值(超出最小、最大范围)。</p><p id="91d0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为简单起见，我们将设置 Min=0，Max=10</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4b08" class="mq lf it mm b gy mr ms l mt mu"># Check data description and shape<br/>print (data.describe())<br/><br/><br/><br/># check if any duplicate lines<br/>duplicateID = data[data.duplicated(subset=0)]<br/>print("Duplicated lines count is :",duplicateID.shape[0])<br/><br/><br/><br/>## check if any outliers (outside range(0,10))<br/>outl=data[data[1] &gt;= 10]<br/>print("Outliers count (POI greater than 10) = ", outl.shape[0])<br/>outl=data[data[1] &lt;= 0]<br/>print("Outliers count (POI less than 0) = ", outl.shape[0])</span></pre><p id="34d1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，我绘制了实际的分布图，看看它看起来如何，离要求的结果有多远。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="31dd" class="mq lf it mm b gy mr ms l mt mu"># Drawing barPlot by [k,k+1] range to see data<br/>data[1].value_counts(bins=[Min,Min+1,Min+2,....,Max]).plot.bar(figsize=(10,5))<br/>plt.xlabel('range of POI')<br/>plt.ylabel('Occurences')<br/>plt.tight_layout()<br/>plt.show()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/eca4b55a2d91b5d1f6f3ad4677ed9564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQoogMAF93QlNSxxwvWYvg.png"/></div></div></figure><p id="a56b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，考虑到以下需求，我开始了一些标准化实验:</p><p id="911f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">要求 1: </strong>将数值限制在标注为“Min”的最小常数值和标注为“Max”的最大常数值之间。</p><p id="55d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">要求 2 </strong>:从“最小”值到“最大”值，点的密度应显著降低。<br/>在我们的实验中，我们定义:dif = minimum ([ k-1，k]和[k，k=1]之间的差)应该大于 0(如果&gt; 5，我们提出宾果)</p><p id="51eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">要求 3 </strong>:很少的值应该以接近最大值的分数结束。</p><p id="bf47" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了做这个实验，我创建了一些有用的函数:</p><p id="721b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> countBin() : </strong>计算每个[k，k+1]中有多少个点</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="68ba" class="mq lf it mm b gy mr ms l mt mu"><br/>def countBin(l,i):<br/>    if len(l.value_counts(bins=[i, i+1]).tolist()) == 0:<br/>        return 0<br/>    else:<br/>        return l.value_counts(bins=[i, i+1]).tolist()[0]</span></pre><p id="edec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> check_requirements() </strong>:检查结果是否符合上述要求的函数。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1e19" class="mq lf it mm b gy mr ms l mt mu">def check_requirements(l):<br/>    t1=countBin(l,0)<br/>    print("range [ 0 - 1 ]",t1)<br/>    t2=countBin(l,9)<br/>    dif = 10<br/>    for i in range(0,9):<br/>        print("range [",i,"-",i+1,"]", countBin(l,i))<br/>        t1 = t1 + countBin(l,i)<br/>        if dif &gt; (countBin(l,i-1) - countBin(l,i)):<br/>            dif = countBin(l,i-1) - countBin(l,i)<br/>    print("total=" ,t1, "dif=", dif, "t2=", t2)<br/>    if (t1  == 91897) and (dif&gt;=5) and (t2 in range(5,250)):<br/>        print("==========================================")<br/>        print("============== BINGO =====================")<br/>        print("==========================================")</span></pre><p id="07dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> Experiment_dis(): </strong>对不同的分布模型进行实验，试图找到符合要求的最佳模型参数。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="328f" class="mq lf it mm b gy mr ms l mt mu">def Experiment_dis(distribution,l,n,m,step):<br/>    for i in np.arange(n, m, step):<br/>        if distribution == "zipfian":<br/>            y = (l + 1) ** (-i) / special.zetac(i)<br/><br/>        if distribution == "pareto":<br/>            y = i / l ** (i + 1)<br/><br/>        if distribution == "binomial":<br/>            y = (1 / i) ** (0.4 * l)<br/><br/>        if distribution == "lomax":<br/>            y = 1 / (i + l) ** (4)<br/><br/>        if distribution == "weibull":<br/>            y = (5 / i) * (l / i) ** (5 - 1) * np.exp(-(l / i) ** 5)<br/><br/>        y = 1 / y  # to preserve order (Requirement4) since all distribution involved will inverse the order.<br/>        y = 10 * (y - min(y)) / (max(y) - min(y))  # Normalisation to [0,10]<br/>        print("i=", i)<br/>        check_requirements(y)<br/>        print("-----")<br/>    data[2] = y<br/>    print(data.head())</span></pre><p id="0854" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们在这里实验的模型有:<br/> <strong class="kh iu">二项式分布、洛马克斯分布、威布尔分布、齐夫安分布。</strong></p><p id="07eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mw">我们为什么选择这些模型分布？</em></p><p id="d983" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为从它们的图形表示来看，它们似乎非常符合要求，请参见下文:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f92b46fb38a1db3830ccc207f019e616.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*D9usWzfkKemK_e6yh7RMnQ.png"/></div></figure><p id="27c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以我们进行实验:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="49b1" class="mq lf it mm b gy mr ms l mt mu">Experiment_dis("zipfian",x,1,5,0.1)<br/>#best score obtained is dif=10 t2=7 for i=2.6<br/><br/>Experiment_dis("pareto",x,1,5,0.1)<br/>#best score obtained is dif=9 t2=7 for i=1.2<br/><br/>Experiment_dis("binomial",x,1,5,0.1)<br/>#best score obtained is dif=10 t2=6 for i=1.8<br/><br/>Experiment_dis("lomax",x,1,10,0.1)<br/>#best score obtained is dif=9 t2=7 for i=7.7<br/><br/>Experiment_dis("weibull",x,1,2,0.1)<br/># Did not give good result, hence not adapted</span></pre><p id="e086" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们选择形状参数为<strong class="kh iu">2.6</strong>的 Zipfian，因为它代表了需求方面的最佳得分。<br/> <strong class="kh iu"> Experiment_dis("zipfian "，x，2.5，2.6，0.1) </strong></p><p id="4b7a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是我们的 POI 标准化后的样子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="95db" class="mq lf it mm b gy mr ms l mt mu"><br/>## Drawing Plot to see new distribution after normalisation using zipfian<br/>data[2].value_counts(bins=[0,1,2,3,4,5,6,7,8,9]).plot.bar(figsize=(10,5))<br/>plt.xlabel('range of POI')<br/>plt.ylabel('Occurences')<br/>plt.tight_layout()<br/>plt.show()<br/><br/><br/>## Saving the output into CSV<br/>data.to_csv(r'submission1.csv')</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d72b32e4cad33859bd3f55518839fbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHbOmu6YvrofsYHpZFbyUQ.png"/></div></div></figure><p id="a597" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我也在一个公开的<a class="ae ld" href="https://gist.github.com/abdel1979/47b239fae381737ea2a210ec3ada18c5" rel="noopener ugc nofollow" target="_blank">要点</a>中分享了代码。</p><p id="ac26" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">本文简单介绍了标准化</strong>如何组织我们的数据，并在不丢失信息的情况下使其更准确地符合现实。一般来说，规范化是许多机器学习算法的要求。如果您不确定哪种类型的标准化适合您的数据，请参阅这些资源的更多详细信息<a class="ae ld" href="https://en.wikipedia.org/wiki/Feature_scaling" rel="noopener ugc nofollow" target="_blank">功能缩放</a>。</p><p id="7e76" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一如既往，我希望你学到了一些新东西:)</p><p id="95ad" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">萨拉姆。</p></div></div>    
</body>
</html>