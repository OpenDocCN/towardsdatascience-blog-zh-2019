<html>
<head>
<title>Bite-Sized Python Recipes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一口大小的蟒蛇食谱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bite-sized-python-recipes-52cde45f1489?source=collection_archive---------12-----------------------#2019-04-22">https://towardsdatascience.com/bite-sized-python-recipes-52cde45f1489?source=collection_archive---------12-----------------------#2019-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="80f9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 中有用的小函数的集合</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1fe1d42c4778b40fc5b8381ff7a4811d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EstfBi6oPEtSpkSD"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mat_graphik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jordane Mathieu</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="adf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">免责声明:</em>这是我在网上找到的一些有用的小函数的集合，主要在 Stack Overflow 或者 Python 的文档页面上。有些人可能会看，但无论如何，我都在我的项目中使用过它们，我认为它们值得分享。你可以在我试图保持更新的笔记本中找到所有这些，以及一些额外的评论。</p><p id="0eea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除非必要，我不打算过度解释这些功能。那么，让我们开始吧！</p><p id="a042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">从两个列表中创建字典:</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="dbe8" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; prod_id = [1, 2, 3]<br/>&gt;&gt;&gt; prod_name = ['foo', 'bar', 'baz']<br/>&gt;&gt;&gt; prod_dict = dict(zip(prod_id, prod_name))</span><span id="ad51" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;&gt; prod_dict<br/>{1: 'foo', 2: 'bar', 3: 'baz'}</span></pre><p id="1c0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">从列表中删除重复项并保留顺序:</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="8370" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; from collections import OrderedDict</span><span id="a97b" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;&gt; nums = [1, 2, 4, 3, 0, 4, 1, 2, 5]<br/>&gt;&gt;&gt; list(OrderedDict.fromkeys(nums))<br/>[1, 2, 4, 3, 0, 5]</span><span id="8053" class="ly lz iq lu b gy me mb l mc md"><em class="ls"># As of Python 3.6 (for the CPython implementation) and<br/># as of 3.7 (across all implementations) dictionaries remember<br/># the order of items inserted. So, a better one is:</em><br/>&gt;&gt;&gt; list(dict.fromkeys(nums))<br/>[1, 2, 4, 3, 0, 5]</span></pre><p id="6fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建多级嵌套字典:</strong></p><p id="7684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个字典作为字典中的值。本质上，它是一本多层次的字典。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="ebe6" class="ly lz iq lu b gy ma mb l mc md">from collections import defaultdict</span><span id="a7cf" class="ly lz iq lu b gy me mb l mc md"><strong class="lu ir">def </strong>multi_level_dict():<br/>    <em class="ls">""" Constructor for creating multi-level nested dictionary. """<br/><br/>    </em><strong class="lu ir">return </strong>defaultdict(multi_level_dict)</span></pre><p id="8f63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例 1: </em></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="5983" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; d = multi_level_dict()<br/>&gt;&gt;&gt; d['a']['a']['y'] = 2<br/>&gt;&gt;&gt; d['b']['c']['a'] = 5<br/>&gt;&gt;&gt; d['x']['a'] = 6</span><span id="fa14" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;&gt; d<br/>{<strong class="lu ir">'a'</strong>: {<strong class="lu ir">'a'</strong>: {<strong class="lu ir">'y'</strong>: 2}}, <strong class="lu ir">'b'</strong>: {<strong class="lu ir">'c'</strong>: {<strong class="lu ir">'a'</strong>: 5}}, <strong class="lu ir">'x'</strong>: {<strong class="lu ir">'a'</strong>: 6}}</span></pre><p id="5a69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例二:</em></p><p id="d661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给出了一个产品列表，其中每个产品需要从其原产地运送到其配送中心(DC)，然后到达其目的地。给定这个列表，为通过每个 DC 装运的产品列表创建一个字典，这些产品来自每个始发地，去往每个目的地。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="0da7" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">import </strong>random<br/>random.seed(20)</span><span id="c206" class="ly lz iq lu b gy me mb l mc md"># Just creating arbitrary attributes for each Product instance<br/><strong class="lu ir">class </strong>Product:<br/>    <strong class="lu ir">def </strong>__init__(self, id):<br/>        self.id = id<br/>        self.materials = random.sample(<strong class="lu ir">'ABCD'</strong>, 3)<em class="ls"><br/>        </em>self.origin = random.choice((<strong class="lu ir">'o1'</strong>, <strong class="lu ir">'o2'</strong>))<br/>        self.destination = random.choice((<strong class="lu ir">'d1'</strong>, <strong class="lu ir">'d2'</strong>, <strong class="lu ir">'d3'</strong>))<br/>        self.dc = random.choice((<strong class="lu ir">'dc1'</strong>, <strong class="lu ir">'dc2'</strong>))<br/><br/>    <strong class="lu ir">def </strong>__repr__(self):<br/>        <strong class="lu ir">return f'P{</strong>str(self.id)<strong class="lu ir">}'</strong></span><span id="f8d3" class="ly lz iq lu b gy me mb l mc md">products = [Product(i) <strong class="lu ir">for </strong>i <strong class="lu ir">in </strong>range(20)]</span><span id="453d" class="ly lz iq lu b gy me mb l mc md"># create the multi-level dictionary<br/><strong class="lu ir">def </strong>get_dc_origin_destination_products_dict(products):<br/>    dc_od_products_dict = multi_level_dict()<br/>    <strong class="lu ir">for </strong>p <strong class="lu ir">in </strong>products:<br/>        dc_od_products_dict[p.dc][p.origin].setdefault(p.destination, []).append(p)<br/>    <strong class="lu ir">return </strong>dc_od_products_dict</span><span id="c064" class="ly lz iq lu b gy me mb l mc md">dc_od_orders_dict = get_dc_origin_destination_products_dict(products)<br/>&gt;&gt;&gt; dc_od_orders_dict<br/>{<strong class="lu ir">'dc1'</strong>: {<strong class="lu ir">'o2'</strong>: {<strong class="lu ir">'d3'</strong>: [P0, P15],<br/>                <strong class="lu ir">'d1'</strong>: [P2, P9, P14, P18],<br/>                <strong class="lu ir">'d2'</strong>: [P3, P13]},<br/>         <strong class="lu ir">'o1'</strong>: {<strong class="lu ir">'d1'</strong>: [P1, P16],<br/>                <strong class="lu ir">'d3'</strong>: [P4, P6, P7, P11],<br/>                <strong class="lu ir">'d2'</strong>: [P17, P19]}},<br/> <strong class="lu ir">'dc2'</strong>: {<strong class="lu ir">'o1'</strong>: {<strong class="lu ir">'d1'</strong>: [P5, P12], <br/>                <strong class="lu ir">'d3'</strong>: [P10]},<br/>         <strong class="lu ir">'o2'</strong>: {<strong class="lu ir">'d1'</strong>: [P8]}}}</span></pre><p id="ac5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，当您运行以上两个示例时，您应该在输出中看到<code class="fe mf mg mh lu b">defaultdict(&lt;function __main__.multi_level_dict()&gt;...)</code>。但是为了结果的易读性，这里删除了它们。</p><p id="8c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">返回嵌套字典最内层的键和值:</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="e5f2" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">from </strong>collections <strong class="lu ir">import </strong>abc<br/><br/><strong class="lu ir">def </strong>nested_dict_iter(nested):<br/>    <em class="ls">""" Return a generator of the keys and values from the innermost layer of a nested dict. """<br/><br/>    </em><strong class="lu ir">for </strong>key, value <strong class="lu ir">in </strong>nested.items():<br/>        <em class="ls"># Check if value is a dictionary<br/>        </em><strong class="lu ir">if </strong>isinstance(value, abc.Mapping):<br/>            <strong class="lu ir">yield from </strong>nested_dict_iter(value)<br/>        <strong class="lu ir">else</strong>:<br/>            <strong class="lu ir">yield </strong>key, value</span></pre><p id="cc6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于此功能，有几点需要说明:</p><ul class=""><li id="b126" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><code class="fe mf mg mh lu b">nested_dict_iter</code>函数返回一个<a class="ae kv" href="https://wiki.python.org/moin/Generators" rel="noopener ugc nofollow" target="_blank">生成器</a>。</li><li id="273f" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">在每个循环中，字典值被递归地检查，直到到达最后一层。</li><li id="2b41" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">在条件检查中，为了通用性，使用了<code class="fe mf mg mh lu b"><a class="ae kv" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="noopener ugc nofollow" target="_blank">collections.abc.Mapping</a></code>而不是<code class="fe mf mg mh lu b">dict</code>。这样就可以检查容器对象，比如<code class="fe mf mg mh lu b">dict</code>、<code class="fe mf mg mh lu b">collections.defaultdict</code>、<code class="fe mf mg mh lu b">collections.OrderedDict</code>和<code class="fe mf mg mh lu b">collections.Counter</code>。</li><li id="ef03" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">为什么是<code class="fe mf mg mh lu b">yield from</code>？简短而不完整的回答:它是为需要从生成器内部调用生成器的情况而设计的。我知道一个简短的解释不能做到任何公正，所以检查<a class="ae kv" href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3" rel="noopener ugc nofollow" target="_blank">这个 so 线程</a>以了解更多信息。</li></ul><p id="8828" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例 1: </em></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="b609" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; d = {'a':{'a':{'y':2}},'b':{'c':{'a':5}},'x':{'a':6}}<br/>&gt;&gt;&gt; list(nested_dict_iter(d))<br/>[('y', 2), ('a', 5), ('a', 6)]</span></pre><p id="a87c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">示例 2: </em>让我们从上面的<code class="fe mf mg mh lu b">dc_od_orders_dict</code>中检索键和值。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3b78" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; list(nested_dict_iter(dc_od_orders_dict))<br/>[('d3', [P0, P15]),<br/> ('d1', [P2, P9, P14, P18]),<br/> ('d2', [P3, P13]),<br/> ('d1', [P1, P16]),<br/> ('d3', [P4, P6, P7, P11]),<br/> ('d2', [P17, P19]),<br/> ('d1', [P5, P12]),<br/> ('d3', [P10]),<br/> ('d1', [P8])]</span></pre><p id="a16b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">多个集合的交集:</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3e80" class="ly lz iq lu b gy ma mb l mc md">def get_common_attr(attr, *args):<br/>    """ intersection requires 'set' objects """</span><span id="4c38" class="ly lz iq lu b gy me mb l mc md">    return set.intersection(*[set(getattr(a, attr)) for a in args])</span></pre><p id="1032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例:</em>找出前 5 个<code class="fe mf mg mh lu b">products</code>中的共同组成材料(如果有的话)。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="9886" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; get_common_attr(<strong class="lu ir">'materials'</strong>, *products[:5])<br/>{'B'}</span></pre><p id="4e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一场比赛:</strong></p><p id="7370" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从符合条件的 iterable 中查找第一个元素(如果有的话)。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="0417" class="ly lz iq lu b gy ma mb l mc md">first_match = next(i <strong class="lu ir">for </strong>i <strong class="lu ir">in </strong>iterable <strong class="lu ir">if </strong>check_condition(i))</span><span id="156d" class="ly lz iq lu b gy me mb l mc md"># Example:<br/>&gt;&gt;&gt; nums = [1, 2, 4, 0, 5]<br/>&gt;&gt;&gt; next(i for i in nums if i &gt; 3)<br/>4</span></pre><p id="da9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有找到匹配，上面的实现抛出一个<code class="fe mf mg mh lu b">StopIteration</code>异常。我们可以通过返回一个默认值来解决这个问题。既然来了，就让它成为一个函数吧:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2e63" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">def </strong>first_match(iterable, check_condition, default_value=<strong class="lu ir">None</strong>):<br/>    <strong class="lu ir">return </strong>next((i <strong class="lu ir">for </strong>i <strong class="lu ir">in </strong>iterable <strong class="lu ir">if </strong>check_condition(i)), default_value)</span></pre><p id="d209" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例如:</em></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="4a74" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; nums = [1, 2, 4, 0, 5]<br/>&gt;&gt;&gt; first_match(nums, lambda x: x &gt; 3)<br/>4<br/>&gt;&gt;&gt; first_match(nums, lambda x: x &gt; 9) # returns nothing<br/>&gt;&gt;&gt; first_match(nums, lambda x: x &gt; 9, 'no_match')<br/>'no_match'</span></pre><p id="93db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">动力组:</strong></p><p id="1cef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集合<strong class="ky ir"> <em class="ls"> S </em> </strong>的幂集是<strong class="ky ir"> <em class="ls"> S </em> </strong>的所有子集的集合。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="c423" class="ly lz iq lu b gy ma mb l mc md">import itertools as it</span><span id="ca7b" class="ly lz iq lu b gy me mb l mc md"><strong class="lu ir">def </strong>powerset(iterable):<em class="ls"><br/>    </em>s = list(iterable)<br/>    <strong class="lu ir">return </strong>it.chain.from_iterable(it.combinations(s, r)<br/>                                  <strong class="lu ir">for </strong>r <strong class="lu ir">in </strong>range(len(s) + 1))</span></pre><p id="e03e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例如:</em></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="65b9" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; list(powerset([1,2,3]))<br/>[(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]</span></pre><p id="eb53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">定时器装饰器:</strong></p><p id="bbd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显示每个类/方法/函数的运行时。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="053c" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">from </strong>time <strong class="lu ir">import </strong>time<br/><strong class="lu ir">from </strong>functools <strong class="lu ir">import </strong>wraps<br/><br/><strong class="lu ir">def </strong>timeit(func):<br/>    <em class="ls">"""<br/>    </em><strong class="lu ir">:param</strong><em class="ls"> func: Decorated function<br/>    </em><strong class="lu ir">:return</strong><em class="ls">: Execution time for the decorated function<br/>    """<br/><br/>    </em>@wraps(func)<br/>    <strong class="lu ir">def </strong>wrapper(*args, **kwargs):<br/>        start = time()<br/>        result = func(*args, **kwargs)<br/>        end = time()<br/>        print(<strong class="lu ir">f'{</strong>func.__name__<strong class="lu ir">} executed in {</strong>end - start<strong class="lu ir">:.4f} seconds'</strong>)<em class="ls"><br/>        </em><strong class="lu ir">return </strong>result<br/><br/>    <strong class="lu ir">return </strong>wrapper</span></pre><p id="72fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">例如:</em></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="b0a1" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">import </strong>random</span><span id="c891" class="ly lz iq lu b gy me mb l mc md"># An arbitrary function<br/>@timeit<br/><strong class="lu ir">def </strong>sort_rnd_num():<br/>    numbers = [random.randint(100, 200) <strong class="lu ir">for </strong>_ <strong class="lu ir">in </strong>range(100000)]<br/>    numbers.sort()<br/>    <strong class="lu ir">return </strong>numbers</span><span id="e6bb" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;&gt; numbers = sort_rnd_num()<br/>sort_rnd_num executed in 0.1880 seconds</span></pre><p id="35df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">计算文件中的总行数:</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="67db" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">def </strong>file_len(file_name, encoding=<strong class="lu ir">'utf8'</strong>):<br/>    <strong class="lu ir">with </strong>open(file_name, encoding=encoding) <strong class="lu ir">as </strong>f:<br/>        i = -1<br/>        <strong class="lu ir">for </strong>i, line <strong class="lu ir">in </strong>enumerate(f):<br/>            <strong class="lu ir">pass<br/>    return </strong>i + 1</span></pre><p id="fd93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">举例:</em>你当前目录的 python 文件有多少行代码？</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1f53" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; from pathlib import Path</span><span id="28bb" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;&gt; p = Path()<br/>&gt;&gt;&gt; path = p.resolve()  # similar to os.path.abspath()<br/>&gt;&gt;&gt; print(sum(file_len(f) for f in path.glob('*.py')))<br/>745</span></pre><p id="d87c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">只是为了好玩！创建长标签:</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="70af" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; s = "#this is how I create very long hashtags"<br/>&gt;&gt;&gt; "".join(s.title().split())<br/>'#ThisIsHowICreateVeryLongHashtags'</span></pre><h1 id="b1ca" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated"><strong class="ak">以下不是一口大小的食谱，但不要被这些错误咬到！</strong></h1><p id="3f07" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">注意不要混淆可变和不可变对象！<br/> <em class="ls">示例:</em>用空列表作为值初始化字典</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="4cdc" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; nums = [1, 2, 3, 4]<br/># Create a dictionary with keys from the list. <br/># Let's implement the dictionary in two ways<br/>&gt;&gt;&gt; d1 = {n: [] for n in nums}<br/>&gt;&gt;&gt; d2 = dict.fromkeys(nums, [])<br/># d1 and d2 may look similar. But list is mutable.<br/>&gt;&gt;&gt; d1[1].append(5)<br/>&gt;&gt;&gt; d2[1].append(5)<br/># Let's see if d1 and d2 are similar<br/>&gt;&gt;&gt; print(f'd1 = {d1} \nd2 = {d2}')<br/>d1 = {1: [5], 2: [], 3: [], 4: []} <br/>d2 = {1: [5], 2: [5], 3: [5], 4: [5]}</span></pre><p id="87f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要在遍历列表时修改它！</p><p id="dce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">示例:</em>从列表中删除所有小于 5 的数字。</p><p id="3bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">错误实现:</em>迭代时移除元素！</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2a8e" class="ly lz iq lu b gy ma mb l mc md">nums = [1, 2, 3, 5, 6, 7, 0, 1]<br/>for ind, n in enumerate(nums):<br/>    if n &lt; 5:<br/>        del(nums[ind])</span><span id="6624" class="ly lz iq lu b gy me mb l mc md"># expected: nums = [5, 6, 7]<br/>&gt;&gt;&gt; nums<br/>[2, 5, 6, 7, 1]</span></pre><p id="87de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">正确实施:</em></p><p id="6582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用列表理解创建一个新列表，只包含您想要的元素:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="af21" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; id(nums)  # before modification <br/>2090656472968<br/>&gt;&gt;&gt; nums = [n for n in nums if n &gt;= 5]<br/>&gt;&gt;&gt; nums<br/>[5, 6, 7]<br/>&gt;&gt;&gt; id(nums)  # after modification<br/>2090656444296</span></pre><p id="2212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在上面看到,<code class="fe mf mg mh lu b"><a class="ae kv" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank">id</a>(nums)</code>在前面和后面被检查，以表明实际上这两个列表是不同的。因此，如果在其他地方使用该列表，并且改变现有列表很重要，而不是创建一个同名的新列表，则将它分配给切片:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1244" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;&gt; nums = [1, 2, 3, 5, 6, 7, 0, 1]<br/>&gt;&gt;&gt; id(nums)  # before modification <br/>2090656472008<br/>&gt;&gt;&gt; nums[:] = [n for n in nums if n &gt;= 5]<br/>&gt;&gt;&gt; id(nums)  # after modification<br/>2090656472008</span></pre><p id="eb15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前就这样了(查看第二个小型博客<a class="ae kv" rel="noopener" target="_blank" href="/bite-sized-python-recipes-vol-2-385d00d17388">这里</a>)。如果你也有一些经常使用的小函数，请告诉我。我会尽量让<a class="ae kv" href="https://github.com/ekhoda/utilities/blob/master/Bite-Sized%20Recipes.ipynb" rel="noopener ugc nofollow" target="_blank">的笔记本</a>在 GitHub 上保持最新，你的也可以在那里结束！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="f4b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">我可以在</em> <a class="ae kv" href="https://twitter.com/EhsanKhoda" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> Twitter </em> </a> <em class="ls">和</em><a class="ae kv" href="https://www.linkedin.com/in/ehsankhodabandeh" rel="noopener ugc nofollow" target="_blank"><em class="ls">LinkedIn</em></a><em class="ls">上联系到。</em></p></div></div>    
</body>
</html>