<html>
<head>
<title>Advent of code: SQL + BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码的出现:SQL + BigQuery</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advent-of-code-sql-bigquery-31e6a04964d4?source=collection_archive---------13-----------------------#2019-12-05">https://towardsdatascience.com/advent-of-code-sql-bigquery-31e6a04964d4?source=collection_archive---------13-----------------------#2019-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fa2a057e12ae551b4175b0937c264979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZWeMTevipO-LXc1DAHGKA.png"/></div></div></figure><div class=""/><div class=""><h2 id="69b4" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated"><a class="ae kq" href="https://adventofcode.com/2019/stats" rel="noopener ugc nofollow" target="_blank">成千上万的程序员正在用他们最喜欢的编程语言解决即将到来的代码挑战。如果我可以利用这个机会来突出 SQL 和最新的 BigQuery 特性的威力，那会怎么样？</a></h2></div><h1 id="015d" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">2020 年更新:有雪花</h1><p id="4f20" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用 SQL 线程检查我的<a class="ae kq" href="https://twitter.com/felipehoffa/status/1334666348794839041" rel="noopener ugc nofollow" target="_blank"> 2020 代码:</a></p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e34f" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">以及<a class="ae kq" href="https://github.com/fhoffa/AdventOfCodeSQL/" rel="noopener ugc nofollow" target="_blank"> GitHub 回购</a>:</p><div class="ip iq gp gr ir mq"><a href="https://github.com/fhoffa/AdventOfCodeSQL/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd jc gy z fp mv fr fs mw fu fw ja bi translated">FH off/AdventOfCodeSQL</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ix mq"/></div></div></a></div><blockquote class="nf"><p id="a0a2" class="ng nh jb bd ni nj nk nl nm nn no me dk translated"><a class="ae kq" href="https://adventofcode.com/2019/about" rel="noopener ugc nofollow" target="_blank"> <em class="np">降临码</em> </a> <em class="np">是一个降临日历的小编程难题，为各种技能集和技能水平。</em></p></blockquote><p id="a1c4" class="pw-post-body-paragraph lj lk jb ll b lm nq kc lo lp nr kf lr ls ns lu lv lw nt ly lz ma nu mc md me ij bi translated">如果您可以使用 SQL 和 BigQuery 来编写编译器、交叉路径、递归运行计算和破解密码，会怎么样？#adventofcode2019，开始啦！</p><h1 id="6168" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">问题 1:递归迭代</h1><p id="f280" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae kq" href="https://adventofcode.com/2019/day/1" rel="noopener ugc nofollow" target="_blank">问题</a>，<a class="ae kq" href="https://github.com/fhoffa/code_snippets/blob/master/2019_advent_of_code/01_02.sql" rel="noopener ugc nofollow" target="_blank"> BigQuery 解决方案</a></p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/22472d0bcff188d624dd34b6e217319b.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*Qf5CIXn2RynOTNSXheAq9g.png"/></div></figure><p id="6c55" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">在 BigQuery 中运行递归函数并不容易——但是现在我们可以做<a class="ae kq" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting" rel="noopener ugc nofollow" target="_blank">循环和通用脚本</a>。这是我用来解决第二部分问题的主要循环:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="38ac" class="ob ks jb nx b gy oc od l oe of">LOOP<br/>  IF (SELECT SUM(x) FROM UNNEST(extra) x)&lt;=0 THEN<br/>    LEAVE;<br/>  END IF;  <br/>  SET weight= weight+(SELECT SUM(x) FROM UNNEST(extra) x);<br/>  SET extra = (SELECT ARRAY_AGG(fuel(x)) x FROM UNNEST(extra) x);<br/>END LOOP;</span></pre><p id="562f" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">和一个方便的 SQL UDF:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="7ef6" class="ob ks jb nx b gy oc od l oe of">CREATE TEMP FUNCTION fuel(x ANY TYPE) AS (<br/> GREATEST(0,FLOOR(x/3)-2)<br/>);</span></pre><p id="0707" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">我在这里必须解决的最有趣的问题是:我不能有一个<code class="fe og oh oi nx b">cursor</code>来逐行计算每个组件的燃料。所以我必须找出一种并行处理每个 rocket 组件(输入行)的方法——这使得查询方式更加高效。</p><h1 id="2a8a" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">问题 2:数据作为代码</h1><p id="91f7" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae kq" href="https://adventofcode.com/2019/day/2" rel="noopener ugc nofollow" target="_blank">问题</a>，<a class="ae kq" href="https://github.com/fhoffa/code_snippets/blob/master/2019_advent_of_code/02_02.sql" rel="noopener ugc nofollow" target="_blank"> BigQuery 解决方案</a></p><p id="6d04" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">可以用 SQL 和 BigQuery 写编译器吗？我们完成图灵了吗？</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/988b7fcb0efeb6939c53dee2dff75f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*6ljO2dUVteNdRQ1TIgUwJg.png"/></div></figure><p id="02ac" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">同样，使用脚本<code class="fe og oh oi nx b">LOOP</code>允许我迭代一个输入数组——它定义了从循环中读取时要执行的代码:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="0129" class="ob ks jb nx b gy oc od l oe of">LOOP<br/>  IF(input[OFFSET(code_pos)]=99) <br/>    THEN LEAVE;<br/>  END IF;<br/>  SET input = (SELECT parse(input, code_pos));<br/>  SET code_pos = code_pos+ 4;<br/>END LOOP;</span></pre><p id="7e8b" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">最有趣的部分是我如何使用<code class="fe og oh oi nx b">ARRAY_AGG()</code>和<code class="fe og oh oi nx b">CASE</code>按照指示重写每个数组的内容:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="336a" class="ob ks jb nx b gy oc od l oe of">SELECT ARRAY_AGG(k) FROM (<br/>SELECT <br/>CASE n<br/>WHEN x[OFFSET(off+3)] THEN <br/>  CASE x[OFFSET(off+0)] <br/>  WHEN 1 THEN x[OFFSET(x[OFFSET(off+1)])]+x[OFFSET(x[OFFSET(off+2)])]<br/>  WHEN 2 THEN x[OFFSET(x[OFFSET(off+1)])]*x[OFFSET(x[OFFSET(off+2)])]<br/>  END<br/>ELSE xx<br/>END k<br/>FROM UNNEST(x) xx WITH OFFSET n<br/>ORDER BY n</span></pre><p id="7e11" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">然后我不得不面对的最困难的问题是——如何做 99*99 次来找到第二部分的答案？这并不漂亮，但它涉及数组的数组，并在(幸运的)线性空间中进行缓慢的搜索。</p><p id="696b" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">警告:搜索 200 个可能的解决方案需要 2 分钟以上。但是由于特定的语句是线性的，你可以跳到正确的结果。</p><h1 id="a9ab" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">问题 3:我们会在哪里相遇</h1><p id="b69f" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae kq" href="https://adventofcode.com/2019/day/3" rel="noopener ugc nofollow" target="_blank">问题</a>，<a class="ae kq" href="https://github.com/fhoffa/code_snippets/blob/master/2019_advent_of_code/03_02.sql" rel="noopener ugc nofollow" target="_blank"> BigQuery 解决方案</a></p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/daa0709a271dc822258a00b797146ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*E6f2XuD31posIR_gc5J9tw.png"/></div></figure><p id="73cb" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">这是一个有趣的地图遍历问题——对于这个解决方案，我使用了生成 SQL 数组的能力来详细描述每个步骤:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="13ff" class="ob ks jb nx b gy oc od l oe of">FROM [...], UNNEST(GENERATE_ARRAY(x-move.x, x, IF(move.x&gt;0,1,-1))) arr_x WITH offset n1, UNNEST(GENERATE_ARRAY(y-move.y, y, IF(move.y&gt;0,1,-1))) arr_y WITH OFFSET n2</span></pre><p id="b027" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">寻找交叉点的路径之间的连接非常优雅:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="c670" class="ob ks jb nx b gy oc od l oe of">USING(arr_x, arr_y)</span></pre><p id="c373" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">一个方便的函数解析输入并生成二维运动指令:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="1414" class="ob ks jb nx b gy oc od l oe of">CREATE TEMP FUNCTION parse(x ANY TYPE) AS (<br/> CASE REGEXP_EXTRACT(x, '^(.)')<br/> WHEN 'D' THEN STRUCT(0 AS x,-parse_n(x) AS y)<br/> WHEN 'R' THEN (parse_n(x),0)<br/> WHEN 'U' THEN (0,parse_n(x))<br/> WHEN 'L' THEN (-parse_n(x),0)<br/> END<br/>);</span></pre><p id="d55b" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">我很自豪能够重新分解路径生成代码，使解决方案易于查看:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="579e" class="ob ks jb nx b gy oc od l oe of">SELECT ABS(arr_x) + ABS(arr_y) distance, (a.rn + b.rn) wire<br/>FROM (<br/>  SELECT * FROM UNNEST(route('L996,D167,R633,...'))<br/>) a<br/>JOIN (<br/>  SELECT * FROM UNNEST(route('R995,U982,R941,...'))<br/>) b<br/>USING(arr_x, arr_y)<br/>WHERE a.rn&gt;0 AND b.rn&gt;0<br/>ORDER BY wire <br/>LIMIT 1</span></pre><h1 id="c471" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">问题 4:密码是…</h1><p id="f9b3" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae kq" href="https://adventofcode.com/2019/day/4" rel="noopener ugc nofollow" target="_blank">问题</a>，<a class="ae kq" href="https://github.com/fhoffa/code_snippets/blob/master/2019_advent_of_code/04_02.sql" rel="noopener ugc nofollow" target="_blank"> BigQuery 解决方案</a></p><p id="8689" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">这里的代码非常短！我希望我编写的手动数组位置更少，但是这样做花费的时间比计算一般情况要少:</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="1c60" class="ob ks jb nx b gy oc od l oe of">SELECT * <br/>FROM (<br/>  SELECT CAST(FORMAT('%i%i%i%i%i%i',n0, n1, n2, n3, n4, n5) AS INT64) number<br/>  FROM (<br/>    SELECT n0, n1, n2, n3, n4, n5<br/>    FROM UNNEST(GENERATE_ARRAY(1, 5)) n0<br/>    , UNNEST(GENERATE_ARRAY(1, 9)) n1<br/>    , UNNEST(GENERATE_ARRAY(1, 9)) n2<br/>    , UNNEST(GENERATE_ARRAY(1, 9)) n3<br/>    , UNNEST(GENERATE_ARRAY(1, 9)) n4<br/>    , UNNEST(GENERATE_ARRAY(1, 9)) n5<br/>    WHERE n1&gt;=n0<br/>    AND n2&gt;=n1<br/>    AND n3&gt;=n2<br/>    AND n4&gt;=n3<br/>    AND n5&gt;=n4<br/>    AND (<br/>    (n1=n0 AND n1!=n2)<br/>    OR (n2=n1 AND n1!=n0 AND n2!=n3)<br/>    OR (n3=n2 AND n2!=n1 AND n3!=n4)<br/>    OR (n4=n3 AND n3!=n2 AND n4!=n5)<br/>    OR (n5=n4 AND n4!=n3)<br/>    )<br/>  )<br/>)<br/>WHERE number BETWEEN 109165 AND 576723</span></pre><p id="e964" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">如你所见,<code class="fe og oh oi nx b">GENERATE_ARRAY()</code>帮助创造了寻找解决方案的空间。</p><h1 id="a3bb" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">第五天</h1><p id="aa09" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当我写下这些想法时，问题仍然没有被公布…</p><p id="bbcb" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">嗯……现在是了，但是我要回家了。能不能同时解决？</p><p id="0e2a" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated"><strong class="ll jc">更新</strong>:问题是第 2 天的延续。建造这台“图灵机”在第二天很有趣，但我不想加倍努力。</p><h1 id="8305" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">第六天:图形遍历</h1><p id="b834" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae kq" href="https://adventofcode.com/2019/day/6" rel="noopener ugc nofollow" target="_blank">问题</a>，<a class="ae kq" href="https://github.com/fhoffa/code_snippets/blob/master/2019_advent_of_code/06_02.sql" rel="noopener ugc nofollow" target="_blank"> BigQuery 解决方案</a></p><p id="3aa4" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">浏览图表并不需要花费太多精力来编写脚本——但是它强调了当一个函数必须经历多次迭代时，BigQuery 可能会很慢。在这种情况下，处理 547 条语句需要大约 20 分钟。提醒一下:BigQuery 在处理万亿字节的数据方面令人难以置信，但不一定能解决一般的计算问题。</p><pre class="mf mg mh mi gt nw nx ny nz aw oa bi"><span id="9cb6" class="ob ks jb nx b gy oc od l oe of">LOOP<br/>  SET steps = steps+1<br/>  ;<br/>  CREATE OR REPLACE TEMP TABLE planets AS<br/>  SELECT DISTINCT planet<br/>  FROM (<br/>    SELECT origin planet FROM t1 WHERE dest IN (SELECT planet FROM planets)<br/>    UNION ALL<br/>    SELECT dest planet FROM t1 WHERE origin IN (SELECT planet FROM planets)<br/>  )<br/>  ;<br/>  IF 'SAN' IN (SELECT * FROM planets )<br/>      THEN LEAVE;<br/>  END IF;<br/>END LOOP</span></pre><p id="cdac" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">现在，如果这个问题不是一次性的，我就不会每次都遍历图，而是预先计算一个更好的结构，用所有路径来立即找到交叉点(因为这是树，不是图)。</p><h1 id="d261" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">最后的想法</h1><p id="9ce2" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><strong class="ll jc"> <em class="ol">我会推荐 SQL 作为通用编程问题工具</em>？</strong></p><p id="54da" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">不要！</p><p id="367d" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">…但对我来说，这是一种尝试 SQL 和 BigQuery 极限的有趣方式。脚本是一个新特性，我还在适应它的语法和局限性。到目前为止，一切顺利。</p><p id="3dbd" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated"><a class="ae kq" href="https://adventofcode.com/2019/" rel="noopener ugc nofollow" target="_blank">以代码挑战赛的到来为例！</a></p><h2 id="f41d" class="ob ks jb bd kt om on dn kx oo op dp lb ls oq or ld lw os ot lf ma ou ov lh ow bi translated">作为奖励:使用这些技巧来打动你的朋友！</h2><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="bc4d" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated">感谢<a class="ox oy ep" href="https://medium.com/u/ef484db59f33?source=post_page-----31e6a04964d4--------------------------------" rel="noopener" target="_blank">艾捷拉哈默利</a>、<a class="ox oy ep" href="https://medium.com/u/76966eff5267?source=post_page-----31e6a04964d4--------------------------------" rel="noopener" target="_blank">马诺马克斯</a>、<a class="ox oy ep" href="https://medium.com/u/39304bcc338a?source=post_page-----31e6a04964d4--------------------------------" rel="noopener" target="_blank">本布莱特辛</a>、……早期的鼓励。</p><p id="b137" class="pw-post-body-paragraph lj lk jb ll b lm ml kc lo lp mm kf lr ls mn lu lv lw mo ly lz ma mp mc md me ij bi translated"><em class="ol">(可以代码 763369-9f36786d 加入 BigQuery SQL 排行榜)</em></p></div></div>    
</body>
</html>