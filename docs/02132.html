<html>
<head>
<title>Solving A Data Science Challenge - The Visual Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决数据科学挑战——可视化方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-a-data-science-challenge-the-visual-way-355cfabcb1c5?source=collection_archive---------14-----------------------#2019-04-08">https://towardsdatascience.com/solving-a-data-science-challenge-the-visual-way-355cfabcb1c5?source=collection_archive---------14-----------------------#2019-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f5cd3a695ae2daa4b03296f58dfb12f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wyTwYsV0eu0yh9a51UgfgA.gif"/></div></div></figure><div class=""/><p id="da46" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于视觉学习者来说</p><p id="a8b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将向您展示一些使用 Foium 的很酷的地理空间可视化，包括时变制图，以及在 fo ium 地图上叠加数据宁滨，以便更深入地了解您的地理空间数据。这篇文章可以作为地理空间数据探索性分析的指南。</p><p id="b727" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在这里试图回答的主要问题是“对于一个城市的零售商来说，最理想的位置是哪里？”我做了一些假设来给这个问题提供一些背景，但事实上这与为客户做的实际研究相差不远。</p><ol class=""><li id="c309" class="kz la je kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">假设零售商实际上是某种仓库</li><li id="3203" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">我们在整个城市有大量的 GPS 数据点，这些数据点是我们车队每天访问的目的地</li></ol><h1 id="9717" class="ln lo je bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">数据</h1><p id="4d91" class="pw-post-body-paragraph kb kc je kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">正如我提到的，我们在城市里有很多 GPS 数据点。她的是快照</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/ac60e699392caec08d4f333ada0eb0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FefJK9uQZ55jRr_5H0LQog.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">GPS data showing lat, long of each data point as well as the the data &amp; time</figcaption></figure><p id="e0d8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让这个更有趣，我找到了一个列出卡尔加里所有街区的数据集，也就是这个城市:)。我们将使用这些数据来收集每个社区中最常见的场馆的一些信息，这将有助于我们将它们分成一组簇。我们的假设是，与拥有更多咖啡店或公园的街区相比，拥有更多建筑或家具店的街区更适合作为仓库，这表明这是一个住宅区。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/c641c11c0fb39b54a3539c6897e089cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49M-LvDI7eLQpV2oKJ2GWQ.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Calgary community data listing all the neighborhoods. Author of this data set has already labeled each neighborhood but since we are bunch of bad ass folks, we’d like to ignore them for now and find label each neighborhood ourselves.</figcaption></figure><p id="5247" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，无聊的事情说够了。下面是你如何为我们的 GPS 数据制作一个漂亮的热图。多田…</p><h2 id="287e" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">图表</h2><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a2969efe0a13be89469abe75c581a6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*aqv73PmQzT6QVWF-d4X4Dw.jpeg"/></div></figure><h2 id="cd01" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">代码</h2><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="5287" class="na lo je no b gy ns nt l nu nv"># Add a column with ones, then calculate sum and generate the heat<br/>sliceDF[‘count’] = 1 <br/># create map of Calgary using latitude and longitude values<br/>base_heatmap = folium.Map(location=[calgLat, calgLng], zoom_start=10)<br/># Just adding a marker for fun<br/>folium.Marker((lat,lng), popup=”label”).add_to(base_heatmap)<br/>HeatMap(data=sliceDF[[‘Lat’, ‘Lng’, ‘count’]].groupby([‘Lat’, ‘Lng’]).sum().reset_index().values.tolist(), radius=8, max_zoom=4).add_to(base_heatmap)<br/># If you want to save the map <br/>base_heatmap.save(outfile= “truckheatMap.html”)<br/># To show the map in jupyter<br/>base_heatmap</span></pre></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="2c36" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的热图实际上并没有显示出准确的情况，因为我们是在综合所有的数据点，而不考虑时间。为了更好地了解我们的舰队大部分时间在哪里，我们需要以某种方式将时间纳入其中。这篇文章漂亮的动画标题就是一种方法。观察在城市中行驶的车队可以发现他们花费更多时间的区域。所以让我们使用酷的叶子制作动画…</p><h2 id="c176" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">图表</h2><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b94c8c637fc18e569f45684188ab3391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/0*bNoiDbOLEXxU5Y2J"/></div></figure><h2 id="8d0c" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">代码</h2><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="f371" class="na lo je no b gy ns nt l nu nv"># Creating list of hours that we need to slice by to generate the time variant map<br/>df_hour_list = []<br/>for hour in sliceDF.Hour.sort_values().unique():<br/>    df_hour_list.append(sliceDF.loc[sliceDF.Hour == hour, ['Lat', 'Lng', 'count']].groupby(['Lat', 'Lng']).sum().reset_index().values.tolist())</span><span id="90a4" class="na lo je no b gy oe nt l nu nv">base_heattimemap = folium.Map(location=[latitude, longitude], zoom_start=11)<br/>HeatMapWithTime(df_hour_list, radius=8, gradient={0.2: 'blue', 0.4: 'lime', 0.6: 'orange', 1: 'red'}, min_opacity=0.8, max_opacity=1, use_local_extrema=True).add_to(base_heattimemap)<br/><br/>base_heattimemap</span></pre><p id="8506" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，这一切都很好，但这不是一种量化的方法。我们仍然需要直观地追逐这些点，并猜测最终哪些区域比其他区域更密集。如果我们有一个基于密度的图，使用网格并显示每个细胞的相对密度，会怎么样？好的，你猜对了。</p><h2 id="6118" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">图表</h2><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/4293275d74989b0013c5cb37f8c4efab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*opMNzaV6bRt42_pOnBI_rg.jpeg"/></div></figure><h2 id="4e70" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated"><strong class="ak">代码</strong></h2><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="5712" class="na lo je no b gy ns nt l nu nv"># Used a def so that if you wish to add interactivity you can do that easily later on.<br/>def plot(min_hour,max_hour,n):<br/>    #boundaries of the main rectangle<br/>    upper_right = [51.1741,-113.8925]<br/>    lower_left = [50.8672,-114.2715]<br/>    <br/>    # Creating a grid of nxn from the given cordinate corners     <br/>    grid = get_geojson_grid(upper_right, lower_left , n)<br/>    # Holds number of points that fall in each cell &amp; time window if provided<br/>    counts_array = []<br/>    <br/>    # Adding the total number of visits to each cell<br/>    for box in grid:<br/>        # get the corners for each cell<br/>        upper_right = box["properties"]["upper_right"]<br/>        lower_left = box["properties"]["lower_left"]</span><span id="c97e" class="na lo je no b gy oe nt l nu nv"># check to make sure it's in the box and between the time window if time window is given <br/>        mask = ((sliceDF.Lat &lt;= upper_right[1]) &amp; (sliceDF.Lat &gt;= lower_left[1]) &amp;<br/>            (sliceDF.Lng &lt;= upper_right[0]) &amp; (sliceDF.Lng &gt;= lower_left[0]) &amp;<br/>            (sliceDF.Hour &gt;= min_hour) &amp; (sliceDF.Hour &lt;= max_hour))</span><span id="d6c3" class="na lo je no b gy oe nt l nu nv"># Number of points that fall in the cell and meet the condition <br/>        counts_array.append(len(sliceDF[mask]))</span><span id="9dbf" class="na lo je no b gy oe nt l nu nv"># creating a base map <br/>    m = folium.Map(zoom_start = 10, location=[latitude, longitude])</span><span id="5cbf" class="na lo je no b gy oe nt l nu nv"># Add GeoJson to map<br/>    for i, geo_json in enumerate(grid):<br/>        relativeCount = counts_array[i]*100/4345<br/>        color = plt.cm.YlGn(relativeCount)<br/>        color = mpl.colors.to_hex(color)<br/>        gj = folium.GeoJson(geo_json,<br/>                style_function=lambda feature, color=color: {<br/>                    'fillColor': color,<br/>                    'color':"gray",<br/>                    'weight': 0.5,<br/>                    'dashArray': '6,6',<br/>                    'fillOpacity': 0.8,<br/>                })<br/>        m.add_child(gj)<br/>        <br/>    colormap = branca.colormap.linear.YlGn_09.scale(0, 1)<br/>    colormap = colormap.to_step(index=[0, 0.3, 0.6, 0.8 , 1])<br/>    colormap.caption = 'Relative density of fleet activity per cell'<br/>    colormap.add_to(m)</span><span id="3dfe" class="na lo je no b gy oe nt l nu nv">return m</span><span id="f50d" class="na lo je no b gy oe nt l nu nv"># limiting time window for our data to 8 am - 5 pm and also grid is 20 x 20 <br/>plot(8,17,20)</span></pre></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="1f47" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章的第二部分旨在向您展示如何使用 Foursquare APIs 来获取一些关于不同邻居的地理空间信息，将邻居分组，并最终组合结果以得出我们的结论。</p><blockquote class="og oh oi"><p id="bd91" class="kb kc oj kd b ke kf kg kh ki kj kk kl ok kn ko kp ol kr ks kt om kv kw kx ky im bi translated"><em class="je">我在谷歌的 API 上工作了很长时间，后来当我开始研究数据科学时，被介绍到 Foursquare 上，感觉棒极了。所以，对于那些不熟悉 Foursquare 的人，我强烈推荐你去看看。值了。</em></p></blockquote><p id="6803" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">社区数据如上所示。现在我们忽略作者使用的标签，并假设我们没有它们。我们的目标是自己将这些社区聚集起来，为我们的零售店(仓库)找到一个合适的区域。为此，我们使用 Foursquare explore API，但请随意查看他们的所有 API 列表，它们可能会在您的项目中派上用场。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/a81668e7c068217e44bb4c6adbd1b69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLTxpDdMaAwBAo5VRnY3tQ.jpeg"/></div></div></figure><p id="779b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您应该知道如何绘制漂亮的地图，所以让我们使用原始标签从社区数据中制作一个地图，看看发生了什么。</p><p id="5b34" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们试图为每个街区获取 n 个最常见的场所，并将这些信息输入到 k-means 聚类代码中，以便将街区分组。</p><p id="a26e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使用 explore Foursquare API 获得一个社区的公共场所列表，您需要做如下事情。</p><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="d179" class="na lo je no b gy ns nt l nu nv"># Using Foursquare's explore API get 10 most common venues around # the latitude, longitude provided within 500 m radius. <br/># You'll get the CLIENT_ID, CLIENT_SECRET and VERSION after signing up for Foursquare.(Pay attention to API call limits.)<br/>url = "<a class="ae oo" href="https://api.foursquare.com/v2/venues/explore?client_id={}&amp;client_secret={}&amp;v={}&amp;ll={},{}&amp;radius=500&amp;limit=10" rel="noopener ugc nofollow" target="_blank">https://api.foursquare.com/v2/venues/explore?client_id={}&amp;client_secret={}&amp;v={}&amp;ll={},{}&amp;radius=500&amp;limit=10</a>".format(CLIENT_ID,CLIENT_SECRET,VERSION,neigh<br/>borhood_lat,neighborhood_lng)</span><span id="07e7" class="na lo je no b gy oe nt l nu nv"># results come back in format of JSON <br/>results = requests.get(url).json()<br/>results</span></pre><p id="e889" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以把这个扩展到所有的社区。下面的数据框显示了几行结果。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/1fdbcac7d631492b083ae870127edd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kfw2EjrELMj3MR81b8sOWg.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Example of data frame including venues with their latitude and longitude</figcaption></figure><h2 id="e713" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">一个热编码</h2><p id="3ea6" class="pw-post-body-paragraph kb kc je kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">为什么？因为我们有字符串作为每个邻域的标签，需要一种方法来数字化它们，以便我们可以在分类算法中使用它们。“一个热编码”基本上解析您的标签，并为每个标签分配虚拟值，以及为每个标签创建新列，并使用 1 或 0 来确定该行表是否具有该功能。例如，云杉悬崖有咖啡馆，但可能没有健身房等等。下面的片段显示了如何“一次热编码”您的结果:</p><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="c3c7" class="na lo je no b gy ns nt l nu nv"># one hot encoding<br/>calgary_onehot = pd.get_dummies(calgary_venues[['Venue Category']], prefix="", prefix_sep="")</span><span id="097d" class="na lo je no b gy oe nt l nu nv"># add neighborhood column back to dataframe<br/>calgary_onehot['Neighbourhood'] = calgary_venues['Neighborhood']</span><span id="f9d5" class="na lo je no b gy oe nt l nu nv"># move neighborhood column to the first column<br/>fixed_columns = [calgary_onehot.columns[-1]] + list(calgary_onehot.columns[:-1])<br/>calgary_onehot = calgary_onehot[fixed_columns]</span><span id="5e43" class="na lo je no b gy oe nt l nu nv">print("calgary_onehot shape is " , calgary_onehot.shape)<br/>calgary_onehot.head()</span></pre><p id="38fc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生成的表格如下所示:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/e57a85ff0b407b4c9eb3f8624bfa9bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dc96cEsXYRfEbhTP3PboSA.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">One hot encoded dataframe</figcaption></figure><p id="c406" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更好地了解每个街区的性质，我们可以对这些结果进行分组，并对每个街区最常见的场馆进行罚款。然后，我们可以尝试标注每个邻域，例如，咖啡店和杂货店较多的邻域最有可能是住宅区，而建筑区或工厂较多的邻域可能是工业区。</p><p id="6e96" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将根据结果创建一个熊猫数据框架，包括每个社区的 10 个最常见的场馆。</p><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="e9f9" class="na lo je no b gy ns nt l nu nv">num_top_venues = 10<br/>indicators = ['st', 'nd', 'rd']</span><span id="7709" class="na lo je no b gy oe nt l nu nv">def return_most_common_venues(row, num_top_venues):<br/>    row_categories = row.iloc[1:]<br/>    row_categories_sorted = row_categories.sort_values(ascending=False)<br/>    return row_categories_sorted.index.values[0:num_top_venues]</span><span id="73af" class="na lo je no b gy oe nt l nu nv"># create columns according to number of top venues<br/>columns = ['Neighborhood']<br/>for ind in np.arange(num_top_venues):<br/>    try:<br/>        columns.append('{}{} Most Common Venue'.format(ind+1, indicators[ind]))<br/>    except:<br/>        columns.append('{}th Most Common Venue'.format(ind+1))</span><span id="2e1f" class="na lo je no b gy oe nt l nu nv"># create a new dataframe<br/>neighborhoods_venues_sorted = pd.DataFrame(columns=columns)<br/>neighborhoods_venues_sorted['Neighborhood'] = calgary_grouped['Neighbourhood']<br/>neighborhoods_venues_sorted.rename(columns={'Neighborhood':"NAME"},inplace=True)</span><span id="839f" class="na lo je no b gy oe nt l nu nv">for ind in np.arange(calgary_grouped.shape[0]):<br/>    neighborhoods_venues_sorted.iloc[ind, 1:] = return_most_common_venues(calgary_grouped.iloc[ind, :], num_top_venues)</span><span id="96a1" class="na lo je no b gy oe nt l nu nv">neighborhoods_venues_sorted.head()</span></pre><p id="a588" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果是这样的:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/a4855558095024fc08693a0e05df277c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CFxk9BMEGkqKOmWXwyXog.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Common venues per each neighborhood, cropped to fit better here but the code above find the 10 most common venues</figcaption></figure><h2 id="59f0" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">聚类邻域</h2><p id="f679" class="pw-post-body-paragraph kb kc je kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">现在，我们正处于根据我们拥有的一个热编码数据帧对我们的邻域进行聚类的阶段。在这种情况下，我使用 Sklearn 包中的 kmeans-clustering，为了能够在稍后将结果与我们社区数据中的原始分类标签进行比较，我选择使用 n=4 作为分类数。</p><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="697d" class="na lo je no b gy ns nt l nu nv"># set number of clusters<br/>kclusters = 4<br/>calgary_grouped_clustering = calgary_grouped.drop('Neighbourhood', 1)<br/># run k-means clustering<br/>kmeans = KMeans(n_clusters=kclusters, random_state=0).fit(calgary_grouped_clustering)<br/># check cluster labels generated for each row in the dataframe<br/>neighborhoods_venues_sorted['labels'] = kmeans.labels_<br/>neighborhoods_venues_sorted.head()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/e58467fdc9e40e137ff163499f4b5d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cptKsYo7dDgR8v5eiU5aMg.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">label column shows the clusters</figcaption></figure><p id="6621" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将我们的结果与包含地理位置的原始数据帧合并，并使用一些选择器绘制一个漂亮的图表，这样我们就可以过滤集群，看看发生了什么。</p><p id="0458" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">图表:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/4c1ebe57a01c1a3b9c9d6621977d090d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QU-owC4mxk-Q9n9KUKq6Aw.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Clustering results plotted with a filtering control panel</figcaption></figure><p id="7554" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现这一点的代码:</p><pre class="mr ms mt mu gt nn no np nq aw nr bi"><span id="fb4a" class="na lo je no b gy ns nt l nu nv">calgary_merged['labels'] = calgary_merged['labels'].astype(int)</span><span id="bfa5" class="na lo je no b gy oe nt l nu nv">map_clusters = folium.Map(location=[latitude, longitude], zoom_start=11)</span><span id="c88e" class="na lo je no b gy oe nt l nu nv"># set color scheme for the clusters<br/>x = np.arange(kclusters)<br/>ys = [i + x + (i*x)**2 for i in range(kclusters)]<br/>colors_array = cm.rainbow(np.linspace(0, 1, len(ys)))<br/>rainbow = [colors.rgb2hex(i) for i in colors_array]</span><span id="2f22" class="na lo je no b gy oe nt l nu nv">for cluster in range(0,kclusters): <br/>    group = folium.FeatureGroup(name='&lt;span style=\\"color: {0};\\"&gt;{1}&lt;/span&gt;'.format(rainbow[cluster-1],cluster))<br/>    for lat, lon, poi, label in zip(calgary_merged['latitude'], calgary_merged['longitude'], calgary_merged['CLASS_CODE'], calgary_merged['labels']):<br/>        if int(label) == cluster: <br/>            label = folium.Popup('ORIG. '+ str(poi) + 'Cluster ' + str(cluster), parse_html=True)<br/>            folium.CircleMarker(<br/>                (lat, lon),<br/>                radius=5,<br/>                popup=label,<br/>                color=rainbow[cluster-1],<br/>                fill=True,<br/>                fill_color=rainbow[cluster-1],<br/>                fill_opacity=0.7).add_to(group)<br/>    group.add_to(map_clusters)</span><span id="af6a" class="na lo je no b gy oe nt l nu nv">folium.map.LayerControl('topright', collapsed=False).add_to(map_clusters)<br/>map_clusters.save(outfile= "map_clusters.html")<br/>map_clusters</span></pre><h2 id="3d8f" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">将聚类与原始标签进行比较</h2><p id="3b37" class="pw-post-body-paragraph kb kc je kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">好吧，一切都很好，那又怎样？这项研究的目的是将聚类与标签进行比较，并尝试确定一个靠近零售店或仓库最小距离中心的合适位置。</p><p id="7256" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，让我们根据聚类标签和原始标签进行分组，并查看混淆矩阵。请记住，原始标签不一定是真正的标签，而仅仅是数据集作者的主观标签。因此，这应该会给我们一些想法，关于我们的标签的分布与原始标签相比有多相似，仅此而已。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/2c5c84f55d853fff277aa419215bf348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*HEMPZciJoIIKf4MF5D86Kg.jpeg"/></div></figure><p id="2865" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们发现的最终结果如下所示。红色圆圈包围了中等距离的中心(中间带中心)以及两个被确定为最有可能正在开发或工业的社区(最常见的场所是建筑、大型保留商店)</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/15f2fbfdf0b04d3dc5236b79c1282675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qS2eWNQbaZz6xP_7Ox8erw.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Most ideal area for a mid-size retail store.</figcaption></figure><h2 id="8e11" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">结论</h2><p id="b0c5" class="pw-post-body-paragraph kb kc je kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">来自车队的 GPS 数据和城市社区数据被用来支持这一发现，并形成这一结论的基础。请记住，我试图向您展示如何在不深究太多细节的情况下，快速找到这类问题的近似解决方案。</p><p id="b159" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用实际路径数据寻找中间中心要复杂得多，建模和寻找更精确答案的下一步可能是使用每个点的相对权重。</p><h2 id="60b0" class="na lo je bd lp nb nc dn lt nd ne dp lx km nf ng mb kq nh ni mf ku nj nk mj nl bi translated">参考</h2><div class="is it gp gr iu ow"><a href="https://glenbambrick.com/tag/median-center/" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jf gy z fp pb fr fs pc fu fw jd bi translated">地理空间</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">(开源地理空间 Python)“这是什么？”也称为最小距离的中心，中央中心是一个…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">glenbambrick.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ja ow"/></div></div></a></div><div class="is it gp gr iu ow"><a href="https://python-visualization.github.io/folium/" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jf gy z fp pb fr fs pc fu fw jd bi translated">0.8.3 文件</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">基于 Python 生态系统的数据优势和库的映射优势。操纵…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">python-visualization.github.io</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk ja ow"/></div></div></a></div><div class="is it gp gr iu ow"><a rel="noopener follow" target="_blank" href="/data-101s-spatial-visualizations-and-analysis-in-python-with-folium-39730da2adf"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jf gy z fp pb fr fs pc fu fw jd bi translated">数据 101s:使用 Folium 在 Python 中进行空间可视化和分析</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">这是我称之为数据 101 系列的第一篇文章，这个系列的重点是分解如何…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk ja ow"/></div></div></a></div></div></div>    
</body>
</html>