<html>
<head>
<title>How to Replace Computer Time by Beach Time — The Magic of the Shell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用海滩时间取代电脑时间——贝壳的魔力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-replace-computer-time-by-beach-time-the-magic-of-the-shell-dcb690ac5175?source=collection_archive---------34-----------------------#2019-07-22">https://towardsdatascience.com/how-to-replace-computer-time-by-beach-time-the-magic-of-the-shell-dcb690ac5175?source=collection_archive---------34-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dcba495a819128a9fe51fc77239db5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jttwaKCfTP3vIEziaLqd0w.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Beach in San Sebastian — Photo by <a class="ae jg" href="https://unsplash.com/@thecupandtheroad?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">Athena Lam on Unsplash</a></figcaption></figure><div class=""/><p id="08ca" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我编程越多，我就越懒。我只是不明白，为什么我应该做一些电脑自己能做得更好、更快、更可靠的事情。在我接近懒惰工作者的过程中，我发现 shell 脚本是一个很好的朋友和助手。虽然在过去，您可以经常使用 Windows(如果您愿意的话)，但在越来越多的计算在云中执行，服务器大多基于 Linux 的时代，在我看来，每个数据科学家和数据工程师都应该至少对 shell 脚本有一个基本的了解。(奖金:*看到我最喜欢的时间，当 shell 脚本实际上使我高兴的时候，在底部的附录。提示:它确实包含了大量的海滩时间。因为我相信，在内心深处，我们都想把时间花在做其他事情上，而不是手动移动文件，所以我想与您分享我对 shell 的个人基本知识的介绍。希望它能让你的生活变得轻松一点(如果你愿意的话，还能让你在海滩上多待些时间:)。</p><h1 id="cbcf" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基础:移动和基本的文件操作</h1><h1 id="f49c" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">四处走动</h1><p id="67b4" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果你登录了，你可能想知道的第一件事是你在哪里(提示:你可能在你的主目录中)。您可以通过将当前工作目录打印到屏幕上来找到答案:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8d7a" class="mq lf jj mm b gy mr ms l mt mu"># print working directory<br/>pwd</span></pre><p id="e976" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，您应该通过键入以下命令列出它的内容</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f00b" class="mq lf jj mm b gy mr ms l mt mu"># list contents of current directory<br/>ls</span></pre><p id="9c6a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多 bash 命令允许修饰符，即所谓的标志。它们主要由一个字母组成，在命令后面加上一个“-”。您可以通过一个接一个地写入多个标志来组合它们。有许多可能的标志。这里有一些例子</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8818" class="mq lf jj mm b gy mr ms l mt mu"># include hidden files<br/>ls -a</span><span id="13ce" class="mq lf jj mm b gy my ms l mt mu"># include hidden files and print more details <br/>ls -la</span><span id="cd29" class="mq lf jj mm b gy my ms l mt mu"># list only directory (without content)<br/>ls -1d directoryname</span></pre><p id="7180" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解有关命令的更多信息，请使用手册(手册页):</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="211a" class="mq lf jj mm b gy mr ms l mt mu"># print manual for mycommand<br/>man mycommand</span><span id="4816" class="mq lf jj mm b gy my ms l mt mu"># for example:<br/>man ls</span></pre><p id="d3de" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了四处移动，您使用<code class="fe mv mw mx mm b">cd</code>(改变目录)命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bf57" class="mq lf jj mm b gy mr ms l mt mu"># change to directory called mydirectory inside current directory<br/>cd mydirectory</span><span id="173f" class="mq lf jj mm b gy my ms l mt mu"># change to directory above<br/>cd ..</span><span id="0fee" class="mq lf jj mm b gy my ms l mt mu"># move to directory which is also inside the directory above (basically a "parallel" directory)<br/>cd ../mydirectory</span><span id="d5c4" class="mq lf jj mm b gy my ms l mt mu"># change into previous work directory<br/>cd -</span></pre><h1 id="b81b" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">高级移动</h1><p id="7106" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以使用<code class="fe mv mw mx mm b">pushd</code> / <code class="fe mv mw mx mm b">popd</code>在堆栈中添加/删除目录。一旦添加到堆栈中，您就可以在堆栈中的目录之间跳转。请注意，在构建您的堆栈时，您需要添加两次最终目录，因为最终位置总是会被覆盖(听起来比实际复杂，只要尝试一下，您就会明白我的意思)。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9685" class="mq lf jj mm b gy mr ms l mt mu"># add mydirectory to stack<br/>pushd mydirectory</span><span id="bbf6" class="mq lf jj mm b gy my ms l mt mu"># show directories in stack<br/>dirs -v </span><span id="06e0" class="mq lf jj mm b gy my ms l mt mu"># delete top repository from stack<br/>popd </span><span id="14a9" class="mq lf jj mm b gy my ms l mt mu"># change to directory numbered n (eg 2) in the stack<br/>cd ~2</span></pre><h1 id="0094" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与文件和文件夹的基本交互</h1><p id="a05e" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以通过以下方式创建一个简单的文本文件</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9cb2" class="mq lf jj mm b gy mr ms l mt mu"># create a text file called mynewtextfile.txt<br/>touch mynewtextfile.txt</span></pre><p id="47a6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件由以下人员复制、移动或删除:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="831f" class="mq lf jj mm b gy mr ms l mt mu"># copy file<br/>cp oldfilename newfilename</span><span id="2b27" class="mq lf jj mm b gy my ms l mt mu"># move/rename file<br/>mv oldfilename newfilename</span><span id="30f4" class="mq lf jj mm b gy my ms l mt mu"># delete file<br/>rm oldfilename</span></pre><p id="4b32" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建(制作)新目录:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a283" class="mq lf jj mm b gy mr ms l mt mu">mkdir mynewdirectory</span></pre><p id="70e0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目录像文件一样被复制、移动和删除。然而，复制和删除需要<code class="fe mv mw mx mm b">-r</code>(递归)标志:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f6a" class="mq lf jj mm b gy mr ms l mt mu"># copy directory<br/>cp -r folder_old folder_new# delete directory<br/>rm –r folder_to_remove# rename directory (does not require -r flag)mv old_folder new_folder</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="ffee" class="le lf jj bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">与文件交互和将命令链接在一起——稍微不太基本</h1><h1 id="500c" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与文本文件交互</h1><p id="858f" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">既然我们知道了如何移动文件，我们还想用它们做一些有用的事情。</p><p id="9436" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有四个主要选项可以访问文本文件的内容。我建议尝试一下，看看它们能做什么，它们的行为有何不同。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5110" class="mq lf jj mm b gy mr ms l mt mu"># prints whole file to screen<br/>cat mytextfile</span><span id="5cdb" class="mq lf jj mm b gy my ms l mt mu"># prints file to screen one screenful at a time<br/>more mytextfile</span><span id="e86c" class="mq lf jj mm b gy my ms l mt mu"># prints file to screen, allowing for backwards movement and returns to previous screen view after finishing<br/># note: less does not require the whole text to be read and therefore will start faster on large text files then more or text-editors<br/>less mytextfile</span><span id="365f" class="mq lf jj mm b gy my ms l mt mu"># use a text editor (for example nano or here vi)<br/>vi mytextfile</span></pre><p id="3cd4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于编辑的选择:我个人是 Vim 的忠实粉丝。然而，我承认一开始它确实有一个陡峭的学习曲线。如果你想从对初学者更友好的东西开始，你可以看看 nano。然而，为了将来，请记住 VIM，一旦您熟悉自己的工作方式，文本处理的速度将会惊人。</p><p id="1a7a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还可以返回文档的前 n 行或后 n 行</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="53bd" class="mq lf jj mm b gy mr ms l mt mu"># show first 10 rows of a document<br/>head -10 mytextfile</span><span id="42d4" class="mq lf jj mm b gy my ms l mt mu"># show last 10 rows of a document<br/>tail -10 mytextfile</span></pre><p id="a6e7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">grep</code>在文档中查找文本</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f30c" class="mq lf jj mm b gy mr ms l mt mu"># look for the string python in mytextfile<br/>grep python mytextfile</span><span id="60b7" class="mq lf jj mm b gy my ms l mt mu"># search case-insensitive<br/>grep -i python mytextfile</span><span id="defd" class="mq lf jj mm b gy my ms l mt mu"># return line-numbers with the results<br/>grep -n python mytextfile</span><span id="85c0" class="mq lf jj mm b gy my ms l mt mu"># search for a filename ("mybadfilename" in the example) (case insensitive) in all files with the ending *.py and return the occurences together with the line number<br/>grep -in mybadfilename *.py</span></pre><p id="e010" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一个例子中，我们已经看到了一个占位符的例子。*.py 表示所有以. py 结尾的文件。</p><h1 id="f6f3" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重定向输出</h1><p id="1811" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一些命令打印到屏幕上。为了将输出重定向到一个文件，我们可以使用<code class="fe mv mw mx mm b">&gt;</code>和<code class="fe mv mw mx mm b">&gt;&gt;</code>。<code class="fe mv mw mx mm b">&gt;&gt;</code>将输出附加到现有文件，或者如果文件尚不存在，则创建一个新文件。相反，<code class="fe mv mw mx mm b">&gt;</code>总是创建一个新文件。如果同名文件已经存在，它将覆盖该文件。以下是如何将<code class="fe mv mw mx mm b">grep -in mybadfilename *.py</code>命令的输出重定向到文件的示例:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f160" class="mq lf jj mm b gy mr ms l mt mu"># creates new file; if file exists, overwrites it<br/>mycommand &gt; mytextfile<br/># example:<br/>grep -in mybadfilename *.py &gt; myoutputfile</span><span id="4e81" class="mq lf jj mm b gy my ms l mt mu"># appends output to file; if myoutputfile does not exist yet, creates it<br/>mycommand &gt;&gt; mytextfile<br/># exammple:<br/>grep -in mybadfilename *.py &gt;&gt; myoutputfile</span></pre><p id="384b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果除了将输出重定向到文件，我们<strong class="ki jk">还</strong>想要将输出打印到屏幕上，我们可以使用<code class="fe mv mw mx mm b">| tee</code>。注意，完整的命令需要出现在<code class="fe mv mw mx mm b">|</code>之前。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="50fd" class="mq lf jj mm b gy mr ms l mt mu"># print output to screen plus re-direct it to file<br/>mycommand | tee myoutputfile</span><span id="f88e" class="mq lf jj mm b gy my ms l mt mu"># example:<br/>grep -in mybadfilename *.py | tee myoutputfile</span></pre><p id="99ce" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的示例中，我们已经看到了管道(|)命令的用法。它是如何工作的？<code class="fe mv mw mx mm b">|</code>将输出重定向到通常“从右边”获取输入的函数，因此输入应该在函数调用之后。一个例子:如前所述，<code class="fe mv mw mx mm b">grep</code>需要语法<code class="fe mv mw mx mm b">grep sth filename</code>。但是，您可能有一个返回输出的程序，并且想要在这个输出中寻找一些东西。这就是<code class="fe mv mw mx mm b">|</code>发挥作用的地方。例如，<code class="fe mv mw mx mm b">ps aux</code>显示系统上运行的所有进程。您可能希望搜索包含特定字符串的进程，例如 launch_。你应该这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fc8a" class="mq lf jj mm b gy mr ms l mt mu"># grep for the string launch_ in the output of ps aux<br/>ps aux | grep launch_</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="57bb" class="le lf jj bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">变量和脚本</h1><h1 id="906b" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变量</h1><p id="f3ac" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Bash 是一种脚本语言，不是类型化的。使用<code class="fe mv mw mx mm b">=</code>符号定义和分配变量。变量名、<code class="fe mv mw mx mm b">=</code>符号和值之间不能有任何空格。您可以使用<code class="fe mv mw mx mm b">$</code>后跟变量名来访问变量的内容。您可以使用<code class="fe mv mw mx mm b">echo</code>打印到屏幕上。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d950" class="mq lf jj mm b gy mr ms l mt mu"># define string variable<br/>my_string_variable="this_is_a_string"</span><span id="024b" class="mq lf jj mm b gy my ms l mt mu"># define numeric variable<br/>my_numeric_variable=3</span><span id="7f55" class="mq lf jj mm b gy my ms l mt mu"># print variable to screen<br/># (will print this_is_a_string to the screen)<br/>echo $my_string_variable</span></pre><p id="a5dc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量通常用于定义路径和文件名。当变量在文本中被重新求解时，需要在变量名周围加上<code class="fe mv mw mx mm b">{}</code>。例如，考虑刚刚创建的变量 my_string_variable。假设你想打印' this_is_a_string_1 '。为了打印变量 my_string_variable 的内容，后跟 _1，请在变量名两边使用{}:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="41ea" class="mq lf jj mm b gy mr ms l mt mu"># incorrect (bash will think that the variable is called "my_string_variable_1"):<br/>echo $my_string_variable_1</span><span id="6a82" class="mq lf jj mm b gy my ms l mt mu"># instead use:<br/>echo ${my_string_variable}_1</span></pre><p id="1b27" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二个例子中，bash 解析对 this_is_a_string 的引用，然后将 _1 追加到结果字符串中。</p><h1 id="ca79" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">环</h1><p id="5cb7" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Bash 使用<code class="fe mv mw mx mm b">for ... do ... done</code>语法进行循环。该示例显示了如何使用循环将文件 myfilename1 和 myfilename2 重命名为 myfilename1.bac 和 myfilename2.bac。请注意，列表元素之间没有逗号分隔。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="90c1" class="mq lf jj mm b gy mr ms l mt mu">rename files by appending a .bac to every filename<br/># no comma between list elements!<br/>for myfilename in myfilename1 myfilename2<br/>do<br/>  mv $filename ${filename}.bac;<br/>done</span></pre><p id="4d0b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了遍历整数列表，首先使用序列生成器生成一个列表:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e864" class="mq lf jj mm b gy mr ms l mt mu">for i in $(seq 1 3)<br/>do<br/> echo $i<br/>done</span></pre><p id="f37e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:<code class="fe mv mw mx mm b">$()</code>打开一个子 shell，在这里解析()的内容。然后将结果返回到外壳。在上面的例子中，<code class="fe mv mw mx mm b">seq 1 3</code>产生的序列 1 2 3 被传递回外壳，然后在外壳中循环。例如，这种行为可用于循环包含特定模式的文件:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f7f4" class="mq lf jj mm b gy mr ms l mt mu">for myfile in $(ls *somepattern*)<br/>do<br/>  cp myfile myfile.bac<br/>done</span></pre><h1 id="26f1" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">编写和执行(非常)基本的脚本</h1><p id="60f9" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要创建脚本，创建一个包含 bash 语法的文本文件，使其可执行并运行它。让我们看一个非常基本的(公认非常无用的)例子。创建包含以下内容的文件:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7a09" class="mq lf jj mm b gy mr ms l mt mu">#!/bin/bash</span><span id="570b" class="mq lf jj mm b gy my ms l mt mu"># print myfilename.txt<br/>echo "Hello World!"</span><span id="079e" class="mq lf jj mm b gy my ms l mt mu">exit 0</span></pre><p id="64a4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并将其保存为 print_hello_world.sh。注意文件的第一行，它告诉 shell 使用哪个解释器。您可以通过为所有者添加执行权限来使其可执行，并由。/scriptname:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3dd8" class="mq lf jj mm b gy mr ms l mt mu"># add execution rights for file myfirstbashscript.sh for the owner of the file<br/>chmod u+x print_hello_world.sh</span><span id="34a8" class="mq lf jj mm b gy my ms l mt mu"># run <br/>./print_hello_world.sh</span></pre><p id="3e7e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不是硬编码“Hello World！”，您希望用户将待问候的传递给脚本，您可以将它作为变量传递给脚本。让我们用以下内容创建一个新文件 print_hello_user.sh:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3fc8" class="mq lf jj mm b gy mr ms l mt mu">#!/bin/bash</span><span id="8cba" class="mq lf jj mm b gy my ms l mt mu"># print "Hello " + user-input <br/>echo "Hello " $1</span><span id="c070" class="mq lf jj mm b gy my ms l mt mu">exit 0</span></pre><p id="453b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们给它执行权，像这样执行</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a84e" class="mq lf jj mm b gy mr ms l mt mu">./print_hello_user.sh "Universe"</span></pre><p id="0fb8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它会将“Hello Universe”打印到屏幕上。为什么？“Universe”作为文件名作为名为 1 的变量传递给脚本后的第一个输入变量，然后通过 print 语句中的$1 命令引用它。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="cb5f" class="le lf jj bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">最后的提示和技巧</h1><ul class=""><li id="5b1e" class="nl nm jj ki b kj mc kn md kr nn kv no kz np ld nq nr ns nt bi translated">尽可能使用 tab 补全:要自动补全，请按“Tab”键。如果有多个选项，按“Tab”两次以显示所有选项。</li><li id="60d3" class="nl nm jj ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mv mw mx mm b">ESC + .</code>将从上一行带回最后一个令牌。例子:<code class="fe mv mw mx mm b">cp file_a file_b</code>；然后在下一行<code class="fe mv mw mx mm b">ESC + .</code>会产生 file_b。</li><li id="7a76" class="nl nm jj ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated">括号结束:你可以使用<code class="fe mv mw mx mm b">{}</code>来缩短你的代码。例如，如果你想重命名一个文件，你可以输入<code class="fe mv mw mx mm b">mv myfilename{,.bac}</code>。这作为<code class="fe mv mw mx mm b">mv myfilename myfilename.bac</code>执行。对于交互式工作非常有用(虽然我不会在脚本中使用它)。</li><li id="8369" class="nl nm jj ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mv mw mx mm b">tail -f myfilename</code> : <code class="fe mv mw mx mm b">tail filename</code>在执行点产生尾部。但是，您可能希望能够在编写输出脚本时跟踪它们。<code class="fe mv mw mx mm b">tail -f</code>照常开始<code class="fe mv mw mx mm b">tail</code>，但是当新的行出现在输出文件的末尾时，继续追加。</li><li id="88a9" class="nl nm jj ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mv mw mx mm b">watch -n somenumber command</code>每隔几秒执行一次命令。例如，<code class="fe mv mw mx mm b">watch -n 2 ls</code>每 2 秒运行一次 ls。观看文件传输非常棒。</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="4490" class="le lf jj bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">结论</h1><p id="5fd4" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这篇文章中，我们看了使用 shell 的基本介绍。我们已经看到了如何在 shell 环境中定位自己，如何四处移动以及一些与文件的基本交互。最后，我们已经创建并运行了我们的第一个脚本，并查看了一些我最喜欢的技巧。虽然这应该会给您一个好的开始，但这只是对 shell 脚本这个怪异而奇妙的世界的一个小小的介绍。如果你想了解更多，这里的<a class="ae jg" href="https://devhints.io/bash?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"/>是一个很好的、广泛的脚本备忘单，可能会对你有进一步的帮助。有关该主题的完整内容，请查看 Mendel Cooper 的<a class="ae jg" href="http://tldp.org/LDP/abs/html/index.html?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">对 shell 脚本艺术的深入探索</a>。和往常一样，<a class="ae jg" href="https://stackoverflow.com/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>也提供了大量的建议和帮助:)玩得开心！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="420a" class="le lf jj bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">*附录:Shell 脚本如何让我花更多时间在沙滩上</h1><p id="cc0c" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我在圣塞巴斯蒂安攻读博士学位，圣塞巴斯蒂安是巴斯克地区的首府，也是著名的“La Concha”海滩的所在地。我的论文非常注重计算，需要协调许多不同的技术。我仍然天真地记得设置我的计算机来自动生成大量用于计算的输入文件，将计算提交给超级计算中心，等待它们完成，从输出中提取相关数据，可视化结果，创建一个完整的网页层次结构，并将所有这些推送到网络服务器，这样来自世界各地的多人就可以协作查看结果。只需按一下按钮，它就能完全自动地完成所有这些工作，而且做得非常可靠，从未出错。而我呢？我正在海滩享受午餐:)</p><p id="835c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nz">原载于</em><a class="ae jg" href="https://walkenho.github.io/introduction-to-bash/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://walken ho . github . io</em></a><em class="nz">。</em></p></div></div>    
</body>
</html>