<html>
<head>
<title>How I (Sort of) Learned Computer Vision in a Couple Months</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何在几个月内学会计算机视觉的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-sort-of-learned-computer-vision-in-a-month-c3faec83b3d6?source=collection_archive---------12-----------------------#2019-12-31">https://towardsdatascience.com/how-i-sort-of-learned-computer-vision-in-a-month-c3faec83b3d6?source=collection_archive---------12-----------------------#2019-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">十年即将结束，回头看，我做得还不够。所以我搜索了一些流行词，遇到了“计算机视觉”并尝试了一下，心想，“伙计，这能有多难？我打赌我能学会这些东西，并且做得更好。”</p><p id="ee71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，我完全错了。</p><p id="f718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我没有扎实的统计背景，或者任何机器学习技能。学习比我想象的要困难得多。我想过在多个点停下来，但出于某种原因，我继续前进。现在我做了这个指南来节省初学者的时间，因为这是一个非常酷的主题。</p><h1 id="3a3c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">那么什么是计算机视觉呢？</h1><p id="8818" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">计算机视觉用来模仿人类的感知系统。我的主要动机是了解它的汽车应用，但实际上它可以应用于安全、医疗和国防工业。</p><p id="917d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在最底层，它通过过滤、寻找线条或改变图像的大小来改变图像的属性。然而，在更高的层次上，它训练一个模型来预测图像组件的类别和位置。图像处理算法涉及线性代数(特征向量、雅可比)、微积分(梯度、拉普拉斯)、统计和信号处理(卷积)的混合。</p><p id="2ca2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，现在你已经被警告了，继续行动，后果自负。</p><h1 id="538d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">简要概述</h1><p id="5a17" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">该列表涵盖了整篇文章中的主题及其顺序:</p><ul class=""><li id="383e" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">数字图象处理</li><li id="f5e1" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">支持向量机</li><li id="5969" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">神经网络</li><li id="4489" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">目标检测(CNN)</li><li id="afe5" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">对象分割(区域提议网络)</li></ul><p id="9d1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python 是我的首选语言，因为它易于实现和配置。如果内存优化是你的目标之一，那就用 C++。包括 OpenCV、Tensorflow、Keras、Numpy 在内的库是应用必不可少的。</p><h1 id="3f12" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">成为一个形象意味着什么？</h1><p id="2276" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">所有的<a class="ae mf" href="https://www.mathworks.com/help/matlab/creating_plots/image-types.html" rel="noopener ugc nofollow" target="_blank">图像</a>都是由红、绿、蓝(RGB)三个通道组成。还有其他颜色方案，如 HSV(色调、饱和度、值)，但 RGB 是最受欢迎的。</p><p id="0059" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个通道都是使用强度函数计算的强度值(像素)矩阵。强度是衡量每种颜色显示强度的标准。它将图像位置作为输入:I(x，y)。强度范围从 0 到 255。因此，您可以将图像想象为三个矩阵的叠加(每个颜色通道一个矩阵)。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/24a593b7d32dfcc1eb1f0d296d86f444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bpeSXBfRjLQpp4BAlXRuQ.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Hernandez D., et al via <a class="ae mf" href="http://www.scielo.br/scielo.php?script=sci_arttext&amp;pid=S2175-91462016000300339" rel="noopener ugc nofollow" target="_blank">Journal of Aerospace Mgmt and Tech</a> (CC); Contained in Each Element is Intensity-Value</figcaption></figure><h1 id="120c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">过滤能力</h1><p id="6af7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae mf" href="https://www.mathworks.com/help/images/what-is-image-filtering-in-the-spatial-domain.html" rel="noopener ugc nofollow" target="_blank">滤镜</a>(或内核)用于找出更多关于图像通道的信息或对其进行转换。这些较小的矩阵在图像上“滑动”,在每个中心像素上进行加权求和。这个操作是一个<a class="ae mf" href="https://www.youtube.com/watch?v=C_zFhWdM4ic" rel="noopener ugc nofollow" target="_blank"> 2D 卷积</a>，允许你模糊图像，锐化图像，最重要的是找到边缘。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/97a012b2fab34768eae9c1076293a6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/1*V4uobVv91cccRy9LtGYkKQ.gif"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Plotke, M., via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:3D_Convolution_Animation.gif" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); Demonstration of Weighted-Sum via Kernel</figcaption></figure><h1 id="2e8f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">但是到底什么是优势呢？</h1><p id="6619" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae mf" href="https://www.cse.unr.edu/~bebis/CS791E/Notes/EdgeDetection.pdf" rel="noopener ugc nofollow" target="_blank">边缘</a>是图像中强度从低到高或从高到低过渡的区域。因此，当搜索它们时，采用提供强度变化率的方向和幅度的像素梯度。更大的梯度表示更强的边缘(参见(a))。名为<a class="ae mf" href="https://www.youtube.com/watch?v=uihBwtPIBxM" rel="noopener ugc nofollow" target="_blank"> sobel </a>算子的滤波器通过使用数值方法(使用<a class="ae mf" href="https://www.youtube.com/watch?v=Jqa-aFE9-GI" rel="noopener ugc nofollow" target="_blank">向前、向后或中心差分</a>)来近似强度梯度的幅度来实现这一点。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mx"><img src="../Images/b6cdd85cf59a6b7455a58860dc6a9a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93lms37x49OexnKSPdTxHg.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Illustrated by me; Step Edge Sharp Intensity Gradient</figcaption></figure><p id="8196" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">边缘对于将图像分割成多个部分的图像分割来说非常重要。我们的眼睛很容易处理这项任务，这让我们能够识别事物，但必须以艰难的方式教会计算机。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi my"><img src="../Images/97f2e28e5b537b089eae4e6191b90a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqA5VXdJKQNvKxfO0v85lw.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Thomas, M. via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:Image-segmentation-example.jpg" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); Image Segmentation Post-Processing</figcaption></figure><h1 id="2a3d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">跟踪运动</h1><p id="8733" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在事情变得真正令人兴奋，因为我们可以用数学来看看像素是如何移动的。好吧，这听起来有点扯，但是听我说完:拍一段视频，然后把它分割成帧。在非常小的时间间隔内，帧根本不会改变。这就是<a class="ae mf" href="https://users.cs.cf.ac.uk/Dave.Marshall/Vision_lecture/node47.html" rel="noopener ugc nofollow" target="_blank">光流约束</a>。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mz"><img src="../Images/7f34e8b65c1c02a5368a927ef935b401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17Cer8f-38vBp6F4wmntmg.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Illustrated by me; I(x+dx, y+dy, t+dt) = I(x, y, t) by op flow constraint, therefore terms cancel</figcaption></figure><p id="fc5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，每一帧都是一个强度值的矩阵，因此通过一些神奇的数学(不完全是，这是一个<a class="ae mf" href="https://youtu.be/5VyLAH8BhF8?t=776" rel="noopener ugc nofollow" target="_blank">泰勒级数展开</a>)公式简化为强度变化的时间(随时间)和空间(沿 x，y 轴)速率。参数 u、v 是特定像素随时间的位置变化率(注意它们不是偏导数)。求解 u，v 是通过估计一个矩阵变换来完成的。由于关于强度值的信息很容易检索，所以给出了其它成分。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1f8fe20a8f471290e2c5046e0abcd982.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*ZTnSN2JoBxHO98lKZHHnkQ.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Illustrated by me; After cancellation get left with this</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ed8aaae0fdea0e4d07f686b801b63512.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*OM1BiGbp5bpYyd0hGu11WQ.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Illustrated by me; u = dx/dt, v = dy/dt</figcaption></figure><p id="ad86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以最后，视频的运动矢量可以被求解以确定物体如何运动。我不想用数学吓走你，但是要提醒你，从现在开始它只会变得更丑陋(以一种有趣的方式)！</p><h1 id="f314" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">高效地跟踪运动</h1><p id="bb33" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae mf" href="https://www.youtube.com/watch?v=NiGcuurpV5o" rel="noopener ugc nofollow" target="_blank">金字塔</a>用于寻找图像特征或通过向上或向下采样来帮助<a class="ae mf" href="https://www.youtube.com/watch?v=5VyLAH8BhF8" rel="noopener ugc nofollow" target="_blank">光流</a>。这仅仅意味着在保持分辨率的同时缩小或放大图像(拜托，我们不可能有土豆质量的图片)。通过匹配的角和吊杆画线！你有一个金字塔。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nc"><img src="../Images/2865c09c2f1b11be5db617959044ad5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwAwo1PcVSOBd8oACICceQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Cmglee via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:Image_pyramid.svg" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); Pyramid Structure — Notice Features Maintained Despite Blur</figcaption></figure><p id="8020" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">物体运动在非常小的尺度上得到估计，每个方向向量使用金字塔增大，这增加了运动的长度。这允许跟踪对象。</p><p id="be0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过找到连续帧之间的像素对齐来完成跟踪。通过最小化像素的估计位置与其真实位置之间的误差，可以密切跟踪感兴趣的点。这涉及使用来自光流约束方程的 u，v。</p><p id="73c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些概念的详细解释可以通过沙阿博士的<a class="ae mf" href="https://www.youtube.com/watch?v=715uLCHt4jE&amp;list=PLd3hlSJsX_Imk_BPmB_H3AQjFKZS9XgZm&amp;index=1" rel="noopener ugc nofollow" target="_blank">讲座</a> (2 — 11)和<a class="ae mf" href="https://www.youtube.com/watch?v=UhDlL-tLT2U&amp;list=PLuh62Q4Sv7BUf60vkjePfcOQc8sHxmnDX" rel="noopener ugc nofollow" target="_blank">拉德克博士的</a> (6 — 7，10 — 12)找到。关于通过代码应用这些概念的内容可以通过<a class="ae mf" href="https://www.youtube.com/watch?v=29vWJ1c9LX8&amp;list=PL6Yc5OUgcoTmTGACTa__vnifNA744Cz-q" rel="noopener ugc nofollow" target="_blank"> PySource </a>找到。</p><h1 id="65f8" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何对图像进行分类</h1><p id="3541" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">假设给你一个两类数据的散点图，你的任务是把它分开。通常，可以画一个函数来做这件事，比如直线或抛物线。然而，对于重叠或必须由非线性函数分隔的数据(例如圆圈)，使用支持向量机(SVM)。它将<a class="ae mf" href="http://courses.washington.edu/ling572/winter2017/teaching_slides/class16_svm_p2.pdf" rel="noopener ugc nofollow" target="_blank">更高维度</a>添加到数据中，以确定功能解决方案。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nd"><img src="../Images/4505a3c7b8099356aff686328336c84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hu-iffNK8wYBL6mgaYF-sQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Learner M., via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:Nonlinear_SVM_example_illustration.svg" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); SVM — Notice Added Dimension Allows Data to be Separated by Hyperplane</figcaption></figure><p id="85ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">支持向量机在图像处理中用于这种分类任务。他们接受正面和反面例子的训练，通常是为了确定随机图像是否属于某一类。</p><h1 id="45c0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何对图像进行分类，但更好</h1><p id="17db" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">特征是图像的不同部分。有效的特征可以通过使用梯度方向的直方图来发现。他们把图像的结构分解成一个向量矩阵。</p><p id="6866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个固定输入大小的图像被分割成一个固定的网格，在每个位置找到梯度的大小和角度。然后，180 度的角度范围被量化为九个仓或部分(每个包含 20 度的范围)。</p><p id="6e0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">形成包含图像上梯度角分布的直方图。面元中心用于说明落在面元之间的角度，它们必须相应地分开。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nc"><img src="../Images/81518438c31b62a9ed4ed9bbb37c3c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9reDbZDgjQU7HLidKtzmfA.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Theiler, M. via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:HOG_scikit-image_AngelaMerkel.jpeg" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); Kernel Applied Over Fixed Grid on Image -&gt; Grid of Gradients -&gt; Histogram</figcaption></figure><p id="1c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过对一群特定类别的猪(如车辆)训练 SVM，它将学习对新图像进行分类。利用图像结构，可以做一个更强的分类器！</p><h1 id="bc2b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">更多分类？我听到的是神经网络吗？</h1><p id="94c8" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我一直提到“分类”这个词，因为它有点重要。<a class="ae mf" href="https://www.youtube.com/watch?v=FK77zZxaBoI&amp;list=PLZbbT5o_s2xq7LwI2y8_QtvuXZedL6tQU&amp;index=4" rel="noopener ugc nofollow" target="_blank">神经网络</a>是另一种分类工具，只是它们可以处理具有数千个特征的多个类别。</p><p id="4c53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，应用它们的一个主要警告是它们是硬件密集型的，通常需要强大的 GPU(不是 CPU，因为我们同时处理许多事情)。这是当前工作被应用于更有效的算法或更好的硬件的地方。</p><p id="a3c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在进入细节之前，理解神经网络的结构是重要的。有不同类型的网络，现在我们将着眼于深度(全连接)神经网络。总体结构分为三个部分:</p><ul class=""><li id="af0e" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">输入层</li><li id="3f5a" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">隐蔽层</li><li id="9a9a" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">输出层</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ne"><img src="../Images/50f718c093b4299c9bc75cf4e62b71dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toBL6XleRkwABSwTAFaY_g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Burgmer, C. via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:MultiLayerNeuralNetworkBigger_english.png" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC);</figcaption></figure><p id="a276" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据在输入层提供给一个节点(称为神经元)。每个节点都连接到下一个隐藏层的每个节点。这种连接是加权的，意味着输入乘以一些标量(权重)。因此，输出层的每个节点成为其输入(来自前一层的节点)的加权和。为了将数据保持在相同的范围内，需要应用一个激活函数。有许多类型的<a class="ae mf" href="https://www.youtube.com/watch?v=m0pIlLfpXWE&amp;list=PLZbbT5o_s2xq7LwI2y8_QtvuXZedL6tQU&amp;index=5" rel="noopener ugc nofollow" target="_blank">激活</a>，现在我们将使用一个 Sigmoid 函数来限制值为[0，1]。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nf"><img src="../Images/4b9e0c8e3424be5805ed27517ec57589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eYIvvDZ3zaNK8G1tH7P_Q.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Chris, L.B via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:SigmoidFunction.png" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); Sigmoid function limits all values over domain to [0,1]</figcaption></figure><p id="8ee0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mf" href="https://www.youtube.com/watch?v=Skc8nqJirJg&amp;list=PLZbbT5o_s2xq7LwI2y8_QtvuXZedL6tQU&amp;index=8" rel="noopener ugc nofollow" target="_blank">损耗</a> <strong class="js iu"> </strong>在每个节点进行计算，作为预期和真实输出之间的差值。神经网络的目标是通过找到这样做的成本函数(权重)的参数来最小化这种损失。看那波浪表面证明它很难找到极值。我们的下一个最佳选择是通过使用梯度(指示下降点)迭代地找到极值，然后更新权重。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5806ed61a9c158d5043f513011440a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*dtQBjR5HlpzEabQzq3fHzg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Derbyshire, S. via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:Surface_with_path_of_greatest_slope.png" rel="noopener ugc nofollow" target="_blank">Wikimedia</a> (CC); Red Line Shows How Minima are Found Iteratively Via Gradient Descent, Avoiding Saddle Points Along the Way</figcaption></figure><p id="bd8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了求解神经网络的梯度，使用了一种称为<a class="ae mf" href="https://www.youtube.com/watch?v=XE3krf3CQls&amp;list=PLZbbT5o_s2xq7LwI2y8_QtvuXZedL6tQU&amp;index=23" rel="noopener ugc nofollow" target="_blank">反向传播</a>的方法。</p><h1 id="2c50" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">一种图像分类器</h1><p id="f65f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在我们将使用神经网络对图像进行分类。但是这并不是一件容易的事情，所以我们将使用一种特殊的类型:一个<a class="ae mf" href="https://www.youtube.com/watch?v=BFdMrDOx_CM" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>。注意，这是用来对整个图像进行分类的。</p><p id="1077" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其思想是取一个输入图像，用一个固定大小的核对其进行多重卷积。该组输出将是第一卷积层。然后重复这个过程。一堆内核得到应用，以增加随机性，并找到更多独特的功能！</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nh"><img src="../Images/a5ef12ab2cd3b4a080e2e7d8c01de8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIFYsepUA52UbA2EHxgdFA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: CodeEmporium via <a class="ae mf" href="https://www.youtube.com/watch?v=m8pOnJxOcqY" rel="noopener ugc nofollow" target="_blank">Youtube</a> (CC); Multiple Filters Convolved with Same Image Produce Depth</figcaption></figure><p id="f5c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着网络了解到更多区分不同图像的特征，每个卷积层的复杂性都会增加。</p><p id="4894" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，第一层可以找到线条和边缘。然而，通过第三层，它确定了定义鼻子和眼睛的线条和边缘的集合和方向。然后到了第五个阶段，它会计算出鼻子和眼睛的组合来定义一张脸。事实上，这就是模型如何被训练来分类人脸，通过阅读<a class="ae mf" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf" rel="noopener ugc nofollow" target="_blank"> haar-cascade 分类器</a>了解更多。</p><p id="31a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程就这样继续下去，这样网络就学会了对图像进行分类。在卷积层之间插入一个池层，对输出进行下采样并减少计算(基本上只记住重要的特征)。</p><p id="0cf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每一步都有深度，因为同一个图像应用了多个内核。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ni"><img src="../Images/fff293357945e7f1d58d1fca7db08cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BRLw4lsANPEfGgimG3YVQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Aphex34 via <a class="ae mf" href="https://en.wikipedia.org/wiki/Convolutional_neural_network#/media/File:Typical_cnn.png" rel="noopener ugc nofollow" target="_blank">Wikipedia</a> (CC); Pooling occurs at Subsampling Layer and Repeats until Flattened</figcaption></figure><p id="798f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到了最后一层，一系列独特的、习得的过滤器就形成了。为了将这从空间输出转换为类预测，它被展平为矢量，并最终通过全连接层馈送。然后，基于训练数据，CNN 提供图像预测(从馈送到全连接层的输出向量中挑选一个类别)。然而，它不能提供图像位置。不要担心，这个以后会改进的。</p><h1 id="1fb1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">CNN 的一些细节</h1><p id="49db" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">请注意，在每一层，图像尺寸变小。在边缘处不能进行卷积，因为内核以输入图像的像素为中心，但是其边界(虚线)之外的值是未知的。为了解决这个问题，这些像素的亮度假定为零。这在前面显示的卷积图中很明显。</p><p id="851d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它被称为<strong class="js iu"> </strong> <a class="ae mf" href="https://www.youtube.com/watch?v=qSTv_m-KFk0" rel="noopener ugc nofollow" target="_blank">零填充</a>，用于保持图像大小和空间信息。然而，一些算法不实现它，再次导致收缩。</p><h1 id="d880" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何编码 CNN 101</h1><p id="4f2d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">下面显示的是使用 Keras(构建在 Tensorflow 之上)实现的 CNN。</p><p id="e4f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，真的很简单。</p><p id="7e00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，该程序遵循上面所示的 CNN 结构，通过应用 2D 卷积，然后是池化(pool_size 表示下采样的内核有多大)，最后是展平层。然后，它使用全连接(Keras 称之为“密集”)层对输出进行分类。</p><pre class="mh mi mj mk gt nj nk nl nm aw nn bi"><span id="7a99" class="no kp it nk b gy np nq l nr ns">model = Sequential()</span><span id="6d1a" class="no kp it nk b gy nt nq l nr ns"><em class="nu">#Apply 2D conv using 32, 3x3 kernels per image with dimensions 64x64x3 (RGB), then pooling layer, then flatten output</em></span><span id="0335" class="no kp it nk b gy nt nq l nr ns">model.add(Conv2D(32, (3, 3), input_shape = (64, 64, 3), activation = 'relu'))<br/>model.add(MaxPooling2D(pool_size = (2,2)))<br/>model.add(Flatten())</span><span id="7f4c" class="no kp it nk b gy nt nq l nr ns"><em class="nu">#Use node-vector to act as input to fully-connected layer<br/>#Expect 128 nodes in hidden layer, add dense layer</em></span><span id="7a80" class="no kp it nk b gy nt nq l nr ns">model.add(Dense(units=128, activation='relu'))</span><span id="3581" class="no kp it nk b gy nt nq l nr ns"><em class="nu">#Binary classification, output layer</em></span><span id="f792" class="no kp it nk b gy nt nq l nr ns">model.add(Dense(units=1, activation='sigmoid'))<br/>model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])</span></pre><p id="41b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要了解更多关于神经网络的知识，可以搜索一下<a class="ae mf" href="https://www.youtube.com/watch?v=gZmobeGL0Yg&amp;list=PLZbbT5o_s2xq7LwI2y8_QtvuXZedL6tQU" rel="noopener ugc nofollow" target="_blank">深蜥蜴</a>和<a class="ae mf" href="https://www.youtube.com/watch?v=vT1JzLTH4G4&amp;list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv" rel="noopener ugc nofollow" target="_blank">斯坦福大学的系列讲座</a>。</p><h1 id="5d78" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">图像各部分的分类器</h1><p id="f2a9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这用于对图像的部分进行分类，也称为对象分割。在这一点上，我们非常接近许多现代计算机视觉算法背后的架构。</p><p id="851a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个架构是一个<a class="ae mf" href="https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf" rel="noopener ugc nofollow" target="_blank">全卷积网络</a>，它提供图像预测和定位，这是典型的 CNN 无法做到的。</p><p id="1353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些网络通过使用一种<a class="ae mf" href="https://www.youtube.com/watch?v=1icvxbAoPWc" rel="noopener ugc nofollow" target="_blank">编码器-解码器</a>方案来全程使用卷积。首先是编码器部分，它输出一个分类器向量。解码器利用这一点对展平向量进行上采样(通过去卷积)并预测像素的类别。输出将是掩膜或要素地图。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nv"><img src="../Images/852548fd362437045257f4224a334309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SiaMZmWt5bbSTYkKmj8aA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: <a class="ae mf" href="http://deeplearning.net/tutorial/fcn_2D_segm.html" rel="noopener ugc nofollow" target="_blank">LISA Lab</a> (Copyright 2008–2010); Decoder Network Completes Pixelwise Categorisation</figcaption></figure><p id="30b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上采样对于重新获得图像的空间信息(分类像素的映射)是必要的。来自编码器网络的较浅层的信息用于寻找图像位置，较深层的信息用于分类。<a class="ae mf" href="https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf" rel="noopener ugc nofollow" target="_blank"> FCNs </a>允许预测图像的部分，增加了更高的准确性和复杂性。获得图像遮罩被称为语义分割。</p><h1 id="b596" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么物体检测是棘手的事情</h1><p id="7df3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">必须对视频的每一帧进行分析以找出可能的类别，并且必须在预测的对象周围包裹一个边界框。典型地，滑动窗口用于寻找匹配的特征并识别图像的部分。但是用 CNN 做这个会花太多时间。</p><p id="2b89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，我们得到了地区提案！目标是找到可能包含对象的“blobby”区域，然后搜索它们。这有许多实现方式，如下所示:</p><ul class=""><li id="e7d5" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">美国有线电视新闻网地区频道</li><li id="b956" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">快速 R-CNN</li><li id="9652" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">更快的 R-CNN</li><li id="51ad" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">你只看一次(YOLO)</li><li id="6c76" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">屏蔽 R-CNN</li></ul><p id="2aa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将讨论 R-CNN，因为其余的(除了 YOLO)都是建立在这个概念之上的。</p><h1 id="961c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">一种有效的图像部分分类器</h1><p id="68c5" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">哈哈思科<a class="ae mf" href="https://www.youtube.com/watch?v=nDPWywWRIRo" rel="noopener ugc nofollow" target="_blank">R-CNN</a>效率不高。它们有点快，但仍有改进的空间。</p><p id="57d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而他们的架构被改进为开发速度快、<a class="ae mf" href="https://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks.pdf" rel="noopener ugc nofollow" target="_blank">更快、</a>、<a class="ae mf" href="https://arxiv.org/pdf/1703.06870.pdf" rel="noopener ugc nofollow" target="_blank">屏蔽</a>算法的变体，所以他们派上了用场。</p><p id="f277" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用诸如选择性搜索的算法在图像中搜索斑点(感兴趣的区域)。然后将子区域扭曲(改变大小、倾斜或镜像)为固定大小，并对每个提议的区域应用 CNN，最后使用 SVM 对其进行分类。这解决了确定对象类别和位置的问题。</p><p id="6e07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是 FCNs 的替代架构。</p><p id="e530" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个问题是同一对象会出现多个边界框。<a class="ae mf" href="https://www.vision.ee.ethz.ch/publications/papers/proceedings/eth_biwi_01126.pdf" rel="noopener ugc nofollow" target="_blank">非最大抑制</a>是一种为每个区域设置置信度得分的算法。分数较低的区域被丢弃，然后使用 union (边界框之间的错误检查器)的<a class="ae mf" href="https://giou.stanford.edu/" rel="noopener ugc nofollow" target="_blank">交集来找到最准确的区域。</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0bc1ff42d2ccdbb72bcfd45b1aa023ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*e7XbLr7A6HF18dcv9EDqpQ.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Source: Rosebrock, A. via <a class="ae mf" href="https://commons.wikimedia.org/wiki/File:Intersection_over_Union_-_object_detection_bounding_boxes.jpg" rel="noopener ugc nofollow" target="_blank">Wikimedia</a>; Intersection of Union Finds Best Bounding Box by Comparison</figcaption></figure><p id="081c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">子区域必须被扭曲，因为它们可以是不同的大小。一旦感兴趣的区域被找到并分类，它就被包围在一个边界框内。</p><h1 id="dd49" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">现在你完全是初学者了！</h1><p id="7e30" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这篇文章是一堆不同主题的混合体，旨在给初学者一个开始编程的基本基础。经历这一切可能需要几个星期到几个月的时间，所以时间投入很少。</p><p id="eeaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">链接到更严格的材料已被放置在整个，我强烈建议通过他们工作。在一天结束时，设置 OpenCV、Keras 和它们所使用的算法是非常容易的。重要的是知道它们是如何工作的，以便最终改进它们或者选择正确的一个。</p></div></div>    
</body>
</html>