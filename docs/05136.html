<html>
<head>
<title>Visual intuition on ring-Allreduce for distributed Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向分布式深度学习的环形全递归视觉直觉</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visual-intuition-on-ring-allreduce-for-distributed-deep-learning-d1f34b4911da?source=collection_archive---------5-----------------------#2019-08-01">https://towardsdatascience.com/visual-intuition-on-ring-allreduce-for-distributed-deep-learning-d1f34b4911da?source=collection_archive---------5-----------------------#2019-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="88fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，我发现自己正在处理一个非常大的数据集，这是一个需要并行学习才能实现的数据集。我立刻想到了优步的<a class="ae ko" href="https://github.com/horovod/horovod" rel="noopener ugc nofollow" target="_blank"> Horovod </a>。我之前在优步的一次技术演讲中听说过它，但并没有真正使用过。我发现它非常有趣，是一个很棒的框架，从高级简化到支持这个框架的算法。在这篇文章中，我将尝试描述我对后者的理解。</p><h2 id="3f32" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">那么它到底是做什么的呢？</h2><p id="a5f1" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">对此需要理解的重要一点是，在深度学习中，我们需要计算梯度，以便能够调整我们的权重。没有这个学习就不可能发生。为了计算这个梯度，我们需要处理所有的数据。当这样的数据太大时，这就成了一个问题。这就是我们并行处理这些计算的原因。这意味着我们将有几台计算机并行处理一部分数据。当这些处理单元或工作者(它们可以是 CPU、GPU、TPU 等)中的每一个时，)完成了对其子集的梯度计算之后，他们需要将其结果传达给所涉及的其余过程。实际上，每个流程都需要与其他流程/工作人员交流结果。幸运的是，其他人在过去也遇到过这个问题，并设计了 Allreduce 算法，它正好可以做到这一点。我先描述一下这个。</p><h2 id="c747" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">全归算法</h2><p id="ecb7" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">从概念上讲，该算法让每个进程/工作者与所有其他进程共享其数据，并应用归约操作。这种运算可以是任何一种归约运算，如求和、相乘、求最大值或最小值。换句话说，它将所有进程/工作进程中的目标数组缩减为一个数组，并将结果数组返回给所有进程。</p><p id="bbe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，这个:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/03a6af9bb3a97286cf5fdadd9697d6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4h5dTTJJRkVY5x74LGWBg.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Before Allreduce operation</figcaption></figure><p id="0116" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有的减少总和之后会变成这样:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi md"><img src="../Images/384a147828717abd441be649e9f20b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zD2PAw-FoyfILJNUV2KQg.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">After Allreduce operation</figcaption></figure><p id="874c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么你真的会怎么做呢？我马上想到了天真的方法。互相发送数据数组，然后对每个进程应用 sum 运算，如下所示:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi me"><img src="../Images/1ed5cb67cc6a01fa4a1d1c05ef526a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eONn-i7ONcyJv7Nnhi58VA.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Message passing using naive Allreduce</figcaption></figure><p id="ff68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实证明，这种方式并不理想。它发送了太多不必要的消息，可能会使消息网络饱和。</p><p id="4e6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种更简单的常见方法是选择一个流程/工人作为驱动者。然后，所有其他进程会将其数组发送给驱动程序，驱动程序会应用该操作，并将结果重新分配给工作进程。看起来像这样的东西:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mf"><img src="../Images/451ab07d5238d40ccf46fbc904ab0c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bhd-Z73HttfpgSqUErkUZA.jpeg"/></div></div></figure><p id="2d58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的问题是它不能很好地扩展。驱动程序进程成为瓶颈，因为它的通信和归约操作的应用与进程的数量成比例增加。这在我只有 4 个进程的玩具例子中可能不明显。</p><p id="9f12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Allreduce 算法还有许多其他实现。一些尝试最小化带宽，一些尝试最小化延迟。在研究这个问题的时候，我意识到还有很多其他的架构可以让我在这篇文章中讨论，而不会让它变得无聊。如果你想知道更多，我找到了这篇<a class="ae ko" href="https://www.researchgate.net/publication/259239833_Sparse_Allreduce_Efficient_Scalable_Communication_for_Power-Law_Data" rel="noopener ugc nofollow" target="_blank">伟大的论文</a>，它描述了一些最常见的方法。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mg"><img src="../Images/a19f0de8e34a1b7d3dc900f4006b7194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsHDQDwCLVuftMNRRdocmw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Figure 2, from the paper, copyright by <a class="ae ko" href="https://www.researchgate.net/profile/John_Canny2" rel="noopener ugc nofollow" target="_blank">John Francis Canny</a></figcaption></figure><p id="936c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经知道了一些不同的实现方法，让我们来描述它的环形版本，并探索它的好处。</p><h2 id="2a01" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">环所有-减少</h2><p id="c356" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">Allreduce 的环形实现有两个阶段。第一阶段，份额减少阶段，然后是纯份额阶段。</p><p id="a169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 share-reduce 阶段，每个进程<em class="mh"> p </em>向进程<em class="mh"> (p+1) % p </em>发送数据，其中%是模运算符。所以进程 A 会发送给进程 B，以此类推。这就是产生类似环的连接的原因。此外，长度为<em class="mh"> n </em>的数据数组除以<em class="mh"> p，</em>这些块中的每一个都将由<em class="mh"> i </em>向前索引。<em class="mh"> </em>大概是这样的:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mf"><img src="../Images/ff8f73e8ad40a160e8c93ea2c465fcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XdMlfmOgPCUG9ZOYLTeP9w.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Each process sends chunks of its array to the next process</figcaption></figure><p id="2029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个份额减少步骤会让进程 A 将<em class="mh"> a0 </em>发送给进程 B，进程 B 将 b1 发送给进程 C，依此类推。大概是这样的:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mf"><img src="../Images/bf2946fa9f0233ea97d14a0600c5b9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6yPBOUXeeeFzauadXa-1g.jpeg"/></div></div></figure><p id="0528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，当每个进程接收到来自前一个进程的数据时，它会应用 reduce 操作符，然后继续将它再次发送到环中的下一个进程。请记住，在我们的示例中，归约运算符是一个 sum。它看起来像这样:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mf"><img src="../Images/b6a09b2721ea1b6e9754adcb3c4e8e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RdSOBpGwArJEZpzxHdQYQ.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Each process sends an intermediate result of the reduce operation.</figcaption></figure><p id="bc73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样重要的是，我们的归约运算符是<a class="ae ko" href="https://en.wikipedia.org/wiki/Associative_property" rel="noopener ugc nofollow" target="_blank"> <em class="mh">关联的</em> </a>，以及<em class="mh"> </em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Commutative_property" rel="noopener ugc nofollow" target="_blank"> <em class="mh">交换的</em> </a> <em class="mh"> </em>否则您无法将中间结果从一个流程传递到另一个流程。当每个进程持有块的完全缩减时，共享缩减阶段结束。此时，每个进程持有最终结果的一部分，它看起来像这样:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi me"><img src="../Images/2f01970591b642aaacef75704faaedb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfwp9K2dBUVlK1VfBcIphA.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">The state of the processes after the share-reduce step is completed</figcaption></figure><p id="c16a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二步，仅共享步骤非常简单，只是以类似环形的方式共享数据的相同过程，而不应用 reduce 操作。这巩固了每个进程中每个块的结果。</p><p id="c70c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像这样:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mf"><img src="../Images/da843ecae417a0b97f9365e4dcdefbb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1Ma9GI9gyoIhKEWKVQcQg.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">The state of all processes after the Allreduce is completed</figcaption></figure><h2 id="e1bd" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">对发送数据的简单分析</h2><p id="fb65" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">如果我们比较驱动程序进程 Allreduce 和环 Allreduce 发送的数据量，我们会发现为什么环 Allreduce 是现代网络架构中共享梯度的最佳选择。</p><p id="efd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的驱动程序进程 Allreduce 中，在这篇文章的前面描述过；其他所有进程都将其数组发送给驱动程序。最初的发送是发送 N 个元素(P-1)次，然后驱动程序进程将应用归约操作符并将结果发送回其他进程，因此将是另一个 N × <em class="mh"> (P-1) </em>通过网络发送，总共是<em class="mh"> 2(N ×(P-1))。</em>这是一个与 p 成正比的项。</p><p id="2c8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 ring Allreduce 的 share-reduce 步骤中，每个进程发送<em class="mh"> (N/P) </em>个元素，它执行<em class="mh"> (P-1) </em>次，所以<em class="mh"> (N/P) ×(P-1)。</em>在仅共享步骤中，每个进程发送它计算的块的结果。那就是一个附加的(N/P)元素做了(P-1)次，所以一个附加的<em class="mh"> (N/P) ×(P-1)。</em>总共加起来是<em class="mh"/>2(<em class="mh">(N/P)×(P-1))</em></p><p id="8f62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这里我们可以观察到，这将缓解瓶颈，因为这是几乎相同的术语，只是驱动程序进程的<em class="mh"> N </em>和环形进程的<em class="mh"> (N/P) </em>不同。让我们记住，这个计算只针对环形体系结构的一个过程。即使你将得到的等式乘以<em class="mh"> P </em>你也会得到同样的另一个等式，但是它仍然分布在<em class="mh"> P </em>进程中，而不是全部在驱动程序进程中。这就是如何缓解瓶颈，这就是为什么他们称这种算法为最佳带宽。</p><h2 id="461d" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">结论</h2><p id="ac80" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">我们调查了为什么在计算深度神经网络中的梯度时，我们需要分布数据。我们直观地探索了 ring Allreduce 算法是如何工作的，并执行了一个基本的分析，将它与其他 Allreduce 范式进行了比较，了解了什么使它成为更好的选择，以及为什么它被用在 Horovod 这样的框架中。据我所知，它现在甚至内置在 tensor flow<a class="ae ko" href="https://www.tensorflow.org/api_docs/python/tf/contrib/distribute/CollectiveAllReduceStrategy" rel="noopener ugc nofollow" target="_blank">collectiveallreducedstrategy</a>中。</p><p id="8e4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考文献:<br/>T27】https://eng.uber.com/horovod/</p><p id="dcca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.researchgate.net/publication/259239833_Sparse_Allreduce_Efficient_Scalable_Communication_for_Power-Law_Data" rel="noopener ugc nofollow" target="_blank">https://www . research gate . net/publication/259239833 _ Sparse _ all reduce _ Efficient _ Scalable _ Communication _ for _ Power-Law _ Data</a></p><p id="a966" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://preferredresearch.jp/2018/07/10/technologies-behind-distributed-deep-learning-allreduce/" rel="noopener ugc nofollow" target="_blank">https://preferred research . jp/2018/07/10/technologies-behind-distributed-deep-learning-all reduce/</a></p><p id="b9ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.tomshardware.com/news/baidu-svail-ring-allreduce-library,33691.html" rel="noopener ugc nofollow" target="_blank">https://www . toms hardware . com/news/Baidu-svail-ring-all reduce-library，33691.html </a></p><p id="bd46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/<a class="ae ko" href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>