# 朴素贝叶斯算法简介

> 原文：<https://towardsdatascience.com/an-introduction-to-the-naive-bayes-algorithm-be3bd692273e?source=collection_archive---------8----------------------->

## 大多数垃圾邮件过滤器背后的算法是如何工作的

![](img/3548f79f25442344f779af2947f97d76.png)

朴素贝叶斯算法是数据科学领域中一个非常常见的工具。它也可能是最受欢迎的，因为它是世界上大多数垃圾邮件过滤器背后的大脑。这个算法的基础很简单:它根据对一个相关事物的了解来计算一个事物的概率。

由于这种算法也是世界上大多数垃圾邮件过滤器的基础，我将提供这方面的例子。在讨论垃圾邮件过滤器时，朴素贝叶斯的基础是，它根据对电子邮件的了解来计算电子邮件是垃圾邮件的可能性。那么，垃圾邮件过滤器有哪些方法可以识别一封电子邮件是垃圾邮件呢？

一些潜在的指标包括:

*   它提到了一个“尼日利亚王子”(特别是如果所说的尼日利亚王子给你钱)。
*   主题行包括短语“热门本地单身”(不幸的是，这也可能是垃圾邮件)。
*   它包括紧急行动呼吁，如“您确认收到此消息很重要”或“此机会只会持续有限的时间。”

请注意，这些例子都不能保证它是垃圾邮件，天真的模型也不认为它能保证这一点。然而，我想我们都同意，包含这些例子的电子邮件比其他邮件更有可能是垃圾邮件。

## 我如何阅读统计符号？

在我们深入研究朴素贝叶斯算法如何工作的细节之前，重温一下统计符号是很重要的。朴素贝叶斯作为一种统计模型，终究只能用统计学的语言来真正理解。有几个重要的符号需要理解。它们是:

*   P(S)表示某事(S)的概率(P)；
*   P(S | T)表示已知一件事(T)的情况下，某件事(S)发生的概率(P)；
*   P(S T)表示已知某事(T)不为真时，某事(S)的概率(P)。

这些工具是朴素贝叶斯模型的基础。本质上，朴素贝叶斯计算的是，给定我们所知道的使用上述符号表达的情况的信息，某事为真的概率。

## 朴素贝叶斯算法是如何工作的？

朴素贝叶斯模型将几个不同的计算概率相乘，以确定某事为真或为假的概率。这也许可以通过一个例子得到最好的理解。假设您正在创建一个垃圾邮件过滤器，从尼日利亚王子发送的邮件开始。为此，您可以从一个非常简单的朴素贝叶斯模型开始，该模型根据包含短语“尼日利亚王子”的电子邮件是垃圾邮件的概率和包含短语“尼日利亚王子”的电子邮件是*而不是*垃圾邮件的概率来计算给定电子邮件是垃圾邮件的几率。该模型将具有以下形式:

P(S | N) = P(N | S) / (P(N | S) + P(N S))

用简单的英语写，根据我们的“尼日利亚王子”过滤器，电子邮件是垃圾邮件的概率等于包含短语“尼日利亚王子”的电子邮件是垃圾邮件的概率除以包含短语“尼日利亚王子”的电子邮件是垃圾邮件的概率加上包含短语“尼日利亚王子”的电子邮件不是垃圾邮件的概率之和。

为了使用这个模型，你需要知道所有这些概率。这叫做训练你的模型，这个过程的描述可以在[如何在多个模型中选择](/how-to-choose-between-multiple-models-a0c274b4228a)中找到。在这个例子中，假设您的训练数据显示了以下内容:

*   90%包含“尼日利亚王子”的电子邮件都是垃圾邮件，而且
*   只有 2%包含“尼日利亚王子”的邮件不是垃圾邮件。

在这种情况下，我们的朴素贝叶斯模型表明，任何包含短语“尼日利亚王子”的电子邮件

0.9 / (0.9 + 0.01) = 0.989

换句话说，它说包含短语“尼日利亚王子”的电子邮件应该在 98.9%的情况下被垃圾邮件过滤器删除。更进一步，每次都删除它是相当安全的…

## 这种模式如何扩展？

显然，上面介绍的垃圾邮件过滤器太简单了，没有用。这是因为一个非常具体的原因:它只有一个单一的过滤器检查一个单一的短语。世界上的垃圾短信种类很多，很多都和尼日利亚王子无关。为了使这个模型有用，它必须能够捕捉所有这些不同的场景。

幸运的是，当应用多个不同的过滤器时，朴素贝叶斯模型继续以相同的方式工作。它只是将不同过滤器的概率相乘。因此，如果我们扩展我们的模型，以包括上面列出的三个不同的例子(“尼日利亚王子”、“热门的当地单身人士”和“确认收到此消息很重要”)，它看起来会像下面这样:

P(S) = P(S | N) * P(S | H) * P(S | I)

P(S | N) = P(N | S) / (P(N | S) + P(N S))

P(S | H) = P(H | S) / (P(H | S) + P(H S))

P(S | I) = P(I | S) / (P(I | S) + P(I S))

注意，在上面的等式中，我用 H 来表示“热门本地单曲”，用“I”来表示“确认收到这条消息很重要。”

为了计算一封包含所有三个可疑短语*的电子邮件的概率，我们需要知道与这三个短语相关的概率。这也是通过将模型训练成训练数据集来完成的，其简要介绍可以在[如何在多个模型之间进行选择](/how-to-choose-between-multiple-models-a0c274b4228a)中找到。假设训练数据集中的数据显示:*

*   70%包含短语“热门本地单身”的电子邮件是垃圾邮件，
*   20%包含“热门本地单身”这句话的邮件不是垃圾邮件(可能那些用户有 Tinder 账号)，
*   50%包含“确认收到此邮件很重要”这句话的电子邮件是垃圾邮件，并且
*   30%包含“确认收到此邮件很重要”这句话的电子邮件不是垃圾邮件。

从前面的例子中我们已经知道 P(S | N)是 0.989，所以我们不需要重新分析它。

执行计算以确定包含所有三个短语的电子邮件是垃圾邮件的概率，得到:

P(S | H) = 0.7 / (0.7 + 0.2) = 0.778

P(S | I) = 0.5 / (0.5 + 0.3) = 0.625

P(S) = 0.989 * 0.778 * 0.625 = 0.481

这表明，假设训练数据集实际上包含了我在这个例子中编造的概率，包含这三个短语的电子邮件有 48.1%的几率是垃圾邮件。这是相当惊人的低，但也证明了重要的一点

## 为什么这个概率这么低？

朴素贝叶斯模型依赖于模型中的每一个概率。全部都是。因此，如果过滤器中使用的任何概率较低，模型预测的最终概率也会较低。如果存在过滤器显示包含短语的电子邮件是垃圾邮件的可能性为 0%的任何情况，这尤其成问题。例如，如果训练数据集中包含短语“爱你的，妈妈”的 0 条消息是垃圾邮件，那么模型将永远不会将带有该短语的消息标记为垃圾邮件。所有的尼日利亚王子都可以把这句话加到他们的电子邮件中，突然之间，模型就无法捕捉到他们中的任何一个了！

为了克服这一挑战，朴素贝叶斯模型通常使用伪计数，人为地夸大带有该短语的邮件是垃圾邮件的百分比。进行计算时，伪计数值通常用 *k* 表示。在计算包含“爱你的，妈妈”(表示为“L”)的邮件是垃圾邮件的几率时，它采用以下形式:

P(S | L) = (k +包含 L 的垃圾邮件数量)/ (2*k +垃圾邮件总数)

分子中有 k 会人为增加包含 L 的垃圾邮件的数量，分母中有 2k 会人为增加垃圾邮件的总数。由于分母中的 k 项是分子中的两倍，这意味着伪计数自然会将概率拉向 50%。注意避免将 k 设置得太大，以至于淹没了实际的数据集，并且所有项的概率约为 50%。

作为工作原理的示例，让我们使用以下假设来计算包含短语“爱你的，妈妈”的电子邮件是垃圾邮件的概率:

*   总共 42 封垃圾邮件中有 0 封包含该短语，并且
*   k 被设置为 4。

那么包含短语“爱你的，妈妈”的电子邮件变成:

P(S | L) = (4 + 0) / (2 * 4 + 42)

P(S | L) = 0.08

这个伪计数将我们的过滤器报告的概率从 0%增加到 8%，降低了检查包含该短语的电子邮件时出现假阴性的可能性。

## 提醒一句

我们还没有讨论的一件事是，为什么这个算法被称为“朴素贝叶斯”贝叶斯部分自然来自于它基于贝叶斯统计的事实。不幸的是，天真的部分是承认这是一个非常天真的模型。也就是说，这个模型假设在计算中使用的键之间没有任何关系。

有时候这个假设成立。包含“尼日利亚王子”这句话的邮件比其他邮件包含“桌子”这个词的可能性大还是小？大概没啥关系吧。或者，一个特别爱出风头的电子邮件人，喜欢说“确认收到这条信息很重要”，也提到冰淇淋的可能性有多大？这很难说——也许那个人没有理由提到冰淇淋，也许他们正在寻找资金来帮助他们开办一家冰淇淋商店。

但是还有其他时候这个假设不成立。我相信你能想出很多例子，一个单词的出现使得其他单词也更有可能出现。我相信你可以想出一些例子，说明这些单词的组合使得给定的电子邮件更有可能是垃圾邮件。

为了抓住这种假设的危险，我将使用 Joel Grus 的书[从头开始的数据科学](https://www.amazon.com/gp/product/1492041130/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1492041130&linkCode=as2&tag=petergrantpub-20&linkId=ace9b9ad1fef61302b9239dac704c24f)中的一个例子。他以兜售“廉价伟哥”或“正宗劳力士”的垃圾邮件为例。相关联的垃圾邮件过滤器正在寻找单词“伟哥”和“劳力士”

他在书中假设，包含“伟哥”一词的垃圾短信有 50%是垃圾短信，包含“劳力士”一词的垃圾短信有 50%是垃圾短信。然后，他计算出垃圾邮件同时包含“伟哥”和“劳力士”的几率是 0.5 * 0.5 = 0.25。这显然是荒谬的，也是朴素贝叶斯模型的弱点之一。

## 测试模型

这一弱点使得在信任朴素贝叶斯分类模型之前测试它们的性能变得极其重要。模型测试是模型开发过程中非常重要的一部分，本质上是指使用模型预测已知的数据集，并将模型预测与已知结果进行比较。表现好的模型会匹配已知结果，表现差的模型不会。你可以在[如何在多个模型中选择](/how-to-choose-between-multiple-models-a0c274b4228a)中找到更多关于测试模型的信息。

在朴素贝叶斯模型的情况下，通常通过计算四个参数来进行测试:

*   “真阳性”的数量，或者模型*正确*预测某事为*真*的情况；
*   “假阳性”的数量，或者模型*错误地*预测某事为*真*的情况；
*   “真否定”的数量，或模型*正确*预测某事为*假*的情况；和
*   “假阴性”的数量，或者模型*错误地*预测某事为*假*的情况。

## 改进模型的方法

当开发你的第一个朴素贝叶斯模型时，你可能会测试你的模型，发现它非常不准确。这是开发数据科学模型的标准部分。因此，有一个不同事物的列表来尝试提高模型的质量是非常有帮助的。这里有一些想法:

*   **使用短过滤器**:你的模型中非常详细的过滤器不会产生有用的结果，因为它们太严格了。它们不会出现在足够多的不同电子邮件中来提供有价值的过滤器。基于这一点，我们示例中的过滤器“确认收到此邮件很重要”是一个糟糕的过滤器。可能有很多很多电子邮件包含这个意图，但很少会包含这个具体的句子。通过使用非常短的过滤器而不是完整的消息，可以避免这个问题。一些可能的例子包括“接收”、“确认接收”和“这很重要”
*   **使用重复的单词**:有可能一次使用的单词并不意味着一封邮件是垃圾邮件，但是重复使用的单词就意味着是垃圾邮件。这在试图推销产品的垃圾邮件中很常见，因为他们反复使用这个词，以确保这个词一直在你的脑海中。例如，一封非常友好的电子邮件可能会使用“增强”这个词，而一封推销“男性增强”的电子邮件可能会一遍又一遍地使用这个词。为了避免这个问题，您可以创建一个字典来跟踪每个过滤术语在电子邮件中出现的次数。然后加入一个限制，这样，如果某个过滤条件出现的次数多于该过滤条件，而不是仅出现一次，则只考虑该过滤条件。
*   添加一个词干分析器函数:我们到目前为止讨论的例子都不知道一些最差的和另一些相似。例如，“更好”和“最好”非常相似，但是显示为两个完全不同的过滤器。词干分析器功能可以识别这些相似之处，并将它们组合成一个过滤器。这是一件很难从头开始做的事情，大多数人使用[搬运工斯特梅尔](https://tartarus.org/martin/PorterStemmer/)帮助。
*   **使用非基于单词的过滤器**:本文中的所有过滤器都基于单词和短语。但是这没有理由成为你模型中的一个限制。考虑使用其他过滤器。如果您添加了一种搜索不同类型图像的方法会怎么样？还是数字？或者电子邮件地址？

## 履行

提供朴素贝叶斯模型的详细实现超出了本文的范围；然而，那些寻求更多信息的人应该考虑从头开始查看[数据科学](https://www.amazon.com/gp/product/1492041130/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1492041130&linkCode=as2&tag=petergrantpub-20&linkId=ace9b9ad1fef61302b9239dac704c24f)中提供的文档。它提供了非常详细的实现，包括我们在这里讨论的所有不同计算的实际 Python 代码。

## 包装它

朴素贝叶斯算法是垃圾邮件过滤器等应用程序中常用的分类算法。它通过计算某件事是或不是基于其他可用知识的事实的概率来运作。当在垃圾邮件过滤器中使用时，这通常采取识别包含特定单词的电子邮件是否是垃圾邮件的形式。这些概率可以相乘，允许模型使用多个不同的过滤器来确定总概率。

将多个过滤器组合在一起存在基于单个过滤器具有 0 概率而返回假阴性的风险。这通常通过包含伪计数来克服。伪计数人为地将正结果和负结果相加，将正结果概率为 0 的过滤器改变为结果概率非常低的过滤器。这种解决方案可以防止过滤器获得肯定结果的可能性为零，并避免使结果立即无效。

请记住，这个算法的名称包含“幼稚”一词是有原因的。它假设没有一个过滤器以任何方式彼此相关。这是一个巨大的假设，任何知道语言如何运作的人都会相信。同时，这个模型无论如何都表现得很好，只要记住这个限制就可以使用。

模型在首次开发时并不总是表现良好。这是开发模型的一个简单现实。在模型测试失败后，改进过滤器的一些方法包括:1)使用短的、有针对性的过滤器；2)使过滤器基于重复的单词，而不是单词的单个实例；3)添加词干分析器功能以识别常用词；以及 4)使用基于事物而不是单词的过滤器。