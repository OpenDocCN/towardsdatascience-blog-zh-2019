<html>
<head>
<title>Pandas for People In A Hurry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫给匆忙的人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-for-people-in-a-hurry-59d966630ae0?source=collection_archive---------5-----------------------#2019-05-23">https://towardsdatascience.com/pandas-for-people-in-a-hurry-59d966630ae0?source=collection_archive---------5-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="727f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">满足您所有数据探索需求的数据框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/715268d6f4a5c13c33576c2f4ac49f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y43M9sZzN0uaa1bJ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@millerthachiller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pascal Müller</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是最流行的用于数据操作和数据分析的 Python 库。这是所有数据科学家必须知道的！</p><p id="b4d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两只熊猫的数据结构是:</p><ol class=""><li id="8cfa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">熊猫数据框</li><li id="974e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">熊猫系列</li></ol><p id="0bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢把熊猫数据框想象成一个 excel 表格。你有许多行和列的数据。然而，在 Pandas 中，列中的数据必须是相同的数据类型。熊猫系列只是熊猫数据框架中的一列。</p><p id="596f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将为您提供大量有用的 Pandas 信息，告诉您如何使用 Pandas 中的不同方法进行数据探索和操作。这是一个很好的熊猫入门指南，也是一个很好的复习工具，如果你有一段时间没有使用熊猫的话。本概述将详细介绍如何导入数据集，以及如何探索、选择、清理、操作、聚合、组合和导出数据，以便您能够顺利完成下一个数据科学项目。</p><blockquote class="mj"><p id="3e4a" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated">我在整篇文章中加入了一些“专家提示”,与你分享我在使用熊猫期间学到的一些有用的东西。如果你有一些很酷的建议要分享，我很想听听！下面掉个评论！</p></blockquote><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">你可以在这里下载我的 Jupyter 笔记本<a class="ae ky" href="https://github.com/julia-git/Soils_DataSet" rel="noopener ugc nofollow" target="_blank">并跟随。下面描述的方法将以土壤数据集为例。我建议您打开 Jupyter 笔记本，以便可以看到代码的输出。</a></p><h1 id="10f2" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">开始提示</h1><p id="3dde" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">首先，确保您首先导入 Pandas 库。</p><p id="a552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">import pandas as pd</code></p><p id="60d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也喜欢在开始之前修改默认的熊猫选项。参见下面的专家提示。</p><blockquote class="nz oa ob"><p id="5bda" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">专家提示:</strong>默认情况下，如果数据框架中有许多列，并非所有的列都会显示在输出显示中。您可以使用这行代码来加宽输出显示中的列:</p></blockquote><p id="de6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.set_option('display.max_columns', 500)</code></p><p id="4a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值 500 表示以字符为单位的列的最大宽度。也就是说，值 500 意味着您希望在调用 dataframe 时显示多达 500 列。默认值仅为 50。</p><p id="f53e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以使用类似的代码行来加宽输出显示中的行。这将允许显示多达 500 行。</p><p id="b830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.set_option('display.max_rows', 500)</code></p><h1 id="127b" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">进口到熊猫</h1><p id="9efd" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">导入数据将是项目的第一步。无论你有一个 excel 文件或 csv 文件，他们可以很容易地导入到熊猫。</p><p id="a986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要导入逗号分隔值(CSV)文件，请使用这行代码。</p><p id="5b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.read_csv("Soils.csv")</code></p><p id="fe37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在括号内，<code class="fe nv nw nx ny b">"Soils.csv",</code>是我上传的文件的名字。对于 excel 文件，使用这行代码。</p><p id="6a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.read_excel("Soils.xls")</code></p><p id="56ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了成功导入您的文件，上面的代码假设数据文件位于您当前的工作目录中。</p><blockquote class="nz oa ob"><p id="2ccd" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">专家提示:</strong>如果你不确定你的工作目录在哪里，在你的 Jupyter 笔记本里，你可以使用<code class="fe nv nw nx ny b">!pwd</code>来得到你的工作目录。<code class="fe nv nw nx ny b">!</code>字符告诉 Jupyter Notebook 将代码视为 OS shell 命令。</p><p id="29f9" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">专家提示:</strong>如果您碰巧有任何日期时间类型的列，请在括号内添加<code class="fe nv nw nx ny b">parse_dates = [column_name]</code>作为参数，以便 Pandas 可以将该列识别为日期。例如，如果您有一个名为 Collection_Date 的日期列，您会使用<code class="fe nv nw nx ny b">pd.read_excel("Soils.xls", parse_dates = ['Collection_Date'])</code>吗</p></blockquote><p id="67e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我成功导入后的数据帧片段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/3104381669b32e7c9584e93dc110bc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*HlAawOtAOfqD4aAL0e8FHA.png"/></div></figure><h1 id="6d55" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">探索您的数据</h1><p id="023c" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">现在您的数据已经在 Pandas 的数据框架中，您已经准备好进行调查了。这里有几个有用的方法，每次引入数据集时都可以调用。这些步骤应该有助于您了解您的数据中有哪些内容。</p><h2 id="17cb" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">探索数据框架</h2><p id="2bdc" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.head()</code>返回数据帧的前 5 行。要覆盖默认值，可以在括号之间插入一个值来更改返回的行数。示例:<code class="fe nv nw nx ny b">df.head(10)</code>将返回 10 行。</p><p id="185f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.tail()</code>返回数据帧的最后 5 行。您可以在括号之间插入一个值来更改返回的行数。</p><p id="1d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.shape</code>返回表示维度的元组。例如,( 48，14)的输出代表 48 行和 14 列。</p><p id="6a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.info()</code>提供数据摘要，包括索引数据类型、列数据类型、非空值和内存使用情况。</p><p id="320d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.describe()</code>提供描述性统计数据，总结集中趋势、分散和形状。</p><h2 id="d3db" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">浏览列</h2><p id="0085" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我最喜欢的方法之一就是<code class="fe nv nw nx ny b">.value_counts()</code>。此方法为所选列中的每个唯一值提供计数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/c566267d59a3d1bf04d8fb4f7ed419bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*-T2thtRqJHFMqXbEgbtpYQ.png"/></div></figure><blockquote class="nz oa ob"><p id="c7a7" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">专家提示:</strong>如果你更希望看到百分比而不是绝对数字的细分，试试<code class="fe nv nw nx ny b">.value_counts(1)</code>吧。</p></blockquote><p id="d551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个更有用的方法来看看你的数据框里有什么。</p><p id="ba68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df['Contour'].isnull().sum()</code>返回列“轮廓”中空值的计数</p><p id="cc97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df['pH'].notnull().sum()</code>返回列“pH”中非空值的计数</p><p id="18c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df['Depth'].unique()</code>返回“深度”列中的唯一值</p><p id="cd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.columns</code>返回所有列的名称</p><h1 id="1484" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">选择数据</h1><p id="0cb4" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">有许多不同的方法来选择您感兴趣的数据。以下是我常用的一些最有用的方法。</p><h2 id="80b9" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">列选择</h2><p id="114c" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">如果你想只选择一列，你可以使用<code class="fe nv nw nx ny b">df['Group'].</code>这里‘组’是列名。</p><p id="5fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要选择多列，您可以使用<code class="fe nv nw nx ny b">df[[‘Group’, ‘Contour’, ‘Depth’]]</code>。注意，选择多列时会使用双括号。只需传入您想要的列名。</p><h2 id="076b" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">子集选择/索引</h2><p id="7057" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">为了选择特定的数据子集，我们依赖于<code class="fe nv nw nx ny b">.loc</code>或<code class="fe nv nw nx ny b">.iloc</code>方法。我建议您尝试一下这两种方法，以便更好地理解它们是如何工作的。</p><p id="6c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nv nw nx ny b">df.loc[]</code>通过行和列的标签进行选择。</p><p id="6428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.loc[:,[‘Contour’]]</code>选择所有行和列的‘轮廓’。单冒号<code class="fe nv nw nx ny b">:</code>选择所有的行。在逗号的左边，指定所需的行，在逗号的右边，指定列。</p><p id="70e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.loc[0:4,[‘Contour’]]</code>选择我们的索引 0 到 4 和列‘轮廓’。</p><p id="bb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们使用<code class="fe nv nw nx ny b">df.iloc[]</code>按位置选择行和列。我们会传入整数位置。</p><p id="5b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.iloc[:,2]</code>选择位置 2 的所有行和列。</p><p id="7126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.iloc[3,:]</code>选择位置 3 的行和所有列。</p><h2 id="e156" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">过滤</h2><p id="ff7e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">此外，我们可以使用掩码来帮助我们在数据帧中选择符合特定标准的特定行。在下面的掩码中，根据语句计算列中的每个值。即值是否等于“顶”。</p><pre class="kj kk kl km gt ou ny ov ow aw ox bi"><span id="e8d2" class="oh mz it ny b gy oy oz l pa pb">mask = df[‘Contour’] == “Top”<br/>df[mask]</span></pre><p id="9f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码<code class="fe nv nw nx ny b">df[‘Contour’] == “Top”</code>返回布尔值 True 或 False。当我们在<code class="fe nv nw nx ny b">df[mask]</code>中使用布尔掩码时，它将只打印掩码为真的行。</p><p id="d7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该掩码也可用于计算数值列。在下面的示例中，当“Conduc”列中的值大于 10 时，将返回布尔值 True。</p><pre class="kj kk kl km gt ou ny ov ow aw ox bi"><span id="8ae2" class="oh mz it ny b gy oy oz l pa pb">mask2 = df[‘Conduc’] &gt; 10<br/>mask2</span></pre><p id="b9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用掩码的另一个有用的方法是过滤列表中的项目。</p><pre class="kj kk kl km gt ou ny ov ow aw ox bi"><span id="4dcb" class="oh mz it ny b gy oy oz l pa pb">mask3 = df[‘Contour’].isin([‘Depression’, ‘Slope’])<br/>df[mask3]</span></pre><blockquote class="nz oa ob"><p id="70c1" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">专家提示</strong>:如果你想选择你蒙版的反面，可以用蒂尔达符号。例如，<code class="fe nv nw nx ny b">df[~mask3]</code>将选择“轮廓”列中既不包含凹陷也不包含坡度的所有行。</p></blockquote><h1 id="6b06" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">清理数据</h1><p id="6227" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">只有数据本身是好的，一个数据科学项目才能是好的。也就是说，我们希望在将数据插入机器学习算法之前，数据质量良好。以下是一些有助于加速数据清理的有用方法。注意，我为下面的许多方法传入了<code class="fe nv nw nx ny b">inplace=True</code>。这确保了更改发生在实际的数据帧中。如果您不传入这一行代码，数据帧中的更改实际上不会发生。</p><h2 id="0acc" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated"><strong class="ak">替换怪异字符</strong></h2><p id="c0f4" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.replace({‘Topk’: ‘Top’}, inplace=True)</code></p><h2 id="3b98" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">删除空值</h2><p id="fc20" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">df[‘pH’].dropna(inplace=True)</code></p><h2 id="aeaf" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">输入空值</h2><p id="74f0" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">df[‘pH’].fillna(df[‘pH’].mean(), inplace=True) #nulls are imputed with mean of pH column</code></p><h2 id="fb27" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">删除行和列</h2><p id="3c3a" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.drop(columns = [‘Na’], inplace = True) #This drops the 'Na' column</code></p><p id="913b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.drop(2, axis=0, inplace=True) #This drops the row at index 2</code></p><p id="b237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，axis=0 告诉熊猫逐行下降。您可以使用 axis=1 来删除列。这适用于许多其他可用的熊猫方法。</p><h2 id="14ca" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">更改列名</h2><p id="256b" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.rename(columns = {‘Conduc’ : ‘Cond’, ‘Dens’ : ‘Density’}, inplace = True)</code></p><h2 id="f7ec" class="oh mz it bd na oi oj dn ne ok ol dp ni li om on nk lm oo op nm lq oq or no os bi translated">操纵数据</h2><p id="8c69" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">您可以使用<code class="fe nv nw nx ny b">.apply</code>在数据框的行或列上应用一个函数。下面的代码将平方根应用于“Cond”列中的所有值</p><p id="9906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df[‘Cond’].apply(np.sqrt)</code></p><h1 id="4e9c" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">分组数据，数据聚合</h1><p id="8d8e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">有时，如果我们将数据分组进行观察，可以更好地识别差异和模式。</p><p id="87ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几种不同的方法可以对数据进行分组。以下示例按“轮廓”列对数据进行分组，并计算“Ca”列中记录的平均值、总和或计数。请参阅 Jupyter Notebook 中的输出，以便更好地理解代码返回的内容。</p><p id="5f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.groupby(by=[‘Contour’])[‘Ca’].mean()</code></p><p id="b584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.groupby(by=[‘Contour’])[‘Ca’].count()</code></p><p id="2b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.groupby(by=[‘Contour’])[‘Ca’].sum()</code></p><p id="f9f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以按多个列进行分组。</p><p id="13b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.groupby(by=[‘Contour’, ‘Gp’])[‘Ca’].mean()</code></p><h1 id="8ae3" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">组合多个数据帧</h1><p id="3cb5" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">有多种方法可以将两个数据帧组合在一起，根据您的特定任务，可能更适合使用其中一个来执行该任务。我倾向于使用的前两个是 concat 和 merge。</p><p id="055a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Concat 适用于堆叠多个数据帧的行。</p><p id="01bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">按列连接数据</strong></p><p id="21a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.concat([df, df2], axis=1)</code></p><p id="3c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">按行连接数据</strong></p><p id="93e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.concat([df, df2], axis=0)</code></p><p id="c384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据帧之间有公共列时，合并适合于合并数据帧。</p><p id="07da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">合并数据</strong></p><p id="3ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">pd.merge(df, df2, left_on=’Contour’, right_on=’Contour’, how=’outer’)</code></p><p id="7675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于合并，我不会讲太多细节，但是你可以在这里找到关于如何更好地利用它的很好的例子。</p><h1 id="9762" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">输出数据帧</h1><p id="077f" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">一旦你清理和处理完你的数据。您可以将其输出到 csv 或 excel 文件来工作。</p><p id="6a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将数据输出到由制表符分隔的 csv 文件，请使用下面的代码。<code class="fe nv nw nx ny b">'\t'</code>表示您希望它用制表符分隔。如果你喜欢用<code class="fe nv nw nx ny b">,</code>代替，你可以用<code class="fe nv nw nx ny b">','</code></p><p id="9831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">df.to_csv(‘myDataFrame.csv’, sep='\t')</code></p><p id="90d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要输出到 excel:</p><pre class="kj kk kl km gt ou ny ov ow aw ox bi"><span id="1e3d" class="oh mz it ny b gy oy oz l pa pb">writer = pd.ExcelWriter(‘myDataFrame.xlsx’) <br/>df.to_excel(writer, ‘DataFrame’) <br/>writer.save()</span></pre></div><div class="ab cl pc pd hx pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="im in io ip iq"><p id="8686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你有一些关于熊猫的小贴士可以分享，别忘了发表评论。干杯。</p></div></div>    
</body>
</html>