<html>
<head>
<title>Forecasting Future Prices of Cryptocurrency using Historical Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用历史数据预测加密货币的未来价格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-future-prices-of-cryptocurrency-using-historical-data-83604e72bc68?source=collection_archive---------10-----------------------#2019-12-05">https://towardsdatascience.com/forecasting-future-prices-of-cryptocurrency-using-historical-data-83604e72bc68?source=collection_archive---------10-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4b70da13c130f1ae0131c067fab23fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIMSSllJ_avORhX72EViXQ.jpeg"/></div></div></figure><p id="622a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">加密货币(cryptocurrency)这个词已经席卷了金融界，然而目前还缺乏对数字资产数据的正式和公开的研究。这篇博文旨在建立在这篇<a class="ae la" href="https://medium.com/@hamzaahmad86/exploratory-data-analysis-of-cryptocurrency-historical-data-d8ec719641e7" rel="noopener"> <strong class="kd iu">文章</strong> </a>中进行的探索性数据分析的基础上。我们将在这里使用可用的数据集<a class="ae la" href="https://www.kaggle.com/sudalairajkumar/cryptocurrencypricehistory" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"/></a>来预测不同加密货币的未来价格。</p><p id="f99d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在 EDA 之后，预测是下一步，你需要预测价格的未来值。对于有兴趣投资这些加密货币的人来说，这可能具有巨大的商业价值。</p><p id="9805" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将尝试通过使用<em class="kz"> closing_price </em>特性来预测<em class="kz">比特币</em>的未来价格。</p><h1 id="fa8e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用什么型号？</h1><p id="0b74" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">为了进行预测，我们需要一个机器学习模型。大多数人想预测值的时候都会想到多元线性回归。但是对于时间序列数据，这不是一个好主意。不选择时间序列数据回归的主要原因是我们对预测未来感兴趣，这将是线性回归的外推(预测数据范围之外)。我们知道，在线性回归中，任何形式的外推都是不可取的。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3991397ea69c589a95dbd2728b915063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*h89iwF45LUx6JE54t6dejQ.jpeg"/></div></figure><p id="7a38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于时间序列数据，最好使用<em class="kz">自回归综合移动平均</em>或<strong class="kd iu"> ARIMA </strong>模型。</p><h1 id="0748" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ARIMA</h1><p id="2e56" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">ARIMA 实际上是一类模型，它基于给定的时间序列的过去值来“解释”给定的时间序列，即其自身的滞后和滞后预测误差，因此该方程可用于预测未来值。任何“非季节性”的时间序列显示模式，不是一个随机的白噪声可以用 ARIMA 模型建模。如下所述，假设检验表明价格不是季节性的，因此我们可以使用 ARIMA 模型。在我们的 EDA 阶段，我们还发现任何加密货币都没有系统模式。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/5423df91b4bce47d90d3ae9e29d966a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ecBOuRczLluRATNOWZBxAw.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Non-Seasonal Trend of Omisego’s Prices</figcaption></figure><p id="146b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要创建 ARIMA 模型，我们需要 3 个参数:</p><ul class=""><li id="921c" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated"><em class="kz">p</em>；自回归项的阶</li><li id="7973" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><em class="kz">问</em>；移动平均项的阶</li><li id="4453" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><em class="kz">d</em>；使时间序列平稳所需的差分次数</li></ul><h2 id="c0e5" class="nc lc it bd ld nd ne dn lh nf ng dp ll km nh ni lp kq nj nk lt ku nl nm lx nn bi translated">确定平稳性</h2><p id="35c4" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">我们将需要时间序列数据是平稳的，因为术语<em class="kz">自动回归</em>在 ARIMA 意味着它是一个<a class="ae la" href="https://www.machinelearningplus.com/machine-learning/complete-introduction-linear-regression-r/" rel="noopener ugc nofollow" target="_blank">线性回归模型</a>，使用它自己的滞后作为预测器。如你所知，当预测因子不相关且相互独立时，线性回归模型效果最佳。</p><p id="110d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现平稳性，我们需要执行<em class="kz">差分</em>:从当前值中减去前一个值。有时，根据系列的复杂程度，可能需要一个以上的差异。在我们这样做之前，我们需要检查我们的数据是否已经是稳定的。为此，我们将使用<a class="ae la" href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.stattools.adfuller.html" rel="noopener ugc nofollow" target="_blank"> <em class="kz">增强的 Dickey Fuller </em>测试</a>。这是一个<strong class="kd iu">假设检验</strong>，假设零假设为<em class="kz">“自回归模型中存在单位根”</em>。单位根检验<strong class="kd iu"> </strong>时间序列变量是否是非平稳的，是否有单位根。如果一个数列有一个单位根，它就显示出一个系统的模式。在这种情况下，另一个假设是“<em class="kz">没有单位根存在</em>”，这意味着时间序列是平稳的。</p><pre class="mf mg mh mi gt no np nq nr aw ns bi"><span id="8524" class="nc lc it np b gy nt nu l nv nw">result = adfuller(df["Close]).dropna())</span></pre><p id="9535" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试返回一个为<strong class="kd iu"> 0.002114 </strong>的<strong class="kd iu"> P 值</strong>。这远低于我们设定的 0.05 的显著性水平，因此我们拒绝零假设，并得出数据是平稳的结论。</p><p id="b1a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于数据是静态的，我们不需要执行任何差分。因此，参数<strong class="kd iu"> d </strong>的值将为 0。</p><h2 id="4e0b" class="nc lc it bd ld nd ne dn lh nf ng dp ll km nh ni lp kq nj nk lt ku nl nm lx nn bi translated">确定 AR 项的阶数</h2><p id="fc68" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated"><strong class="kd iu"> p </strong>是<em class="kz">自回归</em> (AR)项的顺序。它是指用作预测值的 Y 的滞后数。我们可以通过查看<em class="kz">偏相关</em> <em class="kz">函数</em> (PACF)图来找出所需的 AR 项数。在排除中间滞后的贡献后，部分自相关可以被想象为序列和它的滞后之间的相关性。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/cfdfd1ab54e0e93e503137da47e25d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHiG5sW9hD7E2Uq7dfiBig.jpeg"/></div></div></figure><p id="d0ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以观察到，PACF 滞后 1 是唯一一个非常显著的值，与其他值相比，它远远高于显著性线。因此，我们可以安全地将<em class="kz"> p </em>设置为 1。</p><h2 id="b5e9" class="nc lc it bd ld nd ne dn lh nf ng dp ll km nh ni lp kq nj nk lt ku nl nm lx nn bi translated">确定 MA 术语的顺序</h2><p id="3137" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated"><strong class="kd iu"> q </strong>是<em class="kz">移动平均线</em> (MA)项的顺序。它是指应该进入 ARIMA 模型的滞后预测误差的数量。MA 术语在技术上是滞后预测的误差。</p><p id="2a9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像我们看 PACF 图中 AR 项的数量一样，你也可以看 ACF 图中 MA 项的数量。ACF 告诉我们需要多少 MA 项来消除平稳序列中的任何自相关。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/99a40d0fe920255dbbebf4657f427ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXlGqSDonpCWC5OBJTaYZA.jpeg"/></div></div></figure><p id="752d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算显著线以上的滞后数。所以，我们暂定<em class="kz"> q </em>为 8。</p><h2 id="eb67" class="nc lc it bd ld nd ne dn lh nf ng dp ll km nh ni lp kq nj nk lt ku nl nm lx nn bi translated">构建模型</h2><p id="9f3c" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">既然我们已经有了所有需要的参数，现在我们将构建模型。</p><pre class="mf mg mh mi gt no np nq nr aw ns bi"><span id="6e24" class="nc lc it np b gy nt nu l nv nw">model = ARIMA(df["Close"], order=(1,0,8))<br/>model_fit = model.fit(disp=0)<br/>print(model_fit.summary())</span></pre><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e64bac41d3af62ffa4ee23220513417b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVJ888GgwdITTxUxjQq-HA.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">ARIMA MODEL FOR p=1, d=0, q=8</figcaption></figure><p id="b87d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以注意到，MA 项的 P &gt; |z|中的 P 值远小于 0.05。因此，我们可以理想地去掉一些 MA 项并重建模型。由于三项显著高于显著性水平，我们将 q 设为 3。</p><pre class="mf mg mh mi gt no np nq nr aw ns bi"><span id="fdcd" class="nc lc it np b gy nt nu l nv nw">model = ARIMA(df["Close"], order=(1,0,3))</span></pre><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e62e2afe5aec91bc5aa35dfafc25eb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIrqy4nOe592At3JHmarlg.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">ARIMA Model for revised parameters</figcaption></figure><h1 id="7aad" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">评估模型</h1><p id="96b5" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">既然模型已经被拟合，我们现在将测试我们的 ARIMA 模型。为此，我们现在将数据集分为两部分:</p><ul class=""><li id="3a7a" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated">训练数据(原始数据集的 80%)</li><li id="bca4" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">测试数据(原始数据集的 20%)</li></ul><pre class="mf mg mh mi gt no np nq nr aw ns bi"><span id="c64a" class="nc lc it np b gy nt nu l nv nw">X = bit_df["Close"].values<br/>train_size = int(len(X) * 0.80)<br/>predictions = model_fit.predict(train_size,len(X)-1)<br/>test = X[train_size:len(X)]<br/>error = mean_squared_error(test, predictions)</span></pre><p id="61e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">model_fit.predict()获取测试数据的开始和结束索引。然后，通过计算<em class="kz">均方误差</em>，将结果与测试数据集的目标值进行比较。</p><p id="d439" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">均方差的值出来是~ <strong class="kd iu"> 575.24 </strong>。当我们看到数据跨越了 5 年的每日条目时，这个误差并不大。然而，仅仅是均方误差值并不能让我们清楚地知道我们的模型有多精确。因此，我们将可视化测试数据的预测值和实际值的比较。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/d7c20b2c9b533a27c808486dbec64ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TepMkb842NSI5OcUFBhOdg.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Actual closing values VS Predicted closing values</figcaption></figure><p id="7331" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看图表，我们可以看到收盘价的预测值和实际值非常接近。</p><p id="9511" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那都是乡亲们！祝你有愉快的一天。</p></div></div>    
</body>
</html>