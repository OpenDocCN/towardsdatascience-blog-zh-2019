<html>
<head>
<title>Building Pipelines With Lathe 0.0.7 (Unstable) In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Julia 中用车床 0.0.7 构建管道(不稳定)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-pipelines-with-lathe-0-0-7-unstable-in-julia-f7ba1850bde3?source=collection_archive---------36-----------------------#2019-12-05">https://towardsdatascience.com/building-pipelines-with-lathe-0-0-7-unstable-in-julia-f7ba1850bde3?source=collection_archive---------36-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4a9b4f4402c0f21b9fc1995d9e4da763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpBjV-z_ZxCpdNcI-5ge_A.png"/></div></div></figure><p id="babd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据科学的很大一部分是数据科学的一个子集，称为数据工程。数据工程(DE)涉及各种格式的管道、管理和端点数据。好消息是，有了车床 0.0.7，我们可以非常容易地设计一个模型，并用管道进行预测。这个基本版本将会有进一步的改进。但就目前而言，它肯定会是一个非常有用的工具，而且说实话，它是多么容易做到令人难以置信。我期待着进一步扩大这个一揽子计划。</p><p id="ff2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天，我将向大家展示 Julia、Lathe、JLD2 和 Genie 在管道建设领域的成就。</p><blockquote class="kz"><p id="9bab" class="la lb it bd lc ld le lf lg lh li ky dk translated"><a class="ae lj" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Linear%20Regression%20Pipeline%20on%20WW2%20Weather.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><blockquote class="kz"><p id="205c" class="la lb it bd lc ld le lf lg lh li ky dk translated">加载数据</p></blockquote><p id="ee37" class="pw-post-body-paragraph kb kc it kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky im bi translated">为了训练一个模型，我们需要数据。我在 Kaggle 上发现了<a class="ae lj" href="https://www.kaggle.com/smid80/weatherww2/data?fbclid=IwAR2QgHmPywxqe5eY-sskQ5K8_jkjPfcLLoLJUyc6DNwDINjK9euc4gd6TDg" rel="noopener ugc nofollow" target="_blank">这个很酷的数据集</a>，所以我决定尝试一下。现在我们有了一个数据集，我们可以把它读入 Julia:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a6ca" class="mf mg it mb b gy mh mi l mj mk">using CSV<br/>df = CSV.read("Summary of Weather.csv")</span></pre><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/973d72bfcaef8338b9c34dbd774f0f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tr_fNPUV_H7U-zB-5DoxPg.png"/></div></div></figure><p id="1e3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速浏览之后，我选择了三个我认为容易追踪和理解的不同特征。首先，我决定将每个日期戳限定为带有日期和数据框的年份:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="961a" class="mf mg it mb b gy mh mi l mj mk">using DataFrames<br/>using Dates<br/>df.Date = [i = DateTime(i) for i in df.Date]<br/>df.Date = [i = year(i) for i in df.Date]</span></pre><blockquote class="kz"><p id="4192" class="la lb it bd lc ld mm mn mo mp mq ky dk translated">然后提取我提到的那些特征:</p></blockquote><pre class="mr ms mt mu mv ma mb mc md aw me bi"><span id="0a5e" class="mf mg it mb b gy mh mi l mj mk">df = DataFrame(:Date =&gt; df.Date,:Precipitation =&gt; df.Precip,:Temp =&gt; df.MeanTemp)</span></pre><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/5d31f9f44d4be5601e5f9d174c8e4749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBV3guwxAivUuhTwhiWB9A.png"/></div></div></figure><p id="916d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了其他特性，这些特性实际上是相对干净的，没有丢失值。现在我们已经有了三个特性，但是仍然不知道应该为目标选择什么，我们可能应该做一些统计测试！虽然这对于像多元线性回归这样的模型来说并不重要，但是我们还没有在车床上实现它。</p><blockquote class="kz"><p id="6743" class="la lb it bd lc ld le lf lg lh li ky dk translated">我们可以用 Lathe.stats 做一些快速的 f 检验！</p></blockquote><p id="b638" class="pw-post-body-paragraph kb kc it kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky im bi translated">通过使用过滤器，我们可以在 Julia 中基于带有掩码的条件来分离我们的数据！方法，或者通过在数组上循环。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="594c" class="mf mg it mb b gy mh mi l mj mk">high_dfy = df[(df[:Date].&gt;=1944),:]</span></pre><p id="bb45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行我们的 f 检验:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a82f" class="mf mg it mb b gy mh mi l mj mk">using Lathe.stats: f_test<br/>f_test(high_dfy.Temp,df.Temp)</span><span id="af9c" class="mf mg it mb b gy mx mi l mj mk">0.43963490045765957</span></pre><blockquote class="kz"><p id="930c" class="la lb it bd lc ld mm mn mo mp mq ky dk translated">不幸的是，我们必须接受这个零。</p></blockquote><p id="d114" class="pw-post-body-paragraph kb kc it kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky im bi translated">我决定使用这个特性，因为我并不真的像演示如何做那样追求准确性，所以接下来我使用 Lathe.preprocess 来测试 splitted。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b96a" class="mf mg it mb b gy mh mi l mj mk">using Lathe.preprocess: TrainTestSplit<br/>train,test = TrainTestSplit(df)</span></pre><p id="05a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我看来，这是设定您的功能和目标的最佳方式:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="11bf" class="mf mg it mb b gy mh mi l mj mk">target = :Temp<br/>feature = :Date<br/>trainX = train[feature]<br/>trainy = train[target]<br/>testX = train[feature]<br/>testy = train[target]</span></pre></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><p id="b22f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个例子，我选择了带有标准标量的线性最小二乘回归，不是为了太简单，而是为了说明问题:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="deb1" class="mf mg it mb b gy mh mi l mj mk">using Lathe.models: LinearLeastSquare<br/>using Lathe.preprocess: StandardScalar</span></pre><p id="877c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们必须将标准标量应用于 X:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1a54" class="mf mg it mb b gy mh mi l mj mk">trainX = StandardScalar(trainX)</span></pre><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f3045f4740dd7eaae0733480262adc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/1*xSJPL4aA0OsyVsMNLl-uhQ.png"/></div></figure><p id="71cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以快速构建我们的模型:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2f68" class="mf mg it mb b gy mh mi l mj mk">model = LinearLeastSquare(StandardScalar(trainX),trainy,:REG)</span></pre><blockquote class="kz"><p id="98fc" class="la lb it bd lc ld mm mn mo mp mq ky dk translated">请注意:REG 符号！</p></blockquote><p id="9416" class="pw-post-body-paragraph kb kc it kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky im bi translated">我们可以，如果我们在用一个更现实的模型工作(这里没有足够的时间进行线性回归，大约 4 年可以更好地进行分类)，我想验证它。假设我们测试了分裂训练，我们应该继续验证它。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8915" class="mf mg it mb b gy mh mi l mj mk">using Lathe.models: predict<br/>y_pred = predict(model,StandardScalar(testX))</span><span id="fc3c" class="mf mg it mb b gy mx mi l mj mk">using Lathe.validate: r2,mae</span></pre><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f6d9afa5eaeb0afc2fc15d4dccc222ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*tTzQXUdaNa2JHYaxohFwTg.png"/></div></figure><p id="a2e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想指出的是，如果我们聪明地使用代码，我们可以用 4 行代码预测测试集，</p><blockquote class="kz"><p id="0224" class="la lb it bd lc ld le lf lg lh li ky dk translated">包括进口</p></blockquote><pre class="mr ms mt mu mv ma mb mc md aw me bi"><span id="13b4" class="mf mg it mb b gy mh mi l mj mk">using Lathe.models: LinearLeastSquare, predict<br/>using Lathe.preprocess: StandardScalar<br/>model = LinearLeastSquare(StandardScalar(train.Year),train.Temp,:REG)<br/>y_pred = predict(model,test.Year)</span></pre><p id="f7f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了模型，我们如何在管道中实现标准标量和模型。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b73d" class="mf mg it mb b gy mh mi l mj mk">using Lathe.pipelines: Pipeline,pippredict<br/>pipe = Pipeline([StandardScalar],model)</span></pre><blockquote class="na nb nc"><p id="7ede" class="kb kc nd kd b ke kf kg kh ki kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ky im bi translated">注意:将来，车床.管道将合并到车床.模型中，车床. nlp 也将合并到车床.预处理中。</p></blockquote><p id="70c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以使用 pippredict 方法进行预测，但在未来，它将只是来自车床模型的预测方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6dd0" class="mf mg it mb b gy mh mi l mj mk">pippredict(pipe,testy)</span></pre><p id="e7d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以使用 JLD2 来用宏序列化我们的结构。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5bcd" class="mf mg it mb b gy mh mi l mj mk">using JLD2<br/><a class="ae lj" href="http://twitter.com/save" rel="noopener ugc nofollow" target="_blank">@save</a> "algorithm.jld2" pipe</span></pre><p id="e16f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以像这样重新加载它:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f73f" class="mf mg it mb b gy mh mi l mj mk"><a class="ae lj" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> "algorithm.jld2"</span></pre><p id="d346" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该结构将被添加到局部变量中，您可以再次执行以下操作:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="32c6" class="mf mg it mb b gy mh mi l mj mk">pippredict(pipe,testy)</span></pre></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="db82" class="nh mg it bd ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od bi translated">开发我们的管道</h1><p id="17e4" class="pw-post-body-paragraph kb kc it kd b ke oe kg kh ki of kk kl km og ko kp kq oh ks kt ku oi kw kx ky im bi translated">不幸的是，Julia 目前受到其软件包基础的限制，尽管它确实有 Pycall。我们唯一的本地 Julia 选项是 Genie。好消息是:精灵是相当可怕的！</p><p id="3090" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上有一个超级简单的方法可以完全通过管理员命令来完成。像往常一样，首先我们需要进入我们的终端/SSH 客户端，并通过 SSH 连接到我们的服务器。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3a84" class="mf mg it mb b gy mh mi l mj mk">ssh emmett@----------</span></pre><p id="c2c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我也将通过 nautilus 传输 algorithm.jld2 文件。我的文件最终是 5.5 kb，因为 JLD2 实际上是一个非常令人印象深刻的压缩算法。</p><p id="07aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们将使用 Julia 在服务器中快速创建管道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6565" class="mf mg it mb b gy mh mi l mj mk">sudo mkdir /var/www/--------</span></pre><p id="775b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您没有安装 julia，请获取:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9976" class="mf mg it mb b gy mh mi l mj mk">sudo dnf install julia</span></pre><p id="58ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在你的终端中输入“朱丽亚”进入朱丽亚 press，然后按]，这将带你进入 Pkg REPL。添加精灵:</p><ul class=""><li id="5e4d" class="oj ok it kd b ke kf ki kj km ol kq om ku on ky oo op oq or bi translated">添加“精灵”</li></ul><p id="f01d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在用退格键离开 pkg repl，用 ctrl 或 command + D 离开 repl</p><p id="ea77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们要配置 NGINX 并获得一个精灵服务器设置。我们需要制作一个 NGINX 配置文件，将网站指向一个套接字端口，以便在其上执行代码。在这一点上，你将取代--用你的 IP/域名。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6b2e" class="mf mg it mb b gy mh mi l mj mk">server {<br/>    listen 80;<br/>    server_name -----------;</span><span id="51bc" class="mf mg it mb b gy mx mi l mj mk">location / {<br/>        proxy_pass <a class="ae lj" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000</a>;<br/>        proxy_set_header Host $host;<br/>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>    }<br/>}</span></pre><p id="0b5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">配置完 NGINX 之后，我们可以继续测试我们的配置。导航回我们之前创建的目录，并放入我们的 NGINX 配置中</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="558e" class="mf mg it mb b gy mh mi l mj mk">cd /var/www/---------</span></pre><p id="a56c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您的算法应该包含在该文件夹中。现在，我们可以在终端内部使用所有文件。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="42ca" class="mf mg it mb b gy mh mi l mj mk">route("/") do<br/>       <a class="ae lj" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> "algorithm.jld2"<br/>       year = haskey(<a class="ae lj" href="http://twitter.com/params" rel="noopener ugc nofollow" target="_blank">@params</a>, :year)<br/>       y_pred = pippredict(pipe,year)<br/>       return(y_pred)<br/>end</span></pre><p id="f330" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我做的一个:params 宏允许你基于符号获取参数，类似 Flask 中的 request.args()。</p><p id="19b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们只需输入</p><blockquote class="kz"><p id="66bd" class="la lb it bd lc ld le lf lg lh li ky dk translated">向上()</p></blockquote><p id="a8b4" class="pw-post-body-paragraph kb kc it kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky im bi translated">并导航到我们的 NGINX 配置的 IP，如果您没有为此破例，您应该会得到一个空返回，但如果您输入一年，例如我的:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="45ba" class="mf mg it mb b gy mh mi l mj mk"><a class="ae lj" href="http://45.56.119.8/?year=1955" rel="noopener ugc nofollow" target="_blank">http://45.56.119.8/?year=1955</a></span></pre><blockquote class="na nb nc"><p id="9347" class="kb kc nd kd b ke kf kg kh ki kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ky im bi translated">(不确定该链接将存在多长时间)</p></blockquote><p id="daf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是还有一个大问题。我们的服务器将停止，如果我们退出这个朱莉娅 REPL，所以你必须保持这个终端永远开放。</p><blockquote class="kz"><p id="1a26" class="la lb it bd lc ld le lf lg lh li ky dk translated">开个玩笑…</p></blockquote><p id="415c" class="pw-post-body-paragraph kb kc it kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky im bi translated">我们将不得不创建一个真正的精灵应用程序来为我们做计算。首先，把你的工作目录转到我们用 NGINX 提供的 www 文件夹。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9fe3" class="mf mg it mb b gy mh mi l mj mk">cd /var/www/-------</span></pre><p id="938c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在进入朱莉娅·REPL，加载精灵并运行<code class="fe os ot ou mb b">Genie<strong class="kd iu">.</strong>newapp_webservice() like so:</code></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4dfb" class="mf mg it mb b gy mh mi l mj mk">julia<br/>using Genie<br/>Genie<strong class="mb iu">.</strong>newapp_webservice("app")</span></pre><p id="02ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将创建几个目录，但很可能在一个全新的文件夹中，该文件夹名为“无论您如何命名您的应用程序”,因此我们可以使用以下内容将其上移:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5cbf" class="mf mg it mb b gy mh mi l mj mk">mv app/* .<br/>rmdir app</span></pre><p id="6544" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在用 nano 制作一个名为 Project.toml 的新文件。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1902" class="mf mg it mb b gy mh mi l mj mk">nano Project.toml</span></pre><blockquote class="na nb nc"><p id="d2b1" class="kb kc nd kd b ke kf kg kh ki kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ky im bi translated">注意:没有 Project.toml 文件，精灵不会启动</p></blockquote><p id="f42e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要依赖 UUIDs。要获得这些，我们必须进入该项目的 github 页面，并像这样构造结果:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a451" class="mf mg it mb b gy mh mi l mj mk">name = "WWPipe"<br/>authors = ["emmett <a class="ae lj" href="mailto:emmett@emmettboudreau.com" rel="noopener ugc nofollow" target="_blank">emmett@emmettboudreau.com</a>"]</span><span id="a858" class="mf mg it mb b gy mx mi l mj mk">[deps]<br/>JLD2 = "033835bb-8acc-5ee8-8aae-3f567f8a3819"<br/>Lathe = "38d8eb38-e7b1-11e9-0012-376b6c802672"</span></pre><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/8ba0a3519202eb48f8ae292cebe8d98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZpkXmEGsbtQ_W6N0ZFlQA.jpeg"/></div></div></figure><p id="5df3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[deps]部分之后的代码是包的 UUIDs。您可能不需要配置[deps],因为我们正在运行我们自己的 VPS 但是把它们放进去仍然是个好习惯。</p><p id="9113" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们编辑任何东西之前，我们首先需要激活我们的精灵环境，然后安装我们的两个 dep。我们可以使用 bin/repl 从项目的根目录访问 REPL。注意:如果在任何尚未安装的文件中调用了依赖项，REPL 将无法加载，因此最好先这样做。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="715d" class="mf mg it mb b gy mh mi l mj mk">-$ bin/repl</span></pre><p id="2540" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">几分钟后，我们的 REPL 将上升，我们可以添加车床和 JLD2</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="320b" class="mf mg it mb b gy mh mi l mj mk">]<br/>pkg&gt; add "Lathe"#Unstable<br/>pkg&gt; add JLD2</span></pre><p id="0927" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在一直退格，直到 Julia 包装文本闪烁，并按 CTRL/Command + D，这将把我们带回 bash。现在要测试您的服务器，您可以简单地运行 bin/server:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a3b6" class="mf mg it mb b gy mh mi l mj mk">-$ bin/server</span></pre></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><p id="dc1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要编辑我们的 routes 文件来添加一些逻辑。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f79c" class="mf mg it mb b gy mh mi l mj mk">nano routes.jl</span></pre><p id="7244" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我的结局:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c702" class="mf mg it mb b gy mh mi l mj mk">using Genie.Router<br/>using Lathe.pipelines: pippredict<br/>using JLD2<br/>route("/") do<br/>      <a class="ae lj" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> "algorithm.jld2"<br/>      year = haskey(<a class="ae lj" href="http://twitter.com/params" rel="noopener ugc nofollow" target="_blank">@params</a>, :year)<br/>      y_pred = pippredict(pipe,year)<br/>      return(y_pred)<br/>end</span></pre><p id="9449" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">load 宏将我们的管道对象作为可变结构 pipe 加载。我们采用函数 pippredict(很快将使用 Lathe.models: predict)并插入我们的请求参数。当然，我们会返回结果。</p><p id="13c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了一个包含文件和所有内容的工作服务器，我们需要一个管理员来为我们运行服务器。首先，如果您没有 supervisor，请安装它:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4864" class="mf mg it mb b gy mh mi l mj mk">sudo dnf install supervisor</span></pre><p id="60b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要为主管做一个配置。所以纳米一上来！</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="da18" class="mf mg it mb b gy mh mi l mj mk">sudo nano /etc/superviser/conf.d/genieapp.conf</span></pre><p id="7c90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">启动 Genie 服务器的 sh 命令是 bin/server，所以我的配置看起来有点像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ead5" class="mf mg it mb b gy mh mi l mj mk">[program:genie]<br/>directory=/var/www/45.56.119.8/<br/>command=/var/www/45.56.119.8/bin/server<br/>autostart=true<br/>autorestart=true<br/>stopasgroup=true<br/>killasgroup=true</span></pre><p id="97ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要重新启动我们的主管:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fd41" class="mf mg it mb b gy mh mi l mj mk">sudo systemctl reboot</span></pre><p id="2ff3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">等待几分钟，因为 Genie 可能需要重新编译您的依赖项，希望它会出现！</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><p id="7bfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我真的很期待用 Genie 构建更复杂的算法！Genie 最大的弱点是缺乏文档，但是最近这越来越不真实了。我迫不及待地想看看我用这些奇妙的工具开发了什么！我们现在唯一能做的就是继续写作，继续承诺；车床几乎进入 0.1.0 版本，这是令人难以置信的兴奋！如果你想把承诺推到车床上，请这样做！车床不稳定可从这里获得:</p><blockquote class="kz"><p id="b7d1" class="la lb it bd lc ld le lf lg lh li ky dk translated"><a class="ae lj" href="https://github.com/emmettgb/Lathe.jl/tree/Unstable" rel="noopener ugc nofollow" target="_blank">车床</a></p></blockquote></div></div>    
</body>
</html>