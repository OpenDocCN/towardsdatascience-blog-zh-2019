<html>
<head>
<title>Best exponential transformation to linearize your data with Scipy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Scipy 线性化数据的最佳指数变换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/best-exponential-transformation-to-linearize-your-data-with-scipy-cca6110313a6?source=collection_archive---------13-----------------------#2019-02-20">https://towardsdatascience.com/best-exponential-transformation-to-linearize-your-data-with-scipy-cca6110313a6?source=collection_archive---------13-----------------------#2019-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用 scipy 优化包找到拟合线性关系的最佳指数？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/871363b2c8acdb63967904d4dac639f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAkw1soYp6Mw7bQtzH0KiA.jpeg"/></div></div></figure><p id="333b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们希望找到最优解的任何应用来说，迭代搜索都是必要的，但是问题的解不能以显式的形式表达。例如，机器学习中有很多算法使用迭代方法来寻找最佳参数集，如 Lasso 线性回归、梯度推进机器等。<br/>在本文中，我们将尝试在 ETL 过程中使用数值方法，通过最佳指数变换将两个变量之间的非线性关系转换为线性关系。</p><p id="4668" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名数据科学家，我经常要检查不同变量之间的关系，并用它们总结一些关键指标。我最近遇到了一个评估发动机效率的项目，我想表达一种运输寿命期间的燃料消耗/速度比。案例研究变量之间的关系是非线性和单调递增的，所以我开始在谷歌上搜索是否有一种统计测试可以利用我的数据进行转换，使其更加线性，就像正态性的 box-cox 一样。<br/>在这一点上，我想做一个实验:一个迭代过程，通过最小化一个成本函数<strong class="kt ir">线性化</strong>我的数据。<br/>在我平时的工作中，我经常利用<code class="fe ln lo lp lq b"><strong class="kt ir">scipy.optimize</strong></code>模块寻找函数极小值，为什么不把它用于其他用途呢？<br/>你可以更好地阅读<a class="ae lr" href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中的<code class="fe ln lo lp lq b"><strong class="kt ir">scipy.optimize</strong></code>，其中提供了有用的解释和示例。</p><h2 id="937d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">开始设置</h2><p id="80c0" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">在我的搜索中，我将重点放在了<strong class="kt ir">指数变换</strong>上，因为我们可以轻松地将指数设置为一个参数，并提供一个连续的探索范围。尽管这种选择排除了一些强非线性的界限，但它通常会返回好的结果。</p><p id="a13f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们准备测试数据并创建两个相关变量<em class="mq"> x，y </em>，其中<em class="mq"> y </em>等于<em class="mq"> x </em>的幂<em class="mq"> e </em>，加上一些高斯噪声。为了方便起见，我也设置了依赖于指数的高斯噪声方差。</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="4dda" class="ls lt iq lq b gy mv mw l mx my">#test data setting<br/>e = 2.465 #exp<br/>x = np.arange(0,25,0.01)<br/>y = x**e + np.random.normal(0,10**e,x.shape)</span></pre><p id="de05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们用<code class="fe ln lo lp lq b"><strong class="kt ir">seaborn</strong></code>回归图绘制数据，我们可以很容易地发现非线性关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8b4ccc3d3f16badf2957c278fbb96311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*qYLP6wtxqbKPJFKJyhILgw.png"/></div></figure><h2 id="7794" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated"><strong class="ak">成本函数</strong></h2><p id="1222" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">我们现在需要的是一个<strong class="kt ir">成本函数</strong>，一个我们想要最大化的线性关系的“好”的度量。一个很好的指标是<strong class="kt ir">皮尔逊积差相关系数 r </strong>，它确定了两个变量之间线性相关的强度。<br/> Pearson r 的取值在-1 和 1 之间，其中 1 为完全正线性相关，0 为无线性相关，1 揭示完全负线性相关；意思是 r = -1 和 r = 1 一样好。<br/>因此，为了正确使用 Pearson r，我们将取其绝对<strong class="kt ir">值</strong>并<strong class="kt ir">取反</strong>值，因为<code class="fe ln lo lp lq b"><strong class="kt ir">scipy.optimize</strong></code>函数搜索最小值，而我们想要其最大值。</p><p id="f63f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义成本函数:</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="ab7c" class="ls lt iq lq b gy mv mw l mx my">#define cost function<br/>def cost_function(e):<br/>    #y and x are already defined<br/>    r = np.corrcoef(y,x**e) #returns correlation matrix<br/>    #print each iteration<br/>    print('r value: {:0.4f} exp: {:.4f}'.format(r[0][1],e)) <br/>    return -abs(r[0][1])</span></pre><h2 id="4acb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">优化功能</h2><p id="74dc" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">此时，我们必须调用其中一个 Scipy 方法。<br/>合适的选择可能是<code class="fe ln lo lp lq b"><strong class="kt ir">minimize_scalar</strong></code>方法，因为我们的成本函数是标量函数。这个包背后的算法是<strong class="kt ir"> Brent 的方法</strong>，一个不需要梯度估计的求根算法。</p><p id="e672" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我发现了一个非常详尽的视频，是奥斯卡·维利兹频道关于布伦特方法及其对德克尔和割线方法的依赖性的视频。检查出来，如果你想知道更多关于这一点，以及其他，优化功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7f3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们导入并调用<code class="fe ln lo lp lq b"><strong class="kt ir">minimize_scalar</strong></code>函数:</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="f47a" class="ls lt iq lq b gy mv mw l mx my">from scipy.optimize import minimize_scalar</span><span id="263c" class="ls lt iq lq b gy nc mw l mx my">minimize_scalar(cost_function)</span></pre><p id="b763" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以设置一个<strong class="kt ir">搜索范围</strong>，避免指数的 0 值，这意味着 Pearson r 返回一个无效值，即使<code class="fe ln lo lp lq b"><strong class="kt ir">numpy.corrcoeff</strong></code> <strong class="kt ir"> </strong>可以处理它。</p><p id="a95e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，该系数定义为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3e4497f21f3dcfd8fa06490b401daaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*7wsZbZetweC8Y7rOQDAUbQ.png"/></div></figure><p id="2de6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果 x 被提升到 0，则标准偏差为 0，比率返回无效值。为了执行<strong class="kt ir">有界</strong>搜索，让我们调用:</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="3d06" class="ls lt iq lq b gy mv mw l mx my">minimize_scalar(cost_function,bounds=(0.1, 10), method='bounded')</span></pre><p id="9ab2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果列表如下:</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="6e5d" class="ls lt iq lq b gy mv mw l mx my">r value: 0.9242 exp: 3.8815<br/>r value: 0.8681 exp: 6.2185<br/>r value: 0.9416 exp: 2.4371<br/>r value: 0.9100 exp: 1.2663<br/>r value: 0.9407 exp: 2.7565<br/>r value: 0.9416 exp: 2.4255<br/>r value: 0.9416 exp: 2.4861<br/>r value: 0.9416 exp: 2.4815<br/>r value: 0.9416 exp: 2.4819<br/>r value: 0.9416 exp: 2.4819<br/>r value: 0.9416 exp: 2.4819<br/>r value: 0.9416 exp: 2.4819</span><span id="09fc" class="ls lt iq lq b gy nc mw l mx my">fun: -0.9416331392353501<br/> message: 'Solution found.'<br/>    nfev: 12<br/>  status: 0<br/> success: True<br/>       x: 2.4818969221255713</span></pre><p id="aa5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<strong class="kt ir">仅仅 12 次迭代</strong>中，得到的指数是 2.482，非常接近我们用来生成数据的指数 2.465。</p><p id="c1ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">声音<code class="fe ln lo lp lq b"><strong class="kt ir">fun</strong></code>显示皮尔逊 r 的负绝对值的值，好像挺高的。让我们应用在<em class="mq"> x、</em>上找到的指数再次绘制<em class="mq"> y </em>和<em class="mq"> x </em>我们将注意到一个<strong class="kt ir">强线性关系</strong>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/326f29965f88d3ecc3040d7163ebdb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*9p2aTe3biLVY_zdpafUyYQ.png"/></div></figure><p id="799d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们存储每个迭代指数和相关的皮尔逊系数，我们可以绘制 r-指数曲线。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/718f547fb5019c16a982797c4792f0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*she0MJTh2J9J2eC8dRa99g.png"/></div></div></figure><h2 id="8c71" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">其他测试</h2><p id="8163" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">如果我们增加测试数据中噪音的影响会怎样？让我们在噪声发生器中增加高斯方差:</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="c7ca" class="ls lt iq lq b gy mv mw l mx my">y = (x**e) + np.random.normal(0,20**e,x.shape)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1fdcd538dcb84480ef3756e647ed862e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*PGw1XTaHZPev1Tim0CKsOg.png"/></div></figure><p id="9f4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优化函数的执行返回以下结果:</p><pre class="kg kh ki kj gt mr lq ms mt aw mu bi"><span id="97d7" class="ls lt iq lq b gy mv mw l mx my">fun: -0.42597730774659237<br/> message: 'Solution found.'<br/>    nfev: 13<br/>  status: 0<br/> success: True<br/>       x: 2.2958258442618553</span></pre><p id="d4a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">找到的最佳指数不如以前的结果精确，但它仍然是一个很好的近似值。</p><p id="b965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">噪声影响越大，由于噪声对岩心数据的影响越大，会导致错误的结果。</p><h2 id="fd0d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">结论</h2><p id="2755" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">优化方法是许多待开发应用的<strong class="kt ir">金矿</strong>。通过这篇文章，我不想教一种新技术，但我想促进这些有效方法在“不寻常”问题上的实验。</p></div></div>    
</body>
</html>