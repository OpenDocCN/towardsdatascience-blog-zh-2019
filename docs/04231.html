<html>
<head>
<title>How to extract online data using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Python 提取在线数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-extract-online-data-using-python-8d072f522d86?source=collection_archive---------8-----------------------#2019-07-02">https://towardsdatascience.com/how-to-extract-online-data-using-python-8d072f522d86?source=collection_archive---------8-----------------------#2019-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fae8372a104da497f1d2b61d8c536ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZR4iNB24mdH4f51ceQWtHA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@aaronburden?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Aaron Burden</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="facd" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">关于 HTML、XPath、Scrapy 和 spiders 的基本概念</h2></div><p id="e7b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">她的一位同事说:“我希望能拥有网站的所有文件。”</p><p id="cdb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“是的，这能给我们提供很多信息”——另一位同事说</p><p id="fc27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">“你会做刮刀吗？”他们都转头看着她</em></p><p id="fe78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">"<em class="lu">嗯……我可以……她开始喃喃自语</em></p><p id="e2eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">【完美】</em>——他们都说</p><p id="fb4a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">“…。她说完了，但为时已晚</em></p><p id="9aaf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">她一生中从未用过刮刀。所以她当时不知所措。</p><p id="421d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">“我不知道该怎么办”</em> —她哭着给我打电话— <em class="lu">“我觉得这对我来说太难了”</em></p><p id="ad2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">“你别担心！我们可以一起做”</em>——我说</p><p id="eaa6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我完全理解她。第一次我不得不为一个 scraper 编码时，我也感到很失落。</p><p id="2514" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像我在看一场魔术表演。我记得当我开始阅读刮痧时。</p><p id="3690" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">“Web scrapers</em>…mm…<em class="lu">HTML 标签…mm…蜘蛛</em> … <em class="lu">什么…?"对我来说，这听起来像是一门外语</em></p><p id="2d92" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但我读得越多，就越开始明白，就像魔术一样，你需要知道要寻找什么才能理解其中的诀窍。</p><p id="2d7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到底什么是 web 刮刀？web scraper 是一种从网站上自动收集数据的程序。</p><p id="20c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以收集网站的所有内容，或者只是关于某个主题或元素的特定数据。这将取决于我们在脚本中设置的参数。这种多功能性是 web 刮刀的魅力所在。</p><p id="28eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们举个假设的例子。我们想从一个网址为<code class="fe lv lw lx ly b">https://www.mainwebsite.com</code>的网站上抓取数据。特别是，这个网站包含不同的文件。我们对获取他们的文本感兴趣。</p><p id="f3e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在主页中，我们可以找到三个子部分，如下图所示。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/9628b3f54c359795d55f8116105eddd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TwwnnflViAyn0yE_HWeTw.png"/></div></div></figure><p id="ae2a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，点击<code class="fe lv lw lx ly b">topic1</code>，我们将进入另一个页面(<code class="fe lv lw lx ly b">https://www.mainwebsite.com/topic1</code>，在那里我们可以找到我们感兴趣的文档列表。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/6cdce922c3aa2a84d44ffaa79ecbb574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uGpaxIClB84x2R9wbJzZw.png"/></div></div></figure><p id="3f87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们点击<code class="fe lv lw lx ly b">document1</code>，我们将进入另一个页面(<code class="fe lv lw lx ly b">https://www.mainwebsite.com/topic1/document1/date</code>)，在那里我们可以获得该文档的内容。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/9f8fc5ae4c3798546bdbde2071089605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poKvap0dzeNu1Nau5dTLUA.png"/></div></div></figure><p id="3036" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们要手动操作，我们会将内容复制并粘贴到文件中。相反，我们将自动化这一过程。</p><p id="bd16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到了获取数据所需遵循的路径。现在，我们应该找到一种方法来告诉 web scraper 在哪里寻找信息。</p><p id="099b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">网站上有很多数据，比如图片、其他页面的链接、标题，我们都不感兴趣。因此，我们需要非常具体。</p><p id="e5c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们开始揭开魔术的地方。那我们解剖一下吧。</p><p id="d547" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">1</span>T16】HTML 代表超文本标记语言。它与层叠样式表(CSS)和 Javascript 一起，用于在交互式网站上构建和呈现内容。</p><p id="0ac9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你不需要学习如何使用 HTML 编码来构建一个 scraper。但是你应该知道如何识别 HTML 标签和元素。</p><p id="542b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么？因为数据会有一个特定的 HTML 标签。我们可以通过向 scraper 显示正确的 HTML 元素来提取这些数据。</p><p id="3c58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<em class="lu"> HTML 标签</em>由一个用尖括号括起来的标签名组成。通常，您需要一个开头和一个结尾标签来框定一段特定的文本。</p><p id="b2f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始标记由一个名称和可选属性组成。结束标签由相同的名称加上一个正斜杠(<code class="fe lv lw lx ly b">/</code>)组成。</p><p id="0420" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个标签名称都指一个特定的元素。我们会注意下面的标签:<code class="fe lv lw lx ly b">&lt;p&gt;</code>用于段落；<code class="fe lv lw lx ly b">&lt;a&gt;</code>或锚标记为超链接；<code class="fe lv lw lx ly b">&lt;img&gt;</code>为图片；<code class="fe lv lw lx ly b">&lt;h1&gt;</code>、<code class="fe lv lw lx ly b">&lt;h2&gt;</code>等。对于文本标题；<code class="fe lv lw lx ly b">&lt;div&gt;</code>为分隔线，<code class="fe lv lw lx ly b">&lt;tr&gt;</code>为表格行，<code class="fe lv lw lx ly b">&lt;td&gt;</code>为表格列。</p><p id="26bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数标签还带有<code class="fe lv lw lx ly b">id</code>或<code class="fe lv lw lx ly b">class</code>属性。<code class="fe lv lw lx ly b">id</code>为 HTML 文档中的 HTML 标签指定了一个惟一的 id。<code class="fe lv lw lx ly b">class</code>用于定义标签将采用的样式。</p><p id="a0cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们观察一个 HTML 元素:</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/cdc4381426b1f677ce030abf688d3bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67dptBM-D6v6-IXpyiDYnQ.png"/></div></div></figure><p id="7a97" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们希望提取 HTML 元素的内容“2019 年 6 月 28 日版”。我们会告诉 scraper:寻找所有的<h6>元素，给我一个带有类“text-primary”的元素。</h6></p><p id="793c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有一个以上的元素具有这些特征，我们就需要更加具体。指示 ID 属性可以实现这一点。</p><p id="7777" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。但是我在网站上哪里可以找到这些信息呢？</p><p id="d44c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个简单的步骤:右击网页上的任何地方。将出现一个小窗口。接下来，你点击<em class="lu">检查</em>，如下图<em class="lu"> </em>所示。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mp"><img src="../Images/54c773b3deaee362c3d38f3cd762a867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMMxbfiU4UwDzDcvK_xmSA.png"/></div></div></figure><p id="41fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以访问网站的源代码，图片，CSS，字体和图标，Javascript 代码。</p><p id="5290" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，您可以使用光标选择器(<em class="lu">见</em>下面的图片)选择网站中的项目。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/32d44245e1c8f091f58e867e2e089b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFQRn0B2nEkt52rndrzQtA.png"/></div></div></figure><p id="e235" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，对应于所选项目的 HTML 元素将被突出显示。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mr"><img src="../Images/05b86866ab00ad32e995196a92f09d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8MzOzUr7uo2RbnmTgf5UQ.png"/></div></div></figure><p id="ea68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上图中，我们可以观察到一个典型的 HTML 结构是什么样子。</p><p id="3ad2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正常情况下，所有内容都包含在开始和结束<code class="fe lv lw lx ly b">body</code>标签中。每个元素都有自己的标签。</p><p id="3170" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些 HTML 元素嵌套在其他元素中，形成层次结构。这可以用树来表示。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/5412cc69084288ee73324cb526ef751d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJGvrj4Pd3eJQLQeeH94rA.png"/></div></div></figure><p id="5963" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在树中从左向右移动，我们向前移动了几代。如果我们从上到下移动，我们会在同一代之间移动，或者在来自同一个父元素的兄弟元素之间移动。</p><p id="5373" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意两个<code class="fe lv lw lx ly b">&lt;div&gt;</code>元素。他们是兄弟姐妹，因为他们共享<code class="fe lv lw lx ly b">&lt;body&gt;</code>作为父母。他们是<code class="fe lv lw lx ly b">html</code>元素的第二代传人。他们每个人都有孩子。第一只<code class="fe lv lw lx ly b">&lt;div&gt;</code>有两个孩子。它的第一个孩子是一个包含“网页抓取有用！”元素。然而，这个元素并不是第二个<code class="fe lv lw lx ly b">&lt;div&gt;</code>的后代。这是因为您不能沿着从这个 div 元素到 paragraph 元素的路径。</p><p id="82c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些关系也将有助于我们向 web scraper 指示所需的元素。</p><p id="b874" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">2</span>T19】XPath 代表 XML 路径语言。<strong class="la jk"> </strong>跟网页抓取有什么关系？我们将学习如何识别 HTML 元素。但是现在出现的问题是<em class="lu">我如何向刮刀指出元素？答案是 XPath。</em></p><p id="dc0b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XPath 是一种特殊的语法，可用于浏览 XML 文档中的元素和属性。此外，它将帮助我们获得某个 HTML 元素的路径并提取其内容。</p><p id="f50c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这个<a class="ae jg" href="https://devhints.io/xpath" rel="noopener ugc nofollow" target="_blank">语法是如何工作的</a>。</p><p id="4d33" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">/</code>用于向前移动一个代，<code class="fe lv lw lx ly b">tag-names</code>给出哪个元素的方向，<code class="fe lv lw lx ly b">[]</code>告诉我们选择哪个兄弟元素，<code class="fe lv lw lx ly b">//</code>查找所有后代，<code class="fe lv lw lx ly b">@</code>选择属性，<code class="fe lv lw lx ly b">*</code>是通配符，表示我们希望忽略标记类型。</p><p id="642e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们看到下面的 XPath:</p><pre class="ma mb mc md gt mt ly mu mv aw mw bi"><span id="6dc0" class="mx my jj ly b gy mz na l nb nc">Xpath = '//div[@class="first"]/p[2]'</span></pre><p id="21e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们会理解，从所有(<code class="fe lv lw lx ly b">//</code>)<code class="fe lv lw lx ly b">div</code>元素中带<code class="fe lv lw lx ly b">class</code>"<em class="lu">"</em>"(<code class="fe lv lw lx ly b">div[@class="first"]</code>)，我们要第二个(<code class="fe lv lw lx ly b">[2]</code>)段落(<code class="fe lv lw lx ly b">p</code>)元素。</p><p id="f00b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，web 浏览器有一种简单的方法来获取元素的 XPath。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nd"><img src="../Images/f1826dc54cfc18cd383ccda93d8b7bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyi3_moUSh8oiKs-bhQW8g.png"/></div></div></figure><p id="6be6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查网站时，右键单击突出显示的元素。将显示一个小窗口。然后可以复制<em class="lu"> XPath </em>。</p><p id="95ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">3</span>T8】Scrapy 是一个 Python 框架，专为抓取网站和提取结构化数据而设计。它是专门为网络抓取而设计的，但是现在它也可以通过 API 来提取数据。</p><p id="691e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了安装 Scrapy，你需要安装 Python。建议只使用 Python 3。Python 2 将于 2020 年 1 月弃用。</p><p id="fbe2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装 Scrapy，您可以使用 pip:</p><pre class="ma mb mc md gt mt ly mu mv aw mw bi"><span id="c061" class="mx my jj ly b gy mz na l nb nc">pip install Scrapy</span></pre><p id="f521" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者使用康达</p><pre class="ma mb mc md gt mt ly mu mv aw mw bi"><span id="db72" class="mx my jj ly b gy mz na l nb nc">conda install -c conda-forge scrapy</span></pre><p id="a78e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Scrapy 的一个重要方面是它使用了 Twisted，这是一个流行的 Python 事件驱动网络框架。Twisted 为并发性异步工作<em class="lu"/>。</p><p id="4bcd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是什么意思？同步意味着您必须等待一个作业完成，以便启动一个新作业。异步意味着您可以在前一个作业完成之前移动到另一个作业。</p><p id="5908" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">4</span>4<strong class="la jk">蜘蛛。</strong>因为这个特点，Scrapy 可以在很短的时间内抓取一组 URL。因此，Scrapy 与蜘蛛合作，而不是在一个网站上抓取。</p><p id="2c6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">蜘蛛是我们定义的类，Scrapy 使用它来抓取多个页面的链接并抓取信息。</p><h2 id="87f8" class="mx my jj bd ne nf ng dn nh ni nj dp nk lh nl nm nn ll no np nq lp nr ns nt nu bi translated"><em class="nv">蜘蛛结构:</em></h2><p id="9152" class="pw-post-body-paragraph ky kz jj la b lb nw kk ld le nx kn lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">蜘蛛必须满足某些要求才能正常工作。他们必须子类化<code class="fe lv lw lx ly b"><strong class="la jk"><em class="lu">scrapy.Spider</em></strong></code>，并定义要发出的初始请求。此外，他们还可以决定如何在页面中跟随以及如何解析下载的页面内容。</p><p id="a036" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们详细看看这些要求:</p><ol class=""><li id="536f" class="ob oc jj la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">每个蜘蛛必须是<code class="fe lv lw lx ly b"><strong class="la jk"><em class="lu">scrapy.Spider</em></strong></code>类的子类:这意味着它必须把它作为一个参数。</li><li id="c033" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">蜘蛛的<code class="fe lv lw lx ly b"><strong class="la jk"><em class="lu">name</em></strong></code>在一个项目中必须是唯一的。</li><li id="8832" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">他们必须定义最初的请求:必须有一个方法调用<code class="fe lv lw lx ly b"><strong class="la jk"><em class="lu">start_requests()</em></strong></code>。Scrapy 将总是寻找它来发起请求。它还必须返回一系列请求，蜘蛛将从这些请求开始爬行。</li><li id="9560" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">他们可以决定如何解析下载的内容:通常会定义一个<code class="fe lv lw lx ly b"><strong class="la jk"><em class="lu">parse()</em></strong></code>方法。我们调用它来处理为每个请求下载的响应。parse()方法通常会解析响应，提取抓取的数据，还会找到新的 URL 并根据它们创建新的请求。</li><li id="bce7" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">我们也可以找到<code class="fe lv lw lx ly b"><strong class="la jk">allowed_domains</strong></code>名单。这告诉蜘蛛什么是允许抓取的域名。</li><li id="e93a" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">此外，我们可以设置一个列表。用来指定我们要刮什么网站。默认情况下，Scrapy 使用 HTTP 协议。还得改成 https。</li></ol><p id="90f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们已经剖析了 web 刮刀的所有组件。</p><p id="90c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> →该写了！！← </strong></p><p id="ee46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将带来 URL 为<code class="fe lv lw lx ly b">https://www.mainwebsite.com</code>的网站的初始示例。</p><p id="7c77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们回顾一下事实:</p><ul class=""><li id="3f04" class="ob oc jj la b lb lc le lf lh od ll oe lp of lt op oh oi oj bi translated">我们有一个主网站，有三个链接到三个不同的部分。</li><li id="8ad4" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt op oh oi oj bi translated">在每个部分中，我们都有一个文档链接列表。每个部分都有一个特定的 URL，例如<code class="fe lv lw lx ly b">https://www.mainwebsite.com/topic1</code>。</li><li id="6510" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt op oh oi oj bi translated">每个链接都将我们带到我们感兴趣的文档内容。我们可以在每个部分的 HTML 结构中找到每个链接。</li></ul><p id="47f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将设计我们的文件架构。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/8dad7a405f5477d25de803be4f658e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8yRQ7eUwvurCFWjoTrZhQ.png"/></div></div></figure><p id="ef9a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们探索一下我们的<em class="lu">文件夹</em>。</p><p id="6223" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经创建了一个名为<code class="fe lv lw lx ly b">scraper</code>的主文件夹，在这里我们将存储与我们的刮刀相关的所有文件。</p><p id="73a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们将收集 JSON 文件中的所有数据。这些文件都将保存在<code class="fe lv lw lx ly b">JSON</code>文件夹中。</p><p id="90eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">常用文件夹还有一个文件夹叫<code class="fe lv lw lx ly b">spiders</code>。在那里，我们将为每个蜘蛛保存一个文件。我们将为每个主题创建一个蜘蛛。所以，总共三只蜘蛛。</p><p id="f0e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，是时候了解我们创建的文件了。</p><p id="a5ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先从<code class="fe lv lw lx ly b">settings.py</code>说起吧。Scrapy <strong class="la jk">设置</strong>允许我们定制所有 Scrapy 组件的行为，包括核心、扩展、管道和蜘蛛本身。</p><p id="303c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在那里，我们可以指定由 Scrapy 项目实现的 bot 的名称，Scrapy 将在其中寻找蜘蛛的模块列表，以及 HTTP 缓存是否将被启用，等等。</p><p id="8983" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们到达主要的两个文件。</p><p id="7e98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mf translated">我们先从<code class="fe lv lw lx ly b"><strong class="la jk">topic1.py</strong></code> <strong class="la jk">蜘蛛</strong>开始。我们将只研究一个例子，因为它们都非常相似。</p><p id="267d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要做的第一件事是导入所有需要的库。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="bbd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，我们需要导入<code class="fe lv lw lx ly b"> scrapy</code>。模块将允许我们使用正则表达式提取信息。<code class="fe lv lw lx ly b">json</code>模块将在保存信息时帮助我们。<code class="fe lv lw lx ly b">os</code>模块对于处理目录很有用。</p><p id="90a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们之前说过，蜘蛛必须继承<code class="fe lv lw lx ly b"><strong class="la jk"><em class="lu">scrapy.Spider</em></strong></code> <strong class="la jk"> <em class="lu">。</em> </strong>所以我们将创建一个名为<code class="fe lv lw lx ly b">FirstSpider </code>的类来继承它。我们将指定<code class="fe lv lw lx ly b"><strong class="la jk">name</strong> </code>主题 1。然后，我们将定义<code class="fe lv lw lx ly b"><strong class="la jk">allowed_domains</strong></code>列表。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="c6d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还需要创建<code class="fe lv lw lx ly b"><strong class="la jk">start_request()</strong></code>方法来初始化请求。在这个方法中，我们为请求定义了一个 URL 列表。在我们的例子中，这个列表只包含 URL <code class="fe lv lw lx ly b"><a class="ae jg" href="http://www.mainwebsite.com/topic1." rel="noopener ugc nofollow" target="_blank">www.mainwebsite.com/topic1</a></code> <a class="ae jg" href="http://www.mainwebsite.com/topic1." rel="noopener ugc nofollow" target="_blank">。</a>然后，我们要用<code class="fe lv lw lx ly b">scrapy.Request</code>提出请求。</p><p id="5c77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将用<code class="fe lv lw lx ly b"><a class="ae jg" href="https://pythontips.com/2013/09/29/the-python-yield-keyword-explained/" rel="noopener ugc nofollow" target="_blank">yield</a></code>代替<code class="fe lv lw lx ly b">return</code>。我们将告诉 scrapy 使用回调参数中的<code class="fe lv lw lx ly b"><strong class="la jk">parse()</strong></code>方法来处理下载的内容。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="2f09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，你可能认为关于 HTML 和 XPath 的解释是没有用的。现在是我们需要它的时候了。</p><p id="3f4a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们定义了启动初始请求的方法之后，我们需要定义处理下载信息的方法。</p><p id="f3f1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，我们需要决定如何处理这些数据。哪些信息值得保存。</p><p id="c1a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，让我们假设这是我们网站的 HTML 结构。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/5cf081a3211447ddeeb10a40bb7e6a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1EVaTEAsERCkMV9gWEjmA.png"/></div></div></figure><p id="e491" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在图片中看到的，突出显示的元素是我们提取链接所需的元素。</p><p id="2597" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们建造到达那里的路径。从所有(<code class="fe lv lw lx ly b">//</code>)具有<code class="fe lv lw lx ly b">class</code> col-md-12 ( <code class="fe lv lw lx ly b">div[@class='col-md-12']</code>)的<code class="fe lv lw lx ly b">div</code>元素中，我们需要来自<code class="fe lv lw lx ly b">a</code>子元素(<code class="fe lv lw lx ly b">a/@href</code>)的属性<code class="fe lv lw lx ly b">href</code>。</p><p id="065a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们有了 XPath: <code class="fe lv lw lx ly b">//div[@class='col-md-12']/a/@href</code>。</p><p id="d8c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的<code class="fe lv lw lx ly b">parse</code>方法中，我们将使用<code class="fe lv lw lx ly b">response.xpath()</code>来指示路径，使用<code class="fe lv lw lx ly b">extract()</code>来提取每个元素的内容。</p><p id="80a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们期待得到一个链接列表。我们希望提取那些链接中显示的内容。蜘蛛需要跟踪它们中的每一个，并使用我们称之为<code class="fe lv lw lx ly b">parse_first</code>的第二种解析方法解析它们的内容。</p><p id="2d38" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这次我们在响应变量中使用<code class="fe lv lw lx ly b">follow</code>发送链接，而不是创建一个请求。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="4b52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，必须定义<code class="fe lv lw lx ly b">parse_first</code>方法来告诉蜘蛛如何跟踪链接。</p><p id="795d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将提取文档的标题和正文。</p><p id="4522" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在探索了一个文档的 HTML 结构之后，我们将得到任何一个<code class="fe lv lw lx ly b">id</code>为<em class="lu"> titleDocument、</em>的元素，以及任何一个<code class="fe lv lw lx ly b">id</code>为<em class="lu"> BodyDocument 的元素的子元素的所有段落。</em></p><p id="95f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们不关心他们有哪个标签，所以我们将使用<code class="fe lv lw lx ly b">*</code>。</p><p id="8070" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">得到每个段落后，我们将把它们添加到一个列表中。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="f29e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们将把文本列表中的所有段落连接在一起。我们会提取日期。最后，我们将使用<code class="fe lv lw lx ly b">date</code>、<code class="fe lv lw lx ly b">title</code>和<code class="fe lv lw lx ly b">text</code>定义一个字典。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="6b49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将数据保存到一个 JSON 文件中。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="3250" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是函数<code class="fe lv lw lx ly b">extractdate</code>的定义，我们将使用正则表达式来提取日期。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="0b7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们的蜘蛛完成了。</p><p id="d4f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di"> B </span>该调查<code class="fe lv lw lx ly b"><strong class="la jk">scraper.py</strong></code>文件了。我们不仅需要创造蜘蛛，还需要发射它们。</p><p id="2b22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将从 Scrapy 导入所需的模块。<code class="fe lv lw lx ly b">CrawlerProcess</code>将启动抓取过程，而<code class="fe lv lw lx ly b">settings</code>将允许我们安排设置。</p><p id="9cec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还将导入为每个主题创建的三个蜘蛛类。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="e78c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们启动一个爬行过程</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="8a5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们告诉进程使用哪些蜘蛛，最后，我们将开始爬行。</p><figure class="ma mb mc md gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="92a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完美！我们现在有我们的铲运机了！！！</p><p id="c14b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等，我们实际上如何开始抓取我们的网站呢？</p><p id="decd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在终端中，我们通过命令行导航到 scraper 文件夹(使用<code class="fe lv lw lx ly b">cd</code>)。一旦进入，我们就用图中看到的<code class="fe lv lw lx ly b">python3</code>命令启动蜘蛛。</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/3e4a0b44c276a005afe597c9e45fa91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxybXLfl6EmeBF4gYKMQ2w.png"/></div></div></figure><p id="9e9f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后<em class="lu">瞧啊</em>！蜘蛛正在爬网站！</p><figure class="ma mb mc md gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/a70a1e5f27e5efa3a116083ef66dcbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGsd4UJkrwDhGIWVEcve_Q.png"/></div></div></figure><p id="e64c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我列出了一些非常好的资源和课程来学习更多关于网络抓取的知识:</p><ol class=""><li id="101a" class="ob oc jj la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">数据营课程。</li><li id="3b80" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae jg" href="https://realpython.com/python-web-scraping-practical-introduction/" rel="noopener ugc nofollow" target="_blank">网页抓取教程</a></li><li id="7e6e" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae jg" href="https://docs.scrapy.org/en/latest/" rel="noopener ugc nofollow" target="_blank">刺儿头文档</a></li><li id="f30b" class="ob oc jj la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae jg" href="https://medium.com/actualize-network/modern-html-explained-for-dinosaurs-65e56af2981" rel="noopener"> HTML 长</a>和<a class="ae jg" href="https://www.freecodecamp.org/news/learn-html-in-5-minutes-ccd378d2ab72/" rel="noopener ugc nofollow" target="_blank">短</a>解释</li></ol></div></div>    
</body>
</html>