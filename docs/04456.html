<html>
<head>
<title>Bootstrapping at scale in Snowflake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">雪花中的规模自举</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bootstrapping-at-scale-in-snowflake-3e04a225ff5e?source=collection_archive---------30-----------------------#2019-07-09">https://towardsdatascience.com/bootstrapping-at-scale-in-snowflake-3e04a225ff5e?source=collection_archive---------30-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="70a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时候，当统计学家在抽样数据时，他们喜欢在获取下一个数据之前先把每一个数据放回去。这被称为带有替换的随机抽样<strong class="js iu">，相对于没有</strong>替换的随机抽样<strong class="js iu">，这是更常见的事情。</strong></p><p id="7447" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个在野外这样做的例子是在一个随机森林的训练中，这是我写这篇文章的原因。</p><p id="beac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有的雪花内置采样功能都是围绕采样而进行的，没有替换。这意味着您只需对每一行做一次决定——根据情况决定是进还是出。</p><p id="c48a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自举的困难在于，这有点像把骑自行车作为一种爱好；正确地做它是相当昂贵的。</p><p id="5e0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一种简单但完全准确的引导 10，000 行的方法是:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kt ku l"/></div></figure><p id="40f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使得源表中的所有 150，000 个客户每次都有均等的机会被选中，不管他们已经被选中了多少次。</p><p id="fef1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一定有更好的办法！答案当然是我们需要一个“足够好”的替代方案。毕竟我们是在采样，所以如果这意味着性能的提高，精度水平通常是灵活的。</p><p id="a29a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们看看我们是否能想出一个不同的方法。</p><p id="de45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目标是引导“雪花 _ 样本 _ 数据”中 150，000 条记录的 60%。“TPCH_SF1”。“客户”表。</p><p id="50ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望在表上进行一次迭代(从算法的意义上来说)，因此如果可能的话，在每一行上只做一次决策。我们需要想出一种方法来多次选择它，但要保持在样本的参数范围内。</p><p id="e753" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单的修改，如果我们任意地决定十次扫描表就足够了，那么我们可以每次只选择 6%,就像这样:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kt ku l"/></div></figure><p id="a8cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一点都不好。首先，我们对每一行都处理了十次，我们根本没有真正量化不准确性，我们只是编造了一个数字。</p><p id="2646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们看看每次迭代时每一行发生了什么，我们将考虑两个极端:总是被选中，从不被选中。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kv"><img src="../Images/ced645712590707a0ba7862d4808122b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcFW6ENK2aUet7ESjWX2wA.png"/></div></div></figure><p id="2bd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过一定次数的迭代后，不可避免地会有一个点(就像我们在澳大利亚说的那样)，每个记录都有一个“公平的结果”。所以我们需要一种划定界限的方法。出于本练习的目的，让我们允许用户指定两件事:</p><ol class=""><li id="4f27" class="lc ld it js b jt ju jx jy kb le kf lf kj lg kn lh li lj lk bi translated">样本的所需大小，以原始表的百分比表示</li><li id="fd88" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">一个百分比值，当永远不会被选中的概率低于它时，我们停止迭代。想象这是一条水平线，你可以放在上面图表的某个地方。</li></ol><h1 id="f908" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">方程式时间！</h1><p id="caa9" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">提醒一下，目标是 60%的样本。</p><p id="f71b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">暂时忘记“替换”部分，每次选择一行的概率:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/a53cb613a73b367811b3351da24f203a.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*cUem2EGSf0qweORqqRAZUA.png"/></div></figure><p id="5df8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者<strong class="js iu">没有</strong>被选中，只是翻转一下:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/396ae7cb20846960c98c04d8a9d101a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*0V6mFpCTbOILmqDZxF9bsA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">1–0.6 = 0.4</figcaption></figure><p id="354d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">右边的值是我们希望用户指定的。正如你所看到的，它总是减少，我们将不断增加迭代，直到我们达到它。</p><p id="6679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们可以概括地表达这一点，然后求解它，以计算出我们应该进行多少次迭代:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c12b8b14ffec4194df97bb45a14e003c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*lDlLKT0EG39guU8ctWHJJA.png"/></div></figure><p id="e171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了，现在我们有公式可以用了。</p><p id="d78d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们回到雪花。请记住，我们实际上并不想进行多次迭代。但是棘手的是，没有任何方法可以让一行在一个结果集中出现不止一次…<strong class="js iu"> <em class="na">还是有？！？！？！</em>T3】</strong></p><h1 id="ac12" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">输入 UDTFs</h1><p id="5eef" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">我真的很喜欢<a class="ae nb" href="https://docs.snowflake.net/manuals/sql-reference/udf-js-table-functions.html" rel="noopener ugc nofollow" target="_blank">udtf</a>，他们有办法实现优雅的解决方案，而不是糟糕的样板文件。</p><p id="7f97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看这个:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kt ku l"/></div></figure><p id="be1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用这个来一举两得。首先，它将应用该公式，根据我们发明的阈值计算出一个很好的迭代次数(即被选择的机会数)。</p><p id="5f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，礼貌地将样本分数除以该数，并写出该行数。</p><p id="f03a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了进行演示，UDTF 的输出本身如下所示:</p><pre class="ko kp kq kr gt nc nd ne nf aw ng bi"><span id="e181" class="nh lr it nd b gy ni nj l nk nl">select * from table(SAMPLE_PROBABILITY(0.6::double,0.00001::double))</span></pre><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/96612193f14d524f2c8d2aa9824c25ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*a1anLuki6chZBuaPt8em9g.png"/></div></figure><p id="070b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">公式说我们应该做 13 次迭代，0.6/13 = 0.0465384615</p><p id="19bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，我们将给予每行 13 次机会，每次尝试的概率为 0.04615384615。</p><p id="01c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要做的就是像这样加入这个 UDTF:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kt ku l"/></div></figure><p id="64eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">的原始结果:</p><pre class="ko kp kq kr gt nc nd ne nf aw ng bi"><span id="1715" class="nh lr it nd b gy ni nj l nk nl">SELECT customer.*<br/>FROM "SNOWFLAKE_SAMPLE_DATA"."TPCH_SF1"."CUSTOMER" customer,table(SAMPLE_PROBABILITY(0.6::double,0.00001::double))</span></pre><p id="5820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上是 150，000 * 13 = 1，950，000 行，但是我们添加了 WHERE 子句:</p><pre class="ko kp kq kr gt nc nd ne nf aw ng bi"><span id="f67a" class="nh lr it nd b gy ni nj l nk nl">where uniform(0::float, 1::float, random()) &lt; SAMPLE_PROBABILITY</span></pre><p id="da51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这会生成一个介于 0.0 和 1.0 之间的随机数，并删除低于阈值的行。</p><p id="68c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个 100%正确的实现应该给我们 90，000 行(150，000 * 0.6)。这个(使用我选择的输入)似乎每次都能产生 89，000 到 91，000 之间的结果。</p><p id="ad0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，正如我们所希望的那样，有可能出现重复。你甚至可以在搜索结果的第一页看到:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nn"><img src="../Images/fdb0991039b11f622a74d2174ca047b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syy0tzJ1uDPoVkJBJ6tTOA.png"/></div></div></figure><p id="62b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的 150，000 表上，返回大约 90，000 条记录，在一个 x-small 仓库上是一秒多一点。</p></div></div>    
</body>
</html>