<html>
<head>
<title>Cross Validation — Why &amp; How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉验证—为什么和如何</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cross-validation-430d9a5fee22?source=collection_archive---------1-----------------------#2019-01-30">https://towardsdatascience.com/cross-validation-430d9a5fee22?source=collection_archive---------1-----------------------#2019-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c3b150c3cdcff4f7200e4fabe7e1d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uDEMwR7Titl5LkxzrkR-w.jpeg"/></div></div></figure><p id="ee25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，你已经在一个不平衡的数据集上工作了几天，尝试了不同的机器学习模型，在你的数据集的一部分上训练它们，测试它们的准确性，你欣喜若狂地看到分数每次都超过 0.95。你真的认为你的模型达到了 95%的准确率吗？</p><h1 id="7e2b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">需要评估</h1><p id="c7d8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我假设您已经对数据集执行了顶级的预处理，并且已经移除了任何缺失值或分类值和噪声。无论你用什么最先进的算法来构建你的假设函数和训练机器学习模型，你都必须在前进之前评估它的性能。</p><p id="b277" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在评估一个模型最简单快捷的方法就是把数据集分成训练集和测试集，用训练集数据训练模型，用精度来检验它的精度。并且不要忘记在执行分割之前打乱数据集。但是这种方法根本不是一种保证，简单地说，在最终确定一个模型时，你不能依赖这种方法。你可能想知道——为什么？</p><p id="acf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑一下，你正在处理一个<em class="lz">垃圾邮件</em>数据集，其中包含<em class="lz"> 98% </em>的垃圾邮件和<em class="lz"> 2% </em>的非垃圾邮件有效邮件。在这种情况下，即使您不创建任何模型，而只是将每个输入分类为垃圾邮件，您也将获得 0.98 的精确度。这种情况叫做<a class="ae ma" href="https://en.wikipedia.org/wiki/Accuracy_paradox" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="lz">精度悖论</em> </strong> </a> <em class="lz">。</em></p><p id="1b92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一下，如果这是一个用于肿瘤细胞或胸部 x 光分类的模型，并且你已经将一个 98%准确的模型推向市场，会发生什么。也许这会杀死数百名病人，你永远不知道。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/d345c19693aaaab7d1e60cfb94799eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*RnfkW5bY15KKzjOjpCZkkA.gif"/></div></figure><p id="3d61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要担心，拿一杯热的东西。在下面的文章中，我将解释评估你的机器学习模型的整个过程。作为先决条件，您只需要知道一些基本的 Python 语法。</p><h1 id="1df6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模型评估</h1><p id="7628" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们最初将获得的全部数据分成两组，一组用于<strong class="ka ir">训练</strong>模型，另一组作为<strong class="ka ir">维持组</strong>保存，用于检查模型在完全看不见的数据下的表现。下图总结了执行拆分的整个想法。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/48be1439d2ce799efb8287c2b952d682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*pIptNvUJHFiJ_lizQsxyOw.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">A very high-level view of the model building and evaluation pipeline</figcaption></figure><p id="c8c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，训练测试比率可以是 80:20、75:25、90:10 等等。这是机器学习工程师必须根据数据量做出的决定。一个好的经验法则是使用 25%的数据集进行测试。</p><p id="dbaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用一些 Python 和开源 Sci-kit Learn API 轻松做到这一点。</p><pre class="mc md me mf gt ml mm mn mo aw mp bi"><span id="c2e0" class="mq kx iq mm b gy mr ms l mt mu">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 42, shuffle = True, stratify = y)</span></pre><p id="4697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">x 是原始的整个要素集，y 是对应的整个真实标注集。上述函数将整个集合分为训练集和测试集，测试集的比率为 0.3。参数<code class="fe mv mw mx mm b">shuffle </code>被设置为真，因此数据集将在分割前被随机打乱。参数<code class="fe mv mw mx mm b">stratify</code>是最近从<em class="lz"> v0.17、</em>添加到 Sci-kit Learn 中的，它在处理不平衡数据集时是必不可少的，例如垃圾邮件分类示例。它进行了一次分割，使得产生的样本中的值的比例与提供给参数<code class="fe mv mw mx mm b">stratify</code>的值的比例相同。<br/>例如，如果变量<code class="fe mv mw mx mm b">y</code>是具有值<code class="fe mv mw mx mm b">0</code>和<code class="fe mv mw mx mm b">1</code>的二元分类变量，并且有 10%的 0 和 90%的 1，<code class="fe mv mw mx mm b">stratify=y</code>将确保您的随机分割有 10%的<code class="fe mv mw mx mm b">0</code>和 90%的<code class="fe mv mw mx mm b">1</code></p><p id="3eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所讨论的，由于类不平衡等因素，仅仅检查测试集中有多少例子被正确分类并不是检查模型性能的有用指标。我们需要一个更强大、更细致的指标。</p><h2 id="3553" class="mq kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">混淆矩阵</h2><p id="61b6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">向混乱矩阵问好。诊断模型性能的一种简单而普遍的方法。让我们通过垃圾邮件分类的场景来理解这一点。混乱矩阵会是这样的。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/4b8b4ef6933d76b1053822fe92908fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWyKjukGGKCvrnE30763qA.png"/></div></div></figure><p id="7959" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从混淆矩阵中可以推导出几个指标，例如—</p><pre class="mc md me mf gt ml mm mn mo aw mp bi"><span id="f140" class="mq kx iq mm b gy mr ms l mt mu"><strong class="mm ir">Accuracy</strong> = (TP + TN) /(TP + TN + FP + FN)<br/><strong class="mm ir">Precision</strong> = (TP) / (TP + FP)<br/><strong class="mm ir">Recall</strong> = (TP) / (TP + FN)<br/><strong class="mm ir">F1 Score</strong> = (2 x Precision x Recall) / (Precision + Recall)</span><span id="c696" class="mq kx iq mm b gy nk ms l mt mu">—  where <strong class="mm ir"><em class="lz">TP</em></strong> is True Positive, <strong class="mm ir"><em class="lz">FN</em></strong> is False Negative and likewise for the rest.</span></pre><p id="c978" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">精确基本上是你说的所有相关的事情，而回忆是所有实际相关的事情。换句话说，召回也被称为您的模型的<strong class="ka ir">灵敏度</strong>，而精度被称为<strong class="ka ir">正预测值</strong>。这里有一张一页纸的备忘单来总结这一切。</p><p id="7d3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您已经掌握了这个概念，让我们了解如何使用 Sci-kit Learn API 和几行 Python 代码轻松地完成它。</p><pre class="mc md me mf gt ml mm mn mo aw mp bi"><span id="757b" class="mq kx iq mm b gy mr ms l mt mu">from sklearn.metrics import confusion_matrix, classification_report<br/>y_pred = model.predict (X_test)<br/>print(confusion_matrix(y_test, y_pred))<br/>print(classification_report(y_test, y_pred))</span></pre><p id="3e33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您已经使用<strong class="ka ir"> <em class="lz">准备好了模型。fit() </em> </strong>方法在训练集上(我可能改天再写)，然后使用<strong class="ka ir"> <em class="lz">计算预测的标签集。</em>预测()</strong>模型的方法。在<strong class="ka ir"> <em class="lz"> y_test </em> </strong>中有这些数组的原始标签，然后将这两个数组传递给上面的两个函数。您将得到一个二乘二的混淆矩阵(因为垃圾邮件分类是二进制分类)和一个返回所有上述指标的分类报告。</p><p id="ec7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lz">注意:真值作为第一个参数传递，预测值作为第二个参数。</em></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9f6fbd1a5af6a07090632ee50e8fce37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*WBO0R8ld1HrWvSwuTcSXkQ.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">You can pass an extra parameter to the classification report known as <strong class="bd nm">target_names. </strong><a class="ae ma" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html" rel="noopener ugc nofollow" target="_blank">Refer the docs</a>.</figcaption></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="5af0" class="kw kx iq bd ky kz nu lb lc ld nv lf lg lh nw lj lk ll nx ln lo lp ny lr ls lt bi translated">交互效度分析</h1><blockquote class="nz"><p id="b0d8" class="oa ob iq bd oc od oe of og oh oi kv dk translated">交叉验证是一种评估统计分析如何推广到独立数据集的技术。它是一种评估机器学习模型的技术，通过在可用输入数据的子集上训练几个模型，并在数据的互补子集上评估它们。使用交叉验证，我们很有可能轻松检测到过度拟合。</p></blockquote><pre class="oj ok ol om on ml mm mn mo aw mp bi"><span id="ffbe" class="mq kx iq mm b gy mr ms l mt mu">There are several <strong class="mm ir">cross</strong> <strong class="mm ir">validation techniques</strong> such as :-</span><span id="1bbf" class="mq kx iq mm b gy nk ms l mt mu">1. K-Fold Cross Validation<br/>2. Leave P-out Cross Validation<br/>3. Leave One-out Cross Validation<br/>4. Repeated Random Sub-sampling Method<br/>5. Holdout Method</span></pre><p id="aa64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将讨论其中最流行的方法，即 K 折交叉验证。其他的也很有效，但是不常用。</p><p id="0410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们花点时间问问自己，为什么我们需要交叉验证— <br/>我们已经将数据集分成了训练集和测试集(或维持集)。但是，准确性和指标在很大程度上取决于分割是如何执行的，这取决于数据集是否被打乱，哪一部分被用于训练和测试，多少，等等。此外，它并不代表模型的概括能力。这导致我们交叉验证。</p><h2 id="5e95" class="mq kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">k 倍交叉验证</h2><p id="1ef8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，我要向您介绍一条黄金法则— <em class="lz">“永远不要混淆训练和测试数据”</em>。您的第一步应该始终是<strong class="ka ir">隔离测试数据集</strong>，并仅将其用于最终评估。因此，将在训练集上执行交叉验证。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/bd618c56976e5ed035adf8c726fb9299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrUDb8PMbnQ5nGBkxuIEYA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">5 Fold Cross-Validation</figcaption></figure><p id="2051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初，整个训练数据集被分成<em class="lz"> k </em>个相等的部分。第一部分保留作为支持(测试)组，剩余的<em class="lz"> k-1 </em>部分用于训练模型。然后，在维持集上测试已训练的模型。上述过程重复 k 次，每次我们都不断改变维持组。因此，每个数据点都有同等的机会被包含在测试集中。</p><p id="b3b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，k 等于 3 或 5。它甚至可以扩展到更高的值，如 10 或 15，但它在计算上变得极其昂贵和耗时。让我们看看如何用几行 Python 代码和 Sci-kit Learn API 实现这一点。</p><pre class="mc md me mf gt ml mm mn mo aw mp bi"><span id="c2df" class="mq kx iq mm b gy mr ms l mt mu">from sklearn.model_selection import cross_val_score<br/>print(cross_val_score(model, X_train, y_train, cv=5))</span></pre><p id="5757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们传递<strong class="ka ir">模型</strong>或分类器对象、特征、标签和参数<strong class="ka ir"> cv </strong>，其指示用于 K-Fold 交叉验证的<strong class="ka ir"> K </strong>。该方法将为每次迭代返回 k 个精度值的列表。一般来说，我们取它们的平均值，并将其用作合并的交叉验证分数。</p><pre class="mc md me mf gt ml mm mn mo aw mp bi"><span id="def4" class="mq kx iq mm b gy mr ms l mt mu">import numpy as np<br/>print(np.mean(cross_val_score(model, X_train, y_train, cv=5)))</span></pre><p id="964f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管交叉验证在计算上可能很昂贵，但它对于评估学习模型的性能是必不可少的。</p><p id="1fc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随意查看我在本文末尾的参考资料部分中包含的其他交叉验证分数评估方法。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="1865" class="kw kx iq bd ky kz nu lb lc ld nv lf lg lh nw lj lk ll nx ln lo lp ny lr ls lt bi translated">结论</h1><p id="1e75" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">机器学习模型的准确性要求因行业、领域、需求和问题陈述而异。但是，在没有评估所有基本指标的情况下，不应该确认最终模型。</p><p id="791d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，一旦你完成了评估并最终确认了你的机器学习模型，你应该重新使用最初仅为测试目的而隔离的测试数据，并用你拥有的完整数据训练你的模型，以便增加更好预测的机会。</p><p id="1c1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。这是一个高层次的主题概述，我试图尽最大努力以一种简单的方式解释手头的概念。请随时对文章进行评论、批评并提出改进建议。还有，掌声鼓励我多写！敬请关注更多文章。</p><p id="631c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ma" rel="noopener" target="_blank" href="/handwritten-digit-mnist-pytorch-977b5338e627">用 PyTorch   </a>看看这个<strong class="ka ir"> <em class="lz">友好的神经网络入门。</em></strong></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="f3a2" class="mq kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">参考</h2><p id="18e1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">[1] <a class="ae ma" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)#Leave-p-out_cross-validation" rel="noopener ugc nofollow" target="_blank"> <em class="lz">留单交叉验证</em></a><em class="lz"><br/></em>【2】<a class="ae ma" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)#Leave-one-out_cross-validation" rel="noopener ugc nofollow" target="_blank"><em class="lz">留单交叉验证</em></a><em class="lz"><br/></em>【3】<a class="ae ma" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)#Repeated_random_sub-sampling_validation" rel="noopener ugc nofollow" target="_blank"><em class="lz">重复随机子抽样方法</em></a><em class="lz"><br/></em>【4】<a class="ae ma" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)#Holdout_method" rel="noopener ugc nofollow" target="_blank"><em class="lz">维持方法</em></a><em class="lz"><br/></em>【5】<a class="ae ma" href="https://www.cs.cmu.edu/~schneide/tut5/node42.html" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a></p></div></div>    
</body>
</html>