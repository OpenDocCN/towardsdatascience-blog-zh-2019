<html>
<head>
<title>Canny Edge Detection Step by Step in Python — Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的谨慎边缘检测——计算机视觉</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/canny-edge-detection-step-by-step-in-python-computer-vision-b49c3a2d8123?source=collection_archive---------0-----------------------#2019-01-25">https://towardsdatascience.com/canny-edge-detection-step-by-step-in-python-computer-vision-b49c3a2d8123?source=collection_archive---------0-----------------------#2019-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="b498" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi ks translated">当谈到图像分类时，人眼具有在几毫秒内处理图像并确定其内容(标签)的惊人能力。太神奇了，不管是画图还是画图，它都能做到。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d2d5a817a581c5443da90964362a4020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTzWlyYyoU0eLFC0gMykUg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Drawing of a car (Left) — Real car picture (Right): The human eye is able to classify both.</figcaption></figure><p id="32af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">今天的想法是建立一种算法，可以使用 Canny 边缘检测算法绘制出图片上任何对象的边缘。</p><p id="7810" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们来描述一下什么是 Canny 边缘检测器:</p><blockquote class="lr ls lt"><p id="be90" class="ju jv lu jw b jx jy jz ka kb kc kd ke lv kg kh ki lw kk kl km lx ko kp kq kr ij bi translated"><strong class="jw ir"> Canny 边缘检测器</strong>是一个<a class="ae ly" href="https://en.wikipedia.org/wiki/Edge_detection" rel="noopener ugc nofollow" target="_blank">边缘检测</a>算子，它使用多阶段<a class="ae ly" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>来检测图像中的各种边缘。它是由约翰·f·坎尼于 1986 年发明的。Canny 还提出了边缘检测的计算理论，解释了这项技术的工作原理。(维基百科)</p></blockquote><p id="3128" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Canny 边缘检测算法由 5 个步骤组成:</p><ol class=""><li id="809a" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">降噪；</li><li id="c8a9" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">梯度计算；</li><li id="61d5" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">非最大抑制；</li><li id="ce9a" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">双门槛；</li><li id="9551" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">滞后边缘跟踪。</li></ol><p id="3f07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">应用这些步骤后，您将能够获得以下结果:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/d883dc81e9c4b0f90e5b3fb3974d62c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*XAgKINgc2c2gNa2nV3zbNQ.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Original image on the left — Processed image on the right</figcaption></figure><p id="5de4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后要提到的重要一点是，该算法是基于灰度图片的。因此，先决条件是在执行上述步骤之前将图像转换为灰度。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="8c8f" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">噪声降低</h1><p id="3943" class="pw-post-body-paragraph ju jv iq jw b jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr ij bi translated">由于场景背后涉及的数学主要基于导数(参见步骤 2:梯度计算)，边缘检测结果对图像噪声高度敏感。</p><p id="cf9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">去除图像上的噪声的一种方法是应用高斯模糊来平滑它。为此，图像卷积技术应用于高斯核(3x3、5x5、7x7 等)。内核大小取决于预期的模糊效果。基本上，内核越小，模糊越不明显。在我们的例子中，我们将使用一个 5 乘 5 高斯核。</p><p id="2e69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大小为(2<em class="lu">k</em>+1)×(2<em class="lu">k</em>+1)的高斯滤波器内核的等式由下式给出:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/84762b6cc8a77552ae808f22539ea8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*YpLYVBomcYNNbwncG5iP9Q.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Gaussian filter kernel equation</figcaption></figure><p id="e722" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">生成高斯 5x5 内核的 Python 代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Gaussian Kernel function</figcaption></figure><p id="302f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">应用高斯模糊后，我们得到以下结果:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d9590c4e5438f07ba3cca3d94695f12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*-P1q_Io0i1kElOw4q3GAzw.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Original image (left) — Blurred image with a Gaussian filter (sigma=1.4 and kernel size of 5x5)</figcaption></figure><h1 id="28e8" class="mo mp iq bd mq mr nv mt mu mv nw mx my mz nx nb nc nd ny nf ng nh nz nj nk nl bi translated">梯度计算</h1><p id="419c" class="pw-post-body-paragraph ju jv iq jw b jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr ij bi translated">梯度计算步骤通过使用边缘检测算子计算图像的梯度来检测边缘强度和方向。</p><p id="ea6d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">边缘对应于像素强度的变化。要检测它，最简单的方法是应用在两个方向上突出这种强度变化的过滤器:水平(x)和垂直(y)</p><p id="c707" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当图像平滑后，计算导数<strong class="jw ir"> <em class="lu"> Ix </em> </strong>和<strong class="jw ir"><em class="lu">Iy</em></strong>w . r . t .<strong class="jw ir"><em class="lu">x</em></strong>和<strong class="jw ir"> <em class="lu"> y </em> </strong>。可以通过将<strong class="jw ir"> <em class="lu"> I </em> </strong>分别与索贝尔核<strong class="jw ir"> <em class="lu"> Kx </em> </strong>和<strong class="jw ir"> <em class="lu"> Ky </em> </strong>进行卷积来实现:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1994e182abed2a2f4f80c8bed40959fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*r5Y22pLJjDMl19tcqXseZQ.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Sobel filters for both direction (horizontal and vertical)</figcaption></figure><p id="c97d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，梯度的幅度<strong class="jw ir"> <em class="lu"> G </em> </strong>和斜率<strong class="jw ir"> <em class="lu"> θ </em> </strong>计算如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/99e01fc662bbb1b12b11a1840c48577e.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*HmperNZ1AXXNONDbrsJNAg.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Gradient intensity and Edge direction</figcaption></figure><p id="d8a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是 Sobel 滤波器如何应用于图像，以及如何获得强度和边缘方向矩阵:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5e0b76d866151fcf1d2147cd08ac09b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*ZCyKWsmDoj6V-dNwKlKxyA.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Blurred image (left) — Gradient intensity (right)</figcaption></figure><p id="8fd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果和预想的差不多，但是我们可以看到有的边比较厚，有的边比较薄。非最大抑制步骤将帮助我们减轻厚的。</p><p id="171e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，梯度强度水平在 0 和 255 之间，这是不均匀的。最终结果上的边缘应该具有相同的强度(即白色像素= 255)。</p><h1 id="2a23" class="mo mp iq bd mq mr nv mt mu mv nw mx my mz nx nb nc nd ny nf ng nh nz nj nk nl bi translated">非最大抑制</h1><p id="576a" class="pw-post-body-paragraph ju jv iq jw b jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr ij bi translated">理想情况下，最终图像的边缘应该很细。因此，我们必须执行非最大值抑制来细化边缘。</p><p id="0a50" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">原理很简单:该算法遍历梯度强度矩阵上的所有点，找到边缘方向上具有最大值的像素。</p><p id="dece" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们举一个简单的例子:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9780bf15bb72d630eb2b3196289bfd11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*CWrXNSbe7s4qSFr5vylyvQ.png"/></div></figure><p id="f40d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上图左上角的红框代表正在处理的梯度强度矩阵的强度像素。相应的边方向由角度为-π弧度(+/-180 度)的橙色箭头表示。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c50216037c9608af25c69b69155af009.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*K-gnZg4_VPk57Xs0XflIrg.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Focus on the upper left corner red box pixel</figcaption></figure><p id="1929" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">边缘方向是橙色虚线(从左到右水平)。该算法的目的是检查相同方向上的像素是否比正在处理的像素更强或更弱。上例中，正在处理的是像素<strong class="jw ir"> <em class="lu"> (i，j) </em> </strong>，同一方向的像素用蓝色突出显示<strong class="jw ir"> <em class="lu"> (i，j-1)</em></strong><strong class="jw ir"><em class="lu">(I，j+1)。</em> </strong>如果这两个像素中的一个比正在处理的像素更强烈，那么只保留更强烈的一个。像素<strong class="jw ir"> <em class="lu"> (i，j-1) </em> </strong>似乎更强烈，因为是白色(值 255)。因此，当前像素<strong class="jw ir"> <em class="lu"> (i，j) </em> </strong>的亮度值被设置为 0。如果在边缘方向上没有像素具有更强的值，则保持当前像素的值。</p><p id="6ca1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们关注另一个例子:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2cf0100e2595a68f311974249e39f818.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*QjoPwEgQ6NOynOwxc4847A.png"/></div></figure><p id="8893" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，方向是橙色虚线对角线。所以这个方向最强烈的像素就是像素<strong class="jw ir"> <em class="lu"> (i-1，j+1)。</em>T59】</strong></p><p id="f09b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们总结一下。每个像素有两个主要标准(以弧度表示的边缘方向和像素强度(0-255 之间))。基于这些输入，非最大抑制步骤为:</p><ul class=""><li id="3760" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr of mf mg mh bi translated">创建与原始梯度强度矩阵大小相同的初始化为 0 的矩阵；</li><li id="e459" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">基于来自角度矩阵的角度值识别边缘方向；</li><li id="dc5d" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">检查相同方向上的像素是否比当前处理的像素具有更高的亮度；</li><li id="1491" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">返回用非最大值抑制算法处理的图像。</li></ul><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c574" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果是相同的图像具有更薄的边缘。然而，我们仍然可以注意到一些关于边缘强度的变化:一些像素似乎比其他像素更亮，我们将尝试用最后两个步骤来弥补这个缺点。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi og"><img src="../Images/389e75f9a4082ca894f3a3c5dff7f141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*LmBYILsRp_KlVpNweqHh0g.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Result of the non-max suppression.</figcaption></figure><h1 id="3b53" class="mo mp iq bd mq mr nv mt mu mv nw mx my mz nx nb nc nd ny nf ng nh nz nj nk nl bi translated">双阈值</h1><p id="f08f" class="pw-post-body-paragraph ju jv iq jw b jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr ij bi translated">双阈值步骤旨在识别 3 种像素:强、弱和不相关:</p><ul class=""><li id="7bcd" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr of mf mg mh bi translated">强像素是具有如此高强度的像素，以至于我们确信它们对最终边缘有贡献。</li><li id="9390" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">弱像素是强度值不足以被认为是强像素，但又不足以被认为与边缘检测无关的像素。</li><li id="052f" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">其他像素被认为与边缘不相关。</li></ul><p id="ee07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在您可以看到双阈值的含义了:</p><ul class=""><li id="94af" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr of mf mg mh bi translated">高阈值用于识别强像素(强度高于高阈值)</li><li id="dd1f" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">低阈值用于识别不相关的像素(强度低于低阈值)</li><li id="5916" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">强度在两个阈值之间的所有像素都被标记为弱，滞后机制(下一步)将帮助我们识别哪些像素可以被认为是强的，哪些像素被认为是不相关的。</li></ul><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4f0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该步骤的结果是只有 2 个像素强度值(强和弱)的图像:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d321f00be0614f7c16a8d53c5d88746c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*FF6b8FJ2oppREoh9T-hdfA.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Non-Max Suppression image (left) — Threshold result (right): weak pixels in gray and strong ones in white.</figcaption></figure><h1 id="23ef" class="mo mp iq bd mq mr nv mt mu mv nw mx my mz nx nb nc nd ny nf ng nh nz nj nk nl bi translated">滞后边缘跟踪</h1><p id="0041" class="pw-post-body-paragraph ju jv iq jw b jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr ij bi translated">基于阈值结果，滞后包括当且仅当正被处理的像素周围的至少一个像素是强像素时，将弱像素变换为强像素，如下所述:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/df7e42845ec3045952005eb6c31f112d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*jnqS5hbRwAmU-sgK552Mgg.png"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Hysteresis function</figcaption></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oj"><img src="../Images/9bc8b7271092f3b44a6064f132cb8b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pStG0ObTAddm46mdHxY5zA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Results of hysteresis process</figcaption></figure><p id="284b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用的所有代码都可以在下面的 Git 存储库中找到</p><div class="ok ol gp gr om on"><a href="https://github.com/FienSoP/canny_edge_detector" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">FienSoP/canny_edge_detector</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">Canny 边缘检测器库。在 GitHub 上创建一个帐户，为 FienSoP/canny_edge_detector 的开发做出贡献。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ll on"/></div></div></a></div></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h2 id="59a8" class="pc mp iq bd mq pd pe dn mu pf pg dp my kf ph pi nc kj pj pk ng kn pl pm nk pn bi translated">文献学</h2><ul class=""><li id="5726" class="lz ma iq jw b jx nm kb nn kf po kj pp kn pq kr of mf mg mh bi translated"><a class="ae ly" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank">https://opencv-python-tutro als . readthedocs . io/en/latest/py _ tutorials/py _ imgproc/py _ canny/py _ canny . html</a></li><li id="d9ee" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">https://homepages.inf.ed.ac.uk/rbf/HIPR2/canny.htm<a class="ae ly" href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/canny.htm" rel="noopener ugc nofollow" target="_blank"/></li><li id="6785" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated">【http://justin-liang.com/tutorials/canny/ T4】</li><li id="220f" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr of mf mg mh bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Canny_edge_detector" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Canny_edge_detector</a></li></ul></div></div>    
</body>
</html>