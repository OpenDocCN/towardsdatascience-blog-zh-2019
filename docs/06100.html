<html>
<head>
<title>Find Face Edges in 20 Lines of Code From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始在 20 行代码中查找人脸边缘</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-face-edges-in-20-lines-of-code-from-scratch-8058e128c013?source=collection_archive---------23-----------------------#2019-09-04">https://towardsdatascience.com/find-face-edges-in-20-lines-of-code-from-scratch-8058e128c013?source=collection_archive---------23-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8bcd0281f2fd6de7b33ece14cba4882a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*iBJnmfVPVP-c9bMU1tTnlA.jpeg"/></div></figure><p id="f56f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我在读一本机器学习的书，了解到边缘是机器学习图片中是否有物体(在这种情况下是人脸)的重要特征输入。看左边只有边缘的图形，人眼很容易分辨出是一张脸，不是吗？这同样有助于机器。</p><p id="ccc7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最初我认为寻找边缘本身需要一些“人工智能”。但我记得 Python PIL 库有 find_edges 过滤器，这绝对不是机器学习功能。然后，我开始思考如何找到边缘，并最终找到了一个非常简单的方法，只需要从头开始构建大约 20 行 Python 代码。</p><h1 id="4400" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">逻辑</h1><p id="d6d4" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我的逻辑很简单如下。</p><ul class=""><li id="84ee" class="ly lz it jz b ka kb ke kf ki ma km mb kq mc ku md me mf mg bi translated">从上到下，从左到右扫描所有像素</li><li id="3ac6" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated">如果像素与右侧或底部的相邻像素非常不同，则将其标记为边缘。</li></ul><h1 id="ffbd" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">履行</h1><p id="d59c" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我用 Python 代码实现了这一点，但是算法本身是独立于语言的。</p><p id="9af4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是我们需要的库:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c71a" class="mv kw it mr b gy mw mx l my mz">from PIL import Image<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import math</span></pre><p id="6243" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你是 Python 新手，先安装<a class="ae na" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python3 </a>，然后用 pip 安装需要的库。</p><p id="e1a1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe nb nc nd mr b">pip install -U Pillow numpy matplotlib</code></p><p id="6529" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，我们将图像读取为像素的 2D 阵列。每个像素是 3 个值[红、绿、蓝]的阵列，每个颜色值是 0 到 255，例如像素值[0，0，0]是黑色。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6254" class="mv kw it mr b gy mw mx l my mz">filename = 'old.jpg'<br/>im = Image.open(filename)<br/>im_array = np.asarray(im)</span></pre><p id="b3c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果图像太大，您可以先调整其大小。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="77d4" class="mv kw it mr b gy mw mx l my mz">n = 2 # resize times<br/>im = im.resize( (int(im.size[0]/n), int(im.size[1]/n)) )</span></pre><p id="6f3d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">其次，我们定义一个函数来度量两个像素之间的差异。我使用三个颜色值之间的均方差的平方根，就像均方根偏差(<a class="ae na" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation" rel="noopener ugc nofollow" target="_blank"> RMSD </a>)。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/92407eef418cac91bf97f1b5cd4d563a.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*m57bSYMBZNLDf-8AVISChg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">difference between pixel a and b</figcaption></figure><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="809a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，黑色像素 A 为[0，0，0]，白色像素 B 为[255，255，255]，因此 A 和 B 的平方根差为:</p><p id="689e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe nb nc nd mr b">sqrt(([255–0]**2 + [255–0]**2 + [255–0]**2)/3) = sqrt(255**2) = 255</code>。</p><p id="a8b2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注:x**2 表示 x*x。</p><p id="376a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里有一个窍门。我们需要首先将像素值转换为 int 类型，即<code class="fe nb nc nd mr b">int(a[i])</code>，以进行减法运算，因为像素值为 ubyte[0–255]，减法运算可能会变为负值，从而导致类型溢出问题。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="2463" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们从上到下，从左到右迭代图像数组。如果像素与其右侧或底部相邻像素之间的平方根差大于预定义的阈值，则将其标记为边缘像素，并将其设置为黑色[0，0，0]，否则将其设置为白色[255，255，255]作为背景。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">main part</figcaption></figure><p id="b737" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以微调图像的阈值<code class="fe nb nc nd mr b">diff_threshold</code>。10 是我用来创建顶部图像的值。增加较少边的阈值。例如，通过增加到 20，我得到了一个新的图像如下。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f9a1c29fb201ad39c627b818cfb8dd17.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*UUBBCjTduRCz3523S7-RIg.jpeg"/></div></figure><p id="3ce3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，使用 matplotlib 将新的边缘图像保存到本地。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="f2f3" class="mv kw it mr b gy mw mx l my mz">plt.imshow(new_array)<br/>plt.savefig('new.jpg')</span></pre><p id="c177" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您想在弹出窗口中显示新图像，请使用下面的代码。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8336" class="mv kw it mr b gy mw mx l my mz">plt.imshow(new_array)<br/>plt.show()</span></pre><p id="41d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以在这里找到组合的完整代码<a class="ae na" href="https://gist.github.com/peterjpxie/01595d4beb04e39ed97e6937d4424e7f" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f0e6" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">笔记</h1><p id="644d" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">请注意，这种算法不是专门针对人脸检测的。它可以找到所有图像的边缘。你自己试试。</p><p id="0c18" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">感谢阅读。如有任何疑问，您可以通过<a class="ae na" href="http://linkedin.com/in/xiejiping" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。</p></div></div>    
</body>
</html>