<html>
<head>
<title>ARIMA Forecasting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的 ARIMA 预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/arima-forecasting-in-python-90d36c2246d3?source=collection_archive---------5-----------------------#2019-10-13">https://towardsdatascience.com/arima-forecasting-in-python-90d36c2246d3?source=collection_archive---------5-----------------------#2019-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f7c4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">把手放在某物或者某人身上</h2><div class=""/><div class=""><h2 id="cc2c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">手动和自动 ARIMA 快速启动和运行，包括对两者的简要讨论。</h2></div><p id="99a6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将把每周的 Spotify 全球 200 强榜单作为一个时间序列，用来试验 ARIMA 模式。<a class="ae ln" href="https://raw.githubusercontent.com/deinal/predict-spotify-top-global/master/data/top_200_features.csv" rel="noopener ugc nofollow" target="_blank">数据</a>范围从 2017 年到 2019 年，整个 jupyter 笔记本在<a class="ae ln" href="https://colab.research.google.com/drive/1oh3GcHKUJjcAhcvElPlI5iaH7PX-eCcP" rel="noopener ugc nofollow" target="_blank">这里</a>都有。</p><p id="ba46" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">以下是我们进行预测的数据子集:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6542" class="lx ly it lt b gy lz ma l mb mc">feature_mean.head()</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/19499412b081aa56ed6486126b3ca4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*H8RPXzpZtFd9L1vcgISt4Q.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">Spotify weekly top 200 audio features</figcaption></figure><p id="ac73" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">ARIMA 代表自回归综合移动平均线，它取决于三个关键变量<em class="ml"> p </em>、<em class="ml"> d </em>、<em class="ml"> q </em>才能成功。简要如下:</p><p id="6129" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ml"> p </em> =滞后次数/AR 项顺序</p><p id="10d4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ml"> d </em> =差分顺序</p><p id="fb86" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ml"> q </em> =滞后预测误差数/MA 条款顺序</p><p id="d85b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">米什拉写了更多关于 ARIMA 模型内部工作原理的文章，包括参数。我在这里的目标是解释如何手动和自动地在 Python 中快速启动和运行 ARIMA。我将对<em class="ml">声音</em>特征进行预测:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d5af" class="lx ly it lt b gy lz ma l mb mc">timeseries = feature_mean["acousticness"]</span></pre><p id="9fbc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们使用扩展的 Dickey Fuller (ADF)检验来看看时间序列是否是平稳的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ff60" class="lx ly it lt b gy lz ma l mb mc">from statsmodels.tsa.stattools import adfuller</span><span id="0713" class="lx ly it lt b gy mm ma l mb mc">print("p-value:", adfuller(timeseries.dropna())[1])</span></pre><p id="343a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">p 值:0.43</p><p id="da7d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">p 值大于显著性水平 0.05，因此它不是静态的，需要进行差分，即。<em class="ml">d</em>T42 0。</p><p id="8ada" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们首先使用自相关函数找出差分的阶数<em class="ml"> d </em>:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7ded" class="lx ly it lt b gy lz ma l mb mc">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf</span><span id="bd76" class="lx ly it lt b gy mm ma l mb mc">fig = plt.figure(figsize=(10, 10))</span><span id="1ebc" class="lx ly it lt b gy mm ma l mb mc">ax1 = fig.add_subplot(311)<br/>fig = plot_acf(timeseries, ax=ax1,<br/>               title="Autocorrelation on Original Series") <br/>ax2 = fig.add_subplot(312)<br/>fig = plot_acf(timeseries.diff().dropna(), ax=ax2, <br/>               title="1st Order Differencing")<br/>ax3 = fig.add_subplot(313)<br/>fig = plot_acf(timeseries.diff().diff().dropna(), ax=ax3, <br/>               title="2nd Order Differencing")</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/99233036533b9a3effc6770e354b40a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*5wDJkR78ywNn_ww9c-ZrLA.png"/></div></figure><p id="658b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">时间序列在<strong class="kt jd"><em class="ml">d = 1</em></strong><em class="ml"/>处静止，只有第一个滞后高于显著性水平。如果你的数列略有差异，试着增加一个额外的 AR 项，如果略有差异，也许增加一个额外的 MA 项。</p><p id="7c4d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">知道我们应该差一次，我们继续找出 AR，<em class="ml"> p </em>的顺序。我们通过计算偏自相关中显著性水平以上的滞后数来得到它:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ef49" class="lx ly it lt b gy lz ma l mb mc">plot_pacf(timeseries.diff().dropna(), lags=40)</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/0f12ed8bbbffcd3fa8f083e51b683560.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*lVjnOhlzqkS-CWcivEIVAQ.png"/></div></figure><p id="fdcf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第一个滞后是唯一一个大大高于有效电平的滞后，因此<strong class="kt jd"> <em class="ml"> p = 1 </em> </strong>。</p><p id="5a56" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">自相关函数可以告知移除平稳序列中的自相关所需的 MA 项<em class="ml"> q </em>的顺序。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="639e" class="lx ly it lt b gy lz ma l mb mc">plot_acf(timeseries.diff().dropna())</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/d08cb447fc95a0f25496de433df04540.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*-p8bY9v_OL61WomO0qdzkA.png"/></div></figure><p id="5dee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在显著性水平之上可以发现一个滞后，因此<em class="ml"/><strong class="kt jd"><em class="ml">q = 1</em></strong>。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6257" class="lx ly it lt b gy lz ma l mb mc">from statsmodels.tsa.arima_model import ARIMA</span><span id="2cde" class="lx ly it lt b gy mm ma l mb mc">model = ARIMA(timeseries, order=(1, 1, 1))<br/>results = model.fit()<br/>results.plot_predict(1, 210)</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d7b0a06b92540256abc2242477c431d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Wvn0VPf-SZp6C32PQu_LFQ.png"/></div></figure><p id="e993" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Akaike 信息标准(AIC)估计给定模型丢失的相对信息量。越少越好。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="eb14" class="lx ly it lt b gy lz ma l mb mc">results.summary()</span></pre><p id="2374" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">模型:ARIMA(1，1，1)，…，AIC: -806.848 …</p><p id="6b73" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们把它放在脑后，继续测试<a class="ae ln" href="http://www.alkaline-ml.com/pmdarima/1.0.0/modules/generated/pmdarima.arima.auto_arima.html" rel="noopener ugc nofollow" target="_blank"> auto_arima </a>:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1fba" class="lx ly it lt b gy lz ma l mb mc">import pmdarima as pm</span></pre><p id="7506" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">创建模型:自动 ARIMA 使用 ADF 来测试平稳性，p 和 q 的起始值被设置为 1，并且 Spotify 数据不被假定为季节性的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="fda8" class="lx ly it lt b gy lz ma l mb mc">def arimamodel(timeseries):<br/>    automodel = pm.auto_arima(timeseries, <br/>                              start_p=1, <br/>                              start_q=1,<br/>                              test="adf",<br/>                              seasonal=False,<br/>                              trace=True)<br/>    return automodel</span></pre><p id="61e1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们希望像使用 statsmodel 的<a class="ae ln" href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.arima_model.ARMAResults.plot_predict.html" rel="noopener ugc nofollow" target="_blank"> plot_predict </a>一样简洁地绘制它，因此必须填充预测上限和下限之间的区域。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a501" class="lx ly it lt b gy lz ma l mb mc">def plotarima(n_periods, timeseries, automodel):<br/>    # Forecast<br/>    fc, confint = automodel.predict(n_periods=n_periods, <br/>                                    return_conf_int=True)<br/>    # Weekly index<br/>    fc_ind = pd.date_range(timeseries.index[timeseries.shape[0]-1], <br/>                           periods=n_periods, freq="W")<br/>    # Forecast series<br/>    fc_series = pd.Series(fc, index=fc_ind)</span><span id="b828" class="lx ly it lt b gy mm ma l mb mc">    # Upper and lower confidence bounds<br/>    lower_series = pd.Series(confint[:, 0], index=fc_ind)<br/>    upper_series = pd.Series(confint[:, 1], index=fc_ind)</span><span id="78a3" class="lx ly it lt b gy mm ma l mb mc">    # Create plot<br/>    plt.figure(figsize=(10, 6))<br/>    plt.plot(timeseries)<br/>    plt.plot(fc_series, color="red")<br/>    plt.xlabel("date")<br/>    plt.ylabel(timeseries.name)<br/>    plt.fill_between(lower_series.index, <br/>                     lower_series, <br/>                     upper_series, <br/>                     color="k", <br/>                     alpha=0.25)<br/>    plt.legend(("past", "forecast", "95% confidence interval"),  <br/>               loc="upper left")<br/>    plt.show()</span></pre><p id="180c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后我们就有了拟合和绘制模型所需的所有内容:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="78a9" class="lx ly it lt b gy lz ma l mb mc">automodel = arimamodel(feature_mean["danceability"])<br/>plotarima(70, feature_mean["acousticness"], automodel)</span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/97c0a9df542dfc297329e64e279f1921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*MkjZDnaE72skGaJ3yCRsqw.png"/></div></figure><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7555" class="lx ly it lt b gy lz ma l mb mc">automodel.summary()</span></pre><p id="16be" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">模型:ARIMA(1，1，1)，…，AIC: -806.848 …</p><p id="a8a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这与我们手动得到的参数化结果完全相同。哇，效果很好！使用 auto_arima 获得正确的参数要容易得多，也快得多，唯一的缺点是必须从头开始绘制，以便看起来和 statsmodels 内置的一样好。</p><p id="7b3c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">MachineLearning+网站上关于 ARIMA 模式的精疲力尽的指南功不可没。哦，你也可以试着用前面提到的<a class="ae ln" href="https://colab.research.google.com/drive/1oh3GcHKUJjcAhcvElPlI5iaH7PX-eCcP" rel="noopener ugc nofollow" target="_blank">笔记本</a>把<em class="ml">的声音</em>改成别的，比如<em class="ml">的舞蹈</em>。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="ece8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[1]:米什拉(M. Mishra)，拆箱 ARIMA 模型(2018 年 6 月 11 日)，<a class="ae ln" rel="noopener" target="_blank" href="/unboxing-arima-models-1dc09d2746f8">https://towardsdatascience . com/Unboxing-ARIMA-Models-1 DC 09d 2746 f 8</a></p><p id="67f0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[2]: ARIMA 模型—Python 中时间序列预测完全指南，<a class="ae ln" href="https://www.machinelearningplus.com/time-series/arima-model-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank">https://www . machine learning plus . com/Time-Series/ARIMA-Model-Time-Series-Forecasting-Python/</a></p></div></div>    
</body>
</html>