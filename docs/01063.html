<html>
<head>
<title>Cleaner R Code with Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有函数式编程的 Cleaner R 代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cleaner-r-code-with-functional-programming-adc37931ef7a?source=collection_archive---------3-----------------------#2019-02-19">https://towardsdatascience.com/cleaner-r-code-with-functional-programming-adc37931ef7a?source=collection_archive---------3-----------------------#2019-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="94ae" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="ef97" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">由于工作转换，我最近成为了一名 R-to-Python 的转换者。然而，一些兼职项目让我每天在两种语言之间切换。除了让我感到头疼之外，这种日常的反复让我对编程范例有了很多思考。具体来说，我真的成了 r 中函数式编程范式的传播者。我想就什么是函数式编程(FP)以及它如何给你带来超能力(某种程度上)给出一点见解。</p><h1 id="0e81" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">为什么重要？</h1><p id="51fe" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">r 在编程世界中有着独特的地位。全世界每天都有成千上万的人使用它来分析和处理数据。它的用户很少受过纯计算机科学的训练，而且在许多情况下，R 代码只运行一次。这种组合会导致 R 程序变得草率和低效。我们是怎么到这里的？推理通常是:如果它有效，它就有效，对吗？</p><p id="ddfb" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">如果这个“为什么改变？”心态听起来很熟悉，这篇博文是写给你的。事实上，r 是一种受丰富的数学理论影响的完整的(尽管是特定领域的)编程语言。学习 FP 的基础知识将帮助你写出更好的代码，从而使你成为一名更好的统计学家、数据科学家，或者当你读到这篇文章时，我们已经决定称自己为什么。</p><h1 id="34fb" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">什么是函数式编程？</h1><p id="1a1d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我不打算给出一个严格的定义。你可以去维基百科了解一下。</p><p id="86e1" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">简单来说，FP 就是它听起来的样子。如果你不止一次地做某件事，它属于一个函数。在 FP 中，函数是你执行任务的主要方法。所有的动作都只是(通常是创造性的)你所写的函数的实现。</p><p id="172b" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">一旦你进入其中，优势就显而易见了。您的代码更容易修复和维护，因为您已经将代码分割成易于维护的部分。您的代码更容易阅读，因为如果您正确命名了所有内容，您的代码看起来就更接近普通英语。用函数调用代替长代码块也可以帮助你减少<a class="ae ma" href="https://en.wikipedia.org/wiki/Spaghetti_code" rel="noopener ugc nofollow" target="_blank">面条</a>和<a class="ae ma" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noopener ugc nofollow" target="_blank">末日金字塔代码</a>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/71a00e8570b830bc09dd26b139172282.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*cX4jAzZ9z7PskLwl4kDf9Q.jpeg"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk">Most bad code is not this delicious</figcaption></figure><p id="d7ef" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">好吧，我们怎样才能重新训练我们的大脑来适应这种甜蜜的 FP 呢？</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="4d0c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第 0 步:学习基础知识</h1><p id="6ffc" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">要想写出真正“功能性”的函数，必须是<strong class="ku ir"> <em class="mn">纯</em> </strong>。一个纯函数有两条规则:</p><ul class=""><li id="fafa" class="mo mp iq ku b kv lv kz lw ld mq lh mr ll ms lp mt mu mv mw bi translated"><strong class="ku ir">它必须是确定性的</strong> <br/>也就是说，每次你用相同的输入运行这个函数，它必须有相同的输出。每一个。单身。时间。"但是有随机成分的函数和统计过程呢？"你问？只需在函数内部设置一个种子，或者让种子成为函数的参数。无论如何，这对可再生科学很重要。</li><li id="73e6" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">这意味着你的功能不能触及或改变它之外的任何东西。这意味着你可能永远不应该使用全局赋值(<code class="fe nc nd ne nf b">&lt;&lt;-</code>)操作符。奇怪的是，这也意味着<code class="fe nc nd ne nf b">print()</code>函数不服从 FP。</li></ul><h1 id="016f" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">第一步:抛弃循环</h1><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/97cf1df3f4259cf99e963293adbbf4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*JF2BsC3oPzm0Qhj-Dsw-nQ.jpeg"/></div></figure><p id="7e86" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">正如我的研究生导师曾经告诉我的，</p><blockquote class="nh ni nj"><p id="76f9" class="ks kt mn ku b kv lv kx ky kz lw lb lc nk lx lf lg nl ly lj lk nm lz ln lo lp ij bi translated">如果你在 R 中写循环，你可能做错了。</p></blockquote><p id="e0b9" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">(当然，他是在调试我的第三层嵌套<code class="fe nc nd ne nf b">for</code>循环时告诉我的。)</p><p id="febd" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">但是…循环是如此的基本！为什么我们要尽量少用它们呢？原因有两个，第一个是针对 r 的。</p><p id="c8f4" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><strong class="ku ir">整个语言已经矢量化了<br/> </strong>即使你以前从未听说过这个词，你也已经知道了。向量化是你写这个的原因:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="2b1d" class="nr jv iq nf b gy ns nt l nu nv">x &lt;- 1:10<br/>y &lt;- 2 * x</span></pre><p id="47dd" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">代替</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="f9fb" class="nr jv iq nf b gy ns nt l nu nv">x &lt;- 1:10<br/>for (i in seq_along(x)) {<br/>    y &lt;- 2 * x[i]<br/>}</span></pre><p id="12e7" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><strong class="ku ir">循环很慢——使用适用！</strong><br/><code class="fe nc nd ne nf b">apply()</code>函数，以及类似的函数，是 R 的 FP 功能得以完全实现的基础。虽然在大多数语言中，循环和应用(通常称为“映射”)的速度是相同的，但是我们将会看到在 r 中使用 apples 会显著提高速度。</p><p id="82e3" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">r 的基础有一些应用，但真正漂亮的是在<code class="fe nc nd ne nf b">purrr</code>中发现的。稍后将详细介绍。</p><h1 id="adaf" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">第二步:管道，潮汐，和更多的管道</h1><p id="038d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你还没有听说过 Tidyverse，准备好去见你的新朋友吧。但首先，让我们来认识一下潮汐之星的<strong class="ku ir"> <em class="mn">管操作员</em> </strong>:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/2e64b48136bcfa74cebd0de214e068d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*BtqcqN2yx_hH7G6sj3-Bkw.png"/></div></figure><p id="5c37" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">管道(<code class="fe nc nd ne nf b">%&gt;%</code>)是由几个不同的包提供的操作符，但是最常见的是通过<code class="fe nc nd ne nf b">dplyr</code>或<code class="fe nc nd ne nf b">tidyverse</code>来访问。哦，如果你觉得重复输入(<code class="fe nc nd ne nf b">%&gt;%</code>)很痛苦，RStudio 给你一个捷径:Ctrl-Shift-M。</p><p id="a451" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">那么，它是做什么的呢？简单地说，管道接受左边的内容，并将其作为右边内容的第一个参数。例如:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="9b30" class="nr jv iq nf b gy ns nt l nu nv">add &lt;- function(x, y) x + y<br/>3 %&gt;% add(5) <br/># 8</span></pre><p id="6af7" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">这似乎比简单地键入<code class="fe nc nd ne nf b">add(3, 5)</code>更冗长，但是这允许您将复杂的操作写成<strong class="ku ir"> <em class="mn">管道</em> </strong> <em class="mn"> : </em></p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="6487" class="nr jv iq nf b gy ns nt l nu nv">3 %&gt;%<br/>  add(5) %&gt;%<br/>  add(1) %&gt;%<br/>  add(3) %&gt;%<br/>  add(7)<br/> <br/># 19</span></pre><p id="1ab3" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">太琐碎？看看这个来自我的一个咨询项目的真实片段:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="4573" class="nr jv iq nf b gy ns nt l nu nv">data_clean &lt;- data_raw %&gt;%<br/>  isFinal() %&gt;%<br/>  dropLastFiling() %&gt;%<br/>  getAccStats() %&gt;%<br/>  getPctIncs() %&gt;%<br/>  capOrDrop(inc_vars, cap = 3)</span></pre><p id="d5c2" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">你不需要看函数做什么就知道我在这里隐藏了很多复杂性。然而，你几乎可以用英语阅读:</p><ul class=""><li id="37e9" class="mo mp iq ku b kv lv kz lw ld mq lh mr ll ms lp mt mu mv mw bi translated">拿原始数据来说</li><li id="57d7" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">了解这是否是最后一次纳税申报</li><li id="8ea7" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">删除每个组织的最后一个纳税申报</li><li id="ed24" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">获取会计统计数据</li><li id="0bac" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">获得年同比增长百分比</li><li id="766d" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">在适当的时候去掉或限制这些变量(我使用 300%的上限)</li></ul><p id="8abe" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">没有这种模块化，代码几乎不可能调试。删除每个组织的最新纳税申报有问题吗？你必须通读数百行代码。在这里，您只需找到定义<code class="fe nc nd ne nf b">dropLastFiling</code>的位置，并在那里修复它。此外，您可以更清楚地看到准备数据的步骤。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a618d78b1fd6d1e1940dd2940cd2132c.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*54hkaws99jTeBVvP0_b8gg.png"/></div></figure><p id="3392" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">现在，我们准备好开始做 Tidyverse 了。<code class="fe nc nd ne nf b">tidyverse</code>实际上是包的集合，你可能不需要全部。我们需要的大部分东西实际上都包含在<code class="fe nc nd ne nf b">dplyr</code>里。</p><p id="8ac2" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">总之，<code class="fe nc nd ne nf b">tidyverse</code>充满了专门为常见数据操作任务构建的易于使用的函数。以下是一些最常用的方法:</p><p id="8c2a" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><code class="fe nc nd ne nf b">select()</code> —选择要保留(或删除)的列<br/> <code class="fe nc nd ne nf b">filter()</code> —选择要保留(或删除)的行<br/> <code class="fe nc nd ne nf b">arrange()</code> —按给定的行对数据进行排序<br/> <code class="fe nc nd ne nf b">rename()</code> —重命名列<br/> <code class="fe nc nd ne nf b">mutate()</code> —从现有列中创建新行<br/> <code class="fe nc nd ne nf b">group_by()</code> —组织数据，使其按某个分类变量<br/> <code class="fe nc nd ne nf b">summarize()</code>进行分组——类似于<code class="fe nc nd ne nf b">mutate()</code>，但将<code class="fe nc nd ne nf b">group_by()</code>中的数据折叠成汇总统计数据</p><p id="c7ab" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">示例:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="c0c6" class="nr jv iq nf b gy ns nt l nu nv">mtcars %&gt;%<br/>  filter(am == 0) %&gt;%         # Consider manual cars only<br/>  group_by(cyl) %&gt;%           # Group them by the number of cylinders<br/>  summarize(                  # Get the mean and sd of fuel<br/>    mean_mpg = mean(mpg),     # economy by cylinder<br/>    sd_mpg = sd(mpg)<br/>  ) %&gt;%<br/>  ungroup()                   # Undo effects of group_by()<br/>                              # (Not always req, but good practice) <br/> <br/># Output:<br/># A tibble: 3 x 3<br/>#     cyl mean_mpg sd_mpg<br/>#   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;<br/># 1     4     22.9   1.45<br/># 2     6     19.1   1.63<br/># 3     8     15.0   2.77</span></pre><h1 id="53c7" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">第三步:熟悉应用程序和地图</h1><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/f779eb3eab3a2c8893b45a25303e5a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*jUBreZYtlwnJSJdGLO-v1w.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk">The package <code class="fe nc nd ne nf b">purrr</code> is short for “Pure R”. The third R was added for the cat mascot, I suppose.</figcaption></figure><p id="0cee" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">我们的工具包中还有一个缺口:我们不允许使用循环，<em class="mn">有些任务对我们来说还没有矢量化</em>！数据分析师要做什么？</p><p id="d471" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">解决方法是使用<strong class="ku ir"> <em class="mn">应用</em> </strong>(也叫<strong class="ku ir"> <em class="mn">贴图</em> </strong>)。地图收集了一些事物，并对其中的每一个事物应用一些功能。这里有一张图直接取自 RStudio 的<a class="ae ma" href="https://maraaverick.rbind.io/banners/purrr_apply_cheatsheet_rstudio.png" rel="noopener ugc nofollow" target="_blank"> purrr 小抄</a> <em class="mn">(鸣谢:</em> <a class="ae ma" href="https://twitter.com/dataandme" rel="noopener ugc nofollow" target="_blank"> <em class="mn">玛拉·阿威克</em> </a> <em class="mn"> ) </em>:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi od"><img src="../Images/1478f2f69ed9735fdf386779d0245afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjoS2DhnWR9as4npq__1ww.png"/></div></div></figure><p id="e8dc" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><em class="mn">旁注:</em> <code class="fe nc nd ne nf b"><em class="mn">dplyr</em></code> <em class="mn">包实际上是从 applies 中得到它的名字的。</em> <code class="fe nc nd ne nf b"><em class="mn">dplyr</em></code> <em class="mn"> =数据+应用+ R. </em></p><p id="3904" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><code class="fe nc nd ne nf b">purrr</code>包里有多得离谱的地图可供选择。<a class="ae ma" href="https://maraaverick.rbind.io/banners/purrr_apply_cheatsheet_rstudio.png" rel="noopener ugc nofollow" target="_blank">说真的，看看那张备忘单</a>！</p><p id="7087" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><strong class="ku ir">例如，把所有的放在一起</strong>:假设我有一个字符串向量，我想提取每个字符串中最长的单词。没有矢量化的函数可以帮我做到这一点。我需要用空格字符分割字符串，得到最长的单词。为了获得戏剧性的效果，我还将字符串大写并粘贴在一起:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="080c" class="nr jv iq nf b gy ns nt l nu nv">library(tidyverse)<br/>library(purrr)<br/> <br/>sentences &lt;- c(<br/>  "My head is not functional",<br/>  "Programming is hard",<br/>  "Too many rules"<br/>)<br/> <br/>getLongestWord &lt;- function(words) {<br/>  word_counts &lt;- str_length(words)<br/>  longest_word &lt;- words[which.max(word_counts)]<br/>  return(longest_word)<br/>}<br/> <br/>sentences %&gt;% <br/>  toupper() %&gt;% <br/>  str_split(' ') %&gt;% <br/>  map_chr(getLongestWord) %&gt;% <br/>  str_c(collapse = ' ')<br/> <br/># [1] "FUNCTIONAL PROGRAMMING RULES"</span></pre><h1 id="4c6b" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">额外步骤:了解行话</h1><p id="4e9f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在其他语言中，FP 的一些行话是内置的。具体来说，几乎每种语言都有三个高阶函数，不管是不是函数式的:map(我们已经介绍过)、reduce 和 filter。</p><blockquote class="nh ni nj"><p id="ba00" class="ks kt mn ku b kv lv kx ky kz lw lb lc nk lx lf lg nl ly lj lk nm lz ln lo lp ij bi translated">高阶函数是这样一种函数，它要么接受一个函数作为参数，要么返回一个函数，或者两者都接受。</p></blockquote><p id="8540" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><strong class="ku ir">在 R 中过滤很容易。</strong>对于数据帧，我们可以使用使用<code class="fe nc nd ne nf b">tidyverse::filter</code>。对于大多数其他事情，我们可以简单地使用 R 的向量化。然而，当所有其他的都失败时，基数 R 确实有一个<code class="fe nc nd ne nf b">Filter()</code>函数。示例:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="d719" class="nr jv iq nf b gy ns nt l nu nv">Filter(function(x) x %% 2 == 0, 1:10)<br/># [1]  2  4  6  8 10</span></pre><p id="afb4" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated"><strong class="ku ir">同样，你可能永远也不会在 R </strong>里用到 <code class="fe nc nd ne nf b"><strong class="ku ir">Reduce()</strong></code> <strong class="ku ir">。但为了以防万一，它是这样工作的:<code class="fe nc nd ne nf b">Reduce()</code>将接受一个集合和一个二元函数(即接受两个参数)，并沿着该集合一次两个地连续应用该函数。示例:</strong></p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="45c5" class="nr jv iq nf b gy ns nt l nu nv">wrap &lt;- function(a, b) paste0("(", a, " ", b, ")")<br/>Reduce(wrap, c("A", "B", "C", "D", "E"))<br/># [1] "((((A B) C) D) E)"</span></pre><p id="081b" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">另一个广受欢迎的 FP 话题是<strong class="ku ir"> <em class="mn">奉承</em> </strong>。Currying 是这样一种行为:获取一个带有许多参数的函数，然后将它分解成接受部分参数的函数。这些有时被称为<strong class="ku ir"> <em class="mn">部分功能</em> </strong>。下面的例子使用了一个<strong class="ku ir"> <em class="mn">函数工厂</em> </strong>来制作部分函数:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="103e" class="nr jv iq nf b gy ns nt l nu nv"># Adder is a "function factory" - a function that makes new functions.<br/>adder &lt;- function(a) {<br/>    return(function(b) a + b)<br/>}<br/> <br/># Function factory pumping out new functions.<br/>add3 &lt;- adder(3)<br/>add5 &lt;- adder(5)<br/> <br/>add3(add5(1))<br/># 9</span></pre><p id="b52c" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">你觉得这个概念很难理解吗？你并不孤单。为了使这更具可读性，<code class="fe nc nd ne nf b">functional</code>库为您提供了一个显式的 currying builder:</p><pre class="mc md me mf gt nn nf no np aw nq bi"><span id="dcca" class="nr jv iq nf b gy ns nt l nu nv">library(functional)<br/>add &lt;- function(a, b) a + b<br/>add3 &lt;- Curry(add, a = 3)<br/>add5 &lt;- Curry(add, a = 5)<br/> <br/>add3(add5(1))<br/># 9</span></pre><p id="7d3f" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">附注:动词“currying”来自哈斯克尔·库里，著名的数学家/计算机科学家/宾夕法尼亚州立大学的研究员。</p><h1 id="bcb0" class="ju jv iq bd jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr bi translated">摘要</h1><p id="9080" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你觉得自己更聪明了吗？更厉害？准备好用你的新 FP 技能折磨你的数据了吗？以下是一些重要的要点:</p><ul class=""><li id="179f" class="mo mp iq ku b kv lv kz lw ld mq lh mr ll ms lp mt mu mv mw bi translated">不再有循环！永远不会。</li><li id="e91c" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">任何时候你想使用一个循环，找到合适的应用/映射。</li><li id="c588" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">尽可能将 Tidyverse 集成到您的工作流程中。</li><li id="41a0" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">当对一件事应用几个函数时，使用管道(<code class="fe nc nd ne nf b">%&gt;%</code>)(例如，在 Tidyverse 中操作一个数据帧)。</li></ul><p id="3472" class="pw-post-body-paragraph ks kt iq ku b kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ij bi translated">在编码时坚持这些心态可以大大减少难看的、难以维护的代码。将东西装入函数中可以给你留下干净、易读、模块化的<em class="mn">馄饨代码</em>。我将引用约翰·伍兹的一句名言:</p><blockquote class="nh ni nj"><p id="5738" class="ks kt mn ku b kv lv kx ky kz lw lb lc nk lx lf lg nl ly lj lk nm lz ln lo lp ij bi translated">编写代码时，始终要假设最终维护您代码的人是一个知道您住哪儿的暴力精神病患者。</p></blockquote><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8630b3fca6efe78a98058ef0464b8bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*hm-_PVbSJ2xmtQ-tBEEvWw.gif"/></div></figure></div></div>    
</body>
</html>