<html>
<head>
<title>How to use Pandas the RIGHT way to speed up your code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以正确的方式使用熊猫来加速你的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-pandas-the-right-way-to-speed-up-your-code-4a19bd89926d?source=collection_archive---------9-----------------------#2019-05-22">https://towardsdatascience.com/how-to-use-pandas-the-right-way-to-speed-up-your-code-4a19bd89926d?source=collection_archive---------9-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1b02e6d9da5fdba48e8adca90d3151eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9jCqvNYm33nazKkq.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Just a Panda, chillin'</figcaption></figure><blockquote class="kf kg kh"><p id="b724" class="ki kj kk kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">想获得灵感？快来加入我的<a class="ae lh" href="https://www.superquotes.co/?utm_source=mediumtech&amp;utm_medium=web&amp;utm_campaign=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu">超级行情快讯</strong> </a>。😎</p></blockquote><p id="b345" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">熊猫图书馆对数据科学界来说是一份天赐的礼物。问任何一个数据科学家他们喜欢如何用 Python 处理他们的数据集，他们无疑会谈论熊猫。</p><p id="0228" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">Pandas 是一个优秀编程库的缩影:简单、直观、功能广泛。</p><p id="ae18" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">然而，在熊猫数据帧上进行数千甚至数百万次计算，这是数据科学家的常规任务，仍然是一个挑战。你不能只是把你的数据扔进去，写一个 Python for-loop，然后期望你的数据在合理的时间内得到处理。</p><p id="fa38" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">Pandas 是为一次处理整行或整列的矢量化操作而设计的——遍历每个单元格、行或列根本不是该库的设计用途。因此，当使用 Pandas 时，你应该从高度并行化的<em class="kk">矩阵</em> <em class="kk">运算</em>的角度考虑问题。</p><p id="ffd7" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">本指南将教你如何使用熊猫的设计方式，并根据矩阵运算进行思考。在这个过程中，我将向您展示一些实用的节省时间的技巧和诀窍，它们将使您的熊猫代码运行得比那些可怕的 Python for-loops 快得多！</p><h1 id="aa2e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们的设置</h1><p id="eca1" class="pw-post-body-paragraph ki kj it kl b km mj ko kp kq mk ks kt li ml kw kx lj mm la lb lk mn le lf lg im bi translated">在整个教程中，我们将使用经典的鸢尾花数据集。让我们开始用 seaborn 加载数据集，并打印出前 5 行。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="08e0" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">厉害！</p><p id="5d3f" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">现在让我们建立一个基线，用 Python for-loop 来测量我们的速度。我们将通过循环遍历每一行来设置要在数据集上执行的计算，然后测量整个操作的速度。这将为我们提供一个基线，看看我们的新优化对我们有多大帮助。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="636b" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">在上面的代码中，我们创建了一个基本函数，使用 If-Else 语句根据花瓣长度选择花的类别。我们编写了一个 for 循环，通过遍历数据帧将函数应用于每一行，然后测量循环的总运行时间。</p><p id="6bce" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">在我的 i7–8700k 的机器上，在 5 次运行中，循环平均花费了 0.01345 秒。</p><h1 id="0af1" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">循环使用。iterrows()</h1><p id="5e72" class="pw-post-body-paragraph ki kj it kl b km mj ko kp kq mk ks kt li ml kw kx lj mm la lb lk mn le lf lg im bi translated">我们可以马上做的最简单但非常值得的加速是使用 Pandas 内置的<code class="fe mu mv mw mx b">.iterrows()</code>功能。</p><p id="d8e2" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">当我们在前一节中编写 for 循环时，我们使用了<code class="fe mu mv mw mx b">range()</code>函数。然而，当我们在 Python 中循环大量的值时，生成器往往要快得多。你可以在本文<a class="ae lh" rel="noopener" target="_blank" href="/5-advanced-features-of-python-and-how-to-use-them-73bffa373c84">这里</a>阅读更多关于发电机如何工作并使事情变得更快的信息。</p><p id="1a25" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">Pandas 的<code class="fe mu mv mw mx b">.iterrows()</code>函数在内部实现了一个生成器函数，它将在每次迭代中<code class="fe mu mv mw mx b">yield</code>一行数据帧。更准确地说，<code class="fe mu mv mw mx b">.iterrows()</code>为数据帧中的每一行生成(index，<code class="fe mu mv mw mx b">Series</code>)对(元组)。这实际上与在原始 Python 中使用类似于<code class="fe mu mv mw mx b">enumerate()</code>的东西是一样的，但是运行起来要快得多</p><p id="cc8b" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">下面我们修改了代码，使用<code class="fe mu mv mw mx b">.iterrows()</code>代替常规的 for 循环。在我在上一节中用于测试的同一台机器上，平均运行时间是 0.005892 秒——加速了 2.28 倍！</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="74e4" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">完全丢弃循环。应用()</h1><p id="c791" class="pw-post-body-paragraph ki kj it kl b km mj ko kp kq mk ks kt li ml kw kx lj mm la lb lk mn le lf lg im bi translated">这个<code class="fe mu mv mw mx b">.iterrows()</code>函数让我们的速度有了很大的提升，但是我们还远远没有完成。永远记住，当使用一个为向量运算设计的库时，可能有一种完全不用 for 循环就能最有效地做事的方法。</p><p id="4e7e" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">为我们提供这种能力的 Pandas 函数是<code class="fe mu mv mw mx b">.apply()</code>函数。我们的函数<code class="fe mu mv mw mx b">.apply()</code>将另一个函数作为其输入，并沿着数据帧(行、列等)的轴应用它。在我们传递函数的情况下，lambda 通常可以方便地将所有东西打包在一起。</p><p id="7d78" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">在下面的代码中，我们用<code class="fe mu mv mw mx b">.apply()</code>和一个 lambda 函数完全替换了我们的 for 循环，以打包我们想要的计算。在我的机器上，这段代码的平均运行时间是 0.0020897 秒，比我们原来的 for 循环快了 6.44 倍。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eef1" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated"><code class="fe mu mv mw mx b">.apply()</code>快得多的原因是它在内部试图循环遍历<a class="ae lh" href="https://en.wikipedia.org/wiki/Cython" rel="noopener ugc nofollow" target="_blank"> Cython </a>迭代器。如果你的函数恰好针对 Cython 进行了优化，<code class="fe mu mv mw mx b">.apply()</code>将会给你带来更大的速度提升。额外的好处是，使用内置函数会产生更干净、更易读的代码</p><h1 id="d775" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最终剪辑</h1><p id="9957" class="pw-post-body-paragraph ki kj it kl b km mj ko kp kq mk ks kt li ml kw kx lj mm la lb lk mn le lf lg im bi translated">之前我提到过，如果你正在使用一个为矢量化运算设计的库，你应该总是寻找一种不使用 for 循环的方法来进行任何计算。</p><p id="3f51" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">类似地，许多以这种方式设计的库，包括 Pandas，将有方便的内置函数来执行你正在寻找的精确计算——但要快得多。</p><p id="1e3e" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">Pandas 的<code class="fe mu mv mw mx b">.cut()</code>函数将一组定义 If-Else 的每个范围的<code class="fe mu mv mw mx b">bins</code>和一组定义每个范围返回哪个值的<code class="fe mu mv mw mx b">labels</code>作为输入。然后，它执行与我们用<code class="fe mu mv mw mx b">compute_class()</code>函数手动编写的完全相同的操作。</p><p id="c99b" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt li kv kw kx lj kz la lb lk ld le lf lg im bi translated">查看下面的代码，看看<code class="fe mu mv mw mx b">.cut()</code>是如何工作的。我们再次得到了更干净、更易读的代码的好处。最终，<code class="fe mu mv mw mx b">.cut()</code>函数平均运行时间为 0.001423 秒——比原来的 for-loop 快了 9.39 倍！</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="8160" class="ll lm it bd ln lo nf lq lr ls ng lu lv lw nh ly lz ma ni mc md me nj mg mh mi bi translated">喜欢学习？</h1><p id="e72b" class="pw-post-body-paragraph ki kj it kl b km mj ko kp kq mk ks kt li ml kw kx lj mm la lb lk mn le lf lg im bi translated">在推特<a class="ae lh" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank">上关注我，我会在这里发布所有最新最棒的人工智能、技术和科学！也请在 LinkedIn</a><a class="ae lh" href="https://www.linkedin.com/in/georgeseif/" rel="noopener ugc nofollow" target="_blank">上与我联系！</a></p></div></div>    
</body>
</html>