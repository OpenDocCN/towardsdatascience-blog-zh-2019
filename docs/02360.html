<html>
<head>
<title>Rendering elegant stock trading agents using Matplotlib and Gym</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Matplotlib 和 Gym 绘制优雅的股票交易代理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualizing-stock-trading-agents-using-matplotlib-and-gym-584c992bc6d4?source=collection_archive---------3-----------------------#2019-04-18">https://towardsdatascience.com/visualizing-stock-trading-agents-using-matplotlib-and-gym-584c992bc6d4?source=collection_archive---------3-----------------------#2019-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2414" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将扩展我们在上一个教程中编写的代码，以使用 Matplotlib 呈现环境的可视化效果。如果你没有读过我的第一篇文章<a class="ae ko" href="https://medium.com/@notadamking/creating-a-custom-openai-gym-environment-for-stock-trading-be532be3910e" rel="noopener"> <strong class="js iu">从头开始创造定制的健身房环境</strong> </a> <strong class="js iu">，</strong>，你应该停下来先读一下。</p><p id="19d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对<code class="fe kp kq kr ks b">matplotlib</code>库不熟悉，不用担心。我们将检查每一行，以便您可以创建自己的<code class="fe kp kq kr ks b">gym</code>环境的自定义可视化。一如既往，本教程的代码将在我的<a class="ae ko" href="https://github.com/notadamking/Stock-Trading-Visualization" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Github </strong> </a>上提供。</p><p id="c4ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我们将在本文中创建的内容的预览:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/ca2095aa1cef88c6d6d324619b1c0ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*4Hbm9N6jihLO7ta6rFtMhA.gif"/></div></figure><p id="567b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果看起来很复杂，其实也没那么糟糕。只有几个关于每个<code class="fe kp kq kr ks b">step</code>的图表更新，注释了一些关键信息。我们开始吧！</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="bf6d" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">股票交易可视化</strong></h1><p id="da3c" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在上一个教程中，我们编写了一个简单的<code class="fe kp kq kr ks b">render</code>方法，使用<code class="fe kp kq kr ks b">print</code>语句显示代理的净值和其他重要指标。让我们将这个逻辑转移到一个名为<code class="fe kp kq kr ks b">_render_to_file</code>的新方法中，这样我们就可以在必要时将一个会话的交易指标保存到一个文件中。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="b2c8" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> _render_to_file(<em class="mp">self</em>, <em class="mp">filename</em>='render.txt'):<br/>  profit = self.net_worth - INITIAL_ACCOUNT_BALANCE<br/>  <br/>  file = open(filename, 'a+')</span><span id="a948" class="mk le it ks b gy mq mm l mn mo">  file.write(<em class="mp">f</em>'Step: {self.current_step}\n')<br/>  file.write(<em class="mp">f</em>'Balance: {self.balance}\n')<br/>  file.write(<em class="mp">f</em>'Shares held: {self.shares_held} (Total sold: <br/>    {self.total_shares_sold})\n')<br/>  file.write(<em class="mp">f</em>'Avg cost for held shares: {self.cost_basis} (Total <br/>    sales value: {self.total_sales_value})\n')<br/>  file.write(<em class="mp">f</em>'Net worth: {self.net_worth} (Max net worth: <br/>    {self.max_net_worth})\n')<br/>  file.write(<em class="mp">f</em>'Profit: {profit}\n\n')</span><span id="11f6" class="mk le it ks b gy mq mm l mn mo">  file.close()</span></pre><p id="f771" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们继续创建新的<code class="fe kp kq kr ks b">render</code>方法。它将利用我们新的<code class="fe kp kq kr ks b">StockTradingGraph</code>类，我们还没有写。我们下一步会谈到这个。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="fdd1" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> render(<em class="mp">self</em>, <em class="mp">mode</em>='live', <em class="mp">title</em>=None, **<em class="mp">kwargs</em>):<br/>  # Render the environment to the screen</span><span id="866d" class="mk le it ks b gy mq mm l mn mo">  <strong class="ks iu">if</strong> mode == 'file':<br/>    self._render_to_file(kwargs.get('filename', 'render.txt'))<br/>  <strong class="ks iu">elif</strong> mode == 'live':<br/>    <strong class="ks iu">if</strong> self.visualization == None:<br/>      self.visualization = StockTradingGraph(self.df, title)<br/>    <br/>    <strong class="ks iu">if</strong> self.current_step &gt; LOOKBACK_WINDOW_SIZE:        <br/>      self.visualization.render(self.current_step, self.net_worth, <br/>        self.trades, <em class="mp">window_size</em>=LOOKBACK_WINDOW_SIZE)</span></pre><p id="208f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里使用<code class="fe kp kq kr ks b"><a class="ae ko" href="http://book.pythontips.com/en/latest/args_and_kwargs.html" rel="noopener ugc nofollow" target="_blank">kwargs</a></code>将可选的<code class="fe kp kq kr ks b">filename</code>和<code class="fe kp kq kr ks b">title</code>传递给<code class="fe kp kq kr ks b">StockTradingGraph</code>。如果你不熟悉<code class="fe kp kq kr ks b">kwargs</code>，它基本上是一个向函数传递可选关键字参数的字典。</p><p id="5fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还为可视化传递了<code class="fe kp kq kr ks b">self.trades</code>,但是还没有定义它，所以让我们开始吧。回到我们的<code class="fe kp kq kr ks b">_take_action</code>方法，无论何时我们买入或卖出股票，我们现在都要将交易的细节添加到<code class="fe kp kq kr ks b">self.trades</code>对象中，在我们的<code class="fe kp kq kr ks b">reset</code>方法中我们已经将它初始化为<code class="fe kp kq kr ks b">[]</code>。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="4fb5" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu">def </strong>_take_action(self, action):<br/>  ...<strong class="ks iu"><br/>  <br/>  if</strong> action_type &lt; 1:<br/>    <strong class="ks iu">...<br/></strong>    <br/>    <strong class="ks iu">if</strong> shares_bought &gt; 0:<br/>      self.trades.append({'step': self.current_step,<br/>        'shares': shares_bought, 'total': additional_cost,<br/>        'type': "buy"})</span><span id="99b9" class="mk le it ks b gy mq mm l mn mo">  <strong class="ks iu">elif</strong> action_type &lt; 2:<br/>    <strong class="ks iu">...</strong></span><span id="29aa" class="mk le it ks b gy mq mm l mn mo"><strong class="ks iu">    if</strong> shares_sold &gt; 0:<br/>      self.trades.append({'step': self.current_step,<br/>        'shares': shares_sold, 'total': shares_sold * current_price,<br/>        'type': "sell"})</span></pre><p id="f36b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的<code class="fe kp kq kr ks b">StockTradingGraph</code>已经拥有了呈现股票价格历史和交易量所需的所有信息，以及我们代理的净值和它所做的任何交易。让我们开始渲染我们的可视化。</p><p id="beb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将定义我们的<code class="fe kp kq kr ks b">StockTradingGraph</code>和它的<code class="fe kp kq kr ks b">__init__</code>方法。在这里我们将创建我们的<code class="fe kp kq kr ks b">pyplot</code>人物，并设置每个要渲染的支线剧情。<code class="fe kp kq kr ks b">date2num</code>函数用于将日期重新格式化为时间戳，这在以后的呈现过程中是必要的。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="23d1" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu">import</strong> numpy <strong class="ks iu">as</strong> np<br/><strong class="ks iu">import</strong> matplotlib<br/><strong class="ks iu">import</strong> matplotlib.pyplot <strong class="ks iu">as</strong> plt<br/><strong class="ks iu">import</strong> matplotlib.dates <strong class="ks iu">as</strong> mdates</span><span id="6506" class="mk le it ks b gy mq mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> date2num(<em class="mp">date</em>):<br/>  converter = mdates.strpdate2num('%Y-%m-%d')<br/>  <strong class="ks iu">return</strong> converter(date)</span><span id="8b83" class="mk le it ks b gy mq mm l mn mo"><strong class="ks iu"><em class="mp">class</em></strong> <strong class="ks iu">StockTradingGraph</strong>:<br/>  """A stock trading visualization using matplotlib made to render <br/>    OpenAI gym environments"""</span><span id="a386" class="mk le it ks b gy mq mm l mn mo"><em class="mp">  </em><strong class="ks iu"><em class="mp">def</em></strong> __init__(<em class="mp">self</em>, <em class="mp">df</em>, <em class="mp">title</em>=None):<br/>    self.df = df<br/>    self.net_worths = np.zeros(len(df['Date']))</span><span id="0e00" class="mk le it ks b gy mq mm l mn mo">    # Create a figure on screen and set the title<br/>    fig = plt.figure()<br/>    fig.suptitle(title)</span><span id="e1ec" class="mk le it ks b gy mq mm l mn mo">    # Create top subplot for net worth axis<br/>    self.net_worth_ax = plt.subplot2grid((6, 1), (0, 0), <em class="mp">rowspan</em>=2,     <br/>      <em class="mp">colspan</em>=1)<br/>  <br/>    # Create bottom subplot for shared price/volume axis<br/>    self.price_ax = plt.subplot2grid((6, 1), (2, 0), <em class="mp">rowspan</em>=8, <br/>      <em class="mp">colspan</em>=1, <em class="mp">sharex</em>=self.net_worth_ax)</span><span id="d39f" class="mk le it ks b gy mq mm l mn mo">    # Create a new axis for volume which shares its x-axis with <br/>      price<br/>    self.volume_ax = self.price_ax.twinx()</span><span id="6d0b" class="mk le it ks b gy mq mm l mn mo">    # Add padding to make graph easier to view<br/>    plt.subplots_adjust(<em class="mp">left</em>=0.11, <em class="mp">bottom</em>=0.24, <em class="mp">right</em>=0.90, <br/>      <em class="mp">top</em>=0.90, <em class="mp">wspace</em>=0.2, <em class="mp">hspace</em>=0)</span><span id="a7aa" class="mk le it ks b gy mq mm l mn mo">    # Show the graph without blocking the rest of the program<br/>    plt.show(<em class="mp">block</em>=False)</span></pre><p id="8d7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<code class="fe kp kq kr ks b">plt.subplot2grid(<strong class="js iu">...</strong>)</code>方法首先在我们的数字顶部创建一个子图来呈现我们的净值网格，然后在它下面为我们的价格网格创建另一个子图。<code class="fe kp kq kr ks b">subplot2grid</code>的第一个参数是子情节的大小，第二个参数是在图中的位置。</p><p id="f5c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了呈现我们的交易量棒线，我们在<code class="fe kp kq kr ks b">self.price_ax</code>上调用<code class="fe kp kq kr ks b">twinx()</code>方法，这允许我们在顶部覆盖另一个共享相同 x 轴的网格。最后，也是最重要的，我们将使用<code class="fe kp kq kr ks b">plt.show(block=False)</code>将我们的图形渲染到屏幕上。如果您忘记通过<code class="fe kp kq kr ks b">block=False</code>，您将只能看到呈现的第一步，之后代理将被阻止继续。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/13c26fe5beeb1c07b418a210ea7ec82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFP41sk5xtUpsR7yq1g5dQ.png"/></div></div></figure><p id="a699" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来写我们的<code class="fe kp kq kr ks b">render</code>方法。这将从当前时间步骤中获取所有信息，并在屏幕上实时显示。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="9a8a" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> render(<em class="mp">self</em>, <em class="mp">current_step</em>, <em class="mp">net_worth</em>, <em class="mp">trades</em>, <em class="mp">window_size</em>=40):<br/>  self.net_worths[current_step] = net_worth</span><span id="d6b2" class="mk le it ks b gy mq mm l mn mo">  window_start = max(current_step - window_size, 0)<br/>  step_range = range(window_start, current_step + 1)</span><span id="e3e1" class="mk le it ks b gy mq mm l mn mo">  # Format dates as timestamps, necessary for candlestick graph<br/>  dates = np.array([date2num(x)<br/>    <strong class="ks iu">for</strong> x <strong class="ks iu">in</strong> self.df['Date'].values[step_range]])<br/>    <br/>  self._render_net_worth(current_step, net_worth, window_size,   <br/>    dates)<br/>  self._render_price(current_step, net_worth, dates, step_range)<br/>  self._render_volume(current_step, net_worth, dates, step_range)<br/>  self._render_trades(current_step, trades, step_range)</span><span id="f07f" class="mk le it ks b gy mq mm l mn mo">  # Format the date ticks to be more easily read<br/>  self.price_ax.set_xticklabels(self.df['Date'].values[step_range], <br/>    <em class="mp">rotation</em>=45, <em class="mp">horizontalalignment</em>='right')</span><span id="5a50" class="mk le it ks b gy mq mm l mn mo">  # Hide duplicate net worth date labels<br/>  plt.setp(self.net_worth_ax.get_xticklabels(), <em class="mp">visible</em>=False)</span><span id="2b93" class="mk le it ks b gy mq mm l mn mo">  # Necessary to view frames before they are unrendered    <br/>  plt.pause(0.001)</span></pre><p id="40b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们保存<code class="fe kp kq kr ks b">net_worth</code>，然后从上到下渲染每个图形。我们还将使用代理在<code class="fe kp kq kr ks b">self.render_trades</code>方法中进行的交易来注释价格图表。这里调用<code class="fe kp kq kr ks b">plt.pause()</code>很重要，否则在最后一帧真正显示在屏幕上之前，下一次调用<code class="fe kp kq kr ks b">render</code>会清除每一帧。</p><p id="6207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看图表的每一种呈现方法，从净值开始。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="aad9" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> _render_net_worth(<em class="mp">self</em>, <em class="mp">current_step</em>, <em class="mp">net_worth</em>, <em class="mp">step_range</em>, <br/>                      <em class="mp">dates</em>):<br/>  # Clear the frame rendered last step<br/>  self.net_worth_ax.clear()</span><span id="9a5d" class="mk le it ks b gy mq mm l mn mo">  # Plot net worths<br/>  self.net_worth_ax.plot_date(dates, self.net_worths[step_range], '-<br/>    ', <em class="mp">label</em>='Net Worth')</span><span id="3445" class="mk le it ks b gy mq mm l mn mo">  # Show legend, which uses the label we defined for the plot above<br/>  self.net_worth_ax.legend()<br/>  legend = self.net_worth_ax.legend(<em class="mp">loc</em>=2, <em class="mp">ncol</em>=2, <em class="mp">prop</em>={'size': 8})<br/>  legend.get_frame().set_alpha(0.4)</span><span id="b65a" class="mk le it ks b gy mq mm l mn mo">  last_date = date2num(self.df['Date'].values[current_step])<br/>  last_net_worth = self.net_worths[current_step]</span><span id="94dd" class="mk le it ks b gy mq mm l mn mo">  # Annotate the current net worth on the net worth graph<br/>  self.net_worth_ax.annotate('{0<em class="mp">:.2f</em>}'.format(net_worth),     <br/>    (last_date, last_net_worth),<br/>    <em class="mp">xytext</em>=(last_date, last_net_worth),<br/>    <em class="mp">bbox</em>=<em class="mp">dict</em>(<em class="mp">boxstyle</em>='round', <em class="mp">fc</em>='w', <em class="mp">ec</em>='k', <em class="mp">lw</em>=1),<br/>    <em class="mp">color</em>="black",<br/>    <em class="mp">fontsize</em>="small")</span><span id="823d" class="mk le it ks b gy mq mm l mn mo">  # Add space above and below min/max net worth<br/>  self.net_worth_ax.set_ylim(<br/>    min(self.net_worths[np.nonzero(self.net_worths)]) / 1.25,    <br/>    max(self.net_worths) * 1.25)</span></pre><p id="916a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只是调用我们的净值支线剧情上的<code class="fe kp kq kr ks b">plot_date(<strong class="js iu">...</strong>)</code>来绘制一个简单的线图，然后用代理当前的<code class="fe kp kq kr ks b">net_worth</code>进行注释，并添加一个图例。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mw"><img src="../Images/ea6737e2902699a1087de8147e823bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnwH-G7QL06xaTkwFnqOOg.png"/></div></div></figure><p id="ce11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">价格图的呈现有点复杂。为了简单起见，我们将使用不同于音量条的方法来渲染 OHCL 条。首先，如果你还没有这个包，你需要<code class="fe kp kq kr ks b">pip install mpl_finance</code>，因为这个包是我们将要使用的蜡烛图所需要的。然后将这一行添加到文件的顶部。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="4147" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu">from</strong> mpl_finance <strong class="ks iu">import</strong> candlestick_ochl <strong class="ks iu">as</strong> candlestick</span></pre><p id="8529" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好，让我们清除前一帧，压缩 OHCL 数据，并向<code class="fe kp kq kr ks b">self.price_ax</code>子情节渲染一个蜡烛图。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="561f" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> _render_price(<em class="mp">self</em>, <em class="mp">current_step</em>, <em class="mp">net_worth</em>, <em class="mp">dates</em>, <em class="mp">step_range</em>):<br/>  self.price_ax.clear()</span><span id="19b5" class="mk le it ks b gy mq mm l mn mo">  # Format data for OHCL candlestick graph<br/>  candlesticks = zip(dates,<br/>    self.df['Open'].values[step_range],  <br/>    self.df['Close'].values[step_range],<br/>    self.df['High'].values[step_range], <br/>    self.df['Low'].values[step_range])</span><span id="5578" class="mk le it ks b gy mq mm l mn mo">  # Plot price using candlestick graph from mpl_finance<br/>  candlestick(self.price_ax, candlesticks, <em class="mp">width</em>=1,<br/>    <em class="mp">colorup</em>=UP_COLOR, <em class="mp">colordown</em>=DOWN_COLOR)</span><span id="f3b4" class="mk le it ks b gy mq mm l mn mo">  last_date = date2num(self.df['Date'].values[current_step])<br/>  last_close = self.df['Close'].values[current_step]<br/>  last_high = self.df['High'].values[current_step]</span><span id="b612" class="mk le it ks b gy mq mm l mn mo">  # Print the current price to the price axis<br/>  self.price_ax.annotate('{0<em class="mp">:.2f</em>}'.format(last_close),<br/>    (last_date, last_close),<br/>    <em class="mp">xytext</em>=(last_date, last_high),<br/>    <em class="mp">bbox</em>=<em class="mp">dict</em>(<em class="mp">boxstyle</em>='round', <em class="mp">fc</em>='w', <em class="mp">ec</em>='k', <em class="mp">lw</em>=1),<br/>    <em class="mp">color</em>="black",<br/>    <em class="mp">fontsize</em>="small")</span><span id="99d2" class="mk le it ks b gy mq mm l mn mo">  # Shift price axis up to give volume chart space<br/>  ylim = self.price_ax.get_ylim()<br/>  self.price_ax.set_ylim(ylim[0] - (ylim[1] - ylim[0])<br/>    * VOLUME_CHART_HEIGHT, ylim[1])</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mx"><img src="../Images/29b8b84169470c62e5043b351b0f8bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uwkfXde2pSjoKVskVVS4w.png"/></div></div></figure><p id="e117" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用股票的当前价格对图表进行了注释，并向上移动图表以防止它与成交量棒线重叠。接下来让我们看看体积渲染方法，这是非常简单的，因为没有注释。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="fe49" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> _render_volume(<em class="mp">self</em>, <em class="mp">current_step</em>, <em class="mp">net_worth</em>, <em class="mp">dates</em>, <br/>                   <em class="mp">step_range</em>):<br/>  self.volume_ax.clear()</span><span id="aad2" class="mk le it ks b gy mq mm l mn mo">  volume = np.array(self.df['Volume'].values[step_range])<br/>  <br/>  pos = self.df['Open'].values[step_range] - \<br/>    self.df['Close'].values[step_range] &lt; 0<br/>  neg = self.df['Open'].values[step_range] - \<br/>    self.df['Close'].values[step_range] &gt; 0</span><span id="566b" class="mk le it ks b gy mq mm l mn mo">  # Color volume bars based on price direction on that date<br/>  self.volume_ax.bar(dates[pos], volume[pos], <em class="mp">color</em>=UP_COLOR,<br/>    <em class="mp">alpha</em>=0.4, <em class="mp">width</em>=1, <em class="mp">align</em>='center')<br/>  self.volume_ax.bar(dates[neg], volume[neg], <em class="mp">color</em>=DOWN_COLOR,<br/>    <em class="mp">alpha</em>=0.4, <em class="mp">width</em>=1, <em class="mp">align</em>='center')</span><span id="bd4b" class="mk le it ks b gy mq mm l mn mo">  # Cap volume axis height below price chart and hide ticks<br/>  self.volume_ax.set_ylim(0, max(volume) / VOLUME_CHART_HEIGHT)<br/>  self.volume_ax.yaxis.set_ticks([])</span></pre><p id="9561" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个简单的条形图，每个条形显示为绿色或红色，这取决于价格在该时间步长内是上升还是下降。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/6a4c31d0e819bba66ce80856d00eb974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kO9I7imuyvF5UpW4mOc_IQ.png"/></div></div></figure><p id="6cac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们进入有趣的部分:<code class="fe kp kq kr ks b">_render_trades</code>。在这个方法中，我们将在价格图上绘制一个箭头，在这里代理进行了一笔交易，并标注了交易的总金额。</p><pre class="ku kv kw kx gt mg ks mh mi aw mj bi"><span id="ae58" class="mk le it ks b gy ml mm l mn mo"><strong class="ks iu"><em class="mp">def</em></strong> _render_trades(<em class="mp">self</em>, <em class="mp">current_step</em>, <em class="mp">trades</em>, <em class="mp">step_range</em>):<br/>  <strong class="ks iu">for</strong> trade <strong class="ks iu">in</strong> trades:<br/>    <strong class="ks iu">if</strong> trade['step'] <strong class="ks iu">in</strong> step_range:<br/>      date = date2num(self.df['Date'].values[trade['step']])<br/>      high = self.df['High'].values[trade['step']]<br/>      low = self.df['Low'].values[trade['step']]</span><span id="170b" class="mk le it ks b gy mq mm l mn mo"><strong class="ks iu">      if</strong> trade['type'] == 'buy':<br/>        high_low = low<br/>        color = UP_TEXT_COLOR<br/>      <strong class="ks iu">else</strong>:<br/>        high_low = high<br/>        color = DOWN_TEXT_COLOR</span><span id="5dcc" class="mk le it ks b gy mq mm l mn mo">      total = '{0<em class="mp">:.2f</em>}'.format(trade['total'])</span><span id="a423" class="mk le it ks b gy mq mm l mn mo">      # Print the current price to the price axis   <br/>      self.price_ax.annotate(<em class="mp">f</em>'${total}', (date, high_low),<br/>        <em class="mp">xytext</em>=(date, high_low),<br/>        <em class="mp">color</em>=color,<br/>        <em class="mp">fontsize</em>=8,<br/>        <em class="mp">arrowprops</em>=(<em class="mp">dict</em>(<em class="mp">color</em>=color)))</span></pre><p id="d338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！我们现在有了一个在上一篇文章中创建的股票交易环境的漂亮的、实时的可视化效果！太糟糕了，我们仍然没有花太多的时间来教经纪人如何赚钱…我们下次再谈吧！</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mz"><img src="../Images/10c7dd49c51f7eae0fc5789dc75688ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_RAM1Tgl2gewwAbFxMOyg.png"/></div></div></figure><p id="2893" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不算太寒酸！下周，我们将基于本教程的代码<a class="ae ko" rel="noopener" target="_blank" href="/creating-bitcoin-trading-bots-that-dont-lose-money-2e7165fb0b29">创建不会赔钱的比特币交易机器人</a>。</p><div class="na nb gp gr nc nd"><a rel="noopener follow" target="_blank" href="/creating-bitcoin-trading-bots-that-dont-lose-money-2e7165fb0b29"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">创造不赔钱的比特币交易机器人</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">让我们使用深度强化学习来制造有利可图的加密货币交易代理</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">towardsdatascience.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kz nd"/></div></div></a></div></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="e1f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mp">感谢阅读！一如既往，本教程的所有代码都可以在我的</em> <a class="ae ko" href="https://github.com/notadamking/Stock-Trading-Visualization" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Github </em> </a> <em class="mp">上找到。如果您有任何问题或反馈，请在下面留下评论，我很乐意收到您的来信！我也可以通过@notadamking 的</em><a class="ae ko" href="https://twitter.com/notadamking" rel="noopener ugc nofollow" target="_blank"><em class="mp">Twitter</em></a><em class="mp">联系到。</em></p><p id="1f4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mp">你也可以通过下面的链接在</em> <a class="ae ko" href="https://github.com/users/notadamking/sponsorship" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Github 赞助商</em> </a> <em class="mp">或者</em><a class="ae ko" href="https://www.patreon.com/join/notadamking" rel="noopener ugc nofollow" target="_blank"><em class="mp">Patreon</em></a><em class="mp">上赞助我。</em></p><div class="na nb gp gr nc nd"><a href="https://github.com/users/notadamking/sponsorship" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">GitHub 赞助商</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">嗨，我是亚当。我是一名开发人员、作家和企业家，尤其对深度…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nz l no np nq nm nr kz nd"/></div></div></a></div><blockquote class="oa ob oc"><p id="d9fb" class="jq jr mp js b jt ju jv jw jx jy jz ka od kc kd ke oe kg kh ki of kk kl km kn im bi translated">Github 赞助商目前正在 1:1 匹配所有捐款，最高可达 5000 美元！</p></blockquote><div class="na nb gp gr nc nd"><a href="https://patreon.com/notadamking" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">亚当·金正在创造改变世界的内容</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">嗨，我是亚当。我是一名开发人员、作家和企业家，尤其对深度…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">patreon.com</p></div></div><div class="nm l"><div class="og l no np nq nm nr kz nd"/></div></div></a></div></div></div>    
</body>
</html>