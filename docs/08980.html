<html>
<head>
<title>[NLP] Basics: Understanding Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[NLP]基础:理解正则表达式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nlp-basics-understanding-regular-expressions-fc7c7746bc70?source=collection_archive---------8-----------------------#2019-11-30">https://towardsdatascience.com/nlp-basics-understanding-regular-expressions-fc7c7746bc70?source=collection_archive---------8-----------------------#2019-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a0f0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你唯一需要的向导</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d69aa5e7c36d48ee90952f7d1607c6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_LvNULFC5szeKsL1Tm9WQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@travelnow_or_crylater?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">travelnow.or.crylater</a> on <a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fa76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始学习自然语言处理时，正则表达式真的感觉像一门外语。我努力理解语法，花了几个小时写一个正则表达式来返回我正在寻找的输入。很自然的，我尽可能的远离他们。</p><p id="f9c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但事实是，作为一名数据科学家，总有一天你会接触到正则表达式。它们构成了自然语言处理中基本技术的一部分，学习它们将使你成为一个更高效的程序员。</p><p id="4a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以是时候坐下来开始了。把学习正则表达式想象成一堂语法课:它们很痛苦，起初看起来不可理解，但一旦你理解并学会了，你会感到如释重负。我向你保证，到头来也没那么难。</p><p id="78cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意，我将在本文中使用的编程软件是 R. </em></p><h1 id="824a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">展开正则表达式</h1><p id="1c98" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">简而言之，正则表达式是给函数的“指令”,告诉它如何匹配或替换一组字符串。</p><p id="83f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从正则表达式的一些基础开始，这是一些你应该知道的基本语法。</p><p id="0bac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">括号</strong> []用于指定字符的析取。例如，使用括号放 W 或 W 允许我返回大写的 W 或小写的 W。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a11f" class="mv lu iq mr b gy mw mx l my mz">/[wW]oodchuck/ --&gt; Woodchuck or woodchuck <br/>/[abc]/ --&gt; ‘a’, ‘b’, or ‘c’<br/>/[1234567890]/ --&gt; any digit</span></pre><p id="8a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你添加一个<strong class="ky ir">破折号</strong>，你就指定了一个范围。例如，将 A-Z 放在括号中允许 R 返回一个大写字母的所有匹配。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8dbd" class="mv lu iq mr b gy mw mx l my mz">/[A-Z]/ → machtes an upper case letter<br/>/[a-z]/ → matches a lower case letter<br/>/[0–9]/ → matches a single digit</span></pre><p id="35bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">^可以用于否定，或者仅仅表示^.</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6c4f" class="mv lu iq mr b gy mw mx l my mz">/[ˆA-Z]/ --&gt; not an upper case letter<br/>/[ˆSs]/ --&gt; neither ‘S’ nor ‘s’<br/>/[ˆ\.]/ --&gt; not a period<br/>/[eˆ]/ --&gt; either ‘e’ or ‘ˆ’<br/>/aˆb/ --&gt; the pattern ‘aˆb’</span></pre><p id="90e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">问号</strong>？标记上一个表达式的可选性。例如，将一个。在土拨鼠结束时，返回土拨鼠(不带 s)和土拨鼠(带 s)的结果。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f3c4" class="mv lu iq mr b gy mw mx l my mz">/woodchucks?/ --&gt; woodchuck or woodchucks<br/>/colou?r/ --&gt; color or colour</span></pre><p id="bb80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以用<strong class="ky ir">期</strong>。指定两个表达式之间的任意字符。例如，输入 beg.n 将返回 begin 或 begin 这样的单词。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a46f" class="mv lu iq mr b gy mw mx l my mz">/beg.n/ --&gt; Match any character between beg and n (e.g. begin, begun)</span></pre><p id="44a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> *或+ </strong>用户允许您添加 1 个或多个先前字符。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="280b" class="mv lu iq mr b gy mw mx l my mz"><br/>oo*h! → 0 or more of a previous character (e.g. ooh!, ooooh!)<br/>o+h! → 1 or more of a previous character (e.g. ooh!, ooooooh!)<br/>baa+ → baa, baaaa, baaaaaa, baaaaaaa</span></pre><p id="7e79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">锚</strong>用于断言关于字符串或匹配过程的一些东西。因此，它们不是用于特定的单词或字符，而是帮助进行更一般的查询，正如您在下面的示例中所看到的。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3edd" class="mv lu iq mr b gy mw mx l my mz"><br/>. → any character except a new line<br/>\\w → any word character<br/>\\W → anything but a word character<br/>\\d → any digit character<br/>\\D → anything but a digit character<br/>\\b → a word boundary<br/>\\B → anything but a word boundary<br/>\\s → any space character<br/>\\S → anything but a space character</span></pre><p id="b686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> POSIX 字符类别</strong>有助于匹配特定的字符类别，如数字。换句话说，它使一个小的字符序列匹配一个更大的字符集。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a048" class="mv lu iq mr b gy mw mx l my mz"><br/>[[:alpha:]] → alphabetic characters<br/>[[:digit:]] → digits<br/>[[:punct:]] → punctuation<br/>[[:space:]] → space, tab, newline etc.<br/>[[:lower:]] → lowercase alphatic characters<br/>[[:upper:]] → upper case alphabetic characters</span></pre><h1 id="bd13" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">strsplit()、grep()和 gsub()</h1><p id="8baf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是行动开始的地方。在处理字符串时，很可能必须使用命令 strsplit()、grep()和 gsub()来激活您希望 R 返回给您的输入。</p><h2 id="5795" class="mv lu iq bd lv na nb dn lz nc nd dp md lf ne nf mf lj ng nh mh ln ni nj mj nk bi translated"><strong class="ak"> strsplit(x，split) </strong></h2><p id="d992" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下面的例子展示了一种使用 strsplit 来拆分句子中的单词的方法，在这个例子中是破折号“…”内的所有单词。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5f6c" class="mv lu iq mr b gy mw mx l my mz">richard3 &lt;- “now is the winter of our discontent”<br/>strsplit(richard3, “ “) # the second argument specifies the space</span></pre><h2 id="d4ed" class="mv lu iq bd lv na nb dn lz nc nd dp md lf ne nf mf lj ng nh mh ln ni nj mj nk bi translated"><strong class="ak"> grep(pattern，x，ignore.case = FALSE，value = FALSE) </strong></h2><p id="bc34" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">grep 允许你“抓取”你想要的单词或单词集，这取决于你设置的匹配模式。例如，在下面的代码中，我让 R 返回包含单词“both”的字符串。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e507" class="mv lu iq mr b gy mw mx l my mz">grep.ex &lt;- c(“some like Python”, “some prefer R”, “some like both”)</span><span id="ca86" class="mv lu iq mr b gy nl mx l my mz">grep(“both”, grep.ex) # in numerical form<br/>grep(“both”, grep.ex, value=TRUE) #prints the character string itself</span></pre><h2 id="864c" class="mv lu iq bd lv na nb dn lz nc nd dp md lf ne nf mf lj ng nh mh ln ni nj mj nk bi translated">gsub(pattern，replacement，x，ignore.case= FALSE)</h2><p id="4539" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">例如，gsub 允许你用一个词替换另一个词。在这种情况下，我选择在下面的字符串中用超人代替罗密欧。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ce0a" class="mv lu iq mr b gy mw mx l my mz">r_and_j &lt;- “O Romeo, Romeo, wherefore art thou Romeo?”<br/>gsub(“Romeo”, “Superman”, r_and_j, ignore.case = FALSE)</span></pre><h1 id="4447" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">应用了正则表达式</h1><p id="26a7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们开始将这些命令应用于正则表达式。下面我给你看几个例子。</p><h2 id="e2f1" class="mv lu iq bd lv na nb dn lz nc nd dp md lf ne nf mf lj ng nh mh ln ni nj mj nk bi translated">1.grep(模式，x，ignore.case =假，值=假)</h2><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8941" class="mv lu iq mr b gy mw mx l my mz">dollar &lt;- c(“I paid $15 for this book.”, “they received $50,000 in grant money”, “two dollars”)</span></pre><p id="f80a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在上面的例子中，你有三个不同的句子，其中两个使用了$符号，一个使用了单词“美元”。仅使用$来匹配您的模式将会返回所有三个句子。然而，如果你在$前加上\\你可以指定你只需要使用$符号的句子。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ee48" class="mv lu iq mr b gy mw mx l my mz">grep(“$”, dollar) <br/>grep(“\\$”, dollar)</span></pre><p id="eaa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面还有几个例子，说明如何使用 grep 来匹配单词“ashes”、“shark”、“bash”的正则表达式:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2548" class="mv lu iq mr b gy mw mx l my mz"># matches all three vector elements<br/>grep(“sh”, c(“ashes”, “shark”, “bash”), value=TRUE) </span><span id="94a5" class="mv lu iq mr b gy nl mx l my mz"># matches only “shark”<br/>grep(“^sh”, c(“ashes”, “shark”, “bash”), value=TRUE) </span><span id="474d" class="mv lu iq mr b gy nl mx l my mz"># matches only “bash”<br/>grep(“sh$”, c(“ashes”, “shark”, “bash”), value=TRUE) </span></pre><p id="058f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于“失态”、“擦破”、“粉笔”三个词:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6078" class="mv lu iq mr b gy mw mx l my mz">quant.ex &lt;- c(“gaffe”, “chafe”, “chalk”, “encyclopaedia”, “encyclopedia”)</span><span id="4dda" class="mv lu iq mr b gy nl mx l my mz"># Searching for one or more occurences of f and we want to see the value not only the index (that’s why we put value = TRUE)<br/>grep(“f+”, quant.ex, value=TRUE) </span><span id="addd" class="mv lu iq mr b gy nl mx l my mz"># one or two “f”<br/>grep(“f{1,2}”, quant.ex, value=TRUE) </span><span id="ff75" class="mv lu iq mr b gy nl mx l my mz"># at least one “f”<br/>grep(“f{1,}”, quant.ex, value=TRUE)</span></pre><h2 id="79aa" class="mv lu iq bd lv na nb dn lz nc nd dp md lf ne nf mf lj ng nh mh ln ni nj mj nk bi translated">2.gsub(pattern，replacement，x，ignore.case= FALSE)</h2><p id="3a9c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在下面的例子中，你可以用 gsub 替换句子中的单词。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="10ad" class="mv lu iq mr b gy mw mx l my mz">ex.sentence &lt;- “Act 3, scene 1. To be, or not to be, that is the Question:”</span></pre><p id="995a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还记得在本文第一部分中学习的正则表达式，您应该能够猜出 R 将返回哪种输入。否则，我会将它添加到下面的代码中，以便您更好地理解使用正则表达式返回所需结果的所有不同方式。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2ba5" class="mv lu iq mr b gy mw mx l my mz">gsub(“.”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "**********************************************************"</span><span id="eda2" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\w”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "*** *, ***** *. ** **, ** *** ** **, **** ** *** ********:"</span><span id="3b10" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\W”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "Act*3**scene*1**To*be**or*not*to*be**that*is*the*Question*"</span><span id="6068" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\d”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "Act *, scene *. To be, or not to be, that is the Question:"</span><span id="2f8e" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\D”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "****3********1********************************************"</span><span id="08ae" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\b”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "*Act* *3*, *scene* *1*. *To* *be*, *or* *not* *to* *be*, *that* *is* *the* *Question*:"</span><span id="2242" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\B”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "A*c*t 3,* s*c*e*n*e 1.* T*o b*e,* o*r n*o*t t*o b*e,* t*h*a*t i*s t*h*e Q*u*e*s*t*i*o*n:*"</span><span id="28fc" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\s”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "Act*3,*scene*1.*To*be,*or*not*to*be,*that*is*the*Question:"</span><span id="5317" class="mv lu iq mr b gy nl mx l my mz">gsub(“\\S”, “*”, ex.sentence, ignore.case=TRUE, perl=TRUE)<br/>[1] "*** ** ***** ** ** *** ** *** ** *** **** ** *** *********"</span></pre><p id="1801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，试着猜测最后一个问题的答案:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f8b5" class="mv lu iq mr b gy mw mx l my mz">letters.digits &lt;- “a1 b2 c3 d4 e5 f6 g7 h8 i9”<br/>gsub(“(\\w)(\\d)”, “\\2\\1”, letters.digits)</span></pre><p id="8699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我希望你喜欢这篇文章，并且我已经设法使正则表达式对你来说更容易理解。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="fe1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">我经常写关于数据科学和自然语言处理的文章。在</em> <a class="ae kv" href="https://twitter.com/celine_vdr" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> Twitter </em> </a> <em class="ls">或</em><a class="ae kv" href="https://medium.com/@celine.vdr" rel="noopener"><em class="ls">Medium</em></a><em class="ls">上关注我，查看更多类似的文章或简单地更新下一篇文章。</em> <strong class="ky ir"> <em class="ls">感谢阅读！</em>T19】</strong></p><p id="0c3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PS:最后一个的答案是“1a 2b 3c 4d 5e 6f 7g 8h 9i”。换句话说，您已经使用正则表达式重写了所有的字母和数字。很酷不是吗？</p></div></div>    
</body>
</html>