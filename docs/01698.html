<html>
<head>
<title>Getting started with NLP using the PyTorch framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PyTorch 框架开始使用 NLP</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-nlp-using-the-pytorch-framework-72e7b17b8717?source=collection_archive---------17-----------------------#2019-03-19">https://towardsdatascience.com/getting-started-with-nlp-using-the-pytorch-framework-72e7b17b8717?source=collection_archive---------17-----------------------#2019-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/dd113aa1c66c4b36d853745ce2803179.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*tKg0CbKUlXTMRm6G"/></div></figure><p id="09d9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">PyTorch 是最流行的深度学习框架之一，它基于 Python，由脸书支持。</p><p id="0d64" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本文中，我们将研究 PyTorch 提供的帮助自然语言处理(NLP)的类。</p><p id="313c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">PyTorch 中有 6 个类可用于使用递归层的 NLP 相关任务:</p><ul class=""><li id="fc6e" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">torch.nn.RNN</li><li id="5312" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">火炬. nn.LSTM</li><li id="788f" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">火炬网</li><li id="d1f5" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">火炬</li><li id="3ba9" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">火炬. nn.LSTMCell</li><li id="783f" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">火炬. nn .格鲁塞尔</li></ul><p id="6d7e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">理解这些类、它们的参数、它们的输入和输出是开始在 Pytorch 中为自然语言处理(NLP)构建自己的神经网络的关键。</p><p id="c401" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你已经开始了你的 NLP 之旅，很可能你已经遇到了类似的图表(如果没有，我们建议你看看克里斯·奥拉的这篇精彩的、经常被引用的文章——<a class="ae kv" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">了解 LSTM 网络</a>):</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/981244f07ad50985fc4447929a61c9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*IVC8skbSulepyYiv"/></div></figure><p id="ed56" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">来源—【http://colah.github.io/posts/2015-08-Understanding-LSTMs/ T4】</p><p id="5975" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">教师使用这种展开图向学生提供这种神经网络的递归结构的简单易懂的解释。从这些漂亮的、展开的图表和直观的解释到 Pytorch API 可能被证明是具有挑战性的。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/9b9354a21ebfa3181a569d3bfca7fbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*roJ5oqcb96aGzC72"/></div></div></figure><p id="e70e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">来源—<a class="ae kv" href="https://pytorch.org/docs/stable/nn.html#recurrent-layers" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/docs/stable/nn.html#recurrent-layers</a></p><p id="39bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，在本文中，我们旨在通过以清晰和描述性的方式解释 PyTorch 中相关类的参数、输入和输出来弥补这一差距。</p><p id="5e0c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Pytorch 基本上有两个等级的类来构建循环网络:</p><ul class=""><li id="02bf" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">多层类— nn。新泽西州 RNN。GRU·安迪。LSTM </strong> <strong class="jz iu"> <br/> </strong>这些类的对象能够表示深度双向递归神经网络(<em class="lt">或者，如类名所示，它们的一个或多个进化架构——门控递归单元(GRU)或长短期记忆(LSTM)网络</em>)。</li><li id="e949" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu">细胞水平类— nn。新罕布什尔州 RNNCell。格鲁塞尔和 nn。LSTMCell </strong> <strong class="jz iu"> <br/> </strong>这些类的对象只能代表一个单元格<em class="lt">(同样，一个简单的 RNN 或 LSTM 或 GRU 单元格)</em>，它可以处理一个时间步长的输入数据。<em class="lt">(记住，这些细胞没有 cuDNN 优化，因此没有任何融合操作，等等。)</em></li></ul><p id="1f7c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同一级别的所有类共享相同的 API。因此，理解上述两个层次中任何一个类的参数、输入和输出就足够了。</p><p id="4f1a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">为了使解释简单，我们将使用最简单的类——torch . nn . rnn 和 torch.nn.RNNCell </strong></p><h1 id="5aef" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">火炬. nn.RNN:</h1><p id="c150" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">我们将使用下图来解释 API —</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/0d09e147c5aea2fff3f832a7335f830b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*SFC5mU50hgatuCW7"/></div></figure><p id="f95e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">来源——【http://colah.github.io/posts/2015-08-Understanding-LSTMs/ T2】</p><h2 id="6b36" class="mx lv it bd lw my mz dn ma na nb dp me ki nc nd mi km ne nf mm kq ng nh mq ni bi translated">参数:</h2><ul class=""><li id="6fdf" class="kw kx it jz b ka ms ke mt ki nj km nk kq nl ku lb lc ld le bi translated"><strong class="jz iu"> input_size </strong> —输入 x 中期望特征的数量</li></ul><p id="5b18" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这表示向量 x[i]的维数(即上图中从 x[0]到 x[t]的任何向量)。请注意，这很容易与序列长度混淆，序列长度是我们在如上展开 RNN 后得到的细胞总数。</p><ul class=""><li id="8804" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu"> hidden_size </strong> —处于隐藏状态的特征数量 h</li></ul><p id="e027" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这表示向量 h[i]的维数(即上图中从 h[0]到 h[t]的任何向量)。总的来说，在确定网络的权重矩阵的形状时，隐藏大小和输入大小是必要的和充分的。</p><ul class=""><li id="7345" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">层数</strong> —循环层数。例如，设置 num _ layers =将意味着将两个 RNN 堆叠在一起以形成堆叠的 RNN，其中第二 RNN 接收第一 RNN 的输出并计算最终结果。默认值:1</li></ul><p id="aefb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此参数用于构建深度 rnn，如下所示:</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8a8af189e2deab4924a0d8cf47356c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/0*lu1uY-z9fxxSTpGs"/></div></figure><p id="f6c4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里，红色单元代表输入，绿色块代表 RNN 单元，蓝色块代表输出</p><p id="4aa1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以对于上图，我们将 num_layers 参数设置为 3。</p><ul class=""><li id="73d9" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">非线性</strong> —要使用的非线性。可以是“tanh”或“relu”。默认值:“tanh”</li></ul><p id="aeec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是不言自明的。</p><ul class=""><li id="8abd" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">偏差</strong>-如果为假，则该层不使用偏差权重 b_ih 和 b_hh。默认值:真</li></ul><p id="82c0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在深度学习社区，一些人发现去除/使用偏见不会影响模型的性能。因此这个布尔参数。</p><ul class=""><li id="1c93" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu"> batch_first </strong> —如果为真，则输入和输出张量提供为(batch，seq，feature)。默认值:False</li><li id="4957" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu"> dropout </strong> —如果非零，在除最后一层之外的每个 RNN 层的输出上引入一个丢弃层，丢弃概率等于 dropout。默认值:0</li></ul><p id="bc28" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该参数用于控制 RNN 体系结构中的退出正则化方法。</p><ul class=""><li id="5f73" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">双向</strong> —如果为真，则成为双向 RNN。默认值:False</li></ul><p id="a4ed" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建双向 RNN 非常简单，只需将该参数设置为 True！</p><p id="c947" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，要在 PyTorch 中制作 RNN，我们需要向该类传递两个强制参数——input _ size 和 hidden_size。</p><p id="8e82" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦我们创建了一个对象，我们就可以用相关的输入“调用”该对象，它就会返回输出。</p><h2 id="d3ab" class="mx lv it bd lw my mz dn ma na nb dp me ki nc nd mi km ne nf mm kq ng nh mq ni bi translated">输入:</h2><p id="84e4" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">我们需要向对象传递 2 个输入——input 和 h_0:</p><ul class=""><li id="10e5" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">输入</strong> —这是一个形状张量<em class="lt">(序列长度，批次，输入大小)。</em>为了处理可变长度的输入，我们将较短的输入序列打包。详见<a class="ae kv" href="https://pytorch.org/docs/stable/nn.html#torch.nn.utils.rnn.pack_padded_sequence" rel="noopener ugc nofollow" target="_blank">torch . nn . utils . rnn . pack _ padded _ sequence()</a>或<a class="ae kv" href="https://pytorch.org/docs/stable/nn.html#torch.nn.utils.rnn.pack_sequence" rel="noopener ugc nofollow" target="_blank">torch . nn . utils . rnn . pack _ sequence()</a>。</li><li id="deb0" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu"> h_0 </strong> —这是一个形状张量(num_layers * num_directions，batch，hidden_size)。对于双向 RNNs，num_directions 为 2，否则为 1。这个张量包含批处理中每个元素的初始隐藏状态。</li></ul><p id="3462" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">输出</strong>:</p><p id="595a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以类似的方式，对象向 us 返回 2 个输出——output 和 h_n:</p><ul class=""><li id="ebcc" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz iu">输出</strong> —这是一个形状为<em class="lt">(序列长度，批次，数量方向*隐藏尺寸)的张量。</em>它包含来自 RNN 最后一层的输出特征(h_k ),对于每个 k</li><li id="f30a" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu"> h_n </strong> —这是一个大小为(num_layers * num_directions，batch，hidden_size)的张量。它包含 k = seq_len 的隐藏状态。</li></ul><p id="f56d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如前所述，torch.nn.GRU 和 torch.nn.LSTM 具有相同的 API，也就是说，它们接受相同的参数集，接受相同格式的输入并以相同格式返回。</p><h1 id="4c38" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">torch.nn.RNNCell:</h1><p id="de3e" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">因为这仅代表 RNN 的单个单元格，所以它仅接受 4 个参数，所有这些参数的含义与它们在 torch.nn.RNN 中的含义相同。</p><h2 id="70f0" class="mx lv it bd lw my mz dn ma na nb dp me ki nc nd mi km ne nf mm kq ng nh mq ni bi translated">参数:</h2><ul class=""><li id="025f" class="kw kx it jz b ka ms ke mt ki nj km nk kq nl ku lb lc ld le bi translated"><strong class="jz iu"> input_size </strong> —输入 x 中预期特征的数量</li><li id="bff1" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu"> hidden_size </strong> —处于隐藏状态的特征数量 h</li><li id="5485" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu">偏差</strong> —如果为假，则该层不使用偏差权重 b_ih 和 b_hh。默认值:真</li><li id="5a0c" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu">非线性</strong> —要使用的非线性。可以是“tanh”或“relu”。默认值:“tanh”</li></ul><p id="0711" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">再说一次，因为这只是 RNN 的一个细胞，输入和输出维度要简单得多——</p><h2 id="54b8" class="mx lv it bd lw my mz dn ma na nb dp me ki nc nd mi km ne nf mm kq ng nh mq ni bi translated">输入(输入，隐藏):</h2><ul class=""><li id="9cba" class="kw kx it jz b ka ms ke mt ki nj km nk kq nl ku lb lc ld le bi translated"><strong class="jz iu">输入</strong> —这是一个包含输入特征的形状张量(batch，input_size)。</li><li id="8a26" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><strong class="jz iu">hidden</strong>——这是一个形状张量(batch，hidden_size ),包含批处理中每个元素的初始隐藏状态。</li></ul><h2 id="07bb" class="mx lv it bd lw my mz dn ma na nb dp me ki nc nd mi km ne nf mm kq ng nh mq ni bi translated">输出:</h2><ul class=""><li id="2656" class="kw kx it jz b ka ms ke mt ki nj km nk kq nl ku lb lc ld le bi translated"><strong class="jz iu">h’</strong>—这是一个形状张量(batch，hidden_size)，它为我们提供了下一个时间步的隐藏状态。</li></ul><p id="c1d1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是关于自然语言处理(NLP)py torch 框架的入门知识。如果你正在寻找关于什么是可能的和你能构建什么的想法，请查看使用 RNNs 和 CNN 的自然语言处理的<a class="ae kv" href="https://blog.exxactcorp.com/deep-learning-for-natural-language-processing/?utm_source=web%20referral&amp;utm_medium=backlink&amp;utm_campaign=medium.com&amp;utm_term=nlp%20using%20pytorch" rel="noopener ugc nofollow" target="_blank">深度学习。</a></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="7a8d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lt">原载于 2019 年 3 月 19 日</em><a class="ae kv" href="https://blog.exxactcorp.com/getting-started-with-natural-language-processing-using-pytorch/?utm_source=web%20referral&amp;utm_medium=backlink&amp;utm_campaign=medium.com&amp;utm_term=nlp%20using%20pytorch" rel="noopener ugc nofollow" target="_blank"><em class="lt">【blog.exxactcorp.com</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>