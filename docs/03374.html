<html>
<head>
<title>Hands-on Graph Neural Networks with PyTorch &amp; PyTorch Geometric</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch 和 PyTorch 几何图形的手动图形神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-graph-neural-networks-with-pytorch-pytorch-geometric-359487e221a8?source=collection_archive---------0-----------------------#2019-05-30">https://towardsdatascience.com/hands-on-graph-neural-networks-with-pytorch-pytorch-geometric-359487e221a8?source=collection_archive---------0-----------------------#2019-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4bf659105cc2194eeb12c5ff8320ee9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMTs2MPLKCwOZy4WaKbYTw.png"/></div></div></figure><p id="7170" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我上一篇<a class="ae kz" rel="noopener" target="_blank" href="/a-gentle-introduction-to-graph-neural-network-basics-deepwalk-and-graphsage-db5d540d50b3">文章</a>中，我介绍了图形神经网络(GNN)的概念以及它的一些最新进展。由于这个话题被大肆炒作，我决定制作这个教程，讲述如何在你的项目中轻松实现你的图形神经网络。您将学习如何使用 PyTorch Geometric 构建自己的 GNN，以及如何使用 GNN 解决现实世界中的问题(Recsys Challenge 2015)。</p><p id="796e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇博文中，我们将使用 PyTorch 和 PyTorch Geometric (PyG)，这是一个基于 PyTorch 构建的图形神经网络框架，运行速度快得惊人。它比最著名的 GNN 框架 DGL 快好几倍。</p><p id="fba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了其非凡的速度，PyG 还提供了一系列实现良好的 GNN 模型，这些模型在各种论文中都有说明。因此，用 PyG 重现实验将会非常方便。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/a6d259847799e9094796a89d706072ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUyz027Yz_jsGfWBPmfStQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">A Subset of The Implemented Models (<a class="ae kz" href="https://github.com/rusty1s/pytorch_geometric" rel="noopener ugc nofollow" target="_blank">https://github.com/rusty1s/pytorch_geometric</a>)</figcaption></figure><p id="1e11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">鉴于其在速度和便利性方面的优势，毫无疑问，PyG 是最受欢迎和使用最广泛的 GNN 库之一。让我们进入主题，把我们的手弄脏！</p><h1 id="0d5e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">要求</h1><ul class=""><li id="2ba5" class="mh mi it kd b ke mj ki mk km ml kq mm ku mn ky mo mp mq mr bi translated">PyTorch — 1.1.0</li><li id="dc04" class="mh mi it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">PyTorch 几何图形— 1.2.0</li></ul><h1 id="fffa" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">PyTorch 几何基础</h1><p id="1cc8" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">本节将带您了解 PyG 的基础知识。基本上会涵盖<em class="na"> torch_geometric.data </em>和<em class="na"> torch_geometric.nn </em>。您将学习如何将几何数据传递到您的 GNN，以及如何设计一个自定义的消息传递层，GNN 的核心。</p><h2 id="7838" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">数据</h2><p id="4a78" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated"><em class="na"> torch_geometric.data </em>模块包含一个数据类，允许您非常容易地从数据中创建图表。您只需指定:</p><ol class=""><li id="192e" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky nq mp mq mr bi translated">与每个节点相关联的属性/特征</li><li id="fcc6" class="mh mi it kd b ke ms ki mt km mu kq mv ku mw ky nq mp mq mr bi translated">每个节点的连通性/邻接性(边索引)</li></ol><p id="d6b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用下图来演示如何创建数据对象</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/70ec847179d515764f63d5c97ddda594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbZ6BvixcLI0t6Zz3E4EIw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Example Graph</figcaption></figure><p id="3052" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，图中有 4 个节点，v1 … v4，每个节点都与一个二维特征向量相关联，并且标签<em class="na"> y </em>指示其类别。这两个可以表示为浮动传感器:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">图的连通性(边索引)应该用首席运营官格式限制，即第一个列表包含源节点的索引，而目标节点的索引在第二个列表中指定。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9442" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，边索引的顺序与您创建的数据对象无关，因为此类信息仅用于计算邻接矩阵。因此，上面的 edge_index 表示与下面的相同的信息。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3e7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将它们放在一起，我们可以创建如下所示的数据对象:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="61ab" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">资料组</h2><p id="1dca" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">数据集的创建过程不是很简单，但是对于那些使用过<em class="na"> torchvision </em>的人来说，它似乎很熟悉，因为 PyG 遵循它的惯例。PyG 提供了两种不同类型的数据集类，InMemorydataset 和 Dataset。顾名思义，前一个用于适合 RAM 的数据，而第二个用于更大的数据。由于它们的实现非常相似，所以我将只介绍 InMemoryDataset。</p><p id="4975" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要创建 InMemoryDataset 对象，需要实现 4 个函数:</p><ul class=""><li id="db16" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na"> raw_file_names() </em></li></ul><p id="bce9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它返回一个列表，显示原始的、未处理的文件名列表。如果你只有一个文件，那么返回的列表应该只包含一个元素。事实上，您可以简单地返回一个空列表，然后在<em class="na">过程()</em>中指定您的文件。</p><ul class=""><li id="6bbf" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na">已处理文件名()</em></li></ul><p id="5402" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与上一个函数类似，它也返回一个包含所有已处理数据的文件名的列表。调用 process()后，通常返回的列表应该只有一个元素，存储唯一处理过的数据文件名。</p><ul class=""><li id="b78d" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na">下载()</em></li></ul><p id="cd17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个函数应该将您正在处理的数据下载到 self.raw_dir 中指定的目录中。如果你不需要下载数据，就直接来</p><pre class="lb lc ld le gt nu nv nw nx aw ny bi"><span id="11db" class="nb lk it nv b gy nz oa l ob oc">pass</span></pre><p id="f423" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在函数中。</p><ul class=""><li id="39ab" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na">流程()</em></li></ul><p id="d23d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是数据集最重要的方法。您需要将数据收集到一个数据对象列表中。然后，调用<em class="na"> self.collate() </em>来计算 DataLoader 对象将使用的切片。下面是一个来自<a class="ae kz" href="https://rusty1s.github.io/pytorch_geometric/build/html/notes/create_dataset.html" rel="noopener ugc nofollow" target="_blank"> PyG 官网</a>的自定义数据集的例子。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8912" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文后面，我将向您展示如何根据 RecSys 挑战赛中提供的数据创建自定义数据集。</p><h2 id="3151" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">数据加载器</h2><p id="b81a" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">DataLoader 类允许您轻松地将数据批量输入到模型中。要创建 DataLoader 对象，只需指定所需的数据集和批处理大小。</p><pre class="lb lc ld le gt nu nv nw nx aw ny bi"><span id="15ae" class="nb lk it nv b gy nz oa l ob oc">loader = DataLoader(dataset, batch_size=512, shuffle=True)</span></pre><p id="d894" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DataLoader 对象的每次迭代都会生成一个 batch 对象，该对象非常类似于数据对象，但带有一个属性“Batch”。它指示每个节点与哪个图相关联。由于数据加载器将来自不同样本/图形的<em class="na"> x </em>、<em class="na"> y </em>和<em class="na"> edge_index </em>聚集成批，因此 GNN 模型需要这种“批”信息来知道哪些节点属于一批中的同一个图形以执行计算。</p><pre class="lb lc ld le gt nu nv nw nx aw ny bi"><span id="f212" class="nb lk it nv b gy nz oa l ob oc"><strong class="nv iu">for</strong> batch <strong class="nv iu">in</strong> loader:<br/>    batch<br/>    &gt;&gt;&gt; Batch(x=[1024, 21], edge_index=[2, 1568], y=[512], batch=[1024])</span></pre><h2 id="dd42" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">信息传递</h2><p id="7bee" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">消息传递是 GNN 的本质，它描述了如何学习节点嵌入。我在上一篇文章中已经谈到了，所以我将简单地用符合 PyG 文档的术语来介绍一下。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/a7b3977430416258359622233fc7c375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hf7AhJ-nY_qE0MUUMGuMvA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Message Passing</figcaption></figure><p id="27fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="na"> x </em>表示节点嵌入，<em class="na"> e </em>表示边特征，𝜙表示<strong class="kd iu">消息</strong>功能，□表示<strong class="kd iu">聚合</strong>功能，<strong class="kd iu">更新</strong>功能。如果图中的边除了连通性之外没有其他特征，则 e 本质上是图的边指数。上标代表层的索引。当 k=1 时，<em class="na"> x </em>表示每个节点的输入特征。下面我将说明每个功能的工作原理:</p><ul class=""><li id="de3f" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na"> propagate(edge_index，size=None，**kwargs): </em></li></ul><p id="d8bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它接受边索引和其他可选信息，如节点特征(嵌入)。调用此函数将会调用<em class="na">消息</em>和<em class="na">更新</em>。</p><ul class=""><li id="e79c" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na">消息(**kwargs): </em></li></ul><p id="cd3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您指定如何为每个节点对(x_i，x_j)构造“消息”。因为它跟随<em class="na">传播</em>的调用，所以它可以接受传递给<em class="na">传播</em>的任何参数。需要注意的一点是，可以用“_i”和“_j”定义从参数到特定节点的映射。因此，命名该函数的参数时必须非常小心。</p><ul class=""><li id="ecba" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky mo mp mq mr bi translated"><em class="na">更新(aggr_out，**kwargs) </em></li></ul><p id="e6e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它接收聚合的消息和传递到<em class="na"> propagate </em>的其他参数，为每个节点分配一个新的嵌入值。</p><p id="ce09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">例子</strong></p><p id="93ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从论文<a class="ae kz" href="https://arxiv.org/abs/1706.02216" rel="noopener ugc nofollow" target="_blank"> <em class="na">“大型图的归纳表示学习”</em> </a>来看看如何实现一个<strong class="kd iu"> SageConv </strong>层。SageConv 的消息传递公式定义为:</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/04b1759be30980cb309992825536091d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-i0-86EI4ziV5_aGDXEiaw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk"><a class="ae kz" href="https://arxiv.org/abs/1706.02216" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1706.02216</a></figcaption></figure><p id="7a93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们使用最大池作为聚合方法。因此，第一行的右边可以写成:</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c2b9fe67a7d8e9e2e60cdf1aa773c4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*REpyHFIFNiT6hL4SfFN3qQ.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk"><a class="ae kz" href="https://arxiv.org/abs/1706.02216" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1706.02216</a></figcaption></figure><p id="ebeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这说明了“消息”是如何构造的。每个嵌入的相邻节点乘以一个权重矩阵，加上一个偏差，并通过一个激活函数。这可以用 torch.nn.Linear 轻松做到。</p><pre class="lb lc ld le gt nu nv nw nx aw ny bi"><span id="aa47" class="nb lk it nv b gy nz oa l ob oc">class SAGEConv(MessagePassing):<br/>    def __init__(self, in_channels, out_channels):<br/>        super(SAGEConv, self).__init__(aggr='max')<br/>        self.lin = torch.nn.Linear(in_channels, out_channels)<br/>        self.act = torch.nn.ReLU()<br/>        <br/>    def message(self, x_j):<br/>        # x_j has shape [E, in_channels]<br/><br/>        x_j = self.lin(x_j)<br/>        x_j = self.act(x_j)<br/>      <br/>        return x_j</span></pre><p id="1651" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于更新部分，聚合消息和当前节点嵌入是聚合的。然后，将其乘以另一个权重矩阵，并应用另一个激活函数。</p><pre class="lb lc ld le gt nu nv nw nx aw ny bi"><span id="845f" class="nb lk it nv b gy nz oa l ob oc">class SAGEConv(MessagePassing):<br/>    def __init__(self, in_channels, out_channels):<br/>        super(SAGEConv, self).__init__(aggr='max')<br/>        self.update_lin = torch.nn.Linear(in_channels + out_channels, in_channels, bias=False)<br/>        self.update_act = torch.nn.ReLU()<br/>        <br/>    def update(self, aggr_out, x):<br/>        # aggr_out has shape [N, out_channels]<br/>        <br/>        new_embedding = torch.cat([aggr_out, x], dim=1)<br/>        new_embedding = self.update_lin(new_embedding)<br/>        new_embedding = torch.update_act(new_embedding)<br/>        <br/>        return new_embedding</span></pre><p id="b57a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">放在一起，我们有下面的 SageConv 层。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="58a5" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">一个真实的例子—2015 年 RecSys 挑战赛</h1><p id="203a" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">RecSys 挑战赛 2015 向数据科学家发起挑战，要求他们构建一个基于会话的推荐系统。这项挑战要求参与者完成两项任务:</p><ol class=""><li id="91fa" class="mh mi it kd b ke kf ki kj km nn kq no ku np ky nq mp mq mr bi translated">预测是否会有一个购买事件，随后是一系列的点击</li><li id="d604" class="mh mi it kd b ke ms ki mt km mu kq mv ku mw ky nq mp mq mr bi translated">预测哪件商品将被购买</li></ol><p id="6c6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先我们从 RecSys Challenge 2015 官网下载<a class="ae kz" href="https://2015.recsyschallenge.com/challenge.html" rel="noopener ugc nofollow" target="_blank">数据，构建数据集。我们将从第一项任务开始，因为那项更容易。</a></p><p id="366d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该挑战提供了两组主要数据，<em class="na"> yoochoose-clicks.dat </em>和<em class="na"> yoochoose-buys.dat </em>，分别包含点击事件和购买事件。让我们快速浏览一下数据:</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/05235d6589d0dbaf7ec672c266eb2019.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*CcmsurWO-DuYSzVCy7Pf7g.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">yoochoose-click.dat</figcaption></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e531382f9709f0025585ef18a8b35ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*aND01yPpaZLUBtL4SrXR1g.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">yoochoose-buys.dat</figcaption></figure><h2 id="1736" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">预处理</h2><p id="8aa4" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">下载完数据后，我们对其进行预处理，以便将其输入到我们的模型中。item _ id 被分类编码以确保编码的 item _ id 从 0 开始，该编码的 item _ id 稍后将被映射到嵌入矩阵。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/700530e8bd2fe243145475421261f8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*EeKk9k-DKZBenqGV9RoIAw.png"/></div></figure><p id="8c53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于数据非常大，为了便于演示，我们对其进行了二次抽样。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1dbb2d6ca67f71a739fc29c04198eb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*NWyoY-MLfLbN6ZxWiYIN_A.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Number of unique elements in the subsampled data</figcaption></figure><p id="f22a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了确定基本事实，即给定会话是否有任何购买事件，我们只需检查<em class="na"> yoochoose-clicks.dat </em>中的 session_id 是否也出现在<em class="na"> yoochoose-buys.dat </em>中。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/27dbebefa2a9dcd8beb150d41eff8bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*A5jaCXd41plzf8Fvva3_tA.png"/></div></figure><h2 id="37e0" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">数据集构建</h2><p id="654d" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">在预处理步骤之后，数据就可以转换成 Dataset 对象了。这里，我们将会话中的每个项目视为一个节点，因此同一会话中的所有项目构成一个图。为了构建数据集，我们通过<em class="na"> session_id </em>对预处理后的数据进行分组，并迭代这些组。在每次迭代中，每个组中的 item_id 被再次分类编码，因为对于每个图，节点索引应该从 0 开始计数。因此，我们有以下内容:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b108" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在构建数据集之后，我们调用<em class="na"> shuffle() </em>来确保它已经被随机打乱，然后将它分成三组用于训练、验证和测试。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="4e2f" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">构建图形神经网络</h2><p id="668c" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">下面的自定义 GNN 引用了 PyG 官方 Github 库中的一个例子<a class="ae kz" href="https://github.com/rusty1s/pytorch_geometric/blob/master/examples/enzymes_topk_pool.py" rel="noopener ugc nofollow" target="_blank">。我用我们自己实现的 SAGEConv 层改变了 GraphConv 层，如上图所示。此外，还修改了输出图层以匹配二进制分类设置。</a></p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="62b3" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">培养</h2><p id="0fa5" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">训练我们的自定义 GNN 非常容易，我们只需迭代从训练集构建的数据加载器，并反向传播损失函数。这里，我们使用 Adam 作为优化器，学习率设置为 0.005，二进制交叉熵作为损失函数。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="1b4e" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">确认</h2><p id="31d7" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">这种标签是高度不平衡的，有大量的负面标签，因为大多数会议之后没有任何购买活动。换句话说，一个愚蠢的模型猜测所有的否定会给你 90%以上的准确率。因此，曲线下面积(AUC)是该任务的更好指标，而不是准确性，因为它只关心正面示例的得分是否高于负面示例。我们使用 Sklearn 现成的 AUC 计算功能。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="b419" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">结果</h2><p id="dc7a" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">我对模型进行了 1 个时期的训练，并测量了训练、验证和测试的 AUC 分数:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/1441e074dfeab434b60b289bfaca2e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HaowQx5muMrtu3ZwEwHJQ.png"/></div></div></figure><p id="d353" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅用 100 万行训练数据(约占所有数据的 10%)和 1 个时期的训练，我们可以获得验证和测试集的 AUC 分数约为 0.73。如果使用更多的数据以更大的训练步长来训练模型，分数很可能会提高。</p><h2 id="3d7b" class="nb lk it bd ll nc nd dn lp ne nf dp lt km ng nh lx kq ni nj mb ku nk nl mf nm bi translated">结论</h2><p id="096b" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">您已经学习了 PyTorch Geometric 的基本用法，包括数据集构造、自定义图层以及用真实数据训练 gnn。这篇文章中的所有代码也可以在<a class="ae kz" href="https://github.com/khuangaf/Pytorch-Geometric-YooChoose" rel="noopener ugc nofollow" target="_blank">我的 Github repo </a>中找到，在那里你可以找到另一个 Jupyter 笔记本文件，我在其中解决了 RecSys Challenge 2015 的第二个任务。我希望你喜欢这篇文章。如果您有任何问题或意见，请在下面留下！确保在<a class="ae kz" href="https://twitter.com/steeve__huang" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我，我会在那里分享我的博客帖子或有趣的机器学习/深度学习新闻！和 PyG 玩 GNN 玩得开心！</p></div></div>    
</body>
</html>