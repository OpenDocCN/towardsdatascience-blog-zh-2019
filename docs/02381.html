<html>
<head>
<title>How to Filter Rows of a Pandas DataFrame by Column Value</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过列值过滤熊猫数据帧的行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-filter-rows-of-a-pandas-dataframe-by-column-value-51996ea621f8?source=collection_archive---------1-----------------------#2019-04-19">https://towardsdatascience.com/how-to-filter-rows-of-a-pandas-dataframe-by-column-value-51996ea621f8?source=collection_archive---------1-----------------------#2019-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">过滤行的两种简单方法</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a304cc3e42232f3629a0bf7972c494e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quDY8ikk9Uf0D97JtPs-jQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image Courtesy of Peter Oslanec via <a class="ae ky" href="https://unsplash.com/photos/J-n4Y0ZtGjc" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fa41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常需要根据列值过滤表格数据。我们可能会看到一个表格，并希望执行自定义过滤操作。幸运的是，我们可以利用熊猫来做这个手术。Pandas 是一个用于数据分析的开源 Python 库。它使 Python 能够处理类似电子表格的数据，实现快速文件加载和操作等功能。为了实现这些特性，Pandas 向 Python 引入了两种数据类型:Series 和 DataFrame。</p><p id="5c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将重点介绍通过列值过滤数据帧的两种简单方法。</p><p id="d427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例是 BLAST 搜索的结果。在生物信息学中，BLAST(基本局部比对搜索工具)是一种用于比较一级生物序列信息的算法，例如蛋白质的氨基酸序列或 DNA 和/或 RNA 序列的核苷酸。这个表有一个用数字表示的查询序列的 ID 和与之匹配的物种，以及其他元数据。</p><p id="fb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子完全是任意的，下面的技术可以应用于大量的其他情况。</p><p id="ea92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们导入 pandas 库，并给它起别名 pd</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="289f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我使用熊猫<strong class="lb iu"> <em class="lx"> read_csv() </em> </strong>函数读取我的数据帧。我用文件扩展名保存了我的数据帧。csv(逗号分隔值文件)。接下来，我执行一些基本操作来熟悉数据帧。下面显示的是我常用的三种操作。其中包括:使用 head 方法打印前 5 行，使用 DataFrame 对象的 column 属性访问列名。最后，我查看 DataFrame 对象的 shape 属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="35ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个打印函数的输出如下所示(为了增强表示，我建议对 Jupyter 笔记本运行相同的代码，这将把 pandas DataFrame 对象显示为一个更加浏览器友好的 HTML 表)。shape 属性返回一个元组，该元组在逗号的左侧给出行数，在右侧给出列数。该数据帧有 29 行和 5 列。但是请注意，<em class="lx">只显示前 5 行。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/316c05ce361d1e0eb2fa51d948e6ffb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci3P7QeMPcCxNdvhMI3a2A.png"/></div></div></figure><p id="4957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要过滤该数据帧，以便排除<strong class="lb iu"><em class="lx">Species _ name _ blast _ hit</em></strong>列中的任何“细菌”条目。</p><p id="2373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将如何着手做这件事？</p><p id="4d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将介绍两种选择性过滤表格数据的方法。</p><p id="1cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我创建了一个布尔值的 Python 列表。然后，我编写了一个 for 循环，该循环迭代熊猫系列(系列是数据帧中的一列)。熊猫系列，<strong class="lb iu"><em class="lx">Species _ name _ blast _ hit</em></strong>是一个可迭代的对象，就像一个列表。然后，我在条件语句中使用一个基本的正则表达式，如果“细菌”不在序列值中，则附加 True，如果“细菌”存在，则附加 False。当我打印布尔列表的前 5 个条目时，所有的结果都为真。</p><p id="8fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这完全在意料之中，我们从前面的表格中可以看到，<strong class="lb iu"> <em class="lx">中的前 5 个条目 Species_name_blast_hit </em> </strong>名称中没有细菌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/46b0fa00a4446ea351eba473290e1b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*VaHqjmG2U2ROwZ6oo1x5eQ.png"/></div></figure><p id="3bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我创建了一个布尔列表，其长度与 DataFrame，29 相同。接下来，我将布尔列表转换成 Pandas 系列，并给它分配变量名 Filtered。</p><p id="970a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过向<strong class="lb iu"> <em class="lx"> pd 传递一个列表来创建一个熊猫系列。</em>系列()</strong>功能。</p><p id="c264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我对我的原始 Pandas 数据帧使用布尔子集/索引，使用方括号符号 Blast，并为新数据帧分配变量名<strong class="lb iu"> <em class="lx"> New_blast_df </em> </strong>。在这里，我写了原始的 DataFrame，Blast，后面是方括号，里面是经过过滤的熊猫系列。该系列指示选择哪些行，因为它由真值和假值组成，这些值与 Blast 数据集中的行相对应。</p><p id="7aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从 Jupyter 笔记本输出中可以清楚地看到，所有的“细菌”条目都被忽略了！</p><p id="627a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过检查从原始数据帧中删除的行数，从 shape 属性返回的 New_blast_df 的第一个索引中减去 shape 属性返回的元组的第一个索引。现在，我们可以看到删除了 8 行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/691f668a86e2fc2d1db520ec8022b349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2UHi3yBykM9BzF1f4njqw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/1c983deddf816ce047e612f02707dde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYm_upAt5oa7B5kJun1mfQ.png"/></div></div></figure><p id="4ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，还有一种更简单的方法可以通过列值来划分数据帧的子集。对于这个例子，让我们假设我们只想要包含那些包含物种名‘Phoxinus’的行。</p><p id="ecd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方式使用了<strong class="lb iu"> <em class="lx">包含</em> </strong>的方法。<strong class="lb iu"> <em class="lx">包含</em> </strong>方法返回一个布尔数组，如果每个字符串都包含该模式。要使用它，您需要输入 DataFrame 的名称，然后使用点标记法选择感兴趣的适当列名，接下来是。str 和最后的<strong class="lb iu"> <em class="lx">包含</em> </strong>()。contains 方法还可以找到部分名称条目，因此非常灵活。</p><p id="145a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下. str.contains 区分大小写。要忽略大小写，只需将关键字参数 case 设置为 False，. str.contains(case=False)。这进一步增加了灵活性，但必须谨慎使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/ae97fda65041f19f7204760dc905a988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzMyuAz2h9iiqW8e6dO8rw.png"/></div></div></figure><h1 id="ee5a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">结论</strong></h1><p id="10e3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">本教程演示了两种基于列值过滤表格数据的方法。虽然这里给出的例子利用了单个条件，但是可以容易地应用多个条件来进一步微调滤波输出。</p></div></div>    
</body>
</html>