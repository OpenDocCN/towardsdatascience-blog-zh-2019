<html>
<head>
<title>4 Graph Algorithms on Steroids for data Scientists with cuGraph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 cuGraph 为数据科学家提供 4 种强大的图形算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-graph-algorithms-on-steroids-for-data-scientists-with-cugraph-43d784de8d0e?source=collection_archive---------10-----------------------#2019-09-15">https://towardsdatascience.com/4-graph-algorithms-on-steroids-for-data-scientists-with-cugraph-43d784de8d0e?source=collection_archive---------10-----------------------#2019-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0934480383cefda7a3fb46e993bb329d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2sLo6UO_HUw38Og-"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Networks are everywhere. Photo by <a class="ae jg" href="https://unsplash.com/@dulgier?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anastasia Dulgier</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="abc7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">GPU-&gt;Rapids-&gt;Cugraph-&gt;可扩展图形分析</h2></div><p id="2575" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为数据科学家，我们已经对 Pandas 或 SQL 或任何其他关系数据库驾轻就熟。</p><p id="f2d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们习惯于以行的形式看到用户，以列的形式看到他们的属性。但是现实世界是这样的吗？</p><p id="e141" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个互联的世界中，用户不能被视为独立的实体。它们彼此之间有一定的关系，我们有时希望在构建机器学习模型时包括这种关系。</p><p id="6e62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，虽然在关系数据库中，我们不能在不同的行(用户)之间使用这种关系，但在图形数据库中，这样做相对来说比较简单。</p><p id="5201" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，正如我们所知，Python 有一个很棒的包<code class="fe lu lv lw lx b">Networkx</code>来做这件事。但问题是它不可扩展。</p><p id="a478" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"><em class="ly">GPU 凭借其众多内核和并行性，可以帮助我们解决可扩展性问题。这就是 RAPIDS.ai CuGraph 的用武之地。</em> </strong></p><blockquote class="lz ma mb"><p id="4e6f" class="ky kz ly la b lb lc kk ld le lf kn lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated"><a class="ae jg" href="https://rapids.ai/" rel="noopener ugc nofollow" target="_blank"> RAPIDS </a> cuGraph 库是一个图形分析集合，用于处理 GPU 数据帧中的数据——参见<a class="ae jg" href="https://github.com/rapidsai/cudf" rel="noopener ugc nofollow" target="_blank"> cuDF </a>。cuGraph 旨在提供一个数据科学家熟悉的类似 NetworkX 的 API，因此他们现在可以更容易地构建 GPU 加速的工作流。</p></blockquote><p id="dd20" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将谈论一些你应该知道的最基本的图算法，以及如何用 Python 和 cuGraph 实现它们。 </p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8924" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">装置</h1><p id="4fd6" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">要安装 cuGraph，您可以根据您的系统和配置，使用从<a class="ae jg" href="https://rapids.ai/start.html" rel="noopener ugc nofollow" target="_blank"> rapids.ai </a>中选择的简单命令。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/9cf221938fda09f4312b36d0ae15ad50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLfrFdVoSh9m9N3F9Xm73g.png"/></div></div></figure><p id="e0ee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用的命令如下，并且我使用了夜间构建(推荐):</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="9f0b" class="ns mn jj lx b gy nt nu l nv nw">conda install -c rapidsai-nightly -c nvidia -c numba -c conda-forge -c anaconda cudf=0.10 cuml=0.10 cugraph=0.10</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="37f5" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">1.连接的组件</h1><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/d230be936aa4f398e0a120bc1512cf32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zUKkeYzwRgFpnVEI"/></div></div></figure><p id="fb63" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们都知道聚类是如何工作的？</p><p id="7e46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ly">你可以用非常通俗的术语把连通分量看作是一种硬聚类算法，它在相关/连通数据中寻找聚类/孤岛。</em></p><p id="a06a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ly">举个具体的例子:</em> <strong class="la jk"> <em class="ly">假设你有连接世界上任意两个城市的道路的数据。你需要找出世界上所有的大洲以及它们包含的城市。</em>T24】</strong></p><p id="9e17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你将如何实现这一目标？来吧，考虑一下。</p><p id="2af5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用的连通分量算法是基于<strong class="la jk"> BFS/DFS </strong>的一个特例。我不会在这里谈论它是如何工作的，但是我们将看到如何使用<code class="fe lu lv lw lx b">Networkx</code>和<code class="fe lu lv lw lx b">cuGraph</code>来启动和运行代码。</p><h2 id="edc3" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">应用程序</h2><p id="b6d5" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">从零售的角度来看<strong class="la jk"/>:比方说，我们有很多客户使用很多账户。使用连通分量算法的一种方法是在数据集中找出不同的族。</p><p id="44fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以基于相同的信用卡使用、相同的地址或相同的手机号码等假设客户之间的边(道路)。一旦我们有了这些连接，我们就可以在相同的上运行连接组件算法来创建单独的聚类，然后我们可以为这些聚类分配一个家族 ID。</p><p id="d236" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用这些家庭 id 根据家庭需求提供个性化建议。我们还可以使用这个家族 ID，通过创建基于家族的分组特征来推动我们的分类算法。</p><p id="060c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<strong class="la jk">财务角度</strong>:另一个用例是使用这些家庭 id 来捕获欺诈。如果一个帐户在过去进行过欺诈，则关联的帐户很可能也容易受到欺诈。</p><p id="5c14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可能性只受到你想象力的限制。</p><h2 id="eb0d" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">密码</h2><p id="dd78" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们将使用 Python 中的<code class="fe lu lv lw lx b">Networkx</code>模块来创建和分析我们的图表。</p><p id="9a60" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从一个用于我们目的的示例图开始。包含城市和它们之间的距离信息。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/36cd286443808253caec6823b8b5ed2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjrkUYfaIHHrdhwORwgesw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Graph with Some random distances</figcaption></figure><p id="cd00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先创建一个边和距离的列表，我们将添加边的权重:</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="16fb" class="ns mn jj lx b gy nt nu l nv nw">edgelist = [['Mannheim', 'Frankfurt', 85], ['Mannheim', 'Karlsruhe', 80], ['Erfurt', 'Wurzburg', 186], ['Munchen', 'Numberg', 167], ['Munchen', 'Augsburg', 84], ['Munchen', 'Kassel', 502], ['Numberg', 'Stuttgart', 183], ['Numberg', 'Wurzburg', 103], ['Numberg', 'Munchen', 167], ['Stuttgart', 'Numberg', 183], ['Augsburg', 'Munchen', 84], ['Augsburg', 'Karlsruhe', 250], ['Kassel', 'Munchen', 502], ['Kassel', 'Frankfurt', 173], ['Frankfurt', 'Mannheim', 85], ['Frankfurt', 'Wurzburg', 217], ['Frankfurt', 'Kassel', 173], ['Wurzburg', 'Numberg', 103], ['Wurzburg', 'Erfurt', 186], ['Wurzburg', 'Frankfurt', 217], ['Karlsruhe', 'Mannheim', 80], ['Karlsruhe', 'Augsburg', 250],["Mumbai", "Delhi",400],["Delhi", "Kolkata",500],["Kolkata", "Bangalore",600],["TX", "NY",1200],["ALB", "NY",800]]</span></pre><p id="09cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们想从这个图表中找出不同的大陆和它们的城市。 </p><p id="f9df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要创建一个带边的<code class="fe lu lv lw lx b">cudf</code>数据框。现在，我正在创建一个熊猫数据帧，并将其转换为<code class="fe lu lv lw lx b">cudf</code>数据帧，但在现实生活中，我们将从边缘的<code class="fe lu lv lw lx b">csv</code>文件中读取。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="06e5" class="ns mn jj lx b gy nt nu l nv nw">import cugraph<br/>import cudf<br/>import pandas as pd</span><span id="dc85" class="ns mn jj lx b gy ok nu l nv nw"># create a pandas dataframe of edges<br/>pandas_df = pd.DataFrame(edgelist)<br/>pandas_df.columns = ['src','dst','distance']</span><span id="6a0d" class="ns mn jj lx b gy ok nu l nv nw"># create a pandas dataframe of reversed edges as we have a undirected graph<br/>rev_pandas_df = pandas_df.copy()<br/>rev_pandas_df.columns = ['dst','src','distance']</span><span id="b996" class="ns mn jj lx b gy ok nu l nv nw">rev_pandas_df = rev_pandas_df[['src','dst','distance']]</span><span id="405f" class="ns mn jj lx b gy ok nu l nv nw"># concat all edges<br/>pandas_df = pd.concat([pandas_df,rev_pandas_df])</span></pre><p id="3980" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们的<code class="fe lu lv lw lx b">pandas</code> df 包含两个方向的边。而我们在<code class="fe lu lv lw lx b">src</code>和<code class="fe lu lv lw lx b">dst</code>列中的节点名是<code class="fe lu lv lw lx b">str</code>格式的。显然，<code class="fe lu lv lw lx b">cuGraph</code>不喜欢这样，只使用整数节点 id。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="d2e9" class="ns mn jj lx b gy nt nu l nv nw"># CuGraph works with only integer node IDs<br/>unique_destinations = set()<br/>for [src,dst,dis] in edgelist:<br/>  unique_destinations.add(src)<br/>  unique_destinations.add(dst)</span><span id="c78d" class="ns mn jj lx b gy ok nu l nv nw"># create a map of city and a unique id<br/>city_id_dict = {}<br/>for i, city in enumerate(unique_destinations):<br/>  city_id_dict[city]=i</span><span id="b102" class="ns mn jj lx b gy ok nu l nv nw"># create 2 columns that contain the integer IDs for src and dst<br/>pandas_df['src_int'] = pandas_df['src'].apply(lambda x : city_id_dict[x])<br/>pandas_df['dst_int'] = pandas_df['dst'].apply(lambda x : city_id_dict[x])</span></pre><p id="025f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是我们应该关注的主要部分:</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="1ffd" class="ns mn jj lx b gy nt nu l nv nw">cuda_g = cudf.DataFrame.from_pandas(pandas_df)</span><span id="4872" class="ns mn jj lx b gy ok nu l nv nw"># cugraph needs node IDs to be int32 and weights to be float<br/>cuda_g['src_int'] = cuda_g['src_int'].astype(np.int32)<br/>cuda_g['dst_int'] = cuda_g['dst_int'].astype(np.int32)<br/>cuda_g['distance'] = cuda_g['distance'].astype(np.float)</span><span id="aadc" class="ns mn jj lx b gy ok nu l nv nw">G = cugraph.Graph()<br/>G.add_edge_list(cuda_g["src_int"],cuda_g["dst_int"] , cuda_g['distance'])</span><span id="ffef" class="ns mn jj lx b gy ok nu l nv nw"><strong class="lx jk"><em class="ly">cugraph.weakly_connected_components(G)</em></strong></span></pre><p id="adff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一次调用的输出是一个<code class="fe lu lv lw lx b">cudf</code>数据帧。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5ab389d20e18d4b3f9bfb672ac598dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*aSl1w_1xAaMkocwI8MyPBQ.png"/></div></figure><p id="e79b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，标签对应于连接的组件 ID。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f82e" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">2.最短路径</h1><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/c50a290ebc9d5313ce36566c1d515d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*alP1FjFwZ9yYzAHM"/></div></div></figure><p id="b602" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续上面的例子，我们得到一个图表，上面有德国的城市以及它们之间的距离。</p><p id="12ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">你想找出如何从法兰克福(起点)到慕尼黑的最短距离</strong>。</p><p id="3fcc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用来解决这个问题的算法叫做<strong class="la jk"> Dijkstra </strong>。用 Dijkstra 自己的话说:</p><blockquote class="lz ma mb"><p id="eb09" class="ky kz ly la b lb lc kk ld le lf kn lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">一般来说，从<a class="ae jg" href="https://en.wikipedia.org/wiki/Rotterdam" rel="noopener ugc nofollow" target="_blank">鹿特丹</a>到<a class="ae jg" href="https://en.wikipedia.org/wiki/Groningen" rel="noopener ugc nofollow" target="_blank">格罗宁根</a>的最短旅行方式是什么:从一个城市到另一个城市。<a class="ae jg" href="https://en.wikipedia.org/wiki/Shortest_path_problem" rel="noopener ugc nofollow" target="_blank">是最短路径</a>的算法，我大概二十分钟就设计好了。一天早上，我和我年轻的未婚妻在<a class="ae jg" href="https://en.wikipedia.org/wiki/Amsterdam" rel="noopener ugc nofollow" target="_blank">阿姆斯特丹</a>购物，累了，我们坐在咖啡厅露台上喝一杯咖啡，我在想我是否可以这样做，然后我设计了最短路径的算法。正如我所说，这是一个 20 分钟的发明。事实上，它是在三年后的 59 年出版的。该出版物仍然可读，事实上，相当不错。它如此漂亮的原因之一是我没有用铅笔和纸来设计它。我后来才知道，不用铅笔和纸进行设计的一个好处是，你几乎是被迫避免所有可以避免的复杂性。最终，令我大为惊讶的是，这个算法成了我成名的基石之一。</p><p id="cdf9" class="ky kz ly la b lb lc kk ld le lf kn lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">— Edsger Dijkstra，在与 Philip L. Frana 的访谈中，ACM 通讯，2001<a class="ae jg" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#cite_note-Dijkstra_Interview-3" rel="noopener ugc nofollow" target="_blank">【3】</a></p></blockquote><h2 id="aaf7" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">应用程序</h2><ul class=""><li id="367b" class="on oo jj la b lb ne le nf lh op ll oq lp or lt os ot ou ov bi translated">Dijkstra 算法的变体在谷歌地图中被广泛用于查找最短路线。</li><li id="8a61" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">你在沃尔玛超市。你有不同的过道和过道之间的距离。您希望为顾客提供从通道 A 到通道 d 的最短路径。</li></ul><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/7fd38db595067aafc05aed27d8200c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*D2QhdfY5rQCX-rDoVaEVTw.png"/></div></figure><ul class=""><li id="6c76" class="on oo jj la b lb lc le lf lh pc ll pd lp pe lt os ot ou ov bi translated">你已经看到 LinkedIn 如何显示一级关系，二级关系。幕后发生了什么？</li></ul><h2 id="ab3f" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">密码</h2><p id="6bb5" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们已经有了之前的图表。我们可以找到从一个源节点到图中所有节点的最短距离。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="b1c5" class="ns mn jj lx b gy nt nu l nv nw"># get distances from source node 0<br/>distances = cugraph.sssp(G, 0)</span><span id="5ad7" class="ns mn jj lx b gy ok nu l nv nw"># filter infinite distances<br/>distances = cugraph.traversal.filter_unreachable(distances)</span><span id="b0f9" class="ns mn jj lx b gy ok nu l nv nw">distances</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/37c6a602c9f9c297f4d7fa0bc0d3810a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*qZqkWKWkQrZwRbp-ybm6KA.png"/></div></figure><p id="92ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们必须找到节点 0 和 14 之间的路径，我们可以使用距离<code class="fe lu lv lw lx b">cudf</code>。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="ec8b" class="ns mn jj lx b gy nt nu l nv nw"># Getting the path is as simple as:</span><span id="4df6" class="ns mn jj lx b gy ok nu l nv nw">path = []</span><span id="a898" class="ns mn jj lx b gy ok nu l nv nw">dest = 14<br/>while dest != 0:<br/>   dest = distances[distances['vertex'] == dest]['predecessor'].values[0]<br/>   path.append(dest)</span><span id="30dd" class="ns mn jj lx b gy ok nu l nv nw"># reverse the list and print<br/>print(path[::-1])<br/>-------------------------------------------------------<br/>[0, 11, 9]</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4dbc" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">3.Pagerank</h1><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/63bd2e7d5dcdf54d7c9273104623d683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vlVuoBXlu063bQDO.jpg"/></div></div></figure><p id="e5f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是长期以来为谷歌提供动力的页面排序算法。它根据输入和输出链接的数量和质量给网页打分。</p><h2 id="f985" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">应用程序</h2><p id="aff5" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">Pagerank 可以用在任何我们想要评估任何网络中节点重要性的地方。</p><ul class=""><li id="3163" class="on oo jj la b lb lc le lf lh pc ll pd lp pe lt os ot ou ov bi translated">它已经被用于通过引用来寻找最有影响力的论文。</li><li id="1e87" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">已经被谷歌用来对网页进行排名</li><li id="cf6a" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">它可以用来对 tweets 进行排序——用户和 Tweets 作为节点。如果用户 A 关注用户 B，则在用户之间创建链接；如果用户发推文/转发推文，则在用户和推文之间创建链接。</li><li id="217d" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">推荐引擎</li></ul><h2 id="f1e1" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">密码</h2><p id="d0dd" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在这个练习中，我们将使用脸书的社交网络数据。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="2db5" class="ns mn jj lx b gy nt nu l nv nw"># Loading the file as cudf</span><span id="375a" class="ns mn jj lx b gy ok nu l nv nw">fb_cudf = cudf.read_csv("facebook_combined.txt", sep=' ', names=['src', 'dst'],dtype =['int32','int32'])</span><span id="d93d" class="ns mn jj lx b gy ok nu l nv nw"># adding reverse edges also<br/>rev_fb_cudf = fb_cudf[['dst','src']]<br/>rev_fb_cudf.columns = ['src','dst']<br/>fb_cudf = cudf.concat([fb_cudf,rev_fb_cudf])</span></pre><p id="50eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建图表</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="f354" class="ns mn jj lx b gy nt nu l nv nw"># creating the graph<br/>fb_G = cugraph.Graph()<br/>fb_G.add_edge_list(fb_cudf["src"],fb_cudf["dst"])</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/6bff95ff5f4d357a5802368a290433b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZ7cCQlOuL2X2bIm22DDoQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">FB User Graph</figcaption></figure><p id="872b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们想找到具有高影响力的用户。</p><p id="da68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">直观地说，Pagerank 算法会给一个有很多朋友的用户更高的分数，而这个用户又有很多 FB 朋友。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="9219" class="ns mn jj lx b gy nt nu l nv nw"># Call cugraph.pagerank to get the pagerank scores<br/>fb_pagerank = cugraph.pagerank(fb_G)<br/>fb_pagerank.sort_values(by='pagerank',ascending=False).head()</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/21eef0f18bf6f1a546629fc0451f27df.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*Y8B41bkjoo2c3k7Lbw6QFA.png"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="09af" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">4.链接预测</h1><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/b48c13a4c3e498d455a791a8272fc832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*94jlOPKWp3WtJ1rR"/></div></div></figure><p id="fb29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续我们在脸书的例子。您可能已经在您的脸书帐户中看到了推荐的朋友。如何才能创建我们的小推荐器呢？</p><p id="1ce6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">我们可以根据当前的边来预测未来哪些边会被连接吗？</em> </strong></p><p id="f86f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一种简单快速的方法是使用 Jaccard 系数。</p><h2 id="afd9" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">应用程序</h2><p id="d571" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">链路预测可能有许多应用。我们可以预测</p><ul class=""><li id="5c31" class="on oo jj la b lb lc le lf lh pc ll pd lp pe lt os ot ou ov bi translated">那些打算在一个引用网络中建立合作关系的作者</li><li id="3222" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">谁会成为社交网络中的朋友？</li></ul><h2 id="3f8d" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">想法</h2><p id="62b8" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们计算两个节点 I 和 j 之间的 Jaccard 系数如下:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/04e7c65d7fe31820589ed8e2ee25fd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*-BNpmlEVS1WcSx0s.png"/></div></figure><p id="6a86" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中，分子是 I 和 j 的共同邻居的数量，分母是 I 和 j 的不同邻居的总数。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/1fec06f5e5d2de694c862fa9827fd277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtmRpArI3G-1-ox-Gjtnng.png"/></div></div></figure><p id="bb65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在图中，一半红色和一半绿色的节点是 A 和 b 的共同邻居，它们总共有 5 个不同的邻居。所以 JaccardCoeff(A，B)是 2/5</p><h2 id="7ca5" class="ns mn jj bd mo ny nz dn ms oa ob dp mw lh oc od my ll oe of na lp og oh nc oi bi translated">密码</h2><p id="e58c" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们首先用所有可能的节点组合创建一个<code class="fe lu lv lw lx b">cudf_nodes</code> cudf。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="7aa6" class="ns mn jj lx b gy nt nu l nv nw">max_vertex_id = fb_pagerank['vertex'].max()<br/>data = []<br/>for x in range(0,max_vertex_id+1):<br/>  for y in range(0,max_vertex_id+1):<br/>    data.append([x,y])<br/>cudf_nodes =cudf.from_pandas(pd.DataFrame(data))<br/>cudf_nodes.columns = ['src','dst']</span><span id="3fa9" class="ns mn jj lx b gy ok nu l nv nw">cudf_nodes['src'] = cudf_nodes['src'].astype(np.int32)<br/>cudf_nodes['dst'] = cudf_nodes['dst'].astype(np.int32)</span></pre><p id="652a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以计算节点之间的 Jaccard 系数，如下所示:</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="8512" class="ns mn jj lx b gy nt nu l nv nw">jaccard_coeff_between_nodes = cugraph.link_prediction.jaccard(fb_G,cudf_nodes["src"],cudf_nodes["dst"])<br/>jaccard_coeff_between_nodes.head()</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/191e661cdd5fd382a204e2bfafc169a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*mV-nEuauYQa7BKM943z14w.png"/></div></figure><p id="78d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">但我们仍未完成。</em> </strong>我们需要去掉<code class="fe lu lv lw lx b">source==destination</code>处的边和图中已经存在的边。我们将使用简单的连接和过滤操作来实现这一点，这些操作与 pandas 非常相似。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="29c9" class="ns mn jj lx b gy nt nu l nv nw">jaccard_coeff_between_nodes=jaccard_coeff_between_nodes[jaccard_coeff_between_nodes['source']!=jaccard_coeff_between_nodes['destination']]<br/>fb_cudf.columns = ['source', 'destination']<br/>fb_cudf['edgeflag']=1<br/>jaccard_coeff_joined_with_edges = jaccard_coeff_between_nodes.merge(fb_cudf,on= ['source', 'destination'],how='left')<br/># We just want to see the jaccard coeff of new edges<br/>new_edges_jaccard_coeff = jaccard_coeff_joined_with_edges[jaccard_coeff_joined_with_edges['edgeflag']!=1]</span></pre><p id="d835" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们最终排序的数据帧，带有未连接节点之间的 Jaccard 系数。我们知道向我们的平台用户推荐什么样的朋友。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="ad0e" class="ns mn jj lx b gy nt nu l nv nw">new_edges_jaccard_coeff.sort_values(by='jaccard_coeff',ascending=False)</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/132f2db09f02142bb16f044ca09af18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRmYPhw3Hrs6MFPrnW-cUQ.png"/></div></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="0ffc" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">基本网络统计</h1><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi po"><img src="../Images/92ae5eb9e1cc8940d1dc5ce1b02b3608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PvbQAPTDtaceicjp"/></div></div></figure><p id="41ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于你的网络，有很多你想知道的基本措施。</p><p id="8530" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是你如何让他们进入你的社交网络</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="6e0f" class="ns mn jj lx b gy nt nu l nv nw">print("Number of Nodes",fb_G.number_of_nodes())<br/>print("Number of Edges",fb_G.number_of_edges())<br/>------------------------------------------------------<br/>Number of Nodes 4039 <br/>Number of Edges 176468</span></pre><p id="f159" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以计算每个节点的 indegree 和 outdegree。</p><p id="4f1b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在有向图中，这对应于追随者的数量和追随者的数量。</p><pre class="nk nl nm nn gt no lx np nq aw nr bi"><span id="15a4" class="ns mn jj lx b gy nt nu l nv nw">fb_G.degrees().head()</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/151e4b61164ba9252998bb36cde361ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*lZJUToSDGGwooANsvzfcag.png"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="48db" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">性能基准</h1><p id="1010" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">如果我不为不同的算法添加特定的基准，我就不能公正地对待这篇文章。</p><p id="e7fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的基准研究中，我使用了斯坦福大学大型网络数据集集合中的三个数据集，按规模递增的顺序排列。</p><ol class=""><li id="9826" class="on oo jj la b lb lc le lf lh pc ll pd lp pe lt pq ot ou ov bi translated"><a class="ae jg" href="https://snap.stanford.edu/data/ego-Facebook.html" rel="noopener ugc nofollow" target="_blank">自我-脸书</a>:来自脸书的无向图，有<strong class="la jk"> <em class="ly">个 4 K 节点和 88 K 条边</em> </strong></li><li id="5aa5" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt pq ot ou ov bi translated"><a class="ae jg" href="https://snap.stanford.edu/data/ego-Twitter.html" rel="noopener ugc nofollow" target="_blank">自我推特</a>:有向图，有<strong class="la jk"> <em class="ly"> 81 K 个节点和 1.7 米</em> </strong>条边</li><li id="7fb1" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt pq ot ou ov bi translated"><a class="ae jg" href="https://snap.stanford.edu/data/ego-Gplus.html" rel="noopener ugc nofollow" target="_blank"> ego-Gplus </a>:来自 Google+的带有<strong class="la jk"> <em class="ly"> 107 K 个节点和 13.6 M </em> </strong>条边的有向图</li></ol><p id="8114" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我在 NVIDIA <a class="ae jg" href="https://amzn.to/2OaF9uq" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> <em class="ly">特斯拉 V100 32 GB GPU </em> </strong> </a>上进行的实验结果。感谢 NVIDIA 的 Josh Patterson 和 Walmart Labs 的 Richard Ulrich 为我做的安排。所有时间都以毫秒为单位:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/3fad6d9c060a43a3d247e2e2435214b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*my4glJFCR0qyCPhF1v8j3g.png"/></div></figure><p id="4408" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我没有在结果中添加 Jaccard 系数，因为它甚至不能在使用 networkX 的 facebook 上运行。对于 cuGraph，它有毫秒级的延迟。</p><p id="d5b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们想象一下这些结果:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pu"><img src="../Images/cc615014c4da1dc39729c83da5cb1b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JU4xkc3messIBVcsPnZ3g.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Scales well for Weakly Connected Components compared to NetworkX</figcaption></figure><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/9d84be3ab701cc1897095b2b71dd5ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtBaUVHRSJhWalWjBNuU3Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">cuGraph is pretty good with shortest paths. As you can see, the algorithm takes negligible time compared to networkX</figcaption></figure><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pv"><img src="../Images/1575f5fdbb32dff63c2dabfc4c71dc5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqkXOyPbS7BkzNZ6o3Zlrw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">It is on PageRank that cuGraph truly shines. NetworkX is not at all viable for PageRank when compared with cuGraph.</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5b2e" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">警告</h1><p id="8af8" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">Rapids <code class="fe lu lv lw lx b">cuGraph</code>是一个优秀的图形分析库，但是我感觉还缺少一些东西。也许我们会在下一个版本中得到它们。</p><ul class=""><li id="c5f6" class="on oo jj la b lb lc le lf lh pc ll pd lp pe lt os ot ou ov bi translated">有点不方便，我们只能使用数据类型为 int32 的编号节点。重新编号有助于解决这个问题。查看我的笔记本中的<a class="ae jg" href="https://github.com/MLWhiz/data_science_blogs/tree/master/cuGraph_Benchmark" rel="noopener ugc nofollow" target="_blank">基准</a>以获得准确的代码。检查函数<code class="fe lu lv lw lx b">cugraph.symmetrize_df</code>来创建无向图。</li><li id="1d26" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">有些算法还没有实现。例如，我找不到 MST、中心性度量等。</li><li id="8dcb" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">需要更多示例笔记本来记录最佳实践。我可能会去做其中的一些。</li><li id="2cfe" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">库中没有可视化组件。我必须去<code class="fe lu lv lw lx b">networkx</code>绘制图表。</li></ul><p id="7b03" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">但尽管如此，我还想补充一点，用 GPU 提供图形分析的想法太棒了，我可以忍受这些小问题。</em> </strong>以及他们让 API 与<code class="fe lu lv lw lx b">pandas</code>和<code class="fe lu lv lw lx b">networkx</code>如此相似的方式增加了它的价值。</p><p id="8228" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">我记得以前用 GPU 需要很多代码。RAPIDS 的目标是让 GPU 无处不在，这是一个了不起的创举。</em> </strong></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f481" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">结论</h1><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pw"><img src="../Images/d6e9a30fbade2bc14ef19d6dfcd92a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yxhRhSYLEHf6KheL"/></div></div></figure><p id="8cf4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">在这篇文章中，我谈到了一些改变了我们生活方式的最强大的图形算法，以及如何用 GPU 来扩展它们。</em> </strong></p><p id="7a64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢 Rapids AI 一直致力于让典型的开发人员/数据科学家能够访问 GPU 的方式，并且认为我们直到一年前才听说过它。他们已经走了很长的路。</p><p id="0d77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，这里是最新的 0.9 版本的文件为<code class="fe lu lv lw lx b"><a class="ae jg" href="https://docs.rapids.ai/api/cudf/stable/" rel="noopener ugc nofollow" target="_blank">cuDF</a></code>和<code class="fe lu lv lw lx b"><a class="ae jg" href="https://docs.rapids.ai/api/cugraph/stable/" rel="noopener ugc nofollow" target="_blank">cuGraph</a></code>。</p><p id="22b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这个<a class="ae jg" href="https://colab.research.google.com/drive/1quS3-yg6frFo__4VyJTyUytHhqnBQ9j_" rel="noopener ugc nofollow" target="_blank"> Google Colab 笔记本</a>中获得运行代码，在我的<a class="ae jg" href="https://github.com/MLWhiz/data_science_blogs/tree/master/cuGraph_Benchmark" rel="noopener ugc nofollow" target="_blank"> Github 存储库</a>中获得带有基准的代码，因为 Google Colab 在基准测试时缺乏资源。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="06a1" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">继续学习</h1><p id="9202" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">如果你想阅读更多关于图算法的内容，这里有一个由 UCSanDiego 在 Coursera 上开设的<a class="ae jg" href="https://coursera.pxf.io/YgKbbe" rel="noopener ugc nofollow" target="_blank">大数据图分析课程，我强烈推荐你学习图论的基础知识。</a></p><p id="16f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae jg" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"> <strong class="la jk">媒体</strong> </a>关注我，或者订阅我的<a class="ae jg" href="http://eepurl.com/dbQnuX?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p><p id="5f5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，一个小小的免责声明——在这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p></div></div>    
</body>
</html>