<html>
<head>
<title>Expose endpoints using Jupyter Kernel Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Jupyter 内核网关公开端点</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/expose-endpoints-using-jupyter-kernel-gateway-e55951b0f5ad?source=collection_archive---------14-----------------------#2019-02-07">https://towardsdatascience.com/expose-endpoints-using-jupyter-kernel-gateway-e55951b0f5ad?source=collection_archive---------14-----------------------#2019-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/631a8084b2016e09dcb81870dc9a7e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PlDlJkDSrntBjG0v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nknezevic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nikola Knezevic</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a8c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在浏览中型文章时，我偶然发现了 Jupyter 内核网关，它对我来说是全新的。所以，我也探索了一样。我发现了它的文档，并决定实施一个项目来更好地理解它。</p><blockquote class="lb lc ld"><p id="6b90" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">Jupyter 内核网关是一个 web 服务器，提供对 Jupyter 内核的无头访问。— <a class="ae kc" href="https://github.com/jupyter/kernel_gateway" rel="noopener ugc nofollow" target="_blank"> Jupyter 内核网关回购</a></p></blockquote><p id="d36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，该服务允许我们与任何给定的 Jupyter 笔记本的 Jupyter 细胞进行交互，然后相应地使用这些信息。支持<code class="fe li lj lk ll b">GET</code>、<code class="fe li lj lk ll b">POST</code>、<code class="fe li lj lk ll b">PUT</code>和<code class="fe li lj lk ll b">DELETE</code>。让我们一起开始这段旅程吧。你可以在这里查看我的知识库<a class="ae kc" href="https://github.com/kb22/House-Price-Predictions" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="fdd4" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">关于项目</h1><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/012133eddae00117ef19803041f3c59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u9llLH6MCYXayA9l"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brenoassis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Breno Assis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个项目中，我们将使用来自<code class="fe li lj lk ll b">sklearn</code>的加州住房数据集，在其上训练一个<code class="fe li lj lk ll b">Random Forest Regressor</code>模型，然后预测房价。我们将设置一个<code class="fe li lj lk ll b">GET</code>调用来获取数据集的统计数据，并设置一个<code class="fe li lj lk ll b">POST</code>端点来获取具有给定特征集的房屋的预测价格。</p><p id="4aeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这篇文章是关于 Kernel Gateway 的，而不是关于加州住房的机器学习项目本身，我将跳过它的细节，但将解释笔记本的相关单元。笔记本位于<a class="ae kc" href="https://github.com/kb22/House-Price-Predictions/blob/master/House%20Price%20Prediction.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="9900" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">基础</h1><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/5b0fe4a9548565c8f1bcf664fb9538eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L4aZ30l0yEtvs-LV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mimithian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mimi Thian</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7fff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们先来看一下 Jupyter 内核网关的基础知识。</p><h2 id="6ca8" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">定义端点</h2><p id="5169" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们需要用注释开始我们想要创建为端点的单元格。如果我们想要创建一个路径为<code class="fe li lj lk ll b">/housing_stats</code>的<code class="fe li lj lk ll b">GET</code>端点，它被定义为:</p><pre class="ml mm mn mo gt nh ll ni nj aw nk bi"><span id="aa74" class="mq ln iq ll b gy nl nm l nn no"># GET /housing_stats</span></pre><p id="4e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们定义 Python 代码并处理数据。在单元中完成所有工作后，我们定义端点的响应。它被定义为一个带有 JSON 值的<code class="fe li lj lk ll b">print()</code>命令。因此，如果我们必须在参数<code class="fe li lj lk ll b">total_houses</code>中返回数据集中房屋的总数，我们将其定义为:</p><pre class="ml mm mn mo gt nh ll ni nj aw nk bi"><span id="7847" class="mq ln iq ll b gy nl nm l nn no">print(json.dumps({<br/>  'total_houses': 20640<br/>}))</span></pre><p id="9f28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这么简单。如果需要，我们可以将功能扩展到更复杂的解决方案。因此，每个端点 Jupyter 单元将类似于下面的 Github 要点:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="926e" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">启动服务器</h2><p id="fc4b" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">要启动服务器，有一个非常简单的命令。我们将使用名为<code class="fe li lj lk ll b">House Price Prediction</code>的 Jupyter 笔记本。同样的将在<code class="fe li lj lk ll b">0.0.0.0:9090</code>上市。代码如下:</p><pre class="ml mm mn mo gt nh ll ni nj aw nk bi"><span id="9580" class="mq ln iq ll b gy nl nm l nn no">jupyter kernelgateway --api='kernel_gateway.notebook_http' --seed_uri='House Price Prediction.ipynb' --port 9090</span></pre><p id="92f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要您计划在不同的项目上工作，只需更改端口号和/或 Jupyter 笔记本名称。</p><h1 id="08cd" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">获取和发布端点</h1><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/c005e3d06d6e4bf4adaf7045d5b58d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RQsqORIFnNi_jL-V"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mathyaskurmann?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mathyas Kurmann</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9f8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在笔记本中设置我们的端点。</p><h2 id="18ed" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">获取端点</h2><p id="ef1b" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">第一行包含单词<code class="fe li lj lk ll b">GET</code>来定义它是一个 GET 端点，然后是路径<code class="fe li lj lk ll b">/housing_stats</code>。我们提取数据集中的所有房屋，所有房屋的最大值和所有房屋的最小值。此外，根据我在笔记本中的分析，我发现最重要的特征是区块的<em class="le">中值收入。因此，我将所有这些值转储到一个<code class="fe li lj lk ll b">JSON</code>中，并将其放在打印命令中。print 命令定义了该端点的响应。</em></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="a97e" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">终点后</h2><p id="4493" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">现在，我想使用我训练过的机器学习模型来预测任何具有给定功能集的新房子的价格。因此，我使用这个端点来发布我的功能，并获得作为预测价格的响应。</p><p id="b42a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我通过将单元格定义为路径为<code class="fe li lj lk ll b">/get_prices</code>的<code class="fe li lj lk ll b">POST</code>端点来开始该单元格。请求数据包含在对象<code class="fe li lj lk ll b">REQUEST</code>内，键<code class="fe li lj lk ll b">body</code>内。因此，我首先加载请求，然后从<code class="fe li lj lk ll b">body</code>标签中读取所有值，并将其转换成一个 Numpy 数组。然而，形状是不正确的，因此，我使用 Numpy 的函数<code class="fe li lj lk ll b">reshape</code>来纠正它。然后我预测价格。它返回一个预测价格的数组，该数组只有一个值，所以我将该值读入变量<code class="fe li lj lk ll b">predicted_price</code>。我将其重新格式化为两位小数，并乘以<code class="fe li lj lk ll b">100000</code>，因为值的单位是 100，000。最后，我通过将该值附加到一个字符串并放入 print 命令中来返回值。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="7e5e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">提出请求</h1><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/06aff05b2083024d39460beb66b2d266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gtsfSyXm7ufDb97y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Gold</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="57b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们按照步骤与我们的端点进行交互:</p><ol class=""><li id="9e36" class="ns nt iq kf b kg kh kk kl ko nu ks nv kw nw la nx ny nz oa bi translated">启动你的 Jupyter 笔记本。我把我的笔记本命名为<code class="fe li lj lk ll b">House Price Prediction</code>，所以我开始也一样。</li><li id="4ec0" class="ns nt iq kf b kg ob kk oc ko od ks oe kw of la nx ny nz oa bi translated">启动服务器。使用我在上面定义的命令，您的服务器将在<code class="fe li lj lk ll b">http://0.0.0.0:9090</code>开始运行。</li><li id="bd17" class="ns nt iq kf b kg ob kk oc ko od ks oe kw of la nx ny nz oa bi translated">最后，决定从哪里调用端点。您可以使用名为<code class="fe li lj lk ll b">Postman</code>的工具，或者创建一个网页来进行这些呼叫，或者您可以简单地创建另一个笔记本来呼叫这些端点。</li></ol><p id="7f94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们将创建一个笔记本<code class="fe li lj lk ll b">Requests</code>并使用 Python 中的<code class="fe li lj lk ll b">requests</code>包来调用这些端点并获得结果。</p><h2 id="d1d7" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">建立</h2><p id="3a96" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">让我们创建一个新的 Jupyter 笔记本<code class="fe li lj lk ll b">Requests</code>。我们将把<code class="fe li lj lk ll b">requests</code>包导入到笔记本中，它用于调用 Python 中的端点。然后，我们将变量<code class="fe li lj lk ll b">URL</code>中的基本 url 指定为<code class="fe li lj lk ll b"><a class="ae kc" href="http://0.0.0.0:9090." rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:9090</a></code>。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="24b4" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">发出 GET 请求</h2><p id="a2ca" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们使用<code class="fe li lj lk ll b">request.get()</code>发出 get 请求，并指定完整的 URL，即<code class="fe li lj lk ll b"><a class="ae kc" href="http://0.0.0.0:9090." rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:9090</a>/housing_stats</code>，并将其保存在变量<code class="fe li lj lk ll b">stats</code>中。然后，我们从该变量加载<code class="fe li lj lk ll b">JSON</code>。对于每个键值对，我们打印相同的内容。</p><p id="765c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe li lj lk ll b">stats</code>有应答对象。为了获得编码的内容，我们使用<code class="fe li lj lk ll b">content</code>后跟<code class="fe li lj lk ll b">decode('UTF-8)</code>。然后迭代结果。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="44b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经在上面的 Github Gist 中添加了结果作为注释。端点用所有房屋、它们的最高和最低价格以及预测任何房屋价格的最重要因素来响应。</p><h2 id="7159" class="mq ln iq bd lo mr ms dn ls mt mu dp lw ko mv mw ma ks mx my me kw mz na mi nb bi translated">提出发布请求</h2><p id="7f42" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这里，我们将使用<code class="fe li lj lk ll b">requests.post()</code>来发出 POST 请求。我们首先指定完整的 URL，即<code class="fe li lj lk ll b"><a class="ae kc" href="http://0.0.0.0:9090." rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:9090</a>/get_price</code>。我们以 JSON 的形式发送特性。您可以随意更改这些值，并查看对预测价格的影响。然后，我们从端点加载结果，并打印我们得到的结果。</p><p id="7561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe li lj lk ll b">expected_price</code>有响应对象。为了获得编码的内容，我们使用<code class="fe li lj lk ll b">content</code>后跟<code class="fe li lj lk ll b">decode('UTF-8)</code>。然后读取结果，其<code class="fe li lj lk ll b">result</code>字段具有我们的实际响应。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的评论回复中，您可以看到对于给定的一组特性，房子的预测价格是 210，424 美元。</p><h1 id="a378" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="f1db" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在本文中，我们讨论了 Jupyter 内核网关，它允许我们将 Jupyter 笔记本单元转换为 REST 端点，我们可以调用这些端点并从中获得响应。然后，我们通过一个示例项目探索了相同的用法。要了解更多信息，您应该查看 Jupyter 内核网关的文档。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="41e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随时分享你的想法，想法和建议。我们随时欢迎您的反馈。</p></div></div>    
</body>
</html>