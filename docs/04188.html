<html>
<head>
<title>A Python Beginner’s Look at .loc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 初学者的看法。通信线路（LinesofCommunication）</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-python-beginners-look-at-loc-part-1-cb1e1e565ec2?source=collection_archive---------7-----------------------#2019-07-01">https://towardsdatascience.com/a-python-beginners-look-at-loc-part-1-cb1e1e565ec2?source=collection_archive---------7-----------------------#2019-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5e93" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从熊猫数据框架中选择行和列</h2></div><p id="0833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个 Python 初学者，使用<code class="fe lb lc ld le b">.loc</code>来检索和更新 pandas 数据帧中的值对我来说并不合适。Python 不断扔给我的<code class="fe lb lc ld le b">SettingWithCopyWarning</code>消息清楚地表明我需要使用它，但感觉像是大量的试错消息来让它做我需要的事情。</p><p id="3056" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我坐下来玩了足够多的时间，现在我开始感到舒服了，所以我想我应该分享我的漫游；如果你是初学者，希望它能帮助你。在这篇文章中，我将讲述如何通过<code class="fe lb lc ld le b">.loc</code>从<em class="lf">获取</em>数据；我将在未来的<a class="ae lg" href="https://medium.com/@ljhopkins/a-python-beginners-look-at-loc-part-2-bddef7dfa7f2" rel="noopener">文章</a>中讲述<em class="lf">如何设置</em>数据。</p><p id="ac91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在亚特兰大大会上第一周的<a class="ae lg" href="https://generalassemb.ly/education/data-science-immersive" rel="noopener ugc nofollow" target="_blank">数据科学沉浸式课程时，使用了一个神奇宝贝数据集(<code class="fe lb lc ld le b">#dadjokes</code>)进行了“探索”。</a></p><p id="1c73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是<code class="fe lb lc ld le b">df.head(10)</code>的样子:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/9f55e345de53d3219c6a8b09b79b4a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DY9dYY6vAhR2F97hbE0kyQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Header for the Pokémon dataframe I tested with</figcaption></figure><h1 id="764a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">使用检索数据。通信线路（LinesofCommunication）</h1><h2 id="296a" class="mp ly iq bd lz mq mr dn md ms mt dp mh ko mu mv mj ks mw mx ml kw my mz mn na bi translated">可索引属性，而不是方法</h2><p id="1a0a" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">我的第一个提示是<code class="fe lb lc ld le b">.loc</code>不是一个数据帧<em class="lf">方法</em>；一个周六，用<code class="fe lb lc ld le b">()</code>代替<code class="fe lb lc ld le b">[]</code>花了我 45 分钟。在这些方括号中，<code class="fe lb lc ld le b">.loc</code>接受两个输入:一个行“索引器”和一个(可选的，用逗号分隔)列“索引器”:没有其他参数，像<code class="fe lb lc ld le b">inplace</code>或<code class="fe lb lc ld le b">axis</code>。</p><h2 id="fb18" class="mp ly iq bd lz mq mr dn md ms mt dp mh ko mu mv mj ks mw mx ml kw my mz mn na bi translated">单个标签、切片和列表</h2><p id="0d5f" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">那么你能用什么作为索引器呢？pandas 文档列出了允许的输入，它讨论的第一个是单个标签，所以让我们开始吧。</p><p id="9674" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递一个索引器(因为这个数据帧是 RangeIndex，我们传递一个整数)将返回一个 pandas 系列，其中包含具有该索引值的行的数据，在本例中是小火龙:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="88b1" class="mp ly iq le b gy nk nl l nm nn">df.loc[4]</span><span id="7bf9" class="mp ly iq le b gy no nl l nm nn">Name              Charmander<br/>Type                    Fire<br/>Total                    309<br/>HP                        39<br/>Attack                    52<br/>Defense                   43<br/>SpecialAttack             60<br/>SpecialDefense            50<br/>Speed                     65<br/>Name: 4, dtype: object</span></pre><p id="baa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">.loc</code>将<strong class="kh ir">总是</strong>将整数解释为标签，而不是沿着索引的整数位置(你可以使用<code class="fe lb lc ld le b"><a class="ae lg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html" rel="noopener ugc nofollow" target="_blank">.iloc</a></code>来解释)。</p><p id="4691" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只传递一个<strong class="kh ir">列标签</strong>或一个<strong class="kh ir">空白行索引器</strong>会给你一个错误，因为括号索引的第一个位置是寻找<em class="lf">行</em>索引，它是必需的:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="39e0" class="mp ly iq le b gy nk nl l nm nn">&gt;&gt;&gt;df.loc['Type']<br/>KeyError: 'Type'</span><span id="6bdc" class="mp ly iq le b gy no nl l nm nn">&gt;&gt;&gt;df.loc[, 'Type']<br/>SyntaxError: invalid syntax</span></pre><p id="0dde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在使用<a class="ae lg" href="https://stackoverflow.com/questions/509211/understanding-slice-notation" rel="noopener ugc nofollow" target="_blank"> Python 切片符号</a>指定您想要的行(例如<code class="fe lb lc ld le b">[:]</code>指定所有行)之后，传递列标签将得到 pandas 系列中的列数据。注意，与通常的 Python 约定不同，<code class="fe lb lc ld le b"><strong class="kh ir">.loc</strong></code> <strong class="kh ir">切片包括两个端点</strong>:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="2234" class="mp ly iq le b gy nk nl l nm nn">df.loc[:5,'Type']</span><span id="8642" class="mp ly iq le b gy no nl l nm nn">0    GrassPoison<br/>1    GrassPoison<br/>2    GrassPoison<br/>3    GrassPoison<br/>4           Fire<br/>5           Fire<br/>Name: Type, dtype: object</span></pre><p id="3d25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">行和列索引名的切片能力是<code class="fe lb lc ld le b">.loc</code>的一个很好的优势，因为数据帧上的普通括号符号不允许这样做:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="d6b5" class="mp ly iq le b gy nk nl l nm nn">df.loc[:5,'Type':'Speed']</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi np"><img src="../Images/5fd52042310929075c8aed275dfe96bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_1pl5f4Jz6lCk1lvXKpbw.png"/></div></div></figure><p id="af1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以传递带有行或列索引名称的列表<a class="ae lg" href="https://www.digitalocean.com/community/tutorials/understanding-lists-in-python-3" rel="noopener ugc nofollow" target="_blank">来获取数据的子集。(</a><a class="ae lg" href="https://medium.com/better-programming/list-comprehension-in-python-8895a785550b" rel="noopener">列表理解</a>工作也是！):</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="e66e" class="mp ly iq le b gy nk nl l nm nn">df.loc[[2,4,10,99],['Name','HP']]</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4987a070a731b4335d66016b78ec5fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*5Q6ESCQyP3QwjFahBEcs6w.png"/></div></figure><h2 id="b038" class="mp ly iq bd lz mq mr dn md ms mt dp mh ko mu mv mj ks mw mx ml kw my mz mn na bi translated">布尔列表</h2><p id="16ff" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">您可以作为索引器传递的最后一种类型的值是布尔数组，或者是一列<code class="fe lb lc ld le b">True</code>和<code class="fe lb lc ld le b">False</code>值。当我们开始使用<code class="fe lb lc ld le b">.loc</code>到<em class="lf">设置</em>值时，这种方法有一些真正的力量和巨大的应用。对应于索引器中<code class="fe lb lc ld le b">False</code>值的行和列将被过滤掉。数组的大小不必与对应的索引相同，但是<code class="fe lb lc ld le b">.loc</code>会将丢失的值视为<code class="fe lb lc ld le b">False</code>:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="1a71" class="mp ly iq le b gy nk nl l nm nn">df.loc[<br/>       [True, False, False, True, True],<br/>       [True, False, True, False, False, True]<br/>]</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nr"><img src="../Images/a135c5f68491b8bbecd9df3f4c432bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*lAm393_2fqArei5Q03IaPg.png"/></div></div></figure><p id="de0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以使用<a class="ae lg" href="https://jakevdp.github.io/PythonDataScienceHandbook/02.06-boolean-arrays-and-masks.html" rel="noopener ugc nofollow" target="_blank">布尔掩码</a>来生成您传递给<code class="fe lb lc ld le b">.loc</code>的布尔数组。如果我们只想看到“火”类型的神奇宝贝，我们将首先生成一个布尔掩码— <code class="fe lb lc ld le b">df[‘Type’] == ‘Fire’</code> —它为数据帧中的每一行返回一系列<code class="fe lb lc ld le b">True/False</code>值。然后，我们将该掩码作为行索引器在<code class="fe lb lc ld le b">.loc</code>中传递:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="3353" class="mp ly iq le b gy nk nl l nm nn">df.loc[df['Type'] == 'Fire']</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ns"><img src="../Images/7565d12d924ae95a7f74d93e8f6f17f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SXNIeiJtmhhuJTS4RgERQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">The first several rows of the Boolean-filtered dataframe.</figcaption></figure><p id="df2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有各种可能性，比如获得超过 175 次攻击的神奇宝贝:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="93dd" class="mp ly iq le b gy nk nl l nm nn">df.loc[df['Attack'] &gt; 175]</span></pre><p id="8327" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者那些生命值少于 100 而总属性超过 650 的人:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="a17b" class="mp ly iq le b gy nk nl l nm nn">df.loc[(df['HP'] &lt; 100) &amp; (df['Total'] &gt; 650)]</span></pre><p id="55be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者那些名字中带有字母“X”或“灵媒”类型的人:</p><pre class="li lj lk ll gt ng le nh ni aw nj bi"><span id="0b93" class="mp ly iq le b gy nk nl l nm nn">df.loc[<br/>    (df['Name'].str.contains('X')) |     <br/>    (df['Type'].str.contains('PsychicFairy'))<br/>]</span></pre></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="bf7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，您可以在数据帧上用普通的括号符号来完成大部分工作，那么有什么特别的呢？在<a class="ae lg" href="https://medium.com/@ljhopkins/a-python-beginners-look-at-loc-part-2-bddef7dfa7f2" rel="noopener">这篇文章</a>中，我将讨论<code class="fe lb lc ld le b">.loc</code>如何允许你<em class="lf">在数据帧中设置</em>值。</p></div></div>    
</body>
</html>