<html>
<head>
<title>Coding &amp; World Language Lit: Analyzing Dante’s Inferno with Python NLTK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码与世界语言文学:用 Python NLTK 分析但丁的《地狱》</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coding-foreign-language-lit-analyzing-dantes-inferno-with-python-nltk-419124c9eb44?source=collection_archive---------14-----------------------#2019-01-10">https://towardsdatascience.com/coding-foreign-language-lit-analyzing-dantes-inferno-with-python-nltk-419124c9eb44?source=collection_archive---------14-----------------------#2019-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/cdde3a7da180359261875c53c098d357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNMVH73gf1abBtRbPpNPiQ.jpeg"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/photos/7W_ZvKSxQcA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">DR. Alexandru STAVRICĂ</a> on <a class="ae kg" href="https://unsplash.com/search/photos/milan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b4bb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">本初级教程向您展示如何使用 Python NLTK(自然语言工具包)分析外语文本，这是一个自然语言处理平台，允许您将单词分解为词干，并确定文本中最常用的单词。</p><p id="a753" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">计算机科学可以连接到任何其他学科——所以如果你对编程感兴趣<em class="lf">和</em>梦想在意大利别墅的生活，这个教程就是为你准备的！</p><p id="b06a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在本教程中，我们将通过词频来分析但丁的<em class="lf">地狱</em>的文本。《地狱》是一首 14 世纪的意大利诗歌，详细描述了作者虚构的地狱之旅。作者但丁由罗马诗人维吉尔带领，他带他参观了地狱的九层。</p><p id="9837" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">虽然这首诗已被翻译成英语，但原诗是用意大利语写的。你能预料到分析一首意大利诗歌的词频会有什么问题吗？</p><p id="a32e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">考虑一下罗曼语和英语中的动词变化。在英语中，你可以说“我说”和“你说”，而“说”这个词不会改变。主语(做动作的人)用单独的词“我”和“你”来表示但是在意大利语中——很像西班牙语和其他罗曼语——我不得不说<em class="lf">parl</em><strong class="kj iu"><em class="lf">o</em></strong>(我说)和<em class="lf">parl</em><strong class="kj iu"><em class="lf">I</em></strong>(你说)，通过单词的结尾表示主语。</p><p id="fe56" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因此，如果我们分析但丁的<em class="lf">地狱</em>中的词的频率，那么<em class="lf"> parlo </em>和<em class="lf"> parli </em>会被算作同一个词吗，来自不定式<em class="lf"> parlare </em>？不会，因为电脑很笨，不懂意大利语。幸运的是，有一个解决方案！</p><p id="6799" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们分析文本之前，我们可以使用一个叫做<strong class="kj iu">标记化</strong>的过程来分离所有的单词。然后我们把每个单词分解成词干。这个过程将把<em class="lf"> parlo </em>和<em class="lf"> parli </em>转换成它们现在的词干<em class="lf"> parl- </em>，允许它们被算作同一个单词。到那时，文本就可以进行分析了。</p><p id="6a22" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们开始用 Python 编程，这样我们就可以标记但丁的<em class="lf">地狱</em>！</p><h1 id="e8ce" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Python 入门</h1><p id="d46a" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">总的来说，Python 是一种非常棒的数据分析语言，不管我们更侧重于科学还是人文学科。</p><p id="9574" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">要在 web 浏览器中开始使用 Python 编程，请访问 repl.it 并创建一个帐户。之后点击屏幕右下角的红色加号，做一个编码环境:</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi mj"><img src="../Images/f28bf731812a4231653d42ead295a5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6Cy-TWAm-fwnvQ1dw8jWQ.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Click on the red plus sign.</figcaption></figure><p id="b95b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">从“流行”类别中选择“Python ”:</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi mo"><img src="../Images/a327d5dc345a470dd3dd2bd3918fff78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkosOWJGWlFrYKD8Zy6Ilg.png"/></div></div></figure><p id="61b3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，您应该会看到一个空白的 Python 编辑器:</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi mp"><img src="../Images/7c34ce00a5b78964a42e6e687cc7dd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1aLDSNEw89xmbDojvXQMg.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">You’ll be typing in the white text area.</figcaption></figure><p id="c4af" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，我们需要从 NLTK 和其他包中导入和下载我们需要的所有东西。将这些导入复制并粘贴到您的 Python 编辑器中，然后阅读下面的解释。</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="35b6" class="mv lh it mr b gy mw mx l my mz">import nltk<br/>from nltk.corpus import stopwords<br/>from nltk.probability import FreqDist<br/>from nltk.stem.snowball import SnowballStemmer<br/>from nltk.tokenize import word_tokenize<br/>from urllib import request</span><span id="a9d8" class="mv lh it mr b gy na mx l my mz"><br/>nltk.download('punkt')<br/>nltk.download('stopwords')</span></pre><p id="dd42" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们的进口:</p><ul class=""><li id="a845" class="nb nc it kj b kk kl ko kp ks nd kw ne la nf le ng nh ni nj bi translated">Python 附带的自然语言工具包</li><li id="e403" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">阻止来自 NLTK 的单词。这些是常见的词，比如“a”和“the ”,我们在分析频率时会想过滤掉它们。许多语言都有停用词，包括意大利语。</li><li id="99a2" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">NLTK 的雪球斯特梅尔。这个工具可以让我们将每个单词缩减到它的词干，这样我们就可以准确地计算出它的频率，而不管它的语法上下文。雪球斯特梅尔用外语工作。</li><li id="83e5" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">一个单词标记功能，允许我们将文本分解成单词列表进行处理。</li><li id="e0fc" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">一个请求函数，允许 Python 从 URL 中读取文本。</li></ul><p id="899d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最后，我们从 NLTK 下载了一个名为“punkt”的包，它允许我们使用单词标记化功能，以及另一个名为“stopwords”的包，它允许我们访问上面提到的停用单词。</p><p id="c102" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最后的文体提示:按字母顺序排列你的导入是一个好习惯。</p><h1 id="83b2" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">从 URL 导入文本</h1><p id="a170" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">将但丁的<em class="lf">地狱</em>的整个文本复制粘贴到一个单独的文件中真的很难(我试过了)，所以我们将使用 Python 从一个网站上读取文本！</p><p id="2593" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我找到了。txt 文件(通常最容易处理),所以我要做的第一件事(在我的导入下面)是将该 URL 存储在一个变量中:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="d08d" class="mv lh it mr b gy mw mx l my mz">url = "<!-- -->https://www.gutenberg.org/cache/epub/997/pg997.txt<!-- -->"</span></pre><p id="7ffa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，每当我说<code class="fe np nq nr mr b">url</code>，电脑就会知道我指的是 gutenberg.org 的地址。</p><p id="3c7b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">接下来，我可以使用我导入的请求方法向 gutenberg.org 的服务器发送请求，并在服务器响应时获得文本<em class="lf"> Inferno </em>:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="61fc" class="mv lh it mr b gy mw mx l my mz">response = request.urlopen(url)</span></pre><p id="7a6e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">服务器将交付<em class="lf"> Inferno </em>文本并将其存储在<code class="fe np nq nr mr b">response</code>变量中，但是它的格式会比我们需要的稍微复杂一些。我们可以用下面的代码行将<em class="lf"> Inferno </em>变成一个易读的文本字符串:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="ae6c" class="mv lh it mr b gy mw mx l my mz">text = response.read().decode('utf8')</span></pre><p id="534a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">基本上，我只是告诉计算机使用 UTF-8(一种常见的字符编码形式)将过于复杂的变量<code class="fe np nq nr mr b">response</code>翻译成简单的文本字符串。现在变量<code class="fe np nq nr mr b">text</code>将保存一串简单格式的文本，如下所示:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="1517" class="mv lh it mr b gy mw mx l my mz">"<!-- -->Nel mezzo del cammin di nostra vita mi ritrovai per una selva oscura che la diritta via era smarrita...<!-- -->"</span></pre><p id="3e34" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">基本上，<em class="lf">地狱</em>的整篇文字都被引号包围了。在计算机科学中，我们将这种数据类型(由引号包围的一串字符/单词/短语)称为<a class="ae kg" href="https://www.gutenberg.org/cache/epub/997/pg997.txt" rel="noopener ugc nofollow" target="_blank">字符串</a>。</p><p id="275b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">好了，我已经得到了友好格式的文本。接下来要做什么？如果你说的是“标记文本”，你答对了！</p><h1 id="49df" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">对文本进行标记</h1><p id="6d92" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">之前，我提到过标记化会产生“要处理的单词列表”列表实际上是 Python 中的一种数据结构(类似于其他语言中的数组)。而变量看起来像这样:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="1cb0" class="mv lh it mr b gy mw mx l my mz">favorite_food = "tiramisu"</span></pre><p id="42f1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">列表如下所示:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="5d3a" class="mv lh it mr b gy mw mx l my mz">grocery_list = ["pasta", "tomato sauce", "pesto", "gelato"]</span></pre><p id="98a0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可以看到，虽然一个变量只包含一个东西，但一个列表包含许多东西，这使得它对于杂货列表和书籍中的单词列表非常有用。当我们标记出<em class="lf"> Inferno </em>时，它会变成这样:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="b745" class="mv lh it mr b gy mw mx l my mz">"Nel mezzo del cammin di nostra vita..."</span></pre><p id="ee51" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">变成这样:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="560e" class="mv lh it mr b gy mw mx l my mz">["Nel", "mezzo", "del", "cammin", "di", "nostra", "vita"]</span></pre><p id="691a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">编写令牌化的源代码可能很复杂，但是幸运的是，NLTK 为我们提供了这个功能！要将<em class="lf"> Inferno </em>的原始文本转换成令牌，请编写这行代码:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="467a" class="mv lh it mr b gy mw mx l my mz">tokens = word_tokenize(text)</span></pre><p id="fc2f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，变量<code class="fe np nq nr mr b">tokens</code>应该包含一个单词列表。如果您想看看这个列表是什么样子(或者至少是它的底部，因为 repl.it 只能打印这么多)，您可以像这样打印标记:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="1028" class="mv lh it mr b gy mw mx l my mz">print(tokens)</span></pre><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi ns"><img src="../Images/8b669e5ae098351682c072e8e0aa548b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOH7BrQKJRattsFbpuyJXQ.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">The tokens!</figcaption></figure><p id="f906" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">计算机可能需要一点时间来生成令牌。在你等待电脑的时候，沉浸在你的成就中——电脑通常工作得很快，无论何时你让它们变慢，你都知道你正在做复杂、重要的事情(或者不小心写了一个无限循环)。</p><p id="d0a7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">作为一种捷径，我喜欢只打印令牌列表的长度，也就是说，列表中的单词数。您可以使用<code class="fe np nq nr mr b">len</code>函数来计算列表的长度:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="802c" class="mv lh it mr b gy mw mx l my mz">print(len(tokens))</span></pre><p id="60a4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你应该有 45274 个令牌(或单词)！</p><p id="0c17" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您打印了令牌，您会注意到还包括了标点符号。什么？！</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nt"><img src="../Images/df5c6a98c6f081c38ff121c0a9525011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELkcfqR8VaF8AK6s2oAS7Q.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Some of the tokens are just commas and accents!</figcaption></figure><p id="2241" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">幸运的是，我们可以用下面的代码行来摆脱这种疯狂:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="68d1" class="mv lh it mr b gy mw mx l my mz">tokens = [token for token in tokens if token not in '.,:;&lt;&gt;!?[]()`"\'']</span></pre><p id="2e68" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">哇哦。这是怎么回事？！基本上，这是一个很酷的编程策略，我说:“将<code class="fe np nq nr mr b">tokens</code>变量设置为与之前相同的东西(之前存在的所有标记)，但过滤掉任何标记，实际上只是我明确列出的任何标点符号！”</p><p id="1a21" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果再次打印令牌的长度，现在应该有 34，836 个令牌。</p><p id="68e4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可能会注意到，在这些标记中，我们有一些基本的单词，比如“la”(the)和“e”(and)。对于分析词频来说，这些基本单词对我们来说一点也不有趣——谁在乎但丁是否说了 1000 次“the ”?！</p><p id="df2f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这些基本词在 NLTK 里叫做<strong class="kj iu">停用词</strong>，我们可以过滤掉。</p><h1 id="4cd8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">过滤掉停用词</h1><p id="65db" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">现在我们准备去掉停用词，那些我们不在乎的超级常用词。首先，让我们将停用词存储在一个变量中:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="5643" class="mv lh it mr b gy mw mx l my mz">stop_words = stopwords.words("italian")</span></pre><p id="791f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，我们可以做一些有趣的编程工作来从我们的列表中过滤出这些步骤。下面是我们如何将<code class="fe np nq nr mr b">tokens</code>变量重置为没有停用词的单词列表:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="5355" class="mv lh it mr b gy mw mx l my mz">tokens = [token for token in tokens if token not in stop_words]</span></pre><p id="b16c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">基本上，我说:“让<code class="fe np nq nr mr b">tokens</code>变量等于所有和以前一样的记号，除了<code class="fe np nq nr mr b">stop_words</code>列表中的单词/记号！”</p><p id="b8a9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了再次检查是否所有讨厌的停用词都被删除了，我们可以打印出记号——以及记号的长度，以确保它与以前不同！</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="de6d" class="mv lh it mr b gy mw mx l my mz">print(tokens)<br/>print(len(tokens))</span></pre><p id="2d28" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个列表现在应该有 21781 个单词，比我们之前的 34k 左右的单词少了很多。</p><p id="2e90" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们还可以看到，我们的新令牌列表很高兴地没有填充词和标点符号:</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nu"><img src="../Images/28230ce87f2b0bbe14355ec799656f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pKVdUxrxvgQE8I_tbGjtw.png"/></div></div></figure><p id="01f8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">不错！</p><h1 id="788a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">词干</h1><p id="d957" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">现在我们准备把我们的话砍进他们的茎！首先，我们需要创建一个词干分析器。您可以像这样创建一个意大利词干分析器:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="922b" class="mv lh it mr b gy mw mx l my mz">stemmer = SnowballStemmer("italian")</span></pre><p id="f487" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您使用的是不同的语言，请注意，您可以用这行代码打印雪球斯特梅尔处理的所有语言:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="afd2" class="mv lh it mr b gy mw mx l my mz">print(" ".join(SnowballStemmer.languages))</span></pre><p id="a601" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，我们可以用更巧妙的编程方法将所有单词转换成词干:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="fe67" class="mv lh it mr b gy mw mx l my mz">stems = [stemmer.stem(word) for word in tokens]</span></pre><p id="bbe0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">上面的代码行基本上解释为，“对于<code class="fe np nq nr mr b">tokens</code>列表中的每个单词(或标记)，将其转换为词干，并将这个新的词干列表存储在一个名为<code class="fe np nq nr mr b">stems</code>的变量中。”</p><p id="9e1f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您也可以用这行代码打印词干:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="4909" class="mv lh it mr b gy mw mx l my mz">print(stems)</span></pre><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nv"><img src="../Images/a5a581a35041481297f1953666a6ea95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cD7gkcP6wNPOoW2CAmaHtA.png"/></div></div></figure><p id="901b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在我们已经得到了茎，我们准备进行一些频率分析！</p><h1 id="e5ff" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">计算词频</h1><p id="4e4f" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">现在我们可以尝试基于词频来分析但丁的<em class="lf">地狱</em>了！我将这一部分命名为“计算词频”，但计算机将是唯一一台进行数学运算的计算机——我们将只编写几行简洁的代码。这就是 NLTK 的妙处！</p><p id="e152" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">要在变量中存储频率分布，我们只需说:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="e2a9" class="mv lh it mr b gy mw mx l my mz">fdist = FreqDist(stems)</span></pre><p id="d284" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这一点上，一些程序员可能会做数据可视化，但如果我没有弄错的话，repl.it 没有这个功能——如果您想探索数据，您必须将 Python 和适当的包下载到您的计算机上。</p><p id="354d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">但是，我们绝对可以打印出数值！有了这行代码，我可以打印出但丁的<em class="lf">地狱</em>中最常见的 100 个单词:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="56f9" class="mv lh it mr b gy mw mx l my mz">print(fdist.most_common(100))</span></pre><p id="1ce3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">酷，最常用单词列表！</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nw"><img src="../Images/9647c8e6dad29b11173defe86353b86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_wErT8hS9JiUb-EL2OthQ.png"/></div></div></figure><p id="7856" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">看词频可以得出什么结论？或者说，检查这些频率引发了哪些问题？</p><p id="18b1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可能会注意到，单词<em class="lf"> piu </em>(更多)，被使用了 181 次，而词干<em class="lf"> tant- </em>(更多)，被使用了 80 次。这些话表明地狱是一个极端的地方。</p><p id="c498" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可能还会注意到词干<em class="lf"> l'altr- </em>(另一个)被使用了 94 次，这可能会导致对但丁的<em class="lf">地狱</em>中二元性的研究。</p><p id="efb6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以检查最常见的动词，它们与看和说有关，以及出现 50 次的单词<em class="lf"> occhi </em>(眼睛)。这些话表明了但丁在冥界的消极态度。</p><p id="034c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">假设你是意大利文学的研究生。你还能想到什么？</p><figure class="mk ml mm mn gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nx"><img src="../Images/184e3ee10915341ef483ee841d7c3831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wheXmHdmJYeC8OuxBO-mPg.jpeg"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/photos/Y5qJKfg0hJ8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Willian West</a> on <a class="ae kg" href="https://unsplash.com/search/photos/italy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9ec5" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">进一步阅读</h1><p id="9250" class="pw-post-body-paragraph kh ki it kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">编程是面向所有人的，包括人文主义者！查看下面的参考资料，了解关于 NLTK 和 Python 数据分析的更多信息。</p><ol class=""><li id="b53a" class="nb nc it kj b kk kl ko kp ks nd kw ne la nf le ny nh ni nj bi translated"><a class="ae kg" href="https://www.datacamp.com/" rel="noopener ugc nofollow" target="_blank"> DataCamp </a>，学习自然语言处理和其他 Python 数据分析的绝佳资源</li><li id="6848" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ny nh ni nj bi translated"><a class="ae kg" href="https://programminghistorian.org/" rel="noopener ugc nofollow" target="_blank">编程历史学家</a>，一个数字人文教程的伟大资源</li><li id="5e84" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ny nh ni nj bi translated"><a class="ae kg" href="https://medium.com/@kellylougheed/coding-english-lit-natural-language-processing-in-python-ba8ebae4dde3" rel="noopener">编码&amp;英语文学:Python 中的自然语言处理，</a>关于分析英语文本的教程</li><li id="cc0f" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ny nh ni nj bi translated"><a class="ae kg" href="http://www.nltk.org/howto/stem.html" rel="noopener ugc nofollow" target="_blank">如何使用 NLTK Porter &amp;雪球测径器</a></li><li id="2acc" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ny nh ni nj bi translated"><a class="ae kg" href="https://www.geeksforgeeks.org/removing-stop-words-nltk-python/" rel="noopener ugc nofollow" target="_blank">在 Python 中使用 NLTK 删除停用词</a></li></ol></div></div>    
</body>
</html>