<html>
<head>
<title>Comparing Friday the 13th Recommendations from Surprise and Implicit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较星期五第 13 次建议从惊讶和含蓄</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-friday-the-13th-recommendations-from-surprise-and-implicit-ff348f4fe00a?source=collection_archive---------29-----------------------#2019-12-15">https://towardsdatascience.com/comparing-friday-the-13th-recommendations-from-surprise-and-implicit-ff348f4fe00a?source=collection_archive---------29-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e314" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助你计划下一个电影之夜的功能代码。</h2></div><p id="dcdd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最近的一篇<a class="ae le" href="https://medium.com/@jmcneilkeller/item-item-recommendation-with-surprise-4bf365355d96" rel="noopener">博客文章</a>中，我详细介绍了如何令人惊讶地进行单品推荐。我选择惊喜，部分是因为它是我训练营的一些导师强烈推荐的(没有双关语)，但我完全意识到还有很多其他选择，其中一些我在我的上一篇推荐帖子中详细介绍过。我认为从隐式开始深入研究我已经跳过的其他一些库是值得的。</p><p id="30d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Implicit 是一个库，旨在为其他一些已建立的推荐库(如 Annoy 和 NMSLib)提供更快的 Python 实现，所以它似乎是一个不错的起点。我将仅仅触及这个库所提供的皮毛，所以请随意查看这里的文档<a class="ae le" href="https://implicit.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"/>和这里的 GitHub<a class="ae le" href="https://github.com/benfred/implicit" rel="noopener ugc nofollow" target="_blank"/></p><p id="eb85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在评估 Surprise 和 Implicit 各自推荐的质量有点武断。没有一些用户的反馈，这完全取决于我的主观意见，哪一个做得更好。本着这种精神，我将把重点放在提取建议的代码上。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="1011" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们推荐任何东西之前，我们首先要构建并运行我们的模型。我已经在之前的博客中详细介绍了如何构建和运行惊喜(这里是<a class="ae le" href="https://medium.com/@jmcneilkeller/item-item-recommendation-with-surprise-4bf365355d96" rel="noopener">再次是</a>)，所以我将在这里运行隐式。</p><p id="3b8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们必须导入数据。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="c78a" class="lv lw it lr b gy lx ly l lz ma">import implicit</span><span id="f298" class="lv lw it lr b gy mb ly l lz ma">df = pd.read_csv("final_data.csv", index_col=0) <br/># This dataframe has the movie titles, which I'll need later.</span></pre><p id="5a02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与 Surprise 不同，Implicit 特别需要一个稀疏矩阵。令人惊讶的是，假设您只传递 userid、itemid 和 weight(或 rating)列，那么您可以将数据帧直接传递给模型。但是使用 Implicit，您需要首先转换您的数据。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="77ef" class="lv lw it lr b gy lx ly l lz ma">df_sparse = pd.read_csv("item_item_final.csv", index_col=0)<br/>sparse = scipy.sparse.csr_matrix(df_sparse.values)</span></pre><p id="802f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当谈到模型时，Implicit 有很多选项，包括 onyy、NMSLib 和 Faiss 的版本，但出于说明的目的，我将坚持使用良好的 ole 交替最小二乘法。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a334" class="lv lw it lr b gy lx ly l lz ma">als_model = implicit.als.AlternatingLeastSquares()<br/>als_model.fit(sparse)</span></pre><p id="8009" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是有趣的部分——我们可以推荐一些电影。先说惊喜。我会选择单品推荐，这很简单，但会给你带来惊喜。</p><p id="1ca7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">惊喜的好处在于，无论你的 item _ ids 是什么，都可以是字符串。在这种情况下，这非常有用，因为最终我想要吐出的是一个易于阅读的电影名称列表。Surprise 通过将“原始 id”(即电影名称)转换为“内部 id”(数字)来处理这些字符串。这使得你可以相对容易地将你的标题从模型中取出来。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b36d" class="lv lw it lr b gy lx ly l lz ma"># First, select the title you are recommending for:<br/>hd_raw_id = 'Friday the 13th Part VII: The New Blood (1988)'</span><span id="967e" class="lv lw it lr b gy mb ly l lz ma">#Transform that raw_id to an inner_id.<br/>hd_inner_id = KNN_final_model.trainset.to_inner_iid(hd_raw_id)</span><span id="f048" class="lv lw it lr b gy mb ly l lz ma"># Get nearest neighbors. <br/>hd_neighbors = KNN_final_model.get_neighbors(hd_inner_id, k=5)</span><span id="107f" class="lv lw it lr b gy mb ly l lz ma"># Convert inner ids of the neighbors back into movie names.<br/>hd_raw = [KNN_final_model.trainset.to_raw_iid(hd_inner_id)<br/>                       for hd_inner_id in hd_neighbors]</span></pre><p id="c516" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我的建议:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="84ce" class="lv lw it lr b gy lx ly l lz ma">['Friday the 13th Part VIII: Jason '<br/> 'Takes Manhattan (1989)',<br/> 'Leatherface: Texas Chainsaw Massacre '<br/> 'III (1990)',<br/> 'Amityville: A New Generation (1993)',<br/> 'Jaws 3-D (1983)',<br/> 'Texas Chainsaw Massacre: The Next '<br/> 'Generation (a.k.a. The Return of the '<br/> 'Texas Chainsaw Massacre) (1994)']</span></pre><p id="598b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不算太差！我们有所有的恐怖电影，所有的续集，它包括另一个 13 号星期五，这是我的数据集的一部分。至少从表面上看，这是有道理的。</p><p id="75f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在为含蓄。得到相似的物品，其实在隐性上是极其简单的。您只需调用“相似项”函数。代码如下:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0e78" class="lv lw it lr b gy lx ly l lz ma">sim_items = als_model.similar_items(70)</span></pre><p id="c86d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">诀窍是返回一些可理解的东西，尤其是对最终用户。隐式返回 n 个最近邻居的行 id。当然，没有人愿意被推荐一些行 id。这意味着，对于实际应用，您将需要一个助手函数。这是我想到的:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7e40" class="lv lw it lr b gy lx ly l lz ma">def get_item_recs(movie):<br/>    """Takes a movie row from the model and makes a five recommendations.""" <br/>    id_list = []<br/>    sim_items = als_model.similar_items(movie,5)<br/>    for item in sim_items:<br/>        iid = df_sparse.iloc[item[0],[1]]<br/>        id_list.append(int(iid[0]))<br/>    final = []<br/>    for rec in id_list:<br/>        final.append(df.loc[df['movieId']== rec, 'title'].iloc[0])<br/>    return final</span></pre><p id="34eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是清单:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="76a9" class="lv lw it lr b gy lx ly l lz ma">['Friday the 13th Part VIII: Jason Takes Manhattan (1989)',<br/> 'Iron Eagle IV (1995)',<br/> 'Lawnmower Man 2: Beyond Cyberspace (1996)',<br/> 'Troll 2 (1990)',<br/> 'Problem Child 2 (1991)']</span></pre><p id="aa55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这份清单比《惊奇》多了一点多样性，但仍然相当不错。同样，另一个 13 号星期五是它的一部分，它都是续集。榜单上还有铁鹰四和问题儿童 2，有意思。</p><p id="e71a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，我没有真正调整 ALS 模型的参数，Implicit 还有许多我没有包括在内的特性和功能，但有趣的是拍摄的不同之处。</p></div></div>    
</body>
</html>