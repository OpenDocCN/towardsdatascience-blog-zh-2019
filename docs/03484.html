<html>
<head>
<title>Waveform Analysis Unlocks the Data in Music</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">波形分析解锁音乐中的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/waveform-analysis-unlocks-the-data-in-music-c47e773f1fa8?source=collection_archive---------16-----------------------#2019-06-03">https://towardsdatascience.com/waveform-analysis-unlocks-the-data-in-music-c47e773f1fa8?source=collection_archive---------16-----------------------#2019-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e9ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<a class="ae ko" href="https://en.wikipedia.org/wiki/Waveform" rel="noopener ugc nofollow" target="_blank">波形</a>就是一首歌的指纹。正是这种波形，或声波的卷积，包含了一首歌的所有内容。从中可以发现大量的特征。这些功能能够增强推荐算法，远远超过仅使用歌曲的标题、艺术家和流派所能达到的效果。无论是作为纯粹基于内容的方法的一部分<a class="ae ko" href="https://en.wikipedia.org/wiki/Recommender_system#Content-based_filtering" rel="noopener ugc nofollow" target="_blank"/>还是作为解决<a class="ae ko" href="https://en.wikipedia.org/wiki/Cold_start_(computing)" rel="noopener ugc nofollow" target="_blank">【冷启动】问题的重要第一步</a>，理解媒体内容与理解它是如何被消费的同等重要。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/ebdf97a98dd66a84b7d505c9c024b558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5INN2poiginzpa3uyFauw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae ko" href="https://pixabay.com/photos/headphones-smartphone-technology-791078/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h1 id="b667" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我与音乐的关系</h1><p id="2092" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">音乐对我来说极其重要。这是我生命中不变的一部分，它见证了我走过的各行各业，无论是好的还是坏的。因为我花了很多时间在音乐上，所以寻找新的音乐一直是我的激情所在。虽然我不知道这些年来我花了多少时间听音乐，但我知道仅在过去的八年里，我已经积累了超过 6000 首个人精选的歌曲。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/a8d6d471aec7587df535dca2d1777678.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*xXKLQqlgCacMZh4XMGMgNg.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">The size of my music library.</figcaption></figure><p id="744f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我的整个音乐收藏都是离线存储的，我无法参与协同过滤算法，就像音乐流媒体平台用来推荐新歌的那些算法一样。具体来说，如果用户<em class="mj"> X </em>听了很多和我一样的音乐，音乐流媒体平台就知道我可能也喜欢用户<em class="mj"> X </em>听的其他歌曲。因此，如果我想创建主题播放列表，我只能对手头的音乐进行基于内容的过滤。</p><p id="3079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，从这么大的一个集合中手工选择一组有凝聚力的歌曲是很费时间的，即使我能完美地回忆起每首歌的标题、艺术家及其识别特征(例如，古典、钢琴或“chill”)。事实上，我只能回忆起这些歌曲中的一小部分，并且经常忘记艺术家的姓(我知道他们的名字是约翰… <em class="mj">什么的</em>)，所以以这种方式制作播放列表是一项艰巨的任务，我通常会避免。相反，我通常通过启用随机播放和按播放来简化这个过程。</p><p id="1a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，去年我意识到，我可以利用歌曲的波形数据来解决创建播放列表这一日益严重的问题。我以前处理过来自光源的数据，因为光和声音都是以波的形式传播的，所以我相信我能够利用我的技能来解决这个问题。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mk"><img src="../Images/caf98e3e927444c52d27811f5a6e85d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi8nCZPgJQzMIwXpE510Gg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Example single channel audio waveform.</figcaption></figure><h1 id="2557" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">特征提取和选择</h1><p id="4337" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在兴奋和西雅图咖啡的刺激下，我头脑风暴了一下我的方法:从这些波形中可以提取什么特征？哪些功能对我想要的最有用？应该如何为播放列表选择歌曲？</p><p id="8101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想开始，并且知道一旦我掌握了一些特性，我就能够回答后面的问题，所以这就是我开始的地方。在重构了当时已经过时的<a class="ae ko" href="https://github.com/tyiannak/pyAudioAnalysis" rel="noopener ugc nofollow" target="_blank"> pyAudioAnalysis </a>包并管理了包的依赖关系之后，我为每首歌提取了特征。我知道如果我只提取歌曲的一部分的特征，提取的特征可能不能准确地反映歌曲的整体。为了解决这个问题，在移动窗口中提取特征并进行平均。通过这样做，可以计算每个特征的方差，并将其用作附加特征。这相当于每首歌曲的 33 个主要特征，每个特征都有一个相关的标准偏差:</p><ol class=""><li id="4831" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated"><strong class="js iu">过零率</strong> : <em class="mj">符号变化率(音频波形是相对的，以零为中心)。对打击乐声音进行分类的一个关键特征。</em></li><li id="4453" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">能量:</strong> <em class="mj">信号值的平方和，用窗口长度归一化。标识歌曲的音量。</em></li><li id="ea12" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">能量熵:</strong> <em class="mj">子帧归一化能量的熵。用来衡量突然的变化。</em></li><li id="98bf" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">光谱质心:</strong> <em class="mj">光谱的重心。与声音的“亮度”相关。</em></li><li id="7f07" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">频谱扩展:</strong> <em class="mj">频谱的第二中心矩。测量频谱的带宽。</em></li><li id="4e8d" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">光谱熵:</strong> <em class="mj">归一化光谱能量的熵。测量光谱随时间的变化。</em></li><li id="f7c9" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">频谱通量:</strong> <em class="mj">两个连续帧的频谱的归一化幅度的平方差。测量光谱的稳定性/一致性。</em></li><li id="2fd6" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">频谱滚降:</strong> <em class="mj">频谱 90%的量级分布集中在此频率以下。</em></li><li id="8c3c" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">Mel-频率倒谱系数(13 个特征):</strong> <em class="mj">线性倒谱的变化(音高的非线性标度)。通常用于语音识别。</em></li><li id="a10a" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><strong class="js iu">键(12 个特性；g、C、D 等。):</strong> <em class="mj">每个半音中的频谱能量。</em></li></ol><p id="54c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">由此，我基于以下考虑选择了一系列有用的特性:</strong></p><ol class=""><li id="cbf9" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">由于特征是在歌曲的长度上计算的，所以成分变化很大的歌曲或与多首歌曲混合的歌曲将具有不能完美反映歌曲的特征。</li><li id="53d6" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">歌曲的基调用作歌曲选择的特征并不理想。我不想要一个怪异小调的歌曲播放列表(见<a class="ae ko" href="https://www.youtube.com/watch?v=q0-ftKdfAJE" rel="noopener ugc nofollow" target="_blank">阿黛尔的 A 小调《像你一样的人》</a>)，所以我去掉了涉及歌曲基调的特征。</li><li id="f3ee" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">梅尔频率倒谱系数比选择发音相似的歌曲更适合语音识别，所以这些也被删除了。</li></ol><p id="6995" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终，这 33 个特征被浓缩成 8 个有用的特征以及它们的标准偏差，然后被标准化。因此，有了一套强大的功能来封装我的整个音乐库，终于到了制作播放列表的时候了！</p><p id="8362" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的图书馆，没有方便的流派标签，如另类，流行，摇滚等。不允许传统意义上的流派特定播放列表。这困扰着我，直到我意识到流派的界限没有很好地定义，这将对我如何生成播放列表产生不必要的偏见。</p><p id="3eb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很明显，使用类似于<a class="ae ko" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">k-最近邻(k-NN)算法</a>的东西将是创建播放列表最合适的方式，尽管我不需要创建一个分类系统；一旦指定了一首歌，我会通过用 scikit-learn 计算每隔一点成对的<a class="ae ko" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>来找到这首歌在 16 维空间中的最近邻居。我还希望我的框架足够健壮，不需要梳理成千上万的文件，也不需要记住确切的歌曲或艺术家姓名来找到播放列表所基于的歌曲。为此，我创建了一个简单的管道来创建每个播放列表。</p><h1 id="cc93" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建播放列表！</h1><p id="b521" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，我输入部分歌曲或艺术家的名字和播放列表的长度。例如，如果我想要一个基于鲁多维科·艾奥迪的一首古典钢琴曲的 15 首歌曲的播放列表，但是我想不起歌名和他的姓，那么输入应该是:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="2f87" class="ne lg it na b gy nf ng l nh ni">genPlaylist(‘Ludovico’, 15)</span></pre><p id="3189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将显示所有匹配松散 SQL 查询的歌曲:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="176c" class="ne lg it na b gy nf ng l nh ni">SELECT name WHERE name LIKE ‘%ludovico%’</span></pre><p id="d743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给出以下输出:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0e8bc571766a5a92694df572bf073477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*v3rdeoUhJ5BV0jND398EgA.png"/></div></figure><p id="514f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在看到名字并意识到我想要鲁多维科·艾奥迪的歌曲<em class="mj"> Nuvole Bianche </em>后，我可以选择歌曲 2。下面的代码将确定从<em class="mj"> Nuvole Bianche </em>到每首其他歌曲的欧几里德距离，对它们进行排序，然后返回最近的邻居，以便在播放列表中使用。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="e268" class="ne lg it na b gy nf ng l nh ni">min_dists = pairwise_distances(features_df.loc[songID]\<br/>.values.reshape(1,-1), features_df.values)</span><span id="8bbc" class="ne lg it na b gy nk ng l nh ni">neighbor_indices = min_dists.argsort()[0][:num_songs]</span><span id="2308" class="ne lg it na b gy nk ng l nh ni">id_list = [] <br/>   <br/>for neighbors in neighbor_indices:<br/>    id_list += [features_df.iloc[neighbors].name]<br/>        <br/>new_playlist = song_df[song_df.index.isin(id_list)]<br/>new_playlist_entries = new_playlist['title']</span></pre><p id="fe50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">识别出歌曲后，会创建一个名为“鲁多维科·艾奥迪-努沃尔·比安奇”的文件夹，并将歌曲移动到该文件夹中。</p><p id="35b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我可以随时收听我新创建的播放列表，或者我可以继续创建更多的播放列表！如果您感兴趣，可以在这里找到这个精确查询形成的播放列表(再次限于我的音乐库内的那些歌曲)。你也可以在这里查看源代码<a class="ae ko" href="https://github.com/tblair7/playlist_generation" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="9385" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论和潜在应用</h1><p id="cb93" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">虽然这个框架目前仅限于我的个人音乐库，因此无法为我找到新的音乐，但它非常适合在瞬间创建与特定歌曲主题相匹配的播放列表。然而，有了更广泛的库，如 Spotify、iTunes 或 YouTube，它的用途可以扩展到促进音乐发现和新用户的“冷启动”问题。</p><p id="e25c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 16 维特征空间中，用户可能对他们通常会听的内容有明确的界限。如果用户然后决定他们想要将他们的音乐库扩展到位于他们当前特征空间边界之外的歌曲，则包括刚好超出该边界的歌曲的播放列表将是实现这一点的有效方式。对于新用户，该方法可以用来快速定义他们的特征空间边界，此时也可以使用协同过滤。</p><p id="2ae3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我只是在音乐的背景下讨论了这个问题，但是它的应用远远超出了播放列表的生成。底层方法可以(并且可能已经)适用于在视频流平台、半定向广告和其他平台上查找新节目，尽管它需要丰富的特征空间。这可以通过原始数据的工程特征来实现，揭示丰富的信息，并且不限于波形分析。所以我鼓励你更深入地审视你所拥有的数据，因为就像冰山一样，容易看到的可能只是开始。</p></div></div>    
</body>
</html>