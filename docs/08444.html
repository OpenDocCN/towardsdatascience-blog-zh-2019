<html>
<head>
<title>Customize your training loop with callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过回访定制您的培训循环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/customize-your-training-loop-with-callbacks-9d93b415a602?source=collection_archive---------15-----------------------#2019-11-16">https://towardsdatascience.com/customize-your-training-loop-with-callbacks-9d93b415a602?source=collection_archive---------15-----------------------#2019-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fdddab7ca49c63ec7e70db92545700c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZO3zEpluBdOcjlnyXdffNg.jpeg"/></div></div></figure><p id="c82f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的上一篇文章中，我们学习了如何从头开始编写 PyTorch 训练循环。我们从一个混乱的循环版本开始，如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/58125081f1b636bf232d92a13b18cf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDlavTABmeEoZZ8bRbUOGA.png"/></div></div></figure><p id="ef38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们把它变成了一个更简洁的版本，看起来像这样:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/3da8791e78e2124a183244c6693bd6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5H7dCKNy07GVWjQ7eGTZg.png"/></div></div></figure><p id="bada" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个过程中，我们学会了如何通过为数据集、数据加载器、优化器等等编写类来将相似的东西打包在一起。在本文中，我们将进行更多的打包，并学习如何定制我们的训练循环，以实现深度学习中的复杂技术。</p><p id="a555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先说我们的 fit 函数。</p><h2 id="47ce" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">数据群发</h2><p id="c386" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的<code class="fe mb mc md me b">fit()</code>函数包括我们的模型、损失函数、优化器和两个数据加载器(训练和验证)。</p><p id="c8ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果我们仔细想想，训练和验证数据加载器并不是两件独立的事情。他们是我们的<strong class="ka ir"> <em class="mf">数据</em> </strong>。它们必须是一个东西(或者至少是从它派生出来的)。因此，我们将这两个数据加载器合并成一个名为<code class="fe mb mc md me b">DataBunch.</code>的类</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/cff2c5238fab78556656e74f22e6f0a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5IDadXMuw0AGxxcekTOLg.png"/></div></div></figure><p id="186d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们可以将数据中的<strong class="ka ir"> <em class="mf">类的数量</em> </strong>传递给 DataBunch，那也很方便。这是通过传递<code class="fe mb mc md me b">c</code>参数来完成的。我们现在可以创建一个 DataBunch 对象，如下所示。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/bf3ce43b8525375a96454c500a1a18e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ym7VK0-HL7ZDchGO0xMG6g.png"/></div></div></figure><p id="b9d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以使用这个对象通过自动识别输入和输出单元的数量来方便地创建模型。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/269161f70ed044f4f3d1b196ed9fb470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8IYt6umzsPhowbBy8-PQGw.png"/></div></div></figure><h2 id="bcea" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">学习者</h2><p id="925f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">下一步，我们要做的是结合我们的模型，优化和损失函数。</p><p id="3eb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多时候，在进行深度学习的实验时，我们想要测试这些东西的一个<strong class="ka ir"> <em class="mf">组合</em> </strong>。这涉及到对我们代码的各个部分进行大量的修改。但是，将它们组合成一个对象并仅对该对象进行更改是有意义的。这将有助于我们轻松做出明智的决定。</p><p id="b77c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将模型、优化器和损失函数组合成一个名为<code class="fe mb mc md me b">Learner.</code>的类</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/658f3a461f191dd87d7d6ad8dc436e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XzDUOHVxekBQ-byVH6Gtg.png"/></div></div></figure><p id="14c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以使用<code class="fe mb mc md me b">learn.model</code>、<code class="fe mb mc md me b">learn.opt</code>和<code class="fe mb mc md me b">learn.loss_func.</code>来访问它们。我们在训练循环中进行必要的更改。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/238372b6c334ec8c57f2ae12bb9dcff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uReZJBKhm1EPbnJge1M4hw.png"/></div></div></figure><h1 id="0882" class="mk le iq bd lf ml mm mn li mo mp mq ll mr ms mt lo mu mv mw lr mx my mz lu na bi translated">需要复试</h1><p id="1f74" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在这一点上，我们有一个非常整洁的训练循环。然而，这些并不是我们想在训练循环中做的唯一事情。我们可能需要添加一些东西，比如</p><h2 id="7a3b" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><strong class="ak"> <em class="nb">超参数调度</em> </strong></h2><div class="nc nd gp gr ne nf"><a href="https://sgugger.github.io/how-do-you-find-a-good-learning-rate.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">你如何找到一个好的学习率</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">你如何决定学习速度？如果太慢，你的神经网络将会花很长时间去学习(试着用…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">sgugger.github.io</p></div></div><div class="no l"><div class="np l nq nr ns no nt jw nf"/></div></div></a></div><h2 id="d4ba" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><strong class="ak"> <em class="nb">或</em> </strong>正规化技术</h2><div class="nc nd gp gr ne nf"><a href="https://becominghuman.ai/this-thing-called-weight-decay-a7cd4bcfccab" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">这个东西叫做重量衰减</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">了解如何使用权重衰减来训练更好的模型</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">becominghuman.ai</p></div></div><div class="no l"><div class="nu l nq nr ns no nt jw nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://becominghuman.ai/regularization-in-neural-networks-3b9687e1a68c" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">神经网络中的正则化</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">用于正则化神经网络的各种方法的概述</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">becominghuman.ai</p></div></div><div class="no l"><div class="nv l nq nr ns no nt jw nf"/></div></div></a></div><h2 id="6b61" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">或者混合精确训练</h2><div class="nc nd gp gr ne nf"><a href="https://becominghuman.ai/mixed-precision-training-using-fastai-435145d3178b" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">使用 fastai 的混合精确训练</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">图像分类是深度学习的 Hello World。对我来说，这个项目是使用胸部检测肺炎…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">becominghuman.ai</p></div></div><div class="no l"><div class="nw l nq nr ns no nt jw nf"/></div></div></a></div><p id="f219" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者做更复杂的事情比如甘斯。这些只是我们现在知道的事情。更多的调整不断出现。</p><p id="475e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这些调整，我们必须为每个调整编写一个单独的训练循环。当我们想使用它们的组合时，一切都会变得一团糟。</p><p id="c7ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<strong class="ka ir"> <em class="mf">回调</em> </strong>出现的地方。他们帮助我们有效地实现这些调整。让我们看看怎么做。</p><h2 id="7c7c" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">了解回访</h2><p id="ee53" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们首先创建自己的<strong class="ka ir"> <em class="mf">回调对象</em> </strong>。在这些对象中，我们决定了在训练的某一点上我们想要做什么。比如 fastai 中有一个回调叫做<strong class="ka ir"><em class="mf">SaveModelCallback()</em></strong>。该回调检查在每个时期结束时我们是否有更好的模型<strong class="ka ir"><em class="mf"/></strong>，如果有，则<strong class="ka ir"> <em class="mf">保存模型</em> </strong>。这样，我们不仅得到了最后的参数，而且得到了最好的参数。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/5cf641f39fcb428a609932791adf7196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5rAv9p2IkHbmMpBDs_d2A.png"/></div></div></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/bb5e945fe40f23119cf7cb74e872c58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNhxq0OHby3ME0_7UV87dw.png"/></div></div></figure><p id="0f60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，我们可以为学习速率调度、数据增强的混合或梯度裁剪编写回调。点击查看<a class="ae kw" href="https://docs.fast.ai/callbacks.html#SaveModelCallback" rel="noopener ugc nofollow" target="_blank"> fastai 回调的详细列表。</a></p><p id="a7d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是实现一个<code class="fe mb mc md me b">CallbackHandler()</code>。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/5b80c21f152b540f0ecc80cf8b5c2979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLDhmUthPWuyBmOUgwsNRw.png"/></div></div></figure><p id="5151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个类有两个主要目的。</p><ol class=""><li id="1bd2" class="nz oa iq ka b kb kc kf kg kj ob kn oc kr od kv oe of og oh bi translated">它给我们一个地方来存储我们所有的回调(cbs)。</li><li id="7290" class="nz oa iq ka b kb oi kf oj kj ok kn ol kr om kv oe of og oh bi translated">它允许我们很容易地调用所有单独的回调函数。例如，如果我们有 3 个回调函数在一个纪元结束时做了一些事情，那么<code class="fe mb mc md me b">cb.on_epoch_end()</code>将从每个回调对象中调用<code class="fe mb mc md me b">on_epoch_end()</code>方法。</li></ol><p id="b6e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是将这些回访纳入我们的培训循环。我们使用和以前一样的循环，只是稍加修改。在我们的 fit 函数中，我们确保我们遍历了<code class="fe mb mc md me b">all_batches().</code>，并且在所有批次中，我们编写了每个批次要遵循的步骤。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/780bbc2a40b80bfcc0f80beddd9ea52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y64ul00NYE79adcysu418Q.png"/></div></div></figure><p id="b233" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这给了我们很大的灵活性来实现我们想要的东西，而不需要修改原始的训练循环。它让我们在训练期间的不同时间点定义不同的行为，如提前停止或打印各种指标。</p><p id="8bcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们还需要一个<code class="fe mb mc md me b">Callback class</code>，我们的回调对象将从其中继承。这个类有所有可能的行为，所以如果我们的对象没有这些行为，我们的代码不会中断。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/bb1ddd85aa7ddee69468139aa8f2fac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBxSCkfGESUNZegYBufR4Q.png"/></div></div></figure><p id="997e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不喜欢从超类继承，那么你可以使用<code class="fe mb mc md me b">if hasattr(cb, 'on_epoch_end')</code>让它更加灵活。</p><p id="8638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将用一个理解回调的非常简单的例子来结束这篇文章。我们从一个做一些计算的函数开始，然后休眠一段时间。这个函数代表了深度学习中的一个时代。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/60e6e77512927b4055096fdfaa588236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYIOdQKuTSmh5KNVbOEh2A.png"/></div></div></figure><p id="a227" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在计算前后向该函数添加行为，如下所示。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/2c2252c05e05daa0a16a0c56adb712a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJXTul17ZuZ1kuZuuGI04Q.png"/></div></div></figure><p id="772b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以写一个回调函数来处理这些行为。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/d8ba303a031f56fa0f1e445b8ea17443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgEYTNtPSH_Gc3B8goIQzA.png"/></div></div></figure><p id="8ff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是本文的全部内容。</p><p id="1bcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于深度学习的知识，你可以看看我下面的深度学习系列。</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/@dipam44/deep-learning-series-30ad108fbe2b" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">深度学习系列</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">我所有关于深度学习的文章的系统列表</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="or l nq nr ns no nt jw nf"/></div></div></a></div><p id="319e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考文献</strong>:</p><p id="4e63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[1]<a class="ae kw" href="https://docs.fast.ai/callbacks.html#SaveModelCallback" rel="noopener ugc nofollow" target="_blank">https://docs.fast.ai/callbacks.html#SaveModelCallback</a></p><p id="cd1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[2]<a class="ae kw" href="https://medium.com/@edwardeasling/implementing-callbacks-in-fast-ai-1c23de25b6eb" rel="noopener">https://medium . com/@ Edward easling/implementing-callbacks-in-fast-ai-1c 23 de 25 b 6 EB</a></p></div></div>    
</body>
</html>