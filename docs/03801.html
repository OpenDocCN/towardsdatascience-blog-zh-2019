<html>
<head>
<title>LIVE Sentiment Analysis on Twitter Data using Tweepy, Keras, and Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Tweepy、Keras 和 Django 对 Twitter 数据进行实时情感分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/live-sentiment-analysis-on-twitter-data-using-tweepy-keras-and-django-99c344e90488?source=collection_archive---------4-----------------------#2019-06-16">https://towardsdatascience.com/live-sentiment-analysis-on-twitter-data-using-tweepy-keras-and-django-99c344e90488?source=collection_archive---------4-----------------------#2019-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd59b3edaef5cac3d765c5556548247a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CSOrBEN3tb2MerPA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@martenbjork?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marten Bjork</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c47b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎来到这篇关于在推特上进行实时情绪分析的教程。我相信你一定遇到过复杂的仪表板，上面有大量的图表和数字正在被处理，看起来就像科幻电影一样，令人敬畏。这就是我们的目标。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/43bd7da2810620d64e0b559dac0c5b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A7a92sCFdYDQ8wh1.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Some Complex looking dashboard</figcaption></figure><p id="8d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们的最终结果不会像这样广泛，但是，它会教你如何进行必要的数据连接，这样你就可以使它像你想要的那样复杂。你可以继续把它作为一个 SaaS 业务或一个移动应用程序，赚一些钱。我们的结果会是这样的:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/e7ff83ac9011bf89747c50acc09f01cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*romaYePXgiad-GYU.PNG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Our Result</figcaption></figure><blockquote class="lh"><p id="f30d" class="li lj iq bd lk ll lm ln lo lp lq la dk translated">它将对任何标签及其相关上下文进行实时分析，并在新推文出现时向您展示，同时附上一份情感。</p></blockquote><p id="d41f" class="pw-post-body-paragraph kd ke iq kf b kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw lv ky kz la ij bi translated">够兴奋了吧？很好，我们开始吧。本文分为三个部分:</p><ol class=""><li id="1513" class="lw lx iq kf b kg kh kk kl ko ly ks lz kw ma la mb mc md me bi translated">制作模型</li><li id="ada7" class="lw lx iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">制作 UI 界面(前端)</li><li id="c99e" class="lw lx iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">制作后端，获取实时数据，连接一切</li></ol><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/e125c5a09d468b90d7b66c0541fb13a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4h_NDdtWnDZG5Gy8KfFrg.jpeg"/></div></div></figure><h1 id="7fe7" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">1.模特的东西</h1><p id="0031" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">虽然情感分析在自然语言处理中是一个非常常见的话题，但我现在只简要介绍一下模型架构，但稍后我会就此写一篇单独的帖子。</p><p id="23d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用了<a class="ae kc" href="https://www.kaggle.com/kazanova/sentiment140" rel="noopener ugc nofollow" target="_blank">感知 140 数据集</a>进行训练，它包含大约。160 万条推特。在通过规范化清理文本并删除以' @ '开头的用户标签后，我使用了<code class="fe no np nq nr b">gensim </code>包的<em class="ns"> Word2Vec </em>函数在整个语料库上训练它。由于语料库相当庞大，我有足够的数据来训练相当准确的嵌入，否则，我会使用预训练的矢量器。</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="795a" class="nx mm iq nr b gy ny nz l oa ob">#Test word embeddings<br/>w2v_model.most_similar("hate")</span><span id="1902" class="nx mm iq nr b gy oc nz l oa ob">[('suck', 0.5254894495010376),<br/> ('stupid', 0.509635865688324),<br/> ('hat', 0.479534387588501),<br/> ('ugh', 0.4475134015083313),<br/> ('dislike', 0.44565698504447937),<br/> ('despise', 0.43604105710983276),<br/> ('fuck', 0.4104633331298828),<br/> ('annoy', 0.4004197418689728),<br/> ('ughh', 0.3961945176124573),<br/> ('fml', 0.39270931482315063)]</span></pre><p id="43fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我使用了<code class="fe no np nq nr b">keras</code> <em class="ns">标记器</em>将输入数据转换成标记，并添加填充符以使所有输入长度相同。这是 NLP 中数据准备的标准过程。最后，我把准备好的数据传进了一个 LSTM 网络。</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="153c" class="nx mm iq nr b gy ny nz l oa ob">predict("@Nintendo I love your games!")</span><span id="b75b" class="nx mm iq nr b gy oc nz l oa ob">{'score': 0.820274293422699}</span></pre><p id="3b1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的准确率竟然在<strong class="kf ir"> 78.4% </strong>左右，目前来看已经足够好了。整个实现是<a class="ae kc" href="https://github.com/agrawal-rohit/twitter-sentiment-analysis-web-app/blob/master/Twitter%20Sentiment%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank">这里是</a></p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="27ac" class="nx mm iq nr b gy ny nz l oa ob">ACCURACY: 0.784396875<br/>LOSS: 0.45383153524398806</span></pre><p id="122c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我保存了模型(作为一个. h5 文件)和经过训练的 Keras Tokenizer(作为一个. pkl 文件),以便以后在服务器脚本的推理过程中使用它们。您可以在此下载培训文件<a class="ae kc" href="https://github.com/agrawal-rohit/twitter-sentiment-analysis-web-app/tree/master/main_app" rel="noopener ugc nofollow" target="_blank"/></p><blockquote class="od oe of"><p id="e562" class="kd ke ns kf b kg kh ki kj kk kl km kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>我实现了另一个模型，使用 1D 卷积代替 LSTM 网络进行比较，结果提供了几乎相似的结果。对于好奇的学习者，你可以在这里找到这个实现。</p></blockquote></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="3264" class="ml mm iq bd mn mo oq mq mr ms or mu mv mw os my mz na ot nc nd ne ou ng nh ni bi translated">2.UI 前端的东西</h1><p id="ed12" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我使用了<strong class="kf ir"> ReactJS </strong>来构建接口。这是一个 Javascript 框架，通过创建组件并像乐高积木一样重用它们来促进<strong class="kf ir">模块化设计</strong>。每个组件都有其生命周期，因此如果某个组件的数据发生变化，只有该组件会刷新。这减轻了浏览器的负担，并减少了更新信息之间的延迟。</p><p id="1fa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不打算详述我是如何制作这个网站的，因为它只是基本的 CSS 和 Javascript，因此你可以直接研究<a class="ae kc" href="https://github.com/agrawal-rohit/twitter-sentiment-analysis-web-app/tree/master/react-frontend" rel="noopener ugc nofollow" target="_blank">库</a>中的代码。然而，如果你有任何疑问，请在下面留下你的回复，我会很乐意为你解答。</p><h2 id="7f36" class="nx mm iq bd mn ov ow dn mr ox oy dp mv ko oz pa mz ks pb pc nd kw pd pe nh pf bi translated">你只需要知道</h2><p id="e201" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我们有一个名为<code class="fe no np nq nr b"><strong class="kf ir">state</strong> </code>的变量，它属于网站，这里的任何变化都会刷新组件。</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="6b83" class="nx mm iq nr b gy ny nz l oa ob">this.state = {<br/>            hashtag: "",<br/>            options: {<br/>                colors: ['#F7464A', '#46BFBD', '#FDB45C'],<br/>                labels: ['Negative', 'Positive', 'Neutral'],<br/>                plotOptions: {<br/>                pie: {<br/>                  donut: {<br/>                    labels: {<br/>                      show: true<br/>                    }<br/>                  }<br/>                }<br/>              }<br/>            },<br/>            series: [44, 55, 41],<br/>            tweets: [],<br/>            hashtag_desc: ""<br/>        }</span></pre><p id="5642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe no np nq nr b"><strong class="kf ir">hashtag</strong></code>包含输入字段的值，<code class="fe no np nq nr b"><strong class="kf ir">options</strong></code>值属于饼图的一些选项。我们只对一个功能感兴趣:</p><ul class=""><li id="f5fa" class="lw lx iq kf b kg kh kk kl ko ly ks lz kw ma la pg mc md me bi translated">该函数在被调用时会将一个<strong class="kf ir"> GET 请求</strong>连同<code class="fe no np nq nr b"><strong class="kf ir">hashtag</strong> </code>值一起发送到我们位于‘http://localhost:8000/analyzehashtag’的服务器。它需要以下形式的 JSON 响应:</li></ul><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="5507" class="nx mm iq nr b gy ny nz l oa ob">{<br/>...<br/>data: {<br/>    positive: 43,<br/>    negative: 23,<br/>    neutral: 12<br/>    }<br/>...<br/>}</span></pre><ul class=""><li id="a835" class="lw lx iq kf b kg kh kk kl ko ly ks lz kw ma la pg mc md me bi translated">该函数还向公共维基百科 API 发送一个<strong class="kf ir"> GET 请求</strong>，以及<code class="fe no np nq nr b"><strong class="kf ir">hashtag</strong> </code>值，以获取一些关于它的简短信息。</li><li id="a19d" class="lw lx iq kf b kg mf kk mg ko mh ks mi kw mj la pg mc md me bi translated">最后，该函数将另一个 GET 请求连同<code class="fe no np nq nr b"><strong class="kf ir">hashtag</strong> </code>值一起发送到我们位于‘http://localhost:8000/gettweets’的服务器。它需要以下形式的 JSON 响应:</li></ul><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="1c34" class="nx mm iq nr b gy ny nz l oa ob">{<br/>    "results": [<br/>        {<br/>            "text": "Is it possible to wirelessly project my laptop                   to my #Xbox? #XboxOne <a class="ae kc" href="https://t.co/KMuSoD2C5j" rel="noopener ugc nofollow" target="_blank">https://t.co/KMuSoD2C5j</a>",<br/>            "username": "Xbox_One_Reddit",<br/>            "label": "Neutral",<br/>            "score": 0.5679275393486023<br/>        },<br/>        {<br/>            "text": "This year's #E3 had some big #XBOX news for the gaming industry. A glimpse at the future with Scarlet its Next Gen console, promising 4K &amp;amp; 8K gaming, and of course the franchise that started it all... #Halo Infinite announced!\n\nWhich was you favorite?? #E32019 #XboxE3 #Gaming <a class="ae kc" href="https://t.co/tykdIYezmr" rel="noopener ugc nofollow" target="_blank">https://t.co/tykdIYezmr</a>",<br/>            "username": "NrdRnx",<br/>            "label": "Positive",<br/>            "score": 0.9130105972290039<br/>        },<br/>        {<br/>            "text": "DOMED 💀 #apex #apexlegends #apexlegendsxbox #apexlegendsclips #apexlegendscommunity #apexlegendsplays #playapex #controllergang #xbox #mixer #twitch <a class="ae kc" href="https://t.co/itERG2vpaD" rel="noopener ugc nofollow" target="_blank">https://t.co/itERG2vpaD</a>",<br/>            "username": "gle_oh",<br/>            "label": "Negative",<br/>            "score": 0.26629960536956787<br/>        },<br/>        ...<br/>    ]<br/>}</span></pre><p id="f0ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些数据用于填充处理实时 tweets 的组件。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="92a2" class="ml mm iq bd mn mo oq mq mr ms or mu mv mw os my mz na ot nc nd ne ou ng nh ni bi translated">3.后端的东西</h1><p id="9c8a" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">最后，我们进入这篇文章的核心。对于后端，我们将使用 Django 来创建它。</p><blockquote class="od oe of"><p id="3673" class="kd ke ns kf b kg kh ki kj kk kl km kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated">注意:如果你没有后端开发经验，我推荐用 Flask 代替 Django。Flask 对用户非常友好，你可以在几分钟内创建和我在这里做的一样的东西。我使用 Django 是因为我发现部署更容易一些，而且它很容易扩展到更复杂的应用程序。</p></blockquote><p id="9fed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以谷歌如何创建 Django 项目，或者跟随他们文档中给出的教程。完成后，它应该具有以下文件夹结构:</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="251e" class="nx mm iq nr b gy ny nz l oa ob">│   .gitattributes<br/>│   db.sqlite3<br/>│   manage.py<br/>│<br/>├───main_app<br/>│   │   admin.py<br/>│   │   apps.py<br/>│   │   config.py<br/>│   │   models.py<br/>│   │   Sentiment_LSTM_model.h5<br/>│   │   tests.py<br/>│   │   tokenizer.pickle<br/>│   │   twitter_query.py<br/>│   │   views.py<br/>│   │   __init__.py<br/>│   │<br/>│   ├───migrations<br/>│   │<br/>│   └───__pycache__<br/>│           admin.cpython-36.pyc<br/>│           config.cpython-36.pyc<br/>│           models.cpython-36.pyc<br/>│           views.cpython-36.pyc<br/>│           __init__.cpython-36.pyc<br/>│<br/>└───twitter_django<br/>    │   settings.py<br/>    │   urls.py<br/>    │   wsgi.py<br/>    │   __init__.py<br/>    │<br/>    └───__pycache__<br/>            settings.cpython-36.pyc<br/>            urls.cpython-36.pyc<br/>            wsgi.cpython-36.pyc<br/>            __init__.cpython-36.pyc</span></pre><p id="1aaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(而不是<code class="fe no np nq nr b"><strong class="kf ir">main_app</strong></code> <strong class="kf ir"> </strong>和<code class="fe no np nq nr b"><strong class="kf ir">twitter_django</strong></code>，它们将是您选择的应用程序的名称)</p><p id="7c8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Django 用“视图”的概念来封装负责处理用户请求和返回响应的逻辑。因此，我们收到的对服务器的任何请求都将在这里处理。我们使用<code class="fe no np nq nr b"><strong class="kf ir">urls.py</strong></code> <em class="ns"> : </em>来连接视图</p><p id="2c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在一个特定的 URL 端点接收到一个请求时，比如说“/gettweets”，它触发指定的函数——在本例中是“views.gettweets”。功能的逻辑写在<code class="fe no np nq nr b"><strong class="kf ir">views.py</strong></code> <em class="ns">中。</em></p><p id="7069" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这几行:</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="75be" class="nx mm iq nr b gy ny nz l oa ob">global graph<br/>graph = tf.get_default_graph()<br/>model = load_model('main_app/Sentiment_LSTM_model.h5')</span></pre><p id="d307" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有图表，您就无法运行您的模型来获得预测(因为 Tensorflow 的工作方式)。如果你试着跑，' model.predict(..)'而没有指定图形，您将得到一个错误。因此，当你试图使用你的模型时，不要忘记加上:</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="2918" class="nx mm iq nr b gy ny nz l oa ob">with graph.as_default():            <br/>    prediction = model.predict(...)</span></pre><h2 id="60b0" class="nx mm iq bd mn ov ow dn mr ox oy dp mv ko oz pa mz ks pb pc nd kw pd pe nh pf bi translated">十二岁</h2><p id="6988" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">如果你想从 Twitter 获取数据，Tweepy 就像是一个包。你可以使用<code class="fe no np nq nr b">pip.</code>来安装它，你所需要的只是一些独特的密钥。这些密钥可以通过在<a class="ae kc" href="https://developer.twitter.com/en.html" rel="noopener ugc nofollow" target="_blank"> Twitter 开发者网站</a>注册一个应用程序来获得。</p><p id="bc1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦完成，我们可以将<code class="fe no np nq nr b">tweepy </code>初始化为:</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="06c9" class="nx mm iq nr b gy ny nz l oa ob"># Twitter<br/>auth = tweepy.OAuthHandler(consumer_key,consumer_secret)<br/>auth.set_access_token(access_token, access_token_secret)<br/>api = tweepy.API(auth,wait_on_rate_limit=True)</span></pre><p id="f923" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在要获取 tweets，我们可以调用 Cursor 函数。我们使用了一个定制的搜索标签(从前端接收)并收集了相同的 tweets。</p><blockquote class="od oe of"><p id="45d3" class="kd ke ns kf b kg kh ki kj kk kl km kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>我使用<code class="fe no np nq nr b"><em class="iq">“ -filter:retweets”</em></code>是为了只获得唯一的推文，否则，由于不同的转发频率，情感标签可能会有偏差。</p></blockquote><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="5852" class="nx mm iq nr b gy ny nz l oa ob">tweepy.Cursor(api.search,q="#" + request.GET.get("text") + " -filter:retweets",rpp=5,lang="en", tweet_mode='extended').items(100)</span></pre><h2 id="2498" class="nx mm iq bd mn ov ow dn mr ox oy dp mv ko oz pa mz ks pb pc nd kw pd pe nh pf bi translated">制作一个 REST API</h2><p id="ebdd" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我们的服务器有两个重要的功能:</p><ol class=""><li id="ca5d" class="lw lx iq kf b kg kh kk kl ko ly ks lz kw ma la mb mc md me bi translated"><code class="fe no np nq nr b"><strong class="kf ir">analyzehashtag()</strong> </code> —接受标签值，使用 tweepy 获得该标签的大量 tweets，并对每个 tweepy 执行情感分析。最后，通过简单地统计观察结果，计算积极、消极和中性推文在特定标签中的分布。</li></ol><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="b86d" class="nx mm iq nr b gy ny nz l oa ob">def analyzehashtag(request):    <br/>positive = 0    <br/>neutral = 0    <br/>negative = 0    <br/>for tweet in tweepy.Cursor(api.search,q="#" + request.GET.get("text") + " -filter:retweets",rpp=5,lang="en", tweet_mode='extended').items(100):        <br/>    with graph.as_default():            <br/>    prediction = predict(tweet.full_text) <br/>           if(prediction["label"] == "Positive"):    <br/>        positive += 1       <br/>           if(prediction["label"] == "Neutral"):<br/>           neutral += 1<br/>        if(prediction["label"] == "Negative"):<br/>            negative += 1<br/>    return JsonResponse({"positive": positive, "neutral": neutral, "negative": negative});</span></pre><p id="0606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<code class="fe no np nq nr b"><strong class="kf ir">gettweets()</strong></code><strong class="kf ir"/>—这与第一个函数类似，但它不是计算分布，而是收集更少数量的推文并返回每个推文的结果。这样我们可以实时显示我们的模型的熟练程度，并检查它是否符合我们的常识。</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="77ba" class="nx mm iq nr b gy ny nz l oa ob">def gettweets(request):<br/>    tweets = []<br/>    for tweet in tweepy.Cursor(api.search,q="#" + request.GET.get("text") + " -filter:retweets",rpp=5,lang="en", tweet_mode='extended').items(50):<br/>        temp = {}<br/>        temp["text"] = tweet.full_text<br/>        temp["username"] = tweet.user.screen_name<br/>        with graph.as_default():<br/>            prediction = predict(tweet.full_text)<br/>        temp["label"] = prediction["label"]<br/>        temp["score"] = prediction["score"]<br/>        tweets.append(temp)<br/>    return JsonResponse({"results": tweets});</span></pre><p id="f40b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为了让我们的前端能够访问这些函数，我们将把这些函数作为 API。使用<strong class="kf ir"> Django REST 框架</strong>可以很容易地做到这一点。</p><p id="c54f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只需使用<code class="fe no np nq nr b">pip install djangorestframework</code>安装，并在每个功能前添加<code class="fe no np nq nr b"><a class="ae kc" href="http://twitter.com/api_view" rel="noopener ugc nofollow" target="_blank">@api_view</a>([“GET”])</code>。(因为我们在这里只使用了 2 个 GET 请求，所以我在这里只使用 GET)。</p><p id="4978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记在<code class="fe no np nq nr b">settings.py</code>文件中添加以下内容。</p><pre class="lc ld le lf gt nt nr nu nv aw nw bi"><span id="3dca" class="nx mm iq nr b gy ny nz l oa ob">INSTALLED_APPS = [<br/>    'django.contrib.admin',<br/>    'django.contrib.auth',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/>    'rest_framework',<br/>    'corsheaders',<br/>    'main_app'<br/>]</span></pre><h1 id="7800" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">结论</h1><p id="f50d" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">使用<code class="fe no np nq nr b">python manage.py runserver</code>运行服务器，享受洞察“人们对新选举的反应”，或者“人们喜欢赛博朋克 2077 预告片中的基努·里维斯客串吗”。发疯吧！</p><p id="fb01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的 GitHub 上有完整的代码和安装说明。如果你愿意，可以去看看。再见</p><div class="ph pi gp gr pj pk"><a href="https://github.com/agrawal-rohit?tab=repositories" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd ir gy z fp pp fr fs pq fu fw ip bi translated">agrawal-rohit —概述</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">拥有 3 年以上项目工作经验的初级数据科学家和软件开发人员。高度熟练的机器…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">github.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py jw pk"/></div></div></a></div></div></div>    
</body>
</html>