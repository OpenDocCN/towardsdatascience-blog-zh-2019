<html>
<head>
<title>Outlier Detection with Hampel Filter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Hampel 滤波器的异常检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/outlier-detection-with-hampel-filter-85ddf523c73d?source=collection_archive---------6-----------------------#2019-09-26">https://towardsdatascience.com/outlier-detection-with-hampel-filter-85ddf523c73d?source=collection_archive---------6-----------------------#2019-09-26</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/a553273761aa50823b00fac811b4c0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rnNNfL0FeVZG5y-C5uj7A.jpeg"/></div></div><figcaption class="je jf gj gh gi jg jh bd b be z dk">Source: <a class="ae ji" href="https://pixabay.com/photos/lemon-citrus-fruit-juicy-acid-3303842/" rel="noopener ugc nofollow" target="_blank">pixabay</a></figcaption></figure><div class=""/><div class=""><h2 id="32de" class="pw-subtitle-paragraph ki jk jl bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dk translated">如何用 Python 从头开始实现 Hampel 过滤器</h2></div><p id="c1da" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">最近，我偶然发现了一种新的(对我来说)异常值检测算法 Hampel 过滤器。在这篇短文中，我想描述一下它是如何工作的，以及如何在实践中使用它。据我所知，没有包含该算法的 Python 库，所以我们将使用两种不同的方法(<code class="fe lw lx ly lz b">for-loop</code>和<code class="fe lw lx ly lz b">pandas</code>)从头实现它。最终，我们将会看到在执行速度方面，哪一个的表现更好。</p><p id="e7eb" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated"><strong class="lc jm">更新</strong> : Hampel 过滤器在<code class="fe lw lx ly lz b">sktime</code>实现，你可以在<a class="ae ji" href="https://www.sktime.org/en/latest/api_reference/auto_generated/sktime.transformations.series.outlier_detection.HampelFilter.html?highlight=hampel" rel="noopener ugc nofollow" target="_blank">这里</a>找到更多关于它的信息。</p><h1 id="1578" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">汉佩尔过滤器</h1><p id="72da" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">让我们从一个快速的理论介绍开始。描述该算法的在线资源并不多(甚至维基百科上也没有页面)，但它足够简单，可以快速理解其中的逻辑。还有，我在文末放了一些参考资料。</p><p id="3f16" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">Hampel 过滤器的目标是识别和替换给定系列中的异常值。它使用一个可配置宽度的滑动窗口来浏览数据。对于每个窗口(给定观察和<code class="fe lw lx ly lz b">2 window_size</code>周围元素，每侧<code class="fe lw lx ly lz b">window_size</code>，我们计算中值和标准偏差，表示为<a class="ae ji" href="https://en.wikipedia.org/wiki/Median_absolute_deviation" rel="noopener ugc nofollow" target="_blank">中值绝对偏差</a>。</p><p id="9572" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">为了使 MAD 成为标准偏差的一致估计量，我们必须将其乘以一个常数比例因子<em class="mx"> k </em>。该因子取决于分布，对于高斯分布，该因子约为 1.4826。</p><p id="74f2" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">如果考虑的观察值与窗口中值的差异超过<em class="mx"> x </em>标准偏差，我们将其视为异常值并用中值代替。</p><p id="8610" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">Hampel 滤波器有两个可配置的参数:</p><ul class=""><li id="2975" class="my mz jl lc b ld le lg lh lj na ln nb lr nc lv nd ne nf ng bi translated">滑动窗口的大小</li><li id="da09" class="my mz jl lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">识别异常值的标准偏差的数量</li></ul><p id="cd6b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们根据用例选择这两个参数。较高的标准差阈值使过滤器更宽容，较低的标准差阈值将更多的点识别为异常值。将阈值设置为 0 对应于 John Tukey 的中值滤波器。</p><p id="9228" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">由于过滤器使用滑动窗口，因此将其用于时间序列数据最有意义，其中数据的顺序由时间决定。</p><h1 id="a9ad" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">Python 实现</h1><h2 id="e29d" class="nm mb jl bd mc nn no dn mg np nq dp mk lj nr ns mm ln nt nu mo lr nv nw mq nx bi translated">导入库</h2><p id="ca16" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">第一步是导入所需的库。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="775d" class="nm mb jl lz b gy og oh l oi oj">import matplotlib.pyplot as plt<br/>import warnings<br/>import pandas as pd<br/>import numpy as np</span></pre><h2 id="f4b4" class="nm mb jl bd mc nn no dn mg np nq dp mk lj nr ns mm ln nt nu mo lr nv nw mq nx bi translated">有异常值的随机游走</h2><p id="9dbc" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">在实现算法之前，我们使用<a class="ae ji" href="https://en.wikipedia.org/wiki/Random_walk" rel="noopener ugc nofollow" target="_blank">随机漫步</a>创建一个人工数据集。我们定义了一个函数，它接受异常值的百分比作为参数，并通过一个常数乘数随机缩放一些随机游走增量。</p><figure class="ny nz oa ob gt ix"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="66c0" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">使用该函数，我们生成人工数据，并将其绘制如下，以及引入的异常值。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="8be3" class="nm mb jl lz b gy og oh l oi oj">rw, outlier_ind = random_walk_with_outliers(0, 1000, 0.01)</span><span id="4979" class="nm mb jl lz b gy om oh l oi oj">plt.plot(np.arange(len(rw)), rw)<br/>plt.scatter(outlier_ind, rw[outlier_ind], c='r', label='outlier')<br/>plt.title('Random Walk with outliers')<br/>plt.xlabel('Time steps')<br/>plt.ylabel('Values')<br/>plt.legend();</span></pre><figure class="ny nz oa ob gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi on"><img src="../Images/eedd97f001f6d22fdfb5efa227c8bccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8u1vta7A7weuVyaLtYHMw.png"/></div></div></figure><h2 id="13a5" class="nm mb jl bd mc nn no dn mg np nq dp mk lj nr ns mm ln nt nu mo lr nv nw mq nx bi translated">评估结果</h2><p id="6eb1" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">我们还需要定义一个函数来评估异常值检测算法的结果。为此，我们将绘制实际与检测到的异常值，并返回一个简短的性能总结。</p><figure class="ny nz oa ob gt ix"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="d329" class="nm mb jl bd mc nn no dn mg np nq dp mk lj nr ns mm ln nt nu mo lr nv nw mq nx bi translated">Hampel 滤波器实现</h2><ol class=""><li id="6d22" class="my mz jl lc b ld ms lg mt lj oo ln op lr oq lv or ne nf ng bi translated"><code class="fe lw lx ly lz b"><strong class="lc jm">for-loop</strong></code> <strong class="lc jm">实现</strong></li></ol><p id="819f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们从 Hampel 滤波器的<code class="fe lw lx ly lz b">for-loop</code>实现开始。我们基于来自<code class="fe lw lx ly lz b">pracma</code> R 包的代码。</p><figure class="ny nz oa ob gt ix"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="376b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们在 RW 系列上运行算法。我们选择了窗口大小 10，但是这应该根据最佳性能的经验来确定。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="a7bb" class="nm mb jl lz b gy og oh l oi oj">res, detected_outliers = hampel_filter_forloop(rw, 10)</span></pre><p id="b894" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们使用之前定义的帮助函数来评估结果。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="81b0" class="nm mb jl lz b gy og oh l oi oj">tp, fp, fn = evaluate_detection(rw, outlier_ind, detected_outliers)</span></pre><figure class="ny nz oa ob gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi os"><img src="../Images/0c3ff3df0caaaccf4631e7edce3b4d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAHx9cEREnpgI_s37poifA.png"/></div></div><figcaption class="je jf gj gh gi jg jh bd b be z dk">Evaluation of the for-loop implementation</figcaption></figure><p id="3c81" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在图中，我们可以看到，该算法正确识别了 8 个(10 个中的)异常值，将一个观察值误认为异常值(红点)并遗漏了 2 个异常值(黑点)。也许通过调整窗口大小可以获得更好的性能。然而，这对于练习的目的来说已经足够了。</p><p id="3763" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们还绘制了转换后的序列，其中异常值被窗口中值所取代。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="79ea" class="nm mb jl lz b gy og oh l oi oj">plt.plot(np.arange(len(res)), res);<br/>plt.scatter(outlier_ind, rw[outlier_ind], c='g', label='true outlier')<br/>plt.scatter(fp, rw[fp], c='r', label='false positive')<br/>plt.title('Cleaned series (without detected outliers)')<br/>plt.legend();</span></pre><figure class="ny nz oa ob gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ot"><img src="../Images/10ab8ca956bd8ae0cca712864203fa7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BL6E4rTlLnKi-Y31cnpgZQ.png"/></div></div><figcaption class="je jf gj gh gi jg jh bd b be z dk">Transformed series (removed outliers)</figcaption></figure><p id="14fb" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">2.<code class="fe lw lx ly lz b"><strong class="lc jm">pandas</strong></code> <strong class="lc jm">实现</strong></p><p id="16fd" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">对于<code class="fe lw lx ly lz b">pandas</code>的实现，我们使用了<code class="fe lw lx ly lz b">pd.Series</code>和 lambda 函数的<code class="fe lw lx ly lz b">rolling</code>方法。</p><figure class="ny nz oa ob gt ix"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="800e" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在<code class="fe lw lx ly lz b">rolling</code>方法中，我们指定两倍的窗口大小并使用居中，因此所考虑的观察在<code class="fe lw lx ly lz b">2 * window_size + 1</code>窗口的中间。在运行算法之前，我们将 RW 从<code class="fe lw lx ly lz b">np.ndarray</code>转换为<code class="fe lw lx ly lz b">pd.Series</code>。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="7423" class="nm mb jl lz b gy og oh l oi oj">rw_series = pd.Series(rw)<br/>res, detected_outliers = hampel_filter_pandas(rw_series, 10)<br/>tp, fp, fn = evaluate_detection(rw, outlier_ind, detected_outliers)</span></pre><figure class="ny nz oa ob gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ou"><img src="../Images/afbaa6767951fae4fcc245bfc5e2b866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clIfzIFvh5yVb8Q2d-ljZw.png"/></div></div><figcaption class="je jf gj gh gi jg jh bd b be z dk">Evaluation of the pandas implementation</figcaption></figure><p id="634c" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">两种方法的结果是相同的，这总是一个好现象:)</p><h2 id="752d" class="nm mb jl bd mc nn no dn mg np nq dp mk lj nr ns mm ln nt nu mo lr nv nw mq nx bi translated">性能比较</h2><p id="7867" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">此时，我们从执行速度的角度对这两个实现进行测试。我们预计<code class="fe lw lx ly lz b">pandas</code>会运行得更快。</p><p id="5edd" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">首先，我们测试<code class="fe lw lx ly lz b">for-loop</code>实现:</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="24f4" class="nm mb jl lz b gy og oh l oi oj">%%timeit<br/>res, detected_outliers = hampel_filter_forloop(rw, 10)</span><span id="76ea" class="nm mb jl lz b gy om oh l oi oj"># 67.9 ms ± 990 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="63dd" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">然后，我们对<code class="fe lw lx ly lz b">pandas</code>实现运行类比测试:</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="36d5" class="nm mb jl lz b gy og oh l oi oj">%%timeit<br/>res, detected_outliers = hampel_filter_pandas(rw_series, 10)</span><span id="cc05" class="nm mb jl lz b gy om oh l oi oj"># 76.1 ms ± 4.37 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="e159" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们看到<code class="fe lw lx ly lz b">pandas</code>实现变得更慢。要测试的一个假设是，对于更大的系列，<code class="fe lw lx ly lz b">pandas</code>实现会更快。这就是为什么我们也将随机漫步系列的长度增加到 100000，并再次测试性能。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="16e0" class="nm mb jl lz b gy og oh l oi oj">rw, outlier_ind = random_walk_with_outliers(0, 10 ** 5, 0.01)<br/>rw_series = pd.Series(rw)</span></pre><p id="042d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">准备好数据后，我们开始测试性能:</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="ebd6" class="nm mb jl lz b gy og oh l oi oj">%%timeit<br/>res, detected_outliers = hampel_filter_forloop(rw, 10)<br/># 6.75 s ± 203 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><span id="a869" class="nm mb jl lz b gy om oh l oi oj">%%timeit<br/>res, detected_outliers = hampel_filter_pandas(rw_series, 10)<br/># 6.76 s ± 30.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="22b3" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">事实证明，现在他们获得了相当的性能，而<code class="fe lw lx ly lz b">pandas</code>实现提供了更稳定的性能(更低的标准偏差)。</p><h2 id="8b42" class="nm mb jl bd mc nn no dn mg np nq dp mk lj nr ns mm ln nt nu mo lr nv nw mq nx bi translated">奖励:用<code class="fe lw lx ly lz b">numba</code>增加循环的速度</h2><p id="92b5" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">作为奖励，我们探索了用<code class="fe lw lx ly lz b">numba</code>加速基于 for 循环的代码的可能性。<code class="fe lw lx ly lz b">numba</code>是一个将 Python 代码翻译成优化的机器代码的库。考虑到转换代码的可能性，<code class="fe lw lx ly lz b">numba</code>可以让某些用 Python 编写的算法接近 c 语言的速度。</p><p id="5ec8" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">关于<code class="fe lw lx ly lz b">numba</code>最好的部分是(如果可能的话)在编码方面，速度提升的代价非常小。我们需要导入这个库，并在我们想要翻译成机器码的函数之前添加<code class="fe lw lx ly lz b"><a class="ae ji" href="http://twitter.com/jit" rel="noopener ugc nofollow" target="_blank">@jit</a></code>装饰器。</p><figure class="ny nz oa ob gt ix"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="15f9" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated"><code class="fe lw lx ly lz b">nopython</code>参数表明我们是希望<code class="fe lw lx ly lz b">numba</code>使用纯机器代码还是在必要时使用一些 Python 代码。理想情况下，只要<code class="fe lw lx ly lz b">numba</code>没有返回错误，这应该总是设置为<code class="fe lw lx ly lz b">true</code>。</p><p id="cb82" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">下面我们测试执行速度。</p><pre class="ny nz oa ob gt oc lz od oe aw of bi"><span id="84c9" class="nm mb jl lz b gy og oh l oi oj">%%timeit<br/>res, detected_outliers = hampel_filter_forloop_numba(rw, 10)<br/># 108 ms ± 1.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="2760" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">与实施<code class="fe lw lx ly lz b">pandas</code>的 6.76 秒相比，这只需要 108 毫秒！这是一个大约 63 倍的大规模加速！</p><h1 id="9ac7" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">结论</h1><p id="1096" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">总之，在本文中，我们解释了 Hampel 过滤器如何在异常值检测方面工作，以及如何在 Python 中实现它。我们还从执行速度的角度比较了这些实现。</p><p id="5b13" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">考虑 Hampel 滤波器的缺点也是有好处的:</p><ul class=""><li id="4ffd" class="my mz jl lc b ld le lg lh lj na ln nb lr nc lv nd ne nf ng bi translated">它在序列的开始和结束时检测异常值有问题——当窗口不完整时(即使在一侧),该函数不会检测到可能的异常值</li><li id="5d27" class="my mz jl lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">当离群值在窗口范围内彼此接近时，它很难检测到离群值</li></ul><p id="8375" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">一如既往，我们欢迎任何建设性的反馈。你可以在推特上或评论中联系我。你可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Machine%20Learning/outlier_detection_hampel_filter.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。</p><p id="8f31" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">喜欢这篇文章吗？成为一个媒介成员，通过无限制的阅读继续学习。如果你使用<a class="ae ji" href="https://eryk-lewinson.medium.com/membership" rel="noopener">这个链接</a>成为会员，你将支持我，而不需要额外的费用。提前感谢，再见！</p><h1 id="efbc" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">参考</h1><ul class=""><li id="6e8d" class="my mz jl lc b ld ms lg mt lj oo ln op lr oq lv nd ne nf ng bi translated">Hampel F. R .,“影响曲线及其在稳健估计中的作用”，美国统计协会杂志，69，382–393，1974 年</li><li id="c7ff" class="my mz jl lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">刘、韩聪、西里沙、。"在线异常检测和数据清理."计算机和化学工程。第 28 卷，2004 年 3 月，第 1635-1647 页</li><li id="1317" class="my mz jl lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">苏梅拉，朱卡。"中值滤波相当于排序."2014</li></ul></div></div>    
</body>
</html>