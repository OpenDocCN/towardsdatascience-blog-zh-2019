<html>
<head>
<title>How to Handle Privileges in PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 PostgreSQL 中处理特权</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-handle-privileges-in-postgresql-with-specific-use-case-and-code-458fbdb67a73?source=collection_archive---------3-----------------------#2019-10-25">https://towardsdatascience.com/how-to-handle-privileges-in-postgresql-with-specific-use-case-and-code-458fbdb67a73?source=collection_archive---------3-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b89e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我曾经低估了内部工具处理特权的重要性，或者至少误解了它的意图。我将在这里讨论的用例是一个数据库集群，其中的用户是一个研究小组中的研究人员。因为这是一个小团体，本质上每个人都有权利阅读和修改数据。当我被要求将集群迁移到新的服务器并在此之前做一些数据清理时，问题就暴露出来了。事实证明</p><ul class=""><li id="7137" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">大多数数据库都没有很好的文档记录，人们很难弄清楚一些旧数据库的语义。这个问题可以通过<a class="ae ku" href="http://schemaspy.org/" rel="noopener ugc nofollow" target="_blank"> schemaspy </a>和 PostgreSQL 自己的<a class="ae ku" href="https://www.postgresql.org/docs/12/sql-comment.html" rel="noopener ugc nofollow" target="_blank">注释</a>这样的工具部分解决。</li><li id="a372" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">有些字段使用类似于<code class="fe la lb lc ld b">varchar(n)</code>的类型，但是只存储数值——我通过模式匹配查询发现了这一点。</li><li id="9212" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">一个数据库有多个名为<code class="fe la lb lc ld b">xyz-[year]</code>的模式，模式间有重复的数据。从第一点，你可以看到我不知道这样的设计是故意的还是简单的错误。</li></ul><p id="7164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，即使没有人想以任何方式破坏数据，由于缺乏权限管理和使用数据库的明确准则，人们也可以很容易地将数据库集群弄得一团糟，维护数据变得极其困难。这些问题很大程度上是由于学术界的研究人员非常独立地工作，他们主要关心的是做自己的研究项目。确保每个人在数据库集群中做出正确的行动实际上是不可能的。我们决定在新的服务器中限制用户的权限，当创建、删除和更新发生时，必须通知数据库管理员。</p><p id="91e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地用代码演示我们的解决方案，假设现在我们组中只有五个人。<code class="fe la lb lc ld b">postgres</code>将是管理员用户。<code class="fe la lb lc ld b">user1</code>和<code class="fe la lb lc ld b">user2</code>负责数据库<code class="fe la lb lc ld b">demo12</code>。<code class="fe la lb lc ld b">user3</code>和<code class="fe la lb lc ld b">user4</code>为<code class="fe la lb lc ld b">demo34</code>。我们希望只允许人们在数据库管理员的许可下在他们负责的数据库上写。每个人仍然可以读取所有数据。总而言之，我们希望在数据库级别获得<strong class="jp ir">写访问的粒度，在集群级别</strong>获得<strong class="jp ir">读访问的粒度。</strong></p><p id="a20c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="le">旁注:小心混淆 PostgreSQL 和 MySQL 中的“数据库”概念。粗略地说，PostgreSQL 中有表&lt;模式&lt;数据库&lt;集群。“&lt;”应读作“包含于”。</em></p><p id="c438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PostgreSQL 中没有简单的内置解决方案。如果你阅读了<code class="fe la lb lc ld b">GRANT</code>的文档，听起来下面的代码应该已经解决了我们一半的问题</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="e32d" class="ln lo iq ld b gy lp lq l lr ls">GRANT CREATE, CONNECT, TEMPORARY ON DATABASE demo12 TO user1, user2;<br/>GRANT CREATE, CONNECT, TEMPORARY ON DATABASE demo34 TO user3, user4;</span></pre><p id="876b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，事实并非如此。这个 StackOverflow 帖子说明了我们必须处理的繁重工作。</p><p id="183d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，向用户 1/2/3/4 授予相应的权限并不是一个可伸缩的解决方案。首先，这个组中实际上有超过五个人，并且在我们的集群中有超过两个数据库。此外，新的人可能会加入小组，而现有的研究人员将在某个时候离开。为每个用户的特权记账不是一个非常干净的解决方案。</p><p id="7fad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将结合使用 PostgreSQL 的<code class="fe la lb lc ld b">ROLE</code>和<code class="fe la lb lc ld b">USER</code>来构建一个简单的层次结构，如下所示:</p><figure class="lf lg lh li gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lt"><img src="../Images/ce5452ce721f8d640521834abb554b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5xiYEtQgmjuiZ_QfETUpw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Dotted circles represent roles and solid circles represent our users. Rounded squares are our databases. Meanings of the arrows are explained by the demo below.</figcaption></figure><p id="e210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PostgreSQL 中的<code class="fe la lb lc ld b">ROLE</code>和<code class="fe la lb lc ld b">USER</code>会造成很大的混乱。但是从我正在使用的版本 10 开始，文档清楚地说</p><blockquote class="mf mg mh"><p id="1eef" class="jn jo le jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><code class="fe la lb lc ld b">CREATE USER</code>现在是<code class="fe la lb lc ld b"><em class="iq">CREATE ROLE</em></code>的别名。唯一的区别是当命令拼写为<code class="fe la lb lc ld b">CREATE USER</code>时，默认情况下假定为<code class="fe la lb lc ld b">LOGIN</code>，而当命令拼写为<code class="fe la lb lc ld b">CREATE ROLE</code>时假定为<code class="fe la lb lc ld b">NOLOGIN</code>。</p><p id="24fc" class="jn jo le jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">SQL 标准将用户的定义留给实现。</p></blockquote><p id="980e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多人将<code class="fe la lb lc ld b">ROLE</code>用作包含多个<code class="fe la lb lc ld b">USER</code>的“组”角色。我们在这里也将以这种方式思考。</p><p id="58e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，如果您想知道为什么处理 PostgreSQL 的特权值得写一篇文章，这里给出了其中一个原因</p><blockquote class="mf mg mh"><p id="dc4a" class="jn jo le jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">请注意，角色是在数据库集群级别定义的，因此在集群中的所有数据库中都有效。</p></blockquote><p id="c9db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们需要数据库级别的写权限，但是角色是在集群级别定义的。更糟糕的是，应该调用<code class="fe la lb lc ld b">GRANT</code>(和<code class="fe la lb lc ld b">REVOKE</code>)……我想在我们的例子中的每一层都应该调用。虽然这些概念应该很好地协同工作来帮助管理系统中的用户，但它们似乎是由许多人以不同的设计思想设计的。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="9050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听够了我的抱怨。让我们静观其变。</p><h1 id="881a" class="ms lo iq bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">设置</h1><p id="4823" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">我们首先创建一些应该存在于系统中的角色和用户。</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="41ba" class="ln lo iq ld b gy lp lq l lr ls">$ psql -U postgres</span><span id="5cdf" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE ROLE readonly;</span><span id="dfab" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE ROLE rw_demo12;</span><span id="bf3a" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE ROLE rw_demo34;</span><span id="d075" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user1 ENCRYPTED PASSWORD 'user1';</span><span id="82e9" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user2 ENCRYPTED PASSWORD 'user2';</span><span id="de65" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user3 ENCRYPTED PASSWORD 'user3';</span><span id="0cc1" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user4 ENCRYPTED PASSWORD 'user4';</span><span id="f52f" class="ln lo iq ld b gy nu lq l lr ls">postgres=# GRANT readonly TO user1, user2, user3, user4;</span><span id="1e26" class="ln lo iq ld b gy nu lq l lr ls">postgres=# GRANT rw_demo12 TO user1, user2;</span><span id="f3d6" class="ln lo iq ld b gy nu lq l lr ls">postgres=# GRANT rw_demo34 TO user3, user4;</span></pre><p id="c774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我事先在两个数据库中都注入了一些虚拟数据。这里显示了我们的数据库中有什么。</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="1abb" class="ln lo iq ld b gy lp lq l lr ls">demo12(demo34)=# \dn</span><span id="cad9" class="ln lo iq ld b gy nu lq l lr ls">List of schemas</span><span id="354c" class="ln lo iq ld b gy nu lq l lr ls">Name | Owner</span><span id="c160" class="ln lo iq ld b gy nu lq l lr ls">----------+----------</span><span id="9965" class="ln lo iq ld b gy nu lq l lr ls">public | postgres</span><span id="0099" class="ln lo iq ld b gy nu lq l lr ls">(3 rows)</span><span id="4b21" class="ln lo iq ld b gy nu lq l lr ls">demo12(demo34)=# \d</span><span id="d5f7" class="ln lo iq ld b gy nu lq l lr ls">List of relations</span><span id="3596" class="ln lo iq ld b gy nu lq l lr ls">Schema |     Name     | Type  |  Owner</span><span id="e8e5" class="ln lo iq ld b gy nu lq l lr ls">--------+--------------+-------+----------</span><span id="872c" class="ln lo iq ld b gy nu lq l lr ls">public | departments  | table | postgres</span><span id="7680" class="ln lo iq ld b gy nu lq l lr ls">public | dept_emp     | table | postgres</span><span id="184e" class="ln lo iq ld b gy nu lq l lr ls">public | dept_manager | table | postgres</span><span id="c9c8" class="ln lo iq ld b gy nu lq l lr ls">public | employees    | table | postgres</span><span id="3903" class="ln lo iq ld b gy nu lq l lr ls">public | salaries     | table | postgres</span><span id="d9ad" class="ln lo iq ld b gy nu lq l lr ls">public | titles       | table | postgres</span><span id="a323" class="ln lo iq ld b gy nu lq l lr ls">(6 rows)</span></pre><h1 id="99dd" class="ms lo iq bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">配置<code class="fe la lb lc ld b">"readonly"</code></h1><p id="8ad4" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">我们现在将授予<code class="fe la lb lc ld b">readonly</code>读取集群中所有数据库的权限。在外层的<code class="fe la lb lc ld b">FOR</code>循环中，我们遍历每个想要设置特权的数据库。在内部的<code class="fe la lb lc ld b">FOR</code>循环中，我们遍历每个数据库中的所有模式。</p><figure class="lf lg lh li gt lu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b55a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有不止一个数据库<code class="fe la lb lc ld b">demo12</code>和<code class="fe la lb lc ld b">demo34</code>，并且我们想要为所有数据库配置<code class="fe la lb lc ld b">readonly</code>角色，我们可以使用</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="2ca1" class="ln lo iq ld b gy lp lq l lr ls">DATABASE_NAMES=$(psql -U postgres -t -c “SELECT datname FROM pg_database WHERE datistemplate = false AND datname &lt;&gt; ‘postgres’;”)</span></pre><p id="1853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取集群中所有数据库的列表。然后简单的把<code class="fe la lb lc ld b">for DBNAME in "demo12" "demo34"</code>换成<code class="fe la lb lc ld b">for DBNAME in $DATBASE_NAMES</code>。</p><p id="2764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想知道<code class="fe la lb lc ld b">GRANT</code>和<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES</code>之间的区别，以及为什么前者需要放在一个循环中，而后者不需要。简而言之，<code class="fe la lb lc ld b">GRANT</code>改变数据库中特定模式中<strong class="jp ir">当前</strong>对象的权限，而<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES</code>改变数据库中<strong class="jp ir">未来</strong>对象的权限。是的，当我们在<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES</code>中没有指定任何特定的模式时，这些更改会应用到整个数据库。所以又多了一个不同步的命令:<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES</code>可以在数据库级别调用，但是<code class="fe la lb lc ld b">GRANT</code>不能。</p><p id="f38f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你注意到<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES</code>命令中的<code class="fe la lb lc ld b">FOR ROLE postgres</code>部分了吗？密切注意，看看它一会儿能怎样欺骗我们。</p><h1 id="8205" class="ms lo iq bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">配置<code class="fe la lb lc ld b">"rw_demo12" and "rw_demo12"</code></h1><figure class="lf lg lh li gt lu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2da1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看下面的代码会发生什么。</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="a39f" class="ln lo iq ld b gy lp lq l lr ls">$ psql -d demo12 -U user1 -W</span><span id="d500" class="ln lo iq ld b gy nu lq l lr ls">demo12=&gt; create schema foo;</span><span id="83ba" class="ln lo iq ld b gy nu lq l lr ls">CREATE SCHEMA</span><span id="5b78" class="ln lo iq ld b gy nu lq l lr ls">demo12=&gt; create table foo.bar(col1 int);</span><span id="5b1f" class="ln lo iq ld b gy nu lq l lr ls">CREATE TABLE</span><span id="146a" class="ln lo iq ld b gy nu lq l lr ls">demo12=&gt; insert into foo.bar values(1);</span><span id="4985" class="ln lo iq ld b gy nu lq l lr ls">INSERT 0 1</span><span id="9d0c" class="ln lo iq ld b gy nu lq l lr ls">demo12=&gt; \c demo12 user3</span><span id="e1c4" class="ln lo iq ld b gy nu lq l lr ls">You are now connected to database "demo12" as user "user3".</span><span id="9a99" class="ln lo iq ld b gy nu lq l lr ls">demo12=&gt; select * from foo.bar;</span><span id="d0c0" class="ln lo iq ld b gy nu lq l lr ls">ERROR:  permission denied for schema foo</span><span id="de9d" class="ln lo iq ld b gy nu lq l lr ls">LINE 1: select * from foo.bar;</span><span id="1515" class="ln lo iq ld b gy nu lq l lr ls">demo12=&gt; \dn</span><span id="408c" class="ln lo iq ld b gy nu lq l lr ls">List of schemas</span><span id="0839" class="ln lo iq ld b gy nu lq l lr ls">Name  |  Owner</span><span id="78a5" class="ln lo iq ld b gy nu lq l lr ls">--------+----------</span><span id="25fe" class="ln lo iq ld b gy nu lq l lr ls">foo    | user1</span><span id="d2f2" class="ln lo iq ld b gy nu lq l lr ls">public | postgres</span><span id="6982" class="ln lo iq ld b gy nu lq l lr ls">(2 rows)</span></pre><p id="243b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们以<code class="fe la lb lc ld b">user1</code>的身份登录，在<code class="fe la lb lc ld b">demo12</code>中创建一个名为<code class="fe la lb lc ld b">foo</code>的模式，并在其中创建一个表。现在当<code class="fe la lb lc ld b">user3</code>连接到<code class="fe la lb lc ld b">demo12</code>并试图读取数据时，显示<code class="fe la lb lc ld b">user3</code>没有权限。这怎么可能呢？<code class="fe la lb lc ld b">user3</code>不是可以读取所有数据库的<code class="fe la lb lc ld b">readonly</code>成员吗？</p><p id="75e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因显示在<code class="fe la lb lc ld b">Owner</code>栏中。<code class="fe la lb lc ld b">foo</code>的主人是<code class="fe la lb lc ld b">user1</code>。当我们做<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES FOR ROLE postgres GRANT SELECT ON TABLES TO readonly</code>时，我们只授予<code class="fe la lb lc ld b">postgres</code>拥有的未来对象的特权。因此，<code class="fe la lb lc ld b">readonly</code>及其成员不能在<code class="fe la lb lc ld b">user1</code>拥有的表上进行选择。</p><p id="e162" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道我刚才说了我们希望负责人能够写入数据库，但是上面的例子表明这会导致阻止其他用户读取数据。因此，一个简单(但非常严格)的解决方法是强制<code class="fe la lb lc ld b">postgres</code>拥有所有对象。这对我们的情况来说并不坏，因为创建和删除远不如更新数据那么频繁。</p><p id="066f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe la lb lc ld b">rw_demo12</code>和<code class="fe la lb lc ld b">rw_demo34</code>的配置如下</p><figure class="lf lg lh li gt lu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bd6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，这并不能阻止拥有连接权限的用户在模式<code class="fe la lb lc ld b">public</code>中创建新表(并因此拥有它们)。为了避免这种情况，我们需要对所有数据库额外执行<code class="fe la lb lc ld b">REVOKE ALL ON SCHEMA public FROM public</code>。只要把它放在外部循环中，我们就有了完整的配置脚本。</p><h1 id="b9eb" class="ms lo iq bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">试验</h1><p id="197f" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">如果我们想从<code class="fe la lb lc ld b">rw_demo12</code>组中删除<code class="fe la lb lc ld b">user1</code>，我们只需要做</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="e067" class="ln lo iq ld b gy lp lq l lr ls">REVOKE rw_demo FROM user1;</span></pre><p id="45c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，如果我们想为数据库<code class="fe la lb lc ld b">rw_demo12</code>添加一个<code class="fe la lb lc ld b">newuser</code>，只需将它授予组</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="6136" class="ln lo iq ld b gy lp lq l lr ls">GRANT rw_demo TO newuser;</span></pre><p id="04de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们要拒绝所有对<code class="fe la lb lc ld b">demo12</code>的更新，而角色<code class="fe la lb lc ld b">rw_demo12</code>中的成员远不止<code class="fe la lb lc ld b">user1</code>和<code class="fe la lb lc ld b">user2</code>呢？我没有找到任何可以检索此类信息的现有查询。我认为这是因为 PostgreSQL 将每个用户映射到他们所属的所有组角色，而不是相反。所以我们需要撤销我们之前授予<code class="fe la lb lc ld b">rw_demo12</code>的特权，脚本会像以前一样麻烦。但是，嘿，这次我们有一些一致性😃</p><figure class="lf lg lh li gt lu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="5091" class="ms lo iq bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">替代设置</h1><p id="9ece" class="pw-post-body-paragraph jn jo iq jp b jq np js jt ju nq jw jx jy nr ka kb kc ns ke kf kg nt ki kj kk ij bi translated">如果你想要一个更灵活的解决方案，即允许除管理员之外的用户拥有对象，我们可以用<code class="fe la lb lc ld b">NOINHERIT</code>来破解它。我们采用这种严格实现的原因是，我们不想在像<code class="fe la lb lc ld b">ALTER DEFAULT PRIVILEGES FOR ROLE postgres, user1,user2,user3,... GRANT SELECT ON TABLES TO readonly</code>这样的命令中列出所有用户。但是如果我们能确保<code class="fe la lb lc ld b">demo1</code>对象的所有者只有<code class="fe la lb lc ld b">postgres</code>和<code class="fe la lb lc ld b">rw_demo12</code>，那就更容易管理了。我们对使用<code class="fe la lb lc ld b">NOINHERIT</code>的用户使用不同的设置。</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="4470" class="ln lo iq ld b gy lp lq l lr ls">$ psql -U postgres</span><span id="4627" class="ln lo iq ld b gy nu lq l lr ls">postgres=# DROP USER user1, user2, user3, user4;</span><span id="f49d" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user1 NOINHERIT ENCRYPTED PASSWORD 'user1';</span><span id="d056" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user2 NOINHERIT ENCRYPTED PASSWORD 'user2';</span><span id="41be" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user3 NOINHERIT ENCRYPTED PASSWORD 'user3';</span><span id="cf97" class="ln lo iq ld b gy nu lq l lr ls">postgres=# CREATE USER user4 NOINHERIT ENCRYPTED PASSWORD 'user4';</span><span id="5e39" class="ln lo iq ld b gy nu lq l lr ls">postgres=# GRANT readonly TO user1, user2, user3, user4;</span><span id="6b19" class="ln lo iq ld b gy nu lq l lr ls">postgres=# GRANT rw_demo12 TO user1, user2;</span><span id="7cab" class="ln lo iq ld b gy nu lq l lr ls">postgres=# GRANT rw_demo34 TO user3, user4;</span></pre><p id="815e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<code class="fe la lb lc ld b">user1</code>只能连接到集群，因为它不会自动继承<code class="fe la lb lc ld b">rw_demo12</code>的权限。为了查看数据，<code class="fe la lb lc ld b">user1</code>必须显式地做<code class="fe la lb lc ld b">SET ROLE TO readonly</code>。同样，如果<code class="fe la lb lc ld b">user1</code>想要在某些表中插入值，或者创建新表(这在我们提出的解决方案中是禁止的)，那么<code class="fe la lb lc ld b">user1</code>需要<code class="fe la lb lc ld b">SET ROLE TO rw_demo12</code>。这样，<code class="fe la lb lc ld b">user1</code>或<code class="fe la lb lc ld b">user2</code>创建的所有新的未来对象将归<code class="fe la lb lc ld b">rw_demo12</code>所有。所以你看，这种替代方案更灵活，但牺牲了用户体验。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="38ba" class="ms lo iq bd mt mu nx mw mx my ny na nb nc nz ne nf ng oa ni nj nk ob nm nn no bi translated">参考</h1><div class="oc od gp gr oe of"><a href="https://www.postgresql.org/docs/12/client-authentication.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">PostgreSQL:文档:12:第 20 章。客户端身份验证</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">当客户机应用程序连接到数据库服务器时，它会指定它想要哪个 PostgreSQL 数据库用户名…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.postgresql.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://www.postgresql.org/docs/12/user-manag.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">PostgreSQL:文档:12:第 21 章。数据库角色</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">PostgreSQL 使用角色的概念来管理数据库访问权限。角色可以被认为是一个…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.postgresql.org</p></div></div><div class="oo l"><div class="ou l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://dba.stackexchange.com/questions/114834/cant-alter-default-privileges/114839#114839" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">无法更改默认权限</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">感谢给数据库管理员栈交换贡献一个答案！请务必回答问题…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">dba.stackexchange.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://dba.stackexchange.com/questions/117109/how-to-manage-default-privileges-for-users-on-a-database-vs-schema/117661#117661" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">如何管理用户对数据库和模式的默认权限？</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我在哪里可以找到这方面的像样的指南、教程或视频系列？你会在手册中找到一切。下面的链接…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">dba.stackexchange.com</p></div></div><div class="oo l"><div class="ow l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://dba.stackexchange.com/questions/35316/why-is-a-new-user-allowed-to-create-a-table" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">为什么允许新用户创建表？</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我想知道为什么一个新创建的用户可以在连接到数据库后创建一个表。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">dba.stackexchange.com</p></div></div><div class="oo l"><div class="ox l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://dba.stackexchange.com/questions/135168/alter-default-privileges-for-role" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">更改角色的默认权限</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我有一个名为 Blackacre 的数据库和两个可以访问它的角色:johnrole 和。janerole 被授予所有…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">dba.stackexchange.com</p></div></div><div class="oo l"><div class="oy l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://stackoverflow.com/questions/10352695/grant-all-on-a-specific-schema-in-the-db-to-a-group-role-in-postgresql/10353730#10353730" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">将数据库中特定模式的 all 权限授予 PostgreSQL 中的组角色</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">您找到了为给定模式中的所有现有表设置特权的捷径。手册阐明:(但请注意…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">stackoverflow.com</p></div></div><div class="oo l"><div class="oz l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://stackoverflow.com/questions/24918367/grant-privileges-for-a-particular-database-in-postgresql/24923877#24923877" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">在 PostgreSQL 中授予特定数据库的权限</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我正从 MySQL 迁移到 PostgreSQL，但在用户权限方面遇到了瓶颈。我习惯于给用户分配所有…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">stackoverflow.com</p></div></div><div class="oo l"><div class="pa l oq or os oo ot lz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://www.postgresql.org/docs/11/sql-alterdefaultprivileges.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">PostgreSQL:文档:11:更改默认权限</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">更改默认权限-定义默认访问权限更改默认权限[针对{角色|用户}…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.postgresql.org</p></div></div><div class="oo l"><div class="pb l oq or os oo ot lz of"/></div></div></a></div></div></div>    
</body>
</html>