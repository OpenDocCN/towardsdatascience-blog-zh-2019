<html>
<head>
<title>Models as Web Endpoints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为 Web 端点的模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/models-as-web-endpoints-162cb928a9e6?source=collection_archive---------18-----------------------#2019-09-01">https://towardsdatascience.com/models-as-web-endpoints-162cb928a9e6?source=collection_archive---------18-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1fb648079fe21fff53799e7ac9b014cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C7YgFBL2mGncyVN3.jpg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source: <a class="ae jd" href="https://www.maxpixel.net/Internet-Hexagon-Icon-Networks-Honeycomb-Hexagons-3143432" rel="noopener ugc nofollow" target="_blank">https://www.maxpixel.net/Internet-Hexagon-Icon-Networks-Honeycomb-Hexagons-3143432</a></figcaption></figure><div class=""/><div class=""><h2 id="adf7" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">《生产中的数据科学》摘录</h2></div><p id="55cd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae jd" href="https://leanpub.com/ProductionDataScience" rel="noopener ugc nofollow" target="_blank">生产中的数据科学</a>的第二章中，我将讨论如何将预测模型设置为 web 端点。这是一项有用的技能，因为它使数据科学家能够从批处理模型应用程序(如输出 CSV 文件)转移到托管其他应用程序可以实时使用的模型。我以前使用 Keras 写过这个过程，但是结果不是一个可伸缩的解决方案。本文的目标是关注 Python 堆栈中可以用来托管预测模型的工具，该模型可以扩展以满足需求。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/deploying-keras-deep-learning-models-with-flask-5da4181436a2"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用 Flask 部署 Keras 深度学习模型</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">这篇文章演示了如何使用 Keras 构建的深度学习模型来设置端点以服务于预测。它…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ix lr"/></div></div></a></div><p id="5f7c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将展示如何使用一个简单的 Flask 应用程序，并将其作为服务部署在开放的 web 上，这对于构建数据科学组合非常有用。为了实现这个目标，我们将使用 Gunicorn 和 Heroku。我写这本书的目的之一是展示如何从头开始设置环境，这通常包括在 EC2 上设置一个实例。我已经讨论过在<a class="ae jd" rel="noopener" target="_blank" href="/data-science-for-startups-r-python-2ca2cd149c5c">前一篇文章</a>和<a class="ae jd" href="http://samples.leanpub.com/ProductionDataScience-sample.pdf" rel="noopener ugc nofollow" target="_blank">书籍样本</a>中设置机器。</p><h2 id="adb6" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">瓶</h2><p id="cf8f" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">Flask 是一个多功能的工具，用于使用 Python 构建 web 应用程序和服务。虽然可以直接使用 Flask 创建完整的 web 应用程序，但我通常使用它来创建消费和生成 JSON 响应的端点，而使用<a class="ae jd" href="https://plot.ly/dash/" rel="noopener ugc nofollow" target="_blank">破折号</a>来创建更多的 UI 应用程序。</p><p id="5f6c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我们将创建一个返回 JSON 响应的最小服务，如果指定的话，它将回显粘贴的 in <code class="fe ne nf ng nh b">msg</code>参数。返回的字典包括回显的消息和一个指定消息是否被传递给服务的<code class="fe ne nf ng nh b">success</code>值。第一步是安装 Flask 和 Gunicorn。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2a50" class="mg mh jg nh b gy nq nr l ns nt">pip install flask<br/>pip install gunicorn</span></pre><p id="cd6a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将创建一个名为 echo.py 的文件，它使用 Flask 来实现这个 echo 功能。这个 web 应用程序的完整代码如下面的代码片段所示。该脚本首先加载 Flask 库，然后实例化一个 Flask 对象。接下来，<code class="fe ne nf ng nh b">@app.route</code>注释用于定义一个被分配了路由位置和一组 HTTP 方法的函数。在这种情况下，我们在根 URL 处定义函数，<code class="fe ne nf ng nh b">/</code>。该函数定义了一个用于返回 JSON 响应的 dictionary 对象。该函数使用<code class="fe ne nf ng nh b">request.json</code>和<code class="fe ne nf ng nh b">request.args</code>对象检查传入的参数。如果提供了传入的消息，则将它添加到响应字典中，并将成功值设置为 true。最后一步调用应用程序对象上的<code class="fe ne nf ng nh b">run</code>来启动 Flask 会话。这是我们在直接使用 Flask 作为端点时想要做的事情，而不是在使用 Gunicorn 时。我们将主机设置为<code class="fe ne nf ng nh b">0.0.0.0</code>来启用远程连接。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="db9d" class="mg mh jg nh b gy nq nr l ns nt"><strong class="nh jh"># load Flask <br/></strong>import flask<br/>app = flask.Flask(__name__)</span><span id="fd65" class="mg mh jg nh b gy nu nr l ns nt"><strong class="nh jh"># define a predict function as an endpoint <br/></strong><a class="ae jd" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/", methods=["GET","POST"])<br/>def predict():<br/>    data = {"success": False}<br/>    <br/><strong class="nh jh">    # check for passed in parameters   <br/></strong>    params = flask.request.json<br/>    if params is None:<br/>        params = flask.request.args<br/>    <br/><strong class="nh jh">    # if parameters are found, echo the msg parameter <br/>    </strong><strong class="nh jh">if</strong><strong class="nh jh"> "msg" </strong><strong class="nh jh">in</strong><strong class="nh jh"> params</strong><strong class="nh jh">.keys(): </strong><strong class="nh jh"><br/></strong>        data["response"] = params.get("msg")<br/>        data["success"] = True<br/>        <br/><strong class="nh jh">    # return a response in json format <br/></strong>    return flask.jsonify(data)<br/>    <br/><strong class="nh jh"># start the flask app, allow remote connections<br/></strong>if __name__ == '__main__':<br/>    app.run(host='0.0.0.0')</span></pre><p id="8944" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以使用<code class="fe ne nf ng nh b">python echo.py</code>运行应用程序。运行该命令的结果如下所示。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2e07" class="mg mh jg nh b gy nq nr l ns nt">python3 echo.py<br/> * Serving Flask app "echo" (lazy loading)<br/> * Environment: production<br/>   WARNING: This is a development server. <br/>   Do not use it in a production deployment.<br/>   Use a production WSGI server instead.<br/> * Debug mode: off<br/> * Running on <a class="ae jd" href="http://0.0.0.0:5000/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/</a> (Press CTRL+C to quit)</span></pre><p id="324d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用 web 浏览器或 Python 与服务进行交互。如果使用 AMI 实例，您需要使用机器的公共 IP 并打开端口 5000。该服务可以与 get 和 post 方法一起使用，如下所示。如果您需要向服务发送许多参数，那么 post 方法是生产环境的首选方法。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d51e" class="mg mh jg nh b gy nq nr l ns nt">import requests</span><span id="3b0e" class="mg mh jg nh b gy nu nr l ns nt">result = requests.get("<a class="ae jd" href="http://52.90.199.190:5000/?msg=Hello" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/?msg=Hello</a> from URL!")<br/>print(result.json())</span><span id="9477" class="mg mh jg nh b gy nu nr l ns nt">result = requests.get("<a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">http://</a><a class="ae jd" href="http://52.90.199.190:5000/?msg=Hello" rel="noopener ugc nofollow" target="_blank">localhost</a><a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">:5000/</a>",  <br/>                       params = { 'msg': 'Hello from params' })<br/>print(result.json())</span><span id="3c40" class="mg mh jg nh b gy nu nr l ns nt">result = requests.post("<a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/</a>",  <br/>                        json = { 'msg': 'Hello from data' })<br/>print(result.json())</span></pre><p id="7dd5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该脚本的结果如下所示:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="49dd" class="mg mh jg nh b gy nq nr l ns nt">{‘response’: ‘Hello from URL!’, ‘success’: True}<br/>{‘response’: ‘Hello from params’, ‘success’: True}<br/>{‘response’: ‘Hello from data’, ‘success’: True}</span></pre><p id="c6b1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在有了一个可用于托管预测模型的 web 端点，但我们当前的方法无法扩展。开发模式中的 Flask 使用单线程方法，并建议使用 WSGI 服务器来处理生产工作负载。</p><h2 id="a4ea" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">格尼科恩</h2><p id="a427" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">我们可以使用 Gunicorn 为 Flask 应用程序提供一个 WSGI 服务器。使用 gunicorn 有助于将我们在 Flask 中实现的应用程序的功能与应用程序的部署分开。Gunicorn 是一个轻量级的 WSGI 实现，与 Flask 应用程序配合良好。</p><p id="87b7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">直接从使用 Flask 切换到使用 Gunicorn 来运行 web 服务是很简单的。运行应用程序的新命令如下所示。请注意，我们正在传入一个绑定参数来启用到服务的远程连接。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="4a75" class="mg mh jg nh b gy nq nr l ns nt">gunicorn --bind 0.0.0.0 echo:app</span></pre><p id="81dc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">命令行上的结果如下所示。与以前的主要区别是，我们现在在端口 8000 而不是端口 5000 上连接服务。如果您想测试服务，您需要在端口 8000 上启用远程访问。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="788f" class="mg mh jg nh b gy nq nr l ns nt">gunicorn --bind 0.0.0.0 echo:app<br/>[INFO] Starting gunicorn 19.9.0<br/>[INFO] Listening at: <a class="ae jd" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (10310)<br/>[INFO] Using worker: sync<br/>[INFO] Booting worker with pid: 10313</span></pre><p id="2306" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，我们可以用 Python 测试服务，如下所示。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f680" class="mg mh jg nh b gy nq nr l ns nt">result = requests.get("<a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">http://</a><a class="ae jd" href="http://52.90.199.190:5000/?msg=Hello" rel="noopener ugc nofollow" target="_blank">localhost</a><a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">:8000/</a>",  <br/>                       params = { 'msg': 'Hello from Gunicorn' })<br/>print(result.json())</span></pre><h2 id="1f53" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">赫罗库</h2><p id="781e" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">现在我们有了一个 gunicorn 应用程序，我们可以使用<a class="ae jd" href="https://dashboard.heroku.com/apps" rel="noopener ugc nofollow" target="_blank"> Heroku </a>将它托管在云中。Python 是这种云环境支持的核心语言之一。使用 Heroku 的好处在于，你可以免费托管应用程序，这对于展示数据科学项目来说非常棒。第一步是在网站上建立一个账户:<a class="ae jd" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank">https://www.heroku.com/</a></p><p id="59d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将通过运行如下所示的命令，为 Heroku 设置命令行工具。在 AMI EC2 实例上设置 Heroku 时，可能会有些复杂。这些步骤下载一个版本，提取它，并安装一个附加的依赖项。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="6806" class="mg mh jg nh b gy nq nr l ns nt">wget <a class="ae jd" href="https://cli-assets.heroku.com/heroku-linux-x64.tar.gz" rel="noopener ugc nofollow" target="_blank">https://cli-assets.heroku.com/heroku-linux-x64.tar.gz</a><br/>unzip heroku-linux-x64.tar.gz<br/>tar xf heroku-linux-x64.tar<br/>sudo yum -y install glibc.i686<br/>/home/ec2-user/heroku/bin/heroku --version</span></pre><p id="9540" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一步输出安装的 Heroku 版本。我得到了以下输出:<code class="fe ne nf ng nh b">heroku/7.29.0 linux-x64 node-v11.14.0</code></p><p id="1f5c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将使用 CLI 设置一个新的 Heroku 项目:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="806d" class="mg mh jg nh b gy nq nr l ns nt">/home/ec2-user/heroku/bin/heroku login <br/>/home/ec2-user/heroku/bin/heroku create</span></pre><p id="d9ff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将创建一个唯一的应用程序名称，如<code class="fe ne nf ng nh b">obscure-coast-69593</code>。在部署到生产环境之前，最好在本地测试设置。为了测试设置，您需要安装<code class="fe ne nf ng nh b">django</code>和<code class="fe ne nf ng nh b">django-heroku</code>包。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="152d" class="mg mh jg nh b gy nq nr l ns nt">pip install --user django<br/>sudo yum install gcc python-setuptools python-devel postgresql-devel<br/>sudo easy_install psycopg2<br/>pip install --user django-heroku</span></pre><p id="f4d4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要开始设置项目，我们可以从 Heroku 提供的示例 Python 项目开始。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="57e1" class="mg mh jg nh b gy nq nr l ns nt">sudo yum install git<br/>git clone <a class="ae jd" href="https://github.com/heroku/python-getting-started.git" rel="noopener ugc nofollow" target="_blank">https://github.com/heroku/python-getting-started.git</a><br/>cd python-getting-started</span></pre><p id="c6dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将对项目进行更改。我们将我们的 echo.py 文件复制到目录中，将 Flask 添加到 requirements.txt 文件的依赖项列表中，覆盖在 Procfile 中运行的命令，然后调用<code class="fe ne nf ng nh b">heroku local</code>在本地测试配置。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="3322" class="mg mh jg nh b gy nq nr l ns nt">cp ../echo.py echo.py <br/>echo 'flask' &gt;&gt; requirements.txt<br/>echo "web: gunicorn echo:app" &gt; Procfile<br/>/home/ec2-user/heroku/bin/heroku local</span></pre><p id="76c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您应该会看到如下所示的结果:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2028" class="mg mh jg nh b gy nq nr l ns nt">/home/ec2-user/heroku/bin/heroku local<br/>[OKAY] Loaded ENV .env File as KEY=VALUE Format<br/>[INFO] Starting gunicorn 19.9.0<br/>[INFO] Listening at: <a class="ae jd" href="http://0.0.0.0:5000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000</a> (10485) <br/>[INFO] Using worker: sync<br/>[INFO] Booting worker with pid: 10488</span></pre><p id="3f5a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和以前一样，我们可以使用浏览器或 Python 调用来测试端点，如下所示。在测试配置中，默认情况下使用端口 5000。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="45ac" class="mg mh jg nh b gy nq nr l ns nt">result = requests.get("<a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">http://</a><a class="ae jd" href="http://52.90.199.190:5000/?msg=Hello" rel="noopener ugc nofollow" target="_blank">localhost</a><a class="ae jd" href="http://52.90.199.190:5000/" rel="noopener ugc nofollow" target="_blank">:5000/</a>",  <br/>                      params = { 'msg': 'Hello from Heroku Local' })<br/>print(result.json())</span></pre><p id="b19e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一步是将服务部署到生产环境中。git 命令用于将结果推送到 Heroku，Heroku 会自动发布应用程序的新版本。最后一个命令告诉 Heroku 扩展到单个工人，这是免费的。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="1788" class="mg mh jg nh b gy nq nr l ns nt">git add echo.py<br/>git commit . <br/>git push heroku master<br/>/home/ec2-user/heroku/bin/heroku ps:scale web=1</span></pre><p id="b7ff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以调用端点，它有一个正确的 URL，是安全的，可以用来公开共享数据科学项目。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="8177" class="mg mh jg nh b gy nq nr l ns nt">result = requests.get("<a class="ae jd" href="https://obscure-coast-69593.herokuapp.com" rel="noopener ugc nofollow" target="_blank">https://obscure-coast-69593.herokuapp.com</a>",  <br/>                      params = { 'msg': 'Hello from Heroku Prod' })<br/>print(result.json())</span></pre><p id="7f19" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想展示的最后一步是将图像传递到这个端点的能力，这在构建深度学习模型时是一项有用的任务。下面的代码使用 Python 图像库将图像编码为字符串，将结果传递给 echo 服务，然后使用 matplotlib 呈现结果。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d569" class="mg mh jg nh b gy nq nr l ns nt">import matplotlib.pyplot as plt<br/>import numpy as np<br/>from PIL import Image<br/>import io<br/>import base64</span><span id="a111" class="mg mh jg nh b gy nu nr l ns nt">image = open("luna.png", "rb").read()<br/>encoded = base64.b64encode(image)<br/>result = requests.get("<a class="ae jd" href="https://obscure-coast-69593.herokuapp.com" rel="noopener ugc nofollow" target="_blank">https://obscure-coast-69593.herokuapp.com</a>", json = {'msg': encoded})</span><span id="a3c1" class="mg mh jg nh b gy nu nr l ns nt">encoded = result.json()['response']<br/>imgData = base64.b64decode(encoded)<br/>plt.imshow( np.array(Image.open(io.BytesIO(imgData)) ))</span></pre><p id="17dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果如下图所示。我们能够对我姻亲的猫的图像进行编码，将其发送到 echo 服务，并呈现返回的图像。这种方法可以用来建立图像分类器作为网络端点。</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b4487a8dec1b983a42cb90b4eb8579c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*zSy5upiaLAp1kp7afbbUvw.png"/></div></figure><h2 id="7c09" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated"><strong class="ak">结论</strong></h2><p id="0228" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">这篇文章展示了如何使用 Heroku 将 Flask web 应用程序部署到生产环境中。虽然该应用程序是一个简单的 echo 服务，但它确实提供了构建更复杂应用程序所需的脚手架，例如使用 Keras 来识别图像中是否包含猫或狗。下一次，我将介绍使用 AWS Lambda 和 Google Cloud 函数作为构建可伸缩模型端点的替代方法。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="bebd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/ben-weber-3b87482/" rel="noopener ugc nofollow" target="_blank">本·韦伯</a>是 Zynga 杰出的数据科学家。我们正在<a class="ae jd" href="https://www.zynga.com/job-listing-category/data-analytics-user-research/" rel="noopener ugc nofollow" target="_blank">招聘</a>！</p></div></div>    
</body>
</html>