<html>
<head>
<title>Python Basics: Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 基础:函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-basics-functions-ed7c35e194a9?source=collection_archive---------4-----------------------#2019-02-20">https://towardsdatascience.com/python-basics-functions-ed7c35e194a9?source=collection_archive---------4-----------------------#2019-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e6444611b6eb54b9172b1e14c82929c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWrXceae4H_klzpPU6h7Hg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://bit.ly/2EhK47P" rel="noopener ugc nofollow" target="_blank">https://bit.ly/2EhK47P</a></figcaption></figure><p id="1dcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读完这篇文章你会知道:</p><ul class=""><li id="3300" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">什么是<strong class="kf ir">功能</strong>以及<strong class="kf ir">如何定义它们</strong></li><li id="dab4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir">参数</strong>和<strong class="kf ir">自变量</strong></li><li id="4d1e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如何从函数中<strong class="kf ir">返回值</strong></li><li id="4998" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如何定义函数<strong class="kf ir">文档</strong></li><li id="49e7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Python 中的<strong class="kf ir">范围代表什么</strong></li><li id="3656" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir">关键字参数</strong></li><li id="1dad" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">灵活</strong>和<strong class="kf ir">默认参数</strong></li><li id="2c42" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir"> Python 异常</strong>以及<strong class="kf ir">如何处理</strong>以及<strong class="kf ir">如何引发它们</strong></li><li id="515b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">断言语句</strong></li></ul><h1 id="17eb" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">介绍</h1><p id="9915" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">功能是一段有组织的<strong class="kf ir">可重用代码</strong>解决一个<strong class="kf ir">特定任务</strong>。函数帮助我们保持代码的整洁，并为我们提供代码重用的能力。</p><h1 id="e520" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">内置函数</h1><p id="ecc4" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Python 有几个<a class="ae kc" href="https://docs.python.org/3/library/functions.html#built-in-functions" rel="noopener ugc nofollow" target="_blank">内置函数</a>，它们<strong class="kf ir">总是可用</strong>。其中一些功能是<a class="ae kc" href="https://docs.python.org/3/library/functions.html#print" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">打印</strong> </a>和<a class="ae kc" href="https://docs.python.org/3/library/functions.html#max" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">最大</strong> </a>。让我们看一些如何使用它们的例子。</p><ul class=""><li id="e870" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">打印</strong>功能接受对象并打印它们</li></ul><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="ab08" class="nd lq iq mz b gy ne nf l ng nh">Python<br/>chess backgammon</span></pre><ul class=""><li id="90f5" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir"> max </strong>函数接受一个<a class="ae kc" rel="noopener" target="_blank" href="/python-basics-iteration-and-looping-6ca63b30835c">可迭代</a>并返回最大的项</li></ul><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c4d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="482b" class="nd lq iq mz b gy ne nf l ng nh">49</span></pre><p id="7da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，我们只是通过写函数名来调用函数，并传递所需的输入。</p><h1 id="bd06" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">用户定义的函数</h1><p id="c667" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">作为程序员或数据科学家，有时我们需要特定于我们需求的功能。在这些情况下，我们可以定义自己的函数。</p><p id="1739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要定义函数，我们需要遵循以下规则:</p><ol class=""><li id="7197" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la ni lh li lj bi translated">使用关键字<code class="fe nj nk nl mz b"><strong class="kf ir">def</strong></code>引入一个<strong class="kf ir">功能定义</strong></li><li id="b932" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ni lh li lj bi translated">编写<strong class="kf ir">函数名</strong>后跟<strong class="kf ir">括号</strong> <code class="fe nj nk nl mz b"><strong class="kf ir">()</strong></code> <strong class="kf ir"> </strong>和一个<strong class="kf ir">冒号</strong> <code class="fe nj nk nl mz b"><strong class="kf ir">:</strong></code></li><li id="5f91" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ni lh li lj bi translated">在这些括号<strong class="kf ir">(可选)</strong>内定义一个<strong class="kf ir">参数列表</strong></li><li id="dde9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ni lh li lj bi translated">编写<strong class="kf ir">函数体</strong>。构成函数体的语句从<strong class="kf ir">下一行</strong>开始，并且必须是<strong class="kf ir">预期的</strong>。当函数<strong class="kf ir">被调用</strong>时，函数体中的代码为<strong class="kf ir"> run </strong>。</li><li id="ed72" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ni lh li lj bi translated">函数体的第一条语句可以是代表<strong class="kf ir">函数文档(可选)</strong>的<strong class="kf ir">字符串文字</strong></li><li id="5161" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ni lh li lj bi translated">使用<code class="fe nj nk nl mz b"><strong class="kf ir">return</strong></code> <strong class="kf ir">关键字</strong>将结果传回给调用者<strong class="kf ir">(可选)</strong></li></ol><p id="d4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你认为有许多步骤，不要担心。我们将看到许多例子，概念将变得非常简单。</p><h2 id="cf00" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">定义不带参数的函数</h2><p id="f4c9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">让我们看一个没有可选部分的函数定义的简单例子。我们可以通过键入函数名，后跟<strong class="kf ir">括号</strong> <code class="fe nj nk nl mz b">()</code>来调用函数。当我们调用这个函数时，它将打印当前日期。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="230f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="6783" class="nd lq iq mz b gy ne nf l ng nh">2019-02-19</span></pre><p id="6fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这个输出对您来说可能是不同的。输出将是您调用该函数的日期。</p><h2 id="0ad9" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">定义带参数的函数</h2><p id="a51c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们几乎总是需要函数参数。当我们想要<strong class="kf ir">将数据传递到</strong>我们的<strong class="kf ir">函数</strong>中时，就会用到它们。当我们调用一个函数时，我们将参数传递给这个函数。</p><p id="e0ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">一个参数示例</strong></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dced" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="8258" class="nd lq iq mz b gy ne nf l ng nh">Forgive yourself for your faults and your mistakes and move on. - Les Brown</span></pre><p id="68e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们定义这样的参数时，它是必需的。如果我们不为这个参数传递一个参数值，这会给我们一个错误。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="46ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="9c5b" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-48-f2f093834d71&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>      2     print<strong class="mz ir">(</strong>text<strong class="mz ir">)</strong><br/>      3 <br/><strong class="mz ir">----&gt; 4 </strong>print_message<strong class="mz ir">()</strong><br/><br/><strong class="mz ir">TypeError</strong>: print_message() missing 1 required positional argument: 'text'</span></pre><p id="af1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后，在这篇博文中，我们将看到如何定义可选参数(带有默认值的参数)。</p><p id="d6d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">多参数示例<br/> </strong>我们可以添加<strong class="kf ir">任意多的参数</strong>，我们只需要用<strong class="kf ir">逗号</strong>将它们隔开。在许多情况下，我们需要不止一个参数。</p><p id="9890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参数传递的顺序对应于函数定义中参数的顺序。在下面的例子中，我们将 10 作为参数<code class="fe nj nk nl mz b">number1</code>的值，将 5 作为参数<code class="fe nj nk nl mz b">number2</code>的值。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="698f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="0de7" class="nd lq iq mz b gy ne nf l ng nh">15</span></pre><p id="48e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们想将结果保存在变量中，我们不能使用上面的函数定义，因为我们的函数只是打印结果，我们不使用<code class="fe nj nk nl mz b"><strong class="kf ir">return</strong></code> <strong class="kf ir">语句</strong>。让我们看看如果我们试图保存结果会发生什么。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="dfcc" class="nd lq iq mz b gy ne nf l ng nh">15<br/>None</span></pre><p id="835a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到 sum 被打印出来(因为我们的函数被调用了)，但是<code class="fe nj nk nl mz b">result</code>变量的值是<code class="fe nj nk nl mz b">None</code>而不是 15。在下一节中，让我们看看如何返回值。</p><h2 id="3273" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">定义返回结果的函数</h2><p id="5c5c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们可以使用<code class="fe nj nk nl mz b"><strong class="kf ir">return</strong></code> <strong class="kf ir">关键字</strong>离开当前的函数调用并返回想要的结果。让我们看看如何重新定义函数<code class="fe nj nk nl mz b">sum_numbers</code>来返回总和，而不是打印出来。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a55a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="8603" class="nd lq iq mz b gy ne nf l ng nh">15</span></pre><p id="2ace" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以清楚地看到，这次<code class="fe nj nk nl mz b">result</code>变量的值是 15。</p><h2 id="adde" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">定义返回多个值的函数</h2><p id="dc52" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们还可以定义一个返回多个值的函数。我们可以通过在函数中构造名为<a class="ae kc" rel="noopener" target="_blank" href="/python-basics-tuples-9bb3851257b5"> <strong class="kf ir">元组</strong> </a>的对象来实现。Python 中的 tuples 数据类型是一个<a class="ae kc" rel="noopener" target="_blank" href="/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a"> <strong class="kf ir">不可变的</strong> </a> <strong class="kf ir"> </strong> <a class="ae kc" rel="noopener" target="_blank" href="/python-basics-iteration-and-looping-6ca63b30835c"> <strong class="kf ir">序列</strong> </a>。这意味着它们可以像列表一样包含多个值。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a6af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="8132" class="nd lq iq mz b gy ne nf l ng nh">2019-02-19<br/>08:23:38.030659</span></pre><p id="1596" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们使用<strong class="kf ir">序列解包</strong>。我们只是将元组中的值“解包”到<code class="fe nj nk nl mz b">date</code>和<code class="fe nj nk nl mz b">time</code>变量中。</p><h2 id="90ed" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">用文档定义函数</h2><p id="68d6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在上一个例子中，我们定义了一个函数，它以元组的形式返回当前日期和当前时间。也许很容易理解函数是做什么的。然而，如果这个函数有一个<strong class="kf ir">文档</strong>不是很好吗？</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="84f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="1c69" class="nd lq iq mz b gy ne nf l ng nh">2019-02-19<br/>08:26:49.538434</span></pre><p id="b367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在许多情况下，我们的函数比上面的例子更复杂。在这些情况下，为你的功能准备文档总是更好的。功能文档可包括以下信息:</p><ul class=""><li id="e4af" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">函数参数</strong></li><li id="617d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">函数计算</strong></li><li id="9562" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">返回值/秒</strong></li></ul><h1 id="991f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">范围</h1><p id="10fd" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">并不是所有我们定义的对象(包括函数)在 Python 代码中都是可访问的。程序的范围代表<strong class="kf ir">，其中变量名或函数名可以被访问</strong>。Python 有 3 种作用域:<strong class="kf ir">局部</strong>、<strong class="kf ir">全局</strong>和<strong class="kf ir">内置</strong>作用域。</p><h2 id="dae3" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">局部范围</h2><p id="0db5" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当我们的对象或函数在函数中定义<strong class="kf ir">时，这意味着它有一个局部范围。我们只能在定义这个对象或函数的函数内部使用它。</strong></p><h2 id="1bdf" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">全球范围</h2><p id="0408" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当我们的对象或函数在 Python 代码的主体中定义<strong class="kf ir">时，这意味着它具有全局范围。我们可以在任何地方访问这个对象或函数，因为它是全局的。</strong></p><h2 id="d16e" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">内置范围</h2><p id="738f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在 Python 中，我们有许多内置于中的<a class="ae kc" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">函数和类型，它们<strong class="kf ir">总是可用的</strong>。</a></p><h2 id="d3c6" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">附加注释</h2><ul class=""><li id="a097" class="lb lc iq kf b kg mn kk mo ko nx ks ny kw nz la lg lh li lj bi translated">如果我们在函数中使用变量名或函数名<strong class="kf ir">，Python 将首先在<strong class="kf ir">局部</strong>中搜索该名称，然后在<strong class="kf ir">全局</strong>中搜索，最后在<strong class="kf ir">内置</strong> <strong class="kf ir">作用域</strong>中搜索。</strong></li><li id="b320" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如果我们在脚本的主体中使用变量或名称<strong class="kf ir">，Python 将首先在<strong class="kf ir">全局</strong>中搜索该名称，然后在内置</strong> <strong class="kf ir">范围</strong>中搜索该名称。</li></ul><p id="30d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候看看几个例子了。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Local scope Example</figcaption></figure><p id="9aa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="08cd" class="nd lq iq mz b gy ne nf l ng nh">15</span><span id="53d8" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">NameError</strong>                          Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-2-faf6ee9da5b3&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>      4 <br/>      5 print<strong class="mz ir">(</strong>sum_numbers<strong class="mz ir">(10,</strong> <strong class="mz ir">5))</strong><br/><strong class="mz ir">----&gt; 6 </strong>print<strong class="mz ir">(</strong>result<strong class="mz ir">)</strong><br/><br/><strong class="mz ir">NameError</strong>: name 'result' is not defined</span></pre><p id="712a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们可以看到我们可以在函数中访问<code class="fe nj nk nl mz b">result</code>变量，但是在函数之外我们不能访问它。那是因为<code class="fe nj nk nl mz b"><strong class="kf ir">result</strong></code> <strong class="kf ir">变量有局部作用域</strong>，只能在<code class="fe nj nk nl mz b">sum_numbers</code>函数内部访问。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Global vs Local Scope Example</figcaption></figure><p id="6c03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="435f" class="nd lq iq mz b gy ne nf l ng nh">Hi, Ventsi the sum is 15</span><span id="470a" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">NameError</strong>                          Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-1-747761fcaa8f&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>      7 <br/>      8 print<strong class="mz ir">(</strong>sum_numbers<strong class="mz ir">(10,</strong> <strong class="mz ir">5))</strong><br/><strong class="mz ir">----&gt; 9 </strong>print<strong class="mz ir">(</strong>result<strong class="mz ir">)</strong><br/><br/><strong class="mz ir">NameError</strong>: name 'result' is not defined</span></pre><p id="5e9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们可以看到我们可以访问函数中的全局变量<strong class="kf ir"/><code class="fe nj nk nl mz b"><strong class="kf ir">name</strong></code>。同样，我们使用了<code class="fe nj nk nl mz b"><strong class="kf ir">str()</strong></code> <strong class="kf ir">内置函数</strong>。然而，<code class="fe nj nk nl mz b"><strong class="kf ir">result</strong></code> <strong class="kf ir">变量又有一个局部范围</strong>，它不能在<code class="fe nj nk nl mz b">sum_numbers</code>函数之外被访问。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Local vs Global Scope Example</figcaption></figure><p id="ea4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="0370" class="nd lq iq mz b gy ne nf l ng nh">15<br/>100</span></pre><p id="03bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们全局定义了一个<code class="fe nj nk nl mz b">result</code>变量，然后我们在函数中定义了另一个与<strong class="kf ir">同名的变量</strong>。我们可以看到，全局范围的值是 100，因为我们的全局变量有这个值。此外，sum_numbers(10，5)的值是 15，因为局部变量<code class="fe nj nk nl mz b">result</code>的值是在函数内部计算的。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Change the Value of a Global Variable Inside a Function</figcaption></figure><p id="dbbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="a4a9" class="nd lq iq mz b gy ne nf l ng nh">programming<br/>machine learning</span></pre><p id="60fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想在某个函数中改变一个全局变量的值时，我们可以使用关键字<code class="fe nj nk nl mz b"><strong class="kf ir">global</strong></code><strong class="kf ir"/>。</p><h1 id="a14a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">关键字参数</strong></h1><blockquote class="ob oc od"><p id="b6da" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">关键字参数与函数调用相关。当您在函数调用中使用关键字参数时，<strong class="kf ir">调用者通过参数名</strong>识别参数。</p><p id="f265" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">这允许您<strong class="kf ir">跳过参数</strong>或<strong class="kf ir">将它们打乱顺序</strong>，因为 Python 解释器能够使用提供的关键字将值与参数匹配。</p></blockquote><p id="7035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:https://www.tutorialspoint.com/python/python_functions.htm</p><p id="f984" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用关键字 arguments 使用<strong class="kf ir">参数名称</strong> <strong class="kf ir">和</strong> <code class="fe nj nk nl mz b"><strong class="kf ir">=</strong></code> <strong class="kf ir">符号</strong>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Keyword Arguments Example</figcaption></figure><p id="1b72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="2948" class="nd lq iq mz b gy ne nf l ng nh">8<br/>8<br/>9</span></pre><h1 id="e1a8" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">默认参数</h1><p id="b645" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在某些情况下，我们有一个带有多个参数的函数，其中一些参数有一个<strong class="kf ir">公共值</strong>。我们可以为一些函数参数指定<strong class="kf ir">默认参数</strong>。在这些情况下，我们可以调用我们的函数<strong class="kf ir">,而不用为带有默认参数的参数指定值</strong>。在 Python 中要做到这一点，我们可以使用<code class="fe nj nk nl mz b">=</code>符号后跟默认值。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Default Argument Example</figcaption></figure><p id="c3f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="6564" class="nd lq iq mz b gy ne nf l ng nh">81<br/>4<br/>8</span></pre><p id="e213" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的例子中，我们可以看到<code class="fe nj nk nl mz b">power</code>参数有一个默认值<strong class="kf ir"> 2 </strong>。当我们没有为它指定值时，将使用默认值。然而，正如我们看到的，我们可以传递一个不同的值。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Default Arguments Example</figcaption></figure><p id="7fb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="769e" class="nd lq iq mz b gy ne nf l ng nh">The number 2 raised to the power 2 is: 4<br/>8<br/>9</span></pre><h1 id="f600" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">灵活的论据</h1><p id="ddbe" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">有时候，我们想要更多<strong class="kf ir">灵活的功能</strong>。例如，我们可能想要定义一个函数，它接受的参数比我们在函数中指定的参数多。换句话说，我们可能需要向函数传递任意数量的参数。我们可以在函数定义中使用<strong class="kf ir">特殊语法*args </strong>和<strong class="kf ir"> **kwargs </strong>来实现这一点。</p><h2 id="cfa4" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">*参数</h2><p id="285a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这些参数被称为<strong class="kf ir">无名称变长参数</strong>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7e2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="5783" class="nd lq iq mz b gy ne nf l ng nh">&lt;class 'tuple'&gt;<br/>(1, 23, 4, 52, 2, 123)</span></pre><p id="195e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到*args 语法<strong class="kf ir">将所有参数</strong>作为一个名为 <code class="fe nj nk nl mz b"><strong class="kf ir">args</strong></code>的元组传递给函数<strong class="kf ir">。因此，我们可以对元组数据类型做任何我们能做的事情。</strong></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="c470" class="nd lq iq mz b gy ne nf l ng nh">5<br/>10<br/>15</span></pre><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f834" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="2cda" class="nd lq iq mz b gy ne nf l ng nh">10.0<br/>18.0<br/>15.75</span></pre><h2 id="2e8c" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">* *克瓦查</h2><p id="887c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这些参数被称为变长参数。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="830a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="34e6" class="nd lq iq mz b gy ne nf l ng nh">&lt;class 'dict'&gt;<br/>{'age': 24, 'position': 'data analyst'}<br/>&lt;class 'dict'&gt;<br/>{'name': 'Jake', 'email': 'jake@gmail.com', 'position': 'machine learning engineer'}</span></pre><p id="34e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，**kwargs 语法<strong class="kf ir">将所有参数</strong>作为一个名为 <code class="fe nj nk nl mz b"><strong class="kf ir">kwargs</strong></code>的字典传递给了函数<strong class="kf ir">。因此，我们可以对 dictionary 数据类型做任何我们能做的事情。</strong></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="21f3" class="nd lq iq mz b gy ne nf l ng nh">age 24<br/>position data analyst<br/><br/>name Jake<br/>email jake@gmail.com<br/>position machine learning engineer</span></pre><p id="45ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其实变量名可以随便，我们只需要在<strong class="kf ir">前插入一个星号</strong> <strong class="kf ir"> * </strong> <strong class="kf ir">或者两个星号** </strong>即可。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7ad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="4e21" class="nd lq iq mz b gy ne nf l ng nh">10.0<br/><br/>age 24<br/>position data analyst</span></pre><h2 id="532e" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">调用函数时使用*和**</h2><p id="78d3" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们已经看到，我们可以在函数定义中使用这种特殊的语法。然而，<strong class="kf ir">我们也可以在<strong class="kf ir">调用函数</strong>时使用它</strong>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="93b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="be46" class="nd lq iq mz b gy ne nf l ng nh">name: Jake<br/>position: data analyst<br/>email: jake@gmail.com</span></pre><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c2ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="305b" class="nd lq iq mz b gy ne nf l ng nh">name: Jake<br/>position: data analyst<br/>email: jake@gmail.com</span></pre><h1 id="e4b8" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Python 异常</h1><p id="ad74" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在许多情况下，当我们<strong class="kf ir">错误地使用函数</strong>时，它<strong class="kf ir">会引发一个异常(错误)。</strong></p><p id="5edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以从文档中看到内置函数<code class="fe nj nk nl mz b"><a class="ae kc" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank">int()</a></code>的部分内容:“<em class="oe">返回一个由数字或字符串 x 构造的整数对象，或者如果没有给定参数，则返回</em> <code class="fe nj nk nl mz b"><em class="oe">0</em></code> <em class="oe">”</em></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b8df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="ef33" class="nd lq iq mz b gy ne nf l ng nh">6<br/>7</span><span id="71fe" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">ValueError</strong>                         Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-1-dea319bbd9d9&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>      1 print<strong class="mz ir">(</strong>int<strong class="mz ir">(6.99))</strong><br/>      2 print<strong class="mz ir">(</strong>int<strong class="mz ir">("7"))</strong><br/><strong class="mz ir">----&gt; 3 </strong>print<strong class="mz ir">(</strong>int<strong class="mz ir">("Hi"))</strong></span><span id="4b2e" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">ValueError</strong>: invalid literal for int() with base 10: 'Hi'</span></pre><p id="60cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，当我们传递“Hello”字符串作为输入时，引发了 value error。</p><blockquote class="ob oc od"><p id="970b" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">当 Python 脚本<strong class="kf ir">引发异常</strong>时，我们的代码必须<strong class="kf ir">立即<strong class="kf ir">处理异常</strong>，否则程序执行将停止</strong>。</p></blockquote><h2 id="bbcf" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">异常处理</h2><p id="7c1b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">有时，我们可能希望在不停止程序执行的情况下处理引发的异常。在 Python 中，我们可以使用<strong class="kf ir"> try-except </strong> <strong class="kf ir">子句</strong>来实现。</p><ul class=""><li id="4ea7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe nj nk nl mz b"><strong class="kf ir">try</strong></code> <strong class="kf ir">块</strong>让我们测试代码块的错误</li><li id="fdda" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nj nk nl mz b"><strong class="kf ir">except</strong></code> <strong class="kf ir">块</strong>让我们处理一个错误</li></ul><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="56b6" class="nd lq iq mz b gy ne nf l ng nh">An exception occured</span></pre><p id="d4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码引发了一个<a class="ae kc" href="https://docs.python.org/3/library/exceptions.html#NameError" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">名称错误</strong> </a>，因为名称<code class="fe nj nk nl mz b">numbers</code>没有定义。当我们没有指定我们正在寻找的异常类型时，except 将处理所有的异常类型。</p><p id="32ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们可以写一个 except 块，它是<strong class="kf ir">寻找一个特定种类的</strong>异常。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7dc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="9537" class="nd lq iq mz b gy ne nf l ng nh">An NameError occured</span></pre><p id="698c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想为每个被处理的异常执行不同的代码时，我们可以定义尽可能多的<strong class="kf ir">，除了块</strong>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="831d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="b05c" class="nd lq iq mz b gy ne nf l ng nh">A ValueError occured</span></pre><p id="36c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，当我们需要关于异常的更多信息时，我们可以使用语法将它保存到变量中。例如，我们可能希望记录错误消息。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以添加一个<code class="fe nj nk nl mz b"><strong class="kf ir">else</strong></code> <strong class="kf ir">块</strong>，如果没有出现错误，它将被执行。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ece3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="fec1" class="nd lq iq mz b gy ne nf l ng nh">Something went wrong<br/>'int' object is not iterable</span></pre><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ed7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="9f34" class="nd lq iq mz b gy ne nf l ng nh">[1, 2, 3]<br/>Nothing went wrong</span></pre><p id="44be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果我们想执行一些代码<strong class="kf ir">而不管</strong>try 块是否产生了<strong class="kf ir">错误</strong>，我们可以使用<code class="fe nj nk nl mz b"><strong class="kf ir">finally</strong></code>T16 块而不是<code class="fe nj nk nl mz b"><strong class="kf ir">else</strong></code>T18 块。</p><p id="5f37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，我们在你的工作目录中有一个文件<code class="fe nj nk nl mz b">filename.txt</code>，你试图在其中写一些文本。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="70a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="a18c" class="nd lq iq mz b gy ne nf l ng nh">An error occured when writing to the file</span></pre><p id="bd33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出现错误是因为默认情况下，打开的内置函数使用“读取”模式。然而，<code class="fe nj nk nl mz b"><strong class="kf ir">finally</strong></code> <strong class="kf ir">块</strong>在两种情况下都关闭文件连接(如果有错误或没有)。在这种情况下，我们使用这个块来确保我们的文件被关闭。</p><h2 id="c19c" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">投掷错误</h2><p id="50d6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当我们定义自己的函数时，我们可能想要抛出错误并编写更多有意义的错误消息。让我们定义一个函数，如果两个单词是<a class="ae kc" href="https://en.wikipedia.org/wiki/Anagram" rel="noopener ugc nofollow" target="_blank">变位词</a>，它将返回。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="d019" class="nd lq iq mz b gy ne nf l ng nh">True</span><span id="2da7" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-61-f1a30da1d38d&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>      7 <br/>      8 print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">"listen"))</strong><br/><strong class="mz ir">----&gt; 9 </strong>print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">5))</strong><br/><br/><strong class="mz ir">&lt;ipython-input-61-f1a30da1d38d&gt;</strong> in check_anagrams<strong class="mz ir">(word1, word2)</strong><br/>      4     Returns <strong class="mz ir">True</strong> <strong class="mz ir">if</strong> the word1 <strong class="mz ir">and</strong> word2 are anagrams<strong class="mz ir">,</strong> otherwise returns <strong class="mz ir">False</strong><br/>      5     """<br/><strong class="mz ir">----&gt; 6     return</strong> sorted<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> sorted<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong><br/>      7 <br/>      8 print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">"listen"))</strong><br/><br/><strong class="mz ir">TypeError</strong>: 'int' object is not iterable</span></pre><p id="8f54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二次调用函数<strong class="kf ir">时，我们错误地使用了它</strong>，为<code class="fe nj nk nl mz b">word2</code>传递了整数 5。在这种情况下引发了 TypeError。我们可以看到这个信息有点混乱。因此，我们可以尝试检查这两个单词是否作为字符串传递，并抛出一个更具描述性的错误消息。我们可以使用<code class="fe nj nk nl mz b"><strong class="kf ir">raise</strong></code> <strong class="kf ir">关键字</strong>抛出一个错误。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3d28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="c16a" class="nd lq iq mz b gy ne nf l ng nh">True</span><span id="02e0" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-3-afb475aa2f4f&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>     10 <br/>     11 print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">"listen"))</strong><br/><strong class="mz ir">---&gt; 12 </strong>print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">5))</strong><br/><br/><strong class="mz ir">&lt;ipython-input-3-afb475aa2f4f&gt;</strong> in check_anagrams<strong class="mz ir">(word1, word2)</strong><br/>      5     """<br/>      6     <strong class="mz ir">if</strong> type<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">!=</strong> str <strong class="mz ir">or</strong> type<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong> <strong class="mz ir">!=</strong> str<strong class="mz ir">:</strong><br/><strong class="mz ir">----&gt; 7         raise</strong> TypeError<strong class="mz ir">("The word1 and word2 must be strings")</strong><br/>      8 <br/>      9     <strong class="mz ir">return</strong> sorted<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> sorted<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong><br/><br/><strong class="mz ir">TypeError</strong>: The word1 and word2 must be strings</span></pre><p id="7737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，关于这个问题的信息更加具体了。尝试捕捉更具体的异常，并编写具体而清晰的错误消息。您可以从<a class="ae kc" href="https://docs.python.org/3/library/exceptions.html#built-in-exceptions" rel="noopener ugc nofollow" target="_blank">文档</a>中查看所有异常类型。</p><h1 id="7bfd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">断言语句</h1><p id="307e" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">断言语句是对我们的<strong class="kf ir">代码</strong>进行完整性检查的一种便捷方式。它们是<strong class="kf ir">布尔表达式</strong>，检查条件是否返回<code class="fe nj nk nl mz b">True</code>或<code class="fe nj nk nl mz b">False</code>。如果一个条件返回<code class="fe nj nk nl mz b">True</code>，程序将转到下一行代码。否则，将引发一个错误并停止程序执行。</p><p id="2f1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把断言语句看作是<strong class="kf ir">“如果不抛出”语句</strong>。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/4b0fa65a11fa75dcea0540d430b36134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3h7hQEfI1dUzxext7thJqw.png"/></div></div></figure><blockquote class="ob oc od"><p id="f178" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">在当前实现中，内置变量<code class="fe nj nk nl mz b">__debug__</code>在正常情况下是<code class="fe nj nk nl mz b">True</code>，当请求优化时是<code class="fe nj nk nl mz b">False</code></p></blockquote><p id="e605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:<a class="ae kc" href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/reference/simple _ stmts . html # the-assert-statement</a></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="1195" class="nd lq iq mz b gy ne nf l ng nh">True</span><span id="34d5" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">AssertionError</strong>                     Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-68-e5a7f4b2ffc2&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>     10 <br/>     11 print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">"listen"))</strong><br/><strong class="mz ir">---&gt; 12 </strong>print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">5))</strong><br/><br/><strong class="mz ir">&lt;ipython-input-68-e5a7f4b2ffc2&gt;</strong> in check_anagrams<strong class="mz ir">(word1, word2)</strong><br/>      5     """<br/>      6     <strong class="mz ir">assert</strong> type<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> str<br/><strong class="mz ir">----&gt; 7     assert</strong> type<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> str<br/>      8 <br/>      9     <strong class="mz ir">return</strong> sorted<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> sorted<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong><br/><br/><strong class="mz ir">AssertionError</strong>:</span></pre><p id="bc27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，但是没有错误信息。如果我们想<strong class="kf ir">给这个<strong class="kf ir"> AssertionError </strong>添加一个消息</strong>该怎么办？我们可以传递它，用逗号分隔，<strong class="kf ir">就在我们的表达式</strong>之后。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/057e801dba0613173350f2f626c4bfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxm54Jr91l2SjWDbubpEvw.png"/></div></div></figure><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f1fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="a307" class="nd lq iq mz b gy ne nf l ng nh">True</span><span id="a9ee" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------</strong><br/><strong class="mz ir">AssertionError</strong>                     Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-66-5f2e42abf116&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>     10 <br/>     11 print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">"listen"))</strong><br/><strong class="mz ir">---&gt; 12 </strong>print<strong class="mz ir">(</strong>check_anagrams<strong class="mz ir">("silent",</strong> <strong class="mz ir">5))</strong><br/><br/><strong class="mz ir">&lt;ipython-input-66-5f2e42abf116&gt;</strong> in check_anagrams<strong class="mz ir">(word1, word2)</strong><br/>      5     """<br/>      6     <strong class="mz ir">assert</strong> type<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> str<strong class="mz ir">,</strong> <strong class="mz ir">"The word1 must be a string"</strong><br/><strong class="mz ir">----&gt; 7     assert</strong> type<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> str<strong class="mz ir">,</strong> <strong class="mz ir">"The word2 must be a string"</strong><br/>      8 <br/>      9     <strong class="mz ir">return</strong> sorted<strong class="mz ir">(</strong>word1<strong class="mz ir">)</strong> <strong class="mz ir">==</strong> sorted<strong class="mz ir">(</strong>word2<strong class="mz ir">)</strong><br/><br/><strong class="mz ir">AssertionError</strong>: The word2 must be a string</span></pre><h1 id="3b1a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">类型提示</h1><p id="ba50" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Python 是一种动态类型语言。当我们定义变量、函数、类等的时候。我们<strong class="kf ir">不需要指定数据类型</strong>。这让我们可以更快地编写代码。</p><p id="028b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，从 Python 版本开始，我们能够在函数定义中添加<strong class="kf ir">类型提示</strong>。我们可以说出参数的<strong class="kf ir">预期数据类型</strong>以及函数返回的数据类型。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8a5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="98b3" class="nd lq iq mz b gy ne nf l ng nh">Hello Ventsi</span><span id="b351" class="nd lq iq mz b gy oa nf l ng nh"><strong class="mz ir">--------------------------------------------------------------------TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mz ir">&lt;ipython-input-28-b1c33d5121c9&gt;</strong> in &lt;module&gt;<strong class="mz ir">()</strong><br/>      1 print<strong class="mz ir">(</strong>greeting<strong class="mz ir">("Ventsi"))</strong><br/><strong class="mz ir">----&gt; 2 </strong>print<strong class="mz ir">(</strong>greeting<strong class="mz ir">(42))</strong><br/><br/><strong class="mz ir">&lt;ipython-input-1-311aff60a9bd&gt;</strong> in greeting<strong class="mz ir">(name)</strong><br/>      1 <strong class="mz ir">def</strong> greeting<strong class="mz ir">(</strong>name<strong class="mz ir">:</strong> str<strong class="mz ir">)</strong> <strong class="mz ir">-&gt;</strong> str<strong class="mz ir">:</strong><br/><strong class="mz ir">----&gt; 2     return</strong> <strong class="mz ir">'Hello '</strong> <strong class="mz ir">+</strong> name<br/><br/><strong class="mz ir">TypeError</strong>: must be str, not int</span></pre><p id="641c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以定义类型别名。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="eb88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="d376" class="nd lq iq mz b gy ne nf l ng nh">[2.0, -8.4, 10.8]</span></pre><p id="41b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到更多信息<a class="ae kc" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6454" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">传递可变对象和不可变对象</h1><p id="591a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当我们将<a class="ae kc" rel="noopener" target="_blank" href="/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a"> <strong class="kf ir">可变对象</strong> </a>传递给我们的函数时，我们必须小心。函数调用中传递的参数使用的是<strong class="kf ir">对象<em class="oe">引用</em> </strong>，而不是对象的值。所以，请记住，有些函数可以<strong class="kf ir">改变被传递对象</strong>的值。</p><blockquote class="ob oc od"><p id="3824" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated"><em class="iq">某些对象的</em>值<em class="iq">可以改变。值可以改变的对象</em> <strong class="kf ir"> <em class="iq">是</em> </strong> <em class="iq">据说是</em> <strong class="kf ir">可变</strong><em class="iq">；一旦被创建，其值不变的对象</em><strong class="kf ir"><em class="iq"/></strong><em class="iq">称为</em><strong class="kf ir"/><em class="iq">。</em></p></blockquote><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="04e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="3921" class="nd lq iq mz b gy ne nf l ng nh">Before calling the function: ['this is test sentence', 'I love Python', 'positive thinking is nice!']<br/>After calling the function: ['This is test sentence', 'I love python', 'Positive thinking is nice!']</span></pre><p id="f1ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在调用我们的函数之后，我们已经更改了<code class="fe nj nk nl mz b">sentences</code>列表的内容。</p><p id="d819" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想将结果保存在一个不同的变量中，我们可以在我们的函数中拷贝列表，对拷贝版本进行大写并返回。这样，我们不会改变<code class="fe nj nk nl mz b">sentences</code>列表本身(在某些情况下，这是您想要的)。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="ab51" class="nd lq iq mz b gy ne nf l ng nh">Before calling the function: ['this is test sentence', 'I love Python', 'positive thinking is nice!']<br/>After calling the function: ['this is test sentence', 'I love Python', 'positive thinking is nice!']<br/>Capitalized sentences (result of the function): ['This is test sentence', 'I love python', 'Positive thinking is nice!']</span></pre><h1 id="8fb0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">摘要</h1><ul class=""><li id="2327" class="lb lc iq kf b kg mn kk mo ko nx ks ny kw nz la lg lh li lj bi translated">功能是一段有组织的<strong class="kf ir">可重用代码</strong>解决一个<strong class="kf ir">特定任务</strong>。</li><li id="d4e0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们可以添加<strong class="kf ir">任意多的参数</strong>，我们只需要用逗号<strong class="kf ir">分隔它们。</strong></li><li id="57ba" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当我们调用一个函数时，我们将参数传递给这个函数。</li><li id="b4ec" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们可以使用<code class="fe nj nk nl mz b"><strong class="kf ir">return</strong></code> <strong class="kf ir">关键字</strong>从函数中返回一个结果</li><li id="72ae" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们可以定义一个函数<strong class="kf ir">返回多个值</strong>构造名为<a class="ae kc" rel="noopener" target="_blank" href="/python-basics-tuples-9bb3851257b5"> <strong class="kf ir">元组</strong> </a>的对象</li><li id="c283" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">函数体的第一条语句可以是代表<strong class="kf ir">函数文档(可选)</strong>的<strong class="kf ir">字符串文字</strong></li><li id="540c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Python 有<strong class="kf ir"> 3 种类型的作用域</strong> : <strong class="kf ir">局部</strong>，<strong class="kf ir">全局</strong>和<strong class="kf ir">内置</strong>作用域。</li><li id="2298" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当我们在函数调用中使用<strong class="kf ir">关键字参数</strong>时，<strong class="kf ir">调用者通过参数名</strong>识别参数。这允许您<strong class="kf ir">跳过参数</strong>或<strong class="kf ir">将它们打乱顺序</strong>。</li><li id="2800" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们可以为一些函数参数指定<strong class="kf ir">默认参数</strong></li><li id="ebf6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当我们想要有<strong class="kf ir">灵活的参数</strong>时，我们可以使用<strong class="kf ir">特殊语法*args </strong>和<strong class="kf ir"> **kwargs </strong>。</li><li id="50b6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们可以使用<strong class="kf ir"> try-except 子句</strong>来<strong class="kf ir">处理</strong>引发的异常。</li><li id="9673" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们可以用<code class="fe nj nk nl mz b"><strong class="kf ir">raise</strong></code> <strong class="kf ir">关键字</strong>到<strong class="kf ir">抛出一个错误</strong>。</li><li id="a9fb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">断言语句</strong>是一种方便的方式来<strong class="kf ir">检查</strong>我们的<strong class="kf ir">代码</strong>。</li><li id="f25e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当我们<strong class="kf ir">将可变对象</strong>传递给我们的函数时，我们必须小心，<strong class="kf ir">它们的值可以被改变</strong>。</li><li id="5017" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">附加说明:当我们编写自己的函数时，我们必须小心不要覆盖某些<strong class="kf ir">包名</strong>或<strong class="kf ir">内置函数名</strong>。</li></ul><h1 id="0481" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">时事通讯</h1><p id="eb95" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果你想在我发表新的博客文章时得到通知，你可以订阅我的时事通讯。</p><h1 id="6d42" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">商务化人际关系网</h1><p id="517f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这是<a class="ae kc" href="https://www.linkedin.com/in/ventsislav-yordanov-a657b086/" rel="noopener ugc nofollow" target="_blank">我在 LinkedIn 上的简介</a>，如果你想和我联系的话。我将很高兴与你联系在一起。</p><h1 id="f04d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最后的话</h1><p id="a0da" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">谢谢你的阅读。我希望你喜欢这篇文章。如果你喜欢，请按住拍手键，分享给你的朋友。我很高兴听到你的反馈。如果你想写一篇关于λ函数的博文，请告诉我。如果你有什么问题，尽管问。😉</p><h1 id="021e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">资源:</h1><ul class=""><li id="afa0" class="lb lc iq kf b kg mn kk mo ko nx ks ny kw nz la lg lh li lj bi translated"><a class="ae kc" href="https://campus.datacamp.com/courses/python-data-science-toolbox-part-1/" rel="noopener ugc nofollow" target="_blank">https://camp . data camp . com/courses/python-data-science-toolbox-part-1/</a></li><li id="59f5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.geeksforgeeks.org/args-kwargs-python/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/args-kwargs-python/</a></li><li id="1cd2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.tutorialspoint.com/python/python_functions.htm" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/python/python_functions.htm</a></li><li id="347c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . salty crane . com/blog/2008/01/how-to-use-args-and-kwargs-in-python/</a></li><li id="fd37" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://stackoverflow.com/questions/2052390/manually-raising-throwing-an-exception-in-python" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2052390/manually-raising-throwing-a-exception-in-python</a></li><li id="5d27" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.tutorialspoint.com/python/python_exceptions.htm" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/python/python_exceptions.htm</a></li><li id="bce7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.w3schools.com/python/python_try_except.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/python/python_try_except.asp</a></li><li id="8b6a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/exceptions . html # exception-hierarchy</a></li><li id="0454" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">https://docs.python.org/3/tutorial/controlflow.html<a class="ae kc" href="https://docs.python.org/3/tutorial/controlflow.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="2224" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">【https://docs.python.org/3/reference/simple_stmts.html T4】</li><li id="2e09" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3/library/functions.html#built-in-functions" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/functions . html #内置函数</a></li><li id="c892" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3/reference/simple_stmts.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/simple_stmts.html</a></li></ul></div></div>    
</body>
</html>