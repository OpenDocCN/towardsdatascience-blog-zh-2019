<html>
<head>
<title>Security and Cryptography Mistakes You Are Probably Doing All The Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能一直在犯的安全和加密错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/security-and-cryptography-mistakes-you-are-probably-doing-all-the-time-7407c332944f?source=collection_archive---------22-----------------------#2019-12-13">https://towardsdatascience.com/security-and-cryptography-mistakes-you-are-probably-doing-all-the-time-7407c332944f?source=collection_archive---------22-----------------------#2019-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们澄清一些关于加密和安全的常见误解…</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6d805d4206e4f371081b516debb4d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75quRG3Dzfdg9z9_4v46EQ.jpeg"/></div></div></figure><p id="b4b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，关于密码学和安全性有很多神话和错误的假设。人们经常滥用密码原语，假设某些东西默认是安全的，或者使用过时的技术/算法。所以，让我们来看看这些误区和常见错误，这样你就可以在将来避免它们。</p><h1 id="2019" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">已经停止使用<code class="fe mi mj mk ml b">/dev/random</code></h1><p id="5f35" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">几乎所有人都会说，出于加密的目的，应该总是使用<code class="fe mi mj mk ml b">/dev/random</code>。嗯，那是错误的。<code class="fe mi mj mk ml b">/dev/urandom</code>和<code class="fe mi mj mk ml b">/dev/random</code>都使用完全相同的<em class="mr"> CSPRNG </em>。它们之间的区别是，<code class="fe mi mj mk ml b">/dev/random</code>会阻塞，直到它有足够的熵。这是另一个问题——你不希望你的应用程序等待熵，并围绕<code class="fe mi mj mk ml b">/dev/random</code>阻塞的可能性设计逻辑，特别是考虑到你不需要那么多熵...你所需要的是大约 256 比特的熵，这将从<code class="fe mi mj mk ml b">/dev/urandom</code>中得到。如果你想更深入地研究这个话题，那么请看这里的文章<a class="ae ms" href="https://www.2uo.de/myths-about-urandom" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="de15" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">永远不要使用 AES ECB</h1><p id="a243" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">你肯定知道<em class="mr"> AES </em>是一种分组密码。它以 128 位的块加密纯文本。好吧，听起来不错，那么使用<em class="mr"> ECB(电子密码本)</em>模式有什么问题呢？它在每个块上使用一个不变的密钥，所以如果你加密超过 128 位的数据，你的密文将看起来像这样:</p><div class="kj kk kl km gt ab cb"><figure class="mt kn mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3680f8b2f6ddbb89cd7bbe22449854fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*V_zidEDO3cVRsKNyDOrebQ.png"/></div></figure><figure class="mt kn mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c79ad8131603a5a910bf790853ce409e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*VJeUFjb-g9f_GoTKC3fPLA.png"/></div></figure></div><p id="89fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这算不上什么加密，对吧？那么，你应该用什么来代替<em class="mr"> ECB </em>？计数器模式(CTR)！为什么？因为加密可以并行完成，它使用<em class="mr"> IV </em> (nonce)来消除<em class="mr">未更改的密钥问题</em>，这是<em class="mr"> ECB </em>模式所具有的。记住永远不要重复使用第四代。</p><p id="b935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是密文在<em class="mr"> CTR </em>模式下的样子:</p><div class="kj kk kl km gt ab cb"><figure class="mt kn mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3680f8b2f6ddbb89cd7bbe22449854fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*V_zidEDO3cVRsKNyDOrebQ.png"/></div></figure><figure class="mt kn mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0a7113b06da5fcb33a3bb15050b44dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XMaIVPQg8yPg0uoEDUn2mQ.png"/></div></figure></div><p id="6228" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mr">可以用</em> <code class="fe mi mj mk ml b"><em class="mr">openssl</em></code> <em class="mr"> : </em>自己试试</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="989c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">永远不要对任何东西使用 MD5</h1><p id="db58" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">当我们谈到永远不使用东西的话题时…忘掉<em class="mr"> MD5 </em>，就像现在。它被设计用作一种安全的加密散列算法，但是在这一点上没有什么安全可言。它有冲突漏洞，您可以创建一对具有相同<em class="mr"> MD5 </em>哈希的文件，这意味着您可以伪造 SSL 或 CA 证书。那么，你应该用什么来代替呢？这取决于使用案例——对于密码散列使用<code class="fe mi mj mk ml b">bcrypt</code>或<code class="fe mi mj mk ml b">scrypt</code>。你用哪一个，在我看来是个人喜好- <code class="fe mi mj mk ml b">scrypt</code>被设计成<em class="mr">【更好】</em>比<code class="fe mi mj mk ml b">bcrypt</code>好，但它更新，所以它面临的审查更少。我个人仍然使用<code class="fe mi mj mk ml b">bcrypt</code>。至于其他用例，使用来自<em class="mr"> SHA-2 </em>家族的哈希函数，最好是像<em class="mr"> SHA-512 </em>这样的长摘要。</p><h1 id="7849" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">总是先加密后 MAC</h1><p id="613a" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">这一节的标题说<em class="mr">“Encrypt-then-MAC”</em>，但是让我们先回溯一点。很多人没有意识到他们应该始终将加密与消息认证结合使用。我不想详细解释为什么你应该验证消息，我要说的是，如果你不验证消息，那么你的应用程序就很容易受到攻击，比如<em class="mr">重放攻击</em>或<em class="mr">主动攻击</em>。</p><p id="7508" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然这样，为什么<em class="mr">先加密然后 MAC </em>？简单地说，这是获得<em class="mr">可证明安全性</em>的唯一方法，这并不总是必要的，但这意味着当使用这种结构时，基本上不可能在密码上搞乱<em class="mr">。</em></p><p id="fe84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想要更深入的解释，那么我推荐科林·帕西瓦尔的文章。</p><h1 id="e5f3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">特殊字符不会让您的密码变得更好</h1><p id="9610" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">不一定，至少。一个好的密码是你能记住的，所以加入像<code class="fe mi mj mk ml b">!@#$%^&amp;*</code>这样的字符会让你或你的应用程序的用户更有可能忘记它或者把它写在别人能看到的地方。</p><p id="7138" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初在密码中添加特殊字符的原因是什么？是<em class="mr">熵</em>，那么如果我们不想强迫用户在密码中包含特殊字符，那么有什么替代方案可以让熵保持足够高呢？</p><p id="35c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让它<em class="mr"> loooong </em>。正如流行的<a class="ae ms" href="https://xkcd.com/936/" rel="noopener ugc nofollow" target="_blank"> xkcd 密码强度漫画</a>所示，使用由几个随机单词串联而成的密码比试图记住一些胡言乱语更有意义。创建这些类型的密码满足了人类和计算机两方面的要求，换句话说，它很容易记住并且很难猜测(高熵，无法暴力破解)。</p><p id="7778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mr">注意:在理想世界中，每个人都会使用密码管理器并生成他们随机的超高熵密码，但这不是我们对普通非技术用户的期望。</em></p><h1 id="801b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">加密密钥轮换误解</h1><p id="fbaf" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">有人可能已经告诉过你，你应该每隔一段时间旋转你的密钥，没错，你绝对应该这么做。然而，许多人认为他们应该这样做以降低密钥被破解的可能性，而对于<em class="mr">加密</em>密钥来说，情况并非如此。您应该轮换<em class="mr">加密</em>密钥，以减少该密钥加密的数据量，从而降低单个密钥泄露造成的潜在损害。这种误解并没有改变你应该旋转键的事实，但是知道你为什么这样做是很重要的，这样你就可以正确地评估应该使用什么间隔。</p><h1 id="d139" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">不要存储用户密码</h1><p id="275c" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">再次回到<em class="mr">“千万不要做傻事”</em>的话题。这是一个有点夸张的说法，我见过很多次了，一个网站在我注册后通过电子邮件给我发了一个密码…就像…当你从一个用户那里得到一个密码时，你应该做的第一件事就是散列它并扔掉密码的明文版本，如果你是通过电子邮件给我发的，那么你显然没有这样做(<em class="mr">夸张结束</em>)！</p><p id="13c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们深呼吸一下…那么如何存储那些密码呢？</p><p id="2f1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">收到用户的密码后，立即使用工作系数至少为 12 的慢速哈希函数(如<code class="fe mi mj mk ml b">bcrypt</code>)对其进行哈希运算，并从内存中删除明文密码。工作系数 12 在发布时是有效的<em class="mr">现在是有效的</em>，一年后仍然不够。我会亲自<em class="mr">拍摄长达 400 毫秒的密码验证，你可以在你的机器上检查哪个工作因素会给你。</em></p><p id="5685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不打算使用<code class="fe mi mj mk ml b">bcrypt</code>，请确保在密码中添加<em class="mr">盐</em>，以防止<em class="mr">预计算攻击</em>，就像<em class="mr">彩虹表攻击</em>一样。</p><h1 id="bc86" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">集装箱不安全</h1><p id="00e1" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">很多人认为默认情况下 Docker 容器是安全的，但事实并非如此。它们是为了解决部署问题而构建的，而不是安全问题。</p><p id="c23b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">甚至还有漏洞允许攻击者获得对主机系统的<code class="fe mi mj mk ml b">root</code>访问权，而所需要的只是对容器的<em class="mr">外壳</em>访问权。那么，如何避免这些安全问题和漏洞呢？</p><ul class=""><li id="1d0a" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><em class="mr">使用最少的基础图像来减少攻击面</em> —这些图像的例子有基于<code class="fe mi mj mk ml b">alpine</code>的图像或 Red Hat <em class="mr">通用基础图像</em>。</li><li id="7729" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><em class="mr">只安装必要的库</em> —容器中的库越少，被利用的可能性就越低。</li><li id="b9d9" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><em class="mr">使用受信任的图像</em>——不要只是从<em class="mr"> Docker Hub </em>下载任何图像。使用那些由值得信赖的团队审查、维护并有大量下载的网站。</li><li id="a27f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><em class="mr">不要使用</em> <code class="fe mi mj mk ml b"><em class="mr">latest</em></code> <em class="mr">标签</em>——通过使用固定标签，你可以确保在你的下一个版本中不会引入任何漏洞。</li><li id="2f79" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><em class="mr">使用特权最低的用户(永远不要在</em><code class="fe mi mj mk ml b"><em class="mr">root</em></code><em class="mr">)</em>——用<code class="fe mi mj mk ml b">USER 1001</code>命令结束<code class="fe mi mj mk ml b">Dockerfiles</code>是一个很好的做法，这样可以确保你使用的用户没有特权，不会打开你的容器，从而暴露额外的漏洞。</li></ul><p id="0526" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以做更多的事情来保护你的图像，你可以稍后谷歌，但我认为上面的列表是每个人在使用图像/容器时应该记住的最低要求。</p><h1 id="5910" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="5637" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">每个软件开发者/DevOps 工程师都要对应用和系统的安全性负责，至少在一定程度上是这样(不管你喜不喜欢)。因此，我认为我们所有人都应该花一点时间做必要的研究，以确保避免类似上述的愚蠢错误和误解。</p><p id="d705" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要只相信别人告诉你的(人总是会犯错)。当涉及到安全和加密时，自己查找和检查—根据事实做出决定。</p><p id="0036" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mr">注:这最初发布在</em><a class="ae ms" href="https://martinheinz.dev/blog/12" rel="noopener ugc nofollow" target="_blank"><em class="mr">martinheinz . dev</em></a></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="62f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="mr">注来自《走向数据科学》的编辑:</em> </strong> <em class="mr">虽然我们允许独立作者根据我们的</em> <a class="ae ms" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="mr">规则和指导方针</em> </a> <em class="mr">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae ms" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="mr">读者术语</em> </a> <em class="mr">。</em></p></div></div>    
</body>
</html>