<html>
<head>
<title>Color palette extraction with K-means clustering | Machine Learning from Scratch (Part IV)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用 K-均值聚类的调色板提取|从零开始的机器学习(第四部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/color-palette-extraction-with-k-means-clustering-machine-learning-from-scratch-part-iv-55e807407e53?source=collection_archive---------13-----------------------#2019-04-20">https://towardsdatascience.com/color-palette-extraction-with-k-means-clustering-machine-learning-from-scratch-part-iv-55e807407e53?source=collection_archive---------13-----------------------#2019-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Python 中的 K-Means 聚类在移动 UI 截图中查找主色</h2></div><blockquote class="kf"><p id="3203" class="kg kh iq bd ki kj kk kl km kn ko kp dk translated"><em class="kq">TL；DR 使用 Python 从头开始构建 K-Means 聚类模型。使用你的模型从 UI 移动设计截图中寻找主色。</em></p></blockquote><figure class="kr ks kt ku kv kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="b271" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">为你的下一个大型移动应用程序(重新)设计选择调色板可能是一项艰巨的任务，尤其是当你不知道自己在做什么的时候。你如何能使它变得更容易(请求一个朋友)？</p><p id="9516" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">一种方法是去一个地方，在那里<em class="lu">专家</em>分享他们的工作。像<a class="ae lv" href="https://dribbble.com/" rel="noopener ugc nofollow" target="_blank"> Dribbble </a>、<a class="ae lv" href="https://www.uplabs.com/" rel="noopener ugc nofollow" target="_blank"> uplabs </a>和<a class="ae lv" href="https://www.behance.net/" rel="noopener ugc nofollow" target="_blank"> Behance </a>这样的页面都有货。</p><p id="bf6b" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">找到您喜欢的模型后，您可能想要从中提取颜色并使用它们。这可能需要打开专门的软件，用一些工具和其他非处方工具手动选择颜色。让我们用机器学习让你的生活更简单。</p><div class="lw lx gp gr ly lz"><a href="https://colab.research.google.com/drive/1_p1nptDfvJhcSvprmi1WtoIugsCI40Xa" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">源代码</h2><div class="mg l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">colab.research.google.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm mn lz"/></div></div></a></div><h1 id="da08" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">无监督学习</h1><p id="cefa" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">到目前为止，我们只研究了需要特征和标签形式的训练数据的模型。换句话说，对于每个例子，我们也需要有正确的答案。</p><p id="f119" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">通常，这样的训练数据很难获得，并且需要人工完成许多小时的工作(是的，我们已经在为“终结者”服务)。我们能跳过这些吗？</p><p id="1edc" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">是的，至少对于某些问题，我们可以在不知道正确答案的情况下使用示例数据。一个这样的问题是<em class="lu">集群</em>。</p><h2 id="b347" class="nl mp iq bd mq nm nn dn mu no np dp my li nq nr na lm ns nt nc lq nu nv ne nw bi translated">什么是集群？</h2><p id="a608" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">给定一些数据点的向量<em class="lu"> X </em>，聚类方法允许您将每个点放在一个组中。换句话说，您可以根据一组实体的属性自动对它们进行分类。</p><p id="c37c" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">是的，这在实践中非常有用。通常，你在一堆数据点上运行算法，并指定你想要多少组。例如，您的收件箱包含两组主要的电子邮件:垃圾邮件和非垃圾邮件(您是否在等待其他邮件？).你可以让聚类算法从你的电子邮件中创建两个组，并使用你美丽的大脑来分类哪个是哪个。</p><p id="9f4e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">聚类算法的更多应用:</p><ul class=""><li id="730f" class="nx ny iq lb b lc ld lf lg li nz lm oa lq ob kp oc od oe of bi translated"><em class="lu">客户细分</em> —寻找消费/行为方式相同的用户群</li><li id="062a" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp oc od oe of bi translated"><em class="lu">欺诈交易</em> —查找属于不同分类的银行交易，并将它们识别为欺诈交易</li><li id="60bc" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp oc od oe of bi translated"><em class="lu">文档分析</em> —对相似的文档进行分组</li></ul><figure class="om on oo op gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi ol"><img src="../Images/90f97f64fb6c27f99fb65e45067af6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WWeImr31JUkhjZW8.png"/></div></div><figcaption class="ov ow gj gh gi ox oy bd b be z dk"><em class="kq">source: various authors on </em><a class="ae lv" href="https://www.uplabs.com/" rel="noopener ugc nofollow" target="_blank"><em class="kq">https://www.uplabs.com/</em></a></figcaption></figure><p id="f38d" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">这一次，我们的数据不是来自一些预定义的或众所周知的数据集。由于无监督学习不需要标记数据，互联网可以是你的牡蛎。</p><p id="4c28" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">在这里，我们将使用来自不同作者的 3 个移动用户界面设计。我们的模型将在每个镜头上运行，并尝试提取每个镜头的调色板。</p><h1 id="fd61" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">什么是 K-Means 聚类？</h1><p id="acd0" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">K-Means 聚类被<a class="ae lv" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank">维基百科</a>定义为:</p><blockquote class="oz pa pb"><p id="63b2" class="kz la lu lb b lc ld jr le lf lg ju lh pc lj lk ll pd ln lo lp pe lr ls lt kp ij bi translated"><em class="iq"> k-means 聚类是一种矢量量化的方法，起源于信号处理，常用于数据挖掘中的聚类分析。k-means 聚类旨在将 n 个观察值划分为 k 个聚类，其中每个观察值属于具有最近均值的聚类，作为该聚类的原型。这导致将数据空间划分成 Voronoi 单元。</em></p></blockquote><p id="7191" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">维基百科还告诉我们，解决 K-Means 聚类是困难的(事实上，<a class="ae lv" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"> NP-hard </a>)，但我们可以使用一些启发式算法找到局部最优解。</p><p id="600b" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">但是 K 均值聚类是如何工作的呢？</p><p id="2585" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">假设你有一个包含数据点的向量<em class="lu"> X </em>。运行我们的算法包括以下步骤:</p><ol class=""><li id="39d6" class="nx ny iq lb b lc ld lf lg li nz lm oa lq ob kp pf od oe of bi translated">从<em class="lu"> X </em>中随机选取<em class="lu"> k 个</em>点(称为<em class="lu">形心</em></li><li id="0f07" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp pf od oe of bi translated">将每个点分配到最近的质心。新形成的一簇点被称为<em class="lu">簇</em>。</li><li id="0b38" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp pf od oe of bi translated">对于每个聚类，通过从这些点计算新的中心来找到新的质心</li><li id="de62" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp pf od oe of bi translated">重复步骤 2–3，直到质心停止变化</li></ol><p id="8ac4" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">让我们看看如何使用它从移动 UI 截图中提取调色板。</p><h2 id="0d9d" class="nl mp iq bd mq nm nn dn mu no np dp my li nq nr na lm ns nt nc lq nu nv ne nw bi translated">数据预处理</h2><p id="990f" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">假设我们的数据存储在原始像素(称为图像)中，我们需要一种方法将其转换为我们的聚类算法可以使用的点。</p><p id="bb38" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">让我们首先定义两个表示点和簇的类:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="0822" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">我们的<code class="fe ph pi pj pk b">Point</code>只是我们空间中每个维度坐标的持有者。</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="2d93" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated"><code class="fe ph pi pj pk b">Cluster</code>由它的中心和它包含的所有其他点定义。</p><p id="dccc" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">给定图像文件的路径，我们可以如下创建点:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="d97a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">这里发生了几件事:</p><ul class=""><li id="a3f2" class="nx ny iq lb b lc ld lf lg li nz lm oa lq ob kp oc od oe of bi translated">将图像载入内存</li><li id="807e" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp oc od oe of bi translated">将其调整为较小的图像(移动 UX 需要屏幕上的大元素，所以我们不会丢失太多的颜色信息)</li><li id="3c16" class="nx ny iq lb b lc og lf oh li oi lm oj lq ok kp oc od oe of bi translated">删除 alpha(透明度)信息</li></ul><p id="4e21" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">注意，我们正在为图像中的每个像素创建一个<code class="fe ph pi pj pk b">Point</code>。</p><p id="c625" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">好吧！现在，您可以从图像中提取点。但是，我们如何计算我们的集群中各点之间的距离呢？</p><h2 id="35db" class="nl mp iq bd mq nm nn dn mu no np dp my li nq nr na lm ns nt nc lq nu nv ne nw bi translated">距离函数</h2><p id="2f34" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">类似于我们的监督算法示例中的成本函数，我们需要一个函数来告诉我们做得有多好。我们算法的目标是最小化每个质心中的点之间的距离。</p><p id="22f6" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">我们可以使用的最简单的距离函数之一是欧几里德距离，定义如下:</p><figure class="om on oo op gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/6779a5416714074e2797457e218c8082.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*72G9UKga-Mm6hxc1gZfipQ.png"/></div></figure><p id="23ad" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">其中和是我们空间的两点。</p><p id="85c5" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">请注意，虽然欧几里德距离实现起来很简单，但它可能不是计算<a class="ae lv" href="https://en.wikipedia.org/wiki/Color_difference" rel="noopener ugc nofollow" target="_blank">色差</a>的最佳方式。</p><p id="7a9f" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">以下是 Python 实现:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><h2 id="4583" class="nl mp iq bd mq nm nn dn mu no np dp my li nq nr na lm ns nt nc lq nu nv ne nw bi translated">实现 K 均值聚类</h2><p id="2d13" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">现在你已经有了所有的拼图，你可以实现 K-Means 聚类算法。让我们从寻找一组点的中心的方法开始:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="3e1f" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">为了找到一组点的中心，我们将每个维度的值相加，然后除以点数。</p><p id="b242" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">现在，为了找到实际的集群:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="d185" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">实现遵循上面给出的算法描述。请注意，当色差低于我们设置的值时，我们将退出训练循环。</p><h1 id="31bf" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">估价</h1><p id="42e4" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">现在您已经实现了 K-Means 聚类，您可以在 UI 截图上使用它。我们需要更多一点的粘合代码，以便更容易提取调色板:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="c64e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated"><code class="fe ph pi pj pk b">get_colors</code>函数获取一个图像文件的路径和您想要从图像中提取的颜色数量。我们根据每个聚类中的点对从我们的算法中获得的聚类进行排序(降序)。最后，我们将 RGB 颜色转换为十六进制值。</p><p id="304d" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">让我们从数据中提取第一个 UI 截图的调色板:</p><figure class="om on oo op gt kw"><div class="bz fp l di"><div class="pg ky l"/></div></figure><p id="ac6f" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">这是十六进制的颜色值:</p><pre class="om on oo op gt pm pk pn po aw pp bi"><span id="26f7" class="nl mp iq pk b gy pq pr l ps pt">#f9f8fa, #4252a6, #fc6693, #bdbcd0, #374698</span></pre><p id="1d12" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">为了直观地展示我们的结果:</p><figure class="om on oo op gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi ol"><img src="../Images/042b35f1db956bfda6c4f7d6d587127b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FuXIo_qQ4r44J-DR.png"/></div></div></figure><p id="9589" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">在接下来的两个图像上运行聚类，我们得到以下结果:</p><figure class="om on oo op gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi ol"><img src="../Images/6ea282b72911e1245ae12d565e423235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*32o789Yfj6zFfYpf.png"/></div></div></figure><p id="51e0" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">最后一张截图:</p><figure class="om on oo op gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi ol"><img src="../Images/abb0d83f62a6b02fd4b453a92e4e3bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4jCiYLp7aMcHMHpy.png"/></div></div></figure><p id="bed5" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">嗯，看起来很酷，对吧？继续在你自己的图像上试试吧！</p><div class="lw lx gp gr ly lz"><a href="https://colab.research.google.com/drive/1_p1nptDfvJhcSvprmi1WtoIugsCI40Xa" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">源代码</h2><div class="mg l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">colab.research.google.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm mn lz"/></div></div></a></div><h1 id="8910" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="cc7f" class="pw-post-body-paragraph kz la iq lb b lc ng jr le lf nh ju lh li ni lk ll lm nj lo lp lq nk ls lt kp ij bi translated">恭喜你，你刚刚实现了你的第一个无监督算法！当试图从图像中提取调色板时，它似乎也获得了良好的结果。</p><p id="43ce" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">接下来，我们将对短语进行情感分析，并学习如何处理文本数据。</p></div><div class="ab cl pu pv hu pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="ij ik il im in"><p id="4aec" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated"><em class="lu">最初发表于</em><a class="ae lv" href="https://www.curiousily.com/posts/color-palette-extraction-with-k-means-clustering/" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a><em class="lu">。</em></p></div><div class="ab cl pu pv hu pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="ij ik il im in"><p id="2ad0" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt kp ij bi translated">喜欢你读的吗？你想了解更多关于机器学习的知识吗？提升你对 ML 的理解:</p><div class="lw lx gp gr ly lz"><a href="https://leanpub.com/hmls" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">从零开始实践机器学习</h2><div class="qb l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">“我不能创造的东西，我不理解”——理查德·费曼这本书将引导你走向更深的…</h3></div><div class="mg l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">leanpub.com</p></div></div><div class="mh l"><div class="qc l mj mk ml mh mm mn lz"/></div></div></a></div></div></div>    
</body>
</html>