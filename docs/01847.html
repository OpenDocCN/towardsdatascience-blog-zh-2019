<html>
<head>
<title>Using Python Pandas Dataframe vs Min Heap Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python Pandas 数据帧与最小堆数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implement-a-min-heap-to-solve-performance-issue-with-data-processing-1f7f891a4ec0?source=collection_archive---------17-----------------------#2019-03-26">https://towardsdatascience.com/implement-a-min-heap-to-solve-performance-issue-with-data-processing-1f7f891a4ec0?source=collection_archive---------17-----------------------#2019-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f47b9249eae8376c8f519c7f2d6eaee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8HE8_YOtLjGuZYAr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@mkunsplash84?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marian Kroell</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="59fa" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">介绍</h1><p id="2d37" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">最近我花了很多时间研究基本的数据结构，包括栈、队列、堆和树。它教会了我用以下不同的方式解决问题(代码):</p><ul class=""><li id="aa10" class="mj mk it ln b lo ml ls mm lw mn ma mo me mp mi mq mr ms mt bi translated">总是寻找最简单、最有效、最优雅的方式(可读性是金)</li><li id="aaf0" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">审查，审查和审查，以提高代码的效率(是否有重复的部分？我能换一种方式做吗？有些步骤是多余的吗？)</li><li id="791a" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">在选择你可以使用的工具(框架、数据结构、算法)时，要实际考虑</li></ul><p id="6056" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">阅读理论只是一个开始，在我看来，巩固所学知识的最好方法是将其应用到现实世界的问题中。幸运的是，我参与的一个项目中有一部分可以利用<code class="fe nc nd ne nf b">Min Heap</code>的实现，也就是通常所说的<code class="fe nc nd ne nf b">Priority Queue</code>。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/46e548d9789146aa5d27dc8e1cb90aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkGHmuUPGqtTvG8k4OzLxg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">An example of a <strong class="bd nl">Binary Min Heap</strong>, visualised in a tree structure.</figcaption></figure><p id="edb6" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">我在下面几节中概述了实现:</p><ul class=""><li id="5581" class="mj mk it ln b lo ml ls mm lw mn ma mo me mp mi mq mr ms mt bi translated">问题是</li><li id="5f4f" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">在最小堆实现之前</li><li id="7800" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">在最小堆实现之后</li><li id="39f5" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">参考</li></ul></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="f759" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">问题是</h1><p id="2f7e" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">任务很简单:从所有满足<strong class="ln iu">包含依赖规则</strong>的输入表中找到所有<strong class="ln iu">列对</strong>。规则是，对于每个列对，一列的所有值都必须存在于它的列对中。下面是为了更容易理解的例子。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/0b6d5605a998e2984c985e77a29fd0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iW5d89a5_eGvNifrcu1rFQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">In<strong class="bd nl"> Example 1</strong>, there were 2 checks performed: 1) column A in column B and 2) column B in column A. The valid column pair in this example is 2) <strong class="bd nl">column B in column A</strong>, because all values in column B exists in column A (inclusion dependency rule satisfied). In <strong class="bd nl">Example 2,</strong> both checks 1) column C in column D and 2) column D in column C are invalid, because the value LL300 only exists in column D.</figcaption></figure><p id="cdad" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">现在，您可能会想，为什么要让事情变得复杂呢？您可以通过检查每一对，一列中的所有值是否都包含在另一列中，来应用强力方法。问题是大约有 900 个表，每个表都有不同数量的列。简而言之，当使用暴力方法时，要花很长时间来完成检查。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="7967" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">在最小堆实现之前</h1><p id="a21c" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我最初的方法比暴力方法稍微好一点，但是，它仍然需要很长时间来运行。本质上，应用了<code class="fe nc nd ne nf b">Single Pass</code>算法。这意味着在找出列对时，所有数据(或值)将只被读取一次，而不是多次(想想暴力方法，您将多次读取相同的列/值)。</p><p id="15b7" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">为此，我使用<code class="fe nc nd ne nf b">pandas</code>库构建了一个单独的<code class="fe nc nd ne nf b">data frame</code>，存储所有表中的所有列，包括它们的值。最后的<code class="fe nc nd ne nf b">data frame</code>看起来是这样的。</p><pre class="nh ni nj nk gt nn nf no np aw nq bi"><span id="9f4c" class="nr ko it nf b gy ns nt l nu nv">A       B     C<br/>index<br/>0        nan     0.0   0.0<br/>1        1.0     nan   1.0<br/>2        2.0     nan   2.0<br/>3        nan     3.0   3.0</span></pre><p id="458e" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">让我通过这些步骤来了解上面的<code class="fe nc nd ne nf b">data frame</code>:</p><ul class=""><li id="77ef" class="mj mk it ln b lo ml ls mm lw mn ma mo me mp mi mq mr ms mt bi translated">对于每个表中的每一列，将其唯一值存储在一个<code class="fe nc nd ne nf b">list</code>中，按升序排序</li><li id="133f" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">从所有列中获取所有唯一值，将它们存储在一个<code class="fe nc nd ne nf b">list</code>中，按升序排序，例如按照上述<code class="fe nc nd ne nf b">data frame</code>的<code class="fe nc nd ne nf b">[0, 1, 2, 3]</code></li><li id="feaf" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">构造一个<code class="fe nc nd ne nf b">data frame</code>并将其<code class="fe nc nd ne nf b">index</code>设置为包含来自<strong class="ln iu">步骤 2 </strong>的所有唯一值的<code class="fe nc nd ne nf b">list</code></li><li id="2e90" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">通过<code class="fe nc nd ne nf b">index</code>上的<code class="fe nc nd ne nf b">left join</code>合并从<strong class="ln iu">步骤 1 </strong>到<strong class="ln iu">步骤 3 </strong>的所有列表(当一列没有特定值时，会在最后的<code class="fe nc nd ne nf b">data frame</code>中产生一个<code class="fe nc nd ne nf b">nan</code>条目)，例如，列<code class="fe nc nd ne nf b">A</code>没有<code class="fe nc nd ne nf b">[0, 3]</code>。</li></ul><blockquote class="nw nx ny"><p id="f3bb" class="ll lm nz ln b lo ml lq lr ls mm lu lv oa mz ly lz ob na mc md oc nb mg mh mi im bi translated">注意，由于<code class="fe nc nd ne nf b"><em class="it">nan</em></code>值的形成，<code class="fe nc nd ne nf b"><em class="it">data frame</em></code>中的列类型不是<code class="fe nc nd ne nf b"><em class="it">float64</em></code>。那些列的原始值实际上是<code class="fe nc nd ne nf b"><em class="it">int64</em></code>。</p></blockquote><p id="6b97" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">在迭代<code class="fe nc nd ne nf b">data frame</code>中的每一行之前，我们需要初始化一个包含初始包含依赖列列表的<code class="fe nc nd ne nf b">dictionary</code>。等等，什么？让我给你展示一下<code class="fe nc nd ne nf b">dictionary</code>的样子，让你明白这一点。</p><pre class="nh ni nj nk gt nn nf no np aw nq bi"><span id="3a30" class="nr ko it nf b gy ns nt l nu nv">inclusion_dict = {'A': ['B', 'C'],<br/>                  'B': ['A', 'C'],<br/>                  'C': ['A', 'B']}</span></pre><p id="8111" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">现在更有意义了？因此，基本上，我们初始化所有可能的列对(例如，列 B 中的列 A，列 C 中的列 A，表示为字典条目<code class="fe nc nd ne nf b">'A': ['B', 'C']</code>，等等。)作为我们迭代前的起点。当我们迭代<code class="fe nc nd ne nf b">data frame</code>中的每一行时，<code class="fe nc nd ne nf b">inclusion_dict</code>将会相应地更新(更多信息见下文)。</p><p id="9f72" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">好了，让我们来谈谈迭代。下面是执行迭代的代码。</p><pre class="nh ni nj nk gt nn nf no np aw nq bi"><span id="c4b0" class="nr ko it nf b gy ns nt l nu nv">def sp_algorithm(dataframe, inclusion_dict):</span><span id="9d1f" class="nr ko it nf b gy od nt l nu nv">    # for each value, get all columns that contains it<br/>    for val in dataframe.index:</span><span id="0cd0" class="nr ko it nf b gy od nt l nu nv">        cols_list = dataframe.columns[dataframe.isin([val]).any()]</span><span id="fc6b" class="nr ko it nf b gy od nt l nu nv">        # for each column in inclusion_dict.keys(), intersect its values with cols_list to get the remaining column pairs candidates<br/>        for key_col in inclusion_dict.keys():</span><span id="3b72" class="nr ko it nf b gy od nt l nu nv">            column_val = dataframe.loc[val, key_col]</span><span id="bd35" class="nr ko it nf b gy od nt l nu nv"># if the current column value is null, then do nothing<br/>            if (column_val == column_val) &amp; (column_val != ''):<br/>                col_dict[key_col] = list(set(col_dict[key_col]).intersection(cols_list))</span></pre><p id="add4" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">提醒一下，这是<code class="fe nc nd ne nf b">data frame</code>。</p><pre class="nh ni nj nk gt nn nf no np aw nq bi"><span id="c846" class="nr ko it nf b gy ns nt l nu nv">A       B     C<br/>index<br/>0        nan     0.0   0.0<br/>1        1.0     nan   1.0<br/>2        2.0     nan   2.0<br/>3        nan     3.0   3.0</span></pre><p id="51ef" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">在<code class="fe nc nd ne nf b">data frame</code>行的每次迭代中，会发生以下情况:</p><ul class=""><li id="d4f4" class="mj mk it ln b lo ml ls mm lw mn ma mo me mp mi mq mr ms mt bi translated"><code class="fe nc nd ne nf b">cols_list</code>:获取包含当前索引值的所有列(只是它们的名称)<code class="fe nc nd ne nf b">val</code></li><li id="e6a5" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">对于<code class="fe nc nd ne nf b">inclusion_dict</code>中的每一列(字典的<code class="fe nc nd ne nf b">key</code>),根据位置<code class="fe nc nd ne nf b">.loc</code>在<code class="fe nc nd ne nf b">data frame</code>中获取其值</li><li id="cd87" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">检查<strong class="ln iu">第二步</strong>的值是否为<code class="fe nc nd ne nf b">nan</code>和/或<code class="fe nc nd ne nf b">''</code>，如果不是，通过与<code class="fe nc nd ne nf b">cols_list</code>相交更新<code class="fe nc nd ne nf b">inclusion_dict</code>。例如，在上面的<code class="fe nc nd ne nf b">data frame</code>的第一次迭代中，<code class="fe nc nd ne nf b">cols_list</code>将是<code class="fe nc nd ne nf b">['B', 'C']</code>，因为它们包含值<code class="fe nc nd ne nf b">0</code>。当我们查找<code class="fe nc nd ne nf b">inclusion_dict</code>时，<code class="fe nc nd ne nf b">key_col = 'A'</code>将被跳过，因为它在<code class="fe nc nd ne nf b">if statement</code>中返回<code class="fe nc nd ne nf b">False</code>，因为它是<code class="fe nc nd ne nf b">nan</code>(参见<code class="fe nc nd ne nf b">data frame</code>中索引<code class="fe nc nd ne nf b">0</code>处的<code class="fe nc nd ne nf b">A</code>列)。对于<code class="fe nc nd ne nf b">key_col = 'B'</code>，我们将把它当前的<code class="fe nc nd ne nf b">inclusion_dict</code>值与<code class="fe nc nd ne nf b">cols_list</code>相交，这样我们就有了<code class="fe nc nd ne nf b">['C']</code>。这是因为<code class="fe nc nd ne nf b">['A', 'C']</code> <strong class="ln iu">与<code class="fe nc nd ne nf b">['B', 'C']</code>相交的</strong>就是<code class="fe nc nd ne nf b">['C']</code>。对于<code class="fe nc nd ne nf b">key_col = 'C'</code>，其<code class="fe nc nd ne nf b">inclusion_dict</code>剩余值将为<code class="fe nc nd ne nf b">['B']</code>。</li></ul><blockquote class="nw nx ny"><p id="c980" class="ll lm nz ln b lo ml lq lr ls mm lu lv oa mz ly lz ob na mc md oc nb mg mh mi im bi translated">嗯，上面的一系列代码实际上工作并产生了我想要的结果，但是，运行时间非常慢！所以，我开始问自己一个问题，如果数据库大得多，如果有更多的表和列要处理怎么办？</p></blockquote><p id="cdca" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">此外，每次在<code class="fe nc nd ne nf b">sp_algorithm</code>运行时代码中出现错误，我都必须从头重新运行整个程序，这花费了我很长时间。代码看起来也不可读，难以理解，并且可能不可持续。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="4eeb" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">在最小堆实现之后</h1><p id="3b6e" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">多亏了<code class="fe nc nd ne nf b">Min Heap</code>数据结构，我能够将运行时间提高 10 到 60 倍，这取决于数据库(大小、表计数、列计数、唯一值计数等。)!</p><p id="e34d" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">无论如何，这是一个巨大的进步！我不必整夜运行我的代码，希望没有任何东西会中断，并在早上第一件事就是检查它。现在，我可以随时运行代码，并在几分钟内得到结果，而不是几个小时。</p><p id="fa3f" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">事不宜迟，下面是实现代码。</p><pre class="nh ni nj nk gt nn nf no np aw nq bi"><span id="f8a1" class="nr ko it nf b gy ns nt l nu nv"># inclusion_dict from above<br/>inclusion_dict = {'A': ['B', 'C'],<br/>                  'B': ['A', 'C'],<br/>                  'C': ['A', 'B']}</span><span id="8afb" class="nr ko it nf b gy od nt l nu nv"># instead of a data frame, a dictionary is used to store columns from all tables<br/># column_dict stores sorted (ascending order) unique values from all columns from all tables<br/>column_dict = {'A': [1, 2], <br/>               'B': [0, 3],<br/>               'C': [0, 1, 2, 3]}</span><span id="a6ab" class="nr ko it nf b gy od nt l nu nv">def sp_algorithm(column_dict):<br/>    # initialise min heap<br/>    min_heap = []</span><span id="65ae" class="nr ko it nf b gy od nt l nu nv">    for column in column_dict:<br/>        vals = column_dict[column]</span><span id="22f0" class="nr ko it nf b gy od nt l nu nv">        for val in vals:<br/>            tup = (val, column)<br/>            heapq.heappush(min_heap, tup)</span><span id="fddb" class="nr ko it nf b gy od nt l nu nv">    while min_heap:</span><span id="0dcb" class="nr ko it nf b gy od nt l nu nv">        # get the smallest value in the heap<br/>        att = []</span><span id="eff2" class="nr ko it nf b gy od nt l nu nv">        current_smallest, var = heapq.heappop(min_heap)<br/>        att.append(var)</span><span id="5c80" class="nr ko it nf b gy od nt l nu nv">        # pop all elements where values are equal to current smallest and put them in att list<br/>        while min_heap and min_heap[0][0] == current_smallest:<br/>            next_var = heapq.heappop(min_heap)[-1]<br/>            att.append(next_var)</span><span id="848c" class="nr ko it nf b gy od nt l nu nv">        # update inclusion_dict<br/>        for a in att:<br/>            if a in inclusion_dict:<br/>                inclusion_dict[a] = list(set(inclusion_dict[a]).intersection(att))</span><span id="2a2b" class="nr ko it nf b gy od nt l nu nv"># final inclusion_dict should look like<br/>inclusion_dict = {'A': ['C'],<br/>                  'B': ['C'],<br/>                  'C': []}</span></pre><p id="609d" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated"><code class="fe nc nd ne nf b">inclusion_dict</code>最后的结果基本上说:</p><ul class=""><li id="b799" class="mj mk it ln b lo ml ls mm lw mn ma mo me mp mi mq mr ms mt bi translated">列 A 可能依赖于列 C，因为它的所有值都在列 C 中</li><li id="1da0" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">列 B 可能依赖于列 C，因为它的所有值都在列 C 中</li><li id="2eaf" class="mj mk it ln b lo mu ls mv lw mw ma mx me my mi mq mr ms mt bi translated">列 C 在此上下文中没有依赖关系，因为列 A 和列 B 都不包含列 C 中的所有值</li></ul><blockquote class="nw nx ny"><p id="8f4c" class="ll lm nz ln b lo ml lq lr ls mm lu lv oa mz ly lz ob na mc md oc nb mg mh mi im bi translated">我希望这能给你一个在项目中实现<code class="fe nc nd ne nf b"><em class="it">Min Heap</em></code>的潜在好处的想法。正如我前面提到的，思考并重新思考你可以使用哪些工具，并明智地选择。</p></blockquote><p id="04a1" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated"><code class="fe nc nd ne nf b">Min Heap</code>背后的理论不在本文讨论范围之内。本文的主要目的是向您展示一个真实世界中的<code class="fe nc nd ne nf b">Min Heap</code>实现。别担心，只要在谷歌上搜索一下，你就会在<code class="fe nc nd ne nf b">Min Heap</code>上找到大量的资源。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="3a83" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">参考</h1><p id="7b9c" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">上面描述的技术来自一篇讨论<strong class="ln iu">单程包含依赖识别(SPIDER) </strong>算法的论文。你可以在这里了解更多信息<a class="ae kf" href="https://hpi.de/fileadmin/user_upload/fachgebiete/naumann/publications/2010/HPI_34_Efficient_and_Exact_Computation_of_Inclusion_Dependencies_for_Data_Integration.pdf" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7991" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">前往<strong class="ln iu">章节 2.2.2 </strong>和<strong class="ln iu"> 2.2.3 </strong>了解<strong class="ln iu">蜘蛛</strong>算法的更多细节。</p><p id="d376" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">就<code class="fe nc nd ne nf b">Heap</code>理论而言，你可以在谷歌上找到很多参考资料。这里有一本<a class="ae kf" href="https://www.pythoncentral.io/priority-queue-beginners-guide/" rel="noopener ugc nofollow" target="_blank">你可以读。</a></p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="6a94" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">最后的话</h1><p id="eb97" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">这是我写的第一篇有点冗长的文章，所以，如果你觉得有用，请留下你的反馈、评论或给我鼓掌或加书签。</p><p id="05e6" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">欢迎提出任何问题或在下面留下建议。</p><p id="401e" class="pw-post-body-paragraph ll lm it ln b lo ml lq lr ls mm lu lv lw mz ly lz ma na mc md me nb mg mh mi im bi translated">干杯！🙂</p></div></div>    
</body>
</html>