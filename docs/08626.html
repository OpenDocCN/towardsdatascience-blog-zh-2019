<html>
<head>
<title>How to Find Linear (SVMs) and Quadratic Classifiers using MATLAB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 MATLAB 找到线性(支持向量机)和二次分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-linear-svms-and-quadratic-classifiers-using-matlab-97ea7550655a?source=collection_archive---------28-----------------------#2019-11-20">https://towardsdatascience.com/how-to-find-linear-svms-and-quadratic-classifiers-using-matlab-97ea7550655a?source=collection_archive---------28-----------------------#2019-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9acf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 YALMIP 寻找用于数据分类的分离超平面和二次超曲面的快速指南(带图片)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b382bfd8657a8f0f9663ec5efcb82bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Y1u3oN9sTkBnQrJjNLicQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A pretty smart looking elliptic hyperboloid</figcaption></figure><p id="50c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想知道线性分类器是否可以推广到其他形状，而不仅仅是一个看起来无聊的平面(或超平面)？</p><p id="e81b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的。欢迎来到二次分类器的世界，其中两个或更多类别的数据点由二次曲面分隔开！</p><p id="fb42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在我们进入所有这些之前，让我们看看什么是线性分类器，以及我们如何用 MATLAB 和 Johan Lö fberg 开发的优化包<a class="ae lr" href="https://yalmip.github.io" rel="noopener ugc nofollow" target="_blank"> YALMIP </a>对它们建模。然后，在本文的后半部分，我将讨论二次分类器以及如何对它们建模。</p><p id="d0df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls">*这篇文章的某些部分可能看起来有点过于数学化，但我会尽可能保持简单，以便在编程部分花更多的时间。</em></p><h1 id="17ec" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们都从数据开始</h1><p id="f9ae" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们从一些随机数据点开始，每个数据点在欧几里得空间中有 3 个维度。这些点来自 2 个不同的类(X &amp; Y)，我们每个类有 5 个点。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8b79" class="mv lu iq mr b gy mw mx l my mz">% Define some key problem parameters<br/>nDimension = 3;<br/>nVariable = 5;</span><span id="02a7" class="mv lu iq mr b gy na mx l my mz">% Generate some random numbers<br/>X = randn(nDimension, nVariable);<br/>Y = randn(nDimension, nVariable);</span></pre><p id="c8ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls">*你总是可以将问题一般化到更高的维度、更多的类和更多的数据点，但在本文中我们将保持这些值较小，以保持事情简单和易于可视化。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5370a57dae35543a580c8d5555edd8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jj8F0-X5NNUVESUXfaoKwg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Random data points that we have just generated in 3D-space</figcaption></figure><p id="95b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，想法是找到一个分类器，使用来自给定数据点的信息，将整个空间(在这种情况下是 3D 欧几里得空间)分成两个，其中位于一侧的所有点属于类别 X，而位于另一侧的点属于第二类别 y。</p><p id="af22" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们如何选择一个边界来分隔整个空间呢？快速直观的方法是使用平面。</p><h1 id="da34" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">分离超平面</h1><p id="0503" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">超平面指的是一个子空间，它的维数比它所在的空间的维数小一。换句话说，一个超平面在一个<em class="ls"> n </em>维空间中将有<em class="ls"> n-1 </em>维。</p><p id="332c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在 2D 空间中，超平面将是 1D 线，而在 3D 空间中，超平面将仅仅是 2D 平面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/25bd1007fcca6092a411ff7dcaeb6637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwrX8viaCLljRAAxiSAp8Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Visualisations of what a hyperplane is (Image: DeepAI)</figcaption></figure><p id="9064" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到我们的问题，我们想要构建一个超平面来将整个空间一分为二。特别地，我们希望超平面(仅由向量<em class="ls"> a </em>和标量<em class="ls"> b </em>定义)满足以下等式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/0511e73ca51ea53a1114c7fe61db49ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nv__ChFcsjPQrcpDGZMmA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Equations that define a separating hyperplane</figcaption></figure><p id="06c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<em class="ls"> a </em>和<em class="ls"> b </em>，分别是一个矢量和一个标量。</p><p id="1d11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，这假设数据点的坐标之间存在某种线性关系。</p><p id="7aff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，正如我们的本能现在可能已经告诉我们的那样，并不总是可能找到一个超平面，它会以这样一种方式完美地分隔整个空间，即只有属于 X 的点位于一侧，而属于 Y 的点位于另一侧。</p><p id="49de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，即使这是真的情况，我们仍然希望找到最好的超平面，在某种程度上将空间一分为二，即使这意味着有一些点在错误的一边结束。</p><p id="baf6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们需要在方程中引入一些误差变量(每个数据点一个)，以便在定义超平面时留有余地:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/192d7137c5a4c2f3466d41654cea39ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9U4SpEFIpFFHMsXG_qvJw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Equations for a less than perfect hyperplane</figcaption></figure><p id="c97f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似于<em class="ls"> a </em>和<em class="ls"> b </em>，这些误差变量由我们决定，用最优化的说法就是我们所说的决策变量。</p><p id="e4b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们的问题以这种方式定义，<em class="ls">最佳</em>超平面可以说是最好地减少这些误差总和的超平面。因此，我们问题的目标可以简洁地改写为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/191a060a80d7c3b6030ddd017d232862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw6_KEzPArffsYxA79V7Ow.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A linear programme that when solved, provides a separating hyperplane</figcaption></figure><p id="0e1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你们中的一些人现在已经注意到的，我们上面定义的问题被称为线性规划，因为它的目标函数(最小化函数)和约束条件(所有其他方程/不等式)都是线性的。</p><h2 id="d19d" class="mv lu iq bd lv nf ng dn lz nh ni dp md le nj nk mf li nl nm mh lm nn no mj np bi translated">用 MATLAB 实现线性规划</h2><p id="9f61" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">回到我们离开 MATLAB 的地方，我们想使用 YALMIP 来求解我们已经定义的线性规划，以便获得一个分离超平面。</p><p id="cff6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从定义线性规划中的决策变量开始。这需要为它们中的每一个创建一个<em class="ls"> sdpvar </em>对象，然后 YALMIP 会将其识别为决策变量:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5e61" class="mv lu iq mr b gy mw mx l my mz">% Hyperplane variables<br/>a = sdpvar(nDimension, 1, 'full');<br/>b = sdpvar(1);</span><span id="ac5e" class="mv lu iq mr b gy na mx l my mz">% Error variables for points in X and in Y<br/>xError = sdpvar(1, nVariable);<br/>yError = sdpvar(1, nVariable);</span></pre><p id="81d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们继续定义问题中的约束:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2352" class="mv lu iq mr b gy mw mx l my mz">% Error variables should be above 0<br/>constraints = [xError &gt;= 0, yError &gt;=0];</span><span id="7c89" class="mv lu iq mr b gy na mx l my mz">% Hyperplane constraints<br/>constraints = [constraints, a'*X+b &lt;= -(1-xError), a'*Y+b &gt;= 1-yError];</span></pre><p id="5032" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要指定我们的目标函数:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bd74" class="mv lu iq mr b gy mw mx l my mz">% Minimise error values for all points in X and in Y<br/>objective = sum(xError) + sum(yError);</span></pre><p id="b3f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义了我们的问题，剩下的就是解决问题了！我们通过调用<em class="ls"> optimize() </em>函数来实现这一点。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8c0e" class="mv lu iq mr b gy mw mx l my mz">% Solve the linear programme<br/>diagnosis = optimize(constraints, objective);</span><span id="ad01" class="mv lu iq mr b gy na mx l my mz">disp(diagnosis.info); % Success/failure report</span></pre><p id="5fdf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">检索决策变量的值和最优目标值是容易的；它们的最佳值存储在创建它们时所在的对象中。</p><p id="9f45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我们需要将它们从<em class="ls">SDP 变量</em>转换为实际值，以访问它们的最佳值:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a9ad" class="mv lu iq mr b gy mw mx l my mz">a = value(a);<br/>disp('a =');<br/>disp(a);</span><span id="b9a1" class="mv lu iq mr b gy na mx l my mz">b = value(b);<br/>disp('b =');<br/>disp(b);</span><span id="f756" class="mv lu iq mr b gy na mx l my mz">objective = value(objective);<br/>disp('Optimal objective =');<br/>disp(objective);</span></pre><p id="1e77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果确实可以为您生成的随机数据点找到一个完美的超平面，您应该会得到这样的结果，其中最佳目标值正好是 0:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/02c627da48a7612a18103f732757ca3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hh-hXwERhOJ3f8zLWKC6cg.png"/></div></div></figure><p id="6320" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则，高于 0 的目标值将指示所找到的超平面没有将 3D 空间完美地分成仅包含来自每一侧的 X 或 Y 的数据点的两个半空间。</p><h2 id="cbbf" class="mv lu iq bd lv nf ng dn lz nh ni dp md le nj nk mf li nl nm mh lm nn no mj np bi translated">绘制超平面</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3aefcaf904d4c92572d0726040b57bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7xLjc4dLGKpCVDsEnTXMA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Where’s the fun in solving the problem if we don’t get to see anything?</figcaption></figure><p id="bf27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我使用的例子非常简单——只有来自两个不同类的 10 个数据点的三维例子，所以很容易(也是可行的)将我们从求解线性规划中获得的结果绘制到图上。</p><p id="783e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们首先从绘制超平面开始。</p><p id="c0e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回想一下超平面需要满足的两个方程？那么，为了画出<em class="ls">实际的</em>分离超平面，我们只需要画出超平面的一般方程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e0018056f706fc940b5b4e4c0159e1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*PU0-FX62SnD1nMDX9uVzBw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">General equation of a hyperplane</figcaption></figure><p id="7def" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们将生成一些虚拟的<em class="ls">x</em>-坐标和<em class="ls">y</em>-坐标值，然后通过求解上面的等式来计算它们各自的<em class="ls">z</em>-坐标值。在 MATLAB 中，这看起来像这样:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="0dcb" class="mv lu iq mr b gy mw mx l my mz">% Generate x and y dummy data points<br/>[xValuesDummy,yValuesDummy] = meshgrid(-4:0.1:4);</span><span id="25c6" class="mv lu iq mr b gy na mx l my mz">% Solve for z<br/>zValuesDummy = -1/a(3)*(a(1)*xValuesDummy + a(2)*yValuesDummy + b);</span><span id="024f" class="mv lu iq mr b gy na mx l my mz">% Plot the hyperplane<br/>surf(xValuesDummy, yValuesDummy, zValuesDummy, 'FaceAlpha', 0.5, 'FaceColor', 'blue')</span><span id="d589" class="mv lu iq mr b gy na mx l my mz">% Holds the figure before displaying<br/>hold on;</span></pre><p id="98bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们需要沿着每个轴检索每个数据点的坐标值，并将它们存储在相应的数组中。我们还想选择不同的颜色来绘制这两个类的数据点。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f27a" class="mv lu iq mr b gy mw mx l my mz">% Retrieve values of each data point along each axis<br/>xValues = [X(1,:) Y(1,:)];<br/>yValues = [X(2,:) Y(2,:)];<br/>zValues = [X(3,:) Y(3,:)];</span><span id="7e90" class="mv lu iq mr b gy na mx l my mz">% Create different colours for points from different classes<br/>Colour = repmat([1,10],nVariable,1);<br/>colour = Colour(:);</span><span id="e005" class="mv lu iq mr b gy na mx l my mz">% Plot the data points<br/>scatter3(xValues.', yValues.', zValues.', 100, colour,'filled');</span></pre><p id="c83f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成后，您应该能够制作出如下漂亮的 3D 图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/08d64da2abece54b68db87087ff95cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flLGsvevLzZ09QPPhnFsfA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A perfect separating hyperplane</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cc9e987bedb12b4cf57c4587a353a3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNSsW1PQH6HsCOn-r6kpxQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A hyperplane that fails to separate the data points into 2 separate half-spaces</figcaption></figure><p id="f060" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果您不想使用超平面将空间分成两半，尤其是当您的数据似乎不是线性分布时，该怎么办？</p><p id="cb96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，我们可以尝试找到我们的数据点之间的非线性关系，其中一种方法是考虑将它们分开的二次函数！</p><h1 id="6b1c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">分离二次曲面</h1><p id="2cdb" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">什么是二次曲面？简单地说，它们是 2D 圆锥曲线(椭圆、双曲线和抛物线)的一般化形式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/ab2c5b6bd9d4fc345490a3e3cb3b9630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9wI0v440alWoXhAFZM5mg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">I hope you find these more cool-looking than hyperplanes (Image: Saeid Pashazadeh<strong class="bd nt"> &amp; </strong>Mohsen Sharifi)</figcaption></figure><p id="9dbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您可能已经想到的，这些形状在某些情况下可能更适合某些数据，所以让我们来试试吧！</p><p id="e394" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似于我们如何提出定义分离超平面的方程，我们需要寻找满足这些二次方程的对称矩阵<em class="ls"> A </em>，向量<em class="ls"> b </em>和标量<em class="ls"> c </em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/ec7c8f1fdc0ac17382d99b2e3b19308e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oi9QP_kjjjlG3oR2S-7Hcg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Equations that define a separating quadric surface</figcaption></figure><p id="cdff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，我们需要包含误差变量，以使我们的模型能够拟合无法通过二次曲面分离的数据集:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/d5a4c59614842ef063a27f8c0190e861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1GeW1YPiEZgMG8Sw8Lh_A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Equations for a not-so-perfect separating quadric surface</figcaption></figure><p id="a1b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这些方程，我们现在可以定义我们的新问题，就像在超平面的情况下一样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/2dd0990ee6117ee1925669b48980947b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kr72IGJ_upXkux85L2ahfA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Problem to solve to find a quadric surface</figcaption></figure><h2 id="0d5c" class="mv lu iq bd lv nf ng dn lz nh ni dp md le nj nk mf li nl nm mh lm nn no mj np bi translated">用 MATLAB 求解</h2><p id="5988" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">现在，我们的决策变量不再像我们在超平面问题中使用的那些变量，让我们看看我们应该如何定义它们，以便可以使用 YALMIP 解决它们:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b450" class="mv lu iq mr b gy mw mx l my mz">% Quadric surface variables<br/>A = sdpvar(nDimension, nDimension, 'symmetric');<br/>b = sdpvar(nDimension, 1);<br/>c = sdpvar(1);</span><span id="0458" class="mv lu iq mr b gy na mx l my mz">% Error variables for points in X and in Y<br/>xError = sdpvar(1, nVariable);<br/>yError = sdpvar(1, nVariable);</span></pre><p id="da63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们必须定义问题中的约束:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="26d2" class="mv lu iq mr b gy mw mx l my mz">% Error variables should be above 0<br/>constraints = [xError &gt;= 0, yError &gt;=0];</span><span id="82ee" class="mv lu iq mr b gy na mx l my mz">% Quadric surface constraints<br/>constraints = [constraints, diag(X'*A*X)'+b'*X+c&lt;= -(1-xError), diag(Y'*A*Y)'+b'*Y+c &gt;= 1-yError]; % We are only concerned with the diagonal entries of the nVariable x nVariable matrix</span></pre><p id="a46f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们指定问题的目标函数:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fd98" class="mv lu iq mr b gy mw mx l my mz">% Minimise average error values for all points in X and in Y<br/>objective = sum(xError) + sum(yError);</span></pre><p id="891b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，是时候使用我们在超平面问题中使用的同一个函数<em class="ls"> optimize() </em>来解决问题了:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8ef6" class="mv lu iq mr b gy mw mx l my mz">diagnosis = optimize(constraints, objective);</span><span id="99d6" class="mv lu iq mr b gy na mx l my mz">disp(diagnosis.info); % Success/failure report</span></pre><p id="1a5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在成功完成算法后，我们检索最优决策变量和最优目标值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/c6b86cd963b5a694f9e21690a8d9043d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeWMyiW3abGKIkJkEYkL5g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A perfect separating quadric surface is found!</figcaption></figure><h2 id="f0d1" class="mv lu iq bd lv nf ng dn lz nh ni dp md le nj nk mf li nl nm mh lm nn no mj np bi translated">绘制二次曲面</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76617d09790f2ce6ed6dabdb3421e5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aDEWghxsT7Tb1ht41NqpA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A hyperboloid that separates the two data classes</figcaption></figure><p id="bacb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与我们在上一节中绘制超平面的方式不同，我们需要采用一种稍微不同的方法来绘制二次曲面。</p><p id="7cde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们首先在整个绘图区域生成虚拟的 x、y 和 z 值，当使用函数<em class="ls"> isosurface() </em>时，这些值将用于求解一般的二次曲面方程。<em class="ls"> lhs </em>表示将用作函数第 4 个参数的等式左侧，而 0 表示用作第 5 个参数的等式右侧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/5b09cf150732a208358f4894c265d74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpAv6imTTYCD01uMXk2YPw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">General equation of a quadric surface</figcaption></figure><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="337a" class="mv lu iq mr b gy mw mx l my mz">% Generate x, y and z dummy data points<br/>[xValuesDummy,yValuesDummy,zValuesDummy]= meshgrid(-5:0.05:5); </span><span id="987f" class="mv lu iq mr b gy na mx l my mz">q1 = A(1,1)*xValuesDummy+A(2,1)*yValuesDummy+A(3,1)*zValuesDummy;<br/>q2 = A(1,2)*xValuesDummy+A(2,2)*yValuesDummy+A(3,2)*zValuesDummy;<br/>q3 = A(1,3)*xValuesDummy+A(2,3)*yValuesDummy+A(3,3)*zValuesDummy;</span><span id="3afe" class="mv lu iq mr b gy na mx l my mz">lhs = q1.*xValuesDummy+q2.*yValuesDummy+q3.*zValuesDummy+b(1)*xValuesDummy+b(2)*yValuesDummy+b(3)*zValuesDummy + c; </span><span id="21e6" class="mv lu iq mr b gy na mx l my mz">isosurface(xValuesDummy,yValuesDummy,zValuesDummy,lhs,0);</span><span id="7314" class="mv lu iq mr b gy na mx l my mz">hold on;</span></pre><p id="22aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后但同样重要的是，我们将绘制两个类中发现的单个数据点:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9f75" class="mv lu iq mr b gy mw mx l my mz">% Plot data points<br/>xValues = [X(1,:) Y(1,:)];<br/>yValues = [X(2,:) Y(2,:)];<br/>zValues = [X(3,:) Y(3,:)];</span><span id="c741" class="mv lu iq mr b gy na mx l my mz">Colour = repmat([1,10],nVariable,1);<br/>colour = Colour(:);</span><span id="0c95" class="mv lu iq mr b gy na mx l my mz">scatter3(xValues', yValues', zValues', 25, colour,'filled');</span></pre><p id="fd33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">瞧，你完成了！这将允许您生成各种二次曲面，将您的数据点分隔在醒目的图中，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e573209b2305524243969cfdc9b182eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm3UUobP0oY4VYhoVaVFdw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">2-sheet hyperboloid</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/29e81ac256c7dad87085cc0fc678073f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tL4dltaNHUpM9p2MUDd4cw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Hyperbolic paraboloid (or saddle)</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1bcc56a390e7ebfd72e348ba8549866a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mw_i3RtWwkvOxkJdkgMP3A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Hyperbolic cylinder</figcaption></figure><p id="23d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，如果生成的任何二次曲面未能完美分离所有数据点，也不必过于惊慌。就像在超平面的情况下，不可能总是找到适合每个可能的数据集的完美解决方案。</p><h1 id="d5bd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="eaa7" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我刚刚向您展示了如何使用 MATLAB 和 YALMIP 不仅可以找到而且可以绘制分离超平面和二次曲面以进行数据分类。</p><p id="129b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，重要的是要记住，我给出的例子非常简单，当然可以推广到更高维度和更大数量。尽管这些问题仍然很容易解决，但是如果数据大于三维，就很难用同样的方式显示所有的数据。</p><p id="e9f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你已经对各种功能和情节玩得很开心了，非常感谢你阅读我的文章，如果你设法一直做到这里的话！</p></div></div>    
</body>
</html>