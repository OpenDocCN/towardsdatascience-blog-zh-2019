<html>
<head>
<title>Solving Minimum Path Cover on a DAG</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解 DAG 上的最小路径覆盖</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-minimum-path-cover-on-a-dag-21b16ca11ac0?source=collection_archive---------13-----------------------#2019-11-25">https://towardsdatascience.com/solving-minimum-path-cover-on-a-dag-21b16ca11ac0?source=collection_archive---------13-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bfea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们讨论了一个算法来寻找一个 DAG 上的最小路径覆盖。</h2></div><h1 id="5f23" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="dca6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个故事中，我们将首先定义图上的最小路径覆盖问题(MPC ),然后将一个虚构的场景建模为 MPC。接下来，我们将分析我们的模型的结构，并将 MPC 简化为某些特殊情况下的最大匹配问题。我们将用解决方案来结束这个故事。</p><p id="8bdb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">图的 MPC 是具有最小基数的顶点不相交路径的集合，使得这些路径的并集包含图中的所有节点。换句话说，在 MPC 中，我们希望用最少数量的不共享任何顶点的路径覆盖所有节点。这种划分不一定是唯一的。MPC 的应用范围很广，从软件测试到调度[1]。</p><h1 id="d35d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">一个示例场景</h1><p id="1662" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们定义一个假设的场景如下。假设你受雇于一家管理某城市地铁线路的公司。地铁总共有 4 个站，每个站都可以互相到达。市议会已经决定了车站之间应该进行的运输以及发车时间。因此，你剩下的就是决定你应该购买多少辆火车来实现所有的运输。当然，你想最小化这个数字来最大化公司的利润。</p><p id="34b6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">市议会向你提供了交通时刻表，以及从一个车站到另一个车站需要多少小时。这些表格如下:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/240c8a69191198202f5d7c00a1234a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3UZIU3FUy2k6_3Gmpk8SQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Hours to take to reach from one station to another (left) and time table of desired transports (right).</figcaption></figure><p id="f85d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在让我们考虑一个解决方案。最坏的情况下，我们可以为每次运输分配一辆列车，购买 7 辆列车。但是，我们可以从表中观察到，一些运输可以由同一列车依次实现，如 T2 和 T1。如果我们最大化这种运输的数量，那么我们可以最小化购买的数量。因此，我们找到了目标函数最大化！</p><p id="7212" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在最好的情况下，每次运输由同一列火车进行，一列火车就足够了。然而，我们可以看到，这是不可能的，因为有运输冲突的时间表，如 T2 和 T3。因此，我们定义了必须满足的约束。现在我们可以把这个问题表述为:</p><blockquote class="mr"><p id="2313" class="ms mt it bd mu mv mw mx my mz na lv dk translated">我们如何在完成所有运输的同时，最大化同一列车完成的运输总数？</p></blockquote><p id="b97d" class="pw-post-body-paragraph la lb it lc b ld nb ju lf lg nc jx li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">为了对我们的约束进行建模，让我们为运输构建一个<em class="ng">可行性</em>图。在这个图中，我们用一个节点来模拟每一次运输，并画出一条从一次运输到另一次运输的有向边，当且仅当这两次运输可以由同一列火车顺序进行。例如，从 T1 到 T5 将存在有向边，因为火车可以在 6:00 从 S1 出发并在 8:00 到达 S2。然后 13:00 到达 S3，16:00 执行 T3。另一方面，T2 和 T3 不相邻，因为火车不能同时从 S2 和 S3 出发。生成的图表如下:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nh"><img src="../Images/8ff87aef4a8fa1937554815cddc4a8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFhYMixFK2W3DwR5XYfGZQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Feasibility graph of given constraints.</figcaption></figure><p id="f10e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这个图中，一条路径对应于一系列可以由同一列火车依次进行的运输。因此，如果我们找到覆盖所有节点所需的最小路径数，我们就找到了执行所有运输所需的最小列车数。</p><blockquote class="mr"><p id="febc" class="ms mt it bd mu mv mw mx my mz na lv dk translated">因此，我们的目标是在构建的可行性图上找到一个 MPC。</p></blockquote><h1 id="bb93" class="ki kj it bd kk kl km kn ko kp kq kr ks jz ni ka ku kc nj kd kw kf nk kg ky kz bi translated">解决方案</h1><p id="c54e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于一般的图，寻找一个 MPC 收敛于寻找一个哈密尔顿路径，不幸的是，这使得 MPC 成为一个 NP 难问题。幸运的是，对于有向无环图(Dag ),我们可以通过简化为二部最大匹配在多项式时间内解决 MPC，这可以在多项式时间内解决。</p><p id="5e32" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在让我们检查一下我们的可行性图是否能包含任何圈。我们说过，一条路径对应于同一列车可以进行的一系列运输。对于一个周期的发生，我们应该至少有一对运输<em class="ng"> Tᵢ </em>、<em class="ng"> Tⱼ </em>，这样<em class="ng"> Tⱼ </em>可以在之后<strong class="lc iu">进行<em class="ng"> Tᵢ </em>和<em class="ng"> Tᵢ </em>可以在</strong>之后<em class="ng"> Tⱼ </em>进行<strong class="lc iu">。但是，如果<em class="ng"> Tⱼ </em>可以在</strong>tᵢ<em class="ng">之后<strong class="lc iu">进行，则意味着<em class="ng"> Tᵢ </em>在</strong>tⱼ</em>之后<em class="ng">开始<strong class="lc iu">。因此，<em class="ng"> Tⱼ </em>无法在</strong> <em class="ng"> Tᵢ </em>之后<strong class="lc iu">进行，除非我们能时光倒流！</strong></em></p><blockquote class="mr"><p id="a18a" class="ms mt it bd mu mv mw mx my mz na lv dk translated">因此，由于时间限制，我们的可行性图是一个 DAG，我们可以在多项式时间内解决我们的问题。</p></blockquote><p id="8896" class="pw-post-body-paragraph la lb it lc b ld nb ju lf lg nc jx li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">为了解决这个问题，我们将构造一个辅助图<em class="ng"> G </em>，并在<em class="ng"> G </em>上找到一个最大匹配。为了构造<em class="ng"> G </em>，我们将把原始图的每个节点一分为二。其中一个节点将保留原始节点的输出边，另一个节点将保留输入边。例如，考虑可行性图中的节点<em class="ng"> t </em>。<em class="ng"> t </em>将被一分为二为<em class="ng"> t₁ </em>和<em class="ng"> t₂ </em>，我们将从<em class="ng"> t₁ </em>到<em class="ng"> t </em>的邻居绘制一条边，而我们将从<em class="ng"> t </em>到<em class="ng"> t₂ </em>的邻居节点绘制边。注意这样的图总是二分的。对于我们的可行性图，G 可以绘制如下。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nl"><img src="../Images/8d82f5cf1bc7cbed6e8df0900cd1956c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VNgmHJjOUvF-JwdfENEkw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Auxillary graph constructed from the feasibility graph.</figcaption></figure><p id="e08c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">寻找最大匹配意味着最小化不匹配节点的数量。如果右边部分的节点在<em class="ng"> G </em>的最大匹配中不匹配，则在列车执行的序列中，在相应的运输之前，不应执行任何运输。这意味着我们需要这样一个节点一列火车。因此，最小化这样的节点相当于最小化所需的列车数量，在<em class="ng"> G </em>上找到最大匹配就解决了我们的问题！</p><p id="8400" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">下面我们可以看到 G 的最大匹配，匹配中的边和节点用粗线表示，其余的边用虚线表示。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nm"><img src="../Images/72e7eba46814ffa6520999aa5d070c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wokKvrk_fYjQtV4_jCesw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">A maximum matching of G</figcaption></figure><p id="9043" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">注意，我们保证不存在完全匹配，因为在右边部分总是至少有一个节点没有输入边。该节点对应于最早的运输，因为最早的运输不能在任何其它运输之后进行。因此，总有至少一个不匹配的节点，我们至少需要一列火车。</p><p id="896c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有了最大匹配，我们可以通过从左到右追踪匹配来构建路径。这些路径对应于应由同一列车执行的运输，以最小化所需列车的数量。对于上图，我们可以追踪路径为{{ <em class="ng"> T1，T4，T5 </em> }，{ <em class="ng"> T2，T6 </em> }，{ <em class="ng"> T3，T7 </em> }。因此，我们需要至少 3 列火车来完成所有的运输，并在多项式时间内解决我们的问题！</p><h2 id="29e6" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">参考</h2><p id="6ae9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">[1]<a class="ae nz" href="https://www.wikiwand.com/en/Path_cover" rel="noopener ugc nofollow" target="_blank">https://www.wikiwand.com/en/Path_cover</a></p><blockquote class="oa ob oc"><p id="d435" class="la lb ng lc b ld lw ju lf lg lx jx li od ly ll lm oe lz lp lq of ma lt lu lv im bi translated">我感谢<a class="ae nz" href="http://www.ie.boun.edu.tr/~tinaz/" rel="noopener ugc nofollow" target="_blank">tnaz Ekim</a>在 MPC 上的演讲，让我首先听到了这个问题。</p></blockquote></div></div>    
</body>
</html>