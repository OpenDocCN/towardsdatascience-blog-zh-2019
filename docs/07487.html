<html>
<head>
<title>MapReduce in C from Scratch Using Threads: Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用线程在 C 中从头开始使用 MapReduce:Map</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mapreduce-in-c-from-scratch-using-threads-map-c6b1b01f020c?source=collection_archive---------17-----------------------#2019-10-19">https://towardsdatascience.com/mapreduce-in-c-from-scratch-using-threads-map-c6b1b01f020c?source=collection_archive---------17-----------------------#2019-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/23eb1d5e29c08a0931c6a0a04ed2db22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*LUwfTibMtoVwtKHl.jpg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Source: <a class="ae jy" href="https://pixabay.com/photos/knowledge-book-library-glasses-1052011/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="3960" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">Hadoop 的 MapReduce 不仅仅是一个框架，还是一种解决问题的哲学。</p><p id="3645" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">借鉴函数式编程，MapReduce 团队意识到很多不同的问题可以分成两种常见的操作:<strong class="kb ir"> map </strong>，和<strong class="kb ir"> reduce </strong>。</p><p id="2eb0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">映射</strong>和<strong class="kb ir">缩减</strong>步骤都可以并行<strong class="kb ir">完成</strong>。</p><p id="4c11" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这意味着只要你能以那种特定的方式<strong class="kb ir">框定你的问题</strong>，就会有一个解决方案，它可以很容易地并行运行。这通常会大大提升<strong class="kb ir">性能</strong>。</p><p id="a4e9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这听起来不错，并行运行通常是一件好事，尤其是在大规模工作时。但是，坐在后面的一些人可能会想，什么是<strong class="kb ir">地图</strong>和<strong class="kb ir">减少</strong>？</p><h1 id="405b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是 MapReduce？</h1><p id="48f3" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了理解 MapReduce 框架，我们需要了解它的两个基本操作:<strong class="kb ir"> Map </strong>和<strong class="kb ir"> Reduce </strong>。</p><p id="0467" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">它们都是高阶函数:也就是说，它们是可以把其他函数作为自变量的函数。</p><p id="ea1e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">具体来说，当您需要将 A 类型的某个元素序列转换为 B 类型的一个结果或一系列结果时，您将:</p><ul class=""><li id="1b7a" class="ma mb iq kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">将你所有的输入映射到不同的域:这意味着你将用一个选择的函数来转换它们，并应用到每个元素。</li><li id="eaba" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">根据某种标准对映射的元素进行分组，通常是一个分组关键字。</li><li id="dd3b" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated"><strong class="kb ir">用其他函数减少每个组上的映射元素。这个函数需要两个参数并返回一个相同类型的参数，连续运行一个<strong class="kb ir">累加器</strong>和集合中每个值之间的运算。它应该是<strong class="kb ir">交换和关联</strong>，因为并行执行<strong class="kb ir">不会保证操作的任何顺序</strong>。</strong></li></ul><p id="fe97" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了更清楚地说明这一点，让我们看一个例子。</p><h1 id="03f0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">MapReduce 解决方案示例</h1><p id="95d0" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">假设你在一家电子商务公司工作，他们给你一个如下形式的日志文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3cb3" class="mx ky iq mt b gy my mz l na nb">John Surname bought 2 apples <br/>Alice Challice bought 3 bananas <br/>John Surname bought 5 pineapples</span></pre><p id="6041" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然后他们让你告诉他们每个顾客买了多少水果。</p><p id="b8ba" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这种情况下，在解析该文件并将其转换为实际格式(如 CSV)后，您可以轻松地遍历每一行，并在字典上的每个名称下添加购买的水果的数量。</p><p id="8b49" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你甚至可以用一点<a class="ae jy" href="http://www.datastuff.tech/programming/files-strings-shell-tutorial/" rel="noopener ugc nofollow" target="_blank"> Bash 脚本</a>来解决它，或者将 CSV 加载到<a class="ae jy" href="http://www.datastuff.tech/data-science/exploratory-data-analysis-with-pandas-and-jupyter-notebooks/" rel="noopener ugc nofollow" target="_blank">熊猫数据帧</a>上并获得一些统计数据。</p><p id="bb74" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然而，如果日志文件有一万亿行长，bash 脚本并不能真正减少它。尤其是如果你不是永生的。</p><p id="5773" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您需要并行运行这个。让我提出一个 MapReduce-y 的方法:</p><ul class=""><li id="d473" class="ma mb iq kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated"><strong class="kb ir">通过解析每个字符串，将</strong>每一行映射成一对形式为&lt;的名称、数量&gt;。</li><li id="3306" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">按名称分组。</li><li id="5863" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated"><strong class="kb ir">通过对数量求和来减少</strong>。</li></ul><p id="970c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果您熟悉 SQL 和关系数据库，您可能会想到类似的解决方案。该查询类似于</p><p id="b301" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe nc nd ne mt b">select user, sum(bought_fruits) </code> <br/> <code class="fe nc nd ne mt b">from fruit_transactions group by user;</code></p><h1 id="ed3f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么 MapReduce 缩放</h1><p id="1b08" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">注意<strong class="kb ir">映射器不需要看到整个文件</strong>，只需要看到一些行。另一方面，<strong class="kb ir">减速器</strong>，<strong class="kb ir">只需要具有相同名称</strong>的线(属于同一组的线)。</p><p id="18ce" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你可以在同一台计算机上用许多不同的线程来做这件事，然后把结果连接起来。</p><p id="69e6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">或者，您可以让许多不同的进程运行地图作业，并将它们的输出提供给另一个运行归约作业的集合。</p><p id="0624" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果日志足够大，您甚至可以在许多不同的计算机上运行 Mapper 和 Reducer 进程(比如说，在一个集群上)，然后最终在某个湖中加入它们的结果。</p><p id="6129" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这种解决方案在 ETL 作业和其他数据密集型应用程序中非常常见，但我不会深入研究应用程序。</p><p id="2c01" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你想了解更多关于这种可扩展解决方案的知识，我建议你去看看这本关于大规模设计应用的 O'Reilly 书籍。</p><h1 id="c844" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用 C 语言编程 MapReduce</h1><p id="391e" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">现在你已经了解了什么是 MapReduce，以及为什么 MapReduce 会扩展，让我们开门见山吧。</p><p id="cebd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">对于这第一篇文章，我们将编写两个不同的实现<em class="nf"> Map </em>函数的程序。</p><p id="823b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">其中一个将是<strong class="kb ir">单线程</strong>，介绍几个概念并展示一个<strong class="kb ir">简单的解决方案</strong>。另一个将使用<em class="nf"> pthread </em>库来制作一个真正的<strong class="kb ir">多线程</strong>，和<strong class="kb ir">快得多的</strong>版本的<em class="nf"> Map </em>。最后，我们将对二者进行比较，并运行一些基准测试。</p><p id="2313" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">像往常一样，所有的代码都可以在<a class="ae jy" href="https://github.com/StrikingLoo/mapReduCe" rel="noopener ugc nofollow" target="_blank">这个 C GitHub 项目</a>上获得。</p><h1 id="b0ea" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Map 在 C 中的单线程实现</h1><p id="5b79" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">首先，我们先记住<em class="nf">地图</em>是做什么的。</p><blockquote class="ng nh ni"><p id="61e7" class="jz ka nf kb b kc kd ke kf kg kh ki kj nj kl km kn nk kp kq kr nl kt ku kv kw ij bi translated"><em class="iq">Map 函数接收一个</em> <strong class="kb ir"> <em class="iq">序列</em> </strong> <em class="iq">和一个</em> <strong class="kb ir"> <em class="iq">函数</em> </strong> <em class="iq">，并返回</em> <strong class="kb ir"> <em class="iq">将该函数应用于序列中每个元素</em> </strong> <em class="iq">的结果。</em></p></blockquote><p id="b67f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">因为这是 C 语言，表示一个序列可以非常直接:我们可以使用一个指针指向我们映射的任何类型！</p><p id="c229" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然而，有一个问题。C 是静态类型的，我们希望我们的 Map 函数尽可能的通用。我们希望它能够映射任何类型的元素序列(假设它们都共享一个类型)。我们不要在这里失去理智，孩子们。</p><p id="a25f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们如何解决这个问题？这个问题可能有几种不同的解决方案。我选择了看起来最简单的一个，但也可以随意加入其他想法。</p><p id="940e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们将使用<code class="fe nc nd ne mt b">void*</code>的序列，并将所有东西都转换成这种类型。这意味着每个元素都将被表示为一个指向随机内存地址的指针，而无需指定类型(或大小)。</p><p id="9eb8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们将相信我们在所有这些序列元素上调用的任何函数都知道如何在使用它们之前将它们转换为正确的类型。我们有效地将那个问题委托出去了。</p><p id="1752" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们需要解决的一个小问题是序列长度。指向 void 的指针不携带序列有多少元素的信息。它只知道从哪里开始，不知道从哪里结束。</p><p id="1d2e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们将通过传递序列长度作为第二个参数来解决这个问题。知道了这一点，我们的<em class="nf"> Map </em>函数变得非常简单。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7091" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您可以看到，该函数接收一个<code class="fe nc nd ne mt b">void**</code>来表示它将映射的序列，以及一个<code class="fe nc nd ne mt b">void* (*f)(void*)</code>函数，该函数将某种泛型类型的元素转换为另一种(或相同的)元素。</p><p id="e91f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">之后，我们可以在任何序列上使用我们的<em class="nf">映射</em>函数。我们只需要事先做一些笨拙的包装和指针运算。</p><p id="4b5c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这里有一个例子，使用一个函数，对于质数返回 1，对于其他的返回 0。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="91cf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">正如所料，结果指针指向一个整数序列:1 对应于质数，0 对应于合数。</p><p id="441f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在我们已经完成了单线程<em class="nf"> Map </em>函数，让我们看看如何在 c 语言中并行运行这个函数。</p><h1 id="292c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">C 语言中的多线程映射函数</h1><p id="0058" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated"><em class="nf">(如果您想使用流程和分叉添加一个基准，请随时提出拉取请求！)</em></p><p id="daec" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了在 C 语言中使用并行执行，我们可以求助于进程或线程。</p><p id="8c14" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">对于这个项目，我们将使用线程，因为它们更轻量级，在我看来，它们的 API 对于这类教程来说更直观一些。</p><h1 id="abd8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何在 C 语言中使用线程</h1><p id="6958" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">C 中的 threads API 非常直观，即使一开始有点晦涩。</p><ul class=""><li id="a0b5" class="ma mb iq kb b kc kd kg kh kk mc ko md ks me kw mf mg mh mi bi translated">一个指向<code class="fe nc nd ne mt b">pthread_t</code>的指针:实际的线程。</li><li id="5026" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">一个配置<code class="fe nc nd ne mt b">struct</code>。在这种情况下，我们将使用<code class="fe nc nd ne mt b">NULL</code>作为默认配置。</li><li id="aa91" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">我们希望线程运行的函数。与进程不同，线程只会运行一个函数，直到它返回，而不是继续执行任意代码。这个函数必须接受一个<code class="fe nc nd ne mt b">void*</code>参数，并返回另一个<code class="fe nc nd ne mt b">void*</code>值。</li><li id="8732" class="ma mb iq kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated">前述函数的输入。必须投给<code class="fe nc nd ne mt b">void*</code>。</li></ul><p id="489a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">要使用它们，我们必须使用<code class="fe nc nd ne mt b">#include &lt;pthread.h&gt;</code>。手册页很好地解释了他们的界面。然而，对于本教程，我们将使用的是<code class="fe nc nd ne mt b">pthread_create</code>函数。</p><p id="7f29" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe nc nd ne mt b">pthread_create</code>需要四个参数:</p><p id="cae8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在调用<code class="fe nc nd ne mt b">pthread_create</code>之后，一个并行执行线程将开始运行给定的函数。</p><p id="d30a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一旦我们为我们希望映射的每个块调用了<code class="fe nc nd ne mt b">pthread_create</code>，我们将不得不对它们中的每一个调用<code class="fe nc nd ne mt b">pthread_join</code>，这使得父(原始)线程<strong class="kb ir">等待</strong>直到它旋转的所有线程<strong class="kb ir">完成运行</strong>。</p><p id="e9a1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">否则，程序会在映射完成之前结束。</p><p id="ff0d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在，让我们尽情欣赏一些代码。</p><h1 id="b935" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在 C 语言中使用 pthread 实现并行 MapReduce</h1><p id="4a28" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了用 C 语言编写 MapReduce 的<em class="nf"> Map </em>函数，我们要做的第一件事是定义一个<code class="fe nc nd ne mt b">struct</code>来存储它的通用输入和输出，以及我们将要映射的函数。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c1e7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">由于并行执行需要某种方式的切片和<strong class="kb ir">分区</strong>，我们也将把那个逻辑存储在这个结构中，使用两个不同的<strong class="kb ir">索引</strong>作为我们切片的开始和结束。</p><p id="55de" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">接下来，我们将编写实际执行映射的函数:它将从<code class="fe nc nd ne mt b">start</code>到<code class="fe nc nd ne mt b">end</code>循环输入，将映射函数应用于每个输入的结果存储在输出指针中。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2bc9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">最后，节目的主角，启动线程的函数，给每个线程分配一个<code class="fe nc nd ne mt b">map_argument</code>,等待所有的地图作业运行，最后返回结果。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7b05" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">注意这个函数如何允许我们选择我们想要多少线程，并相应地对数据进行分区。它还处理<em class="nf"> pthreads </em>的创建和加入。</p><p id="d968" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">最后，我们在 main 中调用该函数的方式如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="35b1" class="mx ky iq mt b gy my mz l na nb">concurrent_map( (void**) numbers, twice, N, NTHREADS)</span></pre><p id="9c08" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">其中<code class="fe nc nd ne mt b">NTHREADS</code>是我们想要的线程数，<code class="fe nc nd ne mt b">N</code>是<code class="fe nc nd ne mt b">numbers</code>拥有的元素数。</p><p id="64f1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在代码完成了，让我们运行一些基准测试！这真的会更快吗？所有这些包装代码会使事情变得更慢吗？让我们来了解一下！</p><h1 id="481d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">C 语言中的映射，基准:单线程与多线程</h1><p id="b870" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了衡量使用并行<em class="nf"> Map </em>带来的性能提升，我测试了一些单线程算法与多线程算法的对比。</p><h2 id="eee9" class="mx ky iq bd kz no np dn ld nq nr dp lh kk ns nt ll ko nu nv lp ks nw nx lt ny bi translated">第一个基准:slow_twice</h2><p id="cf29" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">对于我的第一个测试，我使用了<em class="nf"> slow_twice </em>函数，它只是将每个数字乘以 2。</p><p id="062c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你可能会奇怪，“为什么叫慢？”。答案很简单:我们将每个数字翻倍 1000 次。</p><p id="efff" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这使得操作更慢，所以我们可以测量时差，而不必使用太多的数字，初始化需要太长时间。它还让我们对许多内存写入的情况进行基准测试。</p><p id="8d4c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">因为每个数字的执行时间是恒定的，所以非并行算法的时间随着输入大小几乎成线性增长。</p><p id="ff77" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然后我用 2、4 和 8 个线程运行它。我的笔记本电脑有 4 个内核，我发现这也是使用线程的最佳数量。对于其他一些算法，我发现使用我的核心数量的倍数是最佳的，但事实并非如此。</p><h2 id="c988" class="mx ky iq bd kz no np dn ld nq nr dp lh kk ns nt ll ko nu nv lp ks nw nx lt ny bi translated">基准测试结果</h2><p id="8fcf" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">我将每个基准测试运行 10 次，取平均值，以防万一。</p><p id="9939" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">结果如下:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/139611d3a8c15ea7169e0535e5f44ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*57R9MFiE3cFnGBikwtWVDg.png"/></div></figure><p id="ac0c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">对于这两个测试案例，使用<strong class="kb ir"> 4 个线程</strong>比单线程实现大约快<strong class="kb ir">三倍</strong>。这证明了使用并行<em class="nf"> Map </em>比使用普通单线程版本要快得多。</p><p id="e535" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">添加 4 个以上的线程也是有代价的，可能是由于初始化和上下文切换的开销。</p><h2 id="2d52" class="mx ky iq bd kz no np dn ld nq nr dp lh kk ns nt ll ko nu nv lp ks nw nx lt ny bi translated">第二个基准:is_prime</h2><p id="eba2" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">对于这个基准测试，我编写了一个朴素的质数测试函数:它简单地遍历所有小于输入的数，如果任何数被整除，则返回 1，否则返回 0。</p><p id="c723" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">注意，这个函数对每个元素取 O(n ),而不是 O(1 ),所以数据的一些分区(有序的)会比其他的慢很多。我想知道这会如何影响运行时间？</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/694a5f244579309497bb0d2ca5028173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*qAPJ7Zm8P5L8u-2JtZLmjg.png"/></div></figure><p id="4edd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这种情况下，并行算法再次击败了单线程算法。没有什么大的意外。然而，这一次当使用超过 4 个线程时有了一个<strong class="kb ir">改进</strong>！</p><p id="bffe" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我认为这是因为在对我们的输入进行分区时，将它分成更小的块会使最慢的分区花费更少的时间，从而使我们的瓶颈变小。</p><h1 id="9cc7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="168d" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">我从这个实验中获得了很多乐趣。</p><p id="d78e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">挑选<strong class="kb ir">多少线程使用</strong>比仅仅“使用相同数量的内核”要困难得多，而且<strong class="kb ir">很大程度上依赖于我们的输入</strong>，即使是非常愚蠢的算法。</p><p id="c772" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这可能有助于我们理解为什么优化集群的配置对于一个大型应用程序来说是一项如此艰巨的任务。</p><p id="9695" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">将来，我可能会添加一个并行的<em class="nf"> reduce </em>实现来完成这个小框架。</p><p id="0335" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">其他一些可能会很有趣并且我可能会在未来运行的基准测试是 C 语言中的<em class="nf">Map</em>vs<a class="ae jy" href="http://www.datastuff.tech/programming/pythons-list-comprehensions-uses-and-advantages/" rel="noopener ugc nofollow" target="_blank">Python 列表理解</a>，以及 C 语言 vs SIMD 汇编。</p><p id="1ef9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="nf">如果你想提升数据科学家的水平，可以看看我的</em> <a class="ae jy" href="http://www.datastuff.tech/data-science/3-machine-learning-books-that-helped-me-level-up-as-a-data-scientist/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">最佳机器学习书籍</em> </a> <em class="nf">清单和我的</em> <a class="ae jy" href="http://www.datastuff.tech/programming/terminal-tutorial-more-productive/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">迎头痛击教程</em> </a> <em class="nf">。</em></p><p id="5b1e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">记住，你可以以任何你喜欢的方式使用这段代码，或者运行你自己的实验，如果你这样做了，请不要忘记在评论中让我知道你的结果！</p><p id="86de" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你想对我说什么或问什么，请随时在<a class="ae jy" href="http://www.twitter.com/strikingloo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae jy" href="http://www.medium.com/@strikingloo" rel="noopener"> Medium </a>或<a class="ae jy" href="http://www.dev.to/strikingloo" rel="noopener ugc nofollow" target="_blank"> dev.to </a>上联系我！</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="141d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="nf">原载于 2019 年 10 月 19 日</em><a class="ae jy" href="http://www.datastuff.tech/programming/how-to-code-mapreduce-in-c-from-scratch-using-threads-pt-1-map/" rel="noopener ugc nofollow" target="_blank"><em class="nf">http://www . data stuff . tech</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>