<html>
<head>
<title>Surprising Sorting Tips for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的惊人排序技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/surprising-sorting-tips-for-data-scientists-9c360776d7e?source=collection_archive---------10-----------------------#2019-07-15">https://towardsdatascience.com/surprising-sorting-tips-for-data-scientists-9c360776d7e?source=collection_archive---------10-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="63ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python、NumPy、pandas、PyTorch 和 TensorFlow 中的排序函数</h2></div><p id="e9a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对数据进行排序是数据科学家和数据工程师的基本任务。Python 用户有许多带有内置优化排序选项的库可供选择。有些甚至在 GPU 上并行工作。令人惊讶的是，一些排序方法并不使用指定的算法类型，而另一些排序方法并不像预期的那样执行。</p><p id="07fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择使用哪个库和哪种类型的排序算法可能很棘手。实现变化很快。截至本文最初撰写时，pandas 文档甚至没有更新代码(尽管我的 PR 更新排序选项刚刚被接受)。😄</p><p id="05dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将向您介绍情况，提供帮助您记住方法的技巧，并分享速度测试的结果。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/348ce696a8249b7f2e155bc2e5a473fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdXDTn55ZZQmpRbnMbSFuQ.jpeg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Sorted Tea</figcaption></figure><p id="6583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始分类吧！</p><p id="e4eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2019 年 7 月 17 日更新:速度测试评测结果现在包括 PyTorch 和 TensorFlow 的 GPU 实现。TensorFlow 还包括<code class="fe lu lv lw lx b">tensorflow==2.0.0-beta1</code>和<code class="fe lu lv lw lx b">tensorflow-gpu==2.0.0-beta1</code>下的 CPU 结果。令人惊讶的发现:PyTorch GPU 快如闪电，TensorFlow GPU 比 TensorFlow CPU 慢。我怀疑 GPU 版本中存在性能错误。2021 年 9 月进一步更新，以提高清晰度。</p><h1 id="5801" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">语境</h1><p id="7533" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">有许多不同的基本排序算法。有些执行速度更快，使用的内存更少。有些更适合大数据，有些如果数据以某种方式排列会更好。很多常用算法的时间和空间复杂度见下图。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><a href="http://bigocheatsheet.com/"><div class="gh gi mv"><img src="../Images/834c486245da28f7560863a1565362f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niPobJI4MOr5hHp1yOqqiQ.png"/></div></a><figcaption class="lq lr gj gh gi ls lt bd b be z dk">From <a class="ae mw" href="http://bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">http://bigocheatsheet.com/</a></figcaption></figure><p id="bfac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于大多数数据科学问题来说，成为基本实现方面的专家并不是必要的。事实上，过早的优化偶尔会被认为是万恶之源。然而，当您需要重复排序大量数据时，知道使用哪个库和哪个关键字参数会很有帮助。这是我的小抄。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mx"><img src="../Images/11adf54d2cfcf6224e3ebe91a75f48ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysMx0QeOi1RPOEajija3Ug.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">My Google Sheet available here: <a class="ae mw" href="https://docs.google.com/spreadsheets/d/1zQbDvpmrvTYVnRz_2OTlfB6knLlotdbAoFH6Oy48uSc/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://docs.google.com/spreadsheets/d/1zQbDvpmrvTYVnRz_2OTlfB6knLlotdbAoFH6Oy48uSc/edit?usp=sharing</a></figcaption></figure><p id="3569" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多年来，许多图书馆的排序算法都发生了变化。本文的分析中使用了以下软件版本:</p><pre class="lf lg lh li gt my lx mz na aw nb bi"><span id="f07c" class="nc lz it lx b gy nd ne l nf ng">python 3.6.8<br/>numpy 1.16.4<br/>pandas 0.24.2<br/>tensorflow==2.0.0-beta1  #tensorflow-gpu==2.0.0-beta1 slows sorting<br/>pytorch 1.1</span></pre><p id="18a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从基础开始。</p><h1 id="9f14" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Python(香草)</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/5a535ecc882d319dc5a4f156a5b281c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*H1olKNHMeAiPbDoDf95MYw.png"/></div></figure><p id="6e2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 包含两种内置的排序方法。</p><ul class=""><li id="7fc3" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><code class="fe lu lv lw lx b">my_list.<a class="ae mw" href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="noopener ugc nofollow" target="_blank">sort()</a></code>就地排序列表。它改变了列表。<code class="fe lu lv lw lx b">sort()</code>返回<code class="fe lu lv lw lx b">None</code>。</li><li id="98dd" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae mw" href="https://docs.python.org/3/library/functions.html#sorted" rel="noopener ugc nofollow" target="_blank">sorted(my_list)</a></code>对任何 iterable 进行排序复制。<code class="fe lu lv lw lx b">sorted()</code>返回排序后的 iterable。<code class="fe lu lv lw lx b">sort()</code>不变异原来的 iterable。</li></ul><p id="c161" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">sort()</code>应该快一点，因为到位了。令人惊讶的是，我在下面的测试中并没有发现这一点。就地排序更危险，因为它会改变原始数据。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nw"><img src="../Images/e21a95e84c8448d0ba175825ed2e6e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vc7JacKNVeW1jCeZxEXH-w.jpeg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Vanilla</figcaption></figure><p id="fcb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于普通 Python，我们将在本文中研究的所有实现，默认的排序顺序是升序——从最小到最大。大多数排序方法接受一个关键字参数来将排序顺序切换到降序。不幸的是，每个库的参数名称都不同。😦</p><p id="09cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在 vanilla Python 中将排序顺序改为降序，传递<code class="fe lu lv lw lx b">reverse=True</code>。</p><p id="2d45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">key</code>可以作为关键字参数来创建你自己的排序标准。例如，<code class="fe lu lv lw lx b">sort(key=len)</code>会按每个列表项的长度排序。</p><p id="4dee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">vanilla Python 中使用的唯一排序算法是 Timsort。Timsort 根据要排序的数据的特征选择排序方法。例如，如果要对一个短列表进行排序，则使用插入排序。点击查看<a class="nx ny ep" href="https://medium.com/u/2480a7e35749?source=post_page-----9c360776d7e--------------------------------" rel="noopener" target="_blank"> Brandon Skerritt </a>的精彩文章，了解更多关于 Timsort <a class="ae mw" href="https://skerritt.blog/timsort-the-fastest-sorting-algorithm-youve-never-heard-of/" rel="noopener ugc nofollow" target="_blank">的详细信息。</a></p><p id="dd44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Timsort，也就是普通的 Python 排序，<a class="ae mw" href="https://docs.python.org/3/howto/sorting.html?highlight=sort" rel="noopener ugc nofollow" target="_blank">是稳定的</a>。这意味着，如果多个值相同，那么这些项目在排序后将保持原来的顺序。</p><p id="8201" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了记住<code class="fe lu lv lw lx b">sort()</code> vs. <code class="fe lu lv lw lx b">sorted()</code>，我只记得<em class="nz"> sorted </em>是一个比<em class="nz"> sort </em>更长的单词，sorted 应该需要更长的时间来运行，因为它必须进行复制。尽管下面的结果不支持传统观点，但助记法仍然有效。😃</p><p id="fe3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看如何使用 NumPy。</p><h1 id="4db3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">NumPy</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b7ae13ca117ba1785396dcabc2f7a30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*rkzjM21lmcx3sPOTqbJ0oA.png"/></div></figure><p id="ea24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy 是科学计算的基础 Python 库。像普通 Python 一样，它有两个 sort 实现，一个改变数组，另一个复制数组。</p><ul class=""><li id="54dc" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae mw" href="https://docs.scipy.org/doc/numpy-1.16.0/reference/generated/numpy.ndarray.sort.html#numpy.ndarray.sort" rel="noopener ugc nofollow" target="_blank">my_array.sort()</a></code>就地改变数组并返回排序后的数组。</li><li id="36ff" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae mw" href="https://docs.scipy.org/doc/numpy-1.16.0/reference/generated/numpy.sort.html#numpy.sort" rel="noopener ugc nofollow" target="_blank">np.sort(my_array)</a></code>返回排序后的数组的副本，因此它不会改变原始数组。</li></ul><p id="2a9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是可选参数。</p><ul class=""><li id="ce89" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">axis</strong><em class="nz"> </em></code> <em class="nz"> : int，可选— </em>排序的轴。默认值为-1，表示沿最后一个轴排序。</li><li id="42a7" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">kind</strong></code> <em class="nz"> : {' </em> <strong class="kk iu"> <em class="nz">快速排序</em> </strong> <em class="nz">'，'</em> <strong class="kk iu"> <em class="nz">归并排序</em> </strong> <em class="nz">'，'</em> <strong class="kk iu"> <em class="nz">堆排序</em> </strong> <em class="nz">'，'</em> <strong class="kk iu"> <em class="nz">稳定排序</em> </strong> <em class="nz"> '}，可选— </em>排序算法。默认为'<strong class="kk iu">快速排序</strong>'。以下是更多相关信息。</li><li id="8546" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">order</strong></code> <em class="nz"> : str 或 str 列表，可选— </em>当<em class="nz"> a </em>是定义了字段的数组时，该参数指定首先比较哪些字段，其次比较哪些字段，等等。可以将单个字段指定为一个字符串，并且不需要指定所有字段，但是仍将使用未指定的字段(按照它们在 dtype 中出现的顺序)来中断连接。</li></ul><p id="eb78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在使用的排序算法与您根据它们的名称所预期的有所不同。通过<code class="fe lu lv lw lx b">kind=quicksort</code>意味着排序实际上从一个<a class="ae mw" href="https://en.wikipedia.org/wiki/Introsort" rel="noopener ugc nofollow" target="_blank"> introsort </a>算法开始。<a class="ae mw" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.sort.html" rel="noopener ugc nofollow" target="_blank">文档</a>解释:</p><blockquote class="ob oc od"><p id="df82" class="ki kj nz kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">当[它]没有取得足够的进展时，它切换到堆排序算法。在最坏的情况下，这种实现使得<strong class="kk iu">快速排序</strong> O(n*log(n))。</p><p id="673f" class="ki kj nz kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><strong class="kk iu">稳定</strong> <em class="it"> </em>自动为被排序的数据类型选择最佳的稳定排序算法。它与<strong class="kk iu"> mergesort </strong>一起当前被映射到 timsort 或 radix sort，这取决于数据类型。API 向前兼容性目前限制了选择实现的能力，并且它是为不同的数据类型硬连线的。</p><p id="9311" class="ki kj nz kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">添加 Timsort 是为了在已经排序或接近排序的数据上获得更好的性能。对于随机数据，timsort 几乎与 mergesort 相同。它现在用于<strong class="kk iu">稳定</strong>排序，而<strong class="kk iu">快速排序</strong>仍然是默认排序，如果没有选择…’<strong class="kk iu">合并排序</strong>和’<strong class="kk iu">稳定</strong>映射到整数数据类型的基数排序。</p></blockquote><p id="61ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">——来自<a class="ae mw" href="https://github.com/numpy/numpy/blob/v1.16.1/numpy/core/fromnumeric.py#L815-L935" rel="noopener ugc nofollow" target="_blank"> NumPy 文档</a>——(经过我的一些编辑)。</p><p id="fc9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个要点是，NumPy 为排序算法选项提供了比普通 Python 更广泛的控制。第二点是<em class="nz">种类</em>关键字值不一定对应于实际使用的排序类型。最后一点是<code class="fe lu lv lw lx b">mergesort</code>和<code class="fe lu lv lw lx b">stable</code>值是稳定的，但是<code class="fe lu lv lw lx b">quicksort</code>和<code class="fe lu lv lw lx b">heapsort</code>不是。</p><p id="dd65" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy 排序是我们列表中唯一没有使用关键字参数来反转排序顺序的实现。幸运的是，用这样的切片反转一个数组很快:<code class="fe lu lv lw lx b">my_arr[::-1]</code>。</p><p id="2c13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy 算法选项也可以在更加用户友好的熊猫中使用——我发现这些函数更容易保持直线。</p><h1 id="8187" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">熊猫</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c431f575db7f477ccdd3646063f42f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*UIJ2FGS-px4aFywabG7qvg.jpeg"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Panda</figcaption></figure><p id="6536" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe lu lv lw lx b"><a class="ae mw" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html" rel="noopener ugc nofollow" target="_blank">df.sort_values(by=my_column)</a></code>对熊猫数据帧进行排序。有许多关键字参数可用。</p><ul class=""><li id="8b29" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">by</strong></code> : <em class="nz"> str </em>或<em class="nz">str 列表</em>，必选——排序依据的名称或名称列表。如果轴是<em class="nz"> 0 </em>或<em class="nz">索引</em>，那么<em class="nz">乘</em>可能包含索引级别和/或列标签。如果轴是<em class="nz"> 1 </em>或<em class="nz">列</em>，那么<em class="nz">到</em>可能包含列级别和/或索引标签</li><li id="90b5" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">axis</strong></code> : { <em class="nz"> 0 </em>或<em class="nz">索引</em>，<em class="nz"> 1 </em>或<em class="nz">列</em> }，默认为<em class="nz"> 0 </em> —待排序的轴。</li><li id="c2ab" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">ascending</strong></code> : <em class="nz">布尔型</em>或布尔型的<em class="nz">列表，默认<em class="nz">真</em> —升序或降序排序。为多个分类订单指定<em class="nz">列表</em>。如果这是一个<em class="nz">列表</em>的<em class="nz">布尔值</em>，则必须通过</em>自变量匹配<em class="nz">的长度。</em></li><li id="90ed" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">inplace</strong></code> : <em class="nz"> bool </em>，默认<em class="nz">False</em>——如果<em class="nz"> True </em>，执行就地操作。</li><li id="b2f3" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">kind</strong></code> : { <em class="nz"> quicksort，mergesort，heapsort，</em>或<em class="nz"> stable </em> }，默认<em class="nz"> quicksort — </em>选择排序算法。更多信息参见<code class="fe lu lv lw lx b">ndarray.np.sort</code>。对于数据帧，此选项仅在对单个列或标签进行排序时适用。</li><li id="9463" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">na_position</strong></code> : {'first '，' last'}，默认为' last' — <em class="nz"> first </em>将<em class="nz"> NaNs </em>放在开头，<em class="nz"> last </em>将<em class="nz"> NaN </em> s 放在末尾。</li></ul><p id="c724" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照相同的语法对熊猫系列进行排序。对于一个系列，你不需要提供一个<code class="fe lu lv lw lx b">by</code>关键字，因为你没有多个列。</p><p id="280c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为 pandas 使用了 NumPy，所以您可以轻松地使用同样的优化排序选项。然而，熊猫需要一些额外的时间来提供便利。</p><p id="49c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按单列排序时默认使用 NumPy 的<code class="fe lu lv lw lx b">quicksort</code> <em class="nz">。</em>你会想起<em class="nz"> </em> <code class="fe lu lv lw lx b">quicksort</code>现在实际上是一个 introsort，如果排序进展缓慢，它会变成一个 heapsort。Pandas 确保通过多列排序使用 NumPy 的<code class="fe lu lv lw lx b">mergesort</code>。NumPy 中的 Mergesort 实际上使用的是 Timsort 或者 Radix 排序算法。这些是稳定的排序算法，当按多列排序时，稳定排序是必要的。</p><p id="0366" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">熊猫要记住的关键事情是:</p><ul class=""><li id="39b9" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated">功能名称:<code class="fe lu lv lw lx b">sort_values()</code>。</li><li id="c701" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">您需要<code class="fe lu lv lw lx b">by=column_name</code>或一个列名列表。</li><li id="b547" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b">ascending</code>是反转的关键词。</li><li id="6664" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">如果你想要一个稳定的排序，使用<code class="fe lu lv lw lx b">mergesort</code>。</li></ul><p id="bdac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用 pandas 进行探索性数据分析时，我经常发现自己用<code class="fe lu lv lw lx b">Series.value_counts()</code>对 pandas 数据帧中的值进行求和和排序。下面是对每一列中最常见的值进行求和和排序的代码片段。</p><pre class="lf lg lh li gt my lx mz na aw nb bi"><span id="1cf8" class="nc lz it lx b gy nd ne l nf ng">for c in df.columns:<br/>    print(f"---- {c} ---")<br/>    print(df[c].value_counts().head())</span></pre><p id="1f1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">pandas 中的排序是对较小数据集进行探索性数据分析的一个很好的选择。当你的数据放不进内存时，Dask 实现了大部分的 pandas API。截至 2019 年年中，Dask 没有并行排序实现，尽管正在讨论<a class="ae mw" href="https://github.com/dask/dask/issues/4368" rel="noopener ugc nofollow" target="_blank"/>。当您拥有大量数据并希望在 GPU 上进行并行搜索时，您可能希望使用 TensorFlow 或 PyTorch。</p><h1 id="b124" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">张量流</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oi"><img src="../Images/e224162da1a39fc4448ea5dd2154768b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmMOdVZ_j9vwMcpdD8Uceg.png"/></div></div></figure><p id="328d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae mw" href="https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/sort" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>是目前最流行的深度学习框架。看我这篇关于深度学习框架普及和使用的文章<a class="ae mw" rel="noopener" target="_blank" href="/which-deep-learning-framework-is-growing-fastest-3f77f14aa318?source=friends_link&amp;sk=0a10207f22f4dbc143e7a90a3f843515">这里</a>。以下信息适用于 TensorFlow 2.0 的 GPU 版本。</p><p id="2417" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">tf.sort(my_tensor)</code>返回张量的排序副本。可选参数:</p><ul class=""><li id="c027" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">axis</strong></code> : {int，optional}排序的轴。默认值为-1，对最后一个轴进行排序。</li><li id="ef81" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">direction</strong></code> : { <em class="nz">升序</em>或<em class="nz">降序</em> } —对值进行排序的方向。</li><li id="b3a2" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">name</strong></code> : {str，可选} —操作的名称。</li></ul><p id="f1eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">tf.sort</code>在幕后使用<code class="fe lu lv lw lx b"> top_k()</code>方法。<code class="fe lu lv lw lx b">top_k</code>使用<a class="ae mw" href="https://nvlabs.github.io/cub/" rel="noopener ugc nofollow" target="_blank"> CUB 库</a>用于 CUDA GPUs，使并行更容易实现。正如文档解释的那样，“CUB 为 CUDA 编程模型的每一层提供了最先进的、可重用的软件组件。”TensorFlow 通过 CUB 在 GPU 上使用基数排序，这里<a class="ae mw" href="https://github.com/tensorflow/tensorflow/issues/288" rel="noopener ugc nofollow" target="_blank">讨论</a>。</p><p id="7e2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TensorFlow GPU 信息可以在这里找到<a class="ae mw" href="https://www.tensorflow.org/install/gpu" rel="noopener ugc nofollow" target="_blank">。要使用 TensorFlow 2.0 启用 GPU 功能，您需要<code class="fe lu lv lw lx b">pip3 install tensorflow-gpu==2.0.0-beta1</code>。正如我们将从下面的评估中看到的，如果你所做的只是排序(这不太可能)，你可能想坚持使用<code class="fe lu lv lw lx b">tensorflow==2.0.0-beta1</code>。</a></p><p id="7046" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用以下代码片段查看每行代码是在 CPU 上运行还是在 GPU 上运行:</p><p id="2266" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">tf.debugging.set_log_device_placement(True)</code></p><p id="b0be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要指定您想要使用的 GPU，请使用下面的<em class="nz">和</em>块:</p><pre class="lf lg lh li gt my lx mz na aw nb bi"><span id="907f" class="nc lz it lx b gy nd ne l nf ng">with tf.device('/GPU:0'):<br/>  %time tf.sort(my_tf_tensor)</span></pre><p id="09d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe lu lv lw lx b">with tf.device('/CPU:0'):</code>来使用 CPU。</p><p id="0b51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">tf.sort()</code>是一个非常直观的方法，如果您在 TensorFlow 中工作，可以记住并使用它。记住<code class="fe lu lv lw lx b">direction=descending</code>切换排序顺序即可。</p><p id="5ac8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看另一个流行的深度学习包 PyTorch 中的排序。</p><h1 id="d649" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">PyTorch</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7ede3c57472170b5e99faf060a291db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*8u5YFObocx7AviTbZYo8-g.png"/></div></figure><p id="6c7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lx b">torch.sort(my_tensor)</code>返回张量的排序副本。可选参数:</p><ul class=""><li id="3abf" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">dim</strong></code> : {int，optional <em class="nz"> } </em> —排序所依据的维度</li><li id="8393" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">descending</strong></code> : {bool，可选<em class="nz"> } </em> —控制排序顺序(升序或降序)。</li><li id="e48c" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><code class="fe lu lv lw lx b"><strong class="kk iu">out</strong></code> : {tuple，optional<em class="nz">}</em>—( Tensor，LongTensor)的输出元组，可以选择用作输出缓冲区。</li></ul><p id="cc0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将<code class="fe lu lv lw lx b">.cuda()</code>添加到张量来指定您想要使用的 GPU。</p><pre class="lf lg lh li gt my lx mz na aw nb bi"><span id="47c0" class="nc lz it lx b gy nd ne l nf ng">gpu_tensor=my_pytorch_tensor.cuda()<br/>%time torch.sort(gpu_tensor)</span></pre><p id="a6c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果数据集大于 100 万行乘以 100，000 列，PyTorch 将通过<a class="ae mw" href="https://thrust.github.io/" rel="noopener ugc nofollow" target="_blank">推力</a>使用分段并行排序。</p><p id="c441" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae mw" href="https://github.com/thrust/thrust/wiki/Quick-Start-Guide" rel="noopener ugc nofollow" target="_blank"> Thrust </a>是一个并行算法库，支持 GPU 和多核 CPU 之间的性能移植。它提供了一个排序原语，可以自动选择最有效的实现。TensorFlow 使用的 CUB 库包装推力。因此，如果你深入研究，你会发现 PyTorch 和 TensorFlow 正在使用类似的实现来进行 GPU 排序——无论 thrust 为这种情况选择了什么。</p><p id="fdcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，Google Colab 服务器在试图通过 NumPy 创建 1.1M x 100K 的随机数据点时耗尽了内存。😦所以我搬到了有 416 MB 内存的谷歌云平台(GCP ),但仍然内存不足。😦 😦所以我不得不保持在一百万行以下。</p><blockquote class="ob oc od"><p id="01b6" class="ki kj nz kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">分段排序和局部排序是 mergesort 的高性能变体，它们对非均匀随机数据进行操作。分段排序允许我们并行排序许多变长数组。—<a class="ae mw" href="https://moderngpu.github.io/segsort.html" rel="noopener ugc nofollow" target="_blank">https://moderngpu.github.io/segsort.html</a></p></blockquote><p id="865a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像 TensorFlow 一样，PyTorch 中的排序方法并不太粗糙，不容易记住:<code class="fe lu lv lw lx b">torch.sort()</code>。唯一棘手的是排序值方向的关键字参数:TensorFlow 使用<code class="fe lu lv lw lx b">direction</code>，而 PyTorch 使用<code class="fe lu lv lw lx b">descending</code>。不要忘记使用<code class="fe lu lv lw lx b">.cuda()</code>来提高大型数据集的速度。😉</p><p id="b6a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然使用 GPU 进行排序对于非常大的数据集来说是一个很好的选择，但是直接在 SQL 中对数据进行排序也是有意义的。在本文的最后，我有一个关于使用 SQL 的简短的附加部分。👍</p><h1 id="2817" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">比较</h1><p id="ee7c" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">对于上面的每个 Python 库，我进行了一次 wall time 分析，以便在一个列、数组或列表中对相同的 1，000，000 个数据点进行排序。我使用了一台<a class="ae mw" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a> Jupyter 笔记本电脑，配备 K80 GPU 和英特尔(R)至强(R) CPU @ 2.30GHz。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ok"><img src="../Images/3712271e1175aae9866bcd7bd3de4f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oAzzPmtk4-lxWzNqDlE11w.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Source code: <a class="ae mw" href="https://colab.research.google.com/drive/1NNarscUZHUnQ5v-FjbfJmB5D3kyyq9Av" rel="noopener ugc nofollow" target="_blank">https://colab.research.google.com/drive/1NNarscUZHUnQ5v-FjbfJmB5D3kyyq9Av</a></figcaption></figure><h2 id="46d1" class="nc lz it bd ma ol om dn me on oo dp mi kr op oq mk kv or os mm kz ot ou mo ov bi translated">观察</h2><ul class=""><li id="6ba3" class="ni nj it kk b kl mq ko mr kr ow kv ox kz oy ld nn no np nq bi translated">PyTorch 配 GPU 超快。</li><li id="b234" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">对于 NumPy 和 pandas 来说，inplace 通常比复制数据更快。</li><li id="7dac" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">默认的熊猫快速排序相当快。</li><li id="1bbf" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">大多数熊猫的功能相对来说比它们的 NumPy 同类要慢。</li><li id="540b" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">TensorFlow CPU 相当快。即使使用 CPU，GPU 安装也会降低 TensorFlow 的速度。GPU 排序相当慢。这看起来像是一个可能的错误。🐞</li><li id="0e26" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">Vanilla Python 就地排序慢得惊人。它比 PyTorch GPU 支持的排序慢了近 100 倍。我对它进行了多次测试(使用不同的数据)，以再次确认这不是一个异常。</li></ul><p id="5f26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这只是一个小测试。这肯定不是决定性的。😉</p><h1 id="533b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">包装</h1><p id="3ef3" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">通常不需要定制排序实现。现成的选项很强大。他们通常不仅仅使用单一的排序方法。相反，他们首先评估数据，然后使用表现良好的排序算法。如果排序进展不快，一些实现甚至会改变算法。</p><p id="16fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，您已经看到了如何在许多 Python 数据科学库中进行排序。我希望它对你有所帮助。如果你有，请分享到你最喜欢的社交媒体上，这样其他人也可以找到它。👏</p><p id="9781" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你只需要记住选择哪个选项，以及如何调用它。使用我上面的小抄来节省时间。👍我的一般建议如下:</p><ul class=""><li id="e088" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated">使用默认的熊猫<code class="fe lu lv lw lx b">sort_values()</code>来探索相对较小的数据集。</li><li id="f649" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">对于大型数据集或者当速度非常重要时，可以尝试 NumPy 的就地合并排序。为了进一步提高速度，在 GPU 上使用 PyTorch。</li></ul><p id="b1c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我没见过太多关于 GPU 排序的文章。这是一个需要更多研究和指导的领域。这里有一篇 2017 年的文章，让你领略一下最近的<a class="ae mw" href="https://dl.acm.org/citation.cfm?id=3079105" rel="noopener ugc nofollow" target="_blank">研究</a>。更多关于 GPU 排序算法的信息可以在<a class="ae mw" href="https://devtalk.nvidia.com/default/topic/951795/fastest-sorting-algorithm-on-gpu-currently/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="6366" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">奖励:SQL</h1><p id="a9d2" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">SQL 中的排序通常非常快，尤其是当排序在内存中时。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oz"><img src="../Images/db4eef942e3b8f02191d4c2fed2897d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*tCcPfdWHFyacdflarVXy5w.png"/></div></div></figure><p id="70c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQL 是一种规范，但并没有规定实现必须使用哪种排序算法。根据具体情况，Postgres 使用磁盘合并排序、堆排序或快速排序。如果你有足够的内存，在内存中排序会变得更快。通过<code class="fe lu lv lw lx b"><a class="ae mw" href="https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server" rel="noopener ugc nofollow" target="_blank">work_mem</a></code> <a class="ae mw" href="https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server" rel="noopener ugc nofollow" target="_blank">设置</a>增加分拣可用内存。</p><p id="cbc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他 SQL 实现使用不同的排序算法。比如 Google BigQuery 用 introsort 配合一些小技巧，根据<a class="ae mw" href="https://stackoverflow.com/a/53026600/4590385" rel="noopener ugc nofollow" target="_blank">这个栈溢出回答</a>。</p><p id="ae43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQL 中的排序是用<code class="fe lu lv lw lx b">ORDER BY</code>命令执行的。这种语法不同于 Python 实现，Python 实现都使用某种形式的单词<em class="nz"> sort。</em>至少按顺序是独一无二的！😃</p><p id="7f53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要进行降序排序，请使用关键字 DESC。按照从后到前的字母顺序返回客户的查询如下所示:</p><pre class="lf lg lh li gt my lx mz na aw nb bi"><span id="4975" class="nc lz it lx b gy nd ne l nf ng">SELECT Names FROM Customers<br/>ORDER BY Names DESC;</span></pre><h1 id="8050" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">就是这样！</h1><p id="abd3" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我写关于 Python、Docker、数据科学等等的文章。如果你对此感兴趣，请在这里阅读更多<a class="ae mw" href="https://medium.com/@jeffhale" rel="noopener">和关注我的媒体。😄</a></p><figure class="lf lg lh li gt lj gh gi paragraph-image"><a href="http://eepurl.com/gjfLAz"><div class="ab gu cl pa"><img src="../Images/ba32af1aa267917812a85c401d1f7d29.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oPkqiu1rrt-hC_lDMK-jQg.png"/></div></a></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nw"><img src="../Images/6bf5e460c504a83197301ec3c5f36489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxu8qdJQw3DoLr2ibHBVRg.jpeg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Tea time!</figcaption></figure><p id="c96c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分类愉快！😀</p></div></div>    
</body>
</html>