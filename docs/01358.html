<html>
<head>
<title>Fundamentals of Machine Learning (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习基础(三)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fundamentals-of-machine-learning-part-3-b305933f00cd?source=collection_archive---------16-----------------------#2019-03-04">https://towardsdatascience.com/fundamentals-of-machine-learning-part-3-b305933f00cd?source=collection_archive---------16-----------------------#2019-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="57c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">信息论</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98f36478b715a7af906f730c2c24d409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ehs-9U2Y7X_6b4Ym8JKBxg.gif"/></div></div></figure><h1 id="a9e8" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="a976" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是我认为机器学习的基础主题系列的第 3 部分。这些主题是加深对该领域理解的基础。到目前为止，我们已经介绍了:</p><ol class=""><li id="dca0" class="mi mj it lo b lp mk ls ml lv mm lz mn md mo mh mp mq mr ms bi translated"><a class="ae mt" rel="noopener" target="_blank" href="/probability-fundamentals-of-machine-learning-part-1-a156b4703e69">概率论</a></li><li id="b431" class="mi mj it lo b lp mu ls mv lv mw lz mx md my mh mp mq mr ms bi translated"><a class="ae mt" rel="noopener" target="_blank" href="/maximum-likelihood-estimation-984af2dcfcac">最大似然估计</a></li></ol><p id="117f" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">这篇文章的目的是涵盖信息论中的重要概念，并描述它们如何用于机器学习。这里的许多主题将建立在我们在概率论的文章中讨论的概念上，比如独立性和期望。</p><p id="9158" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我将利用机器学习和统计学的思想来激发和构建这些概念。如果你有物理学背景，你可能已经看到这些概念的不同动机(即通过热力学)。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="1599" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated">信息</h1><p id="294d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们假设我们的目标是通过使用的单词来检测给定文本的作者，以此来激发我们的讨论。哪些词对检测作者身份有用？直觉上，像“the”、“or”和“it”这样的词不会很有用，因为无论作者是谁，这些词都很有可能出现在任何文本中。看起来普通单词包含的信息比罕见单词少，而且信息内容在某种程度上与概率直接相关。</p><p id="a719" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">让我们通过让 x 是代表所有可能单词的随机变量，<em class="no"> p </em> ( <em class="no"> x </em>)是观察一个特定单词的概率<em class="no"> x </em>来使这个更正式。我们想要为通过观察一个特定的单词所获得的信息创造一些可量化的概念。</p><p id="8885" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我们将使用<em class="no"> h </em> ( <em class="no"> x </em>)来表示从观察单词<em class="no"> x </em>中获得的信息。同样，对于两个单词<em class="no"> x </em>和<em class="no"> y </em>，我们可以将通过观察它们获得的信息写成<em class="no"> h </em> ( <em class="no"> x，y </em>)。我们的目标是找到一个合适的 h。</p><p id="fb5f" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">首先，我们来考虑两个词<em class="no"> x </em>和<em class="no"> y </em>的独立性。像“足球”和“比分”这样的词不是独立的，因为看到一个会使另一个更有可能。所以在“足球”之后看“比分”获得的信息应该不大。回想一下<a class="ae mt" rel="noopener" target="_blank" href="/probability-fundamentals-of-machine-learning-part-1-a156b4703e69">第一部</a>，独立在形式上是指<em class="no"> p </em> ( <em class="no"> x，y</em>)<em class="no">= p</em>(<em class="no">x</em>)<em class="no">p</em>(<em class="no">y</em>)。如果两个词<em class="no"> x </em>和<em class="no"> y </em>不相关，我们要<em class="no"> h </em> ( <em class="no"> x，y</em>)=<em class="no">h</em>(x)+<em class="no">h</em>(<em class="no">y</em>)。换句话说，同时看到两个不相关的单词所获得的信息应该是单独看到它们所获得的信息的总和。</p><p id="e8a0" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我们希望我们的<em class="no"> h </em>公式与<em class="no"> p，</em>相关，但是我们有这样一个问题，即独立观察的联合概率是一个乘积，而联合信息是一个和。为了解决这个问题，我们使用对数的乘积规则将乘积转换为总和:</p><p id="7de1" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">log[ <em class="no"> p </em> ( <em class="no"> x，y</em>)]= log[<em class="no">p</em>(<em class="no">x</em>)<em class="no">p</em>(<em class="no">y</em>)= log<em class="no">p</em>(<em class="no">x</em>)+log<em class="no">p</em>(<em class="no">y</em>)。</p><p id="85d1" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">将信息与概率的对数联系起来似乎是我们需要的技巧。我们把与 x 相关的信息写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a488060d19b2144f917ba42b18507af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*12GpvpvfXHveILz_H10hPA.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Information gained from observing <em class="nu">x.</em></figcaption></figure><p id="44c5" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">这个公式满足我们的要求，即更可能的观察产生更少的信息，对于两个独立的观察<em class="no"> x </em>和<em class="no"> y </em>，我们有<em class="no"> h </em> ( <em class="no"> x，y </em> ) = -log <em class="no"> p </em> ( <em class="no"> x， y</em>)=-log[<em class="no">p</em>(<em class="no">x</em>)<em class="no">p</em>(<em class="no">y</em>)]=[-log<em class="no">p</em>(<em class="no">x</em>)]+[-log<em class="no">p</em>(<em class="no">y</em>)]=<em class="no">h</em>()</p><p id="4527" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">对数的底是一个任意的选择。信息理论家通常使用基数 2，并将信息单位称为“比特”，而在机器学习中，通常使用基数<em class="no"> e </em>并将信息单位称为“NAT”。这个信息量的另一种观点是，给定某种编码<em class="no">，h<em class="no">h</em>(<em class="no">x</em>)给出了发送一条消息<em class="no"> x </em>所需的位数。</em></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="dead" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated">熵</h1><p id="f266" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们刚刚把信息写成了一个随机变量的函数。在<a class="ae mt" rel="noopener" target="_blank" href="/probability-fundamentals-of-machine-learning-part-1-a156b4703e69">第 1 部分</a>中，我们了解到随机变量 x 上的函数<em class="no"> g </em>的期望值，给出了 g 的期望值(或平均值):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b797705ef0d68a5bb84ecc6dd472cf18.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*0lW9RJPFj-qPePT-tChQ0Q.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Expectation of g(x) with respect to x.</figcaption></figure><p id="05d3" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我们的信息函数的期望<em class="no"> h </em>是信息论中最基本的概念之一。这种期望被称为随机变量 x 的熵，通常用大写字母 H 表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5eb7b42dbcfec02c60ecd5f8183ac0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*UcnpHsjumnZEbwhQivCgJw.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Entropy of random variable x.</figcaption></figure><p id="fdc3" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">熵是信息函数的期望值，或者换句话说，它是通过观察从<em class="no"> p </em> ( <em class="no"> x </em>)随机抽取获得的平均信息量。这是一个需要知道的有用值！</p><p id="bb7e" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">信息论者可能会使用熵来计算传输给定长度的消息所需的预期比特数。更好的是，为了降低传输成本，找到使熵最小化的消息编码将是有益的。这将允许发射机压缩消息，并且每条消息发送更少的比特。</p><p id="23a3" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">寻找有效的编码类似于为机器学习问题寻找特征的有效表示。我们希望用尽可能少的特征来表示我们的数据(以避免过度拟合和维数灾难)，同时仍然保持足够的信息来做出准确的决策。</p><p id="7bbe" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我们将会看到，熵的概念对于思考其他几个重要的概念是有用的。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="f07e" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated">交叉熵</h1><p id="8e14" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们回到我们的作者分类问题。让我们通过只考虑两个类来简化问题:{文本来自作者 A，文本不来自作者 A}。我们将把我们试图分类的每个文档视为一个“单词包”，这意味着我们不关心单词的顺序，只关心哪些单词存在。我们将每个文档表示为向量<strong class="lo iu"> x </strong>，其中如果单词<em class="no"> j </em>出现在文档中，则条目<em class="no"> j </em>为 1，否则为 0。</p><p id="ed82" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我们假设存在某种基本事实分布<em class="no"> p </em> ( <strong class="lo iu"> x </strong>)，这给出了文档<strong class="lo iu"> x </strong>是由作者 a 编写的概率。如果我们可以了解这种分布，那么对于任何一个其中<em class="no"> p </em> ( <strong class="lo iu"> x </strong> ) &gt;为 0.5 的文档，我们都可以猜测该文档是由 a 编写的</p><p id="a742" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">但是我们不知道<em class="no"> p </em>，所以我们写下一个模型<em class="no"> q </em>并尝试拟合<em class="no"> q </em>的参数，使其接近<em class="no">p。</em>然后我们将使用<em class="no"> q </em>来决定 A 是否是任何给定文本的作者。</p><p id="35a5" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">由于我们使用的是<em class="no"> q </em>，因此对一个文档<strong class="lo iu"> <em class="no"> x </em> </strong>进行分类所需的信息量为<em class="no">h</em>(<strong class="lo iu"><em class="no">x</em></strong>)=-log<em class="no">q</em>(<strong class="lo iu"><em class="no">x</em></strong>)。但是如果<strong class="lo iu"> x </strong>实际上是由<em class="no"> p </em>分配的，那么对于<strong class="lo iu">xt</strong>所需信息的期望值是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/67ce42030a1affde015c2fe0f1fbf29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*z02AHbDCq8lthX9XGNjq-Q.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Cross Entropy</figcaption></figure><p id="03a8" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">这是<em class="no"> q </em>相对于真实分布<em class="no"> p </em>的交叉熵。如果我们以此为代价函数，找到使交叉熵最小化的<em class="no"> q </em>的参数，那么当<em class="no"> q </em>与<em class="no"> p </em>相同时，将出现最佳解。</p><p id="71be" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">最小化交叉熵通常是逻辑回归和用于分类的神经网络的目标。可以看出，最小化交叉熵相当于最大化我们的模型<em class="no"> q. </em>的似然性。因此，这种解决分类的方法找到了最大似然估计量，如<a class="ae mt" rel="noopener" target="_blank" href="/maximum-likelihood-estimation-984af2dcfcac">第 2 部分</a>中所讨论的。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="ff65" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated">相对熵(KL-散度)</h1><p id="bdd9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">假设我们使用的是<em class="no"> q </em>而不是<em class="no"> p </em>，交叉熵给了我们分类文档所需的平均信息量。显然，如果我们使用<em class="no"> p，</em>，那么平均起来，我们只需要<strong class="lo iu"> H </strong> (x)比特数(真实分布的熵)。但是由于我们使用的是<em class="no"> q </em>，平均需要<strong class="lo iu"> H </strong> ( <em class="no"> p，q </em>)位(交叉熵)。</p><p id="59e8" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">使用<em class="no"> q </em>差多少？用<em class="no"> q </em>代替<em class="no"> p </em>需要<strong class="lo iu"> H </strong> ( <em class="no"> p，q </em> )- <strong class="lo iu"> H </strong> (x)额外的位。我们称这个值为相对熵或 Kullback-Leibler (KL)散度。如果我们代入交叉熵和熵的方程，然后收集各项，我们得到 KL 散度为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8cb9b29f97a6e2e89830a96a1c99f559.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*B4GwxbWoMsGA7_1A7YRD-A.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">KL-Divergence</figcaption></figure><p id="358c" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">同样，这给了我们所需的额外位数(或 NAT ),因为我们使用了<em class="no"> q </em>来代替<em class="no"> p </em>。KL-散度总是大于 0，除非<em class="no"> q </em>等于<em class="no"> p </em>。因此，最小化也是一个常见的目标函数。最小化 KL-散度也最小化交叉熵，我们已经说过交叉熵是最大似然估计量。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="2255" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated">交互信息</h1><p id="403e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们之前讨论过，有些单词并不是相互独立的，当我们同时观察它们时，这种依赖性会导致我们获得多余的信息(例如“足球”和“得分”)。我们想知道两个变量共享多少信息。</p><p id="9b0d" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">回想一下，如果 x <strong class="lo iu"> </strong>和<strong class="lo iu"> </strong> y <strong class="lo iu"> </strong>为自变量，那么它们的联合分布为<em class="no"> p </em> (x，y) = <em class="no"> p </em> (x) <em class="no"> p </em> (y)。如果它们不是独立的，那么我们就不能这样分解联合分布。当变量独立时，我们没有任何冗余，随着变量越来越依赖，冗余信息量增加。为了对此进行量化，我们使用 x 和 y 的互信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9b76a3402fe9d3f633cf28e0b8e223ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*VBA6UH5fuAqX_4V0401ZYg.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Mutual Information.</figcaption></figure><p id="e8ce" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">如果我们用独立因子分解来表示真实的联合分布，那么互信息就是所需的额外信息量。如果变量是独立的，那么 KL 散度将为 0，否则它将随着变量冗余度的增加而增加。</p><p id="789c" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">互信息经常被用于在机器学习中执行特征选择。对于给定的特征，我们可以用类别标签来度量特征的互信息。如果互信息高，则该特征是该类的强指示符。例如，如果作者 A 总是在他们的文档中包含他们的名字，那么他们的名字和类之间的互信息将会非常高。</p><p id="6f60" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">类似地，如果我们有太多的特征需要考虑，我们可以使用特征之间的互信息来删除那些冗余的特征。如果作者 A 总是包括他们的名字和他们的家乡，那么我们可以安全地从我们的词汇中删除他们的家乡，并且仍然可以很好地完成任务。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="ea40" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated">结论</h1><p id="e75c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这篇文章中，我们已经涵盖了信息论中直接适用于机器学习的主要概念。从任何意义上来说，这都不是一个详尽的处理方法，但是这些是我个人在实践中一次又一次看到的概念。</p><p id="2bf1" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">更多阅读，我建议看看克里斯托弗·毕晓普的书<a class="ae mt" href="https://www.microsoft.com/en-us/research/people/cmbishop/#!prml-book" rel="noopener ugc nofollow" target="_blank">模式识别和机器学习</a>。整本书是知识的金矿，但是我讨论的概念都可以在第一章的信息论部分找到。</p><p id="92f9" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">大卫·麦凯的书<a class="ae mt" href="https://www.inference.org.uk/itprnn/book.pdf" rel="noopener ugc nofollow" target="_blank">信息论、推理和学习算法</a>也很受欢迎。</p><p id="27c7" class="pw-post-body-paragraph lm ln it lo b lp mk ju lr ls ml jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">下次见！</p></div></div>    
</body>
</html>