<html>
<head>
<title>Bayes Text Classification in Kotlin for Android without TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Kotlin 的 Android 无张量流贝叶斯文本分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bayes-text-classification-in-kotlin-for-android-without-tensorflow-d10f1247c23d?source=collection_archive---------20-----------------------#2019-05-19">https://towardsdatascience.com/bayes-text-classification-in-kotlin-for-android-without-tensorflow-d10f1247c23d?source=collection_archive---------20-----------------------#2019-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c5f4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">📱<a class="ae ep" href="https://equipintelligence.medium.com/list/stories-on-mobile-ml-with-kotlin-and-tf-lite-3ebee822c87b" rel="noopener">移动机器学习</a></h2><div class=""/><div class=""><h2 id="2d8f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">探索没有 TensorFlow APIs 的纯 Kotlin 中的贝叶斯文本分类。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c0aafc096134fac70a2a3fab6cbe2a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-Bbj5C3_y2zb00W"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luca Bravo</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="04e4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">T <a class="ae le" href="https://monkeylearn.com/text-classification/" rel="noopener ugc nofollow" target="_blank"> ext 分类</a>由于其能力和广泛的用途，已经成为<a class="ae le" href="https://www.sas.com/en_in/insights/analytics/what-is-natural-language-processing-nlp.html" rel="noopener ugc nofollow" target="_blank">自然语言处理</a>中的一项重要任务。我们将学习以非深度学习的方式使用这项技术，而不使用<a class="ae le" href="https://www.tensorflow.org" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>和神经网络。这个分类器将在 Android 应用程序中工作，所以需要用 Kotlin 或 Java 编写。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="e259" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">但是为什么是科特林，为什么不是我们的 TensorFlow 或者 Python？</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mc l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">We aren’t using TensorFlow? Because it’s written in C++, models are constructed in Python and we need to run it in Kotlin!</figcaption></figure><p id="798c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TensorFlow 和<a class="ae le" href="https://www.tensorflow.org/lite" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite </a>可以在 Android 上高效地工作(或者有时是在头脑中吹的方式)。类似的算法可以在任何编程语言中创建，如 C、C++甚至<a class="ae le" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank">Swift</a>(iOS 原生)，如果它可以在 kot Lin(Android 原生)中创建的话。</p><blockquote class="mw"><p id="b97a" class="mx my iq bd mz na nb nc nd ne nf ma dk translated">有时，在平台中本地编码的分类器可以比 TensorFlow 或其 API 执行得更好。此外，我们可以对它的工作和推理有更多的控制流。</p></blockquote><h1 id="7cbe" class="md me iq bd mf mg mh mi mj mk ml mm mn kf ng kg mp ki nh kj mr kl ni km mt mu bi translated">我们要用哪种机器学习算法？我们到底在创造什么？</h1><blockquote class="mw"><p id="e948" class="mx my iq bd mz na nb nc nd ne nf ma dk translated">我们将使用朴素贝叶斯文本分类器对 Kotlin 中的文本进行分类，该分类器最终将在 Android 设备上运行。</p></blockquote><figure class="nj nk nl nm nn kt"><div class="bz fp l di"><div class="mv mc l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Math is coming! Be ready!</figcaption></figure><p id="b463" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">谈论<a class="ae le" href="https://www.geeksforgeeks.org/naive-bayes-classifiers/" rel="noopener ugc nofollow" target="_blank">朴素贝叶斯文本分类</a>，</p><p id="c1c9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">朴素贝叶斯文本分类使用<a class="ae le" href="https://brilliant.org/wiki/bayes-theorem/" rel="noopener ugc nofollow" target="_blank">贝叶斯定理</a>的力量将文档(文本)分类到某一类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1c82677c398a6e1598e5c7ff9fcd939c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*s-XliYQRDFwDvQkd8V8Gbg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Bayes Theorem</figcaption></figure><p id="fd36" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们根据我们对文本分类的需要来建立等式，那么它将变成这样，</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/907edd1a96554ea60cca66be95cdf3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHA2Oanlct67Q8niNg1_Zw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Eq.1</figcaption></figure><blockquote class="nq nr ns"><p id="c9a3" class="lf lg nt lh b li lj ka lk ll lm kd ln nu lp lq lr nv lt lu lv nw lx ly lz ma ij bi translated">在这里，我们将文档表示为 x₂x₁令牌...xₙ和 c 是我们将计算概率的类。分母被省略，在这里可以看到它的<a class="ae le" href="https://stats.stackexchange.com/questions/329382/why-ignore-the-denominator-of-bayes-rule" rel="noopener ugc nofollow" target="_blank">解释</a>(因为在这两种情况下(C₁和 C₂)，P( x₁，x₂...xₙ)将保持不变并将作为归一化常数)</p></blockquote><p id="99c3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将计算两个类别的概率，即<em class="nt">垃圾邮件</em> ( C₁)和<em class="nt">火腿</em> ( C₂)。概率较高的将是我们的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/6c578e5b1f8f7ae6c7caba2e19828fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asu4yEM3x0iAo9-1W4GD8w.png"/></div></div></figure><p id="32aa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于每个类，我们都有一个词汇或一组出现在垃圾邮件或垃圾邮件中的单词，它们将代表我们的类语料库。</p><h1 id="1f9c" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">先说科特林。</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mc l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">If you loved Python earlier!</figcaption></figure><p id="c02b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们将定义我们的语料库<code class="fe ny nz oa ob b">positiveBagOfWords</code>和<code class="fe ny nz oa ob b">negativeBagOfWords</code>，它们分别包含垃圾邮件和火腿词。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b6fc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们创建一个名为<code class="fe ny nz oa ob b">Classifier</code>的新类来处理分类任务。我们需要定义两个常量和一个从给定文本中提取标记的方法(通过删除不必要的单词、标点符号等)。).</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div></figure><blockquote class="nq nr ns"><p id="7c28" class="lf lg nt lh b li lj ka lk ll lm kd ln nu lp lq lr nv lt lu lv nw lx ly lz ma ij bi translated">getTokens( document ) =令牌。因此，我们可以将文档 d 转换为一组令牌，如 x₁ ,x₂ … xₙ.</p></blockquote><h2 id="e321" class="oc me iq bd mf od oe dn mj of og dp mn lo oh oi mp ls oj ok mr lw ol om mt iw bi translated">寻找概率</h2><p id="f8ee" class="pw-post-body-paragraph lf lg iq lh b li on ka lk ll oo kd ln lo op lq lr ls oq lu lv lw or ly lz ma ij bi translated">首先，我们需要找到<em class="nt"> P( C ) </em>或者类概率。这无非是两个语料库中有多少单词属于类别<em class="nt"> C </em>的概率。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/4b214b075dd912715eb7e19aa4ecbf20.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*WrCjaw9s9n-czGDrpdA-tA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Class probabilities. Eq.2</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Calculates Eq.1</figcaption></figure><p id="39c5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，我们需要找到<em class="nt"> P( X | C ) </em>这是 X 的<em class="nt">概率，假设它属于一个类别 C </em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/394dc40180b856cba4c1d8cf5d79cc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*7ArVKh_-jrR50K6pI2y0Xw.png"/></div></figure><p id="f4a1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在此之前，我们需要一个方法来找到给定文档中的令牌<em class="nt"> xᵢ </em>的<em class="nt"> P( xᵢ | C ) </em>。我们可以用这个方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Calculates P( xᵢ | c )</figcaption></figure><blockquote class="nq nr ns"><p id="ea2c" class="lf lg nt lh b li lj ka lk ll lm kd ln nu lp lq lr nv lt lu lv nw lx ly lz ma ij bi translated">其中<code class="fe ny nz oa ob b">class_vocab</code>是其中一个语料库。它代表 P( xᵢ | C)中的 c。想知道 1 是从哪里来的？这就是拉普拉斯平滑。如果 P( xᵢ | C)是 0，而 xᵢ在我们的语料库中不存在，那么我们所有的 P( X | C)都可能变成 0。加 1 可以解决这个问题。</p></blockquote><p id="609c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们需要将所有的<em class="nt"> P( xᵢ | C ) </em>相乘，最后乘以 P( C)，这是我们在下面方法中的类概率。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Calculates Eq.1</figcaption></figure><p id="6f09" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">仅此而已。现在我们需要检查哪个类的可能性更大。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="f36d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个<a class="ae le" href="https://gist.github.com/shubham0204/c19eb5694bf2c7be3901772726ac5c5e" rel="noopener ugc nofollow" target="_blank">要诀</a>里可以一目了然的看到完整的代码。</p><h1 id="8192" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">还有呢！</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="3f82" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">太长了，有点数学化。结束了！</h1><p id="6373" class="pw-post-body-paragraph lf lg iq lh b li on ka lk ll oo kd ln lo op lq lr ls oq lu lv lw or ly lz ma ij bi translated">希望你喜欢科特林的朴素贝叶斯的想法。请在下面的评论区分享您的反馈。</p><blockquote class="nq nr ns"><p id="fe02" class="lf lg nt lh b li lj ka lk ll lm kd ln nu lp lq lr nv lt lu lv nw lx ly lz ma ij bi translated">这是我的第一篇数学含量很高的文章，所以请原谅我在精度标注上的错误。:-)</p></blockquote><p id="2cfa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">快乐的机器学习。</p></div></div>    
</body>
</html>