<html>
<head>
<title>Fake News Classification with BERT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 BERT 的假新闻分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fake-news-classification-with-bert-afbeee601f41?source=collection_archive---------15-----------------------#2019-11-19">https://towardsdatascience.com/fake-news-classification-with-bert-afbeee601f41?source=collection_archive---------15-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/11f96cae3c14e4f3c760766fd9e49d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTWbfjODlTTrEhJu7_Mohg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://www.pexels.com/@connor-danylenko-534256" rel="noopener ugc nofollow" target="_blank">Connor Danylenko</a> on <a class="ae kf" href="https://www.pexels.com/photo/person-holding-a-burning-news-paper-close-up-photography-2538122/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="258c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假新闻是一种通过新闻媒体和/或社交媒体故意传播虚假信息的宣传方式。鉴于假新闻的传播可能会产生严重影响，如左右选举、加剧 T2 的政治分歧，开发检测假新闻内容的方法非常重要。在本帖中，我们将使用一种叫做 BERT 的算法来预测新闻报道是否是假的。</p><p id="aaf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">BERT 代表来自变压器的双向编码器表示。描述伯特算法的论文由谷歌发表，可以在<a class="ae kf" href="https://arxiv.org/pdf/1810.04805.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>找到。BERT 的工作原理是随机屏蔽单词标记，并用基于上下文的向量来表示每个被屏蔽的单词。BERT 的两个应用是“预训练”和“微调”。</p><p id="0af6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">预训练 BERT </strong></p><p id="0b54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于预训练 BERT 算法，研究人员训练了两个无监督学习任务。第一个任务被描述为屏蔽 LM。其工作原理是随机屏蔽 15%的文档，并预测这些被屏蔽的标记。第二个任务是下一句预测(NSP)。这是由问答和自然语言推理等任务激发的。这些任务需要模型来准确捕捉句子之间的关系。为了解决这个问题，他们对二进制预测任务进行了预训练，该任务可以从单一语言的任何语料库中轻松生成。他们在论文中给出的例子如下:如果你有句子 A 和 B，A 有 50%的时间被标注为“isNext”，另外 50%的时间是从语料库中随机选取的句子，被标注为“notNext”。针对这一任务的预训练被证明对于问题回答和自然语言推理任务是有益的。</p><p id="f28f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">微调伯特</strong></p><p id="bd15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">微调 BERT 的工作原理是用自我关注对连接在一起的文本对进行编码。自我注意是学习当前单词和先前单词之间相关性的过程。这一点的一个早期应用是在长短期记忆(<a class="ae kf" href="https://arxiv.org/pdf/1601.06733.pdf" rel="noopener ugc nofollow" target="_blank"/>)论文(Dong2016)中，研究人员使用自我注意进行机器阅读。BERT 的好处在于，通过对带有自我关注的串联文本进行编码，可以捕捉句子对之间的双向交叉关注。</p><p id="673a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将应用 BERT 来预测一个文档是否是假新闻。这个数据集的名字是<em class="le">关于假新闻</em>的真相，在这里可以找到<a class="ae kf" href="https://www.kaggle.com/mrisdal/fake-news" rel="noopener ugc nofollow" target="_blank">。这篇文章的灵感来自于</a><a class="ae kf" rel="noopener" target="_blank" href="/bert-to-the-rescue-17671379687f"> <em class="le"> BERT to the Rescue </em> </a>，它使用 BERT 对 IMDB 数据集进行情感分类。从<a class="ae kf" rel="noopener" target="_blank" href="/bert-to-the-rescue-17671379687f"> <em class="le">伯特到营救</em> </a>的代码可以在<a class="ae kf" href="https://github.com/shudima/notebooks/blob/master/BERT_to_the_rescue.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6446" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">BERT 算法的输入是单词序列，输出是编码的单词表示(向量)。对于单句分类，我们使用每个单词的向量表示作为分类模型的输入。</p><p id="914f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们开始吧！</p><ol class=""><li id="1965" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="ki iu">导入包</strong></li></ol><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8448" class="lx ly it lt b gy lz ma l mb mc">import pandas as pd <br/>import numpy as np <br/>import torch.nn as nn<br/>from pytorch_pretrained_bert import BertTokenizer, BertModel<br/>import torch<br/>from torchnlp.datasets import imdb_dataset<br/>from keras.preprocessing.sequence import pad_sequences<br/>from sklearn.metrics import classification_report</span></pre><p id="354a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<strong class="ki iu">数据探索</strong></p><p id="5f84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们将数据读入 dataframe 并打印前五行。我们还可以将最大显示列数设置为“无”。为简单起见，让我们看看“文本”和“类型”列:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="98f8" class="lx ly it lt b gy lz ma l mb mc">pd.set_option('display.max_columns', None)<br/>df = df[['text', 'type']]<br/>df = pd.read_csv("fake.csv")<br/>print(df.head())</span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/0a163c7e60d9da21acdbda2c698d7a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*-aQupLEW9jSDcetm4mIQjw.png"/></div></figure><p id="c74e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的分类模型的目标在“类型”列中。为了了解“type”值的分布和种类，我们可以使用集合模块中的“Counter ”:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c75a" class="lx ly it lt b gy lz ma l mb mc">from collections import Counter<br/>print(Counter(df['type'].values))</span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/2ccb21f48458de1df3e7c27c8e4bfbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUE5oppnKU3zxlhh-R-bqw.png"/></div></div></figure><p id="78bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们感兴趣的是分类新闻文本是否是假的。我们可以看到我们只有 19 条“假”新闻记录。新闻标签的其他变体对应于不可靠的新闻来源，如“仇恨”，这是一种宣扬种族主义、厌女症、同性恋恐惧症和其他形式的歧视的新闻。另一个是“clickbait ”,通过耸人听闻的标题优化广告收入最大化。数据的完整描述可在<a class="ae kf" href="https://github.com/selfagency/bs-detector" rel="noopener ugc nofollow" target="_blank">这里</a>找到。理想情况下，我们希望我们的目标具有“假新闻”和“真新闻”的值。不幸的是，这些数据并没有提供一个我们可以用作对照组的新闻类别。为了简单起见，我们可以将我们的目标定义为“虚假”和“讽刺”，看看我们是否可以建立一个分类器来区分这两者。我鼓励读者尝试用一些其他标签构建其他分类器，或者用“真实”新闻增强数据集，这些新闻可以用作对照组。</p><p id="9a4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.<strong class="ki iu">资料准备</strong></p><p id="b8ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们想要对应于“假”和“讽刺”的“类型”值的数据，我们可以如下过滤我们的数据:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6f2b" class="lx ly it lt b gy lz ma l mb mc">df = df[df['type'].isin(['fake', 'satire'])]</span></pre><p id="1e3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用“计数器”验证我们得到了期望的输出:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4a84" class="lx ly it lt b gy lz ma l mb mc">print(Counter(df['type'].values))</span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/418ae1efc56eed3f8d8e366c04171ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*ZM6cDOqg1-Z13X6rzNuwJw.png"/></div></figure><p id="15c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们也放弃“南”值:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="fd09" class="lx ly it lt b gy lz ma l mb mc">df.dropna(inplace = True)</span></pre><p id="b02c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们想平衡我们的数据集，这样我们就有相同数量的“假”和“讽刺”类型。我们还应该随机改变目标:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5385" class="lx ly it lt b gy lz ma l mb mc">df_fake = df[df['type'] == 'fake'] <br/>df_statire = df[df['type'] == 'satire'] <br/>df_statire = df_statire.sample(n=len(df_fake))<br/>df = df_statire.append(df_fake)<br/>df = df.sample(frac=1, random_state = 24).reset_index(drop=True)</span></pre><p id="8de1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再次验证我们得到了想要的结果:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="0d1a" class="lx ly it lt b gy lz ma l mb mc">print(Counter(df['type'].values))</span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/189b4d329a8cbf54f381de5bd30fe322.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*XD9pgMB9PXqfCmCPrPVIHQ.png"/></div></figure><p id="594b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们要格式化数据，这样它就可以用作我们的 BERT 模型的输入。我们将数据分为训练集和测试集:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="447c" class="lx ly it lt b gy lz ma l mb mc">train_data = df.head(19)<br/>test_data = df.tail(19)</span></pre><p id="7db4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用“文本”和“类型”关键字生成一个字典列表:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="51f8" class="lx ly it lt b gy lz ma l mb mc">train_data = [{'text': text, 'type': type_data } for text in list(train_data['text']) for type_data in list(train_data['type'])]<br/>test_data = [{'text': text, 'type': type_data } for text in list(test_data['text']) for type_data in list(test_data['type'])]</span></pre><p id="e097" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从字典列表中生成元组列表:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="670f" class="lx ly it lt b gy lz ma l mb mc">train_texts, train_labels = list(zip(*map(lambda d: (d['text'], d['type']), train_data)))<br/>test_texts, test_labels = list(zip(*map(lambda d: (d['text'], d['type']), test_data)))</span></pre><p id="8200" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成令牌和令牌 id:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="47f7" class="lx ly it lt b gy lz ma l mb mc">tokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case=True)<br/>train_tokens = list(map(lambda t: ['[CLS]'] + tokenizer.tokenize(t)[:511], train_texts))<br/>test_tokens = list(map(lambda t: ['[CLS]'] + tokenizer.tokenize(t)[:511], test_texts))</span><span id="6ade" class="lx ly it lt b gy mh ma l mb mc">train_tokens_ids = list(map(tokenizer.convert_tokens_to_ids, train_tokens))<br/>test_tokens_ids = list(map(tokenizer.convert_tokens_to_ids, test_tokens))</span><span id="f0b4" class="lx ly it lt b gy mh ma l mb mc">train_tokens_ids = pad_sequences(train_tokens_ids, maxlen=512, truncating="post", padding="post", dtype="int")<br/>test_tokens_ids = pad_sequences(test_tokens_ids, maxlen=512, truncating="post", padding="post", dtype="int")</span></pre><p id="f8da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们将输入字符串截断为 512 个字符，因为这是 BERT 可以处理的最大令牌数。</p><p id="28c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，为我们的测试和训练集生成一个基于“type”值的布尔数组:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6ec3" class="lx ly it lt b gy lz ma l mb mc">train_y = np.array(train_labels) == 'fake'<br/>test_y = np.array(test_labels) == 'fake'</span></pre><p id="07a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.<strong class="ki iu">模型建立</strong></p><p id="4e1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了我们的 BERT 分类器，它包含一个“初始化”方法和一个返回令牌概率的“转发”方法:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="87d3" class="lx ly it lt b gy lz ma l mb mc">class BertBinaryClassifier(nn.Module):<br/>    def __init__(self, dropout=0.1):<br/>        super(BertBinaryClassifier, self).__init__()</span><span id="436f" class="lx ly it lt b gy mh ma l mb mc">self.bert = BertModel.from_pretrained('bert-base-uncased')</span><span id="8252" class="lx ly it lt b gy mh ma l mb mc">self.dropout = nn.Dropout(dropout)<br/>        self.linear = nn.Linear(768, 1)<br/>        self.sigmoid = nn.Sigmoid()<br/>    <br/>    def forward(self, tokens, masks=None):<br/>        _, pooled_output = self.bert(tokens, attention_mask=masks, output_all_encoded_layers=False)<br/>        dropout_output = self.dropout(pooled_output)<br/>        linear_output = self.linear(dropout_output)<br/>        proba = self.sigmoid(linear_output)<br/>        return proba</span></pre><p id="720c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们生成训练和测试掩码:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e4a5" class="lx ly it lt b gy lz ma l mb mc">train_masks = [[float(i &gt; 0) for i in ii] for ii in train_tokens_ids]<br/>test_masks = [[float(i &gt; 0) for i in ii] for ii in test_tokens_ids]<br/>train_masks_tensor = torch.tensor(train_masks)<br/>test_masks_tensor = torch.tensor(test_masks)</span></pre><p id="9dd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成用于训练和测试的令牌张量:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5110" class="lx ly it lt b gy lz ma l mb mc">train_tokens_tensor = torch.tensor(train_tokens_ids)<br/>train_y_tensor = torch.tensor(train_y.reshape(-1, 1)).float()<br/>test_tokens_tensor = torch.tensor(test_tokens_ids)<br/>test_y_tensor = torch.tensor(test_y.reshape(-1, 1)).float()</span></pre><p id="d129" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，准备我们的数据加载器:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4282" class="lx ly it lt b gy lz ma l mb mc">train_dataset =  torch.utils.data.TensorDataset(train_tokens_tensor, train_masks_tensor, train_y_tensor)<br/>train_sampler =  torch.utils.data.RandomSampler(train_dataset)<br/>train_dataloader =  torch.utils.data.DataLoader(train_dataset, sampler=train_sampler, batch_size=BATCH_SIZE)</span><span id="5b90" class="lx ly it lt b gy mh ma l mb mc">test_dataset =  torch.utils.data.TensorDataset(test_tokens_tensor, test_masks_tensor, test_y_tensor)<br/>test_sampler =  torch.utils.data.SequentialSampler(test_dataset)<br/>test_dataloader =  torch.utils.data.DataLoader(test_dataset, sampler=test_sampler, batch_size=BATCH_SIZE)</span></pre><p id="4728" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.<strong class="ki iu">微调</strong></p><p id="4ca4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用 Adam 优化器来最小化二进制交叉熵损失，并且我们使用 1 个时期的批量大小 1 来训练:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c2d3" class="lx ly it lt b gy lz ma l mb mc">BATCH_SIZE = 1<br/>EPOCHS = 1</span><span id="7e33" class="lx ly it lt b gy mh ma l mb mc">bert_clf = BertBinaryClassifier()<br/>optimizer = torch.optim.Adam(bert_clf.parameters(), lr=3e-6)</span><span id="ec69" class="lx ly it lt b gy mh ma l mb mc">for epoch_num in range(EPOCHS):<br/>    bert_clf.train()<br/>    train_loss = 0<br/>    for step_num, batch_data in enumerate(train_dataloader):<br/>        token_ids, masks, labels = tuple(t for t in batch_data)<br/>        probas = bert_clf(token_ids, masks)<br/>        loss_func = nn.BCELoss()<br/>        batch_loss = loss_func(probas, labels)<br/>        train_loss += batch_loss.item()<br/>        bert_clf.zero_grad()<br/>        batch_loss.backward()<br/>        optimizer.step()<br/>        print('Epoch: ', epoch_num + 1)<br/>        print("\r" + "{0}/{1} loss: {2} ".format(step_num, len(train_data) / BATCH_SIZE, train_loss / (step_num + 1)))</span></pre><p id="c859" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们评估我们的模型:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="93ae" class="lx ly it lt b gy lz ma l mb mc">bert_clf.eval()<br/>bert_predicted = []<br/>all_logits = []<br/>with torch.no_grad():<br/>    for step_num, batch_data in enumerate(test_dataloader):</span><span id="3c12" class="lx ly it lt b gy mh ma l mb mc">token_ids, masks, labels = tuple(t for t in batch_data)</span><span id="ecb7" class="lx ly it lt b gy mh ma l mb mc">logits = bert_clf(token_ids, masks)<br/>        loss_func = nn.BCELoss()<br/>        loss = loss_func(logits, labels)<br/>        numpy_logits = logits.cpu().detach().numpy()<br/>        <br/>        bert_predicted += list(numpy_logits[:, 0] &gt; 0.5)<br/>        all_logits += list(numpy_logits[:, 0])<br/>        <br/>print(classification_report(test_y, bert_predicted))</span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/eaa714a3a718fce8dfcf831707e01247.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Oqrh9LBJSrC4NrvZnRofYA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Classification Report</figcaption></figure><p id="b386" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于我们没有太多的训练数据，结果证明性能精度相当低。随着更多的数据和更大数量的历元，这个问题应该会得到解决。</p><p id="3951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" rel="noopener" target="_blank" href="/bert-to-the-rescue-17671379687f"><em class="le">BERT to the Rescue</em></a><em class="le">中可以找到对代码的更彻底的遍历。再次，我鼓励你尝试修改分类器，以预测一些其他标签，如政治宣传中的“偏见”。另一个有趣的标签是“垃圾科学”，这是促进伪科学和其他科学上可疑的说法的来源。可以在<a class="ae kf" href="https://github.com/selfagency/bs-detector" rel="noopener ugc nofollow" target="_blank">这里</a>找到数据的描述及其标注方式。这篇文章的代码可以在<a class="ae kf" href="https://github.com/spierre91/medium_code" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</em></p><p id="4a1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，机器学习快乐！</p></div></div>    
</body>
</html>