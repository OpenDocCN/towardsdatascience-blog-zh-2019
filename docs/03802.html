<html>
<head>
<title>Spice Up Your Python Visualizations with Matplotlib Animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Matplotlib 动画增加 Python 可视化的趣味</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spice-up-your-python-visualizations-with-matplotlib-animations-d437d7e98e67?source=collection_archive---------5-----------------------#2019-06-16">https://towardsdatascience.com/spice-up-your-python-visualizations-with-matplotlib-animations-d437d7e98e67?source=collection_archive---------5-----------------------#2019-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0b5578fb12d01a30e17755134c691886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3E7zriDvYDGadaO7sCvAw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://www.pexels.com/@ekamelev?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Egor Kamelev </a>from <a class="ae jg" href="https://www.pexels.com/photo/jellyfish-digital-wallpaper-753267/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><div class=""/><div class=""><h2 id="0d02" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">还有约翰·康威的《生命的游戏》的一些有趣的 gif</h2></div><p id="d573" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">如果你对我的代码感兴趣，可以在我的 GitHub </em>  <em class="lu">这里找到</em> <a class="ae jg" href="https://github.com/yiuhyuk/game_of_life" rel="noopener ugc nofollow" target="_blank"> <em class="lu">。第一次运行时，代码会抛出一个错误(这是我一辈子都无法摆脱的)。但是，如果您只是再次执行同一个单元，它将运行良好。</em></a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="bf33" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi mc translated">他的帖子显然不是数据科学帖子，但它确实有数据科学和商业智能应用。Python 的 Matplotlib 是绘制和可视化数据的首选库。我们都熟悉折线图、条形图和热图。但是你知道你也可以使用 Matplotlib 制作简单的动画吗？</p><p id="32cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个用 Matplotlib 创建的动画的例子。它展示了约翰·康威的<a class="ae jg" href="https://bitstorm.org/gameoflife/" rel="noopener ugc nofollow" target="_blank">生命的游戏</a>——Metis 的<a class="ae jg" rel="noopener" target="_blank" href="/how-i-feel-about-data-science-and-the-metis-bootcamp-experience-398b171289d0">编码挑战，这给了我创作第一个 Python 动画的借口。查看最终结果的 gif:</a></p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/3a86d5c40c9d4933a49c72818287c244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*whwcpkNqt3J-LYsX8EzAeQ.gif"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">The Game of Life</figcaption></figure><p id="78ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对我如何编写生命游戏感兴趣，请参考 GitHub 上的<a class="ae jg" href="https://github.com/yiuhyuk/game_of_life" rel="noopener ugc nofollow" target="_blank">我的代码(和评论】</a>。这篇博客将主要关注如何使用 Matplotlib 在 python 中添加动画。</p><p id="eb5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是对于那些不熟悉模拟的人来说(这更像是你观看的模拟，而不是你玩的游戏)，这里有一些规则:</p><ul class=""><li id="9593" class="mq mr jj la b lb lc le lf lh ms ll mt lp mu lt mv mw mx my bi translated">我们从一块 N 乘 N 大小的板开始(在我的动画中是 50 乘 50)。</li><li id="758a" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">我们在板上随机填充了一些细胞(我开始模拟时，在板上 2500 个细胞中随机填充了 1500 个细胞)。</li><li id="943f" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">具有一个或更少邻居的每个被占用的单元死亡。</li><li id="b666" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">具有四个或更多邻居的每个被占用的单元死亡。</li><li id="6854" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">每一个有两三个邻居的被占据的细胞存活下来。</li><li id="0a1d" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">每个<strong class="la jk">空的</strong>细胞与正好三个相邻的细胞发展出一个新的有机体。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c80" class="ne nf jj bd ng nh ni nj nk nl nm nn no kp np kq nq ks nr kt ns kv nt kw nu nv bi translated">设置董事会</h1><p id="0791" class="pw-post-body-paragraph ky kz jj la b lb nw kk ld le nx kn lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我们从导入我们需要的库开始。</p><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="b224" class="og nf jj oc b gy oh oi l oj ok">import time<br/>from IPython import display<br/>import matplotlib.pyplot as plt<br/>import matplotlib.animation as animation</span></pre><p id="a233" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将利用 matplotlib 动画模块中的<strong class="la jk"> FuncAnimation()函数。FuncAnimation()通过反复调用函数来制作图像动画，每次调用时更新图像</strong>。我们将一步一步地完成这个过程。</p><p id="3782" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是首先，我们需要初始化我们的板。下面几行代码收集了我们的输入:</p><ul class=""><li id="a2df" class="mq mr jj la b lb lc le lf lh ms ll mt lp mu lt mv mw mx my bi translated">我们想要一块 50 乘 50 大小的木板。</li><li id="3149" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">pad 变量使得计算邻居变得更加容易。通过用总是空着的额外单元填充边缘，我们就不需要编写额外的逻辑来处理电路板的边缘。因此，我们的 50 乘 50 板被空白单元的边界包围，使得实际的 numpy 数组具有 52 乘 52 的大小。</li><li id="a85b" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">initial_cells 变量是我们希望棋盘从多少个有机体开始。它们将被随机放在黑板上。</li></ul><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="aa29" class="og nf jj oc b gy oh oi l oj ok"># Input variables for the board<br/>boardsize = 50        # board will be X by X where X = boardsize<br/>pad = 2               # padded border, do not change this!<br/>initial_cells = 1500  # this number of initial cells will be placed <br/>                      # in randomly generated positions</span></pre><p id="6766" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">接下来，我们随机生成一串坐标</strong>(我们在上面选择了 1500)<strong class="la jk">，我们最初的生物体将生活在那里。</strong>这些坐标存储在变量 pos_list 中。</p><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="7ba0" class="og nf jj oc b gy oh oi l oj ok"># Get a list of random coordinates so that we can initialize <br/># board with randomly placed organisms<br/>pos_list = []<br/>for i in range(initial_cells):<br/>    pos_list.append([random.randint(1, boardsize), <br/>                     random.randint(1, boardsize)])</span></pre><p id="e795" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后是<strong class="la jk">实例化电路板的时候了。我们将使用一个名为 my_board 的 numpy 数组来表示我们的棋盘</strong> —我们从一个 52 乘 52 的零数组开始(由于填充，它比 50 乘 50 大)，然后调用函数 init_board()根据 pos_list 中的坐标用有机体填充它。我不会在这里详述助手函数，但是它们在我的 GitHub 上有<a class="ae jg" href="https://github.com/yiuhyuk/game_of_life" rel="noopener ugc nofollow" target="_blank">文档。</a></p><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="a77b" class="og nf jj oc b gy oh oi l oj ok"># Initialize the board<br/>my_board = np.zeros((boardsize+pad, boardsize+pad))<br/>my_board = init_board(pos_list, my_board)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2c20" class="ne nf jj bd ng nh ni nj nk nl nm nn no kp np kq nq ks nr kt ns kv nt kw nu nv bi translated">为棋盘制作动画</h1><p id="1081" class="pw-post-body-paragraph ky kz jj la b lb nw kk ld le nx kn lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我们期待已久的部分——动画！首先，我们需要解决一些手续问题。下面几行代码创建的 matplotlib 图形将显示我们的动画。</p><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="1114" class="og nf jj oc b gy oh oi l oj ok"># Required line for plotting the animation<br/>%matplotlib notebook<br/># Initialize the plot of the board that will be used for animation<br/>fig = plt.gcf()</span></pre><p id="3baa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候制作我们的第一个相框了。matplotlib 的函数<strong class="la jk"> imshow()接收一个 numpy 矩阵，并将其呈现为图像。相当酷！</strong></p><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="6571" class="og nf jj oc b gy oh oi l oj ok"># Show first image - which is the initial board<br/>im = plt.imshow(my_board)<br/>plt.show()</span></pre><p id="cba1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们传递给 imshow()的变量是我们的初始板，它存储在 my_board 中。创建的图像如下所示:</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/a3400fc987d252fcb8741d530e9fd25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jW2k4EqVww-Y3WJ64BbQeQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">The Initial State of the Game Board (Yellow = Organism)</figcaption></figure><p id="81bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要做一个 FuncAnimation()可以调用的 helper 函数。函数<strong class="la jk"> animate() </strong>取帧，它只是一个计数器。帧计数器是 FuncAnimation()与<strong class="la jk"> animate() </strong>函数通信的方式——对于每一步时间(也称为帧),它将调用<strong class="la jk"> animate() </strong>一次<strong class="la jk">。</strong>和<strong class="la jk"> animate() </strong>会依次使用辅助函数 update_board()迭代棋盘一圈。最后，函数 set_data()用迭代板更新了我们的图像，我们可以开始了。</p><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="7c4d" class="og nf jj oc b gy oh oi l oj ok"># Helper function that updates the board and returns a new image of<br/># the updated board animate is the function that FuncAnimation calls<br/>def animate(frame):<br/>    im.set_data(update_board(my_board))<br/>    return im,</span></pre><p id="265f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">万岁！我们准备调用<strong class="la jk"> FuncAnimation() </strong>。注意输入:</p><ul class=""><li id="01b6" class="mq mr jj la b lb lc le lf lh ms ll mt lp mu lt mv mw mx my bi translated">fig 是我们之前为容纳动画而创建的绘图变量。</li><li id="8239" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">animate 是我们的函数，<strong class="la jk"> FuncAnimation() </strong>使用帧计数器与之通信(它是自动传递的，不需要显式指定)。</li><li id="7b1c" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">帧是我们希望动画持续多少帧，在这种情况下，我们希望我们的动画是 200 帧长。</li><li id="1da1" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">interval 是帧之间的延迟，以毫秒为单位。所以我们希望两帧之间有 50 毫秒。</li></ul><pre class="mm mn mo mp gt ob oc od oe aw of bi"><span id="a00f" class="og nf jj oc b gy oh oi l oj ok"># This line creates the animation<br/>anim = animation.FuncAnimation(fig, animate, frames=200, <br/>                               interval=50)</span></pre><p id="3792" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！不算太糟吧？为了庆祝我们的成功动画，这里是另一个 gif:</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e5a858f673b06b1de008342a49ed5342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*-btqaGlI0wI3YzBAsg1hZA.gif"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">The Game of Life: Endgame :)</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="87dc" class="ne nf jj bd ng nh ni nj nk nl nm nn no kp np kq nq ks nr kt ns kv nt kw nu nv bi translated">结论</h1><p id="b9e1" class="pw-post-body-paragraph ky kz jj la b lb nw kk ld le nx kn lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我希望你觉得这是有用的。在我离开之前，让我来为我们今天学到的动画功能的更多类似数据科学的应用集思广益:</p><ul class=""><li id="581b" class="mq mr jj la b lb lc le lf lh ms ll mt lp mu lt mv mw mx my bi translated">一个接一个画出蒙特卡洛模拟，这样你可以观察结果分布是如何逐渐形成的。</li><li id="4150" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">向前遍历时间序列数据，以便描述模型或数据在新观测值到达时的反应。</li><li id="ec4e" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">突出显示当您更改输入(如分类数)时，算法所识别的分类是如何变化的。</li><li id="a869" class="mq mr jj la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">一段时间内或跨数据的不同子样本的关联热图，以直观显示不同样本如何影响模型的估计参数。</li></ul><p id="bd7b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="9bd4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">更从我:</em> </strong></p><p id="1b8c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/how-i-feel-about-data-science-and-the-metis-bootcamp-experience-398b171289d0"> <em class="lu">关于数据科学的思考。</em> </a></p><p id="8326" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/understanding-random-forest-58381e0602d2"> <em class="lu">随机森林算法。</em>T11】</a></p><p id="126e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/understanding-neural-networks-19020b758230"> <em class="lu">神经网络如何工作。</em>T15】</a></p><p id="afe4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/understanding-logistic-regression-using-a-simple-example-163de52ea900"> <em class="lu">逻辑回归解释。</em>T19】</a></p></div></div>    
</body>
</html>