<html>
<head>
<title>Cleaning Web-Scraped Data with Pandas (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫清理网络抓取的数据(下)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cleaning-web-scraped-data-with-pandas-part-ii-8520f47cc929?source=collection_archive---------32-----------------------#2019-11-09">https://towardsdatascience.com/cleaning-web-scraped-data-with-pandas-part-ii-8520f47cc929?source=collection_archive---------32-----------------------#2019-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/20bcdc8aa1655ef5fd8ea20bf274f080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jU-2JOj62cssuHId"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@4themorningshoot?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oliver Hale</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="0dca" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何从网络搜集的数据中创造意义，用于数据分析和机器学习</h2></div><p id="3cdf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是我之前关于清理网络抓取数据的讨论的延续。您可以通过以下链接访问第一部分:</p><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/cleaning-web-scraped-data-with-pandas-and-regex-part-i-a82a177af11b"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">用熊猫和 Regex 清理网络抓取的数据！(第一部分)</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">如何从网络搜集的数据中创造意义，用于数据分析和机器学习！第 2 部分—即将推出！</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2250" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">|| I ||数量与质量(数据)</h1><p id="6c86" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">正如我在之前的帖子中提到的，清理数据是机器学习的先决条件。测量数据的健全性也可以很好地表明模型的精确程度。说到网络抓取的数据，你经常会在清理的过程中丢失很多信息。那么应该是什么呢？数量还是质量？</p><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/249f1564ba3b48823830dcac6333844e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ynOHGjObacDoCtu-"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@joshstyle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JOSHUA COLEMAN</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9e66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回答这个问题并不容易，因为它实际上取决于案例和数据科学家制定的流程。</p><p id="4171" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您最终处理的数据需要较少的特异性来处理它的变量，那么您可以选择使用数量，并且应该可以使用数据清理方法，这些方法可以使用推理数据来替换值。</p><p id="848a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您处理的数据确实需要特殊性。例如，在这种情况下，我们正在处理笔记本电脑数据。使用平均值、中间值或众数来替换我们数据中缺失的值是没有意义的，因为有多种类别的笔记本电脑具有不同的规格组合。例如，如果 i5 是列“处理器”的模式，您不能让所有缺少的值都等于 i5，因为这会扭曲数据，产生很大的偏差。</p><p id="892d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，您可以通过删除缺少值的行来清除数据。这将把数据从 440 个值减少到 153 个值。我知道这对机器学习模型来说不太好，但作为一名数据科学家，我明白我的结果质量将与我的数据质量密切相关。因此，保持整洁是最好的方法，否则我将不得不手动检查每一行缺失的数据来填补空白。<br/>— —<em class="ns">——‘废话少说——我们走吧</em> — — —</p><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/62ee616640787f1ee50b444f1455e30d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B8FQn2y1vRVT9hn_"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@smartphotocourses?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Smart</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7caa" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">|| II ||映射并存储到数据框架中</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/283553fe4489f5c6b932fe932b707a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/1*SPYVUpDqI-2PUg1P52bl0w.gif"/></div></figure><p id="ec7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在使用 regex 从每个字符串中提取出所需的文本片段以获得每个新数据列的列表后，我停止了第 1 部分。图中显示了每一列:<br/> - <code class="fe nv nw nx ny b">screen_size</code>:屏幕尺寸<br/> - <code class="fe nv nw nx ny b">processor</code> : GHz <br/> - <code class="fe nv nw nx ny b">processor_type</code>:名称<br/> - <code class="fe nv nw nx ny b">ram</code> : RAM <br/> - <code class="fe nv nw nx ny b">storage</code>:数量(HDD/SSD) <br/> - <code class="fe nv nw nx ny b">chipset</code>:显卡品牌<br/> - <code class="fe nv nw nx ny b">gc</code>:显卡类型</p><p id="e747" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">获得这些列表后，我们现在可以将它们作为列添加到我们的数据框架中。我们只需将每个 DataFrame 列分配给其各自的 list 对象，然后映射每行的文本，这样就可以只保留相关的数据。下面的代码行是我如何为每一个专栏做这件事的例子。例如，在列表 screen_size 中，我们得到了整个字符串“屏幕尺寸 15.6”，而我们只想要“15.6”。我们也希望每行都这样，所以当我们使用<strong class="la jk">映射函数</strong>去掉前 12 个字符:<em class="ns">“屏幕尺寸 15.6”→“15.6”。</em>同样，您应该能够理解不同列的其他示例。</p><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="67c5" class="od mr jj ny b gy oe of l og oh">#Screen Size<br/>data['Screen_size']= screen_size<br/>data['Screen_size']= data['Screen_size'].map(lambda x: str(x)[12:])</span><span id="6db5" class="od mr jj ny b gy oi of l og oh">#Processor Power<br/>data['Processor_power'] = processor<br/>data['Processor_power'] = data['Processor_power'].map(lambda x: str(x)[10:])</span><span id="063c" class="od mr jj ny b gy oi of l og oh">#Processor Type<br/>data['Processor_type'] = processortype<br/>data['Processor_type'] = data['Processor_type'].map(lambda x: str(x)[5:-2])</span><span id="7d65" class="od mr jj ny b gy oi of l og oh">#RAM<br/>data['RAM'] = ram<br/>data['RAM'] = data['RAM'].map(lambda x: str(x)[:])</span><span id="c0e3" class="od mr jj ny b gy oi of l og oh">#Storage &amp; Storage Type<br/>data['Storage'] = storage<br/>data['Storage'] = data['Storage'].map(lambda x: str(x)[:])<br/>data['Storage_type'] = data['Storage'].map(lambda x: x.split()[2])<br/>data['Storage'] = data['Storage'].map(lambda x: x.split()[0] +  x.split()[1])</span><span id="d517" class="od mr jj ny b gy oi of l og oh">#Graphics Card brand<br/>data['Graphics_brand'] = chipset<br/>data['Graphics_brand'] = data['Graphics_brand'].map(lambda x: str(x)[:])</span><span id="b03d" class="od mr jj ny b gy oi of l og oh">#Graphics Card Type<br/>data['Graphics_type'] = gc<br/>data['Graphics_type'] = data['Graphics_type'].map(lambda x: str(x)[:])</span></pre><p id="21b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果应该如下所示:</p><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/bd15eff79bf76c71410a0fb979483634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kp6D5RrRMv4-NY8v4Zypdw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">clean-ish data…</figcaption></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3cab" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">|| III ||数值型数据是真正的数值型</h1><p id="3e73" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">接下来，我将把每个数字列转换成一个真正的数字列，允许它反映所包含的数据类型(整型或浮点型)。为此，我必须从销售价格列中删除' $ '符号，然后将其转换为数字。对于屏幕尺寸，由于我们只有数字，我们只需要转换它。<strong class="la jk">确保使用</strong> <code class="fe nv nw nx ny b"><strong class="la jk">errors='coerce'</strong></code> <strong class="la jk">。</strong></p><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="2e36" class="od mr jj ny b gy oe of l og oh">salesprice = data['sales_price'].str.lstrip('$')<br/>salesprice = pd.to_numeric(salesprice, errors='coerce')<br/>salesprice.fillna(salesprice.mode()[0], inplace=True)<br/>screensize = data['Screen_size']<br/>screensize = pd.to_numeric(screensize, errors='coerce')</span></pre><p id="6915" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那很容易。现在让我向你展示用<code class="fe nv nw nx ny b">rstrip</code>和<code class="fe nv nw nx ny b">lstrip</code>做同样事情的另一种方法。这次我将使用列<code class="fe nv nw nx ny b">processor_power</code>和<code class="fe nv nw nx ny b">ram</code>。我们希望在第一种情况下删除“GHz ”,在第二种情况下删除“GB”。</p><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="fa92" class="od mr jj ny b gy oe of l og oh">data['Processor_GHz'] = data['Processor_power'].str.rstrip('GHz')<br/>data['RAM_GB'] = data['RAM'].str.rstrip(' GB')</span></pre><p id="f0bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面几行应该已经在您的数据中创建了新的列，现在可以将这些列转换为数字。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="69ec" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">|| IV ||保持分类数据的相关性</h1><p id="0161" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">当你有分类数据时，最好少于 5 个类别，因为这会使你的数据不那么模糊。在 processor_type 列中，我可能不能拥有少于 5 个类别，但是我肯定可以将所有相似的对象移动到一个类别中。比如“AMD A4”和“AMD A6”都可以归入“AMD A 系列”。我还添加了一个名为“Other”的类别，包含该列中不常用的值。因此，下面几行:</p><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="e852" class="od mr jj ny b gy oe of l og oh">#Removing "Intel" since we would come to know by the name.<br/>processortypez = data['Processor_type'].str.lstrip(' Intel')</span><span id="84a4" class="od mr jj ny b gy oi of l og oh">pt = []<br/>for i in processortypez:<br/>    if i == 'core_m':<br/>        i = 'M Series'<br/>    elif i == 'AMD A4' or i =='AMD A6' or i=='Apple A6':<br/>        i = 'AMD A Series'<br/>    elif i == 'i7' or i == 'Core':<br/>        i = 'Core i7'<br/>    pt.append(i)</span><span id="8574" class="od mr jj ny b gy oi of l og oh">data['Processor_type'] = pt<br/>proz = data['Processor_type']</span><span id="8a92" class="od mr jj ny b gy oi of l og oh">pz = []<br/>for i in proz:<br/>    if i != 'Core i3' and i != 'Core i5' and i != 'Core i7' and i != 'Celeron' and i != 'Pentium' and i != 'AMD A Series' and i != 'AMD R Series':<br/>        i = 'Other'<br/>    pz.append(i)</span><span id="1dc8" class="od mr jj ny b gy oi of l og oh">data['Processor_type'] = pz</span></pre><p id="ce1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对“存储”列做了类似的操作，其中 1TB 是 1000GB，因为我将删除“GB”部分，所以我将有一个单一的度量单位，将所有 TB 转换为 GB。</p><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="f6a9" class="od mr jj ny b gy oe of l og oh">strzz = data['Storage']<br/>zz = []<br/>for i in strzz:<br/>    if i == '1TB':<br/>        i = '1000GB'<br/>    elif i == '2TB':<br/>        i = '2000GB'<br/>    elif i == 'FlashMemory':<br/>        i = '64GB'<br/>    zz.append(i)<br/>data['Storage'] = zz<br/>data['Storage_GB'] = data['Storage'].str.rstrip('GB')</span></pre><p id="f310" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也对许多其他需要修复的列做了同样的事情。你可以在提供的要点(在底部)中找到所有完整的例子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="0d64" class="od mr jj bd ms ok ol dn mw om on dp na lh oo op nc ll oq or ne lp os ot ng ou bi translated">最后，我将删除不需要的列:</h2><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="f5ce" class="od mr jj ny b gy oe of l og oh">data = data.drop(columns=['Processor_power', 'RAM', 'Storage'])</span></pre><h2 id="092a" class="od mr jj bd ms ok ol dn mw om on dp na lh oo op nc ll oq or ne lp os ot ng ou bi translated">已清理数据帧的快照:</h2><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/fd1b65c36410b0118833c0bbdd9ae914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfkcdMDBwrxleM1nmWI0fw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Clean and ready-to-use data.</figcaption></figure><h2 id="210f" class="od mr jj bd ms ok ol dn mw om on dp na lh oo op nc ll oq or ne lp os ot ng ou bi translated"><strong class="ak">我运行了一个快速散点图来查看数据，猜猜我发现了什么:</strong></h2><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="f105" class="od mr jj ny b gy oe of l og oh">import seaborn as sb</span><span id="88ac" class="od mr jj ny b gy oi of l og oh">scatplot = sb.relplot(x="RAM", y="Screen_size", data=data)</span></pre><p id="b93f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面你可以看到散点图。注意到什么奇怪的事了吗？</p><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/eb152607ab959ed98d2157aa5009c1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*QhYWnUyMVvivc5yWPwJwUA.png"/></div></figure><p id="875a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个屏幕尺寸写着“156”！这不可能。它应该是 15.6，所以让我们继续快速更改它:</p><pre class="no np nq nr gt nz ny oa ob aw oc bi"><span id="7ec2" class="od mr jj ny b gy oe of l og oh">scrnsize2 = []<br/>for i in screensize:<br/>    if i == 156.0:<br/>        i = 15.6<br/>    scrnsize2.append(i)<br/>df[screen_size]=scrnsize2</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0d4e" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">第二部分结束</h1><p id="be3a" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">感谢阅读。我希望你从这两部分中学到了有用的东西！下面，你可以找到我的笔记本，里面有清理这些数据的所有代码。</p><figure class="no np nq nr gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">The “Cleaning” Notebook</figcaption></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><blockquote class="oz"><p id="fde0" class="pa pb jj bd pc pd pe pf pg ph pi lt dk translated">关注 Rohan Gupta，了解其他数据科学内容和教程！</p></blockquote></div></div>    
</body>
</html>