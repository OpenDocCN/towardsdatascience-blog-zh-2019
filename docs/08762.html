<html>
<head>
<title>Assignment, Shallow Copy, Or Deep Copy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">赋值，浅抄，还是深抄？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/assignment-shallow-or-deep-a-story-about-pythons-memory-management-b8fad87bfa6c?source=collection_archive---------11-----------------------#2019-11-24">https://towardsdatascience.com/assignment-shallow-or-deep-a-story-about-pythons-memory-management-b8fad87bfa6c?source=collection_archive---------11-----------------------#2019-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4856" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个关于 Python 内存管理的故事</h2></div><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="acd0" class="ko kp iq kk b gy kq kr l ks kt">from copy import copy, deepcopy</span></pre><p id="8513" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇文章的目的是描述当我们</p><ul class=""><li id="90f0" class="lq lr iq kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">分配一个变量<code class="fe lz ma mb kk b">B = A</code>，</li><li id="e48c" class="lq lr iq kw b kx mc la md ld me lh mf ll mg lp lv lw lx ly bi translated">浅层复制它<code class="fe lz ma mb kk b">C = copy(A)</code>，或者</li><li id="0439" class="lq lr iq kw b kx mc la md ld me lh mf ll mg lp lv lw lx ly bi translated">深抄它<code class="fe lz ma mb kk b">D = deepcopy(A)</code>。</li></ul><p id="85bb" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我首先描述一下 Python 中的内存管理和优化。在奠定基础之后，我解释了赋值语句、浅拷贝和深拷贝之间的区别。然后，我在一个表格中总结了这种差异。</p><p id="319b" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="mh">如果你更喜欢看视频而不是看文章，你可以在这里</em>  <em class="mh">找到补充视频</em> <a class="ae mi" href="https://youtu.be/KnirnBi13CE" rel="noopener ugc nofollow" target="_blank"> <em class="mh">。</em></a></p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="d89e" class="ko kp iq bd mq mr ms dn mt mu mv dp mw ld mx my mz lh na nb nc ll nd ne nf ng bi translated"><strong class="ak">Python 中的内存管理</strong></h2><p id="b84d" class="pw-post-body-paragraph ku kv iq kw b kx nh jr kz la ni ju lc ld nj lf lg lh nk lj lk ll nl ln lo lp ij bi translated"><em class="mh"> int </em>，<em class="mh"> float </em>，<em class="mh"> list </em>，<em class="mh"> dict </em>，<em class="mh">类实例</em>，…它们都是 Python 中的对象。在 CPython 实现中，内置函数<code class="fe lz ma mb kk b">id()</code>返回对象的内存地址—</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="3ee0" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; L1 = [1, 2, 3]</span><span id="f7b7" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(L1)<br/>3061530120</span></pre><p id="2fc2" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果我们创建一个新的变量<code class="fe lz ma mb kk b">L2</code>，它引用一个与<code class="fe lz ma mb kk b">L1</code>具有相同值的对象，<code class="fe lz ma mb kk b">L2</code>将有一个新的内存地址—</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="408e" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; L2 = [1, 2, 3]</span><span id="e38f" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(L2)<br/>3061527304</span></pre><p id="3a82" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">每次创建一个新对象，它都会有一个新的内存地址。除非它是—</p><ol class=""><li id="889b" class="lq lr iq kw b kx ky la lb ld ls lh lt ll lu lp nn lw lx ly bi translated">一根很短的绳子</li><li id="8a32" class="lq lr iq kw b kx mc la md ld me lh mf ll mg lp nn lw lx ly bi translated">[-5，256]范围内的整数</li><li id="8206" class="lq lr iq kw b kx mc la md ld me lh mf ll mg lp nn lw lx ly bi translated">一个空的不可变容器(例如元组)</li></ol><p id="df9d" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们看一个整数对象的例子。<code class="fe lz ma mb kk b"><em class="mh">x</em></code>和<code class="fe lz ma mb kk b"><em class="mh">y</em></code>指的是同一个值 10。虽然上例中的<code class="fe lz ma mb kk b">L1</code>和<code class="fe lz ma mb kk b">L2</code>有两个不同的内存地址，但是<code class="fe lz ma mb kk b"><em class="mh">x</em></code> <em class="mh"> </em>和<code class="fe lz ma mb kk b"><em class="mh">y</em></code> <em class="mh"> </em>共享相同的内存地址</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="ce3c" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; x = 10</span><span id="fbd0" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; y = 10</span><span id="f6a6" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(x)<br/>2301840</span><span id="b6d1" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(y)<br/>2301840</span></pre><p id="1591" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是因为，在这三个例外中，Python 通过让第二个变量引用内存中的同一个对象来优化内存，有人称之为“共享对象”。</p><p id="170e" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">记住共享对象的概念，因为我们稍后创建对象的<em class="mh">深拷贝</em>时会用到它。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="af1f" class="ko kp iq bd mq mr ms dn mt mu mv dp mw ld mx my mz lh na nb nc ll nd ne nf ng bi translated">变量赋值</h2><p id="fe21" class="pw-post-body-paragraph ku kv iq kw b kx nh jr kz la ni ju lc ld nj lf lg lh nk lj lk ll nl ln lo lp ij bi translated">在<a class="ae mi" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>中说“Python 中的赋值语句不复制对象，它们在目标和对象之间创建绑定。”这意味着当我们通过赋值来创建一个变量时，新的变量与原始变量引用同一个对象</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="f418" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; A = [1, 2, [10, 11], 3, [20, 21]]</span><span id="4d14" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; B = A</span><span id="9be0" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(A)<br/>3061527080</span><span id="6bb4" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(B)<br/>3061527080</span></pre><p id="c3fc" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">因为新变量<code class="fe lz ma mb kk b">B</code>和原始变量<code class="fe lz ma mb kk b">A</code>共享同一个对象(即同一个列表)，所以它们也包含相同的元素—</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="0c56" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; id(A[2])<br/>3061527368</span><span id="cc2e" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(B[2])<br/>3061527368</span></pre><p id="5fe4" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如下图所示，<code class="fe lz ma mb kk b">A</code>和<code class="fe lz ma mb kk b">B</code>共享同一个<code class="fe lz ma mb kk b">id</code>，即在内存中引用同一个对象。它们也包含相同的元素。</p><figure class="kf kg kh ki gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/a4efb94d640cc22b7a7452f3da9a2818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxHfWmw9yN6HddHTrS8rWQ.png"/></div></div></figure><h2 id="c4e3" class="ko kp iq bd mq mr ms dn mt mu mv dp mw ld mx my mz lh na nb nc ll nd ne nf ng bi translated">浅拷贝</h2><p id="0cc5" class="pw-post-body-paragraph ku kv iq kw b kx nh jr kz la ni ju lc ld nj lf lg lh nk lj lk ll nl ln lo lp ij bi translated">当我们通过<em class="mh">浅拷贝</em>创建一个变量时，新的变量指向一个新的对象——</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="6e2b" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; A = [1, 2, [10, 11], 3, [20, 21]]</span><span id="1dad" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; C = copy(A)</span><span id="1b13" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(A)<br/>3062428488</span><span id="7874" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(C)<br/>3062428520</span></pre><p id="3765" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">虽然<code class="fe lz ma mb kk b">A</code>和<code class="fe lz ma mb kk b">C</code>指的是两个不同的对象(即两个不同内存地址的列表)，但两个列表中的元素指的是相同的对象—</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="9761" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; id(A[0])<br/>2301696</span><span id="1650" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(C[0])<br/>2301696</span><span id="acc1" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(A[2])<br/>3062464904</span><span id="985c" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(C[2])<br/>3062464904</span></pre><p id="7e14" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">下图说明了<code class="fe lz ma mb kk b">A</code>中的元素如何引用与<code class="fe lz ma mb kk b">C</code>中的元素相同的对象。</p><figure class="kf kg kh ki gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/5bbc9886febc1598c173b510f956d910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDLlYYV25BBl8I28nKspow.png"/></div></div></figure><h2 id="1e3a" class="ko kp iq bd mq mr ms dn mt mu mv dp mw ld mx my mz lh na nb nc ll nd ne nf ng bi translated">深层拷贝</h2><p id="96c2" class="pw-post-body-paragraph ku kv iq kw b kx nh jr kz la ni ju lc ld nj lf lg lh nk lj lk ll nl ln lo lp ij bi translated">类似于浅层拷贝，当我们通过<em class="mh">深层拷贝</em>创建一个变量时，新的变量指向一个新的对象——</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="cb3d" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; A = [1, 2, [10, 11], 3, [20, 21]]</span><span id="5495" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; D = deepcopy(A)</span><span id="937b" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(A)<br/>3062727496</span><span id="6d99" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(D)<br/>3062428488</span></pre><p id="7324" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如<a class="ae mi" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>所述——</p><blockquote class="nw nx ny"><p id="8184" class="ku kv mh kw b kx ky jr kz la lb ju lc nz le lf lg oa li lj lk ob lm ln lo lp ij bi translated"><em class="iq">浅拷贝和深拷贝的区别只与复合对象(包含其他对象的对象，如列表或类实例)相关:</em></p><p id="f095" class="ku kv mh kw b kx ky jr kz la lb ju lc nz le lf lg oa li lj lk ob lm ln lo lp ij bi translated"><em class="iq"> -一个</em>浅拷贝<em class="iq">构造一个新的复合对象，然后(尽可能地)将</em>引用<em class="iq">插入到原始对象中。</em></p><p id="8644" class="ku kv mh kw b kx ky jr kz la lb ju lc nz le lf lg oa li lj lk ob lm ln lo lp ij bi translated"><em class="iq"> -一个</em>深度拷贝<strong class="kw ir"> </strong> <em class="iq">构造一个新的复合对象，然后递归地将</em>拷贝<em class="iq">插入到原始对象中。</em></p></blockquote><p id="59dc" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">与浅层拷贝不同，两个列表中的元素现在引用不同的对象——</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="1c16" class="ko kp iq kk b gy kq kr l ks kt">&gt;&gt;&gt; id(A[0])<br/>2301696</span><span id="5a1f" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(D[0])<br/>2301696</span><span id="9121" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(A[2])<br/>3062464648</span><span id="5a9b" class="ko kp iq kk b gy nm kr l ks kt">&gt;&gt;&gt; id(D[2])<br/>3062466376</span></pre><p id="2b61" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是为什么<code class="fe lz ma mb kk b">A[0]</code>和<code class="fe lz ma mb kk b">D[0]</code>共享同一个对象(即拥有相同的内存地址)？因为它们都引用整数，这是我们在开始提到的内存优化的三个例外之一。</p><p id="9816" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">下图显示<code class="fe lz ma mb kk b">A</code>和<code class="fe lz ma mb kk b">D</code>引用内存中两个不同的列表，由于内存优化的原因<code class="fe lz ma mb kk b">A</code>中的元素引用的对象不同于<code class="fe lz ma mb kk b">D</code>中的元素，整数元素除外。</p><figure class="kf kg kh ki gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/432a3d86101e1da5260b3599dc51dade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLfkGWUPYdtOEg-hCtmGqA.png"/></div></div></figure><h2 id="8f75" class="ko kp iq bd mq mr ms dn mt mu mv dp mw ld mx my mz lh na nb nc ll nd ne nf ng bi translated">摘要</h2><p id="7b4b" class="pw-post-body-paragraph ku kv iq kw b kx nh jr kz la ni ju lc ld nj lf lg lh nk lj lk ll nl ln lo lp ij bi translated">如果这篇文章有什么值得一提的地方，那一定是下表。变量赋值不复制对象，所以<code class="fe lz ma mb kk b">A</code>和<code class="fe lz ma mb kk b">B</code>有相同的内存地址，包含相同的元素。浅层复制为<code class="fe lz ma mb kk b">C</code>创建了一个新对象，但是<code class="fe lz ma mb kk b">C</code>中的元素仍然引用与<code class="fe lz ma mb kk b">A</code>中的元素相同的对象。深度复制还为<code class="fe lz ma mb kk b">D</code>创建了一个新对象，并且<code class="fe lz ma mb kk b">D</code>中的元素引用的对象与<code class="fe lz ma mb kk b">A</code>中的元素不同，有三种类型的异常。</p><figure class="kf kg kh ki gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oc"><img src="../Images/fec1607334932351e5b21538634446d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vg2WLNOW_XKe4WjDt4kNYw.png"/></div></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="eeb4" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇文章的灵感来自于…</p><ul class=""><li id="17b5" class="lq lr iq kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae mi" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">副本上的 Python 文档</a></li><li id="1072" class="lq lr iq kw b kx mc la md ld me lh mf ll mg lp lv lw lx ly bi translated"><a class="ae mi" href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" rel="noopener ugc nofollow" target="_blank">了解 Python 变量和内存管理</a></li></ul></div></div>    
</body>
</html>