<html>
<head>
<title>Search Algorithm Introduction- Breadth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法介绍-广度优先搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/search-algorithm-introduction-1-a71e4a1911b3?source=collection_archive---------21-----------------------#2019-11-30">https://towardsdatascience.com/search-algorithm-introduction-1-a71e4a1911b3?source=collection_archive---------21-----------------------#2019-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9496" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/search" rel="noopener" target="_blank">搜索</a></h2><div class=""/><div class=""><h2 id="2fe3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从头开始 Python 实现</h2></div><p id="9dc3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">搜索是关于规划的，广泛应用于自动驾驶汽车和路线规划。在本帖中，我们来谈谈在给定的静态环境下寻找可行路径的问题。结构遵循<a class="ae ln" href="https://classroom.udacity.com/courses/cs373/lessons/48646841/concepts/486837620923" rel="noopener ugc nofollow" target="_blank">这里</a>的课程，我们直接进入一个问题，基于问题设置引入 first search。</p><h1 id="0d02" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">设置</h1><p id="a223" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">假设我们生活在 2D 网格世界中:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d0c5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">网格大小为 5 乘 6，0 表示可用，1 表示堵塞。我们从点<code class="fe ms mt mu mv b">[0, 0]</code>开始，目标位于右下角<code class="fe ms mt mu mv b">[4, 5]</code>。有 4 个动作可用<code class="fe ms mt mu mv b">left, right, up and down</code>对应<code class="fe ms mt mu mv b">delta_name</code>中列出的 4 个符号。现在的问题是找到一条从起点到目标的可行路径。</p><h1 id="5a7a" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">横向优先搜索</h1><p id="1e87" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">有许多搜索算法，让我们从广度优先搜索开始。与深度优先搜索相反，广度优先搜索开始水平扩展搜索路径:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/cf6bcac2d63d7850104dd9a3a9719a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfAWH7IeiSHZgNrtCpzBVg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">refer to <a class="ae ln" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">wiki</a></figcaption></figure><p id="02ed" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如图所示，从节点<code class="fe ms mt mu mv b">1</code>开始，在深入到下一层之前，它会探索它的所有邻居。与我们的问题设置相同，我们的 2d 网格世界也可以被视为一个可扩展的树，我们从初始点<code class="fe ms mt mu mv b">[0, 0]</code>开始，从这里，我们只能向下到<code class="fe ms mt mu mv b">[1, 0]</code>或直接到<code class="fe ms mt mu mv b">[0, 1]</code>，只有在迭代完所有这些邻居之后，我们才会探索下一级的节点。</p><p id="1753" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，让我们考虑一下实现广度优先搜索需要哪些组件。首先，我们肯定需要维护一个当前扩展路径的队列或列表，并且能够弹出下一个最低级别的节点。其次，我们应该维护另一个列表来跟踪所有被访问过的节点，这样我们就不会两次访问一个节点。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e44d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以这里的<code class="fe ms mt mu mv b">close</code>是我们追踪所有访问过的节点并用值<code class="fe ms mt mu mv b">1</code>表示它们的列表，而<code class="fe ms mt mu mv b">open_list</code>是扩展路径，其中每个元素记录了节点的级别和节点位置→ <code class="fe ms mt mu mv b">[g_value, x, y]</code>。</p><p id="6b7c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">搜索路径不断扩展，直到:</p><ol class=""><li id="2f5d" class="ni nj it kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated">没有可浏览的节点:<code class="fe ms mt mu mv b">len(open_list) == 0</code></li><li id="5536" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">找到目标:<code class="fe ms mt mu mv b">[cur_x, cur_y] == goal</code></li></ol><p id="7a2f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ms mt mu mv b">sort</code>和<code class="fe ms mt mu mv b">reverse</code>确保每次弹出最小级别的节点。如果在那个层次上没有找到目标，它将通过迭代所有可能的动作来扩展节点，同时通过<code class="fe ms mt mu mv b">nxt_g = cur_g + cost</code>添加层次。</p><p id="166f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我们打印出结果:</p><pre class="ml mm mn mo gt nw mv nx ny aw nz bi"><span id="1df9" class="oa lp it mv b gy ob oc l od oe">[11, 4, 5]</span></pre><p id="37e8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以需要 11 步才能达到我们的目标<code class="fe ms mt mu mv b">[4, 5]</code>。你可以算出 11 实际上是我们的最优值。</p><p id="7d1a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面的代码贯穿了整个过程，但是好像缺了点什么……我们并没有真正找到我们的路径并打印出来！</p><p id="bd23" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要打印出我们的路径，我们需要在扩展时跟踪每个单元格中采取的每个动作，然后以相反的方式从目标到初始点，以获得我们的最终路径。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0c14" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">列表<code class="fe ms mt mu mv b">action</code>在展开过程中跟踪每个动作，就像在 for 循环中一样:</p><pre class="ml mm mn mo gt nw mv nx ny aw nz bi"><span id="ef5b" class="oa lp it mv b gy ob oc l od oe">action[nxt_x][nxt_y] = delta.index(d)</span></pre><p id="fec7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">扩展后的行动列表包括:</p><pre class="ml mm mn mo gt nw mv nx ny aw nz bi"><span id="0830" class="oa lp it mv b gy ob oc l od oe">[-1, 3, -1, 0, 3, 3]<br/>[2, 2, -1, 0, 3, 3]<br/>[2, 2, 3, 3, -1, 2]<br/>[2, 2, -1, -1, -1, 2]<br/>[2, 2, 3, 3, -1, 2]</span></pre><p id="5aad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">策略列表从目标状态开始，以相反的方式打印出代表动作的符号，最后，我们得到最终结果:</p><pre class="ml mm mn mo gt nw mv nx ny aw nz bi"><span id="99fe" class="oa lp it mv b gy ob oc l od oe">['&gt;', 'v', ' ', ' ', ' ', ' ']<br/>[' ', 'v', ' ', '&gt;', '&gt;', 'v']<br/>[' ', '&gt;', '&gt;', '^', ' ', 'v']<br/>[' ', ' ', ' ', ' ', ' ', 'v']<br/>[' ', ' ', ' ', ' ', ' ', '*']</span></pre><p id="068e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可能会注意到有多条最佳路径，但是该算法只能根据扩展顺序打印一条路径。我们将在下一篇文章中介绍另一个实现，它给出了所有的最优路径。</p><p id="af1d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，广度优先搜索可以找到给定条件下的最优结果:</p><blockquote class="of og oh"><p id="3170" class="kr ks nh kt b ku kv kd kw kx ky kg kz oi lb lc ld oj lf lg lh ok lj lk ll lm im bi translated">如果路径代价是节点深度的非减函数，则广度优先搜索是最优的。最常见的情况是所有的行为都有相同的成本。</p></blockquote><p id="8315" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一个直观的理解是，由于广度优先搜索仅在当前级别的所有节点都已被访问时探索下一级别，所以它总是在可能的最低级别中找到目标。</p><p id="95f2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">参考</strong>:</p><ol class=""><li id="e4e6" class="ni nj it kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated"><a class="ae ln" href="https://classroom.udacity.com/courses/cs373/lessons/48646841/concepts/112e9f79-63cd-44ee-883f-652677e64d31" rel="noopener ugc nofollow" target="_blank">https://classroom . uda city . com/courses/cs 373/lessons/48646841/concepts/112 e9f 79-63cd-44ee-883 f-652677 e64d 31</a></li></ol></div></div>    
</body>
</html>