<html>
<head>
<title>Scikit-Learn vs MLR for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit-Learn 与机器学习的 MLR</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scikit-learn-vs-mlr-for-machine-learning-exxact-blog-e8eb173a5d65?source=collection_archive---------29-----------------------#2019-08-21">https://towardsdatascience.com/scikit-learn-vs-mlr-for-machine-learning-exxact-blog-e8eb173a5d65?source=collection_archive---------29-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d50e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">检查两个库的 ML 工作流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d08d803a8914d4c3060f95ab812f814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WC4npmELN8DLKfqv09CeNQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image Source: stokpic</figcaption></figure><p id="0f4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Scikit-Learn 以其易于理解的 API 而闻名，对于 Python 用户来说，MLR 成为了流行的 Caret 包的替代品，提供了更多的算法套件和一种调整超参数的简单方法。这两个包在某种程度上是相互竞争的，因为许多参与自动分析的人转向 Python 进行机器学习，R 进行统计分析。</p><p id="4f1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">偏爱 Python 的原因之一可能是因为当前机器学习的 R 包是通过包含该算法的其他包提供的。这些包通过 MLR 调用，但是仍然需要额外的安装。甚至需要外部特征选择库，并且它们还需要满足其他外部依赖性。</p><p id="e30d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Scikit-Learn 被称为许多机器学习算法的统一 API，不需要用户调用任何库。</p><p id="f54f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">这绝不意味着怀疑 R。</strong>不管在线调查结果如何，R 仍然是数据科学领域的一个重要组成部分。任何有统计学或数学背景的人都会知道为什么你应该使用 R(不管他们自己是否使用它，他们认识到了它的吸引力)。</p><p id="fbf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将看看用户如何经历典型的机器学习工作流。在 Scikit-Learn 中，我们将继续学习 MLR 中的逻辑回归和决策树。</p><h1 id="e85f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">创建您的培训和测试数据</h1><ul class=""><li id="0236" class="mm mn it la b lb mo le mp lh mq ll mr lp ms lt mt mu mv mw bi translated"><code class="fe mx my mz na b">train &lt;- sample(1:nrow(data), 0.8 * nrow(data))</code></li><li id="a981" class="mm mn it la b lb nb le nc lh nd ll ne lp nf lt mt mu mv mw bi translated"><code class="fe mx my mz na b">test &lt;- setdiff(1:nrow(train), train)</code></li><li id="c904" class="mm mn it la b lb nb le nc lh nd ll ne lp nf lt mt mu mv mw bi translated">MLR 没有用于子集数据集的内置函数，因此用户需要依赖其他 R 函数来实现这一点。这是一个创建 80/20 训练测试集的例子。</li></ul><h1 id="3805" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">选择算法</h1><ul class=""><li id="a782" class="mm mn it la b lb mo le mp lh mq ll mr lp ms lt mt mu mv mw bi translated"><code class="fe mx my mz na b">makeLearner('classif.rpart')</code>。这个算法被称为学习器，这个函数被调用来初始化它。</li><li id="4436" class="mm mn it la b lb nb le nc lh nd ll ne lp nf lt mt mu mv mw bi translated"><code class="fe mx my mz na b">makeClassifTask(data=, target=)</code>。如果我们正在做分类，我们需要进行一个调用来初始化一个分类任务。这个函数将接受两个参数:训练数据和目标变量的名称。</li></ul><h1 id="5769" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">超参数调谐</h1><p id="148e" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在任一软件包中，优化超参数时都有一个过程要遵循。您首先需要指定要更改哪些参数以及这些参数的间距。然后进行网格搜索或随机搜索，以找到参数估计的最佳组合，从而获得最佳结果(即误差最小化或精度最大化)。</p><p id="f2b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Scikit-Learn </strong></p><pre class="kj kk kl km gt nj na nk nl aw nm bi"><span id="7098" class="nn lv it na b gy no np l nq nr">C = np.logspace(0, 4, 10)<br/>max_iter= [100,110,120,130,140]<br/>hyperparameters = dict(C=C, penalty=penalty, dual=dual, max_iter=max_iter)<br/>GridSearchCV(logreg, hyperparameters, cv=5, verbose=0)<br/>clf.fit(x_train, y_train)</span></pre><p id="fcc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最低贷款利率（minimumlendingrate）</p><pre class="kj kk kl km gt nj na nk nl aw nm bi"><span id="d167" class="nn lv it na b gy no np l nq nr">makeParamSet( makeDiscreteParam("minsplit", values=seq(5,10,1)), makeDiscreteParam("minbucket", values=seq(round(5/3,0), round(10/3,0), 1)), makeNumericParam("cp", lower = 0.01, upper = 0.05), makeDiscreteParam("maxcompete", values=6), makeDiscreteParam("usesurrogate", values=0), makeDiscreteParam("maxdepth", values=10) )<br/>ctrl = makeTuneControlGrid()<br/>rdesc = makeResampleDesc("CV", iters = 3L, stratify=TRUE)<br/>tuneParams(learner=dt_prob, resampling=rdesc, measures=list(tpr,auc, fnr, mmce, tnr, setAggregation(tpr, test.sd)), par.set=dt_param, control=ctrl, task=dt_task, show.info = TRUE) )<br/>setHyperPars(learner, par.vals = tuneParams$x)</span></pre><h1 id="a3ee" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">培养</h1><p id="483c" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">这两个软件包都提供了训练模型的单行代码。</p><p id="927c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可以说是这个过程中最简单的步骤之一。最困难的步骤是调整超参数和特征选择。</p><h1 id="b78a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">预言；预测；预告</h1><p id="a977" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">就像训练模型一样，预测只需要一行代码就可以完成。</p><p id="b28a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Scikitlearn 将返回预测标签的数组，而 MLR 将返回预测标签的数据帧。</p><h1 id="b99f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">模型评估</h1><p id="2e01" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">评估监督分类器最流行的方法是一个混淆矩阵，你可以从中获得准确度、误差、精确度、召回率等。</p><p id="abcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Scikit-Learn </strong></p><ul class=""><li id="34e0" class="mm mn it la b lb lc le lf lh ns ll nt lp nu lt mt mu mv mw bi translated"><code class="fe mx my mz na b">confusion_matrix(y_test, prediction)</code>或者</li><li id="c347" class="mm mn it la b lb nb le nc lh nd ll ne lp nf lt mt mu mv mw bi translated"><code class="fe mx my mz na b">classification_report(y_test,prediction)</code></li></ul><p id="1ff4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> MLR </strong></p><ul class=""><li id="3a90" class="mm mn it la b lb lc le lf lh ns ll nt lp nu lt mt mu mv mw bi translated"><code class="fe mx my mz na b">performance(prediction, measures = list(tpr,auc,mmce, acc,tnr))</code>或</li><li id="a0cc" class="mm mn it la b lb nb le nc lh nd ll ne lp nf lt mt mu mv mw bi translated"><code class="fe mx my mz na b">calculateROCMeasures(prediction)</code></li></ul><p id="ae64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个软件包都提供了多种获取混淆矩阵的方法。<strong class="la iu">然而，对于尽可能简单的信息视图，python 不如 r 信息丰富。第一个 Python 代码将只返回一个没有标签的矩阵。用户不得不返回到文档中去辨认哪些列和行对应于哪个类别。</strong>第二种方法具有更好和更丰富的输出，但它只会产生精确度、召回率、F1 分数和支持度；但这也是不平衡分类问题中更重要的性能指标。</p><h1 id="acaa" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">判定阈值(即改变分类阈值)</h1><p id="b352" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">分类问题中的阈值是将每个实例分类到预测类别中的给定概率。默认阈值将始终为 0.5(即 50%)。这是在 Python 和 R. R 中进行机器学习时的一个主要区别。R . R 提供了一行代码的解决方案来操纵阈值以解决类的不平衡。Python 对此没有内置函数，而是由用户通过定义自己的自定义脚本/函数来以编程方式操纵阈值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5b9a7b608d668fd896b27b91a7d3b8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*jFWZOOEmBnUwv7MnLQwYlw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">pair of graphs showing decision thresholds</figcaption></figure><p id="0bdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Scikit-Learn </strong></p><ul class=""><li id="ad03" class="mm mn it la b lb lc le lf lh ns ll nt lp nu lt mt mu mv mw bi translated">在 Scikitlearn 中没有一种标准的阈值方法。查看这篇文章，你可以自己实现它:<strong class="la iu">在 Scikit-Learn 中微调分类器</strong></li></ul><p id="36b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> MLR </strong></p><ul class=""><li id="8490" class="mm mn it la b lb lc le lf lh ns ll nt lp nu lt mt mu mv mw bi translated"><code class="fe mx my mz na b">setThreshold(prediction, threshold)</code>。mlr 中的这一行代码将自动更改您的阈值，并可以作为参数来计算您的新绩效指标(即混淆矩阵等)。)</li></ul><h1 id="4aa0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="2788" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">最后，在处理机器学习时，mlr 和 Scikitlearn 都有各自的优点和缺点。这是使用其中一种进行机器学习的比较，并不能作为使用其中一种而不是另一种的理由。对这两方面都有所了解，才能给职场上的人带来真正的竞争优势。对流程的概念性理解将使工具的使用更加容易。</p><p id="430d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nw">原载于 2019 年 8 月 21 日</em><a class="ae nx" href="https://blog.exxactcorp.com/scikitlearn-vs-mlr-for-machine-learning/" rel="noopener ugc nofollow" target="_blank"><em class="nw">【https://blog.exxactcorp.com】</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>