<html>
<head>
<title>3 simple ways to handle large data with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫处理大量数据的 3 种简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-simple-ways-to-handle-large-data-with-pandas-d9164a3c02c1?source=collection_archive---------4-----------------------#2019-05-15">https://towardsdatascience.com/3-simple-ways-to-handle-large-data-with-pandas-d9164a3c02c1?source=collection_archive---------4-----------------------#2019-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="805e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熊猫喜欢吃数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/440610af6551c9448c4981cd4d2b0dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dwEPfYHKw-Hvvbhn.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Pandas love eating data</figcaption></figure><blockquote class="ky kz la"><p id="c542" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">想获得灵感？快来加入我的<a class="ae ly" href="https://www.superquotes.co/?utm_source=mediumtech&amp;utm_medium=web&amp;utm_campaign=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="le iu">超级行情快讯</strong> </a>。😎</p></blockquote><p id="3068" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">熊猫已经成为最受欢迎的数据科学图书馆之一。它易于使用，文档非常棒，功能非常强大。</p><p id="c874" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然而，无论使用什么库，大型数据集总是带来额外的挑战，需要小心处理。</p><p id="ac92" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">你开始遇到硬件障碍，因为你没有足够的内存来保存所有的数据。企业公司存储高达数百甚至数千 GB 的数据集。</p><p id="8f2b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">即使你碰巧买了一台有足够内存来存储所有数据的机器，只是把它读入内存也是非常慢的。</p><p id="1fa4" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">但是熊猫图书馆将再次帮助我们。本文将讨论 3 种可以用来减少大型数据集的内存占用和读入时间的技术。我将这些技术用于大小超过 100GB 的数据集，将它们压缩到具有 64 GB(有时是 32GB)RAM 的机器上。</p><p id="9701" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们检查一下！</p><h1 id="013d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(1)将你的数据分块</h1><p id="9bb7" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">CSV 格式是一种非常方便的数据存储方式，既易于书写，又易于阅读。此外，还有一个很好的 pandas 函数<code class="fe mz na nb nc b">read_csv()</code>用于加载以 CSV 格式存储的数据。</p><p id="d66f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">但是当你的 CSV 大到内存不足的时候会发生什么呢？</p><p id="7269" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">有一个非常简单的熊猫技巧来解决这个问题！我们不会试图一次性处理所有数据，而是将数据分成几部分来处理。通常，这些块被称为<em class="ld">块</em>。</p><p id="2b50" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">一个块只是我们数据集的一部分。我们可以随心所欲地将这一大块变大或变小。这取决于我们有多少内存。</p><p id="19d9" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然后，该过程如下进行:</p><ol class=""><li id="fe50" class="nd ne it le b lf lg li lj lz nf ma ng mb nh lx ni nj nk nl bi translated">整体阅读</li><li id="9093" class="nd ne it le b lf nm li nn lz no ma np mb nq lx ni nj nk nl bi translated">处理大块</li><li id="8461" class="nd ne it le b lf nm li nn lz no ma np mb nq lx ni nj nk nl bi translated">保存块的结果</li><li id="a45f" class="nd ne it le b lf nm li nn lz no ma np mb nq lx ni nj nk nl bi translated">重复步骤 1 到 3，直到我们得到所有的块结果</li><li id="0e13" class="nd ne it le b lf nm li nn lz no ma np mb nq lx ni nj nk nl bi translated">合并块结果</li></ol><p id="0445" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们可以使用一个叫做<strong class="le iu"> chunksize </strong>的<code class="fe mz na nb nc b">read_csv()</code>函数的便利变量来执行上述所有步骤。chunksize 指的是熊猫一次将读取多少 CSV 行。这当然取决于你有多少内存和每行有多大。</p><p id="ae10" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果我们认为我们的数据有一个非常容易处理的分布，比如高斯分布，那么我们可以一次对一个数据块进行我们想要的处理和可视化，而不会损失太多的准确性。</p><p id="5e4f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果我们的分布有点像泊松分布那样复杂，那么最好在行进之前过滤每个块并将所有的小块放在一起。大多数情况下，您最终会删除许多不相关的列或缺少值的行。我们可以对每个数据块都这样做，使它们变得更小，然后将它们放在一起，在最终的数据帧上执行我们的数据分析。</p><p id="5724" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">下面的代码执行所有这些步骤。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="1285" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(2)丢弃数据</h1><p id="ccc2" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">有时，我们会马上知道我们要分析数据集的哪些列。事实上，经常会出现这样的情况，有几个或几个我们并不关心的列，如姓名、账号等。</p><p id="23d2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在读入数据之前直接跳过列可以节省大量内存。Pandas 允许我们指定想要阅读的栏目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c6c0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">丢弃包含无用信息的列将是您最大的内存节省之一。</p><p id="8696" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们可以做的另一件事是过滤掉任何缺少值或 NA 值的行。使用<code class="fe mz na nb nc b">dropna()</code>功能最简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c9cb" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">有几个真正有用的变量我们可以传递给<code class="fe mz na nb nc b">dropna()</code>:</p><ul class=""><li id="5c1f" class="nd ne it le b lf lg li lj lz nf ma ng mb nh lx nt nj nk nl bi translated"><strong class="le iu">如何:</strong>这将允许您指定“any”(如果某一行的任何列是 NA，则删除该行)或“all”(仅当某一行的所有列都是 NA 时，才删除该行)</li><li id="9287" class="nd ne it le b lf nm li nn lz no ma np mb nq lx nt nj nk nl bi translated"><strong class="le iu"> thresh: </strong>设置一个阈值，确定一行需要删除多少 NA 值</li><li id="a6a5" class="nd ne it le b lf nm li nn lz no ma np mb nq lx nt nj nk nl bi translated"><strong class="le iu"> subset: </strong>选择检查 NA 值时要考虑的列的子集</li></ul><p id="cd46" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您可以使用这些参数，尤其是<em class="ld"> thresh </em>和<em class="ld"> subset </em>来具体确定哪些行将被删除。</p><p id="f0b6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">Pandas 没有像对列那样在读取时实现这一点的方法，但是我们可以像上面那样在每个块上实现这一点。</p><h1 id="dddd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(3)为每一列设置具体的数据类型</h1><p id="2dc9" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">对于许多初学数据的科学家来说，数据类型并没有被考虑太多。但是一旦开始处理非常大的数据集，处理数据类型就变得至关重要。</p><p id="c00a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">标准的做法是读入数据帧，然后根据需要转换列的数据类型。但是对于一个大的数据集，我们真的需要注意内存空间。</p><p id="3627" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在我们的 CSV 中可能会有一些列，比如浮点数，它们会占据比实际需要更多的空间。例如，如果我们下载了一个预测股票价格的数据集，我们的价格可能会保存为 32 位浮点！</p><p id="3696" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">但是我们<em class="ld">真的</em>需要 32 浮动吗？大多数时候，股票是以两位小数指定的价格买入的。即使我们想做到真正的精确，float16 已经足够了。</p><p id="b610" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">因此，我们不是用列的原始数据类型读入数据集，而是指定我们希望 pandas 在我们的列中使用的数据类型。这样，我们就不会用完超过实际需要的内存。</p><p id="fea4" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这很容易通过使用<code class="fe mz na nb nc b">read_csv()</code>函数中的<strong class="le iu"> dtype </strong>参数来完成。我们可以指定一个字典，其中每个键都是数据集中的一列，每个值都是我们希望使用该键的数据类型。</p><p id="7ae6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这里有一个熊猫的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="23b9" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们的教程到此结束！希望这三个建议能帮你节省很多时间和内存！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="742c" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">喜欢学习？</h1><p id="b88e" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">在<a class="ae ly" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我，我会在那里发布所有最新最棒的人工智能、技术和科学！也在 LinkedIn 上与我联系！</p></div></div>    
</body>
</html>