<html>
<head>
<title>Categorical encoding using Label-Encoding and One-Hot-Encoder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用标签编码和一次性编码器的分类编码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/categorical-encoding-using-label-encoding-and-one-hot-encoder-911ef77fb5bd?source=collection_archive---------0-----------------------#2019-12-06">https://towardsdatascience.com/categorical-encoding-using-label-encoding-and-one-hot-encoder-911ef77fb5bd?source=collection_archive---------0-----------------------#2019-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/194709199588aaa76fbb310389d7f999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*emSbyTsSeHaeFUKc"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@patrickian4?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Patrick Fore</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="968d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在许多机器学习或数据科学活动中，数据集可能包含文本或分类值(基本上是非数值)。例如，具有像红色、橙色、蓝色、白色等值的颜色特征。膳食计划包括早餐、午餐、小吃、晚餐、茶等。很少有算法(如 cat saw、决策树)能够很好地处理分类值，但大多数算法都希望数值能够达到最先进的结果。</p><p id="e477" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你学习人工智能和机器学习的过程中，有一点你会注意到，大多数算法在处理数字输入时效果更好。因此，分析师面临的主要挑战是将文本/分类数据转换为数字数据，并仍然制定算法/模型来理解这些数据。神经网络是深度学习的基础，它期望输入值是数字。</p><p id="0d91" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多方法可以将分类值转换成数值。每种方法都有自己的权衡和对特性集的影响。在此，我将重点介绍两种主要方法:一热编码和标签编码。这两个编码器都是 SciKit-learn 库(使用最广泛的 Python 库之一)的一部分，用于将文本或分类数据转换为模型期望的数值数据，并且可以更好地执行。</p><p id="e30c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文中的代码片段将是 Python 的，因为我更熟悉 Python。如果你需要 R(另一种广泛使用的机器学习语言),那么在评论中说出来。</p><h1 id="3652" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">标签编码</strong></h1><p id="fef4" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这种方法非常简单，它包括将一列中的每个值转换成一个数字。考虑一个桥梁数据集，该数据集具有一个名为 bridge-types 的列，该列具有以下值。尽管数据集中会有更多的列，但为了理解标签编码，我们将只关注一个分类列。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b20b" class="mn lc jg mj b gy mo mp l mq mr"><strong class="mj jh">BRIDGE-TYPE<br/></strong>Arch<br/>Beam<br/>Truss<br/>Cantilever<br/>Tied Arch<br/>Suspension<br/>Cable</span></pre><p id="5fa5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择通过为每个文本值放置一个运行序列来对文本值进行编码，如下所示:</p><figure class="me mf mg mh gt is gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/fe8fc247ee2f5247f2b1289d8df9618c.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*VinegxkUYMzik9GpucWCFA.png"/></div></figure><p id="5771" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们完成了可变桥类型的标签编码。这就是标签编码的全部内容。但是根据数据值和数据类型，标签编码引入了新的问题，因为它使用了数字排序。使用数字的问题在于它们引入了它们之间的联系/比较。显然，各种桥型之间没有关系，但当看数字时，人们可能会认为“缆索”桥型比“拱形”桥型优先。该算法可能会误解数据具有某种等级/顺序 0 &lt; 1 &lt; 2 … &lt; 6，并可能在计算中给予“电缆”比“拱形”桥类型多 6 倍的权重。</p><figure class="me mf mg mh gt is gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/7a2ffc13eeb504076cd79246c2c0e545.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*KdCvKnI9ATVPiozmuRindA.png"/></div></figure><p id="effc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑另一个名为“安全级别”的列。对该列执行标签编码还会导致数字中的顺序/优先级，但方式是正确的。在这里，数字顺序看起来不是现成的，如果算法将安全顺序解释为 0 &lt; 1 &lt; 2 &lt; 3 &lt; 4，即无</p><h1 id="4ed2" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">Python 中的标签编码</strong></h1><p id="215d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf jh">使用类别代码方式:</strong></p><p id="c77d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法要求 category 列的数据类型为“category”。默认情况下，非数字列属于“对象”类型。因此，在使用这种方法之前，您可能必须将类型更改为“category”。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="100d" class="mn lc jg mj b gy mo mp l mq mr"># import required libraries<br/>import pandas as pd<br/>import numpy as np</span><span id="373a" class="mn lc jg mj b gy mu mp l mq mr"># creating initial dataframe<br/>bridge_types = ('Arch','Beam','Truss','Cantilever','Tied Arch','Suspension','Cable')<br/>bridge_df = pd.DataFrame(bridge_types, columns=['Bridge_Types'])</span><span id="7e11" class="mn lc jg mj b gy mu mp l mq mr"># converting type of columns to 'category'<br/>bridge_df['Bridge_Types'] = bridge_df['Bridge_Types'].astype('category')</span><span id="687a" class="mn lc jg mj b gy mu mp l mq mr"># Assigning numerical values and storing in another column<br/>bridge_df['Bridge_Types_Cat'] = bridge_df['Bridge_Types'].cat.codes<br/>bridge_df</span></pre><p id="3cc6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">利用 sci-kit 学习文库的方法:</strong></p><p id="2dab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多数据分析师执行标签编码另一种常见方法是使用 SciKit 学习库。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0dba" class="mn lc jg mj b gy mo mp l mq mr">import pandas as pd<br/>import numpy as np<br/>from sklearn.preprocessing import LabelEncoder</span><span id="f3fe" class="mn lc jg mj b gy mu mp l mq mr"># creating initial dataframe<br/>bridge_types = ('Arch','Beam','Truss','Cantilever','Tied Arch','Suspension','Cable')<br/>bridge_df = pd.DataFrame(bridge_types, columns=['Bridge_Types'])</span><span id="b097" class="mn lc jg mj b gy mu mp l mq mr"># creating instance of labelencoder<br/>labelencoder = LabelEncoder()</span><span id="2079" class="mn lc jg mj b gy mu mp l mq mr"># Assigning numerical values and storing in another column<br/>bridge_df['Bridge_Types_Cat'] = labelencoder.fit_transform(bridge_df['Bridge_Types'])<br/>bridge_df</span></pre><figure class="me mf mg mh gt is gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/c3a94a75c650b9a6aad58632dab9d5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*bXSko0lsut6Q-1fhZGfsew.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">bridge_df with categorical caolumn and label-encoded column values</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="a4cd" class="lb lc jg bd ld le nc lg lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly bi translated">一键编码器</h1><p id="f55b" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">虽然标签编码是直截了当的，但它的缺点是数值可能被算法误解为具有某种层次/顺序。这种排序问题在另一种称为“一键编码”的常见替代方法中得到解决。在这个策略中，每个类别值都被转换成一个新列，并为该列分配一个 1 或 0(表示真/假)值。让我们考虑一下之前的例子，使用一键编码的网桥类型和安全级别。</p><figure class="me mf mg mh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/b452997c66cd2f66eaa81f998cd76177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CK0gfoqvSPBziJcY1TQC6w.png"/></div></div></figure><p id="90a2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上是分类列“桥型”的一键编码值。同样，让我们检查“安全级别”列。</p><figure class="me mf mg mh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/52c9d954a8bc126fc591b7057714bddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jxt_bH504KSYJ3UnVRKY3A.png"/></div></div></figure><p id="73df" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有第一列值(Arch/None)的行将具有‘1’(表示真)，而其他值的列将具有‘0’(表示假)。类似地，对于值与列值匹配的其他行。</p><p id="4f92" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这种方法消除了层次/顺序问题，但也有向数据集添加更多列的缺点。如果在一个类别列中有许多唯一值，这可能会导致列数大幅增加。在上面的例子中，这是可以管理的，但是当编码给出许多列时，管理起来将变得非常困难。</p><h1 id="fae6" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Python 中的一键编码</h1><p id="d5d6" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf jh">使用 sci-kit 学习库方法:</strong></p><p id="71e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SciKit 库中的 OneHotEncoder 只接受数字分类值，因此任何字符串类型的值都应该在 hot 编码之前进行标签编码。因此，以前面示例中的数据帧为例，我们将对 Bridge_Types_Cat 列应用 OneHotEncoder。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7695" class="mn lc jg mj b gy mo mp l mq mr">import pandas as pd<br/>import numpy as np<br/>from sklearn.preprocessing import OneHotEncoder</span><span id="8fd9" class="mn lc jg mj b gy mu mp l mq mr"># creating instance of one-hot-encoder<br/>enc = OneHotEncoder(handle_unknown='ignore')</span><span id="4e0e" class="mn lc jg mj b gy mu mp l mq mr"># passing bridge-types-cat column (label encoded values of bridge_types)<br/>enc_df = pd.DataFrame(enc.fit_transform(bridge_df[['Bridge_Types_Cat']]).toarray())</span><span id="d7ba" class="mn lc jg mj b gy mu mp l mq mr"># merge with main df bridge_df on key values<br/>bridge_df = bridge_df.join(enc_df)<br/>bridge_df</span></pre><figure class="me mf mg mh gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/396028966ce354533a9c1485df57bdde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*ykHF9I4WTmiJXB_Qu-8qEQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Bridge_Type column encoded using SciKit OneHotEncoder</figcaption></figure><p id="78ad" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以从数据框架中删除列“Bridge_Types_Cat”。</p><p id="ae88" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">使用虚拟值方法:</strong></p><p id="6b78" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法更加灵活，因为它允许对任意多的类别列进行编码，并选择如何使用前缀来标记列。正确的命名会使剩下的分析变得简单一点。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d51f" class="mn lc jg mj b gy mo mp l mq mr">import pandas as pd<br/>import numpy as np</span><span id="77a4" class="mn lc jg mj b gy mu mp l mq mr"># creating initial dataframe<br/>bridge_types = ('Arch','Beam','Truss','Cantilever','Tied Arch','Suspension','Cable')<br/>bridge_df = pd.DataFrame(bridge_types, columns=['Bridge_Types'])</span><span id="b965" class="mn lc jg mj b gy mu mp l mq mr"># generate binary values using get_dummies<br/>dum_df = pd.get_dummies(bridge_df, columns=["Bridge_Types"], prefix=["Type_is"] )</span><span id="6240" class="mn lc jg mj b gy mu mp l mq mr"># merge with main df bridge_df on key values<br/>bridge_df = bridge_df.join(dum_df)<br/>bridge_df</span></pre><figure class="me mf mg mh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/9a1008ef3da6771decb3b89569bb3c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CceMA0g31BJcxZaOZVeG_w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Bridge_Type values encoded using dummies approach</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="4868" class="lb lc jg bd ld le nc lg lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly bi translated">结论</h1><p id="fdeb" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">理解对分类变量进行编码各种选择是很重要的，因为每种方法都有自己的优缺点。在数据科学中，这是重要的一步，所以我真的鼓励你在处理分类变量时记住这些想法。对于本文中使用的代码的任何建议或更多细节，请随时发表评论。</p></div></div>    
</body>
</html>