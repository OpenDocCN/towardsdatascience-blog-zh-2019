<html>
<head>
<title>Object detection via color-based image segmentation using python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 python 通过基于颜色的图像分割进行目标检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-detection-via-color-based-image-segmentation-using-python-e9b7c72f0e11?source=collection_archive---------3-----------------------#2019-04-01">https://towardsdatascience.com/object-detection-via-color-based-image-segmentation-using-python-e9b7c72f0e11?source=collection_archive---------3-----------------------#2019-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b52f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 python 和 OpenCV 绘制轮廓的教程。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2bc269053571a6ae062fbe408c2acb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOb7vKuJrF5cdJndTTGuqg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by rawpixel.com from Pexels</figcaption></figure><h1 id="078d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">入门指南</h1><p id="f096" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你已经安装了 jupyter notebook 或者可以运行 python &amp; OpenCV 的 IDE，只需跳到<strong class="ls iu">执行。</strong></p><h2 id="8c30" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">工具</h2><p id="2686" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们今天的英雄是<a class="ae my" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank">蟒蛇</a>。一个免费的开源发行版帮助安装不同的软件包&amp;把它们的混乱整理到隔离的环境中。</p><p id="05d4" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">关于蟒蛇，维基百科的告诉了我们什么</p><blockquote class="ne nf ng"><p id="ea3f" class="lq lr nh ls b lt mz ju lv lw na jx ly ni nb mb mc nj nc mf mg nk nd mj mk ml im bi translated">Anaconda 是用于科学计算(数据科学、机器学习应用、大规模数据处理、预测分析等)的 Python 和 R 编程语言的免费开源发行版。)，<strong class="ls iu">旨在简化包管理和部署</strong>。包版本由包管理系统<em class="it"> conda </em>管理。Anaconda 发行版有 1200 多万用户使用，它包含 1400 多个适用于 Windows、Linux 和 MacOS 的流行数据科学包。</p></blockquote><p id="3215" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">下面是关于如何下载 Anaconda 的详细教程。<br/><a class="ae my" href="https://docs.anaconda.com/anaconda/install/windows/" rel="noopener ugc nofollow" target="_blank">anaconda for Windows</a>&amp;<a class="ae my" href="https://docs.anaconda.com/anaconda/install/linux/" rel="noopener ugc nofollow" target="_blank">anaconda for Linux。</a></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="5c65" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">创造环境</h2><p id="5b12" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">打开 bash (cmd)并键入以下内容</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="db77" class="mm kz it nt b gy nx ny l nz oa">$ conda create -n myEnv python=3</span></pre><p id="2df0" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">当提示下载软件包时，键入<strong class="ls iu"> y </strong>(表示是)。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d5d0" class="mm kz it nt b gy nx ny l nz oa">$ source activate myEnv<br/>$ conda install anaconda<br/>$ conda activate myEnv<br/>$ conda install opencv</span><span id="b4ec" class="mm kz it nt b gy ob ny l nz oa">$ jupyter notebook</span></pre><p id="42ce" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">这将为您在浏览器中打开 jupyter 笔记本。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="780a" class="ky kz it bd la lb oc ld le lf od lh li jz oe ka lk kc of kd lm kf og kg lo lp bi translated">一些重要术语</h1><h2 id="1cc4" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">轮廓</h2><p id="0a33" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">轮廓可以简单地解释为连接所有连续点(连同边界)的曲线，具有相同的颜色或强度。轮廓是形状分析和物体检测与识别的有用工具。</p><h2 id="7bf1" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">阈值</h2><p id="a455" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">对灰度图像应用阈值处理使其成为二值图像。您可以设置一个阈值，低于该阈值的所有值都变成黑色，高于该阈值的所有值都变成白色。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="43f7" class="ky kz it bd la lb oc ld le lf od lh li jz oe ka lk kc of kd lm kf og kg lo lp bi translated">执行</h1><p id="e781" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，您已经拥有了开始工作所需的一切。<br/>我们将从一个简单的例子开始，向您展示基于颜色的分割是如何工作的。</p><p id="b6d8" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">耐心听我说，直到我们找到好东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/2642c196bbd7e7658f4a17ca336e8394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YG9SGOHrhGhzAAIQeKW0HQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">An Ombre circle — image made using photoshop</figcaption></figure><p id="ea98" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">如果你想和我一起试试这个，你可以从这里免费得到这张图片。在下面的代码中，我将把这张图片分割成 17 个灰度级。然后用等高线测量每一层的面积。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6887" class="mm kz it nt b gy nx ny l nz oa">import cv2<br/>import numpy as np</span><span id="b1ae" class="mm kz it nt b gy ob ny l nz oa">def viewImage(image):<br/>    cv2.namedWindow('Display', cv2.WINDOW_NORMAL)<br/>    cv2.imshow('Display', image)<br/>    cv2.waitKey(0)<br/>    cv2.destroyAllWindows()</span><span id="f786" class="mm kz it nt b gy ob ny l nz oa">def grayscale_17_levels (image):<br/>    high = 255<br/>    while(1):  <br/>        low = high - 15<br/>        col_to_be_changed_low = np.array([low])<br/>        col_to_be_changed_high = np.array([high])<br/>        curr_mask = cv2.inRange(gray, col_to_be_changed_low,col_to_be_changed_high)<br/>        gray[curr_mask &gt; 0] = (high)<br/>        high -= 15<br/>        if(low == 0 ):<br/>            break</span><span id="22f3" class="mm kz it nt b gy ob ny l nz oa">image = cv2.imread('./path/to/image')<br/>viewImage(image)<br/>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br/>grayscale_17_levels(gray)<br/>viewImage(gray)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/0e92690e9a1d70a4776a8c60a32bbd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cz4h21aFOnwOXJU-qTF9Sg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The same image segmented into 17 gray levels</figcaption></figure><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c1ce" class="mm kz it nt b gy nx ny l nz oa">def get_area_of_each_gray_level(im):</span><span id="8a11" class="mm kz it nt b gy ob ny l nz oa">## convert image to gray scale (must br done before contouring)<br/>    image = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)<br/>    output = []<br/>    high = 255<br/>    first = True<br/>    while(1):</span><span id="3cb5" class="mm kz it nt b gy ob ny l nz oa">low = high - 15<br/>        if(first == False):</span><span id="4e77" class="mm kz it nt b gy ob ny l nz oa"># making values that are of a greater gray level black <br/>            ## so it won't get detected  <br/>            to_be_black_again_low = np.array([high])<br/>            to_be_black_again_high = np.array([255])<br/>            curr_mask = cv2.inRange(image, to_be_black_again_low, <br/>            to_be_black_again_high)<br/>            image[curr_mask &gt; 0] = (0)<br/>            <br/>        # making values of this gray level white so we can calculate<br/>        # it's area<br/>        ret, threshold = cv2.threshold(image, low, 255, 0)<br/>        contours, hirerchy = cv2.findContours(threshold, <br/>        cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)</span><span id="3230" class="mm kz it nt b gy ob ny l nz oa">if(len(contours) &gt; 0):</span><span id="9267" class="mm kz it nt b gy ob ny l nz oa">output.append([cv2.contourArea(contours[0])])<br/>            cv2.drawContours(im, contours, -1, (0,0,255), 3)</span><span id="53f6" class="mm kz it nt b gy ob ny l nz oa">high -= 15<br/>        first = False<br/>        if(low == 0 ):</span><span id="8064" class="mm kz it nt b gy ob ny l nz oa">break</span><span id="af0d" class="mm kz it nt b gy ob ny l nz oa">return output</span></pre><p id="b0f4" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">在这个函数中，我简单地转换了我想要在这个迭代中轮廓化(突出显示)的灰度范围，将所有在这个范围内的灰度统一为一个灰度。我把除了这个范围之外的所有强度都变成黑色(包括更大和更小的强度)。第二步，我对图像进行阈值处理，这样现在只有我想要轮廓的颜色显示为白色，其他颜色都转换为黑色。这一步在这里变化不大，但必须完成，因为轮廓绘制在黑白(阈值)图像上效果最好。<br/>在应用该步骤(阈值处理)之前，下图将是相同的，除了白色环将是灰色的(第 10 个灰度级的灰度(255–15 * 10))</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/06d5b2cd1b142ac17b19c62eb70b6a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VsDGdEAXGsBLrey44FfX6w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The 10th segment appear alone to be able to calculate its area</figcaption></figure><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a8dd" class="mm kz it nt b gy nx ny l nz oa">image = cv2.imread('./path/to/image')<br/>print(get_area_of_each_gray_level(image))<br/>viewImage(image)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d3993adfa2058ae857b29495b3a13d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--kZITh8Lz3p1Wlm6-cLIw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Contours of the 17 gray levels onto the original image</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/eccaa8963a80e2d510e1347d62b2f937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_Q1Uy7q78ntUEztoxHLOg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Array containing the value of the areas</figcaption></figure><p id="e21c" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">这样我们就获得了每个灰度级的面积。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="54eb" class="ky kz it bd la lb oc ld le lf od lh li jz oe ka lk kc of kd lm kf og kg lo lp bi translated">这真的很重要吗？</h1><p id="bbc6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我们继续之前，我想强调一下这个话题的重要性。<br/>我是一名计算机工程专业的学生，我正在从事一个名为<strong class="ls iu">用于智能肿瘤检测和识别的机器学习项目</strong>。<br/>本项目使用基于颜色的图像分割来帮助计算机学习如何检测肿瘤。当处理 MRI 扫描时，程序必须检测所述 MRI 扫描的癌症水平。它通过将扫描分为不同的灰度级来实现，其中最暗的部分充满癌细胞，最接近白色的部分是健康的部分。然后计算肿瘤对每个灰度级的隶属度。有了这些信息，程序就能够识别肿瘤及其阶段。<br/>这个项目基于软计算、模糊逻辑&amp;机器学习，你可以在<a class="ae my" rel="noopener" target="_blank" href="/fuzzy-logic-and-how-it-is-curing-cancer-dc6bcc961ded">模糊逻辑上了解更多信息，以及它是如何治愈癌症的</a>。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="561c" class="ky kz it bd la lb oc ld le lf od lh li jz oe ka lk kc of kd lm kf og kg lo lp bi translated">目标检测</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/afad307a1e41704d2d08041f80ab58c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_b1mP3awbceOQm5r1fIhg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae my" href="https://www.pexels.com/@goumbik?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Lukas</a> from <a class="ae my" href="https://www.pexels.com/photo/autumn-dry-fall-foliage-628229/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="ed4a" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">你可以从<a class="ae my" href="https://www.pexels.com/photo/autumn-dry-fall-foliage-628229/" rel="noopener ugc nofollow" target="_blank">这里</a>的像素上免费获得这张图片。你只需要修剪它。</p><p id="a28d" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">在这个图像中，我们只想描绘叶子的轮廓。因为这张图像的纹理非常不规则和不均匀，这意味着虽然没有太多的颜色。这幅图像中绿色的强度和亮度都会发生变化。所以，这里最好的办法是把所有这些不同色调的绿色统一成一种色调。这样，当我们应用轮廓时，它将把叶子作为一个整体对象来处理。</p><p id="fba8" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">注意:这是在没有任何预处理的情况下对图像应用轮廓的结果。我只是想让你看看叶子的不均匀性是如何让 OpenCV 不明白这只是一个对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ff7dfdaf76757e31366f2fd1058e96eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcu-1Zanyc0sCH3pQoUWqA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Contouring without pre-processing, 531 contours detected</figcaption></figure><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="7a90" class="mm kz it nt b gy nx ny l nz oa">import cv2<br/>import numpy as np</span><span id="b905" class="mm kz it nt b gy ob ny l nz oa">def viewImage(image):<br/>    cv2.namedWindow('Display', cv2.WINDOW_NORMAL)<br/>    cv2.imshow('Display', image)<br/>    cv2.waitKey(0)<br/>    cv2.destroyAllWindows()</span></pre><p id="e1b5" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">首先，你必须<strong class="ls iu">知道你的颜色的 HSV 表示</strong>，你可以通过把它的 RGB 转换成 HSV 来知道它，就像下面这样。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0f53" class="mm kz it nt b gy nx ny l nz oa">## getting green HSV color representation<br/>green = np.uint8([[[0, 255, 0 ]]])<br/>green_hsv = cv2.cvtColor(green,cv2.COLOR_BGR2HSV)<br/>print( green_hsv)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/a006968e38eea7b10772f9fd15589da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFTAXRtHN-slVK3HtxiFLw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Green HSV color</figcaption></figure><p id="b9ad" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated"><strong class="ls iu">将图像转换为 HSV </strong>:使用 HSV 更容易获得一种颜色的完整范围。HSV，H 代表色调，S 代表饱和度，V 代表数值。我们已经知道绿色是[60，255，255]。世界上所有的果岭都位于[45，100，50]到[75，255，255]之间，即[60-<strong class="ls iu">15</strong>，100，50]到[60+ <strong class="ls iu"> 15 </strong>，255，255]。15 只是一个近似值。<br/>我们将此范围转换为[75，255，<strong class="ls iu"> 200 </strong> ]或任何其他浅色(<strong class="ls iu">第三个值</strong>必须相对较大)，因为这是颜色的亮度，当我们对图像进行阈值处理时，该值将使该部分为白色。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="cb49" class="mm kz it nt b gy nx ny l nz oa">image = cv2.imread('./path/to/image.jpg')<br/>hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)<br/>viewImage(hsv_img) ## 1</span><span id="4ce2" class="mm kz it nt b gy ob ny l nz oa">green_low = np.array([45 , 100, 50] )<br/>green_high = np.array([75, 255, 255])<br/>curr_mask = cv2.inRange(hsv_img, green_low, green_high)<br/>hsv_img[curr_mask &gt; 0] = ([75,255,200])<br/>viewImage(hsv_img) ## 2</span><span id="3c36" class="mm kz it nt b gy ob ny l nz oa">## converting the HSV image to Gray inorder to be able to apply <br/>## contouring<br/>RGB_again = cv2.cvtColor(hsv_img, cv2.COLOR_HSV2RGB)<br/>gray = cv2.cvtColor(RGB_again, cv2.COLOR_RGB2GRAY)<br/>viewImage(gray) ## 3</span><span id="2f90" class="mm kz it nt b gy ob ny l nz oa">ret, threshold = cv2.threshold(gray, 90, 255, 0)<br/>viewImage(threshold) ## 4</span><span id="2f17" class="mm kz it nt b gy ob ny l nz oa">contours, hierarchy =  cv2.findContours(threshold,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<br/>cv2.drawContours(image, contours, -1, (0, 0, 255), 3)<br/>viewImage(image) ## 5</span></pre><div class="kj kk kl km gt ab cb"><figure class="ol kn om on oo op oq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/38b56b58da51b05236cf6d9fba79f931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ERFmobscZPvU9qRCCN3Z7g.png"/></div></figure><figure class="ol kn om on oo op oq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bb612149681bf574999c0b91e54fee78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7tM7qz0F2C9vZowKsvwFwQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk or di os ot">Left: Image just after conversion to HSV (1). Right: Image after applying the mask (color unification)(2)</figcaption></figure></div><div class="ab cb"><figure class="ol kn om on oo op oq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/59f2bbcc4de4f95d8d4e6dd7ee4d2a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FFQvbHBq2eb0WXmQj8nPKA.png"/></div></figure><figure class="ol kn om on oo op oq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/319676860f3f51f1810d17f3310097d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*AqsCsOpnd44Q8PKVa3oNTQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk or di os ot">Left: Image after conversion from HSV to gray(3), Right: Threshold Image, final step(4)</figcaption></figure></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/796cbc06ea49173f7b89af02c6608d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPup8pO4Cf2nDop9ICiNCg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Final contour(5)</figcaption></figure><p id="76d5" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">由于背景中似乎也有不规则性，我们可以用这种方法得到最大的轮廓，最大的轮廓当然是叶子。<br/>我们可以得到轮廓数组中叶子轮廓的索引，从中我们可以得到叶子的面积和中心。<br/>轮廓有许多其他可以利用的特征，如轮廓周长、凸包、边界矩形等。你可以从<a class="ae my" href="https://docs.opencv.org/3.4.2/dd/d49/tutorial_py_contour_features.html" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c015" class="mm kz it nt b gy nx ny l nz oa">def findGreatesContour(contours):<br/>    largest_area = 0<br/>    largest_contour_index = -1<br/>    i = 0<br/>    total_contours = len(contours)<br/>    while (i &lt; total_contours ):<br/>        area = cv2.contourArea(contours[i])<br/>        if(area &gt; largest_area):<br/>            largest_area = area<br/>            largest_contour_index = i<br/>        i+=1<br/>            <br/>    return largest_area, largest_contour_index</span><span id="dd0d" class="mm kz it nt b gy ob ny l nz oa"># to get the center of the contour<br/>cnt = contours[13]<br/>M = cv2.moments(cnt)<br/>cX = int(M["m10"] / M["m00"])<br/>cY = int(M["m01"] / M["m00"])</span><span id="1443" class="mm kz it nt b gy ob ny l nz oa">largest_area, largest_contour_index = findGreatesContour(contours)</span><span id="7132" class="mm kz it nt b gy ob ny l nz oa">print(largest_area)<br/>print(largest_contour_index)</span><span id="ca76" class="mm kz it nt b gy ob ny l nz oa">print(len(contours))</span><span id="a068" class="mm kz it nt b gy ob ny l nz oa">print(cX)<br/>print(cY)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/e5f91b51452bf308f1bc6e0bbaa441e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kd8LEJt0xrcekkauuK5XWw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The result of the print statements</figcaption></figure></div></div>    
</body>
</html>