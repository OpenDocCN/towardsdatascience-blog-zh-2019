<html>
<head>
<title>How to write your first Quine program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写你的第一个 Quine 程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-write-your-first-quine-program-947f2b7e4a6f?source=collection_archive---------6-----------------------#2019-07-26">https://towardsdatascience.com/how-to-write-your-first-quine-program-947f2b7e4a6f?source=collection_archive---------6-----------------------#2019-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9140" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中自我复制程序的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2af27e80e7e101d2bdae0b9f297b0ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVLTR5kscFOBdAxdEQ5nyA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">A quine-relays: a Python program generates a Java program that generates a Ruby program that generates the first Python program</figcaption></figure><p id="7ab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本指南的目的是展示如何编写一个程序，让<strong class="la iu">在没有输入的情况下输出自己的源代码</strong>。这一系列程序被称为奎因。</p><p id="02c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这为什么有意思？因为自我引用的东西总是很有趣:)</p><p id="3778" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建这样的程序有很多方法，但最常见的方法叫做<strong class="la iu">构造方法</strong>。</p><p id="cf46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但首先…这不是一个有效的奎因计划:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/24030a57b7e824a2ab96ef1b223b1782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ve04sSUc4PointOMMJlfbw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">This is not Quine, is cheating in Python</figcaption></figure><p id="8aff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个程序只有在完全不需要输入的情况下才能被称为蒯因。在这种情况下，程序读取其源代码作为文件，从而使其使用自己作为输入。此外，本指南不考虑琐碎的 Quine 程序(如<em class="lv">0 字节程序或<a class="ae lw" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)#Self-evaluating_forms_and_quoting" rel="noopener ugc nofollow" target="_blank">自我评估原子</a>如 Lisp)。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/b73f5d97d9a1f074a8e6507e1c5d84f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*gywsR6ar0fXCyRoHNViN1Q.png"/></div></figure><h1 id="98d8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">建设性蒯因</h1><p id="267f" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">最有效和最容易理解的方法是将程序分成两部分:</p><ul class=""><li id="cefa" class="mv mw it la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">委托打印信息的代码(如 Python 中的<code class="fe ne nf ng nh b">print()</code>函数、Java 中的<code class="fe ne nf ng nh b">System.out.println()</code>或 C++中的全局对象<code class="fe ne nf ng nh b">std::cout</code>)。</li><li id="efa5" class="mv mw it la b lb ni le nj lh nk ll nl lp nm lt na nb nc nd bi translated">可以存储部分源代码的数据结构(如字符串或列表)。注意，程序甚至需要打印字符串周围的引号。</li></ul><p id="d6d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些要求必须根据您想要使用的语言规范进行调整和校准。由于每种语言使用不同的机制来管理数据结构和打印，这里不可能涵盖所有的变化，所以本指南只关注 Python 规范。</p><h1 id="8b75" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">python str()vs repr()</h1><p id="f9a8" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">如果你已经知道这个机制，那么你可以跳过这一节。</p><p id="ee23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">否则，这不仅对完成我们的任务非常重要，而且对更好地理解语言本身的有趣之处也非常重要。</p><h2 id="5895" class="nn lz it bd ma no np dn me nq nr dp mi lh ns nt mk ll nu nv mm lp nw nx mo ny bi translated">str() —人类可读对象</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/0bf6c9e84f97a36bae6f91053cc0077a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSdDNOFveIpv9mHQoBZvDg.png"/></div></div></figure><p id="2a70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/stdtypes.html#str" rel="noopener ugc nofollow" target="_blank">str()</a></code>是 Python 中的标准函数，返回对象的字符串版本。它应该生成一个友好的人类可读的字符串。</p><h2 id="26b9" class="nn lz it bd ma no np dn me nq nr dp mi lh ns nt mk ll nu nv mm lp nw nx mo ny bi translated">repr()-可评估对象</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/5563a6fdfd5fa6d9b7720b275ce91bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wq3EihcX_6AgLnG_JNKGYg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Notice the quotes surrounding the string</figcaption></figure><p id="78c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#repr" rel="noopener ugc nofollow" target="_blank">repr()</a></code>返回表示对象的字符串的可求值版本(通过<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#eval" rel="noopener ugc nofollow" target="_blank">eval()</a></code>函数)。对于字符串，它返回用引号括起来的字符串本身。</p><p id="083d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用下面的语法，同样可以用<code class="fe ne nf ng nh b">printf</code>的方式编写，其中<code class="fe ne nf ng nh b">%r</code>表示用<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#repr" rel="noopener ugc nofollow" target="_blank">repr()</a></code>格式化第二个<code class="fe ne nf ng nh b">%</code>之后的字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/69b1e982bef515f012094ec8db6dd606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gg-yyEH-hyf0mRk28Ia_-Q.png"/></div></div></figure><h1 id="0eed" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">蒯因通过评估</h1><p id="02ff" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这项技术包括使用<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#eval" rel="noopener ugc nofollow" target="_blank">eval()</a></code>功能。我们将要创建的程序的主要模式如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/2258b3232f4e74cdb3e6468e28aa1d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWKx8GARWnkTE8rB3KKm3w.png"/></div></div></figure><p id="4ea9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是我们的数据结构，我们必须在里面放一段代码来打印和评估它自己。为什么我们希望在字符串中也有 eval 函数？因为程序的最后一行使用了<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#eval" rel="noopener ugc nofollow" target="_blank">eval()</a></code>，我们必须在字符串中找到它。</p><p id="5264" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于程序以<code class="fe ne nf ng nh b">variable='</code>开始，我们必须把这部分作为第一件要打印的东西。同样，出于同样的原因，最后要打印的部分必须是<code class="fe ne nf ng nh b">eval(variable)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/3de3c7c2fb4f96cfef4a13fa25660567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7usK7myjF2hZma1AVcJRg.png"/></div></div></figure><p id="8208" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行过程打印了<code class="fe ne nf ng nh b">variable = ??? eval(variable)</code>，这很好，但是我们还必须打印<code class="fe ne nf ng nh b">print()</code>函数、引号和换行符。我们不能在字符串 a <code class="fe ne nf ng nh b">print(...)</code>中再写一次，否则我们将通过无限增加<code class="fe ne nf ng nh b">print(...)</code>进入一个无限递归循环。</p><p id="f4fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以主要思想是再次使用<code class="fe ne nf ng nh b">variable</code>，因为它已经包含了<code class="fe ne nf ng nh b">print()</code>函数！就像这样连接它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5979c9ffd053d98271d7454a8555fa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tp0DUuylhR2Rbe3XSi02GQ.png"/></div></div></figure><p id="0066" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出与源代码非常相似，但是我们必须处理围绕<code class="fe ne nf ng nh b">print()</code>函数的引号和断行。幸运的是，我们现在知道 Python 提供了<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#repr" rel="noopener ugc nofollow" target="_blank">repr()</a></code>函数来返回一个字符串的可求值版本，对于换行符，我们可以添加一个转义的<code class="fe ne nf ng nh b">\n</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/45bf2803c0b5c76ead02193c47cca7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKPGlCLlHbu2L8TdwsStxg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The Quine program perfectly working</figcaption></figure><p id="c56f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是你用 Python 写的第一个 Quine 程序，因为没有输入，输出就是程序的源代码！</p><h1 id="6eb7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">其他奎因计划</h1><p id="b974" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">还有其他方法来创建奎因程序，你可以在下面找到一些简短的描述。</p><h2 id="c7e6" class="nn lz it bd ma no np dn me nq nr dp mi lh ns nt mk ll nu nv mm lp nw nx mo ny bi translated">最短的蟒蛇奎因</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2d9c995c41e03f1cb2592a5936868b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQugIfU2fTd5685oDA6OmA.png"/></div></div></figure><p id="eeeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是 Python 中最著名的 Quine 程序，也是有史以来最短的非平凡程序。请注意，它没有使用<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#eval" rel="noopener ugc nofollow" target="_blank">eval()</a></code>，而是以<code class="fe ne nf ng nh b">printf</code>的方式使用<code class="fe ne nf ng nh b"><a class="ae lw" href="https://docs.python.org/3/library/functions.html#repr" rel="noopener ugc nofollow" target="_blank">repr()</a></code>。与我们的版本没有太大的不同，因为它使用了一种建设性的方法。</p><h2 id="b525" class="nn lz it bd ma no np dn me nq nr dp mi lh ns nt mk ll nu nv mm lp nw nx mo ny bi translated">误差奎因</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/729035608eb5b475e0059b35325df0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxHxxIvpOWkElnoOzxkynA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">This program must be saved as quine.py</figcaption></figure><p id="48f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很有意思。该程序是一个生成<code class="fe ne nf ng nh b">IndentationError</code>的无效 Python 代码。它输出自己，但在<code class="fe ne nf ng nh b">stderr</code>标准流中，而不是在<code class="fe ne nf ng nh b">stdout</code>(在我看来，这仍然是一个有效的查询)。</p><h2 id="9c8e" class="nn lz it bd ma no np dn me nq nr dp mi lh ns nt mk ll nu nv mm lp nw nx mo ny bi translated">奎因继电器</h2><p id="abe9" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">Quine-relay 是用一种语言编写的程序，它输出另一种语言的程序，后者又生成启动程序。</p><p id="2b80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文的特色图片给出了一个直观的例子。</p><p id="7cea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你也可以在这里找到<a class="ae lw" href="https://github.com/mame/quine-relay" rel="noopener ugc nofollow" target="_blank"/>一个用于 128 种编程语言的 Quine-relays 的实际例子！</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h2 id="8115" class="nn lz it bd ma no np dn me nq nr dp mi lh ns nt mk ll nu nv mm lp nw nx mo ny bi translated">你能用你最喜欢的语言写一个蒯因程序吗？</h2></div></div>    
</body>
</html>