<html>
<head>
<title>Chatbots aren’t as difficult to make as You Think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聊天机器人没有你想象的那么难制造</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/chatbots-arent-as-difficult-to-make-as-you-think-f7f90255b993?source=collection_archive---------12-----------------------#2019-04-16">https://towardsdatascience.com/chatbots-arent-as-difficult-to-make-as-you-think-f7f90255b993?source=collection_archive---------12-----------------------#2019-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a970" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/nlp-learning-series" rel="noopener" target="_blank"> NLP 学习系列</a></h2><div class=""/><div class=""><h2 id="1ff7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">达斯·维德的聊天机器人指南</h2></div><p id="0464" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">聊天机器人。聊天机器人。到处都是聊天机器人。</p><p id="994e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">每个网站都必须执行。每个数据科学家都必须了解它们。每当我们谈论人工智能的时候；聊天机器人必须讨论。</p><p id="55d3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">但他们会威胁到这个领域的新手。甚至在我们开始着手解决问题之前，我们就已经纠结于许多问题了。</em></p><p id="204e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">它们很难创造吗？在使用这些技术之前，我应该了解哪些技术？</p><p id="b410" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我们最终沮丧地阅读了网上那么多的帖子，却一事无成。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/a5136f64154541e117e86df9828d6b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gli8FvAt8jupGoLZ"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Photo by <a class="ae me" href="https://unsplash.com/@kasiape?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Katarzyna Pe</a> on <a class="ae me" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3165" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">我向你保证，这不会是“那种帖子”。</em></p><p id="594d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将尝试从我在<a class="ae me" href="https://coursera.pxf.io/yRPoZB" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">高级机器学习专业化</strong>的<a class="ae me" href="https://coursera.pxf.io/yRPoZB" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">自然语言处理</strong> </a>课程中的一个项目中提取一些知识。</a></p><p id="7260" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以在我开始之前，让我先说不要被围绕聊天机器人的炒作和谜团吓倒。他们使用了我们大多数人都已经知道的非常简单的自然语言处理技术。</p><p id="11a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你不知道，欢迎你来看看我的<a class="ae me" href="https://towardsdatascience.com/tagged/nlp-learning-series" rel="noopener" target="_blank"><strong class="kt jd"/></a>NLP 学习系列，在这里我用<a class="ae me" href="https://mlwhiz.com/blog/2019/02/08/deeplearning_nlp_conventional_methods/" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd"/></a><a class="ae me" href="https://mlwhiz.com/blog/2019/03/09/deeplearning_architectures_text_classification/" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd">深度学习</strong> </a>和<a class="ae me" href="https://mlwhiz.com/blog/2019/03/30/transfer_learning_text_classification/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">迁移学习</strong> </a> <strong class="kt jd"> </strong>的方法详细地讲解了文本分类的问题。</p><p id="ca22" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">另外，如果你对在工作中使用的定制深度学习工作站或服务器感兴趣，Exxact Corporation 有一系列基于人工智能的解决方案，起价为 3700 美元，带有几个英伟达 RTX 30 系列 GPU，3 年保修和深度学习软件堆栈。</p><h1 id="c53d" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">聊天机器人的简短介绍</h1><p id="e829" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">因此，我们可以从逻辑上将聊天机器人分为以下两类。</p><ul class=""><li id="d23d" class="nc nd it kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated"><strong class="kt jd">基于数据库/常见问题解答的</strong> —我们有一个带有一些问题和答案的数据库，我们希望用户可以使用自然语言查询数据库。这就是你在大多数银行网站上找到的那种回答常见问题的聊天机器人。</li><li id="72ad" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><strong class="kt jd">基于聊天的</strong> —模拟与用户的对话。这些聊天机器人给聊天机器人带来了乐趣。我们可以使用 Seq-2-Seq 模型和编码器-解码器架构来创建这样的机器人。</li></ul></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="8fb9" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">StackOverflow 聊天机器人</h1><p id="9d55" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">我们将创建一个<strong class="kt jd">对话聊天机器人</strong>，它将能够:</p><ul class=""><li id="b85e" class="nc nd it kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated"><strong class="kt jd">回答编程相关问题</strong>(使用 StackOverflow 数据集)</li><li id="adee" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><strong class="kt jd">闲聊</strong>并就所有与编程无关的问题进行模拟对话</li></ul><p id="69b1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦你将它安装并运行，我们最终的聊天机器人应该是这样的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oc"><img src="../Images/50d6fbc9c30a7657150794b635ed28de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*71Fr8PjGrbQaYjlL.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">The Final Chatbot we will create</figcaption></figure><p id="06d6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">好像挺好玩的。</p><p id="51bd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将借助 Telegram 和 Chatterbot 等资源来构建我们的聊天机器人。因此，在我们开始之前，我应该让您开始使用这两个工具。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="de2c" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">1.电报:</h1><p id="9a7f" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">来自<a class="ae me" href="https://telegram.org/faq#q-what-is-telegram-what-do-i-do-here" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">网站</strong> </a>:</p><blockquote class="od oe of"><p id="d69e" class="kr ks ln kt b ku kv kd kw kx ky kg kz og lb lc ld oh lf lg lh oi lj lk ll lm im bi translated"><em class="it"> Telegram 是一款专注于速度和安全的消息应用，它超级快速、简单且免费。您可以同时在所有设备上使用 Telegram 您的信息可以在任意数量的手机、平板电脑或电脑之间无缝同步。</em></p></blockquote><p id="a8b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于我们来说，<strong class="kt jd"> <em class="ln"> Telegram 为我们提供了一个创建聊天机器人 UI </em> </strong>的简单方法。它为我们提供了一个访问令牌，我们将使用它来连接到 Telegram 应用程序后端并运行我们的 chatbot 逻辑。</p><p id="5f05" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">自然，我们需要一个窗口，在那里我们可以向聊天机器人写问题，这是通过电报提供的。此外，telegram 通过与我们的聊天机器人逻辑进行通信来为聊天机器人提供动力。以上截图仅取自 telegram app。</p><h1 id="0c76" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">设置电报:</h1><p id="c666" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">如果你还不明白它是如何工作的，也不要担心；在我们前进的过程中，我会试着给出一步一步的指示。</p><ul class=""><li id="0759" class="nc nd it kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">第一步:<a class="ae me" href="https://macos.telegram.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">在笔记本电脑上下载安装</strong> </a>电报 App。</li><li id="842c" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">第二步:在 Chrome 中打开这个<a class="ae me" href="https://telegram.me/BotFather" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">链接</strong> </a>，随后在你的 Telegram 应用中打开，与僵尸父亲对话。</li><li id="a4a0" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">第三步:以上步骤将带你到一个名为 Botfather 的聊天机器人，它可以帮助你创建一个新的机器人。<strong class="kt jd"> <em class="ln">盗梦空间有人吗？</em> </strong>大概会是这个样子。</li><li id="5db2" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">a)使用命令“/newbot”设置一个新的机器人</li><li id="ca32" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">b)为您的机器人创建一个名称。</li><li id="477e" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">c)为你的机器人创建一个用户名。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oj"><img src="../Images/f740790b4621d45c9e183ce37b2b2eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uBdguffK3nO-gLy0.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Inception!!!</figcaption></figure><ul class=""><li id="9cb4" class="nc nd it kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">步骤 4:您将获得一个 bot 的访问令牌。<strong class="kt jd">在安全的地方复制令牌。</strong></li><li id="0621" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">第五步:点击“t.me/MLWhizbot”链接，在新窗口中打开与聊天机器人的聊天。</li></ul><p id="b3f3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，如果你试图与聊天机器人交流，你不会得到任何答案。这就是它应该的样子，因为我们还没有写任何逻辑。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/566f555771ca201e09be5b6e609aa133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*ktKnylmavYUzE4p-I61HNg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Unresponsive…. Not Cool</figcaption></figure><p id="6e5c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但这一点也不好玩。是吗？让我们用 python 变变魔术，让它反应灵敏。</p><h1 id="1756" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">让我们的电报聊天机器人响应</h1><p id="c8af" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">创建一个文件<code class="fe ol om on oo b">main.py</code>并将下面的代码放入其中。不要担心，这里的大部分代码是样板代码，让我们的聊天机器人使用访问令牌与电报通信。</p><p id="78dd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们只需要担心实现类<code class="fe ol om on oo b">SimpleDialogueManager</code>。这个类包含一个名为<code class="fe ol om on oo b">generate_answer</code>的函数，我们将在这里编写我们的机器人逻辑。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Simple main.py code</figcaption></figure><p id="fbe9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，您可以在终端窗口中运行文件<code class="fe ol om on oo b">main.py</code>来使您的 bot 做出响应。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="fef2" class="ov mg it oo b gy ow ox l oy oz">$ python main.py</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pa"><img src="../Images/d9176ead0c19ea8843d3078d2c18d6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VL-IHbVc9jbxMZgo.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">A very Naive Chatbot</figcaption></figure><p id="853d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">很好。它遵循简单的逻辑。但好消息是我们的机器人现在做了一些事情。</p><p id="0059" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你到了这里，稍微祝贺一下自己吧。我们在这里取得的成就是不平凡的。</p><p id="e0e6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">另外，看看我们运行<code class="fe ol om on oo b">main.py</code>文件的终端窗口。每当用户提问时，我们会得到下面的那种字典，其中包含唯一的聊天 ID、聊天文本、用户信息等。我们以后可以根据需要使用它。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="2c13" class="ov mg it oo b gy ow ox l oy oz">Update content: {'update_id': 484689748, 'message': {'message_id': 115, 'from': {'id': 844474950, 'is_bot': False, 'first_name': 'Rahul', 'last_name': 'Agarwal', 'language_code': 'en'}, 'chat': {'id': 844474950, 'first_name': 'Rahul', 'last_name': 'Agarwal', 'type': 'private'}, 'date': 1555266010, 'text': 'What is 2+2'}}</span></pre><p id="62b5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">到目前为止，我们所做的都是一些设置和工程方面的工作。</p><p id="d588" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，如果我们能在<code class="fe ol om on oo b">main.py</code>中的<code class="fe ol om on oo b">generate_answer</code>函数中编写一些合理的数据科学逻辑，我们应该有一个像样的聊天机器人。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="070b" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">2.说话机器人计算机程序</h1><p id="c8f3" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">从文档中:</p><blockquote class="od oe of"><p id="d6f7" class="kr ks ln kt b ku kv kd kw kx ky kg kz og lb lc ld oh lf lg lh oi lj lk ll lm im bi translated"><em class="it"> ChatterBot 是一个 Python 库，可以很容易地对用户的输入生成自动响应。ChatterBot 使用一系列机器学习算法来产生不同类型的反应。这使得开发人员可以轻松创建聊天机器人，并自动与用户对话。</em></p></blockquote><p id="1572" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">很简单。这是一个黑盒系统，可以为我们的聊天机器人提供聊天类型问题的回答。T15】</p><p id="db04" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最棒的是，它很容易与我们当前的流程集成。</p><p id="f102" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们也可以训练一个 SeqtoSeq 模型来做同样的事情。也许我会在以后的文章中这样做。我跑题了。</p><p id="c8c9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以，让我们安装它:</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="1d33" class="ov mg it oo b gy ow ox l oy oz">$ pip install chatterbot</span></pre><p id="0591" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">并将 main.py 中的<code class="fe ol om on oo b">SimpleDialogueManager</code>类更改为以下内容。我们可以有一个机器人，它可以与用户交谈并回答随机查询。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="3692" class="ov mg it oo b gy ow ox l oy oz">class SimpleDialogueManager(object):<br/>    """<br/>    This is a simple dialogue manager to test the telegram bot.<br/>    The main part of our bot will be written here.<br/>    """<br/>    def __init__(self):<br/>        from chatterbot import ChatBot<br/>        from chatterbot.trainers import ChatterBotCorpusTrainer<br/>        chatbot = ChatBot('MLWhizChatterbot')<br/>        trainer = ChatterBotCorpusTrainer(chatbot)<br/>        trainer.train('chatterbot.corpus.english')<br/>        self.chitchat_bot = chatbot</span><span id="8a08" class="ov mg it oo b gy pb ox l oy oz"><strong class="oo jd">    def generate_answer(self, question): <br/>        response = self.chitchat_bot.get_response(question)<br/>        return response</strong></span></pre><p id="0c17" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b">init</code>中的代码使用 chatterbot 实例化一个聊天机器人，并在<a class="ae me" href="https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data/english" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">提供的英语语料库</strong> </a>数据上训练它。</p><p id="b9ef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">数据很小，但是你也可以在你的数据集上训练它。就看<a class="ae me" href="https://chatterbot.readthedocs.io/en/stable/training.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">文档</strong> </a>。然后，我们可以在<code class="fe ol om on oo b">generate_answer</code>函数中使用 Chatterbot 聊天机器人给出我们的响应。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pc"><img src="../Images/34ab44820c45f7aa2462c5e8b62fb4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jf1H0bf2RlF4e2-w.png"/></div></div></figure><p id="475f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我必须说，不要太“巴阿阿阿阿阿阿阿”了。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="37a4" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">创建我们的 StackOverflow 聊天机器人</h1><p id="1725" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">好了，我们终于到了可以做自己喜欢的事情的阶段。使用数据科学推动我们的应用/聊天机器人。</p><p id="2e3a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们从创建一个我们下一步要做的粗略架构开始。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pd"><img src="../Images/468fbf8ccf7153c9c1ae593588ee7c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5WP1GbAliLXe0qxb.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">The Architecture of our StackOverflow Chatbot</figcaption></figure><p id="ccb8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们需要创建两个分类器，并将它们保存为<code class="fe ol om on oo b">.pkl</code>文件。</p><ol class=""><li id="3676" class="nc nd it kt b ku kv kx ky la ne le nf li ng lm pe ni nj nk bi translated"><strong class="kt jd">意图分类器</strong>:该分类器将预测一个问题是否是堆栈溢出问题。如果不是堆栈溢出问题，我们让 Chatterbot 来处理。</li><li id="d654" class="nc nd it kt b ku nl kx nm la nn le no li np lm pe ni nj nk bi translated"><strong class="kt jd">编程语言(标签)分类器</strong>:如果问题是堆栈溢出问题，该分类器将预测问题属于哪种语言。我们这样做是为了只在我们的数据库中搜索那些语言问题。</li></ol><p id="5443" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了简单起见，我们将创建简单的 TFIDF 模型。我们需要保存这些 TFIDF 矢量器。</p><p id="3d51" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们还需要存储每个问题的单词向量，以便稍后进行相似度计算。</p><p id="124b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们一步一步地经历这个过程。您可以在我的<a class="ae me" href="https://github.com/MLWhiz/data_science_blogs/tree/master/chatbot" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">项目资源库</strong> </a>中的这个<a class="ae me" href="https://github.com/MLWhiz/data_science_blogs/blob/master/chatbot/Model%20Creation.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> jupyter 笔记本</strong> </a>中获取完整代码。</p><h2 id="d76c" class="ov mg it bd mh pf pg dn ml ph pi dp mp la pj pk mr le pl pm mt li pn po mv iz bi translated">第一步。读取和可视化数据</h2><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="8b80" class="ov mg it oo b gy ow ox l oy oz">dialogues = pd.read_csv("data/dialogues.tsv",sep="\t")<br/>posts = pd.read_csv("data/tagged_posts.tsv",sep="\t")</span><span id="9837" class="ov mg it oo b gy pb ox l oy oz">dialogues.head()</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pp"><img src="../Images/f54df7881ffa714c000ee1c54a15581f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EN0d7YBTUf4fXAKTcNX7Xw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Dialogues Data</figcaption></figure><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="d6cb" class="ov mg it oo b gy ow ox l oy oz">posts.head()</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pq"><img src="../Images/463b58881ea3b828d2e618fe837f6125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_otMtW9lKvjJOIAgFs0nw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">StackOverflow Posts data</figcaption></figure><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="7ad3" class="ov mg it oo b gy ow ox l oy oz">print("Num Posts:",len(posts))<br/>print("Num Dialogues:",len(dialogues))</span></pre><p id="1f82" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">Num Posts: 2171575<br/>Num Dialogues: 218609</em></code></p><h2 id="5b5a" class="ov mg it bd mh pf pg dn ml ph pi dp mp la pj pk mr le pl pm mt li pn po mv iz bi translated">步骤 2:为意图分类器创建训练数据—聊天/堆栈流问题</h2><p id="e406" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">为此，我们将创建一个带有逻辑回归的 TFIDF 模型。如果你想了解 TFIDF 型号，你可以在这里阅读<a class="ae me" href="https://mlwhiz.com/blog/2019/02/08/deeplearning_nlp_conventional_methods/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="aedf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们也可以使用一种深度学习模型或迁移学习方法来做到这一点，但由于这篇文章的主要目标是启动并运行聊天机器人，而不是太担心准确性，我们只使用基于 TFIDF 的模型。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="6a33" class="ov mg it oo b gy ow ox l oy oz">texts  =  list(dialogues[:200000].text.values) + list(posts[:200000].title.values)<br/>labels =  ['dialogue']*200000 + ['stackoverflow']*200000<br/>data = pd.DataFrame({'text':texts,'target':labels})</span><span id="168b" class="ov mg it oo b gy pb ox l oy oz">def text_prepare(text):<br/>    """Performs tokenization and simple preprocessing."""<br/>    <br/>    replace_by_space_re = re.compile('[/(){}\[\]\|@,;]')<br/>    bad_symbols_re = re.compile('[^0-9a-z #+_]')<br/>    stopwords_set = set(stopwords.words('english'))</span><span id="48ce" class="ov mg it oo b gy pb ox l oy oz">    text = text.lower()<br/>    text = replace_by_space_re.sub(' ', text)<br/>    text = bad_symbols_re.sub('', text)<br/>    text = ' '.join([x for x in text.split() if x and x not in stopwords_set])</span><span id="9039" class="ov mg it oo b gy pb ox l oy oz">    return text.strip()</span><span id="8d33" class="ov mg it oo b gy pb ox l oy oz"># Doing some data cleaning<br/>data['text'] = data['text'].apply(lambda x : text_prepare(x))</span><span id="b3f6" class="ov mg it oo b gy pb ox l oy oz">X_train, X_test, y_train, y_test = train_test_split(data['text'],data['target'],test_size = .1 , random_state=0)</span><span id="c72c" class="ov mg it oo b gy pb ox l oy oz">print('Train size = {}, test size = {}'.format(len(X_train), len(X_test)))</span></pre><p id="855f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">Train size = 360000, test size = 40000</em></code></p><h2 id="cb31" class="ov mg it bd mh pf pg dn ml ph pi dp mp la pj pk mr le pl pm mt li pn po mv iz bi translated">第三步。创建意图分类器</h2><p id="2cdb" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">这里，我们创建一个 TFIDF 矢量器来创建要素，并训练一个逻辑回归模型来创建 intent_classifier。请注意我们是如何将 TFIDF 矢量器保存到<code class="fe ol om on oo b">resources/tfidf.pkl</code>并将 intent_classifier 保存到<code class="fe ol om on oo b">resources/intent_clf.pkl</code>的。</p><p id="2921" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦我们要为最终的聊天机器人编写<code class="fe ol om on oo b">SimpleDialogueManager</code>类，我们将需要这些文件。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="42a6" class="ov mg it oo b gy ow ox l oy oz"># We will keep our models and vectorizers in this folder<br/>!mkdir resources</span><span id="4b48" class="ov mg it oo b gy pb ox l oy oz">def tfidf_features(X_train, X_test, vectorizer_path):<br/>    """Performs TF-IDF transformation and dumps the model."""<br/>    tfv = TfidfVectorizer(dtype=np.float32, min_df=3,  max_features=None, <br/>            strip_accents='unicode', analyzer='word',token_pattern=r'\w{1,}',<br/>            ngram_range=(1, 3), use_idf=1,smooth_idf=1,sublinear_tf=1,<br/>            stop_words = 'english')<br/>    <br/>    X_train = tfv.fit_transform(X_train)<br/>    X_test = tfv.transform(X_test)<br/>    <br/>    pickle.dump(tfv,vectorizer_path)<br/>    return X_train, X_test</span><span id="d972" class="ov mg it oo b gy pb ox l oy oz">X_train_tfidf, X_test_tfidf = tfidf_features(X_train, X_test, open("resources/tfidf.pkl",'wb'))</span><span id="f709" class="ov mg it oo b gy pb ox l oy oz">intent_recognizer = LogisticRegression(C=10,random_state=0)<br/>intent_recognizer.fit(X_train_tfidf,y_train)<br/>pickle.dump(intent_recognizer, open("resources/intent_clf.pkl" , 'wb'))</span><span id="2c56" class="ov mg it oo b gy pb ox l oy oz"># Check test accuracy.<br/>y_test_pred = intent_recognizer.predict(X_test_tfidf)<br/>test_accuracy = accuracy_score(y_test, y_test_pred)<br/>print('Test accuracy = {}'.format(test_accuracy))</span></pre><p id="5063" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">Test accuracy = 0.989825</em></code></p><p id="d6dc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">意图分类器有相当好的 98%的测试准确率。TFIDF 没那么差。</p><h2 id="150d" class="ov mg it bd mh pf pg dn ml ph pi dp mp la pj pk mr le pl pm mt li pn po mv iz bi translated">步骤 4:创建编程语言分类器</h2><p id="d4f0" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">让我们首先为编程语言分类器创建数据，然后使用 TFIDF 特性训练一个逻辑回归模型。我们将这个标签分类器保存在位置<code class="fe ol om on oo b">resources/tag_clf.pkl</code>。</p><p id="f42e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们做这一步主要是因为我们不想对整个问题数据库进行相似性计算，而只是根据语言标签对问题子集进行相似性计算。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="06b4" class="ov mg it oo b gy ow ox l oy oz"># creating the data for Programming Language classifier <br/>X = posts['title'].values<br/>y = posts['tag'].values</span><span id="f0ba" class="ov mg it oo b gy pb ox l oy oz">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)<br/>print('Train size = {}, test size = {}'.format(len(X_train), len(X_test)))</span></pre><p id="0c3b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">Train size = 1737260, test size = 434315</em></code></p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="8acc" class="ov mg it oo b gy ow ox l oy oz">vectorizer = pickle.load(open("resources/tfidf.pkl", 'rb'))<br/>X_train_tfidf, X_test_tfidf = vectorizer.transform(X_train), vectorizer.transform(X_test)<br/>tag_classifier = OneVsRestClassifier(LogisticRegression(C=5,random_state=0))<br/>tag_classifier.fit(X_train_tfidf,y_train)<br/>pickle.dump(tag_classifier, open("resources/tag_clf.pkl", 'wb'))</span><span id="9cc7" class="ov mg it oo b gy pb ox l oy oz"># Check test accuracy.<br/>y_test_pred = tag_classifier.predict(X_test_tfidf)<br/>test_accuracy = accuracy_score(y_test, y_test_pred)<br/>print('Test accuracy = {}'.format(test_accuracy))</span></pre><p id="bf65" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">Test accuracy = 0.8043816124241622</em></code></p><p id="f23f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">又不赖。</p><h2 id="34bc" class="ov mg it bd mh pf pg dn ml ph pi dp mp la pj pk mr le pl pm mt li pn po mv iz bi translated">步骤 5:存储问题数据库嵌入</h2><p id="2f7d" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">人们可以使用来自 Google 的<a class="ae me" href="https://code.google.com/archive/p/word2vec/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">预训练词向量</strong> </a>或者通过使用他们的数据训练他们的嵌入来获得更好的结果。</p><p id="9cd9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因为准确度和精确度不是这篇文章的主要目标，我们将使用预训练向量。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="2f42" class="ov mg it oo b gy ow ox l oy oz"># Load Google's pre-trained Word2Vec model.<br/>model = gensim.models.KeyedVectors.load_word2vec_format('GoogleNews-vectors-negative300.bin', binary=True)</span></pre><p id="b6d4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们希望将每个问题转换为一个嵌入并存储它们，这样我们就不用每次都计算整个数据集的嵌入。</p><p id="622b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">本质上，每当用户提出堆栈溢出问题时，我们都希望使用某种距离相似性度量来获得最相似的问题。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="86fc" class="ov mg it oo b gy ow ox l oy oz">def <strong class="oo jd">question_to_vec</strong>(question, embeddings, dim=300):<br/>    """<br/>        question: a string<br/>        embeddings: dict where the key is a word and a value is its' embedding<br/>        dim: size of the representation</span><span id="9114" class="ov mg it oo b gy pb ox l oy oz">        result: vector representation for the question<br/>    """<br/>    word_tokens = question.split(" ")<br/>    question_len = len(word_tokens)<br/>    question_mat = np.zeros((question_len,dim), dtype = np.float32)<br/>    <br/>    for idx, word in enumerate(word_tokens):<br/>        if word in embeddings:<br/>            question_mat[idx,:] = embeddings[word]<br/>            <br/>    # remove zero-rows which stand for OOV words       <br/>    question_mat = question_mat[~np.all(question_mat == 0, axis = 1)]<br/>    <br/>    # Compute the mean of each word along the sentence<br/>    if question_mat.shape[0] &gt; 0:<br/>        vec = np.array(np.mean(question_mat, axis = 0), dtype = np.float32).reshape((1,dim))<br/>    else:<br/>        vec = np.zeros((1,dim), dtype = np.float32)<br/>        <br/>    return vec</span><span id="4c21" class="ov mg it oo b gy pb ox l oy oz">counts_by_tag = posts.groupby(by=['tag'])["tag"].count().reset_index(name = 'count').sort_values(['count'], ascending = False)<br/>counts_by_tag = list(zip(counts_by_tag['tag'],counts_by_tag['count']))<br/>print(counts_by_tag)</span></pre><p id="6ac6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">[('c#', 394451), ('java', 383456), ('javascript', 375867), ('php', 321752), ('c_cpp', 281300), ('python', 208607), ('ruby', 99930), ('r', 36359), ('vb', 35044), ('swift', 34809)]</em></code></p><p id="f5ac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将嵌入保存在一个名为<code class="fe ol om on oo b">resources/embeddings_folder</code>的文件夹中。</p><p id="3b9b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该文件夹将包含每个标记的. pkl 文件。例如，其中一个文件将是<code class="fe ol om on oo b">python.pkl</code>。</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="434a" class="ov mg it oo b gy ow ox l oy oz">! mkdir resources/embeddings_folder</span><span id="897f" class="ov mg it oo b gy pb ox l oy oz">for tag, count in counts_by_tag:<br/>    tag_posts = posts[posts['tag'] == tag]<br/>    tag_post_ids = tag_posts['post_id'].values<br/>    tag_vectors = np.zeros((count, 300), dtype=np.float32)<br/>    for i, title in enumerate(tag_posts['title']):<br/>        tag_vectors[i, :] = question_to_vec(title, model, 300)<br/>    # Dump post ids and vectors to a file.<br/>    filename = 'resources/embeddings_folder/'+ tag + '.pkl'<br/>    pickle.dump((tag_post_ids, tag_vectors), open(filename, 'wb'))</span></pre><p id="56b1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们现在已经接近尾声了。我们需要有一个函数来获取数据集中最相似问题的<em class="ln"> post id </em>，因为我们知道问题和问题的编程语言。这是:</p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="85f0" class="ov mg it oo b gy ow ox l oy oz">def <strong class="oo jd">get_similar_question</strong>(question,tag):<br/>    # get the path where all question embeddings are kept and load the post_ids and post_embeddings<br/>    embeddings_path = 'resources/embeddings_folder/' + tag + ".pkl"<br/>    post_ids, post_embeddings = pickle.load(open(embeddings_path, 'rb'))<br/>    # Get the embeddings for the question<br/>    question_vec = question_to_vec(question, model, 300)<br/>    # find index of most similar post<br/>    best_post_index = pairwise_distances_argmin(question_vec,<br/>                                                post_embeddings)<br/>    # return best post id<br/>    return post_ids[best_post_index]</span><span id="865f" class="ov mg it oo b gy pb ox l oy oz">get_similar_question("how to use list comprehension in python?",'python')</span></pre><p id="0a6c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ol om on oo b"><em class="ln">array([5947137])</em></code></p><p id="d052" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以使用这个帖子 ID，在<a class="ae me" href="https://stackoverflow.com/questions/5947137" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd">https://stackoverflow.com/questions/5947137</strong></a>找到这个问题</p><p id="889e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">相似性检查器建议的问题有实际的文本:“我如何使用列表理解来扩展 python 中的列表？[重复]"</p><p id="246a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">还不错，但是如果我们训练我们的嵌入或者使用<a class="ae me" href="https://github.com/facebookresearch/StarSpace" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> starspace </strong> </a>嵌入，我们可以做得更好。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="c718" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">组装拼图— SimpleDialogueManager 类</h1><p id="50b5" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">最后，我们到达了整个练习的终点。现在，我们必须在我们的<code class="fe ol om on oo b">SimpleDialogueManager</code>类中安装拼图的所有部分。这是代码。</p><p id="081e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">仔细阅读评论，了解各个部分是如何组合在一起，构建一个完整的逻辑的。只看初始化和 generate_answer 函数。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="bfae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">点击获取整个<code class="fe ol om on oo b"><a class="ae me" href="https://github.com/MLWhiz/data_science_blogs/blob/master/chatbot/main.py" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd">main.py</strong></a><strong class="kt jd"> </strong></code>的代码供你使用和查看。只需使用运行整个<code class="fe ol om on oo b">main.py</code></p><pre class="lp lq lr ls gt or oo os ot aw ou bi"><span id="c341" class="ov mg it oo b gy ow ox l oy oz">$ python main.py</span></pre><p id="f8f2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们的机器人能够访问所有的资源，我们将让它启动并运行。耶！</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/5303faacf54af5618598909fc6a4404b.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*JlS_e6NuTt1bh6-G.gif"/></div></figure><p id="77f4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">同样，这里是 GitHub <a class="ae me" href="https://github.com/MLWhiz/data_science_blogs/tree/master/chatbot" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">库</strong> </a>的链接</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="4cfe" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">可能性真是无穷无尽</h1><p id="0ba0" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">这只是一个小的演示项目，演示你可以用聊天机器人做什么。一旦你认识到后台只是 python，你可以做更多的事情。</p><ul class=""><li id="7397" class="nc nd it kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">一个想法是在所有服务器上运行聊天机器人脚本，我必须直接从 telegram 运行系统命令。我们可以使用<code class="fe ol om on oo b">os.system</code>来运行任何系统命令。再见宋承宪。</li><li id="1f1e" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">你可以通过使用简单的基于关键字的意图让聊天机器人完成一些日常任务。这只是简单的逻辑。了解天气、板球比分或者新上映的电影。不管什么能让你开心。</li><li id="a38e" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">或者尝试在你的网站中集成基于电报的聊天机器人。参见<a class="ae me" href="https://livechatbot.net/#" rel="noopener ugc nofollow" target="_blank">中的<strong class="kt jd"> livechatbot </strong>中的</a></li><li id="d321" class="nc nd it kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">或者试着从中获得乐趣。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ps"><img src="../Images/6b2ca50c44517f3b6317a67661d0ca7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p728L9ay_oPdgXht.jpg"/></div></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="35da" class="mf mg it bd mh mi nx mk ml mm ny mo mp ki nz kj mr kl oa km mt ko ob kp mv mw bi translated">结论</h1><p id="c14b" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">在这里，我们学习了如何创建一个简单的聊天机器人。它工作正常。我们可以通过提高分类器准确性、处理边缘情况、使其响应更快、使用更好的相似性度量/嵌入，或者添加更多逻辑来处理更多用例，来对当前的聊天机器人进行大量改进。</p><p id="fad9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">但事实不变。聊天机器人中的人工智能只是简单的人类逻辑，而不是魔法。</em> </strong></p><p id="c124" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我密切关注了这个<a class="ae me" href="https://coursera.pxf.io/yRPoZB" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">课程</strong> </a>中的一个项目来创建这个聊天机器人。</p><p id="5963" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你有困惑，一定要看看这个课程，或者在评论中告诉我你的问题。我一定会尽力帮忙。</p><p id="bd6a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<a class="ae me" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="kt jd">媒体</strong> </a>关注我，或者订阅我的<a class="ae me" href="https://mlwhiz.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">博客</strong> </a>了解我接下来的帖子。</p><p id="471d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">再见！！</p></div></div>    
</body>
</html>