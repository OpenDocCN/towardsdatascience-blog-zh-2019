<html>
<head>
<title>A Brief Intro to Studying Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习算法的简要介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-part-1-c1e148dfa3f?source=collection_archive---------27-----------------------#2019-08-07">https://towardsdatascience.com/algorithms-part-1-c1e148dfa3f?source=collection_archive---------27-----------------------#2019-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将(1)介绍研究算法背后的基本推理，(2)介绍大 O 符号，(3)对 Karatsuba 的算法做一个简要的分析。</p><p id="236a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的帖子大致遵循了 Tim Roughgarden 的算法课程，如果你想为理解数据结构和算法设计打下坚实的基础，我强烈推荐你学习这些课程。</p><ol class=""><li id="4ddd" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">什么是算法，为什么要研究算法？</li></ol><p id="214b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">算法是一组指令，通常用于解决一类问题或执行计算。自从希腊数学家以来，这个概念就一直无处不在。例如，想想用于<a class="ae kl" href="https://en.wikipedia.org/wiki/Long_division" rel="noopener ugc nofollow" target="_blank">长除法</a>或<a class="ae kl" href="https://en.wikipedia.org/wiki/Multiplication_algorithm#Long_multiplication" rel="noopener ugc nofollow" target="_blank">小学乘法</a>的步骤。</p><p id="175d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于更大的数据集，<a class="ae kl" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>的概念变得非常重要。这是因为我们编写代码的方式直接关系到我们的数据是如何被分析的，因此，我们可以得出结论。</p><p id="5258" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.大 O 符号</p><p id="5c5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大 O 符号，<strong class="jp ir"> O(n) </strong>，被开发用来表达算法的<strong class="jp ir">时间复杂度</strong>。使用字母 O 是因为函数的增长率也被称为函数的<strong class="jp ir">阶。</strong></p><p id="eb6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">算法的效率表示为输入长度<strong class="jp ir"> n </strong>的函数。更正式的说法是，这被称为算法的<strong class="jp ir">渐近增长率— </strong>我们关心的是当输入趋近于无穷大时，我们的算法的工作效率如何。</p><p id="dbb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想想你在学校是怎么学乘法的。这个算法是“正确的”，因为只要你按照步骤操作，它总是会返回正确的结果。但是对于计算类似 12315432534535 x 35843958345 的乘积，它的性能会有多好呢？</p><p id="c0e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑这个问题的一个很好的方法是可视化一些时间复杂性的基本函数。看看下面的备忘单，了解当输入变得非常大时，运行时间会如何比较:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/99251c386935b64fda538fffe5f36aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xroUFvF6h8n-31QG"/></div></div></figure><p id="12ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到从最快到最慢有一个等级*:</p><p id="9a53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—常数时间:<strong class="jp ir"> O(1) </strong></p><p id="e5ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—对数时间:<strong class="jp ir"> O(对数 n) </strong></p><p id="8cdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—线性时间:<strong class="jp ir"> O(n) </strong></p><p id="6a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">— <strong class="jp ir"> n </strong>日志时间:<strong class="jp ir"> O(nlog n) </strong></p><p id="4dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—二次时间:<strong class="jp ir"> O(n ) </strong></p><p id="71d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*点击此处查看更多<a class="ae kl" href="https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations" rel="noopener ugc nofollow" target="_blank">详细列表</a></p><p id="f777" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于 Big O shorthands 的重要说明:</p><ul class=""><li id="f4e0" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk lh ks kt ku bi translated">算术运算是常数<br/>当我们考虑渐近增长时，这些较小的项变得无关紧要，并被完全忽略。为什么？因为增长是输入长度<strong class="jp ir"> n. </strong>的函数，例如<strong class="jp ir"> (n) </strong>、<strong class="jp ir"> (n+150) </strong>、<strong class="jp ir"> </strong>或<strong class="jp ir"> (150n) </strong>的运算可以表示为<strong class="jp ir"> O(n) </strong></li><li id="fa37" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk lh ks kt ku bi translated">变量赋值是恒定的</li><li id="bdf9" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk lh ks kt ku bi translated">访问数组(通过索引)或对象(通过键)中的元素是不变的</li><li id="404b" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk lh ks kt ku bi translated">在循环中，复杂度=(循环长度)x(循环内部复杂度)</li></ul><p id="a97d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.看看一些众所周知的算法</p><p id="dbad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为我们的第一个例子，我们的小学算法在时间复杂度方面表现如何？</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ln"><img src="../Images/2b4cc3cd6faf5eb9ebca5f70c982585b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uf5AugVph0vGxgVa"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Section 1.2 in <a class="ae kl" href="http://www.algorithmsilluminated.org/" rel="noopener ugc nofollow" target="_blank">http://www.algorithmsilluminated.org/</a></figcaption></figure><ol class=""><li id="e2d5" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">我们从第一行的部分积开始:22，712。它需要<em class="ls">最多</em>，2 次运算(#1: 4 x (8，7，6，5)，#2:结转的加法(3，3，2，2)，所以我们可以说<strong class="jp ir">总的</strong>运算次数是≤ <strong class="jp ir"> 2n </strong></li><li id="de4a" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk kr ks kt ku bi translated">由于所有剩余的<strong class="jp ir"> n </strong>行都发生了相同的精确运算(我们首先将顶部的行相乘，然后将进位相加),因此我们可以将计算所有部分乘积(上面所有蓝色数字)所需的工作加起来作为<strong class="jp ir"> 2n </strong></li><li id="11c7" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk kr ks kt ku bi translated">最后一个操作是将每一行的总和相加，这是与步骤 2 相当的操作数，另一个<strong class="jp ir"> 2n </strong>，使我们的总操作时间达到<strong class="jp ir"> 4n </strong>，但是这是作为<strong class="jp ir">时间复杂度</strong>的函数的什么呢？</li></ol><p id="15db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据定义，大 O 不考虑常数算术函数，即加法和乘法因子。就像上一节的例子一样，如果你在图上画出<strong class="jp ir"> n，n+150 </strong>，<strong class="jp ir">，</strong>和<strong class="jp ir"> 150n </strong>，<strong class="jp ir"> 150n </strong>增长得更快，但是在所有这些函数中总会有一个恒定的算术因子。然而，就渐近增长而言，我们所关心的是<strong class="jp ir"> n </strong>与<strong class="jp ir"> </strong>增长了多少——在这两个例子中，都是简单的<strong class="jp ir"> O(n) </strong>。</p><p id="09e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们可以把上面的常数 4 去掉，我们看到年级学校算法是<strong class="jp ir"> O(n ) </strong>。</p><blockquote class="lt lu lv"><p id="9c5f" class="jn jo ls jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">现在，我们必须经常问自己，我们能做得更好吗？</p></blockquote><p id="eaab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明我们可以。实际上，复数乘法有多种算法，这里我们来看看其中的一种，<a class="ae kl" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm" rel="noopener ugc nofollow" target="_blank"> Karatsuba 乘法</a>，它产生了更快的运行时间<strong class="jp ir"> O(log n) </strong>。</p><p id="6d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我们上面的例子，(1234) x (5678):</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi lz"><img src="../Images/3fe83766c42612a6bf024eeb69506416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a4Ju8UDdP6eDXDcj"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Section 1.3 in <a class="ae kl" href="http://www.algorithmsilluminated.org/" rel="noopener ugc nofollow" target="_blank">http://www.algorithmsilluminated.org/</a></figcaption></figure><ol class=""><li id="dfb1" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">步骤# 1–3 是如上所述的乘法。</li><li id="9b74" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk kr ks kt ku bi translated">步骤 4 从步骤 3 的结果中减去步骤 1 和步骤 2 的结果</li><li id="2dcb" class="km kn iq jp b jq li ju lj jy lk kc ll kg lm kk kr ks kt ku bi translated">步骤#5 添加如下的零，并添加来自#1、2 和 4 的结果:<br/> — #1: +4 个零(672+0000) <br/> — #2: +2 个零(2840+00)</li></ol><p id="456a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，结果和我们的长乘法算法是一样的！</p><p id="5021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看来很明显，Karatsuba 的算法利用了<strong class="jp ir"> </strong> <a class="ae kl" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">递归函数</strong> </a> <strong class="jp ir">。</strong>作为一种分治算法，这意味着我们获取原始输入(1234) x (5678)，将其分割成更小的块，在更小的块上执行工作，并使用来自这些块的答案来解决原始问题。</p><p id="ad7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更一般地，我们可以用这些较小的数字来表示相关的递归调用，<strong class="jp ir"> a </strong>、<strong class="jp ir"> b </strong>、<strong class="jp ir"> c、</strong>和<strong class="jp ir"> d </strong>:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ma"><img src="../Images/296b17815cb76f59c232fb64341dff50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFoUIxGmzbxG-sJkCVh0vA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Section 1.3 in <a class="ae kl" href="http://www.algorithmsilluminated.org/" rel="noopener ugc nofollow" target="_blank">http://www.algorithmsilluminated.org/</a></figcaption></figure><p id="5ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以快速查一下<strong class="jp ir"> x </strong>是(12x100+34)= <strong class="jp ir"> 1234 </strong>，<strong class="jp ir"> y </strong>是(56 x 100 + 78)= <strong class="jp ir"> 5678。按照上面最后一行展开这些表示，我们有了一个清晰的紫色(*)递归函数表达式:</strong></p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi mb"><img src="../Images/10811646a065754fb784111af7e42208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nhQqIksknkA30SOK"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Section 1.3 in <a class="ae kl" href="http://www.algorithmsilluminated.org/" rel="noopener ugc nofollow" target="_blank">http://www.algorithmsilluminated.org/</a></figcaption></figure><p id="153e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">关键见解</strong>:回想之前，步骤#3 只在步骤#4 中需要，也就是说，我们可以从中减去步骤#1 和步骤# 2 的结果。如果我们展开步骤#3 (ac+ad+bc+bd ),很明显步骤#4(步骤# 3-步骤# 2-步骤#1)可以简化为上面的(ad+bc)*，只剩下 3 个递归调用，而不是 4 个！<br/>*此快捷键为<em class="ls"> </em> <a class="ae kl" href="https://en.wikipedia.org/wiki/Multiplication_algorithm#Complex_multiplication_algorithm" rel="noopener ugc nofollow" target="_blank">复数乘法</a>归于高斯。</p><p id="5145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在以后的文章中，我将尝试介绍合并排序算法和渐近分析。</p></div></div>    
</body>
</html>