<html>
<head>
<title>Using Panda’s “transform” and “apply” to deal with missing data on a group level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Panda 的“转换”和“应用”在组级别处理缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-pandas-transform-and-apply-to-deal-with-missing-data-on-a-group-level-cb6ccf060531?source=collection_archive---------1-----------------------#2019-11-02">https://towardsdatascience.com/using-pandas-transform-and-apply-to-deal-with-missing-data-on-a-group-level-cb6ccf060531?source=collection_archive---------1-----------------------#2019-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7998fdd9a79e06f910d3e28a1cf03d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqr41-AsApEDOWjLPvXkeQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/Brett_Hondow-49958/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1378806" rel="noopener ugc nofollow" target="_blank">Brett Hondow</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1378806" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><div class=""/><div class=""><h2 id="c9ee" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">了解当您不想简单地丢弃丢失的数据时应该怎么做。</h2></div><p id="4ed9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据 Businessbroadway 进行的一项分析，数据专业人员花费高达 60%的时间来收集、清理数据和可视化数据。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/f7538b2e832ee999e03e08a72ef107a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7ygbtZG3PAk5PImVD4aUA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Source: <a class="ae jg" href="https://businessoverbroadway.com/2019/02/19/how-do-data-professionals-spend-their-time-on-data-science-projects/" rel="noopener ugc nofollow" target="_blank">Businessbroadway</a></figcaption></figure><p id="70cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">清理和可视化数据的一个关键方面是如何处理丢失的数据。<strong class="la jk"> Pandas 以</strong> <code class="fe lz ma mb mc b"><strong class="la jk">fillna</strong></code> <strong class="la jk">方法</strong>的形式提供了一些基本功能。虽然<code class="fe lz ma mb mc b">fillna</code>在最简单的情况下工作得很好，但是一旦数据中的组或数据的顺序变得相关时，它就不够用了。本文将讨论解决这些更复杂情况的技术。</p><p id="3e21" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些案例通常是由不同制度(时间序列)、组甚至子组组成的数据集。不同情况的例子有几个月、几个季度(一般时间范围)或一段暴雨期。数据中的组的一个例子是性别。亚组的例子有年龄组和种族。</p><p id="fdeb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文旨在作为一篇代码文章。因此，请随意启动笔记本电脑，开始工作。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b307" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">文章的结构:</h1><ol class=""><li id="6a3b" class="nc nd jj la b lb ne le nf lh ng ll nh lp ni lt nj nk nl nm bi translated">熊猫的 fillna</li><li id="6d85" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">当订单<strong class="la jk">与</strong>不相关时，处理缺失数据</li><li id="8686" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">当订单<strong class="la jk">与</strong>相关时，处理缺失数据</li></ol></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="1516" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">熊猫概述<code class="fe lz ma mb mc b">fillna</code></h1><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/869e9072fa7ca23db43e03950be061d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNr_N8uX1Eog4LK8Y5KV8Q.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/skeeze-272447/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=903044" rel="noopener ugc nofollow" target="_blank">skeeze</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=903044" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="fb27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas 通过调用<code class="fe lz ma mb mc b">fillna()</code>有三种处理丢失数据的模式:</p><ul class=""><li id="cd9f" class="nc nd jj la b lb lc le lf lh ns ll nt lp nu lt nv nk nl nm bi translated"><code class="fe lz ma mb mc b"><strong class="la jk">method='ffill':</strong></code> <strong class="la jk"> </strong> Ffill 或 forward-fill 将<strong class="la jk">最后一个</strong>观察到的非空值向前传播，直到遇到另一个非空值</li><li id="d662" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nv nk nl nm bi translated"><code class="fe lz ma mb mc b"><strong class="la jk">method='bfill':</strong></code> <strong class="la jk"> </strong> Bfill 或 backward-fill 将<strong class="la jk">第一个</strong>观察到的非空值向后传播，直到遇到另一个非空值</li><li id="52b5" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nv nk nl nm bi translated"><code class="fe lz ma mb mc b"><strong class="la jk">explicit value:</strong></code> <strong class="la jk"> </strong>也可以设置一个精确值来替换所有缺失。例如，这种替换可以是-999，表示缺少该值。</li></ul><p id="0ca3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">例如:</strong></p><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="8871" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk">IN:<br/></strong>demo = pd.Series(range(6))<br/>demo.loc[2:4] = np.nan<br/>demo</span><span id="3a01" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk">OUT:<br/></strong>0    0.0<br/>1    1.0<br/><em class="og">2    NaN<br/>3    NaN<br/>4    NaN</em><br/>5    5.0<br/>dtype: float64</span><span id="fffd" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># Forward-Fill<br/>IN:<br/></strong>demo.fillna(method='ffill')</span><span id="0069" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk">OUT:<br/></strong>0    0.0<br/>1    1.0<br/><em class="og">2    1.0<br/>3    1.0<br/>4    1.0</em><br/>5    5.0<br/>dtype: float64</span><span id="2f8b" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># Backward-Fill</strong><br/><strong class="mc jk">IN:<br/></strong>demo.fillna(method='bfill')</span><span id="addc" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk">OUT:<br/></strong>0    0.0<br/>1    1.0<br/><em class="og">2    5.0<br/>3    5.0<br/>4    5.0</em><br/>5    5.0<br/>dtype: float64</span><span id="6f28" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># Explicit value</strong><br/><strong class="mc jk">IN:<br/></strong>demo.fillna(-999)</span><span id="4028" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk">OUT:<br/></strong>0      0.0<br/>1      1.0<br/><em class="og">2   -999.0<br/>3   -999.0<br/>4   -999.0</em><br/>5      5.0<br/>dtype: float64</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="a5d3" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">当订单<strong class="ak">与</strong>不相关时，处理缺失数据</h1><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/013c2839ae978a8a5481fec19fb439de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGlHeaEPahkJ0SJ8EEWBXA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/PublicDomainPictures-14/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=315510" rel="noopener ugc nofollow" target="_blank">PublicDomainPictures</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=315510" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="4f2e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，在处理缺失数据时，排序并不重要，因此，用于替换缺失值的值可以基于全部可用数据。在这种情况下，您通常会用自己的最佳猜测(即，可用数据的平均值或中间值)替换缺失值</p><p id="d457" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们快速回顾一下为什么应该小心使用这个选项。让我们假设你调查了 1000 个男孩和 1000 个女孩的体重。不幸的是，在收集数据的过程中，一些数据丢失了。</p><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="e30e" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># imports</strong><br/>import numpy as np</span><span id="cff0" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># sample 1000 boys and 1000 girls</strong><br/>boys = np.random.normal(70,5,1000)<br/>girls = np.random.normal(50,3,1000)</span><span id="7618" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># unfortunately, the intern running the survey on the girls got distracted and lost 100 samples<br/></strong>for i in range(100):<br/>    girls[np.random.randint(0,1000)] = np.nan</span><span id="1063" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># build DataFrame</strong><br/>boys = pd.DataFrame(boys, columns=['weight'])<br/>boys['gender'] = 'boy'</span><span id="a616" class="oa ml jj mc b gy of oc l od oe">girls = pd.DataFrame(girls, columns=['weight'])<br/>girls['gender'] = 'girl'</span><span id="55bd" class="oa ml jj mc b gy of oc l od oe">df = pd.concat([girls,boys],axis=0)<br/>df['weight'] = df['weight'].astype(float)</span></pre><h2 id="1842" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">一个分组</h2><p id="6101" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ot lj lk ll ou ln lo lp ov lr ls lt im bi translated">不用多想，我们可能会用整个样本的平均值来填充缺失值。不过，结果看起来有些奇怪。女孩的 KDE 有两个驼峰。有人可能会得出结论，在我们的样本中有一个较重的女孩子群。因为我们预先构建了发行版，所以我们知道情况并非如此。但是如果这是真实的数据，我们可能会从这些数据中得出错误的结论。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/52da25d40005763820e919e1a8c3b4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOxoqCj1QuACGh3MmQFyzQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">KDE of weights for boys and girls where we replaced missing data with the sample mean (code below the chart)</figcaption></figure><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="7c34" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># PLOT CODE:</strong><br/>sns.set_style('white')<br/>fig, ax = plt.subplots(figsize=(16, 7))</span><span id="1c76" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk">mean = df['weight'].mean()</strong></span><span id="f901" class="oa ml jj mc b gy of oc l od oe">sns.distplot(<br/><strong class="mc jk">    df[df['gender'] == 'girl']['weight'].fillna(mean),</strong><br/>    kde=True,<br/>    hist=False,<br/>    ax=ax,<br/>    label='girls'<br/>)</span><span id="edde" class="oa ml jj mc b gy of oc l od oe">sns.distplot(<br/>    df[df['gender'] == 'boy']['weight'],<br/>    kde=True,<br/>    hist=False,<br/>    ax=ax,<br/>    label='boys'<br/>)</span><span id="7ff9" class="oa ml jj mc b gy of oc l od oe">plt.title('Kernel density estimation of weight for boys and girls')</span><span id="d941" class="oa ml jj mc b gy of oc l od oe">sns.despine()</span></pre><h2 id="beda" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">用组的平均值填充缺失值</h2><p id="54a0" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ot lj lk ll ou ln lo lp ov lr ls lt im bi translated">在这种情况下，Panda 的转换功能就派上了用场。使用 transform 提供了一种在组级别解决问题的便捷方法，如下所示:</p><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="e4be" class="oa ml jj mc b gy ob oc l od oe">df['filled_weight'] = df.groupby('gender')['weight'].transform(<br/>    lambda grp: grp.fillna(np.mean(grp))<br/>)</span></pre><p id="9eeb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行上述命令并绘制<code class="fe lz ma mb mc b">filled_weight</code>值的 KDE，结果如下:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/4a90f54dcf7ab92701351b7b6363088d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1P7EfaJ3N3wuDjmLr3jK0w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">KDE of weights for boys and girls where we replaced missing values with the group mean (code below the chart)</figcaption></figure><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="c4a5" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># PLOT CODE:</strong><br/>sns.set_style('white')<br/>fig, ax = plt.subplots(figsize=(16, 7))</span><span id="b568" class="oa ml jj mc b gy of oc l od oe">sns.distplot(<br/>    df[df['gender'] == 'girl']['filled_weight'],<br/>    kde=True,<br/>    hist=False,<br/>    ax=ax,<br/>    label='girls'</span><span id="4069" class="oa ml jj mc b gy of oc l od oe">)<br/>sns.distplot(<br/>    df[df['gender'] == 'boy']['filled_weight'],<br/>    kde=True,<br/>    hist=False,<br/>    ax=ax,<br/>    label='boys'<br/>)</span><span id="4f52" class="oa ml jj mc b gy of oc l od oe">plt.title('Kernel density estimation of weight for boys and girls')</span><span id="ab48" class="oa ml jj mc b gy of oc l od oe">sns.despine()</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="0c82" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">多个子组</h2><p id="58bc" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ot lj lk ll ou ln lo lp ov lr ls lt im bi translated">让我们使用前面的例子，但这一次，我们走得更远一点，另外将我们的数据分成年龄组。让我们创建一些模拟数据:</p><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="c717" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># paramter for the weight distribution (mean, std)</strong><br/>param_map = {<br/>    'boy':{<br/>        '&lt;10':(40,4),<br/>        '&lt;20':(60,4),<br/>        '20+':(70,5),<br/>    },<br/>    'girl':{<br/>        '&lt;10':(30,2),<br/>        '&lt;20':(40,3),<br/>        '20+':(50,3),<br/>    }<br/>}</span><span id="82cf" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># generate 10k records</strong><br/>df = pd.DataFrame({<br/>    'gender':np.random.choice(['girl','boy'],10000),<br/>    'age_cohort':np.random.choice(['&lt;10','&lt;20','20+'],10000)<br/>})</span><span id="050a" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># set random weight based on parameters</strong><br/>df['weight'] = df.apply(<br/>    lambda x: np.random.normal(<br/>        loc=param_map[x['gender']][x['age_cohort']][0],<br/>        scale=param_map[x['gender']][x['age_cohort']][1]<br/>    ),axis=1<br/>)</span><span id="3a64" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># set 500 values missing</strong><br/>for i in range(500):<br/>    df.loc[np.random.randint(0,len(df)),'weight'] = np.nan</span></pre><p id="e591" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">绘制数据揭示了有点奇怪的双峰分布(代码如下)。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/d74665281513effb2b0a02bcb2c4a482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZzhoUJZ_i0vO-REiOvnfPA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">KDE of weight by age_cohort and gender were we replaced missing values with the sample mean</figcaption></figure><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="3af0" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># PLOT CODE</strong><br/>df['filled_weight'] = df['weight'].fillna(<br/>    df['weight'].mean()<br/>)</span><span id="cec3" class="oa ml jj mc b gy of oc l od oe">g = sns.FacetGrid(<br/>    df,<br/>    col='age_cohort',<br/>    row='gender',<br/>    col_order=['&lt;10','&lt;20','20+']<br/>)</span><span id="58e2" class="oa ml jj mc b gy of oc l od oe">g.map(sns.kdeplot,'filled_weight')</span></pre><p id="2b4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们只是用各自性别的平均值来代替缺失值，这还不够，因为不仅男孩和女孩的体重不同，而且不同年龄组的体重也有很大差异。</p><p id="9d49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，<code class="fe lz ma mb mc b">transform</code>可以像以前一样应用。我们将在两列上分组，而不是像这样只在一列上分组:</p><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="105a" class="oa ml jj mc b gy ob oc l od oe">df['filled_weight'] = df.groupby(['gender','age_cohort'])['weight'].transform(<br/>    lambda grp: grp.fillna(np.mean(grp))<br/>)</span></pre><p id="f707" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行上面的代码片段将生成这个更加清晰的图:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/2242dbb20c7d4e9a93a0f45e2f376bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUXHLa6Unr9_HN3AidSvVQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">KDE of weight by age_cohort and gender were we replaced missing values with each group’s mean</figcaption></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b143" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">当订单<strong class="ak">与</strong>相关时，处理缺失数据</h1><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/a2aa9fc36f458764a9162174e92d29ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7xj1cMZgMwEzP1Cy"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@jakehills?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jake Hills</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c8cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在处理时序数据时，经常会出现两种情况。</p><ol class=""><li id="7331" class="nc nd jj la b lb lc le lf lh ns ll nt lp nu lt nj nk nl nm bi translated"><strong class="la jk">调整日期范围:</strong>假设你按年查看各国的 GDP、教育水平和人口增长。对一些国家来说，你错过了最初的几年，后来的几年，或者中间的几年。当然，你可以忽略它们。尽管如此，出于可视化的目的，您可能希望保留它们，并将您的第一个观察值投影到开始，将您的最后一个观察值投影到调查期结束，并得出对中间值有意义的东西。</li><li id="40a4" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><strong class="la jk">插值:</strong>查看时间序列数据插值，从而排序变得非常相关。用基于截至 2019 年的数据计算出的平均值替换 2012 年缺失的股票数据，肯定会产生一些古怪的结果。</li></ol><p id="e1bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将根据 2019 年<a class="ae jg" href="https://worldhappiness.report/ed/2019/" rel="noopener ugc nofollow" target="_blank">世界幸福报告</a>的数据来看一个例子，我们解决了这两种情况。《世界幸福报告》试图回答哪些因素影响着全世界的幸福。该报告调查了 2005 年至 2018 年的数据。</p><h2 id="d595" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">加载数据</h2><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="cdbd" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># Load the data</strong><br/>df = pd.read_csv('<a class="ae jg" href="https://raw.githubusercontent.com/FBosler/you-datascientist/master/happiness_with_continent.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/you-datascientist/master/happiness_with_continent.csv'</a>)</span></pre><h2 id="aecf" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">样品检验</h2><p id="049f" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ot lj lk ll ou ln lo lp ov lr ls lt im bi translated"><code class="fe lz ma mb mc b">df.sample(5)</code>与<code class="fe lz ma mb mc b">df.head(5)</code>相反，选择五个随机行，从而给你一个更公正的数据视图。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/370878360f4a8afb973e32c44f281396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O25aSD743iRVOdW2kXlReg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Data sample from the downloaded DataFrame</figcaption></figure><p id="3a6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看每年我们有数据的国家的数量。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/4743bab5eaa28992f40fce28bad5855a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRcUCAO51BzXSJAeTdYnVw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Number of countries we have data for per year</figcaption></figure><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="8282" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># PLOT CODE:</strong><br/>df.groupby(['Year']).size().plot(<br/>    kind='bar',<br/>    title='Number of countries with data',<br/>    figsize=(10,5)<br/>)</span></pre><p id="ce88" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，特别是前几年，我们没有很多国家的数据，而且在整个样本期间也有一些波动。为了减轻丢失数据的影响，我们将执行以下操作:</p><ol class=""><li id="5951" class="nc nd jj la b lb lc le lf lh ns ll nt lp nu lt nj nk nl nm bi translated">按国家分组并重新索引整个日期范围</li><li id="51bc" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">根据我们对每个国家的观察结果，对之间的年份进行插值，并对范围之外的年份进行外推</li></ol><h2 id="b15b" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">1.按国家和重新索引日期范围分组</h2><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="1704" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># Define helper function</strong><br/>def add_missing_years(grp):<br/>    _ = grp.set_index('Year')<br/>    _ = _.reindex(list(range(2005,2019)))<br/>    del _['Country name']<br/>    return _</span><span id="910d" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># Group by country name and extend</strong><br/>df = df.groupby('Country name').apply(add_missing_years)<br/>df = df.reset_index()</span></pre><p id="9257" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在大约有 600 多行。然而，那些观察现在都是<code class="fe lz ma mb mc b">null</code></p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/e22e2ce0559cf815b8e81acd72f2b338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBDTkEcRpeAqMOwzST8NxA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Extended DataFrame, where every country has rows for every year between 2005 and 2018</figcaption></figure><h2 id="5bda" class="oa ml jj bd mm oi oj dn mq ok ol dp mu lh om on mw ll oo op my lp oq or na os bi translated">2.根据我们对每个国家的观察结果，对之间的年份进行插值，并对范围之外的年份进行外推</h2><pre class="lv lw lx ly gt nw mc nx ny aw nz bi"><span id="5f23" class="oa ml jj mc b gy ob oc l od oe"><strong class="mc jk"># Define helper function</strong><br/>def fill_missing(grp):<br/>    res = grp.set_index('Year')\<br/>    .interpolate(method='linear',limit=5)\<br/>    .fillna(method='ffill')\<br/>    .fillna(method='bfill')<br/>    del res['Country name']<br/>    return res</span><span id="c1ee" class="oa ml jj mc b gy of oc l od oe"><strong class="mc jk"># Group by country name and fill missing</strong><br/>df = df.groupby(['Country name']).apply(<br/>    lambda grp: fill_missing(grp)<br/>)</span><span id="0df7" class="oa ml jj mc b gy of oc l od oe">df = df.reset_index()</span></pre><p id="efed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lz ma mb mc b">fill_missing</code>函数向终点和起点进行插值和外推，结果是:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/bb41adf58cb70aa448c7106b76732f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCYkFVUx9StNDEb5r9Q7fA.png"/></div></div></figure><p id="ab3c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">完美！</strong>现在我们有了样本中所有国家从 2005 年到 2018 年的数据。当我写这篇关于可视化的文章时，上面的方法对我来说很有意义。如果你想了解更多关于幸福报告的信息，可以去看看。</p><div class="is it gp gr iu pf"><a rel="noopener follow" target="_blank" href="/plotting-with-python-c2561b8c0f1f"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jk gy z fp pk fr fs pl fu fw ji bi translated">了解如何使用 Python 创建漂亮而有洞察力的图表——快速、漂亮和…</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">数据显示，金钱可以买到幸福。用 Python 可视化的综合代码指南，解释了…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ja pf"/></div></div></a></div><h1 id="54d0" class="mk ml jj bd mm mn pu mp mq mr pv mt mu kp pw kq mw ks px kt my kv py kw na nb bi translated">总结和结束语</h1><p id="39cf" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ot lj lk ll ou ln lo lp ov lr ls lt im bi translated">今天到此为止。在本文中，您学习了如何使用<code class="fe lz ma mb mc b">transform</code>和<code class="fe lz ma mb mc b">apply</code>用比之前或之后的值更有意义的值来替换丢失的值。</p><p id="e5dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你发现了一些奇妙的新的可视化效果，想要提供反馈或进行聊天，请在 LinkedIn 上联系我。</p><p id="bdd3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢你所读的，看看我在 Medium 上写的其他文章。</p></div></div>    
</body>
</html>