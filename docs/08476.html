<html>
<head>
<title>Using Gradient Boosting for Time Series prediction tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对时间序列预测任务使用梯度增强</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-gradient-boosting-for-time-series-prediction-tasks-600fac66a5fc?source=collection_archive---------3-----------------------#2019-11-17">https://towardsdatascience.com/using-gradient-boosting-for-time-series-prediction-tasks-600fac66a5fc?source=collection_archive---------3-----------------------#2019-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/de3438ff0765d69c9532b3c9b714beeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M5GdvZGfBrabPzfXI4Iyw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149701" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><div class=""/><div class=""><h2 id="1c73" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">简单的时间序列建模</h2></div><p id="2f79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间序列预测问题在零售领域相当常见。</p><p id="c675" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像沃尔玛和塔吉特这样的公司需要记录有多少产品应该从配送中心运送到商店。在劳动力管理、库存成本和缺货损失方面，即使对这种需求预测系统进行很小的改进也可以帮助节省大量的美元。</p><p id="22f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然有许多技术来解决这个特殊的问题，如 ARIMA，先知和 LSTMs，我们也可以把这样的问题作为一个回归问题，并使用树来解决它。</p><p id="762d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">在本帖中，我们将尝试使用 XGBoost 解决时间序列问题。</em>T3】</strong></p><p id="d90d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">我要关注的主要事情是这样一个设置需要什么样的功能，以及如何创建这样的功能。</em> </strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80f1" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">资料组</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mu"><img src="../Images/d218134b3fbe96aa6f60507297bd4184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gLUSm0_14D8A3NvR.jpg"/></div></div></figure><p id="79aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kaggle 大师 Kazanova 和他的一些朋友一起发布了一个<a class="ae jg" href="https://www.coursera.org/specializations/aml?siteID=lVarvwc5BD0-BShznKdc3CUauhfsM7_8xw&amp;utm_content=2&amp;utm_medium=partners&amp;utm_source=linkshare&amp;utm_campaign=lVarvwc5BD0" rel="noopener ugc nofollow" target="_blank">“如何赢得数据科学竞赛”</a> Coursera 课程。这门课程包括一个期末专题，它本身是一个时间序列预测问题。</p><p id="3635" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这场比赛中，我们得到了一个由日常销售数据组成的具有挑战性的时间序列数据集，该数据集由俄罗斯最大的软件公司之一 1C 公司提供。</p><p id="9786" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须预测下个月每个产品和商店的总销售额。</p><p id="68bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据如下所示:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/1f5cbc6834231b3344ee59f569961847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hN1eF-iQzfTp6EGg3VBAlA.png"/></div></div></figure><p id="2a84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到了每天的数据，我们希望建立一个模型来预测下个月每个产品和商店的总销售额。</p><p id="4a41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">变量 date_block_num 是一个连续的月数，为方便起见而使用。2013 年 1 月为 0，2015 年 10 月为 33。你可以把它看作月变量的代理。我认为所有其他变量都是不言自明的。</p><p id="3321" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们如何处理这类问题呢？T13】</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4b39" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">数据准备</h1><p id="e91b" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我注意到的主要事情是，当我们试图使用回归来解决时间序列问题时，数据准备和<a class="ae jg" rel="noopener" target="_blank" href="/the-hitchhikers-guide-to-feature-extraction-b4c157e96631">特征生成</a>方面是最重要的事情。</p><h2 id="5f13" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">1.进行基本的 EDA 并去除异常值</h2><pre class="mv mw mx my gt nr ns nt nu aw nv bi"><span id="7021" class="nf md jj ns b gy nw nx l ny nz">sales = sales[sales['item_price']&lt;100000]<br/>sales = sales[sales['item_cnt_day']&lt;=1000]</span></pre><h2 id="9820" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">2.按照您希望的预测级别对数据进行分组:</h2><p id="da87" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们首先创建一个不同的日期块数量、商店和商品组合的数据框架。</p><p id="6969" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一点很重要，因为在我们没有商品商店组合数据的几个月里，机器学习算法需要被明确告知销售额为零。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bde1022ed8215a12716530d0a7839d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*yDLbk-d9EbYV7EG38MXYeg.png"/></div></figure><p id="b620" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">网格数据框架包含所有商店、商品和月份的组合。</p><p id="d860" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们将网格与销售额合并，得到月销售额数据框架。对于没有任何销售的月份，我们也用零替换所有的 NA。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/ec92491381bbedf22027346786596e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_SzSZkoyGT7ce-FtPlLQw.png"/></div></div></figure><h2 id="bdc1" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">3.创建目标编码</h2><p id="6d10" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">为了创建目标编码，我们按特定的列分组，并取平均值/最小值/总和等。目标列的名称。这些特征是我们在模型中创建的第一个特征。</p><p id="3e2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">请注意，这些特性可能会在我们的系统中引起大量泄漏/过拟合，因此我们不会在模型中直接使用它们。我们将在接下来创建的模型中使用这些特性的基于滞后的版本。</em>T9】</strong></p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="3474" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们按<code class="fe oe of og ns b">item_id</code>、<code class="fe oe of og ns b">shop_id</code>和<code class="fe oe of og ns b">item_category_id</code>分组，并在<code class="fe oe of og ns b">item_price</code>和<code class="fe oe of og ns b">item_cnt_day</code>列上聚合，以创建以下新特性:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/d2d02f30472906ddfdd6107205a5887b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNJdVv0Bka75S5QKHV0D-w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">We create the highlighted target encodings</figcaption></figure><p id="88ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以为此使用<a class="ae jg" rel="noopener" target="_blank" href="/the-hitchhikers-guide-to-feature-extraction-b4c157e96631">特征工具</a>。<strong class="la jk">特征工具</strong>是一个执行自动化特征工程的框架。它擅长将时态和关系数据集转换为机器学习的特征矩阵。</p><h2 id="2b09" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">4.创建滞后要素</h2><p id="fd90" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们的模型需要的下一组特征是基于滞后的特征。</p><p id="2870" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们创建常规分类模型时，我们将训练示例视为彼此完全独立。但在时间序列问题的情况下，在任何时间点，模型都需要过去发生的信息。</p><p id="8b37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不能对过去的所有日子都这样做，但是我们可以使用我们的目标编码特征为模型提供最新的信息。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="85c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们的目标是在数据中添加一些特征的过去信息。我们为我们创建的所有新功能和<code class="fe oe of og ns b">item_cnt_day</code>功能都这样做。</p><p id="bf83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦有了滞后特性，我们就用零填充 NA。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1038" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们最终创建了许多具有不同滞后的滞后特征:</p><pre class="mv mw mx my gt nr ns nt nu aw nv bi"><span id="4937" class="nf md jj ns b gy nw nx l ny nz">'item_id_avg_item_price_lag_1','item_id_sum_item_cnt_day_lag_1', 'item_id_avg_item_cnt_day_lag_1','shop_id_avg_item_price_lag_1', 'shop_id_sum_item_cnt_day_lag_1','shop_id_avg_item_cnt_day_lag_1','item_category_id_avg_item_price_lag_1','item_category_id_sum_item_cnt_day_lag_1','item_category_id_avg_item_cnt_day_lag_1', 'item_cnt_day_lag_1',</span><span id="24d0" class="nf md jj ns b gy oi nx l ny nz">'item_id_avg_item_price_lag_2', 'item_id_sum_item_cnt_day_lag_2','item_id_avg_item_cnt_day_lag_2', 'shop_id_avg_item_price_lag_2','shop_id_sum_item_cnt_day_lag_2', 'shop_id_avg_item_cnt_day_lag_2','item_category_id_avg_item_price_lag_2','item_category_id_sum_item_cnt_day_lag_2','item_category_id_avg_item_cnt_day_lag_2', 'item_cnt_day_lag_2',</span><span id="9729" class="nf md jj ns b gy oi nx l ny nz">...</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3cdc" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">系统模型化</h1><h2 id="b6ac" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">1.删除不需要的列</h2><p id="0970" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如前所述，我们将删除目标编码特征，因为它们可能会导致模型中的大量过度拟合。我们还失去了项目名称和项目价格功能。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="93e0" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">2.只取最近的一点数据</h2><p id="ad58" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">当我们创建滞后变量时，我们在系统中引入了很多零。我们使用的最大滞后为 12。为了应对这种情况，我们删除了前 12 个月的指数。</p><pre class="mv mw mx my gt nr ns nt nu aw nv bi"><span id="abb4" class="nf md jj ns b gy nw nx l ny nz">sales_means = sales_means[sales_means['date_block_num']&gt;11]</span></pre><h2 id="2a65" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">3.训练和 CV 分割</h2><p id="81eb" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">当我们进行时间序列分割时，我们通常不进行横截面分割，因为数据是与时间相关的。我们想创建一个模型，看到现在，并能很好地预测下个月。</p><pre class="mv mw mx my gt nr ns nt nu aw nv bi"><span id="2176" class="nf md jj ns b gy nw nx l ny nz">X_train = sales_means[sales_means['date_block_num']&lt;33]<br/>X_cv =  sales_means[sales_means['date_block_num']==33]</span><span id="fc05" class="nf md jj ns b gy oi nx l ny nz">Y_train = X_train['item_cnt_day']<br/>Y_cv = X_cv['item_cnt_day']</span><span id="a994" class="nf md jj ns b gy oi nx l ny nz">del X_train['item_cnt_day']<br/>del X_cv['item_cnt_day']</span></pre><h2 id="3b33" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">4.创建基线</h2><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/a7b13092a2509581d8a89cbcb050abdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ujr-irYHlXd0SAGP.jpg"/></div></div></figure><p id="2c39" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们继续建模步骤之前，让我们检查一个简单模型的 RMSE，因为我们想让<a class="ae jg" rel="noopener" target="_blank" href="/take-your-machine-learning-models-to-production-with-these-5-simple-steps-35aa55e3a43c">有一个与</a>比较的 RMSE。我们假设我们将预测上个月的销售额作为基线模型的本月销售额。我们可以使用这个基线 RMSE 来量化我们模型的性能。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="mv mw mx my gt nr ns nt nu aw nv bi"><span id="0278" class="nf md jj ns b gy nw nx l ny nz">1.1358170090812756</span></pre><h2 id="ab53" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">5.列车 XGB</h2><p id="4942" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们使用来自<code class="fe oe of og ns b">xgboost</code> scikit API 的 XGBRegressor 对象来构建我们的模型。参数取自这个<a class="ae jg" href="https://www.kaggle.com/dlarionov/feature-engineering-xgboost" rel="noopener ugc nofollow" target="_blank"> kaggle 内核</a>。有时间的话可以用 hyperopt 来<a class="ae jg" rel="noopener" target="_blank" href="/automate-hyperparameter-tuning-for-your-models-71b18f819604">自动自己找出超参数</a>。</p><pre class="mv mw mx my gt nr ns nt nu aw nv bi"><span id="b3f0" class="nf md jj ns b gy nw nx l ny nz">from xgboost import XGBRegressor</span><span id="2f91" class="nf md jj ns b gy oi nx l ny nz">model = XGBRegressor(<br/>    max_depth=8,<br/>    n_estimators=1000,<br/>    min_child_weight=300, <br/>    colsample_bytree=0.8, <br/>    subsample=0.8, <br/>    eta=0.3,    <br/>    seed=42)</span><span id="d874" class="nf md jj ns b gy oi nx l ny nz">model.fit(<br/>    X_train, <br/>    Y_train, <br/>    eval_metric="rmse", <br/>    eval_set=[(X_train, Y_train), (X_cv, Y_cv)], <br/>    verbose=True, <br/>    early_stopping_rounds = 10)</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/693d87082fad47a0a60432abb52690a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uK9IjFKLEWPGbbeDLc2hfg.png"/></div></div></figure><p id="01d3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行这个之后，我们可以在 CV 集上看到 RMSE 在<strong class="la jk"> <em class="lu"> 0.93 </em> </strong>的范围内。基于我们对<strong class="la jk"> <em class="lu"> 1.13 </em> </strong>的基线验证 RMSE，这是非常令人印象深刻的。因此，我们致力于部署这个模型，作为我们持续集成工作的一部分。</p><h2 id="0195" class="nf md jj bd me ng nh dn mi ni nj dp mm lh nk nl mo ll nm nn mq lp no np ms nq bi translated">5.地块特征重要性</h2><p id="5537" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们还可以看到来自 XGB 的重要特性。</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/6b262222de510368908a221ec2c1462c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZ_BawTl6O1kMuTUTMYoHw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Feature importances</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f09" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">结论</h1><p id="788c" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">在这篇文章中，我们讨论了如何使用树进行时间序列建模。目的不是在 kaggle 排行榜上获得满分，而是了解这些模型是如何工作的。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/3f4f959208c0dd345bfa8fa01e2dcd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vsyzeBzrG4q4Z33z.png"/></div></div></figure><p id="7ee3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几年前，当我作为<a class="ae jg" href="https://www.coursera.org/specializations/aml?siteID=lVarvwc5BD0-BShznKdc3CUauhfsM7_8xw&amp;utm_content=2&amp;utm_medium=partners&amp;utm_source=linkshare&amp;utm_campaign=lVarvwc5BD0" rel="noopener ugc nofollow" target="_blank">课程</a>的一部分参加这个比赛时，通过使用树木，我接近了排行榜的顶端。</p><p id="1ecd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着时间的推移，人们在调整模型、超参数调整和创建更多信息功能方面做了大量工作。但是基本方法保持不变。</p><p id="5ae1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在<a class="ae jg" href="https://github.com/MLWhiz/data_science_blogs/tree/master/time_series_xgb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的运行代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5d94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看 Google Cloud Specialization 上的<a class="ae jg" href="https://coursera.pxf.io/5bDx3b" rel="noopener ugc nofollow" target="_blank">高级机器学习。本课程将讨论模型的部署和生产。绝对推荐。</a></p><p id="cf10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将来我也会写更多初学者友好的帖子。让我知道你对这个系列的看法。在<a class="ae jg" href="https://medium.com/@rahul_agarwal" rel="noopener"><strong class="la jk"/></a>关注我或者订阅我的<a class="ae jg" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p><p id="14f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，一个小小的免责声明——这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p></div></div>    
</body>
</html>