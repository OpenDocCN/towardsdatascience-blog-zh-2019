<html>
<head>
<title>Performing multidimensional matrix operations using Numpy’s broadcasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Numpy 广播执行多维矩阵运算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performing-multidimensional-matrix-operations-using-numpys-broadcasting-cf33e3029170?source=collection_archive---------13-----------------------#2019-02-12">https://towardsdatascience.com/performing-multidimensional-matrix-operations-using-numpys-broadcasting-cf33e3029170?source=collection_archive---------13-----------------------#2019-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d084d11648f6bd14830d5166efbd5925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTSHRZoGHt56gmcmb7cLPQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Tensor manipulation…</figcaption></figure><p id="5228" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Numpy 的<a class="ae la" href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank"> broadcasting </a>特性可能会让这个库的新用户有些困惑，但它允许非常干净、优雅和有趣的编码。绝对值得努力去习惯。在这篇短文中，我想展示一个很好的广播实现来节省一些循环甚至计算时间。</p><p id="a412" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">先说一个简单的案例。</p><p id="e8ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本概念是，当两个大小为<em class="lf"> (m，1) </em>和<em class="lf"> (1，m) </em>的向量相加或相乘时，numpy 会广播(复制向量)以便允许计算。例如，将一个向量<em class="lf">【1，2，3，4，…10】</em>乘以其自身的转置版本，将得到乘法表。例如:</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/31083710868dab0fb995205975787ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQ_oRvxidBm-84Bjqv3TEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Broadcasting a vector into a matrix. A miniature multiplication table.</figcaption></figure><p id="ff91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个例子中，我们将一个大小为<em class="lf"> (3，1) </em>的一维向量(<code class="fe lb lc ld le b">V</code>)与其大小为<em class="lf"> (1，3) </em>的转置版本相乘，得到一个<em class="lf"> (3，3) </em>矩阵，它是<code class="fe lb lc ld le b">V</code>的<a class="ae la" href="https://en.wikipedia.org/wiki/Outer_product" rel="noopener ugc nofollow" target="_blank">外积</a>。</p><p id="2fa7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您仍然感到困惑，下图将该过程分为两个步骤，使其更加清晰:</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/eda27822d57e90993cf394153a58b76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9h-BKUsWrMC0gfJJX58jOg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Broadcasting in slow motion.</figcaption></figure><p id="4f35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以把广播想象成简单地把我们的两个向量复制成一个<em class="lf"> (3，3) </em>矩阵，然后执行元素式乘法。</p><p id="1cc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们刚刚将一个一维数组广播到一个二维矩阵中，然而，我们可以用它将一个二维数组(或矩阵)广播到一个三维数组(张量)中。想象一下，您需要对相同长度的多个向量执行<code class="fe lb lc ld le b">V*V.T</code>。你可以简单地把它们堆在一起，然后一次性得到所有的结果。</p><h1 id="0e87" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">个案研究</h1><p id="fa15" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">在这种情况下，我希望为<a class="ae la" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>生成一个欧几里德距离矩阵。欧几里得方程是:</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0754fb0068e1461f4998e7aff5780ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*33ddTk_7IMiDYU015NGFmQ.png"/></div></figure><p id="15ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">显然，可以使用两个嵌套的 for 循环来获取表:</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c0cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，它也可以使用矩阵运算来执行(这两种运算都要快 100 倍，而且要酷得多)。</p><p id="2771" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们取数据集(图中表示为<code class="fe lb lc ld le b">'A'</code>)，</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/f4f98de08f762402b87e2ec81eed4590.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*1HgzLIE6ZsG76LTRUi_cAw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A rectangle representing the iris data set, in which case m=150 and n=4.</figcaption></figure><p id="da73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建它的 3D 副本，并将其旋转到图中所示的方向<code class="fe lb lc ld le b">'B'</code>。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/1cf25f56e78ea4bb9676fe6c150eda58.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*ebfF0aIpm9-8Gu3ivbJgEQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We can use numpy’s rot90 function to rotate a matrix. See code below.</figcaption></figure><p id="47ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们创建另一个副本并旋转它，如<code class="fe lb lc ld le b">'C'</code>所示。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a2d71328ef6ecb23c35c3c6ec930bfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*tnig2m1cfCDNSKl3OTNhMw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Copy and rotate again.</figcaption></figure><p id="5563" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">B-C</code>将生成(通过广播！)一个 3D 立方体(<code class="fe lb lc ld le b">'D'</code>)，大小为<em class="lf"> (m，m，n) </em>，代表计算</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4faba48a98f1258d276dd86a7c7441fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:192/format:webp/1*JL7edHUM2uw5QD3_gzOQ6g.png"/></div></figure><p id="a811" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于原始数据集向量(<em class="lf"> n </em> =4)的每个实例(<em class="lf"> m </em>)和特征(<em class="lf"> n </em>)。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/cce7ad253a6c3ee18b7af98a3038203b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzrtP_j9it6dZwEZcJUTeA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Notice that we are summing up the features for all instances at once!</figcaption></figure><p id="6dd3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我们简单地将整个立方体提升到 2 的幂，将代表特征的轴上的结果相加(见上图)，然后平方。</p><p id="4741" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果就是距离矩阵(<code class="fe lb lc ld le b">'E'</code>)！</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/665b2accb6f2f9ce171777001bcbdaad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*0QrwzcNipZo6hFqhEjYmHg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This is the Euclidean distance matrix. It might seems like it only contains the letter ‘E’, but in fact it holds the distance between all instance pairs. Twice. The diagonal is the distance between every instance with itself, and if it’s not equal to zero, then you should double check your code…</figcaption></figure><p id="245b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你在所有这些矩阵的翻腾中迷失了，回头看看计算欧几里得矩阵的方程。我们所做的就是同时求解几个向量的方程。</p><h1 id="7495" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">代码:</h1><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="0ea7" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="a5b8" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">每当在几个实例上执行相同的计算时，广播是一种非常干净有效的方法。作为一个练习，我鼓励你尝试在 2 个 3D 阵列上使用广播(假设你有<em class="lf"> n </em>个向量，属于<em class="lf"> k </em>个类)。这意味着你将需要广播到第四维度。当然不可能<a class="ae la" href="https://www.youtube.com/watch?v=N7K5KjOdLD8" rel="noopener ugc nofollow" target="_blank">想象</a>，但是实现它遵循同样的逻辑。</p></div></div>    
</body>
</html>