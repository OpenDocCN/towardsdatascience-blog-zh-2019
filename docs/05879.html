<html>
<head>
<title>ARIMA Models with Turing.jl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ARIMA 模型与图灵. jl</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/arima-models-with-turing-jl-81dcf2a1094c?source=collection_archive---------11-----------------------#2019-08-27">https://towardsdatascience.com/arima-models-with-turing-jl-81dcf2a1094c?source=collection_archive---------11-----------------------#2019-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用概率编程语言(PPL) <a class="ae ki" href="https://turing.ml/dev/" rel="noopener ugc nofollow" target="_blank"> Turing.jl </a>进行时间序列分析和预测。茱莉亚的实现可以在<a class="ae ki" href="https://github.com/saumyagshah/JupyterNBTuringExamples/blob/master/time_series_ARIMA.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a> (Jupyter 笔记本)或者<a class="ae ki" href="https://github.com/saumyagshah/TuringExamples/blob/time_series_ARIMA/time_series_ARIMA.jl" rel="noopener ugc nofollow" target="_blank">这里</a>(。jl 文件)。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2901307dc9356694badf19691bf47900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IM3rYgCcXRXsXNm5"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Time Series Models often have useful applications in the field of finance; Photo by <a class="ae ki" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aaba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你好！</p><p id="a261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是我在 Julia Season of 投稿(JSoC) 2019 中完成的工作的一部分。它使用概率编程语言(PPL) <a class="ae ki" href="https://turing.ml/dev/" rel="noopener ugc nofollow" target="_blank"> Turing.jl </a>描述了 ARIMA 模型的 Julia 实现，这为定义概率模型提供了极大的便利。当我们在本文后面查看模型定义时，图灵的这一方面将变得更加明显。此外，图灵支持使用定制分布来指定模型。</p><p id="8ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，那我们就直入主题吧！</p><h2 id="9561" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">导入库</h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="3b4e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">加载和可视化数据集</h2><p id="5046" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我们将使用包含 1995 年至 2015 年标准普尔 500 调整后收盘值的数据集，每月一次。数据集可以从<a class="ae ki" href="https://github.com/inertia7/timeSeries_sp500_R/blob/master/data/data_master_1.csv" rel="noopener ugc nofollow" target="_blank">这里</a>(麻省理工学院许可)下载。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="349b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码后获得了下面的图。这就是我们的数据看起来的样子，绘制了每个时间指数的值:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/39a73a46938e959ae21ea1f8e4571fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8VM9sOTjkWR_P9cBG4Y0EQ.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Complete Data</figcaption></figure><p id="5e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将数据分为训练集和测试集，将 95%的数据作为训练集:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2649833f82c931faf93115c40fcc72b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*4643d_ZglNjnG1c0vVIaRw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Train Data</figcaption></figure><h2 id="c9c5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">检查稳定性</h2><p id="5377" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">从图中我们可以看出，这个数列的平均值在接近尾声时上升。所以，级数不是平稳的。这通过针对平稳性的增强 Dickey-Fuller (ADF)测试得到了加强:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ebeb5a980ec9a2e33f7ce6c51734637d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*KJtmBzSwk_x1X8WmEHZKtg.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">ADF test before differencing</figcaption></figure><p id="f1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们对时间序列进行差分，试图消除平稳性:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/dc7c2fb5914124b0f32f32b3bcba5998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*F9_m1WwTEiKyQtvmSjJgBw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Plot of the differenced time series</figcaption></figure><p id="5b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数列似乎有一个大致不变的平均值，尽管这并不一定意味着这个数列是平稳的。我们再次使用 ADF 测试:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/0e0bb69cb78a94d5bacb23d7b61f2b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*Q3cB3rVVwU7vKTv8qy-C0Q.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">ADF test after differencing</figcaption></figure><p id="6134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功！由于 p 值很低，我们可以有把握地假设这个序列是平稳的。借助于 ACF 和 PACF 图，我们现在可以继续为我们的差分时间序列选择 AR 和 MA 项。</p><h2 id="ef66" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">借助 ACF 和 PACF 图选择 MA 和 AR 术语</h2><p id="6277" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">为我们的训练数据获得的 ACF 和 PACF 图如下所示:</p><p id="097d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些图可以用以下方式来解释:</p><ul class=""><li id="e289" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">我们可以有一个一阶自回归项，因为在滞后 1 处有正自相关。</li><li id="e89f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">PACF 曲线逐渐衰减，ACF 曲线在几个滞后之后突然截止。这表明移动平均项的存在。这一项的顺序应该是 1，因为所有大于 1 的滞后没有显著的相关性。</li></ul><p id="397e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 ARIMA 模型中同时包含 AR 和 MA 术语并不常见。所以，我们不会考虑这种情况。从以上两点来看，似乎模型更有可能存在移动平均项。然而，我们将考虑 ARIMA 模型的两种可能情况:</p><ul class=""><li id="68b6" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><em class="nm"> ARIMA(1，1，0) </em></li><li id="ffda" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><em class="nm"> ARIMA(0，1，1) </em></li></ul><p id="9fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm"> ARIMA(p，d，q) </em>模型的符号定义如下:</p><ul class=""><li id="f095" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">p:自回归项的个数</li><li id="8108" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">问:移动平均线的条数</li><li id="0c90" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">差分的顺序</li></ul><p id="d385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实现了这两种情况，并使用赤池信息标准(AIC)对模型进行了比较。这个<a class="ae ki" href="https://people.duke.edu/~rnau/411arim.htm" rel="noopener ugc nofollow" target="_blank">网页</a>作为定义下面的<em class="nm"> ARIMA(1，1，0) </em>和<em class="nm"> ARIMA(0，1，1) </em>模型的参考。</p><h2 id="8e40" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">ARIMA(1，1，0)</h2><p id="b5a5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated"><em class="nm"> ARIMA(1，1，0) </em>模型定义如下:</p><pre class="kk kl km kn gt nn no np nq aw nr bi"><span id="a59a" class="lv lw it no b gy ns nt l nu nv"><a class="ae ki" href="http://twitter.com/model" rel="noopener ugc nofollow" target="_blank">@model</a> ARIMA110(x) = begin<br/>    T = length(x)<br/>    μ ~ Uniform(-10, 10)<br/>    ϕ ~ Uniform(-1, 1)<br/>    for t in 3:T<br/>        val = μ +                      # Drift term.<br/>              x[t-1] +                 # ARIMA(0,1,0) portion.<br/>              ϕ * (x[t-1] - x[t-2]) # ARIMA(1,0,0) portion.<br/>        x[t] ~ Normal(val, 1)<br/>    end<br/>end</span></pre><p id="4a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<em class="nm"> x </em>是原始时间序列，因为我们已经考虑了模型定义本身的差异。注意，我们将有一个自回归项，因为<em class="nm"> p = 1。</em></p><h2 id="5b61" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">ARIMA(0，1，1)</h2><p id="7452" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated"><em class="nm"> ARIMA(1，1，0) </em>模型定义如下:</p><pre class="kk kl km kn gt nn no np nq aw nr bi"><span id="5502" class="lv lw it no b gy ns nt l nu nv"><a class="ae ki" href="http://twitter.com/model" rel="noopener ugc nofollow" target="_blank">@model</a> ARIMA011(x) = begin<br/>    T = length(x)</span><span id="bccc" class="lv lw it no b gy nw nt l nu nv">    # Set up error vector.<br/>    ϵ = Vector(undef, T)<br/>    x_hat = Vector(undef, T)</span><span id="dcd8" class="lv lw it no b gy nw nt l nu nv">    θ ~ Uniform(-5, 5)</span><span id="e4d5" class="lv lw it no b gy nw nt l nu nv">    # Treat the first x_hat as a parameter to estimate.<br/>    x_hat[1] ~ Normal(0, 1)<br/>    ϵ[1] = x[1] - x_hat[1]</span><span id="f6b7" class="lv lw it no b gy nw nt l nu nv">    for t in 2:T<br/>        # Predicted value for x.<br/>        x_hat[t] = x[t-1] - θ * ϵ[t-1]<br/>        # Calculate observed error.<br/>        ϵ[t] = x[t] - x_hat[t]<br/>        # Observe likelihood.<br/>        x[t] ~ Normal(x_hat[t], 1)<br/>    end<br/>end</span></pre><p id="de47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的模型定义一样，<em class="nm"> x </em>是原始时间序列。注意，我们将有一个移动平均项，因为<em class="nm"> q = 1。</em></p><p id="af78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要注意的一点是，用图灵编写的代码与写在纸上的代码在本质上是一样的。从上面的模型定义中可以明显看出这一点，只要看一下代码就可以理解这些模型定义。</p><h2 id="53d6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">抽样</h2><p id="a6aa" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">使用螺母取样器对链条进行取样。你可以查看<a class="ae ki" href="https://turing.ml/dev/docs/library/#samplers" rel="noopener ugc nofollow" target="_blank">文档</a>来了解更多关于 NUTS 和图灵支持的其他几个采样器的信息。用于采样的代码如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e17f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得参数的可视化和汇总统计数据，您可以查看代码<a class="ae ki" href="https://github.com/saumyagshah/JupyterNBTuringExamples/blob/master/time_series_ARIMA.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a> (Jupyter 笔记本)或<a class="ae ki" href="https://github.com/saumyagshah/TuringExamples/blob/time_series_ARIMA/time_series_ARIMA.jl" rel="noopener ugc nofollow" target="_blank">这里</a>(。jl 文件)。</p><h2 id="39ee" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">比较 AIC 值</h2><p id="82f2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">阿凯克信息标准(AIC)衡量不同统计模型的相对“良好性”。因此，它可以用于模型比较的目的。AIC 值越低，模型越好。此外，人们必须记住，AIC 的绝对值并没有多大意义，相对值才是重要的。数学上，AIC 由下式给出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2977aa493c7952a044ef85feca314198.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ji6rmwR7j02t9NYP8kNkPA.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Formula for AIC</figcaption></figure><p id="7338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个公式，我们可以计算两个模型的 AIC 值。该<a class="ae ki" href="http://www.igidr.ac.in/faculty/susant/TEACHING/TSA/print06.pdf" rel="noopener ugc nofollow" target="_blank"> PDF </a>已被用作计算两个模型的 AIC 值的参考。</p><ul class=""><li id="d619" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><em class="nm"> ARIMA(1，1，0) </em></li></ul><pre class="kk kl km kn gt nn no np nq aw nr bi"><span id="31a5" class="lv lw it no b gy ns nt l nu nv">function calculate_aic_ARIMA110(β::Float64, μ:: Float64, σ::Float64, s::Array{Float64, 1})<br/>    T = length(s)<br/>    ϵ = Vector(undef, T)<br/>    s_pred = Vector(undef, T)<br/>    <br/>    s_pred[1], s_pred[2] = s[1], s[2]<br/>    ϵ[1], ϵ[2] = 0.0, 0.0 <br/>    for t in 3:T<br/>        s_pred[t] = μ +                      <br/>              s_pred[t-1] +                 <br/>              β * (s_pred[t-1] - s_pred[t-2]) <br/>        ϵ[t] = s_pred[t] - s[t]<br/>    end<br/>    log_likelihood = (-(T - 1)/2)*2*π*σ^2 - (1/σ^2)*sum(ϵ.^2) <br/>    - π*σ^2/(1 - β^2) - ((s[1] - μ/(1 - β))^2)/(2*σ^2/(1 - β^2))<br/>    aic = -2*log_likelihood + 2<br/>    return aic<br/>end</span></pre><p id="a1d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此函数，我们得到 ARIMA(1，1，0)的 AIC 值约为-299655.26</p><ul class=""><li id="86bd" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><em class="nm"> ARIMA(0，1，1) </em></li></ul><pre class="kk kl km kn gt nn no np nq aw nr bi"><span id="bcf7" class="lv lw it no b gy ns nt l nu nv">function calculate_aic_ARIMA011(β::Float64, σ::Float64, s::Array{Float64, 1})<br/>    T = length(s)</span><span id="83db" class="lv lw it no b gy nw nt l nu nv">    ϵ = Vector(undef, T)<br/>    s_pred = Vector(undef, T)</span><span id="fd23" class="lv lw it no b gy nw nt l nu nv">    s_pred[1] = s[1]<br/>    ϵ[1] = 0.0<br/>    for t in 2:T<br/>        s_pred[t] = s[t-1] - β * ϵ[t-1]<br/>        ϵ[t] = s[t] - s_pred[t]<br/>    end<br/>    log_likelihood = -(T/2)*log(2*π) - (T/2)*log(σ^2) +                                                                           (1/2*σ^2)*sum(ϵ.^2)  <br/>    aic = -2*log_likelihood + 1<br/>    return aic<br/>end</span></pre><p id="2153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此函数，我们得到 ARIMA(1，1，0)的 AIC 值约为 6.22 x 10⁷.</p><p id="5e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们可以看到 ARIMA(0，1，1)模型更好。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="6ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用 Turing.jl 写的关于 ARIMA 模型的文章到此结束，希望你会觉得有趣。如果你对这篇文章有任何问题或疑问，请随时联系我，邮箱是<a class="ae ki" href="https://saumyagshah.github.io/" rel="noopener ugc nofollow" target="_blank"> s </a> shah@iitk.ac.in，或者你可以在 Julia slack 上用@Saumya Shah 给我加标签。</p><h1 id="d6b1" class="of lw it bd lx og oh oi ma oj ok ol md jz om ka mg kc on kd mj kf oo kg mm op bi translated">参考</h1><p id="fb7a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">[1]ARIMA 模型介绍。(2019).检索于 2019 年 8 月 26 日，来自<a class="ae ki" href="https://people.duke.edu/~rnau/411arim.htm" rel="noopener ugc nofollow" target="_blank">https://people.duke.edu/~rnau/411arim.htm</a></p><p id="26d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]托马斯·s .(2009 年)。<em class="nm">估计 AR/MA 模型</em>【电子书】。检索自<a class="ae ki" href="http://www.igidr.ac.in/faculty/susant/TEACHING/TSA/print06.pdf" rel="noopener ugc nofollow" target="_blank">http://www . igi dr . AC . in/faculty/susant/TEACHING/TSA/print 06 . pdf</a></p></div></div>    
</body>
</html>