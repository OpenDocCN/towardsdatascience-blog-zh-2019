<html>
<head>
<title>Interactive Election Visualisations in Python with Altair</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 和 Altair 实现交互式选举可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interactive-election-visualisations-with-altair-85c4c3a306f9?source=collection_archive---------16-----------------------#2019-10-26">https://towardsdatascience.com/interactive-election-visualisations-with-altair-85c4c3a306f9?source=collection_archive---------16-----------------------#2019-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener" target="_blank" href="/visualising-elections-with-python-4973c0c60bbe">最近的一篇文章</a>中，我展示了我们如何用 matplotlib 生成 hexmaps 来可视化选举。虽然这些地图很好地展示了如何传达地理信息，但它们并非没有缺陷。例如，可能很难从静态图像中识别出哪个选区是哪个选区，因为要对选区进行操作以使它们大小相等。</p><p id="0d04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们将使用<a class="ae ko" href="https://altair-viz.github.io/" rel="noopener ugc nofollow" target="_blank"> Altair </a>，一个声明性的 Python 绘图库，来交付 hexmaps 的改进的交互式版本。你可以用我的<a class="ae ko" href="https://github.com/TTitcombe" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的笔记本来关注这篇文章<a class="ae ko" href="https://github.com/TTitcombe/ConstituencyMap/blob/master/examples/altair_examples.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2856" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们提醒自己，在上一篇文章之后，我们还剩下什么。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/25be0b5cc31e87f83c07ac3c635b8006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUbpb-Holf8Bt8OxWE4BiQ.png"/></div></div></figure><h1 id="44c5" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">阿尔泰尔</h1><blockquote class="lz ma mb"><p id="2486" class="jq jr mc js b jt ju jv jw jx jy jz ka md kc kd ke me kg kh ki mf kk kl km kn im bi translated">Altair 是一个用于 Python 的声明性统计可视化库</p></blockquote><p id="9761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本质上，这意味着我们定义我们的数据和输出(图表看起来像什么), Altair 将做所有的操作，把我们从输入带到输出。</p><p id="d5c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与 Python 可视化的主食 matplotlib 相比:对于 hexmap，我们必须明确指定每个六边形的坐标、旋转、大小和颜色<em class="mc">。</em></p><p id="bdef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然 matplotlib 对图形的最终状态提供了更多的控制，但实现基本的定制通常比 Altair 花费更多的时间、知识和精力(当然也比人们愿意付出的多)。</p><p id="2d55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Altair 是基于<a class="ae ko" href="https://vega.github.io/vega/" rel="noopener ugc nofollow" target="_blank"> Vega，</a>一个 JavaScript 绘图库构建的。要渲染交互式图形，您需要一个前端应用程序，如 Jupyter lab。</p><p id="f4f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Altair 可以通过 pip ( <code class="fe mg mh mi mj b">pip install -U altair vega_datasets jupyterlab</code>)或 conda ( <code class="fe mg mh mi mj b">conda install -c conda-forge altair vega_datasets jupyterlab</code>)安装。</p><h1 id="1d79" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据</h1><p id="755b" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">在本帖中，我们将展示 2017 年大选后英国议会的构成。这些数据可以从<a class="ae ko" href="https://data.gov.uk/dataset/b77fcedb-4792-4de4-935f-4f344ed4c2c6/general-election-results-2017" rel="noopener ugc nofollow" target="_blank"> gov.uk 网站</a>免费获得。该数据具有选区名称，<em class="mc">选区</em>，以及获胜政党的名称，<em class="mc">政党</em>。</p><p id="de27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经使用<a class="ae ko" href="https://odileeds.org/projects/hexmaps/constituencies/" rel="noopener ugc nofollow" target="_blank"> ODILeeds 的神奇 hexmap </a>为选区分配了十六进制坐标<em class="mc"> p </em>和<em class="mc"> q </em>。</p><h1 id="8228" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基本地图</h1><p id="0f8b" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">由于 Altair 的声明式风格，在其中生成基本的十六进制地图应该很简单。让我们来测试一下。</p><pre class="kq kr ks kt gt mp mj mq mr aw ms bi"><span id="b491" class="mt lc it mj b gy mu mv l mw mx">import altair as alt</span><span id="d992" class="mt lc it mj b gy my mv l mw mx">alt.Chart(data)<br/>    .mark_circle()<br/>    .encode(<br/>        x="q",<br/>        y="r",<br/>        color=alt.value("lightgray"),<br/>        size=alt.value(50),<br/>)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/42e3169b7744b7e2ee2e266a89c47009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*KCWYwoma1CgWqVYcL7rQiQ.png"/></div></figure><p id="9230" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让基本的 matplotlib 地图工作起来需要很多行代码(和很多小时的堆栈溢出);对于牛郎星，是七行。</p><p id="5228" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 Altair 中，我们首先创建一个包含我们希望使用的数据的<code class="fe mg mh mi mj b">Chart</code>对象。我们用<code class="fe mg mh mi mj b">mark_circle()</code>指定在图表上做什么类型的标记。然后我们<em class="mc">用它们应该表示的数据方面对标记的特征进行编码</em>，在这种情况下，我们设置来自数据列<strong class="js iu"> q </strong>的<strong class="js iu"> x </strong>值和来自数据列<strong class="js iu"> r </strong>的<strong class="js iu"> y </strong>值。此外，我们已经使用<code class="fe mg mh mi mj b">size=alt.value(50)</code>将每个圆的大小设置为一个常量。</p><p id="3761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定义了这几个简单的规则后，Altair 做了所有的脏活，产生了一个精彩的剧情。</p><p id="7231" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">诚然，目前这种颜色没有任何意义，也很暗淡。为了解决这个问题，我们需要向 Altair 提供一个将政党名称与特定颜色联系起来的方法。</p><pre class="kq kr ks kt gt mp mj mq mr aw ms bi"><span id="6b54" class="mt lc it mj b gy mu mv l mw mx">parties = ["Conservative", "Labour", "Lib Dem", "Green", ...]<br/>party_colours = ["darkblue", "red", "orange", "green", ...]  #etc.</span><span id="ad5a" class="mt lc it mj b gy my mv l mw mx">colours_obj = alt.Color(<br/>    "Party:N", <br/>    scale=alt.Scale(domain=parties, <br/>                    range=party_colours)<br/>)</span><span id="d228" class="mt lc it mj b gy my mv l mw mx">alt.Chart(data)<br/>    .mark_circle()<br/>    .encode(<br/>        x="q",<br/>        y="r",<br/>        color=colours_obj,<br/>        size=alt.value(50),<br/>)</span></pre><p id="3b8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mg mh mi mj b">alt.Color</code>对象告诉 Altair 从数据中的<strong class="js iu">方</strong>列获取颜色。然而，当事人是字符串，因此不能被解释为颜色；<code class="fe mg mh mi mj b">alt.Scale</code>将<em class="mc">域</em>参数中的所有方翻译成<em class="mc">范围</em>参数中相应的颜色。这与 matplotlib 形成鲜明对比，matplotlib 必须为每个对象定义一种颜色<em class="mc">。</em></p><p id="e053" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">matplotlib 图的一个负面特性是它没有图例:我不知道如何产生一个图例，将迭代绘制的六边形的颜色与一个政党名称联系起来。了解 matplotlib，即使可以给每个六边形添加一个标签，得到的图例也会为每个六边形添加一个条目<em class="mc">，而不会注意到重复。</em></p><p id="c843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许并不奇怪，传说在 Altair 中是一件小事——<code class="fe mg mh mi mj b">Color</code>对象会自动生成一个。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/1d471b28bd9bd1d451ee8e1d37740d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJacum03Zpxdm0uvXkvuJA.png"/></div></div></figure><h1 id="6f3f" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基本交互性</h1><p id="f974" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">至此，我们已经生成了一个取代 matplotlib 版本的地图。然而，它仍然遭受难以识别扭曲的地理边界的问题。除非你在寻找沿海选区，否则你很可能找不到。</p><p id="a4f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在每个六边形上添加文本来表示选区名称，但这要么太难阅读，要么使情节太大而无法欣赏。我们需要的是把静态图变成交互式的。幸运的是，对于这篇博文来说，Altair 擅长于交互性。</p><pre class="kq kr ks kt gt mp mj mq mr aw ms bi"><span id="6a42" class="mt lc it mj b gy mu mv l mw mx">alt.Chart(data)<br/>    .mark_circle()<br/>    .encode(<br/>        x="q",<br/>        y="r",<br/>        color=colours_obj,<br/>        size=alt.value(50),<br/>        tooltip=["Constituency:N"],<br/>)</span></pre><p id="d10d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Altair 在一行代码中集成了对工具提示的支持。这是一个强大的特性，可以立即提高图形的可用性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nb"><img src="../Images/647337b82faa9c9093c96fe97740ffbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_L1vHPwmQAhoD4qiY7fOpQ.gif"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Oxford: definitely not north of Twickenham</figcaption></figure><h1 id="0c4e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更多互动</h1><p id="5584" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">当然，<a class="ae ko" href="https://altair-viz.github.io/gallery/index.html#interactive-charts" rel="noopener ugc nofollow" target="_blank"> Altair 比工具提示提供了更多的交互性。我们将通过鼠标点击获得图表来突出显示某个政党的所有选区，从而对这些额外的产品进行取样。这种行为有助于识别一个团队在整个土地上的分布，否则可能会显示大量的颜色。</a></p><p id="d645" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先创建一个选择对象，并告诉它我们关心的重要信息是选择的<strong class="js iu">方</strong>。我们用<code class="fe mg mh mi mj b">add_selection</code>将这个交互选择元素添加到图表中。</p><p id="0bf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了改变行为，我们需要用条件参数替换静态标记参数。<code class="fe mg mh mi mj b">alt.condition</code>接受一个条件，一个满足条件时显示的值，一个不满足条件时显示的值。请注意，这种情况下的条件是选择对象。当选择对象的<strong class="js iu">方</strong>参数与标记牛郎星试图显示的<strong class="js iu">方</strong>参数相同时，满足条件。</p><pre class="kq kr ks kt gt mp mj mq mr aw ms bi"><span id="6556" class="mt lc it mj b gy mu mv l mw mx">selector = alt.selection_single(empty='all', fields=['Party'])</span><span id="52eb" class="mt lc it mj b gy my mv l mw mx">colours_condition = alt.condition(selector, <br/>                                  colours_obj,       <br/>                                  alt.value("lightgray")</span><span id="dde6" class="mt lc it mj b gy my mv l mw mx">alt.Chart(data)<br/>    .mark_circle()<br/>    .encode(<br/>        x="q",<br/>        y="r",<br/>        color=colours_condition,<br/>        size=alt.value(50),<br/>        tooltip=["Constituency:N"],<br/>).add_selection(selector)</span></pre><p id="b30a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个例子突出了 Altair 从复杂的绘图中摆脱了多少痛苦。我们甚至不必使用条件代码来获得条件行为。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ng"><img src="../Images/0e73bd2be930b53eac8f0efab1a6d454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gtZ4mlqUmolBNaKNNLyr6w.gif"/></div></div></figure><h1 id="5a8c" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">组合图表</h1><p id="4356" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我们通过展示如何一起显示多个图表来结束这篇文章。我们将添加一个条形图，显示每个政党的议员总数，这一信息很难从我们目前拥有的大量圆圈和颜色中提取出来。</p><p id="3ebe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们创建酒吧。这是一个与之前类似的过程，除了我们使用<code class="fe mg mh mi mj b">mark_bars</code>向 Altair 发出信号，令人震惊的是，我们希望在图表对象上标记条形。还要注意，我们将这个对象赋给了一个变量；我们将对我们的地图图表做同样的事情。</p><p id="8afa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">条形的<code class="fe mg mh mi mj b">y</code>值是每一方出现的次数。在其他绘图库中，我们需要在绘图前计算这些；牛郎星会用<code class="fe mg mh mi mj b">count()</code> <a class="ae ko" href="https://altair-viz.github.io/user_guide/transform.html#user-guide-aggregate-transform" rel="noopener ugc nofollow" target="_blank"> <em class="mc">聚合</em> </a>帮你做到这一点。</p><p id="11e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将在图表中添加一条水平线，以显示一个政党拥有多数席位的点。不幸的是，这是 Altair 容易出错的地方:简单地给该行赋予 y 值<code class="fe mg mh mi mj b">alt.value(325)</code> *不会产生正确的结果。相反，我们必须将阈值添加到我们的数据对象中，并告诉 Altair 使用它。</p><p id="65f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mc">*非技术方面——注:325 票技术上是下议院多数席位的门槛，但由于我们民主制度的“特点”，比如议长和新芬党，实际要求略低。</em></p><pre class="kq kr ks kt gt mp mj mq mr aw ms bi"><span id="15b1" class="mt lc it mj b gy mu mv l mw mx">df["threshold"] = 325<br/><br/>bars = base.mark_bar().encode(<br/>    x="Party:N",<br/>    y=alt.Y("count()", title="Number of MPs"),<br/>    color=colours_condition<br/>)<br/><br/>majority = base.mark_rule(color="black", strokeDash=[1, 1]).encode(<br/>    y="threshold:Q",<br/>    size=alt.value(3)<br/>)</span><span id="e57e" class="mt lc it mj b gy my mv l mw mx">map | (bars + majority)</span></pre><p id="0d56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">牛郎星图表对象可以很容易地组合，堆叠或连接。<code class="fe mg mh mi mj b">| </code>操作符水平堆叠图表对象，<code class="fe mg mh mi mj b">&amp;</code>垂直堆叠它们，<code class="fe mg mh mi mj b">+</code>将对象添加到同一个图表中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ng"><img src="../Images/651ab338ad736cacf51195d8a53e9716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8nardObmm4dQo8g2Yy4ZGw.gif"/></div></div></figure><h1 id="a52f" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">后续步骤</h1><p id="a08a" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">在这次对牛郎星的快速浏览中，我们创造了强大的可视化效果，这在其他库中可能要花更多的时间才能完成。</p><p id="1384" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管 Altair 可以轻松处理定制和复杂的情节，但它是一个利用率极低的软件包。它的交互性和无需干预的绘图方法可以而且应该使它成为 Python 用户的首选绘图库。</p><p id="fdfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在以后的文章中，我们将详细阐述这些情节，来想象在不同的投票制度下，英国的政治地理会如何演变。</p><p id="5f76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在我的<a class="ae ko" href="https://github.com/TTitcombe/ConstituencyMap" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这篇文章中使用的代码。</p></div></div>    
</body>
</html>