<html>
<head>
<title>There is No Argmax Function for Python List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 列表没有 Argmax 函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/there-is-no-argmax-function-for-python-list-cd0659b05e49?source=collection_archive---------10-----------------------#2019-03-05">https://towardsdatascience.com/there-is-no-argmax-function-for-python-list-cd0659b05e49?source=collection_archive---------10-----------------------#2019-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4210" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有三种方法可以解决它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80581e1de53d9c6c914debbf29aac381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g4y_6dVu-xLxL-_q"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@deffyall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Talles Alves</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">亲爱的 Python 程序员们，</strong></p><p id="9e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一个 Python 列表<code class="fe lv lw lx ly b">l = [50, 99, 67, 99, 48]</code>，如何找到列表的<strong class="lb iu"> <em class="lz"> argmax </em> </strong>？原来 Python list 没有内置的<strong class="lb iu"> <em class="lz"> argmax </em> </strong>函数！你不能只做<code class="fe lv lw lx ly b">argmax(l)</code>或<code class="fe lv lw lx ly b">max(l).index</code>。我能想到的第一件事是将列表转换成一个<em class="lz"> numpy </em>数组，或者<em class="lz"> pandas </em> DataFrame，或者甚至<em class="lz"> Tensorflow </em> tensor，如果你认为可以过度使用的话:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="e1ad" class="me mf it ly b gy mg mh l mi mj">import numpy as np<br/>l_np = np.asarray(l)<br/>print(l_np.argmax())</span><span id="db85" class="me mf it ly b gy mk mh l mi mj">import pandas as pd<br/>l_pd = pd.DataFrame({'l': l})<br/>print(l_pd.idxmax())</span><span id="6129" class="me mf it ly b gy mk mh l mi mj">import tensorflow as tf<br/>l_tf = tf.constant(l)<br/>with tf.Session() as sess:<br/>    print(sess.run(tf.argmax(l_tf)))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/c07d9f3b4dd11bd652d118a43e761642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*jptaRb6q--YEnj7zdzBWGw.jpeg"/></div></figure><p id="ec51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们都返回<code class="fe lv lw lx ly b">1</code>，就像他们应该的那样。如果多个项目达到最大值，函数将返回遇到的第一个项目。但是将一个对象转换成另一种数据类型感觉像作弊，而且还需要更多的执行时间。以下是几种修复方法:</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="3db6" class="mt mf it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">1.传统 C 逻辑</h1><p id="5792" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">构建一个 for 循环，手动检查每一个元素，它工作得非常好。但是，它由多行可读性不太好的代码组成。与下面讨论的替代方案相比，它还需要稍微多一点的计算时间。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="1c07" class="me mf it ly b gy mg mh l mi mj">index, max_val = -1, -1<br/>for i in range(len(l)):<br/>    if l[i] &gt; max_val:<br/>        index, max_val = i, l[i]<br/>print(index)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/190b4936d6d060b9b476aa6a4f4beb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L2jDqdyU0t1KVm3M"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@nikhilmitra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nikhil Mitra</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="0150" class="mt mf it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">2.用计数器枚举</h1><p id="8a3d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们可以利用 Python 中<code class="fe lv lw lx ly b">enumerate</code>函数的内置计数器。注意<code class="fe lv lw lx ly b">max((x,i) for i,x in enumerate(l))[1]</code>返回<strong class="lb iu">最后一个</strong>最大项的索引，但是可以通过</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="bceb" class="me mf it ly b gy mg mh l mi mj">-max((x,-i) for i,x in enumerate(l))[1]</span></pre><p id="2266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这绝不是可读的。我们还可以通过使用<code class="fe lv lw lx ly b">zip</code>来模仿<code class="fe lv lw lx ly b">enumerate</code>函数，使其更具可读性:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="bca8" class="me mf it ly b gy mg mh l mi mj">max(zip(l, range(len(l))))[1]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/213b40b8a3012f3686cfb0d7ca1489b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R7iOeZulCFiay5J6"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@tomas_nz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tomas Sobek</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="fc53" class="mt mf it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">3.更改密钥</h1><p id="9449" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这可能是最可读的黑客。原来我们还是可以使用默认的<code class="fe lv lw lx ly b">max</code>功能。但是我们没有将列表作为参数传递，而是将索引列表作为参数传递，并将一个函数作为“key”传递。该函数将索引映射到列表中相应的元素。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="d3b7" class="me mf it ly b gy mg mh l mi mj">f = lambda i: l[i]<br/>max(range(len(l)), key=f)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/7931bbd359fe505326a8dab71e237fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXRt0wS4ZRNv9Ai6"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@silas_crioco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Silas Köhler</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="70ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，Python 列表上执行<strong class="lb iu"> <em class="lz"> argmax </em> </strong>的三种方法。</p><h2 id="b3ec" class="me mf it bd mu ns nt dn my nu nv dp nc li nw nx ne lm ny nz ng lq oa ob ni oc bi translated">相关文章</h2><p id="13cd" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">感谢您的阅读！如果您对 Python 感兴趣，请查看以下文章:</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/5-python-features-i-wish-i-had-known-earlier-bc16e4a13bf4"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">我希望我能早点知道的 5 个 Python 特性</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">超越 lambda、map 和 filter 的 Python 技巧</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/visualizing-bike-mobility-in-london-using-interactive-maps-for-absolute-beginners-3b9f55ccb59"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">使用交互式地图和动画可视化伦敦的自行车移动性</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">探索 Python 中的数据可视化工具</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><p id="1a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">原载于我的博客</em><a class="ae ky" href="https://edenau.github.io" rel="noopener ugc nofollow" target="_blank"><em class="lz">edenau . github . io</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>