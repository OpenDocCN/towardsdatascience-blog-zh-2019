<html>
<head>
<title>Key Kubernetes Concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 的关键概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/key-kubernetes-concepts-62939f4bc08e?source=collection_archive---------3-----------------------#2019-04-10">https://towardsdatascience.com/key-kubernetes-concepts-62939f4bc08e?source=collection_archive---------3-----------------------#2019-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="21ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">云计算、容器化和容器编排是 DevOps 中最重要的趋势。无论您是数据科学家、软件开发人员还是产品经理，了解 Docker 和 Kubernetes 的基础知识都是有益的。这两种技术都有助于你与其他人合作，部署你的项目，并增加你对雇主的价值。</p><p id="2c74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将介绍 Kubernetes 的基本概念。有很多 Kubernetes 的术语，这可能会使它变得令人生畏。我会帮你做一个心智模型来加速你对技术的理解。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3588bd66a694a768a98a3a6db1071db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mg6Ii8ibJPomegYj1tn8Ag.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Orchestrating the movement of shipping containers</figcaption></figure><p id="f41f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你首先了解 Docker 概念，Kubernetes 会更有意义。查看我的码头指南，学习基本原理。</p><div class="le lf gp gr lg lh"><a rel="noopener follow" target="_blank" href="/learn-enough-docker-to-be-useful-b7ba70caeb4b"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">学习足够的码头工人是有用的</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">第 1 部分:概念景观</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">towardsdatascience.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv ky lh"/></div></div></a></div><p id="a5c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后回到这里学习如何编排这些 Docker 容器。</p><h1 id="bdda" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">Kuberwhat？</h1><p id="acfa" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">Kubernetes 是一个开源平台，用于管理生产中的容器化应用。Kubernetes 简称 K8s。展望未来，我将主要使用术语<em class="mz"> K8s </em>，因为谁不喜欢效率呢？😃</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c69a64450ef7cbe3108f980472bbc413.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*nJACeVQHoVi7QYcc6Eqk3w.png"/></div></figure><p id="afec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 火爆。正如你在下面的图表中看到的，谷歌对它的搜索在过去的五年中增长迅速。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/afe994de274294d8a14d426465c442cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2qc67GtA52dZrbpQbORmw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Worldwide search interest for <em class="nc">kubernetes</em></figcaption></figure><p id="2349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 为什么这么抢手？Kubernetes 使您更容易自动扩展应用程序，减少停机时间，并提高安全性。无需再编写脚本来检查、重启和更改 Docker 容器的数量。取而代之的是，你告诉 K8s 你想要的集装箱数量，它会为你完成工作。K8s 甚至可以根据使用的资源自动缩放容器。</p><p id="9642" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes 是所有关于抽象的复杂性。它提供了与应用程序开发环境接口的清晰要点。</p><p id="6e2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 对于一个每天只有少量访问者的基本静态网站来说没有太大意义。它的用例是用于可能需要快速伸缩的大型应用程序。</p><p id="1c26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于大型应用程序，您可以使用 K8s 来充分利用您的计算和存储资源。当与云提供商配对时，K8s 可以为您省钱。💰无论您在哪里运行 K8s，它都应该可以帮助您节省时间并减少 DevOps 的麻烦。</p><p id="3874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker 有一个名为<a class="ae nd" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank">的竞争产品 Docker Swarm </a>，它编排容器。但是，它没有 K8s 那样的功能和市场份额。虽然你可能认为 Docker 在 K8s 有自己的产品时不会很好地与 K8s 配合，但两者配合得非常好。我强烈建议你使用 K8s 来编排你的容器。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b2df084c8eff79ffb7c0f47162c7fad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*skAU3Q_nyw1RR9Xh6X8Zpg.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Playing nicely</figcaption></figure><p id="24a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保持许多 K8s 抽象的直线可能是棘手的。我将解释关键部分是如何组合在一起的，这样您就可以理解这个强大的平台了。让我们来探讨 K8s 的关键概念以及它们之间的关系。</p><p id="a5fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将看看六个抽象层和组成它们的部分。然后我们将看看其他七个关键的 K8s API 对象。</p><h1 id="d2fe" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">K8s 的六层</h1><p id="6d47" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">让我们假设你有一个持续运行的应用，不需要存储状态。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/69182afd197770d4ab3bb366fdda9d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*YggVOtB-mep_HP1C4rhpGg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Kubernetes abstractions for a Deployment. © Jeff Hale 2019</figcaption></figure><p id="e998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是 K8s 概念的六层，从最高层的抽象开始。</p><ol class=""><li id="6cf7" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn nl nm nn no bi translated">部署</li><li id="c988" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">复制集</li><li id="9b94" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">豆荚</li><li id="50b9" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">节点集群</li><li id="5792" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">节点流程</li><li id="5785" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">码头集装箱</li></ol><p id="ba7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部署<em class="mz"> </em>创建和管理复制集，复制集创建和管理 pod，pod 运行在节点上，节点上有容器运行时，运行您放在 Docker 映像中的应用程序代码。听起来像爱尔兰民歌“<a class="ae nd" href="https://en.wikipedia.org/wiki/The_Rattlin%27_Bog" rel="noopener ugc nofollow" target="_blank">拉特林沼泽</a>”。😄</p><p id="9ba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个分解了工作节点流程的图表。让我们挖一点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/5a31f92f4915f46eb338076c4a8b88a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4TTxjBCff9GVRfTZy8GGw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Detailed Kubernetes abstraction Deployment levels. © Jeff Hale 2019</figcaption></figure><p id="6a0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">蓝色阴影的层次是更高层次的 K8s 抽象。绿色级别表示您应该知道但不能接触的节点和节点子流程。</p><p id="5585" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，您的 K8s 实例通常会有多个可以在单个节点上运行的 pod。</p><p id="bc2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker 容器包含您的应用程序代码。</p><p id="7e91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">***语法插曲* * *</p><p id="4b31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据 K8s 自己的<a class="ae nd" href="https://kubernetes.io/docs/contribute/style/style-guide/" rel="noopener ugc nofollow" target="_blank">风格指南</a>，API 对象如<em class="mz"> Pods </em>的大写应该遵循“实际对象名中使用的相同的大写和小写字母”然而，在文档中经常没有遵循这一准则——API 对象的大写或小写似乎是随机的。</p><p id="20e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将遵循我的 K8s 文章和大写错误中的风格指南声明的政策。</p><p id="dc11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">* * *语法插曲结束。😄***</p><p id="f748" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从最高的抽象层次开始，分别看一下这六个层次。</p><h1 id="8657" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">部署</h1><p id="b467" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">如果你想创建一个持续运行的无状态应用，比如 HTTP 服务器，你需要一个部署。部署允许您在不停机的情况下更新正在运行的应用程序。部署还指定了一个当吊舱死亡时重启的策略。</p><p id="b8ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以从命令行或配置文件创建部署。我将在以后的文章中向您展示这两种方法，所以请跟随<a class="ae nd" href="https://medium.com/@jeffhale" rel="noopener"> me </a>以确保您不会错过它们。😄</p><h1 id="0b47" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">复制集</h1><p id="a366" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">部署会创建一个副本集，确保您的应用程序具有所需数量的 pod。复制集将根据您在部署中指定的触发器创建和缩放窗格。</p><p id="418d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mz">复制控制器</em>执行与复制集相同的功能，但是复制控制器是老式的。复制集是 2019 年管理复制 pod 的智能方式。</p><h1 id="e218" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">豆荚</h1><p id="8142" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><a class="ae nd" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pods-and-controllers" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> Pod </em> </a>是 Kubernetes 的基本构建模块。一个 Pod 包含一组一个或多个容器。通常，每个 Pod 有一个容器。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0226a3d35375033a09f1fe60b9d7ffeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ziwaLWYlP_X4gHhf6uuYww.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Pod</figcaption></figure><p id="124c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">pod 处理容器的容量、机密和配置。</p><p id="0635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">豆荚是短暂的。它们在死亡时会自动重启。</p><p id="1f35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当应用程序被 ReplicationSet 水平缩放时，窗格被复制。每个 Pod 将运行相同的容器代码。</p><p id="6791" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">豆荚生活在工人节点上。</p><h1 id="5a97" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">集群级别</h1><h2 id="a270" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">串</h2><p id="240a" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">一个 K8s 集群由一个 C <em class="mz">集群主节点</em>和<em class="mz">工作节点组成。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/a83200abcf40438aa5f835df89bb179a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vT2FsK1vXVu42yipNoagSQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Star Cluster. Credit: <a class="ae nd" href="https://www.spacetelescope.org/images/heic0715a/" rel="noopener ugc nofollow" target="_blank">NASA, ESA and the Hubble Heritage (STScI/AURA)-ESA/Hubble Collaboration</a></figcaption></figure><p id="35bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个集群的示意图。该图强调了如何在一个 Worker 节点上运行多个 Pods，以及如何由一个 Master 管理多个 Worker 节点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/8cc9963f6ea7529768b7c912096306ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*gT5K52iFTJf6SDhwWBaClQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Kubernetes Nodes, Pods, &amp; Containers © Jeff Hale 2019</figcaption></figure><h2 id="9e13" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">工作节点</h2><p id="161d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">一个<a class="ae nd" href="https://kubernetes.io/docs/concepts/architecture/nodes/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">职工节点</em> </a> <em class="mz"> </em>就是<em class="mz"> </em>也简称<em class="mz">节点</em>简称<em class="mz">。</em>节点是机器的抽象，可以是物理机，也可以是虚拟机。把一个节点想象成一台计算机服务器。</p><p id="de1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个或多个 pod 在单个工作节点上运行。</p><p id="bfb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Pod 从不在两个节点之间拆分，它的内容总是位于同一节点上并一起计划。</p><p id="adfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谁在告诉工人节点做什么？大师。</p><h2 id="7a1b" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">集群主机</h2><p id="c88a" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><em class="mz"> </em> <a class="ae nd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#master" rel="noopener ugc nofollow" target="_blank"> <em class="mz">群主</em> </a> <em class="mz"> </em>有着多得严重可笑的别名。它也被称为<em class="mz">主节点、Kubernetes 主节点、集群控制平面、</em>控制平面、<em class="mz">和</em>主节点。不管你叫它什么，它都指挥工人节点。主设备做出调度决策、响应事件、实施更改并监控集群。</p><p id="3aad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">工作节点和主节点都有子流程组件。</p><h1 id="1d22" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">节点流程</h1><h2 id="b4bc" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">主组件</h2><p id="da7c" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">主要组件是<em class="mz"> API </em> <em class="mz">服务器(</em>又名<em class="mz"> kube-apiserver) </em>、<em class="mz"> etcd </em>、S <em class="mz">调度器</em>(又名<em class="mz">kube-调度器)、kube-控制器-管理器和云控制器管理器</em>。**为了完整起见，我于 2019 年 4 月 10 日添加了控制者-管理者* *</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/fa0785177d360838b111db00e911a6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*2B3eMo0iCx3GCPoHWHd1EQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Cluster Master subprocesses</figcaption></figure><p id="7fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们简单看一下每一个。</p><p id="ac56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mz"> API 服务器</em> </strong> —公开 K8s API。这是 Kubernetes 控制的前端。(又名。kube-apiserver)认为<em class="mz">枢纽</em>。<br/> <strong class="js iu"> <em class="mz"> etcd </em> </strong> —集群状态数据的分布式键值存储。思考<em class="mz">集群信息</em>。<br/> <strong class="js iu"> <em class="mz">调度器</em> </strong> —选择新窗格的节点。好导<a class="ae nd" href="https://medium.com/@dominik.tornow/the-kubernetes-scheduler-cd429abac02f" rel="noopener">这里</a>。(又名 kube-scheduler)想想<em class="mz">匹配器</em>。<br/><strong class="js iu"><em class="mz">kube-controller-manager</em></strong>—运行控制器来处理集群后台任务的进程。想想<em class="mz">集群控制器</em>。<br/> <strong class="js iu"> <em class="mz">云控制器管理器</em> </strong> <em class="mz"> — </em>运行与云提供商交互的控制器。想<em class="mz">云接口</em>。</p><h2 id="1658" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">工作节点组件</h2><p id="4bc3" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">Worker 节点的<a class="ae nd" href="https://kubernetes.io/docs/concepts/overview/components/#node-components" rel="noopener ugc nofollow" target="_blank">组件</a>是<em class="mz"> kubelet </em>、<em class="mz"> kube-proxy </em>和<em class="mz">容器运行时</em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1d43336883296a44554e73fc2a28caa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*rrm3H9IVzNOrlLmJsvE4dg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Worker Node subprocesses</figcaption></figure><p id="605d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"><em class="mz"/></strong>—负责工人节点上的一切。它与主服务器的 API 服务器通信。想<em class="mz">脑</em>为工节点。<br/><a class="ae nd" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="mz">kube-proxy</em></strong></a>—将连接路由到正确的 pod。还跨服务单元执行负载平衡。想想<em class="mz">交警</em>。<br/> <strong class="js iu"> <em class="mz">容器运行时</em> </strong> —下载图像并运行容器。例如，Docker 是一个容器运行时。想<em class="mz">码头工人</em>。</p><p id="530a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们深入到最后一个层次，看看那些容器运行时运行的是什么。😄</p><h1 id="4cd5" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">码头集装箱水平</h1><p id="09ea" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">如果你想用 K8s 运行你的应用，你的应用需要在某种容器中。Docker 是目前最常见的容器平台。我们假设你正在使用它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c6e2b05f458b26fd8a957e9beac6e222.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*glD7bNJG3SlO0_xNmSGPcQ.png"/></div></figure><p id="bb67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在创建部署时，您将指定 pod 应该使用哪个 Docker 映像。容器运行时将下载映像并创建容器。</p><p id="2105" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 不直接创建容器。它创造了容纳容器的容器。Pod 中的容器共享任何已配置的资源，例如卷存储。</p><p id="0223" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有五个管理和运行 pod 的高级 K8s API 资源:<em class="mz">部署、StatefulSets、DaemonSets、Jobs、</em>和<em class="mz"> CronJobs </em>。这些对象负责管理和运行创建和运行容器的窗格。让我们看看这些创建和管理连续流程的控制器</p><h1 id="fd17" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">副本集、状态集和守护集</h1><p id="3794" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">如你所见，一个<em class="mz"> </em>复制集<em class="mz"> </em>创建并管理 pod。如果一个 Pod 由于一个节点故障而关闭，复制集可以自动替换另一个节点上的 Pod。通常应该通过部署创建副本集，而不是直接创建，因为使用部署更新应用程序更容易。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fb254930cc6fdf9a65eb151264528b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*4J08LAIHRduvtlaj_KzJGA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">A Volume can be attached to a ReplicaSet or a StatefulSet. © Jeff Hale 2019</figcaption></figure><p id="2328" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时候你的程序需要保存状态信息。你可以把状态想象成你的用户与你的应用程序交互的当前状态。所以在一个视频游戏中，它是用户角色在某个时间点的所有独特方面。</p><p id="11c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，最初的<a class="ae nd" href="https://en.wikipedia.org/wiki/Super_Mario#Super_Mario_Bros." rel="noopener ugc nofollow" target="_blank">超级马里奥兄弟</a>游戏中的状态将包括用户游戏的每个相关方面:什么级别，该级别中的什么位置，大还是小，火球还是没有火球，多少硬币，多少点数，以及多少条生命。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/6cc18cb93cfbc54e57a793096c26f885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ofsyr1MsOaxCerN6fa0A-w.jpeg"/></div></div></figure><p id="a3c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你的应用程序有你需要跟踪的状态时，你会怎么做？使用 StatefulSet。</p><h2 id="75a3" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">状态集</h2><p id="502d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">像 ReplicaSet 一样，<em class="mz"/><a class="ae nd" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"><em class="mz">stateful set</em></a><em class="mz"/>根据容器规范管理一组 pod 的部署和伸缩。与部署不同，StatefulSet 的 pod 不可互换。每个 Pod 都有一个唯一的、持久的标识符，控制器在任何重新调度中都维护该标识符。StatefulSets 适用于持久的、有状态的后端，如数据库。</p><p id="0f60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Pod 的状态信息保存在与 StatefulSet 相关联的卷中。我们稍后将讨论体积。</p><h2 id="581b" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">达蒙塞特</h2><p id="4630" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><a class="ae nd" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> DaemonSets </em> </a>为连续过程。每个节点运行一个 Pod。添加到群集的每个新节点都会自动获得一个由 DaemonSet 启动的 Pod。DaemonSets 对于正在进行的后台任务(如监控和日志收集)非常有用。</p><p id="b864" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">StatefulSets 和 DaemonSets 不受部署控制。尽管它们与副本集处于同一抽象级别，但在当前的 API 中，它们并没有更高的抽象级别。</p><p id="66b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们来看看乔布斯和 CronJobs。</p><h1 id="fe26" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">乔布斯和克朗乔布斯</h1><h2 id="801f" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">职位</h2><p id="6fd1" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">一个<a class="ae nd" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">任务</em> </a> <em class="mz"> </em>是运行批处理的 pod 的主管。作业创建 Pod，并通过跟踪成功完成 Pod 的数量来确保它们执行任务。与复制集不同，一旦容器内的进程成功完成，容器不会重新启动。当您想要运行一次流程时，请使用作业。</p><h2 id="272c" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">克朗乔布</h2><p id="7f21" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">如果您想要在定期、指定的时间(例如每小时、每天或每月)运行作业，请创建一个<a class="ae nd" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> CronJob </em> </a> <em class="mz">。</em>cron Job 类似于一个作业，但被安排在固定的时间间隔或设定的时间重复。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f20a0f1294b52e1f3c98d467b317a1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*jsgssp7WXxxYULDxk_jVbw.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Time</figcaption></figure><p id="494a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您通常需要创建一个服务来提供对临时 pod 的一致访问。</p><h1 id="a90b" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">服务</h1><p id="894d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">K8s <a class="ae nd" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">服务</em> </a>为一组 pod 创建单个接入点。服务提供一致的 IP 地址和端口来访问底层 pod。外部用户和内部 pod 都使用服务与其他 pod 通信。</p><p id="f605" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务有多种形式。与 K8s 联网是一个值得自己指导的话题。幸运的是，这里有一本由 Sandeep Dinesh 写的好书。</p><p id="1fb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看用卷和持久卷存储数据。</p><h1 id="d776" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">卷、持久卷和持久卷声明</h1><h2 id="a92a" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">卷</h2><p id="a340" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">一个<a class="ae nd" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">卷</em> </a>是一个可以容纳数据的目录。卷是 Pod 的一个组件，并不独立于它。在 Pod 规格中创建一个卷。不能单独删除卷。</p><p id="eb53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个卷可供 Pod 中的所有容器访问。您想要访问卷的每个容器必须单独装载它。</p><p id="b5fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 卷比任何单个容器都长寿，但是当封装容器死亡时，该卷也会死亡。但是，某些卷类型的文件会继续存在于本地或云存储中，即使在卷消失后也是如此。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a926af047730ecfd07143546e489efb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*7NY9Itkqy57i_Hd8uP-FuA.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Volumes</figcaption></figure><p id="c0bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 卷比 Docker 卷具有更多功能。卷可以提供对本地磁盘存储、内存存储或云存储的访问。一个 Pod 可以同时使用它们的组合。</p><p id="be5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">K8s 卷类型包括空目录、工作节点的文件系统和特定于云提供商的存储。例如，awsElasticBlockStore 和 gcePersistentDisk 是用于长期存储的特定于提供程序的选项。点击查看更多文档<a class="ae nd" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="f6c6" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">持久卷和持久卷声明</h2><p id="4b33" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">为了帮助抽象出基础设施细节，K8s 开发了<a class="ae nd" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank"> <em class="mz">持久卷</em> </a> <em class="mz"> </em>和<em class="mz">持久卷声明</em>。不幸的是，这些名称有点误导，因为普通卷也可以有持久存储。</p><p id="d725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与单独使用卷相比，PersisententVolumes (PV)和 PersisentVolumeClaims (PVC)增加了复杂性。但是，PV 对于管理大型项目的存储资源非常有用。</p><p id="5b0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用 PVs，K8s 用户最终仍然会使用一个卷，但是首先需要两步。</p><ol class=""><li id="fa3f" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn nl nm nn no bi translated">持久卷由群集管理员提供(或动态提供)。</li><li id="3a33" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">需要存储 Pod 的单个集群用户创建了一个<em class="mz"> PersistentVolumeClaim </em>清单。它指定了他们需要多少和什么类型的存储。K8s 然后找到并保留所需的存储。</li></ol><p id="50b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，用户创建一个包含使用 PVC 的卷的 Pod。</p><p id="28a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">持久卷具有独立于任何 Pod 的生命周期。事实上，Pod 甚至不知道 PV，只知道 PVC。</p><p id="d77d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PVC 消耗 PV 资源，类似于 pod 消耗节点资源的方式。狂野！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/372773fd3bbed23eaab63fc3f4140f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58estJjCSLocLzWKP3sm0w.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Wild</figcaption></figure><h1 id="c231" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">包装</h1><p id="2aa4" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">我希望这篇 K8s 概念的介绍对您有所帮助。如果你有，请在你最喜欢的社交媒体上分享，这样其他人也可以找到它。👍</p><p id="b2e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回顾一下我们见过的 K8s 概念。以下是部署的六个抽象级别:</p><ul class=""><li id="b952" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn oq nm nn no bi translated"><strong class="js iu">部署</strong>:管理副本集。用于持久、无状态的应用程序(例如 HTTP 服务器)。</li><li id="1a37" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">复制集</strong> <em class="mz"> : </em>创建并管理 pod。</li><li id="3fc5" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">Pod</strong><em class="mz">:</em>K8s 的基本单位。</li><li id="e04a" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">节点集群</strong>:工作节点+集群主节点。<br/> - <strong class="js iu">工人</strong> <strong class="js iu">节点</strong>:用于 pod 的机器。<br/> - <strong class="js iu">集群主</strong> <em class="mz"> : </em>指挥工作节点。</li><li id="1d5b" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">节点进程</strong> <br/> Master 子组件:<br/> - <strong class="js iu"> API 服务器</strong> : hub。<br/> - <strong class="js iu"> etcd </strong>:集群信息。<br/> - <strong class="js iu">调度器</strong>:匹配器。<br/>-<strong class="js iu">kube-controller-manager<em class="mz">:</em></strong>集群控制器。<br/> - <strong class="js iu">云-控制器-管理器:</strong>云接口。<br/>工作者节点子组件:<br/> - <strong class="js iu"> kubelet </strong>:工作者节点大脑。<br/> - <strong class="js iu"> kube-proxy </strong>:交警。<br/> - <strong class="js iu">容器-运行时</strong> : Docker。</li><li id="09fe" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu"> Docker 容器:</strong>app 代码所在的地方。</li></ul><p id="c29f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是需要了解的 7 个额外的高级 K8s API 对象:</p><ul class=""><li id="104f" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn oq nm nn no bi translated"><strong class="js iu"> StatefulSet </strong>:类似于有状态进程的复制集。想好<em class="mz">状态</em>。</li><li id="5f24" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu"> DaemonSet: </strong>每个节点一个自动 Pod。想<em class="mz">班长</em>。</li><li id="970c" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">作业</strong>:运行容器直至完成。想<em class="mz">批</em>。</li><li id="2dc0" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu"> CronJob: </strong>重复作业。<strong class="js iu"> </strong>想<em class="mz">时间</em>。</li><li id="5ec9" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">服务</strong>:吊舱的接入点。想<em class="mz">接入点</em>。</li><li id="d78a" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu">卷</strong>:保存数据。想想<em class="mz">盘。</em></li><li id="67af" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><strong class="js iu"> PersistentVolume，PersistentVolumeClaim: </strong>分配存储的系统。认为<em class="mz">存储索赔</em>。</li></ul><p id="9fc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把你的头缠在 K8s 上需要理解很多抽象的概念。不要期望你第一次就能记住它们。查看下面的一些资源来建立你的心智模型。</p><h2 id="ebc7" class="nv lx it bd ly nw nx dn mc ny nz dp mg kb oa ob mk kf oc od mo kj oe of ms og bi translated">资源</h2><p id="80c5" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">以下是巩固你所学内容的资源。</p><ul class=""><li id="b9d1" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn oq nm nn no bi translated">这里有一幅来自谷歌的很好的漫画，介绍了一些关键概念。</li><li id="c165" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated"><a class="ae nd" href="https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16" rel="noopener">Daniel Sanche</a>对关键 K8s 概念的另一个很好的概述。</li><li id="6900" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn oq nm nn no bi translated">看看奈杰尔·波尔顿的《库伯内特的书》——现在在 v3。Kindle Book 最后一次更新是在 2018 年 11 月。</li></ul><p id="e4d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有，关注<a class="ae nd" href="https://medium.com/@jeffhale" rel="noopener">我</a>确保你不会错过我以后在 K8s 上的文章。在<a class="ae nd" rel="noopener" target="_blank" href="/key-kubernetes-commands-741fe61fde8?source=friends_link&amp;sk=42b902d4c337496eb2d5cf40f21e51c6">的下一篇文章</a>中，我将向您介绍如何设置和运行您的第一个 K8s 部署，并介绍关键的 K8s 命令。</p><p id="5888" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我写关于<a class="ae nd" href="https://memorablepython.com" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae nd" href="https://memorablesql.com" rel="noopener ugc nofollow" target="_blank"> SQL </a>、<a class="ae nd" href="https://memorabledocker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>和数据科学的文章。查看我的文章<a class="ae nd" href="https://medium.com/@jeffhale" rel="noopener">这里</a>如果你对这些感兴趣，请关注我。😄</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://dataawesome.com"><div class="ab gu cl or"><img src="../Images/ba32af1aa267917812a85c401d1f7d29.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oPkqiu1rrt-hC_lDMK-jQg.png"/></div></a></figure><p id="7b20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">开心 K8ing！</p></div></div>    
</body>
</html>