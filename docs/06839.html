<html>
<head>
<title>Matplotlib+ Seaborn + Pandas: An Ideal Amalgamation for Statistical Data Visualisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Matplotlib+ Seaborn + Pandas:统计数据可视化的理想融合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matplotlib-seaborn-pandas-an-ideal-amalgamation-for-statistical-data-visualisation-f619c8e8baa3?source=collection_archive---------4-----------------------#2019-09-29">https://towardsdatascience.com/matplotlib-seaborn-pandas-an-ideal-amalgamation-for-statistical-data-visualisation-f619c8e8baa3?source=collection_archive---------4-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ffb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">探索性数据分析包括两个基本步骤</p><ol class=""><li id="3305" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">数据分析(数据预处理、清理和处理)。</li><li id="c31e" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">数据可视化(使用不同类型的图来可视化数据中的关系)。</li></ol><p id="225c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Pandas 是 python 中最常用的数据分析库。python 中有大量用于数据可视化的库，其中 matplotlib 是最常用的。Matplotlib 提供了对情节的完全控制，使情节定制变得容易，但它缺乏对熊猫的支持。Seaborn 是一个构建在 matplotlib 之上的数据可视化库，与 pandas 紧密集成。</p><p id="47a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个职位将负责，</p><ol class=""><li id="2326" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">seaborn 有不同类型的地块。</li><li id="906f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">熊猫和 seaborn 的整合如何帮助用最少的代码制作复杂的多维情节？</li><li id="f4fa" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">如何在 matplotlib 的帮助下定制使用 seaborn 制作的情节？</li></ol><h2 id="9668" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">谁应该阅读这篇文章？</h2><p id="6d8a" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">如果你有 matplotlib 和 pandas 的工作知识，并且想探索 seaborn，这是一个很好的起点。如果你刚刚开始学习 python，我建议在对 matplotlib 和 pandas 有了基本的了解之后再回到这里。</p><h1 id="afd4" class="ma ld it bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">1.Matplotlib</h1><p id="a303" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">尽管许多任务仅使用 seaborn 函数就可以完成，但理解 matplotlib 的基础知识是必不可少的，原因有两个:</p><ol class=""><li id="ed88" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">在幕后，seaborn 使用 matplotlib 绘制情节。</li><li id="936a" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">一些定制可能需要直接使用 matplotlib。</li></ol><p id="222f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是 matplotlib 基础知识的快速回顾。下图显示了 matplotlib <strong class="js iu"> <em class="mr">的解剖图。</em> </strong></p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ms"><img src="../Images/1b63f4acc2a084162fbc08a68886a807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbrEFtcSkNMfROHeM1ztmw.png"/></div></div></figure><p id="c42b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要理解的三个主要类是<strong class="js iu"> <em class="mr">图形</em> </strong>、<strong class="js iu"> <em class="mr">轴</em> </strong>和<strong class="js iu"> <em class="mr">轴</em> </strong></p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/881b3bf05248a6d6a98cce84c4fd979c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTMGQZ3VTow3_H_tNQ4j9A.png"/></div></div></figure><h2 id="b0a4" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">数字</h2><p id="17cf" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">它指的是你看到的整个图形。在同一个图中可以有多个子图(轴)。在上面的例子中，我们在一个图中有四个子图(轴)。</p><h2 id="a49f" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">轴线</h2><p id="eb62" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">坐标轴指的是图中的实际点。一个图形可以有多个轴，但给定的轴只能是一个图形的一部分。在上面的例子中，我们把四个<strong class="js iu"><em class="mr"/></strong>轴放在一个<strong class="js iu"> <em class="mr">图</em> </strong>中</p><h2 id="b3c2" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">轴</h2><p id="bf14" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">轴是指特定图中的实际轴(x 轴/y 轴)。</p><p id="faab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文中的每个例子都假设所需的模块和数据集已经被加载，如下所示</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4869" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着用一个例子来理解<strong class="js iu"> <em class="mr">图</em> </strong>和<strong class="js iu"> <em class="mr">轴</em> </strong>类</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="baaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">plt.subplots()创建单个<strong class="js iu"> <em class="mr">人物</em> </strong>实例，(<strong class="js iu"><em class="mr">nrows</em></strong>*<strong class="js iu"><em class="mr">ncols)轴</em> </strong>实例，并返回创建的<strong class="js iu"> <em class="mr">人物</em> </strong>和<strong class="js iu"> <em class="mr">轴</em> </strong>实例。在上面的例子中，由于我们已经传递了<em class="mr"> nrows=1 </em>和<em class="mr"> ncols=1 </em>，所以它只创建了一个<strong class="js iu"> <em class="mr">轴</em> </strong>实例。如果<strong class="js iu"> <em class="mr"> nrows &gt; 1 </em> </strong>或<strong class="js iu"> <em class="mr"> ncols &gt; 1 </em> </strong>，它会创建一个轴网格，并将它们返回到一个(<em class="mr"> nrows * ncols) </em>形<strong class="js iu"> <em class="mr"> numpy </em> </strong>数组中。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nh"><img src="../Images/c810bf57321e040221eda75578d01faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cW0vg0K1zHmUFeRscgaotQ.png"/></div></div></figure><p id="c759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定制轴类最常用的方法有</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="fd8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个例子，使用上述一些方法进行一些定制</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/da714e8ae9bce21219131a8ef5ded0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69KGBMJsxOjIsN8St9kGaw.png"/></div></div></figure><p id="d6c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经回顾了 matplotlib 的基础知识，让我们继续学习 seaborn</p><h1 id="9a29" class="ma ld it bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">2.海生的</h1><p id="2241" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">seaborn 中的每个绘图函数要么是一个<strong class="js iu"> <em class="mr">图形级</em> </strong>函数，要么是一个<strong class="js iu"> <em class="mr">轴级</em> </strong>函数，了解两者的区别是必不可少的。如前所述，一个图形指的是你看到的整个图形，而 Axes 指的是图形中的一个特定的子图。<strong class="js iu"> <em class="mr">轴级</em> </strong>函数绘制到单个 matplotlib 轴上，不影响图形的其余部分。另一方面，一个<strong class="js iu"> <em class="mr">图形级</em> </strong>函数控制整个图形。一种思考方式是，一个<strong class="js iu"> <em class="mr">人物级</em> </strong>函数可以调用不同的<strong class="js iu"> <em class="mr">轴级</em> </strong>函数在不同的轴上绘制不同类型的支线剧情</p><h1 id="3861" class="ma ld it bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">2.1 轴级功能</h1><p id="7786" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">以下是 seaborn 中所有轴级函数的详尽列表</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f343" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用任何轴级函数，有两点需要理解</p><ol class=""><li id="068a" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">向轴级函数提供输入数据的不同方式。</li><li id="b39f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">指定用于绘图的轴。</li></ol><h2 id="63a7" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">2.1.1 向轴级功能提供输入数据的不同方式</h2><p id="a1a0" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">有三种不同的方法将数据传递给轴级函数</p><ol class=""><li id="6525" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">列表、数组或系列</li></ol><p id="ab02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将数据传递给轴级函数的最常见方式是使用列表、数组或序列等可迭代对象</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/c68d6f6aecc55880cab3831e836bd38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Plu1XUsf78u7MCC1qkaTPw.png"/></div></div></figure><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/22723fe772cb73182e94d58e5f61b63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0k8b91C6ws8WPqGb4wtlg.png"/></div></div></figure><p id="ac55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.使用熊猫数据帧和列名。</p><p id="64c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">seaborn 受欢迎的主要原因之一是它能够直接处理熊猫数据帧。在这个传递数据的方法中，列名应该传递给<strong class="js iu"> <em class="mr"> x </em> </strong>和<strong class="js iu"> <em class="mr"> y </em> </strong>参数，数据帧应该传递给<strong class="js iu"> <em class="mr">数据</em> </strong>参数</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/c5543cfb4064f07fd50ecf8ee80c2906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5HTNt-vl-33aUNZgLV9og.png"/></div></div></figure><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nk"><img src="../Images/6997ea5aa0364e9aa503d057812b4c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2H4CB1Jx0Sie3Sb5y0Iog.png"/></div></div></figure><p id="c141" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.仅传递数据帧</p><p id="505e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种传递数据的方法中，只有 Dataframe 被传递给<strong class="js iu"> <em class="mr"> data </em> </strong>参数。将使用此方法绘制数据集中的每个数值列。该方法只能用于以下轴级功能</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="04f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种传递输入数据的方法的一个具体用例是使用上面提到的任何轴级函数比较数据集中多个数值变量的分布</p><pre class="mt mu mv mw gt nl nm nn no aw np bi"><span id="21ef" class="lc ld it nm b gy nq nr l ns nt">sns.boxplot(data=iris)</span></pre><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nk"><img src="../Images/1d54ea77ff016c392d9cd676f650c756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNupxjFTGKxxjyS5CnnobQ.png"/></div></div></figure><h2 id="1c03" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">2.1.2 指定用于绘图的轴</h2><p id="2b80" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">seaborn 中的每个轴级函数都有一个显式的<strong class="js iu"> <em class="mr"> ax </em> </strong>参数。传递给<strong class="js iu"> <em class="mr"> ax </em> </strong>参数的轴将被用于绘图。这在控制哪些轴用于绘图方面提供了很大的灵活性。<br/>例如，假设我们想要查看账单总额和小费之间的关系(使用散点图)以及它们在同一张图中不同轴上的分布(使用箱线图)。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/5afd160e154ce3b9a4835a6028ea5ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IDT9L6jV4eZHp-kQAltmA.png"/></div></div></figure><p id="2223" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个轴级函数还会返回绘图所在的轴。如果一个 Axes 已经被传递给<strong class="js iu"> <em class="mr"> ax </em> </strong>自变量，将返回相同的 Axes 对象。然后，返回的 Axes 对象可用于使用不同方法(如 Axes.set_xlabel()、Axes.set_ylabel()等)的进一步定制</p><p id="211d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有轴传递给 ax 参数，seaborn 将使用当前(活动)轴进行绘图。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="37b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，即使我们没有明确地将 curr_axes(当前活动的轴)传递给<strong class="js iu"> <em class="mr"> ax </em> </strong>参数，seaborn 仍然使用它来绘图，因为它是当前活动的轴。<br/>id(curr _ Axes)= = id(scatter _ plot _ Axes)返回<strong class="js iu"> <em class="mr"> True </em> </strong>表示它们是相同的轴。</p><p id="27af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有轴被传递给<strong class="js iu"> <em class="mr"> ax </em> </strong>参数，并且没有当前活动的轴对象，seaborn 创建一个<strong class="js iu">新的</strong>轴对象进行绘图，然后返回该轴对象</p><p id="dfd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">seaborn 中的轴级函数没有任何控制图形大小的直接参数。但是，由于我们可以指定哪些轴用于绘图，通过在<strong class="js iu"> <em class="mr"> ax </em> </strong>参数中传递轴，我们可以如下控制图形大小</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="764d" class="ma ld it bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">2.2 图形级功能</h1><p id="f733" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">在探索多维数据集时，数据可视化最常见的用例之一是在不同的数据子集上绘制同一图表的多个实例。seaborn 中的<strong class="js iu"> <em class="mr">图级</em> </strong>函数就是为这个用例量身定制的。一个<strong class="js iu"> <em class="mr">图形级</em> </strong>函数可以完全控制整个图形，并且每次调用一个图形级函数时，它都会创建一个新的图形，该图形可以包括多个轴，所有这些都以有意义的方式组织起来。seaborn 中三个最通用的图形级函数是<strong class="js iu"> <em class="mr"> FacetGrid、PairGrid、JointGrid </em> </strong></p><h2 id="03de" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">2.2.1 面网格</h2><p id="bc1b" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">考虑以下用例，我们希望在不同的数据子集上可视化总账单和小费之间的关系(通过散点图)。每个数据子集通过以下变量<br/> 1 的值的唯一组合进行分类。日(星期四，Fri 星期六，太阳)<br/> 2。吸烟者(不管这个人是不是吸烟者)。性别(男性或女性)<br/>这在 matplotlib 中很容易做到，如下所示</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nu"><img src="../Images/f363edac603a6e8b9025682be0252466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6loEFV7Imjcvq-kwqpOag.png"/></div></div></figure><p id="6b69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述代码可以分为三个步骤:</p><ol class=""><li id="1bf1" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">为每个数据子集创建一个轴(子图)</li><li id="4146" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">将数据集划分为子集</li><li id="4a49" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">在每个轴上，使用对应于该轴的数据子集<br/>绘制散点图</li></ol><p id="77f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤 1 可以在 seaborn 中使用 FacetGrid() <br/>完成，步骤 2 和步骤 3 可以使用 FacetGrid.map()完成</p><p id="2092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用 FacetGrid，我们可以使用<strong class="js iu"> <em class="mr">行</em> </strong>、<strong class="js iu"> <em class="mr">列</em> </strong>和<strong class="js iu"> <em class="mr">色调</em> </strong>参数创建将数据集分割成三维的轴。<br/>一旦我们创建了 FacetGrid，我们可以使用 FacetGrid.map()在所有轴上绘制相同类型的图，方法是将图的类型作为参数传递。我们还需要传递用于绘图的列的名称。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nv"><img src="../Images/aa86c7a60676afdf6e5ca276e759c93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RI8-YO9jYr14bxwfvbe4_w.png"/></div></div></figure><p id="66ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，“Matplotlib 提供了很好的支持来制作具有多个轴的图，但是 seaborn 通过将图的结构与数据集的结构直接链接来构建它”。使用 FacetGrid，我们既不必为每个子集显式创建轴，也不必将数据显式划分为子集。这分别由 FacetGrid()和 FacetGrid.map()在内部完成。<br/>我们可以将不同的轴级函数传递给 FacetGrid.map()。</p><p id="ce58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，seaborn 提供了三个图形级函数(高级接口),它们在后台使用 FacetGrid()和 FacetGrid.map()。<br/> 1。relplot() <br/> 2。catplot() <br/> 3。lmplot() <br/>上面的每个图级函数都使用 FacetGrid()创建多个轴，并在<strong class="js iu"> <em class="mr">种类</em> </strong>参数中取一个轴级函数，然后在内部传递给 FacetGrid.map()。因此，上述三个函数在可以传递给它们中的每一个的轴级函数方面是不同的。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="03a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显式使用 FacetGrid 比直接使用 relplot()、catplot()或 lmplot()等高级接口提供了更多的灵活性；例如，使用 FacetGrid()，我们还可以将自定义函数传递给 FacetGrid.map()，但是对于高级接口，您只能使用<strong class="js iu"> <em class="mr">种类</em> </strong>参数中内置的轴级函数。如果不需要这种灵活性，可以直接使用高级接口</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nv"><img src="../Images/dd525971d8101f4b54f9c4fceea23fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UUUe301kfpPRCIFvTdArg.png"/></div></div></figure><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nw"><img src="../Images/cdb21b6e298b38829886d0f75f8f6723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2x1-Gzbh_VrTwRtxg-UTKg.png"/></div></div></figure><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nx"><img src="../Images/8aed08c74e694e7f5f6a62bc1a7a465c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UerKoqb67bM0HfChqiro9A.png"/></div></div></figure><p id="6d92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述三个图形级函数以及 FacetGrid 都返回 FacetGrid 的一个实例。使用 FacetGrid 实例，我们可以访问各个轴，然后可以使用这些轴来调整绘图(如添加轴标签、标题等)。此外，与控制 matplotlib 图形的大小相比，控制图形级别函数的大小是不同的。我们可以使用<strong class="js iu"> <em class="mr">高度</em> </strong>和<strong class="js iu"> <em class="mr">纵横比</em> </strong>参数来设置每个面(子情节)的高度和纵横比，而不是设置整体的图形大小。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nv"><img src="../Images/e0ae492e19561aac21c0d1a99436213a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuJuShmnI3DpB1Xr8QyAhA.png"/></div></div></figure><p id="85fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多示例请参考<a class="ae ny" href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html" rel="noopener ugc nofollow" target="_blank"> FacetGrid </a>。</p><h2 id="d29e" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">配对网格</h2><p id="7dca" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">PairGrid 用于绘制数据集中变量之间的成对关系。每个子图显示了一对变量之间的关系。考虑以下用例，我们想要可视化每对变量之间的关系(通过散点图)。这可以在 matplotlib 中轻松完成，如下所示</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nz"><img src="../Images/7533385b942807e8614aef36da9147f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6ZVQwuIt4fB3mQDSj49ag.png"/></div></div></figure><p id="d2dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码可以分为两步</p><ol class=""><li id="76a7" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">为每对变量创建一个轴</li><li id="1555" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">在每个轴上，使用对应于该变量对的数据<br/>绘制散点图</li></ol><p id="8fa5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤 1 可以使用 PairGrid() <br/>完成，步骤 2 可以使用 PairGrid.map()完成。</p><p id="8e8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，PairGrid()为每对变量创建轴，PairGrid.map()使用对应于该对变量的数据在每个轴上绘制绘图。我们可以将不同的轴级函数传递给 PairGrid.map()</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oa"><img src="../Images/55c77095dc2b0540c50bd52cf629ecef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aml8R79Tao92AJ2M6vsZw.png"/></div></div></figure><p id="cc74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对角线轴上绘制散点图是没有意义的。可以在对角线轴上绘制一种图形，在非对角线轴上绘制另一种图形。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oa"><img src="../Images/00ac8aaebad2ebbd58baa016373e6669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jgDsFj057RlzKblUTFlhA.png"/></div></div></figure><p id="80a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还可以在上三角轴、对角轴和下三角轴上绘制不同种类的图。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ob"><img src="../Images/858713e4d4ae616643962d1eb07a8954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vW-C4bhdAByIkMpb42xAaQ.png"/></div></div></figure><p id="ec36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不需要 PairGrid()的所有灵活性，Seaborn 还提供了一个高级接口 pairplot()来绘制变量的成对关系。它在后台使用 PairGrid()和 PairGrid.map()。</p><pre class="mt mu mv mw gt nl nm nn no aw np bi"><span id="5c1c" class="lc ld it nm b gy nq nr l ns nt">sns.pairplot(data=iris)</span></pre><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oa"><img src="../Images/d4907a2fbe3607558932107f81f3cb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvyRQEsfTUT4JYFIyvpATA.png"/></div></div></figure><p id="a73f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PairGrid()和 PairPlot()都返回 PairGrid()的一个实例。使用 PairGrid()实例，我们可以访问各个轴，然后可以使用这些轴来调整绘图，如添加轴标签、标题等</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oc"><img src="../Images/8984a7d62e0d41121a46a3d223d9179c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhj4nFCcWebeIRBzU6rOgA.png"/></div></div></figure><p id="e891" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多示例请参考<a class="ae ny" href="https://seaborn.pydata.org/generated/seaborn.PairGrid.html" rel="noopener ugc nofollow" target="_blank">对网格</a></p><h2 id="a205" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">接缝网格</h2><p id="c10e" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">当我们想要在同一个图中绘制双变量分布和边际分布时，使用 JointGrid。两个变量的联合分布可以使用<strong class="js iu"> <em class="mr">散点图</em></strong>/<strong class="js iu">/<em class="mr">regplo</em></strong>t 或<strong class="js iu"> <em class="mr"> kdeplot </em> </strong>可视化。变量的边际分布可以通过<strong class="js iu"> <em class="mr">直方图</em> </strong>和/或<strong class="js iu"> <em class="mr"> kde 图可视化。</em> </strong>用于关节分布的轴级函数必须传递给 JointGrid.plot_joint()。用于边际分布的轴级函数必须传递给 JointGrid.plot_marginals()</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi od"><img src="../Images/3214830a4ee2b9de39b44cf82c033d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51EXsucLFGw7YJHmqpzIWw.png"/></div></div></figure><p id="db81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不需要 JointGrid()的所有灵活性，seaborn 还提供了一个高级接口<strong class="js iu"> <em class="mr"> jointplot() </em> </strong>来绘制双变量分布和边际分布。它在后台使用 JointGrid()和 JointGrid.plot_joint()。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi od"><img src="../Images/60211cc284e23d3d3c5adb3522698b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4Mmo4G_i8785w7PqqCHiA.png"/></div></div></figure><p id="d129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JointGrid()和 jointplot()都返回 JointGrid()的一个实例。使用 JointGrid()实例，我们可以访问单个轴，然后可以使用这些轴来调整绘图，如添加标签、标题等</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oe"><img src="../Images/6ceb9c814e7f78efb2c179271bea3575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGSvgPCNtDT4KC4w4BeXzw.png"/></div></div></figure><p id="5183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多例子请参考<a class="ae ny" href="https://seaborn.pydata.org/generated/seaborn.JointGrid.html" rel="noopener ugc nofollow" target="_blank">接合栅格</a></p><h1 id="01e6" class="ma ld it bd le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq bi translated">摘要</h1><p id="cb07" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">将<strong class="js iu"> <em class="mr"> seaborn </em> </strong>与<strong class="js iu"> <em class="mr"> pandas </em> </strong>整合在一起，有助于用最少的代码制作复杂的多维情节。seaborn 中的每个绘图函数要么是一个<strong class="js iu"> <em class="mr">轴级</em> </strong>函数，要么是一个<strong class="js iu"> <em class="mr">图形级</em> </strong>函数。<strong class="js iu"> <em class="mr">一个轴级</em> </strong>函数绘制到单个 matplotlib 轴上，不影响图形的其余部分。另一方面，<strong class="js iu"> <em class="mr">图形级</em> </strong>功能控制整个图形。她的是轴级和图形级函数的快速总结</p><h2 id="fc98" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">轴级别</h2><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="7dc1" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">数字级</h2><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="023b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎提供使本文更好的建议/技巧。感谢阅读！！！</p></div></div>    
</body>
</html>