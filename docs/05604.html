<html>
<head>
<title>Reinforcement Learning — Generalisation of Off-Policy Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习——非策略学习的概括</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reinforcement-learning-generalisation-of-off-policy-learning-61468b0bc138?source=collection_archive---------14-----------------------#2019-08-17">https://towardsdatascience.com/reinforcement-learning-generalisation-of-off-policy-learning-61468b0bc138?source=collection_archive---------14-----------------------#2019-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">贝尔德反例</h2></div><p id="1847" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们已经将我们的强化学习主题从离散状态扩展到连续状态，并详细阐述了将瓦片编码应用于基于策略的学习，即学习过程遵循代理所采取的轨迹。现在让我们来谈谈在连续环境下的非政策学习。虽然在离散的设置中，基于策略的学习可以很容易地推广到非策略的学习(比如，从 Sarsa 到 Q-learning)，但在连续的设置中，这种推广可能有点麻烦，在某些情况下可能会导致分歧问题。在本文中，我将:</p><ol class=""><li id="817f" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">介绍由政策外学习的延伸所引起的问题</li><li id="3ec5" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">举贝尔德反例来说明这个问题</li><li id="7f17" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">介绍解决问题的潜在方法</li></ol><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/036682434f9c5296522991ef7cfc9d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcWf2ckaIW9PQlzdPnbfhg.jpeg"/></div></div></figure><h1 id="13de" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">政策外学习的问题</h1><p id="932d" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">偏离政策学习最突出的结果是，它可能不一定在连续的环境中收敛。主要原因是由于<em class="nb">非策略情况下的更新分布不符合策略分布，</em>即状态，用于更新的动作可能不是代理采取的状态、动作。下面进入更新公式，进一步说问题。在偏离策略学习的连续状态下，1 步更新流程如下:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nc"><img src="../Images/145c743aed274a9d01fe428ef00494f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVDKhB4J1e8UVF9rOwNO7w.png"/></div></div></figure><p id="05fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，与政策上的概括相比，多了一个术语<code class="fe nd ne nf ng b">ρ</code>，称为重要性抽样比率。<code class="fe nd ne nf ng b">ρ</code>由目标策略<code class="fe nd ne nf ng b">π</code>除以行为策略<code class="fe nd ne nf ng b">b</code>，<em class="nb">计算。在控制中，目标策略通常是相对于动作值函数的当前估计的确定性贪婪策略。该策略成为确定性的最优策略，而行为策略保持随机且更具探索性，例如，ϵ-greedy 策略</em>。回想一下，在 Q 学习的离散状态空间中，时间差异是<code class="fe nd ne nf ng b">max{Q(S', A')} — Q(S, A)</code>(不考虑奖励)<strong class="kk iu">，因此在每次状态更新时，最大 Q 值(来自贪婪策略)用于更新，而不是实际状态的值，即代理采取的动作(行为策略)</strong>。在连续空间中，使用行为策略利用重要性抽样来接近目标策略值。关于<code class="fe nd ne nf ng b">ρ</code>的更多解释，可以参考这里的<a class="ae nh" href="https://stats.stackexchange.com/questions/410131/in-rl-why-using-a-behavior-policy-instead-of-the-target-policy-for-an-episode-i" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae nh" href="https://stats.stackexchange.com/questions/237085/how-to-correctly-compute-rho-in-reinforcement-learning-with-importance-sampli?rq=1" rel="noopener ugc nofollow" target="_blank"/>(关于重要性抽样的更多解释，可以参考这里的<a class="ae nh" href="https://medium.com/@zhangyue9306/importance-sampling-introduction-e76b2c32e744" rel="noopener"/>)。</p><p id="88a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">公式的其余部分与 on-policy learning 相同，其中<code class="fe nd ne nf ng b">w</code>是权重向量，<code class="fe nd ne nf ng b">δ</code>是时间差异(注意，根据问题是否是情节性的，δ略有差异，对于非情节性的情况，请参考此处的<a class="ae nh" rel="noopener" target="_blank" href="/reinforcement-learning-generalisation-on-continuing-tasks-ffb9a89d57d0"/>)。</p><p id="ea7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据萨顿在书中的描述，政策外学习的差异是由以下原因造成的:</p><blockquote class="ni nj nk"><p id="0942" class="ki kj nb kk b kl km ju kn ko kp jx kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">一个转换重复发生，而<code class="fe nd ne nf ng b">w</code>不会在其他转换中更新。这在非策略训练下是可能的，因为行为策略可能选择目标策略永远不会选择的那些其它转变上的动作。</p></blockquote><p id="48ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要担心，如果你有一点困惑，让我们继续一个例子，看看权重如何发散。</p><h1 id="0969" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">贝尔德反例</h1><p id="9080" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">这是一个著名而简洁的例子，说明了偏离政策学习的发散特征。</p><h2 id="544d" class="no mf it bd mg np nq dn mk nr ns dp mo kr nt nu mq kv nv nw ms kz nx ny mu nz bi translated">问题描述</h2><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oa"><img src="../Images/8d65a02ea52ff3310f4af0b2c1d5a52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sd5AiW-ZE9UkrPvMmYEa-g.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">Baird Example</figcaption></figure><p id="9fb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nb">虚线动作以相等的概率将系统带到六个上状态之一，而实线动作将系统带到第七个状态。</em> <code class="fe nd ne nf ng b"><em class="nb">behaviour policy b</em></code> <em class="nb">选择概率为</em><code class="fe nd ne nf ng b"><em class="nb">6/7</em></code><em class="nb"/><code class="fe nd ne nf ng b"><em class="nb">1/7</em></code><em class="nb">的虚线和实线动作，使其下的下一状态分布均匀(所有非终结状态相同)，这也是每集的起始分布。目标策略</em> <code class="fe nd ne nf ng b"><em class="nb">π</em></code> <em class="nb">总是采取稳健的行动，所以策略上的分布(对于</em> <code class="fe nd ne nf ng b"><em class="nb">π</em></code> <em class="nb">)集中在第七个状态。所有转场的奖励是</em> <code class="fe nd ne nf ng b"><em class="nb">0</em></code> <em class="nb">。折现率为</em> <code class="fe nd ne nf ng b"><em class="nb">γ = 0.99</em></code> <em class="nb">。</em>(仅出于简单和说明的原因，目标策略设置为固定)</p><p id="fb11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，每个圆圈内是使用权重向量的每个状态的表示。</p><p id="accb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的实现中，步长<code class="fe nd ne nf ng b">α = 0.01</code>和初始权重是<code class="fe nd ne nf ng b">w = (1, 1, 1, 1, 1, 1, 10, 1)</code>。</p><h1 id="a6d1" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">履行</h1><p id="6247" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">检查完整的<a class="ae nh" href="https://github.com/MJeremy2017/Reinforcement-Learning-Implementation/blob/master/BairdExample/BairdCounterExample.py" rel="noopener ugc nofollow" target="_blank">实现</a></p><h2 id="1db3" class="no mf it bd mg np nq dn mk nr ns dp mo kr nt nu mq kv nv nw ms kz nx ny mu nz bi translated">初始化</h2><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3ce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管有一些常规设置，注意<code class="fe nd ne nf ng b">self.features</code>是每个状态的表示，而<code class="fe nd ne nf ng b">self.weights</code>是权重向量(初始值是特意设置的)。权重和特征的乘积是每个状态的值。</p><h2 id="fc70" class="no mf it bd mg np nq dn mk nr ns dp mo kr nt nu mq kv nv nw ms kz nx ny mu nz bi translated">行动</h2><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9501" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">行动的选择和采取遵循规则。</p><h2 id="d5a1" class="no mf it bd mg np nq dn mk nr ns dp mo kr nt nu mq kv nv nw ms kz nx ny mu nz bi translated">价值函数</h2><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e7cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所述，值函数通过将特征和权重相乘来返回状态的值。</p><h2 id="6cc3" class="no mf it bd mg np nq dn mk nr ns dp mo kr nt nu mq kv nv nw ms kz nx ny mu nz bi translated">违反政策运行</h2><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0fc7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了上面的准备，我们就可以让代理学习了。在每一轮中，代理重复状态、动作、下一个状态、下一个动作……的过程，因为我们设置目标策略总是选择<code class="fe nd ne nf ng b">solid</code>行，当代理采取动作<code class="fe nd ne nf ng b">dash</code>时，重要性抽样比率将为 0，当它采取<code class="fe nd ne nf ng b">solid</code>动作时，重要性抽样比率为<code class="fe nd ne nf ng b">1/self.prob</code>。<code class="fe nd ne nf ng b">sarsa</code>参数用于控制是否使用基于策略的学习(在基于策略的学习中，目标策略总是行为策略，因此<code class="fe nd ne nf ng b">ρ = 1</code>)，这仅用于结果比较。</p><h2 id="04d1" class="no mf it bd mg np nq dn mk nr ns dp mo kr nt nu mq kv nv nw ms kz nx ny mu nz bi translated">学习结果</h2><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oh"><img src="../Images/dcd45556e3de1bfd8a6c64c397944968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmFT0eGdVoXPVn0hWfu8dg.png"/></div></div></figure><p id="b369" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看到在偏离策略的学习中，权重发散到无穷大，而在策略上的方法(在这种情况下是 Sarsa)收敛。现在我们再来看一下图像，解释一下原因:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oa"><img src="../Images/8d65a02ea52ff3310f4af0b2c1d5a52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sd5AiW-ZE9UkrPvMmYEa-g.png"/></div></div></figure><p id="4e44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，当代理从最左边的状态(2*w1+w8)到底部的状态(w7+2*w8)采取一个固体动作时，如果 w8 通过上面的公式增加它的值，这将导致两个状态的值增加，因为它们共享权重 w8。然而，从底部状态开始，通过采取 dash 动作不会有助于偏离策略学习，因为在这种情况下<code class="fe nd ne nf ng b">ρ</code>为 0，这导致 w8 的值总是增加但从不减少。萨顿是这样说的:</p><blockquote class="ni nj nk"><p id="aa4f" class="ki kj nb kk b kl km ju kn ko kp jx kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">一个转换重复发生，而<code class="fe nd ne nf ng b"><em class="it">w</em></code>不会在其他转换中更新。这在非策略训练下是可能的，因为行为策略可能选择目标策略永远不会选择的那些其它转变上的动作。</p></blockquote><h1 id="abd3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">解决方法</h1><p id="65ef" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">就解决方案而言，第一个是在连续空间设置上不使用偏离策略的学习，而总是使用符合策略的学习。另一种方法是改变目标误差函数。到目前为止，所有的函数逼近更新都是基于<code class="fe nd ne nf ng b">(true_value — current_value)^2</code>的目标误差，但是为了使训练过程收敛，萨顿在他的书中建议最小化投影贝尔曼误差(PBE)。详细解释请参考他的书<a class="ae nh" href="http://incompleteideas.net/book/the-book-2nd.html" rel="noopener ugc nofollow" target="_blank">这里</a>，第 11 章。</p><p id="3909" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我给出了这种方法的一个简单实现，并将其与经典的偏离策略学习进行了比较。通过最小化 PBE，可以得到一个更新公式:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oi"><img src="../Images/522f3438b9cf0b06ee44a0b78e3b185f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxyyC9cpWNDDXLHKUt4tFQ.png"/></div></div></figure><p id="5e7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe nd ne nf ng b">β</code>是另一个步长参数，而<code class="fe nd ne nf ng b">vt*xt</code> (xt 是特征向量)是<code class="fe nd ne nf ng b">ρ*δ</code>的近似值。这种方法被称为带梯度修正的时延估计(TDC)</p><h1 id="e700" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">贸发局的实施</h1><p id="f6c0" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">唯一的区别在于<code class="fe nd ne nf ng b">run</code>功能:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="593e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个过程完全遵循上面的公式，使用 TDC，我们得到一个学习过程:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/657ec8235fd8135d8ea39d2d97d9b937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*hPG3ISysU5psGA6qD6Go8A.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">Learning Process of TDC</figcaption></figure><p id="4a25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，权重会慢慢收敛到最佳值。还有其他介绍的解决问题的方法，有兴趣的可以自己了解一下(查看完整<a class="ae nh" href="https://github.com/MJeremy2017/Reinforcement-Learning-Implementation/blob/master/BairdExample/BairdCounterExample.py" rel="noopener ugc nofollow" target="_blank">实现</a>)。</p><p id="200f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，提到萨顿的书的结尾部分:</p><blockquote class="ni nj nk"><p id="7252" class="ki kj nb kk b kl km ju kn ko kp jx kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">政策外学习的整个领域相对较新且不稳定。哪种方法是最好的，甚至是合适的，现在还不清楚。本章末尾介绍的新方法的复杂性真的有必要吗？其中哪些可以和方差缩减法有效结合？政策外学习的潜力仍然诱人，实现它的最佳方式仍然是个谜。</p></blockquote><p id="ab21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考</strong>:</p><ul class=""><li id="1f7e" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld ok lk ll lm bi translated">【http://incompleteideas.net/book/the-book-2nd.html T4】</li><li id="913a" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ok lk ll lm bi translated"><a class="ae nh" href="https://github.com/ShangtongZhang/reinforcement-learning-an-introduction" rel="noopener ugc nofollow" target="_blank">https://github . com/Shang tongzhang/reinforcement-learning-an-introduction</a></li></ul></div></div>    
</body>
</html>