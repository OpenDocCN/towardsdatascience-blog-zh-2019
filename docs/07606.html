<html>
<head>
<title>Navigating The Hell of NaNs in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中导航 NaNs 的地狱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/navigating-the-hell-of-nans-in-python-71b12558895b?source=collection_archive---------0-----------------------#2019-10-23">https://towardsdatascience.com/navigating-the-hell-of-nans-in-python-71b12558895b?source=collection_archive---------0-----------------------#2019-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9bf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">了解 nan 并在您的数据中轻松处理它们的摘要。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0c4acbb2954b0db99ade80077e234f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nopplg_0jRniFo45"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="275b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi lf translated"><span class="l lg lp bm di lq"> <img alt="I" class="ky lr ls lt lu lv fc n ih dh bf" src="../Images/372a85df590327f646ff2d6a8b3607e9.png" width="37" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:74/1*mO7GaCw2WcxXU6FWEq4fuw.png"/> <span class="l lg lh li bm lj lk ll lm ln di lo">我</span> </span>最近有很多 NaNs 引起的头痛。每个程序员都知道它们是什么，以及它们为什么会发生，但在我的情况下，我并不知道它们的所有特征，或者说还不够好来阻止我的努力。为了找到解决方案并避免令人头疼的问题，我进一步研究了 Python 中 NaNs 值的行为。在 Jupyter Notebook 里摆弄了几个语句之后，我的结果相当令人吃惊，也极其混乱。这是我用 Numpy 的 np.nan 得到的。</p><p id="ce56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lw lx ly lz b">np.nan in [np.nan]</code>是<code class="fe lw lx ly lz b">True</code></p><p id="f3d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止还好，但是…</p><p id="414f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lw lx ly lz b">np.nan == np.nan</code>是<code class="fe lw lx ly lz b">False</code></p><p id="418f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">啊？还有…</p><p id="a805" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lw lx ly lz b">np.nan is np.nan</code>是<code class="fe lw lx ly lz b">True</code></p><blockquote class="ma"><p id="0659" class="mb mc it bd md me mf mg mh mi mj kn dk translated">那么 Python 中的 NaNs 到底是怎么回事？</p></blockquote><h1 id="2a49" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">简短介绍</h1><p id="f5fd" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">NaN 代表<strong class="js iu">不是一个数字，是一种常见的缺失数据表示。</strong>它是一个特殊的浮点值，不能转换为除 float 以外的任何其他类型。甚至在 Python 存在之前，它就由用于算术运算的二进制浮点 I <a class="ae le" href="https://www.python-course.eu/dealing_with_NaN_in_python.php" rel="noopener ugc nofollow" target="_blank"> EEE 标准</a> (IEEE 754)引入，并在遵循该标准的所有系统中使用。NaN 可以被视为某种数据病毒，会感染它所涉及的所有操作。</p><h2 id="b56e" class="nn ml it bd mm no np dn mq nq nr dp mu kb ns nt my kf nu nv nc kj nw nx ng ny bi translated">无对南</h2><p id="2c02" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">None 和 NaN 听起来相似，看起来相似，但实际上很不一样。None 是一个 Python 内部类型，可以认为它等同于 NULL。<a class="ae le" href="https://www.w3schools.com/python/ref_keyword_none.asp" rel="noopener ugc nofollow" target="_blank"/><code class="fe lw lx ly lz b"><a class="ae le" href="https://www.w3schools.com/python/ref_keyword_none.asp" rel="noopener ugc nofollow" target="_blank">None</a></code><a class="ae le" href="https://www.w3schools.com/python/ref_keyword_none.asp" rel="noopener ugc nofollow" target="_blank">关键字用于定义空值，或者根本没有值。None 不同于 0、False 或空字符串。它是自己的数据类型(NoneType ),并且只有 None 可以是… None。</a>数值数组中的缺失值为 NaN，而对象数组中的缺失值为 None。最好通过使用<code class="fe lw lx ly lz b">foo is None</code>而不是<code class="fe lw lx ly lz b">foo == None which brings</code>来检查无。我们回到上一个问题，我在 NaN 操作中发现了特殊的结果。</p><h1 id="39a2" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv nz mx my mz oa nb nc nd ob nf ng nh bi translated">南不等于南</h1><p id="71eb" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">起初，读到<code class="fe lw lx ly lz b">np.nan == np.nan</code>是<code class="fe lw lx ly lz b">False</code>会引发困惑和沮丧的反应。这看起来很奇怪，听起来真的很奇怪，但如果你稍微思考一下，逻辑就会开始出现，甚至开始变得有意义。</p><blockquote class="ma"><p id="5876" class="mb mc it bd md me mf mg mh mi mj kn dk translated">尽管我们不知道每个 NaN 是什么，但不是每个 NaN 都是一样的。</p></blockquote><p id="5f0d" class="pw-post-body-paragraph jq jr it js b jt oc jv jw jx od jz ka kb oe kd ke kf of kh ki kj og kl km kn im bi translated">让我们想象一下，我们看到的不是 nan 值，而是一群我们不认识的人。他们对我们来说是完全陌生的人。陌生人对我们来说都是一样的，也就是说我们把他们都描述成陌生人。但是，现实中并不意味着一个不认识的人就等于另一个不认识的人。</p><p id="2ab3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">离开我这个奇怪的比喻，回到 Python，<strong class="js iu"> NaN 不能等于它自己，因为 NaN 是失败的结果</strong>，但是失败可以以多种方式发生。一次失败的结果不能等于任何其他失败的结果，未知值也不能彼此相等。</p><h1 id="98ec" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv nz mx my mz oa nb nc nd ob nf ng nh bi translated">平等与身份</h1><p id="e7f9" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">现在，要理解<code class="fe lw lx ly lz b">np.nan in [np.nan]</code>为什么是<code class="fe lw lx ly lz b">True</code>，我们得看看<em class="oh">相等</em>和<em class="oh">相同</em>的区别。</p><h2 id="ef99" class="nn ml it bd mm no np dn mq nq nr dp mu kb ns nt my kf nu nv nc kj nw nx ng ny bi translated">平等</h2><p id="15ed" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">等式指的是大多数 Python 程序员都知道的“==”这个概念。这用于询问 Python 该变量的内容是否与另一个变量的内容相同。</p><pre class="kp kq kr ks gt oi lz oj ok aw ol bi"><span id="a50b" class="nn ml it lz b gy om on l oo op">num = 1<br/>num2 = 1</span><span id="81e2" class="nn ml it lz b gy oq on l oo op">num == num2 </span></pre><p id="69eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一行将导致<code class="fe lw lx ly lz b">True</code>。<strong class="js iu">两个变量的内容相同</strong>。如前所述，一个 NaN 的内容永远不等于另一个 NaN 的内容。</p><h2 id="b260" class="nn ml it bd mm no np dn mq nq nr dp mu kb ns nt my kf nu nv nc kj nw nx ng ny bi translated">身份</h2><p id="80e2" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">当你问 Python 一个变量<strong class="js iu">是否与另一个变量</strong>相同时，你就是在问 Python 这两个变量是否共享<strong class="js iu">相同的标识</strong>。Python 为每个创建的变量分配一个<strong class="js iu"> id </strong>，当 Python 在一个操作中查看变量的身份时，会比较 id。然而，<code class="fe lw lx ly lz b">np.<strong class="js iu">nan</strong></code> <strong class="js iu">是一个单一的对象，它总是有相同的 id，不管你把它赋给哪个变量。</strong></p><pre class="kp kq kr ks gt oi lz oj ok aw ol bi"><span id="11ad" class="nn ml it lz b gy om on l oo op">import numpy as np<br/>one = np.nan<br/>two = np.nan<br/>one is two</span></pre><p id="d778" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lw lx ly lz b">np.nan is np.nan</code>是<code class="fe lw lx ly lz b">True</code><code class="fe lw lx ly lz b">one is two</code>也是<code class="fe lw lx ly lz b">True</code>。</p><p id="836b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果使用<code class="fe lw lx ly lz b">id(one)</code>和<code class="fe lw lx ly lz b">id(two)</code>检查<code class="fe lw lx ly lz b">one</code>和<code class="fe lw lx ly lz b">two</code>的 id，将显示相同的 id。</p><p id="1d5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lw lx ly lz b">np.nan in [np.nan]</code>之所以是<code class="fe lw lx ly lz b">True</code>是因为 Python 中的 list 容器在检查<strong class="js iu">相等</strong>之前先检查<strong class="js iu">身份</strong> <strong class="js iu">。然而，根据它们是如何被创造出来的，它们有不同的“味道”。<code class="fe lw lx ly lz b">float(‘nan’)</code>用不同的 id 创建不同的对象，所以<code class="fe lw lx ly lz b">float('nan') is float('nan')</code>实际上给了<strong class="js iu">假！！稍后我们将再次提到这些差异。</strong></strong></p><h1 id="5622" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv nz mx my mz oa nb nc nd ob nf ng nh bi translated">对付南而不头痛</h1><p id="7808" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">最初，完整的 nan 概念可能很难理解，也很难处理。令人欣慰的是，<strong class="js iu"> pandas </strong>和<strong class="js iu"> numpy </strong>在处理 nan 值方面非常出色，它们提供了几个函数，可以轻松地选择、替换或删除变量中的 nan 值。</p><h2 id="e5af" class="nn ml it bd mm no np dn mq nq nr dp mu kb ns nt my kf nu nv nc kj nw nx ng ny bi translated">测试值是否为 nan</h2><p id="4ee3" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">正如我所说的，每当你想知道一个值是否是一个 nan，你不能检查它是否等于 nan。然而，有许多其他的选择可以做到这一点，我提出的并不是唯一的选择。</p><pre class="kp kq kr ks gt oi lz oj ok aw ol bi"><span id="63af" class="nn ml it lz b gy om on l oo op">import numpy as np<br/>import pandas as pd</span><span id="393d" class="nn ml it lz b gy oq on l oo op">var = float('nan')</span><span id="c00e" class="nn ml it lz b gy oq on l oo op">var is np.nan #results in True<br/>#or<br/>np.isnan(var) #results in True<br/>#or<br/>pd.isna(var) #results in True<br/>#or<br/>pd.isnull(var)#results in True</span></pre><p id="c6ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lw lx ly lz b">pd.isnull</code> &amp; <code class="fe lw lx ly lz b">pd.isna()</code>表现一致。熊猫提供了。isnull()函数，因为它是 Python 中 R 数据帧的改编版。在 R 中，null 和 na 是两种不同的类型，具有不同的行为。</p><p id="86ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了 numpy 和从<strong class="js iu"> Python </strong> 3.5 开始，你也可以使用<code class="fe lw lx ly lz b">math.<strong class="js iu">nan</strong> </code>。我在本文中同时写 nan 和 NaN 的原因(除了我缺乏一致性)是值不区分大小写的事实。<code class="fe lw lx ly lz b">float(‘nan’)</code>或<code class="fe lw lx ly lz b">float(‘NAN’)</code>都会产生相同的结果。</p><pre class="kp kq kr ks gt oi lz oj ok aw ol bi"><span id="1ce8" class="nn ml it lz b gy om on l oo op">import math<br/>var = float('nan')<br/>math.isnan(var) #results in True</span></pre><p id="e879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">小小警告:</strong></p><pre class="kp kq kr ks gt oi lz oj ok aw ol bi"><span id="f4dd" class="nn ml it lz b gy om on l oo op">import math<br/>import numpy as np<br/>math.nan is math.nan #results in True<br/>math.nan is np.nan #results in False<br/>math.nan is float('nan') #results in False</span></pre><p id="89b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为<code class="fe lw lx ly lz b">math.nan</code>、<code class="fe lw lx ly lz b">np.nan</code>和<code class="fe lw lx ly lz b">float('nan')</code>都有不同的 id，所以这些语句为假。他们没有相同的身份。</p><h2 id="60e6" class="nn ml it bd mm no np dn mq nq nr dp mu kb ns nt my kf nu nv nc kj nw nx ng ny bi translated"><strong class="ak">对于数据帧</strong></h2><pre class="kp kq kr ks gt oi lz oj ok aw ol bi"><span id="53ae" class="nn ml it lz b gy om on l oo op">import pandas as pd</span><span id="5286" class="nn ml it lz b gy oq on l oo op">df = pd.DataFrame(some_data)</span><span id="c85e" class="nn ml it lz b gy oq on l oo op">df.dropna()<br/>#will drop all rows of your dataset with nan values. <br/>#use the subset parameter to drop rows with nan values in specific columns</span><span id="0498" class="nn ml it lz b gy oq on l oo op">df.fillna()<br/>#will fill nan values with the value of your choice</span><span id="ed95" class="nn ml it lz b gy oq on l oo op">df.isnull()<br/>#same as pd.isnull() for dataframes</span><span id="7699" class="nn ml it lz b gy oq on l oo op">df.isna()<br/>#same as pd.isna() for dataframes</span></pre><p id="4995" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，我并不认为熊猫文档在丢失数据文档方面非常有用。然而，我真的很欣赏这篇摘自<em class="oh"> Python 数据科学手册</em>  <em class="oh"> </em>的<a class="ae le" href="https://jakevdp.github.io/PythonDataScienceHandbook/03.04-missing-values.html" rel="noopener ugc nofollow" target="_blank">，它很好地概述了如何处理 Pandas 中的缺失数据。</a></p><h1 id="957d" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv nz mx my mz oa nb nc nd ob nf ng nh bi translated">需要注意什么</h1><blockquote class="ma"><p id="f017" class="mb mc it bd md me mf mg mh mi mj kn dk translated">type error:“float”对象不可迭代</p></blockquote><p id="a789" class="pw-post-body-paragraph jq jr it js b jt oc jv jw jx od jz ka kb oe kd ke kf of kh ki kj og kl km kn im bi translated">虽然非类型错误非常清楚，但是由 nan 值引起的错误可能会有点混乱。Nan 值经常会导致错误(更具体地说是<strong class="js iu"> TypeErrors </strong>)，这将涉及到它们的类型“<strong class="js iu"> float </strong>”。错误消息可能会令人惊讶，尤其是当您认为您的数据绝对没有浮点数时。您的数据帧可能看起来不包含任何浮点，但实际上，它确实包含。它可能有你不知道的 nan 值，你只需要去掉你的 NaN 值就可以消除这个错误！</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="11a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一名数据科学家和 Python 程序员，我喜欢分享我在这一领域的经验，并将继续撰写关于 Python、机器学习或任何有趣的发现的文章，这些发现可能会使其他程序员的生活和任务变得更容易。在<a class="ae le" href="https://medium.com/me" rel="noopener"><em class="oh">Medium</em></a><em class="oh">或</em><a class="ae le" href="https://twitter.com/DIRUSSOJulia" rel="noopener ugc nofollow" target="_blank"><em class="oh">Twitter</em></a><em class="oh">上关注我，以获得关于 Python &amp;数据科学的任何未来文章的通知！</em></p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt oy"><a rel="noopener follow" target="_blank" href="/explaining-data-science-to-your-grandma-f8345621483d"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">向你的祖母解释数据科学</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">或者如何向你的家人或任何与技术世界脱节的人解释数据科学。</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ky oy"/></div></div></a></div></div></div>    
</body>
</html>