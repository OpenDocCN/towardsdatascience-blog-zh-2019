<html>
<head>
<title>How to Add Regularization to Keras Pre-trained Models the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确地将正则化添加到 Keras 预训练模型中</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-add-regularization-to-keras-pre-trained-models-the-right-way-743776451091?source=collection_archive---------29-----------------------#2019-11-26">https://towardsdatascience.com/how-to-add-regularization-to-keras-pre-trained-models-the-right-way-743776451091?source=collection_archive---------29-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Tensorflow 2.0 正则化预训练的 Keras 模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1706b223e9509d9d19121f6f2935fe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QS9n1QfuT2e8eC-H.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by Kelly Sikkema on Unsplash</figcaption></figure><h1 id="a6f5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="8ebe" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你以训练深度学习模型为生，你可能会厌倦知道一件具体而重要的事情:</p><blockquote class="mm"><p id="e021" class="mn mo it bd mp mq mr ms mt mu mv ml dk translated">微调深度预训练模型需要大量的正则化工作。</p></blockquote><p id="6fbc" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">作为对比，你可能已经注意到，如何向来自深度学习库(如 Keras)的预训练模型添加正则化并不总是显而易见的。此外，找到这个问题的正确答案也不容易。在撰写这篇文章的过程中，我遇到了许多关于堆栈溢出的代码片段和一些博客文章，它们根本没有得到正确的解释。然后，作为减少您的 Google 搜索的一种方式(并帮助我未来的自己)，我将向您展示如何以正确的方式将正则化添加到预训练的 Keras 模型中。</p><p id="0c81" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">让我们从基础开始。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2f54" class="ky kz it bd la lb nn ld le lf no lh li jz np ka lk kc nq kd lm kf nr kg lo lp bi translated">微调</h1><p id="6398" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">微调是指采用预先训练好的模型，并将其作为优化不同(大多数情况下相关)任务的起点的过程。你可以想象使用一个在 ImageNet 数据库上训练的 ResNet50 模型，并用它来解决一个新问题，比如昆虫分类。</p><p id="d768" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">这个过程通常遵循简单的步骤。</p><ol class=""><li id="a00b" class="ns nt it ls b lt nb lw nc lz nu md nv mh nw ml nx ny nz oa bi translated"><strong class="ls iu">我们首先加载模型架构和预训练权重。</strong>对于迁移学习更为成熟的计算机视觉，这是我们加载这些著名架构之一的地方，如 DenseNets 或 MobileNets 及其各自的权重(在 ImageNet 上训练)。</li><li id="fe0c" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated"><strong class="ls iu">然后，我们在预训练模型的顶部添加一个特定于任务的分类层。</strong>这通常是一个具有 softmax 或 sigmoid 激活的致密层。请注意，分类层中单元的数量必须等于新问题的类的数量。所以，如果你的昆虫数据集包含 28 种虫子之类的东西，那么最后一层需要有 28 个单元。</li><li id="c9ea" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated">然后，我们完成了模型的准备。在 Keras 中，我们使用优化器和损失函数编译模型，设置超参数，并调用 fit。</li></ol><p id="909a" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated"><em class="og">附注:这可能过于简单，但对我们的例子来说很好。</em></p><h1 id="0e11" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">对抗过度拟合</h1><p id="9a31" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们必须记住的一件事是:</p><blockquote class="mm"><p id="c2f4" class="mn mo it bd mp mq mr ms mt mu mv ml dk translated">当微调预训练模型时，过度拟合是一个更大的问题。</p></blockquote><p id="30a8" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">问题很容易看出来。如果你有一个小的训练数据，你会不断地向网络一遍又一遍地显示相同的实例。此外，正如我们所知，ImageNet 上预先训练的 ConvNets 通常非常复杂；即它们有许多训练参数。因此，模型会很快完全记住你的训练数据。</p><p id="d5c0" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">作为解决方案，微调通常需要两件事:</p><ol class=""><li id="fe41" class="ns nt it ls b lt nb lw nc lz nu md nv mh nw ml nx ny nz oa bi translated">大量的正规化</li><li id="b6dc" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated">非常小的学习率</li></ol><p id="96cf" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">对于正规化，任何事情都可能有所帮助。我通常使用 l1 或 l2 正则化，并提前停止。对于没有批量标准化的 ConvNets，<a class="ae oh" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/SpatialDropout2D" rel="noopener ugc nofollow" target="_blank">空间丢失</a>也是有帮助的</p><p id="027e" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">作为补充说明，深度学习模型是众所周知的数据饥渴。这些模型需要大量数据来将非常复杂的高维空间分解成特征空间中的线性可分决策。许多人将微调视为使用较小数据集训练深度模型的一种方式。虽然在实践中，这种观点听起来可能是正确的，但这里有一个重要的陷阱。即使您可以使用小得多的数据集来拟合新模型，请记住，您的预训练模型训练了几天(使用多个 GPU)。换个说法，微调其实就是——<strong class="ls iu"><em class="og">站在巨人的肩膀上。</em> </strong></p><p id="0c86" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">现在让我们直接进入代码。</p><h1 id="09aa" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">黑客攻击</h1><p id="9fc1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">直观地说，添加正则化的过程很简单。在加载我们预先训练好的模型后，称为<strong class="ls iu"> <em class="og">基础模型</em> </strong>，我们将遍历它的所有层。对于每一层，我们检查它是否支持正则化，如果支持，我们添加它。代码如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1170" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">看起来我们结束了。事实上，如果你在谷歌上搜索如何将正则化添加到 Keras 预训练模型中，你会发现相同的结果。</p><p id="3e25" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">作为安全检查，让我们确保正则化设置正确。在 Keras 中，我们可以通过访问层或模型的 loss 属性来检索损耗。在我们的例子中，我们可以通过以下方式访问所有损失的列表(通过正则化来自所有层):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="862a" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">如果你对术语感到困惑，这个属性叫做损失，因为在优化过程中正则化惩罚被添加到损失函数中。</p><p id="0fcf" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">如你所见，有些奇怪的事情正在发生。<strong class="ls iu">列表是空的，这意味着没有正则化惩罚应用于卷积核。</strong></p><p id="796d" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">但是刚刚发生了什么？</p><p id="670f" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">好吧，直接进入问题，看起来当我们改变一个层的属性时，正如我们所做的，<strong class="ls iu">唯一真正改变的是模型配置。</strong>因此，模型对象本身就和我们加载时一样。完全没有变化。</p><p id="cb36" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">添加正则化后，看一下配置文件。<strong class="ls iu"><em class="og">kernel _ regulator</em></strong>属性和我们设置的一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="c79d" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">这个问题的一个简单解决方案是重新加载模型配置。这很容易做到，也解决了问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="893f" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">现在，如果我们试图看到<strong class="ls iu"><em class="og"/></strong>，我们就有了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f3e5" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">然而，作为一种常见的黑客行为，这又引入了另一个问题。如果您更仔细地注意模型的权重，在从配置文件重新加载模型之后，权重被重置！<strong class="ls iu"> <em class="og">我们刚刚丢失了，所有的 ImageNet 预训练参数！</em>T3】</strong></p><p id="6eb7" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">好吧，一个快速的解决方法是使用相同的策略。我们可以在重新加载模型配置之前保存权重，并在模型正确加载后重新加载权重。</p><p id="e2be" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">下面的函数完成了全部工作。您可以传递来自<a class="ae oh" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank"> Keras 应用</a> <strong class="ls iu"> <em class="og">(使用 Tensorflow 2.0) </em> </strong>的任何模型，以及您想要的正则化器，它会返回正确配置的模型。请注意，在从配置文件重新加载模型之前和之后，我们是如何保存和重新加载模型权重的。</p><p id="8321" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">同样，您可以使用相同的代码添加<strong class="ls iu"><em class="og">bias _ regulator</em></strong>和<strong class="ls iu"><em class="og">activity _ regulator</em></strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b7a3" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated">就是这样。一个快速但有希望的有用的技巧来调整你的预训练模型。</p><p id="127c" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly lz nd mb mc md ne mf mg mh nf mj mk ml im bi translated"><strong class="ls iu">感谢阅读！</strong></p></div></div>    
</body>
</html>