<html>
<head>
<title>Machine Learning for Stock Clustering using K-Means Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 K-Means 算法的股票聚类机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-for-stock-clustering-using-k-means-algorithm-126bc1ace4e1?source=collection_archive---------6-----------------------#2019-01-10">https://towardsdatascience.com/machine-learning-for-stock-clustering-using-k-means-algorithm-126bc1ace4e1?source=collection_archive---------6-----------------------#2019-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用聚类通过无监督的股票聚类使投资组合更加多样化。</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5267bb8413420d238f6f432fbe032cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHWb839J_M1x94A3F59p4w.png"/></div></div></figure><p id="d968" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">多元化是构建投资组合的关键步骤，但真正的多元化是不可能的，因为投资每家公司都需要大量资本。除此之外，并不是所有的公司都值得投资，这可能是因为它们的流动性非常差。</p><p id="abec" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所以现在你要做的是想出一个有效的策略，只选择那些表现不同的股票。这将有助于降低风险，一种方法是从不同的行业挑选股票，但一种更数据驱动的解决方案是对股票数据应用 K 均值聚类算法，以识别不同的股票聚类。</p><p id="d659" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">[参考:<a class="ae lu" href="https://www.pythonforfinance.net/2018/02/08/stock-clusters-using-k-means-algorithm-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . python forfinance . net/2018/02/08/stock-clusters-using-k-means-algorithm-in-python/</a>]</p><p id="b377" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在下面的帖子中，我将给出一个使用 Python 应用 K-Means 算法的例子。</p><p id="8adb" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，我们需要有组织结构的数据。对于这个任务，我将使用一个符合 Shariah 的股票列表，如这里的<a class="ae lu" href="https://www.almeezangroup.com/investor-education/shariah-methodology/" rel="noopener ugc nofollow" target="_blank"/>所列。名单已经更新，所以我选择的公司可能会有点不同。</p><p id="6998" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面的代码块从计算机中加载数据，并根据我们的需要构造数据</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="cbe9" class="ma mb iq lw b gy mc md l me mf">import pandas as pd<br/>from sklearn.cluster import KMeans<br/>from math import sqrt<br/>import  pylab as pl<br/>import numpy as np</span><span id="8e3b" class="ma mb iq lw b gy mg md l me mf">#Loading the data<br/>data = pd.read_csv("SC Close Prices.csv", index_col = "date")<br/>data.index = pd.to_datetime(data.index)</span><span id="8aa3" class="ma mb iq lw b gy mg md l me mf">start = "2010-01-01"</span><span id="2d59" class="ma mb iq lw b gy mg md l me mf">data = data.loc[start:]</span><span id="9d73" class="ma mb iq lw b gy mg md l me mf">#Calculating annual mean returns and variances<br/>returns = data.pct_change().mean() * 252<br/>variance = data.pct_change().std() * sqrt(252)</span><span id="6619" class="ma mb iq lw b gy mg md l me mf">returns.columns = ["Returns"]<br/>variance.columns = ["Variance"]</span><span id="c04a" class="ma mb iq lw b gy mg md l me mf">#Concatenating the returns and variances into a single data-frame<br/>ret_var = pd.concat([returns, variance], axis = 1).dropna()<br/>ret_var.columns = ["Returns","Variance"]</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d322fb966d59c01d615eb73f5a646d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kchaw2nbNH9_qW9rwjr9-A.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">ret_var variable after running the code block above</figcaption></figure><p id="2cbe" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，在将模型拟合到我们的数据之前，我们需要决定我们希望将数据分成多少个簇。决定这个数字可能很棘手，因此我们将使用“肘方法”来计算一系列不同集群的 SSE(误差平方和)。然后，我们将在 x 轴上绘制簇的数量，在 y 轴上绘制 SSE。</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="9175" class="ma mb iq lw b gy mc md l me mf">X =  ret_var.values #Converting ret_var into nummpy array</span><span id="6182" class="ma mb iq lw b gy mg md l me mf">sse = []</span><span id="7c36" class="ma mb iq lw b gy mg md l me mf">for k in range(2,15):<br/>    <br/>    kmeans = KMeans(n_clusters = k)<br/>    kmeans.fit(X)<br/>    <br/>    sse.append(kmeans.inertia_) #SSE for each n_clusters</span><span id="c16d" class="ma mb iq lw b gy mg md l me mf">pl.plot(range(2,15), sse)<br/>pl.title("Elbow Curve")<br/>pl.show()</span></pre><p id="2d12" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下图显示了 5 个簇是一个很好的数字，因为我们不希望 n_clusters 太大，并且在 5 个簇之后错误率下降速度变慢，因此，我认为这是一个合理的选择。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b67a4f8cf93ded1a65ae2a3be508f14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBUH7YbplzXFoEfdrecVJw.png"/></div></div></figure><p id="b9ec" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，现在我们要将 K-Means 模型再次拟合到我们的数据集，n_clusters = 5，并绘制结果。</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="bc12" class="ma mb iq lw b gy mc md l me mf">kmeans = KMeans(n_clusters = 5).fit(X)</span><span id="d43e" class="ma mb iq lw b gy mg md l me mf">centroids = kmeans.cluster_centers_</span><span id="1558" class="ma mb iq lw b gy mg md l me mf">pl.scatter(X[:,0],X[:,1], c = kmeans.labels_, cmap ="rainbow")<br/>pl.show()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/52c69f1ebbc3452442722d2d93be9bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIrodAH6IpGsp_zA_aVcjg.png"/></div></div></figure><p id="e3ad" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">就像任何其他数据科学问题一样，我们的数据中有一个离群值，我们需要通过确定它是哪家公司来消除它。下面的代码做了同样的事情。</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="efe0" class="ma mb iq lw b gy mc md l me mf">print(returns.idxmax())</span><span id="fb72" class="ma mb iq lw b gy mg md l me mf">ret_var.drop("HADC", inplace =True)</span></pre><p id="6756" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">移除后，我们现在重新进行拟合模型和绘图的过程。</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="e85d" class="ma mb iq lw b gy mc md l me mf">X = ret_var.values<br/>kmeans =KMeans(n_clusters = 5).fit(X)</span><span id="be7a" class="ma mb iq lw b gy mg md l me mf">centroids = kmeans.cluster_centers_</span><span id="23e3" class="ma mb iq lw b gy mg md l me mf">pl.scatter(X[:,0],X[:,1], c = kmeans.labels_, cmap ="rainbow")<br/>pl.show()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f3652ee89d362fdba31371c6067a6a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VK4W38L6NbJmYvaFDX5W3A.png"/></div></div></figure><p id="1d47" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在要做的就是获取数据集中每家公司的聚类数，这样我们就可以在构建多元化投资组合的同时区分不同的公司。</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="b3b0" class="ma mb iq lw b gy mc md l me mf">Company = pd.DataFrame(ret_var.index)<br/>cluster_labels = pd.DataFrame(kmeans.labels_)</span><span id="e3cf" class="ma mb iq lw b gy mg md l me mf">df = pd.concat([Company, cluster_labels],axis = 1)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ef7e9d99d9140520f391c924c383e208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vh4F0oFxaHP0PQpv7qgHNA.png"/></div></div></figure><p id="6421" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我更多关注的是算法在 python 中的实现，而不是解释理论。我希望这篇文章对你有用。如果你有任何问题或发现任何技术错误，请在下面的评论区告诉我。</p></div></div>    
</body>
</html>