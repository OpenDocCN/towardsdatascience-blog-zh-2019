<html>
<head>
<title>Three ways of doing matrix multiplication in Excel — fastai part-2, lesson-8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Excel 中做矩阵乘法的三种方法— fastai 第二部分，第八课</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matrix-multiplication-part2-lesson8-34c9b77855c4?source=collection_archive---------26-----------------------#2019-07-02">https://towardsdatascience.com/matrix-multiplication-part2-lesson8-34c9b77855c4?source=collection_archive---------26-----------------------#2019-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fastai“从基础开始”的第二部分终于出来了。我不记得上一次对 MOOC 这么兴奋是什么时候了。课程一对外发布，我就开始深入挖掘，加深对深度学习和底层概念的理解。</p><p id="28e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这次我决定听从杰里米和雷切尔的建议，写博客。这篇特别的文章解释了杰里米在第八课中实现的各种矩阵乘法方法。我将使用<strong class="jp ir">微软 Excel </strong>进行说明。</p><p id="abb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们开始吧！</p><h2 id="142f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">矩阵乘法</h2><p id="d195" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">了解 Jeremy 提到的矩阵乘法的一个很好的互动场所是:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/dea617d670935b504d75c551fc9d5bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/0*TlmHHTp4Lm04vz03.gif"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk"><a class="ae lz" href="http://matrixmultiplication.xyz/" rel="noopener ugc nofollow" target="_blank">matrixmultiplication.xyz</a></figcaption></figure><p id="1bbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从图中可以看出，我们对第二个矩阵进行转置，将元素相乘并相加，得到结果。例如，结果矩阵中的第一项<code class="fe ma mb mc md b">15</code>来自<code class="fe ma mb mc md b">1*2 + 6*2 + 1*1 = 2 + 12 + 1 = 15</code>。</p><p id="c8ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种解释在视觉上令人愉悦，但以我的拙见，很难将其转换为代码。所以还是用 Excel，换一种方式理解矩阵乘法吧！</p><h2 id="9d8e" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">EXCEL 中的矩阵乘法</h2><p id="0e2d" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">考虑大小为<code class="fe ma mb mc md b">4x3</code>和<code class="fe ma mb mc md b">3x4</code>的两个矩阵<strong class="jp ir"> A </strong>和<strong class="jp ir"> B </strong>。<br/>注意:在本文中，我将使用粗体符号<strong class="jp ir"> A </strong>和<strong class="jp ir"> B </strong>来指代矩阵。使用粗体符号引用向量和矩阵是常见的做法。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi me"><img src="../Images/51f6927719ce36f9f95a9063af0e0c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5MXCXNZ1QzB0uIKaFGkxg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Matrices A and B</figcaption></figure><p id="6abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们之前看到的图像中，如果你还记得的话，我们对<strong class="jp ir"> B </strong>进行了转置，并将<strong class="jp ir"> A </strong>的行与<strong class="jp ir"> B </strong>的列相乘，得到了结果矩阵。相反，这次让我们跳过转置这一步，直接将行和列相乘。</p><p id="9836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<strong class="jp ir"> A </strong>的第 0 行与<strong class="jp ir"> B </strong>的第 0 列逐元素相乘，得到的逐元素乘积相加得到结果矩阵<strong class="jp ir"> C </strong>中位置<code class="fe ma mb mc md b">[0][0]</code>处的第一项。</p><p id="72f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是它在 Excel 中的样子:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mf"><img src="../Images/b0e7e87cc642e317e721848d6516744c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5xLJuB4rhuLGTZLNM_ZAQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">C[0][0] = 1*1 + 10*5 + 100*9 = 1 + 50 + 900 = 951</figcaption></figure><p id="0a92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们通过将<strong class="jp ir"> A </strong>的第 0 行和<strong class="jp ir">b</strong>的第 3 列逐元素相乘得到<code class="fe ma mb mc md b">C[0][3]</code>。在 excel 中，它看起来像:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mg"><img src="../Images/22b6b554749143a404d78cf79bf90fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOgijSnSVqTC7DiLhlmhJg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">C[0][3] = 1*4 + 10*8 + 100*12 = 4 + 80 + 1200 = 1284</figcaption></figure><p id="3c3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后我们按照同样的过程遍历<strong class="jp ir"> C </strong>中的每个空盒子，得到最终结果。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mh"><img src="../Images/b26a4dda3c9d4c8620ebd78db9fdfb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7qa-ir9NU0ZtgIcb5Cdtw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">C[3][3] = 4*4 + 40*8 + 400*12 = 16 + 320 + 4800 = 5136</figcaption></figure><p id="299c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们走吧！我们就是这么做矩阵乘法的！那很容易，不是吗？我们现在不仅理解了矩阵乘法，而且还在 Excel 中实现了它！多酷啊。</p><p id="9c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人认为现在你已经准备好处理一些与矩阵乘法相关的规则了(或者简而言之<strong class="jp ir"> MatMul </strong>):</p><ol class=""><li id="a583" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">设<code class="fe ma mb mc md b">ar,ac</code>为<strong class="jp ir"> A. </strong>中的行数和列数，同样，设<code class="fe ma mb mc md b">br, bc</code>为<strong class="jp ir"> B. </strong>中的行数和列数，那么为了执行矩阵乘法，需要<code class="fe ma mb mc md b">ac == br</code>。为什么？嗯，正如你在 excel 中看到的，我们将行和列元素相乘，然后将中间乘积相加，得到最终结果。如果维数不匹配，并且一个向量比另一个向量长，我们就不能再进行元素乘法了！</li><li id="aa3c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">生成的矩阵的维数将总是<code class="fe ma mb mc md b">ar,bc</code>。即行数来自<strong class="jp ir"> A </strong>，列数来自<strong class="jp ir"> B. </strong></li></ol><h2 id="d6a6" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">方法 1:使用 3 进行循环</h2><p id="2bcf" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这里有另一个免责声明，在 Excel 中实现矩阵乘法时，我们不仅理解了它，而且还复制了 Jeremy 的第一个使用 3 进行循环的方法。下面是它在代码中的样子:</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="705a" class="kl km iq md b gy na nb l nc nd">def matmul1(a,b):<br/>    ar,ac = a.shape<br/>    br,bc = b.shape<br/>    assert ac==br<br/>    c = torch.zeros(ar, bc)<br/>    for i in range(ar):<br/>        for j in range(bc):<br/>            for k in range(ac): #or br<br/>                c[i,j] += a[i,k]*b[k,j]<br/>    return c</span></pre><p id="0b2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你现在能更好地理解它。如果没有，这将是一个很好的时机，可以停下来试验一下代码，看看到底发生了什么。我保证，和我们 Excel 版本一样！</p><p id="35ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我假设你花了一些时间思考代码，那么，让我们来讨论一下吧！</p><ul class=""><li id="003c" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk ne mo mp mq bi translated">为什么前两个循环在<code class="fe ma mb mc md b">range(ar) </code>和<code class="fe ma mb mc md b">range(bc)</code>？嗯，正如你在<strong class="jp ir">规则 2 </strong>中所记得的，我们得到的矩阵将会有维度<code class="fe ma mb mc md b">ar,bc</code>。从 Excel 中我们看到，我们逐个遍历了<strong class="jp ir"> C </strong>的每个元素，因此，要遍历<code class="fe ma mb mc md b">ar</code>行和<code class="fe ma mb mc md b">bc</code>列，我们需要 2 个用于<code class="fe ma mb mc md b">range(ar) </code>和<code class="fe ma mb mc md b">range(bc)</code>中的循环。</li><li id="43a9" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk ne mo mp mq bi translated">那么，为什么第三个 FOR 循环在<code class="fe ma mb mc md b">range(ac) #or br</code>里呢？从<strong class="jp ir">规则-1 </strong>中，我们知道<code class="fe ma mb mc md b">ac==br</code>，所以我们是否将<code class="fe ma mb mc md b">range(ac)</code>或<code class="fe ma mb mc md b">range(br)</code>放在第三个循环中并不重要。本质上，这是单个元素相乘并相加的地方。根据我们之前的 Excel 示例，对于<code class="fe ma mb mc md b">C[0][0]</code>，这是步骤<code class="fe ma mb mc md b">C[0][0] = 1*1 + 10*5 + 100*9 = 1 + 50 + 900 = 951</code>发生的地方，最后我们将继续下一个框。相乘并相加的项数等于<code class="fe ma mb mc md b">ac or br</code>。</li></ul><p id="254e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真的是这样！这是给你的方法 1！这里有一首记住矩阵乘法的歌。(这个我最早是从 fast.ai 上了解到的，原作者不详)</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nf"><img src="../Images/a364cc886b9af865c264b02876971037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uZIDNqLUardUT4P9.jpeg"/></div></div></figure><p id="b1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望现在你已经明白两个矩阵是如何相乘的了。如果没有，这里的<a class="ae lz" href="https://www.khanacademy.org/math/precalculus/precalc-matrices/multiplying-matrices-by-matrices/v/matrix-multiplication-intro" rel="noopener ugc nofollow" target="_blank">是可汗学院的另一个教程。</a></p><h2 id="7f3a" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">方法 2:使用逐元素乘法</h2><p id="8a9a" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">所以到目前为止，我们一直在解析结果矩阵<strong class="jp ir"> C 中的每个位置，</strong>寻找单个元素的乘积，然后将它们求和。如果你记得的话，类似于，<code class="fe ma mb mc md b">C[0][0] = 1*1 + 10*5 + 100*9 = 1 + 50 + 900 = 951</code>。当然，肯定有别的办法吧？如果我们不做单个乘积，然后求和，而是一次将向量相乘，得到一个结果向量，然后将结果向量求和，得到最终元素，会怎么样？</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="7d6d" class="kl km iq md b gy na nb l nc nd">m = tensor([1, 2, 3])<br/>n = tensor([10, 10, 10])<br/>m*n</span><span id="b171" class="kl km iq md b gy ng nb l nc nd">&gt;&gt;tensor([10, 20, 30])</span></pre><p id="3d53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们一直在寻找单个产品<code class="fe ma mb mc md b">10, 20, 30</code>并将它们组合在一起<code class="fe ma mb mc md b">10 + 20 + 30 = 60</code>。但是，真的，所有这些都可以替换为:</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="3341" class="kl km iq md b gy na nb l nc nd">m = tensor([1, 2, 3])<br/>n = tensor([10, 10, 10])<br/>(m*n).sum()</span><span id="56aa" class="kl km iq md b gy ng nb l nc nd">&gt;&gt;tensor(60)</span></pre><p id="114b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还记得的话，在<code class="fe ma mb mc md b">range(ac) #or br</code>中最里面的循环是找到单个产品并添加它们。好吧，我们可以替换这个循环来执行向量元素方式的乘积，并在最后放一个<code class="fe ma mb mc md b">.sum()</code>，PyTorch/NumPy 有能力为我们执行元素方式的运算！</p><p id="f578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是它在 excel 中的样子:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nh"><img src="../Images/962934dc81ca6b2247bfe448b8c0edf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXt9rTNPEfh7rwSlYOv1bw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">C[0][0] = sum(A[row 0] * B[col 0])</figcaption></figure><p id="70ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们通过将<strong class="jp ir"> A </strong>的第 0 行的向量与<strong class="jp ir"> B </strong>的第 3 列的向量相乘，并将结果向量相加，得到<code class="fe ma mb mc md b">C[0][3]</code>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mg"><img src="../Images/a627d6fd8bd0da8b2f987c7b70c28183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmSIjDBpolPbbTetTB-H6Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">C[0][3] = sum(A[row 0] * B[col 3])</figcaption></figure><p id="ab1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后我们按照同样的过程遍历<strong class="jp ir"> C </strong>中的每个空盒子，得到最终结果。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ni"><img src="../Images/587928093c3bbecac3999dfba5c2f136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAXe0wI02F2I8UCoX-Je0Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">C[3][3] = sum(A[row 3] * B[col 3])</figcaption></figure><p id="9db6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意这和<strong class="jp ir">方法-1 </strong>有什么不同吗？这一次，我们只是说，要想出类拔萃或 PyTorch，请将<strong class="jp ir"> A </strong>的第 0 行与<strong class="jp ir"> B </strong>的第 0 列相乘，并对结果向量求和，得到答案。而不是做<code class="fe ma mb mc md b">1*1 + 10*5 + 100*9</code>。例如:对于<code class="fe ma mb mc md b">C[0][0]</code>，该方法将<strong class="jp ir"> A </strong> <code class="fe ma mb mc md b">tensor([1,10,100])</code>第 0 行的矢量与<strong class="jp ir"> B </strong> <code class="fe ma mb mc md b">tensor{[1,5,9])</code>第 0 列的矢量相乘，得到中间积矢量<code class="fe ma mb mc md b">tensor([1,50,900])</code>，并求和得到<code class="fe ma mb mc md b">C[0][0]</code>位置的结果为<code class="fe ma mb mc md b">tensor(951)</code>。</p><p id="a4c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在代码中，它看起来像:</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="ce23" class="kl km iq md b gy na nb l nc nd">def matmul2(a,b):<br/>    ar,ac = a.shape<br/>    br,bc = b.shape<br/>    assert ac==br<br/>    c = torch.zeros(ar,bc)<br/>    for i in range(ar):<br/>        for j in range(bc):<br/>            c[i,j] = (a[i,:]*b[:,j]).sum()<br/>    return c</span></pre><p id="c544" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们只需使用两个 FOR 循环来解析<strong class="jp ir"> C、</strong>的每个位置，并在该位置输入相应的结果。如果<code class="fe ma mb mc md b">i,j</code>代表<strong class="jp ir"> C </strong>中的行和列位置，这看起来像..</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="cde2" class="kl km iq md b gy na nb l nc nd">i:0,j:0<br/>a:tensor([  1,  10, 100]),b:tensor([1, 5, 9])<br/>tensor([[951.,   0.,   0.,   0.],<br/>        [  0.,   0.,   0.,   0.],<br/>        [  0.,   0.,   0.,   0.],<br/>        [  0.,   0.,   0.,   0.]])<br/>---<br/>i:0,j:1<br/>a:tensor([  1,  10, 100]),b:tensor([ 2,  6, 10])<br/>tensor([[ 951., 1062.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.]])<br/>---<br/>i:0,j:2<br/>a:tensor([  1,  10, 100]),b:tensor([ 3,  7, 11])<br/>tensor([[ 951., 1062., 1173.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.]])<br/>---<br/>i:0,j:3<br/>a:tensor([  1,  10, 100]),b:tensor([ 4,  8, 12])<br/>tensor([[ 951., 1062., 1173., 1284.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.]])<br/>---<br/>i:1,j:0<br/>a:tensor([  2,  20, 200]),b:tensor([1, 5, 9])<br/>tensor([[ 951., 1062., 1173., 1284.],<br/>        [1902.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.]])</span></pre><p id="0a16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等..直到我们得到完整的矩阵<strong class="jp ir"> C </strong>。</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="a401" class="kl km iq md b gy na nb l nc nd">tensor([[ 951., 1062., 1173., 1284.],<br/>        [1902., 2124., 2346., 2568.],<br/>        [2853., 3186., 3519., 3852.],<br/>        [3804., 4248., 4692., 5136.]])</span></pre><h2 id="7239" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">方法-3:广播</h2><p id="9fba" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">注意到一个共同的主题了吗？每次都要将每一行<strong class="jp ir"> A </strong>与每一列<strong class="jp ir"> B </strong>相乘，得到<strong class="jp ir"> C </strong>。你注意到重复了吗？我们正在将<strong class="jp ir"> A </strong> <code class="fe ma mb mc md b">bc</code>中同一行的向量乘以！我们重复这个过程<code class="fe ma mb mc md b">ar</code>次！</p><p id="1eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有没有办法将<strong class="jp ir"> A </strong>的行向量与<strong class="jp ir"> B </strong>的所有列相乘，得到<strong class="jp ir"> C 中的相应行？</strong>是的，有！进入广播……<br/>注意:我不会解释广播，杰里米在这里做得很好<a class="ae lz" href="https://youtu.be/4u8FxNEDUeg?t=3154" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="cb64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，让我们看看这段神奇的代码</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="4728" class="kl km iq md b gy na nb l nc nd">for i in range(ar):<br/>        c[i] = (a[i,:].unsqueeze(-1).expand_as(b)*b).sum(dim=0)</span></pre><p id="6c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像往常一样，让我们在 Excel 中复制！这会让事情变得非常简单。让我们分步骤做吧。</p><p id="fd1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤-1) </strong>选择第一行的<strong class="jp ir"> A </strong> <code class="fe ma mb mc md b">a[i,:]</code>。我们选择第 0 行作为示例。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nj"><img src="../Images/76e07ea37557d50a4a717ce3b56df789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHTmsbaT2-R_TbjBgTaJaA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Select row 0 of <strong class="bd nk">A</strong></figcaption></figure><p id="a310" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤-2) </strong>取其<strong class="jp ir">转置</strong> <code class="fe ma mb mc md b">a[i,:].unsqueeze(-1)</code></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nl"><img src="../Images/66be46d724ccc49afde7439eb54292a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pg3MmLh16YQFAjJHHTDKg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Take transpose of row 0 of A</figcaption></figure><p id="abfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤-3) </strong>将柱矩阵展开为<strong class="jp ir"> B </strong> <code class="fe ma mb mc md b">a[i,:].unsqueeze(-1).expand_as(b)</code></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nm"><img src="../Images/68600e819b4db584b3fd3ef085a67dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-IbcN4UHnLi74uQCBqunA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Expand column matrix as B</figcaption></figure><p id="74a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤-4) </strong>元素乘以<strong class="jp ir"> B </strong> <code class="fe ma mb mc md b">a[i,:].unsqueeze(-1).expand_as(b)*b</code></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nn"><img src="../Images/e6353750d6ce9c16db267160fde74b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyId5rLpkDt8CiBi9EXUHQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Element wise multiply with B</figcaption></figure><p id="616b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤-5) </strong>沿行求和，得到 C 的第 0 行</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi no"><img src="../Images/c98d26ab2ec6e36e131e49719a4874ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8S6IJ97o6Cw0qzBZwoCzw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Sum along side row dimension to get row 0 of C</figcaption></figure><p id="197b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每排<strong class="jp ir">一个</strong>的完整广播过程看起来像这样:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi np"><img src="../Images/31754e4d432fd9237633339af4b63b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXhtEiumtNgn9W6zD9LeKA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Broadcasting as a whole</figcaption></figure><p id="4e9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望现在你能收到<strong class="jp ir">的广播</strong>！<strong class="jp ir"> </strong>那么，让我们看看它在代码中是什么样子的..</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="d0c8" class="kl km iq md b gy na nb l nc nd">def matmul3(a,b):<br/>    ar,ac = a.shape<br/>    br,bc = b.shape<br/>    assert ac==br<br/>    c = torch.zeros(ar,bc)<br/>    for i in range(ar):<br/>        c[i] = (a[i,:].unsqueeze(-1).expand_as(b)*b).sum(dim=0)<br/>        print(f"i:{i}")<br/>        print(c)<br/>    return c</span></pre><p id="4656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出如下所示:</p><pre class="lk ll lm ln gt mw md mx my aw mz bi"><span id="630a" class="kl km iq md b gy na nb l nc nd">i:0<br/>tensor([[ 951., 1062., 1173., 1284.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.]])<br/>i:1<br/>tensor([[ 951., 1062., 1173., 1284.],<br/>        [1902., 2124., 2346., 2568.],<br/>        [   0.,    0.,    0.,    0.],<br/>        [   0.,    0.,    0.,    0.]])<br/>i:2<br/>tensor([[ 951., 1062., 1173., 1284.],<br/>        [1902., 2124., 2346., 2568.],<br/>        [2853., 3186., 3519., 3852.],<br/>        [   0.,    0.,    0.,    0.]])<br/>i:3<br/>tensor([[ 951., 1062., 1173., 1284.],<br/>        [1902., 2124., 2346., 2568.],<br/>        [2853., 3186., 3519., 3852.],<br/>        [3804., 4248., 4692., 5136.]])</span></pre><p id="f255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是我们所期望的，并且与我们的<strong class="jp ir"> Excel 版本</strong>相同！</p><p id="969a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已！我们已经成功地介绍了包括广播在内的三种矩阵乘法方法。</p><p id="917f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Google sheet 上图可以在</strong> <a class="ae lz" href="https://docs.google.com/spreadsheets/d/1gIhBBtDWwif1wLueY4gx1ybPfNluDJqUETy8KcqX-vE/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这里找到</strong> </a>。感谢阅读！如果您有任何问题，请随时拨打<a class="ae lz" href="https://linkedin.com/in/aroraaman/" rel="noopener ugc nofollow" target="_blank">https://linkedin.com/in/aroraaman/</a>联系我。</p></div></div>    
</body>
</html>