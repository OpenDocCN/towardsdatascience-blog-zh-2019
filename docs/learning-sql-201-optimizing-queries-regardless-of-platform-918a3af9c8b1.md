# 学习 SQL 201:优化查询，不考虑平台

> 原文：<https://towardsdatascience.com/learning-sql-201-optimizing-queries-regardless-of-platform-918a3af9c8b1?source=collection_archive---------1----------------------->

## TL；博士:磁盘太慢了。网络更差。

![](img/7c91bb8fa44fc7cae57e5e55622045b3.png)

It’s hard to find a photo that says “optimization” okay? (Photo credit: Randy Au)

*警告:在撰写本文时，我已经在生产环境中使用了以下类似数据库的系统:MySQL、PostgreSQL、Hive、Hadoop 上的 MapReduce、AWS Redshift、GCP BigQuery，以及各种本地/混合/云设置。我的优化知识很大程度上来源于这些。在这里，我将坚持策略/思维过程，但是在其他流行的数据库中肯定有我不熟悉的特性和怪癖，尤其是 SQL Server 和 Oracle。*

这篇文章是关于速度，让事情进行得更快的通用策略，同时避免具体的实现细节。我是想表达优化的思维过程，而不是具体的机制。在我知道它之前，它已经变成了一篇文章的怪物。有很多要讲的！

# 简介和背景

优化查询是一个很难写的主题，因为它涉及到细节。关于数据库引擎、软件，有时甚至是硬件和网络架构的细节。我多次被要求写关于这个主题的文章，我总是拒绝，因为我找不到一种方法来写一篇普遍有用的文章，来讨论一些很快就会被遗忘的东西。

有[整本](https://www.amazon.com/dp/0071782796) [的书](https://www.amazon.com/dp/0596101716) [写的](https://www.amazon.com/dp/1785284339)关于如何优化不同的数据库系统，其中包括查询，但也包括系统本身调优的细节。他们总是写一个特定的[平台，而不是一般的平台。这是有充分理由的——每个平台都是不同的，您需要的调优参数取决于您的工作负载和设置(写密集型与读密集型、固态硬盘与旋转磁盘等)。](https://hortonworks.com/blog/5-ways-make-hive-queries-run-faster/)

但是在一次令人讨厌的热浪中，在回家的路上，我突然有了一个关于线程将优化联系在一起的想法。所以我试着写这篇疯狂的文章。我将避免过多的细节，而将重点放在核心的思考过程上，这一过程将使您的查询进行得更快。出于说明的目的，将会涉及一些细节，没有真正的代码示例。同样为了简洁起见，我不能说得太详细，但是我会边走边链接例子和进一步的阅读。

*注意:在整篇文章中，我将使用“数据库/DB”这一术语来表示各种各样的数据存储，这些数据存储具有完全不同的后端架构，但呈现类似 SQL 的接口。它们可能是传统的 SQL 数据库，如 MySQL/PostgreSQL，或者基于 Hadoop 的 NoSQL 商店，或者是 NewSQL 数据库，如 CockaroachDB。*

# 查询优化是指计算机在查询时做更少的工作

让您的查询更快归结为让您的查询做更少的工作来获得相同的结果。有许多不同的策略来实现这个目标，并且需要技术知识来知道采用哪种策略。

做更少的工作意味着理解两件事:

*   知道你的数据库在做什么
*   知道如何调整你命令数据库做的事情，减少工作量

实现这一目标的途径在很大程度上取决于您工作的具体技术环境。优化 Hive 查询在某些方面与优化 PostgreSQL 查询截然相反。事实上，一些加快一个查询策略实际上会减慢另一个查询策略。

当“优化查询”时，您实际上正在做的是找到使您的查询工作负载与您的系统的硬件和算法限制很好地配合的方法。这意味着你对硬件、软件和系统特性越熟悉，你就会做得越好。

这也是为什么这个话题如此难教，你不能把它当作一种 SQL 风格的问题。“规则”只是指导方针，经常有反例。你也不能忽视系统的基本实现——尽管供应商会告诉你不必担心实现，但它很重要。

这是我们今天要讲的要点列表，从数据库开始，向外扩展。为了您的方便，它有链接跳转。

*   [查询计划](#0b55)
*   [索引和提示](#7f1b)
*   [磁盘写入](#6a30)
*   [子查询](http://86c2)
*   [临时表](#03e5)
*   [网络](#b554)
*   [CPU 使用率和算法](#8d49)
*   [【架空】](#015b)
*   [争用](#3d2b)
*   [$$$](#7533)

我可能漏掉了一些案例(你可以随时评论并告诉我我错过的事情)，但这些都是我能想到的大案例。

让我们开始吧。

# 查看查询计划

当谈到互联网上关于优化 SQL 查询的博客帖子时，使用 EXPLAIN 通常是你听到的第一件事(有时是唯一的事……)。EXPLAIN 是从数据库中调用查询执行计划的 SQL 方式。它是数据库给你一个关于它如何计划执行你的查询的报告——它将描述它正在使用的任何索引、表连接的顺序、它是否将扫描整个表，有时甚至它在执行操作时期望查看多少行(基数)。

这个想法是，如果您可以访问这个计划，您应该能够找出(以某种方式)如何使您的查询更快。令人沮丧的是，人们通常不会告诉你该怎么做。

## 你在寻找工作的迹象

学习如何阅读乍一看像是胡言乱语的查询执行计划需要练习和耐心。更糟糕的是，执行计划看起来没有标准。每个数据库都有很大的不同。

![](img/535d5160c1a516dd8e30e9d973f5e950.png)

An example MySQL EXPLAIN (src: [https://www.eversql.com/mysql-explain-example-explaining-mysql-explain-using-stackoverflow-data/](https://www.eversql.com/mysql-explain-example-explaining-mysql-explain-using-stackoverflow-data/))

![](img/079725ac78da445205a4e58fe3f7f4e2.png)

An example PostgreSQL EXPLAIN (src: [https://thoughtbot.com/blog/reading-an-explain-analyze-query-plan](https://thoughtbot.com/blog/reading-an-explain-analyze-query-plan))

对于您使用的每个数据库，您都必须重新学习这项技能。您还必须了解怪癖在哪里(就像有时 MySQL 解释说基数错误，它被误导了，因为它对索引做了奇怪的假设)。

不管您使用的是什么数据库，您都在寻找数据库做大量工作和花费大量时间的地方。然后你看看能不能想办法减少。请查阅特定数据库的文档，以了解每个语句的确切含义。

## 工作的迹象

*   表扫描—数据库读取表中的每一个条目，产生大量磁盘使用(这很慢)
*   高基数操作——无论是否使用了索引，当数据库必须处理大量的行时，这又意味着使用更多的磁盘和内存，并且需要花费时间来完成所有这些操作
*   对大量记录执行类似循环的操作——比如相关子查询，其中数据库必须为一组行执行单独的子查询，这很像一般编程中的 for 循环。
*   由于内存限制而写入磁盘——在 [RDBMS](https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html) [和](https://www.citusdata.com/blog/2018/06/12/configuring-work-mem-on-postgres/) [Hadoop](https://stackoverflow.com/questions/8504611/should-spilled-records-always-be-equal-to-mapinput-records-or-mapoutput-records) 系统中都会发现这种情况，当某个东西变得太大而无法在内存中处理时，它必须将其工作写入磁盘才能继续运行而不会崩溃
*   使用网络——尤其是对于几乎需要网络流量的分布式系统，相比之下，它使磁盘看起来更快。

## “磁盘”确实经常出现

希望你注意到“磁盘”这个词的出现。因为一般来说，磁盘访问是非常慢的，并且是你想要最小化的。即使固态硬盘比旋转硬盘快，它们仍然比 RAM 慢几个数量级。这就是为什么优化的第一部分通常包括寻找尽可能避免使用磁盘的方法，以及在别无选择的情况下有效使用磁盘的方法。

## 侧栏:各种组件的速度

![](img/d0484d4bbc5868f23c0967468cbfd592.png)

Comparison of access latency, data and scaling from [https://www.prowesscorp.com/computer-latency-at-a-human-scale/](https://www.prowesscorp.com/computer-latency-at-a-human-scale/)

如果你看一下 CPU 和 RAM 速度与 SSD/HDD/网络操作的比较，你就会明白为什么。RAM 访问比 CPU/L1/L2 慢 3 个数量级。永久内存模块，本质上是位于 DRAM 总线而不是 SATA 或 SAS 总线上的固态硬盘，仍然比标准 RAM 慢大约 3 倍。

一个更典型的 SSD，我们会认为是一个比 RAM 慢 2-3 个数量级的磁盘，旋转磁盘以毫秒为单位:比 RAM 慢 4 个数量级。根据条件和光速的不同，网络在 5-6 个数量级时甚至更差。

[【返回主题列表】](#635a)

# 减少工作量:索引

在“减少工作”的背景下，希望你能明白为什么索引出现得如此频繁。索引本质上是一个预先计算的数据映射，更重要的是，它告诉数据库在磁盘上的什么位置可以找到某些条目。这意味着您不必扫描整个表来搜索所有内容。

全表扫描会变得非常昂贵，因为:

1.  你正在阅读大量可能与你无关的数据(白费力气)
2.  您可能正在使用旋转磁盘，这种磁盘具有非常慢的随机存取特性(固态硬盘可以大大改善这一点),并且
3.  数据库文件可能会在整个驱动器上被分割，这使得寻道惩罚更加严重(固态硬盘肯定有助于这一点)。

但是，深入研究索引，您仍然需要知道您的特定数据库如何使用索引。例如，从版本 8 开始，PostgreSQL 已经能够通过[位图扫描](https://www.postgresql.org/docs/8.3/indexes-bitmap-scans.html)同时使用多个索引。与此同时，MySQL，即使在他们的版本 8 中，[在默认的 InnoDB 存储引擎中只有 HASH 和 B-tree 索引](https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html)，不能将索引组合在一起。

了解这些繁琐的细节对于优化来说是非常重要的。在 MySQL 中，如果您想在一个索引查询中使用两列或更多列，您必须使用这些列构建一个特定的多列索引，并且顺序很重要。*索引(A，B)！= index(B，A)* 。如果您有 *index(A，B)* ，但是需要快速访问 B，您至少需要一个单独的 *index(B)* 。

与此同时，在 PostgreSQL 中，更常见和更受欢迎的做法是只使用单独的索引:index(A)和 index(B ),因为它可以通过位图扫描自动使用 AND/OR 逻辑动态地组合 A 和 B。您可以构建一个多列的索引(A，B) ,这样会更有效，但是您已经通过两个单独的索引获得了很多好处。此外，如果您稍后需要您想要编写的*索引(C)* 和*索引(D)* ，它的伸缩性会更好。

## 针对您的用例使用正确的索引类型

大多数数据库引擎在定义索引时会提供多种索引算法供您使用。缺省值通常是 B 树的某种变体，它适用于大量典型的数据库用例。但是您经常会发现像用于空间数据库的 R/radix 树，或者散列和全文索引这样的东西。有时，对于更具体的用例，甚至有更深奥的东西可用。

不管它是什么，使用最适合您的特定用例的，使用错误的会适得其反。

## 索引提示

有时您有一个索引，但是由于某种原因查询计划没有使用它。MySQL 经常因其相当愚蠢的查询优化器而被取笑，因此许多高级用户使用了大量的[索引提示](https://dev.mysql.com/doc/refman/8.0/en/index-hints.html)，特别是**force index(*idx*)**和 **straight_join，**来强制优化器做正确的事情。经常发生的情况是，优化器认为忽略并索引和扫描一个表会更有效，因为它对正在操作的一个表的基数估计不正确。

同时，在 PostgreSQL 中，[索引提示实际上并不是一件事](https://stackoverflow.com/questions/309786/how-do-i-force-postgres-to-use-a-particular-index)。由于索引提示本质上是对某些表的基数的攻击，随着数据库的不断变化，它们很容易过时。相反，开发人员强迫您依赖他们的查询优化器。谢天谢地，优化器犯的错误比 MySQL 少，所以它不像听起来那么疯狂，尽管您偶尔会遇到难以克服的边缘情况。

不是每个数据库都有索引，许多运行 Hadoop 的东西，比如 Hive 和 Spark，没有这个概念，因为底层的 HDFS 系统只是一个大型文件的分布式存储系统，工具只是数据处理器。您可以使用文件结构(最常见的是使用年/月/日)人工创建类似于索引的东西，但是您必须自己维护它。

希望上面的例子也能向你说明，你擅长优化意味着非常熟悉你正在使用的特定工具。

[【返回主题列表】](#635a)

# 减少工作量:磁盘写入

索引在很大程度上是从磁盘上读取内容。当数据进入时，您需要支付预先计算的成本来维护索引，但是读取索引变得更快。那么，如何管理磁盘写入呢？

—等一下。你会问，当我们在做选择操作时，为什么还要讨论写入磁盘呢？选择不主要是一个阅读操作吗？

遗憾的是，选择不仅仅是读取数据，因为有时需要写入磁盘来完成操作。最简单的例子是 Hadoop，MapReduce 过程中的每一步都涉及到将数据写到磁盘，以便它可以传输到下一步(参见[这里的执行概述](/a-mapreduce-overview-6f2d64d8d0e6))。

另一个相当常见的场景是当您处理大型数据集时，结果集不适合进程的主内存。然后，数据库必须将内容转储到磁盘(无论是通过操作系统交换还是显式转储到文件)才能继续工作。当一个在小数据集上运行耗时 5 秒的查询在稍大的数据集上却要花 5000 秒时，您会经常注意到这一点。

您需要参考特定的数据库文档，以确定如何判断您的数据库是否正在写入磁盘，但是当您发现它正在发生时，它通常是优化的候选对象。

## 一次使用较少的数据

在任何系统中，最小化磁盘写入的唯一通用方法是减少您在任何给定时间处理的数据量。这将减少你被迫离开高速内存并掉进磁盘的机会。即使在必须放到磁盘上的情况下，您至少可以写得更少。

您还应该警惕增加行数的操作，也就是将一行数据连接到多行数据的连接。如果您给数据库一些条件，您的数据库可能会进行优化以过滤掉一个巨大的交叉连接，但是如果您一开始就不给它一些条件，您可能会创建一些巨大的数据集。

这在分布式数据系统(如 Hadoop)上变得更加重要，集群中的单个工作节点在某些时候需要将状态和中间结果传输到其他工作节点以继续工作，并且**网络流量甚至比旋转磁盘还要慢。**您希望尽可能地减少这种情况，同样是通过限制您在任一时间点处理的数据量。

[【返回话题列表】](#635a)

# 兼职工作:子查询

子查询可以有效地在数据库中创建一个临时结果表，该表只在查询期间有效。我在这里汇总的一个相关特性是通用表表达式(CTE ),它本质上是一个具有更好语法的命名子查询，可以在一个查询中多次使用，而无需重复执行。

子查询是有趣的生物。它们可能会使事情变得更快或更慢，你必须努力思考和实验，看看它们是否适合用作优化。

关于子查询要知道的是，它们通常是驻留在内存中的**未索引的**临时表状结构。 [PostgreSQL](https://medium.com/@hakibenita/be-careful-with-cte-in-postgresql-fca5e24d2119) 不会，但是 MySQL“可能”[尝试用散列索引](https://dev.mysql.com/doc/refman/5.6/en/subquery-materialization.html)具体化子查询。从技术上来说，Hive 和 Spark 中的子查询也是无索引的，但是索引在这些系统中并不是一件真正的事情，所以这一点有点争议。它只是内存中的一堆行或一个慢慢溢出到磁盘的表。(又是那个词，明白我的意思了吗？)

[CTE/](https://paquier.xyz/postgresql-2/postgres-12-with-materialize/) 物化视图还可以阻止优化器利用子查询和主查询之间的索引关系，就像数据库无法跨越的优化栅栏。这可能是你想要的，也可能不是。

使子查询成为潜在优化的部分是当使用它们过滤数据源的成本低于使用原始数据源的成本时。1K 行的表扫描可能比扫描 1M 行索引更便宜。您在 Hadoop 生态系统中尤其会看到这一点，因为没有索引，而且 MapReduce 总是会溢出到磁盘。一个写得好的子查询可以过滤掉一个数据集，并减少整个查询过程中的后续操作。这也是为什么您更喜欢在 MapReduce 作业的早期使用这些操作，因为您需要为每一步付出磁盘和网络成本。

同时，在关系数据库中，使用现有索引通常比使用无索引的临时结构更有效。如果子查询太大以至于必须转到磁盘，情况就更糟了。所以你会更小心地使用它们，并且在使用时尽量保持它们的尺寸较小。

[【返回主题列表】](#635a)

# 减少低效/重复性工作:临时表格

继续关于子查询的讨论，如果子查询是不可避免的，但是非常慢，该怎么办？您还可以尝试进一步优化—使用带索引的临时表。

请记住，子查询的主要缺陷是它们(大部分)没有被索引。如果我们能给它们加上一个指数，我们就成了黄金。解决这个问题的方法是制作一个临时表，把你需要的索引放在上面。然后我们将有一个合适的索引(通常是 B 树或类似的),它支持我们想要的许多比较操作符。

构建临时表的另一个潜在优势是，它离成为永久表只差一个关键字。创建表与创建临时表。如果您打算跨事务多次重用该结构，那么这是值得的。

但是有什么问题呢？使用临时表的成本是多少？

一个是简单的权限，您需要能够运行创建命令，但可能没有该级别的访问权限。这可能是一个服务器安全性/可靠性问题，尤其是在生产环境中。

第二个缺点是，一旦系统中有了这个中间表，就必须维护它，使它不会过时。随着人们开始依赖该表，您可能需要维护它，或者更频繁地更新它。这都是开销和开发时间。

最后，因为您正在创建一个表，所以您是*显式地*写入磁盘。我已经反复强调这是一个缓慢的操作，你不想重复做。您的 DB 可以选择在内存中而不是磁盘中创建临时表，但是如果它变得太大，您就要返回到磁盘。因此，您只希望在已经准备写入磁盘的情况下使用这个选项，这样写入磁盘和创建索引的成本基本上可以忽略不计。如果您打算多次重复使用该表，也可以这样做，这样做一次比重复使用花费更少。

[【返回话题列表】](#635a)

# 减少在网络上的工作

如果有什么东西比旋转硬盘还慢，那就是网络连接。如果您有一个分布式系统，需要与位于大陆或地球另一端的服务器进行协调，那么您确实会受到光速和网络拥塞的限制。

最重要的是，网络链接的带宽通常小于硬盘驱动器到 CPU 的带宽，这使得运行速度更慢。此外，网络 TCP 开销是一个非常重要的事情。

您可能会认为这是复杂分布式系统人员的问题。的确，对于大型 Hadoop 集群来说，它们比单个托管服务器更重要，但即使是单个服务器安装也会偶尔出现这种情况。当您向外扩展时，您的数据库将独立于您的应用程序或您的分析服务器。

我曾经有一个简单的即席查询变成了常规仪表板，从一个大表中选择一些字段，简单的从表中选择 foo。将数据拉到另一台服务器上运行摄取到 pandas，并在那里进行分组/透视以进行演示，这非常容易。有索引和一切，但它的反应仍然相对较慢。

当我更深入地研究时，我发现很多延迟是在数据库准备和通过网络发送许多兆字节的输出到进行分析的地方。加快速度的最简单方法是将一些分析逻辑转移到 SQL 查询本身，这样就可以减少通过网络发送的原始数据。

[【返回主题列表】](#635a)

# 最小化算法工作:使用更少的 CPU

对于本文的大部分内容，我一直在谈论 I/O，因为 I/O 通常是最大的缓慢来源，也是您可以找到最容易摘到的果实的地方。但我们还没完！计算机还有其他可能很慢的东西，比如实际的计算部分本身！

数据库不是神奇的计算系统，它们和你自己编写的任何程序一样，受到相同的算法约束。它们的排序速度不会比最著名的排序算法更快(因为它们是通用的，所以它们可能也不会使用最适合你的特定情况的算法)。这意味着您调用的特定操作和函数会对性能产生重大影响。

请记住，就像所有复杂的现实世界一样，**没有灵丹妙药。我不能给你一个做什么/不做什么的硬性规定。您必须努力思考并实际测试性能，以找出适合您的特定设置的方法。**

## 文本匹配功能

处理大量文本总是计算密集型工作。无论你做什么，如果你必须一个字符一个字符地扫描整个字符串，这是对字符串长度的 O(n)运算。

所以像这样带有%通配符和不区分大小写的操作符**是相当密集的操作。他们还可以与索引进行[有趣的互动](https://use-the-index-luke.com/sql/where-clause/searching-for-ranges/like-performance-tuning)。其他字符串函数，split、substr、concat 等。所有这些都使用相似的算法，因此在许多情况下并没有好到哪里去。[正则表达式使用起来更加昂贵](https://stackoverflow.com/questions/5892115/whats-the-time-complexity-of-average-regex-algorithms?lq=1)，因为它们更加复杂。所以你越是使用这些功能，一切都变得越慢。**

除了纯粹的计算复杂性，字符串可能是数据库中实际存储的最大的东西。这是假设您使用最佳实践，并且不在数据库中存储大型 BLOBs。如果使用 unicode 编码，每个字符可能是 1、2、3 甚至 4 个字节的数据，这取决于具体情况。文本字段可能包含数兆字节的文本。所有这些意味着我们将很快耗尽内存。

## **分析和**窗口功能

窗口函数非常棒，从过去遗留的 MySQL 5.4 代码库(没有窗口函数)移植到 Postgres 9.4 令人大开眼界。窗口函数可以做像计算百分位数或滞后这样的事情，这在过去是非常困难的和/或非常繁重的连接/子查询。在这方面，窗口函数往往比没有它们的性能有很大的提升。

也就是说，它们不是魔法。所有数组值的额外存储和排序都是计算工作。除非你注意排序、索引和窗口大小等细节，否则它们可能会造成浪费。优化它们往往需要实验和深入阅读查询计划。但这是可行的，用[举例](https://www.cybertec-postgresql.com/en/postgresql-speeding-up-analytics-and-windowing-functions/) [像](https://www.red-gate.com/simple-talk/sql/t-sql-programming/t-sql-window-functions-and-performance/) [这些](https://stackoverflow.com/questions/16343484/sql-window-functions-performance-impact-of-returning-the-same-avg-many-times)。

[【返回主题列表】](#635a)

# 降低交易成本:避免开销

开销很少对新手，甚至是系统的中级用户讲。不管出于什么原因，它被认为是一种深度的书呆子式的巫术，因为它被束缚在“系统的内脏”，在系统如何工作的元层中。但是当你开始寻找它时，你开始意识到开销无处不在。

实际上，我们用计算机做的每件事都涉及一定数量的开销，基本上是准备和维护我们“真正在做”的事情。我们已经讨论了很多可以被认为是开销的东西，这取决于你的观点。

正如我之前提到的，[网络开销可能很大](https://stackoverflow.com/questions/3613989/what-of-traffic-is-network-overhead-on-top-of-http-s-requests)，我们希望通过减少网络传输来避免这种情况。它会消耗您的最大传输带宽，并且不是特定的数据库问题。谷歌提出并发布了一种网络协议 [QUIC](https://ma.ttias.be/googles-quic-protocol-moving-web-tcp-udp/) ，这种协议通过使用 UDP 避免了一些与 TCP(以及网络堆栈的邻近部分)相关的开销，从而提高了网络性能，这一点非常重要。

还有旋转磁盘并寻找正确的扇区来读取数据的“开销”，我们认为这是硬盘寻道时间慢的原因，也是大多数系统转向固态硬盘的原因。这也是我们在整篇文章中竭力避免磁盘操作的部分原因。

类似地，数据库本身也有大量的开销要处理。当它接受一个连接、打开一个事务、提交一个事务时，所有这些都需要时间。

你会问，这种开销可能是多少？一个非常常见的优化是将大量数据上传到数据库。几乎总是这样，您希望避免进行多次小的插入，因为数据库在负载下会陷入困境。即使您在一个包含许多插入的事务中处理所有的事情，它仍然需要不断旋转查询解释器来处理每个查询调用。

相反，最佳实践是创建一个巨大的文件(CSV 或其他文件)并一次性批量加载数据，即使您通过查询在网络上发送文件。这是**快了多个数量级的**。当你第一次遇到它的时候，它是完全疯狂和令人兴奋的。但是这完全有意义，因为对于一个小的单行插入，连接/事务处理时间比处理该插入所花费的时间要多。

同样的开销问题也适用于运行一组 SELECT 语句。这里仍然涉及到开销。如果你一直用大量的小请求敲打数据库，最终会使整个服务器陷入瘫痪。您可能希望获取更多数据并在本地处理，或者考虑使用某种缓存。

## 到处都有缓存

应用程序实际使用的一种提高应用程序响应性和减少数据库负载的技术是简单地缓存一段时间的查询结果，以便重复的调用完全跳过数据库，只给出缓存的结果。这是应用程序级别的东西，并不是专门针对您的 SQL 查询的优化，但这是一种足够常见的响应模式，您可能会在您使用的一些分析工具上看到它。

然而，在 SQL 查询级别，缓存仍然是一件需要注意的事情。快速连续多次运行完全相同的查询实际上会产生不同的运行时间，即使数据库没有缓存结果。这是因为第一个查询用数据填充了磁盘缓存和操作系统缓存。这不太可能是你的全部数据集，但在少数情况下，这是一个显著的(暂时的)速度提升。如果你是标杆管理的新手，这会影响你做的任何标杆管理。

事实上，虽然您通常没有意识到这一点，但数据库和它们运行的操作系统会使用缓存技术来挤出额外的性能。这里有一个关于 [Postgresql 的缓存](https://madusudanan.com/blog/understanding-postgres-caching-in-depth/)行为的帖子，广义来说其他数据库也会在不同程度上做类似的事情。

[【返回话题列表】](#635a)

# 与他人相处融洽:竞争

作为一个刚刚开始查询的最终用户，很容易**忘记数据库是多用户系统。他们通常处理事情非常迅速和透明，你永远不会真正知道通常有其他人在同一时间攻击服务器。但是，当您将服务器推向其操作极限时，您可能会遇到这样的情况:来自其他用户的查询，或者来自您自己的并行作业的查询，将开始对您产生影响。**

## 一般负荷计划

机器的使用遵循人类的活动模式，因此一天中的某些时段会比其他时段更忙。随着报告和数据库查询开始自动化，大批量请求的时间安排变得越来越重要。夜间作业通常被设置为在晚上非常相似的时间运行(通常在午夜左右)，因为每个人都认为那时服务器将是“空的”。只不过它们不是，现在系统必须在同时运行的 10 个批处理查询之间进行任务切换。

这仅仅是一个资源调度问题，但是我见过在空载服务器上运行只需 5-10 分钟的批处理作业延长到 30 分钟以上，因为它们与一堆其他作业争夺资源。

## 锁

一般负载有点烦人，因为它使事情变得不必要的慢，但是通过锁定会出现更严重的争用问题。数据库希望保持一致，这有时意味着当某些操作运行时，例如大的更新/写操作，整个表可能会被锁定。无论是行级锁还是表级锁，都取决于具体的细节，但无论是哪种情况，如果您有另一个查询需要访问那些被锁定的行，那么在解除锁之前，它们都不允许运行。

锁有时会变成被称为死锁的病态情况，但这种情况很少见。更常见的情况是，它会造成查询堵塞，因为等待而似乎要花很长时间。另一个不太常见的影响是，锁会影响服务器复制，有时甚至会停止数据复制，这意味着没有新的数据更新进出服务器，并导致各种意想不到的副作用。(我向 devops 的人们深表歉意，这些年来我用超长的分析查询破坏了复制)。

[【返回主题列表】](#635a)

# 最后，答案是否定的:向问题扔钱

整篇文章都致力于让查询变得更快。因此，忽视速度的最终答案是错误的——更多的硬件和/或更好的软件，也就是投入资金解决问题。这是我们的最后一招，不是第一招，但也不能忽视。

有时，尽管您尽了最大努力来优化您的查询以使事情进行得更快，您还是会遇到 I/O 的限制，有时还会遇到 CPU 的限制，这些限制是您所拥有的系统无法克服的。在这种情况下，只有一件事可以让事情进展得更快:砸钱。重新设计您的系统，获得更多内存、更大的 RAID 阵列、更快的磁盘、更快的 CPU、更快的网卡和互连，当所有这些还不够时，可以通过集群进行扩展。我不是在开玩笑，脸书一度将他们的 [MySQL 设置扩展到了完全疯狂的](http://highscalability.com/blog/2015/5/18/how-mysql-is-able-to-scale-to-200-million-qps-mysql-cluster.html)水平。如果集群还不够，请根据您需要的速度重新设计您的整个应用系统架构，而不仅仅是 DB 架构。

我们优化查询和数据库的目标是尽可能提高设备的性能，让花在系统上的每一分钱都获得最佳性能。非常容易顾全大局，嘲笑“如果不能做得更快，就多买些设备”的想法。但我们需要承认，优化不可避免地会有一个硬限制，即使这是一个非常高的限制，但确实存在一个收益递减点。经过完美调校和改装的 Miata 永远无法达到 F1 赛车的速度。

查询优化的最后一个技巧是了解何时已经完成了所有可行的优化，何时速度的代价比升级的成本更高。这很难，因为这是一个排除的过程，一个否定的“我们在这里做不了更多”的证明。

但是如果你真的发现自己处于这种情况，那就出去升级系统，这样你就可以重新优化了。

# 在写这篇文章的时候，我发现了一些有趣的链接

排名不分先后:

*   [使用索引，Luke](https://use-the-index-luke.com/sql/preface)—DB performance for developers，许多关于数据库不同部分的性能和行为的小细节
*   [关于硬件和服务器性能的神话](https://logicalread.com/mythbusting-hardware-sql-server-perf-dc01/)——有很多关于用硬件解决问题并不是解决方案的故事
*   [PostgreSQL 中的缓存](https://madusudanan.com/blog/understanding-postgres-caching-in-depth/) —详细介绍了 PostgreSQL 用来更快交付结果的缓存策略，以及缓存如何与其他函数交互
*   [查询优化的故事](https://parallelthoughts.xyz/2019/05/a-tale-of-query-optimization/) —有人记录了他们优化查询的旅程，经历了许多曲折，最终追溯到数组比较& &操作符