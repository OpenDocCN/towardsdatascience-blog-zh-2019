<html>
<head>
<title>Demystifying Feed-forward and Back-propagation using MS Excel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 MS Excel 揭开前馈和反向传播的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-feed-forward-and-back-propagation-using-ms-excel-30f5aeefcfc7?source=collection_archive---------7-----------------------#2019-02-12">https://towardsdatascience.com/demystifying-feed-forward-and-back-propagation-using-ms-excel-30f5aeefcfc7?source=collection_archive---------7-----------------------#2019-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="017a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><em class="km">深入探究神经网络的奥秘，超越理论界限，在 MS Excel 中实现它。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/8559340cf3c5bb80689b917f06205d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USJifaaBxcvQrAofsv8K2A.jpeg"/></div></div></figure><p id="c36a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">近年来，关于神经网络(NNs)已经说了很多，也写了很多——从感知器的概念到神经元的复杂多层结构。本文试图揭开两种基本算法的神秘面纱，<strong class="jq ir">前馈</strong>和<strong class="jq ir">反向传播</strong>，这两种算法使得神经网络能够工作。使用 Microsoft Excel 以最简单的形式解释了这些技术。</p><p id="7901" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">所考虑的例子是非常基础的，与真实世界的例子相去甚远。这里的意图是保持简单直观，理解工作逻辑，而不是关注背后复杂的数学。</p><p id="9d9e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">首先，我只考虑了一个输入向量 V= [X1=1，X2= 0，X3=1，X4=0]，它有一个由 3 个神经元和一个输出层组成的隐藏层。目标输出是 1。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/2e82841c1c9e32292e0e2cbbcbb62cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*aIw-2s9KjEzK3hKlKHh-bg.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Neural Network with One Hidden Layer</figcaption></figure><p id="00cb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">网络设置- </strong></p><p id="47cd" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> <em class="km">输入和输出- </em> </strong>作为一个例子，假设我们期望算法对于‘X1’&amp;‘X3’(比如说 1)的指示非零值给出输出‘1’，对于‘X2’&amp;‘X4’给出输出‘0’。因此，这里考虑的输入向量是[1，0，1，0]。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/08820a5cbc932d13d2abe7c9ca6cdf04.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*uAbDsF1RNWn5IqkoWGNsfQ.jpeg"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Input and Output</figcaption></figure></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="e6af" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak"> <em class="jn">前馈:</em> </strong></h1><h2 id="8441" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 1:初始化网络参数</h2><p id="6bb0" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">第一步是使用 MS Excel 中的<strong class="jq ir"> rand() </strong>函数初始化权重和偏差。</p><p id="c962" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><em class="km">(附注:下表中突出显示的单元格代表基于建议公式的导出值)</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nb"><img src="../Images/0d2379a6a7e33135057e316fdc498b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJHEgDhYdDEt4NHAo1PbEA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Weights and Biases — Input to Hidden Layer</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0dfdd28be46c50bb6f27f95c672116ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*qgujnFZgOxBS_26bZ710gw.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Weights and Biases — Hidden to Output Layer</figcaption></figure><h2 id="e36c" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 2:计算隐藏层节点的净输入</h2><p id="38d0" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">净输入只不过是输入乘以权重，然后按偏差递增。使用输入向量[1×4]和权重[4×3]的矩阵乘法，结果矩阵的维数为[1×3]。要在 excel 中实现这一点，请使用<strong class="jq ir"> =SUMPRODUCT() </strong>得出如下结果矩阵[1X3]</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nd"><img src="../Images/113aac8e9b0886587f2d667e2d796afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*liZhRdHUva5k2ZHVMAYlqA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Input times Weight</figcaption></figure><p id="ab69" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在突出显示的单元格中使用公式来获得<em class="km">输入乘以权重</em>:</p><blockquote class="ne nf ng"><p id="c37c" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =SUMPRODUCT({1，0，1，0}，{0.49，0.35，0.44，0.80}) </strong></p><p id="d20f" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =SUMPRODUCT({1，0，1，0}，{0.72，0.90，0.58，0.92}) </strong></p><p id="0dd0" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =SUMPRODUCT({1，0，1，0}，{0.38，0.43，0.39，0.21}) </strong></p></blockquote><p id="20b3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在，给这些<em class="km">输入乘以权重</em>加上偏差</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nk"><img src="../Images/6da89b6cbac60aabc67b04594a4a6f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYjWmB2q9YtXMPQMAjy1rw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Net Input</figcaption></figure><p id="1b78" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式，以获得净输入</p><blockquote class="ne nf ng"><p id="3925" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> <em class="iq"> = </em> SUM(0.92，0.40) </strong></p><p id="d9dd" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =SUM(1.30，0.00) </strong></p><p id="dd6a" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =SUM(0.76，0.99) </strong></p></blockquote><h2 id="7852" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 3:通过激活函数(Sigmoid)传递净输入</h2><p id="b124" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">让我们将“步骤 2”的输出[1.33，1.30，0.99]作为输入传递给隐藏层的每个神经元处的激活函数[f(1.33)，f(1.30)，f(0.99)]，这可以通过在 MS Excel 中键入 f(x) = 1/(1+exp (-x))来轻松完成。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c62233ff28e3ca7ab32bb1e02f4d6203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*REIYe29i5n7rBom0cV2ltw.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Output at Hidden Layer</figcaption></figure><p id="5014" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式，以获得隐藏层输出:</p><blockquote class="ne nf ng"><p id="3588" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =1/(1+exp(-1.33) ) </strong></p><p id="d64c" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =1/(1+exp(-1.30)) </strong></p><p id="1399" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =1/(1+exp(-0.99)) </strong></p></blockquote><h2 id="2e60" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 4:计算输出节点的净输入</h2><p id="fc39" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">现在，“步骤 3”的输出[0.79，0.79，0.73]将作为输出节点的输入。让我们重复“步骤 2”，输入向量为[0.79，0.79，0.73]，权重向量为[0.71，0.16，0.57]，输出偏差为[0.83]。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nm"><img src="../Images/4873c23ec7747359df254574b79fa075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qb3njGVe84E68Kg3kM97vg.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Net Input at Output Node</figcaption></figure><p id="0a87" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在突出显示的单元格中使用的公式，用于在输出节点获得<em class="km">净输入</em></p><blockquote class="ne nf ng"><p id="ec35" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =SUMPRODUCT ({0.79，0.79，0.73}，{0.71，0.16，0.57}) + 0.83 </strong></p></blockquote><p id="94a8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">其中简化后= <strong class="jq ir"> 1.93 </strong></p><h2 id="4b8e" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 5:获得神经网络的最终输出</h2><p id="84ff" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">让我们将从“步骤 4”[1.93]接收到的输出作为 f(1.93)传递给激活函数，这也可以使用 f(x)=1/(1+exp(-x))来计算，从而得到神经网络的最终输出。</p><blockquote class="ne nf ng"><p id="6a10" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> =1/(1+exp(-1.93)) </strong></p></blockquote><p id="08ec" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> <em class="km">前馈网络输出=0.87 </em> </strong></p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="c390" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">反向传播:</strong></h1><p id="566c" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">一旦获得前馈的输出，下一步是通过与目标结果比较来评估从网络接收的输出。</p><p id="6cbe" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在，神经网络设计者控制的一个明显的事情是权重和偏差(也称为网络参数)。因此，这里的挑战是找到能够最小化误差平方和的最佳权重和偏差:<em class="km"> E=1/2 ∑(网络输出-目标输出)</em>由网络接收，在这种情况下=[0.5 *(0.13)]= 0.00798</p><p id="da66" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们需要单独查看这些权重和偏差所造成的误差，然后不断更新它们以减少误差。这个过程将被重复直到收敛。一旦达到最优，该网络将被称为训练过的网络。让我们开始在 Excel 中实现这个理论。</p><h2 id="d98c" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 1:更新权重[wH1，wH2，wH3]</h2><p id="228d" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">使用<a class="ae nn" href="https://en.wikipedia.org/wiki/Chain_rule" rel="noopener ugc nofollow" target="_blank">链式法则</a> ( <em class="km">我将跳过这里的推导</em>)计算误差函数<strong class="jq ir"> E </strong>相对于权重【wH1，wH2，wH3】的导数，简化后等于</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi no"><img src="../Images/ae3e01f24e0845314cbfabd7da5d4ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BsduWZ_uq2Guhp-ATI5VQ.png"/></div></div></figure><p id="0db2" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">其中，<em class="km">sigmoid 函数 f(x)的导数= [f(x)*(1-f(x)] </em></p><p id="e7ff" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">所以，[ <em class="km"> d </em> (E)/d(wH1)，d(E)/d(wH2)，d(E)/d(wH3)] =</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi np"><img src="../Images/0e66b0f2ea870e9bf03cafe957890fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jFIIW0guR3dOUwFNFkKNQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Derivative of E with respect to WH1, WH2 and WH3 respectively</figcaption></figure><p id="e7ce" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><blockquote class="ne nf ng"><p id="447c" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=乘积(-0.13，0.87，0.13，0.79) </strong></p><p id="b0f3" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=乘积(-0.13，0.87，0.13，0.79) </strong></p><p id="0868" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=乘积(-0.13，0.87，0.13，0.73) </strong></p></blockquote><p id="9611" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">新的更新权重将是<strong class="jq ir">【初始权重】— [{(学习率)* [d(E)/d(wH1)，d(E)/d(wH2)，d(E)/d(wH3)]]，</strong>其中，学习率被假定为 0.5</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nq"><img src="../Images/f77bba371c266e33915fd592872a6bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5kfGAzdnbBxoYdk6uUfDw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Updated weights after 1st Iteration</figcaption></figure><p id="efb3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">通过使用-</p><blockquote class="ne nf ng"><p id="3ba5" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.71)-乘积(0.5，-0.0110) </strong></p><p id="1c65" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.16)-乘积(0.5，-0.0110) </strong></p><p id="e5e7" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.57)-乘积(0.5，-0.0102) </strong></p></blockquote><h2 id="f33a" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated"><strong class="ak">步骤 2 —在输出节点</strong>更新偏置 BO</h2><p id="031d" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">对于偏差，使用链式法则计算误差函数<strong class="jq ir"> E </strong>相对于偏差 BO 的导数，简化后等于</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi no"><img src="../Images/267c2dd5e4056ede77fc5164925267cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhVljKgpuxIeTHwB76FSDw.png"/></div></div></figure><p id="b703" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">所以，d(E)/d(BO)= 1</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e8a74eafaa447aefaa606584489318b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*E-MrgpRGv7V4gCgTOv0DdA.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Derivative of Error E with respect to output node bias</figcaption></figure><p id="04fb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><blockquote class="ne nf ng"><p id="36e6" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"> <em class="iq"> =乘积(-0.13，0.87，0.13) </em> </strong></p></blockquote><p id="60b8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">新的更新偏差[BO] <em class="km">新的</em>=[初始偏差]—[学习率*{d(E)/d(BO)}]</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ns"><img src="../Images/522ecd80471c8312eb17493a0ddebf7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3o2nvbXYk2IuBeK3iM7TQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Update Bias at Output node after 1st Iteration</figcaption></figure><p id="df95" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><blockquote class="ne nf ng"><p id="52a5" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.83)-乘积(0.5，-0.0139) </strong></p></blockquote><h2 id="2c1d" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 3-更新权重[w11，w12，…w43]</h2><p id="c88e" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">为了更新“隐藏输入”层的权重，让我们计算误差<strong class="jq ir"> E </strong>相对于权重【W11，W12…w43】的导数，其在简化后等于</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nt"><img src="../Images/ddd7d8390f62c4f582cf02769d29fdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBWzFsj6SpOwfLhERHlaqw.png"/></div></div></figure><p id="fa22" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">所以，[ <em class="km"> d </em> (E)/d(w11)，d(E)/d(w12)，……d(E)/d(w43)] =</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nu"><img src="../Images/15fb1d3b36846c075b399d6c25680fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJ9BDc_wCYW2sty4tMkl7w.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Derivatives of error E with respect to weights w11, w12,….w43</figcaption></figure><p id="1c1e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nv"><img src="../Images/8ac80a63dd834a9fc786401394f97f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQ6oeo8ti6wn-GCSMQ1NDQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">MS Excel formula to be used to get the derivatives</figcaption></figure><p id="0b99" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">新的更新权重=[初始权重]—[学习率* (d(E)/dwij)]</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nw"><img src="../Images/3d1e146f6df5adfc1bd76dc17041632a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzVaHNij0nST4aekoxv6OA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Updated Weight after 1st Iteration</figcaption></figure><p id="048c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nx"><img src="../Images/4916acacd93810cc2eea3fe6a66752cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyWUH5xA9FhOUovCq9UQaA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">MS Excel formula to be used to update the weights</figcaption></figure><h2 id="9ec3" class="mk ln iq bd lo ml mm dn ls mn mo dp lw jz mp mq ma kd mr ms me kh mt mu mi mv bi translated">步骤 4:更新偏差[BH1，BH2，BH3]</h2><p id="fca0" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">同样，使用链式法则计算误差<strong class="jq ir"> E </strong>相对于隐藏节点偏差的导数，简化后等于</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ny"><img src="../Images/865b88887343ccf7ae2e34a341df187d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3PJdBvn5NZni-gHW1UtRA.png"/></div></div></figure><p id="229b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">所以，[ <em class="km"> d </em> (E)/d(BH1)，d(E)/d(BH2)，d(E)/d(BH3)] =</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nz"><img src="../Images/73502a7ffb507af116ee32de20610240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2bAeBVdeKm-Mjhs4326Jg.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Derivative of error E with respect to Bias at Hidden nodes</figcaption></figure><p id="6f45" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><blockquote class="ne nf ng"><p id="d4fc" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"><em class="iq">=乘积(-0.13，0.87，0.13，0.71，0.79，0.21) </em> </strong></p><p id="c238" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"><em class="iq">=乘积(-0.13，0.87，0.13，0.16，0.79，0.21) </em> </strong></p><p id="377f" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir"><em class="iq">=乘积(-0.13，0.87，0.13，0.57，0.73，0.27) </em> </strong></p></blockquote><p id="6210" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">新的更新偏差=[初始偏差]—[学习率* (d(E)/d(BHi))]</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oa"><img src="../Images/7f34547931b59c952ca1745416e14c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zc-dydND0k-HgYCa94vL1g.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk">Updated Hidden node Bias after 1st Iteration</figcaption></figure><p id="eb6a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要在突出显示的单元格中使用的公式:</p><blockquote class="ne nf ng"><p id="248a" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.40)-乘积(0.5，-0.0016) </strong></p><p id="b752" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.00)-乘积(0.5，-0.0004) </strong></p><p id="e15c" class="jo jp km jq b jr js jt ju jv jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk kl ij bi translated"><strong class="jq ir">=(0.22)-乘积(0.5，-0.0016) </strong></p></blockquote><p id="01c6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">因此，我们已经完成了<strong class="jq ir">前馈</strong>和<strong class="jq ir">反向传播</strong>的一个循环，重复相同的步骤，即使用这些更新的参数再次运行前馈将使您更接近目标输出，反向传播将再次用于更新这些参数。这种前馈和反向传播的循环过程将继续下去，直到误差变得几乎恒定，并且在目标输出中没有太多进一步改进的余地。</p><p id="1afe" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">上述模型在 Excel 中实现，经过 100 次迭代后，网络的行为如下所示。随着每次迭代，网络输出朝着目标输出(蓝线)前进，误差(红线)减少。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ob"><img src="../Images/c41d1d98704a068dfd89889ce6e6c99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DflkZbY_o4DdBiyB_szefA.png"/></div></div></figure><h1 id="3809" class="lm ln iq bd lo lp oc lr ls lt od lv lw lx oe lz ma mb of md me mf og mh mi mj bi translated">为什么选择 MS Excel？</h1><p id="a9c2" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">在 excel 中实现这些复杂概念的主要优势是为这些网络的工作方式提供了坚实的基础，如果您非常了解基础知识，理解复杂架构的工作方式会容易得多。</p><h1 id="3308" class="lm ln iq bd lo lp oc lr ls lt od lv lw lx oe lz ma mb of md me mf og mh mi mj bi translated">接下来是什么:</h1><p id="e841" class="pw-post-body-paragraph jo jp iq jq b jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl ij bi translated">在我接下来的系列文章中，我将尝试将这些概念与相关的数学联系起来。此外，输入可以通过不同的方式传递到网络，训练网络参数也有不同的方式。我将在以后的文章中谈到这些细节。</p><p id="242e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">希望这种在 excel 中演示神经网络的努力将有助于初学者轻松地理解前馈和反向传播的概念。如果您需要在 excel 中实现一个现成的神经网络作为工作模型，请联系我。</p></div></div>    
</body>
</html>