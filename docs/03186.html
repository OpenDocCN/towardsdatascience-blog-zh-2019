<html>
<head>
<title>Pretty displaying tricks for columnar data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中柱状数据的漂亮展示技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pretty-displaying-tricks-for-columnar-data-in-python-2fe3b3ed9b83?source=collection_archive---------2-----------------------#2019-05-22">https://towardsdatascience.com/pretty-displaying-tricks-for-columnar-data-in-python-2fe3b3ed9b83?source=collection_archive---------2-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aafd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改进 Python 及其库显示数据的方式，并使其可读</h2></div><p id="8ca0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于以前使用 lists、Pandas 或 NumPy 广泛争论过数据的每个人来说，您可能都遇到过以正确的方式打印数据的问题。特别是如果有很多列，显示数据就变得很麻烦。本文向您展示了如何以可读的方式用 python 打印大型列数据。</p><p id="3eb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解释清楚，我使用的是<strong class="kk iu"> NYC 房产销售数据</strong>，总共有 21 列。</p><p id="0952" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有一个包含许多列的 Pandas 数据帧，并试图用常规的 print 语句将其打印出来，就会发生这种情况:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="95b8" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">import </strong>pandas <strong class="lj iu">as </strong>pd</span><span id="210c" class="ln lo it lj b gy lt lq l lr ls">nycdata=pd.read_csv(<strong class="lj iu">'nyc-rolling-sales.csv'</strong>,index_col=0)</span><span id="e0b1" class="ln lo it lj b gy lt lq l lr ls">print(nycdata.head())</span></pre><figure class="le lf lg lh gt lv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/dc4557a08d9060c3c03647421f10cd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*tMl-1x1OdxS--o3k2dvhsA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Data is omitted from printing</figcaption></figure><p id="1daf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发生这种情况是因为 Pandas 将检测它可以在终端窗口空间中容纳的列数，这将不会准确显示我们需要的内容。为了节省屏幕上的终端空间，打印时会忽略大部分数据。</p><p id="d7ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要解决这个问题，这里有一些方法。</p><h2 id="324c" class="ln lo it bd mc md me dn mf mg mh dp mi kr mj mk ml kv mm mn mo kz mp mq mr ms bi translated"><strong class="ak">好的</strong>绝招</h2><p id="7aa2" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">您可以增加 Pandas 允许您显示的最大列数，方法是在代码中添加以下代码行:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6570" class="ln lo it lj b gy lp lq l lr ls">pd.options.display.max_columns = <strong class="lj iu">None</strong></span></pre><p id="67ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将取消屏幕上显示的最大列数限制。以下是打印时的样子(现在只打印前 11 列..)</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d14d4373a00a0d4cc6a1ee343168ffb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*B3VSyVqWi4JXrisewVz58g.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Print result after removing max column limit</figcaption></figure><p id="0970" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，嘿，这并不完全是我们所需要的。数据被分成多行，标题由反斜杠分隔。这是可读和有用的，但仍不完美。</p><p id="c3e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要克服这一点，只需在代码中使用这一行，就可以在一行中获得所有数据:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="90c9" class="ln lo it lj b gy lp lq l lr ls">pd.options.display.width=None</span></pre><p id="8c98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是它现在的样子(只打印了 7 列):</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/9b07bf933be58cdf3e2ed4c588806150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKAhZ-4usgJMBAbAE0PuCg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Print result after removing max width limit</figcaption></figure><p id="72d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意——大多数代码编辑器不会以一种好的方式显示大块的列数据。您的输出将以一种完全不可读的方式变得混乱，并且您需要最大化您的输出窗口以便很好地查看所有的数据。PyCharm 在这种情况下做得非常好——它向您显示了一个水平滚动条，您可以在这里滚动浏览您打印的数据。标准终端或编辑器(如 VSCode)不会出现这种情况。</p><p id="623b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用终端或 VSCode，请将窗口最大化并减小字体大小，以便您可以在有限的空间中容纳最多的列，并且可以很好地查看您的数据。</p><p id="f106" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是完整数据在终端输出中的显示方式(VSCode 以同样的方式打印):</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ne"><img src="../Images/6655fe24097c53870aa77c189cc075ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouU6LHEJlgLLUjTxnFnhpQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">All columns in Terminal</figcaption></figure><p id="f94a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是 PyCharm 展示相同数据的方式:</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nf"><img src="../Images/73b103c78a011a97a1c3a1a98c371c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*p7KWBu5Sg_wiF48FjkHegw.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">PyCharm’s scrollbar print</figcaption></figure><p id="5032" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在使用 PyCharm，并且希望显示与上述类似的数据，或者如果您认为最大化和缩小字体大小是可以接受的，这里有一个更好的方法来显示您的数据。</p><h2 id="5a8d" class="ln lo it bd mc md me dn mf mg mh dp mi kr mj mk ml kv mm mn mo kz mp mq mr ms bi translated"><strong class="ak">更好的</strong>绝招:</h2><p id="b2bc" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">您可以使用名为“制表”的库来轻松显示列中的数据。这就像将一个简单的函数封装到数据帧上使用的打印函数中一样简单。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2077" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">from </strong>tabulate <strong class="lj iu">import </strong>tabulate<br/>.<br/>.<br/>.<br/>print(tabulate(df,headers=<strong class="lj iu">'firstrow'</strong>))</span></pre><p id="e416" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是制表显示数据的方式:</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ng"><img src="../Images/80d0eee11f78b4beee1055810f8fd75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Byt0BdrCOjhXXzsg0-bAoQ.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Tabulate’s print</figcaption></figure><p id="b3a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了去掉 print 语句中多余的代码行，可以这样编写一个简单的 lambda 函数:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f7fa" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">from </strong>tabulate <strong class="lj iu">import </strong>tabulate<br/>pdtabulate=<strong class="lj iu">lambda </strong>df:tabulate(df,headers=<strong class="lj iu">'keys'</strong>)<br/>.<br/>.<br/>.<br/>print(pdtabulate(df))</span></pre><p id="41d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更神奇的是，你可以从多种格式中选择打印格式。你所需要做的就是将'<strong class="kk iu"> tablefmt </strong>'参数添加到制表函数中，并为其分配你选择的打印格式。我最喜欢的是“<strong class="kk iu"> psql </strong>，它使用 PostgreSQL 的格式来显示表格数据。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="89f5" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">from </strong>tabulate <strong class="lj iu">import </strong>tabulate<br/>pdtabulate=<strong class="lj iu">lambda </strong>df:tabulate(df,headers=<strong class="lj iu">'keys'</strong>,tablefmt=<strong class="lj iu">'psql'</strong>)<br/>.<br/>.<br/>.<br/>print(pdtabulate(df))</span></pre><p id="81fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是它看起来的样子:</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ng"><img src="../Images/fc66f37a306620e94d7a36b9e08dc050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LQWsKBj0twyEiMm1xImDbw.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Feels like SQL!</figcaption></figure><p id="3f67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有必要将数据转换成 HTML 表格，制表很容易为您做到这一点。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9e21" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">from </strong>tabulate <strong class="lj iu">import </strong>tabulate<br/>pdtabulate=<strong class="lj iu">lambda </strong>df:tabulate(df,headers=<strong class="lj iu">'keys'</strong>,tablefmt=<strong class="lj iu">'html'</strong>)<br/>.<br/>.<br/>.<br/>print(pdtabulate(df))</span></pre><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nh"><img src="../Images/ba3e289936343f7ebe3a59fa0e8a3253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWr62O-e3okgu0j8nONu5Q.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Data printed to HTML Tables</figcaption></figure><p id="a80f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使对于大型列表和巨大的 NumPy 数组，制表也非常有效。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="430c" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">from </strong>tabulate <strong class="lj iu">import </strong>tabulate<br/><br/>pdtabulate=<strong class="lj iu">lambda </strong>df:tabulate(df,headers=<strong class="lj iu">'keys'</strong>,tablefmt=<strong class="lj iu">'psql'</strong>)</span><span id="7008" class="ln lo it lj b gy lt lq l lr ls">#Creating a list using garbage values<br/>list = [['a', 'b', 'c','d'], ['aaaaaaaaaa', 'b', 'c'], ['a', 'bbbbbbbbbb', 'c'], ['aaaaaaaaaa', 'b', 'c'], ['a', 'bbbbbbbbbb', 'c'], ['aaaaaaaaaa', 'b', 'c'], ['a', 'bbbbbbbbbb', 'c'], ['aaaaaaaaaa', 'b', 'c'], ['a', 'bbbbbbbbbb', 'c']]</span><span id="0de3" class="ln lo it lj b gy lt lq l lr ls">print(pdtabulate(list))</span></pre><p id="bd1d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是它看起来的样子:</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ca80a5537d0c130a091e2e62e98115f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*ysJhlv8urgCJBmhvVzPfrw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Normal vs tabulated prints of 2D lists</figcaption></figure><p id="d6df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用制表可视化的示例 NumPy 数组:</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5595d6e01f6b02136a96b00e4131e7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*4JR4xHeBU-2U_Qstqy0QEg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Normal vs tabulated prints of a simple NumPy array</figcaption></figure><p id="96b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多关于这个令人惊叹的图书馆的信息和更多关于不同印刷格式的知识，请访问<a class="ae nk" href="https://pypi.org/project/tabulate/" rel="noopener ugc nofollow" target="_blank">本页</a>。</p><p id="b727" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这些技巧会很有帮助，但下面的技巧尽可能以最好的方式展示了我们的数据。</p><h2 id="6994" class="ln lo it bd mc md me dn mf mg mh dp mi kr mj mk ml kv mm mn mo kz mp mq mr ms bi translated"><strong class="ak">最好的</strong>绝招:</h2><p id="2b8c" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">忘掉 PyCharm、终端和制表软件吧——用 Jupyter 笔记本来显示你的数据。</p><p id="1e9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jupyter 笔记本显示您的数据类似于第一种开箱即用的情况——它们在显示中省略了几列。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nl"><img src="../Images/3f6eba328fcf6da0529e086115ed4398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AtphHivhDTW9dYP0gCgKbw.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Data displayed in a Jupyter Notebook — few columns are omitted</figcaption></figure><p id="f2fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，使用打印示例中使用的同一行来显示数据的所有列:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="264d" class="ln lo it lj b gy lp lq l lr ls">pd.options.display.max_columns = <strong class="lj iu">None</strong></span></pre><p id="398e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jupyter 向您展示了一个完美格式化的 HTML 表格:</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nl"><img src="../Images/d6c9a6d041d7c42ce6aa552bdae81d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lwCnxGUC4eyLPvkwWyv88A.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Data after removing max column limit</figcaption></figure><h2 id="7908" class="ln lo it bd mc md me dn mf mg mh dp mi kr mj mk ml kv mm mn mo kz mp mq mr ms bi translated"><strong class="ak">一天的结束..</strong></h2><p id="ad87" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">如果你习惯经常使用 Jupyter 笔记本，只需将最大列数设置为无，就可以一次显示所有数据。但是如果你是一个喜欢在编辑器中编写代码，而不是使用 Jupyter 笔记本来理解数据的人，那么使用制表库是最好的选择。</p></div></div>    
</body>
</html>