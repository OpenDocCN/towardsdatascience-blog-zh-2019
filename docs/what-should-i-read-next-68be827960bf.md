# 接下来该看哪本书？

> 原文：<https://towardsdatascience.com/what-should-i-read-next-68be827960bf?source=collection_archive---------17----------------------->

![](img/cf08f32910e248bf89ee0d8ed96e3332.png)

Back Bay, Boston

我喜欢阅读，但每次读完一本书，我都会遇到同样的问题:接下来读什么？我使用的平台应该有大量的数据来帮助我解决这个问题。

然而，Libby——通过波士顿公共图书馆——没有提供任何推荐，亚马逊公司 [Goodreads](http://www.goodreads.com) 的推荐也不是很好，我在那里存储了我的阅读历史。

我想要一个算法，为我提供有针对性和相关的选项，由于我没有通过我目前的图书供应商获得它，我想我会尝试自己构建它。

*关于 Python 的完整项目代码，* [*请点击这里*](https://github.com/jordanbean/book_recommendation_system) *。*

**数据**

![](img/909b40db345cfa945c45ce9200cf4856.png)![](img/cc6d0b2834e7cb58b3f786325c03b38b.png)![](img/b74c543c4131965500038ec380aaa999.png)

我能够找到的[最佳数据集](https://github.com/zygmuntz/goodbooks-10k)包含来自 [Goodreads](http://www.goodreads.com) 的前 10，000 本书，以及用户评级、用户想要阅读的书，以及读者与该书相关联的任何标签。

这些数据有其局限性。我们只能访问 10，000 本最受欢迎的书籍，不能添加额外的信息，如流派或书籍描述。数据截至 2017 年，因此我们错过了新出版的书籍。也就是说，肯定有足够的东西来构建算法的框架。

我还能够导出我自己的 Goodreads 数据，虽然我读过的每本书都排在前 10，000 名，但在只考虑了我希望在算法中考虑的书籍后，有大约 60 本匹配。

**方法和批判性思维**

根据我们现有的信息，我觉得最好的方法是找到与我“最相似”的用户，然后寻找他们读过而我没有读过的最受欢迎的书(根据平均评分或阅读次数)。这种方法——在用户中寻找模式，并应用这些模式进行推荐——被称为[协同过滤。](https://en.wikipedia.org/wiki/Collaborative_filtering)

当你在一个产品下看到“购买了这个商品的顾客也购买了”的推荐集时，它实际上是亚马逊使用的一个简化版本。

![](img/25bfb5bc55fe252c5e43d187c4787e3f.png)

Example product recommendations when searching for a cold brew pitcher.

我最初构思这篇文章的目的是关注协同过滤的步骤，但是在我完成第一组代码并查看结果之后，我意识到除了简单的过滤和编码之外，还有很多东西需要考虑。相反，下面将着重于如何使用直觉和批判性思维来提高最初的结果。

![](img/9fd514505daeef721051c2f25ca8250d.png)![](img/49c79f8cdae729fd0f7fd6ae6214fcae.png)![](img/429b768f23499eb5526b4b8b898e9bd5.png)

*投入的加权和标准化*

我意识到，需要有一种方法来标准化一本书在总体上以及在相似读者的相关样本中的受欢迎程度。否则，相似用户阅读最多的书可能会受到该书总体受欢迎程度的过度影响。这不一定不好，但是我想要一种方法来调整样本与总体。

为了克服这一点，我选择使用一种标准化结果的方法，将一本书被评分(阅读)并标记为“值得阅读”的次数除以该书的总评论数。除了帮助我们排序结果和抵消一本书的总受欢迎程度之外，这个比率在任何方面都不一定有意义。

那么，在选择读哪本书的时候，我是想要最受欢迎的书(按这个比例)还是收视率最高的书呢？我应该更看重我已经读过并喜欢的作者的书吗？或者说，应该优先选择 5 星评分最多的那家？简而言之，我选择创建一个与我的偏好相匹配的变量权重。如果我的偏好改变，这些可以在函数调用中改变:

```
rec_weight_avg_rating = 0.5, 
rec_weight_read_ratio = 0.4, 
rec_weight_perc_4_5 = 0.1, 
rec_weight_perc_1_2 = -0.1, 
rec_weight_author_previous = 0.1
```

![](img/0585614525b65c9ac79e9d08e8328cec.png)![](img/d2eeac7ae15dc68d34fe97072079d4ba.png)![](img/ad6587c9f96d080aa8c431be208efc3e.png)

*系列、新作者和我的评分*

当我运行这个算法时，我注意到，即使我在输入数据时，属于一个系列的书籍主导了结果。这是合乎逻辑的——当有人阅读并喜欢某个系列的第一本书时，他们很可能会去读第二本。如果我也读过第一本书，那些用户更有可能和我匹配。

我注意到一个丛书的模式，其格式通常是:标题，(丛书名，#[1，2，3，等等。]).因此，通过在标题中搜索“#”信号，可以很容易地识别系列中的一本书。它并不完美，但它抓住了大部分。因此，在对该函数的调用中，我添加了一个“Series”选项，如果 toggle 设置为“No ”,该选项会过滤掉所有系列。

同样，早期的推荐大部分来自我已经读过的同一作者——同样，考虑到权重，这是可以理解的。但是，如果我想读一个新的作者呢？这是一个简单的修复方法——在函数调用中加入了一个“仅新作者”开关，这样我就可以控制是否只看到新作者。

最后，在应用了其中一些因素后，我注意到我最推荐的是一个我已经读过但不一定喜欢的系列——我给大多数书打了 3/5 分。因此，为了弥补这一点，我采用了用于推荐的数据，在我自己的书中搜索了每个系列，如果平均评分低于 4，我就从数据集中删除所有实例。

![](img/e51af664c9ce3ad0b8dafb06ee4e7ba8.png)![](img/9f2796e4d2d8b05e212df01482a81116.png)![](img/052a8bbe05a1a44472b8aec63114c1d7.png)

*我想看的书*

我阅读各种类型的书籍——小说、非小说、商业等。—但不代表我评价高的东西都要推荐给我。如果我们有可用的流派信息，我可以指定我想要的推荐的流派类型，但是我们没有，所以我必须做一个变通办法。

出于本练习的目的，我决定创建一个新的专栏，并标记我希望被纳入推荐范围的书籍。只有这些书用于匹配，然后对我读过但不想推荐的其他书进行结果调整。

![](img/4024018698912f32b396bebd358b9189.png)

*定义“相似的”*

我必须和一个用户有多少本相同的书才能被认为是相似的？五个？十个？20?应该包括多少读者？算法的结果根据我们如何定义相似而变化。我选择使用相似读者的第 99 个百分位数，因为数据集是 600+人，他们共同评价了近 75，000 本书。同样，这个百分比可以在函数调用中更改。

*推荐输出*

对以上内容进行分层后，结果是什么？让我们试着调用几个函数:

```
# Default call to the functionbook_recommendation_system(my_books = my_books, all_books = 
                    all_books, ratings = ratings, to_read = to_read,
                    series = 'Yes', new_author_only = 'No', 
                    number_of_similar_quantile = 0.99, 
                    english_only = 'Yes', rec_weight_avg_rating = 
                    0.5, rec_weight_read_ratio = 0.4, 
                    rec_weight_perc_4_5 = 0.1, 
                    rec_weight_perc_1_2 = -0.1, 
                    rec_weight_author_previous = 0.1, 
                    return_dataset = 'No', num_similar_ratings = 50)
```

![](img/a58ef315d36afbfcd226f0df2ac20085.png)

Basic call to the function

![](img/16ce6e0fec879e3859d683d2e46d265d.png)

Test the algorithm for new authors only

![](img/51473101c457589c5bcbefe9ce8048de.png)

Widen the bucket of similar users

![](img/d25efec4bb4410c989df00c1c22b43db.png)

Change the weights and widen the audience plus new authors only

**结论**

![](img/c45f103834fab32856619c313c37c19c.png)![](img/c8d61535dec4e17f3aa37ec0e114ac30.png)![](img/2c296e2889070b6a48c1dda4c5d1bcef.png)

我从这个项目中最大的收获是:

*   协同过滤——或者任何推荐系统——都不能放在盒子里看。在*之上分层的必然*是计算机无法理解的思维和直觉。系统和算法的灵活性远比简单地执行代码以实现程序功能的能力更有价值。我以为这个项目会以协同过滤代码开始和结束。相反，我花了更多的时间来完善这个系统，而不是一开始就创建它。

推荐是推动销售和满意度的一种强有力的方式。也就是说，必须小心谨慎地对待这个话题，因为糟糕的推荐可能会令人沮丧，并阻碍未来的销售。最终，帮助某人发现他们正在寻找或甚至不知道他们可能想要的产品或服务，对所有相关人员来说都是一种胜利，对于数据爱好者来说，这是一个有趣的挑战。