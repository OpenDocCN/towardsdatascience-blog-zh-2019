<html>
<head>
<title>How to build a k-NN in Node.js without TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Node.js 中不用 TensorFlow 建立一个 k-NN</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-k-nn-in-node-js-without-tensorflow-cac5753daa87?source=collection_archive---------23-----------------------#2019-03-11">https://towardsdatascience.com/how-to-build-a-k-nn-in-node-js-without-tensorflow-cac5753daa87?source=collection_archive---------23-----------------------#2019-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fbd089cc322142627c2277f7eab5de3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TS26kg4rT2NHAg8A.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Points connected to each other, Image from <a class="ae kc" href="https://pixabay.com/illustrations/system-web-network-connection-3699542/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="181a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">k-NN 是一个简单直观的基于实例的学习器,当训练数据很大时，它工作得很好。因为模型必须记住训练数据中的所有点，所以它也消耗了相当多的内存。为了在 Node.js 中构建 k-NN，人们首先会想到<a class="ae kc" href="https://www.tensorflow.org/js" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>，这是一个流行的机器学习框架，在 JavaScript 中提供 API。</p><p id="b5d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果你是一个有经验的研究人员，想稍微改变一下模型，看看是否有改进的余地，那该怎么办呢？然后，您将需要进入另一个级别来更改核心架构。如果你是一个初学者，能够从头开始编写模型肯定会提高你的理解能力。</p><h1 id="5130" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让我们开始吧！</h1><p id="3205" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">万一你还没有，你得先安装<a class="ae kc" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Node.js </strong> </a>。Node.js 是一种基于 JavaScript 的服务器端语言，相对容易学习。为了以最佳效率构建 k-NN，您将需要一个 k-d 树。k-d 树允许用分治法在 k 维空间中搜索点。对于设计涉及 k-means 或 LBS 服务等多维数据的系统确实很有用。更多关于 k-d 树的信息可以在<a class="ae kc" href="https://en.wikipedia.org/wiki/K-d_tree" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="ab gu cl mi"><img src="../Images/d8221870e6aecfef5caeadd3aa6a4391.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mXPNeON48dlKFSURIX2Cjw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Visualization of a k-d Tree</figcaption></figure><p id="0b7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从<a class="ae kc" href="https://github.com/ubilabs/kd-tree-javascript" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">这里</strong> </a>下载整个 GitHub 存储库到我们的项目文件夹，为了导入它，我们使用了下面的 JavaScript 代码。</p><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="d420" class="mo lc iq mk b gy mp mq l mr ms">const kdtree = require('./kd-tree-javascript/kdTree');</span></pre><p id="5e26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在为了测试 k-d 树是否有效，我们可以使用下面的代码:</p><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="d2c4" class="mo lc iq mk b gy mp mq l mr ms">const kdtree = require('./kd-tree-javascript/kdTree');<br/>var points = [<br/>  {x: 1, y: 2},<br/>  {x: 3, y: 4},<br/>  {x: 5, y: 6},<br/>  {x: 7, y: 8}<br/>];<br/>var distance = function(a, b){<br/>  return Math.pow(a.x - b.x, 2) +  Math.pow(a.y - b.y, 2);<br/>}<br/>var tree = new kdtree.kdTree(points, distance, ["x", "y"]);<br/>var nearest = tree.nearest({ x: 5, y: 5 }, 2);<br/>console.log(nearest);</span></pre><p id="e44f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码应该打印以下对象:</p><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="269d" class="mo lc iq mk b gy mp mq l mr ms">[ [ { x: 3, y: 4 }, 5 ], [ { x: 5, y: 6 }, 1 ] ]</span></pre><p id="2f7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用下面的代码来构建我们的 k-d 树，其中<strong class="kf ir"> <em class="mt"> x </em> </strong>和<strong class="kf ir"> <em class="mt"> y </em> </strong>是 2 个特征，<strong class="kf ir"> <em class="mt"> train </em> </strong>是训练数据。在距离方程中，要素除以其最大值。这样，计算出的欧几里德距离就不会太偏向于任何一个特征。还有许多其他有趣的方法来计算距离。</p><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="1166" class="mo lc iq mk b gy mp mq l mr ms">const kdtree = require('./kd-tree-javascript/kdTree');<br/>var distance = function(a, b){<br/>  return Math.pow((a.x - b.x)/Xmax, 2) +  Math.pow((a.y - b.y)/Ymax, 2);<br/>}<br/>var tree = new kdtree.kdTree(train, distance, ["x", "y"]);<br/>var k = 5;</span></pre><p id="8064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">训练数据是对象的数组，其中每个对象至少包含 k-d 树内的两个特征。下面是一个如何在 for 循环中构造对象的例子。</p><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="65e1" class="mo lc iq mk b gy mp mq l mr ms">var newObject = {<br/>  label: newLabel,<br/>  x: newX,<br/>  y: newY<br/>}<br/>data.push(newObject)</span></pre><p id="3637" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了拆分训练数据，我们还可以使用以下代码混洗数据，在本例中，80%的数据被混洗到训练数据中。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/574dee1511d0b85bce84b6d6b81ae61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbZ7mIUsftJ9BCs0hJ4LJA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Diagram illustrating how the data is processed</figcaption></figure><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="a16d" class="mo lc iq mk b gy mp mq l mr ms">var shuffledData = shuffle(data);<br/>var train = shuffledData.slice(0, Math.floor(shuffledData.length * 0.8));<br/>var test = shuffledData.slice(Math.floor(shuffledData.length * 0.8) + 1, shuffledData.length);<br/>function shuffle(array) {<br/>  var currentIndex = array.length, temporaryValue, randomIndex;<br/>  // While there remain elements to shuffle...<br/>  while (0 !== currentIndex) {<br/>    // Pick a remaining element...<br/>    randomIndex = Math.floor(Math.random() * currentIndex);<br/>    currentIndex -= 1;<br/>    // And swap it with the current element...<br/>    temporaryValue = array[currentIndex];<br/>    array[currentIndex] = array[randomIndex];<br/>    array[randomIndex] = temporaryValue;<br/>  }<br/>return array;<br/>}</span></pre><p id="a94f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以使用下面的代码来运行我们的模型。</p><pre class="me mf mg mh gt mj mk ml mm aw mn bi"><span id="271f" class="mo lc iq mk b gy mp mq l mr ms">var total = 0;<br/>var correct = 0;<br/>while(test[total] != null)<br/>{<br/> var nearest = tree.nearest(test[total], k);<br/> var label = test[total].label;<br/> var classa = 0;<br/> // Count k nearest points that is labeled as "Class A"<br/> for(i = 0; i &lt; k; i++)<br/> {<br/>  if(nearest[i][0].label == "Class A")<br/>  {<br/>   classa++;<br/>  }<br/> }<br/> // Validate if the actual label matches the majority<br/> if(classa &gt; k - classa &amp;&amp; test[total].label == "Class A")<br/> {<br/>  correct++;<br/> }<br/> else if(classa &lt; k - classa &amp;&amp; test[total].label == "Class B")<br/> {<br/>  correct++<br/> }<br/> else if(classa == k - classa)<br/> {<br/>  // In the case of a tie, evaluate randomly 50%/50%<br/>  if(Math.random() &gt; 0.5 &amp;&amp; test[total].label == "Class A")<br/>  {<br/>   correct++;<br/>  }<br/>  else if(test[total].label == "Class B")<br/>  {<br/>   correct++;<br/>  }<br/> }<br/> total++;<br/>}<br/>console.log("k-NN accuracy: " + correct/total);</span></pre><p id="2366" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该代码主要针对测试集运行 k-NN 算法，并对成功分类的实例进行计数。如果该实例周围的 k 个点的大多数被标记为该类，则该实例被分类为该类之一。在出现平局的情况下，算法会将其随机放入其中一个类中。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/99eb32c6d1a835cc3d7f4aece4002efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*xn6LPYORV2SJK3kPfb7XUw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">k-NN Illustrated, Image from <a class="ae kc" rel="noopener" target="_blank" href="/knn-k-nearest-neighbors-1-a4707b24bd1d">Medium</a></figcaption></figure><p id="d53a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！您刚刚学习了如何从零开始构建 k-NN！现在由您来深入研究这个模型！</p><h1 id="1644" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后…</h1><p id="748f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我对许多事情都充满热情，数据科学就是其中之一。在 Unity 机器学习框架准备好之前，我还从头开始构建了一个 BPANN。我当时唯一能找到的人工神经网络是用遗传算法来训练的。我没有把它写成一篇文章，但是我可以根据要求来写。</p><p id="7cf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我喜欢学习新的东西，并与社区分享，如果有你特别感兴趣的主题，请让我知道，我可能会写它。我目前正在写一篇长文，详细解释 AlphaGo 是如何工作的，我需要一些时间来完成。</p><p id="03f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">敬请关注，享受数据科学的乐趣！</p></div></div>    
</body>
</html>