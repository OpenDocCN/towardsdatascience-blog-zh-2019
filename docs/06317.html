<html>
<head>
<title>Survival Modeling — Accelerated Failure Time — XGBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生存建模—加速故障时间— XGBoost</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/survival-modeling-accelerated-failure-time-xgboost-971aaa1ba794?source=collection_archive---------17-----------------------#2019-09-11">https://towardsdatascience.com/survival-modeling-accelerated-failure-time-xgboost-971aaa1ba794?source=collection_archive---------17-----------------------#2019-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="771c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">简介</strong></h1><p id="64ed" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">生存分析是一个“<strong class="kq iu">删失回归</strong>”，其目标是学习事件时间函数。这类似于数据点未经审查的普通回归分析。生存建模没有<strong class="kq iu">回归</strong>和<strong class="kq iu">分类</strong>那么有名。因此，我将用例子更详细地解释它。这是一个有数据审查的建模任务。删失数据是指在研究期间感兴趣的事件没有发生，或者由于某些原因我们无法观察到感兴趣的事件的数据。</p><p id="b605" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">审查类型和实例</strong></p><p id="eb93" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">左侧审查</strong>发生在我们开始研究/活动时，并且该事件已经发生，导致更高的<strong class="kq iu">示例</strong> —我们希望研究给定报价的用户购买新 iPhone 的情况，但一些用户可能已经购买，丢弃这些数据是没有用的。</p><p id="5ccb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">区间删截</strong>用于当我们不知道事件的确切时间，并且它可能在两个时间区间之间发生时。例如，用户购买保险，但不确定购买的确切日期。</p><p id="9271" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">右删截</strong>用于研究期间未发生的事件。示例—癌症患者接受的治疗。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/dfd5759daad884bdb1df6ffe827b712a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3lbo8tbgtklE7V-m4EsvQ.jpeg"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Censored Data-Types</figcaption></figure><p id="ecbc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">事件时间建模对于理解用户/公司的行为至关重要，不仅限于信贷、癌症和流失风险。</p><p id="9ff5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Cox 比例风险模型是一个半参数模型，其中我们使用预测器对<strong class="kq iu">风险比</strong>进行建模，而在加速故障时间<strong class="kq iu">中，使用预测器对生存时间</strong>的日志进行建模。这是参数生存模型，因为我们假设响应数据的分布。</p><p id="076e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面是生存模型的流程图-</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/b9e95e57409b12fde231a7aa9b24d21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8N3epraxaPHFk4O-7nC4w.jpeg"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Flow Chart — Survival Machine Learning</figcaption></figure><h1 id="920b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">最新技术水平</strong></h1><p id="99c4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">基于树的模型改进了监督学习，在 Kaggle 上获得了许多奖项，在行业中也表现得更好。我们在 R 和 python 中实现了梯度推进模型，用于 Cox 比例风险函数和加速故障时间。为生存建模开发更多的基于树的模型也是很自然的。比如— GBM，mboost，Scikit-survival 等等。目前，XGBoost 支持没有基线预测的 Cox-Ph 模型。因此，我们在 Xgboost 中包含了加速故障时间，以提高生存建模支持。</p><h1 id="dbce" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">数据类型支持</strong></h1><p id="de08" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">大多数生存模型只支持正确的删失数据类型。我们通常有 4 种类型的数据— <strong class="kq iu">右数据、左数据、区间数据和未经审查的数据</strong>。右删失是最常用的删失数据类型。了解其他审查类型也很重要。</p><h1 id="433d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">分布类型支持</strong></h1><p id="1505" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">加速故障时间建模是参数生存建模，其中生存时间遵循一定的分布，不同于 Cox 比例风险模型。我们支持 3 种类型的分布——正态分布、逻辑分布和极端分布。正态分布是最常见的分布类型，但它有一个细尾，在厚尾事件或极端事件的情况下，这可能不是正确的选择。</p><p id="cfa7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">还不如形象化一点。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><pre class="ls lt lu lv gt mo mp mq mr aw ms bi"><span id="bdd7" class="mt jr it mp b gy mu mv l mw mx">import numpy as np<br/>import seaborn as sns</span><span id="d317" class="mt jr it mp b gy my mv l mw mx">sns.distplot(np.random.normal(0,1,200),hist=False,label=”Normal”)<br/>sns.distplot(np.random.logistic(0,1,200),hist=False,label=”Logistic”)<br/>sns.distplot(np.random.gumbel(0,1,200),hist=False,label=”Extreme”)</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mz"><img src="../Images/0cbb6ecb10328ed262a10fb00e240b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*nFjtWO2rxKrS1cnr779k8w.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Distributions-Density</figcaption></figure><p id="d072" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当数据有厚尾时，逻辑/极端会导致更好的结果。</p><p id="1b3a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">超参数调谐</strong></p><p id="f2ab" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">超参数优化是机器学习的重要任务之一。我们将响应的误差(\sigma)和基本分数作为超参数。有许多方法可以找到最佳超参数。</p><p id="210a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">网格搜索就是其中之一。我们已经使用 GridSearch 找到了最佳的超参数。</p><p id="1c36" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于区间删失数据集，我们也可以从σ等于 y 较低σ和 y 较高σ的平均值开始，因此对于不同的删失数据集，基础分数等于 y 较低和 y 较高σ的平均值。</p><h1 id="9edf" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">真实例子</strong></h1><p id="1983" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们使用了可用的芯片序列数据集<a class="ae na" href="https://github.com/tdhock/neuroblastoma-data" rel="noopener ugc nofollow" target="_blank"/>。它有多个数据集。数据集的输出/响应是对数变换的。我们将使用 5 个数据集——<a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/tree/master/AFT/test/data/neuroblastoma-data-master/data/ATAC_JV_adipose" rel="noopener ugc nofollow" target="_blank">ATAC _ JV _ 脂肪</a>、<a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/tree/master/AFT/test/data/neuroblastoma-data-master/data/CTCF_TDH_ENCODE" rel="noopener ugc nofollow" target="_blank">CTCF _ TDH _ 编码</a>、<a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/tree/master/AFT/test/data/neuroblastoma-data-master/data/H3K27ac-H3K4me3_TDHAM_BP" rel="noopener ugc nofollow" target="_blank">h3k 27 AC-h3k 4 me 3 _ TD ham _ BP</a>、<a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/tree/master/AFT/test/data/neuroblastoma-data-master/data/H3K27ac_TDH_some" rel="noopener ugc nofollow" target="_blank"> H3K27ac_TDH_some </a>和<a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/tree/master/AFT/test/data/neuroblastoma-data-master/data/H3K36me3_AM_immune" rel="noopener ugc nofollow" target="_blank"> H3K36me3_AM_immune </a>。在所有数据集中，都已经定义了褶皱。</p><p id="09d6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">基础分数</strong>和<strong class="kq iu">适马</strong>是关键的超参数。</p><p id="ed74" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面是用<strong class="kq iu"> </strong>不同分布和<strong class="kq iu"> sigma 生成<strong class="kq iu">加速失效时间</strong>性能的代码。</strong></p><p id="86fc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/blob/master/AFT/R/aft_doc.Rmd" rel="noopener ugc nofollow" target="_blank"> R 代码</a></p><div class="ls lt lu lv gt ab cb"><figure class="nb lw nc nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><img src="../Images/4e6b930ff4b0edaee2548c03176337b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*xKEjGf8JBtGZ5JyOSRCZ7w.png"/></div></figure><figure class="nb lw nc nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><img src="../Images/400b0d298e94542e5b5875ae26ae9331.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*PYLAm8HkF39xBltTgHWYcw.png"/></div></figure><figure class="nb lw nc nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><img src="../Images/260a261264b9d56aa04a2b482e517537.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*U40kKl7wqVu5zEUVVeLreg.png"/></div></figure></div><h1 id="45e6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">结论</strong></h1><p id="2584" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">参数删失回归——加速失效时间是 Cox 比例风险模型的一个强有力的替代方案。我们需要在不同的基于树的模型中对上述模型提供更多的支持，比如 gradient boosting、XGBoost 和 LightGBM。我们现在已经在 XGBoost 中实现了。大多数数据集是平坦的，而改变 sigma 意味着我们可能需要更多的迭代。正常情况下，西格玛起着至关重要的作用，因为当西格玛增加时，它会被奉承。</p><p id="9724" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">超参数调整在这里是一个重要的方面，因为我们可能会发现没有训练/测试损失的移动。很快 XGBoost 包中的所有人都可以使用它。</p><h1 id="3409" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">参考文献</strong></h1><p id="ada0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[1] <a class="ae na" href="https://github.com/rstats-gsoc/gsoc2019/wiki/xgboost-loss-functions" rel="noopener ugc nofollow" target="_blank">项目描述</a></p><p id="1e90" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">[2] <a class="ae na" href="https://github.com/dmlc/xgboost/pull/4763" rel="noopener ugc nofollow" target="_blank">更多细节</a></p><p id="a206" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae na" href="https://github.com/avinashbarnwal/GSOC-2019/blob/master/doc/Accelerated_Failure_Time.pdf" rel="noopener ugc nofollow" target="_blank">推导</a></p><p id="9656" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">P.S. —我们已经将与此相关的论文提交给<a class="ae na" href="https://nips.cc/" rel="noopener ugc nofollow" target="_blank"> NeurIPS </a> — 2020，论文的 Arxiv 版本在这里—<a class="ae na" href="https://arxiv.org/abs/2006.04920" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2006.04920</a>。</p></div></div>    
</body>
</html>