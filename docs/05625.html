<html>
<head>
<title>Converting a Deep Learning Model with Multiple Outputs from PyTorch to TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将具有多个输出的深度学习模型从 PyTorch 转换为 TensorFlow</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/converting-a-deep-learning-model-with-multiple-outputs-from-pytorch-to-tensorflow-a2d27a8e44f4?source=collection_archive---------10-----------------------#2019-08-18">https://towardsdatascience.com/converting-a-deep-learning-model-with-multiple-outputs-from-pytorch-to-tensorflow-a2d27a8e44f4?source=collection_archive---------10-----------------------#2019-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f2e8261260b47f08a1277e754cc1e9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2e1yZyThky_exbt-fld49w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Reference: <a class="ae kf" href="https://i.stack.imgur.com/4YBht.jpg" rel="noopener ugc nofollow" target="_blank">https://i.stack.imgur.com/4YBht.jpg</a></figcaption></figure><p id="f579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">简介</strong></p><p id="536d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前段时间，我写了一篇<a class="ae kf" rel="noopener" target="_blank" href="/converting-a-simple-deep-learning-model-from-pytorch-to-tensorflow-b6b353351f5d">文章</a>，描述了如何使用 ONNX 将一个简单的深度学习模型从 PyTorch 转换为 TensorFlow。虽然这适用于许多用例，但在某些情况下，您需要转换具有多个输出的模型(例如，对象检测模型)。在这里，我将展示如何将一个具有多个输出的模型从 PyTorch 转换为 TensorFlow。</p><p id="4c46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整个转换过程的许多部分重复了我在上一篇文章中提到的内容，所以我将只提到为转换一个具有多个输出的模型而添加或修改的部分。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="ee32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">生成和准备数据</strong></p><p id="a8d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据的主要区别在于现在有两组不同的实际输出，一组是连续变量，另一组是二进制形式。此外，我定义了两个函数来为数据生成两种不同类型的输出。下面的代码片段说明了生成数据并为模型训练和评估做准备的过程。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="6eee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">定义、培训和评估示例模型</strong></p><p id="d6a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所定义的模型类与上一篇文章中的非常相似，除了<em class="lr"> forward() </em>方法返回两个输出张量，而不是一个。还为输出定义了两种不同的损失对象，连续输出的均方误差损失和二进制输出的二进制交叉熵损失。下面的代码片段显示了模型、损失和优化器是如何定义的。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="eb24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">训练和评估过程也是类似的，除了在执行反向传播和模型权重更新之前，必须计算两个输出的损失并将其相加。下面的代码片段包含了训练和评估模型的过程。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b5fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">将模型转换为张量流</strong></p><p id="cab0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将模型导出到<em class="lr">。onnx </em>格式也很相似，只是应该给输出头分配不同的名称。在本例中，名称“output1”和“output2”被分配给两个输出头，如下面的代码片段所示。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="34f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">在 TensorFlow 中做推理</strong></p><p id="f5db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TensorFlow 中的推理步骤也与上一篇文章类似，只是做了一些小的改动，得到了两个输出，而不是一个，如下所示。输入和输出的占位符名称可以用我在<a class="ae kf" rel="noopener" target="_blank" href="/converting-a-simple-deep-learning-model-from-pytorch-to-tensorflow-b6b353351f5d">上一篇文章</a>中提到的相同方法找到。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="3540" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切顺利，<em class="lr"> print('output1:'，output1) </em>和<em class="lr"> print('output2:'，output2) </em>的结果应该与前面步骤中<em class="lr"> print('dummy_output_1:'，dummy_output_1) </em>和<em class="lr"> print('dummy_output_1:'，dummy_output_1) </em>的结果相匹配。</p><p id="6eea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">结论</strong></p><p id="824a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将具有多个输出的模型从 PyTorch 转换到 TensorFlow 可能比对具有单个输出的简单模型执行相同的过程更具挑战性，但仍然可以完成。我希望这篇文章能让您对使用 ONNX 转换更复杂的模型更有信心。</p><p id="f23b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">包含所有代码的 Jupyter 笔记本可以在这里找到<a class="ae kf" href="https://github.com/yxlee245/pytorch2tf/blob/master/PyTorch2TF_Multiple_Output.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>