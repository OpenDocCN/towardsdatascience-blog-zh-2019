<html>
<head>
<title>Artificial Intelligence Made Easy with H2O.ai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">H2O.ai 让人工智能变得简单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/artificial-intelligence-made-easy-187ecb90c299?source=collection_archive---------7-----------------------#2019-06-12">https://towardsdatascience.com/artificial-intelligence-made-easy-187ecb90c299?source=collection_archive---------7-----------------------#2019-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/469d23f1434fa461ef5e46e9c01d3f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSDIm8k315XGjxZ9gqnhvA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo Source: ShutterStock</figcaption></figure><div class=""/><div class=""><h2 id="4bce" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">Python 中使用 H2O.ai 和 AutoML 建模的综合指南</h2></div><p id="8895" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">伊桑·戴伊&amp;爱丽斯·李</p><p id="e105" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">如果</span>你和我爸爸一样，你已经在 IT 行业工作了几十年，但对数据科学却只是一知半解。现在，你的新 C-something-O 希望你组建一个数据分析团队，并使用一套你在会议上只是模糊听说过的新术语。或者，您可能是一家快速发展的初创公司的开发人员，已经花了数周时间完成了一个算法，却被将模型部署到 web 应用程序以供实时使用的问题所困扰。对于这两种情况，H2O.ai 绝对是一个值得研究的解决方案。</p><h2 id="a3bb" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">为什么是 H2O.ai？</h2><p id="c4e6" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">H2O.ai 将自己定位为一个软件包，通过其开源包 H2O 和 AutoML 来简化机器学习过程。虽然像 H2O 无人驾驶人工智能这样的产品允许最终用户在没有一行代码的情况下完全自动化这个过程，但大多数用户(像我一样)希望他们的模型开发至少有一定程度的可定制性。</p><p id="368f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">H2O.ai 在这里大放异彩有几个原因:</p><ul class=""><li id="e25b" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated">它将开发过程简化为一个<em class="lt">直观的工作流程</em>，</li><li id="ded0" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">训练模型<em class="lt">比 sci-kit learn 等流行的软件包</em>更快，并且</li><li id="fc75" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">使用 Java 对象使得将一个模型转移到产品中变得简单多了</li></ul><p id="70e6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">简而言之，H2O 无疑为大型数据集提供了一个快速且可访问的机器学习平台，该平台配备了用户友好的高性能工具。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/d57f8256812208ac3562483cd34ef865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ydw1OgN4xiKDbHNEw8XJXQ.png"/></div></div></figure><h2 id="1125" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">概观</h2><ul class=""><li id="a938" class="nb nc ji kz b la mw ld mx lg nu lk nv lo nw ls ng nh ni nj bi translated">入门指南</li><li id="eb1b" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">构建独立模型</li><li id="d2e9" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">使用 AutoML 寻找最佳模型</li><li id="a84d" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">模型部署</li></ul><p id="be19" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">好消息是，Python 中的大部分 H2O 与您可能熟悉的 sci-kit 学习函数很相似。H2O 的数据结构与熊猫非常相似，指定、拟合和评估模型的工作流程也很相似。使用来自 UCI 知识库的金融信用数据集，我们将使用 H2O.ai 来预测个人在下一次付款中违约的概率。</p><p id="75b0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">注意</em>:如果你只对 AutoML 部分感兴趣，跳过“构建一个 Hello，World！“模型”一节，它深入到开发单个模型的本质。您可以回到那里，将它以及提供的 H2O 文档链接更多地用作参考指南。</p><p id="703f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您可以使用帖子中的代码片段或下面链接的交互式 Python 笔记本来跟进。</p><blockquote class="nx ny nz"><p id="b7ce" class="kx ky lt kz b la lb kj lc ld le km lf oa lh li lj ob ll lm ln oc lp lq lr ls im bi translated">GitHub:<a class="ae od" href="https://github.com/elyselee/H2O-Walkthrough/blob/master/H2O%20Walkthrough.ipynb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/elyselee/H2O-walk through/blob/master/H2O % 20 walk through . ipynb</a></p></blockquote><h1 id="ca98" class="oe me ji bd mf of og oh mi oi oj ok ml ko ol kp mo kr om ks mr ku on kv mu oo bi translated">H2O Python 入门</h1><h2 id="79a4" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">设置相关性</h2><p id="61c7" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">尽管我希望我可以说实现就像抛出另一个 pip install 命令一样简单，但实际上要复杂得多。</p><p id="732e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，到 H2O 稳定链接<a class="ae od" href="https://h2o-release.s3.amazonaws.com/h2o/master/4698/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>，下载包含最新版本的 zip 文件。按照下面的命令完成软件包的安装。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="a474" class="md me ji oq b gy ou ov l ow ox">cd ~/Downloads<br/>unzip h2o-3.25.0.4698.zip<br/>cd h2o-3.25.0.4698<br/>java -jar h2o.jar</span></pre><p id="0f32" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">截至撰写本文时(2019 年 6 月)，H2O 仅支持 Java SE 运行时环境版本 8–11。您可以使用<code class="fe oy oz pa oq b">java -version</code>命令检查您的版本。如果你有 Java SDK 12，你必须卸载并降级到 Java SDK 11 以保持与 H2O 的兼容性。为此，在终端中执行以下命令:<code class="fe oy oz pa oq b">/usr/libexec/java_home -V</code>。复制它返回的路径名，并使用下面的命令卸载:<code class="fe oy oz pa oq b">sudo rm -rf pathname</code>。前往<a class="ae od" href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" rel="noopener ugc nofollow" target="_blank">甲骨文 JDK 11 下载网站</a>，创建一个帐户，并按照那里的说明进行安装。</p><p id="dd65" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在您已经安装了必备包，打开您的 Python 脚本并执行下面的代码。<code class="fe oy oz pa oq b">nthreads</code>参数简单地控制执行操作的内核数量，而<code class="fe oy oz pa oq b">-1</code>为 H2O 分配最大数量的可用内核。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="1dbd" class="md me ji oq b gy ou ov l ow ox">import h2o</span><span id="889e" class="md me ji oq b gy pb ov l ow ox">h2o.init(nthreads = -1, max_mem_size = 8)<br/>h2o.connect()</span></pre><h2 id="d6b6" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">数据预处理</h2><p id="2d2f" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">如果你用 Python 做数据科学，使用熊猫数据框架。如果您正在从头开始编写算法并使用 NumPy 数组，那很好。但是如果你认为 H2OFrames 是值得学习的东西，我会为你节省很多时间和麻烦:它不是。</p><p id="60d7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">公平地说，H2O 跑得比 sci-kit learn 模型快得多的原因之一是 H2O 为熊猫提供了更高效的数据结构。但是对于特征工程，我们建议坚持使用传统的数据帧，然后在准备好导入时转换成 h2of 帧。因为这毕竟是一个 H2O 教程，我们的处理技术将使用 H2OFrames 来完成。H2O 也有很好的数据操作参考指南。</p><p id="493a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，我们将使用<code class="fe oy oz pa oq b">h2o.import_file() </code>函数导入<a class="ae od" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00350/default%20of%20credit%20card%20clients.xls" rel="noopener ugc nofollow" target="_blank"> UCI 信用卡数据集</a>。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="7723" class="md me ji oq b gy ou ov l ow ox">df = h2o.import_file(‘uci_creditheader.csv’)</span></pre><p id="d99a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">H2OFrames 的许多功能与 Pandas DataFrame 的功能是同源的。例如，我们可以使用<code class="fe oy oz pa oq b">.columns</code>属性检查列，该属性返回一个特性名称列表(不是 NumPy 数组)。我们可以使用<code class="fe oy oz pa oq b">drop()</code>功能删除不必要的特征(不需要轴规格)。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="6756" class="md me ji oq b gy ou ov l ow ox">df = df.drop(‘ID’)<br/>df.columns</span></pre><p id="587d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在下面的代码中，我们将创建一个特性列名<code class="fe oy oz pa oq b">x</code>和目标变量名<code class="fe oy oz pa oq b">y</code>的列表。这种格式允许我们向训练和预测函数传递更少的数据结构(sklearn 要求 X_train 和 y_train)，从而显著提高运行时。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="725a" class="md me ji oq b gy ou ov l ow ox">y = ‘default payment next month’<br/>x = list(df.columns).remove(y)</span></pre><p id="8e65" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当我们谈到这个话题时，需要注意的是，H2O 将根据<code class="fe oy oz pa oq b">y</code>变量的数据类型自动假设一个回归或分类模型。使用<code class="fe oy oz pa oq b">df[y].type</code>属性的快速检查显示我们的值是整数(1 表示贷款违约，0 表示其他情况)。然后，我们可以使用<code class="fe oy oz pa oq b">as_factor()</code>函数将该列转换为因子类型。</p><p id="dd09" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe oy oz pa oq b">df[y] = df[y].as_factor()</code></p><p id="89ed" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了创建训练和测试集，我们将使用 H2O <code class="fe oy oz pa oq b">split_frame() </code>函数，而不是使用 sklearn <code class="fe oy oz pa oq b">train_test_split()</code>函数。为此，我们需要传递训练集和验证集大小的分数列表(测试集大小是隐式计算的)。该函数返回一个列表，第一个元素引用定型集，第二个元素对应于验证集，第三个元素是测试集。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="04f9" class="md me ji oq b gy ou ov l ow ox">splits = df.split_frame(ratios=[0.7, 0.15], seed=1)</span><span id="bd50" class="md me ji oq b gy pb ov l ow ox">train = splits[0]<br/>valid = splits[1]<br/>test = splits[2]</span></pre><p id="b5f3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们还可以使用<code class="fe oy oz pa oq b">.nrow</code>属性检查每个集合的大小。请注意，这些集合中的每一个都包含 X 变量特性和 y 目标，这与我们在 sklearn 中完成的过程不同。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="71bf" class="md me ji oq b gy ou ov l ow ox">print(train.nrow)<br/>print(valid.nrow)<br/>print(test.nrow)</span></pre><h1 id="f9e3" class="oe me ji bd mf of og oh mi oi oj ok ml ko ol kp mo kr om ks mr ku on kv mu oo bi translated">构建一个“你好，世界！”模型</h1><h2 id="8b22" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">模型构建</h2><p id="c13b" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">我们将使用随机森林估计器对我们的模型进行分类，您将再次注意到与 sci-kit learn 的相似之处。使用<code class="fe oy oz pa oq b">H2ORandomForestEstimator()</code>函数，我们实例化将用于分类(或回归，如果我们有一个整数或浮点响应变量)的模型。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="40c8" class="md me ji oq b gy ou ov l ow ox">from h2o.estimators.random_forest import H2ORandomForestEstimator</span><span id="f5cb" class="md me ji oq b gy pb ov l ow ox">rf = H2ORandomForestEstimator(seed=1)</span></pre><ul class=""><li id="957b" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">seed</code>:该参数与其他模块中的<code class="fe oy oz pa oq b">random_state</code>类似，只是控制创建模型时使用的随机数。这对于使用外部数据集进行模型验证时的再现性非常重要。</li><li id="1e09" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated">还有一些其他特定于每个型号的参数，如<code class="fe oy oz pa oq b">ntrees</code>或<code class="fe oy oz pa oq b">min_split_improvement</code>，可以指定。为了找出你所选择的模型算法，查看一下 H2O 的文档。</li></ul><h2 id="11d5" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">拟合和预测结果</h2><p id="2998" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">为了使我们的模型适合数据，我们必须至少传递三个参数:<code class="fe oy oz pa oq b">training_frame</code>、<code class="fe oy oz pa oq b">y</code>列和<code class="fe oy oz pa oq b">x</code>列。但是，如果<code class="fe oy oz pa oq b">x</code>参数为空，h2o 将假设在拟合时使用除<code class="fe oy oz pa oq b">y</code>列之外的所有列。下面是一些其他参数，您可能希望在下面的片段中没有包括的数据中使用。同样，完整的列表可以在文档<a class="ae od" href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science.html#supervised" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="80f6" class="md me ji oq b gy ou ov l ow ox">rf.train(x=x, y=y, training_frame=train)</span></pre><ul class=""><li id="c22d" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">nfolds</code>:用于交叉验证的折叠数。关于这方面的更多信息，请查看交叉验证的<a class="ae od" href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/cross-validation.html" rel="noopener ugc nofollow" target="_blank"> H2O 解释</a>。</li><li id="2060" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">balance_classes</code>:当我们的目标特征中存在类别不平衡时，我们可能希望对数据进行重新采样，在创建新分布时，通过对少数类别进行过采样或对多数类别进行欠采样。如果我们将这个参数设置为<code class="fe oy oz pa oq b">True</code>，我们也可以指定一个<code class="fe oy oz pa oq b">class_sampling_factors</code>参数，并传递一个比率列表来确定最终的分布。</li><li id="9d41" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">ignored_columns</code>:如果我们在拟合时不希望包含某些列，但这些列有助于比较预测值，如观察 ID，我们可以使用此参数指定。</li><li id="bb1b" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">categorical_encoding</code>:在 sklearn 中，我们在预处理阶段使用单独的函数处理分类变量，而 H2O 可以使用一个热编码或标签编码等技术处理每一列。简要说明:要将需要处理的列标记为分类列，请事先使用<code class="fe oy oz pa oq b">.as_factor()</code>函数来更改训练集和测试集中的数据类型。可以在<a class="ae od" href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/algo-params/categorical_encoding.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到<code class="fe oy oz pa oq b">categorical_encoding</code>选项的完整列表。</li></ul><p id="5086" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">预测</strong></p><p id="69c1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">返回每个类的预测概率非常简单，可以使用<code class="fe oy oz pa oq b">predict()</code>函数来完成。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="55c4" class="md me ji oq b gy ou ov l ow ox">y_hat = rf.predict(test_data=test)</span></pre><p id="bd1a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">进一步检查 y_hat，我们看到<code class="fe oy oz pa oq b">predict()</code>为每个观察值返回了三列:<code class="fe oy oz pa oq b">p0</code>，观察值属于 0 类的概率；<code class="fe oy oz pa oq b">p1</code>，观察值属于第 1 类的概率；和<code class="fe oy oz pa oq b">predict</code>，预测分类标签。这里，分类标签的判定边界(阈值)被假设为 0.5，因此任何大于 0.5 的<code class="fe oy oz pa oq b">p1</code>值将对应于为 1 的<code class="fe oy oz pa oq b">predict</code>标签。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/1f7b6f75d8fb5e53ecddb3c9bc364348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzXb1I8OSMrYpfg0weHAOQ.png"/></div></div></figure><h2 id="1386" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">性能赋值</h2><p id="fffe" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">真正理解模型评估的基础对于决策者最终决定一个模型是否适合部署和用户交互是至关重要的。我已经在这里写了一篇关于二进制分类的度量的文章<a class="ae od" href="https://medium.com/@ishaandey/hackcvilleds-4636c6c1ba53" rel="noopener">如果你不熟悉这个主题或者需要复习一下。</a></p><p id="36f5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了检索关于我们的模型表现如何的报告，我们可以使用<code class="fe oy oz pa oq b">model_performance()</code>函数，并将结果打印到控制台。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="25c6" class="md me ji oq b gy ou ov l ow ox">rf_performance = rf.model_performance(test)<br/>print(rf_performance)</span></pre><p id="b034" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">输出有几个部分。首先，我们看到一个标题，它指定了报告什么类型的指标<code class="fe oy oz pa oq b">ModelMetricsBinomial</code>，以及模型类型<code class="fe oy oz pa oq b">drf</code>。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="b039" class="md me ji oq b gy ou ov l ow ox">ModelMetricsBinomial: drf<br/>** Reported on train data. **</span><span id="5ff5" class="md me ji oq b gy pb ov l ow ox">MSE: 0.14036700152537882<br/>RMSE: 0.3746558441094691<br/>LogLoss: 0.45587629761245807<br/>Mean Per-Class Error: 0.30286812164834764<br/>AUC: 0.7576361236577988<br/>pr_auc: 0.5240926163909475<br/>Gini: 0.5152722473155975</span></pre><p id="ce70" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们还会收到一个混淆矩阵，纵轴是实际标签，横轴是预测标签。<em class="lt">注意</em>:混淆矩阵的值在最大化 F1 分数的阈值(概率截止值)处报告，而不是 0.5。我们这里的输出确定为 0.312。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/cff11e915dfa51ad063f24a6cfbb4235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CoPa3zLan9ycK34N13kqvA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Confusion Matrix Calculated at Threshold that Maximizes F1 Score</figcaption></figure><p id="e1e3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">H2O 输出的酷之处在于，它会自动计算每个阈值处的每个指标，然后报告最大指标<code class="fe oy oz pa oq b">value</code>以及达到该指标的<code class="fe oy oz pa oq b">threshold</code>。同样，如果这里使用的词汇对你毫无意义，我强烈推荐阅读<a class="ae od" rel="noopener" target="_blank" href="/hackcvilleds-4636c6c1ba53">这篇解释评估指标的文章</a>。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/2cc1ac5b5a4d82e2eba520a5bc4bb734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIfQkWa0-HDCYmksrBwkKQ.png"/></div></div></figure><p id="8195" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个组件对于理解模型是否真的完成了我们所需要的是至关重要的。想象一下，我们正在开发一个检测疾病的模型。<code class="fe oy oz pa oq b">Specificity</code>指我们正确预测的实际疾病病例的比例。我们宁愿最大限度地提高特异性，而不是精确性，原因很简单，因为没有检测到真正的患病患者和放弃早期干预的成本远比虚惊一场更糟糕。</p><p id="2372" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">顺便说一下，我们可以通过调用 H2OModelMetrics 对象的度量函数来返回特定的度量。要查看可以调用的指标的完整列表，请在键入 H2OModelMetrics 对象名称后点击<em class="lt">选项卡</em>，并从下拉列表中选择一个选项(然后添加<code class="fe oy oz pa oq b">()</code>以返回感兴趣的指标)。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="ec2a" class="md me ji oq b gy ou ov l ow ox">rf_performance<strong class="oq jj">.</strong>auc()<br/>rf_performance.confusion_matrix()</span></pre><p id="0b95" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">参考链接</strong>:</p><blockquote class="nx ny nz"><p id="809b" class="kx ky lt kz b la lb kj lc ld le km lf oa lh li lj ob ll lm ln oc lp lq lr ls im bi translated"><em class="ji">指标指南【https://towardsdatascience.com/hackcvilleds-4636c6c1ba53 T21】:<a class="ae od" rel="noopener" target="_blank" href="/hackcvilleds-4636c6c1ba53"/></em></p></blockquote><h2 id="62a6" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">其他型号的快速备忘单:</h2><p id="8edc" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated"><strong class="kz jj">深度学习(DL) </strong>:由分层神经元组成的人工神经网络，每个连续的模型层都通过聚合对前一层进行改进。要了解更多关于这种工作方式的背景，请查看我们关于深度学习的文章。</p><ul class=""><li id="b5b4" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">epochs</code>:流式传输数据集的次数。</li><li id="d0b6" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">L1</code>:添加 L1 正则化，通过将多个权重值设置为 0 来提高泛化能力和稳定性</li><li id="83ce" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">L2</code>:添加 L2 正则化，通过降低许多权重值来提高泛化能力和稳定性</li><li id="1a34" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">adaptive_rate</code>:学习率手动调谐默认开启</li><li id="5d46" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">loss</code>:指定损失函数，选项:<code class="fe oy oz pa oq b">Automatic</code>(默认)、<code class="fe oy oz pa oq b">Absolute</code>、<code class="fe oy oz pa oq b">Quadratic</code>、<code class="fe oy oz pa oq b">Huber</code>、<code class="fe oy oz pa oq b">CrossEntropy</code></li></ul><p id="3254" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">分布式随机森林(DRF)</strong>:DRF 用数据集创建一个回归或分类树森林。</p><ul class=""><li id="467a" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">ntrees</code>:树的数量</li><li id="c889" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">max_depth</code>:最大树深</li><li id="7ee9" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">sample_rate</code>:行采样率从 0 到 1(默认为 1)</li><li id="03f7" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">col_sample_rate_per_tree</code>:每棵树的列采样率从 0 到 1</li></ul><p id="1447" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">广义线性模型(GLM): </strong>一种线性回归，具有灵活的泛化能力，用于处理非线性。</p><ul class=""><li id="efcf" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">Solver</code>:要使用的求解算法:<code class="fe oy oz pa oq b">auto</code>、<code class="fe oy oz pa oq b">l_bfgs</code>、<code class="fe oy oz pa oq b">irlsm</code>、<code class="fe oy oz pa oq b">coordinate_descent</code>、<code class="fe oy oz pa oq b">coordinate_descent_naive</code>、<code class="fe oy oz pa oq b">gradient_descent_lh</code>或<code class="fe oy oz pa oq b">gradient_descent_sqerr</code>。</li><li id="9f4f" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">Lambda</code>:正规化强度</li><li id="344b" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">Alpha</code>:L1 和 L2 之间的规则化分配</li></ul><p id="884f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">梯度推进机器(GBM) </strong>:通过连续细化使用弱决策树的集合(模型集合)</p><ul class=""><li id="fd16" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">ntrees</code>:集合的树数</li><li id="1074" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">learn_rate</code>:学习率，范围从 0 到 1</li><li id="0589" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">sample_rate</code>:行采样率从 0 到 1(默认为 1)</li><li id="0a8d" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">col_sample_rate</code>:列采样率，范围从 0 到 1。</li></ul><p id="b64c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">朴素贝叶斯分类器</strong>:基于应用贝叶斯定理的强特征独立性假设的分类算法</p><ul class=""><li id="502d" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">max_hit_ratio_k</code>:命中率计算的最大预测数</li><li id="53cf" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">min_prob</code>:用于观察的最小概率</li><li id="0737" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">eps_prob</code>:低于被 min_prob 替换的概率的截止值</li></ul><p id="6bdc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">参考链接</strong>:</p><blockquote class="nx ny nz"><p id="823b" class="kx ky lt kz b la lb kj lc ld le km lf oa lh li lj ob ll lm ln oc lp lq lr ls im bi translated">模型估计器文档:<a class="ae od" href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science.html#supervised" rel="noopener ugc nofollow" target="_blank">http://docs . H2O . ai/H2O/latest-stable/H2O-docs/data-science . html # supervised</a></p><p id="4c5e" class="kx ky lt kz b la lb kj lc ld le km lf oa lh li lj ob ll lm ln oc lp lq lr ls im bi translated">参数文档:<a class="ae od" href="http://h2o-release.s3.amazonaws.com/h2o-dev/rel-shackleford/5/docs-website/h2o-py/docs/h2o.html" rel="noopener ugc nofollow" target="_blank">http://H2O-release . S3 . Amazon AWS . com/H2O-dev/rel-shackle Ford/5/docs-website/H2O-py/docs/H2O . html</a></p></blockquote><h1 id="db76" class="oe me ji bd mf of og oh mi oi oj ok ml ko ol kp mo kr om ks mr ku on kv mu oo bi translated">AutoML:优化变得简单</h1><p id="4b74" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">正如您现在可能已经看到的，选择最佳预测模型可能是复杂且耗时的。您不仅需要确定最佳模型，还需要确定使该模型性能最大化的最佳参数。传统上，我们会通过网格搜索来进行超参数调整，但 H2O 也可以跨多个模型自动完成整个过程。</p><p id="b913" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">自动机器学习(AutoML)通过训练各种模型来自动化选择最佳模型的过程，使那些没有该领域专业背景的人能够像传统方法一样产生高性能的模型。想想 sci-kit 学习管道，只是更大更好。</p><p id="838e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">目前，H2O 版本 3.16 中的 AutoML 支持以下模型:随机森林、极度随机森林、深度神经网络的随机网格、梯度推进机器(GBM)的随机网格、广义线性模型(GLM)的固定网格，然后训练模型的堆叠系综。</p><h2 id="89b7" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">构建自动估计器</h2><p id="7f38" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">我们首先导入 H2O AutoML 函数，并将其用于训练集，以与之前模型相同的方式传递<code class="fe oy oz pa oq b">x</code>和<code class="fe oy oz pa oq b">y</code>列。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="ce60" class="md me ji oq b gy ou ov l ow ox">from h2o.automl import H2OAutoML</span><span id="ab64" class="md me ji oq b gy pb ov l ow ox">aml = H2OAutoML(max_models=5, max_runtime_secs=300, seed=1)<br/>aml.train(x=x, y=y, training_frame=train)</span></pre><ul class=""><li id="3ee2" class="nb nc ji kz b la lb ld le lg nd lk ne lo nf ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">max_models</code>:这控制了要构建的模型的最大数量，不包括堆叠的集合模型。</li><li id="6ddf" class="nb nc ji kz b la nk ld nl lg nm lk nn lo no ls ng nh ni nj bi translated"><code class="fe oy oz pa oq b">max_runtime_secs</code>:这是在训练模型之前 AutoML 运行的最大运行时间(秒)。</li></ul><h2 id="15c5" class="md me ji bd mf mg mh dn mi mj mk dp ml lg mm mn mo lk mp mq mr lo ms mt mu mv bi translated">性能赋值</h2><p id="9701" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">我们可以通过调用<code class="fe oy oz pa oq b">leaderboard</code>属性并将输出存储在 H2OFrame <code class="fe oy oz pa oq b">lb</code>中来查看最佳模型及其在各种指标上的性能，然后我们可以使用<code class="fe oy oz pa oq b">head()</code>函数来查看。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="f044" class="md me ji oq b gy ou ov l ow ox">lb = aml.leaderboard<br/>lb.head(rows<strong class="oq jj">=</strong>lb<strong class="oq jj">.</strong>nrows)</span></pre><p id="2605" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">输出将包含按 AUC 分数排序的最佳模型列表，并显示适用于分类或回归的几个拟合优度指标。</p><figure class="nq nr ns nt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/6e479cedfcb82272f50db77acc7498dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tF95YV9Z8Vo4ULWgRqLdmw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Leaderboard Output with Maximum Running Time of 300s</figcaption></figure><p id="afef" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们可以使用排行榜中的最佳模型来预测测试集上的标签，并查看之前显示的其他指标。为此，模型被存储为<code class="fe oy oz pa oq b">aml.leader</code>，并拥有普通分类器所拥有的所有功能和属性。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="8797" class="md me ji oq b gy ou ov l ow ox">y_hat = aml.leader.predict(test) <br/>aml.leader.auc()<br/>aml.leader.confusion_matrix()</span></pre><blockquote class="nx ny nz"><p id="fa82" class="kx ky lt kz b la lb kj lc ld le km lf oa lh li lj ob ll lm ln oc lp lq lr ls im bi translated">AutoML 文档:<a class="ae od" href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/automl.html#" rel="noopener ugc nofollow" target="_blank">http://docs.h2o.ai/h2o/latest-stable/h2o-docs/automl.html#</a></p></blockquote><h1 id="4dba" class="oe me ji bd mf of og oh mi oi oj ok ml ko ol kp mo kr om ks mr ku on kv mu oo bi translated">进入生产阶段</h1><p id="c57b" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">H2O 的一个更大的好处是，所有经过充分训练的模型都可以存储为对象，可以很容易地部署到其他 Java 环境中进行实时评分。</p><p id="a3a5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为此，H2O 可以将模型转换为<em class="lt">M</em>odel<em class="lt">O</em>b<em class="lt">j</em>ect<em class="lt">O</em>optimize(MOJOs)。与普通旧 Java 对象(POJO)不同，mojo 没有大小限制，并且比 POJO 速度更快，占用的磁盘空间更小。产生一个<code class="fe oy oz pa oq b">H2O-genmodel.jar</code>文件作为输出，它是一个支持计分的库，包含所需的阅读器和解释器。将 MOJO 模型部署到生产环境中时，也需要这个文件。</p><p id="6457" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面的代码将 mojo 和<code class="fe oy oz pa oq b">h20-genmodel.jar</code>文件下载到用户指定的路径。</p><pre class="nq nr ns nt gt op oq or os aw ot bi"><span id="8e75" class="md me ji oq b gy ou ov l ow ox">model.download_mojo(path='pathname', get_genmodel_jar=True)</span></pre><p id="8d78" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">有关如何在生产中访问模型的更多信息，请参见下面的 H2O 文档。</p><blockquote class="nx ny nz"><p id="f01e" class="kx ky lt kz b la lb kj lc ld le km lf oa lh li lj ob ll lm ln oc lp lq lr ls im bi translated">生产文档:<a class="ae od" href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/productionizing.html#" rel="noopener ugc nofollow" target="_blank">http://docs . H2O . ai/H2O/latest-stable/H2O-docs/productionizing . html #</a></p></blockquote><h1 id="a03b" class="oe me ji bd mf of og oh mi oi oj ok ml ko ol kp mo kr om ks mr ku on kv mu oo bi translated">离别的思绪</h1><p id="3de3" class="pw-post-body-paragraph kx ky ji kz b la mw kj lc ld mx km lf lg my li lj lk mz lm ln lo na lq lr ls im bi translated">到目前为止，您已经熟悉了 python 中 H2O API 的基础知识，在 StackOverflow 和文档的帮助下，您应该能够使用 Python 启动和运行 H2O，构建和训练模型，评估其性能，甚至研究部署。</p><p id="e1a4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这个过程中，我发现相对于其他来源，可以从 H2O 文档中获得资源。不要低估 StackOverflow，但也不要指望在那里找到所有问题的答案。</p><p id="9e8d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果您有任何问题，请告诉我们，我们很乐意在您开始使用 AutoML 和 H2O.ai 时提供更多资源。</p></div></div>    
</body>
</html>