<html>
<head>
<title>One Simple Trick for Speeding up your Python Code with Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Numpy 加速 Python 代码的一个简单技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/one-simple-trick-for-speeding-up-your-python-code-with-numpy-1afc846db418?source=collection_archive---------5-----------------------#2019-06-05">https://towardsdatascience.com/one-simple-trick-for-speeding-up-your-python-code-with-numpy-1afc846db418?source=collection_archive---------5-----------------------#2019-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d2a33a541b6dc90899aab16ec3ad7f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ux7I2BDl3k4ASOQ5.jpg"/></div></div></figure><blockquote class="kb kc kd"><p id="e5f3" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">想获得灵感？快来加入我的<a class="ae ld" href="https://www.superquotes.co/?utm_source=mediumtech&amp;utm_medium=web&amp;utm_campaign=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="kh iu">超级行情快讯</strong> </a>。😎</p></blockquote><p id="c0b2" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Python 是巨大的。</p><p id="4061" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在过去的几年中，Python 的受欢迎程度迅速增长。其中很大一部分是数据科学、机器学习和人工智能的兴起，所有这些都有高级 Python 库可以使用！</p><p id="6058" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">当使用 Python 处理这些类型的工作时，通常需要处理非常大的数据集。这些大型数据集被直接读入内存，并作为 Python 数组、列表或字典进行存储和处理。</p><p id="4fc3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">处理如此庞大的数组可能非常耗时；真的，这就是问题的本质。你有数千、数百万甚至数十亿个数据点。在处理这些点中的一个点时，每增加一微秒都会大大降低您处理大规模数据的速度。</p><h1 id="ced7" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">缓慢的方式</h1><p id="97c6" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">处理大型数据集的缓慢方法是使用原始 Python。我们可以用一个非常简单的例子来证明这一点。</p><p id="3605" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">下面的代码将 1.0000001 的值乘以自身，500 万次！</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5636" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我家里有一个相当不错的 CPU，英特尔 i7-8700k 加上 32GB 的 3000MHz 内存。然而，将这 500 万个数据点相乘需要 0.21367 秒。如果我将<code class="fe mq mr ms mt b">num_multiplies</code>的值改为 10 亿次，这个过程需要 43.24129 秒！</p><p id="7960" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">让我们试试另一个数组。</p><p id="f573" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们将构建一个大小为 1000x1000 的 Numpy 数组，每个数组的值为 1，并再次尝试将每个元素乘以一个浮点数 1.0000001。代码如下所示。</p><p id="c9f3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在同一台机器上，在常规浮点循环中将这些数组值乘以 1.0000001 需要 1.28507 秒。</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="1f96" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是矢量化？</h1><p id="d46c" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">Numpy 被设计成对矩阵运算有效。更具体地说，Numpy 中的大多数处理都是<em class="kg">矢量化</em>。</p><p id="1e50" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">矢量化包括表示数学运算，例如我们在这里使用的乘法，它发生在整个数组上，而不是它们的单个元素上(如我们的 for 循环)。</p><p id="0ccf" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">借助向量化，底层代码被并行化，因此操作可以一次在多个数组元素上运行，而不是一次遍历一个元素。只要你正在应用的操作不依赖于任何其他的数组元素，也就是一个“状态”，那么矢量化将会给你带来很好的速度提升。</p><p id="c27b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在 Python 数组、列表或字典上循环可能会很慢。因此，Numpy 中的矢量化操作被映射到高度优化的 C 代码，这使得它们比标准 Python 代码快得多。</p><h1 id="5753" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">最快的方法</h1><p id="f806" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">下面是做事情的快速方法——按照设计<em class="kg">使用</em>的方式使用 Numpy。</p><p id="98ef" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在寻求加快速度时，我们可以遵循以下几点:</p><ul class=""><li id="ba5a" class="mu mv it kh b ki kj km kn le mw lf mx lg my lc mz na nb nc bi translated">如果数组上有一个 for 循环，我们很有可能用一些内置的 Numpy 函数来替换它</li><li id="bb16" class="mu mv it kh b ki nd km ne le nf lf ng lg nh lc mz na nb nc bi translated">如果我们看到任何类型的数学，我们很有可能用一些内置的 Numpy 函数来代替它</li></ul><p id="d3c1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这两点实际上都集中在用优化的、矢量化的低级 C 代码替换非矢量化的 Python 代码。</p><p id="b105" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">看看我们之前的第一个例子的快速版本，这次有 10 亿次乘法。</p><p id="6b49" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们做了一些非常简单的事情:我们看到我们有一个 for 循环，在这个循环中我们多次重复相同的数学运算。这应该立即触发我们应该去寻找一个 Numpy 函数来代替它。</p><p id="c8bc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们找到了一个——<code class="fe mq mr ms mt b">power</code>函数，它简单地将某个幂应用于输入值。这段代码运行速度惊人，只需 7.6293-6 秒，这是一个</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e492" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这与将值乘以 Numpy 数组的想法非常相似。我们看到我们正在使用一个双 for 循环，应该立即意识到应该有一个更快的方法。</p><p id="a202" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">方便的是，如果我们直接乘以 1.0000001 标量，Numpy 将自动对我们的代码进行矢量化。所以，我们可以用同样的方式来写我们的乘法，就像我们乘以一个 Python 列表一样。</p><p id="5299" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">下面的代码演示了这一点，运行时间为 0.003618 秒，速度提高了 355 倍！</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="0eff" class="lh li it bd lj lk np lm ln lo nq lq lr ls nr lu lv lw ns ly lz ma nt mc md me bi translated">喜欢学习？</h1><p id="601e" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">在<a class="ae ld" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我，我会在那里发布所有最新最棒的人工智能、技术和科学！也在 LinkedIn 上与我联系！</p></div></div>    
</body>
</html>