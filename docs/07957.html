<html>
<head>
<title>Kalman Filter(1) — The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡尔曼滤波器(1)——基础知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kalman-filter-1-the-basics-68f89deb2613?source=collection_archive---------27-----------------------#2019-11-02">https://towardsdatascience.com/kalman-filter-1-the-basics-68f89deb2613?source=collection_archive---------27-----------------------#2019-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8be5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动驾驶汽车本地化的基础知识</h2></div><p id="4171" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我试图学习卡尔曼滤波器，一种结合你的猜测和一些不确定的测量值并做出更好的估计的方法，并发现没有这样容易理解的话题。但是后来，我遇到了这个<a class="ae le" href="https://classroom.udacity.com/courses/cs373" rel="noopener ugc nofollow" target="_blank">课程</a>，它从最基本的方面介绍了这个想法。所以在这篇文章中，我将按照课程中的结构，简单介绍一下自动驾驶汽车定位的基础知识，这也是卡尔曼滤波器的起点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/e01de23a082e333eda39424b996832c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRB9zkpxlqEo_dF1mWzlsA.jpeg"/></div></figure><h1 id="c4a0" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">问题设置</h1><p id="adb6" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">在自动驾驶汽车定位中，通常有两个组成部分— <strong class="kk iu">第一个是运动</strong>，当汽车踩下油门时，我们肯定可以估计(猜测)它可以走多远，第二个是测量，安装在汽车上的传感器能够检测环境并测量它的位置。<em class="mk">现在问题来了，我们的估计(猜测)和传感器测量都可能不准确，结合这两个不确定的因素，我们是否仍然能够对汽车的位置做出猜测，甚至做出更好的猜测？</em></p><p id="5bcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">答案是肯定的，让我们来看一个具体的例子，看看如何用基本的统计学来解决这个问题:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="0783" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">感觉</h1><p id="3ff2" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">假设我们的汽车行驶在一维世界中，那里只有 5 个网格和 2 种不同的颜色——绿色和红色。一开始，我们的汽车有相等的概率停留在 5 个网格中的任何一个，它也有一个传感器<code class="fe mn mo mp mq b">Z</code>，它检测世界的颜色，然而，传感器并不总是正确的，当传感器说网格是<code class="fe mn mo mp mq b">red</code>时，我们给<code class="fe mn mo mp mq b">red</code>一个较高的权重<code class="fe mn mo mp mq b">pHit = 0.6</code>，给<code class="fe mn mo mp mq b">green</code>一个较低的权重<code class="fe mn mo mp mq b">pMiss = 0.2</code>(这里我们使用权重，事实上当加起来是 1 时，它可以归一化为概率)。现在的问题是，当我们的传感器<code class="fe mn mo mp mq b">Z = red</code>，我们的车的位置的概率是多少？</p><p id="16ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案很简单，我们的传感器看到的网格是<code class="fe mn mo mp mq b">red</code>，所以它更有可能在第二个和第三个单元格中。对于红细胞，我们给出较高的权重，绿色细胞给出较低的权重:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fb35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终概率需要归一化，以便加起来等于 1。运行这个程序，我们得到的结果是:</p><pre class="lg lh li lj gt mr mq ms mt aw mu bi"><span id="c958" class="mv lo it mq b gy mw mx l my mz">array([0.11111111, 0.33333333, 0.33333333, 0.11111111, 0.11111111])</span></pre><p id="9da6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，第二个和第三个单元比其余单元具有更高的概率。</p><p id="691b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实上，其背后的统计数据是贝叶斯法则:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e10da60be4cdcc285b57ff5b19ac6b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*FO6N4TrfquBK4C6PIGZ7VQ.png"/></div></figure><p id="f063" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以<code class="fe mn mo mp mq b">cell 2(X_2)</code>中的概率为例，结合公式(2)和(3)，可以很容易地计算出概率为:</p><pre class="lg lh li lj gt mr mq ms mt aw mu bi"><span id="8442" class="mv lo it mq b gy mw mx l my mz">0.2*0.6 / (0.2*(0.2+0.6+0.6+0.2+0.2))</span></pre><p id="28f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分母是一个规格化器，对于上面代码中对应于<code class="fe mn mo mp mq b">sum(combine_prob)</code>的每个单元格都是一样的。</p><p id="153e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们能够在感知环境后计算后验概率，让我们移动汽车，看看它如何影响定位。</p><h1 id="e01a" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">移动</h1><p id="4278" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">在这个水平的 5 格世界中，我们的汽车能够以定义为<code class="fe mn mo mp mq b">U</code>的步数左右移动。然而，它可能不准确地移动到不期望的单元，并且移动概率具有如下分布:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3bca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有 0.8 的几率正确移动，0.1 的几率比原计划多移动一步，0.1 的几率短移动一步。现在的问题是给一个先验分布<code class="fe mn mo mp mq b">p</code>(每个单元格内的概率)，走一步<code class="fe mn mo mp mq b">U</code>后验概率<code class="fe mn mo mp mq b">q</code>是多少？</p><p id="29f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/e6a20ea30b467f8301990c6adc026a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_eJR35M5IDryW3iE7FaXgA.png"/></div></div></figure><p id="b537" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们的车被指示移动 1 步，那么在 3 号单元格落地的概率是多少？</p><p id="18fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们反过来考虑问题:移动 1 步后，汽车会在什么场景下降落在 3 号单元格？它可以从小区 2 以概率 0.3 正确移动，从小区 3 以概率 0.1 下冲，从小区 1 以概率 0.1 上冲。</p><p id="8da0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的统计称为总概率:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ng"><img src="../Images/47292be4e2979201c3519af7c1414a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9L8nYwqDqADKO3lMHNY4A.png"/></div></div></figure><p id="fadf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到达<code class="fe mn mo mp mq b">X_j</code>的概率等于从每个可能的小区<code class="fe mn mo mp mq b">X_i</code>开始的概率之和乘以从<code class="fe mn mo mp mq b">X_i</code>移动到<code class="fe mn mo mp mq b">X_j</code>的概率。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a976" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意这里的<code class="fe mn mo mp mq b">U</code>大于单元总数<code class="fe mn mo mp mq b">n</code>，汽车将循环回到步骤<code class="fe mn mo mp mq b">U % n</code>。</p><h1 id="93f9" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">结合在一起</h1><p id="93a7" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现在我们有了两个最重要的部分——感知和移动，我们的车已经准备好移动了。过程如下:汽车感知环境→移动→感知环境→移动，…</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c007" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们的汽车从均匀分布开始，有 2 次连续测量<code class="fe mn mo mp mq b">red</code>和<code class="fe mn mo mp mq b">green</code>，每次移动 1 步。我们得到最终概率:</p><pre class="lg lh li lj gt mr mq ms mt aw mu bi"><span id="1ade" class="mv lo it mq b gy mw mx l my mz">[0.21157, 0.15157, 0.08105, 0.1684, 0.3873]</span></pre><p id="5870" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以经过一系列步骤后，它最有可能以 0.3873 的概率落在最后一个单元格。</p><p id="a4bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考</strong>:</p><ol class=""><li id="75c6" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated"><a class="ae le" href="https://classroom.udacity.com/courses/cs373" rel="noopener ugc nofollow" target="_blank">https://classroom.udacity.com/courses/cs373</a></li></ol></div></div>    
</body>
</html>