<html>
<head>
<title>SOLID Programming: Single Responsibility Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠编程:单一责任原则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solid-programming-part-1-single-responsibility-principle-efca5e7c2a87?source=collection_archive---------19-----------------------#2019-09-21">https://towardsdatascience.com/solid-programming-part-1-single-responsibility-principle-efca5e7c2a87?source=collection_archive---------19-----------------------#2019-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aa98c2b697a5287a4eba8b604501ecf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*br0Ezj3WI0zn1DYJ.jpg"/></div></div></figure><p id="35f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">坚实的原则是软件工程中最有价值的原则之一。它们允许编写干净、可伸缩且易于扩展的代码。在这一系列的文章中，我将解释每一个原则是什么，以及为什么应用它是重要的。</p><p id="7806" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有些人认为 SOLID 只适用于 OOP，而实际上它的大部分原理可以用于任何范式。</p><p id="7ce0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实线中的“s”代表<strong class="kd iu">单责任</strong>。很多程序员新手的错误就是写复杂的函数和做很多事情的类。然而，根据单一责任原则，一个模块、一个类或一个函数必须只做一件事。换句话说，他们必须只有一个责任。这样代码更健壮，更容易调试、阅读和重用。</p><p id="4ef4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看这个函数，它将一个单词和一个文件路径作为参数，并返回该单词在文本中出现的次数与单词总数的比率。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="cd4c" class="li lj it le b gy lk ll l lm ln">def percentage_of_word(search, file):<br/>    search = search.lower()<br/>    content = open(file, "r").read()<br/>    words = content.split()<br/>    number_of_words = len(words)<br/>    occurrences = 0<br/>    for word in words:<br/>        if word.lower() == search:<br/>            occurrences += 1<br/>    return occurrences/number_of_words</span></pre><p id="e9e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该代码在一个函数中做许多事情:读取文件，计算总字数，单词出现的次数，然后返回比率。</p><p id="1b45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想遵循单一责任原则，我们可以用下面的代码来代替它:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d281" class="li lj it le b gy lk ll l lm ln">def read_localfile(file):<br/>    '''Read file'''<br/><br/>    return open(file, "r").read()<br/><br/><br/>def number_of_words(content):<br/>    '''Count number of words in a file'''<br/><br/>    return len(content.split())<br/><br/><br/>def count_word_occurrences(word, content):<br/>    '''Count number of word occurrences in a file'''<br/><br/>    counter = 0<br/>    for e in content.split():<br/>        if word.lower() == e.lower():<br/>            counter += 1<br/>    return counter<br/><br/><br/>def percentage_of_word(word, content):<br/>    '''Calculate ratio of number of word occurrences to number of    <br/>       all words in a text'''<br/><br/>    total_words = number_of_words(content)<br/>    word_occurrences = count_word_occurrences(word, content)<br/>    return word_occurrences/total_words<br/><br/><br/>def percentage_of_word_in_localfile(word, file):<br/>    '''Calculate ratio of number of word occurrences to number<br/>       of all words in a text file'''<br/><br/>    content = read_localfile(file)<br/>    return percentage_of_word(word, content)</span></pre><p id="beb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在每个函数只做一件事。第一个读取文件。第二个计算总字数。有一个函数可以计算一个单词在文本中出现的次数。另一个函数计算单词出现的次数与单词总数的比率。如果要得到这个比率，我们更愿意传递文件路径而不是文本作为参数，有一个专门的函数。</p><p id="d3f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，以这种方式重组代码，我们能得到什么呢？</p><ul class=""><li id="2a88" class="lo lp it kd b ke kf ki kj km lq kq lr ku ls ky lt lu lv lw bi translated">这些功能很容易<strong class="kd iu">重用</strong>，并且可以根据任务进行混合，从而使代码很容易<strong class="kd iu">扩展</strong>。例如，如果我们想要计算包含在 AWS S3 桶而不是本地文件中的文本中的单词的频率，我们只需要编写一个新函数<code class="fe lx ly lz le b">read_s3</code>，其余的代码无需修改就可以工作。</li><li id="6f01" class="lo lp it kd b ke ma ki mb km mc kq md ku me ky lt lu lv lw bi translated">代号是<strong class="kd iu">干</strong>。没有重复的代码，所以如果我们需要修改其中一个函数，我们只需要在一个地方做。</li><li id="cc45" class="lo lp it kd b ke ma ki mb km mc kq md ku me ky lt lu lv lw bi translated">代码<strong class="kd iu">干净、有条理，非常容易阅读和理解</strong>。</li><li id="756a" class="lo lp it kd b ke ma ki mb km mc kq md ku me ky lt lu lv lw bi translated">我们可以分别为每个函数编写<strong class="kd iu">测试</strong>，这样就更容易调试代码了。你可以在这里检查这些功能<a class="ae mf" href="https://github.com/AnnaLara/SOLID_blogposts/blob/master/tests.py" rel="noopener ugc nofollow" target="_blank">的测试。</a></li></ul><h1 id="9915" class="mg lj it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">GitHub 中的代码</h1><p id="6495" class="pw-post-body-paragraph kb kc it kd b ke nd kg kh ki ne kk kl km nf ko kp kq ng ks kt ku nh kw kx ky im bi translated">这篇文章中的代码和测试可以在 GitHub 中找到:<br/><a class="ae mf" href="https://github.com/AnnaLara/SOLID_blogposts" rel="noopener ugc nofollow" target="_blank">https://github.com/AnnaLara/SOLID_blogposts</a></p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="cc17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">原载于 2019 年 9 月 21 日</em><a class="ae mf" href="https://dev.to/annalara/solid-programming-part-1-single-responsibility-principle-1ki6" rel="noopener ugc nofollow" target="_blank"><em class="np">https://dev . to</em></a><em class="np">。</em></p></div></div>    
</body>
</html>