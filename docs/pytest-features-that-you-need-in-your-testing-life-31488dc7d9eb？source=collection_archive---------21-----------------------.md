# Pytest 特性，您在(测试)生活中需要的特性

> 原文：<https://towardsdatascience.com/pytest-features-that-you-need-in-your-testing-life-31488dc7d9eb?source=collection_archive---------21----------------------->

*注意:这最初发布在*[*martinheinz . dev*](https://martinheinz.dev/blog/7)

测试你的代码是开发不可或缺的一部分，质量测试可以帮你省去很多麻烦。有很多关于在 *Python* 中进行测试的指南，特别是关于用 *Pytest* 进行测试的指南，但是有相当多的特性我很少在任何地方看到提及，但是我经常需要。所以，这里列出了我不能没有的 *Pytest* 的技巧和特性列表(不久之后*你也不能没有*)。

![](img/798f9d6da702b9cd639d6a629ddb4b43.png)

# 异常测试

让我们从简单的开始。您有一个抛出异常的函数，您希望确保它在正确的条件下发生并包含正确的消息:

这里我们可以看到 *Pytest* 为我们提供的简单的上下文管理器。它允许我们指定应该引发的异常类型以及所述异常的消息。如果块中没有引发异常，则测试失败。当上下文管理器返回具有`type`、`value`或`traceback`等属性的`ExceptionInfo`类时，您还可以检查异常的更多属性。

# 过滤警告

除了异常，让我们看看警告。有时，您会在您使用的库内部的日志中收到大量警告消息。你无法修复它们，它们只会制造不必要的噪音，所以让我们摆脱它们:

这里我们展示了两种方法——在第一种方法中，我们通过在过滤器列表的前面插入一个过滤器，直接忽略指定类别的所有警告。这将导致您的程序忽略这一类别的所有警告，直到它终止，这可能并不总是可取的。对于第二种方法，我们使用上下文管理器，它在退出警告范围后恢复所有警告。我们还指定了`record=True`，这样如果需要的话，我们可以检查发出的(忽略的)警告列表。

# 测试标准输出和标准错误消息

接下来，让我们看看下面的场景:你有一个命令行工具，它有一堆函数，这些函数将消息打印到标准输出，但不返回任何内容。那么，我们如何测试呢？

为了解决这个问题， *Pytest* 提供了名为`capsys`的夹具，它可以很好地捕捉系统输出。要使用它，你只需要把它作为参数添加到你的测试函数中。接下来，在调用被测试的函数之后，您以 tuple - `(out, err)`的形式捕获输出，然后您可以在 assert 语句中使用它。

# 修补对象

有时在测试时，您可能需要替换被测函数中使用的对象，以提供更可预测的数据集，或者避免所述函数访问可能不可用的资源。`mock.patch`可以帮上忙:

在第一个例子中，我们可以看到修补函数，然后检查它们被调用的次数和参数。这些补丁也可以以装饰器和上下文管理器的形式堆叠。现在，对于一些更强大的用途:

上面代码片段中的第一个例子非常简单——我们替换了`SomeClass`的方法，并让它返回`None`。在第二个更实际的例子中，我们通过用 mock 替换`requests.get`,并让它返回我们提供合适数据的对象，来避免依赖远程 API/资源。

`mock`模块还能为你做更多的事情，其中一些相当疯狂——包括副作用、模仿属性、模仿不存在的属性等等。如果你在编写测试时遇到问题，那么你一定要检查这个模块的文档，因为你很可能在那里找到解决方案。

# 与`conftest.py`共享灯具

如果你写了很多测试，那么在某个时候你会意识到把所有的*Pytest*fixture 放在一个地方是很好的，你可以从那里导入它们，因此可以在测试文件之间共享。这个可以用`conftest.py`解决。

`conftest.py`是一个位于测试目录树底部的文件。在这个文件中，你可以存储所有的测试夹具，然后这些夹具会被 *Pytest* 自动发现，所以你甚至不需要导入它们。

如果您需要在多个测试之间共享数据，这也很有帮助——只需创建返回测试数据的 fixture。

另一个有用的特性是指定 fixture 范围的能力——这在创建非常昂贵的 fixture 时非常重要，例如到数据库的连接(`session`范围)和在范围的另一端是在每个测试用例(`function`范围)后需要重置的连接。夹具`scope`的可能值为:`function`、`class`、`module`、`package`和`session`。

# 参数化夹具

我们已经在上面的例子中讨论了设备，所以让我们再深入一点。如果您想通过参数化来创建更多的通用夹具，该怎么办呢？

上面是一个为每个测试准备 SQLite 测试数据库的 fixture 的例子。这个 fixture 接收数据库的路径作为参数。使用`request`对象将该路径传递给 fixture，该属性`param`是传递给 fixture 的所有参数的 iterable，在本例中只有一个参数——路径。这里，这个 fixture 首先创建数据库文件(也可以填充它——为了清楚起见省略了),然后执行测试，测试完成后，fixture 删除数据库文件。

至于测试本身，我们使用带有 3 个参数的`@pytest.mark.parametrize`——第一个是夹具的名称，第二个是夹具的参数值列表，它将成为`request.param`，最后是关键字参数`indirect=True`,它导致参数值出现在`request.param`中。

我们需要做的最后一件事是添加 fixture 作为参数来测试它本身，这样我们就完成了。

有些情况下，跳过一些测试是合理的，无论是因为环境( *Linux* vs *Windows* )、互联网连接、资源可用性还是其他原因。那么，我们该怎么做呢？

这是一个非常简单的例子，展示了如何基于某种条件跳过一个有效的测试——在本例中，基于 PostgreSQL 服务器是否在机器上运行。在 *Pytest* 中还有许多与跳过或预测失败相关的很酷的特性，它们在这里[有很好的记录](http://doc.pytest.org/en/latest/skipping.html)，所以我不会在这里进行更多的详细描述，因为在这里复制和粘贴现有的内容似乎是多余的。

希望这几个小技巧能让你的测试体验变得更加愉快和高效，从而激励你写更多的测试。如果你有任何问题，请随时联系我，如果你有自己的建议或诀窍，请在这里分享。🙂