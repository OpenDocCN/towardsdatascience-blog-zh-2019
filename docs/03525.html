<html>
<head>
<title>DataFrame.transform — Spark Function Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DataFrame.transform —火花函数合成</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dataframe-transform-spark-function-composition-eb8ec296c108?source=collection_archive---------9-----------------------#2019-06-05">https://towardsdatascience.com/dataframe-transform-spark-function-composition-eb8ec296c108?source=collection_archive---------9-----------------------#2019-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/84746e785a19eac2c11a085be7a079d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnNjozkbX9IAvZPkXh5ThQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by 嘉淇 徐 from Pexels</figcaption></figure><h2 id="4dfd" class="jg jh ji bd b dl jj jk jl jm jn jo dk jp translated" aria-label="kicker paragraph">让您的 Spark 代码更具功能性，可读性更好</h2><div class=""/><div class=""><h2 id="7179" class="pw-subtitle-paragraph ko jr ji bd b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dk translated">如何从转换方法中返回容易组合的函数</h2></div><p id="817b" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">随着组织迁移到 Spark 上并在 Spark 上创建新的数据处理逻辑，最终的软件会变得非常大，大到需要考虑我们应用于其他软件项目的所有<strong class="li js">可维护性</strong>。</p><p id="e307" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然有许多关于编写性能逻辑的全面而有价值的资源，但关于<strong class="li js">结构化项目</strong>的资源就不一样了，这些资源创建了可重用的 Spark 代码，并最终降低了长期维护这些项目的成本。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="40a2" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi mj translated"><span class="l mk ml mm bm mn mo mp mq mr di">在</span>这篇文章中，我们来具体看看 Spark Scala DataFrame API，以及如何利用<a class="ae ms" href="https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Dataset@transform[U](t:org.apache.spark.sql.Dataset[T]=%3Eorg.apache.spark.sql.Dataset[U]):org.apache.spark.sql.Dataset[U]" rel="noopener ugc nofollow" target="_blank"> <strong class="li js">数据集[T]。转换</strong> </a>函数来编写可组合代码。</p><p id="fa35" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">注意:<a class="ae ms" href="https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.package@DataFrame=org.apache.spark.sql.Dataset[org.apache.spark.sql.Row]" rel="noopener ugc nofollow" target="_blank">data frame 是 Dataset[Row] </a>的类型别名。</p><h1 id="3a5f" class="mt mu ji bd mv mw mx my mz na nb nc nd kx ne ky nf la ng lb nh ld ni le nj nk bi translated">这个例子</h1><p id="ed1d" class="pw-post-body-paragraph lg lh ji li b lj nl ks ll lm nm kv lo lp nn lr ls lt no lv lw lx np lz ma mb im bi translated">有一些特定金额的交易，包含描述付款人和受益人的“详细信息”列:</p><figure class="nq nr ns nt gt iv"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Note that this DataFrame could be a Dataset[Transaction], but it’s not useful to the examples</figcaption></figure><h1 id="4c1b" class="mt mu ji bd mv mw mx my mz na nb nc nd kx ne ky nf la ng lb nh ld ni le nj nk bi translated">没有。改变</h1><p id="498b" class="pw-post-body-paragraph lg lh ji li b lj nl ks ll lm nm kv lo lp nn lr ls lt no lv lw lx np lz ma mb im bi translated">让我们创建两个函数来处理事务:</p><ul class=""><li id="8220" class="nw nx ji li b lj lk lm ln lp ny lt nz lx oa mb ob oc od oe bi translated"><strong class="li js"> sumAmounts </strong>:对一列或多列的合计值求和</li><li id="f251" class="nw nx ji li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><strong class="li js">extractPayerBeneficiary</strong>:将付款人和受益人从一列分离成两个新列</li></ul><figure class="nq nr ns nt gt iv"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="34b2" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用这些方法来回答以下问题:“哪些受益人在哪些天的总金额超过 25？”</p><figure class="nq nr ns nt gt iv"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8b76" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是一个简单的例子，但是读起来不太好。将其与<code class="fe ok ol om on b">Dataset</code>功能的典型用法进行比较:</p><pre class="nq nr ns nt gt oo on op oq aw or bi"><span id="eb61" class="os mu ji on b gy ot ou l ov ow">df.select(...).filter(...).withColumn(...)...</span></pre><p id="3c4a" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将一些逻辑分解到方法中，这有助于我们分别对每一部分进行推理，但是代码的可读性变得更差了。</p><h1 id="1c7e" class="mt mu ji bd mv mw mx my mz na nb nc nd kx ne ky nf la ng lb nh ld ni le nj nk bi translated">使用。改变</h1><p id="2e17" class="pw-post-body-paragraph lg lh ji li b lj nl ks ll lm nm kv lo lp nn lr ls lt no lv lw lx np lz ma mb im bi translated">transform 函数是 Dataset 类的一个方法，它的目的是添加一个“<em class="ox">简洁的语法来链接定制的转换</em></p><pre class="nq nr ns nt gt oo on op oq aw or bi"><span id="927b" class="os mu ji on b gy ot ou l ov ow"><em class="ox">def </em>transform[U](t: Dataset[T] =&gt; Dataset[U]): Dataset[U] = t(<em class="ox">this</em>)</span></pre><p id="3316" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">它采用了一个函数，从<code class="fe ok ol om on b">Dataset[T]</code>，<em class="ox"> T(数据集中的行类型</em>)到<code class="fe ok ol om on b">Dataset[U]</code>，<em class="ox"> U(结果数据集中的行类型)——</em>U 可以与 T 相同</p><p id="9f21" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一个函数<code class="fe ok ol om on b">DataFrame =&gt; DataFrame</code>符合这个签名——如果我们解开类型别名，我们得到<code class="fe ok ol om on b">Dataset[Row] =&gt; Dataset[Row]</code>,其中 T 和 U 都是<code class="fe ok ol om on b">Row</code>。</p><p id="f3f3" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用您之前定义的方法并简单地切换到使用<code class="fe ok ol om on b">.transform</code>是一个很好的起点:</p><figure class="nq nr ns nt gt iv"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="4651" class="mt mu ji bd mv mw mx my mz na nb nc nd kx ne ky nf la ng lb nh ld ni le nj nk bi translated">更进一步</h1><p id="1fbc" class="pw-post-body-paragraph lg lh ji li b lj nl ks ll lm nm kv lo lp nn lr ls lt no lv lw lx np lz ma mb im bi translated"><code class="fe ok ol om on b">sumAmounts</code>和<code class="fe ok ol om on b">extractPayerBeneficiary</code>方法不太适合<code class="fe ok ol om on b">.transform</code>。这是因为这些方法返回的是一个<strong class="li js">数据帧</strong>，而不是一个函数<code class="fe ok ol om on b">DataFrame =&gt; DataFrame</code>，所以为了返回一个可以在<code class="fe ok ol om on b">.transform</code>中使用的函数，你需要不断地使用下划线来代替数据帧参数。</p><p id="1442" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以重写这些方法来返回签名的函数:<code class="fe ok ol om on b">DataFrame =&gt; DataFrame</code>，以精确匹配<code class="fe ok ol om on b">.transform </code>参数类型:</p><figure class="nq nr ns nt gt iv"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Only the signature had to be changed and a “df =&gt;” added!</figcaption></figure><p id="f9bd" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，您不再需要“下划线”,可以用不同的方式组合这些功能:</p><figure class="nq nr ns nt gt iv"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bbaa" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您所有的自定义转换现在都返回<code class="fe ok ol om on b">DataFrame =&gt; DataFrame</code>，因此您可以使用类型别名来更好地描述返回值:</p><blockquote class="oy"><p id="f19c" class="oz pa ji bd pb pc pd pe pf pg ph mb dk translated"><code class="fe ok ol om on b">type Transform = DataFrame =&gt; DataFrame</code></p></blockquote><p id="2ac6" class="pw-post-body-paragraph lg lh ji li b lj pi ks ll lm pj kv lo lp pk lr ls lt pl lv lw lx pm lz ma mb im bi translated">例如<code class="fe ok ol om on b">def sumAmounts(by: Column*): Transform</code></p><h1 id="c5d6" class="mt mu ji bd mv mw mx my mz na nb nc nd kx ne ky nf la ng lb nh ld ni le nj nk bi translated">摘要</h1><ul class=""><li id="7dbd" class="nw nx ji li b lj nl lm nm lp pn lt po lx pp mb ob oc od oe bi translated">自定义转换方法可以重新排列以返回类型为<code class="fe ok ol om on b">DataFrame =&gt; DataFrame</code>的函数。</li><li id="929a" class="nw nx ji li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated">返回函数使得组合转换和使用它们变得更加容易。</li><li id="b7ab" class="nw nx ji li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated">类型别名可用于显式定义“转换”。</li></ul><p id="e690" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">你可以在这个<a class="ae ms" href="https://gist.github.com/dmateusp/e738a9647ffe2fa432457460d1c0c445" rel="noopener ugc nofollow" target="_blank">要点</a>里找到我的<strong class="li js"> build.sbt </strong>和上面的代码</p></div></div>    
</body>
</html>