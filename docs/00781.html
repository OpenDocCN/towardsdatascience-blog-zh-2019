<html>
<head>
<title>TensorFlow — The Scope of Software Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流——软件工程的范围</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-the-scope-of-software-engineering-ad7306560bb?source=collection_archive---------20-----------------------#2019-02-05">https://towardsdatascience.com/tensorflow-the-scope-of-software-engineering-ad7306560bb?source=collection_archive---------20-----------------------#2019-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ccc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何像软件工程师一样构建你的张量流图</h2></div><p id="a788" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您已经完成了对模型的训练，是时候了解一下它学到了什么。你决定哪个张量应该是有趣的，并在你的代码中去寻找它——找出它的名字。然后你突然想到——你忘了给它起个名字。您还忘记了用一个命名的作用域来包装逻辑代码块。这意味着你很难找到张量的参考。它适用于 python 脚本和 TensorBoard:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/d55a3ebf1abcb7b3517870c9e309d7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1p6hI9TxCOsM9Frxg3zCKg.png"/></div></div></figure><p id="5a8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你能看到那个消失在张量海中的小红圈吗？找到它很难…</p><p id="c073" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">真令人失望！如果它看起来更像这样会好得多:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/ae6548e0b82159a947bbf3f51eaf2efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BG_r91KB9-jtSrA8FHufXQ.png"/></div></div></figure><p id="e872" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这还差不多！构成一个逻辑单元的每组张量都包含在一个命名的作用域内。</p><p id="3e73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么图形不能以类似于你的代码的方式自动构建？我的意思是，大多数情况下，你没有使用单一函数来构建模型，是吗？您的代码库包含多个函数——每个函数都构成一个逻辑单元，它理应拥有自己的命名范围！</p><p id="0eed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你有一个张量<code class="fe lq lr ls lt b">x</code>，它是由函数<code class="fe lq lr ls lt b">f</code>定义的，这个函数又被<code class="fe lq lr ls lt b">g</code>调用。这意味着当你写代码的时候，你的头脑中有这样的逻辑结构:<code class="fe lq lr ls lt b">g</code>-&gt;-<code class="fe lq lr ls lt b">f</code>-&gt;-<code class="fe lq lr ls lt b">x</code>。如果这个模型能够以张量名为<code class="fe lq lr ls lt b">g/f/x</code>的方式自动构建，那不是很好吗？</p><p id="0b2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仔细想想，这很容易做到。您所要做的就是检查所有的函数并添加一行代码:</p><pre class="lf lg lh li gt lu lt lv lw aw lx bi"><span id="a133" class="ly lz it lt b gy ma mb l mc md">def f():<br/>    with tensorflow.name_scope(‘f’):<br/>        # define tensors</span></pre><p id="e8b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么这种方法有什么问题呢？</p><ol class=""><li id="deef" class="me mf it kk b kl km ko kp kr mg kv mh kz mi ld mj mk ml mm bi translated">函数名<code class="fe lq lr ls lt b">f</code>出现了两次——在函数声明中和作为<code class="fe lq lr ls lt b">tensorflow.name_scope</code>的参数。也许下周你会把函数的名字改成更有意义的，比如说<code class="fe lq lr ls lt b">foo</code>。不幸的是，您可能会忘记更新作用域的名称！</li><li id="f5cb" class="me mf it kk b kl mn ko mo kr mp kv mq kz mr ld mj mk ml mm bi translated">你必须对<code class="fe lq lr ls lt b">f</code>的整个主体应用缩进。虽然没那么糟糕，但就我个人而言，我不喜欢高缩进级别。假设<code class="fe lq lr ls lt b">f</code>包含一个 for 循环，该循环包含一个 if 语句，该语句包含另一个 for 循环。由于调用了<code class="fe lq lr ls lt b">tensorflow.name_scope</code>，我们已经达到了缩进级别 4！</li></ol><p id="14cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用简单的元编程来绕过这些缺点——Python 的 decorators 来拯救我们！</p><pre class="lf lg lh li gt lu lt lv lw aw lx bi"><span id="3fde" class="ly lz it lt b gy ma mb l mc md">import re</span><span id="5f7c" class="ly lz it lt b gy ms mb l mc md"><br/>def name_scope(f):<br/>    def func(*args, **kwargs):<br/>        name = f.__name__[re.search(r’[^_]’, f.__name__).start():]<br/>        with tensorflow.name_scope(name):<br/>            return f(*args, **kwargs)<br/>    return func</span><span id="b3c0" class="ly lz it lt b gy ms mb l mc md"><br/>@name_scope<br/>def foo():<br/>    # define tensors</span></pre><p id="eca7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是如何工作的？<code class="fe lq lr ls lt b">@</code>是一个语法糖。它相当于以下内容:</p><pre class="lf lg lh li gt lu lt lv lw aw lx bi"><span id="c1f3" class="ly lz it lt b gy ma mb l mc md">def foo():<br/>    # define tensors</span><span id="6f4d" class="ly lz it lt b gy ms mb l mc md"><br/>foo = name_scope(foo)</span></pre><p id="72b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lq lr ls lt b">name_scope</code>获取一个函数作为参数(<code class="fe lq lr ls lt b">f</code>)并返回一个新函数(<code class="fe lq lr ls lt b">func</code>)。<code class="fe lq lr ls lt b">func</code>创建一个命名作用域，然后调用<code class="fe lq lr ls lt b">f</code>。</p><p id="17b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果呢？由<code class="fe lq lr ls lt b">f</code>定义的所有张量都将在一个命名的作用域内创建。作用域的名称将是原始函数的名称(“foo”)—多亏了<code class="fe lq lr ls lt b">f.__name__</code>。</p><p id="96e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个小问题是，虽然函数名可能以“_”开头，但 tensorflow 作用域名不能。这就是我们必须使用<code class="fe lq lr ls lt b">re</code>的原因。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f2a2" class="na lz it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">为什么这么重要？</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nr"><img src="../Images/efc817b6386c600b601f2dbab64b0717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEk4RGRcBXCiQKcajT4rUA.jpeg"/></div></div></figure><p id="c985" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与实际使模型变得更好的研究挑战相比，编写干净的张量流代码的挑战可以忽略不计。</p><p id="a45e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，很容易被诱惑去专注于你工作的研究方面。然而，从长远来看，重要的是不要忽视代码的可维护性和可读性，包括图形的可维护性和可读性。</p><p id="a1e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">装饰器方法使我的工作变得简单了一些，我希望您也能从中受益。你还有其他的建议想分享吗？在评论里掉一行！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="fb98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ns">最初由我发表于</em><a class="ae nt" href="https://engineering.taboola.com/tensorflow-scope-software-engineering" rel="noopener ugc nofollow" target="_blank"><em class="ns">engineering.taboola.com</em></a><em class="ns">。</em></p></div></div>    
</body>
</html>