<html>
<head>
<title>How to Access Twitter’s API using Tweepy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Tweepy 访问 Twitter 的 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-access-twitters-api-using-tweepy-5a13a206683b?source=collection_archive---------2-----------------------#2019-11-05">https://towardsdatascience.com/how-to-access-twitters-api-using-tweepy-5a13a206683b?source=collection_archive---------2-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e8e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用易于使用的 Python 库获得大型 Twitter 数据集的分步指南(包含代码和技巧)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f3d8d91a2529caae850cdba0f3e77d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*suCkFfxGKR2Uwcgb"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@konkarampelas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kon Karampelas</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tweet 数据集对于有抱负的(和实践中的)数据科学家来说是一个非常理想的分析和执行模型的语料库。推文本质上是简短的，包含不同的相关主题，这使得它成为一个优秀的情感分析数据集。这也是一个分析用户参与度的很好的数据集，因为推特时间戳是可用的。</p><p id="e65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然有许多现有的 Twitter 数据集，但它们会为你预先定义。我相信首先要定义你感兴趣的问题，然后找出获取数据的方法。这就是访问 Twitter API 的好处——你可以获得只有 API 才能提供的类型、容量和“新颖性”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/bd0ec9bae2e4d545cc4b28bfb532a7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*cXq8nM42V2KOQCWC4dsTxA.png"/></div></figure><p id="bc34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有任何证据的话，我能够获得 7 万个用户账户和他们的 1000 万个帖子，这几乎需要一整天的时间。这比用自制的酸面团来醒发你的面包面团要稍微长一点，但是真的不会太长。我更强烈地推荐它，而不是试图从零开始做面包(至少一次),相信我，这说明了很多。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3879" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是 Tweepy？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/49ee05e07152d6e3025d0745ff0bc963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-EfPFqNN6DMulQhZjXdog.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Straight from the Tweepy website: <a class="ae ky" href="https://www.tweepy.org/" rel="noopener ugc nofollow" target="_blank">https://www.tweepy.org/</a></figcaption></figure><p id="d944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Twitter API 公开了数十个 HTTP 端点，可用于检索、创建和删除推文、转发和类似内容。它提供了对丰富的实时 tweet 数据的直接访问，但需要处理大量底层细节(并且调试起来很不有趣)。</p><p id="0270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tweepy 是一个开源包，它允许你绕过许多低级的细节。<a class="ae ky" href="https://developer.twitter.com/en/docs/basics/getting-started" rel="noopener ugc nofollow" target="_blank"> Twitter 的开发者网站</a>有很棒的文档，我推荐你去浏览一下，获取示例回复，看看你能访问的数据类型。<a class="ae ky" href="http://docs.tweepy.org/en/v3.5.0/getting_started.html" rel="noopener ugc nofollow" target="_blank"> Tweepy 的文档</a>将进一步为 Tweepy 模块提供代码片段和一些基本文档。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8258" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">获取 Twitter API 认证</h1><p id="ad31" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Twitter API 使用 OAuth，这是一个开放的授权协议来认证请求。您需要创建和配置您的身份验证凭证来访问 Twitter API。正如我所承诺的，这是一个循序渐进的指南，所以跟着做吧！</p><p id="e8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第 0 步:</strong>开一个推特账号。如果你已经有一个 Twitter 账户，跳过这一步</p><p id="587c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步:</strong>申请开发者账号</p><p id="d478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去他们的开发者网站，进入<a class="ae ky" href="https://developer.twitter.com/en/apply-for-access.html" rel="noopener ugc nofollow" target="_blank">申请访问</a>，选择“申请开发者账户”。系统会提示您登录您的 Twitter 帐户。</p><p id="9230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您将被导航到如下页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/2a58d64122cd9db899c2291a79e0ad07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHfRDWwtQuSy1sDV102RfA.png"/></div></div></figure><p id="0f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择您的选择路径，在下一页填写详细信息，并填写一些个人信息。当你打算使用时，有几个字段有最小字符限制(一次他们有一个最小值😏).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/2c90ac631b3d98a53c44a10e2ca67981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUD_rLAMUt1B57h8BHN9uA.png"/></div></div></figure><p id="6502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我填的。诚实，但是不要太担心细节，尤其不要担心简洁。以我的经验来看，他们的审批是即时的。</p><p id="b016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还会有进一步的简单问题和步骤(耐心点！).一旦你完成了这些步骤并接受开发者协议，你现在就有了一个开发者帐户！</p><p id="4eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步:创建一个应用程序</strong></p><p id="06e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能需要等待开发人员帐户获得批准，但一旦获得批准，您就可以开始创建自己的应用程序了。</p><p id="3cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到您的个人资料选项卡并选择应用程序。创建一个应用程序并填写详细信息。那应该再花一分钟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/4f801c4b3b9785585122617a9232a862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vk_w70NkUbYGgGNHwqwMcA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/4046dcf39559b15365deaeabb3ade4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bvVCXkACR8Ir6N5wBmjKg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fill in details in the app section.</figcaption></figure><p id="a628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建应用程序后，进入下一步。</p><p id="d508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三步:获取您的认证信息</strong></p><p id="6a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到您的应用程序页面，在那里您将看到您创建的应用程序。点击详细信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/7885e4f929218410844069202a824133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sCCX44T249qQ4X8TCrJOQ.png"/></div></div></figure><p id="1dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你在那里，点击钥匙和令牌获得相关的钥匙。您可能需要生成您的访问令牌和访问令牌密码。</p><p id="e8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以重新生成密钥，以防您需要写一篇循序渐进的博客文章并共享您的旧密钥(我就是这样做的)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/db45eed930f6f4804e045335d9bb5d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XC5V-nqxQOctgJwnPc0v8g.png"/></div></div></figure><p id="6de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你做到了这一点，就进入下一步吧！</p><h1 id="6431" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">验证凭据</h1><p id="a416" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">用您自己的凭据替换下面代码中的 CONSUMER_KEY、CONSUMER_SECRET、ACCESS_TOKEN、ACCESS_TOKEN_SECRET。</p><p id="a634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行下面的代码来验证您的身份验证。希望有用！</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ec66" class="nr me it nn b gy ns nt l nu nv">import tweepy<br/><br/># Authenticate to Twitter<br/>auth = tweepy.OAuthHandler("CONSUMER_KEY", "CONSUMER_SECRET")<br/>auth.set_access_token("ACCESS_TOKEN","ACCESS_TOKEN_SECRET")</span><span id="0fba" class="nr me it nn b gy nw nt l nu nv">api = tweepy.API(auth)</span><span id="2a8c" class="nr me it nn b gy nw nt l nu nv"># test authentication<br/>try:<br/>    api.verify_credentials()<br/>    print("Authentication OK")<br/>except:<br/>    print("Error during authentication")</span></pre><h1 id="8283" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">强调几种方法</h1><p id="2e24" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Tweepy 有一个方法列表，可以很容易地帮助你访问 Twitter 的端点。用户时间表、推文、搜索、趋势、用户等等都有一个方法。请务必阅读<a class="ae ky" href="https://tweepy.readthedocs.io/en/latest/api.html" rel="noopener ugc nofollow" target="_blank">文档</a>以获得完整列表，但是让我来谈谈我使用的这两种方法。</p><p id="99ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.twitter.com/en/docs/accounts-and-users/follow-search-get-users/api-reference/get-followers-ids" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> follower_ids </strong> </a></p><p id="c9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法允许您获取特定用户的最近关注(使用 screen_name 作为参数)。结果以 5，000 个用户 id 为一组，您可以使用光标浏览“页面”。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="af7e" class="nr me it nn b gy ns nt l nu nv">api.followers_ids(screen_name=screen_name)</span></pre><p id="4671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我的目的，我将此作为一种策略来获取一个 id 列表，作为一个参数提供给 user_timeline 方法</p><p id="5729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.twitter.com/en/docs/tweets/timelines/api-reference/get-statuses-user_timeline" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">用户 _ 时间线</strong> </a></p><p id="3122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何一个 24 小时内，这种方法的总速率限制为 100，000 次呼叫。这将转化为 100，000 个用户及其时间轴帖子(最多 200 个最新帖子)。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a3b0" class="nr me it nn b gy ns nt l nu nv">timeline = api.user_timeline(user_id=user_id, count=200)</span></pre><p id="fda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是它将返回的 JSON 的一个片段。请仔细查看对您的目的有用的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/8aab9a21f53354fb6d2f70dea550390a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6eKaS2x2uPgUu2L6jbyxw.png"/></div></div></figure><p id="303b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，我收集的属性是<em class="ny"> ['created_at '，' text '，' source '，' in_reply_to_screen_name '，' retweet_count '，<br/> 'favorited '，' retweet '，' is_quote_status '，' retweeted _ status '，' hashtags '，' symbols '，' user_mentions'] </em></p><p id="c6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://tweepy.readthedocs.io/en/latest/api.html#API.search" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">搜索</strong> </a></p><p id="9017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有使用这种方法，但我相信这对于大多数寻找 Twitter 数据的人来说是有用的，可以获得关于特定主题的对话。该方法为所有公共 tweet 返回与指定查询匹配的相关 tweet 集合。</p><p id="c246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子返回了最近 5 条关于热门人物斯诺登的推文。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="71ab" class="nr me it nn b gy ns nt l nu nv">api.search(q="hot pockets snowden", lang="en", rpp=5)</span></pre><p id="d046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要解析的结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/d4672757f3a3f5c2aedb0af8ac0bb009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zS8KBus2AMt5pfUbVkaarQ.png"/></div></div></figure><h1 id="dd79" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">一些我需要的代码</h1><p id="f9f7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这个函数将帮助你获得给定 Twitter 用户名的关注者 id 列表。每个页面有 5000 个 id，所以如果特定用户有超过 5000 个追随者，光标只是帮助你“翻转”页面。我的计划是为每个 id 调用用户时间表。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="0280" class="nr me it nn b gy ns nt l nu nv"># define screen_name<br/>def get_ids(screen_name):<br/>    '''<br/>    :argument: screen_name of user<br/>    :returns: a list_id of the given user's followers<br/>    '''<br/>    # get first list<br/>    first_list = api.followers_ids(screen_name=screen_name)<br/>    id_list = first_list['ids']<br/>    cursor = first_list['next_cursor']</span><span id="94cc" class="nr me it nn b gy nw nt l nu nv">    while cursor != 0 :<br/>        user_ids = api.followers_ids(screen_name=screen_name,  cursor=cursor)<br/>        id_list.extend(user_ids[0]['ids'])<br/>        cursor = user_ids[0]['next_cursor']</span><span id="c312" class="nr me it nn b gy nw nt l nu nv">    return id_list</span></pre><p id="3fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的函数有点难。但是高层次上，它根据我指定的属性获取 tweets。我必须执行一些简单的操作(替换函数)来帮助 API 调用的下一行(\n)格式化。这完全是我的操作，因为我的 final 是一个 csv 文件，我将它移动到 postgresql 数据库中。</p><p id="a2db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是在 MongoDB 中捕获的，这可能是不需要的。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="e5f3" class="nr me it nn b gy ns nt l nu nv">def get_tweets(user_id, timeline) :<br/>    '''<br/>    :param user_id: the list_id as recognized by twitter<br/>    :param timeline: the dictionary that is pulled from user_timeline twitter API<br/>    :return: all the posts in dictionary format of a specified list_id<br/>    '''<br/>    # attribute lists<br/>    post_attrs = ['created_at', 'text', 'source', 'in_reply_to_screen_name', 'retweet_count', 'favorite_count',<br/>                  'favorited', 'retweeted', 'is_quote_status', 'retweeted_status']<br/>    entities_attrs = ['hashtags', 'symbols', 'user_mentions']</span><span id="a972" class="nr me it nn b gy nw nt l nu nv">     # creating empty dictionary, and specifying user id<br/>    post_dict = defaultdict(list)</span><span id="1c21" class="nr me it nn b gy nw nt l nu nv">    for tweets in timeline :<br/>       post_dict['user_id'] = user_id<br/>           for post in list(post_attrs) :<br/>              if post == 'text' :<br/>                try :<br/>                    t = tweets[post]<br/>                    t = t.replace('\n','')<br/>                    t = t.replace('\r','')<br/>                    post_dict[post].append(t)<br/>                except :<br/>                    post_dict[post].append(np.nan)<br/>            else :<br/>                try :<br/>                    t = tweets[post]<br/>                    post_dict[post].append(t)<br/>                except :<br/>                    post_dict[post].append(np.nan)</span><span id="8b05" class="nr me it nn b gy nw nt l nu nv">      # looping through other post attributes<br/>        for entity in entities_attrs :<br/>            try :<br/>                attr_name = 'len_' + entity<br/>                post_dict[entity].append(tweets['entities'][entity])<br/>                post_dict[attr_name].append(len(tweets['entities'][entity]))<br/>            except :<br/>                post_dict[entity].append(np.nan)<br/>    return post_dict</span></pre><h1 id="4f2a" class="md me it bd mf mg nh mi mj mk ni mm mn jz nj ka mp kc nk kd mr kf nl kg mt mu bi translated">其他提示</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="17c5" class="nr me it nn b gy ns nt l nu nv">auth = tweepy.OAuthHandler("CONSUMER_KEY", "CONSUMER_SECRET")<br/>auth.set_access_token("ACCESS_TOKEN","ACCESS_TOKEN_SECRET")</span><span id="d8ac" class="nr me it nn b gy nw nt l nu nv">api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True, parser=tweepy.parsers.JSONParser())</span></pre><ol class=""><li id="c2a7" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">在您的 API 方法中，一定要指定 wait_on_rate_limit 和 wait_on_rate_limit_notify，一旦您达到速率限制，它们就会等待并打印出一条消息。</li><li id="3143" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">我发现从 AWS 服务器(或任何云服务器)调用 API 比使用我的本地机器更快。这可能纯粹是我自己在查询 API 时观察打印的用户 id 填充速度的启发。你可以两者都试试，尤其是如果速度对你很重要的话。</li><li id="339e" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">这可能是我能给你的最大的提示，并且在我自己的数据收集中改变了游戏规则。尽管 Twitter 声明每 15 分钟的请求限制为 900 个，但是如果你在一批中连续请求，它们会变得非常慢(每 7 秒 1 个呼叫对每秒 1 个呼叫)。通过一次将我的批分成 5000 条(而不是我第一次迭代中的 20000 条)，我能够更快地获得用户的历史推文。这意味着每次运行 5000 个用户的用户 ID 迭代，然后休息一下，进行另一个 API auth 调用，并调用另外 5000 个用户。请随意测试更小的批次。</li></ol><p id="04be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些——如果有任何问题，请告诉我。快乐求活新鲜数据！</p></div></div>    
</body>
</html>