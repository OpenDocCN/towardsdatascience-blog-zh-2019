<html>
<head>
<title>Setting Up Swagger Docs for Golang API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为 Golang API 设置 Swagger 文档</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/setting-up-swagger-docs-for-golang-api-8d0442263641?source=collection_archive---------3-----------------------#2019-11-01">https://towardsdatascience.com/setting-up-swagger-docs-for-golang-api-8d0442263641?source=collection_archive---------3-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="015c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:此文最初发布于</em><a class="ae kp" href="https://martinheinz.dev/blog/9" rel="noopener ugc nofollow" target="_blank"><em class="ko">martinheinz . dev</em></a></p><p id="d761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在之前的文章中——在 Golang 中构建 RESTful API——我们在 Golang 中创建了 RESTful API。现在，我们已经准备好使用我们的项目，我们应该向我们的用户展示如何这样做，否则——如果他们不能测试它和查看它的特性——他们甚至不会碰它。</p><p id="be97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有我们的 API 的有意义的文档以及测试其端点的能力，用户甚至不会尝试使用它。解决方法是写文档。然而，编写它可能要花很多时间，而这些时间本来可以用来为我们的应用程序开发更酷的功能…那么，我们该怎么办呢？—我们生成<em class="ko">大摇大摆的</em>单据！</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/9f682902527b038268a774d481118ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*IPeXKrUt5pSTHDtBLnhXPA.png"/></div></figure><h1 id="6ff7" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">图书馆</h1><p id="91ca" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">让我们从创建<em class="ko"> Swagger </em>文档所需的库开始。我说的是库，但实际上只需要一个— <a class="ae kp" href="https://github.com/swaggo/swag" rel="noopener ugc nofollow" target="_blank"> swag </a> —它是将代码注释(注释)转换为<em class="ko">Swagger</em>Documentation 2.0 的<em class="ko"> Golang </em>库。除了 swag 之外，你还需要一个中间件/包装器库用于你的 web 框架。在<em class="ko"> swag </em>文档中有<a class="ae kp" href="https://github.com/swaggo/swag#supported-web-frameworks" rel="noopener ugc nofollow" target="_blank">到支持框架</a>的库的链接，其中既包括很多人喜欢使用的最简单的选项<code class="fe mb mc md me b">net/http</code>，也包括我使用的<em class="ko"> GIN </em>，我将在这里展示它。即使您可能使用不同的 web 框架，注释也是一样的，所以无论如何您都可以在这里学到一些东西。</p><p id="5a2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还值得一提的是，还有一个替代的<em class="ko"> Golang Swagger </em>库— <code class="fe mb mc md me b">go-swagger</code>似乎更受欢迎，也更强大一些。然而，我个人更喜欢<code class="fe mb mc md me b">swaggo/swag</code>，因为它简单。如果您需要对生成的内容有更多的控制，您可能希望切换到<code class="fe mb mc md me b">go-swagger</code>。</p><h1 id="9c58" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">文档字符串</h1><p id="0bd4" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">现在，对于注释/注释/文档字符串或任何你想叫它的东西。它实际上只是特定 API 函数之前的一堆注释，用于生成<em class="ko"> Swagger </em>文档。</p><p id="b91b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们开始描述单个 API 端点之前，我们需要首先为整个项目写一个总体描述。这部分注释位于您的<code class="fe mb mc md me b">main</code>包中，就在<code class="fe mb mc md me b">main</code>函数之前:</p><p id="e110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:下面所有的例子都来自我的仓库</em> <a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api" rel="noopener ugc nofollow" target="_blank"> <em class="ko">这里</em> </a> <em class="ko">，在这里你可以找到包含 Swagger UI/Docs 的 runnable 应用。</em></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f12d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面你可以看到通用 API 信息的例子，包括名称、版本、许可证、基本 URL 等。您可以包括的字段很少，它们在这里列出<a class="ae kp" href="https://github.com/swaggo/swag#general-api-info" rel="noopener ugc nofollow" target="_blank">和一些示例</a>。</p><p id="48a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了注释之外，我们还需要导入必要的库，包括我们必须生成的<code class="fe mb mc md me b">docs</code>包的空白导入(稍后会详细介绍)。我们需要做的另一件事是在某个端点实际安装<em class="ko"> Swagger UI </em>，这里我们使用<code class="fe mb mc md me b">"/swagger/*any</code>。</p><p id="36c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是 UI 的一部分，上面的注释会产生:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/3a2c6021d1f168f418f06e0df465b387.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/0*Su6Y9BrKRwvvK_bV"/></div></figure><p id="b60d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是重要的部分 API 函数的注释。这些注释在<code class="fe mb mc md me b">main</code>中连接的每个函数之前，以服务于某个端点，所以当我们服务于像<code class="fe mb mc md me b">v1.GET("/users/:id", apis.GetUser)</code>这样的端点时，我们需要这样注释它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fb84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数注释都是不言自明的，这是您应该包含的最小注释集。我想强调的一点是成功时返回的<code class="fe mb mc md me b">models.User</code>——这是一个存在于<code class="fe mb mc md me b">models</code>包中的数据库表模型。通过这样引用它，我们使它出现在<em class="ko">模型</em>部分的<em class="ko"> Swagger UI </em>中:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/af706dbded40e803b5172b681899002c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_imfNNH5DYsaAuLQ"/></div></div></figure><p id="eada" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们为我们的终点得到的部分:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mn"><img src="../Images/e793d8ccc47b6881ab1fad5d5cbee83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uYmdi5mubHqfK5gR"/></div></div></figure><h1 id="2792" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">生成！</h1><p id="0d41" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">最后，是生成文档的时候了！你所需要的只是一个命令— <code class="fe mb mc md me b">swag init</code>，这个命令需要从<code class="fe mb mc md me b">main</code>所在的目录运行，所以对于我做的<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api/cmd/blueprint" rel="noopener ugc nofollow" target="_blank">蓝图库</a>，应该是<code class="fe mb mc md me b">.../cmd/blueprint/</code>。这个命令将创建名为<code class="fe mb mc md me b">docs</code>的包，其中包含了我们文档的<em class="ko"> JSON </em>和<em class="ko"> YAML </em>版本。</p><p id="5071" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管这个包已经生成，但我更喜欢将它存储在<em class="ko"> GitHub </em>中，因为它是在<code class="fe mb mc md me b">main</code>包中导入的，因此它是应用程序运行所必需的。如果您想避免将生成的代码推送到<em class="ko"> GitHub </em>中，您可以编写一个<em class="ko"> Makefile </em>目标，在应用程序构建和运行之前，动态地重新生成<em class="ko"> Swagger </em>文档。然而，如果你决定推它<em class="ko"> GitHub </em>，你可能想要通过<code class="fe mb mc md me b">go fmt</code>运行文档，因为它不一定被格式化<em class="ko">“正如它应该的那样”</em>。</p><h1 id="647d" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">证明</h1><p id="e190" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在这一点上，我们可以运行应用程序，看看我们漂亮的新<em class="ko"> Swagger UI </em>，然后就到此为止。但是，缺少的一点是 API 的认证。如果您让<em class="ko"> Swagger UI </em>未经认证，那么任何人都可以访问他们想要的任何端点，这可能是非常不可取的，例如，如果您的数据可能被用户损坏。更糟糕的是，您可能会将数据库中的敏感信息暴露给整个互联网。我认为这些是为我们的 API 设置一些简单认证的足够的理由，因此，也是<em class="ko"> Swagger UI </em>，那么我们如何做呢？</p><p id="3853" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要实际实现身份验证。这里是<em class="ko"> GIN </em>的情况，我们创建了一个非常简单的认证中间件，我们将它附加到路由器组:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ff21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将中间件附加到特定的组，我们可以控制什么是认证的，什么是不认证的，这很重要，因为我们不希望<em class="ko"> Swagger UI </em>本身被认证。</p><p id="6f9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:我省略了一些代码，以使例子可读性更好，更容易理解。完整代码，请参见资源库中的</em> <code class="fe mb mc md me b"><em class="ko">rest-api</em></code> <em class="ko">分支</em> <a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api" rel="noopener ugc nofollow" target="_blank"> <em class="ko">此处</em> </a> <em class="ko">。</em></p><p id="7934" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mb mc md me b">main</code>模块中，我们需要改变的另一件事是注释——更具体地说，我们需要添加<code class="fe mb mc md me b">securityDefinitions</code>注释:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2044" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个注释——您已经猜到了——通过<code class="fe mb mc md me b">Authorization</code>头向<em class="ko"> Swagger UI </em>添加了 API 密钥认证。除了 API 密钥认证之外，您还可以选择使用用户名和密码的<em class="ko">基本</em>认证(<code class="fe mb mc md me b">securitydefinitions.basic</code>)或某个版本的<em class="ko"> OAuth2 </em> ( <code class="fe mb mc md me b">securitydefinitions.oauth2</code>)，所有选项都显示在文档<a class="ae kp" href="https://github.com/swaggo/swag#security" rel="noopener ugc nofollow" target="_blank">这里</a>。我个人喜欢使用 API 密匙，因为在我看来这是简单和最方便的选择。</p><p id="3c68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让<em class="ko"> Swagger </em>识别某个端点已经过身份验证，我们还需要向所述 API 函数添加安全注释:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是最后一步，现在(在重新生成<em class="ko"> Swagger </em> docs 之后)我们终于可以运行我们的应用程序了:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="558d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该在<em class="ko"> GIN </em>日志中看到类似这样的内容:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="09cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以在<a class="ae kp" href="http://localhost:1234/swagger/index.html" rel="noopener ugc nofollow" target="_blank">http://localhost:1234/Swagger/index . html</a>打开<em class="ko"> Swagger UI </em>并测试我们的文档！</p><p id="4c33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:如果上面的命令对你来说没有多大意义，请考虑在这里</em>  <em class="ko">通读之前的</em> <a class="ae kp" rel="noopener" target="_blank" href="/building-restful-apis-in-golang-e3fe6e3f8f95?source=friends_link&amp;sk=8069b4cf34194bdbe73c0e58f37ac334"> <em class="ko">。</em></a></p><p id="1e55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，简单重述一下——<code class="fe mb mc md me b">main</code>包中的安全定义为我们提供了以下模型:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/2f6f951a5faf001d14f57cf4c200321b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/0*nEdRw7c5-kxNzPbZ"/></div></figure><p id="5088" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，如果我们输入不正确的 API 密钥(<code class="fe mb mc md me b">"wrong_api_key"</code>)，我们会得到<em class="ko"> 401 </em>响应代码:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/1f5ef1f9bf184db3ad1e0192905c822e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MLReh3i0_oTx1tq9"/></div></div></figure><p id="d2c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用正确的 API 密钥，我们将返回<em class="ko"> 200 </em>所请求的数据:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mq"><img src="../Images/e0e9770f3980aced74877335e7227318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W1gKtlN04PRwQB2H"/></div></div></figure><p id="a17a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样重要的是要提到，像我们在这里所做的那样以明文形式发送授权头是不安全的，并且违背了认证 API 的全部目的，所以在实际应用中，你应该明确地使用 HTTPS。</p><h1 id="dbfa" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="4ca5" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">读完这篇文章后，我希望你现在知道，如何着手为你的 API 建立<em class="ko"> Swagger </em>文档，我也希望你能为你的下一个项目写一些文档，因为它非常简单，而且好的 API 文档对你(手动测试)和应用程序的用户都有很大的价值。您可以在我的存储库的<code class="fe mb mc md me b">rest-api</code>分支<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api" rel="noopener ugc nofollow" target="_blank">这里</a>检查全部代码，如果您有任何问题或改进，请随时联系我或在存储库中创建问题/请求。🙂</p></div></div>    
</body>
</html>