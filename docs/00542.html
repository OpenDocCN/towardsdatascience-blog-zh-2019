<html>
<head>
<title>Forecasting Intermittent Demand with the Croston Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用克罗斯顿模型预测间歇性需求</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/croston-forecast-model-for-intermittent-demand-360287a17f5f?source=collection_archive---------2-----------------------#2019-01-25">https://towardsdatascience.com/croston-forecast-model-for-intermittent-demand-360287a17f5f?source=collection_archive---------2-----------------------#2019-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d33" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">预测间歇性需求的产品是复杂的。我在这里介绍克罗斯顿的模型，这是专门设计来预测这些时间序列。</h2></div><h1 id="f9f5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">克罗斯顿模型</h1><h2 id="0eb8" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">最初的想法</strong></h2><p id="0b2c" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">1972 年，J.D. Croston 发表了“间歇需求的预测和库存控制”一文，介绍了一种预测间歇需求产品的新技术。他的想法可以总结为三个简单的步骤:<br/>——当有需求发生时，评估平均需求水平。<br/> -评估两次需求发生之间的平均时间。<br/> -将需求预测为需求水平(发生时)乘以发生的概率。</p><p id="4e37" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">让我们通过一个例子来一步步实现这一点:</p><ol class=""><li id="8333" class="mn mo it lr b ls mi lv mj lf mp li mq ll mr mh ms mt mu mv bi translated">如果我们估计平均每四个周期有一次需求发生(即有 25%的机会发生)，</li><li id="c996" class="mn mo it lr b ls mw lv mx lf my li mz ll na mh ms mt mu mv bi translated">我们预计，当出现需求时，平均需求水平为 5 个单位，</li><li id="0564" class="mn mo it lr b ls mw lv mx lf my li mz ll na mh ms mt mu mv bi translated">然后，我们预测未来每期的需求为 5 x 0.25 = 1.25。</li></ol><p id="19db" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">克罗斯顿模型回答了这个问题<strong class="lr iu"> <em class="nb">平均每个时期我们会有多少需求？</em> </strong></p><h2 id="ac34" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">型号</strong></h2><p id="d99f" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">既然我们理解了克罗斯顿模型的基本思想，我们需要回答两个问题:</p><ol class=""><li id="0eaf" class="mn mo it lr b ls mi lv mj lf mp li mq ll mr mh ms mt mu mv bi translated">我们如何估计需求发生的概率？</li><li id="7a43" class="mn mo it lr b ls mw lv mx lf my li mz ll na mh ms mt mu mv bi translated">当发生事故时，我们如何估计需求水平？</li></ol><p id="25d9" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">克罗斯顿使用了一种接近霍尔特&amp;温特斯所用的技术来回答这些问题。对于不同的指数平滑模型，我们将查看每个变量的<strong class="lr iu">先前估计</strong>(即，水平&amp;周期性)及其<strong class="lr iu">最近观察</strong>。</p><h2 id="923a" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">需求水平</strong></h2><p id="8a29" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">让我们记下我们的水平估计<strong class="lr iu"> a </strong>(类似于指数模型)，并记下<strong class="lr iu">实际</strong>需求观察<strong class="lr iu"> d </strong>。只有当我们有了实际的观察结果时，我们才会更新我们的水平估计值</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/61d7cc987c74beb5f31291d8b2dc2034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*BuKp9gKMmv_NcWP5ZG-k3w@2x.png"/></div></figure><p id="ad6f" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">如同在不同的指数平滑模型中一样，我们使用学习参数α(0&lt; alpha &lt; 1) to allocate more or less importance to the most recent observations or the historical ones.</p><h2 id="0634" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">周期性</strong></h2><p id="5883" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">让我们注意两次需求发生<strong class="lr iu"> p </strong>(对于<strong class="lr iu"> p </strong>周期性)之间的时间估计，以及自上一次需求发生<strong class="lr iu"> q </strong>以来经过的时间。我们只会在出现需求时更新<strong class="lr iu"> p </strong></p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0ebbf080ecf7fdfa9493658aa82fce6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*uiQqO1D3sJHJ5TLi4K9plQ@2x.png"/></div></figure><p id="1589" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">注意，我们再次使用 alpha 作为学习参数。这与我们用来估计需求水平的参数相同。</p><h2 id="068e" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated">预报</h2><p id="3d58" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">预测很简单:需求水平(<strong class="lr iu"> a </strong>)除以周期(<strong class="lr iu"> p </strong>)。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/353b9d98df1079e9ec6ad77071b976b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*xwxNL4AHsIG4e1HRkOEs9w@2x.png"/></div></figure><h2 id="804b" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">总结</strong></h2><p id="ebc5" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">然后我们可以总结整个模型。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/47921066ab84185722942fb219ba9b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*H9kjIOsC61V2DrVAPDyuAw@2x.png"/></div></figure><p id="5ad9" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">如您所见，当没有需求观察时，没有任何参数被更新。这将是这种模式的局限性之一。</p><h2 id="8b9d" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">见解</strong></h2><p id="202f" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated"><strong class="lr iu">克罗斯顿与简单指数平滑法</strong> <br/>与简单指数平滑法相比，克罗斯顿法最重要的优点是能够估计两次需求发生之间的时间。让我们看看下图是否有助于我们预测间歇性产品。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><a href="https://www.amazon.com/Data-Science-Supply-Chain-Forecast/dp/1730969437"><div class="gh gi nn"><img src="../Images/04cfac58a3a08debaf5116aeae064297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I27Zr9bvMhhhQ0ce0TGfBw@2x.png"/></div></a></figure><p id="ba24" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">不幸的是，这两种模型的 MAE 值大致相同(简单平滑法略占优势):Croston 为 139%，简单平滑法为 130%。</p><p id="c16a" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated"><strong class="lr iu">限制</strong> <br/>如上图所示，当没有需求发生时，克罗斯顿预测不会改变。这很奇怪，有两个原因。</p><ol class=""><li id="86b2" class="mn mo it lr b ls mi lv mj lf mp li mq ll mr mh ms mt mu mv bi translated">长时间没有需求出现应该是降低我们预测的一个诱因。</li><li id="868b" class="mn mo it lr b ls mw lv mx lf my li mz ll na mh ms mt mu mv bi translated">当我们在很长一段时间没有需求之后，第一次出现需求时(看第 52-60 期)，我们降低预测。</li></ol><p id="cc97" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">这是反直觉的。假设我们处于第 51 期:您刚刚售出 8 件，因此您将预测更新为 3 件/期。从第 52 期到第 58 期，你一件也卖不出去，但是你不会<strong class="lr iu">而不是</strong>更新你的预测。实际上，你将不得不等待 59 期间的 2 件销售醒来，并将你的预测减少到 2 件。<br/>这没有任何意义。为什么我们不能在无销售期间更新我们的预测，以反映我们预期我们的需求会降低的想法？</p><div class="no np gp gr nq nr"><a href="https://medium.com/analytics-vidhya/how-to-forecast-high-profit-low-volume-products-3331c20cc4bb" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">如何预测高利润低产量的产品？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">预测低需求和间歇性需求的高利润产品是一项挑战。让我们讨论一下技巧和窍门。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ni nr"/></div></div></a></div><h1 id="1a8b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">改进克罗斯顿</h1><p id="ce36" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">2011 年，在他们的论文“间歇性需求:将预测与库存过时联系起来”中，Ruud Teunter、Aris Syntetos 和 Zied Babai 提出了对 Croston 模型的改进。他们的想法是允许模型更新(<em class="nb">减少</em>)其周期性估计，即使没有需求观察。<br/>这很完美，因为这个限制是我们对 vanilla Croston 模型的主要限制。</p><h2 id="3b80" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak"> TSB 模式</strong></h2><p id="26b0" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated"><strong class="lr iu">Level—</strong>TSB 模型(用于<strong class="lr iu"> T </strong> eunter，<strong class="lr iu">S</strong>yntetos&amp;<strong class="lr iu">B</strong>abai)与常规 Croston 模型相比，不会改变水平的估算方式。<br/> <strong class="lr iu">周期— </strong>周期<strong class="lr iu"> p </strong>现在将表示为需求发生的概率。实际上，<strong class="lr iu"> p </strong>现在将表示范围从 0(需求从未出现)到 1(需求在每个周期出现)的频率(即概率)。我们将在每个周期更新这个周期--即使没有需求发生。<br/>如果没有需求发生，周期将<br/> - <strong class="lr iu">减少</strong>(因为您预计需求发生的概率会减少)。这种减少将是指数性的(如同所有的指数平滑模型)；<br/> - <strong class="lr iu">如果有需求发生，增加</strong>。</p><p id="fcfc" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">然后我们有</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/5d5354330101a9bf987a94eb00a00338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ggiJlPJv4asEfHnm36LUQ@2x.png"/></div></div></figure><p id="f237" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">这可以简化为</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/560b18727ef8d9b11175d2954d884dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*-lkT5m9S504MbRKjFuc0mw@2x.png"/></div></figure><p id="3d57" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">请记住，在传统的 Croston 模型中，<strong class="lr iu"> p </strong>是两次需求发生之间的预期周期数。</p><p id="bd0f" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">我们现在得到 TSB 模型的这组方程。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cf81d166e8dae918b4c2e12773c7cbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*CYQ4CD9x4TVg_O02vFPFbQ@2x.png"/></div></figure><p id="7a4f" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">注意:<br/> -预测<strong class="lr iu"> f </strong>定义为周期<strong class="lr iu"> p </strong> <strong class="lr iu">乘以</strong>水平<strong class="lr iu"> a </strong>(而不是除以它，如原模型中)；<br/>—<strong class="lr iu">t+1</strong>的预测是基于<strong class="lr iu"> t+1 </strong>的水平和周期估计(而不是<strong class="lr iu"> t </strong>)定义的。</p><h2 id="08ce" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated"><strong class="ak">见解</strong></h2><p id="40ad" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">让我们比较我们的新 TSB 模型与原来的克罗斯顿模型和一个简单的平滑。正如你在下面两张图中看到的，TSB 和简单模型非常相似。实际上，区别在于 TSB 模型跟踪需求水平和需求概率。相比之下，简单平滑模型仅跟踪水平(包括需求发生的可能性)。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><a href="https://www.amazon.com/Data-Science-Supply-Chain-Forecast/dp/1730969437"><div class="gh gi on"><img src="../Images/b663712a26c4d671f034fd0bf65f131d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EYB2LFe12xWAQcmCOF6sw@2x.png"/></div></a></figure><figure class="nd ne nf ng gt nh gh gi paragraph-image"><a href="https://www.amazon.com/Data-Science-Supply-Chain-Forecast/dp/1730969437"><div class="gh gi oo"><img src="../Images/2abce4ba9a77f8de9434f20b49ea7173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxRPziN4eyuckDzrGQ3MJQ@2x.png"/></div></a></figure><p id="8f51" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi translated">多亏了 TSB，我们现在获得了 134%的平均绝对误差。简单平滑模型似乎仍然比该产品的其他两个模型略好。当然，这只是一个例子，克罗斯顿/TSB 可能会在其他产品上做得更好。</p><h1 id="c613" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">自己做</h1><p id="ef8e" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx lf ly lz ma li mb mc md ll me mf mg mh im bi translated">你可以在下面找到克罗斯顿和 TSB 模型的 python 实现。</p><pre class="nd ne nf ng gt op oq or os aw ot bi"><span id="05c0" class="la kj it oq b gy ou ov l ow ox">def Croston(ts,extra_periods=1,alpha=0.4):</span><span id="28e0" class="la kj it oq b gy oy ov l ow ox">d = np.array(ts) # Transform the input into a numpy array<br/>    cols = len(d) # Historical period length<br/>    d = np.append(d,[np.nan]*extra_periods) # Append np.nan into the demand array to cover future periods<br/>    <br/>    #level (a), periodicity(p) and forecast (f)<br/>    a,p,f = np.full((3,cols+extra_periods),np.nan)<br/>    q = 1 #periods since last demand observation<br/>    <br/>    # Initialization<br/>    first_occurence = np.argmax(d[:cols]&gt;0)<br/>    a[0] = d[first_occurence]<br/>    p[0] = 1 + first_occurence<br/>    f[0] = a[0]/p[0]</span><span id="6af2" class="la kj it oq b gy oy ov l ow ox"># Create all the t+1 forecasts<br/>    for t in range(0,cols):        <br/>        if d[t] &gt; 0:<br/>            a[t+1] = alpha*d[t] + (1-alpha)*a[t] <br/>            p[t+1] = alpha*q + (1-alpha)*p[t]<br/>            f[t+1] = a[t+1]/p[t+1]<br/>            q = 1           <br/>        else:<br/>            a[t+1] = a[t]<br/>            p[t+1] = p[t]<br/>            f[t+1] = f[t]<br/>            q += 1<br/>       <br/>    # Future Forecast <br/>    a[cols+1:cols+extra_periods] = a[cols]<br/>    p[cols+1:cols+extra_periods] = p[cols]<br/>    f[cols+1:cols+extra_periods] = f[cols]<br/>                      <br/>    df = pd.DataFrame.from_dict({"Demand":d,"Forecast":f,"Period":p,"Level":a,"Error":d-f})</span><span id="a049" class="la kj it oq b gy oy ov l ow ox">return df</span><span id="610e" class="la kj it oq b gy oy ov l ow ox">def Croston_TSB(ts,extra_periods=1,alpha=0.4,beta=0.4):</span><span id="4a4f" class="la kj it oq b gy oy ov l ow ox">d = np.array(ts) # Transform the input into a numpy array<br/>    cols = len(d) # Historical period length<br/>    d = np.append(d,[np.nan]*extra_periods) # Append np.nan into the demand array to cover future periods<br/>    <br/>    #level (a), probability(p) and forecast (f)<br/>    a,p,f = np.full((3,cols+extra_periods),np.nan)</span><span id="b0e8" class="la kj it oq b gy oy ov l ow ox"># Initialization<br/>    first_occurence = np.argmax(d[:cols]&gt;0)<br/>    a[0] = d[first_occurence]<br/>    p[0] = 1/(1 + first_occurence)<br/>    f[0] = p[0]*a[0]<br/>                 <br/>    # Create all the t+1 forecasts<br/>    for t in range(0,cols): <br/>        if d[t] &gt; 0:<br/>            a[t+1] = alpha*d[t] + (1-alpha)*a[t] <br/>            p[t+1] = beta*(1) + (1-beta)*p[t]  <br/>        else:<br/>            a[t+1] = a[t]<br/>            p[t+1] = (1-beta)*p[t]       <br/>        f[t+1] = p[t+1]*a[t+1]<br/>        <br/>    # Future Forecast<br/>    a[cols+1:cols+extra_periods] = a[cols]<br/>    p[cols+1:cols+extra_periods] = p[cols]<br/>    f[cols+1:cols+extra_periods] = f[cols]<br/>                      <br/>    df = pd.DataFrame.from_dict({"Demand":d,"Forecast":f,"Period":p,"Level":a,"Error":d-f})</span><span id="5473" class="la kj it oq b gy oy ov l ow ox">return df</span><span id="250a" class="la kj it oq b gy oy ov l ow ox">def Croston(ts,extra_periods=1,alpha=0.4):</span><span id="fb62" class="la kj it oq b gy oy ov l ow ox">d = np.array(ts) # Transform the input into a numpy array<br/>    cols = len(d) # Historical period length<br/>    d = np.append(d,[np.nan]*extra_periods) # Append np.nan into the demand array to cover future periods<br/>    <br/>    #level (a), periodicity(p) and forecast (f)<br/>    a,p,f = np.full((3,cols+extra_periods),np.nan)<br/>    q = 1 #periods since last demand observation<br/>    <br/>    # Initialization<br/>    first_occurence = np.argmax(d[:cols]&gt;0)<br/>    a[0] = d[first_occurence]<br/>    p[0] = 1 + first_occurence<br/>    f[0] = a[0]/p[0]</span><span id="09e3" class="la kj it oq b gy oy ov l ow ox"># Create all the t+1 forecasts<br/>    for t in range(0,cols):        <br/>        if d[t] &gt; 0:<br/>            a[t+1] = alpha*d[t] + (1-alpha)*a[t] <br/>            p[t+1] = alpha*q + (1-alpha)*p[t]<br/>            f[t+1] = a[t+1]/p[t+1]<br/>            q = 1           <br/>        else:<br/>            a[t+1] = a[t]<br/>            p[t+1] = p[t]<br/>            f[t+1] = f[t]<br/>            q += 1<br/>       <br/>    # Future Forecast <br/>    a[cols+1:cols+extra_periods] = a[cols]<br/>    p[cols+1:cols+extra_periods] = p[cols]<br/>    f[cols+1:cols+extra_periods] = f[cols]<br/>                      <br/>    df = pd.DataFrame.from_dict({"Demand":d,"Forecast":f,"Period":p,"Level":a,"Error":d-f})</span><span id="916c" class="la kj it oq b gy oy ov l ow ox">return df</span></pre><h1 id="4568" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">关于作者</h1><h2 id="1f60" class="la kj it bd kk lb lc dn ko ld le dp ks lf lg lh ku li lj lk kw ll lm ln ky lo bi translated">👉<a class="ae oz" href="https://www.linkedin.com/in/vandeputnicolas/" rel="noopener ugc nofollow" target="_blank">我们在 LinkedIn 上连线吧！</a></h2><div class="no np gp gr nq nr"><a href="https://www.linkedin.com/in/vandeputnicolas/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Nicolas vande put——顾问，创始人——供应链| LinkedIn</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">查看 Nicolas Vandeput 在世界上最大的职业社区 LinkedIn 上的个人资料。尼古拉斯有 7 份工作列在…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.linkedin.com</p></div></div><div class="oa l"><div class="pa l oc od oe oa of ni nr"/></div></div></a></div><p id="a9eb" class="pw-post-body-paragraph lp lq it lr b ls mi ju lu lv mj jx lx lf mk lz ma li ml mc md ll mm mf mg mh im bi pb translated">icolas Vandeput 是一名供应链数据科学家，擅长需求预测和库存优化。他在 2016 年创立了自己的咨询公司<a class="ae oz" href="http://www.supchains.com/" rel="noopener ugc nofollow" target="_blank"> SupChains </a>，并在 2018 年共同创立了<a class="ae oz" href="https://bit.ly/3ozydFN" rel="noopener ugc nofollow" target="_blank"> SKU 科学</a>——一个快速、简单、实惠的需求预测平台。尼古拉斯对教育充满热情，他既是一个狂热的学习者，也喜欢在大学教学:自 2014 年以来，他一直在比利时布鲁塞尔为硕士学生教授预测和库存优化。自 2020 年以来，他还在法国巴黎的 CentraleSupelec 教授这两个科目。他于 2018 年出版了<a class="ae oz" href="https://www.amazon.com/Data-Science-Supply-Chain-Forecasting/dp/3110671107" rel="noopener ugc nofollow" target="_blank"> <em class="nb">供应链预测的数据科学</em></a>(2021 年第 2 版)和 2020 年出版了<a class="ae oz" href="https://www.amazon.com/Inventory-Optimization-Simulations-Nicolas-Vandeput/dp/3110673916" rel="noopener ugc nofollow" target="_blank"> <em class="nb">库存优化:模型与模拟</em> </a>。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pk"><img src="../Images/c41de08f0cf4d975881aee57c407363c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iiuhN5jer1qCQOcREqNcg.jpeg"/></div></div></figure></div></div>    
</body>
</html>