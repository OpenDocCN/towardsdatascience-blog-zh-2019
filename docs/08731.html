<html>
<head>
<title>Hyper-parameter optimization with Optuna</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Optuna 进行超参数优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/https-medium-com-perlitz-hyper-parameter-optimization-with-optuna-1c32785e7df?source=collection_archive---------13-----------------------#2019-11-23">https://towardsdatascience.com/https-medium-com-perlitz-hyper-parameter-optimization-with-optuna-1c32785e7df?source=collection_archive---------13-----------------------#2019-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0f42" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">5 分钟指南</h2><div class=""/><div class=""><h2 id="3940" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">现在，为您的模型寻找最佳超参数变得轻而易举。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/dbb732bd4ade35bf7abeda0a7553c331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LASFZO4EStM0DlRlECHdcQ.png"/></div></div></figure><p id="afe7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这篇文章中，我们将采用一个简单的 pytorch 神经网络训练脚本，并使用<a class="ae lw" href="https://optuna.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja"><em class="lx">Optuna</em></strong></a>包(此处为文档<a class="ae lw" href="https://optuna.readthedocs.io/en/stable/tutorial/index.html" rel="noopener ugc nofollow" target="_blank"/>)对其进行增强。这将允许将<strong class="lc ja">智能</strong> <strong class="lc ja">超参数调整</strong>和<strong class="lc ja">试验修剪</strong>轻松融入您的 ML 工作流，只需<strong class="lc ja">最少的代码修改。</strong></p><p id="a781" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">就个人而言，寻找最适合我目标的超参数是我 ML 工作流程中最糟糕的部分。到目前为止，我的选择有两个:(1)牺牲我的时间和理智，使用优秀的老研究生血统，或者(2)实现一个复杂的框架来搜索参数空间，找到最佳值，记录和可视化过程。</p><p id="ee02" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好消息是:这样一个框架已经存在，它被称为<strong class="lc ja"> <em class="lx"> Optuna </em> </strong>，使用起来很简单也很有趣。</p><p id="6a61" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们的起点是 Pytorch 教程中的 MNIST 分类脚本。为了完整起见，这里给出了完整的脚本，但是，由于其他部分都与我们的观点无关，我推荐<strong class="lc ja">浏览所有部分，直到主函数。</strong></p><p id="db23" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你想看代码的运行，下面是一个工作的 google colab 笔记本的链接。</p><div class="ly lz gp gr ma mb"><a href="https://colab.research.google.com/drive/1TEILbIeyE1wW3daNWOx9rLq0Hc9TXmbV" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ja gy z fp mg fr fs mh fu fw iz bi translated">谷歌联合实验室</h2><div class="mi l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">MNIST·皮托尔赫光学公司</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ky mb"/></div></div></a></div><p id="d733" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在让我们言归正传。</p><h1 id="8954" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">香草 MNIST 分类器框架</h1><p id="5757" class="pw-post-body-paragraph la lb iq lc b ld nh ka lf lg ni kd li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">我们从导入和数据加载器开始:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c41b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我们实施网络:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6ce4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe no np nq nr b">train</code>和<code class="fe no np nq nr b">test</code>方法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6b69" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">还有<code class="fe no np nq nr b">main</code>功能:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dfb7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意，到目前为止，没有什么有趣的事情发生，只是一个简化的 pytorch MNIST 分类器脚本。用当前随机选择的超参数训练上述脚本 5 个时期将给出 93%的准确度。我们能做得更好吗？让我们看看…</p><h1 id="286d" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">用 Optuna 增强 MNIST 分类器框架</h1><p id="b2fb" class="pw-post-body-paragraph la lb iq lc b ld nh ka lf lg ni kd li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">Optuna 框架(通过<code class="fe no np nq nr b">pip install optuna</code>安装并作为<code class="fe no np nq nr b">import optuna</code>导入)基于<strong class="lc ja"> <em class="lx">研究</em> </strong> <em class="lx"> </em>对象。它包含关于所需参数空间、采样器方法和修剪的所有信息:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fa02" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">研究创建后，搜索空间通过<code class="fe no np nq nr b">trial.suggest_</code>方法合并。我们将这些嵌入到<code class="fe no np nq nr b">train_mnist</code>配置中，这样这些值:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b30e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">将替换为以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e89c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">以这种方式，我们根据我们的需求定义搜索空间，一旦完成，<code class="fe no np nq nr b">train_mnist()</code>应该得到<code class="fe no np nq nr b">trial</code>作为它的输入，并被定义为<code class="fe no np nq nr b">train_mnist(trial)</code>。请注意，存在允许<code class="fe no np nq nr b">train_mnist</code>具有除<code class="fe no np nq nr b">trial</code>之外的输入的配置，如果您遇到这种需要，请检查<a class="ae lw" href="https://optuna.readthedocs.io/en/latest/faq.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><h1 id="24f2" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">最佳化</h1><p id="04ee" class="pw-post-body-paragraph la lb iq lc b ld nh ka lf lg ni kd li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">最后一步是定义一个目标函数，其输出将被优化。在我们的例子中，我们选择<code class="fe no np nq nr b">train_mnist</code>及其输出，即<em class="lx">测试误差</em>。</p><p id="83f9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此将调用<code class="fe no np nq nr b">study.optimize</code>，以<code class="fe no np nq nr b">train_mnist</code>作为其参数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8f22" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">总而言之，由对<code class="fe no np nq nr b">train_mnist()</code>的单一调用组成的<code class="fe no np nq nr b">main</code>，已经变成了:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7f77" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">就是这样！一旦这些行被添加到代码中，优化器将根据采样器对定义的参数空间进行采样。</p><p id="24e9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">优化完成后，可以通过<code class="fe no np nq nr b">study.trials_dataframe</code>以数据帧的形式访问结果:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="412c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">输出如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/ba2ab556c6ed1e391adfc20f79564604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEJJ_bOcesiWJ40y5KV56A.png"/></div></div></figure><p id="55e4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">人们可以看到所有的试验和它们的价值。为了找到最佳试验最佳参数，也可以使用<code class="fe no np nq nr b">study.best_trial</code>和<code class="fe no np nq nr b">study.best_params</code>。</p><p id="66b7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这里，我们还可以看到其中一个结果如何在相同的训练数据量和时间下获得 98.9%的测试误差(约 6%的改进)，这是对 3 行代码的重大改进。</p><h1 id="728f" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">形象化</h1><p id="934e" class="pw-post-body-paragraph la lb iq lc b ld nh ka lf lg ni kd li lj nj ll lm ln nk lp lq lr nl lt lu lv ij bi translated">除了向您展示参数的最佳配置，Optuna 还有助于可视化物镜对参数的依赖性。给定研究对象，各种可视化工具存在于<code class="fe no np nq nr b">optuna.visualization</code>中。您可以调用<code class="fe no np nq nr b">plot_parallel_coordinates(study)</code>查看参数(本例中为 lr 和动量)和目标之间的相关性:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/e1590651db3fb9a3de3e4dfe85391f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pa-Z4TTtnsGz1LKkqwbr9A.png"/></div></div></figure><p id="2b7c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">另一种获得直觉的方法是使用等高线图。这可以通过调用<code class="fe no np nq nr b">plot_contour(study)</code>来产生:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/ded80d20b36541276c3ec836ae23a0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvLBOIRTPgFuNFXwKk8ynw.png"/></div></div></figure><p id="9c67" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了完成画面，还可以通过调用<code class="fe no np nq nr b">slice_plot(study)</code>产生切片图。这有助于理解每个参数的最佳子空间分别位于何处。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/e82319d88c9b20b87a361e3d0185cadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Oz4FTV7uaA9a3GzjABgfg.png"/></div></div></figure><p id="6d57" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后一个可视化选项是由<code class="fe no np nq nr b">plot_optimization_history(study)</code>生成的研究历史。这将呈现以下情节:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/0876eae536233b707fa701947a251f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aa_YgxdiGa792WVNvBufA.png"/></div></div></figure><p id="8e7b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这显示了 Optuna 的研究是如何进行的，首先对空间进行均匀采样，然后聚焦于最有希望的区域。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="dc81" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，我希望你喜欢这篇教程，我遗漏了几个很棒的特性，比如早期修剪和不同的搜索算法，这些将不得不等到下次。如果我激起了你的兴趣，请查看伟大的<a class="ae lw" href="https://optuna.readthedocs.io/en/stable/tutorial/index.html" rel="noopener ugc nofollow" target="_blank"> Optuna 文档</a>，都在那里。</p><p id="f75d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">尽情享受吧！</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="92eb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">[1]注意，在这篇文章中，为了简洁起见，我犯了一个可怕的错误:人们应该<strong class="lc ja">永远不要</strong>优化测试集，因为它会过度拟合测试数据！更好的方法是将训练集分成<em class="lx">训练</em>和<em class="lx">验证</em>，但是因为这不是本文的主题，所以我决定保持原样。</p></div></div>    
</body>
</html>