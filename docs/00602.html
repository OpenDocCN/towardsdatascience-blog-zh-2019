<html>
<head>
<title>Learn Enough Docker to be Useful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习足够的码头工人是有用的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-enough-docker-to-be-useful-b0b44222eef5?source=collection_archive---------1-----------------------#2019-01-28">https://towardsdatascience.com/learn-enough-docker-to-be-useful-b0b44222eef5?source=collection_archive---------1-----------------------#2019-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c38b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第 3 部分:一打漂亮的 Dozen 文件指令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2915d99849c9a4fdf2ca9a36ca4f0836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dj93LUOWPHHiYWS1bh5zDQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Keeping with our carb-rich food metaphors, we’ll explore a dozen tasty Dockerfile instructions.</figcaption></figure><p id="488a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是关于 Dockerfiles 的。这是 Docker 六集系列的第三部分。如果你还没有阅读过<a class="ae lu" rel="noopener" target="_blank" href="/learn-enough-docker-to-be-useful-b7ba70caeb4b">第 1 部分</a>，请先阅读一下，以全新的视角来看待 Docker 容器概念。💡<a class="ae lu" rel="noopener" target="_blank" href="/learn-enough-docker-to-be-useful-1c40ea269fa8">第 2 部分</a>是 Docker 生态系统的快速演练。在<a class="ae lu" rel="noopener" target="_blank" href="/slimming-down-your-docker-images-275f0ca9337e">未来的文章</a>中，我将着眼于精简 Docker 映像、Docker CLI 命令以及使用 Docker 数据。</p><p id="cb6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们跳进十几个 Dockerfile 指令就知道了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/bfdf5627e4c9fb86e41824ec39f40ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Sh6i23HzQcvVy_DUHnmrIw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Jump in. True picture ;)</figcaption></figure><h1 id="ec01" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Docker 图像</h1><p id="1713" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">回想一下，Docker 容器是一个栩栩如生的 Docker 图像。这是一个包含应用程序代码的独立的最小操作系统。</p><p id="e8a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker 映像是在构建时创建的，Docker 容器是在运行时创建的。</p><p id="c755" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker 文件是 Docker 的核心。Docker 文件告诉 Docker 如何构建将用于制作容器的图像。</p><p id="4f5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个 Docker 图像包含一个名为<em class="mt"> Dockerfile </em>的文件，没有扩展名。当调用<code class="fe mu mv mw mx b">docker build</code>创建图像时，Dockerfile 被假定在当前工作目录中。可以用文件标志(<code class="fe mu mv mw mx b">-f</code>)指定不同的位置。</p><p id="0d7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回想一下，容器是由一系列层构成的。每个层都是只读的，除了位于其他层之上的最后一个容器层。Docker 文件告诉 Docker 要添加哪些层以及添加的顺序。</p><p id="0e55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每一层实际上只是一个文件，其中包含了自上一层以来的更改。在 Unix 中，几乎所有东西都是一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Everything_is_a_file" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="dc35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基础图像提供初始层。基础映像也称为父映像。</p><p id="dadf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将图像从远程存储库提取到本地计算机时，只会下载本地计算机上没有的图层。Docker 通过重用现有层来节省空间和时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/40cdc786c565d8e1f0572ad899098439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*AqNC_3Nefyo-enzgRjTD4w.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">A base (jumping) image</figcaption></figure><p id="428b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dockerfile 指令是行首的一个大写单词，后跟它的参数。Dockerfile 文件中的每一行都可以包含一条指令。构建映像时，指令是从上到下处理的。说明是这样的:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5ddc" class="nc lx it mx b gy nd ne l nf ng">FROM ubuntu:18.04<br/>COPY . /app</span></pre><p id="4748" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有来自、运行、复制和添加的指令才能在最终图像中创建层。其他指令配置东西，添加元数据，或者告诉 Docker 在运行时做一些事情，比如公开端口或者运行命令。</p><p id="7c84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我假设您使用的是基于 Unix 的 Docker 映像。您也可以使用基于 Windows 的图像，但这是一个较慢、不太愉快、不太常见的过程。所以可以的话就用 Unix 吧。</p><p id="c4a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们快速浏览一下将要研究的十几条 Dockerfile 指令。</p><h1 id="1253" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一打 Dozen 文件说明</h1><p id="bfc2" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated"><code class="fe mu mv mw mx b">FROM</code> —指定基础(父)图像。<br/><code class="fe mu mv mw mx b">LABEL</code>—提供元数据。包含维护者信息的好地方。<br/> <code class="fe mu mv mw mx b">ENV</code> —设置持久的环境变量。<br/><code class="fe mu mv mw mx b">RUN</code>—运行命令并创建一个图像层。用于将包安装到容器中。<br/> <code class="fe mu mv mw mx b">COPY</code> —将文件和目录复制到容器中。<br/> <code class="fe mu mv mw mx b">ADD</code> —将文件和目录复制到容器。可以备份本地。焦油文件。<br/> <code class="fe mu mv mw mx b">CMD</code> —为正在执行的容器提供命令和参数。参数可以被覆盖。只能有一个 CMD。<br/> <code class="fe mu mv mw mx b">WORKDIR</code> —设置后续指令的工作目录。<br/> <code class="fe mu mv mw mx b">ARG</code> —定义在构建时传递给 Docker 的变量。<br/> <code class="fe mu mv mw mx b">ENTRYPOINT</code> —为正在执行的容器提供命令和参数。争论一直存在。<br/> <code class="fe mu mv mw mx b">EXPOSE</code> —暴露一个端口。<br/> <code class="fe mu mv mw mx b">VOLUME</code> —创建目录挂载点以访问和存储持久数据。</p><p id="f105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们开始吧！</p><h1 id="dbb4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">说明和示例</h1><p id="4888" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">Dockerfile 文件可以简单到只有这一行:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8e58" class="nc lx it mx b gy nd ne l nf ng">FROM ubuntu:18.04</span></pre><h2 id="69a2" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#from" rel="noopener ugc nofollow" target="_blank">从到</a></h2><p id="0b08" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">Dockerfile 必须以 FROM 指令或 ARG 指令开头，后跟 FROM 指令。</p><p id="06ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">FROM <em class="mt"> </em>关键字告诉 Docker 使用与提供的存储库和标签相匹配的基本图像。基础图像也被称为<a class="ae lu" href="https://docs.docker.com/develop/develop-images/baseimages/" rel="noopener ugc nofollow" target="_blank">父图像</a>。</p><p id="d0f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，<em class="mt"> ubuntu </em>是图像库。Ubuntu 是一个官方 Docker 库的名字，它提供了流行的 Linux 操作系统 Ubuntu 版本的基础版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3ae59b914779fa2213d22c586c87a996.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*OiaeQ0JXfdeluoJq-liKYg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Linux mascot Tux</figcaption></figure><p id="ae42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这个 docker 文件包含了一个基本图像的标签:<em class="mt"> 18.04 </em>。这个标签告诉 Docker 要从<em class="mt"> ubuntu </em>库中提取哪个版本的图像。如果没有包含标签，那么 Docker 默认采用<em class="mt">最新的</em>标签<em class="mt">、</em>。为了使您的意图清晰，指定一个基本图像标签是一个好的做法。</p><p id="ddcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当上面的 Docker 文件首次用于在本地构建映像时，Docker 会下载在<em class="mt"> ubuntu </em>映像中指定的层。这些层可以被认为是相互堆叠的。每一层都是一个文件，其中包含了与前一层的一系列差异。</p><p id="0580" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建容器时，在只读层之上添加一个可写层。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ae7c8d63e5c9ef26c8a6228c28b5f651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*l8YiwkfvUQsG_uGv9OyJDw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">From the <a class="ae lu" href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/#images-and-layers" rel="noopener ugc nofollow" target="_blank">Docker Docs</a></figcaption></figure><p id="25be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker 使用写入时复制策略来提高效率。如果一个层存在于映像中的前一层，而另一个层需要对它进行读取访问，Docker 将使用现有的文件。什么都不需要下载。</p><p id="e0ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当映像运行时，如果某个层需要被容器修改，则该文件会被复制到顶部的可写层中。查看 Docker 文档<a class="ae lu" href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于写时复制的信息。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="dc58" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated">更实质性的文档</h2><p id="34fb" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">虽然我们的单行图像很简洁，但它也很慢，提供的信息很少，并且在容器运行时什么也不做。让我们看一个更长的 Dockerfile，它构建一个更小的映像，并在容器运行时执行一个脚本。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="c500" class="nc lx it mx b gy nd ne l nf ng">FROM python:3.7.2-alpine3.8<br/>LABEL maintainer="<a class="ae lu" href="mailto:jeffmshale@gmail.com" rel="noopener ugc nofollow" target="_blank">jeffmshale@gmail.com</a>"<br/>ENV ADMIN="jeff"</span><span id="2ccd" class="nc lx it mx b gy ob ne l nf ng">RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add bash</span><span id="319e" class="nc lx it mx b gy ob ne l nf ng">COPY . ./app</span><span id="a9fb" class="nc lx it mx b gy ob ne l nf ng">ADD <a class="ae lu" href="https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4</a> \<br/>/my_app_directory</span><span id="be9b" class="nc lx it mx b gy ob ne l nf ng">RUN ["mkdir", "/a_directory"]</span><span id="fa77" class="nc lx it mx b gy ob ne l nf ng">CMD ["python", "./my_script.py"]</span></pre><p id="0c54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇，这是怎么回事？让我们一步一步来揭开它的神秘面纱。</p><p id="7d5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基础图片是官方的 Python 图片，标签为<em class="mt"> 3.7.2-alpine3.8 </em>。正如你可以从它的<a class="ae lu" href="https://github.com/docker-library/python/blob/ab8b829cfefdb460ebc17e570332f0479039e918/3.7/alpine3.8/Dockerfile" rel="noopener ugc nofollow" target="_blank">源代码</a>中看到的，图像包括 Linux、Python，没有太多其他的。阿尔卑斯山的图像很受欢迎，因为它们小，快，安全。然而，Alpine 图像并不具备操作系统的许多优点。如果需要，您必须自己安装这些软件包。</p><h2 id="31e2" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#label" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">标签</strong> </a></h2><p id="ba6e" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">下一条指令被标记。标签向图像添加元数据。在这种情况下，它提供了映像维护者的联系信息。标签不会降低构建速度或占用空间，它们确实提供了关于 Docker 图像的有用信息，所以一定要使用它们。关于标签元数据的更多信息可以在<a class="ae lu" href="https://docs.docker.com/config/labels-custom-metadata/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/f163fc9a0f666ed86fb27a8ce5155bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BxNuK7OE4yohf4ASHPemdQ.jpeg"/></div></figure><h2 id="3c13" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#env" rel="noopener ugc nofollow" target="_blank">环境</a></h2><p id="9592" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">ENV 设置一个在容器运行时可用的持久环境变量。在上面的例子中，您可以在创建 Docker 容器时使用 ADMIN 变量。</p><p id="9547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ENV 很适合设置常量。如果您在 docker 文件中的几个位置使用了一个常量，并希望在以后更改它的值，那么您可以在一个位置这样做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/63a0f3a638ae0bbd73d7ee3f553d3849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*RqSnnTIeR5dcUeUMfVP4jw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">ENVironment</figcaption></figure><p id="49a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 Dockerfiles，通常有多种方法来完成同一件事情。对你的情况来说，最好的方法是平衡 Docker 惯例、透明度和速度。例如，RUN、CMD 和 ENTRYPOINT 有不同的用途，都可以用来执行命令。</p><h2 id="10ea" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">运行</a></h2><p id="f979" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">运行在构建时创建一个层。Docker 在每次运行后提交映像的状态。</p><p id="f804" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">RUN 通常用于将软件包安装到镜像中<em class="mt">。</em>在上面的例子中，<code class="fe mu mv mw mx b">RUN apk update &amp;&amp; apk upgrade</code>告诉 Docker 从基础映像<em class="mt">更新包。</em> <code class="fe mu mv mw mx b">&amp;&amp; apk add bash</code>告诉 Docker 将<em class="mt"> bash </em>安装到镜像中。</p><p id="1775" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mt"> apk </em>代表<a class="ae lu" href="https://www.cyberciti.biz/faq/10-alpine-linux-apk-command-examples/" rel="noopener ugc nofollow" target="_blank"> Alpine Linux 包管理器</a>。如果您使用的是除 Alpine 之外的 Linux 基础映像，那么您应该安装带有 RUN <em class="mt"> apt-get </em>而不是<em class="mt"> apk </em>的包。<em class="mt"> apt </em>代表<em class="mt">高级包装工具</em>。我将在后面的例子中讨论安装包的其他方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/dfd5d7442fdfc87093a47c7fce06806f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ovB1vggQ-wDamyzj4YFaqQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">RUN</figcaption></figure><p id="b4b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">RUN——以及它的表亲 CMD 和 entry point——可以在 exec 形式或 shell 形式中使用。Exec 格式使用 JSON 数组语法如下:<code class="fe mu mv mw mx b">RUN ["my_executable", "my_first_param1", "my_second_param2"]</code>。</p><p id="0761" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们使用了格式为<code class="fe mu mv mw mx b">RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add bash</code>的 shell 表单。</p><p id="d452" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后在 docker 文件中，我们使用首选的 exec 格式和<code class="fe mu mv mw mx b">RUN ["mkdir", "/a_directory"]</code>来创建一个目录。不要忘记在 exec 表单的 JSON 语法中对字符串使用双引号！</p><h2 id="2368" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#copy" rel="noopener ugc nofollow" target="_blank">复制</a></h2><p id="08c7" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated"><code class="fe mu mv mw mx b">COPY . ./app</code> <em class="mt"> </em>指令告诉 Docker 获取本地构建上下文中的文件和文件夹，并将它们添加到 Docker 映像的当前工作目录中。如果目标目录不存在，复制将创建它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/7398a174ee9e3b65bbbdc43849e94a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*xHw_3tj8JooiRp-yWZCIyQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">COPY</figcaption></figure><h2 id="849c" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#add" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">添加</strong> </a></h2><p id="af6e" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">ADD 做的事情和 COPY 一样，但是多了两个用例。ADD 可用于将文件从远程 URL 移动到容器，ADD 可提取本地 TAR 文件。</p><p id="dd52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我使用 ADD 将一个文件从远程 url 复制到容器的<em class="mt"> my_app_directory </em>中。Docker 文档不推荐以这种方式使用远程 URL，因为你不能删除文件。额外的文件会增加最终图像的大小。</p><p id="cccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker 文档还建议尽可能使用 COPY 而不是 ADD 来提高清晰度。Docker 没有将 ADD 和 COPY 合并成一个命令来减少 Dockerfile 指令的数量以保持直线，这太糟糕了😃。</p><p id="94b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，ADD 指令包含了<code class="fe mu mv mw mx b">\</code>行继续符。通过将一个长指令分成几行来提高可读性。</p><h2 id="5035" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#cmd" rel="noopener ugc nofollow" target="_blank">T11】CMDT13】</a></h2><p id="1aab" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">CMD 为 Docker 提供了一个在容器启动时运行的命令。它不会在构建时将命令的结果提交给映像。在上面的例子中，CMD 将让 Docker 容器在运行时运行 my_ <em class="mt"> script.py </em>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/9f960a7698c2b42ec77aca3a60223422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*534Bheu2kcpBWl8J4vX4rA.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">That’s a CMD!</figcaption></figure><p id="149a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于 CMD 需要知道的其他一些事情:</p><ul class=""><li id="cadf" class="oc od it la b lb lc le lf lh oe ll of lp og lt oh oi oj ok bi translated">每个 docker 文件只有一条 CMD 指令。否则，除了最后一个，其他的都将被忽略。</li><li id="0347" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">CMD 可以包含一个可执行文件。如果 CMD 没有可执行文件，那么入口点指令必须存在。在这种情况下，CMD 和 ENTRYPOINT 指令都应该是 JSON 格式。</li><li id="c571" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated"><code class="fe mu mv mw mx b">docker run</code>的命令行参数覆盖 Dockerfile 文件中提供给 CMD 的参数。</li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="4a53" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated">准备好了吗？</h2><p id="38af" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">让我们在另一个示例 Dockerfile 中再介绍一些指令。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d6e6" class="nc lx it mx b gy nd ne l nf ng">FROM python:3.7.2-alpine3.8<br/>LABEL maintainer="<a class="ae lu" href="mailto:jeffmshale@gmail.com" rel="noopener ugc nofollow" target="_blank">jeffmshale@gmail.com</a>"</span><span id="04fe" class="nc lx it mx b gy ob ne l nf ng"># Install dependencies<br/>RUN apk add --update git</span><span id="351d" class="nc lx it mx b gy ob ne l nf ng"># Set current working directory<br/>WORKDIR /usr/src/my_app_directory</span><span id="613d" class="nc lx it mx b gy ob ne l nf ng"># Copy code from your local context to the image working directory<br/>COPY . .</span><span id="a7e8" class="nc lx it mx b gy ob ne l nf ng"># Set default value for a variable<br/>ARG my_var=my_default_value</span><span id="6568" class="nc lx it mx b gy ob ne l nf ng"># Set code to run at container run time<br/>ENTRYPOINT ["python", "./app/my_script.py", "my_var"]</span><span id="642a" class="nc lx it mx b gy ob ne l nf ng"># Expose our port to the world<br/>EXPOSE 8000</span><span id="0e77" class="nc lx it mx b gy ob ne l nf ng"># Create a volume for data storage<br/>VOLUME /my_volume</span></pre><p id="1ff0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，您可以在 docker 文件中使用注释。评论从<code class="fe mu mv mw mx b">#</code>开始。</p><p id="8ea2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">软件包安装是 Dockerfiles 的主要工作。如前所述，用 RUN 安装软件包有几种方法。</p><p id="614d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用<em class="mt"> apk 在 Alpine Docker 映像中安装一个包。apk </em>就像普通 Linux 版本中的<em class="mt"> apt-get </em>。例如，Dockerfile 中带有基本 Ubuntu 映像的包可以像这样更新和安装:<code class="fe mu mv mw mx b">RUN apt-get update &amp;&amp; apt-get install my_package</code>。</p><p id="dcee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了<em class="mt"> apk </em>和<em class="mt"> apt-get </em>之外，Python 包还可以通过<a class="ae lu" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> <em class="mt"> pip </em> </a>、<a class="ae lu" href="https://pythonwheels.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mt"> wheel </em> </a>、<a class="ae lu" href="https://medium.com/@chadlagore/conda-environments-with-docker-82cdc9d25754" rel="noopener"> <em class="mt"> conda </em> </a>进行安装。其他语言可以使用各种安装程序。</p><p id="376f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">底层需要为安装层提供相关的包管理器。如果您在安装软件包时遇到问题，请确保在尝试使用软件包管理器之前安装了它们。😃</p><p id="e427" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用 RUN with pip 并在 docker 文件中直接列出您想要安装的软件包。如果这样做，将软件包安装连接成一条指令，并用行继续符(\)将其分隔开。这种方法比多重运行指令更清晰，层次更少。</p><p id="5e52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，您可以在一个文件中列出您的包需求，并在该文件上运行包管理器。民间通常将文件命名为<em class="mt"> requirements.txt </em>。在下一篇文章中，我将分享一个推荐的模式来利用构建时缓存和<em class="mt"> requirements.txt </em>。</p><h2 id="7400" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/v17.09/engine/reference/builder/#workdir" rel="noopener ugc nofollow" target="_blank">工作方向</a></h2><p id="aba3" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">WORKDIR 为其后的 COPY、ADD、RUN、CMD 和 ENTRYPOINT 指令更改容器中的工作目录。一些注意事项:</p><ul class=""><li id="a363" class="oc od it la b lb lc le lf lh oe ll of lp og lt oh oi oj ok bi translated">最好用 WORKDIR 设置一个绝对路径，而不是用 Dockerfile 中的<code class="fe mu mv mw mx b">cd</code>命令在文件系统中导航。</li><li id="a5d9" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">如果该目录不存在，WORKDIR 会自动创建它。</li><li id="9d08" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">您可以使用多个 WORKDIR 指令。如果提供了相对路径，那么每个 WORKDIR 指令都会改变当前的工作目录。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/9ed3636cd72dc425582b690ec549a728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IriKIqsuPjl-A9zqU4NUyw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">WORKDIRs of some sort</figcaption></figure><h2 id="8e85" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#arg" rel="noopener ugc nofollow" target="_blank"> ARG </a></h2><p id="9ab8" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">ARG 定义了一个在构建时从命令行传递到映像的变量。可以为 docker 文件中的 ARG 提供一个默认值，如示例中所示:<code class="fe mu mv mw mx b">ARG my_var=my_default_value</code>。</p><p id="070a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与 ENV 变量不同，ARG 变量不可用于正在运行的容器。但是，您可以在构建映像时使用 ARG 值从命令行为 ENV 变量设置默认值。然后，ENV 变量在容器运行时保持不变。点击了解更多关于这项技术的信息。</p><h2 id="b944" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">入口点</a></h2><p id="e14b" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">ENTRYPOINT 指令还允许您在容器启动时提供默认命令和参数。它看起来类似于 CMD，但是如果使用命令行参数运行容器，入口点参数不会被覆盖。</p><p id="187a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，传递给<code class="fe mu mv mw mx b">docker run my_image_name</code>的命令行参数被附加到 ENTRYPOINT 指令的参数中。例如，<code class="fe mu mv mw mx b">docker run my_image bash</code>将参数<em class="mt"> bash </em>添加到 ENTRYPOINT 指令现有参数的末尾。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/30d4c8502fc1b48d433324adb5264a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*8kfhJgqmW34UYMhDnHUcFA.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">ENTRYPOINT to somewhere</figcaption></figure><p id="66e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dockerfile 应该至少有一个 CMD 或 ENTRYPOINT 指令。</p><p id="29e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://docs.docker.com/v17.09/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact" rel="noopener ugc nofollow" target="_blank"> Docker 文档</a>有一些关于在 CMD 和 ENTRYPOINT 之间选择初始容器命令的建议:</p><ul class=""><li id="9ca2" class="oc od it la b lb lc le lf lh oe ll of lp og lt oh oi oj ok bi translated">当您需要每次都运行相同的命令时，请选择 ENTRYPOINT。</li><li id="72f8" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">当一个容器将被用作一个可执行程序时，选择 ENTRYPOINT。</li><li id="5033" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">当您需要提供可以从命令行覆盖的额外默认参数时，请选择 CMD。</li></ul><p id="9ebb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，当容器开始运行<em class="mt">时，<code class="fe mu mv mw mx b">ENTRYPOINT ["python", "my_script.py", "my_var"]</code>让容器运行带有参数<em class="mt"> my_var </em>的 python 脚本<em class="mt"> my_script.py </em>。my_var </em>然后可以通过<a class="ae lu" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> argparse </a>被<em class="mt"> my_script </em>使用。请注意，<em class="mt"> my_var </em>有一个默认值，由前面 docker 文件中的 ARG 提供。因此，如果没有从命令行传递参数，那么将使用默认参数。</p><p id="1507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker 建议你一般使用 exec 形式的 ENTRYPOINT: <code class="fe mu mv mw mx b">ENTRYPOINT ["executable", "param1", "param2"]</code>。这种形式是带有 JSON 数组语法的形式。</p><p id="478c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#expose" rel="noopener ugc nofollow" target="_blank">曝光</a></p><p id="69b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">EXPOSE 指令显示了打算发布哪个端口来提供对正在运行的容器的访问。EXPOSE 实际上并不发布端口。相反，它充当构建映像的人和运行容器的人之间的文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/377704a86568b83da1163a3659cff4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*S2QyTx1gOWtsIoXPzyhCPQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">EXPOSEd</figcaption></figure><p id="b4a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在运行时使用带有<code class="fe mu mv mw mx b">-p</code>标志的<code class="fe mu mv mw mx b">docker run</code>来发布和映射一个或多个端口。大写的<code class="fe mu mv mw mx b">-P</code>标志将公布所有暴露的端口。</p><h2 id="abbb" class="nc lx it bd ly nh ni dn mc nj nk dp mg lh nl nm mi ll nn no mk lp np nq mm nr bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#volume" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">卷</strong> </a></h2><p id="05df" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">VOLUME 指定容器存储和/或访问持久数据的位置。卷是本系列即将发表的一篇文章的主题，因此我们将在那时研究它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/fe48c17f08a292fa84d3e87ed655e656.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*xZT5mao1DZlKu0Zsl9Zc7w.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">VOLUME</figcaption></figure><p id="c32e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们回顾一下我们研究过的十几个 Dockerfile 指令。</p><h1 id="c915" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">重要的文档说明</h1><p id="2225" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated"><code class="fe mu mv mw mx b">FROM</code> —指定基础(父)图像。<br/><code class="fe mu mv mw mx b">LABEL</code>—提供元数据。包含维护者信息的好地方。<br/> <code class="fe mu mv mw mx b">ENV</code> —设置持久的环境变量。<br/><code class="fe mu mv mw mx b">RUN</code>—运行命令并创建一个图像层。用于将包安装到容器中。<br/> <code class="fe mu mv mw mx b">COPY</code> —将文件和目录复制到容器中。<br/> <code class="fe mu mv mw mx b">ADD</code> —将文件和目录复制到容器。可以备份本地。焦油文件。<br/> <code class="fe mu mv mw mx b">CMD</code> —为正在执行的容器提供命令和参数。参数可以被覆盖。只能有一个 CMD。<br/> <code class="fe mu mv mw mx b">WORKDIR</code> —设置后续指令的工作目录。<br/> <code class="fe mu mv mw mx b">ARG</code> —定义在构建时传递给 Docker 的变量。<br/> <code class="fe mu mv mw mx b">ENTRYPOINT</code> —为正在执行的容器提供命令和参数。争论一直存在。<br/> <code class="fe mu mv mw mx b">EXPOSE</code> —暴露一个端口。<br/> <code class="fe mu mv mw mx b">VOLUME</code> —创建目录挂载点以访问和存储持久数据。</p><p id="5caf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你知道一打 Dockerfile 指令让自己有用！这里有一个额外的百吉饼:一个有所有文档说明的小抄。我们没有涉及的五个命令是 USER、ONBUILD、STOPSIGNAL、SHELL 和 HEALTHCHECK。如果你遇到他们，你会看到他们的名字。😃</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/ab51a782bdbd2acf913e59d2314fb6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*wO-_QeIh-YFXRZeEMrczRw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Bonus bagel</figcaption></figure><h1 id="76df" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">包装</h1><p id="504d" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">Docker 文件可能是 Docker to master 的关键组成部分。我希望这篇文章能帮助你获得对他们的信心。我们将在本系列关于减肥图片的下一篇文章中再次讨论它们。跟着<a class="ae lu" href="https://medium.com/@jeffhale" rel="noopener"> me </a>确保不要错过！</p><p id="022e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得这篇文章有帮助，请分享到你最喜欢的社交媒体上，帮助其他人找到它。👍</p><p id="df08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我写关于数据科学、云计算和其他技术的东西。关注我，在这里阅读更多<a class="ae lu" href="https://medium.com/@jeffhale" rel="noopener"/>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://dataawesome.com"><div class="ab gu cl ot"><img src="../Images/ba32af1aa267917812a85c401d1f7d29.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oPkqiu1rrt-hC_lDMK-jQg.png"/></div></a></figure><p id="eb19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">码头快乐！</p></div></div>    
</body>
</html>