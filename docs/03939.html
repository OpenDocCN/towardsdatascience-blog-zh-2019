<html>
<head>
<title>Practical JavaScript: Arrays vs. Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用 JavaScript:数组与对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-javascript-arrays-vs-objects-3c1f895907bd?source=collection_archive---------7-----------------------#2019-06-21">https://towardsdatascience.com/practical-javascript-arrays-vs-objects-3c1f895907bd?source=collection_archive---------7-----------------------#2019-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/befcf36a0fad3d5ad13110f94458d961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QTBdAh4AOs--cIJ9"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@mcarsience_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Meagan Carsience</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="fe77" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天有人问我:“你怎么知道什么时候使用对象，什么时候使用数组？”我在网上找不到能给出我想要的答案的资源，所以…我会成为我想看到的改变。</p><h1 id="6eba" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">TL；博士简介</h1><p id="5fd5" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">想想<strong class="kf jh">你的特定数据代表什么</strong>:如果它是一个具有命名属性的单一实体，你需要一个对象。如果是一组相同类型/形状的实体，或者顺序很重要，您可能需要一个数组。</p><p id="9a7c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果还不清楚，想想<strong class="kf jh">你将如何处理数据</strong>:操纵单个属性？大概是反对。对整体数据进行操作，还是过滤和操作大块数据？我猜是一个数组。</p><p id="76e7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果您正在处理现有数据，并且它已经是一个对象或数组，那么如果没有充分的理由，您可能不会将它转换为另一个对象或数组。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dbd6" class="mn lc jg mj b gy mo mp l mq mr">// A list of ordered strings is a good case for an array:<br/>const sortedNames = ['Axl', 'Billie', 'Chuck'];</span><span id="16db" class="mn lc jg mj b gy ms mp l mq mr">// An item with named properties is a good case for an object:<br/>const box = { height: 4, width: 3, color: 'blue' };</span></pre><h1 id="5cf0" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">两种类型的集合</h1><p id="4af6" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">数组和对象是将数据收集到一个组中的两种方式。数据可以是原语(字符串、数字、布尔值):</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aa14" class="mn lc jg mj b gy mo mp l mq mr">const namesArr = ['Danny', 'Donny', 'Joey', 'Jordan', 'Jonathan'];<br/>const userObj = { name: 'Jamie', age: 42 };</span></pre><p id="2e52" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…或者它们可以由其他数组或对象组成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="541b" class="mn lc jg mj b gy mo mp l mq mr">const usersArr = [{ name: 'Jim', age: 4 }, { name: 'Al', age: 62 }];<br/>const miscObj = { colors: ['orange', 'red'], numbers: [1, 2, 3] };</span></pre><p id="6811" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，你为什么要选择一个而不是另一个呢？冒着过于简化的风险，它归结为<strong class="kf jh">易用性</strong>和<strong class="kf jh">性能</strong>。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="5530" class="lb lc jg bd ld le na lg lh li nb lk ll lm nc lo lp lq nd ls lt lu ne lw lx ly bi translated">插入、删除、迭代、更新</h1><p id="daa7" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我说的易用性是什么意思？当我们将数据分组在一起时，我们通常希望以某种方式使用它。具体来说，我们希望<strong class="kf jh">添加</strong>元素，<strong class="kf jh">移除</strong>元素，<strong class="kf jh">访问/更新</strong>元素，或者<strong class="kf jh">迭代</strong>元素。</p><p id="96bd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nf">边注:提问的人正在使用 React，所以不变性是一个问题，这对易用性/可读性有影响。像</em> <code class="fe ng nh ni mj b"><em class="nf">push(), pop(), splice()</em></code> <em class="nf">等可变方法会使事情变得更简单，但是在这些例子中，我会不变地思考。也有一些不同的方法来实现这些示例中的每一个(例如，spread vs. </em> <code class="fe ng nh ni mj b"><em class="nf">concat</em></code> <em class="nf">)，但我将只坚持一种方法。</em></p><h2 id="db90" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated"><strong class="ak">插入</strong></h2><p id="6fde" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设我们有这样一组名字:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="27b2" class="mn lc jg mj b gy mo mp l mq mr">const names = ['Bob', 'Cate'];</span></pre><p id="ed63" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个新的名字，我们想添加一个到两端。轻松点。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3322" class="mn lc jg mj b gy mo mp l mq mr">const namesPlusEnd = [...names, 'Deb'];<br/>// ['Bob', 'Cate', 'Deb'];</span><span id="9828" class="mn lc jg mj b gy ms mp l mq mr">const namesPlusStart = ['Axl', ...names];<br/>// ['Axl', 'Bob', 'Cate'];</span></pre><p id="d7d4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们想在数组中间插入一个名字的时候，我们需要知道索引。我们不能插入东西，除非我们知道<em class="nf">它需要去哪里</em>，所以如果我们没有索引，我们需要使用<code class="fe ng nh ni mj b">Array.findIndex</code>找到它，这需要时间来遍历数组。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="55bd" class="mn lc jg mj b gy mo mp l mq mr">const namesPlusMiddle = [<br/>  ...names.slice(0, 1),<br/>  'Bud',<br/>  ...names.slice(1)<br/>];</span><span id="8350" class="mn lc jg mj b gy ms mp l mq mr">// ['Bob', 'Bud', 'Cate']</span></pre><p id="d9ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，对象不跟踪顺序，所以在任何地方添加属性都很简单，因为没有开始/中间/结束的概念，并且快速，因为我们不需要迭代:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4dc" class="mn lc jg mj b gy mo mp l mq mr">const box = { width: 4, height: 3, color: 'blue' };</span><span id="96a6" class="mn lc jg mj b gy ms mp l mq mr">If we care about immutability:<br/>const newBox = { ...box, id: 42 };</span><span id="b8af" class="mn lc jg mj b gy ms mp l mq mr">Or, if we don't:<br/>box.id = 42;</span><span id="565a" class="mn lc jg mj b gy ms mp l mq mr">// box/newBox are both now:<br/>// { width: 4, height: 3, color: 'blue', id: 42 };</span></pre><h2 id="113f" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">删除</h2><p id="e35e" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">移除物品呢？还是那句话，看情况！易于从数组的开头或结尾删除:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8901" class="mn lc jg mj b gy mo mp l mq mr">const colors = ['red', 'green', 'blue'];</span><span id="c7aa" class="mn lc jg mj b gy ms mp l mq mr">const colorsWithoutFirst = colors.slice(1);<br/>// ['green', 'blue']</span><span id="e428" class="mn lc jg mj b gy ms mp l mq mr">const colorsWithoutLast = colors.slice(0, -1);<br/>// ['red', 'green']</span></pre><p id="300b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从中间开始也很容易，但是同样，您需要知道想要删除的索引(在本例中是 index <code class="fe ng nh ni mj b">1</code>)，或者迭代过滤出值:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="47d8" class="mn lc jg mj b gy mo mp l mq mr">const colorsMinusMid = [...colors.slice(0, 1), ...colors.slice(2)];<br/>// ['red', 'blue']</span><span id="7563" class="mn lc jg mj b gy ms mp l mq mr">const colorsMinusGreen = colors.filter(color =&gt; color !== 'green');<br/>// ['red', 'blue']</span></pre><p id="dd7a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像给对象添加属性一样，无论对象在哪里，删除对象属性都很简单(因为没有什么东西在对象中“哪里”的概念)。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="af82" class="mn lc jg mj b gy mo mp l mq mr">Immutably:<br/>const { color, ...colorlessBox } = box;</span><span id="2736" class="mn lc jg mj b gy ms mp l mq mr">With mutation:<br/>delete box.color;</span><span id="28a8" class="mn lc jg mj b gy ms mp l mq mr">colorlessBox/box are both now:<br/>// { height: 4, width: 3, id: 42 }</span></pre><h2 id="9627" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">更新</h2><p id="2708" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">更新-不是一个真正的词。当我们想要更新数组中的元素时，我们可以通过索引来完成，或者如果我们不知道索引，我们可以迭代它，根据元素的值(或者元素的属性)来查找元素。通过迭代进行更新是很常见的，因为我们经常在不知道索引的情况下处理大型数据集，或者在索引可能发生变化的情况下处理动态数据。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f19" class="mn lc jg mj b gy mo mp l mq mr">const fruits = ['apple', 'banana', 'clementine'];</span><span id="ae41" class="mn lc jg mj b gy ms mp l mq mr">const newFruits = [<br/>  ...fruits.slice(0, 1),<br/>  'watermelon',<br/>   ...fruits.slice(1)<br/>];</span><span id="06c2" class="mn lc jg mj b gy ms mp l mq mr">This is a little simpler, and leaves the fruits array unchanged:<br/>const fruitsCopy = fruits.slice();<br/>fruitsCopy[1] = 'watermelon';</span><span id="0552" class="mn lc jg mj b gy ms mp l mq mr">Or, if we don't know the index:<br/>const newFruits = fruits.map(fruit =&gt; {<br/>  if (fruit === 'banana') return 'watermelon';<br/>  return fruit;<br/>});</span><span id="f7d4" class="mn lc jg mj b gy ms mp l mq mr">// ['apple', 'watermelon', 'clementine'];</span></pre><p id="2a17" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，更新一个对象要简单得多:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b8bf" class="mn lc jg mj b gy mo mp l mq mr">const box = { height: 4, width: 3, color: 'blue' };</span><span id="84e1" class="mn lc jg mj b gy ms mp l mq mr">Immutably:<br/>const redBox = { ...box, color: 'red' };</span><span id="38ee" class="mn lc jg mj b gy ms mp l mq mr">Mutably:<br/>box.color = 'red';</span><span id="49ab" class="mn lc jg mj b gy ms mp l mq mr">// box/newBox are both now:<br/>// { height: 4, width: 3, color: 'red' }</span></pre><h2 id="edbd" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">访问元素</h2><p id="2b5f" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您只需要获得数组中某个元素的值(不需要更新它)，如果您知道索引就很简单，如果您不知道索引就不会太难(但是您知道一些关于您要寻找的元素的信息):</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="deef" class="mn lc jg mj b gy mo mp l mq mr">const fruits = ['apple', 'banana', 'clementine'];</span><span id="6fc6" class="mn lc jg mj b gy ms mp l mq mr">const secondFruit = fruits[1];<br/>// 'banana'</span><span id="53a9" class="mn lc jg mj b gy ms mp l mq mr">const clementine = fruits.find(fruit =&gt; fruit === 'clementine');<br/>// 'clementine'</span></pre><p id="f796" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">访问对象属性也很容易:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dc85" class="mn lc jg mj b gy mo mp l mq mr">const box = { width: 4, height: 3, color: 'blue' };</span><span id="cfe9" class="mn lc jg mj b gy ms mp l mq mr">const boxColor = box.color<br/>// 'blue'</span></pre><h2 id="9148" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">迭代和方法</h2><p id="41c0" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">到目前为止，与对象相比，数组是一种累赘。用单个数组元素做任何事情都需要知道索引，或者需要更多的代码。最后，随着迭代，是时候让数组发光了。当您想成批地对元素进行一些转换时，数组就是为此而设计的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b29d" class="mn lc jg mj b gy mo mp l mq mr">const fruits = ['apple', 'banana', 'clementine'];</span><span id="1257" class="mn lc jg mj b gy ms mp l mq mr">const capitalFruits = fruits.map(fruit =&gt; fruit.toUpperCase());<br/>// ['APPLE', 'BANANA', 'CLEMENTINE']</span><span id="adf3" class="mn lc jg mj b gy ms mp l mq mr">fruits.forEach(fruit =&gt; console.log(fruit));<br/>// 'apple'<br/>// 'banana'<br/>// 'clementine'</span><span id="1e5d" class="mn lc jg mj b gy ms mp l mq mr">Iteration is common in React:<br/>const FruitsList = props =&gt; (<br/>  &lt;ul&gt;<br/>    {props.fruits.map(fruit =&gt; &lt;li&gt;{fruit}&lt;/li&gt;)}<br/>  &lt;/ul&gt;<br/>);<br/>// &lt;ul&gt;<br/>//   &lt;li&gt;apple&lt;/li&gt;<br/>//   &lt;li&gt;banana&lt;/li&gt;<br/>//   &lt;li&gt;clementine&lt;/li&gt;<br/>// &lt;/ul&gt;</span></pre><p id="c628" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要迭代一个对象，我们唯一真正的选择是一个<code class="fe ng nh ni mj b">for...in</code>循环，但是(在我看来)通常更简单/更易读的方法是……将它转换成一个数组。<code class="fe ng nh ni mj b">Object.keys/values/entries</code>遍历键、值或两者，并给我们一个数据数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fffa" class="mn lc jg mj b gy mo mp l mq mr">const box = { height: 4, width: 3, color: 'blue' };</span><span id="311a" class="mn lc jg mj b gy ms mp l mq mr">const BoxProperties = ({ box }) =&gt; (<br/>  &lt;ul&gt;<br/>    Object.keys(box).map(prop =&gt; &lt;li&gt;{prop}: {box[prop]}&lt;/li&gt;);<br/>  &lt;/ul&gt;<br/>);<br/>// &lt;ul&gt;<br/>//   &lt;li&gt;height: 4&lt;/li&gt;<br/>//   &lt;li&gt;width: 3&lt;/li&gt;<br/>//   &lt;li&gt;color: blue&lt;/li&gt;<br/>// &lt;/ul&gt;</span></pre><p id="093a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组还有其他方法允许您处理数据，而这些方法是对象所没有的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e5b3" class="mn lc jg mj b gy mo mp l mq mr">const animalNames = ['ant', 'bird', 'centipede', 'demogorgon'];</span><span id="8588" class="mn lc jg mj b gy ms mp l mq mr">animalNames.reverse();<br/>// ['demogorgon', 'centipede', 'bird', 'ant']</span><span id="a3a5" class="mn lc jg mj b gy ms mp l mq mr">const shortNames = animalNames.filter(name =&gt; name.length &lt; 5);<br/>// ['ant', 'bird'];</span><span id="303e" class="mn lc jg mj b gy ms mp l mq mr">const containsB = animalNames.some(name =&gt; name.includes('b'));<br/>// true</span><span id="52fa" class="mn lc jg mj b gy ms mp l mq mr">const allAreLong = animalNames.every(name =&gt; name.length &gt; 3);<br/>// false</span><span id="ee6b" class="mn lc jg mj b gy ms mp l mq mr">const totalLetters = animalNames.reduce((total, name) =&gt; {<br/>  return total + name.length;<br/>}, 0);<br/>// 26</span></pre><p id="b059" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以用<code class="fe ng nh ni mj b">for...in</code>很容易地实现其中的任何一个，但是数组有现成的。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="31c2" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">表演</h2><p id="c032" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">速度并不总是一个需要考虑的因素，但是当它是一个需要考虑的因素时，数组和对象之间会有很大的不同。互联网上有大量关于数组与对象性能的资源，但简单来说:当您不知道索引(<em class="nf">线性时间</em>或 O( <em class="nf"> n </em>))时，数组操作会更慢，因为您必须迭代每个元素，直到找到您想要使用的元素。如果您确实知道索引并且不变性不是问题，那么您不需要迭代，并且可以快速访问/更新该索引处的元素(<em class="nf">常量时间</em>，或者 O(1))。对象属性查找/更新/插入/删除发生得很快(也是<em class="nf">常数时间</em>)，因为属性名称给了你一个参考，所以你不必去寻找你想要的元素。</p><h2 id="1908" class="mn lc jg bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated"><strong class="ak">结论</strong></h2><p id="9224" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">经验法则是:类似类型的数据组(您需要对其进行排序或者希望对其进行批处理操作)更适合于数组，而单个实体的分组属性更适合于对象。使用正确的数据类型并不总是一个明确的选择，但是你使用每种数据类型越多，在任何给定的情况下哪种数据类型更有意义就越明显。</p></div></div>    
</body>
</html>