<html>
<head>
<title>How We Used NLTK and NLP to Predict a Song’s Genre From Its Lyrics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何使用 NLTK 和 NLP 从歌词中预测歌曲的风格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-we-used-nltk-and-nlp-to-predict-a-songs-genre-from-its-lyrics-54e338ded537?source=collection_archive---------11-----------------------#2019-04-01">https://towardsdatascience.com/how-we-used-nltk-and-nlp-to-predict-a-songs-genre-from-its-lyrics-54e338ded537?source=collection_archive---------11-----------------------#2019-04-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div class="gi gj jr"><img src="../Images/8a88ca151652a6c0b4599ef91fac633c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8VuNwv77dpEp4l1tRqDeiA.png"/></div></figure><p id="e663" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">本文的目的是概述我们使用 NLTK 和自然语言处理方法来清理和预处理文本数据并将歌词转换为数值矩阵的过程，以便我们可以训练一个机器学习算法，该算法可以根据歌词对每首歌曲的流派进行分类。</p><p id="ef39" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">什么是自然语言处理(简称 NLP)？</strong></p><p id="8193" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv"> NLP </strong>指的是处理文本或语音形式的自然人类语言的分析任务。这些任务通常涉及某种机器学习，无论是文本分类还是特征生成，但 NLP 不仅仅是机器学习。诸如文本预处理和清理之类的任务也属于 NLP 范畴。</p><p id="91b8" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">用于 NLP 任务的最常见的 python 库是自然语言工具包，或<strong class="ka iv"> NLTK。NLTK 是 NLP 所有事情的“一站式商店”。与大多数其他 Python 库和 ML 模型不同，NLTK 和 NLP 的独特之处在于，除了统计学和数学，它们还非常依赖语言学领域。本文其余部分描述的许多处理文本数据的概念和方法都基于语言学规则。</strong></p><p id="7ea6" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">获取数据:我们从哪里获取数据？</p><p id="ef51" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们在 Kaggle 上发现了一个包含 30 万首歌词的 CSV，这些歌词来自 11 种不同的流派和 6-7 种不同的语言。该数据集包含关于歌曲名称、艺术家、年份、专辑、流派的信息，以及一个包含完整歌词的列。</p><p id="69bd" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">清理和预处理文本数据</strong></p><p id="9429" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">现在我们有了数据，有趣的部分开始了。首先，我们需要预处理和清理我们的文本数据。正如您可能已经怀疑的那样，预处理文本数据比处理更传统的数据类型更具挑战性，因为对于我们需要做什么样的预处理和清理没有明确的答案。使用传统数据集时，我们在这一阶段的目标通常非常明确——标准化和清理数值数据、将分类数据转换为数值格式、检查并处理多重共线性等。我们采取的步骤在很大程度上取决于我们获得数据时它的样子。</p><p id="cff9" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">文本数据不同</strong> —在其原始格式中，文本数据仅从一维开始—在项目的初始阶段，我们对数据集中唯一感兴趣的功能是包含每首歌词全文的列。这意味着我们需要决定如何预处理我们的数据，并从文本文档中提取特征，以便稍后用于训练 ML 模型。在我们开始清理和预处理文本数据之前，我们需要做出一些决定，例如:</p><ul class=""><li id="aabb" class="kw kx iu ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们要不要删除停用词？</li><li id="ff17" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们是对我们的文本数据进行词干化或词目化，还是让单词保持原样？</li><li id="aa55" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">基本的标记化是否足够，或者我们是否需要通过使用正则表达式来支持特殊的边缘情况？</li><li id="e83e" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们是坚持只使用英语单词，还是允许使用其他语言？</li><li id="a214" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们是使用整个词汇表，还是仅仅将模型限制在最常用单词的子集？如果有，有多少？</li><li id="1b88" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们是否设计了其他特征，如二元模型、词性标签或互信息分数？</li><li id="5e9e" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们应该在模型中使用哪种矢量化？布尔矢量化？计数矢量化？TF-IDF？Word2Vec 等更高级的矢量化策略？</li></ul><p id="c55f" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">这些都是我们在处理文本数据时需要考虑的问题。</p><p id="3517" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">探索数据</strong>:查看我们的熊猫数据帧，我们发现…</p><p id="c2f1" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们做的第一件事是检查无价值的歌曲，并删除带有 NaN 歌词的歌曲，在清理后，我们仍然有 200，000 行。</p><p id="8b96" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">然后，我们查看了流派的价值计数，决定放弃民谣、独立音乐和其他音乐，因为前两者没有足够的数据，“其他”不能为我们的最终分类任务提供任何预测价值。</p><p id="1ae6" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">在所有这些清理之后，我们只剩下八种基本风格:<strong class="ka iv">摇滚、流行、嘻哈、金属、乡村、爵士、电子、R &amp; B </strong>。这些是我们将试图预测的目标类别。</p><p id="7c39" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">流派之间的分布是不均匀的，所以我们决定随机选择每个流派 900 首歌曲，这样我们的总行数<strong class="ka iv"> 900 首歌曲* 8 个流派= 7200 首歌曲</strong>。</p><h2 id="39d4" class="lk ll iu bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">特征工程和模型优化:</h2><ol class=""><li id="c545" class="kw kx iu ka b kb md kf me kj mf kn mg kr mh kv mi lc ld le bi translated">我们结合使用 NLTK、Pandas 和 Regex 方法来:</li></ol><ul class=""><li id="f8f9" class="kw kx iu ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">清除文本中的标点符号和奇数字符</li><li id="aef0" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">删除停用词</li><li id="e965" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">仅标记英语单词</li><li id="81c3" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">返回词干语料库</li><li id="ca66" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">返回词条化单词的语料库</li><li id="d6f3" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">将最终的干净歌词附加回熊猫数据帧</li></ul><p id="b8ae" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">2.我们使用 TF-IDF 矢量器将单词转化为每个单词对特定歌词的重要性的数字表示。</p><p id="6525" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">什么是 TF-IDF？</strong></p><p id="b62d" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">TF-IDF 代表<em class="mj">词频-逆文档频率</em>，TF-IDF 权重是信息检索和文本挖掘中经常使用的一种权重。该权重是一种统计度量，用于评估一个单词对集合或语料库中的文档有多重要。重要性与单词在文档中出现的次数成比例增加，但是被单词在语料库中的频率抵消。</p><p id="a036" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">TF-IDF 是如何计算的？</strong></p><p id="d67f" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">通常，TF-IDF 权重由两项组成:第一项计算归一化项频率(TF)，aka。单词在文档中出现的次数，除以该文档中的总单词数；第二项是逆文档频率(IDF ),计算为语料库中文档数量的对数除以特定术语出现的文档数量。</p><ol class=""><li id="bbb7" class="kw kx iu ka b kb kc kf kg kj ky kn kz kr la kv mi lc ld le bi translated"><strong class="ka iv"> TF:术语频率</strong>衡量一个术语在文档中出现的频率。因为每个文档的长度不同，所以一个术语在长文档中出现的次数可能比短文档多得多。因此，术语频率通常除以文档长度(又名。文档中的术语总数)作为标准化的一种方式:</li></ol><p id="e0f3" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv"> TF </strong> =(术语 t 在文档中出现的次数)/(文档中的总术语数)。</p><p id="cf2c" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv"> 2。IDF:逆文档频率</strong>，它衡量与所有其他文档相比，一个术语对于语料库中特定文档的意义/内容有多重要。众所周知，某些术语，如“is”、“of”和“that”，可能会在大多数文档中非常频繁地出现，但这并没有给我们任何关于这些常用词对特定文档含义的重要性的信息。因此，我们需要通过计算以下各项来降低过于频繁的术语的权重，同时增加仅特定于少量文档的罕见术语的权重:</p><ul class=""><li id="7e26" class="kw kx iu ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka iv"> IDF </strong> = log_e(文档总数/其中包含术语 t 的文档数)。</li></ul><p id="4861" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">在对所有歌词进行词干化和词汇化并创建特征 TF-IDF 矩阵后，我们发现自己拥有了一个最终的熊猫数据帧，该数据帧有<strong class="ka iv">7200 行</strong>和<strong class="ka iv"> 30，000 </strong> <strong class="ka iv">列</strong>。每一行代表一个特定的歌词，每一列是一个唯一的单词及其对应的 TF-IDF 值。</p><h2 id="f248" class="lk ll iu bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">培训和优化我们的模型</h2><p id="54bf" class="pw-post-body-paragraph jy jz iu ka b kb md kd ke kf me kh ki kj mk kl km kn ml kp kq kr mm kt ku kv in bi translated">我们想做的第一件事是测试我们的基本 ML 模型在处理词干化或词条化文本时是否表现得更好。我们训练和评估了多项式朴素贝叶斯、随机森林、AdaBoost、梯度增强和 K-最近邻的性能，使用词干和词条。下表显示了我们的结果:</p><figure class="mn mo mp mq gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gi gj gk"><img src="../Images/8206b6cd789cdfc36753c00aa7f4592b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFW80nad4G4fja-Ah-vv-A.png"/></div></div></figure><p id="c9bd" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们选择使用<strong class="ka iv">词汇化的单词</strong>而不是词干化的单词，因为当使用词汇化的文本时，每个模型的性能始终至少提高 1%。</p><p id="9fc8" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">从这里开始，我们选择关注我们的前三个模型- <strong class="ka iv">多项式朴素贝叶斯、梯度推进和随机森林的模型优化。</strong></p><p id="c57d" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们做的下一件事是<strong class="ka iv"> PCA </strong>，我们对我们的数据进行了一次测试，看看有多少组件可以保留 80%的变化。然后，我们在我们的前三个模型上运行 n_components = 1800 的<strong class="ka iv"> PCA，看看这是否提高了性能。下图显示了结果:</strong></p><figure class="mn mo mp mq gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gi gj mv"><img src="../Images/d109516edb0b77c4e8b096293343e54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*WikPGBUaXnA0CWEH3N41Ig.png"/></div></div></figure><p id="cfaf" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">从图中可以看出，PCA 在两种模型中都没有提高性能，所以我们决定不继续使用 PCA。</p><p id="a5fa" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">接下来我们要做的事情是<strong class="ka iv"> GridSearch </strong>三个表现最好的模型，并选择具有产生最高准确度分数的参数组合的模型。结果汇总如下:</p><ul class=""><li id="8be3" class="kw kx iu ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka iv">随机森林上的网格搜索</strong><strong class="ka iv"/>准确率从 41%提高到 43%。</li><li id="fc7a" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka iv">网格搜索</strong> <strong class="ka iv">上的梯度提升</strong>将性能精度从 45%提高到 50%。</li><li id="b3d2" class="kw kx iu ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka iv">朴素贝叶斯网格搜索</strong>上的网格搜索 <strong class="ka iv">没有产生改进的性能，因为默认参数是最优的。</strong></li></ul><h2 id="3468" class="lk ll iu bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">解释和传达最终结果:</h2><p id="1eeb" class="pw-post-body-paragraph jy jz iu ka b kb md kd ke kf me kh ki kj mk kl km kn ml kp kq kr mm kt ku kv in bi translated">下面你可以看到我们的前三个模型在使用 GridSearch 优化和超参数调整后的最终性能图。</p><figure class="mn mo mp mq gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gi gj mw"><img src="../Images/93c2cbb8949dcba3a62810303dbe2b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*EzsJNkxw_oZO8SEC8CQY0Q.png"/></div></div></figure><p id="f7d2" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">网格搜索后，我们的最高模型<strong class="ka iv"> GradientBoost 产生了 50%的准确性</strong>，这比随机猜测(从 8 个可能的类别中随机猜测一个类别= 1/8 或 12.5%)好了大约 4 倍。尽管 50%并不是一个很大的数字，但我们仍然对只有 7200 首歌词的情况印象深刻，我们能够训练一个模型，通过只扫描这首歌的歌词，就可以在 50%的时间内正确猜测这首歌属于什么类型。</p><p id="6cd6" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">通过对网格搜索和 PCA 优化的实验，我们发现多项式朴素贝叶斯是最快和最简单的开箱即用模型。在没有任何额外优化技术的情况下，它的准确率仅比顶级模型 GradientBoosted 分类器低 5%。</p><p id="8d0d" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">结论:</strong></p><p id="1d27" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">根据我们有趣的实验，似乎有一组特定于每种歌曲类型的词汇，可以允许人们训练一种 ML 算法，该算法可以仅通过分析歌词来猜测歌曲的类型。另一个有趣的发现是，NaiveBayes 分类器似乎可以立即生成非常强大的性能。因此，如果您正在处理一个非常大的文本数据集，其中的特征生成和模型优化被证明是计算量大且耗时的，那么您可能会选择使用朴素贝叶斯来简化和提高效率，而不会牺牲太多的性能。如果您有足够的时间和计算能力，并且希望尽可能地优化性能，那么在一系列集成模型(如随机 Fores 或 GradientBoosted 分类器)上运行网格搜索将是一个不错的选择。</p><p id="3b25" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated"><strong class="ka iv">有趣的附加功能:</strong> <em class="mj">使用无监督学习模型来识别每个流派的独特主题和关键词</em></p><p id="9c9b" class="pw-post-body-paragraph jy jz iu ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv in bi translated">我们使用 gensim.corpora.Dictionary 为词汇化、标记化的单词集创建了一个频率词典。我们从每个流派中抓取关键词，并生成主题模型分数。使用 Word2Vec 字典生成器，我们运行了一个主题建模 LDA 算法，并打印了下面每个流派中热门关键词的词云。</p><div class="mn mo mp mq gu ab cb"><figure class="mx jv my mz na nb nc paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/a2dfa6a8c0b775bc8ef1b596c7b28003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*8VuNwv77dpEp4l1tRqDeiA.png"/></div></figure><figure class="mx jv nd mz na nb nc paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/e4b20faebc18b8707d38f8d978e36440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*w5BvU-9Ozd0kwU5Ub3HaFg.png"/></div></figure></div><div class="ab cb"><figure class="mx jv ne mz na nb nc paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/6e9c9562a32375edfca62dc4fd3893f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*A0Q_HtQLRCWewF0Pa1jm6A.png"/></div></figure><figure class="mx jv nf mz na nb nc paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/9596e44af8cca561bf4fbaffb4f4ba73.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*tKvZAlt0fBmVFY_mMGw2YA.png"/></div></figure></div><div class="ab cb"><figure class="mx jv ng mz na nb nc paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/a45db14c600e9af950104f178c98d094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TG1dgkVahebE7kUqbz1e4w.png"/></div></figure><figure class="mx jv ng mz na nb nc paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/8ecd466e469036f03d2d6fe0e852987f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JRRoCG4Wy2lYKfo_YQ2IUQ.png"/></div></figure></div></div></div>    
</body>
</html>