<html>
<head>
<title>Geo-GraphQL with ElasticSearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带弹性搜索的 Geo-GraphQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geo-graphql-with-elasticsearch-b01a6bdf0dc8?source=collection_archive---------22-----------------------#2019-12-02">https://towardsdatascience.com/geo-graphql-with-elasticsearch-b01a6bdf0dc8?source=collection_archive---------22-----------------------#2019-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a6b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a7db10215bc3ca05ad13e9d5d3c3a81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ud39yqupB6g_A23y"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最近在<a class="ae kv" href="https://www.rigup.com/" rel="noopener ugc nofollow" target="_blank"> RigUp </a>举办了第二届黑客马拉松，我的团队获得了客户<em class="ls"> </em>类别的第一名！我们的解决方案包括定制的抓取器、队列、数据 ETL 和结果数据的查询。然后，我们编写了一个 React 应用程序来提供流畅的可视化来显示这些数据。📈由于我们只有 48 小时，我们的代码还没有准备好投入生产。</p><p id="8eb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程探索了我在空闲时间改进项目的方法。我决定编写一个<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务器来访问我们的<a class="ae kv" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank"> ElasticSearch </a>地理数据。我选择的语言是<a class="ae kv" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>，利用了<a class="ae kv" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> Akka Http </a>和<a class="ae kv" href="https://sangria-graphql.org/" rel="noopener ugc nofollow" target="_blank"> Sangria </a>库。应该注意的是，RigUp 不是 Scala 之家，只是 Scala 是我背景的一大部分。</p><p id="4f5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的黑客马拉松，我们为不同类型的文档建立了多个 ElasticSearch 索引，但是每个文档类型都有一个纬度和经度。这要求我们向 ElasticSearch 发出多个 API 请求，这意味着要复制大量的搜索逻辑。由于我们在地图上查看数据，我们利用了 Elastic 的<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-bounding-box-query.html" rel="noopener ugc nofollow" target="_blank">地理边界框查询</a>。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="d6f6" class="ly lz iq lu b gy ma mb l mc md">// Pseudocode<br/>fetch('/users', { geo_bounding_box, ...some_filter_here });<br/>fetch('/coffee-shops', { geo_bounding_box, ...other_filter });</span></pre><p id="0426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，我们希望创建一个简洁的 GQL 查询，其中地理边界框将传播到嵌套查询。在 geoSearch 下添加继承边界框变量的其他模型应该很容易:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">users and coffeeShops can access bbox variable</figcaption></figure><p id="06ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">$bbox 引用将指向我们在 graphiql 的查询变量窗格中定义的<code class="fe mg mh mi lu b">“bbox”</code>对象。我们过滤掉这个框之外的用户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><code class="fe mg mh mi lu b">“bbox”</code> variable as an object in the bottom <strong class="ak">Query Variables</strong> pane</figcaption></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><blockquote class="mq mr ms"><p id="8896" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">下面从<a class="ae kv" href="https://sangria-graphql.org/" rel="noopener ugc nofollow" target="_blank">桑格利亚汽酒文档</a>以及<a class="ae kv" href="https://www.howtographql.com/graphql-scala/0-introduction/" rel="noopener ugc nofollow" target="_blank"> HowToGraphQL Scala 教程</a>中获取<strong class="ky ir">重磅</strong>灵感。<strong class="ky ir">我们将创建 GraphQL 查询，根据名称和地理位置过滤用户和咖啡店。</strong></p></blockquote><h1 id="38a0" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">项目设置</h1><p id="79b5" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">所有最终代码都可以在<a class="ae kv" href="https://github.com/duanebester/gql-elastic-scala" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得</p><h2 id="59a8" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">弹性搜索</h2><p id="2ac4" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">最简单的设置是使用下面的 docker-compose 文件，或者在本地安装 Elastic 并在默认端口(9200)上运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跑步<code class="fe mg mh mi lu b">docker-compose up -d</code>应该能让你开始。确保您可以在浏览器中从 ElasticSearch 得到响应，网址为<a class="ae kv" href="http://localhost:9200/" rel="noopener ugc nofollow" target="_blank"> localhost:9200 </a></p><p id="b7f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要加载我们的测试用户和咖啡店，将目录切换到 scripts 文件夹并运行加载脚本:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="69e3" class="ly lz iq lu b gy ma mb l mc md">$ cd src/main/resources/scripts/<br/>$ ./load-test-data.sh</span></pre><p id="10a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到<a class="ae kv" href="http://localhost:9200/test-users/_search?pretty" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/test-users/_ search？pretty </a>应该会给你一个用户列表。</p><h2 id="4352" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">属国</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="2726" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">资源</h2><p id="62ff" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">让我们将<a class="ae kv" href="https://github.com/graphql/graphiql/blob/master/packages/examples/graphiql-cdn/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">graphiql.html</strong></a>添加到我们的资源目录中(在<code class="fe mg mh mi lu b">/src/main/resources</code>下)，这样我们就可以有一个操场来测试我们的 GraphQL 查询。我们将在下面看到一个路由，它将从资源目录中提供这个文件。</p><h1 id="8e73" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">主服务器</h1><p id="367b" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">只有两条路线:一个接受到/graphql 的 POST，另一个提供静态资源。现在，向 graphql 端点发出 POST 请求只会返回一个字符串。我们在<code class="fe mg mh mi lu b">/src/main/scala</code>下创建<code class="fe mg mh mi lu b">Main.scala</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="bfac" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">模型</h1><p id="14d2" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">模型可以分为几类:变量、响应和公共变量。变量是将被映射到 GraphQL 参数的类。这些响应将是来自 GraphQL 服务器的响应，并将直接绑定到 GraphQL 模式中。这些输入和输出之间可以共享公共模型，这一点很快就会清楚。</p><p id="fa94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加一个包含嵌套目录和类的模型文件夹，如下所示:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="08d0" class="ly lz iq lu b gy ma mb l mc md">    ├── Main.scala<br/>    └── models<br/>        ├── common<br/>        │   └── Location.scala<br/>        ├── responses<br/>        │   ├── CoffeeShop.scala<br/>        │   ├── SearchResponse.scala<br/>        │   └── User.scala<br/>        └── variables<br/>            ├── BBox.scala<br/>            └── Filter.scala</span></pre><h2 id="664c" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">普通的</h2><p id="a47d" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated"><code class="fe mg mh mi lu b">Location</code>是一个简单的 case 类，具有<em class="ls">纬度</em>和<em class="ls">经度</em>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="399f" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">变量</h2><p id="9071" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">让我们建立我们的边界框和过滤器类。<code class="fe mg mh mi lu b">BBox</code>以两个<code class="fe mg mh mi lu b">Location</code>对象<em class="ls">左上方</em>和<em class="ls">右下方</em>为属性，Filter 以可选<code class="fe mg mh mi lu b">BBox</code>和可选<code class="fe mg mh mi lu b">String</code>对象为属性。<em class="ls">顶部左侧</em>和<em class="ls">底部右侧</em>与我们屏幕上渲染地图的角落相关。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="62dd" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">反应</h2><p id="edf6" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">让我们创建一个通用的<code class="fe mg mh mi lu b">SearchResponse</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="7571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe mg mh mi lu b">User</code>案例类将有<em class="ls">名称、</em>和<em class="ls">位置</em>属性。位置属性将是一个类型为<code class="fe mg mh mi lu b">Location</code>的对象。</p><p id="b5f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mg mh mi lu b">UsersResponse</code> case 类将包含一个<em class="ls">总计</em>属性和一个用户列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="affc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lu b">CoffeeShop</code>和<code class="fe mg mh mi lu b">CoffeeShopResponse</code>模型与用户和用户响应模型非常相似:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="3a7f" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">核心代码</h1><p id="eb0b" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">让我们继续在<code class="fe mg mh mi lu b">/src/main/scala</code>中创建/添加以下文件</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="21b0" class="ly lz iq lu b gy ma mb l mc md">├── Elastic.scala<br/>├── GraphQLSchema.scala<br/>├── GraphQLServer.scala<br/>├── Main.scala<br/>└── models</span></pre><h2 id="2b42" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">GraphQL 模式</h2><p id="b480" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">要深入了解 Sangria 和 GraphQL 模式定义，请参阅<a class="ae kv" href="https://sangria-graphql.org/learn/#schema-definition" rel="noopener ugc nofollow" target="_blank"> Sangria 文档</a></p><p id="0709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将模型与一个 GraphQL 模式联系起来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="0c80" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">弹性搜索</h2><p id="5347" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">在<a class="ae kv" href="https://www.howtographql.com/graphql-scala/0-introduction/" rel="noopener ugc nofollow" target="_blank"> HowToGraphQL 教程</a>中，作者使用 Slick 和内存中的 H2 数据库来保存和查询数据。我们将使用橡皮筋。我们创建一个特征来保存我们的弹性配置和方法(使得测试更容易):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="811d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将添加一个实现这个特征和我们定义的方法的类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><blockquote class="mq mr ms"><p id="27de" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">Sangria 有一个随 GraphQL 查询流动的上下文概念。这对我们的用例非常重要，因为它将保存我们的弹性类和 BBox 变量的实例。</p></blockquote><p id="b7ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<code class="fe mg mh mi lu b">GraphQLSchema.scala</code>中将我们的上下文定义为一个简单的 case 类:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="a0b6" class="ly lz iq lu b gy ma mb l mc md">case class MyContext(elastic: Elastic, bbox: Option[BBox] = None)</span></pre><h2 id="6159" class="ly lz iq bd mx ns nt dn nb nu nv dp nf lf nw nx nh lj ny nz nj ln oa ob nl oc bi translated">GraphQL 服务器</h2><p id="152b" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在我们将创建一个 GraphQL 服务器，它将拥有一个 Akka Http <code class="fe mg mh mi lu b">Route</code>和一个我们的<code class="fe mg mh mi lu b">Elastic</code>类的实例。下面的端点方法获取一个<code class="fe mg mh mi lu b">JsValue</code>，解析它，并返回一个<code class="fe mg mh mi lu b">Route</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="88ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会看到我们打电话给<code class="fe mg mh mi lu b">executeGraphQLQuery</code>。让我们接下来构建它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="bfc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是我们传递弹性实例以及之前定义的<code class="fe mg mh mi lu b">GraphQLSchema.SchemaDefinition</code>的地方。让我们不要忘记更新<code class="fe mg mh mi lu b">Main.scala</code>来将请求路由到我们的 GraphQLServer:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="e617" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">测试我们的设置</h1><p id="522f" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">为了运行我们的服务器，我们使用 sbt。从根目录:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2d43" class="ly lz iq lu b gy ma mb l mc md">$ sbt ~reStart</span></pre><p id="10e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到<a class="ae kv" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> localhost:8080 </a>并输入我们的查询和 bbox 变量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/683a01950472e3a09e886f67737cea71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35GDi-qCRodzf_k8kPC-qw.png"/></div></div></figure><p id="f622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用以下边界框坐标进行搜索时，我们将看到从查询中返回 3 个用户。所有这些用户都位于德克萨斯州的奥斯汀。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="8b21" class="ly lz iq lu b gy ma mb l mc md">{<br/>  "data": {<br/>    "geoSearch": {<br/>      "users": {<br/>        "hits": [<br/>          {<br/>            "id": 3,<br/>            "name": "Ricky", <br/>            "location": ...<br/>          },<br/>          {<br/>            "id": 4,<br/>            "name": "Carter", <br/>            "location": ...<br/>          },<br/>          {<br/>            "id": 5,<br/>            "name": "Mitch", <br/>            "location": ...<br/>          }<br/>        ]<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们调整边界框来覆盖更多的区域:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="657f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到第四个用户，他正好在加利福尼亚州的圣地亚哥:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="7103" class="ly lz iq lu b gy ma mb l mc md">{<br/>  "id": 1,<br/>  "name": "Duane", <br/>  "location": {<br/>    "lat": "32.715736",<br/>    "lon": "-117.161087"<br/>  }<br/>}</span></pre><p id="9f7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最后一次调整边界地理框:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在🇲🇽墨西哥城看到了我们的第五个也是最后一个用户</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="0058" class="ly lz iq lu b gy ma mb l mc md">{<br/>  "name": "Matt",<br/>  "id": 2,<br/>  "location": {<br/>    "lat": "19.42847",<br/>    "lon": "-99.12766"<br/>  }<br/>}</span></pre><h1 id="cae0" class="mw lz iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">扩展我们的设置</h1><p id="2611" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">难题的最后一部分是添加一个额外的字段来搜索和过滤我们的用户。我们将添加一个名称过滤器，这样我们就可以进行如下查询:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="4c4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了按名称过滤，让我们更新<code class="fe mg mh mi lu b">Elastic.scala</code>中的<code class="fe mg mh mi lu b">buildQuery</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="debe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们从上面运行新的查询，我们将只看到 Matt 和 Mitch 返回！非常容易添加新功能。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="bd8e" class="ly lz iq lu b gy ma mb l mc md">{<br/>  "data": {<br/>    "geoSearch": {<br/>      "users": {<br/>        "hits": [<br/>          {<br/>            "id": 2,<br/>            "name": "Matt",<br/>            "location": {<br/>              "lat": "19.42847",<br/>              "lon": "-99.12766"<br/>            }<br/>          },<br/>          {<br/>            "id": 5,<br/>            "name": "Mitch",<br/>            "location": {<br/>              "lat": "30.366666",<br/>              "lon": "-97.833330"<br/>            }<br/>          }<br/>        ],<br/>        "total": 2<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="c93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，假设我们希望在地理框中搜索名称以“M”开头的用户，以及该地区名称为“Starbucks”的咖啡店</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="92f0" class="ly lz iq lu b gy ma mb l mc md">{<br/>  "data": {<br/>    "geoSearch": {<br/>      "users": {<br/>        "hits": [<br/>          {<br/>            "id": 2,<br/>            "name": "Matt",<br/>            "location": {<br/>              "lat": "19.42847",<br/>              "lon": "-99.12766"<br/>            }<br/>          },<br/>          {<br/>            "id": 5,<br/>            "name": "Mitch",<br/>            "location": {<br/>              "lat": "30.366666",<br/>              "lon": "-97.833330"<br/>            }<br/>          }<br/>        ],<br/>        "total": 2<br/>      },<br/>      "coffeeShops": {<br/>        "hits": [<br/>          {<br/>            "name": "Starbucks"<br/>          },<br/>          {<br/>            "name": "Starbucks"<br/>          }<br/>        ],<br/>        "total": 2<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="28c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以快速将一个简单的 React 应用程序与<a class="ae kv" href="https://github.com/alex3165/react-mapbox-gl" rel="noopener ugc nofollow" target="_blank"> Mapbox </a>和<a class="ae kv" href="https://www.apollographql.com/docs/react/get-started/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>连接起来，以显示我们的一些数据(<a class="ae kv" href="https://github.com/duanebester/gql-elastic-app" rel="noopener ugc nofollow" target="_blank">源代码</a>):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/0e913b467b0870f2aab8c95578b106ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vNHlC35Ab8gYuBMthklAww.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Display our users within the map’s bounding box</figcaption></figure><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="acd2" class="ly lz iq lu b gy ma mb l mc md">npx create-react-app gql-elastic-app<br/>cd gql-elastic-app/<br/>npm install apollo-boost @apollo/react-hooks graphql<br/>npm install react-mapbox-gl mapbox-gl --save</span></pre><p id="5186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始我们的<code class="fe mg mh mi lu b">UserFeatures</code>组件，它将把我们的用户映射到 Mapbox 特性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="86aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们添加 GraphQL 查询字符串:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="2dc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在应用程序组件中设置 Mapbox:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="02cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在轮到阿波罗了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3ccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要为地图的边界框添加一些状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个快速实用函数，将地图框的<code class="fe mg mh mi lu b">Bounds</code>对象转换成我们自己的<code class="fe mg mh mi lu b">BBox</code>对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="cbf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们添加了两个处理程序，它们接收地图事件并更新我们的本地状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该应用程序会像上面的 GIF 一样将你放大到德克萨斯州的奥斯汀，并将显示 3 个用户。如果我们将地图移到圣地亚哥，我们会看到第四个用户:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/9d54027a212e6a3182dc5d91c1bf689d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cud1qBCB2et84frCd_EpQ.png"/></div></div></figure><p id="2b9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也应该看到我们在墨西哥城的第 5 位用户！如果你一直跟随，你会注意到一个 CORS 错误。这是一个简单的修复方法，已在回购的<code class="fe mg mh mi lu b"><a class="ae kv" href="https://github.com/duanebester/gql-elastic-scala/blob/master/src/main/scala/Main.scala#L44" rel="noopener ugc nofollow" target="_blank">Main.scala</a></code> <a class="ae kv" href="https://github.com/duanebester/gql-elastic-scala/blob/master/src/main/scala/Main.scala#L44" rel="noopener ugc nofollow" target="_blank">中解决。</a></p><p id="94ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢用 GraphQL &amp; ElasticSearch 进行地理搜索！所有的代码都是开源的。😎欢迎 PRs、评论等！</p><p id="be01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Scala 后端代码—<a class="ae kv" href="https://github.com/duanebester/gql-elastic-scala" rel="noopener ugc nofollow" target="_blank">https://github.com/duanebester/gql-elastic-scala</a></p><p id="ccb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反应前端代码—<a class="ae kv" href="https://github.com/duanebester/gql-elastic-app" rel="noopener ugc nofollow" target="_blank">https://github.com/duanebester/gql-elastic-app</a></p></div></div>    
</body>
</html>