<html>
<head>
<title>Markov Ventures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">马尔科夫风险投资公司</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/markov-ventures-generating-venture-firms-using-markov-chains-d3e68295d154?source=collection_archive---------24-----------------------#2019-01-15">https://towardsdatascience.com/markov-ventures-generating-venture-firms-using-markov-chains-d3e68295d154?source=collection_archive---------24-----------------------#2019-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="50e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用马尔可夫链生成风险投资公司名称的探索</h2></div><p id="c8c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">风险投资家在命名方面不是很有创意，所以我决定尝试使用马尔可夫链来生成一些名字。(我是帮手。)</p><p id="9e5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我尝试了数据科学<a class="ae lb" rel="noopener" target="_blank" href="/simulating-text-with-markov-chains-in-python-1a27e6d13fc6">中描述的普通马尔可夫链</a>。基本上，我把我的投资者姓名数据集转化成一个配对列表。所以如果我们有:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ab09" class="ll lm iq lh b gy ln lo l lp lq">Sequoia Capital<br/>Union Square Ventures<br/>GV (Google Ventures)</span></pre><p id="f852" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终会得到:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4190" class="ll lm iq lh b gy ln lo l lp lq">('Sequoia', 'Capital')<br/>('Union', 'Square')<br/>('Square', 'Ventures')<br/>('GV', '(Google')<br/>('(Google', 'Ventures)')</span></pre><p id="3a00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们根据第一个单词分组，找出所有可能的转换。例如，从我的未删节数据集:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a8c2" class="ll lm iq lh b gy ln lo l lp lq">'Sequoia': [<br/>  'Capital',  <br/>  'Financial',  <br/>  'National',  <br/>  'Capital',  <br/>  'Capital',  <br/>  'Capital',  <br/>  'Capital',  <br/>  'Scout', <br/>  'Apps',  <br/>  'Investment',  <br/>  'Capital',  <br/>  'Energy',  <br/>  'Private',<br/>  'Capital',<br/>  'Capital',<br/>  'Apps',<br/>  'Capital',<br/>  'Capital',<br/>  'Capital',<br/>  'Capital'<br/>]</span></pre><p id="7424" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我等待循环突突地创建所有这些重复的列表时，我的眼睛开始抽搐。这可以做得更好。</p><p id="edd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管怎样，现在您可以选择一个起始单词(比如“Benchmark”)，然后从列表中随机选择一个与“Benchmark”配对的单词，以获得名称中的下一个可能的单词。然后在某个时候你切断了它。</p><p id="a21f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的结果并非不切实际:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="7175" class="ll lm iq lh b gy ln lo l lp lq">Adler &amp; Jack W. Baird Capital  # 5 words<br/>Dongxing Capital Corp Equity  # 4 words<br/>Sage Hill Angels  # 3 words</span></pre><p id="2fb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…但我认为我们可以做得更好。</p><h1 id="648f" class="lr lm iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">改进算法</h1><p id="27a9" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">首先，我们随机选择第一个单词。由于大约 50%的风险投资家的名字中有“合伙人”、“资本”、“基金”或一些类似的样板词，很可能我们会以第一个词“LLC”或其他什么结束。因此，我们应该有一些“开始词”的概念，所以我们将来只从那个集合中选择。</p><p id="9697" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样困扰我的是，我必须明确地说出我希望名字有多长:当你到了“LP”的时候，你可以很确定这个名字已经结束了。因此，让我们添加一个“停用词”的概念。</p><p id="2f98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，大部分代码和时间都花在了将<some word="">到<likely next="" word="">的图形硬塞进 dict 中。让我们使用 networkx，而不是我们自己来管理。</likely></some></p><p id="c9f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">修改后的配对生成看起来像:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f835" class="ll lm iq lh b gy ln lo l lp lq">import networkx as nx</span><span id="bd3d" class="ll lm iq lh b gy mn lo l lp lq">graph = nx.DiGraph()<br/>START_WORD = '---START---'<br/>STOP_WORD = '---STOP---'</span><span id="6659" class="ll lm iq lh b gy mn lo l lp lq">def AddPair(start, stop):<br/>  """Add an edge to the graph (or increment the weight of an existing edge)."""<br/>  if start in graph and stop in graph[start]:<br/>    graph[start][stop]['weight'] = graph[start][stop]['weight'] + 1.0<br/>  else:<br/>    graph.add_edge(start, stop, weight=1.0)</span><span id="354b" class="ll lm iq lh b gy mn lo l lp lq">def AddName(name):<br/>  words = name.split(' ')<br/>  AddPair(START_WORD, words[0])<br/>  for i in range(0, len(words)-1):<br/>    AddPair(words[i], words[i+1])<br/>  AddPair(words[-1], STOP_WORD)</span><span id="5b45" class="ll lm iq lh b gy mn lo l lp lq">investors.name.apply(AddName)</span></pre><p id="765c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…这只需要运行时间的一小部分。另一个好处是你可以生成漂亮的图表:</p><figure class="lc ld le lf gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mo"><img src="../Images/59dee6d8c7ac095bc36352a4e639e844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvDW8OvMYuBzJed_XX_BwQ.png"/></div></div></figure><p id="0c13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，有点漂亮。</p><p id="ef9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以从<code class="fe mw mx my lh b">START_WORD</code>开始，随机选择一条路径，直到到达<code class="fe mw mx my lh b">STOP_WORD</code>:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="6829" class="ll lm iq lh b gy ln lo l lp lq">def GenerateVc():<br/>  name = []<br/>  current_word = ChooseNext(START_WORD)<br/>  while current_word != STOP_WORD:<br/>    name.append(current_word)<br/>    current_word = ChooseNext(current_word)<br/>  return ' '.join(name)</span></pre><p id="8276" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my lh b">ChooseNext</code>会取一个词，根据边权重随机选择。<code class="fe mw mx my lh b">numpy</code>有一个很好的<code class="fe mw mx my lh b">np.random.choice</code>方法，它采用一个概率数组，但是这些概率的总和必须是 1。首先，我要遍历所有的边，缩小权重，作为概率。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="8c55" class="ll lm iq lh b gy ln lo l lp lq">def NormalizeWeights():<br/>  for start in graph:<br/>    total_weight = graph.out_degree(start, weight='weight')<br/>    for stop in graph.successors(start):<br/>      graph[start][stop]['weight'] = graph[start][stop]['weight'] / total_weight</span></pre><p id="33ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用这些权重实现<code class="fe mw mx my lh b">ChooseNext</code>:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="af7e" class="ll lm iq lh b gy ln lo l lp lq">def ChooseNext(word):<br/>  next_words = list(graph.successors(word))<br/>  weights = [graph[word][n]['weight'] for n in next_words]<br/>  return np.random.choice(next_words, p=weights)</span></pre><p id="6325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe mw mx my lh b">GenerateVc</code>来创建一个不错的 VC 名称数组:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="fea7" class="ll lm iq lh b gy ln lo l lp lq">for i in range(0, 20):<br/>  print(GenerateVc())</span><span id="1b35" class="ll lm iq lh b gy mn lo l lp lq"># Produces:<br/>Cream City Digital Farm Ventures LLC <br/>INESA Venture Fund LLC <br/>Koms Co. Ltd. <br/>Startup Lab <br/>Japan Securities Investment Management Co. Ltd. <br/>Novestra <br/>Desert Sky Venture Capital Partners Co Ltd <br/>Vuzix <br/>Warren Citrin Impact Partners <br/>Advantage Capital Partners <br/>Genesis Campus, a Day <br/>Denota Ventures LLC <br/>Main Street Capital <br/>Dry Canyon Creek Capital <br/>Cenes Immo <br/>Sheffield University of Iowa Capital Partners <br/>Hamilton Portfolio Ltd. <br/>CSC <br/>Brocade Communications <br/>BPL Global Health &amp; Associates</span></pre><p id="e6e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听起来差不多。</p></div></div>    
</body>
</html>