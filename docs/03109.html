<html>
<head>
<title>Getting started with Apache Cassandra and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Cassandra 和 Python 入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-apache-cassandra-and-python-81e00ccf17c9?source=collection_archive---------2-----------------------#2019-05-19">https://towardsdatascience.com/getting-started-with-apache-cassandra-and-python-81e00ccf17c9?source=collection_archive---------2-----------------------#2019-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4165222209dc1e0ac5fd7637eb6b680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yluBx-0hOMU3djHf.png"/></div></div></figure><p id="c9fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将谈论 Apache Cassandra，它的用途、用法、配置和设置集群，最后，你如何在你的 Python 应用程序中访问它。在这篇文章的最后，你应该对 Cassandra 有了一个基本的了解，以及如何在你的 Python 应用中使用它。</p><h1 id="e209" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是阿帕奇卡珊德拉？</h1><p id="5455" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">根据维基百科:</p><blockquote class="lz ma mb"><p id="7e96" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated">Apache Cassandra 是一个免费的开源分布式宽列存储 NoSQL 数据库管理系统，旨在处理许多商用服务器上的大量数据，提供无单点故障的高可用性。Cassandra 为跨多个数据中心的集群提供了强大的支持，[1]异步无主机复制允许所有客户端进行低延迟操作。</p></blockquote><p id="fda8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两位脸书工程师开发的 Cassandra 用于处理收件箱的搜索机制。后来，脸书将其作为谷歌代码的开源项目发布，过了一段时间，它被移交给阿帕奇基金会。许多知名公司都在使用 Cassandra，比如网飞、苹果、天气频道、易贝等等。它的分散性(无主系统)、容错性、可伸缩性和持久性使其优于竞争对手。让我们讨论一下它的架构，如果你愿意，你可以跳到安装和设置部分。我建议你浏览一下架构部分，因为它会让你知道为什么你会想使用它。</p><h1 id="77bd" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">卡桑德拉建筑</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/3e272aab908fa97495e7fce0ba50f125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vy9ai8zJiZoVDRte.jpg"/></div></div></figure><p id="0921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cassandra 架构由以下组件组成:</p><h2 id="6b7f" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">结节</h2><p id="b150" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">它是数据的基本组成部分，是存储数据的机器</p><h2 id="6845" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">资料处理中心</h2><p id="aac4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">相关节点的集合。它可以是物理数据中心或虚拟数据中心</p><h2 id="4659" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">串</h2><p id="1ab6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个集群包含一个或多个数据中心，它可以跨越多个位置。</p><h2 id="232e" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">提交日志</h2><p id="7ed4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">每个写操作首先存储在提交日志中。它用于崩溃恢复。</p><h2 id="8684" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">记忆表</h2><p id="b75a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将数据写入提交日志后，它会存储在 Mem-Table(内存表)中，直到达到阈值。</p><h2 id="1a21" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">表</h2><p id="3b60" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Sorted-String Table 或 SSTable 是一个磁盘文件，它在 MemTable 达到阈值时存储其中的数据。表按顺序存储在磁盘上，并为每个数据库表进行维护。</p><h1 id="2604" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">写操作</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/66ef06c0d1f06b0b80925e29aa1485ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*hjeKsuSdZ4vzcqzg.jpg"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Write Operation Flow</figcaption></figure><ul class=""><li id="a3fd" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">一旦收到写请求，它首先被转储到提交日志中，以确保数据被保存。</li><li id="62c1" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">数据还被写入 MemTable，这是一个内存系统，它保存数据直到填满。</li><li id="ca17" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">一旦 MemTable 达到其阈值，其数据就会被刷新到 SS 表中。</li></ul><p id="ce8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接受写请求的节点被称为用于特定操作的<strong class="ka ir">协调器</strong>。它充当发送请求的客户端和其他节点之间的代理。然后，协调器根据集群配置确定环中的哪个节点应该接收该数据。</p><p id="8c61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mc">一致性级别</em>决定了有多少节点会用成功确认来回应。</p><h1 id="2b3a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">读取操作</h1><p id="800d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">协调器可以向副本发送三种类型的读取请求:</p><ol class=""><li id="9a52" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv nr nj nk nl bi translated"><strong class="ka ir">直接请求:- </strong>协调器节点向其中一个副本发送读取请求。之后，向其他副本发送一个摘要请求，以确定返回的数据是否是更新的数据。</li><li id="94f3" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nr nj nk nl bi translated"><strong class="ka ir">摘要请求:</strong>协调器联系由一致性级别指定的复制品。被联系的节点用所需数据的摘要请求来响应。每个副本中的行在内存中进行比较，以确保一致性。如果它们不一致，协调器将使用具有最新数据(时间戳)的副本将结果转发回客户端。</li><li id="414b" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nr nj nk nl bi translated"><strong class="ka ir">读取修复请求:</strong>如果节点上的数据不一致，将启动后台读取修复请求，以确保节点上的最新数据可用。</li></ol><h1 id="7542" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据复制策略</h1><p id="627f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">数据复制是一项必不可少的功能，以确保不会因硬件或网络故障而丢失数据。复制策略决定在哪些节点上放置副本。Cassandra 提供了两种不同的复制策略。</p><p id="bc1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">简单策略</strong></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/507502bffc7a444c35d6452bdf6b15f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*L67iu1vU9JJh5XGB.jpg"/></div></figure><p id="3dfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您只有一个数据中心时，使用 SimpleStrategy。它将第一个副本放在由<em class="mc">分区器</em>选择的节点上。分割器决定数据如何在集群中的节点之间分布(包括副本)。之后，剩余的副本以顺时针方向放置在节点环中。</p><p id="af64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">网络拓扑策略</strong></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/309a2498c66e8f3c3c635a51e277be74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dQ4mjqAC2RzR4sMz.jpg"/></div></div></figure><p id="7e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您跨多个数据中心进行部署时，会用到它。该策略通过顺时针遍历环，直到到达另一个机架中的第一个节点，将副本放置在同一数据中心。这是因为机架中有时会出现故障或问题。那么其他节点上的副本可以提供数据。出于可伸缩性和未来扩展的目的，强烈建议采用这种策略。</p><p id="6fd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，理论讨论够了，来点实际的吧。</p><h1 id="d39d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安装和设置</h1><p id="cb70" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你可以从<a class="ae mg" href="http://cassandra.apache.org/download/" rel="noopener ugc nofollow" target="_blank">官方网站</a>下载该软件包，并以单一模式运行用于开发目的，但它不会帮助你了解 Cassandra 的真正实力，因为它的行为就像任何其他数据库一样。因此，我将使用它的 docker 版本，其中我将设置一个包含两个节点的集群。</p><p id="f0d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="mc">注意:在开始之前，请确保将 Docker 内存设置为至少 4GB，否则容器会以错误代码 137 退出。由于内存资源不足，我花了一个小时才发现这个错误。</em>T19】</strong></p><p id="9637" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你的机器上创建一个文件夹，就像我创建的<code class="fe nu nv nw nx b">/Development/PetProjects/CassandraTut/data</code>。在这个文件夹中，我创建了两个子文件夹来存储两个节点的数据。完成后，它将如下所示:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="6b0b" class="mm kx iq nx b gy oc od l oe of">➜  data tree -a</span><span id="446f" class="mm kx iq nx b gy og od l oe of">.</span><span id="5845" class="mm kx iq nx b gy og od l oe of">├── node1</span><span id="3622" class="mm kx iq nx b gy og od l oe of">└── node2</span><span id="9fba" class="mm kx iq nx b gy og od l oe of">2 directories, 1 file</span></pre><p id="e00a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">留在同一个文件夹，运行命令<code class="fe nu nv nw nx b">docker pull cassandra</code>下载<a class="ae mg" href="https://hub.docker.com/_/cassandra" rel="noopener ugc nofollow" target="_blank">官方镜像</a>。如果你是 docker 的新手，那么你应该看看我在 Docker 系列<a class="ae mg" href="http://blog.adnansiddiqi.me/tag/docker/" rel="noopener ugc nofollow" target="_blank">的帖子。一旦下载完毕，<code class="fe nu nv nw nx b">docker images</code>命令就会显示在你的终端上。确保 docker 已安装并正在运行。此外，您必须给 Cassandra 存储数据的文件夹写权限。</a></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/89c8c00537765b7d546eb5a881029ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HDFibQVXW82DwGLR.png"/></div></div></figure><p id="9073" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将设置两个节点:<strong class="ka ir"> Node1 </strong>为主节点，<strong class="ka ir"> Node2 </strong>为<em class="mc">种子节点</em>。种子在启动过程中用于发现集群。让我们运行第一个节点。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="4078" class="mm kx iq nx b gy oc od l oe of">docker run --name cas1 -p 9042:9042 -v /Development/PetProjects/CassandraTut/data/node1:/var/lib/cassandra/data -e CASSANDRA_CLUSTER_NAME=MyCluster -e CASSANDRA_ENDPOINT_SNITCH=GossipingPropertyFileSnitch -e CASSANDRA_DC=datacenter1 -d cassandra</span></pre><p id="06dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多环境变量是不言自明的，我将讨论<code class="fe nu nv nw nx b">CASSANDRA_ENDPOINT_SNITCH</code></p><p id="2aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">告密者决定卡珊德拉如何分发复制品。这个飞贼推荐生产。<code class="fe nu nv nw nx b">GossipingPropertyFileSnitch</code>在添加新节点时使用<a class="ae mg" href="https://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archGossipAbout.html" rel="noopener ugc nofollow" target="_blank">八卦协议</a>自动更新所有节点，建议用于生产。运行以下命令了解节点的状态。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="10e4" class="mm kx iq nx b gy oc od l oe of">➜  data docker exec -it cas1  nodetool status<br/>Datacenter: datacenter1<br/>=======================<br/>Status=Up/Down<br/>|/ State=Normal/Leaving/Joining/Moving<br/>--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack<br/>UN  172.17.0.2  103.67 KiB  256          100.0%            bcb57440-7303-4849-9afc-af0237587870  rack1</span></pre><p id="5adb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nu nv nw nx b">UN</code>表示状态为<strong class="ka ir"> U </strong> p 和<strong class="ka ir"> N </strong>正常。当其他节点加入时，您可能会看到状态 UJ，这意味着<strong class="ka ir"> U </strong> p 和<strong class="ka ir"> J </strong>正在加入。我正在使用<code class="fe nu nv nw nx b">docker run</code>的<code class="fe nu nv nw nx b">-d</code>开关在后台运行它。另外，请注意<strong class="ka ir">节点 1 </strong>文件夹的内容。它创建默认的系统数据库，类似于 MySQL。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="4ae3" class="mm kx iq nx b gy oc od l oe of">➜  node1 ls<br/>system             system_auth        system_distributed system_schema      system_traces<br/>➜  node1</span></pre><p id="6154" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们运行第二个节点:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="2d55" class="mm kx iq nx b gy oc od l oe of">docker run --name cas2 -v /Development/PetProjects/CassandraTut/data/node2:/var/lib/cassandra/data -e CASSANDRA_SEEDS="$(docker inspect --format='{{ .NetworkSettings.IPAddress }}' cas1)" -e CASSANDRA_CLUSTER_NAME=MyCluster -e CASSANDRA_ENDPOINT_SNITCH=GossipingPropertyFileSnitch -e CASSANDRA_DC=datacenter1 -d cassandra:latest</span></pre><p id="272d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在设置了相关的容器名和数据中心后，您还可以将这里的<code class="fe nu nv nw nx b">CASSANDRA_SEEDS </code>设置为节点<code class="fe nu nv nw nx b">cas1</code>的 IP 地址，该节点可以使用<code class="fe nu nv nw nx b">docker inspect</code>命令获取。过一会儿，当您在<code class="fe nu nv nw nx b">cas1</code>中运行<code class="fe nu nv nw nx b">nodetool status</code>命令时，您应该会看到如下所示的内容:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/9bdb776422d9dfd87bd095685eb4ab48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_DO7xSi6LVjeNlb7.png"/></div></div></figure><p id="c5e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们的第二个节点正在加入集群，我们从状态<code class="fe nu nv nw nx b">UJ</code>中了解到这一点。</p><p id="e8c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你查看挂载的卷，<code class="fe nu nv nw nx b">node2</code>文件夹，你也会看到系统文件夹。</p><p id="3bf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从终端运行命令很烦人，因此我创建了一个<code class="fe nu nv nw nx b">docker-compose.yaml</code>文件来运行集群，没有任何麻烦。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了确保<code class="fe nu nv nw nx b">cas1</code>启动并运行，我让<code class="fe nu nv nw nx b">cas2</code>依赖于<code class="fe nu nv nw nx b">cas1</code>，并设置一个 60 秒的<code class="fe nu nv nw nx b">sleep</code>。</p><p id="9e45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我得到 RPC 错误<code class="fe nu nv nw nx b">INFO [main] 2019-05-14 01:51:07,336 CassandraDaemon.java:556 - Not starting RPC server as requested. Use JMX (StorageService-&gt;startRPCServer()) or nodetool (enablethrift) to start it</code>，所以我也调用<code class="fe nu nv nw nx b">CASSANDRA_START_RPC</code>环境参数，并将其设置为真。</p><p id="8a28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们运行<code class="fe nu nv nw nx b">docker-compose up -d</code>以在分离模式下运行。</p><p id="20fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可以看到的，第一个节点没有启动，第二个节点启动过程也没有启动。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/dc2e905cabdfb3373d94039aaec015fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wa243U-KAV0ItbeW.png"/></div></div></figure><p id="dbc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过了一会儿，两个节点都使用各自独特的 IP 启动。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/1d499bc5f8f97cee6aba61a751d673a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*APi-EXNHQTqBcvqH.png"/></div></div></figure><p id="b2b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有 Cassandra 配置文件都位于容器内的<code class="fe nu nv nw nx b">/etc/cassandra/</code>文件夹中。</p><p id="1521" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们运行 CQL 外壳。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="f7cc" class="mm kx iq nx b gy oc od l oe of">➜  CassandraTut docker exec -it cas2  cqlsh          <br/>Connected to MyCluster at 127.0.0.1:9042.<br/>[cqlsh 5.0.1 | Cassandra 3.11.4 | CQL spec 3.4.4 | Native protocol v4]<br/>Use HELP for help.<br/>cqlsh&gt;</span></pre><p id="c381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它类似于 MySQL shell。CQL，Cassandra 查询语言在语法上与 SQL 相似，但其用法与 RDBMS 系统不同。我们将很快对此进行更深入的研究。坚持住！</p><p id="f191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你注意到我已经在<code class="fe nu nv nw nx b">docker run</code>和<code class="fe nu nv nw nx b">docker compose</code>命令中公开了默认的 Cassandra 端口<code class="fe nu nv nw nx b">9042</code>。使用终端 like 并不吸引人，使用 GUI 客户端怎么样？我使用的是 SQL/NoSQL 客户端<a class="ae mg" href="https://tableplus.io/" rel="noopener ugc nofollow" target="_blank"> TablePlus </a>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/78d3c5e2dc14ea3d68f2bccc70f78b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*PE-hBRADKKlYolkv.png"/></div></figure><p id="7ff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦连接，您将看到默认的系统数据库。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/a05ffcabcc51e5e627539f02589ebd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_oIES9Xubg-OOIjO.png"/></div></div></figure><p id="9eee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在节点<code class="fe nu nv nw nx b">cas1</code>上创建一个测试密钥空间、数据库的 Cassandra 版本和一个表。别担心，我稍后会详细讨论。现在，我们的目的是告诉您数据是如何复制的。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/d5482430b2c466df0b1059df56b7f793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bUCzBgHEOueIATw7.png"/></div></div></figure><p id="5ab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将复制因子设置为 2，这意味着将有 2 份数据拷贝，每个节点一份。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/1bb020b7d4ff1ef39f4e814577920eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8gykf7JNDdVfQqQD.png"/></div></div></figure><p id="d309" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们连接到第二个节点。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/1d89f14be8c9359ea7116d76ae80a930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6r_Eea19aDjO1v3l.png"/></div></div></figure><p id="abbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意端口 9043。9042 已经分配给<code class="fe nu nv nw nx b">cas1</code>。</p><p id="e734" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧啊！我的密钥空间在这里也存在，它被很好地从<strong class="ka ir">案例 1 </strong>复制到<strong class="ka ir">案例 2 </strong></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/1f3608e2ce6e9abeee6b5a2abf96c92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QtLGDiTUwmPLemOJ.png"/></div></div></figure><p id="1bc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您在 Cas1 或 Cas2 上进行更改，它最终都会被传播。这并不类似于典型的主/从概念，而是被称为<em class="mc">无主</em>，因为整个系统是分散的，P2P 连接是在环中建立的(<em class="mc">它让你想起区块链了吗？</em>)</p><p id="57b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是数据建模概念和在 CQL 创建实体。</p><h1 id="ab19" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">卡珊德拉数据建模和 CQL</h1><p id="b802" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Cassandra 是一头野兽，不可能在这里涵盖数据建模的每个方面。因此，我将介绍一些基础知识，让您了解它与典型的关系数据库系统有何不同。尽管 CQL 看起来非常类似于 SQL 或基于 MySQL 的 SQL，但它根本不是 SQL。让自己做好准备，忘掉 RDBMS 的东西。</p><h2 id="5c22" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">术语</h2><p id="4cf5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">下面是 Cassandra 和 RDBMS world 的一点对比。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/7eff4cc4872fa9fff5ab154ce1ad50c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*Emp6hYVQCMvLUgDCXbcHgw.png"/></div></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/3c3308f6dd1d93d44f1b2979635cfb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*IRWxvYQBundQDVgy.jpg"/></div></figure><p id="c4bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Keyspace  :-它是列族的容器集合。你可以把它想象成 RDBMS 世界中的一个<em class="mc">数据库</em>。</p><p id="9cc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">列族:- </strong>列族是行的有序集合的容器。每一行又是列的有序集合。可以把它想象成 RDBMS 世界中的一个<em class="mc">表</em>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/fc5236cba231af1846467fbeb8ee903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*VcKBhg5fr3UJy-Fq.jpg"/></div></figure><p id="7bc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">行:- </strong>行是列的集合，按列排序。</p><p id="2c7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">列:- </strong>列是键/值对的集合。</p><p id="7e5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">行键:- </strong>主键叫做行键。</p><p id="604c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">复合主键:- </strong>主键由多列组成。该密钥一部分被称为分区密钥和剩余的簇密钥<em class="mc"/>。</p><p id="b198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分区键:-</strong>Cassandra 中的数据分布在各个节点上。分区键的目的是识别存储了被请求的特定行的节点。名为<em class="mc"> partition </em>的函数用于在写入行时计算分区键的哈希值。例如，<strong class="ka ir">节点 1 </strong>的键值范围从<em class="mc">1–10</em>，<strong class="ka ir">节点 2 </strong>包含<em class="mc">11–20</em>，<strong class="ka ir">节点 3 </strong>包含范围<em class="mc">21–30</em>。当执行带有 WHERE 子句的 SELECT 命令时，使用分区键的哈希值来查找所需的节点，一旦找到该节点，它就会获取数据并返回给客户端。例如，查询是<code class="fe nu nv nw nx b">SELECT * FROM users where id = 5</code>，假设分区键的哈希值(在本例中是 5)是 15，那么将会是<strong class="ka ir">节点 2 </strong>获得该行。下面是它的图示。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/bdb85a10a885b4313ef39e8e0f0f96cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*eTVGWo01oKQAMoQF.jpg"/></div></figure><p id="93b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来举个例子。您正在开发一个保存网站用户及其所在城市信息的系统。我们将创建一个名为 CityInfo 的密钥空间。你可以使用 CQLSH 或 TablePlus GUI，由你决定。</p><p id="916d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nu nv nw nx b">create keyspace CityInfo with replication = {'class' : 'SimpleStrategy', 'replication_factor':2}</code></p><p id="d2af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我有 2 个节点，所以我将<code class="fe nu nv nw nx b">replication_factor</code>设置为<code class="fe nu nv nw nx b">2</code>。</p><h1 id="176c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设计模型</h1><p id="aef2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在 RDBMS 中，我们有一个类似 JOINs 的工具，而编写并不便宜，因此我们通过在相关表中使用外键来避免重复。《卡珊德拉》就不是这样的。Cassandra 是一个分布式系统，编写起来很便宜，因此非常欢迎你在需要的地方去规范化数据。这有助于检索通常通过连接获取的数据。另一方面，数据读取可能会很昂贵，因为数据跨越多个节点并通过分区键检索。设计模型时，您应该记住以下目标:</p><ol class=""><li id="43f5" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv nr nj nk nl bi translated"><strong class="ka ir">在集群中均匀分布数据:- </strong>如果主键由单列组成，则主键是分区键，如果是复合主键，则主键是分区键和集群键。要平均分布数据，您必须为 PK 选择一个具有唯一性的列，这样就可以跨节点分布。像<em class="mc"> ID、用户名、</em>和<em class="mc"> email </em>这样的东西具有唯一性，会充分利用节点的集群。但是如果您使用像<em class="mc">名字/姓氏</em>、<em class="mc">性别</em>等这样的键，那么分区键的选择将会非常少，尽管有 100 个节点，但总是只有少数几个会被使用，从而使一个分区变得臃肿，性能降低。</li><li id="4a81" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nr nj nk nl bi translated"><strong class="ka ir">尽量减少读取次数:- </strong>正如我提到的，读取是很昂贵的。如果您以一种单个查询从多个分区获取的方式建模，将会使系统变慢。</li></ol><p id="e0b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，与 RDBMS 不同，在 RDBMS 中，您首先设计模式，然后根据您的需求自由地创建查询，而 Cassandra 却不是这样。你必须预先知道系统中需要的查询，然后相应地设计模型。</p><h2 id="86fb" class="mm kx iq bd ky mn mo dn lc mp mq dp lg kj mr ms lk kn mt mu lo kr mv mw ls mx bi translated">示例使用案例</h2><p id="a4a5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们有一个系统，不同城市的用户访问一个网站。管理层要求提供以下信息:</p><ol class=""><li id="e33d" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv nr nj nk nl bi translated">所有用户的列表</li><li id="fced" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nr nj nk nl bi translated">所有城市的列表。</li><li id="4393" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nr nj nk nl bi translated">按城市列出的用户列表</li></ol><p id="ec04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建<code class="fe nu nv nw nx b">cities</code>表。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="7b13" class="mm kx iq nx b gy oc od l oe of">CREATE TABLE cities (<br/> id int,<br/> name text,<br/> country text,<br/> PRIMARY KEY(id)<br/>);</span></pre><p id="d2b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后<code class="fe nu nv nw nx b">users</code></p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="28f1" class="mm kx iq nx b gy oc od l oe of">CREATE TABLE users (<br/> username text,<br/> name text,<br/> age int,<br/> PRIMARY KEY(username)<br/>);</span></pre><p id="6bfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插入几个城市。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="6946" class="mm kx iq nx b gy oc od l oe of">INSERT INTO cities(id,name,country) VALUES (1,'Karachi','Pakistan');<br/>INSERT INTO cities(id,name,country) VALUES (2,'Lahore','Pakistan');<br/>INSERT INTO cities(id,name,country) VALUES (3,'Dubai','UAE');<br/>INSERT INTO cities(id,name,country) VALUES (4,'Berlin','Germany');</span></pre><p id="93b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并插入一些用户</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="ecf1" class="mm kx iq nx b gy oc od l oe of">INSERT INTO users(username,name,age) VALUES ('aali24','Ali Amin',34);<br/>INSERT INTO users(username,name,age) VALUES ('jack01','Jack David',23);<br/>INSERT INTO users(username,name,age) VALUES ('ninopk','Nina Rehman',34);</span></pre><p id="f2da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些插入满足了我们的前两个要求，但是第三个要求呢？在 RDBMS 世界中，我们将使用<code class="fe nu nv nw nx b">city_id</code>作为<code class="fe nu nv nw nx b">users</code>表中的 FK，连接将很容易返回数据，但这是 Cassandra，我们不能这样做，剩下的是我们创建另一个表来满足我们的需求。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="912d" class="mm kx iq nx b gy oc od l oe of">CREATE TABLE users_by_cities (<br/> username text,<br/> name text,<br/> city text,<br/> age int,<br/> PRIMARY KEY(city,age)<br/>);</span></pre><p id="7607" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个主键有两个组成部分:第一个成为分区键，第二个成为簇键。它将查找 w . r . t . city，所有记录都按年龄分组。</p><p id="9ba6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在插入一些记录:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="90b5" class="mm kx iq nx b gy oc od l oe of">INSERT INTO users_by_cities(username,name,city,age) VALUES ('aali24','Ali Amin','Karachi',34);<br/>INSERT INTO users_by_cities(username,name,city, age) VALUES ('jack01','Jack David','Berlin',23);<br/>INSERT INTO users_by_cities(username,name,city, age) VALUES ('ninopk','Nina Rehman','Lahore',34);</span></pre><p id="185e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常情况下，在两个表中的这些插入会在“添加用户”界面中一次完成，从 CQL 端，您可以做类似这样的事情来添加用户信息。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="5127" class="mm kx iq nx b gy oc od l oe of">BEGIN BATCH<br/>INSERT into users(username,name,age) VALUES('raziz12','Rashid Aziz',34);<br/>INSERT INTO users_by_cities(username,name,city, age) VALUES ('raziz12','Rashid Aziz','Karachi',30);<br/>APPLY BATCH;</span></pre><p id="2886" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在继续之前，我想提醒您一下我之前讨论过的散列令牌。首先，在 CQL shell 上运行<code class="fe nu nv nw nx b">EXPAND ON</code>命令。一旦你这样做了，你会看到如下结果:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/03f6d554c2bcf678a12f0624c52138ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mjfXgi6s9xKvnv8E.png"/></div></div></figure><p id="b226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来不错，不是吗？好了，现在我们将看到我们的主键的令牌值。它返回以下结果:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="4d9d" class="mm kx iq nx b gy oc od l oe of">cqlsh:cityinfo&gt; select token(username) from users;</span><span id="c55b" class="mm kx iq nx b gy og od l oe of">@ Row 1<br/>------------------------+----------------------<br/> system.token(username) | -7905752472182359000</span><span id="5222" class="mm kx iq nx b gy og od l oe of">@ Row 2<br/>------------------------+----------------------<br/> system.token(username) | 2621513098312339776</span><span id="282a" class="mm kx iq nx b gy og od l oe of">@ Row 3<br/>------------------------+----------------------<br/> system.token(username) | 6013687671608201304</span></pre><p id="3b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有道理，令牌是唯一的，因为用户名是唯一的。这些令牌将跨节点传播。当用户运行命令<code class="fe nu nv nw nx b">SELECT * FROM users where username = 'raziz12'</code>时，它将根据这个令牌值选择节点。我已经在上面几行中展示过了。</p><p id="840b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的查询显示了来自<code class="fe nu nv nw nx b">users_by_cities</code>表的令牌值。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="2694" class="mm kx iq nx b gy oc od l oe of">cqlsh:cityinfo&gt; select token(username),username,city from users_by_cities;</span><span id="bb4c" class="mm kx iq nx b gy og od l oe of">@ Row 1<br/>------------------------+----------------------<br/> system.token(username) | 2621513098312339776<br/> username               | jack01<br/> city                   | Berlin</span><span id="d3d3" class="mm kx iq nx b gy og od l oe of">@ Row 2<br/>------------------------+----------------------<br/> system.token(username) | 6013687671608201304<br/> username               | ninopk<br/> city                   | Lahore</span><span id="f648" class="mm kx iq nx b gy og od l oe of">@ Row 3<br/>------------------------+----------------------<br/> system.token(username) | -882788003101376442<br/> username               | raziz12<br/> city                   | Karachi</span><span id="b1c7" class="mm kx iq nx b gy og od l oe of">@ Row 4<br/>------------------------+----------------------<br/> system.token(username) | -7905752472182359000<br/> username               | aali24<br/> city                   | Karachi</span></pre><p id="f7bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nu nv nw nx b">Select * from users_by_cities where city = 'Karachi';</code>返回以下内容:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="bc72" class="mm kx iq nx b gy oc od l oe of">cqlsh:cityinfo&gt; select * from users_by_cities where city = 'Karachi';</span><span id="01d2" class="mm kx iq nx b gy og od l oe of">@ Row 1<br/>----------+-------------<br/> city     | Karachi<br/> username | aali24<br/> name     | Ali Amin</span><span id="23e8" class="mm kx iq nx b gy og od l oe of">@ Row 2<br/>----------+-------------<br/> city     | Karachi<br/> username | raziz12<br/> name     | Rashid Aziz</span></pre><p id="674f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模型还服务于查询<code class="fe nu nv nw nx b">select * from users_by_cities where city = 'Karachi' and age = 34</code></p><p id="271e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果您想根据字段选择一条记录，该怎么办呢？</p><p id="3267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nu nv nw nx b">SELECT * from users_by_cities where name = 'Ali Amin';</code></p><p id="6310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会得到下面的错误。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="2b7d" class="mm kx iq nx b gy oc od l oe of">Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability</span></pre><p id="0a2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为没有提到分区键，Cassandra 要求在所有节点中搜索所需的名称，是的，所有节点，想象一下如果节点是 10 或 100，返回数据需要时间。因此不建议这样做。如果您想在 w.r.t 字段中找到一些东西，要么创建另一个表(强烈推荐)，要么创建一个二级索引(<em class="mc">不推荐</em>)</p><p id="f56a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据按城市分区，在查找时，一个节点用城市的令牌响应，一旦发现该节点，它就获取该分区中属于卡拉奇城市的用户的所有记录。对于与卡拉奇相关的数据聚类，也可以看到类似的情况。数据根据<em class="mc">年龄</em>列进行聚类。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/3e36d25db42992c04b31f9f802e26bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*gWQxCVmdVDr6PTj5.jpg"/></div></figure><p id="44c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以对于一个保存所有 Karachiites 记录的分区，你会看到记录的集群。</p><p id="0b81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你的脑袋一定在打转，会想念你心爱的 MySQL，但我告诉你，这是值得学习的东西，我也在学习，我只是触及了这个野兽的表面。</p><p id="fee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道这篇文章的标题提到了 Python，但是我听说到目前为止还没有写 Python 代码。有必要准备一个基础，因为您将只是在 Python 应用程序中执行查询。主要工作在别的地方，就在上面。</p><p id="2d33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，在我转向开发之前，我讨论过 Cassandra 最初在<strong class="ka ir"> <em class="mc"> Commitlog 中写数据。</em> </strong></p><p id="9ccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cassandra CommitLog 的路径可以从<code class="fe nu nv nw nx b">/etc/cassandra/cassandra.yaml</code>获得，也就是从<code class="fe nu nv nw nx b">/var/lib/cassandra/commitlog</code>获得，这里它创建了带有时间戳的日志文件。这是不可读的，但当我搜索一些插入的记录，然后发现一些痕迹。检查下面的屏幕:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/7924b4f0bfa610a15dcc543ea5a40855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k_vp84Tor774hc-Y.png"/></div></div></figure><p id="3dbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里找到<strong class="ka ir">杰克 01 </strong>、<strong class="ka ir">阿力、</strong>和<strong class="ka ir">尼诺普</strong>的踪迹。你也可以找到与修复机制相关的文字。</p><p id="8673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nu nv nw nx b">/var/lib/cassandra/data/&lt;keyspacename&gt;</code>可以找到桌子。我的情况是<code class="fe nu nv nw nx b">cityinfo</code></p><p id="b475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每个表/列族，它生成<code class="fe nu nv nw nx b">manifest.json</code>文件，一些<code class="fe nu nv nw nx b">*.db</code>和一些其他类型的文件，下面是表<code class="fe nu nv nw nx b">users_by_cities</code>表的文件。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="09f2" class="mm kx iq nx b gy oc od l oe of">./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/manifest.json<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-CompressionInfo.db<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-Data.db<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-Digest.crc32<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-Filter.db<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-Index.db<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-Statistics.db<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-Summary.db<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/md-1-big-TOC.txt<br/>./users_by_cities-62cea5f0788e11e9b568e709cd27ef9f/snapshots/truncated-1558089482008-users_by_cities/schema.cql</span></pre><p id="3ca5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里了解更多。</p><h1 id="b575" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">从 Python 访问 Cassandra</h1><p id="f2b4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">好的，首先，我们需要安装驱动程序。我在 docker shell 之外，因为我将从我的主机访问它。运行命令<code class="fe nu nv nw nx b">pip install cassandra-driver</code></p><p id="d02d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建驱动程序需要一段时间:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="eac9" class="mm kx iq nx b gy oc od l oe of">Requirement already satisfied: six&gt;=1.9 in /anaconda3/anaconda/lib/python3.6/site-packages (from cassandra-driver) (1.11.0)<br/>Building wheels for collected packages: cassandra-driver<br/>  Building wheel for cassandra-driver (setup.py) ... done<br/>  Stored in directory: /Users/AdnanAhmad/Library/Caches/pip/wheels/df/f4/40/941c98128d60f08d2f628b04a7a1b10006655aac3803e0e227<br/>Successfully built cassandra-driver<br/>Installing collected packages: cassandra-driver<br/>Successfully installed cassandra-driver-3.17.1</span></pre><p id="b99f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是从 Docker 中运行的 Python 脚本连接到 Docker 中的 Cassandra 集群的代码。</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="5501" class="mm kx iq nx b gy oc od l oe of">from cassandra.cluster import Cluster</span><span id="3753" class="mm kx iq nx b gy og od l oe of">if __name__ == "__main__":<br/>    cluster = Cluster(['0.0.0.0'],port=9042)<br/>    session = cluster.connect('cityinfo',wait_for_all_pools=True)<br/>    session.execute('USE cityinfo')<br/>    rows = session.execute('SELECT * FROM users')<br/>    for row in rows:<br/>        print(row.age,row.name,row.username)</span></pre><p id="3871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回了以下输出:</p><pre class="mi mj mk ml gt ny nx nz oa aw ob bi"><span id="7f4e" class="mm kx iq nx b gy oc od l oe of">➜  CassandraTut python cassandra_connect.py<br/>34 Ali Amin aali24<br/>34 Rashid Aziz raziz12<br/>23 Jack David jack01<br/>34 Nina Rehman ninopk<br/>➜  CassandraTut</span></pre><p id="98f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里了解更多信息</p><h1 id="f284" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="44d1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">所以在这篇文章中，你学习了一些关于 Cassandra 的知识，以及如何使用 CQL 并在你的 Python 脚本中连接它。请在下面留下您的评论，以便提出意见、更正或反馈。和往常一样，代码在<a class="ae mg" href="https://github.com/kadnan/PythonCassandraTutorial/" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="144e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mc">本帖原载</em> <a class="ae mg" href="http://blog.adnansiddiqi.me/getting-started-with-apache-cassandra-and-python/" rel="noopener ugc nofollow" target="_blank"> <em class="mc">此处</em> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>