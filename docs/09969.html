<html>
<head>
<title>Decorating functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的装饰函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decorating-functions-in-python-619cbbe82c74?source=collection_archive---------13-----------------------#2019-12-30">https://towardsdatascience.com/decorating-functions-in-python-619cbbe82c74?source=collection_archive---------13-----------------------#2019-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="026f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是高阶函数？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5ed6096e70def6dd9f1ed553476d4de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NiBn43iYhow3wDTTu7JQg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://pixabay.com/images/id-1149619/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="110c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释什么是 Python decorators，以及如何实现它。我们开始吧！</p><h1 id="1770" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是室内设计师？</h1><p id="461a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">装饰器只不过是一种调用高阶函数的舒适方式。你可能已经看过很多次了，它是关于那些“@dostuff”字符串的，你会不时地在函数的签名上面找到它们:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6573" class="mx lw it mt b gy my mz l na nb">@dostuff<br/>def foo():<br/>  pass</span></pre><p id="ae29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，但是现在，什么是高阶函数？高阶函数就是任何一个以一个(或多个)函数作为参数和/或返回一个函数的函数。例如，在上面的例子中，“@dostuff”是修饰者，“dostuff”是高阶函数的名称，“foo”是被修饰的函数和高阶函数的参数。</p><p id="6e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安全了吗？太好了，让我们开始实现我们的第一个装饰器吧！</p><h1 id="d522" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">打造我们的第一个室内设计师</h1><p id="36c5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了开始实现我们的装饰器，我将向您介绍<a class="ae ky" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"> functools </a> : Python 的高阶函数模块。具体来说，我们将使用<a class="ae ky" href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="noopener ugc nofollow" target="_blank">包装</a>函数。</p><p id="0b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个高阶函数，它将打印被修饰函数的执行时间:我们称它为“timeme”。这样，每当我们想要计算函数的执行时间时，我们只需要在目标方法的签名上添加装饰符“@timeme”。让我们开始定义“timeme”的签名:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b72b" class="mx lw it mt b gy my mz l na nb">def timeme(func):<br/>  pass</span></pre><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，一个高阶函数将另一个函数(修饰函数)作为它的参数，所以我们在它的签名中包含了“func”。现在，我们需要添加一个包含计时逻辑的包装函数。为此，我们将创建一个“包装器”函数，它将被 functools 的<a class="ae ky" href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="noopener ugc nofollow" target="_blank">包装器</a>函数包装:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ebf3" class="mx lw it mt b gy my mz l na nb">from functools import wraps</span><span id="6968" class="mx lw it mt b gy nc mz l na nb">def timeme(func):<br/>  @wraps(func)<br/>  def wrapper(*args, **kwargs):<br/>    pass</span><span id="1e3e" class="mx lw it mt b gy nc mz l na nb">  return wrapper</span></pre><p id="4ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意,“timeme”返回函数“wrapper ”,该函数除了打印执行时间之外，还将返回修饰函数的结果。</p><p id="83ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们通过实现计时逻辑来完成包装器:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cb90" class="mx lw it mt b gy my mz l na nb">from functools import wraps<br/>import time</span><span id="4b59" class="mx lw it mt b gy nc mz l na nb">def timeme(func):<br/>  @wraps(func)<br/>  def wrapper(*args, **kwargs):<br/>    print("Let's call our decorated function")<br/>    start = time.time()<br/>    result = func(*args, **kwargs)<br/>    print('Execution time: {} seconds'.format(time.time() - start))<br/>    return result<br/>  return wrapper</span></pre><p id="f6f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，修饰函数“func”是用它的位置和关键字参数执行的。我添加了一些打印消息，供您观察执行顺序。好吧！让我们试一试，我将创建一个简单的函数，带有一条打印消息，用“timeme”来修饰:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2e0a" class="mx lw it mt b gy my mz l na nb">@timeme<br/>def decorated_func():<br/>  print("Decorated func!")</span></pre><p id="069b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行它，您将看到如下内容:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e299" class="mx lw it mt b gy my mz l na nb">Let's call our decorated function<br/>Decorated func!<br/>Execution time: 4.792213439941406e-05 seconds</span></pre><p id="8d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，第一个打印消息被放在高阶函数中。然后，我们调用修饰的函数并打印它自己的消息。最后，我们计算执行时间并打印出来。</p></div></div>    
</body>
</html>