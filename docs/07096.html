<html>
<head>
<title>eCFR Parsing with BeautifulSoup and ElementTree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 BeautifulSoup 和 ElementTree 解析 eCFR</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ecfr-parsing-with-beautifulsoup-and-elementtree-8cf9d3ef8178?source=collection_archive---------21-----------------------#2019-10-07">https://towardsdatascience.com/ecfr-parsing-with-beautifulsoup-and-elementtree-8cf9d3ef8178?source=collection_archive---------21-----------------------#2019-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/614583fcd0d09fb24ff2240c9403aa47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7oeIKhkwrD-vztEb"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@firsara?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fabian Irsara</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="5d06" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下，你正试图理解在<em class="le">标题 16 商业惯例</em>下<em class="le">联邦法规(CFR) </em>中公布的一般和永久规则。目前，您拥有<em class="le">联邦法规电子代码(eCFR) </em>供您使用。然而，在浏览之后，你意识到要找到你需要的信息需要太多的点击。如果您可以提取所有内容并将其保存到一个数据集，会怎么样？嗯，你可以，有了像<a class="ae jg" href="https://docs.python.org/2/library/xml.etree.elementtree.html" rel="noopener ugc nofollow" target="_blank"> ElementTree </a>和<a class="ae jg" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> BeautifulSoup </a>这样的 Python 库。</p><p id="1c7d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我所有的<a class="ae jg" href="https://github.com/traintestbritt/ecfr_xml_parsing/blob/master/ecfr_parsing_notebook_with_beautiful_soup.ipynb" rel="noopener ugc nofollow" target="_blank">全注释代码</a>，我用它们中的任何一个库来解析<em class="le"> eCFR 标题 16 </em>的 XML。作为奖励，我也只用 BeautifulSoup 写了 PySpark 代码，所以如果你对那个<a class="ae jg" href="https://github.com/traintestbritt/ecfr_xml_parsing/blob/master/ecfr_parser_pyspark_.ipynb" rel="noopener ugc nofollow" target="_blank">感兴趣，点击这里</a>。</p><h2 id="8650" class="lf lg jj bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">用 BeautifulSoup 解析</h2><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/8f9caf0af9621abe45a34186154ec024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvsQdTPCXSmluNSOTwUjaA.png"/></div></div></figure><p id="4770" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，我导入了我需要的所有库——创建数据帧的 Pandas、发送请求的 requests、使用正则表达式的 re 和用于解析的 BeautifulSoup。然后，我向 url 发送请求以检索其数据，并将其存储在变量<code class="fe md me mf mg b">xml_bs</code>中。然后我将<code class="fe md me mf mg b">xml_bs</code>传递给<code class="fe md me mf mg b">bs</code>，后者返回一个 BeautifulSoup 对象，将 XML 文档表示为一个嵌套的数据结构。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/df2109bbee4fe636d331e1e4b6454888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqOQin7tr4yduOO8dv30LQ.png"/></div></div></figure><p id="c0ff" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然代码被完全注释掉了，但我将在下一个代码片段中提供更多的上下文。我创建了一个空列表，迭代地追加我检索到的所有数据。然后，我使用<code class="fe md me mf mg b">.find_all()</code>找到所有的<code class="fe md me mf mg b">DIV3</code>元素，并将它们存储在变量<code class="fe md me mf mg b">chapters_bs</code>中。从那里，我开始遍历我的<code class="fe md me mf mg b">soup</code>对象，寻找与<code class="fe md me mf mg b">DIV3</code>元素相关的属性或标签，并将它们保存到各自的变量中。我继续像这样嵌套我的 for 循环并访问父对象 prior，这允许我保留我的 XML 文档的层次结构。请注意，我在部分级别附加了我的所有数据。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/b2610032fa422c717db8171473dcbff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InXRcqRzYjjxFItD0ZLpig.png"/></div></div></figure><p id="6ac6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面接下来的几个步骤非常简单——我将我的数据保存到 Pandas DataFrame，编写一个 for 循环来删除任何前导或尾随空格，编写一个正则表达式来删除我的<code class="fe md me mf mg b">section_text</code>列中的标签和 ASCII 字符，并显示我的数据的前五行。</p><h2 id="2804" class="lf lg jj bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">使用 ElementTree 解析</h2><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mi"><img src="../Images/e5e2901252ad230da182693d05542bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpLBCJP4lyuykDNj4-bGXg.png"/></div></div></figure><p id="1123" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在上面的代码片段中，我导入了我需要的所有库——除了用于解析的 ElementTree 之外，所有库都是相同的。我向 url 发送了一个请求来检索它的数据，并将其存储在变量<code class="fe md me mf mg b">xml_et</code>中。然后我传递<code class="fe md me mf mg b">xml_et</code>到<code class="fe md me mf mg b">fromstring()</code>，后者将来自我的响应内容的 XML 解析成一个元素，这个元素是解析树的根元素。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/a466d3b3e92e57757f6b4adbc4406e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdQozEdAPcRyZaThWKuQHA.png"/></div></div></figure><p id="825a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的大部分代码保持不变，但是我将从头到尾再看一遍，以防您跳过。我创建了一个空列表，迭代地追加我检索到的所有数据。然后，我使用<code class="fe md me mf mg b">.iter()</code>找到所有的<code class="fe md me mf mg b">DIV3</code>元素，并将它们存储在变量<code class="fe md me mf mg b">chapters_et</code>中。从那里，我开始遍历我的<code class="fe md me mf mg b">root</code>对象，寻找与<code class="fe md me mf mg b">DIV3</code>元素相关的属性或标签，并将它们保存到各自的变量中。我继续像这样嵌套我的 for 循环并访问父对象 prior，这允许我保留我的 XML 文档的层次结构。请注意，我在部分级别附加了我的所有数据。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mk"><img src="../Images/6173334aac939614d0a2bc145b50b147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52rvDTAcWvSMGlxFpq8Xfg.png"/></div></div></figure><p id="896f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，上面接下来的几个步骤很简单——我将我的数据保存到 Pandas DataFrame，编写一个 for 循环来删除任何前导或尾随空格，编写一个正则表达式来删除我的<code class="fe md me mf mg b">section_text</code>列中的标签和 ASCII 字符，并显示我的数据的前五行。</p><p id="8890" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一如既往，感谢阅读。</p></div></div>    
</body>
</html>