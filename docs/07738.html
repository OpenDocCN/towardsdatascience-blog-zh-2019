<html>
<head>
<title>Plot Organization in matplotlib — Your One-stop Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">matplotlib 中的绘图组织—您的一站式指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plot-organization-in-matplotlib-your-one-stop-guide-if-you-are-reading-this-it-is-probably-f79c2dcbc801?source=collection_archive---------1-----------------------#2019-10-27">https://towardsdatascience.com/plot-organization-in-matplotlib-your-one-stop-guide-if-you-are-reading-this-it-is-probably-f79c2dcbc801?source=collection_archive---------1-----------------------#2019-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程的<a class="ae kl" href="https://github.com/maticalderini/Tutorial_pltOrganization" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>可以在我的<a class="ae kl" href="https://github.com/maticalderini" rel="noopener ugc nofollow" target="_blank"> Github 页面</a>找到。</p><p id="822a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你正在读这篇文章，可能是因为你同意我的观点，大多数<em class="km"> matplotlib </em>教程都缺少绘图和数据可视化的一个关键方面。</p><p id="fa54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然可能有成千上万的关于如何改变线条粗细或标题大小的教程，但他们似乎都忘记了支线剧情的组织在传达数据所讲述的故事中起着巨大的作用。有时，您可能希望通过放大某个地块来强调其重要性，或者通过在其上添加另一个插图来补充该地块。</p><p id="22bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进行这些编辑，我见过(太多)许多人保存用 Python 完成的单个图，然后在其他图像编辑软件上重新排列。这不仅效率低下，而且无法扩展到大容量绘图或需要多次调整和/或重做的绘图。</p><p id="6e14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于所有那些朋友和所有仍在为这些问题而奋斗的人，这里是你的一站式指南，教你如何只用 Python 上的<em class="km"> matplotlib </em>来组织你的情节和支线剧情。</p><p id="a520" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一张图胜过千言万语，所以对于那些想要快速预览的人，那些正在重新阅读这篇文章的人，或者那些患有 TLDR 综合症的人，这里有一个我们将在本教程中完成的示例代码:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="fc05" class="kw kx iq ks b gy ky kz l la lb">import matplotlib.pyplot as plt<br/>from matplotlib.gridspec import GridSpec<br/>import numpy as np</span><span id="3530" class="kw kx iq ks b gy lc kz l la lb">time = np.linspace(0, 10, 1000)<br/>height = np.sin(time)<br/>weight = time*0.3 + 2<br/>score = time**2 + height<br/>distribution = np.random.normal(0, 1, len(time))</span><span id="c21e" class="kw kx iq ks b gy lc kz l la lb">fig = plt.figure(figsize=(10, 5))<br/>gs = GridSpec(nrows=2, ncols=2)</span><span id="9508" class="kw kx iq ks b gy lc kz l la lb">ax0 = fig.add_subplot(gs[0, 0])<br/>ax0.plot(time, height)</span><span id="37c8" class="kw kx iq ks b gy lc kz l la lb">ax1 = fig.add_subplot(gs[1, 0])<br/>ax1.plot(time, weight)</span><span id="d411" class="kw kx iq ks b gy lc kz l la lb">ax2 = fig.add_subplot(gs[:, 1])<br/>ax2.plot(time, score)</span><span id="a4bb" class="kw kx iq ks b gy lc kz l la lb">ax3 = fig.add_axes([0.6, 0.6, 0.2, 0.2])<br/>ax3.hist(distribution)</span><span id="8d0f" class="kw kx iq ks b gy lc kz l la lb">plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ld"><img src="../Images/15f214c7ce1fa5ae25783988865a376d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIbpqM2CPwaRjiiqtLfSjA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Overview of subplot organization elements</figcaption></figure><p id="98d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们将如何处理支线剧情组织问题的示意图:</p><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/8326f7e3087d01309e03852ad58ec1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdVRbXQRPm8Y0-ED5kIEtA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Schematic of subplot organization elements</figcaption></figure><p id="121e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这激起了你的兴趣，或者如果你回来回顾你以前读过的内容，欢迎来到关于使用<em class="km"> matplotlib </em>在 Python 中组织你的情节的综合初学者教程！</p><p id="341a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们处理组织问题的方法是澄清图形、支线剧情和轴之间的区别，以及我们如何用 matplotlib 的 gridSpec 优化它。事不宜迟，让我们从第一个也是最基本的开始。</p><h1 id="fab4" class="lq kx iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">身材——你的框架</h1><p id="8d9f" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">一个<em class="km"> matplotlib </em>图的最基本元素是<strong class="jp ir">图形</strong>。该图形对象应被视为您的<strong class="jp ir">帧</strong>。把任何可视化想象成潜在的图形拼贴，把图形想象成所有这些图形被粘贴和移动的地方。</p><p id="ab38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像一个相框一样，这个图形本身就是一个等待内容的空结构。这是我们初始原理图的第一个元素:</p><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/a0b88f75d9751f488e256c64b2ad157a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AUCeeV0iaRyt41pAOSmFg.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Schematic — Figure</figcaption></figure><p id="263b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="km"> matplotlib </em>中，我们在使用线<code class="fe ms mt mu ks b">fig = plt.figure()</code>时创建图形对象。我们也可以省略放<code class="fe ms mt mu ks b">fig =</code>。这很简单，所以我们将 figure 对象存储在某个变量中，以防我们以后需要使用它。例如，如果您想用<code class="fe ms mt mu ks b">fig.save()</code>将图形保存为图像。如果您要保存新创建的图形，您将看到新创建的漂亮的空白图像。</p><p id="16c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想要的只是绘制一个图形，那么你就不需要考虑坐标轴或者支线剧情。你可以简单地这样做:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="ab0e" class="kw kx iq ks b gy ky kz l la lb"># Synthetic Data<br/>time = np.linspace(0, 10, 1000)<br/>height = np.sin(time)</span><span id="1735" class="kw kx iq ks b gy lc kz l la lb"># Plotting on a figure<br/>fig = plt.figure()<br/>plt.plot(time, height)<br/>fig.savefig(‘figures/basicFigure.png’)<br/>plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/82f8796ce7e45ab91532e0902ebf82c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*SbCQ1QbLcQw8rnAGd348Gg.png"/></div></figure><p id="60ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以解构前面的代码块:</p><ul class=""><li id="ad98" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><code class="fe ms mt mu ks b">plt.figure()</code>创建一个图形对象</li><li id="d389" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><code class="fe ms mt mu ks b">plt.plot(time, height)</code>会取可用空间，画出时间(x 轴)和高度(y 轴)的关系</li><li id="5b07" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><code class="fe ms mt mu ks b">plt.show()</code>会简单渲染剧情。这在笔记本中是不必要的，但是如果你在一个文本编辑器或者一个交互较少的编辑器上编码，这是一个很好的实践。</li></ul><p id="6d9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有更多的数据，你可以在这个简单的图中添加更多的线条。但是如果我们想在不同的图上画第二个变量呢？这就是轴和支线剧情变得有用的地方。</p><h1 id="64ab" class="lq kx iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">轴-绘图画布</h1><p id="3252" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">当图形对象是您的绘图框架时，您将在其上绘图的<strong class="jp ir">画布</strong>是<strong class="jp ir">轴</strong>对象。轴本身是自由浮动的，这意味着它们可以放在图形的任何位置。我们可以将它们添加到原始原理图中:</p><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/86aaf508acea80bcf5345c73fc61df37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLDvObCORESvyNvbpEo3eA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Schematic — Axes</figcaption></figure><p id="b46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在代码中，这很简单，如下所示:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="755a" class="kw kx iq ks b gy ky kz l la lb"># Original plot<br/>fig = plt.figure()<br/>plt.plot(time, height)</span><span id="efae" class="kw kx iq ks b gy lc kz l la lb"># Adding new empty axes<br/>fig.add_axes([0.43, 0.6, 0.15, 0.15])  #[lowerCorner_x, lowerCorner_y, width, height]<br/>fig.add_axes([0.2, 0.4, 0.1, 0.1])     #[lowerCorner_x, lowerCorner_y, width, height]</span><span id="d59c" class="kw kx iq ks b gy lc kz l la lb">fig.savefig('figures/figureAxes')<br/>plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/366f16e12956c12311241a0aa1f32f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*5ptX7PfVSHZwra_EznCB-Q.png"/></div></figure><p id="8bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们看到<code class="fe ms mt mu ks b">add_axes([left, bottom, width, height])</code>函数在原始绘图上添加了两个新的绘图区域。新轴的具体位置和大小在相应的函数输入数组中指定。</p><p id="8576" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，添加空轴并没有多大作用，所以让我们看看如何使用它们来绘图:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="bfae" class="kw kx iq ks b gy ky kz l la lb"># Original plot<br/>fig = plt.figure()<br/>plt.plot(time, height)</span><span id="0f3f" class="kw kx iq ks b gy lc kz l la lb"># First new axes<br/>ax1 = fig.add_axes([0.43, 0.6, 0.15, 0.15])<br/>ax1.hist(height)</span><span id="2b07" class="kw kx iq ks b gy lc kz l la lb"># Second new axes<br/>ax2 = fig.add_axes([0.2, 0.3, 0.1, 0.1])<br/>ax2.plot(time, time**2)</span><span id="94f8" class="kw kx iq ks b gy lc kz l la lb">fig.savefig('figures/figureAxes2.png')<br/>plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/7bcb7acef1382e71731d7faa3fff4695.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*f1b9XjAoNnG7aXeJ6Hg1pw.png"/></div></figure><p id="567c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们看到<code class="fe ms mt mu ks b">add_axes()</code>实际上给出或者<strong class="jp ir">返回</strong>我们可以在其上绘图的实际轴对象，我们将它存储在变量 ax1 和 ax2 中。然后，我们可以使用这些变量来绘制不同的有意义的数据，以类似于我们之前所做的方式为我们的图增加价值。</p><p id="e1ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们添加了高度值的直方图，并绘制了时间的平方(除了显示如何在轴上绘制之外，这不是非常有意义的信息)。</p><h1 id="e320" class="lq kx iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">子图—组织多个轴</h1><p id="34c1" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">当一个人第一次学习用 matplotlib 绘图时，支线剧情和轴线之间的区别不是特别明显。这是因为，通常情况下，支线剧情会在引入轴线之前引入。正如你现在将看到的，那个微小的细节可以改变你对一个人如何组织他们的视觉化的整体感知。</p><p id="44f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，<strong class="jp ir">支线剧情</strong>只是一种将你自由浮动的坐标轴组织成一个刚性网格的方式。你可以想象<em class="km">支线剧情</em>创建了一个表格，表格的每一个单独的单元格都是一个新的坐标轴供你填充数据。就像这个对原始示意图的新诠释一样:</p><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/c7034f6ed836ee4e1970fc1351e587e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpqifVmhsmHccSqtL5jxbA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Schematic — Subplots</figcaption></figure><p id="f755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是如何使用<strong class="jp ir">支线剧情</strong>:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="509f" class="kw kx iq ks b gy ky kz l la lb"># Synthetic Data<br/>time = np.linspace(0, 10, 1000)<br/>height = np.sin(time)<br/>weight = np.cos(time)</span><span id="be61" class="kw kx iq ks b gy lc kz l la lb"># Plotting all the subplots<br/>fig, axes = plt.subplots(2, 3)</span><span id="a7b6" class="kw kx iq ks b gy lc kz l la lb">axes[0, 0].plot(time, height)<br/>axes[0, 1].plot(time, time**2)<br/>axes[0, 2].hist(height)</span><span id="d5ce" class="kw kx iq ks b gy lc kz l la lb">axes[1, 0].plot(time, weight, color='green')<br/>axes[1, 1].plot(time, 1/(time+1), color='green')<br/>axes[1, 2].hist(weight, color='green')</span><span id="7060" class="kw kx iq ks b gy lc kz l la lb">plt.tight_layout()<br/>fig.savefig('figures/figureAxesSubplots.png')<br/>plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/47c2b1f261d6b07b4508aa43b0f1c076.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*L2pQb3dbditYl40rTxuDug.png"/></div></figure><p id="5312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，让我们一次看一行:</p><ul class=""><li id="4e58" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><code class="fe ms mt mu ks b">plt.subplots()</code>，创建了一个网格(2 行 3 列)。该函数返回图形对象(存储在<code class="fe ms mt mu ks b">fig</code>中)，该对象将保存所有支线剧情，以及所有单独的轴(存储在<code class="fe ms mt mu ks b">axes</code>)。</li><li id="6f7c" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">这些轴包含在一个 2D 数字阵列中(如果你喜欢的话，可以是一个矩阵或表格)，可以根据它们的位置单独访问。比如带<code class="fe ms mt mu ks b">axes[0, 0]</code>的左上轴。如果我们有大量的绘图要做，这里我们可以遍历这些位置来分别绘制它们。</li><li id="83af" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><code class="fe ms mt mu ks b">plt.tight_layout()</code>通常在使用<code class="fe ms mt mu ks b">plt.subplots()</code>时使用，以确保轴刻度和标签不会跨支线剧情重叠。请随意删除它，看看这意味着什么。</li></ul><p id="d7df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈推荐查看<a class="ae kl" href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplots.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>以进一步定制子情节网格，例如行/列之间的间距或者轴是否共享。</p><p id="e9e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们知道如何在特定的、自由浮动的位置和结构良好的网格下绘制多个图形。那么在组织方面还有什么要做的呢？那么，如果我们想通过把一个情节放大一倍来强调另一个情节呢？如果我们想创建某种类型的平铺式图库呢？这就是 GridSpec 有用的地方。</p><h1 id="1423" class="lq kx iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">GridSpec——一个灵活的组织</h1><p id="b204" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">GridSpec 的工作方式是，和支线剧情一样，定义一个网格。但是，可以选择每个单独的绘图区域将占用多少个单元，而不是自动将轴与网格的每个单元相关联。因此，如果我们希望一个图占据另一个图的两倍面积，我们可以将它与网格中两倍数量的单元相关联。</p><p id="e686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看代码:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="aab5" class="kw kx iq ks b gy ky kz l la lb"># A new set of data<br/>time = np.linspace(0, 10, 1000)<br/>height = np.sin(time)<br/>weight = time*0.3 + 2<br/>distribution = np.random.normal(0, 1, len(time))</span><span id="d619" class="kw kx iq ks b gy lc kz l la lb"># Setting up the plot surface<br/>fig = plt.figure(figsize=(10, 5))<br/>gs = GridSpec(nrows=2, ncols=2)</span><span id="4f6f" class="kw kx iq ks b gy lc kz l la lb"># First axes<br/>ax0 = fig.add_subplot(gs[0, 0])<br/>ax0.plot(time, height)</span><span id="3a03" class="kw kx iq ks b gy lc kz l la lb"># Second axes<br/>ax1 = fig.add_subplot(gs[1, 0])<br/>ax1.plot(time, weight)</span><span id="8924" class="kw kx iq ks b gy lc kz l la lb"># Third axes<br/>ax2 = fig.add_subplot(gs[:, 1])<br/>ax2.hist(distribution)</span><span id="0e31" class="kw kx iq ks b gy lc kz l la lb">fig.savefig('figures/gridspec.png')<br/>plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ld"><img src="../Images/1ac3eb2d7689d5f864bc087f1acbf351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k57Ivb8Lx4kAKgYap5lzSQ.png"/></div></div></figure><ul class=""><li id="c9a9" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">我们首先用<code class="fe ms mt mu ks b">gs = gridspec.GridSpec(nrows=2, ncols=2)</code>创建(2 乘 2)的网格。</li><li id="eb2e" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">在这种情况下，<code class="fe ms mt mu ks b">fig.add_subplot(gs[0, 0])</code>将通过索引<code class="fe ms mt mu ks b">[0, 0]</code>访问这些单元格来获取它们的子集。</li><li id="9e32" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">这个子集可以包含 gridSpec 网格的多个单元格，只需像使用<code class="fe ms mt mu ks b">ax2 = fig.add_subplot(gs[:, 1]) </code>那样访问多个单元格，它选择所有行和第二列。</li></ul><p id="06d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过设置每行或每列的大小来进一步定制我们的绘图。这意味着一些行可能比其他行更窄或更宽。例如:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="43f9" class="kw kx iq ks b gy ky kz l la lb"># Setting up the plot surface<br/>fig = plt.figure(figsize=(10, 5))<br/>gs = gridspec.GridSpec(nrows=2, ncols=2, width_ratios=[3, 1], height_ratios=[3, 1])</span><span id="5da3" class="kw kx iq ks b gy lc kz l la lb"># First axes<br/>ax0 = fig.add_subplot(gs[0, 0])<br/>ax0.plot(time, height)</span><span id="fa15" class="kw kx iq ks b gy lc kz l la lb"># Second axes<br/>ax1 = fig.add_subplot(gs[1, 0])<br/>ax1.plot(time, weight)</span><span id="cc15" class="kw kx iq ks b gy lc kz l la lb"># Third axes<br/>ax2 = fig.add_subplot(gs[:, 1])<br/>ax2.hist(distribution)</span><span id="b458" class="kw kx iq ks b gy lc kz l la lb">plt.show()</span></pre><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ld"><img src="../Images/0b7103189d70b0796df4bd56e6e7c812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NK2tJ8S2COGo3s0ep_L03Q.png"/></div></div></figure><p id="c196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，我们终于可以得到我们最初的原理图:</p><figure class="kn ko kp kq gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/8326f7e3087d01309e03852ad58ec1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdVRbXQRPm8Y0-ED5kIEtA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Schematic of subplot organization elements</figcaption></figure><p id="d116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们到这里所学到的一切，我们可以完全解构这个示意图:我们在这里看到的是，我们在(5，5)的网格上应用了 gridspec，但是一些行比其他的小。然后我们添加了覆盖整个第一行的支线剧情，一个覆盖第三行一半的支线剧情，两个覆盖最后一行的支线剧情和一个覆盖最后一列和最后三行的支线剧情。在最后一个支线剧情的顶部，我们添加了两个自由浮动的轴。</p><p id="d49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和以前一样，我强烈建议查看官方文档来进一步定制 gridSpec，比如行/列之间的间距或者如何创建嵌套的 grid spec。</p><p id="14a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，希望你现在知道如何使用<strong class="jp ir">人物</strong>、<strong class="jp ir">轴</strong>、<strong class="jp ir">支线剧情</strong>和<strong class="jp ir"> GridSpec </strong>来构建你的剧情。如果您有任何问题或意见，请在下面留下您的评论。</p></div></div>    
</body>
</html>