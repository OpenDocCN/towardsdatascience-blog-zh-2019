<html>
<head>
<title>Application of Gradient Boosting in Order Book Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">梯度推进在订单建模中的应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/application-of-gradient-boosting-in-order-book-modeling-3cd5f71575a7?source=collection_archive---------2-----------------------#2019-06-18">https://towardsdatascience.com/application-of-gradient-boosting-in-order-book-modeling-3cd5f71575a7?source=collection_archive---------2-----------------------#2019-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="feb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将创建一个预测订单簿中价格变动的 ML 模型。本文包含了一个完整的研究周期:获取数据、可视化、特征工程、建模、算法的微调、质量评估等等。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/692087f0021911461b99ab089a9c3094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AG6DSzbv3OG3MEQCVK7acg.jpeg"/></div></div></figure><h1 id="05c6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">什么是订单簿？</strong></h1><p id="b7da" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">订单簿是一个电子列表，列出了按价格水平组织的特定证券或金融工具的买卖订单。订单簿列出了每个价位或市场深度的出价或出价股票数量。市场深度数据有助于交易者确定特定证券的价格走向。例如，交易者可以使用市场深度数据来了解证券的买卖差价，以及高于这两个数字的交易量。具有强大市场深度的证券通常具有强大的交易量和相当的流动性，允许交易者在不显著影响市场价格的情况下下大量订单。更多信息请点击<a class="ae ma" href="https://www.investopedia.com/terms/m/marketdepth.asp" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/fdd26a6962f9abf18ff7cd749365ae37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLhIPXfPQYAl-b-ww9xJ-A.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Pricing scheme</figcaption></figure><p id="60bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">市场深度看起来像这样，可视化可能是不同的，它取决于软件</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/548aa64ce194ff8f9bf23788bebf095f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NjNZwgGH-jisDvbk7GvrOw.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">BTC market depth on GDAX</figcaption></figure><p id="f7c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种可视化订单簿的方式是一个包含出价和报价的列表</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/b6707332d784dbcc990faa04e82d001c.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/0*sv5AZznMzo2cJ_Hs.PNG"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Order book list</figcaption></figure><p id="163a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">中间价是介于股票或商品的卖方的最优价格或卖价和买方的最优价格或买价之间的价格。它可以简单地定义为当前报价的平均买价和卖价。</p><p id="08ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们的目标是创建一个预测中间价的模型。</strong></p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="935f" class="kx ky iq bd kz la mp lc ld le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu bi translated">获取数据</h1><p id="de6c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们从<a class="ae ma" href="https://lobsterdata.com/info/DataSamples.php" rel="noopener ugc nofollow" target="_blank">龙虾</a>下载数据样本。该服务以谷歌、苹果、亚马逊、英特尔、微软资产为例，提供 3 个级别的市场深度(1、5、10 级)。</p><p id="2349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我建议将所有可用资产的中间价和买卖差价可视化。我们需要导入必要的库</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e04c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一段代码从文件中加载给定资产和级别的数据</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="bec7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以可视化每个资产</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/316772452e56c10f82c67aec400e4cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FloMWbOP9TFRqDx3jMU_Sw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Mid-price and ask-bid volume difference</figcaption></figure><p id="d812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MSFT 和 INTC 有稍微奇怪和不同的分布。中间价图没有单一的钟形曲线，它看起来像两个分布的混合。还有，量差太对称，和其他资产不一样。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="8a5f" class="kx ky iq bd kz la mp lc ld le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu bi translated">特征工程</h1><p id="65f6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这一部分非常重要，因为模型的质量直接取决于它。我们应该在这些新特性中反映出价、要价、交易量以及不同深度数据之间的广泛关系。</p><p id="37a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的公式允许创建这些特征</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/fd3c73f2c495ac97d6153ad20e412d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyJ8qGLhgWpJzUnf0MSqVA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Features</figcaption></figure><p id="0c6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些特征是特征工程的第一部分。第二部分是添加滞后组件。这意味着我们在时间上有一些滞后地移动给定的特征，并作为列添加。此示例显示了它在原始数据集(非新要素)上的工作方式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/b955c7eedd9c881a1cdd4c72a37e03d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqALSLLcoGyyj5xrz-WvkA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Lag components example</figcaption></figure><p id="f2ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的代码提供了特征工程的这两个部分，并添加了目标列<em class="mz"> log_return_mid_price </em>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，特征看起来像这样</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/204a60972eb294274032502fe0257f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSttENeB2Pnbdk7KuWa_BQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Features example</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="15c3" class="kx ky iq bd kz la mp lc ld le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu bi translated">通过梯度增强和微调进行建模</h1><blockquote class="na nb nc"><p id="19b6" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">我们的目标是表明训练 GBM 是在我们的真实目标，<strong class="jp ir"> y，</strong>和我们的近似之间的一些损失函数上执行梯度下降最小化，</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/124d6fb4d599ee0a06f94dc98af0f751.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*eHdYeUyVao1CNX4upeP1gA.png"/></div></figure><blockquote class="na nb nc"><p id="f63b" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">这意味着增加弱模型，</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/73f4ae33216a29186bbd8667e823b263.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/format:webp/1*H4aegd9CXt89tYRjGtUiyA.png"/></div></figure><blockquote class="na nb nc"><p id="1674" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">我们的 GBM 添加剂模型:</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/26b594edc9fed3b7b605b441d5609c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*Qw2_jRGenMY6tkL5Jb6QlA.png"/></div></figure><blockquote class="na nb nc"><p id="fafb" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">正在以某种方式进行梯度下降。这是有意义的，推动我们的逼近，越来越接近真正的目标<strong class="jp ir"> y </strong>将执行梯度下降。例如，在每一步，残差变小。我们必须最小化一些与真实目标和我们的近似值之间的距离相关的函数。让我们重温一下高尔夫球员的类比，想象一下近似值和真实值之间的平方误差</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/2f2cb95a07dae2a46cdf1ea43a60d366.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*4qfVywXUQ6I9Q2psS6Upvg.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/146c5af7a7214828531edfd1f0407e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISUlvqEg3JlLlcGDRKvzMQ.png"/></div></div></figure><p id="4f7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多信息你可以在这里找到<a class="ae ma" href="https://explained.ai/gradient-boosting/descent.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用 Yandex 的梯度增强实现，它调用<a class="ae ma" href="https://catboost.ai" rel="noopener ugc nofollow" target="_blank"> CatBoost </a>。在大多数情况下，这个库在速度和质量上都优于其他库</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/41c7106351f873f02f4424df72da6afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQhOe-2Z4RhIqpp-uYVkKw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Libraries performance</figcaption></figure><p id="1938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法有几个对质量有巨大影响的参数:</p><ul class=""><li id="e807" class="nm nn iq jp b jq jr ju jv jy no kc np kg nq kk nr ns nt nu bi translated"><em class="mz"> n_estimators </em> —解决机器学习问题时可以建立的最大树数；</li><li id="a73f" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><em class="mz">深度</em> —树木的最大<em class="mz">深度</em>；</li><li id="5f36" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><em class="mz"> learning_rate </em> —该设置用于减少梯度步长。它影响训练的整体时间:值越小，训练需要的迭代次数越多；</li><li id="ae2e" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><em class="mz"> l2_leaf_reg </em> —成本函数的 l2 正则项的系数。允许任何正值。</li></ul><p id="3acb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们还有特性的参数:</p><ul class=""><li id="3f13" class="nm nn iq jp b jq jr ju jv jy no kc np kg nq kk nr ns nt nu bi translated"><em class="mz">水平</em> —市场深度；</li><li id="4893" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk nr ns nt nu bi translated"><em class="mz">时间步数</em> —建立多少个滞后。</li></ul><p id="6190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论上，我们的每个资产都有唯一的一组参数。对于这项任务，我们应该定义评估模型质量的目标函数</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="949c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义最佳参数的最佳方法之一是贝叶斯优化。我在<a class="ae ma" href="http://One of the best ways to define the optimal parameters is Bayesian optimization. I described this approach in the previous article." rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中描述了这种方法。</p><p id="5c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">损失函数是这样的 RMSE</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/d5a0a9eef6c1e554c2d7a501e2bc8861.png" data-original-src="https://miro.medium.com/v2/format:webp/1*qYxwsMuaYfhINbq3EteRYQ.png"/></div></figure><p id="f02b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">训练集从一开始就包含 50%的数据。验证数据用于模型的微调。测试最终结果所需的最后 25%的数据，这是保留数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/a96a9951f8e0300bc2209fc68f329c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQcRZz92eu8z_5lrJhA_fw.png"/></div></div></figure><p id="6a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在微调步骤之后，我们在两个部分(训练集和验证集)上训练最终模型，并使用最后一个部分测试模型。让我们编码这个</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="71ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz"> do_experiment </em>函数是本次研究的主要函数之一。该函数另外建立最佳模型的特征重要性，并估计模型的质量。</p><blockquote class="na nb nc"><p id="0d3f" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">通常，重要性提供了一个分数，该分数指示每个特征在模型内的增强决策树的构造中有多有用或有价值。在决策树中，一个属性被用来做关键决策的次数越多，它的相对重要性就越高。</p><p id="b101" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">这种重要性是为数据集中的每个属性显式计算的，允许对属性进行排序和相互比较。</p><p id="a5db" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">对于单个决策树，重要性通过每个属性分割点改进性能度量的量来计算，通过节点负责的观察的数量来加权。性能测量可以是用于选择分裂点的纯度(基尼指数)或另一个更具体的误差函数。</p><p id="80dd" class="jn jo mz jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">然后，对模型中所有决策树的特征重要性进行平均。来源<a class="ae ma" href="https://machinelearningmastery.com/feature-importance-and-feature-selection-with-xgboost-in-python/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="ddf8" class="kx ky iq bd kz la mp lc ld le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu bi translated">结果分析</h1><p id="7dfa" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">成功的基本衡量标准是使误差小于基线。意味着最终的模型质量很好。</p><p id="f01d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个问题是如何衡量质量。可能是平方误差。之后就可以用 bootstrapping 法估计区间了。bootstrap 采样、计算统计和区间估计在上面的<em class="mz"> bs_interval </em>函数中实现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/1700e364e7316e09311019d32f0ccfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*itSEUTq-MbGOGPWq.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Bootstrapping</figcaption></figure><p id="d115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个问题是应该使用什么值作为基线预测。许多研究声称市场是不可预测的。通常，预测的下一个价格与上一个价格相同，加上一些噪声，如下所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/40f47c24ef78509976d35696dd8bd93f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2pp2jUtD_l8yFJroM7brIQ.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Bad stock prediction result</figcaption></figure><p id="809d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着，如果我们想要预测回报，它将是 0 加上噪声左右。你可以在 Rafael Schultze-Kraft 的这篇<a class="ae ma" href="https://hackernoon.com/dont-be-fooled-deceptive-cryptocurrency-price-predictions-using-deep-learning-bf27e4837151" rel="noopener ugc nofollow" target="_blank">文章</a>中找到这个结果。</p><p id="06ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的基线是相似的。这种方法在<em class="mz"> do_experiment </em>函数中实现。让我们运行这个实验<em class="mz">do _ experiment(asset _ name)</em>，其中<em class="mz"> asset_name </em>来自列表(AAPL、AMZN、GOOG、INTC、MSFT)。</p><p id="2c80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将重要的参数和指标收集到此表中</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/e734bbcac6fba42d1d8b8da2b1ad9575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXqYgqfD0KQ4fTRQNXFq4A.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Final result table</figcaption></figure><p id="6dc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AMZN 和 GOOG 具有相同的最佳参数。通常，水平和深度具有最大值或接近最大值。</p><p id="cc39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所记得的，在开始的探索阶段，前三个资产(AAPL、AMZN、GOOG)具有良好的买卖价格和交易量分布。最后两个资产(INTC，MSFT)有奇怪的分布。</p><p id="b4b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该表显示，我们在 AAPL、AMZN、GOOG 和<strong class="jp ir">的误差方面获得了统计上的显著差异。</strong> <strong class="jp ir">基线被击败</strong>(绿色)。建模间隔的上限低于基线的下限。</p><p id="6093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于 INTC，我们没有显著的结果，区间是交叉的(灰色)。在 MSFT 的情况下，给定的结果比基线差(红色)。<strong class="jp ir">可能，其原因是检测到的分布模式</strong>(可能是做市商的一些活动或其他事情)。</p><p id="8ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这些模型最重要的特征</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6c6de9b4fec1a7d5f9ebefbdef5aad1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*8osskpc0ReaypEXUiER-Gg.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Top features for AAPL</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8c89e017097dbc6303438db09366e8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*xN_MSUVbU4TTKHpsvaBreA.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Top features for AMZN</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a54aa4f15e18090d630163de7f77f253.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*yOfISBJAW2IcDKveHxk7qQ.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Top features for GOOG</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/592b7075105e9d5a9058ffd8d987e418.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*RvSdFvUB91AGcWPe5NaWZw.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Top features for INTC</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e0ace9bc9afdd94f8f006c0daead3d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*CEt4p2bHlqzZ2dOHeHDFTg.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Top features for MSFT</figcaption></figure><p id="519c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，对于成功的模型，最重要的特征与最近的值相关联<em class="mz"> log_return_ask </em>，<em class="mz"> log_return_bid </em>，<em class="mz"> log_ask_div_bid </em>等等。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="4e62" class="kx ky iq bd kz la mp lc ld le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu bi translated">结论</h1><ol class=""><li id="6805" class="nm nn iq jp b jq lv ju lw jy oi kc oj kg ok kk ol ns nt nu bi translated">提出了基于梯度推进的订单簿建模方法。你可以在<a class="ae ma" href="https://github.com/lamres/orderbook_modeling" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到的代码。</li><li id="f0dc" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">描述和形式化的特征工程方法。显示了特征的重要性。</li><li id="3ba1" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">演示质量评估。对于一些资产，获得了良好的结果。</li></ol><p id="a4da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何提高成绩:</strong></p><ol class=""><li id="8b13" class="nm nn iq jp b jq jr ju jv jy no kc np kg nq kk ol ns nt nu bi translated">在优化中更改<em class="mz"> max_evals </em>的数量。</li><li id="ff91" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">在拟合中改变<em class="mz">最大 _ 深度</em>，<em class="mz">n _ 估计量</em>。</li><li id="5919" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">添加比当前功能更好的新功能，或给定功能的组合。</li><li id="549c" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">使用更多数据进行实验，以获得更好的模型。</li><li id="d1fe" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">在订单簿中查找具有更多<em class="mz">级</em>的历史。</li><li id="b2e6" class="nm nn iq jp b jq nv ju nw jy nx kc ny kg nz kk ol ns nt nu bi translated">使用专门为时间序列开发的模型(如 LSTM、GRU 等)。</li></ol></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="e494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最诚挚的问候，</p><p id="4e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢尔盖</p></div></div>    
</body>
</html>