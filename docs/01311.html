<html>
<head>
<title>Being a Data Scientist does not make you a Software Engineer!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为数据科学家并不能让你成为软件工程师！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/being-a-data-scientist-does-not-make-you-a-software-engineer-c64081526372?source=collection_archive---------3-----------------------#2019-03-02">https://towardsdatascience.com/being-a-data-scientist-does-not-make-you-a-software-engineer-c64081526372?source=collection_archive---------3-----------------------#2019-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4da9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/towards-data-science/data-science-in-the-real-world/home" rel="noopener">现实世界中的数据科学</a></h2><div class=""/><div class=""><h2 id="e2b8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何构建可扩展的 ML 系统—第 1/2 部分</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0c8f319cb81c893c8684963e762a9640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwpNpfTultM4WOcqK_7xSA.png"/></div></div></figure><h1 id="c1dd" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">放弃</h1><p id="f75b" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">希望我有争议的标题引起了你的注意。太好了！现在请耐心听我说，我将向您展示如何构建一个可扩展的架构来围绕您机智的数据科学解决方案！</p><p id="8ad4" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我正在开始一个由两篇文章组成的<strong class="lx jd">系列</strong>，它将涵盖关于架构和设计的软件工程基础，以及如何在机器学习管道的每一步应用这些基础:</p><blockquote class="mw mx my"><p id="35fd" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/being-a-data-scientist-does-not-make-you-a-software-engineer-c64081526372?source=friends_link&amp;sk=fd1e5ace8c5bfdaa6e1b1ace201dbff1"> <strong class="lx jd"> <em class="it">第一部分</em> </strong> </a> <em class="it">:问题陈述|架构风格|设计模式|坚实<br/> </em> <a class="ae nd" rel="noopener" target="_blank" href="/architecting-a-machine-learning-pipeline-a847f094d1c7?source=friends_link&amp;sk=f934e209896d28b1f3a11f081cb18cb3"> <strong class="lx jd"> <em class="it">第二部分</em> </strong> </a> <em class="it">:构建机器学习管道</em></p></blockquote></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="9405" class="ld le it bd lf lg nl li lj lk nm lm ln ki nn kj lp kl no km lr ko np kp lt lu bi translated">介绍</h1><p id="32fa" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/not-yet-another-article-on-machine-learning-e67f8812ba86">正如我们之前在 Steven Geringer 著名的维恩图中看到的</a>，数据科学是 3 个学科的交叉:计算机科学、数学/统计和特定的领域知识。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://towardsdatascience.com/not-yet-another-article-on-machine-learning-e67f8812ba86"><div class="gh gi nq"><img src="../Images/d8ffbf16bc1cb7cd7b7035c36731b2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*MuglQTETZNJCRp1iceE7-Q.png"/></div></a><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Data Science Venn Diagram [Copyright Steven Geringer]</figcaption></figure><p id="4bcc" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">拥有基本的(甚至是高级的)编程技能是进行端到端实验的关键，但是这并不意味着您已经创建了一个可以投入生产的应用程序。除非你已经从 IT 背景进入数据科学和机器学习(ML)领域，并且在构建企业、分布式、可靠的系统方面有切实的经验，否则你的 Jupyter 笔记本不符合优秀软件的标准，而且很遗憾，也不能让你成为软件工程师！</p><p id="f378" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">你已经建立了一个很好的预测产品的原型，但是你仍然需要推动它通过工程路线图。你需要的是一个专业软件工程师团队在你身边，把你的(一次性)概念证明变成一个<strong class="lx jd">高性能</strong>、<strong class="lx jd">可靠</strong>、<strong class="lx jd">松耦合</strong>和<strong class="lx jd">可扩展</strong>的系统！</p><blockquote class="nv"><p id="33c6" class="nw nx it bd ny nz oa ob oc od oe mq dk translated">一切都是设计好的；很少有东西是设计好的！</p></blockquote><p id="3a3c" class="pw-post-body-paragraph lv lw it lx b ly of kd ma mb og kg md me oh mg mh mi oi mk ml mm oj mo mp mq im bi translated">在这个系列中，我们将看到如何实现这一点的一些想法…我们将从第 1 部分的基础开始，并在第 2 部分逐步设计整体架构。建议的架构将与技术无关。ML 管道将被分解为责任划分清晰的层，在每一层，我们都可以从大量技术堆栈中进行选择。</p><p id="a316" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">但是让我们从定义一个成功的解决方案开始吧！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="3cc7" class="ld le it bd lf lg nl li lj lk nm lm ln ki nn kj lp kl no km lr ko np kp lt lu bi translated">问题陈述</h1><p id="7730" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">主要目标是建立一个系统:</p><blockquote class="mw mx my"><p id="42a7" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated"><em class="it"> ▸降低</em> <strong class="lx jd"> <em class="it">潜伏期</em></strong><em class="it">；<br/> ▸与系统的其他部分集成但</em><strong class="lx jd"><em class="it"/></strong><em class="it">松散耦合，例如数据存储、报告、图形用户界面；<br/> ▸可以</em><strong class="lx jd"><em class="it"/></strong><em class="it">横向和纵向缩放；<br/>是</em> <strong class="lx jd"> <em class="it">消息驱动</em> </strong> <em class="it">即系统通过异步、无阻塞的消息传递进行通信；<br/>针对</em> <strong class="lx jd"> <em class="it">工作量管理</em> </strong> <em class="it">提供高效的计算；<br/> ▸是</em><strong class="lx jd"><em class="it"/></strong><em class="it">容错和自愈即故障管理；<br/>支持</em> <strong class="lx jd"> <em class="it">批量</em> </strong> <em class="it">和</em> <strong class="lx jd"> <em class="it">实时</em> </strong> <em class="it">加工。</em></p></blockquote></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="662e" class="ld le it bd lf lg nl li lj lk nm lm ln ki nn kj lp kl no km lr ko np kp lt lu bi translated">建筑风格</h1><p id="026f" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">我们将首先介绍什么是反应式系统，然后快速浏览一下最流行的架构模式。</p><h2 id="b3d2" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">反应系统</h2><p id="6755" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">反应式系统设计范例是一种构建更好系统的连贯方法，它是根据<a class="ae nd" href="https://www.reactivemanifesto.org" rel="noopener ugc nofollow" target="_blank">反应宣言</a>的原则设计的。每个反应原理都映射到一个重要的系统可扩展性维度:<br/><em class="mz">反应灵敏</em> →时间<br/><em class="mz">弹性</em> →负载<br/><em class="mz">弹性</em> →错误<br/><em class="mz">消息驱动</em> →通信。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/b8a6a724a60e7ac0ce8df692a77546ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*GtONM09zvA4GqznK9oSv3A.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Features of Reactive Systems</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="8393" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">面向服务的架构(SOA)</h2><p id="10c8" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">SOA 以将业务问题分解为服务的概念为中心。这些服务通过网络共享信息，它们还共享代码(即公共组件)以保持一致性并减少开发工作。<br/>服务<strong class="lx jd">提供者</strong>发布一个合同，指定服务的性质和如何使用它。服务<strong class="lx jd">消费者</strong>可以在注册表中定位服务元数据，并开发所需的客户端组件来绑定和使用它。</p><p id="5131" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">一个<strong class="lx jd"> orchestrator </strong>是一个复合服务，负责调用和组合其他服务。或者，<strong class="lx jd">编排</strong>为服务组合采用了一种去中心化的方法，即服务与消息/事件的交换进行交互。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/9e73dee0a6502a1236d91ff1d905b578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*IP1EQNjUFUSo0qWS0LSNzQ.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">SOA</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="ca6c" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">流式架构</h2><p id="27eb" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">流式架构由以下组件组成:</p><ul class=""><li id="87c7" class="ox oy it lx b ly mr mb ms me oz mi pa mm pb mq pc pd pe pf bi translated"><strong class="lx jd">生产者</strong>:生成和发送消息的应用程序</li><li id="d2eb" class="ox oy it lx b ly pg mb ph me pi mi pj mm pk mq pc pd pe pf bi translated"><strong class="lx jd">消费者</strong>:订阅和消费消息的应用程序</li><li id="9c1d" class="ox oy it lx b ly pg mb ph me pi mi pj mm pk mq pc pd pe pf bi translated"><strong class="lx jd">主题</strong>:属于特定类别的记录流，存储为在分布式集群中分区和复制的有序且不可变的记录序列</li><li id="0343" class="ox oy it lx b ly pg mb ph me pi mi pj mm pk mq pc pd pe pf bi translated"><strong class="lx jd">流处理器</strong>:以某种方式处理消息的应用程序(如数据转换、ML 模型等)。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/cb31f98502fc7d82c81cf141180bdd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncJK2FS-o19kNc9hhTWRZA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Streaming Architecture</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="49e4" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">λ架构</h2><p id="114c" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">Lambda (λ)架构旨在以集成方式处理<strong class="lx jd">实时</strong>和历史聚合<strong class="lx jd">批量数据</strong>。它分离了实时和批处理的职责，而查询层提供了所有数据的统一视图。<br/>这个概念很简单:当数据生成时，它在存储之前被处理，因此分析可以包括在最后一秒、最后一分钟或最后一个小时生成的数据，只需处理传入的数据，而不是所有的数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/968db8d7a2ed5b5e27dc9c70c9fd3931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcqxQTlGsF-FJXSBmAPD4Q.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Lambda Architecture</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="eb6c" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">微服务架构</h2><p id="3be6" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">微服务是一种架构风格，它将应用程序构建为小型、自治、松散耦合和协作服务的集合，围绕业务领域建模。这些服务使用同步协议(如 HTTP/REST)或异步协议(如 AMQP)进行通信。它们可以彼此独立地开发和部署。每个服务都有自己的数据库，以便与其他服务分离。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/b4b0ec129a67a2c4b7534a7e2b218173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*VebcfjRrUjmJaNg7J_lwdg.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Microservices Architecture</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="db32" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">表述性状态转移(REST)架构</h2><p id="753f" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">REST 是一种开发 web 服务的架构风格，它建立在互联网 HTTP 的现有特性之上。它允许以无状态的方式传输、访问和操作文本数据表示，即应用程序可以进行不可知的通信。</p><p id="68b6" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">RESTful API 服务通过统一资源定位器(URL)公开，它提供了创建、请求、更新或删除数据(CRUD)的能力。通过将生产和消费的信息从生产和消费信息的技术中分离出来，它最适合用于管理系统！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/b864bc420144bb5a99c25a0ec9a883ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAx8U7noj4YGcoOTpiXcbA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">REST Architecture</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="58ed" class="ld le it bd lf lg nl li lj lk nm lm ln ki nn kj lp kl no km lr ko np kp lt lu bi translated">设计模式</h1><p id="5b86" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">我们将仅仅触及这个主题的表面，并且将仅仅讨论我可能在本系列的第二部分中提到的那些模式。—[现在还很难知道，但这些是我每天使用的模式]</p><blockquote class="mw mx my"><p id="0806" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated">软件设计模式是对软件工程中常见问题的优化的、可重复的解决方案。这是一个解决问题的模板，可以在许多不同的情况下使用。</p></blockquote></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="6253" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">战略</h2><p id="427d" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">策略模式定义了一系列算法，将每个算法放在一个单独的类中，并使它们<strong class="lx jd">可互换</strong>。将行为封装在单独的类中，消除了任何条件语句，并在运行时选择正确的算法(即策略)。</p><p id="944b" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:一个业务规则有不同的实现，或者需要不同的算法变体。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/a1f49805e4b903d373362aee0f86b60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU5IDcyRleFNzPIvv-P-iA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Strategy Pattern</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="630d" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">模板方法</h2><p id="dae8" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">模板方法旨在从不同的过程中抽象出一个共同的过程。它定义了算法的<strong class="lx jd">框架</strong>，将一些步骤推迟到子类。子类可以覆盖一些行为，但不能改变框架。</p><p id="749d" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:有一组一致的步骤可以遵循，但各个步骤可能有不同的实现方式。<br/> ⭐️ <strong class="lx jd">与策略模式</strong>的差异:<br/>模板:通过<strong class="lx jd">子类</strong>在<strong class="lx jd">编译时</strong>选择算法。<strong class="lx jd"> <br/> </strong>策略:由<strong class="lx jd">容器</strong>在<strong class="lx jd">运行时</strong>选择算法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/af9e71200b6aca6643da52f5e11e4dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m001ZMHTFrqF5bL0yBe3Aw.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Template Method</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="0d06" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">责任链</h2><p id="7511" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">责任链模式建议通过启用一个或多个<strong class="lx jd">处理程序</strong>来满足请求，从而避免将客户机(请求的发送者)与接收者耦合在一起。这些处理程序链接成一个链，即每个处理程序都有一个对链中下一个处理程序的引用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/39b587702e3bf4d5696b41022bf7f4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuJn5bGmMOGDETdJ7l06lA.png"/></div></div></figure><p id="a32a" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:一个以上的对象可能会处理一个请求，而处理程序(也不是序列)是未知的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/06400861bdb0ab3add5c065ff66ed4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFU13YADVnaruOKDv-SOMA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Chain of Responsibility</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="05d7" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">观察者</h2><p id="9c2c" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">观察者模式(也称为发布/订阅或简称 PubSub)通过定义对象之间的一对多依赖关系，使通信变得容易<strong class="lx jd">广播</strong>，这样当一个对象经历状态变化时，它的所有依赖对象都会得到通知并自动更新。观察者有责任记录他们正在“观察”的事件。</p><p id="2a3d" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:当一个对象的改变需要改变其他对象，而你不知道需要改变多少个对象时。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/f00a70428d01ff0203ec27ffda82be8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELA-CNXgpG1oKEebpNQT4w.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Observer Pattern</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="44a0" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">建设者</h2><p id="3804" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">构建器模式旨在以<strong class="lx jd">一步一步</strong>的方式构建一个复杂的对象，并将构建与其表示分离开来。本质上，它允许使用相同的代码产生不同类型和表示的对象。</p><p id="40dc" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:几种复杂的物体可以用相同的整体构建过程来构建，尽管各个构建步骤有所不同。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/5e3950343cde7e9724c78ec8cf05eff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIA0KIGSc9FI4moR_11fWQ.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Builder Pattern</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="14a2" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">工厂方法</h2><p id="03f8" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">工厂方法为<strong class="lx jd">创建对象</strong>定义了一个接口，但是实例化是由子类完成的。</p><p id="7ef6" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:事先不知道对象的确切类型和依赖关系。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/5634413dbf860cc92556c0b985c370db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MW6c9owh-1cyx58NqDF7FA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Factory Method</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="ddf2" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">抽象工厂</h2><p id="1077" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">抽象工厂捕获了如何创建相关对象的<strong class="lx jd">系列，而无需指定它们的具体类。</strong></p><p id="7274" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:存在不同的情况，需要不同的规则集实现，要么事先未知，要么可扩展性是一个问题。<br/> ⭐️ <strong class="lx jd">与抽象方法</strong>的区别:<br/>抽象工厂:创建其他工厂，这些工厂又创建从基类派生的对象。<strong class="lx jd"> <br/> </strong>【工厂方法:创建从特定基类派生的对象。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/9006aae20bf458c386d619e36cb70076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsvIVAEeIij4IQqqK5E_6w.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Abstract Factory</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="af03" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">装饰者</h2><p id="4431" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">装饰模式通过将对象放在包含这些行为的特殊包装类中，动态地将新的责任附加到对象上，因此对原始方法的签名没有影响(组合优于继承)。</p><p id="fd29" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:在运行时给对象分配额外的行为，而不破坏使用这些对象的代码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/49569f12b54f60519deb61b4b30c63d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adpb5OfoOIxG1eQMKrTM0w.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Decorator Pattern</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="b6a5" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">贮藏室ˌ仓库</h2><p id="b4aa" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">存储库模式解决了数据检索和持久化的代码集中化问题，并为数据访问操作提供了一个<strong class="lx jd">抽象，即类似于内存中的域对象集合，允许执行 CRUD 方法，并消除了任何数据库问题。</strong></p><p id="be4c" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd"> —用法说明</strong>:将业务逻辑与数据访问代码解耦。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/3f79993402d9f77f2440defdae79d13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_12PxJLBSGdaBIeC_aruw.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Repository Pattern</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="24b7" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">小奖励</h2><p id="d1d6" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">想了解更多关于模式的知识吗？从“四人帮”的书开始，即:“<a class="ae nd" href="https://www.amazon.co.uk/dp/0201633612" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a>”。下面的模式关系图值得注意— <em class="mz">很漂亮，是吧</em>？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi py"><img src="../Images/7cc8642bd4761ae117896dca5cf70b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*pSjrA-Yu_uy6U2Jv8zfZ6w.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Courtesy: <a class="ae nd" href="https://www.amazon.co.uk/dp/0201633612" rel="noopener ugc nofollow" target="_blank">Design Patterns: Elements of Reusable Object-Oriented Software</a></figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="f930" class="ld le it bd lf lg nl li lj lk nm lm ln ki nn kj lp kl no km lr ko np kp lt lu bi translated">固体</h1><p id="28fe" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">在这里，我们将只玩弄坚实的原则，因为它们对每个软件开发人员来说都是必不可少的。</p><p id="68df" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">正如<a class="ae nd" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">鲍勃大叔</a>所说:<em class="mz"/><a class="ae nd" href="https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start" rel="noopener ugc nofollow" target="_blank"><em class="mz">它们不是规律。它们不是完美的真理。这些陈述的顺序是:一天一个苹果，医生远离我。</em></a></p><p id="0a80" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这意味着它们不是某种“魔法”,不会带来牛奶、蜂蜜和伟大软件的乐土，但是它们仍然是健壮和持久软件的重要贡献者。</p><p id="9a83" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">简而言之，这些原则围绕着两个主要概念，它们是成功的企业应用程序的构建块:<strong class="lx jd">耦合</strong>是一个类了解另一个类并与之交互的程度，而<strong class="lx jd">内聚</strong>表示一个类具有单一目的的程度。换句话说:</p><blockquote class="mw mx my"><p id="27b4" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated">耦合是关于类之间如何交互的，而<br/>内聚则关注单个类是如何设计的。</p></blockquote></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="2203" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">单一责任原则</h2><blockquote class="mw mx my"><p id="ac76" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated"><strong class="lx jd"> <em class="it">一个类应该有且只有一个改变的理由。</em> </strong></p></blockquote><p id="fee6" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这是不言自明的，但是说起来容易做起来难——向现有的类中添加新的行为总是很诱人的，但是这是灾难的一个处方:每个行为都可能是将来改变的原因，所以更少的行为导致在改变期间引入错误的机会更少。</p><h2 id="bf02" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">开闭原理</h2><blockquote class="mw mx my"><p id="fecd" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated">你应该能够扩展一个类的行为，而不用修改它。T12】</p></blockquote><p id="edd9" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">您使用的类应该对扩展开放，但对修改关闭。实现这一点的一种方法是通过继承，即创建一个子类，这样原始类就不会被修改，但自定义代码会被添加到子类中以引入新的行为。</p><h2 id="eac9" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">利斯科夫替代原理</h2><blockquote class="mw mx my"><p id="a8b0" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated"><strong class="lx jd"> <em class="it">派生类必须可替换其基类。</em> </strong></p></blockquote><p id="b547" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">当将类 A 的行为扩展到子类 B 时，你必须确保你仍然可以在不破坏任何东西的情况下与 B 交换 A。这可能有点吸引人，尤其是当把这一原则与开闭原则结合起来时。</p><h2 id="8588" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">界面分离原理</h2><blockquote class="mw mx my"><p id="1f57" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated"><strong class="lx jd"> <em class="it">制作客户特定的细粒度接口。</em> </strong></p></blockquote><p id="7152" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">接口和类必须尽可能的专门化，这样调用客户端就不会依赖于它们不使用的方法。这与单一责任原则是相辅相成的。</p><h2 id="23a8" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">从属倒置原则</h2><blockquote class="mw mx my"><p id="4200" class="lv lw mz lx b ly mr kd ma mb ms kg md na mt mg mh nb mu mk ml nc mv mo mp mq im bi translated"><strong class="lx jd">依赖抽象，不依赖具体。T24】</strong></p></blockquote><p id="9240" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">高级类不应该依赖于低级类。它们都应该依赖于抽象。同样，抽象不应该依赖于细节。细节应该依赖于抽象。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="9a35" class="ok le it bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt iz bi translated">小奖励</h2><p id="9abd" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">我创建了这个快速参考图。如果你想知道我对左边小符号的灵感来自哪里，请看看:' '<a class="ae nd" href="https://blogs.msdn.microsoft.com/cdndevs/2009/07/15/the-solid-principles-explained-with-motivational-posters/" rel="noopener ugc nofollow" target="_blank">坚实的原则，用激励海报解释</a>' '文章-我喜欢作者如何在原则上添加有趣的转折🐤。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/6f945fb4e6d7e41c3375d8c43a1182de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bUTXREaWLOhcoBAU6Vokrg.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">SOLID</figcaption></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="edc8" class="ld le it bd lf lg nl li lj lk nm lm ln ki nn kj lp kl no km lr ko np kp lt lu bi translated">脚注</h1><p id="f826" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">这并不是所有软件工程概念的详尽列表，但是它是我们在下一篇文章中将要使用的基础。我希望它能让你对构建可伸缩软件的贡献因素有一个很好的了解。让应用程序设计<strong class="lx jd">对变化有弹性</strong>是构建成功解决方案的关键——如果设计过程仓促，当错误被发现时，项目结束时要支付罚金。</p><blockquote class="nv"><p id="0d91" class="nw nx it bd ny nz oa ob oc od oe mq dk translated">好的设计显而易见。伟大的设计是透明的。</p></blockquote><p id="d2c4" class="pw-post-body-paragraph lv lw it lx b ly of kd ma mb og kg md me oh mg mh mi oi mk ml mm oj mo mp mq im bi translated">感谢阅读！<a class="ae nd" rel="noopener" target="_blank" href="/architecting-a-machine-learning-pipeline-a847f094d1c7?source=friends_link&amp;sk=f934e209896d28b1f3a11f081cb18cb3">第二部</a>快到了…</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="d88c" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><em class="mz">我定期在</em> <a class="ae nd" href="https://medium.com/@semika" rel="noopener"> <em class="mz">媒体</em> </a> <em class="mz">上撰写关于技术的&amp;数据——如果你想阅读我未来的帖子，请“关注”我！</em></p></div></div>    
</body>
</html>