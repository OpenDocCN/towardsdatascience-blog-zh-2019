<html>
<head>
<title>Deep Learning for symbolic mathematics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">符号数学的深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-for-symbolic-mathematics-5830b22063d0?source=collection_archive---------25-----------------------#2019-12-13">https://towardsdatascience.com/deep-learning-for-symbolic-mathematics-5830b22063d0?source=collection_archive---------25-----------------------#2019-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6048" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用于绝对精确任务的神经网络。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37b96b0c4da300d9fb128e9e6ade3ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubAcgBoHgEjkEZdkjGWBjw.jpeg"/></div></div></figure><h1 id="3247" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="e0ed" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">本文试图描述 Guillaume Lample 和 Franç ois Charton 的论文<a class="ae mf" href="https://arxiv.org/abs/1912.01412" rel="noopener ugc nofollow" target="_blank">“符号数学的深度学习”的主要内容。</a></p><p id="a0b5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">深度学习方法已经成功地用于许多任务，最常见的是大幅度提高当前的艺术水平。例子包括:</p><ul class=""><li id="80e7" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">图像分类。(80%的把握图片显示的是一只狗)</li><li id="e977" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">翻译。(将文本从一种语言翻译成另一种语言)</li><li id="41b9" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">自动驾驶。(给定当前传感器输入，向右转向 5.785 度)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/b31ef8949d3433dbd78fc43cd31d24df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVDqnwxOlCm_VXDlPYcnMA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Different applications of DeepLearning. Sources: Cat (<a class="ae mf" href="https://pixabay.com/de/users/pascualamaia-4708629/?utm_source=link-attribution&amp;amp;" rel="noopener ugc nofollow" target="_blank">pascualamaia</a>), Car ( <a class="ae mf" href="https://www.flickr.com/photos/pasa/" rel="noopener ugc nofollow" target="_blank">Paul Sableman</a>)</figcaption></figure><p id="9408" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">所有这些场景的共同点是，对于任何给定的输入，一定范围的输出都是可接受的:</p><ul class=""><li id="2278" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">图像分类。“高信心”表示为 80%还是 83%都没关系。</li><li id="96e3" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">翻译。一个句子有多个有效的翻译。</li><li id="f6cc" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">自动驾驶。准确的转向角度并不重要，只要方向正确，幅度可以接受。</li></ul><p id="c2b4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://arxiv.org/abs/1912.01412" rel="noopener ugc nofollow" target="_blank">上面提到的论文</a>探索了一种不同的场景。一种输出要么 100%正确，要么 100%不正确:求解数学表达式。</p><p id="83aa" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">更具体地说，本文探讨了两项任务:</p><ul class=""><li id="0f14" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">对函数进行积分</li><li id="2e64" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">求解一阶或二阶常微分方程(ODE)</li></ul><p id="0ac6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在本文中，我将只描述函数集成的过程。通常使用以下符号:</p><ul class=""><li id="a911" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated"><em class="ne"> f </em>是任意函数，其积分为<em class="ne"> F </em></li><li id="c09c" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><em class="ne"> F </em>是任意函数，它的导数是<em class="ne"> f </em></li></ul><p id="62c6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于积分的任务，给定一个函数<em class="ne"> f </em>并且它的积分<em class="ne"> F </em>是期望的答案。这个答案有多种正确的表达方式，但每种方式都是 100%正确的。其他任何表述都是 100%不正确。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d08dfe7089233aac211213ae809f73c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*PFWf_vMstPKxz94I6GGRAg.png"/></div></figure><h1 id="64aa" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">深度学习模型:Seq2Seq</h1><p id="8cd0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">用来解决这个问题的深度学习架构被称为<a class="ae mf" href="https://google.github.io/seq2seq/" rel="noopener ugc nofollow" target="_blank"> Seq2Seq </a>。关于它是什么以及如何工作的详细解释可以在<a class="ae mf" rel="noopener" target="_blank" href="/understanding-encoder-decoder-sequence-to-sequence-model-679e04af4346">这里</a>找到。</p><p id="4413" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在您需要知道的是，Seq2Seq 模型接受任意长度的输入序列，并将其转换为任意长度的输出序列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/3a78e4d7da3c38321281c0ef99ae972d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQYGRlGybuCJMrdEAx7f0Q.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Input sequence in german, Output sequence translated to english.</figcaption></figure><p id="7342" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于功能集成任务，该模型最重要的特性是:</p><ul class=""><li id="d256" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">输入和输出序列可以具有任意长度，且这些长度可以不同</li><li id="9cac" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">从输入序列中的项目到输出序列中的项目的一对一关系是不必要的</li></ul><p id="a638" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这两个特性使得这种模型非常适合当前的任务。输入序列是定义输入函数的符号，输出序列是定义积分的符号。</p><p id="a96a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是，我们究竟如何将数学表达式输入到这个模型中呢？</p><h1 id="9928" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">作为序列的数学表达式</h1><p id="fcae" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">通常数学表达式已经是序列形式，即所谓的<a class="ae mf" href="https://en.wikipedia.org/wiki/Infix_notation" rel="noopener ugc nofollow" target="_blank">中缀符号</a>。这样称呼是因为二元运算符写在它们所引用的两个参数之间。</p><p id="ecad" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是，这种表示法不太适合在 seq2seq 模型中进行处理。这是因为为了使运算的顺序明确，需要大量的括号:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f003b630a1137cea3acafb1999e1ca73.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*gwzuaENNhqqQdlBffWUMBA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Top: Commonly used infix-notation. Bottom: Parenthesis for unambiguous order of operations</figcaption></figure><p id="e4af" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了避免这个问题，本文使用了所谓的<a class="ae mf" href="https://en.wikipedia.org/wiki/Polish_notation" rel="noopener ugc nofollow" target="_blank">前缀符号</a>。要从中缀符号表达式构建前缀符号表达式，请使用以下步骤:</p><p id="8159" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">首先，构建一个树来捕获表达式中操作的顺序和值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/cdddf83df0e135def952306ae998de0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2McHZgD7Cz4A0yrJYH3b0Q.png"/></div></div></figure><p id="b199" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">第二，按照以下规则从上到下从左到右遍历树:</p><ul class=""><li id="fd35" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">如果当前节点是一个原始值(一个数字)，则将其添加到序列字符串中</li><li id="5aaf" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">如果当前节点是二元运算，则将运算符号添加到序列字符串中。然后，添加左侧子节点的表示(可以是递归的)。然后，添加右子节点的表示。</li></ul><p id="da7a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在上面的例子中，这个过程将导致表达式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/36ef5350b0f99e279d501b7e38ce1e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*5utNpkt1G-Xdim41wNjcxw.png"/></div></figure><h1 id="26ba" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">数据生成</h1><p id="65bf" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">每个深度学习应用程序都需要大量数据进行训练，集成符号表达式也不例外。幸运的是，有一些方法可以自动生成任意数量的训练数据。论文提出了 3 种不同的生成函数-&gt;积分对的方法。</p><h2 id="8071" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">向前一代</h2><p id="2ce7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个很简单。随机生成一个符号函数 f，然后使用外部工具计算符号整数 f。外部工具可以是像<a class="ae mf" href="https://www.sympy.org/en/index.html" rel="noopener ugc nofollow" target="_blank"> SymPy </a>这样的库。然后将对(F，F)用作训练样本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/a8b2e758cb2291342a757b17b479b9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OZnJeRsXBFdubHln-a9Uw.png"/></div></div></figure><p id="b00d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这种方法有两个主要缺点:</p><ul class=""><li id="1a0e" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">它依赖于一些其他的库，这些库实现了我们试图解决的完全相同的任务</li><li id="fd72" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">即使使用第三方库，自动符号集成也不总是有效。这意味着在训练集中只有对(F，F)存在，对于这些对，存在可以求解 F 的积分的库，因此限制了多样性。</li></ul><p id="bacb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">此外，由这种方法产生的对(F，F)具有这样的性质，即 F 通常由比 F 少得多的符号组成。这是自动符号积分如何工作的结果。</p><h2 id="3690" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">落后一代(BWD)</h2><p id="b8c7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">利用微分容易，积分难的事实。随机生成一个函数 F，然后将其自动微分得到函数 F。然后将(F，F)对作为训练样本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/26b9b0ee5e47f1f3e2fcd65056e5485a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqVjS_YL9oaLibtotggG5g.png"/></div></div></figure><p id="76a2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">由这种方法产生的对(F，F)具有这样的性质，即 F 通常比 F 包含更少的符号。这是自动符号微分如何工作的结果。</p><h2 id="0211" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">零件集成(IBP)</h2><p id="fa19" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这种方法利用了被相乘的函数的积分的数学性质。该属性如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e50222165e829130534d461e810e6761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*Ek8TbZQ-ql1e3ujdrTQxTg.png"/></div></figure><p id="0625" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">用这个技巧生成函数的算法:</p><ol class=""><li id="5f6f" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me nz mr ms mt bi translated">随机生成函数 F 和 G</li><li id="9c75" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nz mr ms mt bi translated">自动微分得到 f 和 g</li><li id="1d9a" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nz mr ms mt bi translated">如果 Fg 已经是训练集的一部分，我们就知道它的积分。使用上面的公式计算 fG 的积分。</li><li id="e0b3" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nz mr ms mt bi translated">如果 fG 已经是训练集的一部分，我们就知道它的积分。使用上面的公式计算 Fg 的积分。</li></ol><h2 id="4894" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">附加步骤</h2><p id="116e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在用上述方法中的一种或组合建立训练集之后，执行这两个附加步骤:</p><ul class=""><li id="16f2" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated"><strong class="ll ir">简化</strong>。表达式被简化，以强制模型也输出简化的表达式。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f821a274521061b2e21fc02f4c7463a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*15kRBfO2ZUa0t6UlwqDyeA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Simplifiying expressions</figcaption></figure><ul class=""><li id="fe56" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated"><strong class="ll ir">删除无效表达式</strong>。由于表达式的随机生成性质，它们可能包含无效的子术语。如果有，从表达式树中删除这些术语。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b25ae71dd93272256730b2c1bf967deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*Cne78Gqa28ln1-sXD-Lnyw.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Invalid expressions are trimmed from the expression trees</figcaption></figure><h1 id="49e7" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结果</h1><p id="18cd" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在基础工作已经完成，让我们看看<a class="ae mf" href="https://arxiv.org/abs/1912.01412" rel="noopener ugc nofollow" target="_blank">纪尧姆·兰普尔和弗朗索瓦·查顿</a>取得的成果。</p><h2 id="e4b3" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">单台发电机的培训/测试</h2><p id="39ef" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用仅来自 FWD、BWD 或 IBP 中的一个的训练数据，并根据从相同方法产生的数据评估模型，产生非常好的结果:</p><ul class=""><li id="1a9a" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">前进:96.2%的准确性</li><li id="4d02" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">BWD:99.7%的准确率</li><li id="590e" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">IBP:99.5%的准确率</li></ul><h2 id="03f4" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">与流行的数学框架相比</h2><p id="9e51" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">接下来，作者将他们的精确度与 Mathematica 、<a class="ae mf" href="https://de.maplesoft.com/products/Maple/" rel="noopener ugc nofollow" target="_blank"> Maple </a>和<a class="ae mf" href="https://www.mathworks.com/products/matlab.html" rel="noopener ugc nofollow" target="_blank"> Matlab </a>产生的结果进行了比较。仅评估了 BWD 发生器。结果很明显:</p><ul class=""><li id="f10b" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">Mathematica(超时 30 秒):84.0%</li><li id="abd1" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">Matlab: 65.2%</li><li id="579a" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">枫叶:67.4%</li><li id="8870" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">seq 2 序列:99.6%</li></ul><p id="16fb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">seq2seq 模型明显优于 BWD 方法生成的方程的数学框架。</p><p id="8b9c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是一个 Mathematica 无法解决的方程的例子。如果分母简化，Mathematica 就能成功求解积分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/6bec699b223e81b99812327c5def5baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBJ_SXJHDf7xw0GM0d-pxQ.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Example failure case from the <a class="ae mf" href="https://arxiv.org/abs/1912.01412" rel="noopener ugc nofollow" target="_blank">original paper</a>.</figcaption></figure><h2 id="4d03" class="nk ks iq bd kt nl nm dn kx nn no dp lb ls np nq ld lw nr ns lf ma nt nu lh nv bi translated">跨生成器比较</h2><p id="913b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最后，作者评估了在一个生成器上使用另一个生成器的方程训练的模型。</p><ul class=""><li id="0375" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">接受过 FWD 培训:17.2%(BWD)，88.9%(IBP)</li><li id="d469" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">在 BWD 接受培训:27.5%(前进)，59.2%(IBP)</li><li id="04aa" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">在 BWD+IBP 接受培训:56.1%(前进)</li></ul><p id="7b3b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">仅在一个生成器上训练模型似乎不能很好地推广到其他生成器。这可能是由于来自每个生成器的训练对(F，F)在长度方面具有不同的特性。例如长 F 和短 F，或者短 F 和长 F。</p><p id="c226" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然而，根据来自所有 3 个发生器的方程训练模型工作良好:</p><ul class=""><li id="3ec5" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">接受过 FWD+BWD+IBP 培训:94.3%(FWD)，99.7%(BWD)，99.7%(IBP)</li></ul><h1 id="1663" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="ae63" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">总而言之，作者证明了神经网络方法甚至可以用于要求输出绝对精确的任务。在某些情况下，它们甚至超越了流行的数学框架。</p><p id="c6e4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你有时间，你应该读一下<a class="ae mf" href="https://arxiv.org/abs/1912.01412" rel="noopener ugc nofollow" target="_blank">原文</a>。它写得很好，很容易理解，即使没有太多的数学背景！</p></div></div>    
</body>
</html>