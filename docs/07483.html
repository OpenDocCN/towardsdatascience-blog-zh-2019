<html>
<head>
<title>Updating Specific Queries in ApolloClient Cache and Re-rendering Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更新非本地客户端缓存中的特定查询并重新呈现数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/updating-apolloclient-cache-and-re-rendering-data-4537c11c6daf?source=collection_archive---------13-----------------------#2019-10-19">https://towardsdatascience.com/updating-apolloclient-cache-and-re-rendering-data-4537c11c6daf?source=collection_archive---------13-----------------------#2019-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jq jr js jt gh gi paragraph-image"><div class="ab gu cl ju"><img src="../Images/1acaaff9ca5e8f1c9e88c3cc3b603a34.png" data-original-src="https://miro.medium.com/v2/format:webp/1*z-LROfr9BoiuMhlra-_OZQ.png"/></div></figure><p id="730f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用 ApolloClient 的最大好处之一是开箱即用的自动内存缓存。当对数据进行分页时，这允许您返回到以前的页面，并且转换非常快。但是有时您不希望这些数据永远被缓存。有时候你希望能够清空缓存，从你的服务器上获取<strong class="jz iu"> <em class="kv">新的</em> </strong>数据。您还希望这个<strong class="jz iu"> <em class="kv"> </em> </strong>触发一个<strong class="jz iu"> <em class="kv">重新呈现</em> </strong>正在呈现该数据的任何组件。</p><h1 id="a818" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我的问题</h1><p id="f72c" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">这是我最近在为公司开发数据可视化工具时发现自己处于的一种情况。我们有一个网络爬虫，它 24/7 爬行出版商的网页，并更新几个不同的数据库和表格。我们可以使用各种 regex、xpath 和元数据配置来操纵这个爬虫的行为，我们为每个发布者提供了这些配置。</p><p id="d38f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们面临的问题是，当对这些配置进行更改时，您希望能够看到您的更改在所有这些不同的数据库和表中的效果，这些数据库和表是由 crawler 更新的。以前，我们只是用大量的<code class="fe lz ma mb mc b">JOIN</code>语句手动编写大量的 SQL 查询，以便在任何给定的时间点只查看我们需要的数据。这相当麻烦，有时真的会降低我们的速度。</p><p id="8ba9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我构建了一个服务器，将所有这些数据库和各种表聚合成一个图(使用 Node.js、GraphQL、ApolloServer 和 MySQL)。然后我构建了一个 web 应用程序，它提供了大量的过滤器，我们可以使用这些过滤器只查看我们想要的数据(使用 Next.js 和 ApolloClient)。</p><p id="bc9c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为我们从<strong class="jz iu">出版商</strong>那里<strong class="jz iu">抓取</strong>网站，这款应用被称为<strong class="jz iu">酒吧抓取</strong>。</p><p id="f9d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它处理大量的数据。以下是一个示例查询:</p><figure class="me mf mg mh gt jt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/6282f0385b329f5a133e5978fc7bf642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*kqn1IRXL6cL6iMi9RS83DA.png"/></div></figure><p id="dda6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">前端面临的主要挑战(由于 ApolloClient 出色的内存缓存)是让用户能够随意更新数据<strong class="jz iu"><em class="kv"/></strong>，这样他们就可以检查一些东西，对配置进行更改，然后看看效果如何。</p><h1 id="9da3" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">挑战</strong></h1><p id="ef89" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">搜索“清除阿波罗缓存”的方法并不是解决这个问题的好方法。不幸的是，我就是这么做的。</p><p id="0cf0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我了解到这样做是因为 Apollo 允许您访问缓存对象上的一个名为<code class="fe lz ma mb mc b">resetStore()</code>的方法。该方法将清空整个缓存，并从服务器重新获取所有查询。我真的希望这能解决我的问题，因为它看起来很简单。</p><p id="ba9a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但事实并非如此，这让我很难过。</p><p id="048c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这不是为用例<code class="fe lz ma mb mc b">resetStore()</code>构建的。这里的问题是它<strong class="jz iu">不会触发重新渲染</strong>，所以即使缓存中充满了新数据，用户也看不到它。我希望用户点击一个按钮，看到一个加载屏幕，然后看到新的数据。我也不想重置整个缓存，因为应用程序中的一些数据不会改变。</p><h1 id="d869" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">以狗为例的解决方案</h1><p id="3297" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">让我们假设有一个页面向我们展示了一只狗。我们的数据库里有一只狗，但是这只狗变了。也许他洗了个澡，也许他在泥土里打滚。但是他很活跃，他的属性经常变化。</p><p id="4025" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过最初的查询，Apollo 让事情变得如此简单。您可以访问一些具有类似于<code class="fe lz ma mb mc b">loading</code>、<code class="fe lz ma mb mc b">error</code>和<code class="fe lz ma mb mc b">data</code>属性的状态。超级好看。它允许您编写这样的代码:</p><figure class="me mf mg mh gt jt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="559b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那太好了。可爱的开发者体验。</p><p id="840f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是现在我们想用一个按钮刷新我们的狗。让我们给我们的 jsx 添加一个按钮:</p><figure class="me mf mg mh gt jt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="45ee" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那个按钮是做什么的？</p><p id="5caa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事实证明，我们的<code class="fe lz ma mb mc b">useQuery()</code>钩子也给了我们一个叫做<code class="fe lz ma mb mc b">refetch()</code>的函数。这个功能太赞了。它允许您只刷新这一个查询的结果，或者甚至向它传递新的参数并获得结果。这解决了我之前提出的清除整个缓存的问题，但并没有为我们重新打开那个<code class="fe lz ma mb mc b">loading</code>布尔值。因此，只有当数据提取完成时，它才会重新呈现。这对我来说是个问题，因为我需要我的用户知道他们的数据正在被重新加载，而不仅仅是信任这个按钮。有可能数据没有改变，在这种情况下，用户不会看到任何事情发生！</p><p id="dfee" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">经过大量的黑客攻击，我发现阿波罗给了我们一个工具，当重取开始时触发我们的重渲染。这是由<code class="fe lz ma mb mc b">useQuery()</code>钩子返回的<code class="fe lz ma mb mc b">networkStatus</code>。要使用它，我们需要向钩子传递一个选项，告诉它在<code class="fe lz ma mb mc b">networkStatus</code>改变时提醒我们(在重取时它会改变)。这个选项是<code class="fe lz ma mb mc b">notifyOnNetworkStatusChange</code>。</p><figure class="me mf mg mh gt jt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3d2c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们可以说“如果网络状态是重新获取，显示加载组件”。其状态代码为<code class="fe lz ma mb mc b">4</code>。因此，我们可以将其添加到我们的<code class="fe lz ma mb mc b">loading</code>检查中:</p><figure class="me mf mg mh gt jt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f527" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们为调用<code class="fe lz ma mb mc b">refetch()</code>函数的按钮创建一个点击处理程序:</p><pre class="me mf mg mh gt mk mc ml mm aw mn bi"><span id="b7ed" class="mo kx it mc b gy mp mq l mr ms">import { useQuery } from '<a class="ae mt" href="http://twitter.com/apollo/react-hooks" rel="noopener ugc nofollow" target="_blank">@apollo/react-hooks</a>';<br/>import Loading from './Loading';<br/>import Error from './Error';<br/>import Dog from './Dog';<br/>import { DOG_QUERY } from '../lib/queries';</span><span id="d10b" class="mo kx it mc b gy mu mq l mr ms">export default () =&gt; {<br/>  const { data, error, loading, refetch, networkStatus } = useQuery(<br/>    DOG_QUERY,<br/>    { notifyOnNetworkStatusChange: true }<br/>  ); <br/>     <br/>  if (loading || networkStatus === 4) return &lt;Loading /&gt;;<br/>  if (error) return &lt;Error error={error} /&gt;;<br/>  <br/>  return (<br/>    &lt;&gt;<br/>      &lt;button <br/>        type="button" <br/>        role="button"<br/>        onClick={() =&gt; refetch()}<br/>      &gt;<br/>        See what's new with the dog<br/>      &lt;/button&gt;<br/>      &lt;Dog dog={data.dog} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="f90c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">仅此而已。现在，当我们单击按钮时，我们将看到<code class="fe lz ma mb mc b">&lt;Loading /&gt;</code>组件，缓存将刷新，然后我们将在<code class="fe lz ma mb mc b">&lt;Dog /&gt;</code>组件中看到新的狗数据。</p><h1 id="1224" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">就这样</h1><p id="5a9f" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">我希望这对你有帮助。我知道我被困在这几个小时仅仅是因为我谷歌了错误的词。希望你不会遇到同样的问题！</p><p id="7b9c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">欢迎在推特上关注我<a class="ae mt" href="https://twitter.com/sour_utley" rel="noopener ugc nofollow" target="_blank"> @sour_utley </a>。</p><p id="c7eb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你(出于某种奇怪的原因)想看看我为我的公司制作的工具的回购，它住在<a class="ae mt" href="https://github.com/mrkutly/pubcrawl" rel="noopener ugc nofollow" target="_blank">这里。</a>此外，如果您对 Carbon 的 iframes 有任何问题，页面上的代码如下:</p><pre class="me mf mg mh gt mk mc ml mm aw mn bi"><span id="2d36" class="mo kx it mc b gy mp mq l mr ms">import { useQuery } from '<a class="ae mt" href="http://twitter.com/apollo/react-hooks" rel="noopener ugc nofollow" target="_blank">@apollo/react-hooks</a>';<br/>import Loading from './Loading';<br/>import Error from './Error';<br/>import Dog from './Dog';<br/>import { DOG_QUERY } from '../lib/queries';</span><span id="8905" class="mo kx it mc b gy mu mq l mr ms">export default () =&gt; {<br/>  const { data, error, loading, refetch, networkStatus } = useQuery(<br/>    DOG_QUERY,<br/>    { notifyOnNetworkStatusChange: true }<br/>  ); <br/>     <br/>  if (loading || networkStatus === 4) return &lt;Loading /&gt;;<br/>  if (error) return &lt;Error error={error} /&gt;;<br/>  <br/>  return (<br/>    &lt;&gt;<br/>      &lt;button <br/>        type="button" <br/>        role="button"<br/>        onClick={() =&gt; refetch()}<br/>      &gt;<br/>        See what's new with the dog<br/>      &lt;/button&gt;<br/>      &lt;Dog dog={data.dog} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="a5ed" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">再见！</p></div></div>    
</body>
</html>