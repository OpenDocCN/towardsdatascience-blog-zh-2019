<html>
<head>
<title>AWS Athena helps to find the worst place to park your car in Portland</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Athena 帮助找到波特兰最糟糕的停车地点</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aws-athena-helps-to-find-the-worst-place-to-park-your-car-in-portland-ffb5195cfd9?source=collection_archive---------28-----------------------#2019-10-30">https://towardsdatascience.com/aws-athena-helps-to-find-the-worst-place-to-park-your-car-in-portland-ffb5195cfd9?source=collection_archive---------28-----------------------#2019-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f5db0f762e17b59a241dd8dc3d2fbea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdZYtEq9cEOBYXblyre9kg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://public.tableau.com/profile/achernyshova#!/vizhome/PortlandCrime_16126542652560/Map" rel="noopener ugc nofollow" target="_blank">My Tableau Public</a></figcaption></figure><p id="1685" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在参观完波特兰之后，或者上周末，我决定探索一些公开的关于这个城市的数据集。在本帖中，我们将使用<em class="lb"> </em> Athena geo 查询来计算每个波特兰社区中与车辆相关的事件(车辆被盗)的数量以及停车位的数量。之后，我们将计算每个停车位的事故数量，以识别危险区域。</p><p id="b486" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用三个数据集:</p><ul class=""><li id="a495" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">2019 年发生在波特兰的所有事件的警方报告。您可以在此下载该数据集<a class="ae kc" href="https://www.portlandoregon.gov/police/71978" rel="noopener ugc nofollow" target="_blank">(点击“下载开放数据”选项卡)</a></li><li id="7ce7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">波特兰停车点坐标，你可以下载这个数据集<a class="ae kc" href="http://gis-pdx.opendata.arcgis.com/datasets/ddd0f467686b422e88e40eb34aa9202f_210" rel="noopener ugc nofollow" target="_blank">这里</a></li><li id="626a" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">波特兰街区边界的 JSON，你可以在这里下载它<a class="ae kc" href="http://gis-pdx.opendata.arcgis.com/datasets/neighborhoods-regions" rel="noopener ugc nofollow" target="_blank"/>(选择 GeoJSON 格式)</li></ul><p id="b7f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始使用 SQL 探索数据集的一种快速简单的方法是使用 AWS Athena 数据库和 S3。创建一个 S3 桶(我称之为波特兰犯罪分数)。</p><p id="72c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于事件文件，在桶中创建一个文件夹“crime_data”。将下载的 CSV 文件导入文件夹。之后，转到 AWS 控制台，打开 Athena 服务并运行以下查询来创建一个表(用您的替换 S3 存储桶名称):</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ba5f" class="lz ma iq lv b gy mb mc l md me">CREATE EXTERNAL TABLE IF NOT EXISTS sampledb.incidents (<br/>  `Address` string,<br/>  `CaseNumber` string,<br/>  `CrimeAgainst` string,<br/>  `Neighborhood` string,<br/>  `OccurDate` string,<br/>  `OccurTime` string,<br/>  `OffenseCategory` string,<br/>  `OffenseType` string,<br/>  `OpenDataLat` float,<br/>  `OpenDataLon` float,<br/>  `OpenDataX` float,<br/>  `OpenDataY` float,<br/>  `ReportDate` string,<br/>  `OffenseCount` int <br/>)<br/>ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORED AS TEXTFILE LOCATION 's3://portland-crime-score/crime_data/'<br/>TBLPROPERTIES ('skip.header.line.count'='1');</span></pre><p id="63ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于停车位，创建一个名为“parking_data”的文件夹并导入相应的文件。运行以下查询来创建表:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="f7ee" class="lz ma iq lv b gy mb mc l md me">CREATE EXTERNAL TABLE IF NOT EXISTS sampledb.parking (<br/> `X` float,<br/> `Y` float,<br/> `OBJECTID` string,<br/> `ModifiedBy` string,<br/> `ModifiedOn` string,<br/> `ModifiedUsing` string,<br/> `Comments` string,<br/> `NonAssetID` string,<br/> `Status` string,<br/> `Owner` string,<br/> `MaintResp` string,<br/> `LocationID` string,<br/> `ImagePath` string,<br/> `Metered` string,<br/> `APPZone` string,<br/> `UseCode` string,<br/> `ParkingDuration` string,<br/> `Rotation` string<br/>)<br/>ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORED AS TEXTFILE LOCATION 's3://portland-crime-score/parking_data/'<br/>TBLPROPERTIES ('skip.header.line.count'='1');</span></pre><p id="4738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于邻域边界文件，创建一个名为“neighborhoods_data”的文件夹，并导入相应的文件。邻域数据存储在嵌套的 JSON 文件中，这就是这次表模式看起来不同的原因:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="029d" class="lz ma iq lv b gy mb mc l md me">CREATE EXTERNAL TABLE neighborhoods (<br/>    type string,<br/>    features array&lt;<br/>        struct&lt;type: string,<br/>            properties: struct&lt;OBJECTID: string,<br/>                  NAME: string, <br/>                  COMMPLAN: string,<br/>                  SHARED: string,<br/>                  COALIT: string,<br/>                  HORZ_VERT: string,<br/>                  MAPLABEL: string,<br/>                  ID: string,<br/>                  Shape_Length: string,<br/>                  Shape_Area: string<br/>            &gt;,<br/>            geometry: struct&lt;type: string,<br/>              coordinates: array&lt;array&lt;array&lt;string&gt;&gt;&gt;<br/>            &gt;<br/>        &gt;<br/>    &gt;<br/>)<br/>ROW FORMAT SERDE 'org.openx.data.jsonserde.JsonSerDe'<br/>LOCATION 's3://portland-crime-score/neighborhoods_data/';</span></pre><p id="03ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个表<strong class="kf ir">事件</strong>和<strong class="kf ir"> </strong>运行几个 SQL 查询来浏览数据。首先，让我们看看我们有多少记录:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="e637" class="lz ma iq lv b gy mb mc l md me">select count(*) <br/>from <strong class="lv ir">incidents;</strong></span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/88d2abb73902888d6d84b954ba22256f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6GY5btxJvP15fcw5ldjeA.png"/></div></div></figure><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ddcb" class="lz ma iq lv b gy mb mc l md me">select * <br/>from <strong class="lv ir">incidents</strong> <br/>limit 10;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/5797761062a140ab8403480e867d1631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ci-d4wAzLWLVV3akZCB6AQ.png"/></div></div></figure><p id="c2bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如我们所见，一些记录没有事件的坐标。如果我们在网站上检查数据集的元数据，就会发现它们是被故意删除的:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/ae2b25d14ac49ea06f6e67bdc656c37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PI6VprLuSSkQh1J4gpa71w.png"/></div></div></figure><p id="8747" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看没有坐标的记录有多少:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="fa4f" class="lz ma iq lv b gy mb mc l md me">select count(*) as count <br/>from <strong class="lv ir">incidents</strong> <br/>where OpenDataLat is Null or OpenDataLon is Null;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/b125d1907c8151427fe40d1b08ea81bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kT9Da6JjIXrYULQAWG7UcQ.png"/></div></div></figure><p id="8403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从进一步的探索中排除那些记录。现在让我们看看文件中有哪些类型的事件:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="119c" class="lz ma iq lv b gy mb mc l md me">select distinct OffenseType <br/>from <strong class="lv ir">incidents</strong>;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/7df7f07f1d5519523a3c8670513c7319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3P3heYk-dp6AJJ4xJzLeA.png"/></div></div></figure><p id="f314" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">共有 46 种事件类型。让我们关注与车辆相关的问题:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="df8c" class="lz ma iq lv b gy mb mc l md me">select distinct OffenseType <br/>from <strong class="lv ir">incidents</strong> <br/>where OffenseType like '%Vehicle%'</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/fdc252c905d2db319785153f4564ecaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWRjSW6KziKN1aUt5Hrpog.png"/></div></div></figure><p id="d591" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们创建一个仅包含 Athena 车辆事故地理点的表，并查看在应用所有这些过滤器后我们有多少行:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="7c0e" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">incident_points</strong> as (<br/>select ST_POINT(opendatalon, opendatalat) <br/>from <strong class="lv ir">incidents</strong> <br/>where OffenseType in (<br/>  'Motor Vehicle Theft', <br/>  'Theft From Motor Vehicle', <br/>  'Theft of Motor Vehicle Parts or Accessories') <br/>  and OpenDataLat is not NULL <br/>  and OpenDataLon is not NULL<br/>)<br/>select count(*) as incident_count <br/>from <strong class="lv ir">incident_points</strong>;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/18e24e93c0177d1fd06d01c022ea9c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*2imK5Q3dlRG8QGL2lESDHw.png"/></div></figure><p id="2b52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们创建一个包含所有停车点的地理点的表，这次我们不需要过滤任何内容:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="853b" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">parking_points</strong> as (<br/>  select ST_POINT(x, y) as point <br/>from <strong class="lv ir">parking</strong><br/>)<br/>select count(*) as parking_count<br/>from <strong class="lv ir">parking_points</strong>;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/f3e117f1f733cfa6799783a527eaf0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJc2jbE3Xq54x_yNKwtUQA.png"/></div></div></figure><p id="a90b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们来看一个邻域数据集。让我们解析 JSON 来提取边界坐标并创建 Athena 支持的 Polygon 类型的对象。我找不到一种简单的方法来解析 Athena 中的 GeoJSON。<a class="ae kc" href="https://docs.aws.amazon.com/athena/latest/ug/geospatial-input-data-formats-supported-geometry-types.html" rel="noopener ugc nofollow" target="_blank">文档</a>没有说支持它。这就是为什么我必须用 json 执行一系列操作来提取所需的坐标。</p><p id="1afc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们看看表邻域中有什么:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d71d" class="lz ma iq lv b gy mb mc l md me">select * <br/>from <strong class="lv ir">neighborhoods</strong>;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/d43a1db287bd1064f83173506c8a6722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKPnWsjBlt04geZd9kSryw.png"/></div></div></figure><p id="7740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个文件被解析成一行。我们需要从具有数组类型的 features 列中提取数据。让我们像这样解除数组嵌套:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="8a1e" class="lz ma iq lv b gy mb mc l md me">select type, feature <br/>from <strong class="lv ir">neighborhoods</strong><br/>CROSS JOIN UNNEST(features) AS t(feature)</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/cb0586cb4d00ace264b56fc890e5d22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNa3YoLVfehL2948plCu2A.png"/></div></div></figure><p id="8ba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个要素代表一个邻域。现在我们可以像这样访问它的值:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="16a5" class="lz ma iq lv b gy mb mc l md me">select feature.properties.Name as name, feature.geometry.coordinates[1] as shape <br/>from <strong class="lv ir">neighborhoods</strong><br/>CROSS JOIN UNNEST(features) AS t(feature)</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/a3e575b2b4bfd69a864a91281ad8dd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P57UNIlMXR_ju7qCsK0aYg.png"/></div></div></figure><p id="3100" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们有一个邻域名称和一个带有边界坐标的数组。我们的目标是将这些坐标转换成 varchar 格式，Athena 可以将它解析成这样的多边形对象:<em class="lb">SELECT ST _ Polygon(' Polygon((1 1，1 4，4 4，4 1))')。</em>要做到这一点，我们应该将坐标连接成一个字符串。此外，两个名为“MC UNCLAIMED #13”和“CRESTWOOD”的街区的坐标格式很奇怪，无法解析，所以我把它们从列表中排除了。让我们运行以下查询:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a65e" class="lz ma iq lv b gy mb mc l md me">with <strong class="lv ir">neighborhood_coords</strong> as (<br/>  select feature.properties.Name as name,<br/>  feature.geometry.coordinates[1] as shape <br/>  from <strong class="lv ir">neighborhoods</strong><br/>  CROSS JOIN UNNEST(features) AS t(feature)<br/>  where feature.properties.Name != 'MC UNCLAIMED #13' AND    feature.properties.Name != 'CRESTWOOD'<br/>),<br/><strong class="lv ir">unnest_nodes</strong> as (<br/>  select name, array_join(node, ' ') as node_str <br/>  from <strong class="lv ir">neighborhood_coords</strong><br/>  CROSS JOIN UNNEST(shape) AS t(node)<br/>)<br/>select * from <strong class="lv ir">unnest_nodes</strong>;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/b16b7af3135329734d29903b19760d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkUztfGCbWzTymN41YuNUg.png"/></div></div></figure><p id="f963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把邻居的坐标提取到多列中。现在我们需要做的就是用字符串连接将它们聚合回来:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="50d6" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">suburbs</strong> as (<br/>  select name as suburb_name, ST_POLYGON('polygon ((' || array_join(array_agg(node_str), ', ') || '))') as poly from <strong class="lv ir">unnest_nodes</strong> group by name <br/>)<br/>select * from <strong class="lv ir">suburbs</strong>;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/38ee7d46d393bdbd51cc44fd7a864994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImVEZU0j21ifbvdj6AUIXw.png"/></div></div></figure><p id="383d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将我们的小区与停车点连接起来，计算每个小区的停车位数量。我们将使用 Athena 函数 ST_CONTAINS 来检查停车点是否位于边界多边形内:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="dcd6" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">suburb_parking</strong> as (<br/>  select suburb_name, count(*) as parking_count from <strong class="lv ir">suburbs</strong> <br/>  join parking_points on ST_CONTAINS(poly, point)<br/>  group by suburb_name order by parking_count desc<br/>)<br/>select * from <strong class="lv ir">suburb_parking</strong> limit 10;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/47eb0e0dc161f6161793b0c088a9f1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxLHT-0YM-bphUyNUnrQhg.png"/></div></div></figure><p id="eec0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，市中心有最多的停车位。</p><p id="3e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看发生事故的街区，统计每个街区的事故数量:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="05e6" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">suburb_incident</strong> as (<br/>  select suburb_name, count(*) as incident_count from <strong class="lv ir">suburbs</strong> <br/>  join incident_points on ST_CONTAINS(poly, incident_point)<br/>  group by suburb_name order by incident_count desc<br/>)<br/>select * from <strong class="lv ir">suburb_incident</strong> limit 10;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/494e8c886165fad6fd7776dfc450cd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74wyDRSk5VexU5NWQr0tiQ.png"/></div></div></figure><p id="e1a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">黑兹尔伍德记录的事故数量最高，市中心位居第二。</p><p id="f4e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们计算事故数量与停车点数量之间的比率:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="4af3" class="lz ma iq lv b gy mb mc l md me">select suburb_parking.suburb_name, CAST(incident_count as double)/parking_count as crime_score <br/>from <strong class="lv ir">suburb_incident</strong><br/>join suburb_parking on suburb_incident.suburb_name = suburb_parking.suburb_name<br/>order by incident_count/parking_count desc;</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/937099aeebaa2f2ca4f9eaa515b3c3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miIr_XQs1sVUcUkXkEtyCg.png"/></div></div></figure><p id="20aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">令我们惊讶的是，像里士满这样名字好听的社区每个停车位的事故数量最高，而西北区是最安全的地方，每个停车位发生 0，056 起事故。</strong></p><p id="b5f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个查询如下所示:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="747a" class="lz ma iq lv b gy mb mc l md me">with <strong class="lv ir">regions_coords</strong> as (<br/>  select feature.properties.Name as name, feature.geometry.coordinates[1] as shape from <strong class="lv ir">neighborhoods</strong><br/>  CROSS JOIN UNNEST(features) AS t(feature)<br/>  where feature.properties.Name != 'MC UNCLAIMED #13' AND feature.properties.Name != 'CRESTWOOD'<br/>),<br/><strong class="lv ir">unnest_nodes</strong> as (<br/>  select name, array_join(node, ' ') as node_str from <strong class="lv ir">regions_coords</strong><br/>  CROSS JOIN UNNEST(shape) AS t(node)<br/>),<br/><strong class="lv ir">suburbs</strong> as (<br/>  select name as suburb_name, ST_POLYGON('polygon ((' || array_join(array_agg(node_str), ', ') || '))') as poly from <strong class="lv ir">unnest_nodes</strong> group by name <br/>),<br/><strong class="lv ir">parking_points</strong> as (<br/>  select ST_POINT(x, y) as point from <strong class="lv ir">parking</strong><br/>),<br/><strong class="lv ir">incident_points</strong> as (<br/>  select ST_POINT(opendatalon, opendatalat) as incident_point from <strong class="lv ir">incidents</strong><br/>  where OffenseType in (<br/>    'Motor Vehicle Theft', <br/>    'Theft From Motor Vehicle', <br/>    'Theft of Motor Vehicle Parts or Accessories') <br/>  and OpenDataLat is not NULL <br/>  and OpenDataLon is not NULL<br/>),<br/><strong class="lv ir">suburb_parking</strong> as (<br/>  select suburb_name, count(*) as parking_count from <strong class="lv ir">suburbs</strong> <br/>  join parking_points on ST_CONTAINS(poly, point)<br/>  group by suburb_name order by parking_count desc<br/>),<br/><strong class="lv ir">suburb_incident</strong> as (<br/>  select suburb_name, count(*) as incident_count from <strong class="lv ir">suburbs</strong> <br/>  join incident_points on ST_CONTAINS(poly, incident_point)<br/>  group by suburb_name order by incident_count desc<br/>)<br/>select suburb_parking.suburb_name, CAST(incident_count as double)/parking_count as crime_score <br/>  from <strong class="lv ir">suburb_incident</strong><br/>  join suburb_parking on suburb_incident.suburb_name = suburb_parking.suburb_name<br/>  order by incident_count/parking_count desc;</span></pre><p id="2043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次我去波特兰的时候，我会查看这些信息，找到最好的住处。</p></div></div>    
</body>
</html>