<html>
<head>
<title>Visualizing NYC Bike Data on interactive and animated maps with Folium plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Folium 插件在交互式和动画地图上可视化纽约市自行车数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualizing-nyc-bike-data-on-interactive-and-animated-maps-with-folium-plugins-c2d7645cd19b?source=collection_archive---------7-----------------------#2019-08-17">https://towardsdatascience.com/visualizing-nyc-bike-data-on-interactive-and-animated-maps-with-folium-plugins-c2d7645cd19b?source=collection_archive---------7-----------------------#2019-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f56f1ed5798c2ed960c3af77b768a265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGo15FzB4T209HdCQUcQVw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Visualizing NYC Bike Data on interactive and animated maps with Folium plugins</figcaption></figure><h1 id="cd2e" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">当哪里的科学还不够</h1><p id="a57e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">当分析交通和流动性时，在地图上画图总是很有帮助的。这有助于我们回答问题“<em class="ly">事情在</em>哪里发生？”</p><p id="1b88" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">尽管如此，如果我们不考虑<strong class="lc ir">时间</strong>，很多时候分析的结果会发生巨大的变化。也许最明显的例子是在分析通勤模式时:如果你分析一整天，看起来去市中心的人和去相反方向的人大致相同。当你按一天中的时间划分时，你可以看到人们早上(去上班)和下午(回家)的移动方式有很大的不同。</p><p id="e140" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在这种情况下，我们想要加深对特定情况的理解，我们需要在分析中添加第二个变量:<strong class="lc ir">时间</strong>。这将帮助我们在事情发生时回答<em class="ly">。</em></p><blockquote class="me"><p id="9fc7" class="mf mg iq bd mh mi mj mk ml mm mn lx dk translated"><em class="mo">在我们想要加深对特定情况的理解的情况下，我们需要在分析中加入第二个变量:</em> <strong class="ak"> <em class="mo">时间</em> </strong> <em class="mo">。</em></p></blockquote></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="0014" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="ly">友情提醒:请帮我鼓掌(或者很多！)当你读完之后如果觉得这篇文章有帮助。</em></p><h1 id="8064" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">你会在这篇文章中发现什么</h1><p id="5862" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在这篇文章中，我们与纽约自行车共享服务的<a class="ae mw" href="https://s3.amazonaws.com/tripdata/index.html" rel="noopener ugc nofollow" target="_blank">公开可用数据</a>争论，以介绍一些<a class="ae mw" href="https://python-visualization.github.io/folium/plugins.html" rel="noopener ugc nofollow" target="_blank">插件</a>，它们可以帮助我们在<a class="ae mw" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>中用 Python 的<a class="ae mw" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">叶子</a>库制作动画、交互式地图。</p><p id="f0f7" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们不会关注数据分析工作流程或我们从不同的视觉效果中得到的结论。我们将尝试优化这里显示的代码，以获得我们正在寻找的动画地图。</p><p id="2511" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们会发现一些例子:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/55a2b366acc50a3db7c458efeb90c8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LZcuqJUwOmwELvA1ZBaNIw.gif"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/4acb419df567d3c9bc17456945e7caa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VrYy4bN0m830ZNT5S2JFFQ.gif"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/1108dc72923e4d14e557c3e57a8d734b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D5Tv6C-YbgsT0A07JpfGHg.gif"/></div></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="6d90" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">导入库</h1><p id="f5c7" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">和往常一样，我们做的第一件事是导入我们将使用的 Python 库。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="50d4" class="nm kd iq ni b gy nn no l np nq">import numpy as np <br/>import pandas as pd <br/>import geopandas as gpd <br/>import folium <br/>import datetime</span></pre><p id="b966" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果您是 Python 用户，您可能已经熟悉了前三个库。如果你开始使用 Python 并且想了解更多，我强烈推荐你阅读杰克·范德普拉斯的名著《Python 数据科学手册》，以获得完整的介绍。它是免费的，你可以直接从你的电脑上阅读。</p><p id="c907" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">第四行是导入<a class="ae mw" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">leave</a>，这是一个将<a class="ae mw" href="https://leafletjs.com/" rel="noopener ugc nofollow" target="_blank"> Leaflet.js </a>引入 Python 的库，让我们只用几行代码就能创建交互式地图。</p><p id="abdb" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在最后一行，我们导入了<a class="ae mw" href="https://docs.python.org/2/library/datetime.html" rel="noopener ugc nofollow" target="_blank"> <em class="ly"> datetime </em> </a> <em class="ly"> </em>库，这将使我们能够更轻松地处理时间序列。如果你有兴趣了解更多关于如何有效处理时间序列的知识，你可以阅读本书的这一部分。我发现它很有帮助。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="d492" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">导入和浏览数据</h1><p id="6a3f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">纽约花旗自行车共享服务的数据是公开的，可以在这里下载。在本笔记本中，我们使用了 2019 年 5 月<strong class="lc ir">月</strong>的数据。</p><p id="f680" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">将文件下载到工作目录后，运行以下脚本导入数据:</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="e9d2" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Import the file as a Pandas DataFrame</em><br/>fp = 'file.csv' <br/>nyc = pd.read_csv(fp) <br/>nyc.head()</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/7996c8a4e54b9999bf9196b67ab019cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjWNcywkvf4r-1JR-AHTCA.png"/></div></div></figure><p id="1a56" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">数据看起来很完整。我们对每次旅行都有很多信息:</p><ul class=""><li id="8f65" class="ns nt iq lc b ld lz lh ma ll nu lp nv lt nw lx nx ny nz oa bi translated"><strong class="lc ir">行程持续时间:</strong>行程的持续时间，以秒为单位。</li><li id="ab4e" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">开始时间:</strong>行程的开始日期和时间。</li><li id="8b17" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">停止时间:</strong>行程的结束日期和时间。</li><li id="3e60" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">起点站 id、名称、纬度和经度:</strong>识别和定位起点站的所有有用信息。纬度和经度值在 WGS84 投影(GPS 投影)中，这将使我们以后的工作更容易。</li><li id="a72c" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">终点站 id、名称、纬度和经度:</strong>识别和定位旅行终点站的所有有用信息。</li><li id="5a2d" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir"> bikeid: </strong>旅途中骑过的自行车的 id。</li><li id="c506" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">用户类型:</strong>用户是订户(年卡)还是顾客(不同于年卡)。</li><li id="1137" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">出生年份</strong></li><li id="f936" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">性别:</strong>表示用户是女性(2)、男性(1)还是未知(0)</li></ul><p id="8de2" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对这些变量的完整解释可以在花旗自行车的网页上找到。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="4a81" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">转换</h1><p id="00a9" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们注意到变量<strong class="lc ir">开始时间</strong>和<strong class="lc ir">停止时间</strong>被作为文本(字符串)导入:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/4e5655736303e68e64d6b6737e32ff9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCYtKZJ_CfCMvrvEaV_IOA.png"/></div></div></figure><p id="f723" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">为了让 Pandas 充分发挥时间序列的功能，我们将做以下工作:</p><ol class=""><li id="f376" class="ns nt iq lc b ld lz lh ma ll nu lp nv lt nw lx oh ny nz oa bi translated">将这些变量的类型更改为<strong class="lc ir">日期时间。</strong></li><li id="4432" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx oh ny nz oa bi translated">将<strong class="lc ir">start time</strong>定义为数据帧的索引。这将使我们能够更容易地按一天中的时间对值进行透视(分组)。</li><li id="9545" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx oh ny nz oa bi translated">创建一个名为<strong class="lc ir">【类型】</strong>的新列来帮助我们进行旋转。</li></ol><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="a266" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Setting the right format for starttime and stoptime</em><br/>nyc['starttime'] = nyc['starttime'].str[:-5]<br/>nyc['stoptime'] = nyc['stoptime'].str[:-5]<br/>nyc['starttime'] = pd.to_datetime(nyc['starttime'])<br/>nyc['stoptime'] = pd.to_datetime(nyc['stoptime'])<br/><br/><br/><em class="ly"># Define the startime as index and create a new column</em><br/>nyc = nyc.set_index('starttime')<br/>nyc['type'] = 'station'<br/>nyc.head(1)</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/3baa88a9372975eb8bc4b151709f7b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygzAwd6OVLvwyeKlfUdB1g.png"/></div></div></figure><p id="9380" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这正是我们想要为每个可视化开始特定转换的格式。我们开始吧！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="2e6b" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">时间戳 GeoJson</h1><p id="a6fb" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这个插件允许我们在交互式叶子地图上绘制数据，并根据时间变量(年、月、日、小时等)制作动画，并且支持任何类型的几何图形(点、线串等)。你唯一要做的就是确保用 geojson 以正确的格式“输入”它。</p><p id="b484" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">为此，我们将开始转换数据框。首先，我们计算每个车站每小时的发车次数:</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="51ca" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Aggregate number of trips for each start station by hour of the day</em><br/>start = nyc.pivot_table('tripduration', <br/>                      index = ['start station id', <br/>                               'start station latitude', <br/>                               'start station longitude',<br/>                                nyc.index.hour],<br/>                      columns = 'type',<br/>                      aggfunc='count').reset_index() start.head()</span><span id="c4cf" class="nm kd iq ni b gy oj no l np nq">start.head()</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/e34a0e53e65ca2cbf6c0dacf9d64ada7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*OOtETdBWLWypEzjjxPDrDw.png"/></div></figure><p id="a2d9" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在上面的代码中，我们使用了 pandas<a class="ae mw" href="https://jakevdp.github.io/PythonDataScienceHandbook/03.09-pivot-tables.html" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir">pivot _ table()</strong></a>函数来帮助我们以任何我们想要的方式对数据进行分组。注意，我们使用的最后一个索引是<strong class="lc ir">“NYC . index . hour”</strong>。这将获取数据帧的索引，因为它是<strong class="lc ir"> datetime </strong>格式，所以我们可以获得该值的小时，如上所示。我们可以类似地得到日子或月份。</p><p id="ea40" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">尽管如此，我们得到的计数是整个月的。为了得到日平均值，我们将除以天数。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="72a4" class="nm kd iq ni b gy nn no l np nq">days = nyc.index.day.max() <br/>start['station'] = start['station']/days</span></pre><p id="5dd7" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">现在，为了方便起见，我们将更改列的名称，并定义我们希望地图上的点具有的颜色。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="424d" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Rename the columns</em><br/>start.columns = ['station_id', 'lat', 'lon', 'hour', 'count']<br/><br/><em class="ly"># Define the color</em><br/>start['fillColor'] = '#53c688'<br/><br/><em class="ly"># The stops where less than one daily trip</em><br/><em class="ly"># will have a different color</em><br/>start.loc[start['count']&lt;1, 'fillColor'] = '#586065'<br/>start.head(1)</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/915de23f55abc0534598cc340c4d800a.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*d6DetR6D102jZT0KjnXKKw.png"/></div></figure><p id="f3ad" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在将数据框转换为我们需要的格式后，我们必须定义一个函数，从其中获取值，并使用正确的属性创建 geojson 以在插件中使用。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="c4e5" class="nm kd iq ni b gy nn no l np nq">def create_geojson_features(df):<br/>    features = []<br/>    <br/>    for _, row in df.iterrows():<br/>        feature = {<br/>            'type': 'Feature',<br/>            'geometry': {<br/>                'type':'Point', <br/>                'coordinates':[row['lon'],row['lat']]<br/>            },<br/>            'properties': {<br/>                'time': pd.to_datetime(row['hour'], unit='h').__str__(),<br/>                'style': {'color' : ''},<br/>                'icon': 'circle',<br/>                'iconstyle':{<br/>                    'fillColor': row['fillColor'],<br/>                    'fillOpacity': 0.8,<br/>                    'stroke': 'true',<br/>                    'radius': row['count'] + 5<br/>                }<br/>            }<br/>        }<br/>        features.append(feature)<br/>    return features<br/>start_geojson[0]</span></pre><p id="c626" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">让我们来看看函数:</p><ol class=""><li id="5f85" class="ns nt iq lc b ld lz lh ma ll nu lp nv lt nw lx oh ny nz oa bi translated">它获取一个数据帧并遍历其行</li><li id="b843" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx oh ny nz oa bi translated">它创建一个要素并将几何定义为一个点，从数据框中获取纬度和经度变量</li><li id="1442" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx oh ny nz oa bi translated">它使用其他变量定义其余的属性:</li></ol><ul class=""><li id="c7b1" class="ns nt iq lc b ld lz lh ma ll nu lp nv lt nw lx nx ny nz oa bi translated">它使用<strong class="lc ir">小时</strong>变量来创建一个<strong class="lc ir">时间</strong>属性。这是最重要的数据动画。</li><li id="a443" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated">创建<strong class="lc ir"> fillColor </strong>属性需要<strong class="lc ir"> fillColor </strong></li><li id="f78b" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated">它将点的<strong class="lc ir">半径</strong>定义为<strong class="lc ir">计数</strong>变量的函数</li></ul><p id="3997" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">一旦定义了函数，我们就可以在数据框中使用它并获得 geojson。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="cfc7" class="nm kd iq ni b gy nn no l np nq">start_geojson = create_geojson_features(start) <br/>start_geojson[0]</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/870ac9de200e3015aeda454fd5153306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrabWYunoFl0LzdJ71w2rw.png"/></div></div></figure><p id="99fe" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">有了这个，我们现在可以创建我们的第一个互动和动画地图。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="7ea5" class="nm kd iq ni b gy nn no l np nq">from folium.plugins import TimestampedGeoJson<br/><br/><br/>nyc_map = folium.Map(location = [40.71958611647166, -74.0431174635887],<br/>                    tiles = "CartoDB Positron",<br/>                    zoom_start = 14)<br/><br/><br/>TimestampedGeoJson(start_geojson,<br/>                  period = 'PT1H',<br/>                  duration = 'PT1M',<br/>                  transition_time = 1000,<br/>                  auto_play = True).add_to(nyc_map)</span></pre><p id="e4a4" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">TimestampedGeoJson 插件的参数是:</p><ul class=""><li id="40f4" class="ns nt iq lc b ld lz lh ma ll nu lp nv lt nw lx nx ny nz oa bi translated">有数据的 geojson</li><li id="0536" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">周期:</strong>是动画从第一个值开始的时间步长。例如:' P1M ' 1/月，' P1D ' 1/天，' PT1H ' 1/小时，' PT1M ' 1/分钟。</li><li id="33d6" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated"><strong class="lc ir">持续时间:</strong>时间过后，要素将在地图上显示的时间段。如果没有，将显示所有以前的时间。</li></ul><p id="43a3" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">结果看起来像这样:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/247b002640ef954c50bc3ec6bc87ce15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*V2mirNnkgprNlfcyybs_bg.gif"/></div></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="593e" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">双重地图</h1><p id="4f8b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">上面的地图看起来很酷，我们可以清楚地看到，在早高峰，许多行程从市中心周围的地方开始，而在下午，有大量的行程从地图中心的车站开始。</p><p id="5f42" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">分析一天中不同时间的旅行终点可能是个好主意。更重要的是，并排查看两张地图并尝试识别一种模式可能会很有趣。</p><p id="adf9" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><strong class="lc ir"> DualMap </strong>插件可以帮助我们实现这一点。为了使用它，我们将首先运行一个与上面类似的脚本，以获得一天中每个时间<em class="ly">在每个车站结束</em>的车次。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="ba1f" class="nm kd iq ni b gy nn no l np nq">nyc1 = nyc.reset_index().set_index('stoptime')<br/>end = nyc1.pivot_table('tripduration', <br/>                     index = ['end station id', <br/>                              'end station latitude', <br/>                              'end station longitude', <br/>                              nyc1.index.hour],<br/>                     columns = 'type',<br/>                     aggfunc='count').reset_index()<br/><br/><br/>end['station'] = end['station']/days<br/><br/><br/>end.columns = ['station_id', 'lat', 'lon', 'hour', 'count']<br/>end['fillColor'] = '#e64c4e'<br/>end.loc[end['count']&lt;1, 'fillColor'] = '#586065'<br/>end_geojson = create_geojson_features(end)</span></pre><p id="456d" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在这之后，我们只需要创建我们的对偶地图。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="cc47" class="nm kd iq ni b gy nn no l np nq">from folium.plugins import DualMap<br/><br/>dualmap = DualMap(location = [40.71958611647166, -74.0431174635887],<br/>                 tiles = 'cartodbpositron',<br/>                 zoom_start = 14)<br/><br/>TimestampedGeoJson(start_geojson,<br/>                  period = 'PT1H',<br/>                  duration = 'PT1M',<br/>                  transition_time = 1000,<br/>                  auto_play = True).add_to(dualmap.m1)<br/><br/>TimestampedGeoJson(end_geojson,<br/>                  period = 'PT1H',<br/>                  duration = 'PT1M',<br/>                  transition_time = 1000,<br/>                  auto_play = True).add_to(dualmap.m2)<br/><br/>dualmap</span></pre><p id="26c5" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">请注意，我们首先创建对偶地图，然后将<strong class="lc ir"> start_geojson </strong>添加到左侧地图(m1)，将<strong class="lc ir"> end_geojson </strong>添加到右侧地图(m2)。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/78fb018fe92e1c6e80a48b0d86eadcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Owyg6JTX-QkTKzIwysMDDQ.gif"/></div></div></figure><p id="583f" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">正如我们所猜测的那样，在早上，大部分行程都在地图中间的车站结束(右边地图上的红色圆圈)，而在下午，大部分行程都从那里开始(左边地图上的绿色圆圈),并分布在整个城市。有理由假设那里有一个大的中转站(也许是一个火车站),带着许多人去曼哈顿工作，穿过这座桥。</p><p id="d5ee" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这是一个很好的例子，说明向空间数据添加<strong class="lc ir">时间</strong>变量可以帮助我们更好地理解某些情况。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="f5bb" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">蚂蚁路径</h1><p id="b6fb" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这个插件帮助我们在地图上制作路径动画。在这种情况下，我们没有每次旅行的确切路径，因此我们将创建从起点到目的地的线。</p><p id="3c9b" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在开始处理我们的数据之前，让我们看看这个插件需要什么设置。从<a class="ae mw" href="https://rubenspgcavalcante.github.io/leaflet-ant-path/" rel="noopener ugc nofollow" target="_blank">现场演示</a>中我们可以看到设置包括<strong class="lc ir">权重</strong>(线条粗细)和<strong class="lc ir">延迟</strong>(动画的速度，延迟越高，动画越慢)。在我们的例子中，利用这些设置来更好地表示两个站点之间的活动水平是很有趣的。今后我们将牢记这一点。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="12f3" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">从我们之前看到的地图来看，似乎在地图中间有一个很大的车站，可能值得单独分析。我先从筛选与之互动最多的前 6 个站开始。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="5e90" class="nm kd iq ni b gy nn no l np nq">df = nyc.pivot_table('tripduration', <br/>                     index = ["start station name", <br/>                              "end station name",],<br/>                     columns = ['type'],<br/>                     aggfunc='count').reset_index().sort_values(by='station', ascending=False)<br/>df.head()</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a6eb342e7946049e5afd9be9d1477138.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*bGiC3DT_z1LyoHfDX6xkuQ.png"/></div></figure><p id="0e07" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">现在，我们可以将这前 6 个站点作为掩码，在接下来的步骤中过滤信息。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="d6e2" class="nm kd iq ni b gy nn no l np nq">mask1 = df["start station name"].head(10)<br/>mask2 = df["end station name"].head(10)<br/>mask = mask1.append(mask2)<br/>mask = mask.unique()</span></pre><p id="e7c5" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在用袖扣做了一个关联热图后，我发现最有趣的分析站是“Grove St PATH”(你可以去<a class="ae mw" href="https://github.com/Bondify/Python/blob/master/Visualizing%20NYC%20Bike%20Data%20on%20interactive%20and%20animated%20maps%20with%20Folium%20plugins.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>找这个的代码，因为这不是本文的目的)。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/9c2a74ed48feae545994fc2422cba377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*af2o8Yg8YhRvi3q3Fbahtw.png"/></div></div></figure><p id="2f12" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">因此，格罗夫圣路径似乎是最有趣的<em class="ly">那里</em>，但我们也将切片我们的数据一点点，以了解<em class="ly">时</em>的事情发生。正如我们在盖有时间标记的 geojson 地图上看到的，早上最大的流量是<strong class="lc ir">流向</strong>Grove St PATH，而下午主要的流量是来自 Grove St PATH <strong class="lc ir">的<strong class="lc ir">。</strong>在制作数据动画之前，将我们的数据分成这些时间段似乎会很有用。</strong></p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="c6ee" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Assign to each row a period of the day</em><br/>nyc['time_of_day'] = pd.cut(nyc.index.hour,<br/>                            [0,6,10,16,20,24],<br/>                            labels = ['am_valley', 'am_peak', 'mid_valley', 'pm_peak', 'pm_valley'], <br/>                            right=False)<br/><br/><em class="ly"># Create a different dataframe for each peak</em><br/>am = nyc.loc[nyc['time_of_day'] == 'am_peak', :]<br/>pm = nyc.loc[nyc['time_of_day'] == 'pm_peak', :]<br/><br/><em class="ly"># Filter the trips that end in Grove St PATH during the morning peak</em><br/><em class="ly"># and the trips that start in Grove St PATH during the afternoon peak</em><br/>to_st_path = am.loc[(am['end station name'] == 'Grove St PATH') &amp; (am['start station name'].isin(mask)), :]<br/>from_st_path = pm.loc[(pm['start station name'] == 'Grove St PATH') &amp; (pm['end station name'].isin(mask)), :]</span></pre><p id="2ed3" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">现在我们已经根据需要过滤了信息，我们将转换数据框来创建插件需要的格式。我将在文章中展示将<strong class="lc ir">转换为 _st_path </strong>数据帧的过程，但对<strong class="lc ir"> from_st_path </strong>也是如此。你可以在这里下载整个<a class="ae mw" href="https://github.com/Bondify/Python/blob/master/Visualizing%20NYC%20Bike%20Data%20on%20interactive%20and%20animated%20maps%20with%20Folium%20plugins.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本的完整代码。</a></p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="b5e4" class="nm kd iq ni b gy nn no l np nq">to_st_path = to_st_path.pivot_table('tripduration',<br/>                                   index = ['start station name', <br/>                                            'start station latitude',<br/>                                            'start station longitude',<br/>                                            'end station name',<br/>                                            'end station latitude',<br/>                                            'end station longitude'],<br/>                                   columns = ['type'],<br/>                                   aggfunc='count').reset_index().sort_values(by='station', ascending=False)</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/b8562d94d5efc6ef6da9c0fcd6f046e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9QqAA6izyCwCJetl5q2jQ.png"/></div></div></figure><p id="d6db" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">现在我们可以为每一行再创建两个变量:<strong class="lc ir">权重</strong>和<strong class="lc ir">延迟。</strong>都将是<strong class="lc ir">站</strong>的功能。</p><ul class=""><li id="939e" class="ns nt iq lc b ld lz lh ma ll nu lp nv lt nw lx nx ny nz oa bi translated">对于体重，我决定在 1 到 10 的范围内。站<strong class="lc ir">越高</strong>就是<em class="ly">越重</em>。</li><li id="85cc" class="ns nt iq lc b ld ob lh oc ll od lp oe lt of lx nx ny nz oa bi translated">对于<strong class="lc ir">延迟</strong>，我决定在 100 到 800 的范围内进行。<strong class="lc ir">较高的</strong>工位是<em class="ly">较低的</em>工位(它将移动得更快)。</li></ul><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="8f74" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Define the weight</em><br/>to_st_path['weight'] = to_st_path['station']*10/(to_st_path['station'].max())<br/><br/><em class="ly"># Get the needed values for interpolating</em><br/>a_to_st_path = (800-100)/(to_st_path['station'].min() - to_st_path['station'].max())<br/>b_to_st_path = 100 - to_st_path['station'].max()*a_to_st_path<br/><br/><em class="ly"># Define the delay interpolating</em><br/>to_st_path['delay'] = a_to_st_path*to_st_path['station'] + b_to_st_path</span></pre><p id="3345" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对另一个数据框运行相同的代码后，我们现在可以创建一个双地图，显示上午高峰时朝向 Grove St PATH 的活动<strong class="lc ir">和下午</strong>高峰时来自 Grove St PATH 的活动<strong class="lc ir">。</strong></p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="6dc7" class="nm kd iq ni b gy nn no l np nq">from folium.plugins import DualMap<br/><br/><br/>dualmap = DualMap(location = [to_st_path.loc[0, 'end station latitude'], to_st_path.loc[0, 'end station longitude']],<br/>                         tiles='cartodbpositron',<br/>                         zoom_start=15)<br/><br/><br/>to_st_path.apply(lambda row: folium.plugins.AntPath([(row['start station latitude'],<br/>                                                      row['start station longitude']),<br/>                                                     (row['end station latitude'],<br/>                                                      row['end station longitude'])],<br/>                                                    color='blue',<br/>                                                    weight = row['weight'],<br/>                                                    delay = row['delay']).add_to(dualmap.m1),<br/>                   axis=1)<br/><br/><br/>from_st_path.apply(lambda row: folium.plugins.AntPath([(row['start station latitude'],<br/>                                                        row['start station longitude']),<br/>                                                       (row['end station latitude'],<br/>                                                        row['end station longitude'])],<br/>                                                      color='blue',<br/>                                                      weight = row['weight'],<br/>                                                      delay = row['delay']).add_to(dualmap.m2),<br/>                   axis=1)<br/><br/><br/>dualmap</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/96815a7c02df0416d90bdfa5435dbaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jqhuhs0gDeWknAEZ5hzj1g.gif"/></div></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="1c07" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">热图时间</h1><p id="e054" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">根据这个插件的<a class="ae mw" href="https://python-visualization.github.io/folium/plugins.html" rel="noopener ugc nofollow" target="_blank">文档</a>，它需要的输入是一个列表列表:</p><p id="977c" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">"<strong class="lc ir">数据</strong>(<em class="ly">[lat，lng]或[lat，lng，weight] </em>形式的点列表列表)-您想要绘制的点。外部列表按顺序对应不同的时间步长。(权重在(0，1)范围内，如果没有为点指定权重，则默认为 1)"</p><p id="caf0" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">也就是说，我们需要为一天中的每个小时创建一个点列表，然后将所有这些列表放入一个新列表中。为此，我们创建了一个函数:</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="8fd5" class="nm kd iq ni b gy nn no l np nq"><em class="ly"># Create an empty list</em><br/>df_hour_list = []<br/><br/><em class="ly"># Create a series with the different hours of the day</em><br/>hours = pd.Series(nyc.index.hour.unique().sort_values())<br/><br/><em class="ly"># Create a list of points for each hour of the day</em><br/>def create_list(hour):<br/>    df_hour_list.append(nyc.loc[nyc.index.hour == hour,<br/>                                ['start station latitude',<br/>                                 'start station longitude']].<br/>                        groupby(['start station latitude', <br/>                                 'start station longitude']).sum().reset_index().values.tolist())<br/>hours.apply(create_list);</span></pre><p id="a94e" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">之后，我们可以很容易地创建时间热图。</p><pre class="my mz na nb gt nh ni nj nk aw nl bi"><span id="2301" class="nm kd iq ni b gy nn no l np nq">from folium.plugins import HeatMapWithTime<br/><br/><br/><em class="ly"># Add trip events to the map</em><br/>map_time = folium.Map(location=location, <br/>                      tiles="CartoDB Positron", <br/>                      zoom_start=12)<br/><br/><br/>HeatMapWithTime(df_hour_list, <br/>                auto_play=True, <br/>                max_opacity=0.5, <br/>                gradient = {0.2: '#FBD973', <br/>                            0.4: '#fa782f', <br/>                            0.75: '#F16578', <br/>                            1: '#782890'}).add_to(map_time)<br/>map_time</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/1108dc72923e4d14e557c3e57a8d734b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D5Tv6C-YbgsT0A07JpfGHg.gif"/></div></div></figure><p id="c98d" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">目前就这些了，希望你觉得有用。</p><p id="b30e" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果你觉得它有帮助，请留下一些掌声来帮助我继续下去；)</p><p id="3a78" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">感谢阅读！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="d794" class="kc kd iq bd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz bi translated">参考</h1><p id="36a3" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae mw" href="https://automating-gis-processes.github.io/2018/index.html" rel="noopener ugc nofollow" target="_blank">赫尔辛基大学 AutoGIS 课程</a></p><p id="7657" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><a class="ae mw" href="https://jakevdp.github.io/PythonDataScienceHandbook/" rel="noopener ugc nofollow" target="_blank">杰克·范德普拉斯的 Python 数据科学手册</a></p><p id="a604" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><a class="ae mw" rel="noopener" target="_blank" href="/visualizing-air-pollution-with-folium-maps-4ce1a1880677">用树叶地图可视化空气污染</a></p><p id="f172" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><a class="ae mw" href="https://www.kaggle.com/daveianhickey/how-to-folium-for-maps-heatmaps-time-analysis" rel="noopener ugc nofollow" target="_blank">How to:follow for maps，heatmaps &amp;时间分析</a>作者 Dave Ian Hickey</p><p id="8ab8" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><a class="ae mw" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">叶子文档</a> <a class="ae mw" href="https://python-visualization.github.io/folium/plugins.html" rel="noopener ugc nofollow" target="_blank">叶子插件文档</a></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="0e94" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="ly">原载于</em><a class="ae mw" href="https://www.linkedin.com/pulse/visualizing-nyc-bike-data-interactive-animated-maps-folium-toso" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://www.linkedin.com</em></a><em class="ly">。</em></p></div></div>    
</body>
</html>