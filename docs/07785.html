<html>
<head>
<title>Constructing HTTP data pipelines with Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Flask 构建 HTTP 数据管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/constructing-http-data-pipelines-with-flask-27fba04fbeed?source=collection_archive---------16-----------------------#2019-10-28">https://towardsdatascience.com/constructing-http-data-pipelines-with-flask-27fba04fbeed?source=collection_archive---------16-----------------------#2019-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cc4849de251df6f33aaed5584c975018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVvohkgdf-42P6R9CwEYBw.png"/></div></div></figure><p id="5cd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">许多数据科学工作倾向于关注那些非常明显的属性，如训练模型、验证、统计……然而，如果没有可用的数据，所有这些技能最终都像是在泥沼中冲刺。如今用于在网络上传输数据的最大工具之一是 Flask。Flask 是一个非常棒的工具，通常用于在 Python 中创建数据驱动的 web 应用程序和管道。Flask 有大量的内置功能，可以与 SQL、Json 和 HTML 一起使用，这使得它非常适合 web 上的后端使用。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><blockquote class="lg"><p id="3bf1" class="lh li it bd lj lk ll lm ln lo lp ky dk translated">请求和返回</p></blockquote><p id="bdc5" class="pw-post-body-paragraph kb kc it kd b ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku lu kw kx ky im bi translated">为了拥有一个完全基于云的管道，以及相应的回报，我们需要了解 Flask 的请求和返回系统。对于计算型或信息型返回管道，通常会保留默认路线，或者:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0e78" class="me mf it ma b gy mg mh l mi mj"><a class="ae mk" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')</span></pre><p id="178f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着 Flask-app 的目录没有被更改，并允许我们在访问路由时执行一个函数。这可以比作“Index.html”</p><p id="78c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，我们知道我们在哪里，但是我们如何将超文本传输协议应用到 Flask 以接收数据和传输结果呢？为此，我们需要向我们的项目添加请求:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a49d" class="me mf it ma b gy mg mh l mi mj">from flask import Flask, render_template, request</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="fb75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个特殊的例子，我和我的一些同事一起做一个项目；全栈开发者、UI/UX 开发者、前端开发者。和往常一样，我有一个 Github 回购的源代码链接。我的任务是创建一个算法，该算法将获取房屋的某些属性，并返回一个预测，用户可以将该预测保存到他们的帐户中。最大的挑战是以一种特定的方式设置事情，以便他们的请求和我的回报可以正确地排列。如果你想看整个项目的 Github，这里是<a class="ae mk" href="https://github.com/FTBW-AppraisersBFF" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8e37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这个方法，我构建了我的 Sklearn 管道，并把它分配出去。让这变得困难的是数据中包含的大量观察结果…这很难处理，尤其是首先很难阅读。如果你不确定这样的事情是如何做的，你可以在这里查看<a class="ae mk" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Exploratory_zillow.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本。</a></p><p id="e326" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我选择的模型是 XGBoost 回归器，对于这种情况，它有自己的优点和缺点。最大的缺点是一个不重要的特性会扭曲结果。我只用了几个特征，就像我们数据科学家所做的那样，我可以用统计数据证明这些特征对模型的结果有重大影响，然后用标准标量把它放入管道，以提高一点准确性。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7308" class="ml mf it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">最后请求！</h1><p id="7f8c" class="pw-post-body-paragraph kb kc it kd b ke ni kg kh ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky im bi translated">你曾经看过地址栏，并在谷歌搜索中读出网址吗？您可能会看到类似这样的内容:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="c4db" class="me mf it ma b gy mg mh l mi mj">search=hello%where%are%we?</span></pre><p id="c1dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为 Google 的整个网站都是建立在 HTTP 请求之上的，当然这和返回管道有一点不同，但是不管怎样，这就是这个方法的价值范围。</p><p id="1c37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用函数从 flask 请求传输协议 URL 信息</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1169" class="me mf it ma b gy mg mh l mi mj">request.args</span></pre><p id="eb23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以在我的项目中，我做了这样的事情:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="039a" class="me mf it ma b gy mg mh l mi mj">try:        <br/>  bathrooms = request.args['bathrooms']        <br/>  bedrooms = request.args['bedrooms']        <br/>  squarefeet = request.args['squarefeet']        <br/>  yearbuilt = request.args['yearbuilt']    <br/>except KeyError as e:        <br/>  return ('Some Values are missing')</span></pre><p id="4390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是在当前的 http 请求中请求参数，以便将参数引入 Python。因此，如果我们请求应用程序的路线，比如:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="227f" class="me mf it ma b gy mg mh l mi mj">ourapp.com/?<a class="ae mk" href="https://predictorman.herokuapp.com/?bedrooms=5&amp;bathrooms=2&amp;squarefeet=1500&amp;yearbuilt=1988" rel="noopener ugc nofollow" target="_blank">bedrooms=5&amp;bathrooms=2&amp;squarefeet=1500&amp;yearbuilt=1988</a></span></pre><p id="5573" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的请求会带来:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9b90" class="me mf it ma b gy mg mh l mi mj">bedrooms = 5<br/>bathrooms = 2<br/>squarefeet = 1500<br/>yearbuilt = 1988</span></pre><p id="1479" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很酷，对吧？你也可以在这里测试一下。但现在我们进入了利用这条管道的有趣部分，即返回所请求的信息。还记得我们基于工作的管道吗？我们现在可以把它带进我们的 Flask 应用程序</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="163f" class="me mf it ma b gy mg mh l mi mj">from joblib import load<br/>pipeline = load('alg.sav')</span></pre><p id="4445" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最终将所有的值都放入一个观察数据框中，因为这似乎是最容易处理的。最后但同样重要的是，我们可以使用管道进行预测，并返回结果:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1527" class="me mf it ma b gy mg mh l mi mj">estimate = pipeline.predict(dcry)        <br/>return str(int(estimate))</span></pre><p id="f785" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们在应用程序的路径目录下的最后一个功能是:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f6fd" class="me mf it ma b gy mg mh l mi mj">def template():<br/>    try:<br/>        bathrooms = request.args['bathrooms']<br/>        bedrooms = request.args['bedrooms']<br/>        squarefeet = request.args['squarefeet']<br/>        yearbuilt = request.args['yearbuilt']<br/>    except KeyError as e:<br/>        return ('Some Values are missing')<br/>    try:<br/>        bathrooms = float(bathrooms)<br/>        bedrooms = float(bedrooms)<br/>        squarefeet = float(squarefeet)<br/>        yearbuilt = int(yearbuilt)<br/>    except ValueError as e:<br/>        return ('That aint a number, Cowboy.')<br/>    else:<br/>        dcry = pd.DataFrame({"YearBuilt": [yearbuilt],        "LotSize": [squarefeet],"Bedrooms": [bedrooms],        "Bathrooms": [bathrooms]})<br/>        pipeline = load('alg.sav')<br/>        estimate = pipeline.predict(dcry)<br/>        return str(int(estimate))</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5c69" class="ml mf it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">最后</h1><p id="2b15" class="pw-post-body-paragraph kb kc it kd b ke ni kg kh ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky im bi translated">这些管道绝对可以成为任何数据驱动的应用程序的基础。拥有一个独立的实体的好处是显而易见的，尽管这也可以在本地应用程序中实现。无论你是想返回 k-best 结果，还是想预测一栋房子的价格，数据管道都是一种非常好的方式，可以完全独立地在幕后完成。</p></div></div>    
</body>
</html>