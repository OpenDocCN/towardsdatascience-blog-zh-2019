<html>
<head>
<title>How I used Machine Learning to detect chat screenshots on my phone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用机器学习来检测手机上的聊天截图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-used-machine-learning-to-detect-chat-screenshots-on-my-phone-a46d875b07af?source=collection_archive---------10-----------------------#2019-12-21">https://towardsdatascience.com/how-i-used-machine-learning-to-detect-chat-screenshots-on-my-phone-a46d875b07af?source=collection_archive---------10-----------------------#2019-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9777814367749506e5fde660d834cf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ln7ur4uxI-2QLiP1yUxVJQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Image from Unsplash</figcaption></figure><p id="139d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi ld translated">有些时候，我们不是告诉朋友我们在某个消息应用程序上的聊天，而是把那次聊天的截图发给他们。如果你发送或接收了大量的截图，那么最终你手机的大部分内存会被封锁。我就是这种情况。在保证重要图像安全的同时找到并删除这些截图是一项极其耗时的任务。然后一个简单的(假设对 ML 有一点了解)想法出现在我的脑海里…</p><h1 id="c3fe" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">想法</h1><p id="531f" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">我意识到<strong class="kh iu">从普通图像中检测聊天截图的任务可以表述为一个经典的二值图像分类问题！</strong>我们可以使用卷积神经网络(CNN)来完成这项工作。CNN 的输入层将是一个图像，输出层将只包含一个神经元，告诉我们输入图像是正常图像还是聊天截图。在接下来的章节中，我将介绍构建模型的所有细节。</p><h1 id="9c09" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">数据收集</h1><p id="e536" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">在机器学习中，一切从数据开始。在这个分类问题中，我们有<strong class="kh iu">两类:【聊天】和【不聊天】</strong>。第一个表示聊天截图，另一个表示普通图片。所以我收集了我和朋友们在不同消息应用上聊天的截图，比如 WhatsApp，Messenger，Instagram 等等。第二节课，我从手机和互联网上收集了一些人物、地点、风景的随机图片。总共我拍了<strong class="kh iu"> <em class="mp"> 660 张</em> </strong>图片(每班<strong class="kh iu"> <em class="mp"> 330 张</em> </strong>)。请注意，对于许多更难的问题来说，这些数据量是不够的。</p><h1 id="af9a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">列车测试分离</h1><p id="0632" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">我用<strong class="kh iu"> <em class="mp"> 80% </em> </strong>的数据进行训练，剩下的用于测试。为了能够在 Keras 中使用 flow_from_directory 函数，我像这样组织数据…</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a966f2bfa1131206c14534fb477f064c.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*45hbFBc0boSOBOoURxY3iA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Folder tree of data</figcaption></figure><h1 id="8774" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">构建模型</h1><p id="4126" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">每个 CNN 由两个主要部分组成:卷积基和全连接网络。在卷积库中，我使用了两个卷积块，每个包含<strong class="kh iu"> <em class="mp"> 32 个</em> </strong>滤波器。内核大小为<strong class="kh iu">T5】3 * 3T7】。第一个卷积层的输入尺寸为<strong class="kh iu"> <em class="mp"> 64*64*3 </em> </strong>(大小为<strong class="kh iu"> <em class="mp"> 64 px*64 px </em> </strong>的 RGB 图像)。每个卷积块后面是一个大小为<strong class="kh iu"> <em class="mp"> 2*2 </em> </strong>的 max_pooling 层。Relu 激活功能用于卷积层。卷积模块的输出被展平为一个向量，以将其传递给全连接网络。隐藏层由<strong class="kh iu"> <em class="mp"> 128 个</em> </strong>神经元组成。该层的激活功能再次被 Relu。输出层(即最后一层)只包含一个告诉我们结果的神经元。由于这是一个二进制分类问题，我在这一层使用了 sigmoid 函数，该函数输出一个在<strong class="kh iu"> <em class="mp"> 0 </em> </strong>到<strong class="kh iu"> <em class="mp"> 1 </em> </strong>之间的数字(<strong class="kh iu"> <em class="mp"> p </em> </strong>)，表示输入图像属于“聊天”类别的概率(如果<strong class="kh iu"> <em class="mp"> p≤0.5 </em> </strong>，则“聊天”否则“不聊天”)。下面是实现…</strong></p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/ab18a3a2b1948f00e11b4596ee9e2bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuALbv73z7q8BtBK03BT2A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">The architecture of the model</figcaption></figure><h1 id="e42e" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">输入数据</h1><p id="4b87" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">由于数据是以上面提到的特定方式组织的，现在我们可以使用 Keras 的<strong class="kh iu"> ImageDataGenerator </strong>类和<strong class="kh iu"> flow_from_directory </strong>方法来扩充并将其提供给模型。首先，创建一个 ImageDataGenerator 对象。在这个对象的帮助下，我使用了缩放，剪切，翻转变换来增加数据。图像应通过系数<strong class="kh iu"> <em class="mp"> 1/255.0 </em> </strong>进行重新缩放，以标准化像素值。现在，目录路径、class_mode 和 target_size 作为 flow_from_directory 方法的参数传递，这有助于将数据提供给模型。我们必须将这个过程进行两次(一次用于训练数据，另一次用于测试数据)。<strong class="kh iu">这里需要记住的一件重要事情是，只有训练数据需要扩充，而不是测试数据。</strong>这是关于这个的代码…</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="c206" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">培养</h1><p id="b2d1" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">现在到了模型学习的部分。这里我们需要一个优化器，因为学习只不过是通过更新模型的权重和偏差来优化成本函数。在这种情况下，我选择了<strong class="kh iu"> Adam optimizer </strong>。成本函数是<strong class="kh iu">二元交叉熵</strong>(因为这是二元分类)。Keras 提供了一个名为<strong class="kh iu"> fit_generator </strong>的函数，可以用来运行训练。在这里，我们还可以设置历元数、每历元步数和验证步数。由于数据相对较少，因此我使用了<strong class="kh iu"> steps_per_epoch =训练样本数</strong>和<strong class="kh iu"> validation_steps =测试样本数。</strong></p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="b032" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结果</h1><p id="e0d8" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">仅经过<strong class="kh iu"> <em class="mp"> 5 </em> </strong>个历元后，模型达到了<strong class="kh iu"><em class="mp"/></strong>99%的训练准确率和<strong class="kh iu"><em class="mp"/></strong>98%的测试准确率。一旦我们保存了模型，我们就可以多次使用它。为了能够使用该模型预测新图像，我们必须将图像整形为<strong class="kh iu"> <em class="mp"> 64*64*3 </em> </strong>并对像素进行归一化。这个<a class="ae my" href="https://github.com/Suji04/Chat_ScreenShot_Classifier/blob/master/load%20model%20and%20predict.py" rel="noopener ugc nofollow" target="_blank">脚本</a>为我们做了这项工作。以下是一些预测示例…</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/35d912d37035b34286676566550aebc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bhMdrjDZEEWuTmIYAQwPg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Images from the author’s collection</figcaption></figure><p id="b65b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这里找到完整的代码<a class="ae my" href="https://github.com/Suji04/Chat_ScreenShot_Classifier" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="c949" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如果你真的很兴奋</h1><p id="b88d" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">要使用这个模型来分类手机<strong class="kh iu"> </strong>上一个文件夹的所有图像，你只需要遍历这个文件夹，一次传递一个图像给这个模型。类似这样的…</p><pre class="mr ms mt mu gt na nb nc nd aw ne bi"><span id="4f2e" class="nf ln it nb b gy ng nh l ni nj">import glob<br/>for img_file in glob.iglob(“dir_name/*”):<br/>  new_image = load_image(img_file)<br/>  pred = classifier.predict(new_image)<br/>  if pred&lt;.5 : print(“chat”)<br/>  else : print(“not chat”)</span></pre><h2 id="c7c8" class="nf ln it bd lo nk nl dn ls nm nn dp lw kq no np ma ku nq nr me ky ns nt mi nu bi translated">还好奇？看一个我最近做的视频…</h2><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nv mw l"/></div></figure><p id="a8d1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你喜欢阅读。下次见…学习愉快！</p></div></div>    
</body>
</html>