<html>
<head>
<title>Understanding how the perceptron really works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解感知机是如何工作的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-how-the-perceptron-really-works-234b1b7cf44b?source=collection_archive---------15-----------------------#2019-10-07">https://towardsdatascience.com/understanding-how-the-perceptron-really-works-234b1b7cf44b?source=collection_archive---------15-----------------------#2019-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/21b5bd21a6e2003302b94d9839b3748c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZK8Dtx88dnTXramM.png"/></div></div></figure><div class="kb kc gp gr kd ke"><a href="https://bobbywlindsey.ck.page/5dca5d4310" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab fo"><div class="kg ab kh cl cj ki"><h2 class="bd iu gy z fp kj fr fs kk fu fw is bi translated">想在数据科学方面变得更好吗？</h2><div class="kl l"><h3 class="bd b gy z fp kj fr fs kk fu fw dk translated">当我在我发布独家帖子的媒体和个人网站上发布新内容时，请单击此处获得通知。</h3></div></div></div></a></div><p id="dabf" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">感知器模型是一种二元分类器，其分类基于线性模型。所以，如果你的数据是线性可分的，这个模型会找到把它分开的超平面。该模型是这样工作的:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lk"><img src="../Images/7e8ac4445eee33231373ddbf63efdee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xcnMYwOBjo9hfWlL.jpeg"/></div></div></figure><p id="afc5" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">本质上，对于一个给定的样本，你把每个特征，<em class="lp"> x_i </em>，乘以它自己的权重，<em class="lp"> w_i </em>，然后求和。然后取这个和，应用激活函数。这将是你的预测。但是你用哪个激活功能呢？</p><h1 id="f5b4" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">激活功能</h1><p id="e349" class="pw-post-body-paragraph km kn it ko b kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj im bi translated">二元分类标签一般出现为<em class="lp"> {-1，1} </em>或<em class="lp"> {0，1} </em>。感知器模型中使用的激活函数将取决于您选择哪组二进制标签。如果您选择<em class="lp"> {0，1} </em>，您将需要使用<a class="ae mt" href="https://en.wikipedia.org/wiki/Heaviside_step_function" rel="noopener ugc nofollow" target="_blank"> Heaviside 阶跃函数</a>作为您的激活函数，因为它接受任何实数并输出 0 或 1。否则，您将使用<a class="ae mt" href="https://en.wikipedia.org/wiki/Sign_function" rel="noopener ugc nofollow" target="_blank">符号功能</a>。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Sign and heaviside step functions</figcaption></figure><h1 id="6c92" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">获取数据</h1><p id="ae9a" class="pw-post-body-paragraph km kn it ko b kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj im bi translated">假设你的二进制标签是<em class="lp"> {0，1} </em>。感知器模型预测将是</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b7e008364d34d7eed12f38b92a11962b.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*W9fEjC1V55QcrkW1L8oUlQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Equation 1</figcaption></figure><p id="ca9f" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">产生 0 或 1。让我们来看看一个快速的例子，其中一些数据来自 Jason Brownlee 的博客<a class="ae mt" href="https://machinelearningmastery.com/implement-perceptron-algorithm-scratch-python/" rel="noopener ugc nofollow" target="_blank">机器学习大师</a>。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1171ab04c326307aa1db455d50099314.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/0*ifA2dCI4ZYQkKcyq.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">The data</figcaption></figure><p id="3b09" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">让我们将数据帧分成训练数据和标签。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/803a1c943922736ffce3e4367d4e97f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/0*luu0Ai7ocOujiZOr.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Features of the data</figcaption></figure><h1 id="59df" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">感知器推理</h1><p id="1386" class="pw-post-body-paragraph km kn it ko b kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj im bi translated">要从感知器模型获得预测，您需要实现等式 1。回想一下，等式 1 的矢量化等价物就是</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4253dcfb4beee5b75d3b34ed395a781e.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*AZbQfhOhKXJeAUlu7mMikA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Vectorized Equation 1</figcaption></figure><p id="5765" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">权重向量<em class="lp"> w </em>和特征向量<em class="lp"> x </em>的点积。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0800" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">所以你有<em class="lp"> x </em>，它代表一个样本，其中<em class="lp"> x_i </em>是该样本的一些特征(比如<code class="fe ne nf ng nh b">has_scales</code>或<code class="fe ne nf ng nh b">has_fur</code>，如果你试图预测哺乳动物与爬行动物)。但是你从哪里得到重量呢？这就是感知器模型需要从你的标记样本中学习的东西。开始时，你不知道这些值应该是什么，所以你可以让它们全是零。</p><p id="ff18" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">尝试预测第一个样本:</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ll lm ln lo gt ni nh nj nk aw nl bi"><span id="86cc" class="nm lr it nh b gy nn no l np nq">Prediction: 1.0, Label: 0, Error: -1.0</span></pre><p id="771a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">不出所料，这个模型做得并不太好。让我们看看你是否能想出一种方法，让感知器模型学习它需要什么样的权重才能输出预期的标签。</p><h1 id="422d" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">教感知机学习</h1><p id="a32a" class="pw-post-body-paragraph km kn it ko b kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj im bi translated">首先，你需要指定一个损失函数来告诉你你的模型做得有多差。损失越低越好。对于我们的示例，您可以使用误差平方和作为损失函数:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a0fa5f320f58350e2ad63b9906a4d9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*N6L3UBMsuHIMsR4WBMNsKg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Sum of squared errors (our loss function)</figcaption></figure><p id="7afc" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">其中<em class="lp"> yhat_i </em>是感知器模型的预测，而<em class="lp"> y </em>是预测应该是什么(即标签)。该函数简单地确定预测值和真实值之间的平方距离，并将所有这些距离相加。</p><p id="4766" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">与大多数现代机器学习方法一样，您现在可能会尝试使用梯度下降法，即获取上述损失函数相对于权重的梯度，并使用该梯度在最小化损失的方向上更新权重。产生的梯度将是:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2d51ec6a1f8383cb62b7b8e973049e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*udIGCsZmpozPwbNFuek3kA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Gradient of the loss function, but there’s a problem…</figcaption></figure><p id="a3b9" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">但是你看到这里的问题了吗？阶跃函数的导数在任何地方都是 0，除了在没有定义的<em class="lp"> x = 0 </em>处。这将迫使整个梯度为 0，权重永远不会更新。感知器模型永远不会学习。同样的问题也困扰着 sign 函数。</p><p id="fa74" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">那么如何更新权重呢？事实证明，如果您的数据是线性可分的，那么下面的权重更新规则可以保证(通过<a class="ae mt" href="http://www.cs.ubbcluj.ro/~csatol/kozgaz_mestint/4_neuronhalo/PerceptConvProof.pdf" rel="noopener ugc nofollow" target="_blank">收敛定理证明</a>)在有限的步骤中收敛到一组权重，从而将数据线性分成两个不同的类。此更新规则定义为:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/22560663519f9544ea73fc7c4a6c3bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*-BYha4CRTKls0VO20zMHWg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Weight-update rule for the perceptron</figcaption></figure><p id="60e2" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">并且仅在<em class="lp"> x </em>被感知器模型错误分类时应用。</p><p id="0483" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">但是这个更新规则是在假设二进制标签是<em class="lp"> {-1，1} </em>，而不是<em class="lp"> {0，1} </em>的情况下推导出来的。如果您的标签是<em class="lp"> {-1，1} </em>，那么更新规则中的<em class="lp"> y </em>将是-1 或 1，从而改变权重更新的方向。</p><p id="b7e8" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">但是因为你的二进制标签是<em class="lp"> {0，1} </em>，这就出现了一个问题，因为<em class="lp"> y </em>可能是 0。这意味着如果一个<em class="lp"> x </em>被错误分类，并且它的真实值是 0，那么<em class="lp"> w = w + 0 x = w </em>并且权重永远不会被更新。</p><p id="8162" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">幸运的是，您可以通过修改更新规则来解决这一问题，该规则仍然保证收敛，但同时适用于作为二进制标签的<em class="lp"/><em class="lp">{-1，1} </em>和<em class="lp"> {0，1} </em>:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/69dd1eaf064a5b960697f2edd0420f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*wCXEBLoXWgqRvmdgALpITg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">The more flexible weight-update rule</figcaption></figure><p id="e296" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">请注意，如果您的二进制标签是<em class="lp"> {0，1} </em>，<em class="lp"> (y - yhat) </em>如果感知器模型预测正确(从而保持权重不变)，则为 0，如果预测不正确，则为 1 或-1(这将确保权重在正确的方向上更新)。如果你的二进制标签是<em class="lp"> {-1，1} </em>，<em class="lp"> (y - yhat) </em>如果感知器模型预测正确就是 0，如果预测错误就是 2 或者-2。这个修正的权重更新规则确保了正确的方向变化，无论你选择哪组二进制标签。</p><p id="8c85" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在您已经知道如何更新权重，试着取一个样本，预测它的标签，然后更新权重。对每个样品重复上述步骤。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ll lm ln lo gt ni nh nj nk aw nl bi"><span id="5859" class="nm lr it nh b gy nn no l np nq">SSE: 2.0<br/>Weights: [4.84644761, 0.20872523, 0.]</span></pre><p id="c6dd" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">看起来感知器模型还没有找到完美区分这两个类别的权重。不如你给它更多的时间来学习，通过多次通过数据。让我们试三次传球。</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ll lm ln lo gt ni nh nj nk aw nl bi"><span id="abb0" class="nm lr it nh b gy nn no l np nq">SSE: 2.0<br/>SSE: 1.0<br/>SSE: 0.0<br/>Weights: [ 2.06536401, -2.34181177, -1.]</span></pre><p id="8bf3" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">不错！误差平方和为零，这意味着感知器模型在分离数据时不会产生任何误差。</p><h1 id="4317" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">适用于不同二进制标签的感知器</h1><p id="88e8" class="pw-post-body-paragraph km kn it ko b kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj im bi translated">现在说你的二进制标签是<em class="lp"> {-1，1} </em>。使用上面相同的数据(用-1 替换标签的 0)，可以应用相同的感知器算法。这一次，你会看到<em class="lp"> w = w + y x </em>和<em class="lp"> w = w + (y - yhat) x </em>都找到了一组权重来正确分离数据(即使权重不同)。</p><p id="6fbc" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">以下是感知器模型，其更新规则为<em class="lp"> w = w + y x </em>:</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ll lm ln lo gt ni nh nj nk aw nl bi"><span id="20e8" class="nm lr it nh b gy nn no l np nq">SSE: 5.0<br/>SSE: 4.0<br/>SSE: 0.0<br/>Weights: [ 2.06536401, -2.34181177, -1.]</span></pre><p id="5618" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在用<em class="lp"> w = w + (y — yhat) x </em>作为更新规则:</p><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ll lm ln lo gt ni nh nj nk aw nl bi"><span id="ec36" class="nm lr it nh b gy nn no l np nq">SSE: 5.0<br/>SSE: 8.0<br/>SSE: 0.0<br/>Weights: [ 3.98083288, -6.85733669, -3.]</span></pre><p id="e7e0" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">两者融合！</p><h1 id="bcf3" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">包扎</h1><p id="d147" class="pw-post-body-paragraph km kn it ko b kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj im bi translated">在这篇文章中，你已经学习了什么是感知机模型，它可以应用于什么样的数据，模型背后的数学和它如何学习，以及用 Python 实现你的所有发现！</p><p id="718f" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">当然，在现实环境中，您会希望交叉验证您的模型，并且最好使用 scikit-learn 等库中可用的模型的可靠实现。但我希望这种感知机模型下的窥视有所帮助，如果你有任何问题，请随时通过<a class="ae mt" href="https://www.bobbywlindsey.com" rel="noopener ugc nofollow" target="_blank">bobbywlindsey.com</a>联系我，或者通过<a class="ae mt" href="https://medium.com/@bobbylindsey" rel="noopener">媒体</a>或<a class="ae mt" href="https://twitter.com/bobbywlindsey/" rel="noopener ugc nofollow" target="_blank">推特</a>关注我。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="22be" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><em class="lp">原载于 2019 年 10 月 7 日</em><a class="ae mt" href="https://www.bobbywlindsey.com/2019/10/06/understanding-the-perceptron/" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://www.bobbywlindsey.com</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>