<html>
<head>
<title>Powering SQL With Machine Learning Capabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用机器学习能力驱动 SQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/powering-sql-with-machine-learning-capabilities-24eba7d0914c?source=collection_archive---------17-----------------------#2019-11-15">https://towardsdatascience.com/powering-sql-with-machine-learning-capabilities-24eba7d0914c?source=collection_archive---------17-----------------------#2019-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="17f8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用单词嵌入在 SQL 中启用语义查询</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6f41cb6e112bf9151c3c6003203d0dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eNXdDiQ2e0S0pnW3ib3lXw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@nate_dumlao?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nathan Dumlao</a> on <a class="ae le" href="https://unsplash.com/s/photos/similar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e1d4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当今世界，对机器学习的需求越来越大。这导致了巨大的努力来减少这些任务所需的技能/努力。最有希望的策略之一是将这些功能整合到标准 SQL 中，它始于 Oded Shmueli <a class="ae le" href="https://arxiv.org/abs/1712.07199" rel="noopener ugc nofollow" target="_blank">论文</a>，并在<a class="ae le" href="https://github.com/gyang274/visual-search" rel="noopener ugc nofollow" target="_blank">弹性搜索</a>和<a class="ae le" href="https://github.com/guenthermi/postgres-word2vec" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>中得以实现。</p><p id="2a43" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了在 SQL 中启用这些功能，我们需要向数据库实体(行/列/表)插入实际的语义。我们通过将单词嵌入向量合并到我们数据库中来做到这一点。因此，我们可以询问诸如“显示与此行相似的所有行<em class="md">这是标准 SQL 无法做到的。</em></p><p id="ef65" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们需要在数据库中变得神奇的是以正确的方式加入单词嵌入。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi me"><img src="../Images/b86b905042a0b42d242e9f6a77a049bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*o10nRVGBtxAMd_33xeaFBQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">All we need to get magic in our database is to incorporate word embedding in the right way</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d852" class="jq jr it bd js jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn bi translated">它是如何工作的</h1><p id="8a73" class="pw-post-body-paragraph lf lg it lh b li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">为了量化数据库内部的语义关系，除了所有数据库关系之外，还需要一种以某种方式表示它们的语义的方法。</p><p id="74d4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">嵌入是一种将序列映射到数字向量空间的技术，其中向量表示相关序列的各个方面(嵌入使用的是<a class="ae le" href="https://medium.com/towards-artificial-intelligence/an-intuitive-introduction-of-word2vec-by-building-a-word2vec-from-scratch-a1647e1c266c" rel="noopener"> word2vec </a>)。提出的解决方案是构建数据库实体的嵌入，以表示它们的语义，然后访问这些向量(通过用户定义的函数)并比较它们的接近度(通过用户定义的函数)。</p><p id="7772" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下图描述了查询执行的主要阶段:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/0ac9951364cb8072536fc23db0bee29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmfRQinjbhIXh0G6XjCulQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">We start by getting a SQL query with UDFs from the user and executing it, to execute the query the sentences are tokenized and the relational vectors are calculated and returned to the user.</figcaption></figure><p id="1ed1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，我们将通过允许使用以下 UDF 量化数据库内部的语义关系来增强查询:</p><ul class=""><li id="d670" class="mx my it lh b li lj lm ln lq mz lu na ly nb mc nc nd ne nf bi translated"><strong class="lh iu">余弦距离(a，b) </strong>取向量 a，b 返回它们的余弦距离。</li><li id="96b8" class="mx my it lh b li ng lm nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lh iu"> vec(token) </strong>接受一个令牌并返回其相关向量。</li><li id="7778" class="mx my it lh b li ng lm nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lh iu">令牌实体 e </strong>声明了一个可以绑定到令牌的变量。</li><li id="a06e" class="mx my it lh b li ng lm nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lh iu"> Contain(row，entity) </strong>声明实体必须绑定到 tokenizing row 生成的 token。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4903" class="jq jr it bd js jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn bi translated">它增加了什么功能</h1><p id="9107" class="pw-post-body-paragraph lf lg it lh b li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">我之前展示的那些构建模块将允许进行高级查询，首先，我们可以运行“语义相似性查询”。</p><p id="958d" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如<em class="md">“按行业查找与潜在客户(语义)最相似的客户”。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/062b6b64bbe0c3c9b147066e265d0675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKjt0q1r15Iv4hQHvPhbhA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">We find all pairs of products a,b (only once per pair) and order those by similarity.</figcaption></figure><p id="f115" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">回想一下单词嵌入也支持归纳推理(经典<a class="ae le" href="https://blog.acolyer.org/2016/04/21/the-amazing-power-of-word-vectors/" rel="noopener ugc nofollow" target="_blank">国王之于男人就像女王之于？</a>)，换句话说，我们可以计算类比。</p><p id="99a1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，<em class="md">“</em>找到所有与自己相关的产品 a、b 对，就像花生酱与果冻的关系<em class="md">”。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/fe3be1021ef389b937ec1fcd18a34013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Twzy71-7tKSfilR1o2mBQw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">First, we create a table with product names and the distance between them and the jelly/peanut butter vector. Afterward, we find all pairs of products a,b which relate close (from distance perspective) to themselves as peanut butter relates to jelly.</figcaption></figure><p id="4751" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对数据库实体(如列、行甚至表)进行模糊连接的另一组新功能。在许多用例中，人们希望在不确切知道列/表需要使用什么的情况下运行查询。</p><p id="21ba" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，“在票证和用户之间给定未知模糊外键的情况下，查找用户‘Moshe’的所有票证”。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/ee5768e4ce032a9fd5e8f1d86c96a1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmOxtDcgdNOHTU0bxHTXmA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">First, we declare two tokens e1, e2 that represent in our database and in our use case unknown column. Afterward, we find all the users called Moshe and find their tickets, since we don’t know the join columns on the ticket table we try to join on every column and keep those with small similarities. Note: we could enforce a 1:1 relation with rank with the distance ordered.</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cf0b" class="jq jr it bd js jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn bi translated">定论</h1><p id="df59" class="pw-post-body-paragraph lf lg it lh b li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">这是向赋予数据库系统机器学习能力的一步。这些功能适用于各种各样的应用程序(包括数据集成、搜索等等)。</p><p id="d688" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望你觉得有趣和有用，我愿意接受任何建设性的反馈。</p></div></div>    
</body>
</html>