# 用 Python 在遗传学中使用正则表达式

> 原文：<https://towardsdatascience.com/using-regular-expression-in-genetics-with-python-175e2b9395c2?source=collection_archive---------11----------------------->

## 如何在生物序列数据中发现模式

![](img/ccf4a7777674c49c459106c6a85c99df.png)

Image Courtesy of National cancer Institute via [Unsplash](https://unsplash.com/photos/J28Nn-CDbII)

Python 中的正则表达式(regex)可以用来帮助我们发现遗传学中的模式。当我们分析生物序列数据时，我们可以利用正则表达式，因为我们经常在 DNA、RNA 或蛋白质中寻找模式。这些序列数据类型只是字符串，因此非常适合使用 regex 进行模式分析。我们可能有兴趣寻找:导致人类疾病的核苷酸重复序列、DNA 转录因子结合位点、限制性酶切位点和特定突变。为了能够使用 regex 实现这一点，我们必须首先掌握 regex 的基本语法和一些特定于 regex 模块的函数。在本教程的第一部分，例子将使用 4 个 DNA 核苷酸；a，T，G，c。

这个简短的教程旨在:

1.介绍正则表达式语法，并举例说明遗传学

2.展示我们如何使用普通的正则表达式函数来寻找模式

## **正则表达式**

以下字符在正则表达式中是特殊的:$^.*+?{ } [ ] | \并在表 1 中显示了相应的描述。^和$元字符被称为锚点，代表输入字符串中的位置。^匹配字符串的开头，而$匹配字符串的结尾。模式^CCC 将匹配 CCCGGG，但不匹配 GGGCCC。模式 AAA$将匹配 TTTAAA，但不匹配 AAAGGG。

答。句点(或小数点)是查找任何字符的通配符。如果蛋白激酶具有共有序列“RXYVHXFDEXK ”,其中 X 表示任何氨基酸，那么正则表达式“R.YVH.FDE.K”将成功搜索底物。但是，需要注意的是，句号(。)，将匹配任何甚至不是字母的字符。因此，模式“R.YVH.FDE.K”将匹配“R8YVH FDE&K”，这可能不是我们想要的。

元字符，*，+，？、和{ }是量词运算符。这些用于指定字符或字符组的重复。字符或组后面的星号表示该字符或组是可选的，但也可以重复。遗传学领域中使用星号元字符的一个例子是，当我们搜索 RNA-seq reads 以通过搜索 AAAAAA*找到 3’-聚腺苷酸化的序列时。这个正则表达式将精确地找到 5 个 A，后面跟着零个或更多个 A。+元字符类似于*，只是它会一次或多次找到该字符。答？零次或一次查找前面的字符或字符组。

如果需要具体或者匹配特定的重复次数，我们可以使用花括号符号。花括号中的单个数字将与前面的字符或组中的重复次数完全匹配。例如，CA{3}GATT 将匹配 CAAAGATT，但不匹配 CAAGATT 或 CAAAGATT。要指定一个范围，我们可以使用相同的花括号语法，并使用一般模式，其中{ *n* ， *x* }查找在 *n* 和 *x* 时间之间的前一个字符或组。例如，TCG{2，4}A 将匹配模式 TCGGA、TCGGGA、TCGGGA，但不匹配 TCGA 或 TCGGGGGA。表 1 总结了这些元字符。

![](img/4f117cc0bb4b83fc7110124d7f92d037.png)

## **匹配一个图案**

re 模块用于在 Python 中编写正则表达式(regex)。要加载这个模块，我们需要使用 import 语句。以下代码行必须包含在代码的顶部:

**进口** re

为了使用正则表达式模块中的工具，有必要在它前面加上模块名。最简单的正则表达式函数 re.search()确定模式是否存在于字符串中的某个位置。re.search()有两个参数，都是字符串。第一个参数是要搜索的模式，第二个参数是要搜索的字符串。为了清楚起见，在下面的例子中，我包含了两个参数作为关键字参数。通常没有必要包含这些关键字参数。为了完整起见，我包括了被注释掉的另一个 syntaxic 版本。

下面的代码演示了一个简单的例子；在这里，我们正在寻找一个硬编码 DNA 变量中 A 碱基的三核苷酸重复序列的存在。

许多 re 函数调用的输出是一个匹配对象。如果我们查看上面的匹配对象，我们可以确定是否有匹配。span 标识出现匹配的字符串的索引，而 match 标识得到匹配的确切字符串。

正则表达式搜索也可以用作条件语句的一部分:

## **提取匹配对象值**

通常在我们的脚本中，我们不仅要确定是否匹配，还要确定匹配发生在哪里。我们可能还想提取匹配*本身*。幸运的是，Python 使得提取匹配对象值变得很简单，比如匹配的索引位置和匹配的确切字符串。这可以通过在 match 对象上使用一些方法来实现。

## **交替和字符组**

re.search()也可以用来寻找更灵活的模式。举例来说，NCII 限制酶识别核苷酸序列模式“CCSGG”，其中核苷酸代码“S”可以是 C 或 g。我们可以使用一个改变来捕获这种变化，而不是编写两个正则表达式搜索。这里，为了表示许多不同的替代项，我们将替代项写在括号内，并使用管道字符将它们分隔开(元字符|也称为交替运算符，请参见表 1)。

交替组的实用性来自于它们作为重复单位的能力。例如，为了确定一个序列是否由起始和终止密码子限定，并因此有可能成为开放阅读框，我们可以编写以下正则表达式:

这个正则表达式将在序列的末尾搜索 UAA、UAG 和 UGA。为了改进这个正则表达式，并确保起始和终止密码子在同一个框架中，我们可以将正则表达式改为:

这将检查起始和终止密码子之间的所有字符都是 3 的倍数。

## 字符组

字符组也可以用来捕捉单个模式中的变化。考虑蛋白质中共有的 N-糖基化位点。该序列基序具有以下模式:Asn，后跟除 Pro 以外的任何东西，后跟 Ser 或 Thr，后跟除 Pro 以外的任何东西。

使用相应的单字母氨基酸代码和字符组，我们可以将此模式写为:

这种模式将识别单个字母代码 N，后跟任何不是 P 的字符(参见表 1，取反的字符组)，后跟 S 或 T，再后跟任何不是 P 的字符。一对带有字符列表的*方括号*可以表示这些字符中的*任何*(参见表 1)。

## **Regex 的威力**

当这些工具一起使用时，regex 的真正威力就发挥出来了。考虑下面的场景。许多人类遗传性神经退行性疾病，如亨廷顿氏病(HD ),都与特定基因中三核苷酸重复数目的异常扩增有关。HD 的病理严重程度与编码亨廷顿蛋白的基因 *htt* 的外显子-1 中的(CAG) *n* 重复的数量相关。在亨廷顿氏病中，重复次数越多意味着疾病发作越早，疾病进展越快。CAG 密码子指定谷氨酰胺，HD 属于一大类多谷氨酰胺疾病。这种基因的健康(野生型)变异体具有 6-35 个串联重复，而超过 35 个重复几乎肯定会患病。

我们可以使用正则表达式来破译多聚谷氨酰胺重复数。这首先包括写一个模式以找到高于设定阈值的三核苷酸重复数。

密码子 CAA 也编码谷氨酰胺，因此，在上面的 htt_pattern 中，我们必须使用| alternation 操作符。然后，我们可以使用上面讨论的花括号符号来指定我们希望找到这个模式的次数。在这里，我选择了 18 次或更多次，通过*故意*离开上限。

![](img/fb16cfe7b67c7652a5c9dcaaf1c9254b.png)

我首先在 NCBI 核苷酸数据库中搜索了 *htt* mRNA 序列，并将其下载到我的工作目录中。然后我读取了这个序列，并使用我的模式来确定谷氨酰胺串联重复序列的长度超过 18。为了清楚起见，我在 NCBI·法斯特的文件中突出了这场比赛。我还使用了 re.findall()函数，因为 re.search()只会找到第一个匹配项，在这种情况下可能会找到许多匹配项。

## **结论:**

本教程简要介绍了正则表达式在遗传学中的具体应用。正则表达式中的知识是高度可转移的，特别是在 Python 和许多其他主流编程语言(如 Perl 和 r)中，语法形式和功能表现大致相似。