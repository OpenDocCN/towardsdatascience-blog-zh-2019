<html>
<head>
<title>Relational Database Management (RDBMS) Basic for Data Professionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据专业人员的关系数据库管理(RDBMS)基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/relational-database-management-rdbms-basic-for-data-professionals-aca3567f03da?source=collection_archive---------7-----------------------#2019-06-23">https://towardsdatascience.com/relational-database-management-rdbms-basic-for-data-professionals-aca3567f03da?source=collection_archive---------7-----------------------#2019-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1a89" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据专业人员权威指南</h2><div class=""/><div class=""><h2 id="0fa8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用 Python SQLite3 和 SQLAlchemy 的基本 RDBMS</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fff6f515d413ebef25981f6a1f5af703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xl1Lfz6vLZjVrwl-"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Source from Unsplash</figcaption></figure><p id="cf01" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据科学家需要每天与数据库打交道。作为数据分析师和工程师，我们需要精通 SQL 和数据库管理。了解 RDBMS 将有助于我们访问、交流和处理数据。它将允许我们更快、更稳健地存储和过滤替代数据。</p><h2 id="2f98" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">在本教程中，我们将学习如何:</h2><ol class=""><li id="68a9" class="mv mw it lj b lk mx ln my lq mz lu na ly nb mc nc nd ne nf bi translated">设置 SQLite 磁盘连接</li><li id="35a4" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">创建具有结构的表</li><li id="98ff" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">将数据框值插入表中</li></ol><p id="6dea" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本教程中，我们将学习在 Python 中执行的两种方法。第一个是使用 SQLite 3，这里我们将使用 Python 和 SQL 来执行每个学习点。但是，我们也将简要讨论一下 SQL 炼金术，它允许我们仅用 4 行代码就能执行这些学习要点。(不开玩笑！)</p><p id="b6e9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在此之前，我们先来谈谈 RDBMS</p><h1 id="ff57" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">什么是 RDBMS？</h1><blockquote class="nw nx ny"><p id="0bba" class="lh li nz lj b lk ll kd lm ln lo kg lp oa lr ls lt ob lv lw lx oc lz ma mb mc im bi translated">一个<em class="it">关系数据库</em>是一种数据库。它使用的结构允许我们识别和访问数据库中与另一条数据相关的数据<em class="it">。通常，关系数据库中的数据被组织成表。法典编纂</em></p></blockquote><p id="2910" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关系数据库使用被称为<strong class="lj jd">记录</strong>的表。这些记录拥有<strong class="lj jd">多个列</strong>，这些列具有不同的<strong class="lj jd">名称</strong>和<strong class="lj jd">数据类型</strong>。然后，我们可以通过使用<strong class="lj jd">主键</strong>和<strong class="lj jd">外键</strong>来识别表模式关系，从而在记录之间建立连接。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/9b5c53fa8d342b3689c4ddfc3733e53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l6cVqtFmBQaMXvjE.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Data Schema Sample for RDBMS</figcaption></figure><h1 id="d773" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">为什么不只是？csv 或。xlsx 对比 RDBMS (SQL)？</h1><p id="8bb6" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">如今，Excel 和 csv 在存储我们的数据需求方面存在许多限制，而 RDBMS 可以解决这些限制:</p><h2 id="a692" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">容量</h2><p id="4865" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">数据生态系统每天都在变化，今天被认为是大而快的东西，明天可能就不是了。这意味着我们需要一个能够灵活承载大量数据的专用存储。我们需要比 Excel 和 csv 更具可扩展性的存储。RDBMS 是解决方案—它允许基于服务器分布的可伸缩性，而不是基于行数和列数有限的 Excel，048，576 行乘以 16，384 列)。</p><h2 id="c75d" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">具有已定义关系的依赖性</h2><p id="d771" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">RDBMS 允许用户在表之间建立定义的关系。这将给用户一个完整的数据定义画面。例如，在您的购物收据中，您可能有几个实体，如产品描述、商品价格、商店分店位置等。所有这些都可以根据需要进行分离和合并。</p><h2 id="d220" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">分析没有从数据中分离出来</h2><p id="61e2" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">我们现在可以将数据与分析分开存储。在 Excel 中，我们需要管理不同的版本来与您的团队成员协作。每个文件都需要结合不同版本的数据和分析。但是，在 RDBMS 中，我们现在可以使用 SQL 指令分别重现和分析数据。这样，我们可以确保您的团队从中央数据服务器生成更新的数据和分析。</p><p id="4770" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您想了解更多信息，请参考这篇 Codecademy 文章。</p><div class="oh oi gp gr oj ok"><a href="https://news.codecademy.com/excel-to-sql-why-switch/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">Excel 到 SQL:为什么您应该进行转换</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">如果您在工作中使用 Excel 或 Google Sheets 等电子表格应用程序，这些问题可能对您来说很熟悉:它…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">news.codecademy.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy lb ok"/></div></div></a></div><p id="06f0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于数据专业人员来说，这项技能很有价值。它创建了一个一站式数据存储，每个人都可以从他们的 SQL 指令中获得相同的更新数据。</p><h1 id="376e" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">为什么我们选择 SQLite 而不是 PostgreSQL？</h1><p id="9988" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">SQLite 为基于磁盘的数据库提供了一个轻量级的 C 库，允许 SQL 处理 CRUD 进程。这意味着我们可以在许多小型应用程序/用例中依赖 SQLite:</p><ol class=""><li id="a59a" class="mv mw it lj b lk ll ln lo lq oz lu pa ly pb mc nc nd ne nf bi translated">SQLite 用于快速方便的内部数据存储</li><li id="6c4f" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">SQLite 快速开发小型原型</li><li id="8362" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">在通过 PostgreSQL 或 Oracle 迁移到更大的数据库之前，SQLite 托管概念证明(POC)。</li></ol><p id="27f5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">PostgreSQL 是一个非常先进的开源数据库，提供专用的数据服务器来运行其数据库。但是，SQLite 提供了不需要专用数据服务器的轻量级设置。</p><p id="a8d4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们的数据需求包括适当的管理和安全性，那么 PostgreSQL 将是合适的选择。否则 SQLite 也行。</p><div class="oh oi gp gr oj ok"><a href="https://tableplus.io/blog/2018/08/sqlite-vs-postgresql-which-database-to-use-and-why.html" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">SQLite 与 PostgreSQL——使用哪个数据库，为什么？</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">SQLite 和 PostgreSQL 是最广泛使用的关系数据库管理系统(RDMS)。他们都是…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">tableplus.io</p></div></div><div class="ot l"><div class="pc l ov ow ox ot oy lb ok"/></div></div></a></div><p id="f560" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了构建本文的 POC，我们将使用 SQLite。但是可以尝试使用 PostgreSQL。</p><h1 id="d624" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">将来自 Lazada 的数据提取插入 SQLite</h1><h2 id="4963" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">问题陈述</h2><p id="ff7c" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">我们将重用从 Lazada 中提取关键产品信息的问题。我们将把它导出到 SQLite 数据库，而不是导出到 csv。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/67eaca274d86712b88e62a79adaea3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*jhBv5evecYAcIETLUermAQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">product_df to store scraped information at Lazada Website</figcaption></figure><p id="a684" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你对此不熟悉，请随意浏览我下面的文章。</p><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/in-10-minutes-web-scraping-with-beautiful-soup-and-selenium-for-data-professionals-8de169d36319"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">10 分钟内:为数据专业人员提供美味汤和硒的网络刮擦</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">使用 BS4 和 Selenium 快速提取关键信息</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="pe l ov ow ox ot oy lb ok"/></div></div></a></div><p id="24f0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于本教程，我们将首先使用 SQLite3 来生成到 SQLite 引擎的连接。这将允许我们执行 SQL 命令来插入值。之后，我们将研究 SQLAlchemy 来缩短和简化这个过程，而不需要创建任何 SQL 命令。</p><h1 id="f442" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">Python SQLite3</h1><h2 id="5ffd" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">连接到 SQLite 磁盘</h2><p id="b526" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">我们首先建立到磁盘文件 lazada.db 的连接，这是 SQLite 引擎用来存储数据的磁盘。如果 lazada.db 不存在，它将创建一个新的，下次我们可以连接它。</p><pre class="ks kt ku kv gt pf pg ph pi aw pj bi"><span id="3ebf" class="md me it pg b gy pk pl l pm pn">import sqlite3<br/>conn = sqlite3.connect("lazada.db")<br/>c = conn.cursor()</span></pre><p id="6729" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，当我们打开连接时，我们也建立了一个游标。数据库游标是一种遍历数据库记录的工具。使用这个游标，我们可以创建表并在数据库磁盘中执行 SQL 命令。</p><h2 id="310c" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">创建 lazada_product 表</h2><p id="41de" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">在将我们的 SQLite3 连接到<em class="nz"> lazada.db </em>之后，我们将使用游标执行 SQL 查询并创建<em class="nz"> lazada_product </em>表。我们将我们的元数据标识如下。</p><pre class="ks kt ku kv gt pf pg ph pi aw pj bi"><span id="6ea8" class="md me it pg b gy pk pl l pm pn">c.execute('''<br/>    CREATE TABLE lazada_product (<br/>    time date_time ,<br/>    id <strong class="pg jd">INTEGER</strong> ,<br/>    link <strong class="pg jd">TEXT</strong> NOT NULL,<br/>    product_title <strong class="pg jd">TEXT</strong> NOT NULL,<br/>    product_price <strong class="pg jd">DOUBLE</strong> NOT NULL,<br/>    category <strong class="pg jd">TEXT</strong> NOT NULL,<br/>    PRIMARY KEY (time, id)<br/>    );<br/>    ''')</span></pre><p id="bcee" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意我们是如何将 time 和 id 指定为主键的。这意味着每一行都有唯一的 id 和日期时间。如果我们插入具有相同 id 和日期时间的行；SQLite 会抱怨并返回一个重复的错误。这种验证有助于防止不干净的冗余数据进入数据库。</p><h2 id="fa91" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">将 df 行插入 lazada_product 表</h2><p id="4eeb" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">让我们将提取的 product_df 插入到 lazada_product 表中。</p><pre class="ks kt ku kv gt pf pg ph pi aw pj bi"><span id="d3cb" class="md me it pg b gy pk pl l pm pn">def write_from_df_with_sqlite3(df):<br/>    for index, row in df.iterrows():<br/>        c.execute(<br/>        '''<br/>            INSERT INTO lazada_product VALUES <br/>              (<em class="nz">CURRENT_TIMESTAMP</em>,?,?,?,?,?)<br/>        ''',<br/>            (row['id'], row['link'],row['product_title'],row['product_price'],<br/>            row['category'])<br/>        )</span></pre><p id="50d5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦运行这个方法，您将成功地将每个值转储到您的 lazada_product 表中。</p><blockquote class="po"><p id="513c" class="pp pq it bd pr ps pt pu pv pw px mc dk translated">祝贺您，您已经创建了 RDBMS 表并向其中插入了数据</p></blockquote><p id="4757" class="pw-post-body-paragraph lh li it lj b lk py kd lm ln pz kg lp lq qa ls lt lu qb lw lx ly qc ma mb mc im bi translated">注意，SQLite3 Python 有一个限制。当您将 SQL 命令和 Python 代码组合在一个文件中时，代码可能很难阅读。它看起来也很冗长。</p><p id="2ae4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，我们将看看如何使用 SQLAlchemy 以一种更短的、无 SQL 的方法来执行表和数据插入。</p><h1 id="c966" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">Python 对象关系映射器(ORM) SQLAlchemy</h1><p id="27de" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">SQLAlchemy 是一个激活数据库引擎的 Python ORM。它在 SQLite 的 SQL 执行之上创建了一个 pythonic 包装器。这允许您在不接触任何 SQL 命令代码的情况下对表运行逻辑。</p><h2 id="c59f" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">什么是对象关系映射器(ORM)？</h2><p id="d489" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">ORM 提供了一个高级抽象，允许开发人员编写 Python 代码来调用数据库中 CRUD 和模式的 SQL。每个开发人员都可以使用他们熟悉的编程语言，而不是处理 SQL 语句或存储过程</p><h2 id="33a4" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">连接到 SQLite 引擎</h2><pre class="ks kt ku kv gt pf pg ph pi aw pj bi"><span id="1214" class="md me it pg b gy pk pl l pm pn">from sqlalchemy import create_engine<br/>disk_engine = create_engine('sqlite:///lazada_alchemy.db')</span></pre><h2 id="0565" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">创建 lazada_product 表并插入 df 行</h2><pre class="ks kt ku kv gt pf pg ph pi aw pj bi"><span id="f80c" class="md me it pg b gy pk pl l pm pn">def write_from_df_with_alchemy(df):<br/>    df.to_sql('lazada_product', disk_engine, if_exists='append')</span></pre><p id="3985" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看看这段代码有多简洁。运行这个方法后，我们立即根据 df 数据类型创建带有默认设置的表。同时，我们将把值追加到 lazada_product 表中，而不涉及任何 SQL。</p><p id="e144" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，SQLAlchemy 最大的优点是促进 SQL 命令的高级抽象，以帮助 Python 开发人员使用同一种语言提取数据。</p><blockquote class="po"><p id="99e1" class="pp pq it bd pr ps pt pu pv pw px mc dk translated">执行 SQL 而不运行 SQL 查询。— SQLAlchemy</p></blockquote><p id="218f" class="pw-post-body-paragraph lh li it lj b lk py kd lm ln pz kg lp lq qa ls lt lu qb lw lx ly qc ma mb mc im bi translated">当然，这不应该取代懂 SQL 语言的重要性。我们可以用 SQL 更好地处理更多的复杂性。然而，要对数据表的设置和插入进行编码，SQLAlchemy 将为您节省大量时间和精力。</p><h1 id="ecdf" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">访问我们的 SQLite 磁盘</h1><p id="70d0" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">为了检查我们磁盘的内容，我们可以使用下面的 Web Dashboard 工具。</p><div class="oh oi gp gr oj ok"><a href="https://sqliteonline.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">SQLite 浏览器- SQL Online</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">JavaScript 上的 SQL 在线。用户友好的界面。不下载，不安装。在线测试 SQL 脚本…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">sqliteonline.com</p></div></div></div></a></div><p id="c37b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从这里，您可以将磁盘作为文件插入，并编写一个简单的 SQL select 语句。</p><pre class="ks kt ku kv gt pf pg ph pi aw pj bi"><span id="7cca" class="md me it pg b gy pk pl l pm pn">SELECT * from lazada_product</span></pre><p id="a716" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">单击 run，这将显示您在 lazada_product 中的所有数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/169a99278601213269e890e1ee4a06b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZrX4akIyoKTH1lLMptLdwA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">The results after inserting lazada_product inside the table. In total there are 108 products appended</figcaption></figure><blockquote class="po"><p id="be91" class="pp pq it bd pr ps qe qf qg qh qi mc dk translated">恭喜你，你已经学会了 RDBMS 和使用 Python SQLite3 和 SQLAlchemy 插入值</p></blockquote><h1 id="8b9b" class="nl me it bd mf nm nn no mi np nq nr ml ki qj kj mo kl qk km mr ko ql kp mu nv bi translated">结论</h1><ol class=""><li id="8622" class="mv mw it lj b lk mx ln my lq mz lu na ly nb mc nc nd ne nf bi translated">RDBMS 为 csv 或 excelsheet 提供了许多好处，因为它具有更大的<strong class="lj jd">容量、依赖性检查以及分析和数据的分离</strong></li><li id="ca14" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd">创建</strong>一个<strong class="lj jd">简单的 RDBMS </strong>并不需要太多时间，我们可以使用<strong class="lj jd"> SQLAlchemy </strong>来创建模式，只需用<strong class="lj jd">的 4 行代码</strong>。</li><li id="573f" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">我们可以通过使用 SQLite 浏览器在线或<strong class="lj jd">下载 Linux 或微软 SQLite 浏览器</strong>来<strong class="lj jd">恢复读取和 CRUD 操作。</strong></li></ol><h1 id="065e" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">目的、Github 代码和您的贡献</h1><div class="oh oi gp gr oj ok"><a href="https://github.com/VincentTatan/Web-Scraping/tree/master/Selenium%20Web%20Scraping" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">Vincent tatan/网页抓取</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">美汤硒网刮。为 VincentTatan/Web 抓取开发做出贡献，创建一个…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="qm l ov ow ox ot oy lb ok"/></div></div></a></div><p id="35d3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请随意克隆存储库并做出贡献。</p><h2 id="ff1b" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">最后…</h2><p id="4a40" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">我真的希望这是一本很棒的读物，是你发展和创新的灵感来源。</p><p id="82f1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请在下面<strong class="lj jd">评论</strong>出来建议和反馈。</p><p id="1da9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">快乐编码:)</p><h1 id="f668" class="nl me it bd mf nm nn no mi np nq nr ml ki ns kj mo kl nt km mr ko nu kp mu nv bi translated">关于作者</h1><p id="5193" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq oe ls lt lu of lw lx ly og ma mb mc im bi translated">Vincent Tatan 是一名数据和技术爱好者，拥有在 Visa Inc .和 Lazada 实施微服务架构、商业智能和分析管道项目的相关工作经验<a class="ae qn" href="https://bit.ly/2I8jkWV." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cee0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Vincent 是土生土长的印度尼西亚人，在解决问题方面成绩斐然，擅长全栈开发、数据分析和战略规划。</p><p id="d165" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">他一直积极咨询 SMU BI &amp; Analytics Club，指导来自不同背景的有抱负的数据科学家和工程师，并为企业开发他们的产品开放他的专业知识。</p><p id="066a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请通过<a class="ae qn" href="http://www.linkedin.com/in/vincenttatan/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd">LinkedIn</strong></a><strong class="lj jd">、</strong><a class="ae qn" href="https://medium.com/@vincentkernn" rel="noopener"><strong class="lj jd">Medium</strong></a><strong class="lj jd">或</strong> <a class="ae qn" href="https://www.youtube.com/user/vincelance1/videos" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd"> Youtube 频道</strong> </a>联系文森特</p></div></div>    
</body>
</html>