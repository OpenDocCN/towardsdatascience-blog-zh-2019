<html>
<head>
<title>When Job Hunting Meets Data Science (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当求职遇到数据科学(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/when-job-hunting-meets-data-science-part-2-675f154269c7?source=collection_archive---------15-----------------------#2019-05-21">https://towardsdatascience.com/when-job-hunting-meets-data-science-part-2-675f154269c7?source=collection_archive---------15-----------------------#2019-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从业务理解到模型评估，这个数据科学项目帮助我在找工作时变得非常清晰。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5f963001673fcd8a6f4884b9739c8561.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*kLNzSuGs6BN8gZm5ZoWu0w.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Payday! Image found on GIPHY by andersonpaak.com</figcaption></figure><p id="2492" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">这是第一部分</em><a class="ae lr" rel="noopener" target="_blank" href="/when-job-hunting-meets-data-science-part-1-e8f64867d8c"><em class="lq"/></a><em class="lq">的延续，我在这里经历了业务理解和数据理解的步骤。所采取的行动是制定问题陈述、网络搜集数据并将数据存储在数据库中。</em></p><p id="4fbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于第 2 部分，我们关注数据准备和数据建模！</p><p id="62d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，我们首先从存储数据的数据库中提取数据，并随机抽取 5 个职业数据的观察值。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="9a53" class="lx ly it lt b gy lz ma l mb mc">engine = create_engine('postgresql://[username]:<a class="ae lr" href="mailto:qFH95+yw+ppY9tRm@careers.c0ocff1wef7u.ap-southeast-1.rds.amazonaws.com" rel="noopener ugc nofollow" target="_blank">[password]@[database].ap-southeast-1.rds.amazonaws.com</a>:5432/postgres', echo=True)<br/>query = """<br/>        SELECT * FROM posting;<br/>        """<br/>posting = pd.read_sql(query, engine)<br/>posting.sample(5)</span></pre><p id="bc38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">"让我们开始做模特吧！"我知道我们对模特有多渴望。但是，让我们在开始之前先回顾一下业务问题并执行探索性数据分析(EDA)。</p><h1 id="af3e" class="md ly it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">业务理解(重访)</h1><p id="f40f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">商业问题是调查影响工资的因素。我们想知道可以用来预测工资的特征。更具体地说，给定一个由我们确定的截止工资(可能是所有职位发布工资的中间值或平均值)，有哪些特征可能预测工资是高于还是低于截止工资。</p><h1 id="0db7" class="md ly it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据准备、数据清理</h1><p id="63ec" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">总共有 1，173 个观察值和 16 个特征。一些特征将不会用于建模，例如发布 id、公司名称、公司信息和发布链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d3c7ae8e581218cb32c234db5cca2354.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*6VE3Lb5izFyqWmKTZSjogA.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Great! No null value hidden in our dataset (really ‘Great’? Think again!)</figcaption></figure><p id="d124" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的是，在“要求的经验年数”下没有捕捉到任何信息。因此，此功能将被删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/18fe97772cbc74fba454256e33dbdf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*bV2Ici1vu2CH_jY37dL8hA.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Constants like this don’t give any value for analysis and modelling, DROP!</figcaption></figure><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="81f3" class="lx ly it lt b gy lz ma l mb mc"># Drop features that don't give any value for modelling or don't make any sense to be used for modelling</span><span id="5efc" class="lx ly it lt b gy nb ma l mb mc">posting['emp_min_exp'].value_counts()<br/>posting = posting.drop(columns=['job_id','emp_min_exp','company_name','company_info','link'])</span></pre><p id="18b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其余的特征要么是分类的，要么是文本的。对于文本特征，我们通过转换为小写、删除不必要的特殊字符和转义序列(\n，\t)来清理数据。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="3155" class="lx ly it lt b gy lz ma l mb mc"># Clean up the text data<br/>posting.replace(r'\n', '', regex = True, inplace = True)<br/>posting.replace(r'\t', '', regex = True, inplace = True)<br/>for header in ['job_desc', 'job_req', 'job_title']:<br/>    posting[header] = posting[header].map(lambda text: ''.join([char for char in text.lower() if char in string.ascii_lowercase + " /'-"]))<br/>    posting[header] = posting[header].map(lambda text: text.replace('-', ' '))<br/>    posting[header] = posting[header].map(lambda text: text.replace('/', ' '))</span></pre><p id="adc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些工资是以年频率而不是月频率引用的。我们将这些工资除以 12，并删除“工资频率”功能。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="c333" class="lx ly it lt b gy lz ma l mb mc"># Convert all salary to monthly salary<br/>posting.loc[posting['salary_freq'] == 'Annually','salary_low'] /= 12<br/>posting.drop(columns='salary_freq', inplace = True)<br/>posting.sample(5)</span></pre><p id="211b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，我们要决定如何制定我们的目标，也就是工资。一个简单的方法是取高低端点之间的平均值，并将其作为我们的目标。但是，考虑这 2 个场景:<br/> 1。4，000 美元到 6，000 美元<br/> 2。3，000 美元—7，000 美元<br/>确定两者的平均值为 5，000 美元并不重要，但两者的范围非常不同。</p><p id="4c2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我决定使用工资的低端点作为目标。(另一个实际原因是，老板们通常希望将成本降至最低，这意味着……)</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="1a07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们专注于我们的目标，薪水。我们绘制了一个柱状图来看工资是如何分布的。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="c002" class="lx ly it lt b gy lz ma l mb mc">plt.figure(figsize=(18,5))<br/>sns.distplot(posting['salary_low'], kde=False, axlabel='Salary', color='red');</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/4bd9b448894391bb476f92b1be87c1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6frzft5OwUxZUelYNH2og.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">When can I reach the right hand side of this graph?</figcaption></figure><p id="74f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这个分布观察到的 3 点:<br/> 1。没有负面价值观(谢天谢地，你没有付钱让你的老板为他/她工作)<br/> 2。数量可观的 0 美元薪水(这不是慈善工作，只是薪水在贴子里没有公开)<br/> 3。在最右边出现异常值(我想要的位置)</p><p id="ff31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决第 2 点，我们可以执行<strong class="kw iu">插补</strong>来插补 113 个＄0 值。为此，我们首先使用 CountVectorizer 函数将所有特征转换成一个单词包。然后，我们使用基于 k 近邻的<strong class="kw iu">回归</strong>来估算$0 值。该算法将首先获取一个工资为 0 美元的数据点，在其周围寻找 5 个最近的点，并根据这 5 个最近点的平均工资估算值。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="75fe" class="lx ly it lt b gy lz ma l mb mc">#Init CountVectorizer with stop words and use 0/1 to denote presence<br/>cvec = CountVectorizer(stop_words='english', binary=True)</span><span id="b727" class="lx ly it lt b gy nb ma l mb mc"># Transform all text features into bag of words and concatenate<br/>X = [cvec.fit_transform(posting[i]).todense() for i in posting.columns[:-1]]<br/>X = np.concatenate(X, axis=1)</span><span id="e2f7" class="lx ly it lt b gy nb ma l mb mc"># Draw references to observations where salary = 0 vs =/= 0<br/>salary0_index = posting[posting['salary_low'] == 0].index<br/>salary_not0_index = posting[posting['salary_low'] != 0].index</span><span id="d58d" class="lx ly it lt b gy nb ma l mb mc"># Init KNeighborsRegressor with 5 neighbors to impute $0 salary<br/>neigh = KNeighborsRegressor(n_neighbors=5)<br/>neigh.fit(X[salary_not0_index], posting.loc[salary_not0_index, 'salary_low'])<br/>posting.loc[salary0_index, 'salary_low'] = neigh.predict(X[salary0_index])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/c50cb752c9ca280e7a27b25b6ff5870c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOcEsdTLvczzzLiBV-EuHg.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">KNeighborsRegressor with 5 neighbors and uniform weights a.k.a. just take the average of the 5 neighbors!</figcaption></figure><p id="d251" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了更新后的薪水列表，我们可以再次绘制一个直方图来查看新的分布。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi np"><img src="../Images/046f11600b6e34cfda65dc2d9e6d8bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gu0BqQGWvZRu_4cptONAJg.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Don’t you think I look like lognormal distribution?</figcaption></figure><p id="4d88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为它呈现对数正态分布，并且它没有 0 值，所以我们可以执行对数变换，使它看起来像正态分布。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nq"><img src="../Images/7c7ded32b77d84284431fb350cac7e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VW5QgVfG9A14itL3T2YTpQ.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Do I look normal now?</figcaption></figure><p id="b68a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们确定 1173 个观察值中的 590 个等于或高于正态分布的平均值，而 583 个观察值不等于或高于正态分布的平均值。显然，这种情况下的截断点是对数(工资)的平均值。使用<strong class="kw iu">零规则算法</strong>，可以预测 all 为多数类，等于或高于 log(salary)的均值，基线为 590/1173 = 0.503。</p><h1 id="b81c" class="md ly it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据建模</h1><p id="1b1e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">准备好数据后，我们拆分数据，将 80%用于训练，20%用作维持集。</p><p id="a33b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们采用两种模型来完成分类任务:<strong class="kw iu">逻辑回归</strong>和<strong class="kw iu"> XGBoost 分类器</strong>。</p><h1 id="ecd4" class="md ly it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模型评估</h1><p id="77a9" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">虽然我们可以使用准确性作为衡量标准，但我们将使用 ROC-AUC 作为衡量模型性能的关键指标。</p><p id="c679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，我们希望真阳性率为 100%，假阳性率为 0%。然而，在现实中，这几乎是不可能的。因此，通过改变阈值，我们可以使用相应的真阳性率和假阳性率绘制受试者工作特征(ROC)曲线。然后，曲线下面积(AUC)将告诉我们我们的模型能够在两个类别之间分离得有多好。AUC 越高，该模型就越能更好地预测真 0 为 0，真 1 为 1。</p><p id="5dbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在维持集上，<br/>逻辑回归:AUC = 0.9028 <br/> XGBoost 分类器:AUC = 0.8988</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nr"><img src="../Images/055c5874cb5deabeaa8ae5ad98ee198d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_SOwPaEHeonHR4EPNoCAw.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">ROC for Logistic Regression and XGBoost Classifier</figcaption></figure><h1 id="3514" class="md ly it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简而言之…</h1><p id="a359" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">使用给我们的所有特征，一个好的 ol' Logistic 回归模型在维持集上的表现比 XGBoost 分类器稍好。有了这个模型，我们可以预测日志(工资)是高于还是低于平均值，给定工作发布的信息。对于提供职位匹配服务的公司，该模型可以帮助管理雇主和雇员双方的薪资期望。</p><p id="5614" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Code for everything discussed in this story!</figcaption></figure><h1 id="277b" class="md ly it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">更加卖力！</strong></h1><ol class=""><li id="6f06" class="nu nv it kw b kx mu la mv ld nw lh nx ll ny lp nz oa ob oc bi translated">除了插补，我们还可以删除那些价值为 0 美元的记录。请注意，该组代表了大约 10%的观察结果，在业务环境中删除它们可能不是一个可行的选项。</li><li id="fb92" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">除了使用 k-最近邻回归量进行插补，我们还可以使用其他技术，例如</li><li id="2fcb" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">在这个项目中，NLP 被大量使用，并且由函数生成的矩阵主要是稀疏的。因此，我们应该找到舒适地处理稀疏矩阵的方法，比如使用专门为稀疏矩阵构建的函数，而不是转换和处理密集矩阵。</li><li id="e052" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">此外，有些算法可能不适用于稀疏矩阵。它们在低维空间(很少特征)可能做得很好，但是在高维空间它们的性能是次优的。我们应该意识到这样的算法。</li><li id="e5b7" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">更多的超参数调整可以获得更高的度量分数。然而，我们需要注意的是，这种调整可能只会对总体分数产生微小的改善。</li><li id="4a35" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">因此，与看似无止境的超参数调整相比，基于领域专业知识(在本例中，人力资源)的更好的特征提取和特征工程策略可能有利于提高分数。</li><li id="9856" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">我们还可以努力找出哪些词对薪水有更高的预测能力。需要注意的是，为了欺骗系统，帖子可能只包含某些具有高预测能力的词(如数据科学家)，但会形成不正确的句子。例如，“优秀的数据科学家，优秀的数据科学家，完美的数据科学家”。</li></ol><p id="a948" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读，我希望你能像我写的一样喜欢这个故事！如果我可以以任何方式提高我的编码或文章写作技能，请在下面留下您的评论，以便我可以从社区学习最佳实践和经验法则。(^^,)</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="b38f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个接一个的项目，我着迷于事物如何使用收集的数据和建立在其上的模型工作，并通过部署模型来解决现实生活中的问题。你可以通过我的 <a class="ae lr" href="http://www.linkedin.com/in/JackieTanSG" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> LinkedIn </em> </a> <em class="lq">联系我。</em></p></div></div>    
</body>
</html>