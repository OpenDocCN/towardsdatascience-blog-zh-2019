<html>
<head>
<title>Implementing Cosmos DB Change Feed using Azure Functions in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 C#中的 Azure 函数实现 Cosmos DB 变更提要</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-cosmos-db-change-feed-using-azure-functions-in-c-d76a7f3c4ac?source=collection_archive---------5-----------------------#2019-08-23">https://towardsdatascience.com/implementing-cosmos-db-change-feed-using-azure-functions-in-c-d76a7f3c4ac?source=collection_archive---------5-----------------------#2019-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/876875c03dffba3fe6bb7d012059d707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CdBH8y_734rbVjL6.png"/></div></div></figure><p id="8936" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Azure Cosmos DB 有一个很酷的特性叫做<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed" rel="noopener ugc nofollow" target="_blank"> Change Feed </a>，它允许我们通过监听容器中发生的任何变化来对我们的容器进行实时分析。</p><p id="77ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，这些更改被生成为文档的排序列表，这些列表按照它们被修改的顺序进行了更改。这些是持久的，可以增量处理。然后，输出可以由多个使用者进行并行处理。</p><p id="5ed0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个特性在一个项目的变化可能触发另一个事件或附加动作的情况下非常有用。一个例子可能是一个项目被插入到我们的容器中，我们用它来触发一个网站警报，告诉它在我们的容器中有一个新的项目。</p><p id="6640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">默认情况下，所有 Cosmos DB 帐户都启用变更订阅功能</strong>。您不需要做任何特殊的事情来设置它，并且您可以使用您在您的 Cosmos 帐户上提供的吞吐量来读取更改提要，就像任何常规的 Cosmos DB 操作一样。</p><p id="72d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，变更提要包括对容器中的项目进行插入和更新操作(这是我们在本教程中要关注的)。如果您想要捕获容器中项目的删除，您可以使用一个标记来捕获软删除，或者在项目上设置一个<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/time-to-live" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">生存时间(TTL) </strong> </a>周期，并使用该属性来捕获更改提要。请记住，更改馈送需要在比 TTL 间隔更短的时间内处理。</p><p id="e0f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更改在更改提要中只出现一次。管理您可能需要的任何检查点逻辑需要由您的应用程序来完成。<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed-processor" rel="noopener ugc nofollow" target="_blank">更改进给处理器库</a>很适合这种情况，因为它提供了自动检查点。对于这个简单的例子，现在不用担心这个。</p><p id="df82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更改可以从任何时间点同步，并且在每个逻辑分区键值内，它按修改的顺序排序。如果您有一个大型容器，那么变更提要可以由多个使用者处理，我们可以在同一容器上同时运行多个变更提要。</p><p id="8057" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed#supported-apis-and-client-sdks" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">在这篇博文发表的时候，只有 SQL API 和 Gremlin API 支持变更提要。NET、Java、Python 和 Node.js 应用</strong> </a>。</p><p id="3975" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过三种方式使用变更馈送:</p><ol class=""><li id="f582" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/read-change-feed#using-the-azure-cosmos-db-sql-api-sdk" rel="noopener ugc nofollow" target="_blank">使用 Azure Cosmos DB SQL API SDK </a></li><li id="d1d8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/read-change-feed#using-the-change-feed-processor-library" rel="noopener ugc nofollow" target="_blank">使用更换进给处理器库</a></li><li id="968a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/read-change-feed#using-azure-functions" rel="noopener ugc nofollow" target="_blank">使用 Azure 功能</a></li></ol><p id="f095" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用 Azure 函数是迄今为止开始使用 Cosmos DB change feed 最简单的方法。我们实际上创建了在容器的变更提要中的每个新事件上触发的函数。<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-cosmos-db-triggered-function#prerequisites" rel="noopener ugc nofollow" target="_blank"> CosmosDB 触发器</a>允许我们使用来改变提要功能，而不用担心任何基础设施。</p><p id="46ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于我们的目的，我将创建两个函数:</p><ol class=""><li id="1685" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">一个<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook" rel="noopener ugc nofollow" target="_blank"> HTTP 触发器</a>函数，允许我们插入和更新新的条目。</li><li id="a333" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">一个<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb-v2" rel="noopener ugc nofollow" target="_blank"> CosmosDB Trigger </a>函数，它使用变更提要来跟踪我们的容器上的变更和插入，然后将这些持久化到一个租用容器中。</li></ol><p id="6e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用 2.x 运行时来运行我们的函数。</p><p id="8d85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，即使更改提要支持 Gremlin API 和 SQL API Cosmos DB 帐户，<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb-v2#supported-apis" rel="noopener ugc nofollow" target="_blank">Azure 函数的 Cosmos DB 触发器只支持 SQL API </a>，所以这就是我们将在本演示中使用的。</p><p id="9e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里查看<a class="ae kw" href="https://github.com/willvelida/ChangeFeedDemo/" rel="noopener ugc nofollow" target="_blank">完整的代码库</a>。这包括我在这个项目中使用的相关模型和助手类。我只是使用 Azure Cosmos DB 本地模拟器作为我的 Cosmos 帐户。本地仿真器对于在 Azure 中进行本地开发而言非常酷，无需在实际的数据库上花钱。</p><p id="0e58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建 HTTP 触发器函数来创建和更新我们的项目:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="5ad3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有两个函数，<strong class="ka ir"> CreateTaskItem </strong>和<strong class="ka ir"> UpdateTaskItem。</strong>在我们的 create 函数中，我们使用 HTTP 触发器输入向我们的 Cosmos DB 数据库发出 POST 请求。我们只是创建一个简单的 TaskItem 并将其持久化到我们的 TaskCollection 集合中。我在这里使用 CosmosDB 绑定只是为了这个例子，但是如果你在生产用例中使用 Azure 函数和 Cosmos DB，你应该考虑使用 Cosmos DB 的单一实例。对于我们的更新函数，我们只是向 task/{id}的路由发出一个 PUT 请求，其中 id 是我们的任务 id。</p><p id="2921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建另一个函数，它监听我们的 HTTP 函数并将这些更改记录到更改提要中:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="c2ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我创建了一个名为<strong class="ka ir">changeed listener</strong>的函数，它连接到我们的<em class="lr"> TaskItemCollection </em>并监听容器上的任何变化。然后，它将这些更改保存到一个<em class="lr"> LeaseCollection </em>容器中。在我们的函数中，每次我们在<em class="lr"> TaskItemCollection </em>中创建或更新一个<em class="lr"> TaskItem </em>时，它都会打印出有多少文档被更改(在我们的简单用例中只有 1 个)以及被更改的文档的 id 是什么。</p><p id="0cd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在生产场景</strong>中，我们可以将此作为消息发送到事件中心，使用<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-twilio" rel="noopener ugc nofollow" target="_blank"> Twilio 绑定</a>通过文本发送，甚至作为通知发送到网站。但是现在，这个简单的函数就可以了。</p><p id="d970" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了两个函数，所以让我们用它们做点什么吧！</p><p id="6555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我在本地运行，所以我将使用<a class="ae kw" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>来触发我的 HTTP 函数。让我们从 Create 函数开始，创建一个任务。为此，我们将向我们的函数 app 发出一个<strong class="ka ir"> POST </strong>请求，并传入一个<strong class="ka ir"> JSON </strong>主体，其中包括<em class="lr"> TaskName </em>、<em class="lr"> TaskDescription </em>和<em class="lr"> IsCompleted </em>属性。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/ef072bf3d4f438b5c3694d85ece91ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzWLuXgswI5eKzOQbpiJXQ.png"/></div></div></figure><p id="c24f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击 send 按钮发送我们的<strong class="ka ir"> POST </strong>请求，如果我们的函数正常工作，我们应该会看到下面的<strong class="ka ir"> JSON </strong>响应:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/6947d537410f7623ecf5bc9f6974aff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*gc_O5udwxqhlAYIJWrW9EQ.png"/></div></figure><p id="7697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的 HTTP 函数已经被触发了，不久之后我们的<strong class="ka ir">changeedplistener</strong>函数就会被触发，告诉我们有一个修改。记下下面的文档 ID。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/6dbee1cb3fbb08d1b8b0e5dd47cf08a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFgGrUcNScJnyGies9ddRw.png"/></div></div></figure><p id="a6a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它与我们刚刚创建的<em class="lr"> TaskItem </em>文档的 Id 相同！在 postman 中复制该 id，并将其作为参数传递给我们的<strong class="ka ir"> UpdateTaskItem </strong>函数。让我们更改<em class="lr">任务描述</em>和<em class="lr">已完成</em>值，并更新我们的项目:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/23e00e6fb9f324abaf24f9a31a4ae018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4QTd0bEKLlTomALOSblJw.png"/></div></div></figure><p id="d238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看我们的函数返回的响应体。我们可以看到，我们的项目现在已经用更新后的值进行了更改。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/889d0824ac69e99dbec4bc5e09fce6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*NhqObuyhI134T05MujmiVg.png"/></div></figure><p id="a92a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们查看函数应用程序的日志时，我们看到变更提要已经跟踪了我们对<em class="lr"> TaskItem </em>的更新。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="ab gu cl lx"><img src="../Images/ebc08eebde03923034106241965a389a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ABe2v0qmU2lX6xLm2m2BSQ.png"/></div></figure><p id="fe1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你有它！Azure Cosmos DB 变更提要的一个非常基本的例子！</p><p id="be8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">花点时间让<a class="ae kw" href="https://github.com/willvelida/ChangeFeedDemo/" rel="noopener ugc nofollow" target="_blank">看看代码</a>，并随意克隆它，玩玩它！如你所见，使用 Azure 函数实现变更提要功能非常简单直接。</p><p id="bba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以使用<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed-processor" rel="noopener ugc nofollow" target="_blank">新 Azure Cosmos SDK v3 库</a>中的变更提要处理器来利用变更提要特性，所以将来我会尝试一下并写点东西。</p><p id="1930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有任何问题，欢迎在此评论或联系我。</p></div></div>    
</body>
</html>