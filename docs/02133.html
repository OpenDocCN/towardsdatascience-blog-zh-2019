<html>
<head>
<title>Creating and Deploying a Python Machine Learning Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建和部署 Python 机器学习服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-and-deploying-a-python-machine-learning-service-a06c341f020f?source=collection_archive---------15-----------------------#2019-04-08">https://towardsdatascience.com/creating-and-deploying-a-python-machine-learning-service-a06c341f020f?source=collection_archive---------15-----------------------#2019-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b49f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 scikit 构建一个仇恨言论检测系统-通过 Heroku 上的 Docker 学习和部署它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fdea00edd0f652382bc8b8b1eb28a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6x9WsXQZmDB0S4odp-KkQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@jontyson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="305e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="e1b8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设你是留言板或评论区的版主。你不想阅读你的用户在网上写的所有东西，但你想在讨论变得不愉快或人们开始到处散布种族诽谤时得到提醒。所以，你决定为自己建立一个自动检测仇恨言论的系统。</p><p id="c871" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过机器学习进行文本分类是一种明显的技术选择。然而，将模型原型转化为工作服务被证明是一个普遍的挑战。为了帮助弥合这一差距，本四步教程展示了仇恨言论检测应用程序的示例性部署工作流程:</p><ol class=""><li id="15a3" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">用<strong class="lt iu"> scikit-learn </strong>训练并保持一个预测模型</li><li id="2eb4" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">用<strong class="lt iu"> firefly </strong>创建一个 API 端点</li><li id="9a8b" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">为这个服务创建一个<strong class="lt iu"> Docker </strong>容器</li><li id="edbe" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">在<strong class="lt iu"> Heroku </strong>上部署容器</li></ol><p id="47bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该项目的代码可在<a class="ae ky" href="https://github.com/dhaitz/python-sklearn-firefly-docker-heroku" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="fdeb" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">1.创建预测模型</h1><h2 id="28b0" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">资料组</h2><p id="f077" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该方法基于戴维森、瓦姆斯利、梅西和韦伯的论文<a class="ae ky" href="https://arxiv.org/abs/1703.04009" rel="noopener ugc nofollow" target="_blank"> <em class="oe">自动仇恨言论检测和攻击性语言问题</em> </a>。他们的结果是基于超过 20 000 条有标签的推文，这些推文可以在相应的 Github 页面上找到。</p><p id="6f34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">的。csv 文件作为数据帧加载:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="7ab6" class="ns la it og b gy ok ol l om on">import pandas as pd<br/>import re</span><span id="52df" class="ns la it og b gy oo ol l om on"><strong class="og iu">df</strong> = pd.read_csv('labeled_data.csv', usecols=['class', 'tweet'])</span><span id="1e99" class="ns la it og b gy oo ol l om on"><strong class="og iu">df</strong>['tweet'] = <strong class="og iu">df</strong>['tweet'].apply(lambda tweet: re.sub('[^A-Za-z]+', ' ', tweet.lower()))</span></pre><p id="f214" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一行通过将所有文本转换为小写并删除非字母字符来清理 tweet 列。</p><p id="657a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="87c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">class 属性可以假设三个类别值:<code class="fe or os ot og b">0</code>表示仇恨言论，<code class="fe or os ot og b">1</code>表示攻击性语言，<code class="fe or os ot og b">2</code>两者都不表示。</p><h2 id="c559" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">模特培训</h2><p id="9017" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在训练机器学习分类器之前，我们必须将我们的预测器，即推文文本，转换为数字表示。我们可以使用 scikit-learn 的<strong class="lt iu"> TfidfVectorizer </strong>来完成这项任务，它将文本转换为适合机器学习的术语频率乘以逆文档频率(tf-idf)值的矩阵。此外，我们可以从处理中删除<strong class="lt iu">停用词</strong>(常用词如<em class="oe">、</em>、<em class="oe">为</em>、…)。</p><p id="ed42" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于文本分类，支持向量机(<strong class="lt iu"> SVMs </strong>)是一个可靠的选择。由于它们是二元分类器，我们将使用<strong class="lt iu">一对其余</strong>策略，其中对于每个类别，训练一个 SVM 来将该类别与所有其他类别分开。</p><p id="9b26" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过使用 scikit-learn 的<strong class="lt iu">管道</strong>功能并定义相应的步骤，可以在一个命令中执行文本矢量化和 SVM 训练:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="94ca" class="ns la it og b gy ok ol l om on">from sklearn.pipeline import make_pipeline<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn.multiclass import OneVsRestClassifier<br/>from sklearn.svm import SVC<br/>from stop_words import get_stop_words</span><span id="906d" class="ns la it og b gy oo ol l om on"><strong class="og iu">clf</strong> = make_pipeline(<br/>    TfidfVectorizer(stop_words=get_stop_words('en')),<br/>    OneVsRestClassifier(SVC(kernel='linear', probability=True))<br/>)</span><span id="e3f3" class="ns la it og b gy oo ol l om on"><strong class="og iu">clf</strong> = <strong class="og iu">clf</strong>.fit(X=<strong class="og iu">df</strong>['tweet'], y=<strong class="og iu">df</strong>['class'])</span></pre><p id="953d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，应该评估模型的性能，例如，使用交叉验证方法来计算分类度量。然而，由于本教程关注的是模型部署，我们将跳过这一步(<strong class="lt iu">在实际项目中从不这样做</strong>)。这同样适用于参数调整或自然语言处理的附加技术，在<a class="ae ky" href="https://arxiv.org/abs/1703.04009" rel="noopener ugc nofollow" target="_blank">原始论文</a>中有所描述。</p><h2 id="4ed6" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">测试模型</h2><p id="c75f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在可以尝试一个测试文本，让模型预测概率:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="5e98" class="ns la it og b gy ok ol l om on"><strong class="og iu">text</strong> = "I hate you, please die!"<strong class="og iu"><br/>clf</strong>.predict_proba([<strong class="og iu">text</strong>.lower()])</span><span id="b5c3" class="ns la it og b gy oo ol l om on"># Output:<br/>array([0.64, 0.14, 0.22])</span></pre><p id="d0a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数组中的数字对应于三个类别的概率(仇恨言论、攻击性语言，都不是)。</p><h2 id="5a2b" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">模型持久性</h2><p id="9983" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用 joblib 模块，我们可以将模型作为二进制对象保存到磁盘。这将允许我们在应用程序中加载和使用模型。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="22f2" class="ns la it og b gy ok ol l om on">from sklearn import externals</span><span id="888d" class="ns la it og b gy oo ol l om on"><strong class="og iu">model_filename</strong> = 'hatespeech.joblib.z'<br/>externals.joblib.dump(<strong class="og iu">clf</strong>, <strong class="og iu">model_filename</strong>)</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a4d3" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">2.创建 REST API</h1><h2 id="94d0" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">创建 API 端点</h2><p id="4a74" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">python 文件<code class="fe or os ot og b">app.py</code>加载模型并定义一个简单的模块级函数，该函数封装了对模型的 predict_proba 函数的调用:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="b9fc" class="ns la it og b gy ok ol l om on">from sklearn import externals</span><span id="0afb" class="ns la it og b gy oo ol l om on"><strong class="og iu">model_filename</strong> = 'hatespeech.joblib.z'<br/><strong class="og iu">clf </strong>= externals.joblib.load(model_filename)</span><span id="c385" class="ns la it og b gy oo ol l om on">def predict(<strong class="og iu">text</strong>):<br/>    probas = <strong class="og iu">clf</strong>.predict_proba([<strong class="og iu">text</strong>.lower()])[0]<br/>    return {'hate speech': probas[0],<br/>           'offensive language': probas[1],<br/>           'neither': probas[2]}</span></pre><p id="0b81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们使用<a class="ae ky" href="https://github.com/rorodata/firefly" rel="noopener ugc nofollow" target="_blank"> firefly </a>，这是一个轻量级 python 模块，用于将<em class="oe">功能作为服务</em>。对于高级配置或在生产环境中的使用，Flask 或 Falcon 可能是更好的选择，因为它们已经在大型社区中建立了良好的声誉。对于快速原型，我们对 firefly 很满意。</p><p id="31cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将在命令行中使用 firefly 将 predict 函数绑定到本地主机上的端口 5000:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="802b" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> firefly app.predict --bind 127.0.0.1:5000</span></pre><h2 id="1b86" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">本地测试 API</h2><p id="617e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通过<code class="fe or os ot og b">curl</code>，我们可以向创建的端点发出 POST 请求，并获得一个预测:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="93e4" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> curl -d '{"text": "Please respect each other."}' \ http://127.0.0.1:5000/predict</span><span id="3c59" class="ns la it og b gy oo ol l om on"># Output:<br/>{"hate speech": 0.04, "offensive language": 0.31, "neither": 0.65}</span></pre><p id="1e26" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，在一个成熟的实际应用程序中，会有更多的附加功能(日志记录、输入和输出验证、异常处理等等)和工作步骤(文档、版本控制、测试、监控等等)，但是这里我们只是部署一个简单的原型。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="f0f7" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">3.创建 Docker 容器</h1><p id="3236" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为什么是 Docker？Docker 容器在一个隔离的环境中运行应用程序，包括所有的依赖项，并且可以作为映像提供，从而简化服务设置和扩展。</p><h2 id="8896" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">构建图像</h2><p id="464c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们必须在一个名为<code class="fe or os ot og b">Dockerfile</code>的文件中配置容器的内容和开始动作:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="a06a" class="ns la it og b gy ok ol l om on">FROM python:3.6<br/>RUN pip install scikit-learn==0.20.2  firefly-python==0.1.15<br/>COPY app.py hatespeech.joblib.z ./</span><span id="f112" class="ns la it og b gy oo ol l om on">CMD firefly app.predict --bind 0.0.0.0:5000<br/>EXPOSE 5000</span></pre><p id="57b6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">前三行是关于将<code class="fe or os ot og b">python:3.6</code>作为基础映像，另外安装 scikit-learn 和 firefly(与开发环境中的版本相同)并复制里面的 app 和模型文件。后两行告诉 Docker 启动容器时执行的命令以及应该暴露的端口 5000。</p><p id="cf9c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建图像<code class="fe or os ot og b">hatespeechdetect</code>的构建过程通过以下方式开始:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="6c49" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> docker build . -t hatespeechdetect</span></pre><h2 id="10e2" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">运行容器</h2><p id="d392" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe or os ot og b">run</code>命令启动一个容器，从一个图像派生。此外，我们通过<code class="fe or os ot og b">-p</code>选项将容器的端口 5000 绑定到主机的端口 3000:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="b075" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> docker run -p 3000:5000 -d hatespeechdetect</span></pre><h2 id="0a72" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">使用预测服务</h2><p id="13a4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们可以发送一个请求并获得一个预测:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1bfc" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> curl -d '{"text": "You are fake news media! Crooked!"}' \ http://127.0.0.1:3000/predict</span><span id="b274" class="ns la it og b gy oo ol l om on"># Output:<br/>{"hate speech": 0.08, "offensive language": 0.76, "neither": 0.16}</span></pre><p id="c3b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本例中，容器在本地运行。当然，实际的目的是让它在一个永久的位置运行，并且可能通过在一个企业集群中启动多个容器来扩展服务。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b1bb" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">4.部署为 Heroku 应用程序</h1><p id="089c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让其他人可以公开使用该应用的一种方式是使用平台即服务，如<strong class="lt iu"> Heroku </strong>，它支持 Docker 并提供免费的基本会员资格。要使用它，我们必须注册一个帐户并安装 Heroku CLI。</p><p id="534b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Heroku 的应用程序容器公开了一个动态端口，这需要在我们的<code class="fe or os ot og b">Dockerfile</code>中进行编辑:我们必须将端口 5000 更改为环境变量<code class="fe or os ot og b">PORT</code>:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="dab3" class="ns la it og b gy ok ol l om on">CMD firefly app.predict --bind 0.0.0.0:$PORT</span></pre><p id="5e60" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在此变更之后，我们就可以开始部署了。在命令行上，我们登录 heroku(它会在浏览器中提示我们输入凭证)并创建一个名为<code class="fe or os ot og b">hate-speech-detector</code>的应用程序:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="20bd" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> heroku login</span><span id="8225" class="ns la it og b gy oo ol l om on"><strong class="og iu">$ </strong>heroku create hate-speech-detector</span></pre><p id="ac33" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后我们登录到容器注册中心。<code class="fe or os ot og b">heroku container:push</code>将基于当前目录中的 Dockerfile 构建一个映像，并将其发送到 Heroku 容器注册表。之后，我们可以将图像发布到应用程序:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="dc15" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> heroku container:login</span><span id="7279" class="ns la it og b gy oo ol l om on"><strong class="og iu">$</strong> heroku container:push web --app hate-speech-detector</span><span id="acf0" class="ns la it og b gy oo ol l om on"><strong class="og iu">$</strong> heroku container:release web<!-- --> --app hate-speech-detector</span></pre><p id="1954" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">和以前一样，API 可以通过 curl 来处理。但是，这一次，服务不是在本地运行，而是面向全球！</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="f36f" class="ns la it og b gy ok ol l om on"><strong class="og iu">$</strong> curl -d ‘{“text”: “You dumb idiot!”}’ https://hate-speech-detector.herokuapp.com/predict</span><span id="c51b" class="ns la it og b gy oo ol l om on"># Output:<br/>{"hate speech": 0.26, "offensive language": 0.68, "neither": 0.06}</span></pre><p id="6294" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，只需点击几下鼠标或输入几个命令，就可以扩展应用程序。此外，该服务需要连接到留言板，需要设置触发阈值并实现警报。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="d581" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">希望这篇教程能帮助你部署你自己的机器学习模型和应用。有其他想法吗？请在评论中分享你的观点！</p></div></div>    
</body>
</html>