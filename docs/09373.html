<html>
<head>
<title>Multiprocess access to Intel Neural Computer Stick via REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过 REST 对英特尔神经计算机棒进行多进程访问</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multiprocess-access-to-intel-neural-computer-stick-via-rest-3e1d6eb50135?source=collection_archive---------37-----------------------#2019-12-10">https://towardsdatascience.com/multiprocess-access-to-intel-neural-computer-stick-via-rest-3e1d6eb50135?source=collection_archive---------37-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bbfd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 Python 包装器扩展硬件限制</h2></div><h1 id="b6bd" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">单一过程问题</h1><p id="7bad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我开始在我的树莓派机器人上使用<a class="ae lw" rel="noopener" target="_blank" href="/robot-tank-with-raspberry-pi-and-intel-neural-computer-stick-2-77263ca7a1c7">英特尔 NCS，这种升级有积极和消极的一面。</a></p><p id="1247" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">积极的一面是 NCS 能够用 Tensorflow 和 OpenCV 替换所有运行在 Raspberry 上的网络。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/ea0fb87340c6b81a18d8bfb1a37c727f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULFM1tOP-xVnonCwW2532A.jpeg"/></div></div></figure><p id="dd17" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">性能的提高激发了新的目标，但是很快我发现 NCS 不能在两个不同的过程中使用。</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="5ab3" class="mt kj it mp b gy mu mv l mw mx">E: [ncAPI] [    926029] resetAll:348     Failed to connect to stalled device, rc: X_LINK_ERROR <br/>E: [ncAPI] [    933282] ncDeviceOpen:672        Failed to find suitable device, rc: X_LINK_DEVICE_NOT_FOUND</span></pre><p id="f66f" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">在英特尔支持论坛上的搜索带来了一个<a class="ae lw" href="https://software.intel.com/en-us/forums/computer-vision/topic/815657" rel="noopener ugc nofollow" target="_blank">类似的问题</a>。</p><p id="91b9" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">有一个关于<a class="ae lw" href="https://docs.openvinotoolkit.org/2019_R1.1/_docs_IE_DG_supported_plugins_MYRIAD.html#supported_configuration_parameters" rel="noopener ugc nofollow" target="_blank">供应商文档</a>的参考，它说得很简单:</p><blockquote class="my mz na"><p id="863a" class="la lb nb lc b ld lx ju lf lg ly jx li nc lz ll lm nd ma lp lq ne mb lt lu lv im bi translated">单个设备不能跨多个进程共享。</p></blockquote><p id="1698" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">这意味着有必要建立一个变通办法。</p><h1 id="e53d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">NCS 服务</h1><p id="c159" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以这个想法是将 NCS 的工作委托给一个专门的服务。</p><p id="69a5" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">该服务应该提供 REST API 包装 NCS 函数。</p><h2 id="50c6" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">NCS API</h2><p id="babb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">基本用例非常简单:</p><ul class=""><li id="7fff" class="nq nr it lc b ld lx lg ly lj ns ln nt lr nu lv nv nw nx ny bi translated">加载模型</li><li id="5e46" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">进行推理</li><li id="b6fb" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">列出加载的模型</li><li id="2138" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">获取模型的特征</li></ul><p id="55d6" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">最有趣的场景是推理运行。</p><p id="b780" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">通常它返回整个模型的输出——多维张量。</p><p id="e12c" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">原始张量在某些情况下是有用的，但通常我们需要更具体的数据。</p><p id="c96e" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">我使用 NCS 对图像进行分类，检测物体和分割道路。</p><p id="3f96" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">因此，一般用例“运行推理”被扩展为:</p><ul class=""><li id="a14d" class="nq nr it lc b ld lx lg ly lj ns ln nt lr nu lv nv nw nx ny bi translated">分类</li><li id="a56d" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">发现</li><li id="b3a9" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">段</li></ul><h2 id="9659" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">REST 接口</h2><ul class=""><li id="92db" class="nq nr it lc b ld le lg lh lj oe ln of lr og lv nv nw nx ny bi translated">POST: /load —加载模型</li><li id="d4aa" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /unload/$model —删除模型(从服务内存中，无法从设备中删除)</li><li id="3aad" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">GET: /list —列出模型</li><li id="0bd0" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">GET:/input/shape/$ model-获取模型的形状</li><li id="5ddd" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /inference/file/$model —使用来自内存的数据运行推理</li><li id="7c2e" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /inference/path/$model —使用文件系统中的数据运行推理</li><li id="c165" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /classify/file/$model</li><li id="c784" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /classify/path/$model</li><li id="d828" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /detect/file/$model</li><li id="d702" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /detect/path/$model</li><li id="9bd8" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /segment/file/$model</li><li id="9cd0" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">POST: /segment/path/$model</li></ul><h2 id="5e89" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">内存与文件系统</h2><p id="4454" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有两种方法可以传递图像——通过内存(如果已经有了，可能会有用)或文件系统路径。</p><p id="f24b" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">当 NCS 服务和客户端运行在同一个 Raspberry Pi 上时，第二种方法会更好。</p><p id="d66f" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">有一个简短的基准确认(1000 次尝试):</p><p id="990f" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">内存:87.5 秒<br/>文件:63.3150 秒</p><h2 id="7430" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">分类</h2><p id="65a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">方法/分类将原始推理输出转换成一组对(类，分数):</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="b03c" class="mt kj it mp b gy mu mv l mw mx">def get_class_tensor(data):<br/>    ret = []<br/>    thr = 0.01<br/>    while(True):<br/>        cls = np.argmax(data)<br/>        if data[cls] &lt; thr:<br/>            break;<br/>        logging.debug(("Class", cls, "score", data[cls]))<br/>        c = {"class" : int(cls), "score" : int(100 * data[cls])}<br/>        data[cls] = 0<br/>        ret.append(c)<br/>    return ret</span><span id="6826" class="mt kj it mp b gy oh mv l mw mx">def classify(model_id, img):<br/>    rc, out = run_inference(model_id, img)<br/>    if not rc:<br/>        return rc, out<br/>    return True, get_class_tensor(out)</span></pre><h2 id="6191" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">侦查</h2><p id="693f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出检测张量包含一组(类别、概率、归一化坐标),看起来不太可读。</p><p id="64e6" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">将其转换为简单的表示，同时删除最不可能的选项:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="3212" class="mt kj it mp b gy mu mv l mw mx">def get_detect_from_tensor(t, rows, cols):<br/>    score = int(100 * t[2])<br/>    cls = int(t[1])<br/>    left = int(t[3] * cols)<br/>    top = int(t[4] * rows)<br/>    right = int(t[5] * cols)<br/>    bottom = int(t[6] * rows)<br/>    return {"class" : cls, "score" : score, "x" : left, "y" : top, "w" : (right - left), "h" : (bottom - top)}<br/></span><span id="7684" class="mt kj it mp b gy oh mv l mw mx">def build_detection(data, thr, rows, cols):<br/>    T = {}<br/>    for t in data:<br/>        score = t[2]<br/>        if score &gt; thr:<br/>            cls = int(t[1])<br/>            if cls not in T:<br/>                T[cls] = get_detect_from_tensor(t, rows, cols)<br/>            else:<br/>                a = T[cls]<br/>                if a["score"] &lt; score:<br/>                    T[cls] = get_detect_from_tensor(t, rows, cols)<br/>    return list(T.values())</span></pre><h2 id="2742" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">分割</h2><p id="65be" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分段张量包含模型维度内分类的概率。</p><p id="ec13" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">将其转换为类别掩码:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="192c" class="mt kj it mp b gy mu mv l mw mx">def segment(model_id, img):<br/>    rc, out = run_inference(model_id, img)<br/>    if not rc:<br/>        return rc, out<br/>    out = np.argmax(out, axis=0)<br/>    out = cv.resize(out,(img.shape[1], img.shape[0]), interpolation=cv.INTER_NEAREST)<br/>    return True, out</span></pre><h2 id="0869" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">结论</h2><p id="7b16" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我根据自己的需要开发了在 Raspberry Pi 上运行的服务。</p><p id="6ebd" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">但是没有什么可以阻止在任何其他平台上运行 Python、OpenVino 和 NCS。</p><h2 id="22e5" class="mt kj it bd kk nf ng dn ko nh ni dp ks lj nj nk ku ln nl nm kw lr nn no ky np bi translated">链接</h2><p id="848b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae lw" href="https://software.intel.com/en-us/articles/run-intel-openvino-models-on-intel-neural-compute-stick-2" rel="noopener ugc nofollow" target="_blank">英特尔 OpenVino 简介</a></p><p id="3fe4" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">【Raspbian 官方 OpenVino 安装指南</p><p id="2a46" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><a class="ae lw" href="https://software.intel.com/en-us/openvino-toolkit/documentation/pretrained-models" rel="noopener ugc nofollow" target="_blank">奥博维诺模型动物园</a></p><p id="61cc" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><a class="ae lw" href="https://download.01.org/opencv/2019/open_model_zoo/" rel="noopener ugc nofollow" target="_blank"> OpenVino 模型下载</a></p><p id="e7a6" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><a class="ae lw" href="https://github.com/tprlab/ncs-rest" rel="noopener ugc nofollow" target="_blank">Github 上的 NCS 包装器源代码</a></p></div></div>    
</body>
</html>