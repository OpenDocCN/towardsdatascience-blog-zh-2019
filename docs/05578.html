<html>
<head>
<title>Outlier Detection: An ETL Tutorial with Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">离群点检测:Spark ETL 教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/outlier-detection-an-etl-tutorial-with-spark-f4197eb84a7b?source=collection_archive---------9-----------------------#2019-08-16">https://towardsdatascience.com/outlier-detection-an-etl-tutorial-with-spark-f4197eb84a7b?source=collection_archive---------9-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e9f37e1f5f1acea6279141f10b638759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpJn_UoU6BWjXfjxHiFTQQ.png"/></div></div></figure><p id="0aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">工业 4.0 框架的一部分是确保制造商对他们在工厂车间的机器有更多的可见性。这也是工业 4.0 与物联网紧密结合的原因。物联网允许从安装在生产设备中的传感器收集大规模实时数据。然而，仅有好的数据收集代理是不够的。我们需要一种自动化的方式从大量的数据流中提取、分析和总结信息，因为人类不可能手动完成这些工作。在大数据术语中，这个过程通常被称为<a class="ae kz" href="https://en.wikipedia.org/wiki/Extract,_transform,_load" rel="noopener ugc nofollow" target="_blank"> ETL </a>(提取-转换-加载)。</p><p id="8efe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天，我们将讨论一个我个人认为在行业中有用的算法家族:异常值检测。想法是从数据流中发现任何异常测量，并向领域专家(如过程工程师)突出显示它们。我将在<a class="ae kz" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Spark </a>中分享一个基本异常检测算法的实现。我本来可以用 python 的 pandas-dataframe 做同样的教程，但不幸的是，一旦我们处理大数据集(其大小远远大于内存空间)，后者就不再合适了。</p><p id="c5fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将使用<a class="ae kz" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> scala </a>作为我选择的编程语言。我个人在为生产写代码的时候喜欢用 scala。Python 写起来更快，因此对原型开发很有用。然而，它缺乏静态类型可能会使事情更难调试。另一方面，scala 更类似于 Java，尽管不那么冗长(它也运行在 JVM 上)。但是让我们把这个赞成和反对的辩论留到另一个会议。</p><p id="7d8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我使用的一个简单的虚拟数据集。假设我们有来自 2 个传感器的数据流。我们如何自动捕捉下面出现的两个异常点？</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/6a47df21e5929494770915f05699261d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NT1gMrAKkeGC-YUF-olSDw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Dataset</figcaption></figure><h2 id="b4fc" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">离群点检测</h2><p id="76e7" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们使用的模型找到了在符合观察数据的分布下出现概率低的值的区域。我们假设传感器本质上是单峰高斯型的。这样，我们就可以计算出两个阈值，这两个阈值与分布的平均值相差 6σ。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/ada8f687f5d9e4fdab7ef17e5ac67c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLuquZaamGS1GdYjen7ieQ.png"/></div></div></figure><p id="2602" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视觉上，阈值以这种方式拟合。任何高于上限(约 25)或低于下限(约 15)的测量值都被视为异常值。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/d1f748dd47a10f8e2ebcab87a35914a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FSmI7mMO6Eukukpn.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">The Upper and Lower Outlier Thresholds</figcaption></figure><p id="c1bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了在 Spark 中实现这一点，我们首先导入所有的库依赖项。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="d410" class="lj lk it mk b gy mo mp l mq mr"><strong class="mk iu">import </strong>org.apache.spark.sql.{Column, SQLContext}<br/><strong class="mk iu">import </strong>org.apache.spark.{SparkConf, SparkContext}<br/><strong class="mk iu">import </strong>org.apache.spark.sql.types._<br/><strong class="mk iu">import </strong>org.apache.spark.sql.functions._</span></pre><p id="fd7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要用一个主函数将所有的函数包装在一个对象中(这可能会让你想起 Java)。我们实际上可以用不同的风格来写，看起来更像一个脚本。Scala 有一个名为 REPL 的解释器，允许程序员逐行执行代码。然而，在生产中，以这种方式组织事情是有好处的。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="a285" class="lj lk it mk b gy mo mp l mq mr"><em class="ms">/**<br/>  * Sample Anomaly Detection with Spark<br/>  */<br/></em><strong class="mk iu">object </strong>AnomalyDetection {<br/>    <strong class="mk iu">def </strong>main(args: Array[String]): Unit = {<br/>      // the rest of the functions go here<br/>    }<br/>}</span></pre><p id="7b77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果你在 Windows 中运行 spark，你可能会遇到一些异常，说程序无法找到 winutil 二进制文件。在这种情况下，您需要下载 winutils.exe(<a class="ae kz" href="https://jaceklaskowski.gitbooks.io/mastering-apache-spark/spark-tips-and-tricks-running-spark-windows.html" rel="noopener ugc nofollow" target="_blank">这个</a>是如何做的)并在您的代码中设置以下系统属性。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="e376" class="lj lk it mk b gy mo mp l mq mr">System.<em class="ms">setProperty</em>("hadoop.home.dir", "C:/winutil/")</span></pre><p id="7f84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要配置 spark、sparkContext 和 sqlContext。如果我们将<a class="ae kz" href="https://hbase.apache.org/" rel="noopener ugc nofollow" target="_blank"> HBase </a>(一个 NoSQL 数据库)与<a class="ae kz" href="https://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank"> ZooKeeper </a>一起使用，我们将需要配置<em class="ms"> spark.hbase.host </em>参数来指向相应的主机地址。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="29f2" class="lj lk it mk b gy mo mp l mq mr"><em class="ms">/** Configure Spark */<br/></em><strong class="mk iu">val </strong>conf = <strong class="mk iu">new </strong>SparkConf()<br/>  .setAppName("anomalyDetection")<br/>  .setMaster("local[8]")<br/>conf.set("spark.hbase.host", "zookeeper.default.svc.cluster.local")<br/><br/><strong class="mk iu">val </strong>sc = <strong class="mk iu">new </strong>SparkContext(conf)<br/>sc.setLogLevel("WARN")<br/><strong class="mk iu">val </strong>sqlContext = <strong class="mk iu">new </strong>SQLContext(sc)</span></pre><h2 id="ea3b" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">提取</h2><p id="f3ce" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们现在假设我们的数据是 csv 格式的。它也被保存在一个名为<em class="ms"> test.csv </em>的文件中。我们首先明确指定数据模式。注意，在生产中，数据也可以从数据库和消息代理(例如 MQTT、Kafka 等)获得。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="663c" class="lj lk it mk b gy mo mp l mq mr"><em class="ms">/** read csv */<br/></em><strong class="mk iu">val </strong>customSchema = StructType(<em class="ms">Array</em>(<br/>  <em class="ms">StructField</em>("sensorId", StringType, <strong class="mk iu">true</strong>),<br/>  <em class="ms">StructField</em>("values", DoubleType, <strong class="mk iu">true</strong>))<br/>)</span></pre><p id="c27a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将 csv 文件读入 Spark 数据帧。这里我们可以看到只有两列:sensorId 和值。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="2c3b" class="lj lk it mk b gy mo mp l mq mr">// load dataset<br/><strong class="mk iu">val </strong>df = sqlContext.read<br/>  .format("com.databricks.spark.csv")<br/>  .option("header", "true")<br/>  .schema(customSchema)<br/>  .load("test.csv")<br/>df.printSchema()</span></pre><blockquote class="mt mu mv"><p id="b063" class="kb kc ms kd b ke kf kg kh ki kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ky im bi translated">root<br/>|—sensorId:string(nullable = true)<br/>|—values:double(nullable = true)</p></blockquote><h2 id="52b0" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">改变</h2><p id="9c5d" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们希望计算每个 sensorID 的分布轮廓，特别是异常值的上限和下限。为此，我们需要按 sensorId 对数据帧进行分组，然后相应地汇总每个传感器数据的平均值和标准差。然后，我们可以创建 2 个新列，每个异常阈值一列。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="146e" class="lj lk it mk b gy mo mp l mq mr">// calculate statistics<br/><strong class="mk iu">val </strong>statsDF = df<br/>  .groupBy("sensorId")<br/>  .agg(<em class="ms">mean</em>("values").as("mean"), <em class="ms">stddev</em>("values").as("stddev"))<br/>  .withColumn("UpperLimit", <em class="ms">col</em>("mean") + <em class="ms">col</em>("stddev")*3)<br/>  .withColumn("LowerLimit", <em class="ms">col</em>("mean") - <em class="ms">col</em>("stddev")*3)<br/>statsDF.printSchema()</span></pre><blockquote class="mt mu mv"><p id="605d" class="kb kc ms kd b ke kf kg kh ki kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ky im bi translated">root<br/>|—sensorId:string(nullable = true)<br/>|—mean:double(nullable = true)<br/>|—stddev:double(nullable = false)<br/>|—upper limit:double(nullable = true)<br/>|—lower limit:double(nullable = true)</p></blockquote><p id="e20d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在想找出原始数据帧中哪些传感器读数是异常的。由于信息存在于两个不同的数据帧中，我们需要使用 sensorId 列作为公共索引来连接它们。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="d5e2" class="lj lk it mk b gy mo mp l mq mr">// join the two dataframe<br/><strong class="mk iu">val </strong>joinDF = df.join(statsDF, usingColumns = <em class="ms">Seq</em>("sensorId"))</span></pre><p id="4d3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们可以过滤值超出离群阈值范围的行。瞧吧！我们设法捕捉到了两个异常点。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="2e47" class="lj lk it mk b gy mo mp l mq mr">// outlierDetection<br/><strong class="mk iu">val </strong>detectOutlier = (values: Column, UpperLimit: Column, LowerLimit: Column) =&gt; {<br/>  // outliers are points lying below LowerLimit or above upperLimit<br/>  (values &lt; LowerLimit) or (values &gt; UpperLimit)<br/>}<br/><strong class="mk iu">val </strong>outlierDF = joinDF<br/>  .withColumn("isOutlier", detectOutlier(<em class="ms">col</em>("values"), <em class="ms">col</em>("UpperLimit"), <em class="ms">col</em>("LowerLimit")))<br/>  .filter(<em class="ms">col</em>("isOutlier"))</span><span id="e4f9" class="lj lk it mk b gy mz mp l mq mr">outlierDF.show()</span></pre><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/131571b83f353711ab8be8d1908c2d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjGFiL-Xd7-iz5YNhwTByw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Anomalous Rows</figcaption></figure><h2 id="fd23" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">负荷</h2><p id="6594" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">(可选)我们还可以将输出数据帧写入另一个表(或 csv 文件)以供进一步处理。这就完成了整个 ETL 过程。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="6267" class="lj lk it mk b gy mo mp l mq mr">outlierDF<br/>  .repartition(1)<br/>  .write.format("com.databricks.spark.csv")<br/>  .save("result")</span></pre><p id="90dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的方法输出一个名为<em class="ms"> result </em>的文件夹，里面有以下文件。通常情况下，数据会被分割成多个 CSV(每个 CSV 都有不同的零件名称)。但是，由于我们已经将数据帧重新分区为 1，所有数据都收集到一个分区(或文件)中。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/e8c29f2205d35d71bb6d379fd40c32e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AA0CppxfrxGcb6kodtBg9w.png"/></div></div></figure><p id="e469" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一步是关闭 sparkContext。</p><pre class="lb lc ld le gt mj mk ml mm aw mn bi"><span id="f932" class="lj lk it mk b gy mo mp l mq mr">// close sparkContext<br/>sc.stop()</span></pre><h1 id="27a2" class="nc lk it bd ll nd ne nf lo ng nh ni lr nj nk nl lu nm nn no lx np nq nr ma ns bi translated">排除故障</h1><p id="83ca" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Spark 附带了一个 web 界面(默认情况下在 4040 端口),可以用来查看 ETL 过程是如何运行的。我发现这很有用，尤其是在识别瓶颈功能方面。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/742b81272206a5fe9f0bbb755ac3f5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0nOksf7UnIOdDTUHFj2xQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Example of Spark Web Interface in localhost:4040</figcaption></figure><h1 id="7ff6" class="nc lk it bd ll nd ne nf lo ng nh ni lr nj nk nl lu nm nn no lx np nq nr ma ns bi translated">结论</h1><p id="acc0" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们已经看到了一个典型的带有 Spark 的 ETL 管道是如何工作的，使用异常检测作为主要的转换过程。请注意，这里使用的一些程序不适合生产。例如，不鼓励 CSV 输入和输出。通常我们会使用 Hadoop 分布式文件系统(HDFS)。后者也可以包装在数据库下，例如 HBase。尽管如此，主要的编程范式保持不变。</p></div></div>    
</body>
</html>