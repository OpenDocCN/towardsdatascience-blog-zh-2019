<html>
<head>
<title>How To Fine-Tune Your Neural Network For Your Data: Image Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何针对数据微调神经网络:图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-fine-tune-your-neural-network-for-your-data-image-classification-d0f01c92300b?source=collection_archive---------10-----------------------#2019-12-04">https://towardsdatascience.com/how-to-fine-tune-your-neural-network-for-your-data-image-classification-d0f01c92300b?source=collection_archive---------10-----------------------#2019-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="950c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用 PyTorch 从迁移学习中获得更多</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e4255f00778a7a2a431eb29c06583b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tq_yFS02glh1GupH"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@denisseleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Denisse Leon</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a195" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="a223" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当你没有很多数据时，建立一个用于图像分类的神经网络并不总是容易的。近年来，这一领域取得了一些重大进展，使得构建有价值的模型变得更加可能，而无需使用数百万张图像进行训练。最值得注意的是，迁移学习名列榜首。</p><p id="f263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">迁移学习是从在 I <a class="ae le" href="http://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"> mageNet 数据集</a>上训练的大型模型中提取预先训练的权重，并使用这些权重作为不同数据集的起点。通常，这是通过替换最后一个全连接层并训练模型，同时仅更新线性层的权重并让卷积层保持它们的权重来完成的。</p><p id="33e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种图像分类方法通常非常有效，因为卷积层(我们可以将其视为学习图像特征的模型的一部分)已经看到了许多不同的图像，并且通常在提取图像特征以传递给线性层方面做得非常好。有一些简单的方法可以让这种普遍有效的方法更好地适用于您的特定数据。</p><h1 id="dc37" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">GoodReads 案例研究</h1><h2 id="22de" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">数据</h2><p id="9984" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了证明迁移学习的有效性以及如何在迁移学习的基础上进行改进，我使用了一个从 Goodreads 收集的数据集，这个数据集可以在<a class="ae le" href="https://www.kaggle.com/meetnaren/goodreads-best-books" rel="noopener ugc nofollow" target="_blank"> Kaggle 上找到。从这些数据中，我试图根据书籍封面的图像来预测一本书的正确类型。为了节省计算时间，我只使用了数据的子样本，并删除了所有少于 5 次观察的类型。最终的数据集有 77 种类型和近 20，000 个观察值，我们将其分为一个训练、验证和测试集(60/20/20)。</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a28b23b97ecf5486638ddcf804c3efcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*9SHhdO1zW_i0qsbeobnb0w.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://www.goodreads.com/book/show/6.Harry_Potter_and_the_Goblet_of_Fire" rel="noopener ugc nofollow" target="_blank">Example of book cover image</a></figcaption></figure><h2 id="c0c4" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">模型</h2><p id="e376" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这个案例研究中，我使用了 VGG 11 网络，如下图所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/0b2ae6aa9abd13164acbf2e4a3c79f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lfBlfwmlsfV_AseNoL95g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://www.quora.com/What-is-the-VGG-neural-network" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/What-is-the-VGG-neural-network</a></figcaption></figure><p id="ea27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将对网络进行的唯一更改是用一个新的线性层替换最后一个输入为 4096、输出为 1000 的线性层，新的线性层输入为 4096、输出为 77(我们拥有的流派数量)。除此之外，网络的架构将保持不变。</p><p id="65ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于模型的每个版本，我们保持相同的超参数，以便进行公平的比较。我使用 0.0003 的学习率，Adamax 优化器，交叉熵损失，以及 10 个时期后没有改善的早期停止。</p><h1 id="346c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">迁移学习</h1><p id="5bbd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如上所述，迁移学习为图像分类任务提供了巨大的收益。我们要运行的第一个测试是比较迁移学习和在没有任何预训练权重的情况下从头开始训练 VGG-11 架构。在 PyTorch 中，我们通过加载模型的预训练权重，替换最后一层，并从所有卷积层中移除梯度来实现这一点，如下所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8904" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以像普通网络一样训练它。我训练并测试了我们的转移学习网络，以及我们的从头开始的网络。结果完全符合我们的预期。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/2cea6c34878cc1dec08136539c36990d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*kgQvYmA9B8epREfYVqGxjg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Losses for transfer model vs. scratch model</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/5a00d62a3b1538aed6ed204e6064bf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7n4VSW6mfu04frxMp3lsjQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Accuracy for transfer model vs. scratch model</figcaption></figure><p id="7bee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从准确度图和损失图来看，很明显，我们的迁移学习模型比我们的从头开始模型表现得好得多。事实上，看起来我们迁移学习模型第一个时期的验证损失比我们从头开始的模型要好。除此之外，值得注意的是，传输模型达到最小验证损失只需要一半的时间。因此，传输模型在一半的时间内执行得更好。这是双赢的局面。</p><h1 id="4155" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">微调</h1><p id="22a8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">很明显，迁移学习是有效的，我们也很好地理解了它为什么有效。该模型从图像中学习了许多特征，并根据这些特征对我们的书籍封面进行了训练。让我们快速看一下 ImageNet 到底是什么样子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/4b908bec24ac8ce49d65aa63da96beba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7CM5ZBOXSe7Po9o-zczFg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://www.researchgate.net/figure/Examples-in-the-ImageNet-dataset_fig7_314646236" rel="noopener ugc nofollow" target="_blank">https://www.researchgate.net/figure/Examples-in-the-ImageNet-dataset_fig7_314646236</a></figcaption></figure><p id="1c1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些图像中有很多多样性，所以模型学习一般特征如此之好并不令人惊讶。如果我们看看这些数据，它看起来真的不像许多图片看起来像我们的哈利波特书的封面。有理由认为，更好地学习我们的书籍封面的特性可能有助于我们的转移模型进一步改进。</p><p id="0c0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过在训练时慢慢解冻卷积层的梯度来微调我们的传输模型，以适应我们独特的数据。首先，我们开始加载我们的模型，并以与我们第一个传输模型完全相同的方式更改最后一层。然后，在每一次训练之后，我们可以用类似这样的代码来更新网络的下一个卷积层的权重。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="366c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们慢慢地更新渐变，从最底层开始，一直到顶层。这保留了我们的模型从预先训练的权重中获得的大量信息，同时有助于根据我们的书籍封面对其进行微调。经过训练和测试后，我们可以将其与我们的其他两个网络进行比较。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a4dbbfafed702123b4b97cf79ba02a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*eqte2RmAmgRvbV9dCuTA1Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Losses for all models</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/0afbe9a68f140e46bfe02293fa7c1a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCNBOYZYxhsX6GNnqmPH9Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Accuracy for all models</figcaption></figure><p id="562d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对我们的模型进行微调会使我们的原始模型获得一些适度的收益。同样，我们也看到它减少了达到最小验证损失所需的训练时间。</p><h1 id="12cd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">提示和技巧</h1><ul class=""><li id="c66c" class="nd ne it js b jt md jx me kb nf kf ng kj nh kn ni nj nk nl bi translated">我在所有这些模型中使用了相同的超参数，试图使比较公平。实际上，在进行微调以防止过度拟合时，使用较低的学习速率(通常是递减的学习速率)通常更有效。</li><li id="5ed0" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">与大多数深度学习实例一样，大量数据将使微调更加有效。</li><li id="7398" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">同样的技术也可以用于 NLP 任务的网络。它不限于图像。</li></ul><h1 id="5700" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">最后的想法</h1><p id="8fe7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">像这样微调一个模型并不总是能得到更好的结果，但是绝对值得尝试。这是一个很容易的调整，你可以对你的代码进行调整，这有可能为你的模型提供一个几乎没有成本的提升。</p><p id="3c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想看完整的代码，你可以查看我的 github repo。数据和代码都在那里，应该可以运行。</p></div></div>    
</body>
</html>