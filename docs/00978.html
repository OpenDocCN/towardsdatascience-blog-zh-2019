<html>
<head>
<title>Image Segmentation using Python’s scikit-image module.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 的 scikit-image 模块进行图像分割。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-segmentation-using-pythons-scikit-image-module-533a61ecc980?source=collection_archive---------2-----------------------#2019-02-15">https://towardsdatascience.com/image-segmentation-using-pythons-scikit-image-module-533a61ecc980?source=collection_archive---------2-----------------------#2019-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="836b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">scikit-image 库的图像分割方法概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b0fb24a55c7165f087be17f436347d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oJJ2NNGYt6kS-zD1.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://i.imgflip.com/nuf6y.jpg" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><blockquote class="kz"><p id="55ac" class="la lb it bd lc ld le lf lg lh li lj dk translated">所有的东西迟早都是数字，包括图像。</p></blockquote><p id="e9fa" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated"><em class="mf">看过</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/The_Terminator" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu"> <em class="mf">【终结者】</em> </strong> </a> <em class="mf">的人一定会同意这是那个时代最伟大的科幻电影。在电影中，</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/James_Cameron" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu"> <em class="mf">詹姆斯·卡梅隆</em> </strong> </a> <em class="mf">引入了一个有趣的视觉效果概念，使观众有可能获得被称为终结者的电子人的眼睛后面。这种效果后来被称为</em> <a class="ae ky" href="http://www.imaginativeuniversal.com/blog/2015/10/16/terminator-vision/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu"> <em class="mf">终结者视觉</em></strong></a><strong class="lm iu"><em class="mf"/></strong><em class="mf">和</em><em class="mf">中的一种方式，它把人类从背景中分割出来。这听起来可能完全不合时宜，但图像分割是当今许多图像处理技术的重要组成部分。</em></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="334c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">图象分割法</h1><p id="4fd4" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">我们都很清楚 Photoshop 或类似的图形编辑器提供的无限可能性，它们可以将一个人从一幅图像中取出，放入另一幅图像中。然而，这样做的第一步是<strong class="lm iu"> <em class="mf">识别该人在源图像中的位置</em> </strong>和<strong class="lm iu"> <em class="mf"> </em> </strong>这是图像分割发挥作用的地方。有许多为图像分析目的而编写的库。在本文中，我们将详细讨论<strong class="lm iu"> scikit-image </strong>，这是一个基于 Python 的图像处理库。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><blockquote class="nk nl nm"><p id="3655" class="lk ll mf lm b ln nn ju lp lq no jx ls np nq lv lw nr ns lz ma nt nu md me lj im bi translated">完整的代码也可以从与本文相关的<a class="ae ky" href="https://github.com/parulnith/Image-Processing/tree/master/Image%20Segmentation%20using%20Python's%20scikit-image%20module" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu"> Github 资源库</strong> </a>中获得。</p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ec34" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">sci kit-图像</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/152cf9082c9bbdeb730bdfb8a4a979ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*eHdXVdhbQ39hDb08UcbBcw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">scikit-image.org</figcaption></figure><p id="1abf" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">Scikit-image 是一个专门用于图像处理的 Python 包。</p><h2 id="927e" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">装置</h2><p id="dce2" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">scikit-image 可以按如下方式安装:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="b45b" class="nw mo it oj b gy on oo l op oq">pip install scikit-image</span><span id="e128" class="nw mo it oj b gy or oo l op oq"># For Conda-based distributions<br/>conda install -c conda-forge scikit-image</span></pre><h2 id="1661" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">Python 中的图像概述</h2><p id="0501" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">在讨论图像分割的技术细节之前，有必要先熟悉一下 scikit 图像生态系统及其处理图像的方式。</p><ul class=""><li id="d35d" class="os ot it lm b ln nn lq no lt ou lx ov mb ow lj ox oy oz pa bi translated"><strong class="lm iu">从浏览库导入灰度图像</strong></li></ul><p id="4c59" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">skimage 数据模块包含一些内置的示例数据集，这些数据集通常以 jpeg 或 png 格式存储。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="aefa" class="nw mo it oj b gy on oo l op oq">from skimage import data<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="aa62" class="nw mo it oj b gy or oo l op oq">image = data.binary_blobs()<br/>plt.imshow(image, cmap='gray')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/093a5a23297a28fa29785888d721d053.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*zjJS3h1Yfahkdcvov-X76Q.png"/></div></figure><ul class=""><li id="bac2" class="os ot it lm b ln nn lq no lt ou lx ov mb ow lj ox oy oz pa bi translated"><strong class="lm iu">从浏览库导入彩色图像</strong></li></ul><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="e4ba" class="nw mo it oj b gy on oo l op oq">from skimage import data<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="aa5c" class="nw mo it oj b gy or oo l op oq">image = data.astronaut()</span><span id="c089" class="nw mo it oj b gy or oo l op oq">plt.imshow(image)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d38078b9a0392a12b5b945add26cf6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*GzdmwcDvp8jJ2vXA_johhg.png"/></div></figure><ul class=""><li id="5c5c" class="os ot it lm b ln nn lq no lt ou lx ov mb ow lj ox oy oz pa bi translated"><strong class="lm iu">从外部来源导入图像</strong></li></ul><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f477" class="nw mo it oj b gy on oo l op oq"># The I/O module is used for importing the image<br/>from skimage import data<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from skimage import io</span><span id="8e45" class="nw mo it oj b gy or oo l op oq">image = io.imread('skimage_logo.png')</span><span id="1a66" class="nw mo it oj b gy or oo l op oq">plt.imshow(image);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bfcda16e8f271bd60c4ef2e13abff9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*RS0cA3nB6Q0oHHNvyOGCRg.png"/></div></figure><ul class=""><li id="b780" class="os ot it lm b ln nn lq no lt ou lx ov mb ow lj ox oy oz pa bi translated"><strong class="lm iu">加载多张图片</strong></li></ul><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="e941" class="nw mo it oj b gy on oo l op oq">images = io.ImageCollection('../images/*.png:../images/*.jpg')</span><span id="c17f" class="nw mo it oj b gy or oo l op oq">print('Type:', type(images))<br/>images.files<br/>Out[]: Type: &lt;class ‘skimage.io.collection.ImageCollection’&gt;</span></pre><ul class=""><li id="23d5" class="os ot it lm b ln nn lq no lt ou lx ov mb ow lj ox oy oz pa bi translated"><strong class="lm iu">保存图像</strong></li></ul><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="503b" class="nw mo it oj b gy on oo l op oq">#Saving file as ‘logo.png’<br/>io.imsave('logo.png', logo)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="1b3f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">图象分割法</h1><p id="24b6" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">现在我们对 scikit-image 有了一个概念，让我们进入图像分割的细节。<a class="ae ky" href="https://en.wikipedia.org/wiki/Image_segmentation" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu">图像分割</strong> n </a>本质上是将<a class="ae ky" href="https://en.wikipedia.org/wiki/Digital_image" rel="noopener ugc nofollow" target="_blank">数字图像</a>分割成多个片段的过程，以简化和/或改变图像的表示，使其更有意义且更易于分析。</p><p id="dcd1" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">在本文中，我们将结合监督和非监督算法来处理分割过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/1a5a7c247f2bf68416e5bd1773187645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKnOz-YWIKtIohhYcydNEQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Some of the Segmentation Algorithms available in the scikit-image library</figcaption></figure><p id="7523" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated"><strong class="lm iu">监督分割:</strong>可能来自人的输入的一些先验知识用于指导算法。</p><p id="5445" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated"><strong class="lm iu">无监督分割</strong>:不需要先验知识。这些算法试图将图像自动细分成有意义的区域。用户可能仍然能够调整某些设置以获得期望的输出。</p><p id="e8b9" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">让我们从称为<strong class="lm iu">阈值处理的最简单算法开始。</strong></p><h2 id="86fc" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated"><a class="ae ky" href="http://scikit-image.org/docs/dev/auto_examples/xx_applications/plot_thresholding.html" rel="noopener ugc nofollow" target="_blank">阈值处理</a></h2><p id="8256" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">通过选择高于或低于某个<strong class="lm iu"> <em class="mf">阈值的像素，这是从背景中分割对象的最简单方法。当我们打算从背景中分割出物体时，这通常是有帮助的。你可以在这里阅读更多关于阈值<a class="ae ky" href="http://scikit-image.org/docs/dev/auto_examples/xx_applications/plot_thresholding.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></em></strong></p><p id="9b2d" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">让我们在预先加载了 scikit-image 数据集的教科书图像上尝试一下。</p><h2 id="66f1" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">基本进口</h2><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f16b" class="nw mo it oj b gy on oo l op oq">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="4f6d" class="nw mo it oj b gy or oo l op oq">import skimage.data as data<br/>import skimage.segmentation as seg<br/>import skimage.filters as filters<br/>import skimage.draw as draw<br/>import skimage.color as color</span></pre><p id="69c4" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">一个简单的函数来绘制图像</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="accd" class="nw mo it oj b gy on oo l op oq"><strong class="oj iu">def</strong> image_show(image, nrows=1, ncols=1, cmap='gray'):<br/>    fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(14, 14))<br/>    ax.imshow(image, cmap='gray')<br/>    ax.axis('off')<br/>    <strong class="oj iu">return</strong> fig, ax</span></pre><h2 id="1872" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">图像</h2><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="0ed2" class="nw mo it oj b gy on oo l op oq">text = data.page()</span><span id="b63b" class="nw mo it oj b gy or oo l op oq">image_show(text)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/1d21d18c4dd1839a49c9ec3b5be78782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TwGT2v06kkwZUechsRmQQ.png"/></div></div></figure><p id="c579" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">这张图像有点暗，但也许我们仍然可以选择一个值，在没有任何高级算法的情况下，给我们一个合理的分割。现在，为了帮助我们选择这个值，我们将使用一个<strong class="lm iu">直方图</strong>。</p><p id="2645" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated"><a class="ae ky" href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/histgram.htm" rel="noopener ugc nofollow" target="_blank">直方图</a>是显示在图像中发现的不同亮度值下图像中的<a class="ae ky" href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/pixel.htm" rel="noopener ugc nofollow" target="_blank">像素</a>的数量的图表。简而言之，直方图是一种图表，其中 x 轴显示图像中的所有值，而 y 轴显示这些值的频率。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="afa0" class="nw mo it oj b gy on oo l op oq">fig, ax = plt.subplots(1, 1)<br/>ax.hist(text.ravel(), bins=32, range=[0, 256])<br/>ax.set_xlim(0, 256);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a33c1f6960b2401ca1a0e42de7180ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*vn8dvcgPp6Rc_-vLQSf6Sw.png"/></div></figure><p id="cb6c" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">我们的例子恰好是一个 8 位图像，所以我们在 x 轴上总共有 256 个可能的值。我们观察到存在相当亮的像素浓度(0:黑色，255:白色)。这很可能是我们相当轻的文本背景，但其余的是一种涂抹了。一个理想的分割直方图应该是双峰的，并且是完全分开的，这样我们就可以在中间选择一个数字。现在，让我们试着基于简单的阈值分割制作一些分段图像。</p><h2 id="62b5" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">监督阈值</h2><p id="b430" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">由于我们将自己选择阈值，我们称之为监督阈值。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="4708" class="nw mo it oj b gy on oo l op oq">text_segmented = <em class="mf">text &gt; (value concluded from histogram i.e 50,70,120 )</em></span><span id="238e" class="nw mo it oj b gy or oo l op oq">image_show(text_segmented);</span></pre><div class="kj kk kl km gt ab cb"><figure class="pg kn ph pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/e6402d5d64d0df95d983c552c2907cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*eaK3yNuI9bJbj141fOCNwg.png"/></div></figure><figure class="pg kn ph pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/184ea7ebc904f4b5a0c8555955b14a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*haayaRKrp3rIQTHb7tOVaQ.png"/></div></figure><figure class="pg kn ph pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/610669746ab09219784e661485e76812.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*vEAuOsqfjvL1zCbXiI6Oxg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk pm di pn po">Left: text&gt;50 | Middle : text &gt; 70 | Right : text &gt;120</figcaption></figure></div><p id="9884" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">我们没有得到任何理想的结果，因为左边的阴影产生了问题。现在让我们尝试无监督阈值处理。</p><h2 id="1220" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">无监督阈值处理</h2><p id="7f92" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">Scikit-image 有许多自动阈值方法，在选择最佳阈值时不需要输入。一些方法有:<code class="fe pp pq pr oj b">otsu, li, local.</code></p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f6e1" class="nw mo it oj b gy on oo l op oq">text_threshold = filters.threshold_  <em class="mf"># Hit tab with the cursor after the underscore to get all the methods.</em></span><span id="d78f" class="nw mo it oj b gy or oo l op oq">image_show(text &lt; text_threshold);</span></pre><div class="kj kk kl km gt ab cb"><figure class="pg kn ps pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b04cb26712e9fe549a2c9097d728c3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*p8AyvPrybghIyUCejXDnag.png"/></div></figure><figure class="pg kn ps pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a08f5290a6f81b91642fef8489417b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*PzNc7qjP2CJxT5mh_Arrqg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk pt di pu po">Left: otsu || Right: li</figcaption></figure></div><p id="e81f" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">在<code class="fe pp pq pr oj b">local</code>的情况下，我们还需要指定<code class="fe pp pq pr oj b">block_size</code>。<code class="fe pp pq pr oj b"> Offset </code>帮助调整图像以获得更好的效果。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="db90" class="nw mo it oj b gy on oo l op oq">text_threshold = filters.threshold_local(text,block_size=51, offset=10) <br/>image_show(text &gt; text_threshold);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/b1b16284660c7a5571c414c909ba4c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqdIWXH33rCDhNQe4HP7xA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">local thresholding</figcaption></figure><p id="8f27" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">这是非常好的，并且在很大程度上摆脱了噪声区域。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="165f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">监督分割</h1><p id="8ea2" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">阈值分割是一个非常基本的分割过程，在高对比度图像中无法正常工作，为此我们需要更先进的工具。</p><p id="2b79" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">在本节中，我们将使用一个免费提供的示例图像，并尝试使用监督分割技术分割头部。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c2a6" class="nw mo it oj b gy on oo l op oq"><em class="mf"># import the image</em><br/>from skimage import io<br/>image = io.imread('girl.jpg') <br/>plt.imshow(image);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/f4fd783b5148b5ce6d2fe82a05d1cffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*j-7uFNt627H-FJOAUDEAfg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://www.pexels.com/photo/women-wearing-white-long-sleeved-collared-shirt-holding-bitcoin-1037915/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><blockquote class="kz"><p id="4733" class="la lb it bd lc ld le lf lg lh li lj dk translated">在对图像进行任何分割之前，使用一些滤波器对其进行降噪是一个好主意。</p></blockquote><p id="ad1f" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">但是，在我们的例子中，图像并不是很嘈杂，所以我们会照原样处理。下一步是用<code class="fe pp pq pr oj b">rgb2gray</code>将图像转换成灰度。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="face" class="nw mo it oj b gy on oo l op oq">image_gray = color.rgb2gray(image) <br/>image_show(image_gray);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/5b9ca66dc166211d9b56bcebbbe379f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7IfpQT4JJqOkBViwie09g.png"/></div></div></figure><p id="2c70" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">我们将使用两种基于完全不同原理的分割方法。</p><h2 id="8a7b" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated"><a class="ae ky" href="http://scikit-image.org/docs/dev/auto_examples/edges/plot_active_contours.html" rel="noopener ugc nofollow" target="_blank">活动轮廓分割</a></h2><p id="7287" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated"><strong class="lm iu">活动轮廓分割</strong>也称为<strong class="lm iu">蛇</strong>和<strong class="lm iu"> </strong>使用感兴趣区域周围的用户定义轮廓或线条进行初始化，然后该轮廓缓慢收缩，并被光线和边缘吸引或排斥。</p><p id="c49a" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">对于我们的示例图像，让我们在人的头部周围画一个圆来初始化蛇。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c5a9" class="nw mo it oj b gy on oo l op oq"><strong class="oj iu">def</strong> circle_points(resolution, center, radius):</span><span id="0eed" class="nw mo it oj b gy or oo l op oq"><em class="mf">    """</em><br/><em class="mf">    Generate points which define a circle on an image.Centre refers to the centre of the circle</em><br/><em class="mf">    """</em>   <br/>    radians = np.linspace(0, 2*np.pi, resolution)</span><span id="7b4d" class="nw mo it oj b gy or oo l op oq">    c = center[1] + radius*np.cos(radians)#polar co-ordinates<br/>    r = center[0] + radius*np.sin(radians)<br/>    <br/>    <strong class="oj iu">return</strong> np.array([c, r]).T</span><span id="6a2a" class="nw mo it oj b gy or oo l op oq"><em class="mf"># Exclude last point because a closed path should not have duplicate points</em><br/>points = circle_points(200, [80, 250], 80)[:-1]</span></pre><blockquote class="nk nl nm"><p id="1a19" class="lk ll mf lm b ln nn ju lp lq no jx ls np nq lv lw nr ns lz ma nt nu md me lj im bi translated">上面的计算计算了圆周上的点的 x 和 y 坐标。由于我们给定的分辨率是 200，它将计算 200 个这样的点。</p></blockquote><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f7fe" class="nw mo it oj b gy on oo l op oq">fig, ax = image_show(image)<br/>ax.plot(points[:, 0], points[:, 1], '--r', lw=3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/af6a428fcccf891b1490de8b242c8e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lErgdYIszHl7ldOhypNXyA.png"/></div></div></figure><p id="b7a9" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">然后，该算法通过将闭合曲线拟合到人脸的边缘，将人脸从图像的其余部分中分割出来。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="eb82" class="nw mo it oj b gy on oo l op oq">snake = seg.active_contour(image_gray, points)</span><span id="433e" class="nw mo it oj b gy or oo l op oq">fig, ax = image_show(image)<br/>ax.plot(points[:, 0], points[:, 1], '--r', lw=3)<br/>ax.plot(snake[:, 0], snake[:, 1], '-b', lw=3);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/fb0e6c251f22d01711b01ed5d5cd4028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFqeXPRL4luHygrHAflzDg.png"/></div></div></figure><p id="d18c" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">我们可以调整名为<code class="fe pp pq pr oj b">alpha</code>和<code class="fe pp pq pr oj b"> beta</code>的参数。较高的 alpha 值会使蛇收缩得更快，而 beta 值会使蛇更平滑。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="326d" class="nw mo it oj b gy on oo l op oq">snake = seg.active_contour(image_gray, points,alpha=0.06,beta=0.3)</span><span id="150d" class="nw mo it oj b gy or oo l op oq">fig, ax = image_show(image)<br/>ax.plot(points[:, 0], points[:, 1], '--r', lw=3)<br/>ax.plot(snake[:, 0], snake[:, 1], '-b', lw=3);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/f79ceef3abf7790f36d57057fa6edbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rb94RuEMDyOMsKqyXerMuA.png"/></div></div></figure><h2 id="8ffd" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated"><a class="ae ky" href="http://scikit-image.org/docs/dev/auto_examples/segmentation/plot_random_walker_segmentation.html" rel="noopener ugc nofollow" target="_blank">随机行者分割</a></h2><p id="eb80" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">在这种方法中，用户交互式地标记少量像素，这些像素被称为<strong class="lm iu">标记</strong>。然后，设想每个未标记的像素释放一个随机行走体，然后可以确定随机行走体从每个未标记的像素开始并到达预先标记的像素之一的概率。通过将每个像素分配给计算出最大概率的标签，可以获得高质量的图像分割。点击阅读<a class="ae ky" href="https://ieeexplore.ieee.org/document/1704833" rel="noopener ugc nofollow" target="_blank">参考文件。</a></p><p id="5e7e" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">在这里，我们将重用上一个示例中的种子值。我们可以用<br/>完成不同的初始化，但是为了简单起见，让我们坚持使用圆形。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="aec2" class="nw mo it oj b gy on oo l op oq">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</span></pre><p id="f367" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">随机漫步算法需要一个标签图像作为输入。因此，我们将有一个较大的圆圈包围着这个人的整个脸，另一个较小的圆圈靠近脸的中间。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ea0c" class="nw mo it oj b gy on oo l op oq">indices = draw.circle_perimeter(80, 250,20)#from <a class="ae ky" href="https://medium.com/p/533a61ecc980/oeed" rel="noopener">here</a></span><span id="2aaf" class="nw mo it oj b gy or oo l op oq">image_labels[indices] = 1<br/>image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2</span><span id="8666" class="nw mo it oj b gy or oo l op oq">image_show(image_labels);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/d578c9da2846f93d2cc3e61d81fa1830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E86k-8aHncrcWwQv5Sov3A.png"/></div></div></figure><p id="9220" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">现在，让我们使用随机漫步机，看看会发生什么。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="bcfe" class="nw mo it oj b gy on oo l op oq">image_segmented = seg.random_walker(image_gray, image_labels)</span><span id="302b" class="nw mo it oj b gy or oo l op oq"># Check our results<br/>fig, ax = image_show(image_gray)<br/>ax.imshow(image_segmented == 1, alpha=0.3);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/68027e67c4e801c0e7c11803d191e646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBqfhpKdxu5L8S2Sc9XuKQ.png"/></div></div></figure><p id="43d9" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">它看起来不像我们想要的那样抓住边缘。为了解决这种情况，我们可以调整β参数，直到我们得到想要的结果。经过几次尝试后，值 3000 工作得相当好。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1016" class="nw mo it oj b gy on oo l op oq">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000)</span><span id="9842" class="nw mo it oj b gy or oo l op oq"># Check our results<br/>fig, ax = image_show(image_gray)<br/>ax.imshow(image_segmented == 1, alpha=0.3);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/591a6ef2399205f15284f5465f7d7733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqJ9oZNn7a-jOe2dhb88gw.png"/></div></div></figure><p id="2e73" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">这就是监督分割，我们必须提供某些输入，还必须调整某些参数。然而，让一个人看着一幅图像，然后决定给出什么输入或者从哪里开始，并不总是可能的。幸运的是，对于这些情况，我们有无监督分割技术。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="6f16" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">无监督分割</h1><p id="0348" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">无监督分割不需要先验知识。考虑一个如此大的图像，以至于不可能同时考虑所有像素。因此，在这种情况下，无监督分割可以将图像分解成几个子区域，所以不是数百万像素，而是数十到数百个区域。让我们来看两个这样的算法:</p><h2 id="5457" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated"><a class="ae ky" href="http://scikit-image.org/docs/dev/api/skimage.segmentation.html#skimage.segmentation.slic" rel="noopener ugc nofollow" target="_blank"> SLIC(简单线性迭代聚类)</a></h2><p id="fba5" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">SLIC 算法实际上使用了一种叫做<strong class="lm iu"> K-Means </strong>的机器学习算法。它接受图像的所有像素值，并试图将它们分成给定数量的子区域。在此阅读<a class="ae ky" href="https://ieeexplore.ieee.org/document/6205760" rel="noopener ugc nofollow" target="_blank">参考文件</a>。</p><p id="b8a0" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">SLIC 是彩色的，所以我们将使用原始图像。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="6c95" class="nw mo it oj b gy on oo l op oq">image_slic = seg.slic(image,n_segments=155)</span></pre><p id="3c09" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">我们所做的只是将我们找到的每个子图像或子区域设置为该区域的平均值，这使得它看起来不像是随机分配的颜色的拼凑物，而更像是被分解成类似区域的图像。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="cfa3" class="nw mo it oj b gy on oo l op oq"><em class="mf"># label2rgb replaces each discrete label with the average interior color</em><br/>image_show(color.label2rgb(image_slic, image, kind='avg'));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/95dc79e245741de588df4bc0328f8f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAZRt53iRxqRRvR0HftyXA.png"/></div></div></figure><p id="3d0f" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">我们将这张图片从 512*512 = 262，000 像素缩减到 155 个区域。</p><h2 id="293b" class="nw mo it bd mp nx ny dn mt nz oa dp mx lt ob oc mz lx od oe nb mb of og nd oh bi translated">费尔曾兹瓦尔布</h2><p id="da51" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">该算法还使用了一种叫做<strong class="lm iu">最小生成树聚类</strong>的机器学习算法。Felzenszwaib 没有告诉我们图像将被划分成多少个簇。它将运行并生成它认为适合图像上给定的<br/>比例或缩放因子的尽可能多的集群。<a class="ae ky" href="http://cs.brown.edu/people/pfelzens/segment/" rel="noopener ugc nofollow" target="_blank">参考文件可在此处</a>获取。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="4b5c" class="nw mo it oj b gy on oo l op oq">image_felzenszwalb = seg.felzenszwalb(image) <br/>image_show(image_felzenszwalb);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/9943732a1916fdc691827f3154bdeae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeAmHNlvZ1RrhZU6Z3xTgA.png"/></div></div></figure><p id="2fe6" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">这是很多地区。让我们来计算独特区域的数量。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="0ccc" class="nw mo it oj b gy on oo l op oq">np.unique(image_felzenszwalb).size<br/>3368</span></pre><p id="ae67" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">现在让我们使用区域平均值对它们重新着色，就像我们在 SLIC 算法中做的那样。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c465" class="nw mo it oj b gy on oo l op oq">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind='avg')</span><span id="c46b" class="nw mo it oj b gy or oo l op oq">image_show(image_felzenszwalb_colored);</span></pre><p id="3ca4" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">现在我们得到了相当小的区域。如果我们想要更少的区域，我们可以改变<code class="fe pp pq pr oj b">scale</code>参数或者从这里开始合并它们。这种方法有时被称为<strong class="lm iu">过度分割</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/f27cdbbf55f07f90350739d302638f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HedpxW-NdnI8JlMQ3iIB3Q.png"/></div></div></figure><p id="73d9" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated">这几乎看起来更像是一个色调分离的图像，本质上只是减少了颜色的数量。要再次组合它们，可以使用<a class="ae ky" href="http://scikit-image.org/docs/dev/auto_examples/segmentation/plot_rag.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu">区域邻接图(RAG </strong> </a> <strong class="lm iu"> ) </strong>，但这超出了本文的范围。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="eaf3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">基于深度学习的图像分割</h1><p id="adb2" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">到目前为止，我们只使用 scikit 图像模块研究了图像分割技术。然而，值得一提的是一些使用深度学习的图像分割技术。这里有一篇精彩的博客文章，重点介绍了图像分割架构、损失、数据集和框架，您可以将其用于您的图像分割项目。</p><div class="pw px gp gr py pz"><a href="https://neptune.ai/blog/image-segmentation-in-2020" rel="noopener  ugc nofollow" target="_blank"><div class="qa ab fo"><div class="qb ab qc cl cj qd"><h2 class="bd iu gy z fp qe fr fs qf fu fw is bi translated">2020 年的图像分割:架构、损失、数据集和框架</h2><div class="qg l"><h3 class="bd b gy z fp qe fr fs qf fu fw dk translated">在这篇文章中，我们将使用深度学习深入研究图像分割的世界。我们将讨论:什么…</h3></div><div class="qh l"><p class="bd b dl z fp qe fr fs qf fu fw dk translated">海王星. ai</p></div></div><div class="qi l"><div class="qj l qk ql qm qi qn ks pz"/></div></div></a></div></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3328" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="f193" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">图像分割是一个非常重要的图像处理步骤。它是一个活跃的研究领域，应用范围从计算机视觉到医学成像，再到交通和视频监控。Python 以 scikit-image 的形式提供了一个健壮的库，其中包含大量用于图像处理的算法。它是免费的，没有任何限制，背后有一个活跃的社区。看看他们的文档，了解更多关于这个库及其用例的信息。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="55cd" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated"><strong class="lm iu">参考文献:</strong></p><p id="132d" class="pw-post-body-paragraph lk ll it lm b ln nn ju lp lq no jx ls lt nq lv lw lx ns lz ma mb nu md me lj im bi translated"><a class="ae ky" href="https://scikit-image.org/docs/dev/user_guide/tutorial_segmentation.html" rel="noopener ugc nofollow" target="_blank"> Scikit 图像文档</a></p></div></div>    
</body>
</html>