<html>
<head>
<title>How to cut out the SQL middle-person in analytics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在分析中避开 SQL 中间人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-cut-out-the-sql-middle-person-in-analytics-9687d640cecc?source=collection_archive---------12-----------------------#2019-01-16">https://towardsdatascience.com/how-to-cut-out-the-sql-middle-person-in-analytics-9687d640cecc?source=collection_archive---------12-----------------------#2019-01-16</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="01b5" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">不断地为您的客户手动执行 SQL 查询？这里有一个让他们自助的方法。</h2></div><p id="7596" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我目前的人生目标之一是帮助数据分析师削减他们工作中无聊、麻木的方面，以便他们可以专注于更有趣、有用和酷的东西。</p><p id="8fba" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我在分析团队中看到的一种常见情况是，分析师扮演了一个不必要且高度重复的中间人角色，即业务用户反复需要某些特定数据，而由分析师手动执行这些重复的 SQL 查询来提取数据并将其发送给客户端。相同或非常相似的查询，一次又一次。不好玩。实际上在今天的技术下完全没有必要。</p><p id="acc5" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我爱 R 生态系统。我喜欢它的原因之一是因为它可以让你轻松地做一些神奇的事情，将数据源与基于 web 的交互联系起来。在这篇文章中，我将向您展示如何使用 R Shiny 建立一个简单的 web 应用程序，它将允许您的非技术专业客户从 SQL 数据库中选择他们想要的原始数据，并将其提取和下载到 Excel 电子表格中。这是去掉中间人的安全方法，因为您可以控制谁可以访问 Web 应用程序，以及允许它从数据库中检索哪些数据。</p><p id="2a53" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我将在这里使用一个简单的场景来说明这些概念，但是这个想法可以扩展到能够向您的客户端提供大量可下载的预处理数据。</p><h2 id="6ed4" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">你需要什么</h2><ol class=""><li id="ce6e" class="lz ma iv km b kn mb kq mc kt md kx me lb mf lf mg mh mi mj bi translated">r 安装了<code class="fe mk ml mm mn b">shiny</code>、<code class="fe mk ml mm mn b">dplyr</code>、<code class="fe mk ml mm mn b">openxlsx</code>、<code class="fe mk ml mm mn b">rmarkdown</code>和<code class="fe mk ml mm mn b">odbc</code>包。</li><li id="fcda" class="lz ma iv km b kn mo kq mp kt mq kx mr lb ms lf mg mh mi mj bi translated">您希望从中检索特定数据的 SQL 数据库。在本文中，我将假设它是一个 Oracle SQL 数据库。</li><li id="c835" class="lz ma iv km b kn mo kq mp kt mq kx mr lb ms lf mg mh mi mj bi translated">RStudio Connect 文档/应用托管平台，或至少访问一个闪亮的服务器。</li></ol><h2 id="ec31" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">我们的简单示例场景</h2><p id="535f" class="pw-post-body-paragraph kk kl iv km b kn mb jw kp kq mc jz ks kt mt kv kw kx mu kz la lb mv ld le lf io bi translated">让我们假设你是一家连锁兽医诊所的数据分析师。每天您都会收到一些关于预约和预约取消的数据请求。我们会问两个问题:在这几年中，我们为每种动物预约了多少次？其中有百分之多少被取消了？您已经厌倦了一次又一次地使用相同的 SQL 查询来回答这些问题。</p><p id="a17c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">您的约会数据库表称为<code class="fe mk ml mm mn b">APPTS_DB</code>，它有许多列，特别是<code class="fe mk ml mm mn b">DATE</code>(格式为<code class="fe mk ml mm mn b">DD-MMM-YYYY</code>，例如<code class="fe mk ml mm mn b">01-MAR-2017</code>)、<code class="fe mk ml mm mn b">ANIMAL_TYPE</code>(例如<code class="fe mk ml mm mn b">Cat</code>、<code class="fe mk ml mm mn b">Dog</code>)、<code class="fe mk ml mm mn b">CANCEL_FLAG</code>(如果约会被取消，则为二进制<code class="fe mk ml mm mn b">1</code>，否则为<code class="fe mk ml mm mn b">0</code>)。</p><p id="0beb" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我假设你知道闪亮应用的结构。在这篇文章中，我将把这个闪亮的应用写成一个交互式 R markdown <code class="fe mk ml mm mn b">.Rmd</code>文档。有关这方面的更多信息，请参见<a class="ae mw" href="https://shiny.rstudio.com/articles/rmarkdown.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h2 id="9365" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">步骤 1:将您的 SQL 查询转换成 R 中的函数</h2><p id="0fb3" class="pw-post-body-paragraph kk kl iv km b kn mb jw kp kq mc jz ks kt mt kv kw kx mu kz la lb mv ld le lf io bi translated">将常用的 SQL 查询转换成 R 函数确实是一个好主意，即使您在本文中没有做任何其他事情。它允许您在 R 会话中用一个命令执行常见的查询。</p><p id="967b" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">为了将这一点构建到您的应用程序中，这一步可以在一个单独的 R 脚本中完成，您可以将其加载到您闪亮的应用程序中，或者它可以作为应用程序本身的代码块来完成。我们假设是后者。</p><p id="c8fd" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">首先，我们建立一个到数据库的连接。如果您打算将代码存储在 Github 或其他任何可能被他人看到的地方，我建议将您的凭证放在系统环境中。</p><pre class="mx my mz na gt nb mn nc nd aw ne bi"><span id="1756" class="lg lh iv mn b gy nf ng l nh ni">``` {r db_connect}</span><span id="1aaa" class="lg lh iv mn b gy nj ng l nh ni">db_conn &lt;- odbc::dbConnect(odbc::odbc(), <br/>                          dsn = Sys.getenv("DSN"), # &lt;- database<br/>                          uid = Sys.getenv("UID"), # &lt;- user id<br/>                          pwd = Sys.getenv("PASS")) # &lt;- password</span><span id="ab8c" class="lg lh iv mn b gy nj ng l nh ni">```</span></pre><p id="449f" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">首先，我们用占位符编写 SQL 查询，然后使用<code class="fe mk ml mm mn b">gsub() </code>用函数参数替换占位符，然后运行查询。我们希望设置它来提取从指定的起始年到结束年的时间段内按动物类型的约会总数，并计算取消率。理想情况下，我会建议您使用<code class="fe mk ml mm mn b">dbplyr</code>以整洁的形式完成这个查询，但是我在这里将使用原始 SQL 来完成，因为大多数读者对此都很熟悉。</p><pre class="mx my mz na gt nb mn nc nd aw ne bi"><span id="3146" class="lg lh iv mn b gy nf ng l nh ni">``` {r query_fn}</span><span id="2348" class="lg lh iv mn b gy nj ng l nh ni"># create query function</span><span id="cc62" class="lg lh iv mn b gy nj ng l nh ni">appt_query &lt;- function (start_yr, end_yr) {</span><span id="f741" class="lg lh iv mn b gy nj ng l nh ni"># write query with placeholders</span><span id="53e9" class="lg lh iv mn b gy nj ng l nh ni">  qry &lt;- "SELECT ANIMAL_TYPE, COUNT(*) NUM_APPTS, <br/>          SUM(CANCEL_FLAG)/COUNT(*) PERC_CANCELLED<br/>          FROM APPTS_DB<br/>          WHERE EXTRACT(YEAR FROM DATE) BETWEEN start_year AND end_year          <br/>          GROUP BY ANIMAL_TYPE<br/>          ORDER BY ANIMAL_TYPE"</span><span id="9504" class="lg lh iv mn b gy nj ng l nh ni"># replace placeholders with function arguments</span><span id="c84e" class="lg lh iv mn b gy nj ng l nh ni">  qry &lt;- gsub("start_year", start_yr, qry)<br/>  <br/>  qry &lt;- gsub("end_year", end_yr, qry)</span><span id="3a1e" class="lg lh iv mn b gy nj ng l nh ni"># execute query</span><span id="e0fc" class="lg lh iv mn b gy nj ng l nh ni">  odbc::dbGetQuery(db_conn, qry)</span><span id="0b2d" class="lg lh iv mn b gy nj ng l nh ni">}</span><span id="3e34" class="lg lh iv mn b gy nj ng l nh ni"><br/>```</span></pre><p id="f418" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这非常强大，因为它允许使用简单的命令如<code class="fe mk ml mm mn b">appt_query(2015, 2017)</code>获取信息。您也可以使用一个简单的<code class="fe mk ml mm mn b">paste()</code>函数将 SQL 查询粘贴在一起，但是我发现使用<code class="fe mk ml mm mn b">gsub()</code>更容易管理和检测错误。</p><h2 id="5864" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">步骤 2:设置闪亮的应用程序输入和下载按钮</h2><p id="cb79" class="pw-post-body-paragraph kk kl iv km b kn mb jw kp kq mc jz ks kt mt kv kw kx mu kz la lb mv ld le lf io bi translated">现在，我们为最终用户设置了一些简单的输入，以及一个下载按钮，他们将按下该按钮来执行查询并下载他们需要的数据。</p><p id="2d1c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在这个简单的例子中，只需要用户输入起始年份和结束年份。我们将从 2010 年开始我们的年度期权，到今年结束</p><pre class="mx my mz na gt nb mn nc nd aw ne bi"><span id="53a6" class="lg lh iv mn b gy nf ng l nh ni">``` {r user_input}</span><span id="61d8" class="lg lh iv mn b gy nj ng l nh ni"># get current year</span><span id="d82d" class="lg lh iv mn b gy nj ng l nh ni">curr_year &lt;- format(Sys.Date(), "%Y")</span><span id="c624" class="lg lh iv mn b gy nj ng l nh ni"># set up panel to select start and end years</span><span id="4fb4" class="lg lh iv mn b gy nj ng l nh ni">mainPanel(<br/>  HTML("&lt;br&gt;"),<br/>  selectInput("start_yr", "Select start year:",<br/>              choices = c(2010:curr_year)),<br/>  selectInput("end_yr", "Select end year:", <br/>              choices = c(2010:curr_year)),<br/>  HTML("&lt;br&gt;"),<br/>  uiOutput("downloadExcel")<br/>)</span><span id="e319" class="lg lh iv mn b gy nj ng l nh ni"># generate download button confirming the input selection</span><span id="5d77" class="lg lh iv mn b gy nj ng l nh ni">output$downloadExcel &lt;- renderUI(<br/>  downloadButton("downloadData", paste("Download Data for", input$start_yr, "to", input$end_yr, "in Excel"))<br/>)</span><span id="8192" class="lg lh iv mn b gy nj ng l nh ni">```</span></pre><p id="eea4" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这将创建一个带有下载按钮的用户输入面板，确认所选择的年份。这个 download 按钮将链接到一个名为<code class="fe mk ml mm mn b">downloadData</code>的服务器进程，在这里我们将执行查询并写入一个 Excel 文件供用户下载。</p><h2 id="e2fb" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">步骤 3:编写后台代码来执行查询和下载数据</h2><p id="b2d8" class="pw-post-body-paragraph kk kl iv km b kn mb jw kp kq mc jz ks kt mt kv kw kx mu kz la lb mv ld le lf io bi translated">现在我们编写服务器进程来执行查询和下载数据。这变得更简单了，因为我们设置了一个简洁的函数来执行查询(参见步骤 1)。我们还将建立一个整洁的进度条，以便用户可以看到该进程是如何进展的。对于一个可以立即完成的简单查询来说，这是不必要的，但是如果您正在使用许多不同的查询构建一个多选项卡的电子表格，那么它是必不可少的，以便让用户确信正在发生一些事情。</p><pre class="mx my mz na gt nb mn nc nd aw ne bi"><span id="cd8d" class="lg lh iv mn b gy nf ng l nh ni">``` {r query_and_download}</span><span id="3e9b" class="lg lh iv mn b gy nj ng l nh ni"># use downloadHandler</span><span id="e11e" class="lg lh iv mn b gy nj ng l nh ni">output$downloadData &lt;- downloadHandler(</span><span id="3971" class="lg lh iv mn b gy nj ng l nh ni"># give download file a name </span><span id="b128" class="lg lh iv mn b gy nj ng l nh ni">  filename = function() {<br/>    paste0("animal_appt_data_", input$start_yr, "_", input$end_yr, ".xlsx")<br/>    },</span><span id="02af" class="lg lh iv mn b gy nj ng l nh ni"># download and populate excel file</span><span id="5769" class="lg lh iv mn b gy nj ng l nh ni">  content = function(file) {</span><span id="ac73" class="lg lh iv mn b gy nj ng l nh ni"># create progress bar for user with first step<br/>  <br/>    shiny::withProgress(<br/>          min = 0,<br/>          max = 1,<br/>          value = 0,<br/>          {<br/>            shiny::incProgress(<br/>              amount = 1/2,<br/>              message = "Retrieving data from database..."<br/>              )<br/>  <br/># get data using function</span><span id="9a18" class="lg lh iv mn b gy nj ng l nh ni">  data &lt;- appt_query(input$start_yr, input$end_yr)</span><span id="18a1" class="lg lh iv mn b gy nj ng l nh ni"># set up an excel file in a tab called "Appointment Data"</span><span id="a25f" class="lg lh iv mn b gy nj ng l nh ni">        shiny::incProgress(<br/>          amount = 1/2,<br/>          message = "Writing to Excel..."<br/>        )</span><span id="4616" class="lg lh iv mn b gy nj ng l nh ni">  wb &lt;- openxlsx::createWorkbook()<br/>  openxlsx::addWorksheet(wb, "Appointment Data")</span><span id="8260" class="lg lh iv mn b gy nj ng l nh ni"><br/># design a nice header style so the results look professional</span><span id="4c02" class="lg lh iv mn b gy nj ng l nh ni">  hs1 &lt;- openxlsx::createStyle(fontColour = "#ffffff", <br/>                               fgFill = "#4F80BD",<br/>                               halign = "left", <br/>                               valign = "center", <br/>                               textDecoration = "bold",<br/>                               border = "TopBottomLeftRight", <br/>                               wrapText = TRUE)</span><span id="adf1" class="lg lh iv mn b gy nj ng l nh ni"># write the results into the "Appointment Data" tab with a nice border</span><span id="fc47" class="lg lh iv mn b gy nj ng l nh ni">  openxlsx::writeData(wb, "Appointment Data", x = data,<br/>                      startRow = 1, startCol = 1, <br/>                      borders = "surrounding",<br/>                      headerStyle = hs1)</span><span id="21ee" class="lg lh iv mn b gy nj ng l nh ni"># save Excel file and send to download</span><span id="10e5" class="lg lh iv mn b gy nj ng l nh ni">  openxlsx::saveWorkbook(wb, file, overwrite = TRUE)</span><span id="0b52" class="lg lh iv mn b gy nj ng l nh ni">  } # &lt;- end progress bar <br/>) # &lt;- end withProgress</span><span id="b407" class="lg lh iv mn b gy nj ng l nh ni">})  # &lt;- close content wrapper and downloadHandler function</span><span id="dac8" class="lg lh iv mn b gy nj ng l nh ni">```</span></pre><h2 id="ab4b" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">步骤 4:向客户端提供访问权限</h2><p id="7b62" class="pw-post-body-paragraph kk kl iv km b kn mb jw kp kq mc jz ks kt mt kv kw kx mu kz la lb mv ld le lf io bi translated">使用这种方法，客户端只能访问您为其设计的数据。如果您使用 RStudio Connect 共享平台，您可以将其发布为应用程序，并仅向特定个人或群组提供访问权限，确保只有授权的客户端才能访问。如果您使用 Shiny Server Pro，请从用户文档中寻求如何控制用户访问的建议。</p><h2 id="b66d" class="lg lh iv bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">结论和延伸</h2><p id="132f" class="pw-post-body-paragraph kk kl iv km b kn mb jw kp kq mc jz ks kt mt kv kw kx mu kz la lb mv ld le lf io bi translated">如果你是一个流利的闪亮的用户，你可能会立即掌握这里发生了什么。如果没有，你可能需要更多的培训，在你接受这个之前。这种方法可以扩展到非常强大。仪表板可以使用<code class="fe mk ml mm mn b">ggplot2</code>或<code class="fe mk ml mm mn b">plotly</code>来设计，而不是——或者除了——Excel 下载。像<code class="fe mk ml mm mn b">async</code>、<code class="fe mk ml mm mn b">future</code>和<code class="fe mk ml mm mn b">promises</code>这样的包可以用于使用异步编程的多个并发用户的伸缩(更多信息见<a class="ae mw" href="https://blog.rstudio.com/2018/06/26/shiny-1-1-0/" rel="noopener ugc nofollow" target="_blank">这里</a>)。在最高级的情况下，可以使用这里介绍的初始概念在 Shiny 上构建和托管一个完整的灵活的商业智能平台。</p><p id="d7ad" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本 RPG 的超级粉丝。在<a class="ae mw" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"><em class="nk">LinkedIn</em></a><em class="nk">或</em><a class="ae mw" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="nk">Twitter</em></a><em class="nk">上找我。</em></p><figure class="mx my mz na gt nm gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3c94322805b1e2fa4ee0c52ebedc2a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*jIP6nKd4cPqCQF8XFQhIEQ.jpeg"/></div></figure></div></div>    
</body>
</html>