<html>
<head>
<title>Data Visualization — Advanced Bokeh Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据可视化—高级散景技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-visualization-advanced-bokeh-techniques-e33f92537415?source=collection_archive---------18-----------------------#2019-10-23">https://towardsdatascience.com/data-visualization-advanced-bokeh-techniques-e33f92537415?source=collection_archive---------18-----------------------#2019-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/7722767036bc1027149722305127e862.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*fPt3XMVKJKFwh-pxJHu97w.gif"/></div></figure><div class=""/><div class=""><h2 id="8145" class="pw-subtitle-paragraph jx iz ja bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">散景交互式地图、数据表、文本输入和文档布局</h2></div><p id="4701" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果你想创建强大的数据可视化，那么你应该考虑使用散景。在之前的文章“如何使用 Python 和散景创建交互式地理地图”中，我演示了如何使用散景创建交互式地理地图。本文将更进一步，演示如何使用交互式地图以及使用散景布局组织的数据表和文本字段来创建用于显示数据的交互式仪表板。</p><p id="91c7" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">首先，让我们来看看文章《T2》中的成品:小心 Zillow，Jestimate 来了！”:</p><p id="2ce7" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><a class="ae ll" href="https://sf-2018-sales.herokuapp.com/SF_2018_Sales" rel="noopener ugc nofollow" target="_blank">点击这里观看三藩市 2018 Jestimates！</a></p><p id="28d0" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">关于代码的一句话</strong></p><p id="21ae" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">该项目的所有代码、数据和相关文件都可以在 my <a class="ae ll" href="https://github.com/JimKing100/Jestimate_Live" rel="noopener ugc nofollow" target="_blank"> GitHub </a>访问。该项目分为两个 Colab 笔记本。一个运行线性回归模型(为可视化创建数据)，另一个使用 Heroku 上的 Bokeh 服务器生成交互式可视化。</p><p id="0249" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">安装并导入</strong></p><p id="3008" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们从图表所需的安装和导入开始。Pandas、numpy 和 math 是用于清理和争论数据的标准 Python 库。geopandas、json 和 bokeh 导入是映射所需的库。</p><p id="9af0" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我在 Colab 工作，需要安装 fiona 和 geopandas。当您在 Colab 中开发应用程序时，您需要将这些安装保存在代码中。然而，一旦你开始用散景服务器测试，你将需要注释掉这些安装，因为散景不能很好地与魔术命令(！idspnonenote)一起工作。pip 安装)。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="bbe8" class="lv lw ja lr b gy lx ly l lz ma"># Install fiona - need to comment out for transfer to live site.<br/># Turn on for running in a notebook<br/>%%capture<br/>!pip install fiona<br/><br/># Install geopandas - need to comment out for tranfer to live site.<br/># Turn on for running in a notebook<br/>%%capture<br/>!pip install geopandas</span><span id="e612" class="lv lw ja lr b gy mb ly l lz ma"># Import libraries<br/>import pandas as pd<br/>import numpy as np<br/>import math<br/><br/>import geopandas<br/>import json<br/><br/>from bokeh.io import output_notebook, show, output_file<br/>from bokeh.plotting import figure<br/>from bokeh.models import GeoJSONDataSource, LinearColorMapper, ColorBar, NumeralTickFormatter<br/>from bokeh.palettes import brewer<br/><br/>from bokeh.io.doc import curdoc<br/>from bokeh.models import Slider, HoverTool, Select, TapTool, CustomJS, ColumnDataSource, TableColumn, DataTable, CDSView, GroupFilter<br/>from bokeh.layouts import widgetbox, row, column, gridplot<br/>from bokeh.models.widgets import TextInput</span></pre><p id="9aed" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">初步代码</strong></p><p id="8a20" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">由于本文的重点是交互式仪表板的创建，我将跳过以下步骤，这些步骤在我的上一篇文章“<a class="ae ll" rel="noopener" target="_blank" href="/how-to-create-an-interactive-geographic-map-using-python-and-bokeh-12981ca0b567">如何使用 Python 和 Bokeh 创建交互式地理地图”</a>中有详细介绍。</p><ol class=""><li id="0f6c" class="mc md ja kr b ks kt kv kw ky me lc mf lg mg lk mh mi mj mk bi translated">准备制图数据和地理数据框 geopandas.read _ file()</li><li id="57c3" class="mc md ja kr b ks ml kv mm ky mn lc mo lg mp lk mh mi mj mk bi translated">创建颜色条查找表— format_df 数据帧</li><li id="2456" class="mc md ja kr b ks ml kv mm ky mn lc mo lg mp lk mh mi mj mk bi translated">为 GeoJSONDataSource-JSON _ Data 函数创建 JSON 数据</li><li id="3f40" class="mc md ja kr b ks ml kv mm ky mn lc mo lg mp lk mh mi mj mk bi translated">创建绘图函数— make_plot 函数</li><li id="e3ee" class="mc md ja kr b ks ml kv mm ky mn lc mo lg mp lk mh mi mj mk bi translated">颜色栏-颜色栏，make_plot 函数的一部分</li><li id="eda7" class="mc md ja kr b ks ml kv mm ky mn lc mo lg mp lk mh mi mj mk bi translated">悬停工具—悬停工具</li></ol><p id="bb85" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">数据加载、清理和争论</strong></p><p id="0744" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我将简要讨论应用程序中使用的数据，如果你有兴趣，可以查看完整的清洗和争论<a class="ae ll" href="https://github.com/JimKing100/Jestimate_Live/blob/master/Final_SF_Map_Code.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2cd4" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">应用程序中使用了两个数据框架:用于显示每个街区 2018 年总统计数据的街区数据，以及由我的文章“<a class="ae ll" href="https://medium.com/p/look-out-zillow-here-comes-jestimate-145a96efbfbb?source=email-607257182a94--writer.postDistributed&amp;sk=c7ba752420820a3ef1b8b7cabf535b47" rel="noopener">中的线性回归代码生成的 2018 年销售的每个单独房产的显示数据。</a></p><p id="512d" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">邻域 _ 数据数据帧</strong></p><figure class="lm ln lo lp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/fd2d7ac2ed63b117b1666b5574167f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4xL_GVYZyUJ9Kuta0irHw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">neighborhood_data DataFrame</figcaption></figure><p id="2e6e" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">显示 _ 数据数据帧</strong></p><figure class="lm ln lo lp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mz"><img src="../Images/48cf1159c574ccef0b15d0e413888850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuaHh_ZZThOP66L_EuC_wA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">display_data DataFrame</figcaption></figure><p id="bc05" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">应用程序的主要代码</strong></p><p id="5670" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们看一下应用程序的主要代码，然后一步一步地详细介绍。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="dfb2" class="lv lw ja lr b gy lx ly l lz ma">### Start of Main Program<br/>    <br/># Input geojson source that contains features for plotting for:<br/># initial year 2018 and initial criteria sale_price_median<br/>geosource = GeoJSONDataSource(geojson = json_data(2018))<br/>original_geosource = geosource<br/>input_field = 'sale_price_mean'<br/><br/># Initialize the datatable - set datatable source, set intial neighborhood, set initial view by neighborhhood, set columns<br/>source = ColumnDataSource(results_data)<br/>hood = 'Bernal Heights'<br/>subdist = '9a'<br/>view1 = CDSView(source=source, filters=[GroupFilter(column_name='subdist_no', group=subdist)])<br/>columns = [TableColumn(field = 'full_address', title = 'Address')]<br/><br/># Define a sequential multi-hue color palette.<br/>palette = brewer['Blues'][8]<br/><br/># Reverse color order so that dark blue is highest obesity.<br/>palette = palette[::-1]<br/><br/>#Add hover tool to view neighborhood stats<br/>hover = HoverTool(tooltips = [ ('Neighborhood','@neighborhood_name'),<br/>                               ('# Sales', '@sale_price_count'),<br/>                               ('Average Price', '$@sale_price_mean{,}'),<br/>                               ('Median Price', '$@sale_price_median{,}'),<br/>                               ('Average SF', '@sf_mean{,}'),<br/>                               ('Price/SF ', '$@price_sf_mean{,}'),<br/>                               ('Income Needed', '$@min_income{,}')])<br/><br/># Add tap tool to select neighborhood on map<br/>tap = TapTool()<br/><br/># Call the plotting function<br/>p = make_plot(input_field)<br/><br/># Load the datatable, neighborhood, address, actual price, predicted price and difference for display<br/>data_table = DataTable(source = source, view = view1, columns = columns, width = 280, height = 280, editable = False)<br/>tap_neighborhood = TextInput(value = hood, title = 'Neighborhood')<br/>table_address = TextInput(value = '', title = 'Address')<br/>table_actual = TextInput(value = '', title = 'Actual Sale Price')<br/>table_predicted = TextInput(value = '', title = 'Predicted Sale Price')<br/>table_diff = TextInput(value = '', title = 'Difference')<br/>table_percent = TextInput(value = '', title = 'Error Percentage')<br/>table_shap = TextInput(value = '', title = 'Impact Features (SHAP Values)')<br/><br/># On change of source (datatable selection by mouse-click) fill the line items with values by property address<br/>source.selected.on_change('indices', function_source)<br/><br/># On change of geosource (neighborhood selection by mouse-click) fill the datatable with nieghborhood sales<br/>geosource.selected.on_change('indices', function_geosource)<br/><br/># Layout the components with the plot in row postion (0) and the other components in a column in row position (1)<br/>layout = row(column(p, table_shap), column(tap_neighborhood, data_table, table_address,<br/>              table_actual, table_predicted, table_diff, table_percent))<br/><br/># Add the layout to the current document<br/>curdoc().add_root(layout)<br/><br/># Use the following code to test in a notebook<br/># Interactive features will not show in notebook<br/>#output_notebook()<br/>#show(p)</span></pre><p id="e143" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">步骤 1 —初始化数据</strong></p><p id="b6f7" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">散景提供了几种处理数据的方法。在典型的散景交互式图形中，数据源是 ColumnDataSource。这是散景中的一个关键概念。然而，当使用地图时，我们使用 GeoJSONDataSource。我们将同时使用两者！</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d1c0" class="lv lw ja lr b gy lx ly l lz ma"># Input geojson source that contains features for plotting for:<br/># initial year 2018 and initial criteria sale_price_median<br/>geosource = GeoJSONDataSource(geojson = json_data(2018))<br/>original_geosource = geosource<br/>input_field = 'sale_price_mean'<br/><br/># Initialize the datatable - set datatable source, set intial neighborhood, set initial view by neighborhhood, set columns<br/>source = ColumnDataSource(results_data)<br/>hood = 'Bernal Heights'<br/>subdist = '9a'<br/>view1 = CDSView(source=source, filters=[GroupFilter(column_name='subdist_no', group=subdist)])<br/>columns = [TableColumn(field = 'full_address', title = 'Address')]</span></pre><p id="bd18" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们将希望加载的数据年份(2018)传递给 json_data 函数。然后，json_data 函数从<strong class="kr jb"> neighborhood_data </strong>中提取所选年份的数据，并将其与映射数据合并，为散景服务器返回转换为 json 格式的合并文件。我们的 GeoJSONDataSource 是 geosource。initial_field 用 sale_price_mean 初始化。</p><p id="a3c2" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们的 ColumnDataSource，Source，用<strong class="kr jb"> results_data </strong>初始化，列数据源视图(CDSView)，view1，用 Bernal Heights 邻域(subdist=9a)初始化。CDSView 是一种过滤数据的方法，允许您显示数据的子集，在本例中是 Bernal Heights 邻域。datatable 的列被初始化以显示属性的完整地址。</p><p id="a3b2" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">步骤 2——初始化颜色条、工具和地图绘制</strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1d29" class="lv lw ja lr b gy lx ly l lz ma"># Define a sequential multi-hue color palette.<br/>palette = brewer['Blues'][8]<br/><br/># Reverse color order so that dark blue is highest obesity.<br/>palette = palette[::-1]<br/><br/>#Add hover tool to view neighborhood stats<br/>hover = HoverTool(tooltips = [ ('Neighborhood','@neighborhood_name'),<br/>                               ('# Sales', '@sale_price_count'),<br/>                               ('Average Price', '$@sale_price_mean{,}'),<br/>                               ('Median Price', '$@sale_price_median{,}'),<br/>                               ('Average SF', '@sf_mean{,}'),<br/>                               ('Price/SF ', '$@price_sf_mean{,}'),<br/>                               ('Income Needed', '$@min_income{,}')])<br/><br/># Add tap tool to select neighborhood on map<br/>tap = TapTool()<br/><br/># Call the plotting function<br/>p = make_plot(input_field)</span></pre><p id="7de9" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">ColorBar 调色板、HoverTool 和 TapTool 被初始化，并且调用 make_plot 函数来创建显示中间价格邻域热图的初始地图图。</p><p id="1945" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">步骤 3——用初始数据填充数据表和文本字段</strong></p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b7a9" class="lv lw ja lr b gy lx ly l lz ma"># Load the datatable, neighborhood, address, actual price, predicted price and difference for display<br/>data_table = DataTable(source = source, view = view1, columns = columns, width = 280, height = 280, editable = False)<br/>tap_neighborhood = TextInput(value = hood, title = 'Neighborhood')<br/>table_address = TextInput(value = '', title = 'Address')<br/>table_actual = TextInput(value = '', title = 'Actual Sale Price')<br/>table_predicted = TextInput(value = '', title = 'Predicted Sale Price')<br/>table_diff = TextInput(value = '', title = 'Difference')<br/>table_percent = TextInput(value = '', title = 'Error Percentage')<br/>table_shap = TextInput(value = '', title = 'Impact Features (SHAP Values)')</span></pre><p id="acee" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">使用源(从 results_data 填充的 ColumnDataSource)、视图(针对 Bernal Heights 过滤的 view1)和列(仅使用 full_address 列的列)填充 datatable。Bokeh 中的 TextInput 小部件通常用于从用户那里收集数据，但也可以很好地显示数据！所有的 TextInput 小部件都用空格初始化。</p><p id="b762" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">第四步——回调函数</strong></p><p id="aade" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是交互性发挥作用的关键功能。散景小部件使用事件处理程序基于回调原理工作。on_change 或。on_click —提供自定义交互功能。然后，这些事件处理程序调用表单函数(attr，old，new)中的自定义回调函数，其中 attr 是指已更改属性的名称，old 和 new 是指属性的以前值和更新值。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="09fc" class="lv lw ja lr b gy lx ly l lz ma"># On change of source (datatable selection by mouse-click) fill the line items with values by property address<br/>source.selected.on_change('indices', function_source)</span></pre><p id="ceb0" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于数据表来说，这很容易，只需使用 source 的<strong class="kr jb">selected . on _ change</strong>event _ handler，并在用户单击数据表中的一行时调用函数<strong class="kr jb"> function_source </strong>，将该行的索引传递给它。然后，根据从数据表中选择的索引，从源(results_data)更新 TextInput 值。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="fdda" class="lv lw ja lr b gy lx ly l lz ma">def function_source(attr, old, new):<br/>    try:<br/>        selected_index = source.selected.indices[0]<br/>        table_address.value = str(source.data['full_address'][selected_index])<br/>        table_actual.value = '${:,}'.format((source.data['sale_price'][selected_index]))<br/>        table_predicted.value = '${:,}'.format((source.data['prediction'][selected_index]))<br/>        table_diff.value = '${:,}'.format(source.data['difference'][selected_index])<br/>        table_percent.value = '{0:.0%}'.format((source.data['pred_percent'][selected_index]))<br/>        table_shap.value = source.data['shap'][selected_index]<br/>        <br/>    except IndexError:<br/>        pass</span></pre><p id="4326" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于地图，我希望能够单击一个街区，并根据所选的街区填充数据表。奇怪的是，没有内置。HoverTool 的 on_click 事件处理程序。很明显，HoverTool 知道它在哪个街区盘旋，所以我自己建了一个！</p><p id="0851" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我意识到有一个 TapTool，在用地图测试后，我发现它是一个选择工具。换句话说，当您在地图上的多边形上单击鼠标时，它实际上使用邻域 id 作为索引来选择多边形！这也会触发。geosource 中的 on_change 事件处理程序。因此，使用与数据表相同的基本方法:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="674f" class="lv lw ja lr b gy lx ly l lz ma"># On change of geosource (neighborhood selection by mouse-click) fill the datatable with nieghborhood sales<br/>geosource.selected.on_change('indices', function_geosource)</span></pre><p id="2594" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于地图，使用 geosource 的<strong class="kr jb">selected . on _ change</strong>event _ handler，并在用户单击某个邻域时调用函数<strong class="kr jb"> function_geosource </strong>，向其传递该邻域的索引。基于新的索引(邻域 id/subdistr_no)，将 CDSView 重置为新的邻域，用视图中的新数据重新填充 datatable，并将 TextInput 值设置为空。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e2d7" class="lv lw ja lr b gy lx ly l lz ma"># On change of geosource (neighborhood selection by mouse-click) fill the datatable with nieghborhood sales     <br/>def function_geosource(attr, old, new):<br/>    try:<br/>        selected_index = geosource.selected.indices[0]<br/>        tap_neighborhood.value = sf.iloc[selected_index]['neighborhood_name'] <br/>        subdist = sf.iloc[selected_index]['subdist_no']<br/>        hood = tap_neighborhood.value<br/>        <br/>        view1 = CDSView(source=source, filters=[GroupFilter(column_name='subdist_no', group=subdist)])<br/>        columns = [TableColumn(field = 'full_address', title = 'Address')]<br/>  <br/>        data_table = DataTable(source = source, view = view1, columns = columns, width = 280, height = 280, editable = False)<br/>        table_address.value = ''<br/>        table_actual.value = ''<br/>        table_predicted.value = ''<br/>        table_diff.value = ''<br/>        table_percent.value = ''<br/>        table_shap.value = ''<br/><br/>        # Replace the updated datatable in the layout<br/>        layout.children[1] = column(tap_neighborhood, data_table, table_address, table_actual, table_predicted,<br/>                                    table_diff, table_percent)<br/>       <br/>    except IndexError:<br/>        pass</span></pre><p id="b2a9" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr jb">步骤 5 —布局和文件</strong></p><p id="01e8" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">散景提供了几个布局选项来安排地块和部件。布局的三个核心对象是 row()、column()和 widgetbox()。这有助于将屏幕想象成一个由行、列组成的网格。widgetbox 是小部件的容器。在应用程序中，组件在一行中排列成两列:</p><ol class=""><li id="7661" class="mc md ja kr b ks kt kv kw ky me lc mf lg mg lk mh mi mj mk bi translated">第一列-包含绘图 p(地图)和文本输入微件 table _ shap(Shapley 值)。</li><li id="80f7" class="mc md ja kr b ks ml kv mm ky mn lc mo lg mp lk mh mi mj mk bi translated">第二列—包含数据表 tap_neighborhood 和其余的 TextInput 小部件。</li></ol><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f1c8" class="lv lw ja lr b gy lx ly l lz ma"># Layout the components with the plot in row postion (0) and the other components in a column in row position (1)<br/>layout = row(column(p, table_shap), column(tap_neighborhood, data_table, table_address,<br/>              table_actual, table_predicted, table_diff, table_percent))<br/><br/># Add the layout to the current document<br/>curdoc().add_root(layout)</span></pre><p id="5d48" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后，该布局被添加到文档中进行显示。</p><p id="c288" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我欢迎建设性的批评和反馈，请随时给我发私信。</p><p id="f9f0" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在推特上关注我</p><p id="c7e6" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这篇文章最初出现在我的<a class="ae ll" href="https://jimking100.github.io/2019-10-22-Post-5/" rel="noopener ugc nofollow" target="_blank"> GitHub 页面</a>网站上</p><p id="85c8" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="na">这是探索三藩市房地产数据系列文章的一部分</em></p><p id="56b9" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="na">旧金山房地产数据来源:旧金山 MLS，2009–2018 年数据</em></p></div></div>    
</body>
</html>