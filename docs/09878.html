<html>
<head>
<title>gRPC in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/grpc-in-golang-bb40396eb8b1?source=collection_archive---------2-----------------------#2019-12-27">https://towardsdatascience.com/grpc-in-golang-bb40396eb8b1?source=collection_archive---------2-----------------------#2019-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c04a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 gRPC 构建一个简单的 API 服务</h2></div><p id="ad7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在很长一段时间里，REST API 一直统治着 web 编程世界，直到 gRPC 的到来，颠覆了这个行业。网上有很多帖子讨论 gRPC 的优势，并将其与 REST 进行比较，因此我不打算在这一点上做多余的评论。我的理解是 gRPC 继承了 REST 的功能，并用更快、更轻、更灵活的服务对其进行了扩展。在这篇文章中，让我们看一下 gRPC 并使用 Golang 实现一个简单的服务。</p><h1 id="1c1a" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">先决条件</h1><ul class=""><li id="f24b" class="lw lx it kk b kl ly ko lz kr ma kv mb kz mc ld md me mf mg bi translated">安装 Go:<a class="ae mh" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">https://golang.org/doc/install</a></li><li id="814a" class="lw lx it kk b kl mi ko mj kr mk kv ml kz mm ld md me mf mg bi translated">安装<code class="fe mn mo mp mq b">protoc</code> : gRPC 使用<code class="fe mn mo mp mq b">protobuf</code>进行通信，为了生成相关文件，需要安装<code class="fe mn mo mp mq b">protoc</code>:</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ba02" class="mz lf it mq b gy na nb l nc nd">brew install protobuf // For MacOS</span></pre><ul class=""><li id="b2d1" class="lw lx it kk b kl km ko kp kr ne kv nf kz ng ld md me mf mg bi translated">安装<code class="fe mn mo mp mq b">protoc-gen-go</code>:因为我们在这篇文章中使用<code class="fe mn mo mp mq b">go</code>，你将需要<code class="fe mn mo mp mq b">protobuf</code>的 go-support</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="2146" class="mz lf it mq b gy na nb l nc nd">go get -u github.com/golang/protobuf/protoc-gen-go</span></pre><ul class=""><li id="c49f" class="lw lx it kk b kl km ko kp kr ne kv nf kz ng ld md me mf mg bi translated">安装<code class="fe mn mo mp mq b">grpc</code>:go 的 grpc 包</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="a360" class="mz lf it mq b gy na nb l nc nd">go get -u google.golang.org/grpc</span></pre><p id="2fe2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(注意:确保您的<code class="fe mn mo mp mq b">GOPATH</code>设置正确，这样您的包和项目将位于<code class="fe mn mo mp mq b">GOPATH/src</code>下)</p><h1 id="5b9e" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">gRPC 概述</h1><p id="4910" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">与传统的 REST API 相比，在传统的 REST API 中，客户端通过指定一系列约束条件与服务器进行通信，如发送到特定的 url — <code class="fe mn mo mp mq b">localhost/api/v1/hello</code>、<code class="fe mn mo mp mq b">localhost/api/v1/doSomething</code>并指定哪种操作，如 PUT、POST、GET……<em class="nk">我认为 gRPC 在某种程度上抽象了这个概念，并通过简单地调用函数来定义通信，这些函数中的消息以</em> <code class="fe mn mo mp mq b"><em class="nk">protobuf</em></code> <em class="nk">格式定义。</em></p><figure class="mr ms mt mu gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nl"><img src="../Images/4db2c08760970184265d8b656a9dd196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5z3vKFFW4vY5zuFuhBjFw.png"/></div></div></figure><p id="585a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 gRPC，客户机可以直接调用服务器中的函数，正如您稍后将看到的，它们实际上共享同一个 protobuf 文件。上图的一个巨大优势是，用不同语言编写的服务器和客户端可以很容易地相互通信，因为它们共享一个 protobuf 文件。</p><p id="8d8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果到目前为止您对 gRPC 和 protobuf 有点困惑，让我们继续并实现一个服务，看看 protobuf 如何在通信中发挥作用。在这篇文章中，我们将实现一个简单的一元服务，即发送一个问候请求并接收一个响应。<em class="nk">客户端会发送一个对其名称的请求，服务器会返回一串</em> <code class="fe mn mo mp mq b"><em class="nk">Hello + client_name</em></code> <em class="nk">。</em></p><h1 id="4ce8" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">原蟾蜍</h1><p id="f39a" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">在 protobuf 中，它定义了可用的服务和消息。打开具有结构的项目:</p><figure class="mr ms mt mu gt nm gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/60769729d7917ffac0ad8c70faf2035c.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*yBAVNbtJzdRqcJRnnDhT7w.png"/></div></figure><p id="82b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且在<code class="fe mn mo mp mq b">hello.proto</code>里面写着:</p><figure class="mr ms mt mu gt nm"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ebc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe mn mo mp mq b">service</code>关键字定义了一个服务，<code class="fe mn mo mp mq b">rpc</code>定义了服务的功能。在这个例子中，我们的<code class="fe mn mo mp mq b">helloService</code>提供了一个<code class="fe mn mo mp mq b">Hello</code>函数，它需要输入<code class="fe mn mo mp mq b">helloRequest</code>消息并输出一个<code class="fe mn mo mp mq b">helloResponse</code>消息。如果你熟悉任何一门编程语言，我们大致可以打个比方:<code class="fe mn mo mp mq b">service =&gt; class</code>、<code class="fe mn mo mp mq b">rpc =&gt; function</code>和<code class="fe mn mo mp mq b">message =&gt; global variables</code>。</p><p id="2e17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">转到您的终端并运行:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="e57d" class="mz lf it mq b gy na nb l nc nd">protoc --go_out=plugins=grpc:. YOUR_ROOT_FOLDER/hellopb/hello.proto</span></pre><p id="c46f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mn mo mp mq b">--go_out</code>选项指定了生成文件的输出目录，也告诉我们需要使用 grpc 插件。第二部分是目标文件。</p><p id="3bc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果给你一个<code class="fe mn mo mp mq b">hello.pb.go</code>文件。如果你查看文件，你会发现 gRPC 的神奇之处在于，所有这些信息都是用 go 特定语言表示的，而<em class="nk">如果你使用其他语言，同样的 protobuf 会用其他特定语言表示，这也是 protobuf 可以跨语言交流的原因。</em></p><h1 id="8adb" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">计算机网络服务器</h1><p id="cc18" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">服务器接收来自客户端的请求并相应地做出响应。</p><figure class="mr ms mt mu gt nm"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1546" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mn mo mp mq b">main</code>函数中，我们注册了一个服务器，让它监听地址<code class="fe mn mo mp mq b">0.0.0.0:50051</code>，它是本地主机，端口<code class="fe mn mo mp mq b">50051</code>是 gRPC 连接的端口。</p><p id="edf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe mn mo mp mq b">RegisterHelloServiceServer</code>是从我们刚刚编写的 protobuf 文件自动生成的。<em class="nk">如果你仔细研究这个函数，你会发现第二个参数需要一个 struct 类型来实现服务接口——做“实际工作”:</em></p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ace0" class="mz lf it mq b gy na nb l nc nd">// HelloServiceServer is the server API for HelloService service.<br/>type HelloServiceServer interface {<br/>   Hello(context.Context, *HelloRequest) (*HelloResponse, error)<br/>}</span></pre><p id="f790" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码是在<code class="fe mn mo mp mq b">hello.pb.go</code>中生成的。为了实现服务器，struct 类型需要在接口内部实现函数<code class="fe mn mo mp mq b">Hello</code>。</p><p id="441d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在实现中，它从请求中接受名称并返回一个字符串<code class="fe mn mo mp mq b">Hello + name</code>。</p><h1 id="2823" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">客户</h1><p id="c6d2" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">客户端发送请求并接收响应。</p><figure class="mr ms mt mu gt nm"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1a38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码很简单，我们创建一个客户端<code class="fe mn mo mp mq b">hellopb.NewHelloServiceClient</code>拨号到端口<code class="fe mn mo mp mq b">50051</code>并通过函数<code class="fe mn mo mp mq b">client.Hello</code>发送请求。注意，所有这些函数都在自动生成的文件中提供。</p><p id="3d43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，请再次理解文档中所说的内容:</p><blockquote class="nw"><p id="25b2" class="nx ny it bd nz oa ob oc od oe of ld dk translated">在 gRPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序的方法，就像它是一个本地对象一样，这使得您可以更容易地创建分布式应用程序和服务。</p></blockquote><p id="b785" class="pw-post-body-paragraph ki kj it kk b kl og ju kn ko oh jx kq kr oi kt ku kv oj kx ky kz ok lb lc ld im bi translated"><code class="fe mn mo mp mq b">client.Hello</code>正是上面所描述的，因为客户端可以直接调用服务器端的函数。</p><h1 id="1287" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">运行应用程序</h1><p id="c6e0" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">服务器和客户端都准备好了，让我们先运行服务器，然后运行客户端，您将得到结果:</p><figure class="mr ms mt mu gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ol"><img src="../Images/38edc2108c17cd0ca84b256006bbaa9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lguhzW6kwxeg537XcD5nQ.png"/></div></div></figure><p id="7151" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是 gRPC 在 golang 中最简单的用法，当然，还有很多其他应用，特别是 gRPC 支持流调用，允许客户端和服务器以流格式相互通信。我希望这只是一个起点，还有更多值得探索。</p><p id="85df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考</strong>:</p><ol class=""><li id="70fe" class="lw lx it kk b kl km ko kp kr ne kv nf kz ng ld om me mf mg bi translated"><a class="ae mh" href="https://grpc.io/docs/guides/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/docs/guides/</a></li><li id="55a2" class="lw lx it kk b kl mi ko mj kr mk kv ml kz mm ld om me mf mg bi translated"><a class="ae mh" href="https://github.com/golang/protobuf" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/protobuf</a></li><li id="e8a8" class="lw lx it kk b kl mi ko mj kr mk kv ml kz mm ld om me mf mg bi translated"><a class="ae mh" href="https://github.com/grpc/grpc-go" rel="noopener ugc nofollow" target="_blank">https://github.com/grpc/grpc-go</a></li><li id="e3ce" class="lw lx it kk b kl mi ko mj kr mk kv ml kz mm ld om me mf mg bi translated"><a class="ae mh" href="https://code.tutsplus.com/tutorials/rest-vs-grpc-battle-of-the-apis--cms-30711" rel="noopener ugc nofollow" target="_blank">https://code . tuts plus . com/tutorials/rest-vs-grpc-battle-of-the-API-CMS-30711</a></li></ol></div></div>    
</body>
</html>