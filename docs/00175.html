<html>
<head>
<title>InfluxDB Data Retention</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">InfluxDB 数据保留</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/influxdb-data-retention-f026496d708f?source=collection_archive---------7-----------------------#2019-01-08">https://towardsdatascience.com/influxdb-data-retention-f026496d708f?source=collection_archive---------7-----------------------#2019-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="107e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运营团队经常使用时间序列数据来调查性能问题。因为我们无法提前预测性能问题的来源，所以我们经常犯谨慎的错误，尽可能频繁地收集尽可能多的数据。这使得获取环境中最近一小时、一天或一周内发生的事情的详细信息变得非常容易。但是，随着主机数量和数据量的增加，保留超过一两周的数据会变得很困难。</p><p id="83d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多原因可以解释为什么有必要将数据保留更长的时间。在下列情况下，参考几周、几个月甚至几年前的数据通常很有用:</p><ul class=""><li id="2d26" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">容量规划—通过查看过去 12 至 24 个月的资源利用率，您可以预测未来的使用情况，以便预测下一财年的预算需求。</li><li id="4b4d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">性能下降—用户经常报告说，应用程序性能“似乎比几周或几个月前慢了”。手边有历史数据，就有可能量化任务需要多长时间，或者负载增加和性能降低之间是否存在关联。</li></ul><p id="0df1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在处理时间序列数据时，不可避免地会遇到无法无限期完整保留所有数据的情况。必须在数据保留时间、数据保留量和数据粒度之间进行权衡。本文介绍了如何在<a class="ae kz" href="https://www.influxdata.com/" rel="noopener ugc nofollow" target="_blank"> InfluxDB </a>中实现数据保留策略，以确保您可以对数据进行降采样，将其保留一段指定的时间，并执行定期备份以避免数据丢失。</p><p id="af11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于本例的目的，我们将关注运行在 3 台主机上的<a class="ae kz" href="https://collectd.org/" rel="noopener ugc nofollow" target="_blank"> <em class="la">收集的</em> </a>系统守护进程收集的 CPU 利用率指标。在这个场景中，<em class="la"> collectd </em>以 10 秒的间隔从每个被监控的主机提交 CPU 数据(“load_shortterm”)。使用<em class="la"> collectd </em>守护程序将数据直接发送到 InfluxDB，并存储在“指标”数据库中，该数据库使用 7 天保留策略进行定义。目标是将这些数据保留在“长期”数据库中，保留策略为 3 年。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/9f4f9d883c1256d435cf84f45d046e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*p8L1Fw9jw-jaLsFhGxtuaQ.png"/></div></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h2 id="fe9c" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">InfluxDB 配置</h2><p id="b649" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">默认情况下，InfluxDB 不监听<em class="la"> collectd </em>输入。为了允许由<em class="la"> collectd </em>代理提交数据，必须将 InfluxDB 服务器配置为侦听<em class="la"> collectd </em>连接。本节介绍如何在 RHEL/CentOS 系统上配置<em class="la"> collectd </em>。</p><p id="2095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是在 InfluxDB 服务器上创建一个数据库，将传入的<em class="la"> collectd </em>数据存储 7 天。为此，在 InfluxDB 服务器上打开一个终端窗口，并使用<code class="fe mo mp mq mr b">influx</code>命令连接到服务器。运行以下命令创建新数据库:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="7f6b" class="lq lr iq mr b gy mw mx l my mz">CREATE DATABASE metrics WITH DURATION 7d</span></pre><p id="8708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是在 InfluxDB 服务器上安装<em class="la"> collectd </em>，以便 InfluxDB 可以使用<a class="ae kz" href="https://collectd.org/documentation/manpages/types.db.5.shtml" rel="noopener ugc nofollow" target="_blank"> types.db </a>规范文件:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="1fa8" class="lq lr iq mr b gy mw mx l my mz"># Install the collectd RPM (available from the EPEL repo)<br/>yum install collectd</span><span id="a57d" class="lq lr iq mr b gy na mx l my mz"># Locate the types.db file installed by the RPM<br/>rpm -ql collectd | grep types.db</span></pre><p id="e15b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新 InfluxDB 配置文件(<code class="fe mo mp mq mr b">/etc/influxdb/influxdb.conf</code>)监听<em class="la">收集的</em>数据，然后重新启动<em class="la"> influxd </em>服务:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="aeba" class="lq lr iq mr b gy mw mx l my mz">[[collectd]]<br/>  enabled = true<br/>  bind-address = ":8096"<br/>  database = "metrics"<br/>  typesdb = "/usr/share/collectd/types.db"</span></pre><p id="193d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦 InfluxDB 正在监听<em class="la"> collectd </em>输入，您将需要在 3 台主机上安装 collectd 代理，并将其配置为向您的 InfluxDB 服务器发送数据。</p><h2 id="f16f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">数据识别</h2><p id="dcde" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">如果您不熟悉 InfluxDB 数据模型，弄清楚如何定位数据可能是第一个挑战。被收集的每种类型的数据被称为“测量”,并且每个测量可以具有任意数量的与之相关联的“标签”。对于由 collectd 代理报告的数据，您配置代理报告的每种数据类型都有一个度量。</p><p id="9bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可在<code class="fe mo mp mq mr b">influx</code>命令窗口中执行以下命令，以查询数据库并识别将在后续步骤中用于定义连续查询的测量值。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="fd77" class="lq lr iq mr b gy mw mx l my mz"># Switch to the InfluxDB database containing the CollectD data<br/>USE metrics</span><span id="86bb" class="lq lr iq mr b gy na mx l my mz"># Display a list of metrics in the database<br/>SHOW MEASUREMENTS</span><span id="5c93" class="lq lr iq mr b gy na mx l my mz"># Display the tags (keys) used to uniquely identify CPU load<br/>SHOW SERIES FROM load_shortterm</span></pre><p id="51fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq mr b">SHOW SERIES</code>命令应该产生类似如下的输出:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="9440" class="lq lr iq mr b gy mw mx l my mz">load_shortterm,host=host1,type=load<br/>load_shortterm,host=host2,type=load<br/>load_shortterm,host=host3,type=load</span></pre><h2 id="f13d" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">数据保留政策</h2><p id="8375" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在 InfluxDB 中，有许多选项可用于定义长期保留策略。一种选择是在现有的<code class="fe mo mp mq mr b">metrics</code>数据库中创建新的保留策略，并将长期数据与短期数据一起存储:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="9c4d" class="lq lr iq mr b gy mw mx l my mz">CREATE RETENTION POLICY longterm_policy ON metrics DURATION 156w REPLICATION 1</span></pre><p id="c865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我会避免在单个数据库中创建多个保留策略，除非您有特别的理由这样做。如果单个数据库中有多个保留策略，那么在对数据进行操作时，您的查询将需要显式引用保留策略(<code class="fe mo mp mq mr b">database.policy.measurement</code>)。由于明确引用了保留策略，这将使您的查询更加脆弱。</p><p id="de09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，<code class="fe mo mp mq mr b">metrics</code>数据库中的输入数据是大量的瞬时数据。备份整个数据库的成本非常高，丢失一周的非常精细的数据所带来的影响也不值得。</p><p id="702e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的方法是专门为您希望保留的任何长期数据定义一个单独的数据库。这样做将便于以后更改保留策略或备份整个数据库，而不会影响任何外部报告或查询。以下示例显示了如何创建保留策略为 3 年(156 周)的数据库:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="ca1e" class="lq lr iq mr b gy mw mx l my mz">CREATE DATABASE longterm WITH DURATION 156w</span></pre><h2 id="7c34" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">数据聚合</h2><p id="b47c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">创建一个连续查询，将数据从 10 秒的间隔向下采样到 15 分钟的间隔:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="a3a2" class="lq lr iq mr b gy mw mx l my mz">CREATE CONTINUOUS QUERY aggregate_load ON longterm<br/>BEGIN<br/>  SELECT max(value) AS value <br/>  INTO longterm.autogen.load_shortterm <br/>  FROM metrics.autogen.load_shortterm <br/>  GROUP BY time(15m),* <br/>END</span></pre><p id="a59c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="la">重要提示:</em> </strong></p><ul class=""><li id="4d73" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">您选择的聚合函数将取决于您的用例。在这种情况下使用了<code class="fe mo mp mq mr b">max</code>函数，因为我们通常关心一个时间间隔内的平均峰值负载。使用平均值计算会稀释这些尖峰信号，并使识别活动中的短尖峰信号变得更加困难。</li><li id="7183" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe mo mp mq mr b">INTO</code>和<code class="fe mo mp mq mr b">FROM</code>子句要求完全合格的度量(数据库.策略.度量)。如果您将默认保留策略定义为数据库创建的一部分，如以上示例所示，则默认情况下，保留策略将被称为“自动生成”。</li><li id="dcf6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe mo mp mq mr b">GROUP BY</code>子句包含一个<code class="fe mo mp mq mr b">*</code>通配符，意思是“所有标签”这确保了仅在所有标签都相同的数据点上执行聚合。如果没有这个通配符(或一个显式的标记列表)，将会对所有主机的所有数据执行聚合，从而导致一个无意义的聚合。在大多数情况下，应该在<code class="fe mo mp mq mr b">GROUP BY</code>中使用通配符，以确保在相同的唯一项目上执行聚合。</li><li id="60bd" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">上面显示的多行格式是为了可读性。当在<code class="fe mo mp mq mr b">influx</code>命令中执行该命令时，您需要在一行中构建该命令。</li></ul><p id="d627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您成功地创建了一个连续查询，您应该会看到在第一个时间间隔结束时出现测量值。这可以通过列出测量值来验证，方法与您之前发现它们的方法相同:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="2ce8" class="lq lr iq mr b gy mw mx l my mz">USE longterm<br/>SHOW MEASUREMENTS<br/>SHOW SERIES FROM load_shortterm</span></pre><p id="e8ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的 Grafana 图表显示了原始数据(10 秒间隔)和聚合数据(15 分钟间隔)之间的差异。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/cd3c16cd09da390182b20a2caa88d150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WskOaOAKfrvxYr2lhWl9sg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Grafana chart of metrics.load_shortterm</figcaption></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nk"><img src="../Images/411ca18c728354f69b1c22f08bff83b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlAokDc5T_FaHT8JUi8fUg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Grafana chart of longterm.load_shortterm</figcaption></figure><h2 id="f944" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">数据备份</h2><p id="1d7d" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">InfluxDB 附带了一个用于执行数据库备份的命令行实用程序。执行相当简单:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="c0d6" class="lq lr iq mr b gy mw mx l my mz">influxd backup -portable -database longterm /backup/longterm</span></pre><p id="2be3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以指定附加参数，以通过特定的保留策略、碎片或日期范围来限制导出。</p><h2 id="dc00" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">调试提示</h2><p id="1e4a" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">默认情况下，InfluxDB 服务将其日志输出写入<code class="fe mo mp mq mr b">/var/log/messages</code>。每次连续查询运行时都会生成几行输出。以下命令可用于查找连续查询执行消息:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="d4ef" class="lq lr iq mr b gy mw mx l my mz">tail -f /var/log/messages | grep "Finished continuous"</span></pre><p id="20a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">匹配线看起来会像这样:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="d494" class="lq lr iq mr b gy mw mx l my mz">Jan  7 15:00:00 influxdbhost01 influxd: <br/>   ts=2019-01-07T20:00:00.127002Z <br/>   lvl=info <br/>   msg="Finished continuous query" <br/>   log_id=0BoYFF20000 <br/>   service=continuous_querier <br/>   trace_id=0CrUFfTl000 <br/>   op_name=continuous_querier_execute <br/>   name=aggregate_load <br/>   db_instance=longterm <br/>   written=129 <br/>   start=2019-01-07T19:59:00.000000Z <br/>   end=2019-01-07T20:00:00.000000Z <br/>   duration=7ms</span></pre><p id="e31a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">日志输出包含几条重要信息:</p><ul class=""><li id="8c2b" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><em class="la">名称</em> —连续查询的名称</li><li id="9948" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><em class="la">已写入</em> —已写入的测量记录的数量</li><li id="ffe9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><em class="la">持续时间</em> —查询执行的时间</li></ul><p id="855e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，定义一个连续的查询，并安排其运行频率高于完成查询所需的时间，这不是一个好主意。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h2 id="b402" class="lq lr iq bd ls lt lu dn lv lw lx dp ly jy lz ma mb kc mc md me kg mf mg mh mi bi translated">总结</h2><p id="6ab4" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">连续查询是一种有选择地对数据进行降采样并将其保留更长时间的便捷方式。通过创建周密的保留策略和备份程序，可以将历史时间序列数据保留数月甚至数年。让这些历史数据在与实时指标相同的可视化界面中易于访问，将使应用程序所有者和运营人员能够基于历史背景和趋势做出明智的决策，而不是依赖“直觉”方法进行预算、容量规划或问题调查。</p></div></div>    
</body>
</html>