<html>
<head>
<title>Gradient Boosting Machines (GBMs)— the ELI5 way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">梯度增压机(GBM)—Eli 5 方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gradient-boosting-machines-gbms-the-eli5-way-c4a21b2e2b0a?source=collection_archive---------21-----------------------#2019-07-12">https://towardsdatascience.com/gradient-boosting-machines-gbms-the-eli5-way-c4a21b2e2b0a?source=collection_archive---------21-----------------------#2019-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1e51b33d633e6ec40f0d1937581e49f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JYGU_MEBZaJfWw4HnQtvcg.jpeg"/></div></div></figure><p id="ef45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"><em class="kz">【GBMs】</em></strong>梯度推进机器(GBMs)是机器学习中的一种集成技术，其中建立个体<em class="kz">弱学习者(弱模型)</em>的复合模型，以便组合它们的所有结果并形成<em class="kz">强学习者(强模型)</em>。这是因为给定一个映射每一个观察值的数据集<em class="kz"> (xi，易)</em>，我们和算法总是更容易将整体函数<strong class="kd iu"><em class="kz">【F(x)</em></strong>分解成<strong class="kd iu"><em class="kz"/></strong>个简单的<em class="kz">子模块(子函数)</em>，而不是必须一次猜测整个表达式。由于这种<em class="kz">分而治之</em>的方法，该算法在逼近强模型方面变得非常好，从而减少了预测过程中出现的错误。</p><p id="ca4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，Boosting 模型旨在提高前一个函数的精度分数，可以递归表示为:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="10ba" class="lj lk it lf b gy ll lm l ln lo">Fm(x) = Fm-1(x) + fm(x)</span><span id="8b48" class="lj lk it lf b gy lp lm l ln lo">where,</span><span id="4a83" class="lj lk it lf b gy lp lm l ln lo">1. Fm(x) = overall composite function of "m" simpler models<br/>2. fm(x) = m-th sub-module for Fm(x)<br/>3. Fm-1(x) = overall compositve function without fm(x)</span></pre><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lq"><img src="../Images/2de24760b62a0f8a76c7bce64948c487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuUPKLYT8zKaW38dsognNg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">The overall function y = 30 + x + sin(x) has been broken down into its sub-modules to illustrate how its simpler constituents can individually make an overall difference</figcaption></figure><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="482f" class="lj lk it lf b gy ll lm l ln lo"><em class="kz">Example:</em></span><span id="cc17" class="lj lk it lf b gy lp lm l ln lo"><strong class="lf iu">F(x)  =</strong> 30 + x + sin(x)</span><span id="ee91" class="lj lk it lf b gy lp lm l ln lo"><strong class="lf iu">f1(x) =</strong> 30<br/><strong class="lf iu">f2(x) =</strong> x<br/><strong class="lf iu">f3(x) =</strong> sin(x)</span><span id="08e5" class="lj lk it lf b gy lp lm l ln lo"><strong class="lf iu">F(x)  =</strong> f1(x) + f2(x) + f3(x)</span></pre><p id="7fdf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们可以说，我们正在训练 M = 3 个弱学习者来近似整体函数<strong class="kd iu"><em class="kz"/></strong>为<strong class="kd iu"><em class="kz">f1(x)+F2(x)+F3(x)</em></strong><em class="kz">。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/e6c548195c1359d834e9202dc4c30e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJ68GhNaq_iQ0IzbsE5Ggg.png"/></div></div></figure><p id="2e6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们训练我们的复合学习器，使得每一次迭代的输出值都向真实值的方向推进。在上图中，我们看到一名高尔夫球手试图通过不同强度和方向的努力将球击入洞中。梯度增强以类似的方式工作。</p><h1 id="4f63" class="lw lk it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">梯度推进决策树</h1><p id="1140" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">梯度增强决策树(GBDT)是按顺序建模的——每次构建一棵树，其中每个新树负责纠正先前添加的树所产生的错误。尽管与训练随机森林相比，这个训练过程需要更长的时间，但是我们发现 GBDTs 是更好的学习者，即，我们用更少数量的树获得更好的准确度分数。此外，boosting 还可以处理不平衡的数据集。</p><p id="f4f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">培训 GBDTs 时需要执行 3 个步骤—</p><ol class=""><li id="fba4" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">损失/目标函数被优化</li><li id="cca6" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">弱学习者做预测</li><li id="7760" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">加法模型将弱学习者堆积起来，以最小化成本函数。</li></ol><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="29ba" class="lj lk it lf b gy ll lm l ln lo">Cost Function = average(outputs of Loss Function)</span></pre><h1 id="2e37" class="lw lk it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">培训 GBDTs 时需要考虑的事项</h1><p id="cba8" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">梯度推进是一种贪婪的算法，容易过度拟合。我们可以考虑一些参数来优化我们的模型—</p><ol class=""><li id="26b5" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">增加树的数量，直到没有观察到改进，以确保我们的模型是可推广的。</li><li id="c661" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">较浅的树(4 - 8 层)是首选，以使模型不那么复杂。</li><li id="62de" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">学习率可以保持在[0.1，0.3]的范围内，甚至小于 0.1。这是因为收缩减少了每棵树对整体模型未来改进的影响。</li><li id="5424" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">也可以通过对权重执行 L1 和 L2 正则化来避免过拟合。一个规则化的目标将倾向于选择一个使用简单和预测函数的模型。</li></ol></div></div>    
</body>
</html>