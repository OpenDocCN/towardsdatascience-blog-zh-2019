<html>
<head>
<title>Tennis Prize Money Data Harvesting Using Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Selenium 收集网球奖金数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tennis-prize-money-data-harvesting-using-selenium-c38b79323d47?source=collection_archive---------26-----------------------#2019-07-30">https://towardsdatascience.com/tennis-prize-money-data-harvesting-using-selenium-c38b79323d47?source=collection_archive---------26-----------------------#2019-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5298" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">利用<strong class="ak">模式的</strong>进行多页面网页抓取，并在硒中等待</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e33c8d5d0380d2f4f7a8a35ff0d10d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iRGxlxmKLizbDpmtA7shA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><strong class="bd ky">Lucas Davies via Unsplash</strong></figcaption></figure><h1 id="9eef" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9e1c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这篇教程将详细介绍如何利用模式来迭代目前参加 ATP 巡回赛的前 200 名男子网球选手。</p><p id="5caf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">具体来说，对于每个球员，我想提取他们各自的姓名、年龄和截至 2019 年 7 月 29 日的奖金。web 抓取将使用 Selenium 模块执行，并将利用该模块中的一些有用的类，这将确保代码更有效地运行。</p><p id="26a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个例子中，玩家姓名和年龄在同一网页上，但是他们各自的奖金收入在单独的页面上，对于每个玩家是唯一的。</p><p id="bcde" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过使用 Selenium 模块，可以获得这些信息。</p><h1 id="2474" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门和模式搜索</h1><p id="098b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我从 Selenium 模块导入 webdriver。然后，我创建一个 web 驱动对象，并将其分配给变量 browser。接下来，我只需导航到 ATP 巡回赛网页，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="907b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在已经加载了适当的网页，我可以清楚地看到前 100 名男单选手的列表(下图中的<em class="mu">，只显示了前 11 名，但向下滚动到底部会显示前 100 名选手</em>)。</p><p id="1da7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了遍历前 100 个玩家，我需要在数据组织中找到一些一致性。具体来说，当我右键单击、选择 inspect 并将鼠标悬停在玩家名称上时，我可以复制 Xpath。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/e4bbc2b41c653b81a096f8bd961ff7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9PQyEbYVgxWRdNs8aSPxw.png"/></div></div></figure><p id="62e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我将这个 Xpath 粘贴到 Chrome 开发者工具的控制台标签中。当我第一次复制并粘贴诺瓦克·德约科维奇的 Xpath 时，我可以看到球员对应于表行 1，tr[1]和表数据 4，td[4]。通过检查其他玩家，例如下面突出显示的 Fabio Fogini，我可以看到 Xpath 中唯一改变的部分是表的行号 tr[9]。</p><p id="92b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是有意义的，因为数据被组织成表格格式，因此具有我可以利用的一致性。为了利用这个特性，我可以简单地替换 Xpath 的<strong class="lt iu"> tr </strong>部分中的数字，并使用从 1(含)到 101(不含)的<strong class="lt iu">范围</strong>遍历所有玩家的名字！</p><p id="7edc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我利用相同的关系提取玩家的年龄，但是在这种情况下，表中的数据<strong class="lt iu"> td </strong>在第 5 列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/9fb19a5552807be9c1d62b2594efa9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hP4-3cZChbXCA6OcL_NIw.png"/></div></div></figure><h1 id="8a79" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">代码工作流</h1><p id="7b3f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望我的代码如下工作:</p><ol class=""><li id="856b" class="mx my it lt b lu mn lx mo ma mz me na mi nb mm nc nd ne nf bi translated">转到<a class="ae ng" href="https://www.atptour.com/en/rankings/singles" rel="noopener ugc nofollow" target="_blank">主排名页面</a>，从排名最高的玩家开始查找个人玩家姓名和年龄，并提取此信息。</li><li id="0b8f" class="mx my it lt b lu nh lx ni ma nj me nk mi nl mm nc nd ne nf bi translated">点击每位玩家的链接，从排名最高的玩家开始，提取他们今年到目前为止的奖金(截至 2019 年 7 月 29 日)。</li><li id="7afa" class="mx my it lt b lu nh lx ni ma nj me nk mi nl mm nc nd ne nf bi translated">导航回主排名页面，对前 100 名玩家重复步骤 1 和 2。</li><li id="08a2" class="mx my it lt b lu nh lx ni ma nj me nk mi nl mm nc nd ne nf bi translated">获得前 100 名玩家的数据后，点击进入下一页，玩家排名在 100-200 之间，重复步骤 1 和 2。</li><li id="d493" class="mx my it lt b lu nh lx ni ma nj me nk mi nl mm nc nd ne nf bi translated">一旦获得了这些信息，就停止迭代并将输出写入 Excel，以便进行下游数据操作和验证。</li></ol><h1 id="2be9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Webdriver 等待和预期条件一起工作</h1><p id="49d3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当浏览器加载页面时，该页面中的元素可能会在不同的时间间隔加载。这使得定位元素变得困难:如果元素还没有出现在 DOM 中，定位函数将引发 ElementNotVisibleException 异常。使用等待，我们可以解决这个问题。</p><p id="adac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">显式等待使 WebDriver 在继续执行之前等待某个条件发生。</p><p id="9038" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了使代码更加健壮，我将指示代码在对 web 元素执行任何操作之前等待，直到找到或可以点击 web 元素。下面是两种重要的硒，来源于:<a class="ae ng" href="https://seleniumhq.github.io/selenium/docs/api/py/api.html" rel="noopener ugc nofollow" target="_blank">https://seleniumhq.github.io/selenium/docs/api/py/api.html</a>。</p><p id="04a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">WebDriverWait 和 expected_conditions 可以一起使用。在下面列出的预期条件示例中，我将等待定位 an 元素的可见性。</p><p id="329b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> <em class="mu">类 selenium . web driver . support . wait . web driver wait(driver，timeout，poll_frequency=0.5，ignored _ exceptions = None)</em></strong></p><p id="101b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> <em class="mu">类 selenium . web driver . support . expected _ conditions . visibility _ of _ element _ located(locator)</em></strong></p><h1 id="4b8c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">如何在预期条件下使用 Webdriver Wait？</h1><p id="8d9a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">WebDriverWait 有两个必需的参数，即驱动程序、浏览器和超时。超时指示如果找不到相应的 web 元素，在引发超时异常之前要等待多长时间。</p><p id="2ccf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们剖析一个例子。</p><p id="ec08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想提取下面有 Xpath 的玩家名字</p><p id="35fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">//*[@ id = " rankingDetailAjaxContainer "]/table/tbody/tr[1]/TD[4]/a '</p><p id="e3ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我写了 WebdriverWait，然后是我的驱动程序 browser，然后等待 20 秒。然后，我通过将<strong class="lt iu"><em class="mu">visibility _ of _ element _ located</em></strong><em class="mu">附加到</em><strong class="lt iu"><em class="mu">expected _ conditions，告诉 webdriver 等待元素可见。</em> </strong>我接着指定一个定位器<strong class="lt iu"> <em class="mu"> </em> </strong>使用<strong class="lt iu"> <em class="mu">通过。Xpath(大写)</em> </strong>，后面是引用的适当 XPATH。</p><p id="73e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">添加等待会在脚本中添加额外的检查步骤。这在 for 循环中在网页之间切换时特别有用，因为 web 元素可能需要一点时间来加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="78f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">结合这些核心思想，现在可以创建一个范围为 1 到 101 的 for 循环，以收集每页上前 100 名玩家的数据。</p><p id="e03a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当使用。文本功能，然后代码指示浏览器点击每个玩家的链接并提取他们的奖金。这里，不是通过<strong class="lt iu">提取玩家名字。短信</strong>功能，我用<strong class="lt iu">点击他们的名字。单击()方法</strong>，如下面的代码所示。由于每个玩家都在同一行，我可以使用我之前发现的模式来显示玩家统计页面的所有唯一链接。</p><p id="ba65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每个玩家的奖金可以简单地通过复制 Xpath 找到。对于每个玩家，数据是统一组织的，因此这个 Xpath 将在 for 循环的每次迭代中为每个玩家工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/5cb7244c3ba1fcdb4f1b8b6488975f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Llb0AD3bUaax2cYIQ_OZdg.png"/></div></div></figure><p id="b888" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦实现了这一点，我导航回到单打排名页面，提取排名第二的球员的姓名、年龄和收入。在 for 循环的每次迭代中，我都会将数据追加到 Tennis_player、Age 和 Prize_money_2019 的列表中。</p><p id="ff0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当第一批 100 名玩家的数据收集完毕后，我导航到下一个页面，再次检查网页上是否有这样的按钮，并且可以点击。while 循环中的条件告诉代码返回到哪个页面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ce01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当 while 循环的两次迭代完成后，我使用 pandas 将数据写入 Excel 文件，方法是创建一个 DataFrame 并将我的列表压缩在一起，并给它们指定合理的列名。</p><p id="19be" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了澄清脚本运行顺利，在每一次迭代中，我打印了玩家，以及他们的年龄和奖金。这是不必要的，但是给了我一个迭代进度的视觉检查。下面显示了该输出在控制台中的外观示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/70d6a71003012d40abc61fa082d98e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EEPrv_PnChwhqwRHdXsqg.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="64c7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">确认</h1><p id="060f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，验证代码是否按预期工作是很重要的。例如，我将检查 3 个玩家，以显示已经获得了正确的数据。首先，让我们通过查看我的 Excel 文件“Tennis_Player_Earnings”来确认诺瓦克·德约科维奇的奖金是 8，839，549 美元。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3b59c10991a8bdb388fb355ccc570888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhQwRlq2tcW-GpLfwBybSg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/8192f007c9e81a104418d7994217d32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbF0EozCX2ez5TiwiZ4LDg.png"/></div></div></figure><p id="fbe1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">成功！现在让我们再次检查与另一名球员，即劳埃德哈里斯。他的奖金应该是 275531 美元。</p><p id="e259" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在与诺瓦克争夺奖金之前，劳埃德似乎还有一段路要走！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3178b7e9d970e68bbef636f53c335a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDCFfbuE2mhjlM4F3B3a5g.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/640ea07ddf7d072d50403e7dd4b6a539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCdl_BmP7yHqVyUorMZgcQ.png"/></div></div></figure><p id="4408" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了再次确认，我应该检查第二页的玩家，即排名在 100-200 之间的玩家是否有正确的奖金。排名第 188 位的鲁本·贝蒙尔曼斯本应获得 103，754 美元的奖金。这将确认点击到下一页的工作符合预期！同样，信息是正确的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/09ade1971c13d928280e7c5a7a9f16bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBvk7QgkBdglBeEQa0aSXQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3867f2ec654a7ec09077706c74d69345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlWbLGPT--HD-7klXcm-gw.png"/></div></div></figure><p id="929e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该代码在一个单独的页面上自动遍历网球运动员和他们的奖金，通过他们名字上的链接可以访问。实时观察自动 web 迭代显示了这个过程是如何工作的。为了演示，描述了显示前 3 个玩家的迭代的视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mt l"/></div></figure><h1 id="e7dd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="4811" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个例子说明了，通过寻找模式并利用它们，以及等待 web 元素加载并填充网页，我们可以提取信息，而不会出现常见的元素位置错误。但是，需要注意的是，这些模式是使用 Xpaths 找到的。</p><p id="e25e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果该页面的组织者决定添加一列或将玩家姓名移动到另一列，脚本将会中断，因此在使用 Xpaths 时要小心，并尽可能使用 CSS 选择器。然而，如果您正在编写一个像这样的快速脚本，并将数据输出到 Excel，所示的方法应该足够了，但是不要期望它能工作 X 个月。</p></div></div>    
</body>
</html>