<html>
<head>
<title>Python And R for Data Wrangling: Compare Pandas and Tidyverse Code Side-By-Side, and Learn Speed-Up Tips.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 和 R 的数据争论:并排比较 Pandas 和 Tidyverse 代码，并学习加速技巧。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-and-r-for-data-wrangling-examples-for-both-including-speed-up-considerations-f2ec2bb53a86?source=collection_archive---------13-----------------------#2019-08-12">https://towardsdatascience.com/python-and-r-for-data-wrangling-examples-for-both-including-speed-up-considerations-f2ec2bb53a86?source=collection_archive---------13-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b9b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成为双语数据科学家。学习加速代码技巧。用可互操作的 Python 和 R cells 编写双语笔记本。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1e970c5ed72032119c799850ac8dffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDv8Dc3Z6wTD8NxLeJh3_w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">© Artur/AdobeStock</figcaption></figure><p id="f0be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">几年前，你会专门用这两种语言中的一种来编写数据分析程序:Python 或 r。这两种语言都提供了从数据探索到建模的强大功能，并且拥有非常忠实的粉丝。然而，事情已经发生了变化。如今，有一些库，如<em class="me"> reticulate </em>和<em class="me"> PypeR、</em>允许你分别将 Python 代码合并到<em class="me"> R Markdown </em>和<em class="me"> Jupyter </em>笔记本中。了解两种语言的基本功能，如数据争论，可以扩展您的编程视野，允许您与使用任一种语言的人一起工作，并创建双语笔记本，充分利用每种语言的优势。在本文中，我们将分别使用<em class="me"> pandas </em>和<em class="me"> tidyverse </em>库来讨论 Python 和 R 中的数据争论，以及加速代码的技巧。<strong class="la iu">读完这篇文章后，你会发现 Python 和 R，在许多表达式上非常相似，至少在数据争论方面是如此</strong>。所以，你只要额外付出一点努力，就能掌握两种语言的数据角力，成为“超级<strong class="la iu"> R </strong> -Pythonista”！</p><blockquote class="mf"><p id="a261" class="mg mh it bd mi mj mk ml mm mn mo lt dk translated">做一个超级——T21——巨蟒(而不仅仅是一个巨蟒！)</p></blockquote><h1 id="b232" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">双语 R 降价文件</h1><p id="7e48" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated">他的文章附有一个 R Markdown 文件，你可以在 github 上找到。 在这个文件中，数据角力操作实现了两次:在 Python 和 R 单元格中，彼此相邻。这可以通过导入<em class="me"> reticulate </em>库来实现。Python 和 R 单元目前独立工作；在我的下一篇文章中，我将展示 Python 和 R 单元之间的参数传递以及跨语言通信。</p><p id="9251" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="me"> R Markdown </em>文件也可以作为 Python 和 R 数据争论操作的两个独立的备忘单。您也可以<a class="ae md" href="https://drive.google.com/file/d/1k6ASkLWCQoDCWTvHTuLYz-Vo1eCcerAB/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">下载<em class="me"> R Markdown </em>文件的编织版本</a>。两种语言的数据争论是在相似的结构上进行的:R 数据帧和 Python 数据帧。具体实现的操作有:</p><p id="f589" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">A.<strong class="la iu">创建/读取数据帧。</strong></p><p id="7d4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">B.<strong class="la iu">总结。</strong></p><p id="8e23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">C.<strong class="la iu">使用索引、名称、逻辑条件、正则表达式选择</strong>行、列、元素。将介绍 Python 和 R 中的<em class="me"> filter() </em>函数。</p><p id="a070" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">D.<strong class="la iu">删除-添加</strong>行、列。我们将讨论 R 中的<em class="me"> mutate() </em>函数和 Python 中的<em class="me"> map </em>。</p><p id="6a16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">E.<strong class="la iu">对行/列应用函数</strong>，包括 Python 中的 l <em class="me"> ambda </em>函数。</p><p id="8a65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">F.<strong class="la iu">加速代码</strong>。我们将讨论一些技术，比如并行化和用于代码加速的函数编译。</p><h2 id="cdd6" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">数据争论操作</h2><p id="9f58" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">在</span>前面提到的<em class="me"> R Markdown 文件</em>中，Python 代码被括在下面的括号中，这些括号定义了一个 Python 单元格:</p><p id="5ea0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">` ` `{python}</p><p id="98ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">```</p><p id="a3f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然 R 代码包含在这些括号中:</p><p id="58d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">` ` `{r}</p><p id="2cf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">```</p><p id="9a79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些括号由<em class="me"> RStudio </em>自动生成，点击<em class="me">插入</em>选项卡并选择您想要的语言。</p><p id="22e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">编程提示</strong>:在执行<em class="me"> R Markdown </em>中的任何 Python 单元之前，执行导入<em class="me"> reticulate </em>库的 shell。注意，在同一个单元格中，我们指示<em class="me"> RStudio </em>使用哪个 Python。另外，使用命令<em class="me"> py_config()在<em class="me"> RStudio </em>控制台中配置 Python 也是一个好主意。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3606" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是，在这两种语言中，有多种方式来执行操作，其中许多在前面提到的<em class="me"> R Markdown </em>文件中有所介绍。由于篇幅所限，在本文中，我们将只介绍其中的一部分。让我们开始吧:</p><h2 id="ed56" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">从 CSV 文件中读取数据帧</h2><p id="3ef0" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">正如我们在下面的要点中看到的，在两种语言中，我们都调用一个读取 csv 文件的函数。在 Python 中，这个函数是通过<em class="me"> pandas </em>库调用的。<a class="ae md" href="https://www.kaggle.com/sonumj/heart-disease-dataset-from-uci" rel="noopener ugc nofollow" target="_blank"> heart.csv </a>文件来自 Kaggle 和 UCI 库。</span></p><p id="dd02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的 Python 代码中值得注意的是使用了一个<em class="me"> lambda </em>函数(一个匿名内联函数)来排除读取<em class="me"> drop_col </em>列表中定义的列。</p><p id="b8d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">编程提示:</strong>在 R 中定义<em class="me"> read.csv() </em>函数的编码是一个好主意，如下所示，以确保正确读取所有列名。当我不使用编码时，第一列的名称被读错了。我不需要用 Python 定义编码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="68c5" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">从头开始创建数据框架</h2><p id="3a5b" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">正如下面的</span>所示，在这两种语言中，一个<em class="me">数据帧</em>可以从一个低阶结构中创建，分别用于 Python 和 R 的<em class="me">矩阵</em>和<em class="me">数组</em>。</p><p id="e676" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 R 部分中，<em class="me">存款帧</em> <em class="me">数据帧</em>包含 3 个人的银行存款(单位:千)。使用<em class="me"> rnorm() </em>函数生成银行存款，该函数生成 6 个随机数，平均值为 12，标准差为 3。</p><p id="92c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">编程技巧:</strong>正如你在下面的 R 代码中注意到的，我们导入了<em class="me"> tidyverse </em>库，这是一个包含很多包的库，比如<em class="me"> dplyr </em>。我们在 R 代码段中需要的函数只在<em class="me"> dplyr </em>库中定义。那么为什么要进口<em class="me"> tidyverse，</em>而不是我们刚需的<em class="me"> dplyr 呢？一个原因是未来的可扩展性(我们可能需要使用其他包中的函数)。</em>另一个原因是当我们导入<em class="me">库(dplyr) </em>时，得到一个警告，它的重要函数<em class="me"> filter() </em>被另一个库屏蔽了。如果我们导入<em class="me">库(tidyverse) </em>，就没有这个问题了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="cecd" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">摘要</h2><p id="150b" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di"> H </span>在这里，我们将检查两种类型的汇总:(a)汇总关于<em class="me">数据帧</em>的基本信息的函数。(b)允许对数据切片进行分组和定制洞察的功能。</p><p id="c6d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">描述数据帧一般信息的函数</strong></p><p id="66ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在以下要点中，在 R 部分，<em class="me"> head() </em>函数显示了<em class="me">数据帧</em>的前几行(观察值)。<em class="me"> glimpse() </em>函数显示观察值的数量、变量(列)以及后者的类型、名称和值。与<em class="me"> glimpse() </em>功能类似的信息由<em class="me"> str() </em>功能显示。一个更有用的函数是来自<em class="me"> prettyR </em>包的<em class="me"> describe() </em>函数，它显示每个变量的基本统计数据和有效案例数。变量统计信息也由<em class="me"> summary() </em>函数显示。与 R 类似，在 Python 部分中，<em class="me"> head() </em>函数显示第一行，而<em class="me"> describe() </em>函数显示每一列的基本统计信息，比如平均值、最小值和最大值。</p><h2 id="9ecf" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">分组和汇总组内的信息</h2><p id="4ec2" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">R 和 Python 都有基于一个变量或一组变量进行分组的函数。如以下要点所示，在 R 中，我们可以使用以 R 为基数的函数<em class="me"> tapply() </em>，分别计算男性和女性的平均胆固醇。或者，我们可以使用函数<em class="me"> group_by() </em>，后跟汇总函数，如<em class="me"> count() </em>、<em class="me"> mean() </em>或<em class="me">summary _ all()</em>。类似地，如下图所示，在 Python 中，组总结是由函数<em class="me"> groupby() </em>执行的，后面是总结函数，如<em class="me"> count()。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="12a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分组的另一个例子，在 R:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="51c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 中分组汇总的另一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e036" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">基于索引的行、列、元素选择</strong></p><p id="6a0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里需要注意的一点是，R 中的索引从 1 开始，而 Python 中的索引从 0 开始。在 Python 中，我们使用<em class="me"> iloc </em>索引器来访问整数位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="658c" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">使用名称、正则表达式、逻辑条件进行列/行选择</h2><p id="cd53" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated">这里有一些需要注意的亮点:</p><ul class=""><li id="95b3" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">在 R 中使用<em class="me"> % &gt; % </em>管道操作符，它允许你编写简洁的功能代码。</li><li id="862b" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">使用 R 中的<em class="me"> select() </em>函数选择列，使用列名、正则表达式和/或逻辑表达式。例如，在第 7、8 行中，select() 语句用于选择包含字母 m 的所有列，它们的<em class="me"> max() </em>小于 12。</li><li id="af9b" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">函数<em class="me"> filter() </em>，这是在 r 中进行选择的另一种方法。下面的函数<em class="me"> filter_all() </em>允许我们选择满足标准的所有行。</li><li id="64c4" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">Python 提供了类似的<em class="me"> filter() </em>函数供选择。axis 参数指定操作是应用于列还是行。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="816e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">行/列删除和添加</strong></p><p id="f759" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di"> B </span> elow，值得注意的有以下几点:</p><ul class=""><li id="8dc3" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">在 R 中，对列名使用减号操作符来执行列删除。我们也可以使用字符串匹配函数，比如<em class="me"> starts_with() </em>，如下图所示。其他类似的函数有<br/> <em class="me"> ends_with()，matches()，contains()。</em></li><li id="ab06" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">在 R 中，只需使用列名就可以添加列(下面的列<em class="me"> Brandon </em>)。另一种流行的方法是来自<em class="me"> dplyr </em>库中的<em class="me"> mutate() </em>函数。这里，我们使用<em class="me"> mutate() </em>添加一个列<em class="me"> sumdep </em>，其中这个新列是两个现有列的总和。请注意与 t <em class="me"> ransmute() </em>函数的区别，它只添加新列(不保留旧列)。如下图所示，使用<em class="me"> mutate() </em>的一个特别有趣的方法是将它与<em class="me"> group by </em>结合起来，在组内进行计算。</li><li id="1eca" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">在 Python 部分，值得注意的是添加了一个使用逻辑的列，该逻辑是通过<em class="me"> map() </em>函数实现的。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="d22a" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">对列/行应用函数</h2><p id="6018" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">B</span>Python 和 R 都提供了<em class="me"> apply() </em>函数，允许我们根据一个额外的参数在行或列上实现一个函数。例如下面，在 R 中，如果中间的参数是 2，则函数应用于列，而如果是 1，则应用于行。在 Python 中，<em class="me"> apply() </em>函数的决定参数是 axis (0，应用于列，1，应用于行)。下面另一个有趣的花絮是使用一个<em class="me"> lambda </em>函数将所有元素乘以 5。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="6985" class="mp mq it bd mr ms ov mu mv mw ow my mz jz ox ka nb kc oy kd nd kf oz kg nf ng bi translated">加速考虑</h1><p id="20ab" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi lu translated">在这里，我们将简要讨论三种加速 R 中代码的方法:<em class="me"> data.table </em>、并行化和函数编译。对于 Python，将呈现的加速选项是<em class="me"> modin </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/389652a06dda820acccf66261e87b35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oALU2EjhikGa3gPLdxtAtg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">©Syda Productions/AdobeStock</figcaption></figure><h2 id="765d" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">r:数据表</h2><p id="66e7" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><em class="me">数据表</em>是<em class="me">数据帧</em>【2】的扩展，其优点有两方面:</p><p id="906d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(a)对于大文件，加载数据比<em class="me">数据帧</em>快得多。下面是一个例子。我读取一个大文件(66.9MB)，使用函数<em class="me"> read.csv()，</em>返回一个<em class="me">数据帧</em>，以及<em class="me"> fread()，</em>返回一个<em class="me">数据表</em>。差异非常显著(例如，对于 data.table，用户+系统时间大约快了<strong class="la iu"> 30 倍！</strong>)。我使用的数据文件的引用是 references 部分中的[3]。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ae0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(b)简洁、紧凑的过滤表达式，其执行速度也相当快。使用<em class="me">数据表</em>进行过滤以及与<em class="me"> dplyr </em>过滤进行比较的示例如下所示。在这个要点中，我们使用库<em class="me"> dplyr </em>的<em class="me"> filter() </em>计算胆固醇&gt; 280 的男性的平均年龄。我们也用<em class="me">数据表</em>计算它，这是用<em class="me"> </em>在一行简洁的代码中完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="34a0" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">r:并行</h2><p id="2c15" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">在 R 中，并行化是使用<em class="me">并行</em>库[4]实现的，这允许我们的 R 程序利用我们计算机中的所有内核。我们可以使用函数<em class="me"> detectCores() </em>来找出我们有多少个内核，然后我们可以使用函数<em class="me"> makeCluster() </em>来创建一个包含这些内核的集群。这显示在下面的要点中。然后，我们可以使用<em class="me"> apply() </em>系列函数的并行版本来执行各种操作。例如，在下面的要点中，<em class="me"> sapply() </em>函数及其并行版本<em class="me"> parSapply() </em>用于对大量数字求平方。我们可以看到,<em class="me"> parSapply() </em>的用户+系统时间是 7.95+0.66=8.61，而 plain apply()的用户+系统时间是 11.80+0.03=11.83。</p><h2 id="8c98" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">r:函数编译</h2><p id="e49f" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">另一种提高 R 语言运算速度的方法是编译函数。这是通过<em class="me">编译器</em>库及其<em class="me"> cmpfun() </em>函数【5】实现的。下面的要点显示了这一点，以及并行化、编译在时间消耗方面的比较。我们看到，当我们结合并行化和编译时，实现了最快的用户+系统时间(7.73)。就其本身而言，只实现<em class="me">的</em>并行化比只实现<em class="me">的</em>函数编译(8.87)产生更快的用户+系统时间(8.61)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="62ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结束我们对超速 R 的讨论，值得一提的是库<em class="me">gpuR</em>【6】<em class="me">。</em>使用<em class="me"> ViennaCL </em>库，<em class="me"> gpuR </em>允许在任何 GPU 上并行计算，这与之前的 R 包在后端依赖<em class="me"> NVIDIA CUDA </em>形成对比。</p><h2 id="c792" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">Python:摩丁</h2><p id="8ff1" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如[7]中所述，modin 是一个<em class="me">数据框架</em>库，具有与<em class="me"> pandas </em>完全相同的 API，并允许显著加速工作流(在 8 核机器上快 4 倍)。要使用它，我们只需要修改一行代码。而不是:</p><p id="d417" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="me">进口熊猫作为 pd </em>我们将使用:</p><p id="dd2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="me">导入 modin.pandas 作为 pd </em></p><p id="1b76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一句忠告。modin 是建立在 Ray 之上的，所以要确保你有正确版本的 Ray。</p><p id="73de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在我的 github 库中找到一个额外的赠品是<a class="ae md" href="https://github.com/theomitsa/bilingual-R-Markdown/blob/master/arrayoperations" rel="noopener ugc nofollow" target="_blank">另一个双语 R Markdown 文件，</a>它实现了数组创建(1-D 和 2-D)和使用数组的数学函数(点积、特征值等)。)都有 Python 和 r .你也可以<a class="ae md" href="https://drive.google.com/file/d/1ID1RbER17OueZufjoKXZyO7ZzHDCYKB2/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">下载它的针织版</a>。</p><p id="0561" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><h1 id="9b22" class="mp mq it bd mr ms mt mu mv mw mx my mz jz pb ka nb kc pc kd nd kf pd kg nf ng bi translated">参考</h1><ol class=""><li id="6557" class="oa ob it la b lb nh le ni lh pe ll pf lp pg lt ph og oh oi bi translated">Pandey，p .，<strong class="la iu">从 R vs. Python，到 R 和 Python，</strong>https://towardsdatascience . com/From-R-vs-Python-to-R-and-Python-aa 25 db 33 ce 17</li><li id="83f3" class="oa ob it la b lb oj le ok lh ol ll om lp on lt ph og oh oi bi translated"><strong class="la iu">数据表简介</strong>，<a class="ae md" href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html" rel="noopener ugc nofollow" target="_blank">https://cran . r-project . org/web/packages/data . table/vignettes/datatable-intro . html</a></li><li id="0509" class="oa ob it la b lb oj le ok lh ol ll om lp on lt ph og oh oi bi translated">MITx 和 HarvardX，2014 年，“HMX PC 13 _ DI _ v2 _ 5–14–14 . CSV”，<strong class="la iu"> <em class="me"> HarvardX-MITx 个人课程 2013 学年 De-Identified 数据集，v </em> </strong> <em class="me">版本 2.0 </em>，<a class="ae md" href="https://doi.org/10.7910/DVN/26147/OCLJIV" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.7910/DVN/26147/OCLJIV</a>，哈佛数据世界，V10</li><li id="ca5d" class="oa ob it la b lb oj le ok lh ol ll om lp on lt ph og oh oi bi translated">特雷德韦、<strong class="la iu">并行运行 R 代码</strong>、<a class="ae md" href="https://www.r-bloggers.com/running-r-code-in-parallel/" rel="noopener ugc nofollow" target="_blank">https://www.r-bloggers.com/running-r-code-in-parallel/</a></li><li id="63d7" class="oa ob it la b lb oj le ok lh ol ll om lp on lt ph og oh oi bi translated">罗斯，n .<strong class="la iu">快一点！更高！更强！-忙人加速 R 码指南，</strong><a class="ae md" href="https://www.r-bloggers.com/faster-higher-stonger-a-guide-to-speeding-up-r-code-for-busy-people/" rel="noopener ugc nofollow" target="_blank">https://www . R-bloggers . com/faster-higher-stonger-A-Guide-to-Speeding-Up-R-Code-for-Busy-People/</a></li><li id="c993" class="oa ob it la b lb oj le ok lh ol ll om lp on lt ph og oh oi bi translated"><strong class="la iu">包 gpuR </strong>，<a class="ae md" href="https://cran.r-project.org/web/packages/gpuR/gpuR.pdf" rel="noopener ugc nofollow" target="_blank">https://cran.r-project.org/web/packages/gpuR/gpuR.pdf</a></li><li id="ec78" class="oa ob it la b lb oj le ok lh ol ll om lp on lt ph og oh oi bi translated">Pandey，p .，<strong class="la iu">用 Modin 获得更快的熊猫，甚至在你的笔记本电脑上</strong>，<a class="ae md" rel="noopener" target="_blank" href="/get-faster-pandas-with-modin-even-on-your-laptops-b527a2eeda74">https://towards data science . com/Get-faster-pandas-with-Modin-even-on-your-laptops-b 527 a2 eeda 74</a></li></ol></div></div>    
</body>
</html>