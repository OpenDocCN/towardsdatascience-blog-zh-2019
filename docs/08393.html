<html>
<head>
<title>Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regular-expressions-f3ee2213b085?source=collection_archive---------22-----------------------#2019-11-14">https://towardsdatascience.com/regular-expressions-f3ee2213b085?source=collection_archive---------22-----------------------#2019-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/141ae36622e21513d6379674becd2af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*T00mWOJB7y_wey6h6-jZRw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Stanley Cole Kleene, 1978. Photograph by Konrad Jacobs, Erlangen. Copyright: MFO, <a class="ae jy" href="https://opc.mfo.de/detail?photo_id=2122" rel="noopener ugc nofollow" target="_blank">https://opc.mfo.de/detail?</a></figcaption></figure><p id="26ed" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在计算机科学、数理逻辑和语言学中，正则表达式指的是提取和处理文本模式的技术集合。正则表达式有时被称为<em class="kx">正则表达式</em>，它是一组精确的字符，用来对目标文本中的字符组模式进行操作。例如，用户输入到微软 Word 中熟悉的<code class="fe ky kz la lb b">find</code>和<code class="fe ky kz la lb b">find and replace</code>功能中的文本作为正则表达式；查询的文本序列的每个文档实例被定位、突出显示、计数，然后被单独或成批处理。</p><p id="0fd2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在计算中，复杂的正则表达式技术提供了比那些在<code class="fe ky kz la lb b">find</code>中使用的更复杂的功能。事实上，模式匹配正则表达式的理论是由美国数学家斯坦利·科尔·克莱尼——阿隆佐·邱奇的学生——在 20 世纪 50 年代初首次系统化的，这比现代编程的出现早了几十年。然而，20 世纪 70 年代 Unix 和 Unix 邻近操作系统的发展使得正则表达式无处不在。实现正则表达式的两个主要语法标准之一在当代编程语言中仍然存在:继承自 POSIX 的标准和继承自 Perl 的标准。</p><p id="fa35" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">Perl 是 Python 内置<code class="fe ky kz la lb b">re</code>模块的祖先。使用<code class="fe ky kz la lb b">re</code>，Python 程序员可以编写以各种方式作用于字符串的字符串，而不是简单地将输入字符串中的单个字符与文本中的其他字符串进行元素匹配。其中，正则表达式搜索中最常用的技术之一叫做<em class="kx">通配符</em>。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="2de7" class="lk ll iq lb b gy lm ln l lo lp">&gt;import re<br/>&gt;<br/>&gt;string = 'This is a wildcard.'<br/>&gt;x = re.findall('wil.*', string)<br/>&gt;<br/>&gt;print(x)</span><span id="a401" class="lk ll iq lb b gy lq ln l lo lp">['wildcard.']</span></pre><p id="2659" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">通配符——有时称为占位符——在上面的代码中由字符对<code class="fe ky kz la lb b">.*</code>表示。这个<code class="fe ky kz la lb b">.*</code>指示解释器在目标文本中搜索它左边的任何字符，然后它右边的任何字符可以跟随它。在本例中，通配符的功能类似于 Bash 中文件搜索时的 tab 补全，它允许用户只键入文件的前几个字母，然后让 autocomplete 处理其余部分。在 SQL 中，通配符只是星号<code class="fe ky kz la lb b">*</code>，前面没有<code class="fe ky kz la lb b">.</code>。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="261b" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'This is a wildcard.'<br/>&gt;x = re.findall('wil.', string)<br/>&gt;<br/>&gt;print(x)</span><span id="e180" class="lk ll iq lb b gy lq ln l lo lp">['wild']</span></pre><p id="2fef" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果我们删除<code class="fe ky kz la lb b">*</code>但保留<code class="fe ky kz la lb b">.</code>，单个通配符将表示在该位置允许任何一个字符。换句话说，<code class="fe ky kz la lb b">.</code>将告诉解释器在目标文本中搜索它左边的字符序列，并打印它和紧随其后的下一个字符。正则表达式理论中的单个字符被称为<em class="kx">原子</em>。添加更多的<code class="fe ky kz la lb b">.</code>原子字符将打印序列后面更多的字母。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="14ec" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'This is a wildcard.'<br/>&gt;x = re.findall('wil...', string)<br/>&gt;<br/>&gt;print(x)</span><span id="139b" class="lk ll iq lb b gy lq ln l lo lp">['wildca']</span></pre><p id="2682" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们也可以在表达式中间使用通配符。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="d2a6" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'This is a wildcard.'<br/>&gt;x = re.findall('wil....d', string)<br/>&gt;<br/>&gt;print(x)</span><span id="8e92" class="lk ll iq lb b gy lq ln l lo lp">['wildcard']</span></pre><p id="28b8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">通配符在正则表达式理论中被称为<em class="kx">元字符</em>，在<code class="fe ky kz la lb b">re</code>中有很多这样的元字符。另一个特别有用的元字符允许我们搜索目标文本<em class="kx">是否以正则表达式的</em>开头。这个正则表达式用<code class="fe ky kz la lb b">^</code>表示。其他元字符包括以<code class="fe ky kz la lb b">$</code>、非此即彼<code class="fe ky kz la lb b">|</code>结尾，以及特定数量的实例<code class="fe ky kz la lb b">{}</code>。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="253c" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'This is a wildcard.'<br/>&gt;x = re.findall('^This', string)<br/>&gt;<br/>&gt;print(x)</span><span id="7c69" class="lk ll iq lb b gy lq ln l lo lp">['This']</span></pre><p id="a23c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">除了元字符之外，<code class="fe ky kz la lb b">re</code>还有大量的<em class="kx">特殊字符</em>、<em class="kx">、</em>，它们允许表达式对模式进行不同类型的检索或操作。这些特殊字符各由<code class="fe ky kz la lb b">\</code>表示；这与该字符在 Python 字符串中的用法一致。这些特殊字符之一就是<code class="fe ky kz la lb b">d</code>。<code class="fe ky kz la lb b">d</code>返回目标文本中所有匹配的整数。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="3fe7" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = '1These2are3not4numbers5.'<br/>&gt;x = re.findall('\d', string)<br/>&gt;<br/>&gt;print(x)</span><span id="3f87" class="lk ll iq lb b gy lq ln l lo lp">['1', '2', '3', '4', '5']</span></pre><p id="2d19" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">与此相反，我们可以通过调用<code class="fe ky kz la lb b">\D</code>返回所有非数字字符。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="bd88" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = '1These2are3not4numbers5.'<br/>&gt;x = re.findall('\D', string)<br/>&gt;<br/>&gt;print(x)</span><span id="ac0c" class="lk ll iq lb b gy lq ln l lo lp">['T', 'h', 'e', 's', 'e', 'a', 'r', 'e', 'n', 'o', 't', 'n', 'u', 'm', 'b', 'e', 'r', 's', '.']</span></pre><p id="dad3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们也可以将正则表达式视为集合。这是通过将我们的表达式放在括号<code class="fe ky kz la lb b">[]</code>中来实现的。下面，我们在目标文本中搜索表达式中的任何字符，并在每次匹配时返回该字符:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="09dc" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'I am looking for all five vowels.'<br/>&gt;x = re.findall('[aeiou]', string)<br/>&gt;<br/>&gt;print(x)</span><span id="5d88" class="lk ll iq lb b gy lq ln l lo lp">['a', 'o', 'o', 'i', 'o', 'a', 'i', 'e', 'o', 'e']</span></pre><p id="2412" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">与此相反，如果我们以<code class="fe ky kz la lb b">^</code>开始表达式，那么集合的补集——正则表达式中除以外的任何字符——都将被打印出来。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="1d53" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'I am looking for all five vowels.'<br/>&gt;x = re.findall('[^aeiou]', string)<br/>&gt;<br/>&gt;print(x)</span><span id="77cc" class="lk ll iq lb b gy lq ln l lo lp">['I', ' ', 'm', ' ', 'l', 'k', 'n', 'g', ' ', 'f', 'r', ' ', 'l', 'l', ' ', 'f', 'v', ' ', 'v', 'w', 'l', 's', '.']</span></pre><p id="b4d4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">使用连字符时，正则表达式将返回任何没有指定范围的小写字母的字符的匹配。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="9619" class="lk ll iq lb b gy lm ln l lo lp">&gt;string = 'I am looking for all five vowels.'<br/>&gt;x = re.findall('[a-l]', string)<br/>&gt;<br/>&gt;print(x)</span><span id="88ea" class="lk ll iq lb b gy lq ln l lo lp">['a', 'l', 'k', 'i', 'g', 'f', 'a', 'l', 'l', 'f', 'i', 'e', 'e', 'l']</span></pre><p id="a2a9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这里给出的每个例子都使用了<code class="fe ky kz la lb b">findall()</code>方法。但是我们也可以<code class="fe ky kz la lb b">split()</code>、<code class="fe ky kz la lb b">sub()</code>、<code class="fe ky kz la lb b">search()</code>、<code class="fe ky kz la lb b">span()</code>、<code class="fe ky kz la lb b">match()</code>、<code class="fe ky kz la lb b">group()</code>。因此，这仅仅是对<code class="fe ky kz la lb b">re</code>的一些概念基础的简单介绍。此外，Python 中的正则表达式超越了<code class="fe ky kz la lb b">re</code>固有的功能。例如，一个流行的第三方包<code class="fe ky kz la lb b">regex</code>提供了更多的正则表达式方法，并且向后兼容原生的<code class="fe ky kz la lb b">re</code>。</p></div></div>    
</body>
</html>