<html>
<head>
<title>I wrapped my Spotify history the hard way.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我艰难地结束了我的 Spotify 历史。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/i-wrapped-my-spotify-history-the-hard-way-93dc832d9b47?source=collection_archive---------12-----------------------#2019-12-08">https://towardsdatascience.com/i-wrapped-my-spotify-history-the-hard-way-93dc832d9b47?source=collection_archive---------12-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">用 Go 和 PostgreSQL 分析一年的流。</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1664941636258a3284a5d5f65c3bb268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RH72pKm8Yc7ToGKYHEBEsA.png"/></div></div></figure><p id="1936" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，各地的 Spotify 用户已经获得了他们的<a class="ae lq" href="https:/spotify.com/wrapped/" rel="noopener ugc nofollow" target="_blank"> 2019 年包装</a>结果。我对自己的经历并不感到惊讶，部分原因是我知道自己花了很多时间在一支 90 年代即将回归的乐队<a class="ae lq" href="https://www.forbes.com/sites/stevebaltin/2019/11/01/confirmed-rage-against-the-machine-to-reunite-in-2020-headline-coachella/#5d56860812b1" rel="noopener ugc nofollow" target="_blank">的音乐中锻炼，还因为我最近使用了 Spotify 的</a><a class="ae lq" href="https://www.makeuseof.com/tag/download-privacy-data-spotify/" rel="noopener ugc nofollow" target="_blank">隐私数据下载</a>来直接查看我过去一年的历史，Spotify 保留了所有细节。</p><h1 id="6d11" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">从 Spotify 获取我的播放历史</h1><p id="e967" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">它始于在<a class="ae lq" href="https://www.spotify.com/ca-en/account/privacy/" rel="noopener ugc nofollow" target="_blank">https://www.spotify.com/ca-en/account/privacy/</a>的一个请求，在那里(靠近底部)，Spotify 用户可以请求下载，包括“你的播放列表副本、搜索、过去一年的流媒体历史、你的库中保存的项目列表、你的粉丝数量、你关注的其他用户和艺术家的数量和姓名，以及你的付费和订阅数据。”</p><p id="98e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那似乎是很多！网站上说最多需要 30 天(<a class="ae lq" href="https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/individual-rights/right-of-access/" rel="noopener ugc nofollow" target="_blank">按照 GDPR 的要求</a>)，但是根据我的经验(两次请求)，收到一封包含链接的邮件需要三四天。该链接指向一个可使用两周的 zip 文件。解压存档文件时，我找到了这些文件:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="9aea" class="mt ls it mp b gy mu mv l mw mx">$ ls -s<br/>total 4428<br/>   4  CarThing.json         16  SearchQueries.json<br/>   4  FamilyPlan.json     1404  StreamingHistory0.json<br/>   4  Follow.json         1412  StreamingHistory1.json<br/>   0  KidsAccount.json     980  StreamingHistory2.json<br/>   4  Payments.json          4  Userdata.json<br/>  92  Playlist1.json       160  YourLibrary.json<br/> 344 'Read Me First.pdf'</span></pre><p id="1679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于 Spotify 如何使用它的详细信息在 Spotify 的<a class="ae lq" href="https://www.spotify.com/us/privacy/" rel="noopener ugc nofollow" target="_blank">隐私中心</a>中，但是文件名大部分是不言自明的。你会看到信用卡的详细信息被屏蔽了，我们没有得到任何我们关注的帐户的身份，但如果你想知道你的收听历史，它都在这里！查看名为<code class="fe my mz na mp b">StreamingHistory[0-2].json</code>的文件，我发现每个文件有多达 10，000 条记录，每条记录描述了一个流媒体播放，包括其时间和持续时间。比如 2018 年 11 月 22 日，我正在怀旧地听<a class="ae lq" href="https://www.rush.com/band/" rel="noopener ugc nofollow" target="_blank"> Rush </a>:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="b34e" class="mt ls it mp b gy mu mv l mw mx">{<br/>    "endTime" : "2018-11-22 20:57",<br/>    "artistName" : "Rush",<br/>    "trackName" : "Subdivisions",<br/>    "msPlayed" : 334722<br/>},</span></pre><p id="87a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部分播放包括在内，流可能短至 0 毫秒，我猜这相当于快速跳过播放列表。</p><p id="f009" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会惊讶地发现(就像我一样),这不包括艺术家和歌曲的 Spotify URIs。例如，<a class="ae lq" href="https://open.spotify.com/track/0Z0s6dw0zw2ENU1gVjlLV6?si=UzTRYEAHRyCl_wmpkG-HlQ" rel="noopener ugc nofollow" target="_blank">分部</a>的 Spotify URI 是<code class="fe my mz na mp b">spotify:track:0Z0s6dw0zw2ENU1gVjlLV6</code>，而<a class="ae lq" href="https://open.spotify.com/artist/2Hkut4rAAyrQxRdof7FVJq?si=67GmcS_USUW7k-j8hWjwNQ" rel="noopener ugc nofollow" target="_blank"> Rush </a>的 URI 是<code class="fe my mz na mp b">spotify:artist:2Hkut4rAAyrQxRdof7FVJq</code>。但这可能只是意味着这些数据更多的是给人类使用，而不是给机器使用。</p><p id="9641" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我决定用 Go 来分析我的流历史，并从编写一些代码来读取我的一个流历史文件的内容开始:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="3fe3" class="mt ls it mp b gy mu mv l mw mx">package main</span><span id="7f83" class="mt ls it mp b gy nb mv l mw mx">import (<br/>    “encoding/json”<br/>    “fmt”<br/>    “io/ioutil”<br/>)</span><span id="38a5" class="mt ls it mp b gy nb mv l mw mx">type Play struct {<br/>    EndTime string `json:”endTime”`<br/>    ArtistName string `json:”artistTime”`<br/>    TrackName string `json:”trackName”`<br/>    MSPlayed int32 `json:”msPlayed”`<br/>}</span><span id="7fda" class="mt ls it mp b gy nb mv l mw mx">func main() {<br/>    b, err := ioutil.ReadFile(“StreamingHistory0.json”)<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    fmt.Printf(“%d\n”, len(b))<br/>    var plays []Play<br/>    json.Unmarshal(b, &amp;plays)<br/>    fmt.Printf(“%d\n”, len(plays))<br/>}</span></pre><h1 id="4a02" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">将我的游戏历史加载到 PostgreSQL</h1><p id="8c79" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我可以直接在 Go 中完成剩下的工作，但是因为我也想温习一下 PostgreSQL，所以我决定将这些记录加载到本地数据库中，用 SQL 对它们进行分析。</p><p id="526c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我已经在我的桌面 Ubuntu 机器上安装了 PostgreSQL(这里的指令<a class="ae lq" href="https://www.postgresql.org/download/linux/ubuntu/" rel="noopener ugc nofollow" target="_blank">是</a>)，所以我的第一步是为数据设计一个模式。我决定将它正常化，将艺术家、曲目和流式播放分离到单独的表中。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8263" class="mt ls it mp b gy mu mv l mw mx">CREATE TABLE artists (<br/>  id SERIAL PRIMARY KEY,<br/>  name TEXT UNIQUE NOT NULL<br/>);</span><span id="6bea" class="mt ls it mp b gy nb mv l mw mx">CREATE TABLE tracks (<br/>  id SERIAL PRIMARY KEY,<br/>  name TEXT NOT NULL,<br/>  artist_id INTEGER NOT NULL REFERENCES artists (id)<br/>);</span><span id="c6bf" class="mt ls it mp b gy nb mv l mw mx">CREATE TABLE streaming_plays (<br/>  id SERIAL PRIMARY KEY,<br/>  end_time TIMESTAMPTZ NOT NULL,<br/>  ms_played INTEGER NOT NULL,<br/>  track_id INTEGER NOT NULL REFERENCES tracks (id)<br/>);</span></pre><p id="fac5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将它放在一个文件中，并从命令行直接加载到 PostgreSQL 中(首先用<code class="fe my mz na mp b">createdb playtime</code>创建了<code class="fe my mz na mp b">playtime</code>数据库之后):</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="0a47" class="mt ls it mp b gy mu mv l mw mx">psql -U postgres -d playtime -a -f schema.sql</span></pre><p id="527e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我需要一种将数据从 Go 加载到 PostgreSQL 的方法。在浏览各种选项时，我发现了<a class="ae lq" href="https://github.com/gnormal/gnorm" rel="noopener ugc nofollow" target="_blank"> gnorm </a>和<a class="ae lq" href="https://github.com/gnormal/postgres-go" rel="noopener ugc nofollow" target="_blank"> postgres-go </a>，它们直接从数据库模式生成 go 支持代码。<a class="ae lq" href="https://github.com/gnormal/postgres-go" rel="noopener ugc nofollow" target="_blank"> postgres-go </a> repo 包含了<a class="ae lq" href="https://github.com/gnormal/gnorm" rel="noopener ugc nofollow" target="_blank"> gnorm </a>使用的模板，并做了一些假设，让我回去修改我的数据库模式。来自<a class="ae lq" href="https://github.com/gnormal/postgres-go/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述</a>:</p><blockquote class="nc nd ne"><p id="a063" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">这些模板假设了一些事情——如果一个列有一个默认的主键，我们将在插入时忽略这个主键，让数据库生成这个键(例如，一个 uuid 或自动递增的整数)。这避免了 Go 代码的零值是有效值的问题，因此您忘记了设置 id，它被插入 ID == 0(这通常是错误的)。</p><p id="cd86" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">其他假设—名为 updated_at 和 created_at 的列被假设为由数据库生成，因此永远不会手动插入或更新，并且在插入时使用 Postgres 的 RETURNING 语句返回(连同 id)。</p></blockquote><p id="d3b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我完全修改过的数据库模式:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="9d5f" class="mt ls it mp b gy mu mv l mw mx">CREATE OR REPLACE FUNCTION trigger_set_timestamp ()<br/>  RETURNS TRIGGER<br/>  AS $$<br/>BEGIN<br/>  NEW.updated_at = NOW();<br/>  RETURN NEW;<br/>END;<br/>$$<br/>LANGUAGE plpgsql;</span><span id="1852" class="mt ls it mp b gy nb mv l mw mx">DROP TABLE IF EXISTS streaming_plays;<br/>DROP TABLE IF EXISTS tracks;<br/>DROP TABLE IF EXISTS artists;</span><span id="52ce" class="mt ls it mp b gy nb mv l mw mx">CREATE TABLE artists (<br/>  id SERIAL PRIMARY KEY,<br/>  name TEXT UNIQUE NOT NULL,<br/>  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),<br/>  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()<br/>);</span><span id="3977" class="mt ls it mp b gy nb mv l mw mx">CREATE TABLE tracks (<br/>  id SERIAL PRIMARY KEY,<br/>  name TEXT NOT NULL,<br/>  artist_id INTEGER NOT NULL REFERENCES artists (id),<br/>  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),<br/>  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()<br/>);</span><span id="1268" class="mt ls it mp b gy nb mv l mw mx">CREATE TABLE streaming_plays (<br/>  id SERIAL PRIMARY KEY,<br/>  end_time TIMESTAMPTZ NOT NULL,<br/>  ms_played INTEGER NOT NULL,<br/>  track_id INTEGER NOT NULL REFERENCES tracks (id),<br/>  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),<br/>  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()<br/>);</span><span id="afff" class="mt ls it mp b gy nb mv l mw mx">CREATE TRIGGER set_timestamp<br/>  BEFORE UPDATE ON artists<br/>  FOR EACH ROW<br/>  EXECUTE PROCEDURE trigger_set_timestamp ();</span><span id="c06e" class="mt ls it mp b gy nb mv l mw mx">CREATE TRIGGER set_timestamp<br/>  BEFORE UPDATE ON tracks<br/>  FOR EACH ROW<br/>  EXECUTE PROCEDURE trigger_set_timestamp ();</span><span id="173d" class="mt ls it mp b gy nb mv l mw mx">CREATE TRIGGER set_timestamp<br/>  BEFORE UPDATE ON streaming_plays<br/>  FOR EACH ROW<br/>  EXECUTE PROCEDURE trigger_set_timestamp ();</span></pre><p id="b41a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个加载到我的数据库中，我就能够用<code class="fe my mz na mp b">gnorm gen</code>生成支持代码，并扩展我的 Go 程序来循环遍历我的播放历史，并为列出的艺术家、曲目和播放创建条目。<a class="ae lq" href="https://gist.github.com/timburks/5a13e4cceb421220b96bd417b1d305bf" rel="noopener ugc nofollow" target="_blank">下面是我最后一个<code class="fe my mz na mp b">main.go</code>的要点</a>。</p><h1 id="3dca" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用 SQL 分析我的游戏历史</h1><p id="479c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">将我的历史加载到 PostgreSQL 后，生成我的“包装”列表只需要运行正确的 SQL 命令。这里有一个返回我播放时间最长的十首歌曲:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="bfeb" class="mt ls it mp b gy mu mv l mw mx">SELECT sum(ms_played)/(60*60*1000.0), artists.name, tracks.name<br/>FROM streaming_plays,tracks,artists<br/>WHERE track_id = tracks.id<br/>AND artist_id = artists.id<br/>GROUP BY tracks.name, artists.name<br/>ORDER BY sum(ms_played) DESC LIMIT 10</span></pre><p id="dab2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<code class="fe my mz na mp b">psql -U postgres -d playtime -a -f toptracks.sql </code>运行它产生了下表:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="397f" class="mt ls it mp b gy mu mv l mw mx">?column?      |           name           |         name          <br/>--------------------+--------------------------+--------------------<br/> 4.6896372222222222 | Rage Against The Machine | Killing In The Name<br/> 3.6687563888888889 | Rage Against The Machine | Wake Up<br/> 3.5106108333333333 | Dave Grohl               | Play<br/> 3.4357252777777778 | Rage Against The Machine | Renegades Of Funk<br/> 3.0494194444444444 | Rage Against The Machine | Know Your Enemy<br/> 2.8526719444444444 | Rage Against The Machine | Bombtrack<br/> 2.5247416666666667 | Rage Against The Machine | Bulls On Parade<br/> 2.4658491666666667 | Gwen Stefani             | Harajuku Girls<br/> 2.4145450000000000 | Rage Against The Machine | Take The Power Back<br/> 2.3744705555555556 | Jessie Ware              | Alone</span></pre><p id="ed65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(如前所述，今年我和 RATM 一起跑了很多次！)下面是一个查询，它返回了我的前十位艺术家:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="659b" class="mt ls it mp b gy mu mv l mw mx">SELECT sum(ms_played)/(60*60*1000), artists.name<br/>FROM streaming_plays,tracks,artists<br/>WHERE track_id = tracks.id<br/>AND tracks.artist_id = artists.id<br/>GROUP BY artists.name<br/>ORDER BY sum(ms_played) DESC LIMIT 10</span><span id="4ca8" class="mt ls it mp b gy nb mv l mw mx">?column? |           name           <br/>----------+--------------------------<br/>       54 | Rage Against The Machine<br/>       31 | AC/DC<br/>       18 | Foo Fighters<br/>       15 | Hole<br/>       15 | Britney Spears<br/>       13 | Cibo Matto<br/>       13 | Nine Inch Nails<br/>       12 | Beastie Boys<br/>       11 | Rush<br/>       10 | Weezer</span></pre><p id="84d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还没有进一步探索，但可以想象按月、按一周中的某一天、或按一天中的某个时间来排列我的热门曲目(“热门锻炼曲目”、“热门早间音乐”等)。</p><h1 id="b566" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用 Hasura 探索我与 GraphQL 的历史</h1><p id="1c69" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">2018 年宣布，<a class="ae lq" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura </a>为 PostgreSQL 数据库创建 GraphQL 接口。稍微阅读了一下，我发现我可以在 Docker 容器中运行 Hasura，并将其附加到我的本地数据库:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="1f11" class="mt ls it mp b gy mu mv l mw mx">#!/bin/bash<br/>docker run -d --net=host \<br/>       -e HASURA_GRAPHQL_DATABASE_URL=postgres://postgres:test@localhost:5432/playtime \<br/>       -e HASURA_GRAPHQL_ENABLE_CONSOLE=true \<br/>       hasura/graphql-engine:v1.0.0-rc.1</span></pre><p id="7229" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给了我一个本地控制台，我可以用它来研究我的数据库，只需几次点击，我就可以接受 Hakura 的缺省值，并将我的键关系转换成一个丰富的 GraphQL 模式。这是一个 GraphQL 查询，查询的是歌手的歌曲:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9cfbb37cf3662d7a2ece8ed8f41dd31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaGXI3OuqxuvzU6zJfi1-w.png"/></div></div></figure><p id="2dac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个查询，显示每次我流<a class="ae lq" href="https://open.spotify.com/artist/36E7oYfz3LLRto6l2WmDcD?si=2DyZcn8eSN2CUuzUyXHYvw" rel="noopener ugc nofollow" target="_blank">纸浆</a>的<a class="ae lq" href="https://open.spotify.com/track/2fXKyAyPrEa24c6PJyqznF?si=pJa3ZqCGT3eZrw_mZEeVLQ" rel="noopener ugc nofollow" target="_blank">普通人</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/11f7d528ed159d0ca194fce57e7c6731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jq8mdYw0NPYFU_3ZK0KIw.png"/></div></div></figure><h1 id="01b0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">从 Spotify API 获取摘要和更多内容</h1><p id="e51f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">有了 Spotify APIs，可以实时获得更多信息。这里有一个很好的教程，描述了如何使用 React 和 Node 查看您的实时 Spotify 历史。它使用<a class="ae lq" href="https://developer.spotify.com/documentation/web-api/" rel="noopener ugc nofollow" target="_blank"> Spotify Web API </a>来<a class="ae lq" href="https://developer.spotify.com/documentation/web-api/reference/player/get-recently-played/" rel="noopener ugc nofollow" target="_blank">获取当前用户最近播放的曲目</a>。其他 API 函数包括 one to <a class="ae lq" href="https://developer.spotify.com/documentation/web-api/reference/personalization/get-users-top-artists-and-tracks/" rel="noopener ugc nofollow" target="_blank">获取用户的顶级艺术家和曲目</a>和方法<a class="ae lq" href="https://developer.spotify.com/documentation/web-api/reference/player/get-information-about-the-users-current-playback/" rel="noopener ugc nofollow" target="_blank">获取关于用户当前回放的信息</a>和<a class="ae lq" href="https://developer.spotify.com/documentation/web-api/reference/player/start-a-users-playback/" rel="noopener ugc nofollow" target="_blank">开始/恢复用户的回放</a>。有人想建一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Turntable.fm" rel="noopener ugc nofollow" target="_blank">共享点唱机</a>吗？</p></div></div>    
</body>
</html>