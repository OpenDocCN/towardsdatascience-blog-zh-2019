<html>
<head>
<title>Going Serverless with OpenFaaS and Golang — Building Optimized Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OpenFaaS 和 Golang 实现无服务器——构建优化的模板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/going-serverless-with-openfaas-and-golang-building-optimized-templates-730991084443?source=collection_archive---------25-----------------------#2019-11-29">https://towardsdatascience.com/going-serverless-with-openfaas-and-golang-building-optimized-templates-730991084443?source=collection_archive---------25-----------------------#2019-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bd3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:这最初发布在</em><a class="ae kp" href="https://martinheinz.dev/blog/11" rel="noopener ugc nofollow" target="_blank"><em class="ko">martinheinz . dev</em></a></p><p id="d286" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae kp" href="https://dev.to/martinheinz/going-serverless-with-openfaas-and-golang-the-ultimate-setup-and-workflow-2hd1" rel="noopener ugc nofollow" target="_blank">上一篇关于<em class="ko"> OpenFaaS </em>函数</a>的博文中，我们探索了我们可以用<em class="ko"> OpenFaaS </em>做什么——我们在<em class="ko"> Golang </em>中创建了我们的第一个 OpenFaaS 函数，我们为它编写了单元测试，用<em class="ko"> Travis </em>设置了 CI/CD，用<em class="ko"> Taskfile </em>自动化了常见任务。现在，是时候深入一点了。</p><p id="dd80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇博文中，我们将探讨如何构建定制模板，优化它们，从它们构建函数，最后，我们还将把<em class="ko"> Go </em>模块合并到我们的新模板中。所以，让我们开始吧！</p><p id="b973" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">TL；博士:这篇文章的完整源代码，包括文档可以在这里找到:</em><a class="ae kp" href="https://github.com/MartinHeinz/openfaas-templates" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://github.com/MartinHeinz/openfaas-templates</em></a></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/b5fb926c9656f77bc808dec43980b8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*zhzBhv0JZjGYgdch2sX54Q.png"/></div></figure><h1 id="57b6" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">深入了解模板</h1><p id="a605" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">如果我们想要构建自定义模板，那么我们首先需要了解它们是如何工作的。让我们首先看看模板由哪些文件组成:</p><ul class=""><li id="337f" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated">模板清单——<code class="fe mk ml mm mn b">template.yml</code>是一个描述模板本身的文件，因此<em class="ko"> OpenFaaS </em>知道如何从中创建和部署功能。在该文件中，您可以找到诸如<code class="fe mk ml mm mn b">language</code>、必需的<code class="fe mk ml mm mn b">packages</code>或<code class="fe mk ml mm mn b">fprocess</code>等信息</li><li id="d057" class="mb mc it js b jt mo jx mp kb mq kf mr kj ms kn mg mh mi mj bi translated">Entrypoint——接下来，为了使函数能够工作，我们需要一些文件(entry point ),这些文件要么监听 HTTP 请求，要么读取<em class="ko"> STDIO </em>并将这些请求转发给函数本身。这个入口点文件是什么，取决于语言，所以可以有<code class="fe mk ml mm mn b">main.go</code>、<code class="fe mk ml mm mn b">index.py</code>、<code class="fe mk ml mm mn b">index.js</code>等。</li><li id="1cfd" class="mb mc it js b jt mo jx mp kb mq kf mr kj ms kn mg mh mi mj bi translated">handler——现在，我们有了一个入口点，它将请求传递给我们的函数，我们需要以某种方式<em class="ko">处理</em>它。为此，我们有<code class="fe mk ml mm mn b">handler.{go,js,py...}</code>来做实际的工作，并从函数返回响应</li><li id="b5d9" class="mb mc it js b jt mo jx mp kb mq kf mr kj ms kn mg mh mi mj bi translated">依赖性——大多数时候，你的函数会用到一些包。这些可以用语言特定的方式指定，例如使用<code class="fe mk ml mm mn b">package.json</code>表示<em class="ko"> JavaScript </em>或者使用<code class="fe mk ml mm mn b">go.mod</code>表示<em class="ko"> Golang </em></li><li id="f13b" class="mb mc it js b jt mo jx mp kb mq kf mr kj ms kn mg mh mi mj bi translated"><code class="fe mk ml mm mn b">Dockerfile</code> -最后，为了将所有这些文件打包成一个函数，我们有了<code class="fe mk ml mm mn b">Dockerfile</code>，它构建、测试并创建最终的<em class="ko"> runner </em>映像，该映像可以部署到<em class="ko"> OpenFaaS </em>。</li></ul><p id="d8bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们知道了函数由什么组成，它实际上是如何工作的？<em class="ko"> OpenFaaS </em>模板有两个版本——<em class="ko">经典</em> ( <code class="fe mk ml mm mn b">watchdog</code>)和新<em class="ko"> beta </em> ( <code class="fe mk ml mm mn b">of-watchdog</code>)模板。它们都是通过创建微小的<em class="ko"> Golang </em> webserver 来运行的，webserver 整理 API 网关上接受的 HTTP 请求，然后将请求转发给被调用的函数。这就是相似之处，现在让我们看看不同之处:</p><ul class=""><li id="b904" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><code class="fe mk ml mm mn b">watchdog</code> : <em class="ko">经典</em>模板通过为每个请求派生一个流程来操作。一旦您的流程被分叉，看门狗通过<code class="fe mk ml mm mn b">stdin</code>传入 HTTP 请求，并通过<code class="fe mk ml mm mn b">stdout</code>读取 HTTP 响应。</li></ul><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9788857a18f3a9810cc2479fb6fde963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/0*Ch9PzxsjJmho3Epm"/></div></figure><ul class=""><li id="dfc8" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><code class="fe mk ml mm mn b">of-watchdog</code>:另一方面，当 watchdog 启动时，新模板派生出一个进程，然后我们将任何传入 watchdog 的请求转发到容器内的 HTTP 端口。</li></ul><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/85a41b72b18d5b244161beaefd332aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/0*XjU94SzAIujJEsQs"/></div></figure><p id="2be5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">以上图片摘自 OpenFaaS 架构文档—</em><a class="ae kp" href="https://docs.openfaas.com/architecture/watchdog/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://docs.openfaas.com/architecture/watchdog/</em></a></p><p id="9e2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想更深入地了解<code class="fe mk ml mm mn b">watchdog</code>(旧的和新的)是如何工作的，那么去<a class="ae kp" href="https://github.com/openfaas/faas/blob/master/watchdog/README.md" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae kp" href="https://github.com/openfaas-incubator/of-watchdog/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">这里</a></p><h1 id="95ca" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建模板</h1><p id="e19b" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">首先，模板有特定的文件/目录结构，这是我们需要遵循的，看起来是这样的:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ce67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用上面的结构——<code class="fe mk ml mm mn b">template</code>目录是所有模板驻留的地方。在其中，我们有一个名为<code class="fe mk ml mm mn b">my-template</code>的模板，里面是它工作所必需的文件——所有这些我们已经在前一节中描述过了。这是一个非常小的例子，我们将会添加更多的文件。</p><p id="41ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结构到此为止，现在我觉得终于到了创建模板的时候了，先从<em class="ko">【经典</em> <code class="fe mk ml mm mn b"><em class="ko">watchdog</em></code> <em class="ko">风格】</em>模板开始吧。我们可以通过从官方模板商店<a class="ae kp" href="https://github.com/openfaas/templates/tree/master/template" rel="noopener ugc nofollow" target="_blank">复制一个来创建一个。考虑到这是<em class="ko"> Golang </em>模板的指南，我就拿基本的<code class="fe mk ml mm mn b">go</code>模板(这里复制是多余的，你可以在这里</a>看到最新版本的模板<a class="ae kp" href="https://github.com/openfaas/templates/tree/master/template/go" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="4aca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们把它复制到<code class="fe mk ml mm mn b">template</code>文件夹时，我们应该检查它是否真的工作，对吗？所以让我们来建造它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b1e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来不错，现在让我们部署功能，好吗？</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="019c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样，我们创建了自己的模板(嗯，我们真的只是从官方商店借来的)并部署了从中获得的功能。然而，整个过程感觉相当笨拙，因为我们不得不使用相当多的命令来运行它，并直接调用<code class="fe mk ml mm mn b">docker</code>命令，而不是例如<code class="fe mk ml mm mn b">faas-cli build</code>和<code class="fe mk ml mm mn b">faas-cli push</code>。在下一篇博文中，我们将用<em class="ko">任务文件</em>和几个脚本来简化这个过程。现在，让我们优化一下现有的模板...</p><h1 id="41da" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们可以改进什么？</h1><p id="4e48" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">上一节的<em class="ko">经典</em>模板非常好，但是有一些问题:</p><ul class=""><li id="72d9" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><em class="ko">无 Go 模块</em>:该模板不使用 1.11 中引入的<em class="ko"> Golang </em>模块系统，这意味着必须使用不实用且过时的依赖管理。</li><li id="2444" class="mb mc it js b jt mo jx mp kb mq kf mr kj ms kn mg mh mi mj bi translated"><em class="ko">非最佳</em> <code class="fe mk ml mm mn b"><em class="ko">Dockerfile</em></code> : <code class="fe mk ml mm mn b">Dockerfile</code>这个模板有相当多的不必要的层，使其构建缓慢，并且很少<em class="ko">比所需的</em>厚。</li><li id="a90b" class="mb mc it js b jt mo jx mp kb mq kf mr kj ms kn mg mh mi mj bi translated"><code class="fe mk ml mm mn b"><em class="ko">of-watchdog</em></code> <em class="ko">更快</em>:如上所述，是<em class="ko">经典</em>模板，所以不用<code class="fe mk ml mm mn b">of-watchdog</code>。因此，我们可以通过切换到<code class="fe mk ml mm mn b">of-watchdog</code>并使用 HTTP 模式来提高它的性能。</li></ul><p id="4e1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，让我们来解决这些问题吧！</p><p id="1e4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">注:</em> </strong> <em class="ko">这里提一下，OpenFaaS 社区已经在这些模板上做了很多工作。经典的是遗留模板，你应该使用中间件或它的 http 版本，并可能应用下面介绍的调整和更改。</em></p><p id="e579" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中一些问题可以通过在这里使用<code class="fe mk ml mm mn b">openfaas-incubator/golang-http-template</code><a class="ae kp" href="https://github.com/openfaas-incubator/golang-http-template" rel="noopener ugc nofollow" target="_blank"/>来解决，但是我们可以把它推得更远一点，所以让我们从这里的<a class="ae kp" href="https://github.com/openfaas-incubator/golang-http-template/tree/master/template/golang-http" rel="noopener ugc nofollow" target="_blank"/>中取出<code class="fe mk ml mm mn b">golang-http</code>并在此基础上构建。</p><p id="7f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我将向您展示我使用<a class="ae kp" href="https://github.com/openfaas-incubator/golang-http-template/blob/master/template/golang-http/Dockerfile" rel="noopener ugc nofollow" target="_blank">这个</a>T3】作为基础创建的最终<code class="fe mk ml mm mn b">Dockerfile</code>，我将带您了解所有的变化及其背后的基本原理:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ebcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:您可以在</em> <a class="ae kp" href="https://github.com/MartinHeinz/openfaas-templates/blob/master/template/golang-mod/Dockerfile" rel="noopener ugc nofollow" target="_blank"> <em class="ko">这里</em> </a>中查看 <code class="fe mk ml mm mn b"><em class="ko">Dockerfile</em></code> <em class="ko"/></p><p id="596b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从 2 个<code class="fe mk ml mm mn b">FROM</code>命令开始，因为我们既需要<em class="ko"> Golang </em> image 来构建函数，也需要<code class="fe mk ml mm mn b">watchdog</code> binary。接下来，我们打开 Go 模块并禁用<em class="ko"> CGO </em>，这将允许我们调用这里不需要的<em class="ko"> C </em>代码。下面的代码将<code class="fe mk ml mm mn b">git</code>安装到构建映像中，因为我们需要它在构建期间下载<em class="ko"> Golang </em>包。在接下来的 2 行中，我们复制<code class="fe mk ml mm mn b">watchdog</code>二进制文件并使其可执行。现在是时候构建我们的函数二进制代码了——我们首先将源代码复制到<code class="fe mk ml mm mn b">/go/src/handler</code>,然后对其运行 2 个命令—<em class="ko">test</em>和<em class="ko"> build </em>。对于测试，我们使用模板中包含的<code class="fe mk ml mm mn b">test.sh</code>脚本。让我们看看它能做什么:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b498" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:您可以在</em> <a class="ae kp" href="https://github.com/MartinHeinz/openfaas-templates/blob/master/template/golang-mod/test.sh" rel="noopener ugc nofollow" target="_blank"> <em class="ko">这里</em> </a>中查看 <code class="fe mk ml mm mn b"><em class="ko">test.sh</em></code> <em class="ko">文件</em></p><p id="6b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，它从<code class="fe mk ml mm mn b">function</code>目录中收集测试<em class="ko">目标</em>，这是我们的源代码。然后它对这些目标文件运行<code class="fe mk ml mm mn b">go test</code>，如果测试通过，那么就该检查格式并寻找代码中的可疑结构，这就是<code class="fe mk ml mm mn b">gofmt</code>和<code class="fe mk ml mm mn b">go vet</code>的作用。那时——在测试成功通过之后——回到<code class="fe mk ml mm mn b">Dockerfile</code>——我们构建名为<code class="fe mk ml mm mn b">handler</code>的二进制文件。</p><p id="cb88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mk ml mm mn b">Dockerfile</code>的最后部分是<em class="ko">亚军</em>的形象。在这里，我们运行<em class="ko">的命令真的</em>开始变得重要了。我们希望减少对<code class="fe mk ml mm mn b">RUN</code>、<code class="fe mk ml mm mn b">COPY</code>和<code class="fe mk ml mm mn b">ADD</code>的所有调用，因为这些调用会创建额外的图层，并会使最终图像膨胀。因此，首先我们使用单个<code class="fe mk ml mm mn b">RUN</code>命令添加 CA，添加名为<code class="fe mk ml mm mn b">app</code>的用户，函数将在该用户下运行并移动到它的主目录。接下来我们<code class="fe mk ml mm mn b">COPY</code>将所有需要的文件从构建器镜像到 runner 目录，函数将从该目录在单层中运行，这包括<em class="ko"> Golang </em>二进制、<code class="fe mk ml mm mn b">watchdog</code>二进制和函数目录中的所有内容。最后，我们设置我们的用户，设置环境变量，并将<code class="fe mk ml mm mn b">watchdog</code>二进制文件设置为默认启动命令。</p><p id="3bbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经解决了<code class="fe mk ml mm mn b">Dockerfile</code>,我们可以看看源代码了。为了简单起见，我只使用了前面提到的<a class="ae kp" href="https://github.com/openfaas-incubator/golang-http-template/tree/master/template/golang-http" rel="noopener ugc nofollow" target="_blank"> golang-http </a>中的<code class="fe mk ml mm mn b">main.go</code>和<code class="fe mk ml mm mn b">handler.go</code>，因为在模板代码方面没有太多变化。但是缺少的是一些单元测试模板，所以让我们看看我们能做些什么...</p><h1 id="429c" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试时间</h1><p id="2737" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">如果你读过我以前的任何一篇文章，你就已经知道接下来会发生什么了——单元测试。模板可以包含任何代码——包括测试，所以我认为添加简单的测试模板来测试您的功能是合适的。这是一个测试例子:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a54d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该测试位于紧挨着<code class="fe mk ml mm mn b">handler.go</code>的<code class="fe mk ml mm mn b">handler_test.go</code>文件中。该测试涵盖了在进行 HTTP 请求/响应时所期望的基本检查，即状态代码检查和响应验证。因此，首先我们使用<code class="fe mk ml mm mn b">handler.Response</code>创建期望值，接下来我们向由<code class="fe mk ml mm mn b">Handle</code>函数表示的函数发出请求，传递我们的请求，最后我们对照期望值检查它的响应。</p><h1 id="ae93" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将这一切结合在一起</h1><p id="1ce4" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">我们终于有了模板所需的所有源代码，但是我们还不能完全使用它。我们缺少构建函数所需的<code class="fe mk ml mm mn b">template.yml</code>。这是:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="57ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没什么好说的。我们指定语言、将作为<code class="fe mk ml mm mn b">fprocess</code>运行的二进制文件和简单的欢迎消息。我们也可以在这里包括<code class="fe mk ml mm mn b">build_options</code>和<code class="fe mk ml mm mn b">packages</code>，但在这种情况下，这是不必要的。</p><p id="fb81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我们需要完成的是模板的依赖关系，考虑到我们正在使用 Go 模块，我们需要做的就是在<code class="fe mk ml mm mn b">main.go</code>旁边创建<code class="fe mk ml mm mn b">go.mod</code>文件，如下所示</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9c40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后运行<code class="fe mk ml mm mn b">go mod tidy</code>，这将用我们所有的依赖项(<code class="fe mk ml mm mn b">openfaas-incubator/go-function-sdk</code>和<code class="fe mk ml mm mn b">stretchr/testify</code>)填充文件</p><p id="7d25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在唯一要做的就是构建、推动和部署它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="68ca" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="954a" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">就这样，我们创建了自定义模板，可以用来构建和部署<em class="ko"> OpenFaaS </em>函数。也就是说，剩下的事情不多了…在下一篇博文中，我们将构建个人模板库，在那里我们可以放置所有的自定义模板，然后添加模板的自动验证并将其包含在 CI/CD 管道中，最后我们将简化所有与使用<em class="ko"> Taskfile </em>构建和运行模板相关的任务，就像我们在上一篇博文中对函数所做的那样。如果你想先睹为快，请看<a class="ae kp" href="https://github.com/MartinHeinz/openfaas-templates" rel="noopener ugc nofollow" target="_blank">我的库这里</a>，如果你喜欢这些类型的帖子，可以随意留下反馈或者直接启动库。😉</p></div></div>    
</body>
</html>