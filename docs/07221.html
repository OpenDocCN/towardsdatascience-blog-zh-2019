<html>
<head>
<title>Line Detection: Make an Autonomous Car see Road Lines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线检测:让自动驾驶汽车看到道路线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/line-detection-make-an-autonomous-car-see-road-lines-e3ed984952c?source=collection_archive---------10-----------------------#2019-10-11">https://towardsdatascience.com/line-detection-make-an-autonomous-car-see-road-lines-e3ed984952c?source=collection_archive---------10-----------------------#2019-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0b0774800378a8a78f26a059068c17b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fe9HixTWTpQEwX7IVVa1Mg.gif"/></div></div></figure><div class=""/><p id="381f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">通过计算机视觉，你可以一步一步地将视频流转换成线状探测器</em></p><h1 id="5aa0" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动机</h1><p id="f6a0" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">全自动驾驶乘用车并非“指日可待”。埃隆·马斯克声称<strong class="kd jf">特斯拉</strong>将在 2020 年年底<a class="ae md" href="https://www.wired.com/story/elon-musk-tesla-full-self-driving-2019-2020-promise/" rel="noopener ugc nofollow" target="_blank">具备“完全自动驾驶”能力。特别是，他说特斯拉的硬件已经为自动驾驶做好了准备，剩下的只是对他们当前软件的更新，许多杰出的科学家正在为此努力。</a></p><p id="718a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们人类作为司机的第一本能，很可能是看着前方，决定车该往哪里开；在哪个方向，在哪些线之间，等等。由于每辆自动驾驶汽车前面都有一个摄像头，因此一项非常重要的任务是决定汽车应该在其间移动的边界。对人类来说，我们在道路上画线。现在我们将教一辆自动驾驶汽车看到这些线。我保证会很好玩:)</p><p id="a6c1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> <em class="kz">鸣谢—参考文献</em> </strong></p><p id="e945" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">这些项目大部分是由麻省理工学院的</em> <a class="ae md" href="https://selfdrivingcars.mit.edu" rel="noopener ugc nofollow" target="_blank"> <em class="kz">自动驾驶汽车深度学习</em> </a> <em class="kz">课程和 Udacity 的</em> <a class="ae md" href="https://www.udacity.com/school-of-autonomous-systems" rel="noopener ugc nofollow" target="_blank"> <em class="kz">自动驾驶汽车工程师</em> </a> <em class="kz">激发的。后者是学习和扩展你的领域技术知识的良好开端。</em></p><h1 id="15ac" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">议程</h1><p id="59c8" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们将一步一步地设计孔管道，其中我们将激励我们为什么这样做。<br/>灰度变换<br/>高斯模糊<br/>Canny 边缘检测<br/>遮蔽感兴趣区域<br/>霍夫线检测器<br/>寻找道路线</p><blockquote class="me"><p id="4627" class="mf mg je bd mh mi mj mk ml mm mn ky dk translated">完整的<strong class="ak">代码</strong>可以在<a class="ae md" href="https://github.com/ioangatop/AutonomousCar" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><p id="a72e" class="pw-post-body-paragraph kb kc je kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在这里，我们将一步一步，提供整个代码的快照。然而，一些部分被省略了，因为这将使邮件非常沉重，并分散我们的目标。因此，如需更多信息，请参考上述知识库。</p><h1 id="b7ec" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">步骤 0:读取图像</strong></h1><p id="4ebc" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在<code class="fe mt mu mv mw b">matplotlib</code>的帮助下，我们可以轻松地将 python 脚本中的任何图像加载为三维张量 C-H-W(颜色通道，图像的高度和宽度)</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="9f3e" class="nf lb je mw b gy ng nh l ni nj">import matplotlib.image as mpimg</span><span id="c6d9" class="nf lb je mw b gy nk nh l ni nj">img_path = 'test_images/solidWhiteCurve'<br/>img = mpimg.imread(img_path)<br/>plt.imshow(img)<br/>plt.show()</span></pre><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/59215543a0db1c509664769038534374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAYhzModmkMq3xRC3MaVQA.jpeg"/></div></div></figure><h1 id="938d" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">第一步:灰度</strong></h1><p id="a8c1" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，我们要把图像变成灰度图像；只有一个颜色通道。这将有助于我们识别棱角。<br/>我们可以通过<code class="fe mt mu mv mw b">opencv</code>轻松做到这一点</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="ea15" class="nf lb je mw b gy ng nh l ni nj">import cv2</span><span id="a402" class="nf lb je mw b gy nk nh l ni nj">gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br/>plt.imshow(gray_img, <em class="kz">cmap</em>='gray')<br/>plt.show()</span></pre><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/fa13359e2f113c6dbb763556a2af7986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJoaBC7WgzXCiDcnSdjlGQ.png"/></div></div></figure><h1 id="a775" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第二步:高斯模糊</h1><p id="fac0" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">将高斯噪声添加到图像中，这非常有用，因为它平滑了像素之间的插值，并且是一种超越噪声和伪梯度的方法。<code class="fe mt mu mv mw b">kernel</code>越高，结果图像越模糊。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="5a35" class="nf lb je mw b gy ng nh l ni nj">kernel_size = 5<br/>gauss_img = cv2.GaussianBlur(gray_img,(kernel_size, kernel_size), 0)</span></pre><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/d2a48eb862e71521b63a5194aef7af2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RS2XBuMSo7S-BkcGDLvO8Q.png"/></div></div></figure><h1 id="2594" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">第三步:</strong> Canny 边缘检测</h1><p id="f00a" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Canny 边缘检测提供了一种检测图像边界的方法。这是通过图像的渐变来完成的。</p><blockquote class="me"><p id="87ed" class="mf mg je bd mh mi mj mk ml mm mn ky dk translated">后者只不过是一个函数，其中每个像素的亮度对应于梯度的强度。</p></blockquote><p id="ac25" class="pw-post-body-paragraph kb kc je kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">我们将通过追踪沿着最强梯度的像素来找到边缘！一般来说，梯度显示函数变化有多快，像素之间强烈的密度变化将指示边缘。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="d28d" class="nf lb je mw b gy ng nh l ni nj">low_threshold, high_threshold = [200, 300]<br/>canny_img = cv2.Canny(gauss_img, low_threshold, high_threshold)</span></pre><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/cb38df533bcce11c71f3f7584b65c725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iruZZJEqIxvtadaSCYEBkQ.png"/></div></div></figure><p id="9b96" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，我们现在可以清楚地识别道路线！(我们甚至可以看到汽车的外形！)</p><h1 id="53c2" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤 4:遮蔽感兴趣的区域</h1><p id="3916" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">上图中，有一些离群值；来自道路的其他部分、来自风景(山脉)等的一些边缘。由于我们的相机是固定的，我们可以在图像上加一个<em class="kz">遮罩</em>，只保留那些我们感兴趣的线条。因此，画一个<em class="kz">梯形</em>是非常自然的，目的是只保留一个区域，在那里我们应该期望道路线。<code class="fe mt mu mv mw b">cv2</code>再次为我们而来；)</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="6c49" class="nf lb je mw b gy ng nh l ni nj"># Setting the corners of the trapezium<br/>vertices = np.array([[(0, img_line.shape[0]), (img_line.shape[1], img_line.shape[0]), (400, 260), (600, 260)]])</span><span id="70af" class="nf lb je mw b gy nk nh l ni nj"># make a blank/white image<br/>mask = np.zeros_like(img)<br/>mask_channels = (255,) * img.shape[2]</span><span id="ed8d" class="nf lb je mw b gy nk nh l ni nj"># Fill the area of interest with 0 and 255 these<br/># which lie outside of it, thoughout all color channels<br/>cv2.fillPoly(mask, vertices, mask_channels)</span><span id="5a2e" class="nf lb je mw b gy nk nh l ni nj"># Keep only the pixels with 0 value of the canny_img<br/>masked_img = cv2.bitwise_and(canny_img, mask)</span></pre><div class="mx my mz na gt ab cb"><figure class="nn iv no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/b5d43218735a93ba7ee83df388fc0e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LeeYPbOsHy2aKMEFxUa_NA.png"/></div></figure><figure class="nn iv no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/092c9c69c8b4d0068d85358f356aa393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5_zC_VGUzGFb7iHJueiBQQ.png"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk nx di ny nz"><strong class="bd oa">Left</strong>: Selected Region <strong class="bd oa">Right</strong>: After applying the mask</figcaption></figure></div><h1 id="62bc" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第五步:霍夫线检测器</h1><p id="ef2b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">上面的图像只代表了边缘的点。剩下的就是把边缘连接起来。在这种情况下，我们正在寻找直线，我们将通过将图像传输到称为<em class="kz">霍夫空间</em>的参数空间来实现这一点。我们现在将处理<em class="kz">极坐标</em> (rho 和 theta)，其中我们将搜索相交线。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a91a" class="nf lb je mw b gy ng nh l ni nj">import math</span><span id="f853" class="nf lb je mw b gy nk nh l ni nj">lines = cv2.HoughLinesP(img, rho=1, theta=math.pi/180,<br/>                        threshold=15, np.array([]),        <br/>                        <em class="kz">minLineLength</em>=30,<br/>                        <em class="kz">maxLineGap</em>=40)</span><span id="af16" class="nf lb je mw b gy nk nh l ni nj">line_img = np.zeros((img.shape[0], img.shape[1], 3), <em class="kz">dtype</em>=np.uint8)</span></pre><p id="83a6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上将返回许多小车道(最小长度是一个超参数<em class="kz"> minLineLength </em>)。<em class="kz"> line_img </em>将是一个列表，其中它的元素是一个列表，由图像空间{(x1，y1)，(x2，y2)}中的两个点组成。众所周知，在 2D 空间中，只有一条直线经过两点。</p><p id="d02f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里自然会出现一个问题:我们如何连接这些线，并导致只有两条，他们将是道路吗？这可能是这篇文章中最具挑战性的部分。</p><h1 id="de10" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">第六步:找到道路线路</strong></h1><p id="6ca9" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们的策略如下:<br/>。参照 x 轴将图像分成两半<br/>。用线性回归模型拟合这些点，以找到一条平滑的线。<br/>由于离群值，我们想要一个可以有效处理它们的回归模型。我们将使用<code class="fe mt mu mv mw b">HuberRegressor</code>。然后，我们将图像限制在 y 轴的某个范围内，并在<code class="fe mt mu mv mw b">cv2.polylines</code>的帮助下绘制直线。请记住，为了有一条平滑的线，<strong class="kd jf">我们将通过给定的回归量绘制给定的</strong> <code class="fe mt mu mv mw b"><strong class="kd jf">x</strong></code> <strong class="kd jf"> </strong>的 <code class="fe mt mu mv mw b"><strong class="kd jf">y</strong></code> <strong class="kd jf">的预测。</strong></p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="6c79" class="nf lb je mw b gy ng nh l ni nj">import math</span><span id="7220" class="nf lb je mw b gy nk nh l ni nj">def draw_lines(line_img, lines):<br/>   # CODE HERE<br/>   pass</span><span id="016f" class="nf lb je mw b gy nk nh l ni nj">lines = cv2.HoughLinesP(img, rho=1, theta=math.pi/180,<br/>                        threshold=15, np.array([]),        <br/>                        <em class="kz">minLineLength</em>=30,<br/>                        <em class="kz">maxLineGap</em>=40)</span><span id="d46b" class="nf lb je mw b gy nk nh l ni nj">line_img = np.zeros((img.shape[0], img.shape[1], 3), <em class="kz">dtype</em>=np.uint8)<br/>draw_lines(line_img, lines)</span><span id="68bc" class="nf lb je mw b gy nk nh l ni nj">plt.imshow(line_img)<br/>plt.show()</span></pre><p id="a944" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，鼓励读者编写上述函数。如果你卡住了或者只是想看看我的版本是什么样子，请在这里看<a class="ae md" href="https://github.com/ioangatop/AutonomousCar/blob/f252c236a260f549a10525ac23cf6ee261f46485/1-line_detection/line_detector.py#L40" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="3fec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的结果会是…</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/f8d34e2571795361deebaaba25ea674e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLpIXWITyse18DwDVqlFjQ.png"/></div></div></figure><h1 id="c9ef" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤 7:将线条与原始图像连接起来</h1><p id="8f9e" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">通过对两幅图像进行加权，我们可以将它们相加。记住<code class="fe mt mu mv mw b">img_lines</code>的黑色区域有值<code class="fe mt mu mv mw b">0</code>，因此相加不会改变输出值。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a112" class="nf lb je mw b gy ng nh l ni nj">out_img = cv2.addWeighted(img, 0.9, img_lines, 1.0, 0.0)<br/>plt.imshow(out_img)<br/>plt.show()</span></pre><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/92870b5c2b4487bc81cc001750c1e434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4wII85Sd7FhbYa0wXg6Qw.png"/></div></div></figure><h1 id="eade" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">备注</strong></h1><p id="bfce" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">瞧啊。我们已经成功探测到道路了！视频只是一个图像序列，因此，在<code class="fe mt mu mv mw b">moviepy</code>的帮助下，我们为每一帧绘制上述管道！视频管道将看起来像:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="7557" class="nf lb je mw b gy ng nh l ni nj">from moviepy.editor import VideoFileClip</span><span id="f019" class="nf lb je mw b gy nk nh l ni nj">in_video = 'test_videos_output/solidWhiteCurve.mp4'<br/>output_video = 'test_videos_output/out.mp4'</span><span id="cc45" class="nf lb je mw b gy nk nh l ni nj">clip = VideoFileClip(in_video).subclip(0, 8)<br/>empty_clip = clip.fl_image(YOUR PIPELINE AS A FUNCTION THAT <br/>                           RETURNS THE WEIGHTED IMAGE)</span><span id="c6db" class="nf lb je mw b gy nk nh l ni nj">out_clip.write_videofile(output_video, <em class="kz">audio</em>=False)</span></pre><p id="e9ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，完整的代码可以在这里找到<a class="ae md" href="https://github.com/ioangatop/AutonomousCar" rel="noopener ugc nofollow" target="_blank">。随意摆弄参数，想出新的方法来检测道路线。</a></p><p id="adfa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下次再见，保重！</p></div></div>    
</body>
</html>