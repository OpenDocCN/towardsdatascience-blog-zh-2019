<html>
<head>
<title>Artificial Neural Networks Optimization using Genetic Algorithm with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Python 的遗传算法优化人工神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/artificial-neural-networks-optimization-using-genetic-algorithm-with-python-1fe8ed17733e?source=collection_archive---------1-----------------------#2019-03-06">https://towardsdatascience.com/artificial-neural-networks-optimization-using-genetic-algorithm-with-python-1fe8ed17733e?source=collection_archive---------1-----------------------#2019-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2ca0154a4c3981409a2d2e6010af67b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wT6pIMnjZ9oArkidnVsGtg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image Created by Ahmed Fawzy Gad: <a class="ae kc" href="https://pixabay.com/illustrations/artificial-neural-network-ann-3501528/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/illustrations/artificial-neural-network-ann-3501528</a></figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="8f93" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我的 LinkedIn 个人资料中的标题为“<strong class="km ir">使用 NumPy 的人工神经网络实现和 Fruits360 图像数据集的分类</strong>”的先前教程中，在此<a class="ae kc" href="https://www.linkedin.com/pulse/artificial-neural-network-implementation-using-numpy-fruits360-gad" rel="noopener ugc nofollow" target="_blank">链接</a>处，创建了一个人工神经网络(ANN)用于对 Fruits360 图像数据集的 4 个类别进行分类。本教程中使用的源代码可以在我的<a class="ae kc" href="https://github.com/ahmedfgad/NumPyANN" rel="noopener ugc nofollow" target="_blank"> GitHub 页面</a>中找到。</p><p id="414d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个教程也可以在 TowardsDataScience <a class="ae kc" rel="noopener" target="_blank" href="/artificial-neural-network-implementation-using-numpy-and-classification-of-the-fruits360-image-3c56affa4491">这里</a>获得。</p><p id="058e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">本教程的快速总结是提取特征向量(360 箱色调通道直方图)并通过使用基于标准偏差的过滤技术将其减少到仅 102 个元素。后来，使用 NumPy 从头开始构建 ANN。</p><p id="994b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">人工神经网络没有完全创建，因为只有前向传递准备就绪，但没有用于更新网络权重的后向传递。这就是为什么准确率很低，不超过 45%的原因。这个问题的解决方案是使用优化技术来更新网络权重。本教程使用遗传算法(GA)优化网络权重。</p><p id="554a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">值得一提的是，上一篇和这篇教程都是基于我 2018 年的一本书，该书被引用为“<strong class="km ir">Ahmed Fawzy Gad‘使用深度学习的实用计算机视觉应用与 CNN’。2018 年 12 月，新闻，978–1–4842–4167–7</strong>。这本书可以在施普林格书店<a class="ae kc" href="https://springer.com/us/book/9781484241660" rel="noopener ugc nofollow" target="_blank">这个链接</a>买到。你可以在这本书里找到所有的细节。</p><p id="02dc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">本教程中使用的源代码可以在我的 GitHub 页面<a class="ae kc" href="https://github.com/ahmedfgad/NeuralGenetic" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="d7c7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">阅读更多关于遗传算法的信息</h1><p id="8a9b" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">在开始本教程之前，我建议先阅读一下遗传算法是如何工作的，以及如何使用 NumPy 从头开始在 Python 中实现它，这是基于我在本教程末尾的参考资料一节中列出的链接中找到的以前的教程。</p><p id="2b0a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">除了使用 Python 实现之外，在了解 GA 如何基于数值示例工作之后，我们可以开始使用 GA 通过更新其权重(参数)来优化 ANN。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="9418" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">将遗传算法与人工神经网络结合使用</h1><p id="f141" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">GA 为一个给定的问题创建多个解决方案，并通过若干代进化它们。每个解决方案都包含所有可能有助于增强结果的参数。对于人工神经网络，所有层中的权重有助于实现高精度。因此，GA 中的单个解将包含 ANN 中的所有权重。根据前面教程中讨论的网络结构以及下图中给出的网络结构，ANN 有 4 层(1 个输入层、2 个隐藏层和 1 个输出层)。任何层中的任何重量都是同一解决方案的一部分。此类网络的单个解决方案将包含总重量数，等于 102x150+150x60+60x4=24，540。如果总体有 8 个解，每个解有 24，540 个参数，则整个总体的参数总数为 24，540x8=196，320。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/a2fb2fece8a7483990fe2296e37c1802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzJCA69AW19b1IgRjlKIXQ.png"/></div></div></figure><p id="d0e2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">看上面的图，网络的参数是矩阵形式，因为这使得人工神经网络的计算更容易。对于每一层，都有一个相关的权重矩阵。只需将输入矩阵乘以给定层的参数矩阵，即可返回该层的输出。遗传算法中的染色体是 1D 向量，因此我们必须将权重矩阵转换成 1D 向量。</p><p id="d189" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因为矩阵乘法是处理 ANN 的一个很好的选择，所以在使用 ANN 时，我们仍将以矩阵形式表示 ANN 参数。因此，当与 ANN 一起工作时使用矩阵形式，而当与 GA 一起工作时使用向量形式。这使得我们需要将矩阵转换成向量，反之亦然。下图总结了将遗传算法与人工神经网络结合使用的步骤。该图被称为<strong class="km ir">主图</strong>。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/966312967afb6b66e7340b839fab2410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJptAF_dhtZrsGNem6O3bQ.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="8e12" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1D 向量的权重矩阵</h1><p id="75eb" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">群体中的每个解决方案将有两个表示。第一个是用于 GA 的 1D 向量，第二个是用于 ANN 的矩阵。因为 3 层有 3 个权重矩阵(2 个隐藏+ 1 个输出)，所以将有 3 个向量，每个矩阵一个。因为 GA 中的解被表示为单个 1D 向量，所以这 3 个单独的 1D 向量将被连接成单个 1D 向量。每个解将被表示为长度为 24，540 的向量。下一个 Python 代码创建了一个名为<strong class="km ir"> mat_to_vector() </strong>的函数，该函数将群体中所有解的参数从矩阵转换为向量。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="3d36" class="mw lj iq ms b gy mx my l mz na"><strong class="ms ir">def </strong>mat_to_vector(mat_pop_weights):<br/>     pop_weights_vector = []<br/>     <strong class="ms ir">for </strong>sol_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[0]):<br/>         curr_vector = []<br/>         <strong class="ms ir">for </strong>layer_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[1]):<br/>             vector_weights = numpy.reshape(mat_pop_weights[sol_idx, layer_idx], newshape=(mat_pop_weights[sol_idx, layer_idx].size))<br/>             curr_vector.extend(vector_weights)<br/>         pop_weights_vector.append(curr_vector)<br/>     <strong class="ms ir">return </strong>numpy.array(pop_weights_vector)</span></pre><p id="678a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">该函数接受一个表示所有解的总体的参数，以便遍历这些解并返回它们的向量表示。在函数的开始，创建一个名为<strong class="km ir"> pop_weights_vector </strong>的空列表变量来保存结果(所有解的向量)。对于每一个矩阵形式的解，都有一个内部循环来遍历它的三个矩阵。对于每个矩阵，使用<strong class="km ir"> numpy.reshape() </strong>函数将其转换为向量，该函数接受输入矩阵和矩阵将被整形到的输出大小。变量<strong class="km ir"> curr_vector </strong>接受单个解的所有向量。生成所有向量后，它们被追加到<strong class="km ir"> pop_weights_vector </strong>变量中。</p><p id="8278" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">注意，我们对属于同一解决方案的向量使用了<strong class="km ir"> numpy.extend() </strong>函数，对属于不同解决方案的向量使用了<strong class="km ir"> numpy.append() </strong>。原因是<strong class="km ir"> numpy.extend() </strong>将属于同一解决方案的 3 个向量中的数字连接在一起。换句话说，为两个列表调用这个函数将返回一个新的单个列表，其中包含两个列表中的数字。这适合于为每个解决方案创建一个 1D 染色体。但是<strong class="km ir"> numpy.append() </strong>将为每个解决方案返回三个列表。为两个列表调用它，它返回一个新的列表，该列表被分成两个子列表。这不是我们的目标。最后，函数<strong class="km ir"> mat_to_vector() </strong>以 NumPy 数组的形式返回群体解，以便于以后操作。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="bf37" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">实施 GA 步骤</h1><p id="5709" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">在将所有解从矩阵转换为向量并连接在一起后，我们准备好执行名为“<strong class="km ir">遗传算法优化简介</strong>”的教程中讨论的遗传算法步骤。这些步骤在<strong class="km ir">主图</strong>中介绍，也在下图中总结。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/d3bb8efa29c5d260cd5fc765dc5d9f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KenWhL8FnRHflkVYenhtHA.png"/></div></div></figure><p id="b12a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">请记住，GA 使用适应度函数来返回每个解决方案的适应度值。适应值越高，解决方案越好。最佳解决方案在<strong class="km ir">父选择</strong>步骤中作为父返回。</p><p id="68c5" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">诸如 ANN 之类的分类器的常见适应度函数之一是准确性。它是正确分类的样本与样本总数之间的比率。它是根据下一个等式计算的。根据<strong class="km ir">主图</strong>中的步骤计算每个解决方案的分类精度。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5602e176b62f70129d824c213d320949.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*2uB29jyAbdzDhrY4GdTsew.jpeg"/></div></figure><p id="ff0b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">每个解的单个 1D 向量被转换回 3 个矩阵，每层一个矩阵(2 个隐藏和 1 个输出)。使用名为<strong class="km ir"> vector_to_mat() </strong>的函数进行转换。它在下一段代码中定义。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="7114" class="mw lj iq ms b gy mx my l mz na"><strong class="ms ir">def </strong>vector_to_mat(vector_pop_weights, mat_pop_weights):<br/>    mat_weights = []<br/>    <strong class="ms ir">for </strong>sol_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[0]):<br/>        start = 0<br/>        end = 0<br/>        <strong class="ms ir">for </strong>layer_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[1]):<br/>            end = end + mat_pop_weights[sol_idx, layer_idx].size<br/>            curr_vector = vector_pop_weights[sol_idx, start:end]<br/>            mat_layer_weights = numpy.reshape(curr_vector, newshape=(mat_pop_weights[sol_idx, layer_idx].shape))<br/>            mat_weights.append(mat_layer_weights)<br/>            start = end<br/>    <strong class="ms ir">return </strong>numpy.reshape(mat_weights, newshape=mat_pop_weights.shape)</span></pre><p id="4f64" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它逆转了先前所做的工作。但是有一个重要的问题。如果给定解的向量只是一片，我们如何能分裂成三个不同的部分，每个部分代表一个矩阵？输入层和隐藏层之间的第一个参数矩阵的大小是 102x150。当转换成向量时，它的长度将是 15，300。因为根据<strong class="km ir"> mat_to_vector() </strong>函数，它是要插入到<strong class="km ir"> curr_vector </strong>变量中的第一个向量，所以它的索引从索引 0 开始，到索引 15，299 结束。<strong class="km ir"> mat_pop_weights </strong>用作<strong class="km ir"> vector_to_mat() </strong>函数的参数，以了解每个矩阵的大小。我们对使用来自<strong class="km ir"> mat_pop_weights </strong>变量的权重不感兴趣，只是使用了其中的矩阵大小。</p><p id="a2a3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">对于同一解决方案中的第二个向量，它将是转换大小为 150x60 的矩阵的结果。因此，向量长度为 9000。这样的向量被插入到长度为 15，300 的前一个向量之前的变量<strong class="km ir"> curr_vector </strong>中。因此，它将从索引 15，300 开始，到索引 15，300+9，000–1 = 24，299 结束。使用-1 是因为 Python 从 0 开始索引。对于从大小为 60×4 的参数矩阵创建的最后一个向量，其长度为 240。因为它被添加到<strong class="km ir"> curr_vector </strong>变量中正好在长度为 9000 的前一个向量之后，所以它的索引将在它之后开始。也就是说，它的开始索引是 24，300，结束索引是 24，300+240–1 = 24，539。因此，我们可以成功地将向量恢复为原始的 3 个矩阵。</p><p id="6052" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为每个解决方案返回的矩阵用于预测所用数据集中 1，962 个样本中每个样本的类别标签，以计算精确度。根据下一个代码，这是使用两个函数完成的，它们是<strong class="km ir">预测输出()</strong>和<strong class="km ir">适应度()</strong>。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="51e0" class="mw lj iq ms b gy mx my l mz na"><strong class="ms ir">def </strong>predict_outputs(weights_mat, data_inputs, data_outputs, activation=<strong class="ms ir">"relu"</strong>):<br/>    predictions = numpy.zeros(shape=(data_inputs.shape[0]))<br/>    <strong class="ms ir">for </strong>sample_idx <strong class="ms ir">in </strong>range(data_inputs.shape[0]):<br/>        r1 = data_inputs[sample_idx, :]<br/>        <strong class="ms ir">for </strong>curr_weights <strong class="ms ir">in </strong>weights_mat:<br/>            r1 = numpy.matmul(a=r1, b=curr_weights)<br/>            <strong class="ms ir">if </strong>activation == <strong class="ms ir">"relu"</strong>:<br/>                r1 = relu(r1)<br/>            <strong class="ms ir">elif </strong>activation == <strong class="ms ir">"sigmoid"</strong>:<br/>                r1 = sigmoid(r1)<br/>        predicted_label = numpy.where(r1 == numpy.max(r1))[0][0]<br/>        predictions[sample_idx] = predicted_label<br/>    correct_predictions = numpy.where(predictions == data_outputs)[0].size<br/>    accuracy = (correct_predictions/data_outputs.size)*100<br/>    <strong class="ms ir">return </strong>accuracy, predictions<br/><br/><strong class="ms ir">def </strong>fitness(weights_mat, data_inputs, data_outputs, activation=<strong class="ms ir">"relu"</strong>):<br/>    accuracy = numpy.empty(shape=(weights_mat.shape[0]))<br/>    <strong class="ms ir">for </strong>sol_idx <strong class="ms ir">in </strong>range(weights_mat.shape[0]):<br/>        curr_sol_mat = weights_mat[sol_idx, :]<br/>        accuracy[sol_idx], _ = predict_outputs(curr_sol_mat, data_inputs, data_outputs, activation=activation)<br/>    <strong class="ms ir">return </strong>accuracy</span></pre><p id="3b6d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> predict_outputs() </strong>函数接受训练数据的单个解决方案、输入和输出的权重，以及指定使用哪个激活函数的可选参数。它只返回一个解的精度，而不是群体中所有解的精度。为了返回群体中所有解的适应度值(即精度)，函数<strong class="km ir"> fitness() </strong>遍历每个解，将其传递给函数<strong class="km ir"> predict_outputs() </strong>，将所有解的精度存储到数组<strong class="km ir">精度</strong>中，并最终返回这样一个数组。</p><p id="79f0" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在计算了所有解决方案的适应值(即精度)后，主图中 GA 的剩余步骤以与之前相同的方式应用。最佳亲本根据其准确性被选入交配池。然后应用变异和交叉变异来产生后代。新一代的群体是利用后代和父母两者创建的。这些步骤要重复几代。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="06b3" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">完整的 Python 实现</h1><p id="cc71" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">此类项目的 Python 实现有三个 Python 文件:</p><ol class=""><li id="7772" class="nd ne iq km b kn ko kr ks kv nf kz ng ld nh lh ni nj nk nl bi translated"><strong class="km ir"> ga.py </strong>用于实现 ga 功能。</li><li id="92a9" class="nd ne iq km b kn nm kr nn kv no kz np ld nq lh ni nj nk nl bi translated"><strong class="km ir"> ANN.py </strong>用于实现 ANN 功能。</li><li id="811d" class="nd ne iq km b kn nm kr nn kv no kz np ld nq lh ni nj nk nl bi translated">第三个文件，用于通过若干代调用此类函数。这是项目的主文件。</li></ol></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="350a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">主项目文件实现</h1><p id="dba5" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">第三个文件是主文件，因为它连接了所有的函数。它读取特征和类标签文件，基于标准偏差过滤特征，创建 ANN 体系结构，生成初始解决方案，通过计算所有解决方案的适应度值、选择最佳父代、应用交叉和变异并最终创建新群体来循环通过若干代。下面给出了它的实现。这样的文件定义了 GA 参数，例如每个种群的解的数量、选择的亲本的数量、突变百分比和代的数量。您可以为它们尝试不同的值。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="7566" class="mw lj iq ms b gy mx my l mz na"><strong class="ms ir">import </strong>numpy<br/><strong class="ms ir">import </strong>GA<br/><strong class="ms ir">import </strong>pickle<br/><strong class="ms ir">import </strong>ANN<br/><strong class="ms ir">import </strong>matplotlib.pyplot<br/><br/>f = open(<strong class="ms ir">"dataset_features.pkl"</strong>, <strong class="ms ir">"rb"</strong>)<br/>data_inputs2 = pickle.load(f)<br/>f.close()<br/>features_STDs = numpy.std(a=data_inputs2, axis=0)<br/>data_inputs = data_inputs2[:, features_STDs&gt;50]<br/><br/><br/>f = open(<strong class="ms ir">"outputs.pkl"</strong>, <strong class="ms ir">"rb"</strong>)<br/>data_outputs = pickle.load(f)<br/>f.close()<br/><br/><em class="nr">#Genetic algorithm parameters:<br/>#    Mating Pool Size (Number of Parents)<br/>#    Population Size<br/>#    Number of Generations<br/>#    Mutation Percent<br/><br/></em>sol_per_pop = 8<br/>num_parents_mating = 4<br/>num_generations = 1000<br/>mutation_percent = 10<br/><br/><em class="nr">#Creating the initial population.<br/></em>initial_pop_weights = []<br/><strong class="ms ir">for </strong>curr_sol <strong class="ms ir">in </strong>numpy.arange(0, sol_per_pop):<br/>    HL1_neurons = 150<br/>    input_HL1_weights = numpy.random.uniform(low=-0.1, high=0.1, <br/><br/>                                             size=(data_inputs.shape[1], HL1_neurons))<br/><br/>    HL2_neurons = 60<br/>    HL1_HL2_weights = numpy.random.uniform(low=-0.1, high=0.1, <br/><br/>                                             size=(HL1_neurons, HL2_neurons))<br/><br/>    output_neurons = 4<br/>    HL2_output_weights = numpy.random.uniform(low=-0.1, high=0.1, <br/><br/>                                              size=(HL2_neurons, output_neurons))<br/><br/>    initial_pop_weights.append(numpy.array([input_HL1_weights, <br/><br/>                                                HL1_HL2_weights, <br/><br/>                                                HL2_output_weights]))<br/><br/>pop_weights_mat = numpy.array(initial_pop_weights)<br/>pop_weights_vector = ga.mat_to_vector(pop_weights_mat)<br/><br/>best_outputs = []<br/>accuracies = numpy.empty(shape=(num_generations))<br/><br/><strong class="ms ir">for </strong>generation <strong class="ms ir">in </strong>range(num_generations):<br/>    print(<strong class="ms ir">"Generation : "</strong>, generation)<br/><br/>    <em class="nr"># converting the solutions from being vectors to matrices.<br/>    </em>pop_weights_mat = ga.vector_to_mat(pop_weights_vector, <br/>                                       pop_weights_mat)<br/><br/>    <em class="nr"># Measuring the fitness of each chromosome in the population.<br/>    </em>fitness = ANN.fitness(pop_weights_mat, <br/>                          data_inputs, <br/>                          data_outputs, <br/>                          activation=<strong class="ms ir">"sigmoid"</strong>)<br/><br/>    accuracies[generation] = fitness[0]<br/>    print(<strong class="ms ir">"Fitness"</strong>)<br/>    print(fitness)<br/><br/>    <em class="nr"># Selecting the best parents in the population for mating.<br/>    </em>parents = ga.select_mating_pool(pop_weights_vector, <br/><br/>                                    fitness.copy(), <br/><br/>                                    num_parents_mating)<br/>    print(<strong class="ms ir">"Parents"</strong>)<br/>    print(parents)<br/><br/>    <em class="nr"># Generating next generation using crossover.<br/>    </em>offspring_crossover = ga.crossover(parents,<br/><br/>                                       offspring_size=(pop_weights_vector.shape[0]-parents.shape[0], pop_weights_vector.shape[1]))<br/><br/>    print(<strong class="ms ir">"Crossover"</strong>)<br/>    print(offspring_crossover)<br/><br/>    <em class="nr"># Adding some variations to the offsrping using mutation.<br/>    </em>offspring_mutation = ga.mutation(offspring_crossover, <br/><br/>                                     mutation_percent=mutation_percent)<br/>    print(<strong class="ms ir">"Mutation"</strong>)<br/>    print(offspring_mutation)<br/><br/>    <em class="nr"># Creating the new population based on the parents and offspring.<br/>    </em>pop_weights_vector[0:parents.shape[0], :] = parents<br/>    pop_weights_vector[parents.shape[0]:, :] = offspring_mutation<br/><br/>pop_weights_mat = ga.vector_to_mat(pop_weights_vector, pop_weights_mat)<br/>best_weights = pop_weights_mat [0, :]<br/>acc, predictions = ANN.predict_outputs(best_weights, data_inputs, data_outputs, activation=<strong class="ms ir">"sigmoid"</strong>)<br/>print(<strong class="ms ir">"Accuracy of the best solution is : "</strong>, acc)<br/><br/>matplotlib.pyplot.plot(accuracies, linewidth=5, color=<strong class="ms ir">"black"</strong>)<br/>matplotlib.pyplot.xlabel(<strong class="ms ir">"Iteration"</strong>, fontsize=20)<br/>matplotlib.pyplot.ylabel(<strong class="ms ir">"Fitness"</strong>, fontsize=20)<br/>matplotlib.pyplot.xticks(numpy.arange(0, num_generations+1, 100), fontsize=15)<br/>matplotlib.pyplot.yticks(numpy.arange(0, 101, 5), fontsize=15)<br/><br/>f = open(<strong class="ms ir">"weights_"</strong>+str(num_generations)+<strong class="ms ir">"_iterations_"</strong>+str(mutation_percent)+<strong class="ms ir">"%_mutation.pkl"</strong>, <strong class="ms ir">"wb"</strong>)<br/>pickle.dump(pop_weights_mat, f)<br/>f.close()</span></pre><p id="e0d8" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">基于 1000 代，使用<strong class="km ir"> Matplotlib </strong>可视化库在该文件的末尾创建了一个图，该图显示了精度在每代之间如何变化。如下图所示。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/365435d722f8df530a69c949e31a4ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdIbL6CfZ-7tuLZhDRaZ3A.png"/></div></div></figure><p id="f99f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">经过 1000 次迭代，准确率达到 97%以上。相比之下，在之前的教程中，如果不使用优化技术，这一比例为 45%。这是为什么结果可能不好的证据，不是因为模型或数据有问题，而是因为没有使用优化技术。当然，对参数使用不同的值，比如 10，000 代，可能会提高精度。在这个文件的末尾，它将参数以矩阵的形式保存到磁盘上以备后用。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="b853" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">遗传算法实现</h1><p id="46f0" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">下面列出了<strong class="km ir"> ga.py </strong>文件的实现。注意，<strong class="km ir"> mutation() </strong>函数接受<strong class="km ir"> mutation_percent </strong>参数，该参数定义了随机改变其值的基因数量。它在主文件中被设置为 10%。这样的文件包含两个新函数<strong class="km ir"> mat_to_vector() </strong>和<strong class="km ir"> vector_to_mat() </strong>。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="569c" class="mw lj iq ms b gy mx my l mz na"><strong class="ms ir">import </strong>numpy<br/><strong class="ms ir">import </strong>random<br/><br/><em class="nr"># Converting each solution from matrix to vector.<br/></em><strong class="ms ir">def </strong>mat_to_vector(mat_pop_weights):<br/>    pop_weights_vector = []<br/>    <strong class="ms ir">for </strong>sol_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[0]):<br/>        curr_vector = []<br/>        <strong class="ms ir">for </strong>layer_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[1]):<br/>            vector_weights = numpy.reshape(mat_pop_weights[sol_idx, layer_idx], newshape=(mat_pop_weights[sol_idx, layer_idx].size))<br/>            curr_vector.extend(vector_weights)<br/>        pop_weights_vector.append(curr_vector)<br/>    <strong class="ms ir">return </strong>numpy.array(pop_weights_vector)<br/><br/><em class="nr"># Converting each solution from vector to matrix.<br/></em><strong class="ms ir">def </strong>vector_to_mat(vector_pop_weights, mat_pop_weights):<br/>    mat_weights = []<br/>    <strong class="ms ir">for </strong>sol_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[0]):<br/>        start = 0<br/>        end = 0<br/>        <strong class="ms ir">for </strong>layer_idx <strong class="ms ir">in </strong>range(mat_pop_weights.shape[1]):<br/>            end = end + mat_pop_weights[sol_idx, layer_idx].size<br/>            curr_vector = vector_pop_weights[sol_idx, start:end]<br/>            mat_layer_weights = numpy.reshape(curr_vector, newshape=(mat_pop_weights[sol_idx, layer_idx].shape))<br/>            mat_weights.append(mat_layer_weights)<br/>            start = end<br/>    <strong class="ms ir">return </strong>numpy.reshape(mat_weights, newshape=mat_pop_weights.shape)<br/><br/><strong class="ms ir">def </strong>select_mating_pool(pop, fitness, num_parents):<br/>    <em class="nr"># Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.<br/>    </em>parents = numpy.empty((num_parents, pop.shape[1]))<br/>    <strong class="ms ir">for </strong>parent_num <strong class="ms ir">in </strong>range(num_parents):<br/>        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))<br/>        max_fitness_idx = max_fitness_idx[0][0]<br/>        parents[parent_num, :] = pop[max_fitness_idx, :]<br/>        fitness[max_fitness_idx] = -99999999999<br/>    <strong class="ms ir">return </strong>parents<br/><br/><strong class="ms ir">def </strong>crossover(parents, offspring_size):<br/>    offspring = numpy.empty(offspring_size)<br/>    <em class="nr"># The point at which crossover takes place between two parents. Usually, it is at the center.<br/>    </em>crossover_point = numpy.uint32(offspring_size[1]/2)<br/>    <strong class="ms ir">for </strong>k <strong class="ms ir">in </strong>range(offspring_size[0]):<br/>        <em class="nr"># Index of the first parent to mate.<br/>        </em>parent1_idx = k%parents.shape[0]<br/>        <em class="nr"># Index of the second parent to mate.<br/>        </em>parent2_idx = (k+1)%parents.shape[0]<br/>        <em class="nr"># The new offspring will have its first half of its genes taken from the first parent.<br/>        </em>offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]<br/>        <em class="nr"># The new offspring will have its second half of its genes taken from the second parent.<br/>        </em>offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]<br/>    <strong class="ms ir">return </strong>offspring<br/><br/><br/><strong class="ms ir">def </strong>mutation(offspring_crossover, mutation_percent):<br/>    num_mutations = numpy.uint32((mutation_percent*offspring_crossover.shape[1])/100)<br/>    mutation_indices = numpy.array(random.sample(range(0, offspring_crossover.shape[1]), num_mutations))<br/>    <em class="nr"># Mutation changes a single gene in each offspring randomly.<br/>    </em><strong class="ms ir">for </strong>idx <strong class="ms ir">in </strong>range(offspring_crossover.shape[0]):<br/>        <em class="nr"># The random value to be added to the gene.<br/>        </em>random_value = numpy.random.uniform(-1.0, 1.0, 1)<br/>        offspring_crossover[idx, mutation_indices] = offspring_crossover[idx, mutation_indices] + random_value<br/>    <strong class="ms ir">return </strong>offspring_crossover</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="91be" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">ANN.py 实现</h1><p id="b142" class="pw-post-body-paragraph kk kl iq km b kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ij bi translated">最后，根据下面列出的代码实现<strong class="km ir"> ANN.py </strong>。它包含激活函数(sigmoid 和 ReLU)的实现，以及用于计算精度的<strong class="km ir">适应度()</strong>和<strong class="km ir">预测输出()</strong>函数。</p><pre class="mm mn mo mp gt mr ms mt mu aw mv bi"><span id="8602" class="mw lj iq ms b gy mx my l mz na"><strong class="ms ir">import </strong>numpy<br/><br/><strong class="ms ir">def </strong>sigmoid(inpt):<br/>    <strong class="ms ir">return </strong>1.0 / (1.0 + numpy.exp(-1 * inpt))<br/><br/><strong class="ms ir">def </strong>relu(inpt):<br/>    result = inpt<br/>    result[inpt &lt; 0] = 0<br/>    <strong class="ms ir">return </strong>result<br/><br/><strong class="ms ir">def </strong>predict_outputs(weights_mat, data_inputs, data_outputs, activation=<strong class="ms ir">"relu"</strong>):<br/>    predictions = numpy.zeros(shape=(data_inputs.shape[0]))<br/>    <strong class="ms ir">for </strong>sample_idx <strong class="ms ir">in </strong>range(data_inputs.shape[0]):<br/>        r1 = data_inputs[sample_idx, :]<br/>        <strong class="ms ir">for </strong>curr_weights <strong class="ms ir">in </strong>weights_mat:<br/>            r1 = numpy.matmul(a=r1, b=curr_weights)<br/>            <strong class="ms ir">if </strong>activation == <strong class="ms ir">"relu"</strong>:<br/>                r1 = relu(r1)<br/>            <strong class="ms ir">elif </strong>activation == <strong class="ms ir">"sigmoid"</strong>:<br/>                r1 = sigmoid(r1)<br/>        predicted_label = numpy.where(r1 == numpy.max(r1))[0][0]<br/>        predictions[sample_idx] = predicted_label<br/>    correct_predictions = numpy.where(predictions == data_outputs)[0].size<br/>    accuracy = (correct_predictions / data_outputs.size) * 100<br/>    <strong class="ms ir">return </strong>accuracy, predictions<br/><br/><strong class="ms ir">def </strong>fitness(weights_mat, data_inputs, data_outputs, activation=<strong class="ms ir">"relu"</strong>):<br/>    accuracy = numpy.empty(shape=(weights_mat.shape[0]))<br/>    <strong class="ms ir">for </strong>sol_idx <strong class="ms ir">in </strong>range(weights_mat.shape[0]):<br/>        curr_sol_mat = weights_mat[sol_idx, :]<br/>        accuracy[sol_idx], _ = predict_outputs(curr_sol_mat, data_inputs, data_outputs, activation=activation)<br/>    <strong class="ms ir">return </strong>accuracy</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="3cc7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">资源</h1><ul class=""><li id="6b59" class="nd ne iq km b kn mg kr mh kv nt kz nu ld nv lh nw nj nk nl bi translated">遗传算法优化导论</li></ul><p id="633f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/introduction-优化-遗传-算法-ahmed-gad/ </a></p><p id="9224" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.kdnuggets.com/2018/03/introduction-optimization-with-genetic-algorithm.html" rel="noopener ugc nofollow" target="_blank">https://www . kdnugges . com/2018/03/introduction-optimization-with-genetic-algorithm . html</a></p><p id="1b50" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b">https://towards data science . com/introduction-to-optimization-with-genetic algorithm-2f 5001d 9964 b</a></p><p id="0a0f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.springer.com/us/book/9781484241660" rel="noopener ugc nofollow" target="_blank">https://www.springer.com/us/book/9781484241660</a></p><ul class=""><li id="c7b5" class="nd ne iq km b kn ko kr ks kv nf kz ng ld nh lh nw nj nk nl bi translated">遗传算法(GA)优化—分步示例</li></ul><p id="b59e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/AhmedGadFCIT/genetic-algorithm-ga-optimization-step by step-example</a></p><ul class=""><li id="26fb" class="nd ne iq km b kn ko kr ks kv nf kz ng ld nh lh nw nj nk nl bi translated">遗传算法在 Python 中的实现</li></ul><p id="243e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/genetic-algorithm-implementation-python-Ahmed-gad/</a></p><p id="eb38" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.kdnuggets.com/2018/07/genetic-algorithm-implementation-python.html" rel="noopener ugc nofollow" target="_blank">https://www . kdnugges . com/2018/07/genetic-algorithm-implementation-python . html</a></p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/genetic-algorithm-implementation-in-python-5ab67bb124a6"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">遗传算法在 Python 中的实现</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">本教程将基于一个简单的例子用 Python 实现遗传算法优化技术，其中…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo jw oa"/></div></div></a></div><p id="2202" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://github.com/ahmedfgad/GeneticAlgorithmPython" rel="noopener ugc nofollow" target="_blank">https://github.com/ahmedfgad/GeneticAlgorithmPython</a></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="bb82" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">联系作者</h1><ul class=""><li id="0664" class="nd ne iq km b kn mg kr mh kv nt kz nu ld nv lh nw nj nk nl bi translated">领英:<a class="ae kc" href="https://linkedin.com/in/ahmedfgad/" rel="noopener ugc nofollow" target="_blank">https://linkedin.com/in/ahmedfgad</a></li><li id="f8ea" class="nd ne iq km b kn nm kr nn kv no kz np ld nq lh nw nj nk nl bi translated">GitHub:<a class="ae kc" href="https://github.com/ahmedfgad" rel="noopener ugc nofollow" target="_blank">https://github.com/ahmedfgad</a></li></ul></div></div>    
</body>
</html>