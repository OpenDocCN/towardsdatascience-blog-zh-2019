<html>
<head>
<title>Find Lowest Common Ancestor Subtree and Shortest Dependency Path with spaCy Only</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅用空间查找最低公共祖先子树和最短依赖路径</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-lowest-common-ancestor-subtree-and-shortest-dependency-path-with-spacy-only-32da4d107d7a?source=collection_archive---------13-----------------------#2019-08-18">https://towardsdatascience.com/find-lowest-common-ancestor-subtree-and-shortest-dependency-path-with-spacy-only-32da4d107d7a?source=collection_archive---------13-----------------------#2019-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d14" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用空间作为一个解决所有问题的工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9123c63e79450e92c3b94390d52cffe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1BMM7QGJrtoDXKxiBbpNw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@paulamayphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Paula May</a> on <a class="ae ky" href="https://unsplash.com/search/photos/path?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的帖子:<a class="ae ky" rel="noopener" target="_blank" href="/how-to-find-shortest-dependency-path-with-spacy-and-stanfordnlp-539d45d28239?source=your_stories_page---------------------------">如何用 spaCy 和 StanfordNLP 寻找最短依赖路径</a>中，我讲过如何用 spaCy 和 NetworkX 提取最短依赖路径(SDP)。</p><p id="da36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是使用 NetworkX 有个问题。我们无法获得头部实体或尾部实体的索引。例如，我们有下面的句子。三联是<code class="fe lv lw lx ly b">Convulsions-&gt;(caused_by)-&gt;fever</code>。但是这句话里有两个<code class="fe lv lw lx ly b">fever</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5927" class="md me it ly b gy mf mg l mh mi">Convulsions that occur after DTaP are caused by a fever, and fever may cause headache.</span></pre><h1 id="dbf9" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">NetworkX 解决方案</h1><p id="4bda" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">一个解决方案是为每个令牌添加一个索引，并指定要查找哪个<code class="fe lv lw lx ly b">fever</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="60d9" class="md me it ly b gy mf mg l mh mi">import spacy<br/>import networkx as nx<br/>nlp = spacy.load("en_core_web_sm")<br/>doc = nlp(u'Convulsions that occur after DTaP are caused by a fever, and fever may cause headache.')</span><span id="1544" class="md me it ly b gy nf mg l mh mi"># Add pair to edges<br/>edges = []<br/>for token in doc:<br/>    for child in token.children:<br/>        <strong class="ly iu">edges.append(('{0}-{1}'.format(token.text, token.i),<br/>                      '{0}-{1}'.format(child.text, child.i)))</strong></span><span id="fca6" class="md me it ly b gy nf mg l mh mi"># Construct Graph with nextworkx<br/>graph = nx.Graph(edges)</span><span id="3f29" class="md me it ly b gy nf mg l mh mi"># Get the length and path<br/><strong class="ly iu">entity1 = 'Convulsions-0'<br/>entity2 = 'fever-9'</strong></span><span id="a545" class="md me it ly b gy nf mg l mh mi">print(nx.shortest_path_length(graph, source=entity1, target=entity2))<br/>print(nx.shortest_path(graph, source=entity1, target=entity2))</span><span id="a095" class="md me it ly b gy nf mg l mh mi">##### output #####<br/>3<br/>['Convulsions-0', 'caused-6', 'by-7', 'fever-9']</span></pre><p id="6359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的<code class="fe lv lw lx ly b">edges</code>看起来像。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7674" class="md me it ly b gy mf mg l mh mi">In [6]: edges<br/>Out[6]:<br/>[('Convulsions-0', 'occur-2'),<br/> ('occur-2', 'that-1'),<br/> ('occur-2', 'after-3'),<br/> ('caused-6', 'Convulsions-0'),<br/> ('caused-6', 'DTaP-4'),<br/> ('caused-6', 'are-5'),<br/> ('caused-6', 'by-7'),<br/> ('caused-6', ',-10'),<br/> ('caused-6', 'and-11'),<br/> ('caused-6', 'cause-14'),<br/> ('by-7', 'fever-9'),<br/> ('fever-9', 'a-8'),<br/> ('cause-14', 'fever-12'),<br/> ('cause-14', 'may-13'),<br/> ('cause-14', 'headache-15'),<br/> ('cause-14', '.-16')]</span></pre><p id="3e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以确保尾部实体令牌是<code class="fe lv lw lx ly b">fever-9</code>而不是<code class="fe lv lw lx ly b">fever-12</code>。</p><p id="ce22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案有点麻烦，因为 NetworkX 只接受字符串类型，我们必须在字符串中包含这样的信息。</p><h1 id="21e5" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">只有空间的解决方案</h1><p id="5908" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">sapCy 中的<a class="ae ky" href="https://spacy.io/api/token" rel="noopener ugc nofollow" target="_blank">令牌类</a>非常强大。它在每个标记中都有索引信息。但是怎么用 spaCy 找 SDP 呢？</p><p id="c85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一些研究，我发现我们可以利用<a class="ae ky" href="https://spacy.io/api/doc#get_lca_matrix" rel="noopener ugc nofollow" target="_blank"> get_lca_matrix </a>函数。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2a84" class="md me it ly b gy mf mg l mh mi">In [11]: doc = nlp(u"This is a test")<br/>    ...: lca_matrix = doc.get_lca_matrix()</span><span id="84dd" class="md me it ly b gy nf mg l mh mi">In [12]: lca_matrix<br/>Out[12]:<br/>array([[0, 1, 1, 1],<br/>       [1, 1, 1, 1],<br/>       [1, 1, 2, 3],<br/>       [1, 1, 3, 3]], dtype=int32)</span></pre><blockquote class="ng nh ni"><p id="bbdd" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">Doc.get_lca_matrix:计算给定<code class="fe lv lw lx ly b"><em class="it">Doc</em></code>的最低公共祖先(lca)矩阵。返回包含祖先整数索引的 LCA 矩阵，如果没有找到共同祖先，则返回<code class="fe lv lw lx ly b"><em class="it">-1</em></code>。</p></blockquote><p id="25ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这个函数来查找 SDP。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="07f1" class="md me it ly b gy mf mg l mh mi">import spacy<br/>nlp = spacy.load("en_core_web_sm")</span><span id="cdc6" class="md me it ly b gy nf mg l mh mi">doc = nlp(u'Convulsions that occur after DTaP are caused by a fever, and fever may cause headache.')</span><span id="6064" class="md me it ly b gy nf mg l mh mi"><strong class="ly iu">def get_sdp_path(doc, subj, obj, lca_matrix):<br/></strong>  lca = lca_matrix[subj, obj]<br/>  <br/>  current_node = doc[subj]<br/>  subj_path = [current_node]<br/>  if lca != -1: <br/>    if lca != subj: <br/>      while current_node.head.i != lca:<br/>        current_node = current_node.head<br/>        subj_path.append(current_node)<br/>      subj_path.append(current_node.head)</span><span id="565c" class="md me it ly b gy nf mg l mh mi">current_node = doc[obj]<br/>  obj_path = [current_node]<br/>  if lca != -1: <br/>    if lca != obj: <br/>      while current_node.head.i != lca:<br/>        current_node = current_node.head<br/>        obj_path.append(current_node)<br/>      obj_path.append(current_node.head)<br/>  <br/>  return subj_path + obj_path[::-1][1:]<br/>  <br/># set head entity index and tail entity index<br/><strong class="ly iu">head = 0<br/>tail = 9</strong><br/>  <br/><strong class="ly iu">sdp = get_sdp_path(doc, head, tail, doc.get_lca_matrix())<br/></strong>print(sdp)</span><span id="3369" class="md me it ly b gy nf mg l mh mi">##### output #####<br/>[Convulsions, caused, by, fever]</span></pre><p id="618d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">get_sdp_path()</code>可以找到头实体和尾实体之间的 SDP。我们唯一需要的是输入头部实体索引和尾部实体索引。</p><p id="934b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">get_sdp_path()</code>函数中，它实际上首先找到从头实体到 LCA 令牌的<strong class="lb iu"> SDP 路径</strong>，然后找到从尾实体到 LCA 令牌的<strong class="lb iu"> SDP 路径</strong>。最后，我们将两个子树组合在一起并返回结果。</p><blockquote class="ng nh ni"><p id="ece0" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">查看我的其他帖子</em> </strong> <a class="ae ky" href="https://medium.com/@bramblexu" rel="noopener"> <strong class="lb iu"> <em class="it">中</em> </strong> </a> <strong class="lb iu"> <em class="it">同</em> </strong> <a class="ae ky" href="https://bramblexu.com/posts/eb7bd472/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="it">一个分类查看</em> </strong> </a> <strong class="lb iu"> <em class="it">！<br/>GitHub:</em></strong><a class="ae ky" href="https://github.com/BrambleXu" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="it">bramble Xu</em></strong></a><strong class="lb iu"><em class="it"><br/>LinkedIn:</em></strong><a class="ae ky" href="https://www.linkedin.com/in/xu-liang-99356891/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="it">徐亮</em> </strong> </a> <strong class="lb iu"> <em class="it"> <br/>博客:</em></strong><a class="ae ky" href="https://bramblexu.com" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="it">bramble Xu</em></strong></a></p></blockquote><h1 id="c541" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><ul class=""><li id="b19b" class="nn no it lb b lc na lf nb li np lm nq lq nr lu ns nt nu nv bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/how-to-find-shortest-dependency-path-with-spacy-and-stanfordnlp-539d45d28239?source=your_stories_page---------------------------">如何用 spaCy 和 StanfordNLP 找到最短依赖路径</a></li><li id="91e6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://spacy.io/api/doc#get_lca_matrix" rel="noopener ugc nofollow" target="_blank"> get_lca_matrix </a></li></ul></div></div>    
</body>
</html>