<html>
<head>
<title>Full Stack Machine Learning on Azure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure 上的全栈机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/full-stack-machine-learning-on-azure-f0f6b77be07e?source=collection_archive---------14-----------------------#2019-10-29">https://towardsdatascience.com/full-stack-machine-learning-on-azure-f0f6b77be07e?source=collection_archive---------14-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fdca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用 MERN 在 Azure 上构建全栈机器学习网站指南(Mongo，Express，React (Node.js)) </strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/786d0ea4b7273eed2f5513c4b3fd6716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O35ZUZzpKY9qgcryQqanxQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Tech stack and flow for <a class="ae le" href="http://diamonds.foostack.ai" rel="noopener ugc nofollow" target="_blank">http://diamonds.foostack.ai</a></figcaption></figure><p id="d051" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对最新技术感到生疏后，我决定同时学习一系列东西，并开发了<a class="ae le" href="http://diamonds.foostack.ai/" rel="noopener ugc nofollow" target="_blank"><em class="lf">http://diamonds . foo stack . ai</em></a>，现在已经上线。(<em class="lf">基础机器学习 app 给钻石定价</em>)。</p><p id="f2c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的女朋友让我给她买一枚钻戒，我告诉她“不，等等！！！我必须先建立一个定价应用程序/网站……(<em class="lf">在家试试</em>)”</p><p id="8983" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本博客中的步骤和章节概述:</p><ol class=""><li id="8d45" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">使用 Python 获取数据</li><li id="187a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">使用 ScikitLearn 在 Jupyter 笔记本电脑中培训 ML 模型</li><li id="0bbf" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">将 ML 模型部署到 Azure</li><li id="8ce8" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">在 React w/ Express 上构建前端</li><li id="ad4c" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">构建后端 Express，MongoDB</li><li id="77d4" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">Azure Web 应用部署和 CI/CD</li><li id="95a5" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">总结、提示和技巧</li></ol><p id="8c49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回顾我的 github 签到记录，这个项目花了我 1 个月(26 天)——可能每周花 8-10 个小时，所以大概 40 个小时以上。最终产品还不算太差:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lu"><img src="../Images/a6115b59531cdb8c99e483972ecb608a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f476b3iLMMWLa6KVuH_9Qw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="http://diamonds.foostack.ai" rel="noopener ugc nofollow" target="_blank">http://diamonds.foostack.ai</a></figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b8c0" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">步骤 1:获取数据</h1><p id="de10" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我在网上搜索好的钻石数据。我发现:</p><ul class=""><li id="a62c" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><a class="ae le" href="https://www.kaggle.com/shivam2503/diamonds" rel="noopener ugc nofollow" target="_blank"> Kaggle 的钻石数据集</a>有 50k 行，但与我找到的其他数据集进行交叉比较时，它似乎缺乏真实世界的定价准确性。</li><li id="eb08" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">其他“<a class="ae le" href="https://datasciencereview.com/case-study-does-the-size-of-diamonds-affect-its-price -- https://vincentarelbundock.github.io/Rdatasets/csv/Ecdat/Diamond.csv" rel="noopener ugc nofollow" target="_blank">实验数据集</a>”是旧的或者类似地与当前价格不同步。</li><li id="58ec" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">一些商业供应商出售更新的钻石库存/价格数据，但我不愿意付钱。</li><li id="f6ca" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">零售网站有数据，但需要搜集(bluenile.com，rarecarat.com 等)</li></ul><p id="8a4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解决:</strong>被爆料加强<a class="ae le" href="https://thenextweb.com/security/2019/09/10/us-court-says-scraping-a-site-without-permission-isnt-illegal/" rel="noopener ugc nofollow" target="_blank">刮不违法</a> —我在刮<strong class="js iu">BLUENILE.COM</strong>——(感谢<a class="ae le" href="https://amarder.github.io/diamonds/" rel="noopener ugc nofollow" target="_blank">安德鲁·马尔德</a>的首发码)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/2e03aa04d761fd2bbdfb2d4ac3d06cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X5UsqqrfwrG0-ifH.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">My source of data!</figcaption></figure><p id="f2b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安德鲁斯的代码基本有效，除了:</p><ul class=""><li id="8d9e" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated">它是用 Python 2.7 写的，所以有一些问题</li><li id="2b1e" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">自从他写了以后，网站上的数据格式改变了</li><li id="1d94" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">Bluenile 不断发展，目前已经阻止了运行此类脚本的吸血鬼</li></ul><p id="5bd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我唯一的黑客/贡献是在他们一直关闭我的时候添加重试循环:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="73c7" class="nm md it ni b gy nn no l np nq"># (bluenile API restricts to 1,000 page chunks at a time)<br/>home = requests.get('http://www.bluenile.com/')<br/>while True:<br/>   url = 'http://www.bluenile.com/api/public/diamond-search-grid/v2'<br/>   try:<br/>      response = requests.get(url, params, cookies=home.cookies)<br/>   except:  # request api exception, usually timeout<br/>      time.sleep(60*30)<br/>      next<br/>   if (response.ok == False):  # server may have disconnected us<br/>      time.sleep(60*30)<br/>      next<br/>   else:   # all going well<br/>      time.sleep(60*4)<br/>      next</span></pre><p id="0e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初的脚本进行了内联清理——我选择了下游清理(通常是个坏主意)。</p><p id="dcb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出示例 1 行(注意需要清理的＄逗号引号等):</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="b573" class="nm md it ni b gy nn no l np nq">carat,clarity,color,culet,cut,date,dateSet,depth,detailsPageUrl,fluorescence,hasVisualization,id,imageUrl,lxwRatio,measurements,polish,price,pricePerCarat,sellingIndex,shapeCode,shapeName,skus,symmetry,table,v360BaseUrl,visualizationImageUrl,willArriveForHoliday<br/>['0.23'],['FL'],['D'],['None'],"[{'label': 'Ideal', 'labelSmall': 'Ideal'}]",['Sep 30'],['Oct 1'],['58.8'],./diamond-details/LD12750672,['None'],[True],LD12750672,,['1.01'],"[{'label': '4.04 x 4.00 x 2.36 mm', 'labelSmall': '4.04 x 4.00 x 2.36'}]",['Excellent'],871,"['$3,787']",0.7348354,['RD'],['Round'],['LD12750672'],['Excellent'],['60.0'],https://bluenile.v360.in/50/imaged/gia-7313767639/1/,https://bnsec.bluenile.com/bnsecure/diamondvis/gia-7313767639/still_230x230.jpg,False</span></pre><p id="b83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我的抢劫成功了 14 万颗圆钻！我将这些保存到一个 CSV 文件中，用于清理和模型训练。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a31b" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak">第二步:用 Jupyter 和 SKLearn 训练模型</strong></h1><p id="55bf" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">Jupyter 笔记本很棒(看我的<a class="ae le" href="https://nbviewer.jupyter.org/github/dougfoo/machineLearning/blob/master/diamonds/Diamond-Analysis-4.ipynb" rel="noopener ugc nofollow" target="_blank">全笔记本</a>这里):</p><ul class=""><li id="6fdf" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated">当我试验不同的想法时，用简单的方法来注释我的想法——有助于以后修改或传递给其他人！</li><li id="05f3" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">比 VS 代码项目设置和运行更快——隔离细胞和独立运行的能力就像修改过的 REPL！</li><li id="3676" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">可视化更容易操作，因为您可以重新运行单元，只绘制图形，而不是重新运行整个程序！</li><li id="15cc" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated"><em class="lf">(上面的一些可以用调试器和 REPL shell 来完成，但是看起来更干净&amp;更容易在笔记本上重现)</em></li></ul><p id="5ea0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于数据清理，一些选项:</p><ol class=""><li id="4439" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">通过 python 脚本清理:CSV -&gt; scrub.py -&gt; CSV</li><li id="5160" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">在笔记本内拖动:CSV -&gt;笔记本-&gt; pandas/python -&gt; CSV</li><li id="b8a4" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">在数据库内部清理:CSV-&gt; MongoDB-&gt; SQL scrubbing-&gt; CSV</li><li id="190e" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">使用其他工具，如 Alteryx、Trifacta 或 Informatica</li></ol><p id="76e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选项#1 可以工作，但是为什么还要处理另一个脚本/env。#2 看起来是正确的方法，因为我们在 ML 之后使用 Python 和笔记本。#3 听起来我们在推迟不可避免的事情，而不是把垃圾放入数据库。#4 对像我这样的穷人来说不是一个真正的选择。</p><p id="8567" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用熊猫进行擦洗&amp;数据帧</strong></p><p id="a73e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">熊猫是令人惊奇的东西。加载我的 CSV 很容易，数据帧上的 describe()显示了一些基本的统计数据:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="256b" class="nm md it ni b gy nn no l np nq"><strong class="ni iu">import</strong> <strong class="ni iu">pandas</strong> <strong class="ni iu">as</strong> <strong class="ni iu">pd</strong><br/>diamonds5 = pd.read_csv('./blue-nile-download-round-full.csv')<br/>diamonds5.describe()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/e7d7f6ad0f11d82b977922eadd1ab835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3u5N1H8jkhvn_-rn.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">describe() and head() of the pandas.Dataframe</figcaption></figure><p id="70b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，数据存在一些问题，这是我的数据相关培训前任务清单:</p><ol class=""><li id="e5b6" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">确定在生产模型中使用哪些列</li><li id="52f0" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">将文本转换为干净的文本(即删除[])</li><li id="c11b" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">正确转换数字(删除$和，并删除[]和'')</li><li id="0523" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">处理关键字字段中的空值或超出范围的值</li><li id="41fa" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">剔除异常值(使用≤ 4.5 克拉，因为此后会变得稀疏)</li></ol><p id="660f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，我们对克拉和切工(颜色)进行一点视觉图形检查，以确定价格——使用 Jupyter 非常简单:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="0af9" class="nm md it ni b gy nn no l np nq">fig, ax = plt.subplots()<br/><strong class="ni iu">for</strong> c, df <strong class="ni iu">in</strong> diamonds5a.groupby('cut'):<br/>    ax.scatter(df['carat'], df['price'], label=c, s=np.pi*3)<br/>fig.set_size_inches(18.5, 10.5)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/e325b6d591c8e0389bd4d793a1211673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kQgVUftBSNfbdqtY.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Price to Carat (to Cut)</figcaption></figure><p id="6964" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然形状和深度等一些指标可能对预测有价值，但我真的想只关注 4-C——克拉、净度、颜色和切割(加上 sku，这是 BlueNile 中的 ID)。我可以放弃剩下的。</p><p id="a060" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">(注意，我发现烦人的 DataFrame 有一些 mutator 函数就地改变 obj，还有一些返回改变后的对象。似乎有点不一致？)</em></p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="8392" class="nm md it ni b gy nn no l np nq"># basic cleanup functions<br/>def cleanBracketsToF(x):<br/>    return float(cleanBracketsToS(x))def cleanBracketsToS(x):<br/>    return x.replace("['",'').replace("']",'')def cleanCut(str):<br/>    return str[str.index('label') + 9: str.index('labelSmall')-4]df.loc[:,'carat'] =   <br/>    df.loc[:,'carat'].to_frame().applymap(cleanBracketsToF)<br/>...</span><span id="959d" class="nm md it ni b gy nt no l np nq"><em class="lf"># clear nulls</em><br/>pd.set_option('use_inf_as_na', <strong class="ni iu">True</strong>)<br/>df = df.loc[~df['carat'].isnull()]<br/>...</span></pre><p id="389c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在清理并仅包括培训所需的列后，我们有了这个(第一列是熊猫 DF 标识符，它是内部的，以及我们稍后为培训删除但稍后为显示/链接回 bluenile.com 而包括的 SKU):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bf24d1baee5c2c7b036d955ce2519122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*q7idvwuSrWvqlIIB.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Pre column encoded</figcaption></figure><p id="f296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要转换非数字(切割，颜色，清晰度)。您有几个编码选项:</p><ol class=""><li id="fb13" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">Onehot 编码(可能是最常见的，将类别转换为二进制列)</li><li id="5e8a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">顺序映射，如果它是分级的/连续的(例如，对于颜色，D-&gt;0，E-&gt;1，F-&gt;2 …)或者反过来(K-&gt;0，J-&gt; 1…)</li></ol><p id="33db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用 sklearn 的 Pandas.get_dummies()调用去了 Onehot</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="a2f9" class="nm md it ni b gy nn no l np nq">cut = pd.get_dummies( diamonds5b['cut'], prefix='cut_')# result: cut__Astor Ideal', 'cut__Good', 'cut__Ideal','cut__Very Good'<br/># do the same for color, clarity...</span></pre><p id="9de0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> OneHot 编码</strong>我们的数据现在看起来像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/741073b979ad2d2ef421a2ddbb1e193b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nUO2S9ebtTd2N9C6.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Post OneHot encoded “cut”</figcaption></figure><p id="15e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我学到的一件棘手的事情是，如果你在一个 Hot 上对所有列进行编码，你可能会产生一个线性代数问题，这个问题是“奇异的”,这个小故事破坏了这个模型。阅读<a class="ae le" href="https://www.algosome.com/articles/dummy-variable-trap-regression.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">这篇关于</strong>的假人陷阱</a>。</p><p id="d7cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是将 one-hot 应用于所有列并测量系数的最终结果(将其视为每个特征的权重):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/c4c52603fb16d3be76c8ae307a24a6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WEf1aMJKtS3_ZuWj.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Column coefficients of for a linear model</figcaption></figure><p id="17a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是 reg 中的准确重量。_coeff</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="0388" class="nm md it ni b gy nn no l np nq">coefficients: [ 1122.35088004  -957.70046613   471.56252273  3604.24362627<br/>  3443.65378177  3128.96414383  2340.71261083  1717.39519952<br/>  1673.9767721    590.1060328  10566.54997464  1383.32878002<br/> -1131.5953868  -1340.53213295  -457.74564551  -848.77484115<br/>   540.46973926 15014.89306894]<br/>intercept: -8389.974398175218</span></pre><p id="5a3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着线性预测模型主要基于克拉(有道理)和完美无瑕的钻石。该等式的结果类似于:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="ef03" class="nm md it ni b gy nn no l np nq">y = -8389 + 1122*(cut == Astor ? 1: 0) + ….. + carat*15014)….</span></pre><p id="9c2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们为 1.0 克拉、切割理想、颜色 G、净度 VVS1 的钻石定价，计算结果为:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="01bc" class="nm md it ni b gy nn no l np nq">y = -8389 + 1*15014 (carats)+ 1*471 (cut)+ 1*2340 (color)+ 1*540 (clarity) = $9,976 </span></pre><p id="d886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 SKLearn 中训练一个模型——大部分代码是这样的。<em class="lf">警告——你可能会花很多时间调试错误的形状&amp;数组&amp;矩阵的方向！</em></p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="c08a" class="nm md it ni b gy nn no l np nq">regr = linear_model.LinearRegression()<br/>regr.fit(X_train, y_train)               # training<br/>y_pred = regr.predict(X_test)            # inference<br/>r2score = regr.score(X_test, y_test)     # get r2 score</span></pre><p id="3001" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">R2 分数值得一提——它不是一个“准确性”分数，所以不要期望得到 99%。这是对准确性/差异的一种衡量，更多信息请点击@ <a class="ae le" href="https://en.wikipedia.org/wiki/Coefficient_of_determination" rel="noopener ugc nofollow" target="_blank"> R2 维基</a>。</p><p id="2962" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我测试了其他的<a class="ae le" href="https://scikit-learn.org/stable/modules/linear_model.html" rel="noopener ugc nofollow" target="_blank"> SKLearn 模型</a>:岭回归、套索回归、保序回归(克拉上的单一特征)、弹性正则回归。较新的 AutoML 框架(H2O、DataRobot、Azure AutoML、SageMaker 等)同时测试所有模型&amp;超参数..让很多业余 DS 失业..</p><p id="2b74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我再次使用相同的数据集应用树和集成方法。尝试各种超参数组合后的最佳性能(R2)不足为奇 XGBoost:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="c746" class="nm md it ni b gy nn no l np nq">est = GradientBoostingRegressor(n_estimators=ne, learning_rate=lr,<br/>    max_depth=md, random_state=8, loss='ls').fit(X_train, y_train)<br/>score = est.score(X_test, y_test)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/b8e837abc7008b28d9805aefb6647f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S73bivhfRkYpubEI.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Rough feature weights w/ XGB</figcaption></figure><p id="50d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看特征权重——克拉是最高的，其他具有中等影响(有趣的是，完美无瑕的清晰度不如线性回归有影响力)。</p><p id="6291" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">系数对于确定每个特征的“重要性”可能不是最佳的。<a class="ae le" href="https://christophm.github.io/interpretable-ml-book/shapley.html" rel="noopener ugc nofollow" target="_blank"> Shapley 值</a>似乎更符合行业标准。</p><p id="d52d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦在笔记本中进行了训练，我们就使用 SKLearn 的 joblib 库导出所有经过训练的模型，以便稍后进行部署(该库将文件“pickless”或序列化为专有格式(<a class="ae le" href="https://www.benfrederickson.com/dont-pickle-your-data/" rel="noopener ugc nofollow" target="_blank">阅读 pickle 的一些不好的方面</a>))。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="5e0e" class="nm md it ni b gy nn no l np nq">joblib.dump(value=regr_full, filename='regr_model.pkl')<br/>joblib.dump(value=model, filename='xgb_model.pkl')<br/>joblib.dump(value=rfr, filename='randomforest_model.pkl')<br/>joblib.dump(value=iso_reg, filename='isoridgelineartreg_model.pkl')</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a88a" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">步骤 3:将模型部署到 Azure</h1><p id="7566" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">退一步说，我们有几种方法可以在生产中运行模型:</p><ol class=""><li id="cd24" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">将预先训练好的模型嵌入后端。在我们的例子中，我们使用的是 Express (Javascript ),这不是最好的嵌入方式..</li><li id="ad0c" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">将预先训练好的模型发布到某个地方(比如 Python Flask 容器),并通过 webservice 公开。</li><li id="30d5" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">使用像 Azure ML 这样的 API 发布和部署到他们的容器中。</li><li id="7a66" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">使用 Azure ML Studio 这样的框架进行设计、训练和发布(半自动)。</li></ol><p id="8b6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将做#2、#3 和#4</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/7d0d1b78b03d592186ccf0f1488eb68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f3jEq8nxZ8a16elr.png"/></div></div></figure><p id="2614" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步是在 Azure 上进行设置——如果这对你来说是新的，有几个基本步骤:</p><ol class=""><li id="29a9" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">在 portal.azure.com 上创建帐户</li><li id="26fa" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">你可以获得一段时间的免费订阅，但最终你可能需要创建一个付费订阅(小心$$$)。</li></ol><h1 id="d2b4" class="mc md it bd me mf nz mh mi mj oa ml mm mn ob mp mq mr oc mt mu mv od mx my mz bi translated">创建新的 ML 服务工作场所</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/18dd8bf4512f512b1e56a9f74bce0660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zDPYrOFxZc5l2f5G.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">New stuff in Azure — evolving fast</figcaption></figure><p id="1997" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用新的 Azure ML API(尽管你应该看看 ML GUI 工作区——你可以启动 Jupyter 笔记本，尝试他们的菜单驱动 AutoML，ML Studio Visual GUI(下图),以及其他现在不断变化的东西……</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/ca21dfa880f91104206baa672d5e3f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-S-yNkfwAHQRV9mj.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Drag-n-Drop ML… iffy distraction at best</figcaption></figure><h1 id="c3cd" class="mc md it bd me mf nz mh mi mj oa ml mm mn ob mp mq mr oc mt mu mv od mx my mz bi translated"><strong class="ak">通过 Python API 设置模型</strong></h1><p id="ddbf" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">使用 API 在 Azure 上设置服务有几个步骤</p><ol class=""><li id="1971" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">注册你的模型(你的泡菜。pkl]文件)</li><li id="bd5b" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">设置环境文件和评分回调文件(。py 接口)</li><li id="724f" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">设置 web 服务(AciWebService)、模型、推理配置和部署。</li></ol><p id="4a64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注册</strong>真的很简单，每个模型做一次(pkl 文件):</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="b4c2" class="nm md it ni b gy nn no l np nq">ws = Workspace.get(name='DiamondMLWS',<br/>    subscription_id='****',resource_group='diamond-ml')new_model = Model.register(model_path="mymodel.pkl"model_name=name,<br/>    description="mymodel descr",workspace=ws)</span></pre><p id="f6fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Env </strong>文件可以用这样的脚本生成(一次):</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="075c" class="nm md it ni b gy nn no l np nq">myenv = CondaDependencies.create(conda_packages=['numpy',<br/>   'scikit-learn'])<br/>with open("myenv.yml","w") as f:<br/>   f.write(myenv.serialize_to_string())</span></pre><p id="34eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">评分</strong>文件如下所示，为每个模型实现 init()和 run():</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="a7a8" class="nm md it ni b gy nn no l np nq">#score_mymodel.py<br/>def init():<br/>   global model<br/>   model_path = os.path.join(os.getenv('AZUREML_MODEL_DIR'),<br/>        'mymodel.pkl')<br/>   model = joblib.load(model_path)def run(raw_data):<br/>   data = np.array(json.loads(raw_data)['data'])<br/>   y_hat = model.predict(data)<br/>   return y_hat.tolist()</span></pre><p id="6f78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一步包括设置服务、模型，并为每个模型部署一次:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="4102" class="nm md it ni b gy nn no l np nq">aciconfig = AciWebservice.deploy_configuration(cpu_cores=1,<br/>   memory_gb=1,tags={"data": "diamonds","method": "sklearn"},<br/>   description='Predict Diamonds with sklearn')<br/>ws = Workspace.get(name='DiamondMLWS', subscription_id='****',<br/>   resource_group='diamond-ml')<br/>model = Model(ws, name)inference_config = InferenceConfig(runtime= "python",<br/>   entry_script="score_mymodel.py", conda_file="myenv.yml")service = Model.deploy(workspace=ws,<br/>   name=svcname, models=[model], inference_config=inference_config,<br/>   deployment_config=aciconfig)<br/>service.wait_for_deployment(show_output=True)</span></pre><p id="9686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！您应该会看到输出声明服务已经部署并返回 URI 以供访问，并检查 Azure 门户以查看它是否在那里。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="ef3a" class="nm md it ni b gy nn no l np nq">Running.......................<br/>ACI service creation operation finished, operation "Succeeded"<br/>http://dds2f-97f5eb5c4163.eastus.azurecontainer.io/score</span></pre><p id="58e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">差不多就是这样。输入格式和输出由您在第 2 部分中创建的模型细节定义。你可以用 Postman 或 curl 测试 API 确保它是定价的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/c979d6c39377f9f6147fadee4108845f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WsYQF0J84BUvP_Ek.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Testing via POSTman</figcaption></figure><p id="359a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发布到 azure web service——价格 1.1 克拉，F 色，未切割，VVS2 净度钻石→ $11，272 是预测！</p><p id="2b3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会深入讨论使用 GUI 驱动的 Azure ML Studio 的细节。您可以拖放、训练并最终发布一个 web 服务 URL(使用不同的输入/输出格式)。对于我的应用程序，我在 GUI ML Studio 中发布了 3 个模型，在 SKLearn 中发布了 4 个模型。查看 web GUI 上定价请求的输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/aa715ad1a1a3c527ea72a79e0832226c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WtBMdmG1yL8wI3Ic.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Target aggregated results</figcaption></figure><p id="7408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意神经网络模型是完全疲惫不堪…不知道我是否会麻烦修复它…</p><p id="6761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于 Azure ML 容器的成本，我选择将模型转移到 Azure 托管的<strong class="js iu"> Flask Python 服务</strong>。这是非常少的代码——而且成本只是 Azure ML ACI 的一小部分($ 2/天每项服务，所以部署了 w/ 4 个模型，大概是$ 8/天..迅速破产的老道格·福】。重新部署非常容易。烧瓶中的 pkl:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="a4b5" class="nm md it ni b gy nn no l np nq">app = Flask(__name__)<br/>models = {}<br/>models['XGB2'] = joblib.load('models/sklearn_diamond_xgb_model.pkl')<br/>models['ISO'] = joblib.load('models/sklearn_diamond_iso_model.pkl')<br/>models['LR3'] = joblib.load('models/sklearn_diamond_regr_model.pkl')print('loaded models', models)@app.route('/models/&lt;model&gt;', methods=['POST'])<br/>def predict(model):<br/>   if (models.get(model) is None):<br/>      print('model not found: ',model)<br/>      return jsonify("[-1]")<br/>   j_data = np.array(request.get_json()['data'])<br/>   y_hat = np.array2string(models[model].predict(j_data))<br/>   print('input: ',j_data, ', results:', y_hat)<br/>   return y_hatif __name__ == '__main__':<br/>   app.run(debug=True)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="46c1" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak">步骤 4:用 React 构建完整的堆栈 ML 前端</strong></h1><p id="5c6c" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">同样，关于启动 React 项目&amp; Express.js 项目的故事数不胜数，所以我将跳过一些步骤..</p><ul class=""><li id="4a26" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated">将<strong class="js iu"> express </strong>安装到我的项目文件夹~/diamonds 中</li><li id="7b94" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">安装<strong class="js iu"> react </strong>，用 create-react-app 在一个名为~/diamonds/diamond-app 的子目录中创建起始项目</li><li id="b3b6" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">对于生产部署，它们通过 webpack 合并成一个单一的<strong class="js iu"> express </strong>捆绑包</li></ul><h1 id="f71d" class="mc md it bd me mf nz mh mi mj oa ml mm mn ob mp mq mr oc mt mu mv od mx my mz bi translated">React 与我以前使用过的所有其他框架相比</h1><p id="e04c" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我对 Web 开发非常熟悉，比如 Perl-CGI、Php、JSP、ASP 和所有那些“Web 2.0”框架，包括传统的 AJAX。我也用过 Django，仔细观察过 Angular。<strong class="js iu"> React 不同——有一个学习曲线</strong>。经过一番挣扎，我现在是你的忠实粉丝了！需要记住的关键事项:</p><ul class=""><li id="5407" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu">组件— </strong>编码使用 JSX 语言，看起来像 Javascript，但略有不同。你通过 JSX 类或函数来编码组件(&lt;标签/ &gt;)。顶层组件通常是 App.js，在这里你可以添加你的自定义 JSX 和其他组件，比如&lt; MyTag/ &gt;。</li></ul><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="c529" class="nm md it ni b gy nn no l np nq">class MyTag extends React.Component {<br/>    const constvar = "Text"<br/>    render() { return (&lt;div&gt;Hi {constvar}&lt;/div&gt;) }<br/>}</span></pre><ul class=""><li id="b0a5" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu">状态</strong> —动态渲染流程与您可能习惯的非常不同。React 有自己的生命周期，主要由“状态”(特殊变量)变化控制。声明一组状态变量，然后像变魔术一样刷新受影响的组件。见下文，随着<strong class="js iu">动态</strong>的值的改变，GUI 组件将自我刷新。</li></ul><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="44bd" class="nm md it ni b gy nn no l np nq">class MyTag extends React.Component {<br/>    constructor(props) {<br/>       super(props);<br/>       this.state = { dynamic: 'Dyn txt' }<br/>    }<br/>    const constvar = "Const Txt";<br/>    render() { <br/>       return (&lt;div&gt;Hi {constvar} and {this.state.dynamic}  &lt;/div&gt;<br/>    )}<br/>}<br/>// equiv as a function, bit tighter ?  also use MyTag<br/>function MyTag2() {  <br/>    const constvar = "Const Txt";<br/>    const [dynamic, setDynamic] = React.useState('Dyn Txt');<br/>    return (&lt;div&gt;Hi {constvar} and {dynamic} and &lt;MyTag/&gt; &lt;/div&gt;);<br/>}</span></pre><ul class=""><li id="4f55" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu"> Props — </strong> props 是标签属性和组件/标签的子组件—传递数据的一种方式。您可以通过 props 将数据<strong class="js iu"> <em class="lf">向下</em> </strong>传递，但是调用<strong class="js iu"> <em class="lf">向上</em> </strong>需要一个回调函数(例如在 caller/parent 中定义的 myCallbackFunc)。</li></ul><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="b83c" class="nm md it ni b gy nn no l np nq">function MyTag2(props) {  <br/>  const constvar = "Const Txt";<br/>  const [dynamic, setDynamic] = React.useState('Dyn Txt');<br/>  return (<br/>     &lt;div&gt; <br/>       Hi {constvar} and {dynamic} <br/>       Hi {props.var1} <br/>       &lt;Button onClick={props.callback} /&gt;<br/>     &lt;/div&gt;);<br/>  }<br/>}<br/>function App() {<br/>  function myCallbackFunc() {<br/>     // do something on button click<br/>  }  return (<br/>     &lt;div&gt; <br/>        &lt;MyTag2 <strong class="ni iu">var1</strong>=’var' <strong class="ni iu">callback</strong>={myCallbackFunc}&gt;Text&lt;/MyTag2&gt; <br/>     &lt;/div&gt;);<br/>  }<br/>}</span></pre><p id="5af2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上例——你的 app 根是<App/>，在里面我们调用 MyTag <strong class="js iu"> w/ "props" </strong> var1 和回调以及内部的" Text "。</p><p id="5ef7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这需要一些拨弄来学习，但它实际上非常优雅——试试吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用材料设计启动用户界面</strong></p><p id="b319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Google 的 Material-UI 是 React 的一个组件库/框架，它给你提供了很棒的小部件和默认主题，这样任何人都可以让网站看起来很棒！我浏览了画廊，选择了<a class="ae le" href="https://github.com/mui-org/material-ui/tree/master/docs/src/pages/getting-started/templates/dashboard" rel="noopener ugc nofollow" target="_blank">仪表盘(在左边)</a>开始。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/3fd86e75aeb562cbf15c4035ef9afff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f6bBYOvGcUDJYU2Q.png"/></div></div></figure><p id="2965" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Material-UI 有类似于<grid>布局和<paper>容器的组件来管理反应式/自动调整组件。包括一个漂亮的侧菜单<drawer>。</drawer></paper></grid></p><p id="49c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在默认仪表板上做的主要事情:</p><ul class=""><li id="e885" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated">设置左抽屉默认关闭，添加<modal>帮助弹出链接到外部网站。</modal></li><li id="740a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">更新了顶栏和新文本，替换了通知铃声和帮助</li><li id="e450" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">在网格中实现了 3 个主要的“纸”容器:随机钻石、库存选择器/过滤器和 ML Pricer。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/a8752c4185f6ced8463f8f0b7c1d029b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5NYedqhTXSJCpys6.png"/></div></div></figure><h1 id="64d3" class="mc md it bd me mf nz mh mi mj oa ml mm mn ob mp mq mr oc mt mu mv od mx my mz bi translated">今日随机钻石</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/4fc2d2b07f8d37b6a8730639e290bc0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*X-h4p-hDgNo4YcEB.png"/></div></div></figure><p id="fb8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是最容易建立的一个。假设/diamonds/daily/上有一个服务器 REST 端点，它返回一个 json (data.price，data.carat，等等..)—我们只获取组件负载(useEffect())并从结果中设置状态变量。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="a74e" class="nm md it ni b gy nn no l np nq">export default function Daily() {<br/>  const [diamond, setDiamond] = useState({<br/>    price:0.0,carat:0.0,color:'',cut:'',clarity: '',skus: ''<br/>  });  useEffect(() =&gt; {<br/>    axios.get('/diamonds/daily/').then(response =&gt; {<br/>      setDiamond({<br/>         price: response.data.price, <br/>         carat: response.data.carat, <br/>         ...<br/>      });<br/>    })},<br/>  []);  <br/>  return (<br/>    &lt;React.Fragment&gt;&lt;Title&gt;Random Diamond Featured&lt;/Title&gt;   <br/>      &lt;Typography&gt;Price: {diamond.price}&lt;/Typography&gt;<br/>      &lt;Typography&gt;Carats: {diamond.carat}&lt;/Typography&gt;<br/>      ...<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span></pre><h1 id="7742" class="mc md it bd me mf nz mh mi mj oa ml mm mn ob mp mq mr oc mt mu mv od mx my mz bi translated">钻石过滤器</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/d16c3fa9679e01e07fde2ff09da004c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fwn-kykGN8Wm5dc9.png"/></div></div></figure><p id="de7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想要一个基本的搜索表单，让我通过 140k 钻石过滤-图表+表格中的细节。</p><p id="ec46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我选择<a class="ae le" href="https://formidable.com/open-source/victory/docs/" rel="noopener ugc nofollow" target="_blank"> Victory </a>作为我的制图/绘图工具，因为它适用于反应式(也考虑了反应式和重新制图)。我不喜欢 material-ui 数据表(缺乏更高层次的抽象)，所以选择了更小的开源<a class="ae le" href="https://github.com/mbrn/material-table" rel="noopener ugc nofollow" target="_blank"> Material-Table </a>项目。在 React-land 中，您可以选择许多组件！</p><p id="4745" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建该组件的主要步骤:</p><ol class=""><li id="0a49" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">使用 Material-UI 表单组件，在表单组中添加复选框，并实现克拉滑块。</li><li id="102c" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">实现 SearchButton 的 onClick</li><li id="bad4" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">模仿或构建您的<a class="ae le" href="https://medium.com/@doug.foo/full-stack-mern-machine-learning-on-azure-part-5-building-backend-express-mongodb-f87f5ddf707d" rel="noopener">后端</a>来返回一个列表中的钻石 JSON，我们在一个图形+表格中呈现(通过选项卡)— <a class="ae le" href="https://medium.com/@doug.foo/full-stack-mern-machine-learning-on-azure-part-5-building-backend-express-mongodb-f87f5ddf707d" rel="noopener">更多内容在第 5 部分</a></li></ol><p id="9b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考<a class="ae le" href="https://github.com/dougfoo/diamonds/blob/master/diamond-app/src/Chooser.js" rel="noopener ugc nofollow" target="_blank"> github 获取完整源代码</a>。下面显示了如何将选项传递给服务器:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="1ad0" class="nm md it ni b gy nn no l np nq">class Chooser extends Component {<br/>  constructor(props) {<br/>  super(props);  this.state = {<br/>    D: true,<br/>    E: true,<br/>    F: true,<br/>    G: true,<br/>    H: true,<br/>    AstorIdeal: false,<br/>    Ideal: true,<br/>    diamonds: [],<br/>    ...<br/>  }  handleSubmit = event =&gt; {<br/>    // call REST api, setState of return diamonds[] etc<br/>  }  render() {<br/>    return (<br/>      &lt;React.Fragment &gt;<br/>         &lt;Title&gt;Filter Diamonds&lt;/Title&gt;<br/>         &lt;FormControl component="fieldset" &gt;<br/>           ... checkboxes and button <br/>         &lt;/FormControl&gt;<br/>         &lt;Paper square className={classes.root}&gt;<br/>           &lt;Chart diamonds={this.state.diamonds}/&gt;<br/>           &lt;DiamondsTable diamonds={this.state.diamonds} /&gt;<br/>         &lt;/Paper&gt;<br/>      &lt;/React.Fragment&gt;<br/>   )<br/>}</span></pre><p id="eb81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DiamondsTable 是一个第三方表格组件<a class="ae le" href="https://github.com/mbrn/material-table" rel="noopener ugc nofollow" target="_blank">来查看数据网格。把钻石[]当道具传就行了。钻石[]状态的任何变化都会强制重新渲染。反应刷新魔法！</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/f6d3509e67564ddef86d20cd7f6691a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nozq-ehLxHuAbKs4.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Tab to DiamondTable (customized react-table component)</figcaption></figure><h1 id="beac" class="mc md it bd me mf nz mh mi mj oa ml mm mn ob mp mq mr oc mt mu mv od mx my mz bi translated"><strong class="ak"> ML 定价—终于！</strong></h1><p id="96bd" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我们已经接近目标—根据我们训练集中的 14 万颗钻石预测钻石价格。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/f4b53cdd9833b13c61838513fa1ddc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8Ihpro1WAmCFHbst.png"/></div></div></figure><p id="f8bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控件非常简单——很像过滤器/选择器，我们有一个基本的表单和按钮。</p><p id="0782" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码结构非常相似:</p><ol class=""><li id="f6b1" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">带有 submitPrice 回调的 FormGroup 和 Button</li><li id="a281" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">submitPrice 调用 REST 服务，传递输入{克拉、净度、切工、颜色}并返回设置为状态变量的钻石列表[]。</li><li id="3169" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">钻石[]作为道具传递到图表和表格中。</li><li id="eca7" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">diamonds[]状态的初始和任何后续更改都会触发使用 diamonds[]重新渲染子组件。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/6dbfe292ac779595fded11b78a21e90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tmh9jM1ca6S7Czx_.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Full results of model prices and analytic graphs + unseen tab view to tabular results</figcaption></figure><p id="958b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自上一步的过滤器(<a class="ae le" href="https://github.com/dougfoo/diamonds/blob/master/diamond-app/src/Chooser.js" rel="noopener ugc nofollow" target="_blank"> Chooser.js </a>)和<a class="ae le" href="https://github.com/dougfoo/diamonds/blob/master/diamond-app/src/Pricer.js" rel="noopener ugc nofollow" target="_blank"> Pricer.js </a>非常相似。<a class="ae le" href="https://github.com/dougfoo/diamonds/blob/master/diamond-app/src/Pricer.js" rel="noopener ugc nofollow" target="_blank"> Pricer </a>是作为<strong class="js iu">函数</strong>而不是<strong class="js iu">类</strong>实现的，因此语法略有不同。带状态的函数是新的“钩子”,被添加到 React 中，是完整类的更好的替代品。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="028b" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">步骤 5:在 Express 中构建 REST 服务(w/ MongoDB)</h1><p id="0cbd" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">Express 是 JavaScript Node.js webserver。我仍然更喜欢 Python 中的后端，但我猜这个教程是 MERN，所以我必须使用/学习 Express(这并不太难)。一个关键的优势是当您拥有相同的前端和后端库时可以重用。</p><p id="c668" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我不会深入安装的基础知识。我将跳转到托管我的 API 逻辑的 server.js 脚本。我需要的主要 REST 调用:</p><ul class=""><li id="ee16" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated">获得/钻石/每日-每日随机钻石</li><li id="e3be" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">POST /diamonds/q/ —获取具有某些过滤标准的列表</li><li id="6ebb" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">POST /diamonds/q2/ —获取符合定价标准的列表</li><li id="05fa" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn nf lm ln lo bi translated">POST/diamonds/price——使用我的 ML 模型为钻石定价</li></ul><h2 id="523a" class="nm md it bd me op oq dn mi or os dp mm kb ot ou mq kf ov ow mu kj ox oy my oz bi translated"><strong class="ak">首先让我们设置 MongoDB </strong></h2><p id="effa" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">为 Express 设置一个 Mongoose 模型，创建一个数据库并批量加载该数据库。</p><ol class=""><li id="caf3" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">设置 Express 端点</li><li id="21a1" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">MongoDB 在 MLab 上免费— <em class="lf"> FYI Azure 有 CosmoDB，它(大部分)与 MongoDB 有线兼容。CosmoDB 最便宜的计划是 24 美元/月！</em></li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/ade370281fc6198a00a00e2f08a42e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FA55t2OTRWFkDDec.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Mongo is free — vs $24/month on Azure</figcaption></figure><p id="dd03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建数据库后，您需要上传数据或手工输入数据。对我来说，最简单的方法是使用批量加载器脚本——要求您在 PC 上安装 MongoDB 客户端，并指向 MLAB 连接字符串。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="134a" class="nm md it ni b gy nn no l np nq">mongoimport --uri mongodb://user:pass@host.mlab.com:12122/diamonds --collection myc --type csv --headerline  --file jsonfile.csv</span></pre><p id="1292" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上传 150k 的钻石条目速度很快，只需几分钟，并且确实使用了接近 0.5gb 的限制。全部完成！</p><p id="ad38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。Mongoose 模型— </strong>创建一个脚本，定义一个与您的 MongoDB 集合的 JSON 格式相匹配的模式:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="60c5" class="nm md it ni b gy nn no l np nq">#diamond.model.js<br/>let Diamond = new Schema({<br/>  carat: {<br/>     type: Number,<br/>     default: -1<br/>  },<br/>  color: {<br/>     type: String,<br/>     default: 'Default'<br/>  },<br/>  ...<br/>}, { collection: 'myc' });module.exports = mongoose.model('Diamond', Diamond);</span></pre><p id="19d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。Express.js REST 端点(</strong><a class="ae le" href="https://github.com/dougfoo/diamonds/blob/master/server.js" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">server . js</strong></a><strong class="js iu">)</strong>都是下一步。</p><p id="2a61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那里，大部分都是样板文件。打开一个要共享的连接，设置任何备用映射(在本例中为 react path)，并监听一个端口。在这两者之间，我们为各种 GET/POST 处理程序创建路由(在下一节中定义)。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="d2da" class="nm md it ni b gy nn no l np nq">app.use(cors());<br/>app.use(bodyParser.json());<br/>mongoose.connect('mongodb://user:pass@host:port/diamonds', <br/>   { useNewUrlParser: true, useUnifiedTopology: true  });</span><span id="1b05" class="nm md it ni b gy nt no l np nq">const connection = mongoose.connection;<br/>connection.once('open', function() {<br/>  console.log("MongoDB connection established successfully");<br/>})</span><span id="23b6" class="nm md it ni b gy nt no l np nq">//-- fill w/ diamondRoutes start<br/>... see below<br/>//-- fill end</span><span id="09af" class="nm md it ni b gy nt no l np nq">app.use('/diamonds', diamondRoutes);// for webpack'd react front end <br/>app.use(express.static("./diamond-app/build")); <br/>app.get("*", (req, res) =&gt; {<br/>   res.sendFile(path.resolve(__dirname, "./diamond-app", <br/>       "build", "index.html"));<br/>});<br/>app.listen(PORT, function() {<br/>   console.log("Server is running on Port..: " + PORT);<br/>});</span></pre><p id="6be4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们填写 diamondRoutes — /daily /q /q2 和/price。/daily 很简单——只是一个返回 1 个 diamond 的随机查询(使用 diamond.model.js 中定义的 json 模式)</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="8ff1" class="nm md it ni b gy nn no l np nq">diamondRoutes.route('/daily').get(function(req, res) {<br/>   let random = Math.floor(Math.random() * 140000);  // skip n<br/>   Diamond.findOne().skip(random).exec(function(err, diamonds) {<br/>      res.json(diamonds);<br/>   });<br/>});</span></pre><p id="f341" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">/q 和/q2 都是类似的查询搜索，接受 POST 参数并映射到一个 Mongoose 查询——POST 输入是一个 JSON，如{carat:3，color:'D '，cut:' '，clarity:''}</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="369b" class="nm md it ni b gy nn no l np nq">diamondRoutes.route('/q2').post(function(req, res) {<br/>   const qobj = req.body;<br/>   query = Diamond.find(); <br/>   query = query.where('carat').<br/>       gt(qobj.carat-0.05).lt(qobj.carat+0.05);   <br/>   if (qobj.cut !== '') query = query.where('cut').equals(qobj.cut);<br/>   if (qobj.color !== '') query =<br/>      query.where('color').equals(qobj.color);<br/>   if (qobj.clarity !== '') query =<br/>      query.where('clarity').equals(qobj.clarity);  <br/>   query.exec(function(err, diamonds) {   <br/>      res.json(diamonds);<br/>   });<br/>});</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/852ea5186955868139b65a3e1c0b0354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DQeCJTitusT-OTQp.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">POSTman test</figcaption></figure><p id="c2c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">调用/价格</strong>—<strong class="js iu">机器学习推理调用</strong>是通过另一个 REST API 调用 Azure ML Studio 的 farm 完成的(<em class="lf">现在大部分是对 Azure Flask 服务器</em>)。</p><p id="ae11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请求链:React 客户端-&gt; Express.js -&gt; ML 服务-&gt;返回 Express.js -&gt;返回 React 客户端。</p><p id="9b42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为以块的形式显示代码会令人困惑，所以只看关键步骤，即使用“异步”调用 callSvc 函数，然后“等待”它们全部加入结果:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="1b67" class="nm md it ni b gy nn no l np nq">let r0 = await callSvc(p2.XGB.url, p2.XGB.token, reqJson);<br/>let r1 = await callSvc(p2.LR.url, p2.LR.token, reqJson);<br/>let r2 = ...</span></pre><p id="11f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">callSvc 只是执行一个 axios http POST 来获取 ML 预测。注意函数上的“async”定义，以及上面配对异步调用的 await 调用。</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="0cef" class="nm md it ni b gy nn no l np nq">async function callSvc(apiurl, token, reqJson) {<br/>    return axios.post(apiurl, reqJson, <br/>        { headers: {<br/>            'Content-Type': 'application/json',<br/>            'Authorization': token,<br/>            }<br/>        })<br/>        .catch(function (error){<br/>            console.log(error);<br/>        });<br/>}</span></pre><p id="c4f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于前端来说，响应被合并到单个响应 JSON 中，注意 ML Studio 格式不同于我的定制 SKLearn 模型:</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="346b" class="nm md it ni b gy nn no l np nq">res.json([<br/>   { price:r0.data.Results.output1.value.Values[0][6],model:'XGB' }, <br/>   { price:r1.data.Results.output1.value.Values[0][6],model:'LR' },<br/>   { price:r2.data.Results.output1.value.Values[0][6],model:'NN' },<br/>   { price: r3.data[0], model: 'ISO' },<br/>   { price: r4.data[0], model: 'XGB2' },<br/>   { price: r5.data[0], model: 'LR3' },<br/>   { price: r6.data[0], model: 'RF' },<br/>]);</span></pre><p id="7e80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过 POSTMAN 查看链的外观(调用 express，它调用 ML 服务，汇总所有 7 个模型的结果):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/b3e17c0d7a00316574d0d933701f7589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7XAsWXp5Incrdy1QlzBtA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Final test via POSTMAN-&gt;Express.js-&gt;ML Services</figcaption></figure><p id="1c29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的故事请看完整的<a class="ae le" href="https://github.com/dougfoo/diamonds/blob/master/server.js" rel="noopener ugc nofollow" target="_blank">源代码</a>。这就是大部分——我们现在已经构建了 express.js 后端！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="00f8" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">步骤 6:React+Express 的 Azure 部署</h1><p id="2cba" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">部署到 Azure 站点真的很简单(当它正常工作时)——当出现构建或部署错误时会非常沮丧。祝你好运！</p><p id="6503" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您应该理解在开发中您可能运行 2 个服务器:</p><ol class=""><li id="5767" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">反应开发引擎(默认端口 3000)</li><li id="cbc8" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">快速开发服务器(默认端口 4000)</li></ol><p id="1a99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 prod 中，您只运行一台服务器(Express ), React 的内容通过“npm build”被“捆绑”到一个 webpack 中，结果是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/1aaab582cf5d82780a2df965c6ce172a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtoCtkHKI0oLBBHbEGufqQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">webpack results</figcaption></figure><p id="852d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的 express.js 有指向这个构建/静态文件夹的代码</p><pre class="kp kq kr ks gt nh ni nj nk aw nl bi"><span id="b2b3" class="nm md it ni b gy nn no l np nq">app.use(express.static("./diamond-app/build"));<br/>app.get("*", (req, res) =&gt; {<br/>     res.sendFile(path.resolve(__dirname, "./diamond-app", <br/>                  "build", "index.html"));<br/>});</span></pre><p id="0779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将这个项目签入 github，你就可以开始了！(<em class="lf">)。git 忽略 express.js (~diamonds)和 react (~diamonds/diamond-app)级别的 node _ modules</em>)。</p><p id="9dac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">登录 Azure 门户并创建 Web 应用</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/be308aba7feb5060d6ccf02c6e430804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygBMYmXVSgJhm_t7oUmvKQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">creating an azure webapp</figcaption></figure><p id="82fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“testwebapp23”将变成<a class="ae le" href="http://testwebapp23.azurewebsites.net" rel="noopener ugc nofollow" target="_blank">http://testwebapp23.azurewebsites.net</a>所以要小心命名，它<strong class="js iu">以后不能更改</strong>(如果你拥有一个域，你可以在外部给它起个 DNS 别名)。选择最便宜的尺寸，B1 将花费你大约 15 美元一个月！</p><p id="9d6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我会检查 Azure Web App 的配置面板，确认一些事情:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/1613834d37211b26a7bd0796488b3b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it0FV8HlqejMoGGj1SRQPQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">double check the config</figcaption></figure><p id="5a2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，您需要在<strong class="js iu">Azure devo PS</strong>(<a class="ae le" href="https://dev.azure.com" rel="noopener ugc nofollow" target="_blank">https://dev.azure.com</a>)中创建一个项目来托管构建环境。然后，转到项目设置(左下角)并将其链接到您的 GitHub repo，并启用管道:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/18346ce99930dfa86091c9adfe69846c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1k3mMLah7N4osve3CNOIxA.png"/></div></div></figure><p id="76fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">管道将启用您的 CI/CD 设置，因此对 GitHub 的签入将触发构建和部署。有几种方法来设置它，每种方法都有其缺陷。奇怪但半简单的方法是跳回 Azure Portal，用他们的 webapp-&gt; <strong class="js iu">部署中心</strong>结束。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ph"><img src="../Images/614e1e31d6887449683e44c5c6cec062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dx8BJNKipeNczj-DBfq2Lw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Select GitHub — then Azure Pipelines</figcaption></figure><p id="8719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以选择 Kudu App Build 或者 Azure Pipelines。Pipelines 是最新的 Azure CI/CD 工具集(取代了 TFS)。两者都有问题..但是我发现对于 node.js 管道部署效果更好(对于 Python 我更喜欢 Kudu)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pi"><img src="../Images/5f202c600d0eed7fa6bb3ac11e7bae93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ocIqW46kolcBPv2PWIU-w.png"/></div></div></figure><p id="cef8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成，这将创建您的第一个构建和部署。如果你幸运的话，它可以工作，你可以像这样在线查看你的应用程序:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/66c46b619e8ae09e91fdcbec1df5b96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slsiJdMcPECC1liHXBQXew.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">It works!</figcaption></figure><p id="2bae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">跳回 Azure DevOps，你会看到它生成了一个管道(构建)和发布(部署):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/18878e798591d609ef054d7df8ae9d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8Xa18dPyc2XE-xQoIRTiA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Code successfully built in Azure Pipelines</figcaption></figure><p id="ee63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果通过，则进入发布(部署):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/f69d120ea38cfe225bd70213801c6db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIxfm1NCQub25gbk3ylqlw.png"/></div></div></figure><p id="af62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以定制每个步骤，并添加一些漂亮的东西，如前/后脚本或如下所示的批准流程，以在您的环境中传播更改。一个变更触发了一个预生产(演示)构建，然后一旦我验证了构建，我必须手动批准发布到生产(diamonds.foostack.ai)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/6317d13d5b20f3a722ec03c7629fb81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imvks3RKPtrpXkdh60hPMQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="380f" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak">第七步:技巧和烦恼</strong></h1><p id="f81a" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我学到并想提醒你的最重要的事情:</p><ul class=""><li id="c0c4" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu"> Azure Insights </strong>非常适合跟踪使用统计数据(设置起来比你想象的要困难，你必须将代码与你的每个组件挂钩，但之后你会得到一些很好的遥测数据)</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pn"><img src="../Images/5109750cfd7b2544080a054af5fe944a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4U6DP-1NRaIqK8z7.png"/></div></div></figure><ul class=""><li id="1ade" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated">Azure 正在发展(正在崩溃),所以准备好面对一些麻烦，尤其是机器学习和管道等新事物(linux 上的 node.js 版本突然崩溃..几个星期以来，Azure 团队一直在努力清理这场灾难:</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl po"><img src="../Images/6c24ba7fdcb1237bdd7f8041d17478a2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ko5p-GfVxA0EJ2hnf5JArw.png"/></div></figure><ul class=""><li id="bfa1" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu"> Scrum Boards </strong>和票证管理可以在 Azure DevOps 中完成，并与 GitHub 集成。它很新，但对于一个小项目来说还不错。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl po"><img src="../Images/6df2fe76b9bd6f19cb5a6b4f2c17e161.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3gPOorejSuMh4FGZf92TIw.png"/></div></figure><ul class=""><li id="d6a1" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu">成本管理</strong> —密切跟踪。每个机器学习模型的成本有点疯狂(每个模型容器/天 2 美元，仅 12 天就花了我 100 多美元)。这促使我迁移到 Flask。在另一个项目中，SQL Warehouse 用了 2 天就超过了 100 美元！小心，设置成本警报！</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl po"><img src="../Images/00709f49bed258e0f5117c258992d332.png" data-original-src="https://miro.medium.com/v2/format:webp/1*lj0nBdfEZlCQlU3GybjPtA.png"/></div></figure><ul class=""><li id="db52" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><a class="ae le" href="https://github.com/dougfoo/flaskml" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Python Flask Deploy</strong></a><strong class="js iu"/>——因为上面的成本问题，我晚加了这个。我使用传统的来自 WebApp- &gt; Deployment 的 Kudu build，而不是 Azure Pipelines，因为我一直使用 Azure Pipelines 时出现了一些错误。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pp"><img src="../Images/2f9faf264e93339f0e5af8f58b097a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucwEVdG1btcs4JzYZnyJLw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Python Flask using older Kudu deployment (works !)</figcaption></figure><ul class=""><li id="1c2d" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn nf lm ln lo bi translated"><strong class="js iu">域名</strong>设置真的很简单——Azure 不这么做，去<a class="ae le" href="http://namecheap.com" rel="noopener ugc nofollow" target="_blank">namecheap.com</a>——然后在 Azure 上链接就行了。非常简单的说明。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl po"><img src="../Images/33eb0598ef72d04ad7d6cee4c4e94d15.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3pihl_EJWnuvmn7Dsumjhw.png"/></div></figure><p id="8b71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！在线阅读 live<a class="ae le" href="http://diamonds.foostack.ai" rel="noopener ugc nofollow" target="_blank">http://diamonds . foo stack . ai</a>网站、<a class="ae le" href="https://github.com/dougfoo/diamonds" rel="noopener ugc nofollow" target="_blank"> github 项目</a>或<a class="ae le" href="https://nbviewer.jupyter.org/github/dougfoo/machineLearning/blob/master/diamonds/Diamond-Analysis-4.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>。</p></div></div>    
</body>
</html>