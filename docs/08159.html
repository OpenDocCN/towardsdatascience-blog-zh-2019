<html>
<head>
<title>How to Write Python Command-Line Interfaces like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像专业人士一样编写 Python 命令行界面</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-write-python-command-line-interfaces-like-a-pro-f782450caf0d?source=collection_archive---------2-----------------------#2019-11-08">https://towardsdatascience.com/how-to-write-python-command-line-interfaces-like-a-pro-f782450caf0d?source=collection_archive---------2-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4750f6e9b3a4c28146472c5d69ad0d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYZkHTLtm5pH7wmxkNiXTw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kf" href="https://unsplash.com/s/photos/interface?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3e95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为数据科学家，我们面临着许多重复和相似的任务。这包括创建每周报告，执行提取、转换、加载(<a class="ae kf" href="https://en.wikipedia.org/wiki/Extract,_transform,_load" rel="noopener ugc nofollow" target="_blank"> ETL) </a>作业，或者使用不同的参数集训练模型。通常，我们最终会有一堆 Python 脚本，每次运行它们时，我们都会更改代码中的参数。我讨厌这样做！这就是为什么我养成了将脚本转换成可重用的命令行界面(CLI)工具的习惯。这提高了我的效率，让我在日常生活中更有效率。我开始用<a class="ae kf" href="https://docs.python.org/3/howto/argparse.html" rel="noopener ugc nofollow" target="_blank"> Argparse </a>做这件事，但是这并不愉快，因为我不得不产生很多难看的代码。所以我想，我不需要一遍又一遍地写很多代码就能实现吗？我能享受编写 CLI 工具的乐趣吗？</p><blockquote class="le lf lg"><p id="82d1" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><a class="ae kf" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank">点击</a>是你的朋友！</p></blockquote><p id="ff3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么什么是点击呢？从网页上:</p><blockquote class="le lf lg"><p id="1cae" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">(点击)它旨在使编写命令行工具的过程变得快速而有趣，同时防止因无法实施预期的 CLI API 而导致的任何挫折。</p></blockquote><p id="8086" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我来说，这听起来很棒，不是吗？</p><p id="5bdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将向您提供如何使用 Click 构建 Python CLIs 的实践指南。我一步一步地构建了一个示例，向您展示 Click 提供的基本功能和好处。学完本教程后，您应该能够愉快地编写下一个 CLI 工具，而且只需一眨眼的功夫:)所以，让我们动手吧！</p><h1 id="d7f6" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">教程</h1><p id="1979" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在本教程中，我们使用 Click 逐步构建一个 Python CLI。我从基础开始，每一步都引入 Click 提供的新概念。除了 Click，我还使用<a class="ae kf" href="https://poetry.eustace.io/" rel="noopener ugc nofollow" target="_blank">poems</a>来管理依赖项和包。</p><h2 id="2855" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">准备</h2><p id="f710" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">首先，我们来装诗。有多种方法可以做到这一点，参见我的文章，但是这里我们使用 pip</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6f3d" class="mo lm it nf b gy nj nk l nl nm">pip install poetry==0.12.7</span></pre><p id="5312" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用诗歌创建一个名为<em class="lh"> cli-tutorial 的项目，</em>添加 click 和 funcy 作为依赖项，并创建一个文件 cli.py，稍后我们将在其中填充代码</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="4a7c" class="mo lm it nf b gy nj nk l nl nm">poetry new cli-tutorial<br/>cd cli-tutorial<br/>poetry add click funcy<br/><strong class="nf iu"># Create the file we will put in all our code</strong><br/>touch cli_tutorial/cli.py</span></pre><p id="d1d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经添加了 funcy，因为我稍后会用到它。要了解这个模块有什么用处，我建议感兴趣的读者参考这篇文章。现在，我们已经准备好实施我们的第一个 CLI。顺便说一下，所有示例代码都可以在我的<a class="ae kf" href="https://github.com/Shawe82/cli-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub 账户上找到。</a></p><h2 id="413a" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">我们的第一个 Click CLI</h2><p id="ca6e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们的初始 CLI 从磁盘读取一个 CSV 文件，对其进行处理(如何处理对本教程并不重要)，并将结果存储在 Excel 文件中。输入文件和输出文件的路径都应该由用户配置。用户<em class="lh">必须</em>指定输入文件路径。指定输出文件路径是可选的，默认为<em class="lh"> output.xlsx </em>。使用 Click，这样做的代码读作</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b2d1" class="mo lm it nf b gy nj nk l nl nm"><strong class="nf iu">import</strong> click</span><span id="9b78" class="mo lm it nf b gy nn nk l nl nm"><strong class="nf iu">@click.command()<br/>@click.option("--in", "-i", "in_file", required=True,<br/>    help="Path to csv file to be processed.",<br/>)<br/>@click.option("--out-file", "-o", default="./output.xlsx",<br/>    help="Path to excel file to store the result.")</strong><br/><strong class="nf iu">def</strong> process(<strong class="nf iu">in_file</strong>, <strong class="nf iu">out_file</strong>):<br/><strong class="nf iu">    """ Processes the input file IN and stores the result to <br/>    output file OUT.<br/>    """</strong><br/>    input = read_csv(in_file)<br/>    output = process_csv(input)<br/>    write_excel(output, out_file)</span><span id="3677" class="mo lm it nf b gy nn nk l nl nm"><strong class="nf iu">if</strong> __name__ =="__main__":<br/>    process()</span></pre><p id="74a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在这里做什么？</p><ol class=""><li id="e157" class="no np it ki b kj kk kn ko kr nq kv nr kz ns ld nt nu nv nw bi translated">我们用<em class="lh"> click.command. </em>修饰我们想要从命令行调用的方法<em class="lh"> process </em></li><li id="73e5" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">我们使用<em class="lh"> click.option </em>装饰器定义命令行参数。现在，您必须小心在修饰函数中使用正确的参数名。如果我们将不带破折号的字符串添加到<em class="lh"> click.option </em>中，参数必须与该字符串匹配。这是- in 和 in_file 的情况。如果所有名称都包含前导破折号，单击将使用最长的名称生成参数名称，并将所有非前导破折号转换为下划线。该名称被转换为小写。出文件和出文件就是这种情况。更多详情，请参考<a class="ae kf" href="https://click.palletsprojects.com/en/7.x/parameters/#parameter-names" rel="noopener ugc nofollow" target="_blank">点击文档</a> n。</li><li id="82db" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">我们使用<em class="lh"> click.option </em>的相应参数来配置所需的先决条件，如默认值或必需参数。</li><li id="7a34" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">我们将帮助文本添加到我们的参数中，当使用- help 调用我们的函数时会显示该文本。来自我们函数的 docstring 也将显示在那里。</li></ol><p id="62d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以通过多种方式调用这个 CLI</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c38e" class="mo lm it nf b gy nj nk l nl nm"><strong class="nf iu"># Prints help</strong><br/>python -m cli_tutorial.cli --help<br/><strong class="nf iu"># Use single char -i for loading the file</strong><br/>python -m cli_tutorial.cli -i path/to/some/file.csv<br/><strong class="nf iu"># Specify both file with long name</strong><br/>python -m cli_tutorial.cli --in path/to/file.csv --out-file out.xlsx</span></pre><p id="a6df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了，我们已经使用 Click 创建了第一个 CLI！</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6b18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我没有实现<em class="lh"> read_csv </em>、<em class="lh"> process_csv </em>和<em class="lh"> write_excel </em>，而是假设它们存在并做它们应该做的事情。</p><p id="03db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CLIs 的一个问题是我们将参数作为通用字符串传递。为什么这是一个问题？因为这些字符串必须被解析为实际类型，这可能会由于用户输入的格式不正确而失败。看看我们的例子，我们使用路径并尝试加载一个 CSV 文件。用户可以提供一个根本不代表路径的字符串。即使字符串格式正确，相应的文件也可能不存在，或者您没有访问它的正确权限。自动验证输入，如果可能的话解析它，或者在失败的早期给出有用的错误消息，这难道不是一件好事吗？理想情况下，所有这些都不需要编写大量代码？Click 通过为我们的参数指定类型来支持我们。</p><h2 id="1371" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">类型规范</h2><p id="84d4" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在我们的示例 CLI 中，我们希望用户传入一个<strong class="ki iu">有效路径</strong>到一个<strong class="ki iu">现有文件</strong>，我们对该文件拥有<strong class="ki iu">读取权限</strong>。如果满足了这些要求，我们就可以加载输入文件了。此外，如果用户指定输出文件路径，这应该是一个有效的路径。我们可以通过传递一个<em class="lh">点击来执行所有这些操作。路径</em>对象到<em class="lh"> click.option </em> decorator 的<em class="lh">类型</em>参数</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="44e7" class="mo lm it nf b gy nj nk l nl nm">@click.command()<br/>@click.option("--in", "-i", "in_file", required=True,<br/>    help="Path to csv file to be processed.",<br/>    <strong class="nf iu">type=click.Path(exists=True, dir_okay=False, readable=True)</strong>,<br/>)<br/>@click.option("--out-file", "-o", default="./output.csv",<br/>    help="Path to csv file to store the result."<strong class="nf iu">,</strong><br/>    <strong class="nf iu">type=click.Path(dir_okay=False)</strong>,<br/>)<br/><strong class="nf iu">def </strong>process(in_file, out_file):<br/>    """ Processes the input file IN and stores the result to output     <br/>    file OUT.<br/>    """<br/>    input = read_csv(in_file)<br/>    output = process_csv(input)<br/>    <em class="lh">write_excel</em>(output, out_file)<br/>...</span></pre><p id="70dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">点击。路径</em>是 Click out of the box 提供的各种类型之一。您也可以实现自定义类型，但这超出了本教程的范围。有关更多细节，我建议感兴趣的读者参考 Click <a class="ae kf" href="https://click.palletsprojects.com/en/7.x/parameters/#implementing-custom-types" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="c3c1" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">布尔标志</h2><p id="fae2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">Click 提供的另一个有用的特性是布尔标志。可能，最著名的布尔标志是<em class="lh">详细</em>标志。如果设置为 true，您的工具将向终端打印出大量信息。如果设置为 false，则只打印少量内容。通过点击，我们可以实现为</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="bae3" class="mo lm it nf b gy nj nk l nl nm"><strong class="nf iu">from</strong> funcy <strong class="nf iu">import</strong> identity<br/>...<br/><strong class="nf iu">@click.option('--verbose', is_flag=True, help="Verbose output")</strong><br/><strong class="nf iu">def</strong> process(in_file, out_file, <strong class="nf iu">verbose</strong>):<br/>    <strong class="nf iu">""" Processes the input file IN and stores the result to<br/>    output file OUT.<br/>    """</strong><br/>    print_func = print <strong class="nf iu">if</strong> verbose <strong class="nf iu">else</strong> identity<strong class="nf iu"><br/></strong>    print_func("We will start with the input")<br/>    input = read_csv(in_file)<br/>    print_func("Next we procees the data")<br/>    output = process_csv(input)<br/>    print_func("Finally, we dump it")<br/>    write_excel(output, out_file)</span></pre><p id="ee66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你所要做的就是再添加一个<em class="lh">click . option</em>decoration 并设置<em class="lh"> is_flag=True </em>。现在，要获得详细的输出，您需要调用 CLI 作为</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3eef" class="mo lm it nf b gy nj nk l nl nm">python -m cli_tutorial.cli -i path/to/some/file.cs --verbose</span></pre><h2 id="a654" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">特征开关</h2><p id="adc1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">假设我们不仅想在本地存储<em class="lh"> process_csv </em>的结果，还想将它上传到服务器。此外，不仅有一个目标服务器，还有一个开发实例、一个测试实例和一个生产实例。您可以通过不同的 URL 访问这三个实例。用户选择服务器的一个选项是将完整的 URL 作为参数传递，她必须键入该参数。但是，这不仅容易出错，而且是一项繁琐的工作。在这种情况下，我使用<em class="lh">功能开关</em>来简化用户的生活。他们所做的最好通过代码来解释</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="fe72" class="mo lm it nf b gy nj nk l nl nm">...<br/>@click.option(<br/>    <strong class="nf iu">"--dev", "server_url"</strong>, help="Upload to dev server",<br/>    <strong class="nf iu">flag_value</strong>='https://dev.server.org/api/v2/upload',<br/>)<br/>@click.option(<br/>    <strong class="nf iu">"--test", "server_url"</strong>, help="Upload to test server",<br/>    <strong class="nf iu">flag_value</strong>='https://test.server.com/api/v2/upload',<br/>)<br/>@click.option(<br/>    <strong class="nf iu">"--prod", "server_url"</strong>, help="Upload to prod server",<br/>    <strong class="nf iu">flag_value</strong>='https://real.server.com/api/v2/upload',<br/>    <strong class="nf iu">default=True</strong><br/>)<br/><strong class="nf iu">def</strong> process(in_file, out_file, verbose, <strong class="nf iu">server_url</strong>):<br/>    """ Processes the input file IN and stores the result to output<br/>    file OUT.<br/>    """<br/>    print_func = print <strong class="nf iu">if</strong> verbose <strong class="nf iu">else</strong> identity<br/>    print_func("We will start with the input")<br/>    input = read_csv(in_file)<br/>    print_func("Next we procees the data")<br/>    output = process_csv(input)<br/>    print_func("Finally, we dump it")<br/>    write_excel(output, out_file)<br/>    print_func("Upload it to the server")<br/>    upload_to(server_url, output)<br/>...</span></pre><p id="5206" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我为三个可能的服务器 URL 添加了三个<em class="lh">click . option</em>decorator。重要的一点是，所有三个选项都有相同的目标变量<em class="lh"> server_url </em>。根据您选择的选项，<em class="lh"/><em class="lh">server _ URL</em>的值等于<em class="lh"> flag_value </em>中定义的相应值。您通过添加- <em class="lh"> dev </em>、- <em class="lh"> test </em>或- <em class="lh"> prod </em>作为参数来选择其中之一。所以当你执行的时候</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="173a" class="mo lm it nf b gy nj nk l nl nm">python -m cli_tutorial.cli -i path/to/some/file.csv <strong class="nf iu">--test</strong></span></pre><p id="8ac0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">server_url 等于“https://test . server . com/API/v2/upload”。如果我们不指定这三个标志中的任何一个，Click 将取- prod 的值，因为我设置了<em class="lh"> default=True </em>。</p><h2 id="7493" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">用户名和密码提示</h2><p id="bf40" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">不幸的是，或者说幸运的是:)，我们的服务器有密码保护。所以要上传我们的文件，我们需要一个用户名和密码。当然，您可以提供标准的 click.option 参数。但是，您的密码会以纯文本的形式出现在您的命令历史记录中。这可能会成为一个安全问题。</p><p id="15ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们喜欢提示用户输入密码，而不将密码回显到终端，也不将密码存储在命令历史中。对于用户名，我们也希望一个简单的提示<em class="lh">与</em>回显。当你知道点击时，没有比这更容易的了。这是代码。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ab25" class="mo lm it nf b gy nj nk l nl nm">import os<br/>...<br/>@click.option('--user', <strong class="nf iu">prompt=True</strong>,<br/>              <strong class="nf iu">default=lambda: os.environ.get('USER', '')</strong>)<br/>@click.<strong class="nf iu">password_option</strong>()<br/>def process(in_file, out_file, verbose, server_url, <strong class="nf iu">user</strong>, <strong class="nf iu">password</strong>):<br/>    ...<br/>    upload_to(server_url, output, user, password)</span></pre><p id="c0f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要为一个参数添加提示，你必须<em class="lh">设置提示=真</em>。每当用户没有指定- <em class="lh"> user </em>参数时，这将<em class="lh">添加</em>一个提示，但是她仍然可以这样指定。当您在提示符下点击 enter 键时，将使用默认的值。默认值由函数决定，这是 Click 提供的另一个便利特性。</p><p id="e89f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提示密码而不回显到终端并要求确认是如此普遍，以至于 Click 提供了一个名为<em class="lh"> password_option </em>的专用装饰器。重要的注释；这不会阻止用户通过-password my cretpassword 传递密码。这只能让她不那么做。</p><p id="4c78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。我们已经构建了完整的 CLI。在今天结束之前，我想在下一部分给你一个最后的提示。</p><h2 id="059e" class="mo lm it bd ln mp mq dn lr mr ms dp lv kr mt mu lz kv mv mw md kz mx my mh mz bi translated">诗歌脚本</h2><p id="85ed" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我想给你的最后一个技巧是创建<a class="ae kf" href="https://poetry.eustace.io/docs/pyproject/#scripts" rel="noopener ugc nofollow" target="_blank">诗歌脚本</a>，它与点击无关，但与 CLI 主题完全匹配。使用诗歌脚本，您可以创建可执行文件来从命令行调用您的 Python 函数，就像您使用<a class="ae kf" href="https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html#the-scripts-keyword-argument" rel="noopener ugc nofollow" target="_blank"> Setuptools 脚本</a>一样。那看起来怎么样？首先，需要将以下内容添加到 pyproject.toml 文件中</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e98b" class="mo lm it nf b gy nj nk l nl nm">[tool.poetry.scripts]<br/>your-wanted-name = 'cli_tutorial.cli:process'</span></pre><p id="d1be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">your-want-name</em>是<em class="lh"> cli_tutorial.cli </em>模块中定义的函数<em class="lh">进程</em>的别名。现在，你可以通过</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="add1" class="mo lm it nf b gy nj nk l nl nm">poetry run your-wanted-name -i ./dummy.csv --verbose --dev</span></pre><p id="8ca3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，这允许您向同一个文件添加多个 CLI 函数，定义别名，并且您不必添加<em class="lh"> if __name__ == "__main__" </em>块。</p><h1 id="4e83" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">包裹</h1><p id="cd9a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在本文中，我向您展示了如何使用点击和诗歌来轻松构建 CLI 工具，并提高工作效率。这只是 Click 提供的一小部分功能。还有很多其他的，比如<a class="ae kf" href="https://click.palletsprojects.com/en/7.x/options/#callbacks-and-eager-options" rel="noopener ugc nofollow" target="_blank">回调</a>、<a class="ae kf" href="https://click.palletsprojects.com/en/7.x/commands/#nested-handling-and-contexts" rel="noopener ugc nofollow" target="_blank">嵌套命令</a>，或者<a class="ae kf" href="https://click.palletsprojects.com/en/7.x/options/#choice-options" rel="noopener ugc nofollow" target="_blank">选择选项</a>等等。现在，我建议感兴趣的读者参考 Click 文档，但我可能会写一篇后续文章来讨论这些高级主题。敬请关注，感谢您关注这篇文章。如有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>