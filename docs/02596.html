<html>
<head>
<title>Take care of your privacy and create your own virtual private network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护您的隐私，创建您自己的虚拟专用网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/new-story-a6420a1f097?source=collection_archive---------13-----------------------#2019-04-28">https://towardsdatascience.com/new-story-a6420a1f097?source=collection_archive---------13-----------------------#2019-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8acbdd7a65cb113652900e3c269a34f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckp7M9UW2EI_yg5fKlTprQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk"><a class="ae kf" href="https://www.pinterest.co.uk/pin/330310953911450778/" rel="noopener ugc nofollow" target="_blank">Hacking Scence.</a></figcaption></figure><p id="6a55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您的智能手机或笔记本电脑连接到不可信的网络(如酒店、咖啡店或图书馆的 WiFi)时，您是否希望安全可靠地访问互联网？一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Virtual_private_network" rel="noopener ugc nofollow" target="_blank">虚拟专用网</a> (VPN)可以让你像在一个专用网上一样，安全地穿越不可信的网络。流量从 VPN 服务器流出，继续其到达目的地的旅程。</p><p id="3914" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://openvpn.net/" rel="noopener ugc nofollow" target="_blank"> OpenVPN </a>是一款功能全面、开源的安全套接字层(SSL) VPN 解决方案，支持多种配置。在这个由两部分组成的教程中，我们将使用 digital ocean 在 Ubuntu 服务器上设置一个 OpenVPN 服务器，然后配置从 Android 对它的访问。本教程将使每个设置的安装和配置步骤尽可能简单。让我们从第一部分开始，它包括安装和配置的前五个步骤。</p><h2 id="d634" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">第一步:安装 OpenVPN 和 EasyRSA</h2><p id="4284" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这一步适用于 VPN 服务器和 CA 机器。我们开始更新我们的包索引并安装 OpenVPN。OpenVPN 在 Ubuntu 的默认存储库中可用，所以我们可以使用<code class="fe mc md me mf b">apt</code>进行安装</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="517b" class="le lf it mf b gy mo mp l mq mr">$ sudo apt update <br/>$ sudo apt install openvpn</span></pre><p id="be38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenVPN 是一种 TLS/SSL VPN。这意味着它使用证书来加密服务器和客户端之间的流量。为了发布可信证书，我们将设置简单的证书颁发机构(CA)。为此，我们将从项目的官方 GitHub 资源库下载最新版本的 EasyRSA，我们将部署它来构建我们的 CA 公钥基础设施(PKI)。</p><p id="e754" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在独立的服务器上构建 CA。这种方法的原因是，如果攻击者能够渗透到我们的服务器，他们将能够访问我们的 CA 私钥，并使用它来签署新的证书，使他们能够访问我们的 VPN。因此，从独立机器管理 CA 有助于防止未经授权的用户访问我们的 VPN。还要注意，作为进一步的预防措施，建议我们在不使用 CA 服务器来签署密钥时将其关闭。</p><p id="2040" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了开始构建 CA 和 PKI 基础设施，我们使用<strong class="ki iu"> wget </strong>在我们的 CA 机器和 OpenVPN 服务器上下载最新版本的 EasyRSA。要获得最新版本，请进入官方 EasyRSA GitHub 项目的<a class="ae kf" href="https://github.com/OpenVPN/easy-rsa/releases" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">发布</strong>页面，复制以<code class="fe mc md me mf b">.tgz</code>结尾的文件的下载链接，然后将其粘贴到以下命令中:</a></p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="5f6a" class="le lf it mf b gy mo mp l mq mr">$ wget -P ~/ <a class="ae kf" href="https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.4/EasyRSA-3.0.4.tgz" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.4/EasyRSA-3.0.4.tgz</a></span></pre><p id="57ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后提取 tarball:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="875d" class="le lf it mf b gy mo mp l mq mr">$ cd ~ <br/>$ tar xvf EasyRSA-3.0.4.tgz</span></pre><p id="10a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经成功地在服务器和 CA 机器上安装了所有需要的软件。继续配置 EasyRSA 使用的变量，并设置一个 CA 目录，从中我们将生成我们的服务器和客户机访问 VPN 所需的密钥和证书。</p><h2 id="8387" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">第二步:配置 EasyRSA 变量并构建 CA 证书</h2><p id="465c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><strong class="ki iu">我们将仅在 CA 机器上遵循这些说明</strong>。EasyRSA 安装了一个配置文件，我们可以编辑它来为我们的 CA 定义一些变量。在我们的<strong class="ki iu"> CA 机器</strong>上，导航到 EasyRSA 目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="92d2" class="le lf it mf b gy mo mp l mq mr">$ cd ~/Documents/EasyRSA-3.0.4/</span></pre><p id="751d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个目录中有一个名为<code class="fe mc md me mf b">vars.example</code>的文件。我们制作了这个文件的副本，并将副本命名为<code class="fe mc md me mf b">vars</code>,没有文件扩展名:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d38b" class="le lf it mf b gy mo mp l mq mr">$ cp vars.example vars</span></pre><p id="97cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用我们首选的文本编辑器打开这个新文件，我们可以使用另一个编辑器，例如<em class="ms"> nano </em>编辑器:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6239" class="le lf it mf b gy mo mp l mq mr">$ vim vars</span></pre><p id="7de2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查找为新证书设置字段默认值的设置。它看起来会像这样:~/Documents/EasyRSA-3.0.4/vars</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="9dfb" class="le lf it mf b gy mo mp l mq mr">. . .</span><span id="9d6d" class="le lf it mf b gy mt mp l mq mr">#set_var EASYRSA_REQ_COUNTRY    "US"<br/>#set_var EASYRSA_REQ_PROVINCE   "California"<br/>#set_var EASYRSA_REQ_CITY       "San Francisco"<br/>#set_var EASYRSA_REQ_ORG        "Copyleft Certificate Co"<br/>#set_var EASYRSA_REQ_EMAIL      "me@example.net"<br/>#set_var EASYRSA_REQ_OU         "My Organizational Unit"</span><span id="1204" class="le lf it mf b gy mt mp l mq mr">. . .</span></pre><p id="0070" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">取消对这些行的注释，并将突出显示的值更新为我们喜欢的值，但我们不会将它们留空:~/Documents/EasyRSA-3.0.4/vars</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4547" class="le lf it mf b gy mo mp l mq mr">. . .</span><span id="ee99" class="le lf it mf b gy mt mp l mq mr">set_var EASYRSA_REQ_COUNTRY    "US"<br/>set_var EASYRSA_REQ_PROVINCE   "NewYork"<br/>set_var EASYRSA_REQ_CITY       "New York City"<br/>set_var EASYRSA_REQ_ORG        "DigitalOcean"<br/>set_var EASYRSA_REQ_EMAIL      "admin@example.com"<br/>set_var EASYRSA_REQ_OU         "Community"</span><span id="f07e" class="le lf it mf b gy mt mp l mq mr">. . .</span></pre><p id="3ed5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成后，保存并关闭文件。在 EasyRSA 目录中有一个名为<code class="fe mc md me mf b">easyrsa</code>的脚本，调用它来执行与构建和管理 CA 相关的各种任务。我们使用<code class="fe mc md me mf b">init-pki</code>选项运行这个脚本，在 CA 服务器上启动公钥基础设施:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="fa51" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa init-pki</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/87ba54557730413ddf14427d1f3f647b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wn0IAd3mQnJgCU0LFvSELw.png"/></div></figure><p id="c10e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一点上，我们再次调用<code class="fe mc md me mf b">easyrsa</code>脚本，在它后面加上<code class="fe mc md me mf b">build-ca</code>选项。这将构建 CA 并创建两个重要的文件<code class="fe mc md me mf b">ca.crt</code>和<code class="fe mc md me mf b">ca.key</code>，它们构成了 SSL 证书的公共端和私有端。</p><ul class=""><li id="fc20" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated"><code class="fe mc md me mf b">ca.crt</code>是 CA 的公共证书文件，在 OpenVPN 的上下文中，服务器和客户端使用该文件相互通知他们是同一个信任网络的一部分，而不是某人执行的<a class="ae kf" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人攻击</a>。因此，我们的服务器和所有客户端都需要一份<code class="fe mc md me mf b">ca.crt</code>文件的副本。</li><li id="72ba" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated"><code class="fe mc md me mf b">ca.key</code>是 CA 机器用来为服务器和客户端签署密钥和证书的私钥。如果攻击者能够访问我们的 CA，进而访问我们的文件，他们将能够签署证书请求并访问我们的 VPN，从而影响其安全性。这就是为什么我们的文件应该<strong class="ki iu">只有</strong>在我们的 CA 机器上，并且理想情况下，我们的 CA 机器应该在不签署证书请求时保持离线，作为额外的安全措施。</li></ul><p id="87ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不想每次与 CA 交互时都被提示输入密码，我们可以运行带有<code class="fe mc md me mf b">nopass</code>选项的<code class="fe mc md me mf b">build-ca</code>命令，如下所示:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="a4e7" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa build-ca nopass</span></pre><p id="2c09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在输出中，我们将被要求确认我们的 CA 的通用名称:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/aa8b6dec1b7b95fdba0d74c1eaac3e96.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Swb2B99gyrQUt9HjGeuncg.png"/></div></figure><p id="8e51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通用名称是在证书颁发机构的上下文中用来指代该机器的名称。我们可以输入任何字符串作为 CA 的通用名称，但是为了简单起见，按下<code class="fe mc md me mf b">ENTER</code>接受默认名称。这样，我们的 CA 就就位了，并准备好开始签署证书请求。</p><h2 id="b0d7" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">第三步:创建服务器证书、密钥和加密文件</h2><p id="6b1d" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><strong class="ki iu">我们将仅在服务器上遵循这些说明</strong>。现在我们已经有了一个准备好的 CA，我们可以从我们的服务器生成一个私钥和证书请求，然后将请求传送给我们的 CA 进行签名，创建所需的证书。我们也可以自由创建一些加密过程中使用的附加文件。首先导航到我们的<strong class="ki iu"> OpenVPN 服务器</strong>上的 EasyRSA 目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="bd32" class="le lf it mf b gy mo mp l mq mr">$ cd ~/Documents/EasyRSA-3.0.4/</span></pre><p id="ede7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从那里，用<code class="fe mc md me mf b">init-pki</code>选项运行<code class="fe mc md me mf b">easyrsa</code>脚本。虽然我们已经在 CA 机器上运行了这个命令，但是有必要在这里运行它，因为我们的服务器和 CA 将有单独的 PKI 目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="361f" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa init-pki</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/05b1069247a96c5d7e7e0ebb6e2d5d8d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*lGBxgmxHag5f0ck8LKUISA.png"/></div></figure><p id="d2b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后再次调用<code class="fe mc md me mf b">easyrsa</code>脚本，这次使用<code class="fe mc md me mf b">gen-req</code>选项，后跟机器的通用名称。同样，这可以是我们喜欢的任何东西，但最好是描述性的。在本教程中，OpenVPN 服务器的通用名称将简单地称为<strong class="ki iu">服务器</strong>。一定要包括<code class="fe mc md me mf b">nopass</code>选项。如果不这样做，将对请求文件进行密码保护，这可能会导致以后的权限问题:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="a7f4" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa gen-req server nopass</span></pre><p id="b0ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将为服务器创建一个私钥和一个名为<code class="fe mc md me mf b">server.req</code>的证书请求文件。将服务器密钥复制到<code class="fe mc md me mf b">/etc/openvpn/</code>目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d308" class="le lf it mf b gy mo mp l mq mr">$ sudo cp ~/Documents/EasyRSA-3.0.4/pki/private/server.key /etc/openvpn/</span></pre><p id="39e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">我们将仅在 CA 机器上遵循这些说明</strong>。使用一种安全的方法(比如下面例子中的 SCP ),将<code class="fe mc md me mf b">server.req</code>文件传输到我们的 CA 机器:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1e97" class="le lf it mf b gy mo mp l mq mr">$ scp -i ~/.ssh/id_rsa_do zaid@my_server_ip:~/Documents/EasyRSA-3.0.4/pki/reqs/server.req .</span></pre><p id="3428" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，在<strong class="ki iu">我们的 CA 机器</strong>上，导航到 EasyRSA 目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="eb78" class="le lf it mf b gy mo mp l mq mr">$ cd ~/Documents/EasyRSA-3.0.4/</span></pre><p id="2c30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再次使用<code class="fe mc md me mf b">easyrsa</code>脚本，导入<code class="fe mc md me mf b">server.req</code>文件，遵循具有其通用名称的文件路径:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="15b3" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa import-req /tmp/server.req server</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/6de67f44f21adb0b6e0e4ff3a2c10b2c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GUsc9W7lbdtXozELlhDu9A.png"/></div></figure><p id="76a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过运行带有<code class="fe mc md me mf b">sign-req</code>选项的<code class="fe mc md me mf b">easyrsa</code>脚本，后跟请求类型和通用名称，对请求进行签名。请求类型可以是<code class="fe mc md me mf b">client</code>或<code class="fe mc md me mf b">server</code>，因此对于 OpenVPN 服务器的证书请求，请确保使用<code class="fe mc md me mf b">server</code>请求类型:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d89b" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa sign-req server server</span></pre><p id="e75a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在输出中，我们将被要求验证请求是否来自可信的来源。键入<code class="fe mc md me mf b">yes</code>，然后按<code class="fe mc md me mf b">ENTER</code>确认:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/b47af28e2139985d9089381f34adfdf7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zFiYkJAXD-OdBfK9yOmU8g.png"/></div></figure><p id="495e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们加密了 CA 密钥，此时会提示我们输入密码。接下来，使用一种安全的方法将签名的证书传输回我们的 VPN 服务器:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="edff" class="le lf it mf b gy mo mp l mq mr">$ scp -i ~/.ssh/id_rsa_do pki/issued/server.crt zaid@my_server_ip:/tmp</span></pre><p id="c45f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在退出我们的 CA 机器之前，我们也将<code class="fe mc md me mf b">ca.crt</code>文件传输到我们的服务器:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3740" class="le lf it mf b gy mo mp l mq mr">$ scp -i ~/.ssh/id_rsa_do pki/ca.crt zaid@my_server_ip:/tmp</span></pre><p id="447c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">我们将只在服务器</strong>上遵循这些说明。接下来，重新登录到我们的 OpenVPN 服务器，并将<code class="fe mc md me mf b">server.crt</code>和<code class="fe mc md me mf b">ca.crt</code>文件复制到我们的<code class="fe mc md me mf b">/etc/openvpn/</code>目录中:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="ca75" class="le lf it mf b gy mo mp l mq mr">$ sudo cp /tmp/{server.crt,ca.crt} /etc/openvpn/</span></pre><p id="e9bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后导航到我们的 EasyRSA 目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="a83e" class="le lf it mf b gy mo mp l mq mr">$ cd ~/Documents/EasyRSA-3.0.4/</span></pre><p id="a91d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，通过键入以下命令创建一个强 Diffie-Hellman 密钥，以便在密钥交换期间使用:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d8e9" class="le lf it mf b gy mo mp l mq mr">$ ./easyrsa gen-dh</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/9cfecfd22a2831f99940728b1b098af8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Qrjv-mdpRGtbYog_aAKsyg.png"/></div></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/4846e074b07516efe29aa9123f8c8af8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8fXlNFCAR61iiebhSQckVw.png"/></div></figure><p id="0414" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能需要几分钟才能完成，<em class="ms">所以如果你在这里，我亲爱的读者，你可以喝杯茶，尽情享受。一旦完成，生成一个 HMAC 签名以增强服务器的 TLS 完整性验证能力:</em></p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="e040" class="le lf it mf b gy mo mp l mq mr">$ openvpn --genkey --secret ta.key</span></pre><p id="9cee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当命令完成时，我们将两个新文件复制到我们的<code class="fe mc md me mf b">/etc/openvpn/</code>目录中:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="8fa9" class="le lf it mf b gy mo mp l mq mr">$ sudo cp ~/Documents/EasyRSA-3.0.4/ta.key /etc/openvpn/<br/>$ sudo cp ~/Documents/EasyRSA-3.0.4/pki/dh.pem /etc/openvpn/</span></pre><p id="7675" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至此，我们的服务器所需的所有证书和密钥文件都已生成。我们已经准备好创建相应的证书和密钥，我们的客户机将使用它们来访问我们的 OpenVPN 服务器。</p><h1 id="200a" class="nj lf it bd lg nk nl nm lj nn no np lm nq nr ns lp nt nu nv ls nw nx ny lv nz bi translated">第四步:生成客户端证书和密钥文件</h1><p id="4b52" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们将只在服务器上遵循这些说明。虽然我们可以在客户机上生成私钥和证书请求，然后将其发送给 CA 进行签名，但本指南概述了在服务器上生成证书请求的过程。</p><blockquote class="oa ob oc"><p id="4d72" class="kg kh ms ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated"><em class="it">这样做的好处是，我们可以创建一个脚本来自动生成包含所有必需的密钥和证书的客户端配置文件。这让我们不必向客户端传输密钥、证书和配置文件，并简化了加入 VPN 的过程。</em></p><p id="dcba" class="kg kh ms ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated"><em class="it">最佳实践</em></p></blockquote><p id="03a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将为本指南生成一个客户端密钥和证书对。如果我们有多个客户，我们可以对每个客户重复这个过程。但是请注意，我们需要为每个客户端的脚本传递一个唯一的名称值。在本教程中，第一个证书/密钥对被称为<code class="fe mc md me mf b">client1</code>。</p><p id="3efe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，在我们的主目录中创建一个目录结构来存储客户端证书和密钥文件:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2c2d" class="le lf it mf b gy mo mp l mq mr">$ mkdir -p ~/client-configs/keys</span></pre><p id="a602" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们将在此目录中存储客户端的证书/密钥对和配置文件，因此作为一项安全措施，我们现在应该锁定其权限:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3857" class="le lf it mf b gy mo mp l mq mr">$ chmod -R 700 ~/client-configs</span></pre><p id="971b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，导航回我们的 EasyRSA 目录，运行带有<code class="fe mc md me mf b">gen-req</code>和<code class="fe mc md me mf b">nopass</code>选项的<code class="fe mc md me mf b">easyrsa</code>脚本，以及客户端的通用名称:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="90c6" class="le lf it mf b gy mo mp l mq mr">$ cd ~/Documents/EasyRSA-3.0.4/<br/>$ ./easyrsa gen-req client1 nopass</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/05a999341b1b1f1740af4b81ffe3726d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wC8ZHVEnrhlEq1IkZAya_w.png"/></div></figure><p id="83ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按<code class="fe mc md me mf b">ENTER</code>确认常用名。然后，将<code class="fe mc md me mf b">client1.key</code>文件复制到我们之前创建的<code class="fe mc md me mf b">/client-configs/keys/</code>目录中:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="ac92" class="le lf it mf b gy mo mp l mq mr">$ cp pki/private/client1.key ~/client-configs/keys/</span></pre><p id="d63d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，使用安全方法<strong class="ki iu">将<code class="fe mc md me mf b">client1.req</code>文件传输到我们的 CA 机器。我们将仅在 CA 机器</strong>上遵循这些说明。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="de3c" class="le lf it mf b gy mo mp l mq mr">$ sudo scp -i ~/.ssh/id_rsa_do zaid@my_server_ip:~/Documents/EasyRSA-3.0.4/pki/reqs/client1.req .</span></pre><p id="f5a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们导航到 EasyRSA 目录，并导入证书请求:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="058a" class="le lf it mf b gy mo mp l mq mr">$ cd ~/Documents/EasyRSA-3.0.4/<br/>$ sudo ./easyrsa import-req /tmp/client1.req client1</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/45143cde794ffaac5924e90693a9211d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9bnsax32WbTlxdO48goPdg.png"/></div></figure><p id="882c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后像我们在上一步中对服务器所做的那样对请求进行签名。不过，这次一定要指定<code class="fe mc md me mf b">client</code>请求类型:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4f6c" class="le lf it mf b gy mo mp l mq mr">$ cd pki/reqs<br/>$ sudo chown zeyd:zeyd client1.req<br/>$ ./easyrsa sign-req client client1</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/df97138dc070cb2a812e119010d0d8c7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EgAEEqzaZhNmI60FmMg5GA.png"/></div></figure><p id="1d32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在提示符下，输入<code class="fe mc md me mf b">yes</code>以确认我们打算对证书请求进行签名，并且它来自受信任的来源。同样，如果我们加密了 CA 密钥，这里会提示我们输入密码。这将创建一个名为<code class="fe mc md me mf b">client1.crt</code>的客户端证书文件。将此文件传输回服务器:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="5a47" class="le lf it mf b gy mo mp l mq mr">$ scp -i ~/.ssh/id_rsa_do pki/issued/client1.crt zaid@my_server_ip:~/client-configs/keys/</span></pre><p id="7fa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将只在服务器上遵循这些指示。接下来，我们也将<code class="fe mc md me mf b">ca.crt</code>和<code class="fe mc md me mf b">ta.key</code>文件复制到<code class="fe mc md me mf b">/client-configs/keys/</code>目录:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d9c6" class="le lf it mf b gy mo mp l mq mr">$ cp ~/Documents/EasyRSA-3.0.4/ta.key ~/client-configs/keys/<br/>$ sudo cp /etc/openvpn/ca.crt ~/client-configs/keys/</span></pre><p id="b0b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们的服务器和客户机的证书和密钥都已生成，并存储在服务器上的适当目录中。仍然需要对这些文件执行一些操作，但是这些将在后面的步骤中进行。现在，我们可以继续在我们的服务器上配置 OpenVPN。</p><h1 id="eb6d" class="nj lf it bd lg nk nl nm lj nn no np lm nq nr ns lp nt nu nv ls nw nx ny lv nz bi translated">第五步:配置 OpenVPN 服务</h1><p id="b808" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><strong class="ki iu">我们将仅在服务器上遵循这些说明</strong>。现在，我们的客户机和服务器的证书和密钥都已经生成，我们可以开始配置 OpenVPN 服务来使用这些凭证。首先将一个示例 OpenVPN 配置文件复制到配置目录中，然后提取它，以便将其用作我们设置的基础:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2803" class="le lf it mf b gy mo mp l mq mr">$ sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/<br/>$ sudo gzip -d /etc/openvpn/server.conf.gz</span></pre><p id="70d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们首选的文本编辑器中打开服务器配置文件:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="463a" class="le lf it mf b gy mo mp l mq mr">$ sudo vim /etc/openvpn/server.conf</span></pre><p id="5939" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过查找<code class="fe mc md me mf b">tls-auth</code>指令找到 HMAC 部分。这一行应该已经被取消了注释，但是如果没有，那么删除"<strong class="ki iu">；</strong>“取消注释。在这一行下面，添加<code class="fe mc md me mf b">key-direction</code>参数，设置为" 0":/etc/openvpn/server.conf</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="8c15" class="le lf it mf b gy mo mp l mq mr">tls-auth ta.key 0 # This file is secret<br/>key-direction 0</span></pre><p id="35e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，通过查找注释掉的<code class="fe mc md me mf b">cipher</code>行，找到关于加密算法的部分。<code class="fe mc md me mf b">AES-256-CBC</code>密码提供了很好的加密级别，并得到了很好的支持。同样，这一行应该已经被取消了注释，但是如果没有，那么就删除"<strong class="ki iu">；</strong>"前置:/etc/openvpn/server.conf</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="bf13" class="le lf it mf b gy mo mp l mq mr">cipher AES-256-CBC</span></pre><p id="f96d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之下，添加一个<code class="fe mc md me mf b">auth</code>指令来选择 HMAC 消息摘要算法。为此，<code class="fe mc md me mf b">SHA256</code>是个不错的选择:/etc/openvpn/server.conf</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="660f" class="le lf it mf b gy mo mp l mq mr">auth SHA256</span></pre><p id="cfe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，找到包含定义 Diffie-Hellman 参数的<code class="fe mc md me mf b">dh</code>指令的行。由于最近对 EasyRSA 进行了一些更改，Diffie-Hellman 密钥的文件名可能与示例服务器配置文件中列出的不同。如有必要，通过删除<code class="fe mc md me mf b">2048</code>来更改此处列出的文件名，使其与我们在上一步中生成的密钥一致:/etc/openvpn/server.conf</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="180d" class="le lf it mf b gy mo mp l mq mr">dh dh.pem</span></pre><p id="e52b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，找到<code class="fe mc md me mf b">user</code>和<code class="fe mc md me mf b">group</code>设置，去掉<strong class="ki iu">；</strong>"在每一行的开头取消对这些行的注释:/etc/openvpn/server.conf</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3587" class="le lf it mf b gy mo mp l mq mr">user nobody<br/>group nogroup</span></pre><p id="0b9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们对样本<code class="fe mc md me mf b">server.conf</code>文件所做的更改对于 OpenVPN 的运行是必要的。下面列出的更改是可选的，尽管它们对于许多常见用例来说也是必需的。</p><p id="10d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Udemy 上查看我们的免费课程。 </p><blockquote class="og"><p id="7139" class="oh oi it bd oj ok ol om on oo op ld dk translated"><em class="oq">感谢阅读。如果你喜欢这篇文章，请点击下面的按钮，这样我们就可以保持联系。</em></p></blockquote><p id="e692" class="pw-post-body-paragraph kg kh it ki b kj or kl km kn os kp kq kr ot kt ku kv ou kx ky kz ov lb lc ld im bi translated"><strong class="ki iu"> <em class="ms">注来自《走向数据科学》的编辑:</em> </strong> <em class="ms">虽然我们允许独立作者根据我们的</em> <a class="ae kf" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="ms">规则和指导方针</em> </a> <em class="ms">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae kf" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="ms">读者术语</em> </a> <em class="ms">。</em></p></div></div>    
</body>
</html>