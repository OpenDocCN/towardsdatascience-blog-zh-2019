<html>
<head>
<title>Object-oriented programming for data scientists: Build your ML estimator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据科学家的面向对象编程:构建您的 ML 估计器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-oriented-programming-for-data-scientists-build-your-ml-estimator-7da416751f64?source=collection_archive---------2-----------------------#2019-07-10">https://towardsdatascience.com/object-oriented-programming-for-data-scientists-build-your-ml-estimator-7da416751f64?source=collection_archive---------2-----------------------#2019-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e228" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">逐步指南</h2><div class=""/><div class=""><h2 id="741e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过构建您自己的 Scikit-learn-like 估计器，在机器学习环境中实现一些核心的 OOP 原则，并使其变得更好。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1a0fbcef469764b1ee4e670fce666cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_XOnlAT7CEkkhedW7kZEg.jpeg"/></div></div></figure><p id="d921" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">更新</strong>:在这里 你总能找到最新的 Python 脚本(带有线性回归类定义和方法)<a class="ae lz" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/OOP_in_ML/Class_MyLinearRegression.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">。用它来进一步构建或实验。</strong></a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9f4a" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">有什么问题？</h1><p id="964e" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">数据科学家的背景通常与传统的计算机科学/软件工程相去甚远——物理学、生物学、统计学、经济学、电子工程等。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://medium.com/indeed-engineering/where-do-data-scientists-come-from-fc526023ace"><div class="gh gi ne"><img src="../Images/386e5f4a4cf0ecfe697a7988318f92d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TrlIleH6DqR_eZumY1PBQ.png"/></div></a><figcaption class="nf ng gj gh gi nh ni bd b be z dk"><strong class="bd nj">Source</strong>: <a class="ae lz" href="https://medium.com/indeed-engineering/where-do-data-scientists-come-from-fc526023ace" rel="noopener">“Where do Data Scientists Come From?”</a></figcaption></figure><p id="fa00" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是最终，他们被期望获得足够数量的编程/软件工程，以对他们的组织和业务产生真正的影响。</p><div class="nk nl gp gr nm nn"><a rel="noopener follow" target="_blank" href="/being-a-data-scientist-does-not-make-you-a-software-engineer-c64081526372"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">成为数据科学家并不能让你成为软件工程师！</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">如何构建可扩展的机器学习系统——第 1/2 部分</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lb nn"/></div></div></a></div><p id="67bd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">大多数现代编程语言和软件工程范例的核心是什么？</p><p id="3188" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html" rel="noopener ugc nofollow" target="_blank">面向对象编程。</a></p><p id="1803" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是对于外行人来说，OOP 的<a class="ae lz" href="https://realpython.com/python3-object-oriented-programming/" rel="noopener ugc nofollow" target="_blank">原则起初可能感觉有点陌生，甚至有点吓人。因此，数据科学家，其背景不包括计算机编程的正式培训，可能会发现 OOP 的概念在他们的日常工作中有些难以接受。</a></p><p id="30f7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">流行的 MOOCs 和数据科学/人工智能/人工智能训练营也没有帮助。</p><p id="2b0e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">他们试图给初露头角的数据科学家一种混合汤的味道，包括统计学、数值分析、科学编程、机器学习(ML)算法、可视化，甚至可能还有一点 web 框架来部署这些 ML 模型。</p><p id="c0a4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">几乎所有这些都可以学习和实践，即使没有严格遵守 OOP 的原则。事实上，年轻的数据科学家渴望学习最新的神经网络架构或最酷的数据可视化技术，如果被 OOP 编程范式的所有细节轰炸，他们甚至会感到窒息。因此，MOOCs 通常不会在他们的数据科学课程中混合或强调它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/c656860a04c8b828df596ecc918a2094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYxPOKNAefv_2B3NkFNsSw.png"/></div></div></figure><h1 id="dce9" class="mh mi it bd mj mk od mm mn mo oe mq mr ki of kj mt kl og km mv ko oh kp mx my bi translated">一个简单的例子(还有更多…)</h1><p id="73ef" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">让我用 Python 来举例说明这个问题，因为它是数据科学和机器学习任务发展最快的语言。</p><h2 id="467d" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">算术示例</h2><p id="b7f4" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">如果让你写一个程序来实现涉及两个数<code class="fe ot ou ov ow b">a</code>和<code class="fe ot ou ov ow b">b</code>的加、减、乘、除，你最有可能做什么？</p><p id="bf6c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你很可能会打开一个 Jupyter 笔记本，在一个单元格中键入以下内容，点击<em class="ox"> shift-enter </em>并获得结果。</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="ff18" class="oi mi it ow b gy pc pd l pe pf">a+b<br/>a-b<br/>a*b<br/>a/b</span></pre><p id="f6ee" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你喜欢用函数来整理东西，那么你可以这样做，</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="53f9" class="oi mi it ow b gy pc pd l pe pf">def add(a,b):<br/>    return a+b<br/>...</span></pre><p id="5e93" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是你会定义一个 Calc <strong class="lf jd"> <em class="ox">类</em> </strong>并把这些函数作为<strong class="lf jd"> <em class="ox">方法</em> </strong>放在那个类里面吗？这些都是性质相似的操作，它们处理相似的数据。那么为什么不把它们封装在一个更高阶的对象中呢？为什么不是下面的代码？</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="1b6e" class="oi mi it ow b gy pc pd l pe pf">class Calc:<br/>    def __init__(self,a,b):<br/>        self.a = a<br/>        self.b = b<br/>    def add(self):<br/>        return self.a+self.b<br/>    def sub(self):<br/>        return self.a-self.b<br/>    def mult(self):<br/>        return self.a*self.b<br/>    def div(self):<br/>        return self.a/self.b</span></pre><p id="e466" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不，你不会这么做的。对于这个特殊的问题，这样做可能也没有意义。但是这个想法是有效的— <em class="ox">如果你有数据和函数(在 OOP 的说法中称为方法),它们可以逻辑地组合，那么它们应该封装在一个类中</em>。</p><p id="0799" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是对于一些简单的数值计算来说，快速得到答案看起来太麻烦了。那么，有什么意义呢？数据科学家的价值通常在于他们能否得到数据问题的正确答案，而不是他们在代码中使用了什么样的复杂对象。</p><h2 id="235a" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">数据科学家的例子</h2><p id="e70e" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">如果数据科学家不是以这种方式编码，难道不是吗，他们真的不需要使用这些精心设计的编程结构？</p><p id="6b25" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">错了。</strong></p><p id="b04c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在没有意识到的情况下，数据科学家大量使用了 OOP 范例的好处。<strong class="lf jd">无时无刻</strong>。</p><p id="3c17" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">还记得<code class="fe ot ou ov ow b">import matplotlib.pyplot as plt</code>后的<code class="fe ot ou ov ow b">plt.plot</code>吗？</p><p id="1ad1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">那些<strong class="lf jd">。</strong>符号。你有一点面向对象编程的知识。就在那里。</p><p id="52be" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者，你还记得在 Jupyter 笔记本上学习很酷的技巧——在放一个点(.)，从而显示可以与一个<em class="ox">对象</em>关联的所有功能？像这样，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/84f4c1ee8d6187fb2766db582e19a672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0C8A1kJdM6pU4h9qOXSkA.png"/></div></div></figure><h2 id="dc7d" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">这个例子说明了什么？</h2><p id="ccc4" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">这个例子显示了对逻辑一致性的坚持。</p><p id="4fc4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果没有 OOP 范例，我们将不得不把这些函数命名为<code class="fe ot ou ov ow b">linear_model_linear_regression_fit</code>、<code class="fe ot ou ov ow b">linear_model_linear_regression_predict</code>等等。它们不会被归入一个共同的逻辑单元。</p><p id="7143" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为什么？因为它们是不同的函数，处理不同的数据集。当<code class="fe ot ou ov ow b">fit</code>函数期望训练特征和目标时，<code class="fe ot ou ov ow b">predict</code>只需要一个测试数据集。<code class="fe ot ou ov ow b">fit</code>函数不会返回任何结果，而<code class="fe ot ou ov ow b">predict</code>会返回一组预测。</p><p id="0128" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">那么，为什么它们在同一个下拉菜单</strong>下可见呢？尽管有所不同，但它们有一个共同点，即<em class="ox">它们都可以被想象为整个线性回归过程的重要组成部分</em> —我们希望线性回归能够拟合一些训练数据，然后能够预测未来的未知数据。我们还希望线性回归模型能为我们提供一些关于拟合程度的指示，通常是以一个称为回归系数或 R 的单一数字量或分数的形式。正如我们所料，我们看到一个函数<code class="fe ot ou ov ow b">score</code>，它确切地返回 R 数，也在<code class="fe ot ou ov ow b">fit</code>和<code class="fe ot ou ov ow b">predict</code>附近。</p><p id="64db" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">整洁干净，不是吗？</p><blockquote class="ph pi pj"><p id="ead0" class="ld le ox lf b lg lh kd li lj lk kg ll pk ln lo lp pl lr ls lt pm lv lw lx ly im bi translated">数据、函数和参数共存于单个逻辑单元中。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://python.swaroopch.com/oop.html"><div class="gh gi pn"><img src="../Images/7cb802322ec36d026637e610472daa8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtGDL8Ol7WZMoaBssJVkog.png"/></div></a></figure><h2 id="ec37" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">这是如何实现的？</h2><p id="40db" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">这是可能的，因为<strong class="lf jd">我们超越了个体差异，将线性回归视为一个高层次的过程</strong>，并决定它应该服务于什么样的基本操作以及它应该告知用户什么样的关键参数。</p><p id="eec3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们创建了一个名为<code class="fe ot ou ov ow b">LinearRegression</code>的高级类，在这个类下，所有那些明显不同的功能可以被组合在一起，以便于记账和增强可用性。</p><p id="1a1b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一旦我们从库中导入了这个类，我们只需要创建这个类的一个实例——我们称之为<code class="fe ot ou ov ow b">lm</code>。就是这样。我们可以通过新定义的实例<code class="fe ot ou ov ow b">lm</code>访问该类下的所有函数。</p><p id="0448" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们对函数的一些内部实现不满意，我们可以对它们进行处理，并在修改后将其重新附加到主类。只有内部函数的代码会改变，其他都不会改变。</p><p id="1ca4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">看，这听起来多有逻辑性和可伸缩性？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/3311a7effdadb9be3a51c3f2faec05ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nzq0H9VzkC-L4ap3hLxR1g.png"/></div></div></figure><h1 id="60cc" class="mh mi it bd mj mk od mm mn mo oe mq mr ki of kj mt kl og km mv ko oh kp mx my bi translated">创建您自己的 ML 估计器</h1><p id="fbb2" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">传统的 OOP 入门会有很多使用类的例子，比如动物、运动、几何形状。</p><p id="edb0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是对于数据科学家来说，<strong class="lf jd">为什么不使用他们每天在代码中使用的一个对象的例子来说明这些概念呢——机器学习估计器</strong>。就像 Scikit-learn 库中的<code class="fe ot ou ov ow b">lm</code>对象，如上图所示。</p><h2 id="91a2" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">一个很好的、古老的线性回归估计器——有所改变</h2><p id="5709" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated"><a class="ae lz" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/OOP_in_ML" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">在这个 Github repo </strong> </a>中，我一步一步地展示了如何遵循 OOP 范例构建一个简单的线性回归(单变量或多变量)估计器类。</p><p id="1b19" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">没错，就是好老的线性回归类。它有 Scikit-learn 的<code class="fe ot ou ov ow b">LinearRegression</code>类中常见的<code class="fe ot ou ov ow b">fit</code>和<code class="fe ot ou ov ow b">predict</code>方法。但是它有更多的功能。这里先睹为快…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/1aafb9837c021cb8c5cb322c12fb8dea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHBGiPDfwkOqF-MDL_a1bQ.png"/></div></div></figure><p id="802a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">是的，这个估计器比 Scikit-learn 估计器更丰富，因为除了标准的<code class="fe ot ou ov ow b">fit</code>、<code class="fe ot ou ov ow b">predict</code>和 R <code class="fe ot ou ov ow b">score</code>函数之外，<strong class="lf jd">它还有许多其他实用程序，这些实用程序对于线性回归建模任务</strong>是必不可少的。</p><p id="327b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尤其是对于数据科学家和统计建模人员来说，他们不仅想预测，而且也想</p><ul class=""><li id="7983" class="pq pr it lf b lg lh lj lk lm ps lq pt lu pu ly pv pw px py bi translated">测量<a class="ae lz" href="https://blog.minitab.com/blog/adventures-in-statistics-2/regression-analysis-how-do-i-interpret-r-squared-and-assess-the-goodness-of-fit" rel="noopener ugc nofollow" target="_blank">拟合优度</a>，</li><li id="4142" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated">验证线性回归的<a class="ae lz" href="https://statisticsbyjim.com/regression/ols-linear-regression-assumptions/" rel="noopener ugc nofollow" target="_blank">假设</a>，</li><li id="fc30" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated">检查数据中的多重共线性，或</li><li id="4768" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated">检测<a class="ae lz" href="https://stattrek.com/regression/influential-points.aspx" rel="noopener ugc nofollow" target="_blank">异常值</a>。</li></ul><div class="nk nl gp gr nm nn"><a rel="noopener follow" target="_blank" href="/how-do-you-check-the-quality-of-your-regression-model-in-python-fa61759ff685"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">如何在 Python 中检查你的回归模型的质量？</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">线性回归在统计学习中根深蒂固，因此必须检查模型的“良好性”</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="qe l ny nz oa nw ob lb nn"/></div></div></a></div><h2 id="4009" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">你如何开始构建类？</h2><p id="5030" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">我们从一个简单的代码片段开始定义这个类。我们把它命名为——<code class="fe ot ou ov ow b">MyLinearRegression</code>。</p><p id="f7b6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里，<code class="fe ot ou ov ow b">self</code>表示对象本身，<code class="fe ot ou ov ow b">__init__</code>是一个<a class="ae lz" href="https://micropyramid.com/blog/understand-self-and-__init__-method-in-python-class/" rel="noopener ugc nofollow" target="_blank">特殊函数，当在代码中的某个地方创建了一个类的实例</a>时，就会调用这个函数。顾名思义，<code class="fe ot ou ov ow b">__init__</code>可以用来初始化带有必要参数(如果有的话)的类。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/448b7a0fe745e7a44f27ef4cfb1effed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5GqUKT1PgqcYP2L1EJ47A.png"/></div></div></figure><p id="35ce" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以添加一个简单的描述字符串来保持它的真实性:-)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/929f574d76f1f15cb56d9ff7bd9686f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0zKGYFqS3Mx4odyRPwC2Q.png"/></div></div></figure><p id="1b54" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来我们添加核心的<code class="fe ot ou ov ow b">fit</code>方法。注意<a class="ae lz" href="https://www.geeksforgeeks.org/python-docstrings/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> docstring </strong> </a>描述了该方法的用途、它做什么以及它期望什么类型的数据。所有这些都是好的面向对象原则的一部分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/cdae97f269ea66e7e07d6a368c58dedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*oNK55U3LdmXK5-6aIFVGvg.png"/></div></figure><p id="73a8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以生成一些随机数据来测试我们的代码。我们创建一个两个变量的线性函数。这是数据的散点图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/0c9b6a8fe540da553031a1dfc48e74b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYGDjhKRO6b0JT-fRrQX1w.png"/></div></div></figure><p id="df8c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，我们可以创建一个名为<code class="fe ot ou ov ow b">mlr</code>的类<code class="fe ot ou ov ow b">MyLinearRegression</code>的实例。如果我们试图打印回归参数会发生什么？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qj"><img src="../Images/6cd05f66bc60369487613aa5bba47669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojeY7TwWZR_jmi9RDYNraQ.png"/></div></div></figure><p id="65e6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因为<code class="fe ot ou ov ow b">self.coef_</code>被设置为<code class="fe ot ou ov ow b">None</code>，我们在试图打印<code class="fe ot ou ov ow b">mlr.coef_</code>时得到相同的结果。请注意，self 一旦被创建，就变成了类实例的同义词。</p><p id="1cbf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是<code class="fe ot ou ov ow b">fit</code>的定义包括在拟合完成后设置属性。所以，我们可以直接调用<code class="fe ot ou ov ow b">mlr.fit()</code>，打印出拟合的回归参数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/b8c71b3a4634ba552028ef43b804ae77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sW_El43vAm7FCtNnU9fQw.png"/></div></div></figure><h2 id="959a" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">最典型的<code class="fe ot ou ov ow b">Predict</code>方法</h2><p id="8b8a" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">拟合之后，就是预测。我们可以很容易地将该方法添加到我们的回归类中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/f500f95d5cb8b132a1f43e038980ec5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*IvHmTCLzsIwY3tk0wnxmNA.png"/></div></figure><h2 id="92e5" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">如果我们想添加一个(或几个)绘图实用函数呢？</h2><p id="f925" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">在这一点上，我们开始扩展我们的回归类，并且<strong class="lf jd">添加了标准 scikit-learn 类中没有的东西！</strong>例如，我们总是希望看到拟合值与地面真实值相比如何。为此创建一个函数很容易。我们就叫它<code class="fe ot ou ov ow b">plot_fitted</code>。</p><p id="9972" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，<a class="ae lz" href="https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function/29379748" rel="noopener ugc nofollow" target="_blank">方法类似于普通函数</a>。它可以接受额外的参数。这里，我们有一个参数<code class="fe ot ou ov ow b">reference_line</code>(默认设置为<code class="fe ot ou ov ow b">False</code>)，它在拟合与真实曲线上绘制了一条 45 度参考线。另外，请注意 docstring 描述。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/33dc4cd77831053c2518707a82b9a72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3VS7Uu_VHxqFSuDwnKcMg.png"/></div></div></figure><p id="4ae1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以通过简单地执行以下操作来测试方法<code class="fe ot ou ov ow b">plot_fitted</code>,</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="49b7" class="oi mi it ow b gy pc pd l pe pf">m = MyLinearRegression()<br/>m.fit(X,y)<br/>m.plot_fitted()</span></pre><p id="3aed" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者，我们可以选择画一条参考线，</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="0df8" class="oi mi it ow b gy pc pd l pe pf">m.plot_fitted(reference_line=True)</span></pre><p id="a922" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们得到以下情节！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/d91ee1e4637ecd27d0690002b8cc7f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Breja-YYTpyKdAUupZPxEg.png"/></div></div></figure><p id="3717" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一旦我们明白我们可以添加任何有用的方法来处理相同的数据(一个训练集)，与相同的目的(线性回归)相关，就没有束缚我们的想象力了！我们把下面的情节加到我们班怎么样？</p><ul class=""><li id="3489" class="pq pr it lf b lg lh lj lk lm ps lq pt lu pu ly pv pw px py bi translated"><strong class="lf jd"> Pairplots </strong>(绘制所有特性和输出之间的成对关系，很像 R 中的<code class="fe ot ou ov ow b">pairs</code>函数)</li><li id="6095" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated"><strong class="lf jd">拟合与残差</strong>图(这属于线性回归的诊断图，即检查基本假设的有效性)</li><li id="bfc9" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated"><strong class="lf jd">直方图</strong>和<strong class="lf jd">分位数-分位数(Q-Q) </strong>残差图(检查误差分布的正态假设)</li></ul><h2 id="f039" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">继承——不要让你的主类负担过重</h2><p id="0d0f" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">当我们热情地计划将实用方法添加到类中时，我们认识到这种方法可能会使主类的代码非常长，并且难以调试。为了解决这个难题，我们可以利用 OOP 的另一个美丽的原则— <strong class="lf jd"> </strong> <a class="ae lz" href="https://www.geeksforgeeks.org/inheritance-in-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">继承</strong> </a>。</p><div class="nk nl gp gr nm nn"><a href="https://www.geeksforgeeks.org/inheritance-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">Python 中的继承- GeeksforGeeks</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">继承是一个类从另一个类派生或继承属性的能力。…的好处</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nw l"><div class="qo l ny nz oa nw ob lb nn"/></div></div></a></div><p id="0ed4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们进一步认识到<strong class="lf jd">并非所有的图都属于同一类型</strong>。配对图和拟合与真实数据图具有相似的性质，因为它们只能从数据中获得。其他图与拟合优度和残差相关。</p><p id="f433" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们可以用这些绘图函数创建两个独立的类— <code class="fe ot ou ov ow b">Data_plots</code>和<code class="fe ot ou ov ow b">Diagnostic_plots</code>。</p><p id="5c7d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你猜怎么着！我们可以根据这些实用程序类 来定义我们的主<code class="fe ot ou ov ow b">MyLinearRegression</code>类<strong class="lf jd"> <em class="ox">。那是继承的一个例子。</em></strong></p><p id="3f86" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意:这看起来和标准的父类-子类继承实践有点不同，但是语言的相同特性在这里被用来保持主类的整洁和紧凑，同时从其他类似构造的类继承有用的方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/d6d9668fdd58a393292ecb1e04004a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3A2Gm2FTriEQfdQGfkcxbQ.png"/></div></div></figure><p id="b13a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意以下代码片段仅用于说明。请使用上面的 Github 链接查看实际代码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/392b18100906efe3d41db80acb7624c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdREqLUvf8_gG2hT6gRqiQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk"><code class="fe ot ou ov ow b">Data_plots</code> class</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qr"><img src="../Images/2aae080e7927a8f1a56253a617358132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZ3hVlZXIB2X2qBc104l5A.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">Diagnostics_plots class</figcaption></figure><p id="e0de" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">而<code class="fe ot ou ov ow b">MyLinearregression</code>的定义只是略有改变，</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="aea3" class="oi mi it ow b gy pc pd l pe pf"><strong class="ow jd">class MyLinearRegression(Diagnostics_plots,Data_plots</strong>):<br/>    <br/>    def __init__(self, fit_intercept=True):<br/>        self.coef_ = None<br/>        self.intercept_ = None<br/>        self._fit_intercept = fit_intercept<br/>...</span></pre><p id="bbad" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通过简单地将<code class="fe ot ou ov ow b">Data_plots</code>和<code class="fe ot ou ov ow b">Diagnostics_plots</code>的引用传递给<code class="fe ot ou ov ow b">MyLinearRgression</code>类的定义，我们继承了这些类的所有方法和属性。</p><p id="7d40" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，为了检查误差项的正态假设，我们可以简单地拟合模型并运行这些方法。</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="5ff0" class="oi mi it ow b gy pc pd l pe pf">m = MyLinearRegression() # A brand new model instance<br/>m.fit(X,y) # Fit the model with some data</span><span id="c990" class="oi mi it ow b gy qs pd l pe pf"><strong class="ow jd">m.histogram_resid()</strong> # Plot histogram of the residuals<br/><strong class="ow jd">m.qqplot_resid()</strong> # Q-Q plot of the residuals</span></pre><p id="ea10" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们得到，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qt"><img src="../Images/73e3acd1a62bddd15bb79c52ed64ea87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZDzG7sadyRntVCNm7PKfg.png"/></div></div></figure><p id="da57" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，代码分离在这里起作用。您可以修改和改进核心绘图实用程序，而无需触及主类。高度灵活且不易出错的方法！</p><h1 id="0246" class="mh mi it bd mj mk od mm mn mo oe mq mr ki of kj mt kl og km mv ko oh kp mx my bi translated">利用 OOP 的强大功能做更多事情</h1><p id="abfe" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">我们不会进一步详述我们可以添加到<code class="fe ot ou ov ow b">MyLinearRegression</code>中的各种实用程序类和方法。可以<a class="ae lz" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/OOP_in_ML" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">查看 Github 回购</strong> </a>。</p><h2 id="394a" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">添加了其他类别</h2><p id="2011" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">为了完整起见，我们补充说，</p><ul class=""><li id="a246" class="pq pr it lf b lg lh lj lk lm ps lq pt lu pu ly pv pw px py bi translated">用于计算各种回归指标的类<code class="fe ot ou ov ow b">Metrics</code>——SSE、SST、MSE、<em class="ox"> R </em>和调整后的<em class="ox"> R </em>。</li><li id="f199" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated">一个类<code class="fe ot ou ov ow b">Outliers</code>来绘制库克的距离、杠杆和影响图</li><li id="4ee7" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated">计算方差膨胀因子的类<code class="fe ot ou ov ow b">Multicollinearity</code>(VIF)</li></ul><p id="fce6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">总而言之，这个宏伟的计划看起来如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qu"><img src="../Images/e72c30eb8cf5b836c56787f3b87c42fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEX7iiMS218eDmtmo2borA.png"/></div></div></figure><p id="6bde" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个类比 Scikit-learn 的 LinearRegression 类丰富吗？你决定吧。</p><h2 id="0de8" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">通过创建分组实用程序来添加语法糖</h2><p id="6b4a" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">一旦你继承了其他类，它们的行为就像你熟悉的 Python 模块一样。因此，您可以向主类添加实用方法，以便一起执行子类中的多个方法。</p><p id="4278" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，以下方法一次运行所有常规诊断检查。注意我们是如何通过放置一个简单的<strong class="lf jd">来访问绘图方法的。点号</strong>即<code class="fe ot ou ov ow b">Diagnostics_plot.histogram_resid</code>。就像从熊猫或 NumPy 库中访问一个函数一样！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/6cc85ee337b45fcb2454bb6aa423f80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*dC-48wpBj22qgDo9vuJz0g.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">run_diagnostics method in the main class</figcaption></figure><p id="cc5f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这样，我们可以在拟合数据后用一行代码运行所有的诊断。</p><pre class="ks kt ku kv gt oy ow oz pa aw pb bi"><span id="0b15" class="oi mi it ow b gy pc pd l pe pf">m = MyLinearRegression() # A brand new model instance<br/>m.fit(X,y) # Fit the model with some data</span><span id="d7c6" class="oi mi it ow b gy qs pd l pe pf"><strong class="ow jd">m.run_diagnostics()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qw"><img src="../Images/1caff53e639fe9a4e1e85afba5f919ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uiWtj3zk-3Afa3rgMU--Q.png"/></div></div></figure><p id="cab1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">类似地，您可以在一个实用程序方法中添加所有异常值图。</p><h1 id="5ef1" class="mh mi it bd mj mk od mm mn mo oe mq mr ki of kj mt kl og km mv ko oh kp mx my bi translated">模块化—将类作为模块导入</h1><p id="8261" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">虽然这不是一个规范的 OOP 原则，但是遵循 OOP 范例的本质优势是<a class="ae lz" href="https://atomicobject.com/resources/oo-programming/encapsulation-modularity" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">能够模块化你的代码</strong> </a>。</p><p id="45d5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以在一个标准的 Jupyter 笔记本上试验和开发所有这些代码。但是为了实现最大的模块化，可以考虑将笔记本转换成独立的可执行 Python 脚本(扩展名为. py)。一个好的做法是，从这个文件中删除所有不必要的注释和测试代码，只保留在一起的类。</p><p id="1845" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/OOP_in_ML/Class_MyLinearRegression.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">这里是我为这篇文章整理的脚本</strong> </a>的链接。</p><p id="43c0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一旦你这样做了，你就可以从一个完全不同的笔记本中导入<code class="fe ot ou ov ow b">MyLinearRgression</code>类。这通常是<strong class="lf jd">测试代码的首选方式</strong>，因为这不会触及核心模型，而只是用各种数据样本和功能参数来测试它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qx"><img src="../Images/8cb2116521db86196779680805d3fff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WGuijSPcK5V0OVkR5CBrA.png"/></div></div></figure><p id="a7c0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此时，您可以考虑将这个 Python 脚本放在 Github 上，创建一个 Setup.py 文件，创建适当的目录结构，并将其作为独立的线性回归包发布，该包可以进行拟合、预测、绘图、诊断等工作。</p><p id="d54f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然，你必须添加许多<a class="ae lz" href="https://www.geeksforgeeks.org/python-docstrings/" rel="noopener ugc nofollow" target="_blank">文档串描述</a>，函数用法的例子，<a class="ae lz" href="https://airbrake.io/blog/python-exception-handling/python-assertionerror" rel="noopener ugc nofollow" target="_blank">断言检查</a>，和<a class="ae lz" href="http://softwaretestingfundamentals.com/unit-testing/" rel="noopener ugc nofollow" target="_blank">单元测试</a>来使它成为一个好的包。</p><blockquote class="ph pi pj"><p id="d495" class="ld le ox lf b lg lh kd li lj lk kg ll pk ln lo lp pl lr ls lt pm lv lw lx ly im bi translated">但是作为一名数据科学家，现在你已经增加了一项重要的技能——遵循 OOP 原则的软件开发。</p></blockquote><p id="07f2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这并不困难，是吗？</p><h1 id="7e52" class="mh mi it bd mj mk od mm mn mo oe mq mr ki of kj mt kl og km mv ko oh kp mx my bi translated">收场白</h1><h2 id="762b" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">动机和相关文章</h2><p id="ec5e" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">为了写这篇文章，我受到了<a class="ae lz" href="https://dziganto.github.io/classes/data%20science/linear%20regression/machine%20learning/object-oriented%20programming/python/Understanding-Object-Oriented-Programming-Through-Machine-Learning/" rel="noopener ugc nofollow" target="_blank">这篇精彩文章</a>的启发，这篇文章在机器学习的背景下更详细地探讨了 Python 中 OOP 的概念。</p><div class="nk nl gp gr nm nn"><a href="https://dziganto.github.io/classes/data%20science/linear%20regression/machine%20learning/object-oriented%20programming/python/Understanding-Object-Oriented-Programming-Through-Machine-Learning/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">通过机器学习理解面向对象编程</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">面向对象编程(OOP)并不容易理解。你可以一个接一个的看教程，筛选…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">dziganto.github.io</p></div></div><div class="nw l"><div class="qy l ny nz oa nw ob lb nn"/></div></div></a></div><p id="1664" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我写过一篇类似的文章，在深度学习的背景下，触及了更基本的方法。看看这里，</p><div class="nk nl gp gr nm nn"><a rel="noopener follow" target="_blank" href="/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">面向对象编程的简单混合如何增强你的深度学习原型</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">通过混合面向对象编程的简单概念，如函数化和类继承，您可以添加…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="qz l ny nz oa nw ob lb nn"/></div></div></a></div><h2 id="44e3" class="oi mi it bd mj oj ok dn mn ol om dp mr lm on oo mt lq op oq mv lu or os mx iz bi translated">课程？</h2><p id="20a5" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">我试着寻找相关课程，发现如果你正在使用 Python，就很少。大多数软件工程课程都是用 Java 教授的。这里有两个可能会有帮助，</p><ul class=""><li id="ae2e" class="pq pr it lf b lg lh lj lk lm ps lq pt lu pu ly pv pw px py bi translated"><a class="ae lz" href="https://www.datacamp.com/courses/software-engineering-for-data-scientists-in-python" rel="noopener ugc nofollow" target="_blank">Python 中数据科学家的软件工程</a></li><li id="d6ab" class="pq pr it lf b lg pz lj qa lm qb lq qc lu qd ly pv pw px py bi translated"><a class="ae lz" href="https://www.coursera.org/learn/python-classes-inheritance/" rel="noopener ugc nofollow" target="_blank"> Python 类和继承</a></li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="0fa5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi ra translated"><span class="l rb rc rd bm re rf rg rh ri di">如果</span>您有任何问题或想法要分享，请联系作者在<a class="ae lz" href="mailto:tirthajyoti@gmail.com" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">tirthajyoti【AT】Gmail . com</strong></a>。此外，您可以查看作者的 GitHub 资源库<strong class="lf jd"> </strong>中其他有趣的 Python、R 或 MATLAB 代码片段和机器学习资源。如果你像我一样，对机器学习/数据科学充满热情，请随时<a class="ae lz" href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上添加我</a>或<a class="ae lz" href="https://twitter.com/tirthajyotiS" rel="noopener ugc nofollow" target="_blank">在 Twitter 上关注我。</a></p><div class="nk nl gp gr nm nn"><a href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">Tirthajyoti Sarkar - Sr .首席工程师-半导体、人工智能、机器学习- ON…</h2><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.linkedin.com</p></div></div><div class="nw l"><div class="rj l ny nz oa nw ob lb nn"/></div></div></a></div></div></div>    
</body>
</html>