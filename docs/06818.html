<html>
<head>
<title>Transfer Learning with TF 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 TF 2.0 迁移学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transfer-learning-with-tf-2-0-ff960901046d?source=collection_archive---------10-----------------------#2019-09-28">https://towardsdatascience.com/transfer-learning-with-tf-2-0-ff960901046d?source=collection_archive---------10-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="4fb9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">站在巨人的肩膀上</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/85c50e967daa6e227362a99ea7ac7b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ARtTmgwtOgUk3MKf"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@sunburned_surveyor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Blake</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="85e8" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">迁移学习是这样一个过程:采用一个已在相似域的数据集上训练过的模型，然后通过添加层来扩展该模型，以根据您的数据进行预测。</p><p id="42f4" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">已训练的模型(称为预训练模型)存在于 TensorFlow 库中。这些人通常在 Imagenet 大规模视觉识别挑战(Imagenet)可用的图像上接受训练。该挑战赛提供了 120 万张图片，可分为 1000 个类别。</p><p id="96ad" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">预训练模型的主要优势在于，它们是在这些图像上使用我们通常无法获得或购买成本过高的硬件进行训练的。这些模型通常有一个最终层，将输出分成 1000 个不同的类别。</p><p id="6031" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在迁移学习中，你要做的是选择一个模型，然后冻结权重。然后向模型中添加新的层，并训练权重，直到收敛。</p><p id="951f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">TensorFlow 中有各种预训练的模型，如 VGG，我们将利用这些模型。让我们从安装 TF 2.0 和导入必要的库开始。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Install TensorFlow 2.0</figcaption></figure><p id="75c8" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">接下来，我们需要为我们的图像和模型定义一些常量。这些细节包括我们在最终图层中想要的类的数量，以及颜色通道的数量和图像的尺寸。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="efe7" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们现在准备创建我们的基础模型，这是没有最终层的预训练模型。我们将可训练值设置为 false，以防止在训练期间更新权重。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1e35" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">打印基础模型将显示架构。然后，我们可以继续向基础模型添加新层。我们可以为此使用函数式 API。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="82e2" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">就这样，我们有了一个可以用来训练的模型。不要忘记，您需要通过创建一个生成器来将您的图像转换成正确的格式，以便进行培训。我喜欢用 Python 处理文件名列表(文件)和它们所属的类(类别)。有了这两个列表，下面的代码将创建您的生成器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image input pipeline</figcaption></figure><p id="f4b9" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，您可以继续编译和训练您的模型。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2466" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，您可以检查培训的结果，并进行修改以进行改进。你应该改变<code class="fe mc md me mf b">steps_per_epoch</code>和<code class="fe mc md me mf b">epochs</code>。您应该选择您的优化器并配置学习率。您可能还想携带我们的数据增强功能，使您的训练数据更加可靠。</p><p id="ab51" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">练习愉快。</p></div></div>    
</body>
</html>