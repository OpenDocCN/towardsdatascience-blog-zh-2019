<html>
<head>
<title>The Best Format to Save Pandas Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保存熊猫数据的最佳格式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-best-format-to-save-pandas-data-414dca023e0d?source=collection_archive---------0-----------------------#2019-03-14">https://towardsdatascience.com/the-best-format-to-save-pandas-data-414dca023e0d?source=collection_archive---------0-----------------------#2019-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c71d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将 pandas 数据帧序列化到持久存储的各种方法的比较</h2></div><p id="3f46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当从事数据分析项目时，我通常使用<code class="fe lb lc ld le b">Jupyter</code>笔记本和一个很棒的<code class="fe lb lc ld le b">pandas</code>库来处理和移动我的数据。对于中等大小的数据集，这是一个非常简单的过程，您可以将其存储为纯文本文件，而不会有太多的开销。</p><p id="ec70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，当数据集中的观察值很多时，保存数据和将数据加载回内存的过程会变得更慢，现在每个内核的重新启动都会占用您的时间，迫使您等待数据重新加载。因此，最终，CSV 文件或任何其他纯文本格式都失去了吸引力。</p><p id="82d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以做得更好。有大量的二进制格式来存储磁盘上的数据，其中许多是<code class="fe lb lc ld le b">pandas</code>支持的。我们如何知道哪一个更适合我们的目的？嗯，我们可以尝试其中的几个，比较一下！这就是我在这篇文章中决定做的:通过几种方法将<code class="fe lb lc ld le b">pandas.DataFrame</code>保存到磁盘上，看看哪种方法在 I/O 速度、消耗的内存和磁盘空间方面更好。在这篇文章中，我将展示我的小基准测试的结果<a class="ae lf" href="https://github.com/devforfu/pandas-formats-benchmark" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/20de5dfe5fa4245bf312a09805231eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V1FJDEUwELWbdkuX"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Photo by <a class="ae lf" href="https://unsplash.com/@heapdump?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Patrick Lindenberg</a> on <a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6047" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">要比较的格式</h1><p id="1ae3" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我们将考虑以下存储数据的格式。</p><ul class=""><li id="8f16" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated">纯文本 CSV —数据科学家的老朋友</li><li id="de8a" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">pickle——Python 序列化事物的方式</li><li id="1394" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">message pack——它像 JSON，但是又快又小</li><li id="983f" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format" rel="noopener ugc nofollow" target="_blank">HD F5</a>—一种旨在存储和组织大量数据的文件格式</li><li id="5070" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><a class="ae lf" href="https://blog.cloudera.com/blog/2016/03/feather-a-fast-on-disk-format-for-data-frames-for-r-and-python-powered-by-apache-arrow/" rel="noopener ugc nofollow" target="_blank">羽化</a> —一种快速、轻量且易于使用的二进制文件格式，用于存储数据帧</li><li id="d072" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><a class="ae lf" href="https://parquet.apache.org" rel="noopener ugc nofollow" target="_blank">Parquet</a>—Apache Hadoop 的柱状存储格式</li></ul><p id="9bc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你做一些数据分析工作时，它们都被广泛使用(可能除了 MessagePack)并且经常遇到。</p><h1 id="b8ca" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">选择的指标</h1><p id="5d32" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了找到存储笔记本会话之间数据的最佳缓冲格式，我选择了以下指标进行比较。</p><ul class=""><li id="75c5" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><code class="fe lb lc ld le b">size_mb</code> —带有序列化数据帧的文件的大小(Mb)</li><li id="27c8" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe lb lc ld le b">save_time</code> —将数据帧保存到磁盘上所需的时间</li><li id="2ecd" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe lb lc ld le b">load_time</code> —将之前转储的数据帧加载到内存中所需的时间</li><li id="e058" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe lb lc ld le b">save_ram_delta_mb</code> —数据帧保存过程中的最大内存消耗增长</li><li id="031b" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><code class="fe lb lc ld le b">load_ram_delta_mb</code> —数据帧加载过程中的最大内存消耗增长</li></ul><p id="a40d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，当我们使用高效压缩的二进制数据格式(如 Parquet)时，最后两个指标变得非常重要。它们可以帮助我们估计加载序列化数据所需的 RAM 数量，<em class="nh">此外还有</em>数据本身的大小。我们将在接下来的章节中更详细地讨论这个问题。</p><h1 id="01e4" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">基准</h1><p id="1fd5" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我决定在测试中使用合成数据集，以便更好地控制序列化的数据结构和属性。此外，我在基准测试中使用了两种不同的方法:(a)将生成的分类变量保存为字符串，以及(b)在执行任何 I/O 之前，将它们转换为<code class="fe lb lc ld le b">pandas.Categorical</code>数据类型。</p><p id="1c55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe lb lc ld le b">generate_dataset</code>展示了我是如何在基准测试中生成数据集的。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b92c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CSV 文件保存和加载的性能作为基准。五个随机生成的百万次观察的数据集被转储到 CSV 中，并被读回到内存中以获得平均指标。每种二进制格式都在 20 个随机生成的具有相同行数的数据集上进行了测试。数据集由 15 个数值特征和 15 个分类特征组成。您可以在<a class="ae lf" href="https://github.com/devforfu/pandas-formats-benchmark" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中找到带有基准测试功能的完整源代码。</p><h2 id="10ab" class="nk lx iq bd ly nl nm dn mc nn no dp mg ko np nq mi ks nr ns mk kw nt nu mm nv bi translated">(a)作为字符串的分类特征</h2><p id="be91" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">下图显示了每种数据格式的平均 I/O 时间。一个有趣的观察是<code class="fe lb lc ld le b">hdf</code>显示了比<code class="fe lb lc ld le b">csv</code>更慢的加载速度，而其他二进制格式表现明显更好。印象最深的两个是<code class="fe lb lc ld le b">feather</code>和<code class="fe lb lc ld le b">parquet</code>。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/20756bd786848782ce834912daefc35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*6qdaUz8pMFTurG7N14SQjA.png"/></div></figure><p id="d101" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保存数据和从磁盘读取数据时的内存开销如何？下一张图片显示<code class="fe lb lc ld le b">hdf</code>再次表现不佳。果然，<code class="fe lb lc ld le b">csv</code>不需要太多额外的内存来保存/加载纯文本字符串，而<code class="fe lb lc ld le b">feather</code>和<code class="fe lb lc ld le b">parquet</code>彼此非常接近。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6d5a32489c9a5ef822e36c8511cda428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*d5RKfYfcVzOkZFoMeV4nyA.png"/></div></figure><p id="d77e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们看看文件大小。这次<code class="fe lb lc ld le b">parquet</code>显示了一个令人印象深刻的结果，考虑到这种格式是为了高效存储大量数据而开发的，这并不奇怪。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b9cca9473b8a03628e20cfd4b9551e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*Q4QsOWSh2gDrG8aCAF8ewA.png"/></div></figure><h2 id="7c8f" class="nk lx iq bd ly nl nm dn mc nn no dp mg ko np nq mi ks nr ns mk kw nt nu mm nv bi translated">(b)转换的分类特征</h2><p id="4ec3" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在上一节中，我们没有尝试有效地存储我们的分类特征，而是使用普通字符串。我们来修正这个疏漏吧！这次我们使用专用的<code class="fe lb lc ld le b">pandas.Categorical</code>类型，而不是普通的字符串。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0006f7158f2bcc9b6b8a2926ac58768f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*-QoJbusw3MUYdms0lbmd4Q.png"/></div></figure><p id="c9e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看它现在和纯文本<code class="fe lb lc ld le b">csv</code>相比是什么样子！现在所有的二进制格式都显示了它们的真正威力。基线远远落后，所以让我们把它去掉，以便更清楚地看到各种二进制格式之间的差异。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/da194d72f64526ad9a83f4d94e3f8c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*pzDTkklNZpseBSW7VUf6xQ.png"/></div></figure><p id="6c5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">feather</code>和<code class="fe lb lc ld le b">pickle</code>显示出最佳的 I/O 速度，而<code class="fe lb lc ld le b">hdf</code>仍然显示出明显的开销。</p><p id="6d06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候比较数据流程加载期间的内存消耗了。下面的条形图显示了我们之前提到的关于拼花地板格式的一个重要事实。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ec0f890aa52c4f8a960f53fda19370fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*5fAYsFAf_BVIYuNSmuxjcA.png"/></div></figure><p id="888b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要占用磁盘上的一点空间，就需要额外的资源来将数据解压缩回数据帧。您可能无法将文件加载到内存中，即使它需要永久存储磁盘上的中等容量。</p><p id="6d66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一幅图显示了这些格式的文件大小。所有格式都显示出良好的效果，除了<code class="fe lb lc ld le b">hdf</code>仍然比其他格式需要更多的空间。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0479d357d37e4f933b52347c77737761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*j_n0OIfrrs2PviWaZrGDxQ.png"/></div></figure><h1 id="9ce1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="b8bf" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">正如我们的小测试所显示的，似乎<code class="fe lb lc ld le b">feather</code>格式是存储 Jupyter 会话之间数据的理想选择。它显示出很高的 I/O 速度，不会占用太多的磁盘内存，并且在加载回 RAM 时不需要任何拆包。</p><p id="997b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这种比较并不意味着您应该在每种可能的情况下都使用这种格式。例如，<code class="fe lb lc ld le b">feather</code>格式<a class="ae lf" href="https://stackoverflow.com/questions/48083405/what-are-the-differences-between-feather-and-parquet" rel="noopener ugc nofollow" target="_blank">预计不会用作长期文件存储</a>。此外，它没有考虑到所有可能的情况，当其他格式可以显示他们最好的。然而，对于本文开头所述的目的来说，这似乎是一个极好的选择。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="c56e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">你对 Python 语言感兴趣吗？离不开机器学习？看过网上的其他东西吗？</em></p><p id="f3fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">那么你可能会对我的博客</em> <a class="ae lf" href="https://iliazaitsev.me/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">感兴趣，我的博客</em> </a> <em class="nh">讨论了各种编程话题，并提供了我感兴趣的教科书和指南的链接。</em></p></div></div>    
</body>
</html>