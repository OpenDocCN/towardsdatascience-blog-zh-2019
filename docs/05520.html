<html>
<head>
<title>A Brief Introduction to Change Point Detection using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 进行变化点检测的简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-brief-introduction-to-change-point-detection-using-python-d9bcb5299aa7?source=collection_archive---------18-----------------------#2019-08-14">https://towardsdatascience.com/a-brief-introduction-to-change-point-detection-using-python-d9bcb5299aa7?source=collection_archive---------18-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e8e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我的很多工作都大量涉及时间序列分析。我使用的一个很棒但不太为人所知的算法是变化点检测。</h2></div><p id="33a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变点检测(或 CPD)检测时间序列趋势的突然变化(即时间序列瞬时速度的变化)，这可以通过人眼轻松识别，但使用传统的统计方法很难精确定位。CPD 适用于一系列行业，包括金融、制造质量控制、能源、医疗诊断和人类活动分析。</p><p id="7431" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CPD 非常适合以下使用案例:</p><ol class=""><li id="249e" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">检测时间序列中的异常序列/状态</li><li id="df65" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">检测时间序列中唯一状态的平均速度</li><li id="4a77" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">实时检测时间序列状态的突变</li></ol><p id="b316" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现 CPD 在自动识别和去除时间序列中的异常序列时特别有用，如下所示:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/a6469b3e88f6c8ed7c6e16c36a216142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k9Knznv7O11T_uTl"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Change point detection using the Python ruptures package: We can identify anomalous data sequences that need to be removed from the time series</em></figcaption></figure><p id="401e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我试图确定系统中的速率变化，这也很好，使我可以专注于类似序列的平均速率:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f523b0f943ff1d5d574f32e15c842f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/0*zlLPremY6W-OTz7G"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Change Point Detection in R using the PELT Algorithm: We can split up average velocity of a time series across phases using CPD</em></figcaption></figure><p id="3ffa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文提供了关于变化点检测的简单易懂的背景知识，以及用 Python 实现的实用包(包括示例代码！).</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="afe9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">算法背景</h1><p id="a865" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">CPD 有两种不同的类别——离线和在线。在本节中，我将对这两者进行简要概述。</p><p id="b215" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">离线变化点检测</strong></p><p id="8b72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当不使用实时流数据时，变化点检测方法是“离线”的，并且需要完整的时间序列来进行统计分析。因为离线方法分析整个时间序列，它们通常更准确。离线变化点检测的一些特征如下(1):</p><ol class=""><li id="503d" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">所有数据同时被接收和处理</li><li id="c700" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">所有的变化都是感兴趣的，而不仅仅是序列中最近的变化</li></ol><p id="36da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">在线变点检测</strong></p><p id="4b50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与离线变化点检测相比，在线变化点检测用于实时流时间序列，通常用于持续监控或即时异常检测(1)。在线 CPD 在单个数据点可用时对其进行处理，目的是在它们发生时立即检测到状态变化(2)。在线变化点检测有几个特征:</p><ol class=""><li id="1b8c" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">快速“即时”处理，以便快速评估时间序列趋势的变化</li><li id="b59e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">仅评估时间序列中最近的变化，而不是以前的变化</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1083" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">用于变化点检测的 Python 包</h1><p id="e02f" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">r 有一个优秀的包用于变点检测，叫做<a class="ae no" href="https://cran.r-project.org/web/packages/changepoint/changepoint.pdf" rel="noopener ugc nofollow" target="_blank"> changepoint </a>。该软件包允许用户使用多种搜索方法对时间序列进行变点分析。不幸的是，没有与 R 的 changepoint 包直接对应的 Python。然而，还有其他几个包提供了变化点检测，可通过 Python 获得:</p><ol class=""><li id="6f17" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae no" href="https://github.com/deepcharles/ruptures" rel="noopener ugc nofollow" target="_blank">破坏了包</a>，这是一个用于执行离线变化点检测的 Python 库</li><li id="95f4" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用一个 R 到 Python 的接口<a class="ae no" href="https://rpy2.readthedocs.io/en/version_2.8.x/overview.html" rel="noopener ugc nofollow" target="_blank"> rpy2 包</a>将 R changepoint 包调用到 Python 中</li><li id="bce4" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae no" href="https://github.com/shunsukeaihara/changefinder" rel="noopener ugc nofollow" target="_blank"> changefinder 包</a>，一个用于在线变更点检测的 Python 库</li></ol><p id="8373" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这三个选项中，我发现选项#1 和#3 最容易实现，因为它们不需要在 Python 环境中下载和配置 R 和 rpy2。R changepoint 包的功能是迄今为止最健壮的，但是配置它很耗时。因此，这不是这篇文章的重点。</p><p id="51e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="np">如果您对使用 rpy2 通过 Python 调用 R changepoint 包的深入背景感兴趣，请查看 Steven Reitsma 的本教程</em> </strong> <a class="ae no" href="https://medium.com/bigdatarepublic/contextual-changepoint-detection-with-python-and-r-using-rpy2-fa7d86259ba9" rel="noopener"> <strong class="kk iu"> <em class="np">】。</em> </strong></a></p><p id="bf18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们进一步探讨选项 1 和选项 3。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ea90" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">破裂包装</h1><p id="36b0" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">Charles Truong 改编了 R changepoint 包的<a class="ae no" href="http://ctruong.perso.math.cnrs.fr/ruptures-docs/build/html/index.html" rel="noopener ugc nofollow" target="_blank">破裂包</a>。它特别关注离线变点检测，在这里对整个序列进行分析。在所有 Python changepoint 选项中，它是最好的文档。我们可以使用基本的 pip 安装命令来安装它:</p><pre class="lt lu lv lw gt nq nr ns nt aw nu bi"><span id="befd" class="nv ms it nr b gy nw nx l ny nz">pip install ruptures</span></pre><p id="112f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该软件包提供了多种搜索方法(二进制分割、毛皮、基于窗口的变化检测、动态编程等)。)，以及多种成本函数。在本教程中，我们特别关注搜索方法。</p><p id="f553" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">搜索方法背景</strong></p><p id="5991" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本节简要介绍了 surfaces 包中可用的一些搜索方法，包括二进制分割、PELT、基于窗口的变化检测和动态编程。</p><p id="c04a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="np">修剪精确线性时间(毛皮)搜索方法:</em>毛皮方法是一种精确的方法，并且通常产生快速且一致的结果。它通过最小化成本来检测变化点(4)。该算法的计算成本为 O(n)，其中 n 是数据点的数量(4)。更多关于毛皮方法的信息，请查看<a class="ae no" href="https://pdfs.semanticscholar.org/a7bc/09b7a73dc96be7cf844978014ad13cf0475a.pdf?_ga=2.100774593.1133001833.1565582238-1351709189.1562946956" rel="noopener ugc nofollow" target="_blank">这篇论文</a>。</p><p id="c04d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="np">动态规划搜索法:</em>这是一种精确法，计算量相当大，为 O(Qn)，其中 Q 为最大变化点数，n 为数据点数(4)。有关动态编程搜索方法的更多信息，请查看本文。</p><p id="8fc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="np">二分分割搜索法:</em>这种方法可以说是文献中最成立的(4)。二进制分割是一种近似方法，其有效计算成本为 O (n log n)，其中 n 是数据点的数量(4)。该算法通过对整个序列反复应用单个改变点方法来确定是否存在分裂。如果检测到分裂，则序列分裂成两个子序列(5)。然后将相同的过程应用于两个子序列，等等(5)。欲了解更多关于二进制分割的信息，请查看本文。</p><p id="77cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="np">基于窗口的搜索方法:</em>这是一种比较简单的近似搜索方法。基于窗口的搜索方法“计算随信号 y 移动的两个相邻窗口之间的差异”(6)。当两个窗口非常不相似时，两个值之间会出现很大的差异，这指示了一个变化点(6)。在生成差异曲线时，该算法在序列中定位最佳变化点索引(6)。有关基于窗口的搜索方法的更多信息，请查看<a class="ae no" href="https://arxiv.org/pdf/1801.00718.pdf" rel="noopener ugc nofollow" target="_blank">本文</a>。</p><p id="e434" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">代码示例</strong></p><p id="d954" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码中，我们使用上面描述的搜索方法来执行变化点检测。我们使用每日 WTI 石油价格的时间序列，从 2014 年到现在，通过能源信息管理局(EIA)的 API 提取(<a class="ae no" href="https://techrando.com/2019/06/26/how-to-use-the-energy-information-administration-eia-application-programming-interface-api-and-pull-live-data-directly-into-python-for-analysis/" rel="noopener ugc nofollow" target="_blank">参见本教程了解更多关于使用 EIA API 提取数据的信息</a>):</p><pre class="lt lu lv lw gt nq nr ns nt aw nu bi"><span id="21c9" class="nv ms it nr b gy nw nx l ny nz">def retrieve_time_series(api, series_ID):<br/>    """<br/>    Return the time series dataframe, <br/>    based on API and unique Series   ID<br/>    api: API that we're connected to<br/>    series_ID: string. Name of the series that we want <br/>    to pull from the EIA API<br/>    """<br/>    #Retrieve Data By Series ID <br/>    series_search = api.data_by_series(series=series_ID)<br/>    ##Create a pandas dataframe from the retrieved time series<br/>    df = pd.DataFrame(series_search)<br/>    return df<br/></span><span id="eaa9" class="nv ms it nr b gy oa nx l ny nz">"""<br/>Execution in main block<br/>"""</span><span id="b636" class="nv ms it nr b gy oa nx l ny nz">#Create EIA API using your specific API key<br/>api_key = 'YOUR API KEY HERE'<br/>api = eia.API(api_key)<br/>    <br/>#Pull the oil WTI price data<br/>series_ID='PET.RWTC.D'<br/>price_df=retrieve_time_series(api, series_ID)<br/>price_df.reset_index(level=0, inplace=True)<br/>#Rename the columns for easier analysis<br/>price_df.rename(columns={'index':'Date',<br/>            price_df.columns[1]:'WTI_Price'}, <br/>            inplace=True)<br/>#Format the 'Date' column <br/>price_df['Date']=price_df['Date'].astype(str).str[:-3]<br/>#Convert the Date column into a date object<br/>price_df['Date']=pd.to_datetime(price_df['Date'], format='%Y %m%d')<br/>#Subset to only include data going back to 2014<br/>price_df=price_df[(price_df['Date']&gt;='2014-01-01')]</span><span id="0197" class="nv ms it nr b gy oa nx l ny nz">#Convert the time series values to a numpy 1D array<br/>points=np.array(price_df['WTI_Price'])<br/>    <br/>#RUPTURES PACKAGE<br/>#Changepoint detection with the Pelt search method<br/>model="rbf"<br/>algo = rpt.Pelt(model=model).fit(points)<br/>result = algo.predict(pen=10)<br/>rpt.display(points, result, figsize=(10, 6))<br/>plt.title('Change Point Detection: Pelt Search Method')<br/>plt.show()  <br/>    <br/>#Changepoint detection with the Binary Segmentation search method<br/>model = "l2"  <br/>algo = rpt.Binseg(model=model).fit(points)<br/>my_bkps = algo.predict(n_bkps=10)<br/># show results<br/>rpt.show.display(points, my_bkps, figsize=(10, 6))<br/>plt.title('Change Point Detection: Binary Segmentation Search Method')<br/>plt.show()<br/>    <br/>#Changepoint detection with window-based search method<br/>model = "l2"  <br/>algo = rpt.Window(width=40, model=model).fit(points)<br/>my_bkps = algo.predict(n_bkps=10)<br/>rpt.show.display(points, my_bkps, figsize=(10, 6))<br/>plt.title('Change Point Detection: Window-Based Search Method')<br/>plt.show()<br/>    <br/>#Changepoint detection with dynamic programming search method<br/>model = "l1"  <br/>algo = rpt.Dynp(model=model, min_size=3, jump=5).fit(points)<br/>my_bkps = algo.predict(n_bkps=10)<br/>rpt.show.display(points, my_bkps, figsize=(10, 6))<br/>plt.title('Change Point Detection: Dynamic Programming Search Method')<br/>plt.show()</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2c5b3ddc853d28652f2d78a78058d182.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/0*xHnS5dn2yqRHrxGJ"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Snapshot of the WTI Oil Price Time Series, pulled via the EIA API</em></figcaption></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9e99193f86cc17dad36fe1300a931ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/0*RMkGJUjsiawSXVWp"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Change Point Detection with Pelt Search Method, WTI Oil Price Time Series, 2014-Present</em></figcaption></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi od"><img src="../Images/89ac4ce4a1434fa88f4b20fe1db1996f.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/0*QvnnGrQNy8B_xEPG"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Change Point Detection with Binary Segmentation Search Method, WTI Oil Price Time Series, 2014-Present</em></figcaption></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/caccc72f6bc3cd5d9e504e93d565fd60.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/0*B2_1AUgvA_OY-2HT"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Change Point Detection with Window-Based Search Method, WTI Oil Price Time Series, 2014-Present</em></figcaption></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi of"><img src="../Images/f0f71aee0df66c93369830a2c4223c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/0*HSrOJ_XajEwNoJZC"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">Change Point Detection with Dynamic Programming Search Method, WTI Oil Price Time Series, 2014-Present</em></figcaption></figure><p id="15df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，序列中检测到的变化点因使用的搜索方法而异。最佳搜索方法取决于您在对时间序列进行子集化时最重视的内容。PELT 和动态规划方法都是精确(与近似相反)方法，因此它们通常更精确。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1476" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">changefinder 包</h1><p id="8fd4" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">changefinder 包专门用于在线变化点检测。为了执行变点检测，该包使用 SDAR 建模，或顺序贴现自回归时间序列建模。SDAR 就像它听起来的那样——它是自回归(AR)模型的扩展，其中序列中较旧的数据点被“贴现”，即不如序列中较新的值重要。因为最近的数据在 SDAR 模型中权重更大，所以 SDAR 非常适合在线变化点检测，这种检测侧重于检测序列中最近的变化。</p><p id="a943" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自回归建模(AR)是时间序列建模最流行的形式之一，其中当前值是根据序列中以前的值预测的(3)。有关 SDAR 模型(以及多元标准差模型)的更多信息，请查看本文。</p><p id="ca2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">代码示例</strong></p><p id="59d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经有了 changefinder 包的一些初始背景，让我们用它来执行在线变更点检测。</p><p id="8b83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本例，我们将使用 random()和 numpy()包自动生成数据:</p><pre class="lt lu lv lw gt nq nr ns nt aw nu bi"><span id="0097" class="nv ms it nr b gy nw nx l ny nz">#Create a synthetic data set to test against<br/>points=np.concatenate([np.random.rand(100)+5,<br/>                       np.random.rand(100)+10,<br/>                       np.random.rand(100)+5])</span></pre><p id="c390" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成一些合成数据后，我们通过 ChangeFinder 函数运行这些数据，并根据 SDAR 为每个数据点生成一个异常值:</p><pre class="lt lu lv lw gt nq nr ns nt aw nu bi"><span id="9c65" class="nv ms it nr b gy nw nx l ny nz">#CHANGEFINDER PACKAGE<br/>f, (ax1, ax2) = plt.subplots(2, 1)<br/>f.subplots_adjust(hspace=0.4)<br/>ax1.plot(points)<br/>ax1.set_title("data point")<br/>#Initiate changefinder function<br/>cf = changefinder.ChangeFinder()<br/>scores = [cf.update(p) for p in points]<br/>ax2.plot(scores)<br/>ax2.set_title("anomaly score")<br/>plt.show()</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8efed95dac99eab2d21d42b195156ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/0*t72lU8NLKJ4whmCK"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><em class="mi">ChangeFinder Results: Top graph represents the synthetic data, and bottom graph represents corresponding anomaly scores</em></figcaption></figure><p id="3e20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的图像中，异常分数在时间 100 和时间 200 达到峰值，这对应于时间序列中发生巨大变化的点。为异常分数设置一个最小阈值，其中任何高于某个阈值的分数都对应于序列中的一个变化点，这是识别序列中单个变化点的最佳方法。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="b11e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我对变化点检测的简要介绍到此结束。要访问我在本教程中使用的代码，请查看<a class="ae no" href="https://github.com/kperry2215/change_point_detection" rel="noopener ugc nofollow" target="_blank">我的 Github repo </a>。</p><p id="dee1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一如既往的感谢阅读！</p><p id="57f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看我的其他数据科学文章和教程:</p><div class="oh oi gp gr oj ok"><a href="https://techrando.com/2019/07/30/using-ml-to-predict-the-best-time-to-sell-electricity-back-to-the-grid/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">用最大似然法预测向电网售电的最佳时间</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">随着新技术在可再生能源和能源存储行业的兴起，有许多新的机会…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">techrando.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy mc ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://techrando.com/2019/07/19/analyzing-electricity-price-time-series-data-using-python-time-series-decomposition-and-price-forecasting-using-a-vector-autoregression-var-model/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">使用 Python 分析电价时间序列数据:时间序列分解和价格…</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">欢迎来到科技兰多博客！在今天的帖子中，我将使用能源信息管理局的 API…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">techrando.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy mc ok"/></div></div></a></div><h1 id="8209" class="mr ms it bd mt mu pa mw mx my pb na nb jz pc ka nd kc pd kd nf kf pe kg nh ni bi translated">来源</h1><ol class=""><li id="555a" class="le lf it kk b kl nj ko nk kr pf kv pg kz ph ld lj lk ll lm bi translated">基利克，丽贝卡。2017.<em class="np">最佳变点检测算法介绍</em>。<a class="ae no" href="http://members.cbio.mines-paristech.fr/~thocking/change-tutorial/RK-CptWorkshop.html" rel="noopener ugc nofollow" target="_blank">http://members . cbio . mines-Paris tech . fr/~ thocking/change-tutorial/RK-cptworkshop . html</a></li><li id="5a38" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">Aminikhanghahi，Samaneh 和 Cook，Diane。2017 年 5 月。<em class="np">时间序列突变点检测方法综述。</em><a class="ae no" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5464762/#R7" rel="noopener ugc nofollow" target="_blank">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5464762/#R7</a></li><li id="842b" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">法蒂玛·萨伊德；努尔、达尔菲亚纳；国王，罗伯特。2012.<em class="np">利用 SDVAR 算法检测向量自回归模型的变点。</em><a class="ae no" href="https://pdfs.semanticscholar.org/c56d/4adad7ed3f504015bc6bbc663e21e55f174b.pdf" rel="noopener ugc nofollow" target="_blank">https://pdfs . semantic scholar . org/c56d/4 adad 7 ed 3 f 504015 BC 6 BBC 663 e 21 e 55 f 174 b . pdf</a></li><li id="1290" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">Wambui，Gachomo Dorcas 吉丘希·安东尼·怀蒂图；安东尼·万何亚。2015 年 12 月。<em class="np">多变点检测中修剪精确线性时间(PELT)检验的功效。</em><a class="ae no" href="https://pdfs.semanticscholar.org/a7bc/09b7a73dc96be7cf844978014ad13cf0475a.pdf?_ga=2.100774593.1133001833.1565582238-1351709189.1562946956" rel="noopener ugc nofollow" target="_blank">https://pdfs . semantic scholar . org/a7bc/09 B7 a 73 DC 96 be 7 cf 844978014 ad 13 cf 0475 a . pdf？_ ga = 2.100775582238-1351705</a></li><li id="a92c" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">克里斯蒂安·罗尔贝克。<em class="np">使用二元分割和最优分割检测方差变化</em>。<a class="ae no" href="https://www.lancaster.ac.uk/pg/rohrbeck/ResearchTopicI.pdf" rel="noopener ugc nofollow" target="_blank">https://www.lancaster.ac.uk/pg/rohrbeck/ResearchTopicI.pdf</a></li><li id="900e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">查尔斯·张；劳伦特·奥德雷；尼古拉·瓦亚提斯。2019 年 1 月。<em class="np">离线变点检测方法的选择性审查。<a class="ae no" href="https://arxiv.org/pdf/1801.00718.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1801.00718.pdf</a>T21</em></li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="55ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="np">原载于 2019 年 8 月 14 日</em><a class="ae no" href="https://techrando.com/2019/08/14/a-brief-introduction-to-change-point-detection-using-python/" rel="noopener ugc nofollow" target="_blank"><em class="np">https://techrando.com</em></a><em class="np">。</em></p></div></div>    
</body>
</html>