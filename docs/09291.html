<html>
<head>
<title>A Solution of Rest API for Concurrent Background Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向并发后台请求的 Rest API 解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-python-api-for-background-requests-based-on-flask-and-multi-processing-187d0e3049c9?source=collection_archive---------2-----------------------#2019-12-09">https://towardsdatascience.com/a-python-api-for-background-requests-based-on-flask-and-multi-processing-187d0e3049c9?source=collection_archive---------2-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5702" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python flask 和多重处理，逐步构建在后台运行耗时请求的 Rest API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8a91b67f38daa6bc3bee4443c70e8908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DRB3b5r9kFRPBI3g"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Safar Safarov</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子也可以在<a class="ae ky" href="https://burntbit.com/a-python-api-for-background-requests-based-on-flask-and-multi-processing/" rel="noopener ugc nofollow" target="_blank">大数据日报</a>和<a class="ae ky" href="https://www.linkedin.com/pulse/python-api-background-requests-based-flask-boning-zhang/?trackingId=5yep7JGG3P%2Fetv4XPJG%2FYQ%3D%3D" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>找到。</p><p id="7f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇博客将首先向您介绍 Rest API，解释它的基础知识以及我们可以使用 Rest API 做什么。之后，我们将一起使用 Python flask 包构建我们的第一个 API。最后，我们将通过一个通用代码框架，使用多处理模块在后台运行耗时的作业。整个项目的源代码可以在<a class="ae ky" href="https://github.com/BoningZhang/intro_api" rel="noopener ugc nofollow" target="_blank"> Git </a>找到。</p><h2 id="60d9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Rest API 基础介绍</h2><p id="3322" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，让我简单解释一下什么是 API，它能帮助我们什么。简单地说，API 是一个运行在主机上的程序，它监听一个端口来接收和响应来自互联网的 HTTP 请求。假设我们想要求解一个超出我们知识范围的方程，有人开发了一个运行在主机上的求解器 API，那么我们只需在浏览器中粘贴一个 URL:<a class="ae ky" href="http://host:port/equation/x+8=20" rel="noopener ugc nofollow" target="_blank">http://host:port/equation？x+8=20 </a>。看多简单！如果我们有一些复杂的任务不适合在我们的前端 UI 中实现，或者我们有凭证数据，我们希望将它们从我们的 UI 中分离出来，API 就是解决方案。然后前端需要知道的是与 API 通信的接口，简单地向它发送请求。前端不会执行任务或接触凭证数据。</p><p id="8042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在剩下的部分，我将一步一步展示如何基于 flask 和多处理模块构建一个在后台运行请求的 Python API。这些步骤应该很容易遵循，即使你没有使用 flask 或 API 的经验。</p><h2 id="0cb3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用 Flask 构建您的第一个 API</h2><p id="4395" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">作为开始，让我们首先构建一个简单的 API 向世界问好。对于已经熟悉 flask API 的人，可以跳过这一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将其保存为<em class="mv"> intro_api.py </em>，并作为“<em class="mv"> python intro_api.py </em>运行。您已经成功构建并运行了一个 API。够简单吗？那就叫吧！我们需要做的只是在我们的浏览器中复制并粘贴<a class="ae ky" href="http://0.0.0.0:6060/" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0:6060/</a>。看到了吗？我们的网页显示“你好，世界！”，这正是我们在 API 中定义的。让我一行一行地解释这个脚本。首先，我们导入 Flask 包，并使用<em class="mv"> Flask(__name__) </em>创建一个 API，其名称作为模块的名称。然后我们定义一个函数来响应 rout path 发来的 HTTP GET 请求，即<em class="mv"> host:port/ </em>。在这里，route decorator<em class="mv">@ app . route()</em>包装了将由 URL 调用的方法。即使你对 route decorator 没有任何概念，它也会影响你在这篇博客中对 flask API 的理解。但是我想强调两点。(1)注意<em class="mv"> @app.route('/'，methods=['GET']) </em>中的'<em class="mv"> / </em>，它定义了用来调用这个方法的 URL(<a class="ae ky" href="http://0.0.0.0:6060/" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:6060/</a>)，即<em class="mv"> hello_world() </em>。(2) <em class="mv"> methods=['GET']) </em>定义了方法只会被 HTTP GET 请求调用。</p><p id="3207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们在本地主机(即 0.0.0.0)运行这个 API，在 main 函数中 port=6060。请注意，我们在开发环境中通过调用<em class="mv"> app.run() </em>来运行它，这并不是特别高效、稳定或安全。让我们使用包<a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/tutorial/deploy/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">女侍</em> </a> <em class="mv"> </em>来代替生产服务器运行 API。然后主机变成运行我们 API 的计算机的 IP 地址。注意我们使用<em class="mv"> CORS </em>包来允许跨来源访问，否则一些现代浏览器可能会拒绝访问我们的 API。在 https://www.codecademy.com/articles/what-is-cors 查看更多关于 CORS 的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="554a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">定义另一种路由方法</h2><p id="aa65" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来，让我们通过定义另一个 route decorator 及其相关方法，在我们的 API 中做一些实际的工作。该方法将响应 HTTP POST 请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<em class="mv"> request.json </em>是 json 格式的请求体。请求主体将从前端 UI 发送到后端 API，它总是用于从前端向 API 发送一些附加信息。请记住，API 可以被同时调用多次，因此每个会话(即调用)都有自己的请求体。比如说，A 和 B 都是通过<a class="ae ky" href="http://host:port/task/job_A" rel="noopener ugc nofollow" target="_blank">http://host:port/task/job _ A</a>和<a class="ae ky" href="http://host:port/task/job_B" rel="noopener ugc nofollow" target="_blank">http://host:port/task/job _ B</a>用不同的请求体调用 API。然后，每个会话将在内存中拥有自己的请求体，即 A 和 B 将触发相同的函数，但使用不同的<em class="mv"> request.json </em>变量运行。注意，job_id 应该是 uuid 的格式，因为我们在装饰器中定义了<em class="mv"> &lt; uuid:job_id &gt; </em>。</p><h2 id="b68e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用多重处理在后台运行请求</h2><p id="1bdf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">到目前为止还好吗？上面的函数非常简单，它接收一个 POST 请求并获取其主体，然后运行一些任务并将输出响应给客户端。但是，如果这项任务非常耗时，比如说运行一个机器学习模型需要几分钟，那该怎么办？该程序将平稳运行，直到<em class="mv"> run_task() </em>为止，然后它将挂起，因为<em class="mv"> run_task() </em>将需要几分钟的时间返回。我们的网页将被封锁，用户不得不等待它的完成，没有任何其他选择，例如提交另一份工作。这当然不是我们愿意看到的。一个简单的解决方案是使用多处理在后台运行任务。另一个解决方案是消息队列，基本上 API 将只设计为将作业信息推送到消息队列，然后返回到前端，而 dameon 服务将从消息队列中提取消息并运行真正的任务。关于它的更多细节可以在我的另一篇博客中找到:<a class="ae ky" rel="noopener" target="_blank" href="/a-python-implementation-of-concurrent-consumers-for-google-cloud-platform-pub-sub-991ae8b9841d">Google 云平台并发消费者的通用框架 Pub/Sub </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="62d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们在后台进程中运行<em class="mv"> run_task() </em>，而不等待其完成，并通知客户端作业已收到。在这种情况下，网页将不会被阻止，用户可以在该网页中执行一些其他操作，例如提交另一个作业。但是缺少的一点是，当工作完成时，用户不会得到通知。然后我们需要在<em class="mv"> run_task() </em>中记录作业的状态。</p><p id="818e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果作业有并发限制会怎样？假设我们只能运行 4 个并发<em class="mv"> run_task() </em>，那么其他请求应该处于等待状态。此外，我们只允许处理 8 个并发请求，即等待和运行。在这个场景中，我们需要一个数据库来记录请求的状态，以帮助检查工作人员的可用性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="4671" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="3923" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们已经构建了我们的第一个 Rest API，并暴露在后台运行耗时请求的代码框架中。希望你会发现它很有趣和有用，也许你会想建立一个 API，让其他人与你的机器学习模型进行交互。</p></div></div>    
</body>
</html>