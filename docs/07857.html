<html>
<head>
<title>A Guide to Linear Search and Binary Search on Arrays (Data Structures &amp; Algorithms)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阵列的线性搜索和二分搜索法指南(数据结构和算法)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-linear-search-and-binary-search-on-arrays-data-structures-algorithms-2c23a74af28a?source=collection_archive---------17-----------------------#2019-10-30">https://towardsdatascience.com/a-guide-to-linear-search-and-binary-search-on-arrays-data-structures-algorithms-2c23a74af28a?source=collection_archive---------17-----------------------#2019-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9d4e03151a29b0c5c783fe138c692a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pelfJytd4FXDtjHzBuJLSw.jpeg"/></div></div></figure><p id="f9c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一篇文章中，我们讨论了数组和操作(<a class="ae kz" rel="noopener" target="_blank" href="/a-guide-to-arrays-and-operations-data-structures-f0671028ed71"> LINK </a>)。现在，我们将回顾算法选择如何影响代码的性能。特别是，我们将通过无序和有序数组来研究线性搜索和二分搜索法。</p><h1 id="8354" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是算法？</h1><p id="7c83" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我的一个经理是个数学专家，他总是喜欢明确地陈述定义，这样每个人都在同一页上。在我们的例子中，算法是解决问题的一种方式。例如，这里有一个关于如何执行谷歌搜索的粗略算法:</p><p id="0e09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.打开 web 浏览器。<br/> 2。在地址栏<br/> 3 中输入<a class="ae kz" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">www.google.com</a>。按回车键<br/> 4。在谷歌搜索栏中，输入想要的搜索<br/> 5。按回车键</p><p id="cb1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在有更多的步骤来更加明确和改进算法，但你得到的想法。换句话说，算法是做某事的过程。</p><h1 id="7e3c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">有序数组</strong></h1><p id="ced5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在上一篇文章(<a class="ae kz" rel="noopener" target="_blank" href="/a-guide-to-arrays-and-operations-data-structures-f0671028ed71">链接</a>)中，我们讨论了无序数组。有序数组是数据以定向方式组织的数组(通常被视为升序)。因此，每次添加或删除一个数字时，数组都会按照需要的顺序进行重组。让我们看一个 Python 中数组的例子:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e0e4" class="mm lb it mi b gy mn mo l mp mq">ordered_array = [1, 6, 7, 22, 100]</span><span id="9730" class="mm lb it mi b gy mr mo l mp mq"># Let's insert the value 19<br/>ordered_array.insert(0, 19)<br/>ordered_array</span></pre><p id="57ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi">[19, 1, 6, 7, 22, 100]</p><p id="8389" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，增加值并没有按照正确的升序排列。为了保持数组有序，值 19 必须放在正确的位置。在 Python 中，我们可以这样对数组进行排序:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e2eb" class="mm lb it mi b gy mn mo l mp mq">ordered_array.sort()<br/>ordered_array</span></pre><p id="4bc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi">[1, 6, 7, 19, 22, 100]</p><p id="400b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很容易，但是，在幕后，Python 做了更多的事情。如果我们从插入 19 和排列开始，第一步是检查 19 是否大于 1。如果是，则移动到下一个值。如果没有，则将值放在索引处，并将所有值向右移动。</p><p id="76cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，它将逐个搜索每个值，直到达到 22。在 22 处，它会将 22 和 100 向右移动一个索引值。之后，它会将 19 放在 22 的前一个索引值上。</p><h1 id="7569" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">线性搜索</h1><p id="8825" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">好吧，那么显示有序和无序数组的全部意义是什么？对于线性搜索这样的算法来说，性能变化很大。线性搜索逐个检查数组中的值，直到找到为止。在无序数组中，线性搜索必须检查整个数组，直到找到所需的值。但是有序数组就不同了。原因是，一旦线性搜索发现一个值大于它的期望值，那么它可以停止，并说它找到了值或没有。基本上，有序数组需要更少的步骤，无序数组使用线性搜索。Python 示例编码如下:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="527a" class="mm lb it mi b gy mn mo l mp mq">#Linear Search Function (modified from: <a class="ae kz" href="https://www.geeksforgeeks.org/linear-search/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/linear-search/</a>)<br/>def linsearch(arr, n, x): <br/>    for i in range (0, n): <br/>        if (arr[i] == x): <br/>            return i; <br/>    return -1;</span><span id="9488" class="mm lb it mi b gy mr mo l mp mq">#Ordered Array<br/>arr = [1, 6, 7, 19, 22, 100]; <br/>#Desired value<br/>x = 19;</span><span id="83f8" class="mm lb it mi b gy mr mo l mp mq">n = len(arr); <br/>result = linsearch(arr, n, x)</span><span id="e507" class="mm lb it mi b gy mr mo l mp mq">if(result == -1): <br/>    print("Element is not present in array") <br/>else: <br/>    print("Element is present at index", result);</span></pre><p id="e098" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">元素出现在索引 3 处</p><h1 id="e00d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">二进位检索</h1><p id="3564" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">由于我们的数据被结构化为有序数组，因此实际上有一种比线性搜索更好的方法来搜索值。你已经猜到了。更好的算法是二分搜索法！那么，它是如何工作的呢？</p><p id="ab19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">二分搜索法基本上是取你要找的值，然后到有序数组的中间。它现在会考虑期望值是大于还是小于中间值。如果更高，二分搜索法会到达中间点，再次询问更高或更低的价格，直到找到理想的价格。这同样适用于较低的值。</p><p id="7715" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重要的是要记住，二分搜索法只能发生在有序的数组中。如果它是无序的，二分搜索法不能要求更高或更低的值来加速搜索。这个例子强调了数据结构的重要性以及正确的算法选择如何影响性能。二分搜索法的 Python 示例如下:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3054" class="mm lb it mi b gy mn mo l mp mq">#Binary Search Function (modified from: <a class="ae kz" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/binary-search/</a>)<br/>def binarySearch(arr, l, r, x): <br/>    while l &lt;= r: <br/>        mid = l + (r - l)//2; <br/>        if arr[mid] == x: <br/>            return mid <br/>        elif arr[mid] &lt; x: <br/>            l = mid + 1<br/>        else: <br/>            r = mid - 1<br/>    return -1</span><span id="779b" class="mm lb it mi b gy mr mo l mp mq">#Ordered Array<br/>arr = [1, 6, 7, 19, 22, 100]; <br/>#Desired value<br/>x = 19; <br/>  <br/>result = binarySearch(arr, 0, len(arr)-1, x) <br/>  <br/>if(result != -1): <br/>    print("Element is present at index % d" % result)<br/>else: <br/>    print("Element is not present in array")</span></pre><p id="2361" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">元素出现在索引 3 处</p><h1 id="037c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="4b8f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">因此，我们了解了线性搜索和二分搜索法对有序数组的性能影响。由于逐个检查数组中每个数据点的期望值，线性搜索速度较慢。相比之下，二分搜索法通过获取中间值并根据期望值升高或降低来减少搜索时间。我认为以图形方式观察这种变化会有所帮助，所以请看下图:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/2d412579747bafa6de7c8a597d46b74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yajAx27IwspJ3D5iNO3tg.jpeg"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Graph performance of Linear Search v. Binary Search. Image taken from Techtud: <a class="ae kz" href="https://www.techtud.com/sites/default/files/public/user_files/tud39880/linearSearch%20vs%20binary%20search%20diagram_0.jpg" rel="noopener ugc nofollow" target="_blank">https://www.techtud.com/sites/default/files/public/user_files/tud39880/linearSearch%20vs%20binary%20search%20diagram_0.jpg</a></figcaption></figure><p id="9429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上，在最坏的情况下，线性搜索性能会随着每个新元素的增加而提高。例如，期望值为 49，000 的 50，000 个有序数组将以从 0 一直到 49，000 为步长进行线性搜索。另一方面，二分搜索法将在大约 15 步内穿过一个又一个中间值。不要担心图中的 O 符号。这是一个很大的 O 符号，我们将在下一篇文章中讨论它！</p><p id="feba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本系列文章的第一部分可以在这里找到:</p><p id="621f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/a-guide-to-arrays-and-operations-data-structures-f0671028ed71">https://towards data science . com/a-guide-to-arrays-and-operations-data-structures-f 0671028 ed 71</a></p><p id="6683" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于那些现在想了解更多的人来说，下面是我用来撰写本文的关于这些主题的好资源:</p><ul class=""><li id="4da4" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">http://elementsofprogramming.com/<a class="ae kz" href="http://elementsofprogramming.com/" rel="noopener ugc nofollow" target="_blank"/></li><li id="f507" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated"><a class="ae kz" href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/Cracking-Coding-Interview-Programming-Questions/DP/0984782850</a></li><li id="3d74" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated"><a class="ae kz" href="https://learning.oreilly.com/library/view/a-common-sense-guide/9781680502794/" rel="noopener ugc nofollow" target="_blank">https://learning . oreilly . com/library/view/a-common-sense-guide/9781680502794/</a></li></ul><p id="1448" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl">免责声明:本文陈述的所有内容均为我个人观点，不代表任何雇主。</em></p></div></div>    
</body>
</html>