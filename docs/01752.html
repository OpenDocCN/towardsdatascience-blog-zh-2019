<html>
<head>
<title>Introducing Google Guava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍谷歌番石榴</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-google-guava-f295d22319f7?source=collection_archive---------5-----------------------#2019-03-22">https://towardsdatascience.com/introducing-google-guava-f295d22319f7?source=collection_archive---------5-----------------------#2019-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a4e48d8e8e5d7a88f93fd82751d8b154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjmDb7LvLRBbWsp6x7Gakw.jpeg"/></div></div></figure><h2 id="60b6" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Guava 是一个开源的 Java“收藏库”库，由 Google 开发。</h2><p id="694d" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">它提供了使用 Java 集合的实用程序。当您深入研究 Guava 时，您会注意到它是如何通过使代码简洁易读来减少编码错误、促进标准编码实践和提高生产率的。</p><p id="dd84" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我决定把番石榴教程分解成一系列的帖子。我们将涵盖许多 Guava 概念——<em class="lx">Guava 实用程序类</em>，<em class="lx">函数式编程，使用集合，以及事件总线</em>。</p><p id="15ca" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在这篇文章中，你将了解到:<br/> 1。<strong class="kz iu"> <em class="lx">给你的 Java 项目添加番石榴。</em> </strong> <br/> 2。<em class="lx">Guava 中的基本实用程序—拆分器、地图拆分器、连接程序、地图连接程序和预处理类</em></p><h1 id="675b" class="ly kc it bd kd lz ma mb kg mc md me kj mf mg mh kn mi mj mk kr ml mm mn kv mo bi translated">1.将番石榴添加到项目中</h1><p id="7e36" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">番石榴有两种口味</p><ol class=""><li id="9a25" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr mu mv mw mx bi translated">一个用于 Java 8+ JavaRuntimeEnvironment。</li><li id="51ea" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">另一个用于 Java 7 或 Android 平台。</li></ol><p id="9ec3" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">如果您使用的是 Maven，将下面的代码片段添加到<strong class="kz iu"> <em class="lx"> &lt;依赖关系&gt;…&lt;/依赖关系&gt; </em> </strong>部分</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9e08" class="kb kc it ni b gy nm nn l no np">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br/>    &lt;artifactId&gt;guava&lt;/artifactId&gt;<br/>    &lt;version&gt;<strong class="ni iu">version</strong>&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="f5e7" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">如果你正在使用 Gradle，添加<strong class="kz iu"><em class="lx">maven central()</em></strong><em class="lx"/>到资源库</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="de74" class="kb kc it ni b gy nm nn l no np">repositories {<br/>    mavenCentral()<br/>}</span></pre><p id="e1fe" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">然后将下面的代码片段添加到<strong class="kz iu"> <em class="lx"> build.gradle </em> </strong>文件的依赖项部分。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="168b" class="kb kc it ni b gy nm nn l no np">dependencies {<br/>    compile group:'com.google.guava’, name:'guava', version:<strong class="ni iu">version</strong><br/>}</span></pre><p id="11e7" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">查看<a class="ae nq" href="https://mvnrepository.com/artifact/com.google.guava/guava" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多版本信息。</p><p id="fed1" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">对于不使用任何项目管理工具(如 Maven 或 Gradle)的人来说—</p><ol class=""><li id="8ad7" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr mu mv mw mx bi translated">从<a class="ae nq" href="https://mvnrepository.com/artifact/com.google.guava/guava" rel="noopener ugc nofollow" target="_blank"> <strong class="kz iu">这里</strong> </a> <strong class="kz iu">下载一罐谷歌番石榴。</strong></li><li id="5dae" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">如果使用 IDE，将 JAR 文件作为外部库添加。</li><li id="0028" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">如果您使用文本编辑器，将 JAR 文件添加到您的类路径中。</li></ol><h1 id="5aa6" class="ly kc it bd kd lz ma mb kg mc md me kj mf mg mh kn mi mj mk kr ml mm mn kv mo bi translated">2.基本的番石榴公用事业</h1><p id="8cb6" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated"><strong class="kz iu"> 2.1 Joiner 类</strong> <br/>它接受任意字符串，并用一些定界符将它们连接在一起。通过为每个元素调用<strong class="kz iu"> Object.toString() </strong>来构建结果。</p><p id="ebee" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">通常你会这样做</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="57ad" class="kb kc it ni b gy nm nn l no np">public String concatenateStringsWithDelimiter(List&lt;String&gt; strList, String delimiter) {<br/>    StringBuilder builder = new StringBuilder();<br/>    for (String str: strList) <br/>        if (str != null) <br/>            builder.append(str).append(delimiter);<br/>    // To remove the delimiter from the end<br/>    builder.setLength(builder.length() - delimiter.length());<br/>    return builder.toString();<br/>}</span></pre><p id="2fc6" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">但是在 Joiner 类的帮助下，等价于上面的代码可以写成</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="defb" class="kb kc it ni b gy nm nn l no np">Joiner.on(delimiter).skipNulls().join(strList);</span></pre><p id="4662" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">如你所见，代码变得简洁且易于维护。同样，用番石榴找虫子也相对容易。现在，如果你想添加一个空字符串的替换，该怎么办呢？嗯，Joiner 类也处理这种情况。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="6a24" class="kb kc it ni b gy nm nn l no np">Joiner.on(delimiter).useForNull(replacement).join(strList);</span></pre><p id="823f" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">你可能会想，也许 Joiner 类仅限于处理字符串，但事实并非如此。因为它是作为泛型类实现的，所以也可以传递任何对象的数组、iterable 或 varargs。<br/> Joiner 类一旦创建就不可改变。因此，它是线程安全的，可以用作静态最终变量。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="67ef" class="kb kc it ni b gy nm nn l no np">public static final Joiner jnr = Joiner.on(delimiter).skipNulls();<br/>String result = jnr.append(strList);</span></pre><p id="5a12" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><strong class="kz iu"> 2.2 接合工。MapJoiner 类</strong> <br/>它与 Joiner 类的工作方式相同，唯一的区别是它用指定的键-值分隔符将给定的字符串连接成键-值对。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="34f3" class="kb kc it ni b gy nm nn l no np">public void DemoMapJoiner() {<br/>    // Initialising Guava LinkedHashMap Collection<br/>    Map&lt;String, String&gt; myMap = Maps.newLinkedHashMap();<br/>    myMap.put(“India”, “Hockey”);<br/>    myMap.put(“England”, “Cricket”);<br/>    String delimiter = “#”;<br/>    String separator = “=”;<br/>    String result = Joiner.on(delimiter).withKeyValueSeperator(separator).join(myMap);<br/>    String expected = “India=Hocket#England=Cricket”;<br/>    assertThat(result, expected);<br/>}</span></pre><p id="4a09" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><strong class="kz iu"> 2.3 Splitter 类</strong> <br/> Splitter 类的作用与 Joiner 类相反。它接受一个带分隔符的字符串(一个字符、一个字符串或者甚至是一个正则表达式模式),并在分隔符上分割该字符串，然后获得一个部分数组。</p><p id="5d4b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">通常你会这样做</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="7b33" class="kb kc it ni b gy nm nn l no np">String test = “alpha,beta,gamma,,delta,,”;<br/>String[] parts = test.split(“,”);<br/>// parts = {“alpha”, “beta”, “gamma”, “”, “delta”, “”};</span></pre><p id="882c" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">你能注意到这个问题吗？你不希望空字符串成为我的结果的一部分。所以，split()方法还有待改进。</p><p id="5227" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">但是在 Splitter 类的帮助下，与上面等价的代码可以写成</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="5b53" class="kb kc it ni b gy nm nn l no np">Splitter splitter = Splitter.on(“,”);<br/>String[] parts = splitter.split(test);</span></pre><p id="08b9" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><strong class="kz iu"> split() </strong>方法返回一个 iterable 对象，该对象包含测试字符串中的各个字符串部分。<strong class="kz iu"> trimResults() </strong>方法可用于删除结果中的前导和尾随空格。</p><p id="c36d" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">就像 Joiner 类一样，Splitter 类一旦创建也是不可变的。因此，它是线程安全的，可以用作静态最终变量。</p><p id="734d" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><strong class="kz iu"> 2.4 MapSplitter 类</strong> <br/> Splitter 类伴随着 MapSplitter。它接受一个字符串，该字符串中的键值对由某种分隔符(一个字符、一个字符串甚至是一个正则表达式模式)分隔，并以与原始字符串相同的顺序返回带有键值对的 Map 实例。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="67fd" class="kb kc it ni b gy nm nn l no np">public void DemoMapSplitter() {<br/>    String test = “India=Hocket#England=Cricket”; <br/>    // Initialising Guava LinkedHashMap Collection<br/>    Map&lt;String, String&gt; myTestMap = Maps.newLinkedHashMap();<br/>    myMap.put(“India”, “Hockey”);<br/>    myMap.put(“England”, “Cricket”);<br/>    String delimiter = “#”;<br/>    String seperator = “=”;<br/>    Splitter.MapSplitter mapSplitter = Splitter.on(delimiter).withKeyValueSeperator(seperator);<br/>    Map&lt;String, String&gt; myExpectedMap = mapSplitter.split(test);<br/>    assertThat(myTestMap, myExpectedMap);<br/>}</span></pre><p id="1f14" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><strong class="kz iu"> 2.5 前置条件类</strong> <br/>前置条件类提供了静态方法的集合来检查我们代码的状态。前提条件很重要，因为它们保证成功代码的期望得到满足。</p><p id="2193" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">比如:<br/> 1。检查空条件。你可以一直写</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="826b" class="kb kc it ni b gy nm nn l no np">if (testObj == null)<br/>        throw new IllegalArgumentException(“testObj is null”);</span></pre><p id="a31d" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">使用前置条件类使它更加简洁易用</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9c18" class="kb kc it ni b gy nm nn l no np">checkNotNull(testObj, “testObj is null”);</span></pre><p id="585b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">2.检查有效参数。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="fc78" class="kb kc it ni b gy nm nn l no np">public void demoPrecondition {<br/>    private int age;<br/>    public demoPrecondition(int age) {<br/>    checkArgument(age &gt; 0, “Invalid Age”);<br/>        this.age = age;<br/>    }<br/>}</span></pre><p id="2b13" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">checkArgument(exp，msg)计算作为参数传递给方法的变量的状态。它计算一个布尔表达式 exp，如果表达式计算结果为 false，则抛出 IllegalArgumentException。</p><p id="d2c7" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">3.检查对象的状态</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="18f0" class="kb kc it ni b gy nm nn l no np">public void demoPrecondition {<br/>        private String name;<br/>        public demoPrecondition(String name) {<br/>            this.name = checkNotNull(name, “Anonamous”);<br/>        }<br/><br/>        public void Capitalize() {<br/>            checkState(validate(), “Empty Name”);    <br/>        }<br/>        <br/>        private bool validate() { this.name.length() &gt; 0; }<br/>    }</span></pre><p id="8af9" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">checkState(exp，msg)计算对象的状态，而不是传递给方法的参数。它计算一个布尔表达式 exp，如果表达式计算结果为 false，则抛出 IllegalArgumentException。</p><p id="fc6e" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">4.检查有效的元素索引</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="62a0" class="kb kc it ni b gy nm nn l no np">public void demoPrecondition {<br/>        int size;<br/>        private int [] price;<br/>        <br/>        public demoPrecondition(int size) {<br/>            this.size = checkArgument(size &gt; 0, “size must be greater than 0”);<br/>           this.price = new int[this.size];<br/>        }<br/>        public void updateItem(int index, int value) {<br/>            int indexToBeUpdated = checkElementIndex(index, this.size, “Illegal Index Access”);<br/>        }<br/>    }</span></pre><p id="6070" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">谢谢你的阅读。在下一篇文章中，我们将讨论 Guava 中的函数式编程。</p></div></div>    
</body>
</html>