<html>
<head>
<title>Decomposing Signal Using Empirical Mode Decomposition — Algorithm Explanation for Dummy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用经验模式分解法分解信号——哑元算法解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decomposing-signal-using-empirical-mode-decomposition-algorithm-explanation-for-dummy-93a93304c541?source=collection_archive---------5-----------------------#2019-10-04">https://towardsdatascience.com/decomposing-signal-using-empirical-mode-decomposition-algorithm-explanation-for-dummy-93a93304c541?source=collection_archive---------5-----------------------#2019-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4d7b7ce4f49f82a8940795ff7c9e0ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sw8td2wzhPqz43fAhXS68A.jpeg"/></div></div></figure><p id="9267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经验模式分解(EMD)是一只什么样的‘野兽’？这是一种分解信号的算法。而<strong class="kd iu">我说的信号，指的是一个时序数据</strong>。我们<strong class="kd iu">输入一个信号到 EMD，我们将得到一些分解的信号</strong>，也就是我们信号输入的“基本成分”。它类似于快速傅立叶变换(FFT)。FFT 假设我们的信号是周期性的，它的“基本成分”是各种简单的正弦波。在 FFT 中，我们的信号是从时间频谱转换到频率频谱。</p><p id="e5cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">EMD 的不同之处在于输出保留在时间谱中，并且<strong class="kd iu"> EMD 不假设我们的信号是周期性的，它不是基于简单的正弦波</strong>，而是基于固有模式函数(IMF)。EMD 实际上是基于数据集的，没有关于数据的假设(这就是为什么它被称为经验的)。IMF 是一个波，它有两个特性:</p><ol class=""><li id="1c3d" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">最大值和最小值最多相差 1 个</strong>。最大值是波峰，最小值是波谷。</li></ol><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi li"><img src="../Images/1ad23f6a00e814a1fc99141811c5fd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*MySDdRqXYI2vtJCeEENk1w.png"/></div></figure><p id="cd87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们的数据集已经使用</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/8490db3b627c43313518553cfe629f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Ap_7t_-luGSaAVgc7kl7qA.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">z is the standardized value of data, x is the real value of data, μ is the mean of the dataset, and σ is the standard deviation of the dataset</figcaption></figure><p id="5e13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后<strong class="kd iu">最大值不总是大于零，最小值不总是小于零</strong>。最大值是信号的值，当信号的趋势继续上升，然后突然下降时，正好在值下降之前的值是最大值。另一方面，最小值是当信号的趋势继续下降，然后突然上升时，上升前的值是最小值。</p><p id="4588" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.<strong class="kd iu">IMF 的波动均值为零</strong>。</p><p id="de17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个简单的正弦波就是一个 IMF(最小值和最大值之间的差值最多为 1，数据集的平均值为零)。</p><pre class="lj lk ll lm gt ls lt lu lv aw lw bi"><span id="701c" class="lx ly it lt b gy lz ma l mb mc">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; frequency = 1<br/>&gt;&gt;&gt; total_time = 1<br/>&gt;&gt;&gt; res = 0.01<br/>&gt;&gt;&gt; time = np.arange(0, total_time, res)<br/>&gt;&gt;&gt; amplitude = np.sin(2 * np.pi * frequency * total_time * (time/time[-1]))<br/>&gt;&gt;&gt; np.mean(amplitude)<br/>-2.6319088627735572e-17 #this value literally equal 0</span></pre><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/c2fa4bf8f70e7891ed61468dd00ad7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLT-8yXWofXZs32jAtu9_g.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The difference between maxima and minima in 1 Hz sine wave is 0</figcaption></figure><p id="b807" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是一个 IMF 可以有不止一个频率，而且更复杂。</p><p id="8555" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让我们更容易理解算法，这里我呈现一个玩具测试信号。</p><p id="1d84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该信号(1 Hz 正弦波)</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/c379040c9eee2663a4d176dc95894bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*U3VWVyzlipVHGY24lDJXzw.png"/></div></figure><p id="700a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和这个(4 Hz 正弦波)</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8eeaa8f2785f3dfe7a5d92a5adc158f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*vOLgdm1TD_F4ZRHmGayHOQ.png"/></div></figure><p id="2bf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结合成这样</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/5da22c0058ee2d1304383fcd3349444b.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*ty1ASMt6d4Hhr6k8weeKIQ.png"/></div></figure><p id="d659" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">瞧，我们将试着通过这一步一步的算法解释来分解这个信号。</p><p id="f6c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是 EMD 的算法。</p><p id="91e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第一步，求最小值和最大值。</strong></p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/33d2293668cd9c02352fecb365b21cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*WQTqPnutaJgS0X4slQyvOA.png"/></div></figure><p id="9c4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤 2，从最小值和最大值数组中创建最小值和最大值的包络</strong>。使用三次样条插值最小值和最大值以创建最小值和最大值的包络。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/84b60bd0adb8ad489eb3caf4cb9d5b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*02GBMUI8IdXTOdV6lmjTZg.png"/></div></figure><p id="d414" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第四步，从最小值和最大值的包络中，得到中间值</strong>。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/903084b3840d049d6eacaab87631aae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*kCmAUpcweDz60VLRrrkAJw.png"/></div></figure><p id="9b50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤 5，将真实玩具测试信号的值减少包络线的中间值</strong>。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/d6c1bec77e65e3836a9326389151e779.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*ILLJuAM9aNFYDiZiVoof8w.png"/></div></figure><p id="943a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你仔细看，这是我们成功提取的 4 Hz 正弦波。但是看起来有一些误差，比如波的两边有一个突然的跳跃。<strong class="kd iu">这来自于三次样条</strong>的插值误差。<strong class="kd iu">三次样条插值在信号</strong>开始和结束时变得如此糟糕。解决方法是我们必须定义一个边界条件。关于边界条件，我的意思是<strong class="kd iu">在</strong>进行三次样条之前，我们必须定义信号开始和结束时的最小值和最大值的包络。在这篇文章中，信号开始和结束时的最小值和最大值的包络与离它们最近的最大值和最小值相同。让我们从步骤 1 到步骤 5 重新开始，但是这次，我们定义边界条件。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/86d448fbdd480ef2cd0279ebf3682a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*uKiaAdW-E6RxUlt8WRdRVg.png"/></div></figure><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/a717c3027be15be512ac9a151dc3da0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*KJvAM3Htez54-TUnBgrwSw.png"/></div></figure><p id="8a03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哎哟，这一次的错误是影响整个提取的信号。但是这种突然的飞跃已经消失了。</p><p id="c06b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">步骤 6，检查该提取的信号是否是 IMF </strong>。</p><pre class="lj lk ll lm gt ls lt lu lv aw lw bi"><span id="91b6" class="lx ly it lt b gy lz ma l mb mc">#here is the ouput of python script<br/>mean: -0.002681745482482584 <br/>Total minima 20 <br/>Total maxima 21</span></pre><p id="2ba0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">平均值几乎为零，我认为我们可以忽略它，将其四舍五入为零。最小值和最大值的数量也满足要求，<strong class="kd iu">我们得到一个 IMF </strong>。如果您对提取信号的平均值不满意，您可以按照步骤 2-步骤 6 再处理一次。但是<strong class="kd iu">这一次，我们使用提取的信号</strong>，而不是输入真实的玩具测试信号。当在第一次或第二次等尝试中，提取的信号不满足 IMF 条件时，这是算法的路线。为了使它更简单，让我们承认信号是一个国际货币基金组织。</p><p id="819f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第七步，用这个 IMF </strong>降低原来的玩具测试信号。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3344fb81a006bf43c9ff649b61f13f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*sSshVo6xu1ILELEKizBaaA.png"/></div></figure><p id="0725" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哇，我们得到了我们的 1 Hz 信号(但正如我们所想的，开始和结束是错误的)。看来我们成功地分解了融合信号。但是，在 EMD 算法中停止的条件是当我们的残差信号只是一个常数，单调的，或只有 1 个极值(只有 1 个最小值或最大值)。<strong class="kd iu">我们之前被 IMF 减少的信号被称为残差</strong>。让我们继续这个过程。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/b442bf386f2a81e93a5f54e164cbbe25.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*oN01jcvUOwzRbG5XpteokA.png"/></div></figure><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/4391b008c3f215e3382286164cd66205.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*CrrRXmqhd1HPJJlC99sgHg.png"/></div></figure><pre class="lj lk ll lm gt ls lt lu lv aw lw bi"><span id="7bdf" class="lx ly it lt b gy lz ma l mb mc">mean: -0.002681745482482584 <br/>Total minima 6 <br/>Total maxima 6</span></pre><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/df898ecf833df1d15b943626baa33fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*PNg4efZHacnHh39OmWn5zA.png"/></div></figure><p id="57bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看起来渣油的要求还没有满足。让我们再处理一遍。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/58723992d58ea3b06b85e352cfd86ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*F8tZEE1OmhdPm8xgVg0PRQ.png"/></div></figure><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8f1fd50dcac5e668d6c9471a1c927ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*sI5P-A2vfSl-7PLWpAmlrw.png"/></div></figure><pre class="lj lk ll lm gt ls lt lu lv aw lw bi"><span id="9c14" class="lx ly it lt b gy lz ma l mb mc">mean: -0.002681745482482584 <br/>Total minima 2 <br/>Total maxima 2</span></pre><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/ce3a1a2057d69df6e4921e4679026661.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*D4L5XDd1XnKD_Et23xi0Xw.png"/></div></figure><p id="7ec8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们找到了剩余(单调的)。由于边界的累积误差，最后提取的像噪声一样。<strong class="kd iu">这可以通过提高信号平均值的阈值</strong>来防止。当信号的平均值不满足阈值时(提取的信号不是 IMF)，它将按照步骤 2–6 再次尝试，直到提取的信号满足阈值。阈值越趋近于零，这种噪声就越有可能消失。所以这篇文章不会太长，在前面的 EMD 算法演示中，我们使用的阈值并不是太严格。因为最终我们想要达到的是，读者一步一步地理解 EMD 算法。</p><p id="a8c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">第一次，我在尝试使用 google colab，所以所有构建上面所有图的代码和解释都可以通过这个链接</strong>  <strong class="kd iu">访问</strong><a class="ae mi" href="https://colab.research.google.com/drive/1omi4RFZRp4-FY2yhGWnmAlE9MnIkxkfj" rel="noopener ugc nofollow" target="_blank">(PS:有些代码必须按顺序运行才能正常工作)。</a></p><p id="c426" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再见。</p><p id="d343" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参考资料:</p><p id="07cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mi" href="https://medium.com/@rrfd/standardize-or-normalize-examples-in-python-e3f174b65dfc" rel="noopener">https://medium . com/@ rrfd/standardize-or-normalize-examples-in-python-E3 f 174 b 65 DFC</a>，2019 年 10 月 2 日获取</p><p id="5242" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">a .泽勒、r .法特尔迈尔、I. R .凯克、A. M .汤姆、C. G .蓬托内特和 E. W .朗(2010 年 7 月)。经验模态分解-导论。在<em class="mj">2010 年国际神经网络联合会议(IJCNN) </em>(第 1-8 页)。IEEE。</p></div></div>    
</body>
</html>