<html>
<head>
<title>An Introduction to Big Data, Apache Spark, and RDDs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大数据、Apache Spark 和 RDDs 简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-big-data-apache-spark-and-rdds-975ef4d91be2?source=collection_archive---------8-----------------------#2019-06-13">https://towardsdatascience.com/an-introduction-to-big-data-apache-spark-and-rdds-975ef4d91be2?source=collection_archive---------8-----------------------#2019-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a87" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Spark 架构如何优化以处理大型数据集的基本方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61fb7a2b00f20a2c5f438fa37dde11d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mOyAyNkZI236vJSt"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NASA</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们每天总共产生超过 2.5 万亿字节的数据。</p><p id="2437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">yelp 评论、广告点击或地理坐标——只要你说得出，我们的数字足迹就可能在那里。从社交媒体平台上的数百万内容创作者到源源不断的交易行项目，我们的世界一直在以指数速度产生数据。它们的大小从 0.7 MB 的 twitter 帖子到<a class="ae kv" href="https://eng.uber.com/uber-big-data-platform/" rel="noopener ugc nofollow" target="_blank"> 100 多 PB 的优步地理交通洞察</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/7fe59a63a56877f3ee7707ddb4235b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/0*08Otot4zHOe0iERs.jpg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Current big data systems are processing datasets in the Petabytes range</figcaption></figure><p id="3890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着这一趋势，重要的是，我们有能力捕捉它，解释它，并基于它做出“数据驱动的决策”。但为了让我们真正获得这些见解，数据科学家围绕大数据以及如何处理如此庞大的信息创建了一个完整的领域。</p><p id="3dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是，大数据需要更强大的计算工具，而不仅仅是标准的 excel 回归，甚至是你可能熟悉的 python 熊猫。特别是在处理企业级生产级数据集或考虑为任何具有数据播放功能的初创公司进行扩展时，大数据平台是管理和分析您所有大数据需求的核心。其中一个平台 Apache Spark 已经成为处理大数据的事实平台，并继续成为学术界和行业中数据专家使用最多的平台。本文旨在将 Spark 的核心概念分解成简单明了的描述。</p><h1 id="c7f8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Spark 处理大数据</h1><p id="77b1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们从 Apache Spark 网站开始——Spark 是一个“用于大数据处理的统一分析引擎”从高层次来说，它是一个计算框架，允许我们:</p><ol class=""><li id="91f9" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">加载/接收大量实时数据(流)</li><li id="6476" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">转换/清理大量数据(SQL 操作)</li><li id="725a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">对大量数据运行 ML 分析技术(机器学习)</li><li id="9d25" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">处理大量数据的图形网络(图形处理)</li></ol><p id="8b73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看到模式了吗？处理大数据的各种计算功能。我们用 Python、R、Scala 和 Java 为 Apache Spark 编写代码，脚本通常运行在支持这些大型计算的平台上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/1969f7ac78c52a55a6ddce884e35c001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4ztlF7D3C91SZR08.jpg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A Big Number of Big Machines process Big Data</figcaption></figure><p id="9229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些运行 Spark 的平台通常是基于云的(微软 Azure、AWS、谷歌云等。)并写在与云环境相连的笔记本上。这些笔记本电脑由联网的计算机集群支持，可以高效地处理大型数据集，这是您单独的笔记本电脑或 PC 无法处理的。(更多关于<em class="nf">如何</em>以后)</p><h1 id="d311" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">RDD 作为火花的基本抽象</h1><p id="97b0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Apache Spark 通过一种称为弹性分布式数据集(RDD)的抽象来处理这些海量数据。你会经常听到这个词，因为它是 Spark 强大的数据处理引擎的基础。</p><p id="f52d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从高层次上讲，RDD 是一种逻辑结构，它允许我们以我们熟悉的传统表格格式可视化数据，并在数据集上运行必要的 SQL 查询。它的核心是一个 java 对象，有内置的方法(如<em class="nf"> RDD_example.map() </em>、<em class="nf"> RDD_example.filter() </em>等)。)允许我们操作传入的原始数据。RDD 仅仅是一个抽象，负责处理(存储&amp;转换)我们传入的数据。</p><p id="d282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在幕后，RDD 通过对数据子集进行分区来有效地处理大数据，这些子集可以在各个节点上并行地在<strong class="ky ir">上操作</strong>，并且每个分区都有副本以防止数据丢失。下面是一个用 RDD 表示数据的具体例子:</p><h2 id="bc41" class="ng lu iq bd lv nh ni dn lz nj nk dp md lf nl nm mf lj nn no mh ln np nq mj nr bi translated">示例:让我们给 Spark 100GB 的数据:</h2><p id="d54c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设在这个设置中我们有 5 个工作节点可用。Spark 认识到将所有 100 GB 分配给一个工作节点而让其他四个空着是低效的。相反，它选择将这个原始数据集划分到工作节点上，以平均分配工作负载。Spark 决定将数据划分为 100 个分区(从技术上讲，分区数量是您首先设置的参数)，每个分区有不同的 GB。</p><p id="42ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，节点#1 获得第一个 20 GB，节点#2 获得 21–40gb，节点#3 获得 41–60gb，依此类推。</p><p id="2fda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是并不是所有的数据都是同等地创建的——有些数据可能比其他数据运行得更快，而有些数据可能过于繁重，以至于会导致节点崩溃。</p><p id="a2f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spark 决定为节点#1 提供 21–40gb 和 41–60gb 的副本，为节点#2 提供 41–60gb 和 61–80gb 的副本，依此类推。</p><p id="3cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，虽然每个工作节点主要负责其原始的 20 GB，但它也存储其他 GB 分区的副本。<em class="nf">因此，Spark 有效地将数据划分到节点上，这样工作节点可以并行计算数据，同时防止空闲节点。</em>也就是说，如果一个工作者节点提前完成了它的计算，它可以从另一个工作者节点(可能很慢或者已经崩溃)那里“拾起空闲”并支持另一个 GB 分区的计算。</p><p id="77bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从示例中，我们可以看到以下几点:</p><ol class=""><li id="53b4" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">数据具有<strong class="ky ir">弹性</strong> —通过存储数据的多个副本，每个副本存储在不同的节点中，我们可以避免在一个或多个节点发生故障的罕见情况下丢失数据。</li><li id="1e63" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">数据是<strong class="ky ir">分布式的</strong> —很明显，在最初的 100GB 数据中，我们已经跨多个节点对数据进行了分区或分片。这使得每个节点处理的数据更少，从而提高了整体运行速度。</li><li id="eab7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">数据是一个<strong class="ky ir">数据集</strong> —它是一个保存数据的数据结构。在表功能中，它可以被格式化为具有索引的命名列，但是除了被分区之外，它也可以没有正式的结构组织。当它以 DataFrame 对象的形式使用内置方法时，可以为这种特殊的数据集提供更丰富的优化。</li></ol><p id="69f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就产生了弹性分布式数据集的名称。当然，这个过程还存在更多的细微差别，但是上面的例子试图说明 Spark 使用 rdd 的效率的一个简化的思考过程。</p><h1 id="30fe" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">PySpark 中 rdd 的 4 行代码</h1><p id="585c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">RDD_example = sc.parallelize([1，2，3])<br/>o = RDD _ example . filter(lambda I:I % 2)。map(lambda I:I * 2)<br/>result = o . collect()<br/>print(结果)</p><p id="c1e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">##(输出:2，6)</p><p id="9343" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，使用并行化方法的第一行，我们从传入的整数列表中创建 RDD。可以把并行化想象成这样——创建 RDD，这样我们就可以并行处理数据。</p><p id="cffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们创建的 RDD 上，我们对该对象应用了两个额外的方法，这两个方法仍然返回 RDD 对象。过滤器和映射都是 MapReduce 框架的一部分，接受各自的匿名函数。在这种情况下，我们过滤 RDD 以包含奇数的元素，然后将加倍函数映射到这些相应的元素。</p><h2 id="f195" class="ng lu iq bd lv nh ni dn lz nj nk dp md lf nl nm mf lj nn no mh ln np nq mj nr bi translated">惰性评估和 Dag</h2><p id="e6b2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这一点上，RDD 的方法似乎与我们在 CS 入门课程中看到的方法相同。那么，为什么我们要费这么大的劲来过滤一个函数并把它映射到一个列表上呢？来评价一下 Spark 如何懒懒地计算<em class="nf"/>。</p><p id="b80e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子，在我们调用 collect 的最后一行，简洁地显示了 spark <strong class="ky ir">转换</strong>和<strong class="ky ir">动作</strong>之间的区别。在这里，我们可以深入了解——的转变。过滤器()和。先前的 map()没有被实际执行，而是被放入执行 map 中，以便稍后被动作激活。的。collect()操作方法实际上用于执行整个代码序列，并开始跨节点的计算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/c1ab1afb34fdab74c524edeba7c57870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HeY7berPUABCVugG.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The local environment execution plan as a Directed Acyclic Graph (DAG) <a class="ae kv" href="https://spark.apache.org/docs/latest/cluster-overview.html" rel="noopener ugc nofollow" target="_blank">https://spark.apache.org/docs/latest/cluster-overview.html</a></figcaption></figure><p id="30c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转换在本地环境中创建的执行计划存储在一个有向无环图(DAG)中。与中一样，计算的步骤遵循一个连续的方向，永远不会循环回自身。</p><p id="cc44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">长话短说，转换方法是返回放入 DAG 的 RDD 的 RDD 方法。动作方法通常是启动 Spark 引擎进行计算的最终操作。转换在本地环境中添加 DAG，并且在动作调用时，DAG 被发送到主驱动程序上的主 Spark 解释器。</p><h1 id="63d2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">大局</h1><p id="93a2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在 Spark 如何运行以及 RDD 如何融入框架的更大范围内，下图抓住了中央驱动程序如何在工作节点之间分布的核心。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/65ea1c258a0eddfdbdae88a561783340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*mDT-5ypTNOzBRIYk.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://spark.apache.org/docs/latest/cluster-overview.html" rel="noopener ugc nofollow" target="_blank">https://spark.apache.org/docs/latest/cluster-overview.html</a></figcaption></figure><p id="2ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们称之为初始的 sc 对象或 SparkContext。parallelize()方法是 Apache Spark 的内置功能，我们可以将其视为主驱动程序的一部分。这个火花上下文对象是我们创建的，或者是给予我们的，这样我们就有能力创建 RDD。从那里，主驱动程序从您的 PySpark 脚本接收 DAG 执行计划，序列化代码(例如，转换成位和字节)，并将各自的分区发送到它们通过 API 调用接收的工作节点。然后，每个工人执行从 DAG 分配给他们的操作。这提升了 Spark 并行计算和高效处理大数据的能力。</p></div></div>    
</body>
</html>