<html>
<head>
<title>Coupling Web Scraping with Functional programming in R for Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向规模的 R 语言中 Web 抓取与函数式编程的耦合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coupling-web-scraping-with-functional-programming-in-r-for-scale-1bc4509eef29?source=collection_archive---------27-----------------------#2019-02-11">https://towardsdatascience.com/coupling-web-scraping-with-functional-programming-in-r-for-scale-1bc4509eef29?source=collection_archive---------27-----------------------#2019-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4e32d564d9722e9d3017159139e04ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPhII8tpOj9XsXXQNngPzw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://unsplash.com/photos/-lp8sTmF9HA" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/-lp8sTmF9HA</a></figcaption></figure><p id="c774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看到如何使用 R 进行 web 抓取，同时，我们将利用 R 中的函数式编程来扩展它。这篇文章的性质更像是一种食谱格式，而不是文档/教程类型，因为这里的目标是解释 web 抓取如何有效地与函数式编程相结合</p><h2 id="4dfd" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">R 中的网页抓取</strong></h2><p id="de47" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">数据爱好者无需介绍网络搜集。当数据本身不可用时，这是收集数据的最可行和最基本的方法之一。</p><p id="2026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你缺少数据，或者需要宏观经济指标，或者某个项目没有可用的数据，比如带有自定义文本数据集的 Word2vec / Language 时，了解网络搜集会非常方便。</p><p id="73c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个漂亮的(类似 Python 中的 BeautifulSoup 包，用于 web 抓取。它与<code class="fe lz ma mb mc b">tidyverse</code>的宇宙和超级方便的<code class="fe lz ma mb mc b">%&gt;%</code>管道操作员也很好。</p><h2 id="e1cc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">样本用例</strong></h2><p id="2a8d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">顾客对 Etsy.com 感受的文本分析。为此，我们将从<a class="ae kc" href="http://trustpilot.com" rel="noopener ugc nofollow" target="_blank">trustpilot.com</a>中提取评论数据。</p><p id="1479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是从 Trustpilot 的 Etsy 页面第一页抓取评论的 R 代码。<a class="ae kc" href="https://www.trustpilot.com/review/www.etsy.com?page=1" rel="noopener ugc nofollow" target="_blank">网址:https://www.trustpilot.com/review/www.etsy.com?page=1</a></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="d822" class="lb lc iq mc b gy ml mm l mn mo">library(tidyverse) #for data manipulation - here for pipe<br/>library(rvest) - for web scraping</span><span id="6d78" class="lb lc iq mc b gy mp mm l mn mo">#single-page scraping</span><span id="22d8" class="lb lc iq mc b gy mp mm l mn mo">url &lt;- "<a class="ae kc" href="https://www.trustpilot.com/review/www.etsy.com?page=1" rel="noopener ugc nofollow" target="_blank">https://www.trustpilot.com/review/www.etsy.com?page=1</a>"</span><span id="15eb" class="lb lc iq mc b gy mp mm l mn mo">url %&gt;% <br/>  read_html() %&gt;% <br/>  html_nodes(".review-content__text") %&gt;% <br/>  html_text() -&gt; reviews</span></pre><p id="022d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一段相当简单的代码，我们传递 URL 来读取 html 内容。一旦内容被读取，我们使用<code class="fe lz ma mb mc b">html_nodes</code>函数根据它的<code class="fe lz ma mb mc b">css selector property</code>获取评论文本，最后从它的<code class="fe lz ma mb mc b">html_text()</code>中取出文本并将其分配给 R 对象<code class="fe lz ma mb mc b">reviews</code>。</p><p id="a97a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe lz ma mb mc b">reviews</code>的输出示例:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/9262fe9136c71f5c24b576e66800c3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfimrAbyjQFZ7icNctmTrw.png"/></div></div></figure><p id="92ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。我们已经成功地收集了我们分析所需的评论。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0ba26a9a8313c7459d5ea426a417cfe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*zeuLPCYv_9AIn7Gz6VpeNQ.png"/></div></figure><p id="2d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但问题是我们得到的评论数量只有 20 条——正如我们在截图中看到的，我们已经得到了一条非英语评论，我们可能不得不在数据清理过程中将其排除。</p><p id="55eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使我们有机会收集更多的数据来弥补上述数据损失，并使分析更加有效。</p><h2 id="1d42" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">规模需求</h2><p id="46ea" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">使用上面的代码，我们只从第一页(也是最近的一页)开始。因此，由于需要更多的数据，我们必须将搜索范围扩大到更多的页面，比如说 10 个其他页面，在数据处理之前，这些页面将为我们提供 200 条原始评论。</p><h2 id="097c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">传统方式</h2><p id="fdf0" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">非常传统的方法是使用一个循环——通常是使用<code class="fe lz ma mb mc b">for</code>循环从 1 到 20 迭代 url，以基于一个基本 URL 创建 20 个不同的 URL(字符串连接)。众所周知，这需要更多的计算，代码也不紧凑。</p><h2 id="c4aa" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">函数式编程方式</strong></h2><p id="a2e1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在这里，我们将使用来自包<code class="fe lz ma mb mc b">purrr</code>的 R 的函数式编程支持，在与上述代码相同的数据管道中，以 R 的<code class="fe lz ma mb mc b">tidy</code>方式执行相同的迭代。我们将使用<code class="fe lz ma mb mc b">purrr</code>中的两个函数，</p><ol class=""><li id="9b52" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated"><code class="fe lz ma mb mc b">map()</code>是来自函数式编程范式的典型映射，它接受一个函数并映射到一系列值上。</li><li id="a294" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><code class="fe lz ma mb mc b">map2_chr()</code>是 map 的发展，它接受函数的附加参数，并将输出格式化为字符。</li></ol><p id="021e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">下面是我们的函数式编程代码</strong></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="dad6" class="lb lc iq mc b gy ml mm l mn mo">library(tidyverse)<br/>library(rvest)<br/>library(purrr)</span><span id="5c57" class="lb lc iq mc b gy mp mm l mn mo">#multi-page</span><span id="c63b" class="lb lc iq mc b gy mp mm l mn mo">url &lt;- "<a class="ae kc" href="https://www.trustpilot.com/review/www.etsy.com?page=" rel="noopener ugc nofollow" target="_blank">https://www.trustpilot.com/review/www.etsy.com?page=</a>" #base URL without the page number</span><span id="eadf" class="lb lc iq mc b gy mp mm l mn mo">url %&gt;% <br/>  map2_chr(1:10,paste0) %&gt;% #for building 20 URLs <br/>  map(. %&gt;% <br/>    read_html() %&gt;% <br/>      html_nodes(".review-content__text") %&gt;% <br/>      html_text()<br/>  ) %&gt;% <br/>  unlist() -&gt; more_reviews</span></pre><p id="c81f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，这段代码与上面的单页代码非常相似，因此它使得任何理解前面代码的人都可以更容易地用最少的先验知识来通读这段代码。</p><p id="37e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码中的额外操作是，我们构建 20 个新的 URL(通过更改 URL 的查询值)并逐个传递这 20 个 URL 以进行 web 抓取，最后，作为回报，我们将获得一个列表，我们使用<code class="fe lz ma mb mc b">unlist</code>保存所有计数必须为 200 的评论(每页 20 条评论 x 10 页)。</p><p id="fe5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看输出是什么样子的:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/57c05d57c402d261cb17ae85203b5fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gb-oTtYRXoBMBQ4_j83-dA.png"/></div></div></figure><p id="6758" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，200 条评论。这实现了我们的目标，即收集(相当)足够的数据来执行我们上面提到的文本分析用例。</p><p id="9ad1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是本文的重点是向您介绍 R 中的函数式编程，并展示它如何容易地适应现有的数据管道/工作流，它是如何紧凑，毫无疑问，它是如何高效(比典型的 for 循环)。希望这篇文章达到了它的目的。</p><ul class=""><li id="1654" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la nh my mz na bi translated"><strong class="kf ir">如果你更感兴趣，可以看看这个关于函数式编程的</strong> <a class="ae kc" href="https://www.datacamp.com/courses/foundations-of-functional-programming-with-purrr?tap_a=5644-dce66f&amp;tap_s=210728-e54afe" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Datacamp 课程</strong></a></li><li id="7828" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la nh my mz na bi translated">这里使用的完整代码可以在 github 上<a class="ae kc" href="https://github.com/amrrs/blogpost_codes/blob/master/rvest_purrr_scraping_at_scale.R" rel="noopener ugc nofollow" target="_blank">找到</a></li></ul><p id="51a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ni">谢谢:整篇文章和代码的灵感来自 Saurav Ghosh 在 Bengaluru R 用户组 meetup </em>中参加的会议</p></div></div>    
</body>
</html>