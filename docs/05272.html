<html>
<head>
<title>Javascript Execution Context and Hoisting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 执行上下文和提升</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/javascript-execution-context-and-hoisting-c2cc4993e37d?source=collection_archive---------17-----------------------#2019-08-06">https://towardsdatascience.com/javascript-execution-context-and-hoisting-c2cc4993e37d?source=collection_archive---------17-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f085c5b32e050afee1144d0b707b620e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXTMuOB_HSMTZlfM2V4xIQ.png"/></div></div></figure><p id="00d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章是写给那些不知道 JavaScript 是如何执行的人的。</p><p id="ded9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先决条件:你应该知道</p><ol class=""><li id="9a91" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/@ideepak.jsd/still-confused-in-js-scopes-f7dae62c16ee?" rel="noopener">JavaScript 中的作用域</a></li><li id="1520" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/@ideepak.jsd/javascript-context-this-keyword-9a78a19d5786?" rel="noopener">JavaScript 中的这个关键字</a></li><li id="83c0" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">电脑中的堆栈</a></li></ol><p id="9a58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始之前，你能回答下面的问题吗？</p><h2 id="be56" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">Javascript 是解释语言还是编译语言？</h2><p id="d8a0" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">是的，Javascript (JS)是一种解释型语言，仍然有自己的编译器形式，运行在所谓的 Javascript 引擎中。</p><p id="7708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个网络浏览器都有自己的 JavaScript 引擎形式，例如 Chrome 有 v8，Mozilla 有 spider monkey 等，尽管它们都有相同的目的。JavaScript 引擎只是将 JavaScript 源代码转换成编译器可以理解的语言，然后执行它。</p><p id="c7e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那我们开始吧，</p><h1 id="fed3" class="mm lp it bd lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz na nb mf nc bi translated">执行上下文</h1><p id="fa1f" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">javascript 代码运行的环境构成了执行上下文。</p><p id="91a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行上下文决定了哪段代码可以访问变量、函数、对象等。</p><p id="c7a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你读过作用域的文章，那么你应该知道什么是全局作用域和局部作用域(函数作用域)。</p><p id="fc9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，执行上下文也有不同的类型—</p><h2 id="7071" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">1.全局执行上下文</h2><p id="41e8" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">每当代码第一次运行时，或者当代码不在任何函数中时，它就会进入全局执行上下文。在整个代码执行过程中，只有一个全局执行上下文。</p><p id="5063" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在浏览器的情况下，全局执行上下文做两件事</p><ol class=""><li id="e16b" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">创建一个“窗口”对象。</li><li id="a7fe" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">窗口对象引用了“this”关键字。</li></ol><h2 id="d3c1" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">2.函数执行上下文</h2><p id="730d" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">每当代码执行发现一个函数，它就创建一个新的函数执行上下文。可以有任意数量的函数执行上下文。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/5e397d35975e34c8fd4c3697a9f2d94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-A-jDYmBTIfN2ADj13iaw.png"/></div></div></figure><p id="376d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面，全局执行上下文包含“name”变量和对“func1”的函数引用。而包含变量和函数引用三个函数执行上下文将被创建。文章中进一步解释了细节。</p><h1 id="e696" class="mm lp it bd lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz na nb mf nc bi translated">执行堆栈/调用堆栈</h1><p id="710e" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">Javascript 在浏览器中一次只能运行一件事，这意味着它是单线程，所以它在所谓的执行堆栈中对其他动作、事件和函数进行排队。</p><p id="8409" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当浏览器加载脚本时，堆栈中的第一个元素是全局执行上下文。然而，当一个函数执行时，一个执行上下文被创建并虚拟地放置在全局执行上下文之上。一旦函数执行完毕，它就会从执行堆栈中弹出，并将控制权返回给它下面的上下文。</p><p id="7df1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们举个例子，把上面的形象化。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/e1166aabaf274991e77e4d79543cb359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu3kTRffs9o9XD1qa6rMCw.png"/></div></div></figure><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/2e590a10ba351e8f18b29d0cc2dc8a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78luWh7gZV3c-99_eLpRWg.png"/></div></div></figure><blockquote class="nk nl nm"><p id="56db" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">步骤 1:当上述代码加载到浏览器中时，Javascript 引擎创建一个全局执行上下文，并将其推送到当前执行堆栈中。</p><p id="1210" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">步骤 2:假设最后我们调用了 func1()，然后 Javascript 引擎为该函数创建了一个新的执行上下文，并将其推到全局执行上下文的顶部</p><p id="5317" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">步骤 3:在 func1()中，我们调用了 func2()，因此 Javascript 引擎为该函数创建了一个新的执行上下文，并将其推到 func1 执行上下文的顶部。</p><p id="2fd0" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">第四步:当 func2()函数结束时，从当前堆栈中弹出它的执行上下文，控件到达它下面的执行上下文，也就是 func1()函数执行上下文。</p><p id="68c4" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">步骤 5:当 func1()完成时，它的执行堆栈被从堆栈中移除，控制到达全局执行上下文。一旦执行完所有代码，JavaScript 引擎就会从当前堆栈中删除全局执行上下文。</p></blockquote><h1 id="81d1" class="mm lp it bd lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz na nb mf nc bi translated">执行上下文阶段</h1><p id="9659" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">执行上下文主要有两个阶段。</p><ol class=""><li id="4016" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">创造</li><li id="0e4c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">执行</li></ol><p id="a1fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们一个一个来看看</p><h2 id="dc5a" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">创建阶段</h2><p id="13bb" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">在函数执行之前，这里会发生一些事情。</p><ol class=""><li id="5e21" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">首先，为每个函数或变量创建一个到外部环境的连接，这就形成了作用域链。这告诉执行上下文它应该包含什么，以及它应该在哪里寻找解析函数的引用和变量值。</li></ol><ul class=""><li id="04ed" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky nr lf lg lh bi translated">对于全球环境来说，外部环境是零。然而，全球范围内的所有环境都以全球环境为其外部环境。</li><li id="567d" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky nr lf lg lh bi translated">如果函数‘a’包含在函数‘b’中，那就意味着‘a’有一个外部环境‘b’。</li></ul><p id="4a7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.在扫描作用域链之后，创建一个环境记录，其中全局上下文(将是 web 浏览器中的一个窗口)、变量、函数和函数参数的创建和引用是在内存中完成的。</p><p id="459b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.最后，在第一步创建的每个执行上下文中确定“this”关键字的值(在全局执行上下文中，“this”指的是窗口)。</p><blockquote class="nk nl nm"><p id="f4aa" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">注意:如果你发现理解这个关键字行为有困难，那么我强烈推荐<a class="ae li" href="https://overflowjs.com/posts/This-keyword-In-Javascript-2019-Javascript-Context.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p></blockquote><p id="2a95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们可以将创建阶段表示为</p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="8e7f" class="lo lp it nt b gy nx ny l nz oa">creationPhase = {<br/>'outerEnvironmentConnection': {<br/>        /* scope chain resolution*/ <br/>    },    <br/>'variableObjectMapping': {<br/>        /* function arguments, parameters, inner variable and function declarations are created or referenced in memory */ <br/>    },<br/>    'valueOfThis': {},<br/>    <br/>}</span></pre><h2 id="4eaa" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">执行阶段</h2><p id="fbc9" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">在这个阶段，代码开始在创建阶段形成的执行上下文中运行，并逐行分配变量值。</p><p id="7e07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当执行开始时，引擎在其创建阶段对象中寻找引用来执行该函数。如果它没有在自己的环境中找到它，它将继续沿着作用域链向上移动，直到到达全局环境。</p><p id="7acb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在全局环境中没有找到引用，它将返回一个错误。但是，如果找到了引用并且正确执行了函数，则该特定函数的执行上下文将从堆栈中弹出，引擎将移动到下一个函数，它们的执行上下文将被添加到堆栈中并执行，依此类推。</p><p id="ce60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过例子来看看上面的两个阶段，以便对它有一个更好的了解。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/dd9a09e6662afa7b7ba3a99bf35f3d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPBnzm2A--iapSJtXJGQFg.png"/></div></div></figure><p id="b5d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，在创建阶段，全局执行上下文将如下所示:</p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="7acd" class="lo lp it nt b gy nx ny l nz oa">globalExecutionObj = {<br/>    outerEnvironmentConnection: null,<br/>    variableObjectMapping: {<br/>        name: uninitialized,<br/>        title: undefined,<br/>        date: uninitialized,<br/>        func1: func,<br/>    },<br/>    this: window //Global Object<br/>}</span></pre><blockquote class="nk nl nm"><p id="c483" class="kb kc nn kd b ke kf kg kh ki kj kk kl no kn ko kp np kr ks kt nq kv kw kx ky im bi translated">注意:上面的<code class="fe oc od oe nt b">let</code>(名称)和<code class="fe oc od oe nt b">const</code>(日期)定义的变量在创建阶段没有任何关联的值，但是<code class="fe oc od oe nt b">var</code>(标题)定义的变量被设置为<code class="fe oc od oe nt b">undefined </code>。</p></blockquote><p id="6b3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是为什么您可以在声明<code class="fe oc od oe nt b">var </code>定义的变量之前访问它们(虽然是<code class="fe oc od oe nt b">undefined</code>)，但是在声明<code class="fe oc od oe nt b">let</code>和<code class="fe oc od oe nt b">const</code>变量之前访问它们时会得到一个引用错误。</p><p id="2cc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们所说的提升，即所有使用<code class="fe oc od oe nt b"><em class="nn">var</em></code>的变量声明都被提升到它们的函数/局部范围的顶部(如果在函数内声明)或全局范围的顶部(如果在函数外声明)，而不管实际声明是在哪里进行的。</p><p id="2630" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在执行阶段，变量赋值已经完成。因此，在执行阶段，全局执行上下文看起来会像这样。</p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="d5aa" class="lo lp it nt b gy nx ny l nz oa">globalExectutionObj = {<br/>    outerEnvironmentConnection: null,<br/>    variableObjectMapping: {<br/>        name: "overflowjs.com",<br/>        title: "Execution context",<br/>        date: "5 july 2019",<br/>        func1: <!-- -->pointer to function func1<!-- -->,<br/>    },<br/>    this: window //Global Object<br/>}</span></pre><p id="ba19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:在执行阶段，如果 JavaScript 引擎在源代码中声明变量<code class="fe oc od oe nt b">let</code>的实际位置找不到它的值，那么它将为它分配<code class="fe oc od oe nt b">undefined</code>的值。</p><p id="f411" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当到达“func1”时，将形成一个新的函数执行上下文，其创建对象如下所示</p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="617f" class="lo lp it nt b gy nx ny l nz oa">func1ExecutionObj = {<br/>    outerEnvironmentConnection: Global,<br/>    variableObjectMapping: {<br/>       <!-- -->arguments: {<br/>            0: 10,<br/>            length: 1<br/>        },<br/>        num: 10,<br/><br/>        author: undefined,<br/>        val: <!-- -->uninitialized<!-- -->,<br/>        func2: undefined<br/>        fixed: <!-- -->uninitialized<br/>        addFive: pointer to function addFive()<br/>    },<br/>    this: Global Object or undefined<br/>}</span></pre><p id="3d8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在执行阶段，</p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="89de" class="lo lp it nt b gy nx ny l nz oa">func1ExecutionObj = {<br/>    outerEnvironmentConnection: Global,<br/>    variableObjectMapping: {<br/>       <!-- -->arguments: {<br/>            0: 10,<br/>            length: 1<br/>        },<br/>        num: 10,<br/><br/>        author: "Deepak",<br/>        val: <!-- -->3<!-- -->,<br/>        func2: pointer to function func2() <br/>        fixed: "<!-- -->Divine"<br/>        addFive: pointer to function addFive()<br/>    },<br/>    this: Global Object or undefined<br/>}</span></pre><p id="6398" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在该函数完成其执行之后，全局环境被更新。然后全局代码完成，程序结束。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="7819" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想被添加到我的电子邮件列表中，请考虑在这里输入您的电子邮件地址 和<strong class="kd iu">关注我的</strong> <a class="ae li" href="https://medium.com/@ideepak.jsd" rel="noopener"> <strong class="kd iu"> medium </strong> </a> <strong class="kd iu">阅读更多关于 javascript 的文章，并关注</strong><a class="ae li" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">github</strong></a><strong class="kd iu">查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="c7a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="8d2a" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="edcb" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://levelup.gitconnected.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener ugc nofollow" target="_blank"> Javascript 数据结构与映射、归约、过滤</a></li><li id="201e" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="7b8f" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="a8af" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a></li></ol><p id="3774" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢！</p></div></div>    
</body>
</html>