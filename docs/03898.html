<html>
<head>
<title>How to bridge Machine Learning and Software Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在机器学习和软件工程之间架起桥梁</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-bridge-machine-learning-and-software-engineering-6f51b38f4b49?source=collection_archive---------17-----------------------#2019-06-19">https://towardsdatascience.com/how-to-bridge-machine-learning-and-software-engineering-6f51b38f4b49?source=collection_archive---------17-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dc204e63872c6f3c619d04f8e2d33f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QVS2E6zZzupIu0xt"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@lastly?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tyler Lastovich</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="aa77" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">将数据科学转化为软件的实用工作流程</h2></div><p id="bcb9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据科学/机器学习社区越来越沮丧地看到又一个 PoC(概念验证)创造了有希望的结果，但从未变成有影响力的东西。主要原因:开发和部署之间的差距很大。</p><p id="bdf6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">越来越多的工具和框架——开源的和商业的——有望弥合这一鸿沟。然而，将他们引入组织是一项耗时且昂贵的工作。</p><p id="e250" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为这样的解决方案而战是光荣的，也是必要的。尽管如此，在此期间我们还可以做些别的事情来缩小差距:使我们的工作流程与软件开发原则保持一致。要学的第一件事:单元测试。</p><p id="904a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，大多数介绍和文档都以抽象的方式处理这个主题。相比之下，这篇博客通过一个具体的例子向你展示了一个实用的工作流程。我们开始吧！</p><h1 id="c513" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">方案</h1><p id="b983" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们在一家迅速扩大客户群的初创公司工作。虽然这对公司来说是个好消息，但有些流程需要适应新的形势。其中之一是电子邮件营销。</p><p id="fd7f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们公司开始发送营销邮件时，客户群很小，而且很专注。因此，所有注册客户都收到了所有的电子邮件，这很好。这不再是真的了。虽然仍有一些忠实的客户不想错过促销和产品更新，但许多新客户却不那么兴奋了。更糟糕的是，越来越多的潜在客户选择退出营销通讯，因为不相关或太多的电子邮件。</p><p id="6215" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过一番讨论后，我们初创企业的创始人决定加强营销流程。他们设想了一种系统，可以将电子邮件发送给关心他们的客户，让其他人免受收件箱的额外压力。</p><p id="2160" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的工作是构建该系统的机器学习部分。</p><h1 id="c45f" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">要求</h1><p id="e0de" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们总结一下我们拥有的和我们需要的:</p><ul class=""><li id="78b6" class="mr ms jj la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">我们有一些顾客的信息。</li><li id="d47d" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">我们有一些关于计划营销电子邮件的信息。</li><li id="2c5f" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">我们需要每个客户与给定营销电子邮件互动的可能性(不包括选择退出简讯的互动)。</li></ul><p id="0d86" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于数据科学家和机器学习工程师来说，跳入收集数据和建立复杂模型是非常非常诱人的。然而，这不是我们现在需要的。请记住，我们的目标是构建一个完整的系统，而不是一个独立的模型。那么，我们如何使我们的工作符合这些要求呢？</p><h1 id="99bb" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">工作流程</h1><p id="cca8" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们决定采用四步工作流程:</p><ol class=""><li id="34da" class="mr ms jj la b lb lc le lf lh mt ll mu lp mv lt nf mx my mz bi translated">选择下一个要开发的组件。</li><li id="7abd" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">编写捕捉我们想要实现的目标的单元测试。</li><li id="64d2" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">编写通过单元测试的代码。</li><li id="926a" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">重复一遍。</li></ol><p id="f2a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们开始吧！</p><h2 id="9739" class="ng lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">步骤 1:选择下一个要开发的组件</h2><p id="93ec" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在，什么都没有。然而，我们知道其他团队开始在整个系统上工作，我们想要支持他们。因此，我们的第一个任务是为整个流程创建一个接口，它接受两个输入并返回期望的输出。我们把这个主类叫做<em class="ns"> CampaignPredictor </em>。它采用一个 pandas 数据框作为客户数据，一个字典作为计划活动的信息，并有一个方法返回所有客户与电子邮件交互的概率。它看起来像这样:</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="72c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我已经包含了类型提示、一个(初步的)docstring 和一个 NotImplementedError。在这一点上继续编码是非常有诱惑力的。然而，如果我们首先陈述我们对这段代码的期望，我们就帮了自己一个大忙。向我们以及将我们的代码集成到整个过程中的团队表达这些期望的最佳方式是:单元测试。</p><h2 id="2895" class="ng lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">步骤 2:编写捕捉我们目标的单元测试</h2><p id="ac8b" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">编写好的单元测试本身就是一门艺术。尽管如此，我们还是想在代码的两个维度上使用它们。第一个尺寸<strong class="la jk">是有效的，而不是无效的输入。在有效输入的情况下，我们关注正确的输出。在无效输入的情况下，我们关注错误处理和快速失败。前者帮助用户了解哪里出错了，而后者确保用户在出错时不必等待。</strong></p><p id="c68d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">第二个</strong>维度是结构与功能质量。结构单元测试包括输入和输出的正确类型和形状。功能单元测试覆盖了代码的功能。也就是说，它是否提供了它承诺要解决的问题。下面是这些单元测试的样子:</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e97c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<strong class="la jk">无效的</strong>输入，主要有两种错误。<em class="ns"> TypeErrors </em>捕获我们期望一种类型的输入并得到另一种类型的输入的所有情况。例如，我们期望一个熊猫数据帧，但是得到一个 numpy 矩阵。<em class="ns"> ValueErrors </em>捕获类型正确的情况，但是我们不能处理值本身。例如，我们期望一个字典有一个“campaign_type”键，该键的值是一个字符串，但是要么这个键丢失了，要么这个值不是一个字符串。这两种情况都会导致以后的问题，所以我们希望尽早发现并提供有意义的错误消息。</p><p id="61b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<strong class="la jk">有效的</strong>输入，不应有任何错误。首先，我们期望输出具有正确的类型和形状。在我们的例子中，这是一个长度与输入中的客户数量相同的列表。第二，我们期望这个列表中的所有值都是有效概率，也就是说，它们的范围从 0 到 1。</p><p id="0539" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们讨论了有效和无效输入的结构和功能方面。因为所有这些测试现在都失败了，所以一切都按预期运行。也就是说，根本不是。让我们解决这个问题。</p><h2 id="0e68" class="ng lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">步骤 3:构建通过测试所必需的东西(第一次尝试)</h2><p id="d0d3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">虽然测试没有明确的顺序，但是我们从无效输入的测试开始。这有助于我们在做一些事情之前澄清我们实际期望得到什么。</p><p id="8438" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们的主要目标是在有无效输入时快速失败，所以我们将编写验证代码作为类初始化的一部分。在我们的例子中，我们需要确保得到一个包含预期键值对的字典和一个至少有一行的数据框，即至少有一个客户可供选择。</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4e6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码通过了无效输入的测试。在进行这项工作时，您可能会获得关于应该测试什么的其他想法。总的来说，这是一件好事，因为这表明你开始更详细地考虑你的方法。然而，不要太具体，因为事情可能会改变。</p><p id="4027" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看第二个测试是非常诱人的——最后！—从建模开始。然而，这不是我们现在的目标。我们的目标是整个过程。同时，有许多不同的方法来预测客户与电子邮件交互的概率。</p><p id="86b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决办法？我们在兔子洞里更深入一步。单元测试的美妙之处在于，一个失败的测试会提醒我们还有一些东西需要修复。首先，让我们实现一个简单的方法来为活动选择客户:简单随机化。</p><h2 id="fc45" class="ng lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">延时拍摄中的步骤 1-3</h2><p id="6ccb" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">第一步:我们现在正在为选择客户的更复杂的方法构建蓝图。对于简单的集成测试来说，这个占位符应该是快速的——并且不是完全愚蠢的。姑且称之为<em class="ns"> RandomSelector </em>类。它需要一些客户来选择，以及他们中应该收到电子邮件的百分比。然后，它应用一种方法来随机选择一组客户，并将结果作为列表返回。</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="bfb9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">第二步:</strong>我们为有效和无效的输入编写单元测试。关于输入，我们希望确保客户的数量多于一个，并且要选择的百分比在 0 和 1 之间。如果输入与此不符，我们希望看到正确的错误类型。关于输出，我们希望得到一个长度正确的列表，并且至少有一个选定的客户。</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b39e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在第 42–51 行看到的，我还包括了一个我在编写测试时想到的边缘案例。同样，单元测试有助于澄清你实际期望得到什么，这使得之后的编码更加集中。</p><p id="0909" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">第 3 部分:</strong>我们更新了类的初始化，以检查输入和产生正确输出的方法。一旦我们通过了测试，我们就完成了这个任务。</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2a1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以使用这个新类来处理我们开始时的事情:CampaignPredictor。</p><h2 id="eb5c" class="ng lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">步骤 3:构建通过测试所必需的东西(第二次尝试)</h2><p id="8797" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果我们正确地从<em class="ns"> CampaignPredictor </em>为<em class="ns"/><em class="ns">random selection</em>类翻译我们的需求，我们几乎不需要额外的代码来通过有效输入的测试:</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="16f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有测试都通过了，我们可以庆祝我们的第一次迭代。在我们开始第二个之前，这是更新 docstring 并将代码提交给我们的版本控制系统的好时机。</p><h2 id="0253" class="ng lv jj bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated">重复</h2><p id="12b7" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们的下一步取决于业务优先级。在这种情况下，随机化将是不可接受的，因此我们需要集成一段能够加载训练模型并将其应用于所提供的数据集的代码。我把这个练习留给思考什么是有效的和无效的输入，以及这样一个模块需要传递给你什么。</p><h1 id="3431" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">外卖</h1><p id="fbbf" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这个工作流和场景被简化了。然而，每个案例都有其自身的复杂之处，这一微不足道的观察不能成为使一切复杂化的理由。相反，在构建下一个组件时，只有四个问题:</p><ol class=""><li id="504b" class="mr ms jj la b lb lc le lf lh mt ll mu lp mv lt nf mx my mz bi translated">我期望的输入是什么？</li><li id="9b0c" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">如何处理无效或不完整的输入？</li><li id="094d" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">从结构的角度来看，我希望输出是什么样的？</li><li id="5d0d" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">从功能角度来看，我希望我的输出达到什么目的？</li></ol><p id="29f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">诚然，回答这些问题会让人觉得很烦。我认为主要有两个原因:</p><ol class=""><li id="1814" class="mr ms jj la b lb lc le lf lh mt ll mu lp mv lt nf mx my mz bi translated">这些问题出奇的难。很好。你意识到你不确定你想要实现什么。现在比 1000 行额外的代码要好。</li><li id="3aaa" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">感觉又慢又啰嗦，尤其是截止日期临近的时候。如果你不在乎你要去哪里，感觉很快会更容易。然而，在压力下，方向感不清晰是最糟糕的。</li></ol><p id="2f47" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于测试本身的更多例子和更多细节，请参阅我的上一篇博文和其中包含的参考资料:</p><div class="is it gp gr iu nz"><a rel="noopener follow" target="_blank" href="/tdd-datascience-689c98492fcc"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jk gy z fp oe fr fs of fu fw ji bi translated">如何在数据科学工作流程中使用测试驱动开发</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">数据科学家和机器学习工程师应该向软件开发人员学习的另一件事</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ja nz"/></div></div></a></div></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="6410" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这篇文章对你有所帮助或者你想补充什么，请在评论中或者在 Twitter 上告诉我。我也很乐意在 LinkedIn 上联系。<strong class="la jk">感谢阅读！</strong></p></div></div>    
</body>
</html>