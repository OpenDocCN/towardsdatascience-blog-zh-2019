<html>
<head>
<title>K-Fold Cross Validation Example Using Sklearn Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Sklearn Python 的 K-Fold 交叉验证示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-algorithms-part-14-cross-validation-and-ridge-regression-example-in-python-2d9e0c4de875?source=collection_archive---------10-----------------------#2019-05-03">https://towardsdatascience.com/machine-learning-algorithms-part-14-cross-validation-and-ridge-regression-example-in-python-2d9e0c4de875?source=collection_archive---------10-----------------------#2019-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/82b11e817ee52ca48dc3626decf2faf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5hp0eKkyaiO-3EfO"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@goumbik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lukas Blazek</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="2074" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终，机器学习模型被用来对我们还没有答案的数据进行预测。例如，这可以采取推荐系统的形式，试图预测用户是否会喜欢这首歌或产品。</p><p id="c14f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发模型时，我们必须非常小心，不要过度适应我们的训练数据。换句话说，我们必须确保模型捕捉到了潜在的模式，而不是简单地记忆数据。因此，在生产中使用模型之前，我们必须检查它如何处理不可预见的数据。这通常是通过将数据分成两个子集来完成的，一个子集用于训练，另一个子集用于测试模型的准确性。</p><p id="af07" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">某些机器学习算法依赖于超参数。本质上，超参数是一个由用户设置的变量，它决定了算法的行为方式。超参数的一些例子是梯度下降中的步长和岭回归中的α。当涉及到超参数时，没有放之四海而皆准的方法。数据科学家必须通过反复试验来确定最佳超参数值。我们称这个过程为<strong class="ki jk">超参数调谐。</strong></p><p id="fb23" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，如果我们不断地使用测试集来衡量我们的模型对于不同超参数值的性能，我们的模型将会对测试集中的数据产生亲和力。换句话说，关于测试集的知识可能会泄漏到模型中，并且评估度量不再反映一般的性能。</p><p id="db1f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们可以进一步分解数据(即验证、训练和测试集)。训练在训练集上进行，之后在验证集上进行评估，当我们对结果满意时，可以在测试集上执行最终评估。</p><p id="6d2a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，通过将可用数据分成三组，我们大大减少了可用于训练模型的样本数量。此外，结果可能取决于对样本的特定随机选择。例如，假设我们建立了一个模型，试图对手写数字进行分类，我们可能会得到这样一个场景，其中我们的训练集包含非常少的数字 7 的样本。</p><p id="c990" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决这些问题的方法是一种叫做交叉验证的程序。在交叉验证中，测试集仍然被放在一边进行最终评估，但是不再需要验证集。交叉验证有多种，最常见的叫做<em class="le"> k 倍</em>交叉验证。在<em class="le"> k-fold </em>交叉验证中，训练集被分割成<em class="le"> k </em>个更小的集合(或折叠)。然后，使用褶皱的<em class="le"> k-1 </em>训练模型，最后一个褶皱用作验证集，以计算精度等性能指标。</p><figure class="lg lh li lj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lf"><img src="../Images/5f86ee14c79951a8991858ff0747fded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ARXxmIQPojHCfzZ-.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://scikit-learn.org/stable/_images/grid_search_cross_validation.png" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/_images/grid_search_cross_validation.png</a></figcaption></figure><p id="efab" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子。对于前面的示例，我们将使用波士顿房价数据集。</p><figure class="lg lh li lj gt iv gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/81f4af5da1b795452cab6d279f731506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*OEPlxL8cUdu-hYw3ms21kQ.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_boston.html" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_boston.html</a></figcaption></figure><p id="5894" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，导入所有必需的库。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="1bae" class="lq lr jj lm b gy ls lt l lu lv">from sklearn.datasets import load_boston<br/>from sklearn.linear_model import RidgeCV<br/>from sklearn.model_selection import train_test_split<br/>import numpy as np<br/>import pandas as pd<br/>from matplotlib import pyplot as plt</span></pre><p id="7c7f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将使用 sklearn 为我们的数据导入特征和标签。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="6d85" class="lq lr jj lm b gy ls lt l lu lv">boston = load_boston()</span><span id="42c8" class="lq lr jj lm b gy lw lt l lu lv">boston_features = pd.DataFrame(boston.data, columns=boston.feature_names)</span><span id="8f78" class="lq lr jj lm b gy lw lt l lu lv">X = boston_features['RM'].values.reshape(-1,1)</span><span id="04c0" class="lq lr jj lm b gy lw lt l lu lv">y = boston.target</span></pre><p id="d265" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用 matplotlib 来绘制房价和每个住宅的平均房间数之间的关系。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="66cf" class="lq lr jj lm b gy ls lt l lu lv">plt.scatter(X, y);<br/>plt.title('boston house prices')<br/>plt.xlabel('average number of rooms per dwelling')<br/>plt.ylabel('house prices')<br/>plt.show()</span></pre><figure class="lg lh li lj gt iv gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/3831e6a08be669df6bd4e84f681e536e.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*A2f0PhpqpJ5Nm1NifNKV0w.png"/></div></figure><p id="a36c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，我们希望将一部分数据留到最后评估时使用。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="66da" class="lq lr jj lm b gy ls lt l lu lv">train_X, test_X, train_y, test_y = train_test_split(X, y, test_size=0.2, random_state=0)</span></pre><p id="29e0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用交叉验证来确定最佳 alpha 值。默认情况下，岭回归交叉验证类使用<em class="le">留一个</em>策略(k-fold)。我们可以通过观察均方误差来比较我们的模型在不同 alpha 值下的性能。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="a19f" class="lq lr jj lm b gy ls lt l lu lv">regressor = RidgeCV(alphas=[1, 1e3, 1e6], store_cv_values=True)</span><span id="2d98" class="lq lr jj lm b gy lw lt l lu lv">regressor.fit(train_X, train_y)</span><span id="8b4f" class="lq lr jj lm b gy lw lt l lu lv">cv_mse = np.mean(regressor.cv_values_, axis=0)</span><span id="78aa" class="lq lr jj lm b gy lw lt l lu lv">print(alphas)<br/>print(cv_mse)</span></pre><figure class="lg lh li lj gt iv gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/2669fbbcd4cf7f54d66f81efbe79848d.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*JhHzTcj7s9clMKri9S3HUQ.png"/></div></figure><p id="755d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RidgeCV 类将自动选择最佳 alpha 值。我们可以通过访问以下属性来查看它。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="0bad" class="lq lr jj lm b gy ls lt l lu lv"># Best alpha<br/>print(regressor.alpha_)</span></pre><p id="8eb1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用该模型来预测测试集的房价。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="5a58" class="lq lr jj lm b gy ls lt l lu lv">predict_y = regressor.predict(test_X)</span></pre><p id="90f1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们绘制测试集中的数据和在训练阶段确定的线。</p><pre class="lg lh li lj gt ll lm ln lo aw lp bi"><span id="4e96" class="lq lr jj lm b gy ls lt l lu lv">plt.scatter(test_X, test_y);<br/>plt.plot(test_X, predict_y, color='red')<br/>plt.title('boston house prices')<br/>plt.xlabel('average number of rooms per dwelling')<br/>plt.ylabel('house prices')<br/>plt.show()</span></pre><figure class="lg lh li lj gt iv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/313fb4b6b054c32a038aec34a220cb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*Cjx-zVcovO63sUPwei4mKQ.png"/></div></figure></div></div>    
</body>
</html>