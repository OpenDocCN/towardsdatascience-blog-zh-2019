<html>
<head>
<title>A primer on *args, **kwargs, decorators for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">*args，**kwargs 的初级读本，数据科学家的装饰者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-primer-on-args-kwargs-decorators-for-data-scientists-bb8129e756a7?source=collection_archive---------14-----------------------#2019-05-12">https://towardsdatascience.com/a-primer-on-args-kwargs-decorators-for-data-scientists-bb8129e756a7?source=collection_archive---------14-----------------------#2019-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7938" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/python-shorts" rel="noopener" target="_blank">蟒蛇短裤</a></h2><div class=""/><div class=""><h2 id="ae8b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">对于编码来说，理解是至关重要的</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c4e5512be7d4a2b4b674d41953a0d4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rUaHclQUJG-XK1p_"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@almosbech?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Almos Bechtold</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d9f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://amzn.to/2XPSiiG" rel="noopener ugc nofollow" target="_blank"> Python </a>有很多构造，在我们的代码中学习和使用起来相当容易。当我们在代码中遇到一些构造时，它们总是让我们感到困惑。</p><p id="3069" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一些甚至是经验丰富的程序员也无法理解的。装饰者就是属于这一类的一些构造。</p><p id="ef2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我猜我的许多数据科学朋友也面临过这些问题。</p><p id="5bad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数 seaborn 函数都以某种方式使用*args 和**kwargs。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mi"><img src="../Images/42a20b27a3e1423e06b5d4039863d65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Whm1f2Mytp0Qve5TQAflGw.png"/></div></div></figure><p id="15c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者装修工呢？</p><p id="2ba8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每次你看到一个警告，像一些功能将在下一个版本中被否决。<code class="fe me mf mg mh b">sklearn</code>包为此使用了装饰器。你可以在源代码中看到<code class="fe me mf mg mh b">@deprecated</code>。这是一个装饰函数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mj"><img src="../Images/d8d50a0f659760860c0d84d3ef2203a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrFQQlXzBC0GwTzdUC9Row.png"/></div></div></figure><p id="e61a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个名为<strong class="lk jd">'</strong><a class="ae lh" href="https://towardsdatascience.com/tagged/python-shorts" rel="noopener" target="_blank"><strong class="lk jd">Python Shorts</strong></a><strong class="lk jd">，‘</strong>的系列帖子中，我将解释 Python 提供的一些简单构造，一些基本技巧和我在数据科学工作中经常遇到的一些用例。</p><p id="d861" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章是关于用一种简单易懂的方式解释一些难懂的概念。T25】</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1506" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">什么是*args？</h1><p id="0eaf" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">简单来说，<strong class="lk jd"> <em class="mk">你可以用</em> </strong> <code class="fe me mf mg mh b"><strong class="lk jd"><em class="mk">*args</em></strong></code> <strong class="lk jd"> <em class="mk">给你的函数任意数量的输入。</em> </strong></p><h2 id="44d2" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">一个简单的例子:</h2><p id="07e2" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">假设我们必须创建一个将两个数相加的函数。在 python 中我们可以很容易地做到这一点。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="3600" class="np mt it mh b gy oe of l og oh">def adder(x,y):<br/>    return x+y</span></pre><p id="18cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想创建一个函数来添加三个变量呢？</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="7c7b" class="np mt it mh b gy oe of l og oh">def adder(x,y,z):<br/>    return x+y+z</span></pre><p id="f06a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想让同一个函数加上未知数量的变量呢？请注意，我们可以使用<code class="fe me mf mg mh b">*args</code>或<code class="fe me mf mg mh b">*argv</code>或<code class="fe me mf mg mh b">*anyOtherName</code>来完成此操作。重要的是<code class="fe me mf mg mh b">*</code>。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="fc2f" class="np mt it mh b gy oe of l og oh">def adder(*args):<br/>    result = 0<br/>    for arg in args:<br/>        result+=arg<br/>    return result</span></pre><p id="f094" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">*args</code>所做的是，它接受你传递的所有参数，并向函数提供一个可变长度的参数列表，你可以随意使用。</p><p id="ae71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，您可以使用如下相同的函数:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="809e" class="np mt it mh b gy oe of l og oh">adder(1,2)<br/>adder(1,2,3)<br/>adder(1,2,5,7,8,9,100)</span></pre><p id="7152" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">诸如此类。</p><p id="87d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="mk">现在，你有没有想过 python 中的 print 函数怎么可以带这么多参数？</em></strong>T9】</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5c56" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">什么是**kwargs <code class="fe me mf mg mh b">?</code></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mi"><img src="../Images/42a20b27a3e1423e06b5d4039863d65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Whm1f2Mytp0Qve5TQAflGw.png"/></div></div></figure><p id="eb1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说，<strong class="lk jd"> <em class="mk"> </em>你可以使用</strong> <code class="fe me mf mg mh b"><strong class="lk jd">**kwargs</strong></code> <strong class="lk jd">给你的函数任意数量的<em class="mk">关键字输入</em>，并使用字典访问它们。</strong></p><h2 id="42e6" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">一个简单的例子:</h2><p id="73ec" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">假设您想要创建一个打印函数，它可以将姓名和年龄作为输入并打印出来。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="b390" class="np mt it mh b gy oe of l og oh">def myprint(name,age):<br/>    print(f'{name} is {age} years old')</span></pre><p id="906b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单。现在让我们说，你希望同一个函数有两个名字和两个年龄。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="e3ca" class="np mt it mh b gy oe of l og oh">def myprint(name1,age1,name2,age2):<br/>    print(f'{name1} is {age1} years old')<br/>    print(f'{name2} is {age2} years old')</span></pre><p id="ba6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你猜对了我的下一个问题是:<strong class="lk jd"> <em class="mk">如果我不知道我将需要多少个参数呢？</em>T25】</strong></p><p id="1740" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我能用<code class="fe me mf mg mh b">*args</code>吗？猜不到，因为姓名和年龄顺序至关重要。我们不想写“28 岁是迈克尔的年龄”。</p><p id="f521" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来图中的<code class="fe me mf mg mh b">**kwargs </code>。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="26f2" class="np mt it mh b gy oe of l og oh">def myprint(**kwargs):<br/>    for k,v in kwargs.items():<br/>        print(f'{k} is {v} years old')</span></pre><p id="1251" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用以下方式调用此函数:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="63ca" class="np mt it mh b gy oe of l og oh">myprint(Sansa=20,Tyrion=40,Arya=17)</span><span id="6b13" class="np mt it mh b gy oi of l og oh">Output:<br/>-----------------------------------<br/>Sansa is 20 years old<br/>Tyrion is 40 years old<br/>Arya is 17 years old</span></pre><p id="93bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，我们从未将珊莎、艾莉亚或提利昂定义为我们的方法参数。T29】</p><p id="af43" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个非常强大的概念。许多程序员在编写包装器库时非常巧妙地利用了这一点。</p><p id="2381" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，<code class="fe me mf mg mh b">seaborn.scatterplot</code>函数包装了 Matplotlib 中的<code class="fe me mf mg mh b">plt.scatter</code>函数。本质上，使用<code class="fe me mf mg mh b">*args</code>和<code class="fe me mf mg mh b">**kwargs</code>，我们也可以提供<code class="fe me mf mg mh b">plt.scatter</code>可以带给<code class="fe me mf mg mh b">seaborn.Scatterplot</code>的所有参数。</p><p id="45d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以节省大量的编码工作，并且使代码经得起未来的考验。如果在将来的任何时候<code class="fe me mf mg mh b">plt.scatter</code>开始接受任何新的参数，<code class="fe me mf mg mh b">seaborn.Scatterplot</code>函数仍然会工作。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="38c7" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">什么是装修工？</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/86e8f16b2812cf4f9ebf266502c43ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0myD6Op8BQjB9pz0"/></div></div></figure><p id="a5fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说:<strong class="lk jd"> <em class="mk">装饰器是包装另一个函数从而修改其行为的函数。</em> </strong></p><h2 id="855c" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">一个简单的例子:</h2><p id="26b1" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">假设我们想在我们的一些功能中添加自定义功能。其功能是，每当调用函数时，打印“<code class="fe me mf mg mh b">function name</code>开始”，每当函数结束时，打印“<code class="fe me mf mg mh b">function name</code>结束”和函数花费的时间。</p><p id="0e31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们假设我们的函数是:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="bb52" class="np mt it mh b gy oe of l og oh">def somefunc(a,b):<br/>    output = a+b<br/>    return output</span></pre><p id="4cd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在所有函数中添加一些打印行来实现这一点。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="2cfe" class="np mt it mh b gy oe of l og oh">import time<br/>def somefunc(a,b):<br/>    print("somefunc begins")<br/>    start_time = time.time()<br/>    output = a+b<br/>    print("somefunc ends in ",time.time()-start_time, "secs")<br/>    return output</span><span id="145e" class="np mt it mh b gy oi of l og oh">out = somefunc(4,5)</span><span id="24d1" class="np mt it mh b gy oi of l og oh">OUTPUT:<br/>-------------------------------------------<br/>somefunc begins<br/>somefunc ends in  9.5367431640625e-07 secs</span></pre><p id="4410" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="mk">但是，我们能做得更好吗？</em>T41】</strong></p><p id="0ade" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是装修工擅长的地方。我们可以使用 decorators 来包装任何函数。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="07df" class="np mt it mh b gy oe of l og oh">from functools import wraps<br/>def timer(func):<br/>    <a class="ae lh" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrapper(a,b):<br/>        print(f"{func.__name__!r} begins")<br/>        start_time = time.time()<br/>        result = func(a,b)<br/>        print(f"{func.__name__!r} ends in {time.time()-start_time}  secs")<br/>        return result<br/>    return wrapper</span></pre><p id="164d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我们如何定义任何装饰者。<code class="fe me mf mg mh b">functools</code>帮助我们使用<code class="fe me mf mg mh b">wraps</code>创建装饰者。本质上，在上面的装饰器中，我们在任何函数被调用之前做一些事情，在函数被调用之后做一些事情。</p><p id="4fa6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以使用这个<code class="fe me mf mg mh b">timer</code>装饰器来装饰我们的函数<code class="fe me mf mg mh b">somefunc</code></p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="2691" class="np mt it mh b gy oe of l og oh"><a class="ae lh" href="http://twitter.com/decorator_func" rel="noopener ugc nofollow" target="_blank">@t</a>imer<br/>def somefunc(a,b):<br/>    output = a+b<br/>    return output</span></pre><p id="9bdf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在调用这个函数，我们得到:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="ccd6" class="np mt it mh b gy oe of l og oh">a = somefunc(4,5)</span><span id="3a1a" class="np mt it mh b gy oi of l og oh">Output<br/>---------------------------------------------<br/>'somefunc' begins<br/>'somefunc' ends in 2.86102294921875e-06  secs</span></pre><p id="f45b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可以将<code class="fe me mf mg mh b">@timer</code>添加到我们想要打印时间的每个函数中。我们结束了。</p><p id="c398" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">真的吗？</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="fe98" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">连接所有的部分</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/fb4bd632f715839b5572fe4ad9364dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4xLT23sxQ_Yq_PWq"/></div></div></figure><p id="30cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们的函数有三个参数呢？还是很多论据？ </p><p id="b801" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我们到目前为止所学到的东西的联系。我们使用<code class="fe me mf mg mh b">*args</code>和<code class="fe me mf mg mh b">**kwargs</code></p><p id="64aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将装饰函数更改为:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="1de8" class="np mt it mh b gy oe of l og oh">from functools import wraps<br/>def timer(func):<br/>    <a class="ae lh" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrapper(*args,**kwargs):<br/>        print(f"{func.__name__!r} begins")<br/>        start_time = time.time()<br/>        result = func(*args,**kwargs)<br/>        print(f"{func.__name__!r} ends in {time.time()-start_time}  secs")<br/>        return result<br/>    return wrapper</span></pre><p id="e093" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们的函数可以接受任意数量的参数，我们的装饰器仍然可以工作。</p><blockquote class="ol"><p id="f24b" class="om on it bd oo op oq or os ot ou md dk translated">Python 是不是很好看？</p></blockquote><p id="c968" class="pw-post-body-paragraph li lj it lk b ll ov kd ln lo ow kg lq lr ox lt lu lv oy lx ly lz oz mb mc md im bi translated">在我看来，装修工可能会很有帮助。我只提供了装饰者的一个用例，但是有几种方法可以使用它们。</p><p id="84b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用装饰器通过检查函数中的参数来调试代码。或者可以使用装饰器来计算特定函数被调用的次数。这可能有助于计算递归调用。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c661" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">结论</h1><p id="471d" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在这篇文章中，我谈到了一些你可以在<a class="ae lh" href="https://amzn.to/2XPSiiG" rel="noopener ugc nofollow" target="_blank"> python </a>源代码中找到的结构，以及你如何理解它们。</p><p id="045f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有必要现在就在代码中使用它们。但是我想理解这些东西是如何工作的有助于减轻每当这些结构出现时人们所面临的困惑和恐慌。</p><blockquote class="ol"><p id="d582" class="om on it bd oo op oq or os ot ou md dk translated">对于编码来说，理解是至关重要的</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="670f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，如果你想了解更多关于 Python 3 的知识，我想向你推荐密歇根大学的一门优秀的中级 Python 课程。一定要去看看。</p><p id="29c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将来我也会写更多初学者友好的帖子。让我知道你对这个系列的看法。在<a class="ae lh" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="lk jd">媒体</strong> </a>关注我或者订阅我的<a class="ae lh" href="http://eepurl.com/dbQnuX" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae lh" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p></div></div>    
</body>
</html>