<html>
<head>
<title>Writing tests for the Albumentations library with pytest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 pytest 为白蛋白库编写测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-test-for-the-image-augmentation-albumentation-library-a73d7bc1caa7?source=collection_archive---------26-----------------------#2019-08-06">https://towardsdatascience.com/writing-test-for-the-image-augmentation-albumentation-library-a73d7bc1caa7?source=collection_archive---------26-----------------------#2019-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1850a29ae32fcbfc239d63802c3205ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qy2FZj_dLacj23kNDW_TSQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://github.com/albu/albumentations" rel="noopener ugc nofollow" target="_blank">https://github.com/albu/albumentations</a></figcaption></figure><p id="212c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的名字是弗拉基米尔·伊格洛维科夫。我是 Lyft 的高级计算机视觉工程师，Level5，将深度学习应用于自动驾驶汽车的问题。</p><p id="3296" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也是<a class="ae kc" href="https://www.kaggle.com/iglovikov" rel="noopener ugc nofollow" target="_blank"> Kaggle 特级大师</a>和图像增强库<a class="ae kc" href="https://github.com/albu/albumentations" rel="noopener ugc nofollow" target="_blank">相册</a>的作者之一。这个库是从 Kaggle Masters 的一系列计算机视觉竞赛的获奖解决方案中脱颖而出的:<a class="ae kc" href="https://www.linkedin.com/in/al-buslaev/" rel="noopener ugc nofollow" target="_blank"> Alexander Buslaev </a>、<a class="ae kc" href="https://www.linkedin.com/in/alex-parinov/" rel="noopener ugc nofollow" target="_blank"> Alex Parinov </a>、<a class="ae kc" href="https://www.linkedin.com/in/cvtalks/" rel="noopener ugc nofollow" target="_blank"> Eugene Khvedchenya </a>和我。</p><p id="ede9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大约一年前，我们发布了该库的 alpha 版本。从那以后，它被工业、学术界的机器学习工程师和研究人员采用，当然也被竞争激烈的机器学习社区采用。在过去的八个月中，Kaggle 计算机视觉挑战赛中的所有或几乎所有顶级解决方案都使用了我们的图书馆。</p><p id="22e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某个时候，Alex Parinov 写了一篇关于单元测试的<a class="ae kc" href="https://albumentations.readthedocs.io/en/latest/writing_tests.html" rel="noopener ugc nofollow" target="_blank">文本</a>，以及我们如何使用它们来检查我们实现的 60 多个不同的转换。目前，我们需要通过 4470 个单元测试，才能合并每个拉取请求。问题是如何编写这些测试来增加覆盖率并减少重复代码的数量。</p><p id="9441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那篇文章中，Alex 向读者展示了一组例子，解释了如何编写测试。他从一个简单的用例开始，然后是更高级的夹具和参数化。</p><p id="dfcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为该文档没有得到数据科学界的足够重视。因此，我把它复制到这个平台上，对原文做了一些修改。</p><p id="6574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将假设读者熟悉这个库。如果没有，您可以查看一套 Jupiter 笔记本，其中涵盖了不同计算机视觉任务的应用:</p><ul class=""><li id="8692" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/showcase.ipynb" rel="noopener ugc nofollow" target="_blank">展柜</a></li><li id="3dfe" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/showcase.ipynb" rel="noopener ugc nofollow" target="_blank">分类</a></li><li id="5dd9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_bboxes.ipynb" rel="noopener ugc nofollow" target="_blank">物体检测</a></li><li id="3c2f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_kaggle_salt.ipynb" rel="noopener ugc nofollow" target="_blank">分割</a></li><li id="7258" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_16_bit_tiff.ipynb" rel="noopener ugc nofollow" target="_blank">非 8 位图像</a></li><li id="dcd6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_kaggle_salt.ipynb" rel="noopener ugc nofollow" target="_blank">分割</a></li><li id="af4a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_keypoints.ipynb" rel="noopener ugc nofollow" target="_blank">要点</a></li><li id="c8d7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_multi_target.ipynb" rel="noopener ugc nofollow" target="_blank">自定义目标</a></li><li id="35db" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/example_weather_transforms.ipynb" rel="noopener ugc nofollow" target="_blank">天气变化</a></li><li id="3440" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/albu/albumentations/blob/master/notebooks/serialization.ipynb" rel="noopener ugc nofollow" target="_blank">连载</a></li></ul><h1 id="d2ff" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">写作测试</h1><h2 id="2344" class="mn lq iq bd lr mo mp dn lv mq mr dp lz ko ms mt md ks mu mv mh kw mw mx ml my bi translated">第一次测试</h2><p id="6c54" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们使用<strong class="kf ir"> pytest </strong>来运行<a class="ae kc" href="https://github.com/albu/albumentations" rel="noopener ugc nofollow" target="_blank">白蛋白</a>的测试。包含测试的 python 文件应该放在<code class="fe ne nf ng nh b">albumentations/test</code>文件夹中。文件名应该以<code class="fe ne nf ng nh b">test_</code>开头。例如，<code class="fe ne nf ng nh b">test_bbox.py</code>。测试函数的名称也应该以<code class="fe ne nf ng nh b">test_</code>开头。例如<code class="fe ne nf ng nh b">def test_random_brightness()</code></p><p id="7ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们要测试<code class="fe ne nf ng nh b">brightness_contrast_adjust</code>函数。该函数将 NumPy 数组作为输入，将所有值乘以指定的参数<code class="fe ne nf ng nh b">alpha</code>并返回结果数组。</p><p id="93ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为这个函数编写第一个测试。测试将检查如果您向函数传递一个所有值都等于<code class="fe ne nf ng nh b">128</code>且参数<code class="fe ne nf ng nh b">alpha</code>等于<code class="fe ne nf ng nh b">1.5</code>的数组，该函数将产生所有值都等于<code class="fe ne nf ng nh b">192</code>的数组。<code class="fe ne nf ng nh b">(128 * 1.5 = 192)</code></p><p id="a52d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在文件夹<code class="fe ne nf ng nh b">albumentations/test</code>中，我们创建一个新文件<code class="fe ne nf ng nh b">test_sample.py</code></p><p id="6ff9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在文件的顶部，我们添加了所有必需的导入:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="5842" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">import numpy as np</strong></span><span id="29f9" class="mn lq iq nh b gy nu nr l ns nt"><strong class="nh ir">import albumentations.augmentations.functional as F</strong></span></pre><p id="48ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试本身:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="3ae9" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_random_contrast():<br/>    img = np.ones((100, 100, 3), dtype=np.uint8) * 128<br/>    img = F.brightness_contrast_adjust(img, alpha=1.5)<br/>    expected_multiplier = 192<br/>    expected = np.ones((100, 100, 3), dtype=np.uint8) * expected_multiplier<br/>    <strong class="nh ir">assert</strong> np.array_equal(img, expected)</span></pre><p id="ec87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了运行来自<code class="fe ne nf ng nh b">test_example.py</code>的测试，此时它只包含一个测试，我们执行以下命令:</p><p id="222b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">pytest tests/test_example.py -v .</code></p><p id="0bf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">-v</code>标志告诉<strong class="kf ir"> pytest </strong>产生更详细的输出。</p><p id="e51f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> pytest </strong>将显示测试已成功完成:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ae63" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_random_brightness PASSED</span></pre><h1 id="e3d3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">测试参数化和@ pytest . mark . parameter ize 装饰器</h1><p id="ab39" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">上例中的函数很简单，它没有考虑到 8 位图像不能包含超过 255 =(2⁸-1)的值。</p><p id="3868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们希望函数<code class="fe ne nf ng nh b">brightness_contrast_adjust</code>来处理这个问题，并截取超出[0，255]范围的值。</p><p id="281c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们写一个测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="8260" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_random_contrast_2():<br/>    img = np.ones((100, 100, 3), dtype=np.uint8) * 128<br/>    img = F.brightness_contrast_adjust(img, alpha=3)</span><span id="0b7d" class="mn lq iq nh b gy nu nr l ns nt">expected_multiplier = 255<br/>    expected = np.ones((100, 100, 3), dtype=np.uint8) * expected_multiplier<br/>    <strong class="nh ir">assert</strong> np.array_equal(img, expected)</span></pre><p id="44f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将从<code class="fe ne nf ng nh b">test_example.py</code>开始运行测试:</p><p id="1681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">pytest tests/test_example.py -v</code></p><p id="68b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="9dbe" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_random_brightness PASSED<br/>tests/test_example.py::test_random_brightness_2 PASSED</span></pre><p id="4ec4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">功能<code class="fe ne nf ng nh b">test_random_brightness</code>和<code class="fe ne nf ng nh b">test_random_brightness_2</code>看起来几乎一样。唯一不同的是<code class="fe ne nf ng nh b">alpha</code>和<code class="fe ne nf ng nh b">expected_multiplier</code>的值。为了消除代码重复，我们可以使用<code class="fe ne nf ng nh b">@pytest.mark.parametrize</code>装饰器。有了这个装饰器，我们可以描述哪些值应该作为参数传递给测试，<strong class="kf ir"> pytest </strong>将多次运行测试，每次都从装饰器传递下一个值。</p><p id="72b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用参数化将之前的两个测试重写为一个测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d9c3" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">import</strong> <strong class="nh ir">pytest</strong></span><span id="7e82" class="mn lq iq nh b gy nu nr l ns nt"><strong class="nh ir">@pytest.mark.parametrize</strong>(['alpha', 'expected_multiplier'], [(1.5, 192), (3, 255)])<br/><strong class="nh ir">def</strong> test_random_brightness(alpha, expected_multiplier):<br/>    img = np.ones((100, 100, 3), dtype=np.uint8) * 128<br/>    img = F.brightness_contrast_adjust(img, alpha=alpha)<br/>    expected = np.ones((100, 100, 3), dtype=np.uint8) * expected_multiplier<br/>    <strong class="nh ir">assert</strong> np.array_equal(img, expected)</span></pre><p id="bcc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该测试将运行两次，在第一次运行中，<code class="fe ne nf ng nh b">alpha</code>将等于<code class="fe ne nf ng nh b">1.5</code>，而<code class="fe ne nf ng nh b">expected_multiplier</code>将等于<code class="fe ne nf ng nh b">192</code>。在第二次运行中，<code class="fe ne nf ng nh b">alpha</code>将等于<code class="fe ne nf ng nh b">3</code>，而<code class="fe ne nf ng nh b">expected_multiplier</code>将等于<code class="fe ne nf ng nh b">255</code>。</p><p id="126a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进行测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="19a7" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_random_brightness[1.5-192] PASSED<br/>tests/test_example.py::test_random_brightness[3-255] PASSED</span></pre><p id="2140" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，<strong class="kf ir"> pytest </strong>在每次运行时打印测试参数值。</p><h1 id="d250" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用辅助函数简化对图像和遮罩都有效的函数的测试</h1><p id="60a4" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设我们想要测试<code class="fe ne nf ng nh b">vflip</code>函数。此函数垂直翻转作为输入传递的图像或遮罩。面具的形状是<code class="fe ne nf ng nh b">(height, width)</code>。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f86a" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_vflip_mask():<br/>    mask = np.array(<br/>        [[1, 1, 1],<br/>         [0, 1, 1],<br/>         [0, 0, 1]], dtype=np.uint8)<br/>    expected_mask = np.array(<br/>        [[0, 0, 1],<br/>         [0, 1, 1],<br/>         [1, 1, 1]], dtype=np.uint8)<br/>    flipped_mask = F.vflip(mask)<br/>    <strong class="nh ir">assert</strong> np.array_equal(flipped_mask, expected_mask)</span></pre><p id="bba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试的结果:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="27eb" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_vflip_mask PASSED</span></pre><p id="a95b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步，我们将测试相同的函数如何处理 RGB 图像，RGB 图像是具有形状<code class="fe ne nf ng nh b">(height, width, 3)</code>的三维 NumPy 数组。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="4564" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_vflip_img():<br/>    img = np.array(<br/>        [[[1, 1, 1],<br/>          [1, 1, 1],<br/>          [1, 1, 1]],<br/>         [[0, 0, 0],<br/>          [1, 1, 1],<br/>          [1, 1, 1]],<br/>         [[0, 0, 0],<br/>          [0, 0, 0],<br/>          [1, 1, 1]]], dtype=np.uint8)<br/>    expected_img = np.array(<br/>        [[[0, 0, 0],<br/>          [0, 0, 0],<br/>          [1, 1, 1]],<br/>         [[0, 0, 0],<br/>          [1, 1, 1],<br/>          [1, 1, 1]],<br/>         [[1, 1, 1],<br/>          [1, 1, 1],<br/>          [1, 1, 1]]], dtype=np.uint8)<br/>    flipped_img = F.vflip(img)<br/>    <strong class="nh ir">assert</strong> np.array_equal(flipped_img, expected_img)</span></pre><p id="1f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个测试中，<code class="fe ne nf ng nh b">img</code>的值与分配给<code class="fe ne nf ng nh b">test_vflip_mask</code>中的<code class="fe ne nf ng nh b">mask</code>变量的 NumPy 数组相同，但是这次它重复了三次(三个通道各一次)。<code class="fe ne nf ng nh b">expected_img</code>也是一个重复三次的 NumPy 数组，它被分配给<code class="fe ne nf ng nh b">test_vflip_mask</code>函数中的<code class="fe ne nf ng nh b">expected_mask</code>变量。</p><p id="5947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进行测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="8b2f" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_vflip_img PASSED</span></pre><p id="e6b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ne nf ng nh b">test_vflip_img</code>中，我们手动定义了<code class="fe ne nf ng nh b">img</code>和<code class="fe ne nf ng nh b">expected_img</code>的值，分别等于重复三次<code class="fe ne nf ng nh b">mask</code>和<code class="fe ne nf ng nh b">expected_mask</code>的值。</p><p id="2da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免不必要的重复代码，我们可以创建一个 helper 函数，它将一个形状为<code class="fe ne nf ng nh b">(height, width)</code>的 NumPy 数组作为输入，并沿着一个新的轴重复这个值三次，以生成一个形状为<code class="fe ne nf ng nh b">(height, width, 3)</code>的 NumPy 数组:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="46b8" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> convert_2d_to_3d(array, num_channels=3):<br/>    <strong class="nh ir">return</strong> np.repeat(array[:, :, np.newaxis], repeats=num_channels, axis=2)</span></pre><p id="9b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们可以使用该函数将<code class="fe ne nf ng nh b">test_vflip_img</code>重写如下:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="11c3" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_vflip_img_2():<br/>    mask = np.array(<br/>        [[1, 1, 1],<br/>         [0, 1, 1],<br/>         [0, 0, 1]], dtype=np.uint8)<br/>    expected_mask = np.array(<br/>        [[0, 0, 1],<br/>         [0, 1, 1],<br/>         [1, 1, 1]], dtype=np.uint8)<br/>    img = convert_2d_to_3d(mask)<br/>    expected_img = convert_2d_to_3d(expected_mask)<br/>    flipped_img = F.vflip(img)<br/>    <strong class="nh ir">assert</strong> np.array_equal(flipped_img, expected_img)</span></pre><p id="0864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进行测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="6455" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_vflip_img_2 PASSED</span></pre><h1 id="0749" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">通过使用参数化来简化对图像和遮罩都起作用的函数的测试</h1><p id="a36c" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在上一节中，我们为<code class="fe ne nf ng nh b">vflip</code>编写了两个单独的测试。第一个检查了<code class="fe ne nf ng nh b">vflip</code>如何使用蒙版，第二个检查了<code class="fe ne nf ng nh b">vflip</code>如何使用图像。</p><p id="2210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些测试共享大量相同的代码。因此，我们可以将公共部分移动到单个函数中，并使用参数化将关于输入类型的信息作为参数传递给测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="4fe0" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">@pytest.mark.parametrize</strong>('target', ['mask', 'image'])<br/><strong class="nh ir">def</strong> test_vflip_img_and_mask(target):<br/>    img = np.array(<br/>        [[1, 1, 1],<br/>         [0, 1, 1],<br/>         [0, 0, 1]], dtype=np.uint8)<br/>    expected = np.array(<br/>        [[0, 0, 1],<br/>         [0, 1, 1],<br/>         [1, 1, 1]], dtype=np.uint8)<br/>    <strong class="nh ir">if</strong> target == 'image':<br/>        img = convert_2d_to_3d(img)<br/>        expected = convert_2d_to_3d(expected)<br/>    flipped_img = F.vflip(img)<br/>    <strong class="nh ir">assert</strong> np.array_equal(flipped_img, expected)</span></pre><p id="1cea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该测试将运行两次，第一次运行时<code class="fe ne nf ng nh b">target</code>将等于<code class="fe ne nf ng nh b">'mask`</code>。条件<code class="fe ne nf ng nh b">if target == 'image':</code>将不被执行，测试将检查<code class="fe ne nf ng nh b">vflip</code>如何与屏蔽一起工作。在第二次运行中，<code class="fe ne nf ng nh b">target</code>将等于<code class="fe ne nf ng nh b">'image'</code>。将执行条件<code class="fe ne nf ng nh b">if target == 'image':</code>，测试将检查<code class="fe ne nf ng nh b">vflip</code>如何处理图像:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="a5e2" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_vflip_img_and_mask[mask] PASSED<br/>tests/test_example.py::test_vflip_img_and_mask[image] PASSED</span></pre><p id="bc55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将<code class="fe ne nf ng nh b">if target == 'image'</code>下的逻辑移到一个单独的函数中来进一步减少代码量:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d0d8" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> convert_2d_to_target_format(*arrays, target=None):<br/>    <strong class="nh ir">if</strong> target == 'mask':<br/>        <strong class="nh ir">return</strong> arrays[0] <strong class="nh ir">if</strong> len(arrays) == 1 <strong class="nh ir">else</strong> arrays<br/>    <strong class="nh ir">elif</strong> target == 'image':<br/>        <strong class="nh ir">return</strong> tuple(convert_2d_to_3d(array, num_channels=3) <strong class="nh ir">for</strong> array <strong class="nh ir">in</strong> arrays)<br/>    <strong class="nh ir">else</strong>:<br/>        <strong class="nh ir">raise</strong> ValueError('Unknown target {}'.format(target))</span></pre><p id="8f59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数将把形状为<code class="fe ne nf ng nh b">(height, width)</code>的 NumPy 数组作为输入，并根据<code class="fe ne nf ng nh b">target</code>的值，要么原样返回它们，要么将它们转换为形状为<code class="fe ne nf ng nh b">(height, width, 3)</code>的 NumPy 数组。</p><p id="cd39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个助手函数，我们可以如下重写测试:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="6428" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">@pytest.mark.parametrize</strong>('target', ['mask', 'image'])<br/><strong class="nh ir">def</strong> test_vflip_img_and_mask(target):<br/>    img = np.array(<br/>        [[1, 1, 1],<br/>         [0, 1, 1],<br/>         [0, 0, 1]], dtype=np.uint8)<br/>    expected = np.array(<br/>        [[0, 0, 1],<br/>         [0, 1, 1],<br/>         [1, 1, 1]], dtype=np.uint8)<br/>    img, expected = convert_2d_to_target_format(img, expected, target=target)<br/>    flipped_img = F.vflip(img)<br/>    <strong class="nh ir">assert</strong> np.array_equal(flipped_img, expected)</span></pre><p id="fd80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> pytest </strong>输出:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="0fff" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_vflip_img_and_mask[mask] PASSED<br/>tests/test_example.py::test_vflip_img_and_mask[image] PASSED</span></pre><h1 id="c980" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用夹具</h1><p id="1c74" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设我们想测试这样一种情况，我们将一个数据类型为<code class="fe ne nf ng nh b">np.uint8</code>的图像和蒙版传递给<code class="fe ne nf ng nh b">VerticalFlip</code>增强，我们希望它不会改变输入的数据类型，并将产生一个数据类型为<code class="fe ne nf ng nh b">np.uint8</code>的图像和蒙版作为输出。</p><p id="a380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种测试可以写成如下形式:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f161" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">from</strong> <strong class="nh ir">albumentations</strong> <strong class="nh ir">import</strong> VerticalFlip</span><span id="5f9d" class="mn lq iq nh b gy nu nr l ns nt"><strong class="nh ir">def</strong> test_vertical_flip_dtype():<br/>    aug = VerticalFlip(p=1)<br/>    image = np.random.randint(low=0, high=256, size=(100, 100, 3), dtype=np.uint8)<br/>    mask = np.random.randint(low=0, high=2, size=(100, 100), dtype=np.uint8)<br/>    data = aug(image=image, mask=mask)<br/>    <strong class="nh ir">assert</strong> data['image'].dtype == np.uint8<br/>    <strong class="nh ir">assert</strong> data['mask'].dtype == np.uint8</span></pre><p id="1aff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们生成随机图像和随机遮罩，然后将它们作为输入传递给<a class="ae kc" href="https://albumentations.readthedocs.io/en/latest/api/augmentations.html#albumentations.augmentations.transforms.VerticalFlip" rel="noopener ugc nofollow" target="_blank"> VerticalFlip </a>转换，之后，我们检查输出值的数据类型。</p><p id="27d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们希望对其他增强也执行这种检查，我们将不得不编写代码来在每次测试开始时生成随机图像和遮罩:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="52c4" class="mn lq iq nh b gy nq nr l ns nt">image = np.random.randint(low=0, high=256, size=(100, 100, 3), dtype=np.uint8)<br/>mask = np.random.randint(low=0, high=2, size=(100, 100), dtype=np.uint8)</span></pre><p id="8746" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种重复，我们可以将生成随机值的代码移到 fixture 中。夹具的工作原理如下:</p><p id="9aba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ne nf ng nh b">tests/conftest.py</code> e 中，创建用<code class="fe ne nf ng nh b">@pytest.fixture</code>装饰器包装的函数:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="284e" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">@pytest.fixture</strong><br/><strong class="nh ir">def</strong> image():<br/>    <strong class="nh ir">return</strong> np.random.randint(low=0, high=256, size=(100, 100, 3), dtype=np.uint8)</span><span id="56af" class="mn lq iq nh b gy nu nr l ns nt"><strong class="nh ir">@pytest.fixture</strong><br/><strong class="nh ir">def</strong> mask():<br/>    <strong class="nh ir">return</strong> np.random.randint(low=0, high=2, size=(100, 100), dtype=np.uint8)</span></pre><p id="4a08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的测试中，我们使用夹具名称作为可接受的参数:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="e847" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_vertical_flip_dtype(image, mask):<br/>    ...</span></pre><p id="0c90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> pytest </strong>将使用参数的名称来查找具有相同名称的 fixture，然后它将执行这些 fixture 函数，并将输出作为参数传递给测试函数。</p><p id="d033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用夹具重写<code class="fe ne nf ng nh b">test_vertical_flip_dtype</code>，如下所示:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="3d97" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">def</strong> test_vertical_flip_dtype(image, mask):<br/>    aug = VerticalFlip(p=1)<br/>    data = aug(image=image, mask=mask)<br/>    <strong class="nh ir">assert</strong> data['image'].dtype == np.uint8<br/>    <strong class="nh ir">assert</strong> data['mask'].dtype == np.uint8</span></pre><h1 id="6757" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">夹具和参数化的同时使用</h1><p id="9379" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设我们想要检查两个转换是否正确地处理了输入和输出数据类型，例如，<a class="ae kc" href="https://albumentations.readthedocs.io/en/latest/api/augmentations.html#albumentations.augmentations.transforms.VerticalFlip" rel="noopener ugc nofollow" target="_blank"> VerticalFlip </a>和<a class="ae kc" href="https://albumentations.readthedocs.io/en/latest/api/augmentations.html#albumentations.augmentations.transforms.HorizontalFlip" rel="noopener ugc nofollow" target="_blank"> HorizontalFlip </a>。</p><p id="3982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上讲，我们可以为每个转换编写一个单独的测试。我们在上一节为 VerticalFlip 写了一个。现在我们为水平的写几乎相同的:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2388" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">from</strong> <strong class="nh ir">albumentations</strong> <strong class="nh ir">import</strong> HorizontalFlip</span><span id="c09c" class="mn lq iq nh b gy nu nr l ns nt"><strong class="nh ir">def</strong> test_horizontal_flip_dtype(image, mask):<br/>    aug = HorizontalFlip(p=1)<br/>    data = aug(image=image, mask=mask)<br/>    <strong class="nh ir">assert</strong> data['image'].dtype == np.uint8<br/>    <strong class="nh ir">assert</strong> data['mask'].dtype == np.uint8</span></pre><p id="58d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法可行，但我们可以做得更好。在测试中消除不必要的代码复制会很棒。为此，我们可以使用参数化，并将一个类作为参数传递。</p><p id="dafa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查<a class="ae kc" href="https://albumentations.readthedocs.io/en/latest/api/augmentations.html#albumentations.augmentations.transforms.VerticalFlip" rel="noopener ugc nofollow" target="_blank">垂直翻转</a>和<a class="ae kc" href="https://albumentations.readthedocs.io/en/latest/api/augmentations.html#albumentations.augmentations.transforms.HorizontalFlip" rel="noopener ugc nofollow" target="_blank">水平翻转</a>的测试可以写成如下:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="10f2" class="mn lq iq nh b gy nq nr l ns nt"><strong class="nh ir">from</strong> <strong class="nh ir">albumentations</strong> <strong class="nh ir">import</strong> VerticalFlip, HorizontalFlip</span><span id="ff83" class="mn lq iq nh b gy nu nr l ns nt"><strong class="nh ir">@pytest.mark.parametrize</strong>('augmentation_cls', [<br/>    VerticalFlip,<br/>    HorizontalFlip,<br/>])<br/><strong class="nh ir">def</strong> test_multiple_augmentations(augmentation_cls, image, mask):<br/>    aug = augmentation_cls(p=1)<br/>    data = aug(image=image, mask=mask)<br/>    <strong class="nh ir">assert</strong> data['image'].dtype == np.uint8<br/>    <strong class="nh ir">assert</strong> data['mask'].dtype == np.uint8</span></pre><p id="108e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该测试将运行两次。在第一次运行中，<code class="fe ne nf ng nh b">augmentation_cls</code>参数将等于<code class="fe ne nf ng nh b">VerticalFlip</code>。在第二次运行中，<code class="fe ne nf ng nh b">augmentation_cls</code>参数将等于<code class="fe ne nf ng nh b">HorizontalFlip</code>。</p><p id="eecf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> pytest </strong>输出:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="0b2a" class="mn lq iq nh b gy nq nr l ns nt">tests/test_example.py::test_multiple_augmentations[VerticalFlip] PASSED<br/>tests/test_example.py::test_multiple_augmentations[HorizontalFlip] PASSED</span></pre><h1 id="ad62" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="6b95" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">现在，如果您克隆这个库并运行<strong class="kf ir"> pytest，</strong>您将会看到 60 多个转换被 4470 个测试所覆盖。每次合并拉取请求时，它们都应该通过。而且测试的数量还在增长。</p><p id="0812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们添加新的功能或修复在 https://github.com/albu/albumentations/issues<a class="ae kc" href="https://github.com/albu/albumentations/issues" rel="noopener ugc nofollow" target="_blank">报告的问题时，我们会编写新的测试。</a></p><p id="16b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单元测试并不容易涵盖机器学习管道中的所有内容。但是管道的某些部分，那些具有确定性的部分，我们肯定能够也应该涵盖。</p><p id="ddc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遗憾的是，数据科学家低估了机器学习的这一部分，他们更关注过程的炼金术部分，如超参数或网络架构。</p><p id="d0b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望通过这篇博客，我们至少激励了一些数据科学家，他们不会编写测试来实现一些简单的功能来检查一些东西。这可能是养成高质量代码的好习惯的第一步。</p><p id="1c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">附注:所有文字归功于<a class="ae kc" href="https://www.linkedin.com/in/alex-parinov/" rel="noopener ugc nofollow" target="_blank">亚历克斯·帕瑞诺夫</a>。</p></div></div>    
</body>
</html>