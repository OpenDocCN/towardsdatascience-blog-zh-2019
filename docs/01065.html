<html>
<head>
<title>Name Your Favorite Excel Function and I’ll Teach You its Pandas Equivalent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">说出你最喜欢的 Excel 函数，我会教你它的熊猫等价物</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/name-your-favorite-excel-function-and-ill-teach-you-its-pandas-equivalent-7ee4400ada9f?source=collection_archive---------5-----------------------#2019-02-19">https://towardsdatascience.com/name-your-favorite-excel-function-and-ill-teach-you-its-pandas-equivalent-7ee4400ada9f?source=collection_archive---------5-----------------------#2019-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8016" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这篇文章中，我们利用流行的库 Pandas 来编码实现与 Python 的索引/匹配的方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7558ff7153294a905cbda3069a4f182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N7CR3PooKHWbHOM-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以既然还没人起名字，那我就开始了！迄今为止，我最喜欢的 excel 公式之一是嵌套在索引函数中的匹配函数。但是在我教你它的熊猫等价物之前，让我们先了解一下<code class="fe lv lw lx ly b">INDEX/MATCH</code>函数的背景，以及为什么它比<code class="fe lv lw lx ly b">VLOOKUP.</code>函数好</p><p id="b285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">INDEX/MATCH</code>优于<code class="fe lv lw lx ly b">VLOOKUP</code>的两个原因:</p><ol class=""><li id="159d" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">您可以在整个电子表格中搜索值，而不是被迫只搜索最左边的列。(下面有更多相关信息)</li><li id="938c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">对于未排序的数据，计算效率提高了 3%,对于排序的数据和近似匹配，计算效率提高了 30%,对于排序的数据和精确匹配，计算效率提高了 13%!(<a class="ae ky" href="http://www.exceluser.com/formulas/why-index-match-is-better-than-vlookup.htm" rel="noopener ugc nofollow" target="_blank">T17】来源 T19)</a></li></ol><p id="1c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过组合<code class="fe lv lw lx ly b">INDEX/MATCH</code>公式，你可以绕过<code class="fe lv lw lx ly b">VLOOKUP</code>的限制。简而言之，<code class="fe lv lw lx ly b">VLOOKUP</code>扫描给定范围最左边的列，直到它落在给定“search_key”的第一个实例上。然后，它返回所提供的索引中单元格的值，该值将始终位于右侧。但是，正如我上面所说的，使用<code class="fe lv lw lx ly b">INDEX/MATCH</code>您可以搜索整个电子表格(按列或按行)的值，而不是被迫使用<code class="fe lv lw lx ly b">VLOOKUP</code>只搜索最左边的列。</p><p id="02a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个<a class="ae ky" href="https://docs.google.com/spreadsheets/d/1JYLGDtYFLKmfDqZGww00_XL1jcxKUjn2CNnnT2GTHlk/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">月度播客仪表板</strong> </a>吧，这是我在 Vox Media 担任流量分析师时为 Recode 构建的，看看我是如何利用嵌套在<code class="fe lv lw lx ly b">INDEX/MATCH</code>函数中的<code class="fe lv lw lx ly b">SMALL</code>函数来显示剧集级数据的。</p><p id="41fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们进入有趣的部分…如何用熊猫做到这一点！</p><p id="c91d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示利用 Pandas 库用 Python 编写代码的四种方法，但是首先，让我们了解一下我们目标的背景。我们有两个名为<code class="fe lv lw lx ly b">df_1</code>和<code class="fe lv lw lx ly b">df_2</code>的数据帧(如下所示)。</p><div class="kj kk kl km gt ab cb"><figure class="mo kn mp mq mr ms mt paragraph-image"><img src="../Images/f43aa9b9ddb418f288e8994804dd0512.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*tjJ2T2zSx_A7smJi0-dANg.png"/></figure><figure class="mo kn mp mq mr ms mt paragraph-image"><img src="../Images/73595226ef76948714a30bcf0ca5dca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*_GBv3sl0OP5BnfmhNocokg.png"/><figcaption class="ku kv gj gh gi kw kx bd b be z dk mu di mv mw">df_1 (left) and df_2 (right)</figcaption></figure></div><p id="f46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是将<code class="fe lv lw lx ly b">df_2</code>中的<code class="fe lv lw lx ly b">last_name</code>列与<code class="fe lv lw lx ly b">df_1</code>中的正确行进行匹配，得到如下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d1a7fd8a0c57555c234c8a5b7de04d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*do5h13BvpOtbDVh247kf5A.png"/></div></figure><h1 id="e1dd" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">解决方案 1:使用。地图()</h1><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="0ad5" class="nu mz it ly b gy nv nw l nx ny"><strong class="ly iu">code</strong>:<strong class="ly iu"> </strong>df_1[‘last_name’] = df_1.id.map(df_2.set_index(‘id’)[‘last_name’].to_dict())</span><span id="737f" class="nu mz it ly b gy nz nw l nx ny">2.3 ms ± 131 µs per loop</span></pre><p id="0ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们为<code class="fe lv lw lx ly b">df_1</code>创建一个新列<code class="fe lv lw lx ly b">last_name</code>。这个新列的值是通过将来自<code class="fe lv lw lx ly b">df_1</code>的 id 映射到那些 id 匹配的<code class="fe lv lw lx ly b">df_2</code>中的姓氏来创建的。通过对我们的系列<code class="fe lv lw lx ly b">df_2.last_name</code>调用<code class="fe lv lw lx ly b">.to_dict()</code>方法，我们得到了索引的键:值对，这将是:<code class="fe lv lw lx ly b">{0: ‘Snow’, 1: ‘Targaryen’, 2: ‘Tyrell’, 3: ‘Lannister’, 4: ‘Stark’}</code>。在这种情况下，<code class="fe lv lw lx ly b">.map()</code>方法将不起作用，因为我们的<code class="fe lv lw lx ly b">id</code>列中的值与这个字典中的键不匹配。所以我们首先传递了<code class="fe lv lw lx ly b">.set_index()</code>方法，将索引改为<code class="fe lv lw lx ly b">df_2</code>的 id，这将为我们提供这个字典:<code class="fe lv lw lx ly b">{1003: ‘Snow’, 1004: ‘Targaryen’, 1005: ‘Tyrell’, 1002: ‘Lannister’, 1006: ‘Stark’}</code>。我们现在可以使用<code class="fe lv lw lx ly b">.map()</code>方法将我们的系列值(<code class="fe lv lw lx ly b">id</code>)映射到新字典的相应值。</p><p id="287a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一位数据科学家同事 Bernard Kurka 帮助我找到了第一个解决方案。也看看他的一些<a class="ae ky" href="https://medium.com/@bkexcel2014" rel="noopener">中型帖子</a>。</p><h1 id="9147" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">解决方案 2:使用。加入()</h1><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="ac41" class="nu mz it ly b gy nv nw l nx ny"><strong class="ly iu">code</strong>: <!-- -->df_1 = <!-- -->df_1.set_index('id').join(df_2.set_index('id'))</span><span id="5090" class="nu mz it ly b gy nz nw l nx ny">39.2 ns ± 0.709 ns per loop</span></pre><p id="62a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.join()</code>方法将连接另一个数据帧的列。默认情况下，它执行左连接，但是您可以通过传递<code class="fe lv lw lx ly b">how=</code>超参数并将其更改为“右”、“外”或“内”来指定。我们需要在<code class="fe lv lw lx ly b">df_1</code>和<code class="fe lv lw lx ly b">df_2</code>上调用<code class="fe lv lw lx ly b">.set_index()</code>方法，这样我们就可以加入正确的索引。</p><h1 id="9ce2" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">解决方案 3:使用。合并()</h1><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="0d35" class="nu mz it ly b gy nv nw l nx ny"><strong class="ly iu">code</strong>: df_1 = <!-- -->df_1.merge(df_2, how='left', on='id')</span><span id="21f6" class="nu mz it ly b gy nz nw l nx ny">38 ns ± 0.369 ns per loop</span></pre><p id="ca43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.merge()</code>方法用数据库风格的连接合并数据帧或命名系列对象。在这里，我通过指定<code class="fe lv lw lx ly b">on=</code>超参数来指定我希望它如何与<code class="fe lv lw lx ly b">how=</code>连接以及在哪个列/索引上连接。</p><h1 id="aaeb" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">解决方案 4:使用 pd.concat()</h1><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="52af" class="nu mz it ly b gy nv nw l nx ny"><strong class="ly iu">code</strong>: <!-- -->df_1 = <!-- -->pd.concat([df_1.set_index('id'), df_2.set_index('id').last_name], axis=1, sort='id', join='inner')</span><span id="843d" class="nu mz it ly b gy nz nw l nx ny">38.5 ns ± 0.379 ns per loop</span></pre><p id="05c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">pd.concat()</code>方法沿着一个特定的轴连接 pandas 对象，沿着其他轴连接可选的 set 逻辑。所以在这里我传递了我想要连接成一个列表的熊猫对象。第一个是 DataFrame，其中我将索引设置为<code class="fe lv lw lx ly b">id</code>列，第二个是 Series，但也在<code class="fe lv lw lx ly b">id</code>列上进行索引。通过设置<code class="fe lv lw lx ly b">axis=1</code>，我指定了要连接的轴，1 表示列，0 表示索引(行)。因为<code class="fe lv lw lx ly b">id</code>列没有在<code class="fe lv lw lx ly b">df_2</code>上排序，所以我也必须指定<code class="fe lv lw lx ly b">sort=</code>超参数。<code class="fe lv lw lx ly b">join=</code>超参数指定如何处理其他轴上的索引。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="a399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这真的很酷，我们看到有几种方法可以做完全相同的事情。所以现在的问题是，这些方法中哪一个计算效率最高？我包括了上面的时间，但是我会把它们排在这里，这样你就不用向上滚动了。他们将从最快运行时间到最慢运行时间排列。</p><ol class=""><li id="e791" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">.merge()</code>每环路 38 纳秒±0.369 纳秒</li><li id="9de7" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">.concat()</code>每环路 38.5 纳秒±0.379 纳秒</li><li id="d352" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">.join()</code>每环路 39.2 纳秒±0.709 纳秒</li><li id="0ad1" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">.map()</code>每循环 2.3 毫秒 131 秒</li></ol><p id="8d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你发现自己需要使用这些方法中的一种，我希望你可以参考这个(或我的<a class="ae ky" href="https://github.com/traintestbritt/excel_to_pandas/blob/master/excel_to_pandas.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">代码</strong> </a> <strong class="lb iu"> </strong> —如果是移动设备，滚动到底部并选择右边的“显示桌面版本”)<strong class="lb iu"> </strong>作为如何做的指导。我很想把这变成一个系列，在那里我会教你如何用 Python 和 Pandas 之类的库在 Excel 中做更多你喜欢做的事情，所以请在下面的评论中告诉我你接下来想看到什么。一如既往，感谢阅读。</p></div></div>    
</body>
</html>