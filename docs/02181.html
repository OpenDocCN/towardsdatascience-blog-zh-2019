<html>
<head>
<title>Feature Engineering in SQL and Python: A Hybrid Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 和 Python 中的特征工程:一种混合方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-in-sql-and-python-a-hybrid-approach-b52347cd2de4?source=collection_archive---------19-----------------------#2019-04-10">https://towardsdatascience.com/feature-engineering-in-sql-and-python-a-hybrid-approach-b52347cd2de4?source=collection_archive---------19-----------------------#2019-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d14" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">设置您的工作站，减少工作场所的混乱，保持一个干净的命名空间，并毫不费力地保持您的数据集最新</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/de73e9ac4cc51a4bc7843d6b57b67ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qtxyC5pzJ0m9ElrnvBpFCQ.png"/></div></div></figure><p id="0f88" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在了解 Pandas 之前，我很早就知道 SQL，Pandas 忠实地模拟 SQL 的方式引起了我的兴趣。一般来说，SQL 是为分析人员设计的，他们将数据整理成信息丰富的报告，而 Python 是为数据科学家设计的，他们使用数据来构建(并过度拟合)模型。尽管它们的功能几乎相同，但我认为这两种工具对于数据科学家高效工作都是必不可少的。根据我和熊猫相处的经验，我注意到了以下几点:</p><ul class=""><li id="c143" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">在探索不同的特性时，我最终得到了许多 CSV 文件。</li><li id="134e" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">当我在一个大的数据帧上进行聚合时，Jupyter 内核就会死亡。</li><li id="d8b8" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在我的内核中，有多个数据帧有令人困惑的(长的)名字。</li><li id="a837" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">我的特征工程代码看起来很难看，分散在许多单元中。</li></ul><p id="3fb8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我直接在 SQL 中开始特性工程时，这些问题自然就解决了。所以在这篇文章中，我将通过一个带回家的挑战数据集来分享一些我最喜欢的技巧。如果你懂一点 SQL，是时候好好利用它了。</p><h2 id="022f" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">安装 MySQL</h2><p id="8083" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">首先，您需要一台 SQL 服务器。我在这篇文章中使用 MySQL。你可以通过安装 MAMP、WAMP 或 XAMPP 等本地桌面服务器来获得 MySQL 服务器。网上有很多教程，值得不厌其烦的去做。</p><p id="2b84" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在设置好你的服务器后，确保你已经准备好三样东西:用户名，密码，端口号。通过终端输入以下命令登录(这里我们有用户名“root”，密码 1234567)。</p><pre class="kk kl km kn gt nd ne nf ng aw nh bi"><span id="ef82" class="mf mg it ne b gy ni nj l nk nl">mysql -uroot -p<!-- -->1234567</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nm"><img src="../Images/b6c2c86f45dcf090bb3a992d6205e0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BsyO0B939I3SbZ8UCspOA.png"/></div></div></figure><p id="4f0a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后在 MySQL 控制台中创建一个名为“Shutterfly”的数据库(你可以随意命名)。这两个表将被加载到这个数据库中。</p><pre class="kk kl km kn gt nd ne nf ng aw nh bi"><span id="02af" class="mf mg it ne b gy ni nj l nk nl">create database Shutterfly;</span></pre><h2 id="8a9d" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">安装 sqlalchemy</h2><p id="863a" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">您将需要 Pandas 和 sqlalchemy 来使用 Python 中的 SQL。我打赌你已经有熊猫了。然后通过激活您想要的环境来安装 sqlalchemy，启动 Jupyter notebook，并输入:</p><pre class="kk kl km kn gt nd ne nf ng aw nh bi"><span id="9a4c" class="mf mg it ne b gy ni nj l nk nl">pip install sqlalchemy</span></pre><p id="e391" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">sqlalchemy 模块还需要<em class="nn"> MySQLdb </em>和<em class="nn"> mysqlclient </em>模块。根据你的操作系统，这可以使用不同的<a class="ae no" href="https://stackoverflow.com/questions/454854/no-module-named-mysqldb" rel="noopener ugc nofollow" target="_blank">命令</a>来安装。</p><h2 id="5f80" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">将数据集加载到 MySQL 服务器</h2><p id="0a0c" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">在这个例子中，我们将从两个<a class="ae no" href="https://github.com/shawlu95/Data-Science-Toolbox/tree/master/case_study/shutterfly/data" rel="noopener ugc nofollow" target="_blank"> CSV 文件</a>中加载数据，并直接在 MySQL 中设计特性。为了加载数据集，我们需要使用用户名、密码、端口号和数据库名实例化一个<strong class="kx iu">引擎</strong>对象。将创建两个表:<em class="nn">在线</em>和<em class="nn">订单</em>。将在每个表上创建一个自然索引。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="893e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在 MySQL 控制台中，您可以验证表是否已经创建。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="7908" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">分割数据集</h2><p id="eaa4" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">这可能看起来违背直觉，因为我们还没有构建任何特性。但它实际上非常简洁，因为我们所需要做的就是按照索引分割<strong class="kx iu">数据集。通过设计，我还包含了我们试图预测的标签(事件 2)。当加载特性时，我们将简单地用特性表连接索引。</strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b588" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在 MySQL 控制台中，您可以验证训练集和测试集是否已创建。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="cf45" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">特征工程</h2><p id="e759" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">这是最重要的部分。我直接用 Sublime 文本编写 SQL 代码，并通过将它们粘贴到 MySQL 控制台来调试我的代码。因为这个数据集是一个事件日志，所以我们必须避免将未来的信息泄露到每个数据点。正如您所想象的，每个特性都需要在历史上进行聚合！</p><p id="d25e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">连接表是最慢的操作，所以我们希望从每个连接中获得尽可能多的特征。在这个数据集中，我实现了四种类型的连接，产生了四组要素。细节并不重要，但是你可以在这里找到我所有的 SQL 片段<a class="ae no" href="https://github.com/shawlu95/Shutterfly-Take-Home-Challenge/tree/master/features" rel="noopener ugc nofollow" target="_blank"/>。每个代码片段创建一个表。<strong class="kx iu">索引被保留，并且必须与训练集和测试集中的响应变量正确匹配。</strong>每个片段的结构如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d87c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要生成功能表，请打开一个新的终端，导航到包含 sql 文件的文件夹，并输入以下命令和密码。第一个代码片段创建了一些必要的索引来加速连接操作。接下来的四个片段创建了四个功能表。如果没有索引，连接将永远无法完成。使用索引，大约需要 20 分钟(在本地机器上还不错)。</p><pre class="kk kl km kn gt nd ne nf ng aw nh bi"><span id="cbe2" class="mf mg it ne b gy ni nj l nk nl">mysql &lt; add_index.sql <!-- -->-uroot -p1234567<br/>mysql &lt; feature_group_1.sql -uroot -p1234567<br/>mysql &lt; feature_group_2.sql -uroot -p1234567<br/>mysql &lt; feature_group_3.sql -uroot -p1234567<br/>mysql &lt; feature_group_4.sql -uroot -p1234567</span></pre><p id="1c4d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，数据库中应该有下面的表。请注意，派生功能与原始事件日志分开存储，这有助于防止混淆和灾难。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="6176" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">加载功能</h2><p id="5cd9" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">这里我写了一个从 MySQL 服务器获取数据的实用函数。</p><ul class=""><li id="74a5" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">该函数将表名“trn_set”(训练集)或“tst_set”(测试集)作为输入，如果您只需要数据的一个子集，还需要一个可选的<em class="nn"> limit </em>子句。</li><li id="557b" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">删除唯一列和大部分值缺失的列。</li><li id="a693" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">日期列映射到月份，以帮助捕捉季节性影响。</li><li id="385d" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">请注意特征表是如何连续连接的。这实际上是有效的，因为我们总是以一对一的映射来连接索引。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0bbb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，让我们来看看 5 个培训示例及其特点。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bdf7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在您已经有了一个定义良好的数据集和特性集。您可以调整每个要素和缺失值的比例，以满足模型的要求。</p><p id="2988" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于基于树的方法，它对特征缩放是不变的，我们可以直接应用模型，只需专注于调整参数！在这里看一个普通的梯度推进机器<a class="ae no" href="https://github.com/shawlu95/Data-Science-Toolbox/blob/master/case_study/shutterfly/gbm_benchmark_2.ipynb" rel="noopener ugc nofollow" target="_blank">的例子。</a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nr"><img src="../Images/0ca1f33ebdf0a7f1e7020f722748268e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTZeCcwqZGFVKkMtTdh7Gg.png"/></div></div></figure><p id="2a24" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">很高兴看到除了<em class="nn">类别</em>功能之外，所有有用的功能都被设计出来了。我们的努力得到了回报！此外，event2 最具预测性的特性是在 event2 中观察到多少 nulls 值。这是一个说明性的例子<strong class="kx iu">，我们不能用中值或平均值来代替空值</strong>，因为它们缺失的事实与响应变量相关！</p><h2 id="deed" class="mf mg it bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">摘要</h2><p id="6158" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">如您所见，我们没有中间 CSV 文件，笔记本中有一个非常干净的名称空间，我们的功能工程代码减少到几个简单的 SQL 语句。在两种情况下，SQL 方法更加高效:</p><ul class=""><li id="1ed3" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">如果您的数据集部署在云上，您可能能够运行分布式查询。如今，大多数 SQL server 都支持分布式查询。在 Pandas 中，您需要一些名为<em class="nn"> Dask DataFrame 的扩展。</em></li><li id="1445" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如果你能负担得起实时拉取数据，你可以创建 SQL <strong class="kx iu">视图</strong>而不是表。这样，每次用 Python 拉数据，<strong class="kx iu">你的数据都会一直是最新的</strong>。</li></ul><p id="d691" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这种方法的一个基本限制是，您必须能够用 Python 直接连接到 SQL server。如果这是不可能的，您可能需要下载一个 CSV 文件格式的查询结果，并在 Python 中加载它。</p><p id="c96f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我希望这篇文章对你有所帮助。虽然我并不提倡一种方法优于另一种方法，但有必要了解每种方法的优点和局限性，并在我们的工具包中准备好这两种方法。因此，我们可以应用在约束条件下最有效的方法。</p></div></div>    
</body>
</html>