<html>
<head>
<title>Hopefully This Bayesian Spam Filter isn’t Too Naive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">希望这个贝叶斯垃圾邮件过滤器不是太天真</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hopefully-this-bayesian-spam-filter-isnt-too-naive-d89675bce99c?source=collection_archive---------42-----------------------#2019-11-04">https://towardsdatascience.com/hopefully-this-bayesian-spam-filter-isnt-too-naive-d89675bce99c?source=collection_archive---------42-----------------------#2019-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/329c72843cb83ef81347df258bcaf22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*QcGW-8CyKYP1W7LRhJ-20g.jpeg"/></div></figure><p id="a1d6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们都遇到过垃圾邮件，从 Gmail 收件箱中的可疑电子邮件，到社交媒体帖子上的重复评论。垃圾邮件是一种自 2000 年初以来一直困扰互联网的现象，并不是什么新鲜事。然而，我们现在有很好的方法使用机器学习来处理垃圾邮件。今天，我们将创建一个带有自然语言处理的垃圾邮件过滤器，它将根据我们是否确定该文本是垃圾邮件来返回布尔值 1 或 0。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="217e" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">处理自然语言</h1><p id="e8d6" class="pw-post-body-paragraph jx jy it jz b ka ma kc kd ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku im bi translated">(<a class="ae mf" href="https://github.com/emmettgb/Spammy/blob/master/ML/Spam_Filtering.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p><p id="ad2b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的数据最初有一些不重要的列，我很快就删除了。接下来，看看我们从数据帧中提取的两列，标签和文本，标签是包含“垃圾邮件”或“火腿”的分类特征，所以我认为垃圾邮件是垃圾邮件，火腿不是垃圾邮件。</p><p id="b933" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，为了让我们能够使用我们想要使用的任何模型，我将数据集中的所有标签映射到数字类型的布尔</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f56a" class="mp ld it ml b gy mq mr l ms mt">dataset['numerical_label'] = dataset.label.map({'ham':0, 'spam':1})</span></pre><p id="4f40" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这样一来，我使用了一个反矢量器来对我们的英语输入进行矢量化:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a139" class="mp ld it ml b gy mq mr l ms mt">from sklearn.feature_extraction.text import CountVectorizer<br/>vect = CountVectorizer(stop_words='english')<br/>vect.fit(X_train)</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/864dd173ae4229137f5269c916e2506b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpQf9G3ZdnMXLT-QT3sErQ.jpeg"/></div></div></figure><p id="d071" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于我的模型，我选择利用贝叶斯多项式模型，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b701" class="mp ld it ml b gy mq mr l ms mt">from sklearn.naive_bayes import MultinomialNB<br/>model = MultinomialNB()<br/>model.fit(X_train_df,y_train)</span></pre><p id="db50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以在适应、转换和改变之后，我得到了一个准确度分数:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/671bd70e320264bafa5979bcd6cb906e.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*Gbnp3A8zphEhQpTBasBB0Q.png"/></div></figure><p id="caf4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并准备序列化我的模型，以便在 Flask 应用程序中使用。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8327" class="mp ld it ml b gy mq mr l ms mt">from sklearn.externals import joblib<br/>filename = 'alg.sav'<br/>joblib.dump(model, filename)</span></pre></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="8865" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">烧瓶时间，宝贝</h1><p id="213c" class="pw-post-body-paragraph jx jy it jz b ka ma kc kd ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku im bi translated">我决定使用 HTTP 参数，因为这将使默认版本对任何人来说都是最通用和最容易实现的。所以我们当然要从我们的 app.route()开始:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1f4b" class="mp ld it ml b gy mq mr l ms mt">@app.route(‘/’)</span></pre><p id="5a93" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并在其下方添加我们的函数。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b535" class="mp ld it ml b gy mq mr l ms mt">def template():<br/>    try:<br/>        txt = request.args['text']<br/>    except KeyError as e:<br/>        return ('Some Values are missing')</span></pre><p id="01bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Request.args 从 URL 中提取 HTTP 参数，用作 Flask 应用程序中的变量。HTTP 请求非常适合数据管道和深度嵌套的后端。接下来，我选择将读取的文本放入数据帧中进行预测。这一步不一定是至关重要的，但我已经将熊猫添加到 Flask 应用程序中，所以我决定使用它。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi na"><img src="../Images/e2c86460a86189b5492089ac0826f60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YnOp_i0XDejHiiLPGkvTcw.gif"/></div></div></figure><p id="78a8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们已经将数据放入 Flask，我们可以反序列化并加载我们的管道。</p><p id="d4f1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">需要注意的一点是，为了使数组适合模型，您可能需要用 np.reshape()来改变数组的形状。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="5c85" class="mp ld it ml b gy mq mr l ms mt">pipeline = load('alg.sav')    <br/>estimate=pipeline.predict(df['input'])    <br/>return(estimate)</span></pre><p id="2f13" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">没什么太复杂的！现在，我们可以通过任何字符串请求访问 Flask 应用程序，并通过数据管道尽可能多地重用这个精确的算法！</p><blockquote class="nb"><p id="96e6" class="nc nd it bd ne nf ng nh ni nj nk ku dk translated">厉害！</p></blockquote></div></div>    
</body>
</html>