<html>
<head>
<title>Who Is Your Golden Goose?: Cohort Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁是你的金鹅？:群组分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/who-is-your-golden-goose-cohort-analysis-50c9de5dbd31?source=collection_archive---------10-----------------------#2019-01-06">https://towardsdatascience.com/who-is-your-golden-goose-cohort-analysis-50c9de5dbd31?source=collection_archive---------10-----------------------#2019-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b5b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 中基于 RFM 值和 K 均值聚类的客户细分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a2ed8ced749589b4d70965cacf20164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ym2eP4l9cdm5bZL1.png"/></div></div></figure><p id="a0fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">客户细分是一种根据购买模式将客户分组的技术，以确定谁是最有利可图的群体。在细分客户时，也可以根据市场使用各种标准，如地理、人口特征或行为基础。这种方法假设具有不同特征的群体需要不同的营销方法，并希望找出最能提高其盈利能力的群体。</p><p id="92dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我们将讨论如何使用来自 UCI ML repo 的<a class="ae ln" href="https://www.kaggle.com/jihyeseo/online-retail-data-set-from-uci-ml-repo" rel="noopener ugc nofollow" target="_blank">在线零售数据集</a>进行客户细分分析。这种分析将集中在获得 RFM 值和用 K-means 算法进行聚类这两个步骤上。数据集和完整代码也可以在我的<a class="ae ln" href="https://github.com/jjone36/Cohort/blob/master/Cohort_Anaylsis_Medium.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。这篇笔记的原始资料来自课程“Python 中的<a class="ae ln" href="https://www.datacamp.com/courses/customer-segmentation-in-python" rel="noopener ugc nofollow" target="_blank">客户细分分析</a>”</p><h1 id="7169" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">什么是 RFM？</h1><p id="cb29" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">RFM 是近期、频率和货币的缩写。<strong class="kt ir">最近</strong>是关于客户最后一次订购的时间。它表示自客户最后一次购买以来的天数。如果是网站或应用程序的情况，这可能被解释为最后访问日或最后登录时间。</p><p id="4090" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">频率</strong>是关于给定时间段内的购买次数。可能是 3 个月，6 个月或者 1 年。所以我们可以把这个值理解为客户使用公司产品的频率或数量。价值越大，客户参与度越高。我们可以说他们是我们的贵宾吗？没必要。因为我们还必须考虑他们每次购买实际支付了多少钱，这意味着货币价值。</p><p id="bbfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">货币</strong>是客户在给定期间花费的总金额。因此，挥金如土的人将与其他客户区分开来，如 MVP 或 VIP。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/1c4a7fcc0ebd607adf71213e3e4355d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zrI_0xNSPFBejgjz.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Photo from CleverTap</figcaption></figure><p id="131e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这三个值是队列分析中常用的可量化因素。由于其简单直观的概念，它们在其他客户细分方法中很受欢迎。</p><h1 id="27d3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">导入数据</h1><p id="41be" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">所以我们今天将把 RFM 应用到我们的队列分析中。我们将要使用的数据集是从 2010 年 1 月到 2011 年 9 月的交易历史数据。由于这是队列分析的指导方针，我将只使用原始数据集的随机选择部分。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b118" class="mv lp iq mr b gy mw mx l my mz"># Import data<br/>online = pd.read_excel('Online Retail.xlsx')</span><span id="8148" class="mv lp iq mr b gy na mx l my mz"># drop the row missing customer ID <br/>online = online[online.CustomerID.notnull()]<br/>online = online.sample(frac = .3).reset_index(drop = True)</span><span id="c8de" class="mv lp iq mr b gy na mx l my mz">online.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/cb3af71ec2ae4fc7b0ad277eb379b691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgsF_eJmuh1nhyzXk1sB4A.png"/></div></div></figure><h1 id="e736" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">计算 RFM 值</h1><p id="5231" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们要计算的第一件事是最近值，即自客户最后一个订单以来的天数。我们可以从哪一列获得该值？<strong class="kt ir"> InvoiceData </strong>。使用这个列，我们可以得到客户的第一次购买和最后一次购买的时间。我们姑且称第一个为<strong class="kt ir">cohorday</strong>。由于<strong class="kt ir"> InvoiceDate </strong>还包含额外的时间数据，我们需要提取年、月和日部分。之后，我们将得到<strong class="kt ir">工作日</strong>，它是<strong class="kt ir">工作日</strong>的最小值。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9332" class="mv lp iq mr b gy mw mx l my mz"># <em class="nc">extract year, month and day</em><br/>online['InvoiceDay'] = online.InvoiceDate.apply(<strong class="mr ir">lambda</strong> x: dt.datetime(x.year, x.month, x.day))</span><span id="887e" class="mv lp iq mr b gy na mx l my mz">online.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/8e258ab9bb467ac4f1caeda7f1b9ec12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mfpWSzG--pPyYBR68gDfQ.png"/></div></div></figure><p id="688e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们随机选择了数据的子集，我们还需要知道数据的时间段。如下图所示，我们数据集的最后一天是 2011 年 12 月 9 日。因此，将 12 月 10 日设置为我们的 pining 日期，并从每个客户最近一次购买的天数开始倒数。这就是最近值。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9599" class="mv lp iq mr b gy mw mx l my mz"># print the time period<br/>print('Min : {}, Max : {}'.format(min(online.InvoiceDay), max(online.InvoiceDay)))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/773fc8e10df32cbb54b1f7f9ddba75f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*r4i8uKk8XHOEUlT07bxXTg.png"/></div></figure><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4b86" class="mv lp iq mr b gy mw mx l my mz"># pin the last date<br/>pin_date = max(online.InvoiceDay) + dt.timedelta(1)</span></pre><p id="7896" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在得到最近值之前，让我们先多算一个值，每个顾客花的钱的总数。这是为了计算货币价值。我们怎样才能得到它？轻松点。将每行中的产品价格和订单数量相乘。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="83ac" class="mv lp iq mr b gy mw mx l my mz"># Create total spend dataframe<br/>online['TotalSum'] = online.Quantity * online.UnitPrice<br/>online.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/e03051f69f022d67b00f623a4b637080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzDeOvwNCobotVsk2XMaAA.png"/></div></div></figure><p id="89a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们准备一下子得到三个 RFM 值。我将对每个客户的数据进行分组，并针对每个最近、频率和货币价值进行汇总。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8d39" class="mv lp iq mr b gy mw mx l my mz"># calculate RFM values<br/>rfm = online.groupby('CustomerID').agg({<br/>    'InvoiceDate' : lambda x: (pin_date - x.max()).days,<br/>    'InvoiceNo' : 'count', <br/>    'TotalSum' : 'sum'})</span><span id="77da" class="mv lp iq mr b gy na mx l my mz"># rename the columns<br/>rfm.rename(columns = {'InvoiceDate' : 'Recency', <br/>                      'InvoiceNo' : 'Frequency', <br/>                      'TotalSum' : 'Monetary'}, inplace = True)</span><span id="1458" class="mv lp iq mr b gy na mx l my mz">rfm.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2f3f1b470396be3094a88c3ef8d565d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*ZIhkO-Qiztkn4z1pMkbY2w.png"/></div></figure><h1 id="52d8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">RFM 四分位数</h1><p id="0670" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在，我们将根据 RFM 价值观对客户进行分组。因为这些是连续值，我们也可以使用分位数值，并将它们分成 4 组。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e6a2" class="mv lp iq mr b gy mw mx l my mz"># create labels and assign them to tree percentile groups <br/>r_labels = range(4, 0, -1)<br/>r_groups = pd.qcut(rfm.Recency, q = 4, labels = r_labels)</span><span id="858b" class="mv lp iq mr b gy na mx l my mz">f_labels = range(1, 5)<br/>f_groups = pd.qcut(rfm.Frequency, q = 4, labels = f_labels)</span><span id="446a" class="mv lp iq mr b gy na mx l my mz">m_labels = range(1, 5)<br/>m_groups = pd.qcut(rfm.Monetary, q = 4, labels = m_labels)</span></pre><p id="59a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请格外小心<code class="fe nh ni nj mr b">r_labels</code>。我把标签按降序排列。这是为什么呢？因为最近意味着从客户最后一次订购到现在已经过去了多长时间。因此，价值越小，顾客对该品牌的参与度越高。现在让我们创建一个新的列来表示组标签。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b39d" class="mv lp iq mr b gy mw mx l my mz"># make a new column for group labels<br/>rfm['R'] = r_groups.values<br/>rfm['F'] = f_groups.values<br/>rfm['M'] = m_groups.values</span><span id="5bf7" class="mv lp iq mr b gy na mx l my mz"># sum up the three columns<br/>rfm['RFM_Segment'] = rfm.apply(lambda x: str(x['R']) + str(x['F']) + str(x['M']), axis = 1)<br/>rfm['RFM_Score'] = rfm[['R', 'F', 'M']].sum(axis = 1)<br/>rfm.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/1622584ecc8ff34a2613d768a2c3b040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*rg_5W9l9ShEspc_OwSeqrg.png"/></div></figure><p id="2214" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在一个单元格中贴上了所有三个标签作为<code class="fe nh ni nj mr b">RFM_Segment</code>。这样，我们可以很容易地检查一个客户属于哪个级别或细分市场。<code class="fe nh ni nj mr b">RFM_Score</code>是三个值的总和。不一定是总和，所以平均值也是可能的。此外，我们可以捕捉进一步的模式与平均值或计数值的新近，频率和货币分组的分数如下。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="143c" class="mv lp iq mr b gy mw mx l my mz"># calculate averae values for each RFM<br/>rfm_agg = rfm.groupby('RFM_Score').agg({<br/>    'Recency' : 'mean',<br/>    'Frequency' : 'mean',<br/>    'Monetary' : ['mean', 'count']<br/>})</span><span id="044a" class="mv lp iq mr b gy na mx l my mz">rfm_agg.round(1).head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9cd800299f9ab1779156d39dfac39295.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*-mUPcHDHW1B2EOO4oghEnA.png"/></div></figure><p id="3e8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nh ni nj mr b">RFM_Score</code>将是客户参与度或忠诚度的总分。将这三个价值加在一起，我们最终可以将客户分为“金牌”、“银牌”、“铜牌”和“绿色”。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="488d" class="mv lp iq mr b gy mw mx l my mz"># assign labels from total score<br/>score_labels = ['Green', 'Bronze', 'Silver', 'Gold']<br/>score_groups = pd.qcut(rfm.RFM_Score, q = 4, labels = score_labels)<br/>rfm['RFM_Level'] = score_groups.values</span><span id="5c04" class="mv lp iq mr b gy na mx l my mz">rfm.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/7d6818f7c81fa317347f1f808de4321c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MfKJS-LLLd9zsWjYqAZqA.png"/></div></div></figure><p id="8205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太好了！我们完成了一个 RFM 值的队列分析。我们确定了谁是我们的金鹅，以及我们应该额外注意的地方。现在，我们为什么不尝试一种不同的客户细分方法，并比较两种结果呢？</p><h1 id="e8cf" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">k 均值聚类</h1><p id="7104" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> K-Means 聚类</strong> </a> <strong class="kt ir"> </strong>是一种无监督学习算法，它根据点与点之间的距离进行分组。怎么会？K-Means 聚类中有两个距离概念。<strong class="kt ir">类内平方和</strong> (WSS)和<strong class="kt ir">类间平方和</strong> (BSS)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/2662ebc4c47624a3b237e9c1ded64e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elDpzAzFuvFtm62DusqI_Q.png"/></div></div></figure><p id="fe0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">WSS 表示每个聚类的点和相应质心之间的距离之和，BSS 表示质心和总样本平均值之间的距离之和乘以每个聚类内的点数。因此，您可以将 WSS 视为紧致性的度量，将 BSS 视为分离性的度量。为了聚类成功，我们需要获得较低的 WSS 和较高的 BSS。</p><p id="89a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过迭代和移动聚类质心，K-Means 算法试图得到质心的优化点，使 WSS 值最小，盲源分离值最大。基本概念我就不去更深入了，不过你可以从<a class="ae ln" href="https://www.youtube.com/watch?v=_aWzGGNrcic" rel="noopener ugc nofollow" target="_blank">视频</a>中找到进一步的解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/ee97fe004b109f9624b89c7f326c44ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvASNhZHdbQRf5Vy5fr3hg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Photo from Wikipedia</figcaption></figure><p id="abe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为 K-means 聚类使用距离作为相似性因子，所以我们需要缩放数据。假设我们有两种不同尺度的特征，比如身高和体重。平均身高 150cm 以上，体重 100kg 以下。因此，如果我们绘制这些数据，点与点之间的距离将在很大程度上由高度决定，从而导致有偏差的分析。</p><p id="e1ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，当涉及 K-means 聚类时，缩放和归一化数据是预处理的关键步骤。如果我们检查 RFM 值的分布，你会注意到它们是右偏的。不规范使用不是一个好的状态。让我们先将 RFM 值转换成对数标度，然后再进行归一化。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="aa45" class="mv lp iq mr b gy mw mx l my mz"># define function for the values below 0<br/>def neg_to_zero(x):<br/>    if x &lt;= 0:<br/>        return 1<br/>    else:<br/>        return x</span><span id="bd78" class="mv lp iq mr b gy na mx l my mz"># apply the function to Recency and MonetaryValue column <br/>rfm['Recency'] = [neg_to_zero(x) for x in rfm.Recency]<br/>rfm['Monetary'] = [neg_to_zero(x) for x in rfm.Monetary]</span><span id="f566" class="mv lp iq mr b gy na mx l my mz"># unskew the data<br/>rfm_log = rfm[['Recency', 'Frequency', 'Monetary']].apply(np.log, axis = 1).round(3)</span></pre><p id="269a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">小于或等于零的值在对数标度时变为负无穷大，我创建了一个函数将这些值转换为 1，并将其应用于<code class="fe nh ni nj mr b">Recency</code>和<code class="fe nh ni nj mr b">Monetary</code>列，使用如上所述的列表理解。然后，对每个 RFM 值应用对数变换。下一个预处理步骤是缩放，但它比上一步简单。使用<strong class="kt ir"> StandardScaler() </strong>，我们可以得到如下标准化值。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="43d1" class="mv lp iq mr b gy mw mx l my mz"># scale the data<br/>scaler = StandardScaler()<br/>rfm_scaled = scaler.fit_transform(rfm_log)</span><span id="5c4c" class="mv lp iq mr b gy na mx l my mz"># transform into a dataframe<br/>rfm_scaled = pd.DataFrame(rfm_scaled, index = rfm.index, columns = rfm_log.columns)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/5f98cf97a68198ffc5dc46f371dac03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDV34_kEmi0BiHsTLiWQPg.png"/></div></div></figure><p id="0a31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">左边的图是预处理前的 RFM 分布，右边的图是归一化后的 RFM 分布。通过使它们处于某种程度上的正态分布，我们可以向我们的模型提供一些提示，以便轻松而准确地掌握值之间的趋势。现在，我们完成了预处理。</p><p id="9b74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是什么？下一步是选择正确的集群数量。我们必须选择要组成多少个小组。如果有先验知识，我们可以把数字直接给算法。但是在无监督学习的大多数情况下，没有。所以我们需要选择优化的数字，肘法是我们可以得到提示的解决方案之一。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="21e2" class="mv lp iq mr b gy mw mx l my mz"># the Elbow method<br/>wcss = {}<br/>for k in range(1, 11):<br/>    kmeans = KMeans(n_clusters= k, init= 'k-means++', max_iter= 300)<br/>    kmeans.fit(rfm_scaled)<br/>    wcss[k] = kmeans.inertia_</span><span id="ec39" class="mv lp iq mr b gy na mx l my mz"># plot the WCSS values<br/>sns.pointplot(x = list(wcss.keys()), y = list(wcss.values()))<br/>plt.xlabel('K Numbers')<br/>plt.ylabel('WCSS')<br/>plt.show()</span></pre><p id="413d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用 for 循环，我为从 1 到 10 的每个集群构建了模型。然后收集每个模型的 WSS 值。看下面的剧情。随着聚类数量的增加，WSS 值降低。这并不奇怪，因为我们做的聚类越多，每个聚类的大小就会减小，所以每个聚类内的距离之和就会减小。那么最佳数字是多少呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/48f031c4e10437e728ebaf7ecae1b016.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*8O4mCiv7lQAoM9QJQzU1wg.png"/></div></figure><p id="a5d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答案在这条线的“肘”处。在某处，WSS 急剧下降，但 k 值不会太大，我在这里的选择是 3。你说什么？它看起来真的不像线的一个肘吗？</p><p id="58f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们选择了集群的数量，我们可以建立一个模型，使实际的集群如下。我们还可以检查每个点和聚类的质心或标签之间的距离。让我们创建一个新列，并将标签分配给每个客户。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c7ca" class="mv lp iq mr b gy mw mx l my mz"># clustering<br/>clus = KMeans(n_clusters= 3, init= 'k-means++', max_iter= 300)<br/>clus.fit(rfm_scaled)</span><span id="bcb5" class="mv lp iq mr b gy na mx l my mz"># Assign the clusters to datamart<br/>rfm['K_Cluster'] = clus.labels_<br/>rfm.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d9d684f92583c9faaeab8708fab9ed54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1s_Lp_ykNjK9cyV9xYh7g.png"/></div></div></figure><p id="2e28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们做了两种分割，RFM 分位数组和 K-均值组。我们来做个可视化，对比一下两种方法。</p><h1 id="0b4e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">蛇图和热图</h1><p id="b7ea" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我要做两种图，线图和热图。我们可以很容易地比较这两个图的 RFM 值的差异。首先，我将创建列来分配两个聚类标签。然后通过将 RFM 值融合到一列来重塑数据框。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ed36" class="mv lp iq mr b gy mw mx l my mz"># assign cluster column <br/>rfm_scaled['K_Cluster'] = clus.labels_<br/>rfm_scaled['RFM_Level'] = rfm.RFM_Level<br/>rfm_scaled.reset_index(inplace = True)</span><span id="bf6d" class="mv lp iq mr b gy na mx l my mz"># melt the dataframe<br/>rfm_melted = pd.melt(frame= rfm_scaled, id_vars= ['CustomerID', 'RFM_Level', 'K_Cluster'], var_name = 'Metrics', value_name = 'Value')<br/>rfm_melted.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/ceb89daa505f6ea81fc3a15232370906.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*AZgnAt1ZPedkvejeaWhHLQ.png"/></div></figure><p id="7fee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将使新近性、频率和货币类别成为观察值，这允许我们在一个图中绘制值。将<code class="fe nh ni nj mr b">Metrics</code>放在 x 轴上，将<code class="fe nh ni nj mr b">Value</code>放在 y 轴上，并通过<code class="fe nh ni nj mr b">RFM_Level.</code>对值进行分组。这次重复通过<code class="fe nh ni nj mr b">K_Cluster</code>对值进行分组的相同代码。结果如下所示。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c9eb" class="mv lp iq mr b gy mw mx l my mz"># a snake plot with RFM<br/>sns.lineplot(x = 'Metrics', y = 'Value', hue = 'RFM_Level', data = rfm_melted)<br/>plt.title('Snake Plot of RFM')<br/>plt.legend(loc = 'upper right')</span><span id="1a80" class="mv lp iq mr b gy na mx l my mz"># a snake plot with K-Means<br/>sns.lineplot(x = 'Metrics', y = 'Value', hue = 'K_Cluster', data = rfm_melted)<br/>plt.title('Snake Plot of RFM')<br/>plt.legend(loc = 'upper right')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/40b70da6bb03c2729ef3c92e5025b8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VW9nw5cj6KSCKnm4geZzQ.png"/></div></div></figure><p id="b339" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种情节在市场分析中被称为“蛇情节”。似乎左边图中的<strong class="kt ir">金色</strong>和<strong class="kt ir">绿色</strong>组与右边图中的<strong class="kt ir"> 1 </strong>和<strong class="kt ir"> 2 </strong>组相似。而<strong class="kt ir">铜牌</strong>和<strong class="kt ir">银牌</strong>组好像合并成了<strong class="kt ir"> 0 组</strong>。</p><p id="8269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用热图再试一次。<a class="ae ln" href="https://en.wikipedia.org/wiki/Heat_map" rel="noopener ugc nofollow" target="_blank">热图</a>是数据的图形表示，其中较大的值用较暗的刻度表示，较小的值用较亮的刻度表示。我们可以通过颜色非常直观地比较各组之间的差异。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c1ad" class="mv lp iq mr b gy mw mx l my mz"># the mean value in total <br/>total_avg = rfm.iloc[:, 0:3].mean()<br/>total_avg</span><span id="fb92" class="mv lp iq mr b gy na mx l my mz"># calculate the proportional gap with total mean<br/>cluster_avg = rfm.groupby('RFM_Level').mean().iloc[:, 0:3]<br/>prop_rfm = cluster_avg/total_avg - 1</span><span id="b5f3" class="mv lp iq mr b gy na mx l my mz"># heatmap with RFM<br/>sns.heatmap(prop_rfm, cmap= 'Oranges', fmt= '.2f', annot = True)<br/>plt.title('Heatmap of RFM quantile')<br/>plt.plot()</span></pre><p id="ec31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后像之前一样对 K-clusters 重复相同的代码。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="69ec" class="mv lp iq mr b gy mw mx l my mz"># calculate the proportional gap with total mean<br/>cluster_avg_K = rfm.groupby('K_Cluster').mean().iloc[:, 0:3]<br/>prop_rfm_K = cluster_avg_K/total_avg - 1</span><span id="01ea" class="mv lp iq mr b gy na mx l my mz"># heatmap with K-means<br/>sns.heatmap(prop_rfm_K, cmap= 'Blues', fmt= '.2f', annot = True)<br/>plt.title('Heatmap of K-Means')<br/>plt.plot()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/9009847200fd7967be92892b33c6a099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arEK1Y2Ca5r4whWjkkG0nw.png"/></div></div></figure><p id="5c5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能是不匹配的，尤其是在地块的顶部。但只是因为顺序不同而已。左边的<strong class="kt ir">绿色</strong>组将对应<strong class="kt ir"> 2 </strong>组。如果你看到每个方框内的数值，你会发现<strong class="kt ir">黄金</strong>组和<strong class="kt ir"> 1 </strong>组之间的差异变得非常显著。通过颜色的深浅很容易辨认出来。</p><h1 id="e7fd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="8ea2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们讨论了如何从客户购买数据中获取 RFM 值，并用 RFM 分位数和 K-Means 聚类方法进行了两种细分。有了这个结果，我们现在可以知道谁是我们的“黄金”客户，最赚钱的群体。这也告诉我们应该关注哪个客户，向谁提供特别优惠或促销，以培养客户忠诚度。我们可以为每个细分市场选择最佳的沟通渠道，并改进新的营销策略。</p><h1 id="1123" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">资源</h1><ul class=""><li id="5658" class="nv nw iq kt b ku mg kx mh la nx le ny li nz lm oa ob oc od bi translated">一篇关于 https://clevertap.com/blog/rfm-analysis/的精彩文章<br/><a class="ae ln" href="https://clevertap.com/blog/rfm-analysis/" rel="noopener ugc nofollow" target="_blank"/></li><li id="ab11" class="nv nw iq kt b ku oe kx of la og le oh li oi lm oa ob oc od bi translated">另一个对 RFM 分析有用的解释:<a class="ae ln" href="https://www.optimove.com/learning-center/rfm-segmentation" rel="noopener ugc nofollow" target="_blank">https://www.optimove.com/learning-center/rfm-segmentation</a></li><li id="4091" class="nv nw iq kt b ku oe kx of la og le oh li oi lm oa ob oc od bi translated">对 K-means 聚类的直观解释:<a class="ae ln" href="https://www.youtube.com/watch?v=_aWzGGNrcic" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=_aWzGGNrcic</a></li></ul><p id="5872" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读，希望您对这篇文章感兴趣。如果有需要改正的地方，请分享你的见解！如果您想鼓励一位有抱负的数据科学家，请点击👏 👏 👏！我总是乐于交谈，所以请随时留下评论或在 LinkedIn 上联系我。我会带着另一个令人兴奋的项目回来。在那之前，机器学习快乐！</p></div></div>    
</body>
</html>