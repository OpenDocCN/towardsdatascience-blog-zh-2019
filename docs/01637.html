<html>
<head>
<title>Machine Learning Models as Micro Services in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 中作为微服务的机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-models-as-micro-services-in-docker-a798e1f068a5?source=collection_archive---------5-----------------------#2019-03-17">https://towardsdatascience.com/machine-learning-models-as-micro-services-in-docker-a798e1f068a5?source=collection_archive---------5-----------------------#2019-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4916ee4eeec13d62c7649edf069cd3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQK4s0lOiK1ZkcXxFNIMDQ.png"/></div></div></figure><p id="9248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">机器学习开发中最大的被低估的挑战之一是在生产中以可扩展的方式部署训练好的模型。我读过的一个关于它的笑话是“如今机器学习最常见的部署方式是 powerpoint 幻灯片:)”。</p><h1 id="2d90" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">为什么是 Docker？</strong></h1><p id="4e33" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank"> Docker </a>是一个容器化平台，它将一个应用程序&amp;及其所有依赖项打包到一个容器中。</p><p id="9d95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">激活该容器导致应用程序被激活</em>。</p><p id="340e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你有一大堆以隔离方式工作的服务，并作为 web 应用程序的数据提供者时，就使用 Docker。根据负载情况，可以根据设置的规则按需剥离实例。</p><h1 id="004d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">为什么要用 Docker 做机器学习模型？</strong></h1><p id="4ba7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">常规软件应用程序的生产部署非常困难。如果那个软件是机器学习管道，那就更糟糕了！在今天的情况下，你无法摆脱机器学习，因为这是你在业务中可以获得的最大竞争优势。在生产中，一个机器学习驱动的应用程序可能会出于多种目的使用多个模型。可以通过 docker 处理的机器学习模型部署中的一些主要实际挑战有:</p><ol class=""><li id="026e" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka ir">不同型号的环境不一致。</strong></li></ol><p id="64d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些情况下，对于一个模型，您需要将 LANG_LEVEL 设置为“c ”,而对于另一个模型，LANG_LEVEL 应该为“en_us”。UTF 8 英尺高。将不同的模型放入不同的容器中，以便获得不同模型的<strong class="ka ir">隔离环境</strong>。</p><p id="638a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。模型间不一致的库需求。</strong></p><p id="c19d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您已经使用 tensorflow 1.10 开发了一个文本摘要器。现在我们想用 tensorflow2.0 支持的迁移学习进行情感分析(假设)。将它们放在不同的容器中不会破坏应用程序。</p><p id="9eb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个主要的用例是，你用 python 开发 ML 模型。但是你想用 Go 语言做的应用(为了一些技术优势)，那么通过 docker 把 ml 模型暴露给 app 就解决了。</p><p id="6085" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。不同型号的资源需求不一致。</strong></p><p id="98e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你有一个非常复杂的对象检测模型，需要 GPU，你有 5 个不同的神经网络，用于其他目的，适合在 CPU 上运行。然后在容器中部署模型时，您可以根据需求灵活地分配资源。</p><p id="38e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。跨模型的不一致流量。</strong></p><p id="35d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您有一个问题标识符模型和答案生成模式，前者调用频繁，而后者调用不频繁。那么你需要比答案生成器更多的问题标识符实例。这可以由 docker 轻松处理。</p><p id="d173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个场景是，上午 10 点你的模型有 10000 个请求，而晚上 8 点只有 100 个。因此，您需要根据您的需求剥离更多的服务实例，这在 docker 中更容易。</p><p id="cd4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 5。模型级缩放</strong></p><p id="971a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你有一个每秒处理 100000 个请求的统计模型，而一个每秒能够处理 100 个请求的深度学习模型。那么对于 10000 个请求，你只需要纵向扩展深度学习模型。这可以由 docker 来完成。</p><p id="7ed5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看如何创建深度学习模型的容器。在这里，我建立的模型是在 http://cogcomp.org/Data/QA/QC/的<a class="ae lz" href="http://cogcomp.org/Data/QA/QC/" rel="noopener ugc nofollow" target="_blank">可用的问题分类器数据集上的问题主题标识符。Google 的通用句子编码器用于单词嵌入。</a></p><p id="91c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为模型创建容器时，通常必须遵循的工作流程是:</p><ol class=""><li id="2ed2" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">建立和训练模型。</li><li id="0b24" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">创建模型的 API。(这里我们把它放在一个 flask API 中)。</li><li id="19a7" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">创建包含所有必需库的需求文件。</li><li id="4232" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">使用必要的环境设置和启动操作创建 docker 文件。</li><li id="c335" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">建立 docker 形象。</li><li id="ebb8" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">现在运行容器，并在完成后跳舞:)</li></ol><div class="mp mq gp gr mr ms"><a href="https://github.com/sambit9238/QuestionTopicAnalysis" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">sambit 9238/QuestionTopicAnalysis</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">发现问题主题在各种用例中起着重要的作用，从问答系统到回答…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jw ms"/></div></div></a></div><p id="e861" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">建立并训练模型。</strong></p><p id="046b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了建立和训练模型，基本的工作流程是获取数据，对数据进行清理和处理，然后将数据提供给模型架构，以获得训练好的模型。</p><p id="3fa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我在 http://cogcomp.org/Data/QA/QC/<a class="ae lz" href="http://cogcomp.org/Data/QA/QC/" rel="noopener ugc nofollow" target="_blank">的 TREC 数据集上建立了一个问题意图分类器模型。训练数据有 6 个意图，每个意图的实例数如下:</a></p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="e5b3" class="nq kx iq nm b gy nr ns l nt nu">Counter({'DESC': 1162,<br/>         'ENTY': 1250,<br/>         'ABBR': 86,<br/>         'HUM': 1223,<br/>         'NUM': 896,<br/>         'LOC': 835})</span></pre><p id="215c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以在<a class="ae lz" href="https://github.com/sambit9238/QuestionTopicAnalysis/blob/master/question_topic.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/sambit 9238/QuestionTopicAnalysis/blob/master/question _ topic . ipynb</a>查看模型创建</p><p id="5105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里遵循的处理步骤是:</p><ol class=""><li id="2dc8" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">处理宫缩就像我会，我已经等。</li><li id="a8b3" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">处理超链接、邮件地址等。</li><li id="c2a8" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">处理数字和身份证。</li><li id="f7e2" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">处理标点符号。</li></ol><p id="478e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于嵌入，<a class="ae lz" rel="noopener" target="_blank" href="/use-cases-of-googles-universal-sentence-encoder-in-production-dd5aaab4fc15">使用了来自 tensorflow-hub 的 Google 通用句子编码器。</a></p><p id="dca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遵循的模型结构是具有两个隐藏层的神经网络，每个隐藏层具有 256 个神经元。为了避免过度拟合，使用 L2 正则化。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="5ef5" class="nq kx iq nm b gy nr ns l nt nu">Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>input_1 (InputLayer)         (None, 1)                 0         <br/>_________________________________________________________________<br/>lambda_1 (Lambda)            (None, 512)               0         <br/>_________________________________________________________________<br/>dense_1 (Dense)              (None, 256)               131328    <br/>_________________________________________________________________<br/>dense_2 (Dense)              (None, 256)               65792     <br/>_________________________________________________________________<br/>dense_3 (Dense)              (None, 6)                 1542      <br/>=================================================================<br/>Total params: 198,662<br/>Trainable params: 198,662<br/>Non-trainable params: 0<br/>_________________________________</span></pre><p id="a6fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模型存储在. h5 文件中以供重用。标签编码器存储在 pickle 文件中以供重用。</p><p id="57e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建模型的 API。(这里我们把它放在一个 flask API 中)。</strong></p><p id="a322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">存储的模型放在 Flask api 中，以便可以在生产中使用(<a class="ae lz" href="https://github.com/sambit9238/QuestionTopicAnalysis/blob/master/docker_question_topic/app.py" rel="noopener ugc nofollow" target="_blank">https://github . com/sambit 9238/QuestionTopicAnalysis/blob/master/docker _ question _ topic/app . py</a>)。)</p><p id="1034" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API 需要一个文本列表，因为在实时使用时会出现多个句子。它经过清洗和处理后被送入预测系统。预测结果被缩放以表示每个意图的置信度百分比。然后，缩放后的结果以 JSON 格式发送。</p><p id="4f51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子，</p><p id="9fff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输入:【“你工资多少？”]</p><p id="5beb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:{'ABBR': 0.0012655753，' DESC': 0.0079659065，' ENTY': 0.011016952，'哼':0.028764706，' LOC': 0.013653239，' NUM': 0.93733364}</p><p id="9340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着模型有 93%的把握认为这个问题的答案应该是一个<strong class="ka ir">数字</strong>。</p><p id="d2c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建包含所有所需库的需求文件。</strong></p><p id="6b9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建 Docker 映像来服务我们的 API，我们需要创建一个需求文件，其中包含所有使用过的库及其版本。</p><p id="3d88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建具有必要环境设置和启动操作的 Dockerfile 文件。</strong></p><p id="8914" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir"> Dockerfile </strong>是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。</p><p id="8660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的示例，预构建的 python-3.6 映像被用作基础映像。然后，已经下载了预先训练的通用语句编码器模型文件，随后安装了所需的库。docker 的 5000 端口是公开的，这是 flask app 在默认配置下运行的端口。</p><p id="7a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">打造 docker 形象。并运行容器</strong></p><p id="7e47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们在一个目录中有了 Dockerfile、flask API 和经过训练的模型文件。因此，我们需要从中创建 docker 图像。该命令可以是:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9bed" class="nq kx iq nm b gy nr ns l nt nu">docker build -t question_topic .<br/>#the last option is location of the directory. Since I am in the directory so '.' is put, which represents current directory in unix.</span></pre><p id="312c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在 docker 映像已经创建，我们需要在容器<code class="fe nv nw nx nm b">docker run -p 8888:5000 --name question_topic question_topic</code>中运行该映像</p><p id="7384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将使创建的 docker 映像运行。docker 中的端口 5000 映射到主机的 8888 端口。因此，API 将在端口 8888 接收和响应请求。如果您想在后台运行 docker 并将其从命令提示符中分离出来(这将是实时的情况)，请使用'-d '选项运行它。</p><p id="0054" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了检查 docker 的输出，让我们使用 curl 发送一个 post 请求。</p><p id="3a33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输入:</p><p id="5e3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提供输入，curl—request POST<br/>—URL<a class="ae lz" href="http://0.0.0.0:8888/predict_topic" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:8888/predict _ topic</a><br/>—header ' content-type:application/JSON '<br/>—data ' { " raw text _ list ":["您现在在哪里工作？"，“你的工资是多少？”]}'</p><p id="bf6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><p id="4bcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">{</p><p id="cf92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">" input": "['你现在在哪里工作？'，‘你的工资是多少？’]",</p><p id="26ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“output”:“[{ ' ABBR ':0.0033528977，' DESC': 0.0013749895，' ENTY': 0.0068545835，'哼':0.7283039，' LOC': 0.25804028，' NUM': 0.0020733867}，</p><p id="e0c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">{'ABBR': 0.0012655753，' DESC': 0.0079659065，' ENTY': 0.011016952，'哼':0.028764706，' LOC': 0.013653239，' NUM': 0.93733364} ]"</p><p id="1787" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">}</p><p id="24a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看来 docker 运行良好:)</p><p id="7b6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">备注:</strong></p><p id="0625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提到的例子还没有准备好投入生产。但是，通过以下几个步骤，它就可以投入生产了:</p><ol class=""><li id="668d" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">在模型级别，可以进行更多的处理和模型超参数调整，以使模型更好。</li><li id="4fa5" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在 API 级别，不需要在每次请求时初始化会话和变量。通过大幅缩短 API 的响应时间，可以在应用启动时完成一次。</li><li id="697d" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在 docker 级别，Docker 文件没有优化，因此 Docker 映像在大小上可能比要求的要大。</li></ol></div></div>    
</body>
</html>