<html>
<head>
<title>Building a Stable and User Friendly API for your Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的模型构建一个稳定且用户友好的 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e?source=collection_archive---------12-----------------------#2019-07-24">https://towardsdatascience.com/building-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e?source=collection_archive---------12-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/99838839027393f04df1cb4b9a6aa619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRC6tdXpTekQ6X7qdUDehg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://pixabay.com/photos/milky-way-starry-sky-night-sky-star-2695569/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><div class=""/><div class=""><h2 id="588f" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">你的模型值得一个伟大的 API</h2></div><p id="3d95" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数(如果不是全部)数据科学家最终都需要部署他们的模型，并通过 API 使其可用。在机器学习项目的端到端过程中，这通常是最容易被忽视的部分，因为大多数注意力都集中在建立模型或可怕的数据清理上。构建一个稳定且用户友好的 API 是让用户/产品团队开始消费你的服务并持续消费的关键。那么，如何着手构建一个稳定且用户友好的 API 呢？这就是这篇文章的来源，这些年来，我专门为数据科学模型构建了许多 API，我想与您分享我是如何着手构建它们的。本文假设了以下情况:</p><ul class=""><li id="f7a8" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">Python 知识</li><li id="cd24" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">烧瓶的基本知识</li></ul><p id="0a3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你还没有猜到，我们将使用 Python 和 Flask 来构建 API，所有代码都可以在我的<a class="ae jg" href="https://github.com/harpalsahota/DataScience/tree/master/Model_API_Example" rel="noopener ugc nofollow" target="_blank"> GitHub 账户</a>上找到。</p><h1 id="57d8" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">问题背景</h1><p id="adfc" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们建立了一个(非常粗糙的)随机森林模型来预测房价。这个模型有三个特点:<code class="fe nf ng nh ni b">is_house</code>、<code class="fe nf ng nh ni b">has_garden</code>和<code class="fe nf ng nh ni b">n_bedrooms</code>。<code class="fe nf ng nh ni b">is_house </code>和<code class="fe nf ng nh ni b">has_garden</code>都是二进制标志，而<code class="fe nf ng nh ni b">n_bedrooms</code>是整数。向利益相关者展示该模型给他们留下了深刻的印象，现在他们希望进入下一阶段，即通过 API 进行质量保证。现在，您的任务是为您的模型构建一个 API。</p><h1 id="cb00" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">文件夹结构</h1><p id="fecb" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我的 API 通常遵循这种文件夹结构。我试图让它尽可能简单，同时也让它易于扩展:</p><ul class=""><li id="e65d" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">common</code>:保存常用的模块/类，可以与代码库的其他部分共享(例如，代码库中可能有多个 API)</li><li id="8b76" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">endpoint_docs</code>:保存端点文档的 YAML 文件(我们稍后会讲到)</li><li id="545c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">views</code>:保存 API 视图的模块</li><li id="f7f2" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">api.py</code>:本地启动 API</li><li id="3439" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">blueprint.py</code>:用于使您的应用程序模块化，并为您的端点生成 URL 前缀</li><li id="66f4" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">config.yml.example</code>:保存应用程序配置的示例文件</li><li id="bd51" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">Pipfile</code>:API 需要的包</li><li id="18fa" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">settings.py</code>:用于从您的配置文件导入设置</li><li id="c789" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">wsgi.py</code>:用于启动生产服务器</li><li id="2382" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">.env.example</code>:保存环境变量</li></ul><p id="4e2a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在本地安装并运行，请查看 repo 上的自述文件，其中给出了安装说明。</p><h1 id="7be6" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">配置和设置文件</h1><p id="a7b6" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这可能看起来像是构建 API 的一个非常无聊的方面，确实如此，但是从一开始就正确地配置 API 确实有助于以后的工作。这里涉及的三个文件是 API 配置:</p><ul class=""><li id="39df" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">配置. yml .示例</li><li id="a329" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">. env .示例</li><li id="d585" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">settings.py</li></ul><p id="4d7a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">config.yml</code>和<code class="fe nf ng nh ni b">.env</code>文件包含应用程序的应用程序设置和环境变量，其中可能包含敏感信息。我们不希望这些信息出现在存储库中，所以我们创建了示例文件，其中省略了敏感信息。例如，<code class="fe nf ng nh ni b">config.yml</code>文件可能包含一个数据库密码:<code class="fe nf ng nh ni b">DB_PASSWORD: XXXXX</code>，但是在<code class="fe nf ng nh ni b">config.yml.example</code>中这个密码将是:<code class="fe nf ng nh ni b">DB_PASSWORD:</code>。密码被删除，但与之相关的变量被保留，这使得应用程序的新用户更容易启动和运行，因为这突出了应用程序所需的配置。要使用这些文件，你需要做的就是复制它们，但是去掉后缀<code class="fe nf ng nh ni b">.example</code>重新命名它们。在我的<code class="fe nf ng nh ni b">config.yml</code>文件中，我只有一个名为<code class="fe nf ng nh ni b">MODEL_NAME</code>的变量，这只是我们希望使用的模型的名称。在<code class="fe nf ng nh ni b">config.yml</code>文件中，用<code class="fe nf ng nh ni b">rf_classifier.pkl</code>填写<code class="fe nf ng nh ni b">MODEL_NAME </code>。在<code class="fe nf ng nh ni b">.env</code>文件中，将<code class="fe nf ng nh ni b">APP_SETTINGS_YAML</code>分配给<code class="fe nf ng nh ni b">config.yml</code>。最后，确保<code class="fe nf ng nh ni b">config.yml</code>和<code class="fe nf ng nh ni b">.env </code>文件都在您的<code class="fe nf ng nh ni b">.gitignore</code>文件中，这样它们就不会被意外地推到存储库中。</p><p id="25f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">settings.py</code>文件是 API 对这些变量的访问点(如下所示)。以下代码部分的第 9-14 行加载到<code class="fe nf ng nh ni b">.env</code>文件中，并有一个用于<code class="fe nf ng nh ni b">MODEL_NAME</code>的占位符，默认为<code class="fe nf ng nh ni b">None</code>:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="175c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，获得<code class="fe nf ng nh ni b">APP_SETTING_YAML</code>(在<code class="fe nf ng nh ni b">.env</code>文件中定义)的值(第 17 行)，该值为<code class="fe nf ng nh ni b">config.yml</code>。然后读取该文件并提取键值对(第 18–20 行)。然后，<code class="fe nf ng nh ni b">config.yml</code>中的这些键值对被用来更新<code class="fe nf ng nh ni b">settings.py</code>文件中的值。占位符为<code class="fe nf ng nh ni b">None</code>的变量是要更新的变量。</p><p id="7db5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">MODEL_NAME</code>的初始值是<code class="fe nf ng nh ni b">None</code>，但是在读入<code class="fe nf ng nh ni b">config.yml</code>文件并更新全局值后，它现在被设置为<code class="fe nf ng nh ni b">rf_classifier.pkl</code>。要访问这个变量，您在应用程序中要做的就是:</p><pre class="nj nk nl nm gt np ni nq nr aw ns bi"><span id="be1c" class="nt mj jj ni b gy nu nv l nw nx"><em class="ny">import </em>settings<br/>print(settings.MODEL_NAME)</span></pre><p id="b4a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里需要注意的重要一点是<code class="fe nf ng nh ni b">settings.py</code>中定义的应用变量名必须与<code class="fe nf ng nh ni b">config.yml</code>中的键名完全匹配，否则<code class="fe nf ng nh ni b">settings.py</code>中的变量不会被更新。</p><p id="c307" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第 22–24 行的最后一段代码实际上查看了您的操作系统中定义的环境变量，并使用这些变量覆盖来自<code class="fe nf ng nh ni b">config.yml</code>的派生变量。我听你说，你为什么要这么做？当您通常部署到生产环境时，可能会有不同的应用程序设置，如生产数据库用户名和密码或端口号等，您不会在本地使用这些设置。你需要做的不是有第二个<code class="fe nf ng nh ni b">config.yml</code>文件，而是在你的操作系统环境中定义这些相同的变量。这允许您在用于本地开发的设置和用于生产的设置之间轻松切换，而无需更改任何应用程序代码。这里要记住的一个关键点是，在操作系统环境中定义的变量优先于在<code class="fe nf ng nh ni b">config.yml</code>文件中定义的变量。</p><h1 id="3b53" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated"><strong class="ak">常用文件夹</strong></h1><p id="705e" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">该文件夹包含 python 模块，这些模块具有与其他 API 相同的功能。因此，如果您要为这个项目添加另一个 API，比如说为另一个模型添加 API，您就不必重复代码。让我们从<code class="fe nf ng nh ni b">schemas.py</code>开始分解这个文件夹中的模块</p><h2 id="2249" class="nt mj jj bd mk nz oa dn mo ob oc dp ms lh od oe mu ll of og mw lp oh oi my oj bi translated">schemas.py</h2><p id="2df8" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">该模块使用<a class="ae jg" href="https://marshmallow.readthedocs.io/en/3.0/" rel="noopener ugc nofollow" target="_blank"> marshmallow </a>包将数据加载到我们定义的模式中。Marshmallow 将根据模式检查数据，如果发现任何不一致，将会引发错误。通过对照模式验证数据，我们确保 API 的消费者符合模型被训练的特性范围。这很好，因为它防止 API 的消费者向模型传递意外的参数，从而获得奇怪的结果，这些结果可能会在以后的报告中使用。我们模型的模式如下所示:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5810" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先创建一个从 marshmallow 继承了<code class="fe nf ng nh ni b">Schema</code>类的类，这将允许我们创建自己的模式。接下来，模式的变量(模型的特征)被定义并被赋予字段对象。字段对象简单地定义了对象的类型，例如字符串，甚至是字段接受的另一个模式的整数。它们还可以通过传递带有布尔值的关键字参数<code class="fe nf ng nh ni b">required</code>来声明一个字段是否是强制的。这里我们创建三个变量<code class="fe nf ng nh ni b">is_house</code>、<code class="fe nf ng nh ni b">has_garden,</code>和<code class="fe nf ng nh ni b">n_bedrooms</code>，它们在第 13-15 行声明，并根据需要标记。这三个变量都定义了一个整数类型。接下来，我们创建三个函数来验证每一个特性，这些函数的名字前面都有前缀<code class="fe nf ng nh ni b">validate</code>，这不是必须的，只是我自己命名的。这些函数是用<code class="fe nf ng nh ni b">@validates</code>方法修饰的，该方法接受一个参数，该参数是您希望作为类型字符串进行验证的特性的名称。只有用<code class="fe nf ng nh ni b">@validates</code>包装的函数用于验证数据，并且字符串输入必须是在类顶部定义的变量。作为修饰函数的结果，它们现在接受一个位置参数，这里定义为<code class="fe nf ng nh ni b">value</code>。这是传递给每个特性的值，我们根据它执行验证。<code class="fe nf ng nh ni b">is_house</code>和<code class="fe nf ng nh ni b">has_garden</code>都是二进制标志，具有完全相同的检查，只有错误消息不同(第 17-25 行)。</p><p id="556f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果<code class="fe nf ng nh ni b">validate_is_house</code>中的 if 语句返回 true，就会产生一个错误，并显示一条特定的消息:<code class="fe nf ng nh ni b">is_house must be either 0 or 1</code>。然后可以将错误消息返回给客户端。这种错误信息为用户提供了有用的调试信息，而不是一般的 HTTP 错误信息。<code class="fe nf ng nh ni b">n_bedrooms</code>验证(第 27–30 行)验证该值是否大于或等于零，如果不大于或等于零则引发错误。</p><p id="29cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方法<code class="fe nf ng nh ni b">make_price_prediction_data_model</code>在模式检查通过后运行。这是由<code class="fe nf ng nh ni b">@posts_loads</code>装饰者定义的。该函数的执行返回包含特征的数据类对象。这是查看<code class="fe nf ng nh ni b">data_models.py</code>中定义的数据类的好时机</p><h2 id="89eb" class="nt mj jj bd mk nz oa dn mo ob oc dp ms lh od oe mu ll of og mw lp oh oi my oj bi translated">data_models.py</h2><p id="a35b" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如上所述，一旦模式检查通过，数据模型就会以数据类的形式返回。如果你不知道什么是数据类，我强烈推荐你查看这个<a class="ae jg" href="https://hackernoon.com/a-brief-tour-of-python-3-7-data-classes-22ee5e046517" rel="noopener ugc nofollow" target="_blank">帖子</a>。数据类为我们提供了开箱即用的附加功能，还允许我们通过名称访问类的属性，就像普通的类一样。我们模型的数据类如下所示:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7730" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里没什么事情。我们定义了一个由<code class="fe nf ng nh ni b">@dataclass</code>包装的类，并在该类中定义了三个变量，它们是该类的属性。在我们的例子中，这些属性是模型的特征。我还定义了一个<code class="fe nf ng nh ni b">__repr__</code>方法来给我们一个有用的类表示。就像普通的类一样，如果需要的话，你可以添加额外的方法。</p><h2 id="78d1" class="nt mj jj bd mk nz oa dn mo ob oc dp ms lh od oe mu ll of og mw lp oh oi my oj bi translated">logger.py</h2><p id="458b" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">最后一个模块是<code class="fe nf ng nh ni b">common</code>文件夹，是日志文件。该文件只包含几行设置记录器的代码:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c1ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我设置了一个带有<code class="fe nf ng nh ni b">StreamHandler</code>的日志记录器来记录控制台。如果您愿意，您可以设置一个记录器来记录文件，请参考文档中的<a class="ae jg" href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="noopener ugc nofollow" target="_blank">基础教程</a>来告诉您如何操作。</p><h1 id="8867" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">时髦的</h1><p id="cf56" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">有了定义的模式，用户如何预先知道什么是模型可接受的输入？此外，用户如何为您的 API 探索其他端点？这就是<a class="ae jg" href="https://swagger.io/solutions/api-design/" rel="noopener ugc nofollow" target="_blank">霸气</a>的用武之地。通过在 API 中实现 Swagger，我们为 API 提供了一个可视端点，列出了所有可用的端点以及它们接受的 HTTP 方法。此外，对于每个端点，您可以提供要运行的模式和示例，本质上是记录 API。下面是我们正在构建的 API 的 Swagger 页面的屏幕截图:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/c73af9c81726d520f9d2ef178e290e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQ3rS_4xoXeLr9Jn2AHUuQ.png"/></div></div></figure><p id="511e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何实现 swagger for out API？好消息是，有一些软件包可以帮我们做到这一点，比如<a class="ae jg" href="https://github.com/rochacbruno/flasgger" rel="noopener ugc nofollow" target="_blank"> Flassager </a>和<a class="ae jg" href="https://github.com/zalando/connexion" rel="noopener ugc nofollow" target="_blank">connection</a>。对于我们的 API，我们将使用 Flassager。</p><h2 id="0ac2" class="nt mj jj bd mk nz oa dn mo ob oc dp ms lh od oe mu ll of og mw lp oh oi my oj bi translated">招摇文件</h2><p id="bf99" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">为了让 swagger 显示信息，我们需要为它提供文档。该文件以<code class="fe nf ng nh ni b">yaml</code>文件格式提供，位于<code class="fe nf ng nh ni b">endpoint_docs</code>文件夹中。如果您导航到在<code class="fe nf ng nh ni b">/endpoint_docs/property_price_prediction_v1/get.yml</code>找到的文件，您将找到上面显示的该端点的文档。该文件中包含端点的参数以及响应示例。有关记录端点的更多信息，请参见<a class="ae jg" href="https://swagger.io/docs/specification/2-0/basic-structure/" rel="noopener ugc nofollow" target="_blank"> swagger 文档</a></p><h1 id="6996" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">创建端点</h1><p id="e81a" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">现在我们来看 api 本身的代码。让我们从位于<code class="fe nf ng nh ni b">/views/property_price_prediction.py</code>的 API 的唯一端点开始。该文件包含一个定义端点的类:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0a70" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">ProperyPricePrediction</code>类从<code class="fe nf ng nh ni b">flassagger</code>继承了<code class="fe nf ng nh ni b">SwaggerView</code>，后者也从 Flask 继承了<a class="ae jg" href="http://flask.pocoo.org/docs/1.0/views/#method-views-for-apis" rel="noopener ugc nofollow" target="_blank">方法视图</a>。方法视图允许我们使用同一个端点在一个类中接受不同的 HTTP 方法。要做到这一点，我们首先需要定义以它们所服务的方法命名的函数。例如，在上面的代码中，这个端点接受 GET 方法，所以我定义了一个名为<code class="fe nf ng nh ni b">get</code>的函数。如果我想让这个端点也接受一个<code class="fe nf ng nh ni b">POST</code>方法，我要做的就是在这个类中定义一个<code class="fe nf ng nh ni b">post</code>方法，并将<code class="fe nf ng nh ni b">POST</code>添加到在类顶部创建的<code class="fe nf ng nh ni b">methods</code>变量中。这个变量对于 method 视图来说不是必需的，但是对于 swagger 来说是必需的，所以如果你没有使用 swagger，你可以省略它。如果你使用的是 swagger，那么它现在希望文档存在于一个名为<code class="fe nf ng nh ni b">get.yml</code>的文件中，你可能已经猜到了，但是这些文件是以它们所服务的 HTTP 方法命名的。下面的蓝图部分解释了<code class="fe nf ng nh ni b">get.yml</code>文件的目录结构。</p><p id="6f4a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转到<code class="fe nf ng nh ni b">def get</code>方法。这个函数中的代码被封装在一个<code class="fe nf ng nh ni b">try/except</code>块中，以防止在任何处理过程中出现错误时 API 关闭。这个方法获得模型的输入，作为第 21 行定义的 URL 参数，并将它转换成一个字典。接下来的第(22)行将这个特性加载到模式中，模式反过来验证输入。如果失败，验证错误出现，在<code class="fe nf ng nh ni b">try/except</code>块中捕获并返回给用户。如果通过，数据将被加载到数据模型中，该模型现在可用于进行预测。下一行代码使用数据模型进行预测(第 23— 27 行)。请注意，我们现在可以通过名称来引用特性，这样在代码中看起来更好。然后，预测作为 JSON 对象返回给用户。</p><p id="76b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在文件的顶部，我导入了设置模块。在这个模块中定义了一个全局变量<code class="fe nf ng nh ni b">MODEL_NAME</code>。该变量表示要使用的模型名称，该名称随后被分配给<code class="fe nf ng nh ni b">MODEL</code>变量。我将<code class="fe nf ng nh ni b">MODEL_NAME</code>定义为一个 API 配置，因为它可以通过简单地改变应用程序中的配置而不是源代码，轻松地在不同模型之间快速切换。<code class="fe nf ng nh ni b">MODEL</code>变量是在类的外部定义的，因为我们只需要模型加载一次。如果这是在<code class="fe nf ng nh ni b">get</code>方法中定义的，这将意味着每次请求进来时都要加载模型。这将大大降低请求的响应时间，尤其是在模型很大的情况下。</p><h1 id="ef9d" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">蓝图</h1><p id="f575" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">蓝图允许我们模块化我们的应用程序路线，例如，我们可能有一个仅供管理员使用的蓝图和一个供用户使用的蓝图，因此分离路线。为了实现这一点，我们需要创建蓝图并向它们注册端点，在<code class="fe nf ng nh ni b">blueprints.py</code>中的代码为我们做了这些:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d883" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，要创建一个蓝图，您所要做的就是创建一个<code class="fe nf ng nh ni b">Blueprint</code>类的实例，并用<code class="fe nf ng nh ni b">add_url_rule</code>方法向它注册端点。在上面的代码中，我通过创建自己的继承 Flask 的<code class="fe nf ng nh ni b">Blueprint</code>类的<code class="fe nf ng nh ni b">BaseBlueprint</code>类来扩展<code class="fe nf ng nh ni b">Blueprint</code>类。我这样做是为了让日志记录更容易。Flask 的 Blueprint 类有两个方法<code class="fe nf ng nh ni b">before_request</code>和<code class="fe nf ng nh ni b">after_request</code>，如果分配给方法，它们将分别在请求之前和之后被调用。在<code class="fe nf ng nh ni b">BaseBlueprint</code>类的<code class="fe nf ng nh ni b">__init__</code>方法中，我调用这两个方法，并分配<code class="fe nf ng nh ni b">_log_before_request</code>在每个请求之前调用，而<code class="fe nf ng nh ni b">_log_after_request</code>在每个请求之后调用。在<code class="fe nf ng nh ni b">_log_before_request</code>方法中，我记录了与任何参数一起被调用的端点。<code class="fe nf ng nh ni b">_log_after_request</code>方法记录 HTTP 响应状态和返回的 JSON 负载。对于单个端点来说，这似乎是一项繁重的工作，但是如果我们要向 API 添加新的端点，我们所要做的就是将新的视图作为一项规则添加到这个<code class="fe nf ng nh ni b">BaseBlueprint</code>实例中(实际上只有一行代码),并且我们已经实现了日志记录！这使得扩展 API 的日志更加容易。我发现这个解决方案比在视图函数本身中实现日志记录要优雅得多。</p><p id="bc1b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在需要做的就是创建一个<code class="fe nf ng nh ni b">BaseBlueprint</code>类的实例，这是在第 31 行完成的。然后，我们获取该实例并向其添加一个 URL 规则(第 33–36 行)，这意味着每次调用该 URL 时，都会调用分配的视图函数。<code class="fe nf ng nh ni b">add_url_rule</code>方法接受一个位置参数，它是一个字符串，是这个端点的 URL。我还添加了一个关键字参数<code class="fe nf ng nh ni b">view_func</code>，它接受我们想要分配给这个 URL 的<code class="fe nf ng nh ni b">MethodView</code>(或者在我们的例子中是<code class="fe nf ng nh ni b">SwaggerView</code>)。在这里，我将<code class="fe nf ng nh ni b">PropertyPricePrediction</code>视图分配给这个 URL，并声明它是一个使用<code class="fe nf ng nh ni b">as_view</code>方法的视图。这样做是为了将类转换成路由系统可以使用的视图函数。这个方法中的关键字参数<code class="fe nf ng nh ni b">name</code>只是为这个视图指定一个名称。这里定义的名称也为 Swagger 搜索端点文档提供了参考。因为这个视图有一个<code class="fe nf ng nh ni b">get</code>方法，所以到<code class="fe nf ng nh ni b">get</code>文档的路径会有如下模式:<code class="fe nf ng nh ni b">&lt;name of view&gt;/&lt;HTTP method&gt;.yml</code>并且会转换成:<code class="fe nf ng nh ni b">property_price_prediction_v1/get.yml</code></p><h1 id="930f" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">api.py</h1><p id="3603" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">该文件是启动 API 的访问点，主要包含配置:</p><figure class="nj nk nl nm gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="057d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们一行一行地过一遍:</p><ul class=""><li id="35ce" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la jk">1–5</strong>:所需进口。注意，我导入了 Swagger 和我们在上面创建的蓝图</li><li id="39fa" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk"> 8 </strong>:创建一个 Flask 实例</li><li id="5dbb" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">10–15</strong>:允许所有前缀为<code class="fe nf ng nh ni b">/api</code>的 URL 上的跨来源请求</li><li id="aa03" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">17–20</strong>:注册我们在上面创建的蓝图，并为所有端点创建以<code class="fe nf ng nh ni b">/api</code>开头的前缀</li><li id="9346" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">21–23</strong>:有些霸气的配置。在这里，我告诉 Swagger 在哪里可以找到端点文档。</li><li id="aa75" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">24–34</strong>:围绕第 9 行创建的 Flask 实例创建一个 Swagger 实例。我将 parse 设置为<code class="fe nf ng nh ni b">False</code>，这意味着不根据端点文档中提供的模式检查传入的请求，因为我更喜欢 Marshmallow 的灵活性。当然，您可以将其设置为<code class="fe nf ng nh ni b">true</code>，所有传入的请求都将被检查。最后，我只是在 API 文档页面上提供一些元数据。</li><li id="9a4c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">36–41</strong>:只有当文件作为主程序运行时，才会启动 API。</li></ul><h1 id="e00f" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">wsgi.py</h1><p id="a33e" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这是最后的文件。在生产设置中启动 API 的文件。这个文件只导入 API 实例(从 api.py)。我将这一点分离出来，这样我们就可以在生产中进行不同的设置，并在需要时进行任何额外的检查。你可以直接运行<code class="fe nf ng nh ni b">api.py</code>，但是你将只使用 flask 的内部服务器，这不是我们想要的，并且<a class="ae jg" href="http://flask.pocoo.org/docs/1.0/tutorial/deploy/#run-with-a-production-server" rel="noopener ugc nofollow" target="_blank">不推荐</a>用于生产。相反，我们将使用一个名为<a class="ae jg" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> Gunicorn </a>的包，它是一个用于 UNIX 的 Python WGSI 服务器，与许多 python web 框架兼容。如果你在 Windows 上，你可以使用<a class="ae jg" href="https://docs.pylonsproject.org/projects/waitress/en/latest/#" rel="noopener ugc nofollow" target="_blank">女服务员</a>。启动 API 的调用如下:</p><p id="bab6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> Unix / Mac </strong> : <code class="fe nf ng nh ni b">gunicorn -b 0.0.0.0:5000 -w 1 wsgi:api</code></p><p id="2d35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">视窗</strong> : <code class="fe nf ng nh ni b">waitress-serve --listed=*5000 wsgi:api</code></p><p id="50f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在 Unix / Mac 上运行，应该会看到类似这样的内容:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/3167a8b0f5ab2746cf3d3cf635b03db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7tZwgE0hpBfAuBpBl5ygA.png"/></div></div></figure><p id="7dd5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">API 现在正在运行，如果您导航到<code class="fe nf ng nh ni b">http://localhost:5000/apidocs</code>，您应该会看到:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/cb6265e682b28badf06f148b379f3e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsLbirmbyJICronlqpPF7g.png"/></div></div></figure><p id="e2f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是显示 API 文档的页面。单击蓝色条将展开它，显示对模型执行查询的能力，如下所示:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/229e6fd3b784c44d52818a8e64915bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8r023yi6aufxrd-th2vXBw.png"/></div></div></figure><p id="307a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击“试用”将允许您输入特性值，输入以下特性值，然后点击“执行”(在您单击“试用”之前，按钮不会显示):</p><ul class=""><li id="3d0a" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">is_house</code> : 5</li><li id="b715" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">had_garden</code> : 1</li><li id="847c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">n_bedrooms</code> : 3</li></ul><p id="3850" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">is_house</code>的这个值对于我们的模型是无效的，当您点击 execute 时，它会抛出一个错误。再往下是示例 curl 请求，请求您刚刚输入的数据以及请求 url(示例 curl 请求直到执行查询后才会显示)。下面是来自服务器的实际响应。该示例如预期的那样应该返回 400 —错误:错误的请求以及该响应正文:</p><pre class="nj nk nl nm gt np ni nq nr aw ns bi"><span id="7482" class="nt mj jj ni b gy nu nv l nw nx">{<br/>  "error": "{'is_house': ['is_house must be either 0 or 1']}"<br/>}</span></pre><p id="606d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这正是我们想要的，一个清晰的错误被返回给用户，解释请求失败的原因。现在输入一些应该有效的值:</p><ul class=""><li id="9ff0" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">is_house</code> : 0</li><li id="7d31" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">had_garden</code> : 0</li><li id="7172" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nf ng nh ni b">n_bedrooms</code> : 2</li></ul><p id="b571" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后点击执行。在点击 execute 之后，curl 请求和请求 url 应该被更新。您还应该有一个状态代码为 200 的新响应主体，表示查询成功。响应正文应该类似于:</p><pre class="nj nk nl nm gt np ni nq nr aw ns bi"><span id="b288" class="nt mj jj ni b gy nu nv l nw nx">{<br/>  "data": {<br/>    "predicted_price": [<br/>      300000<br/>    ]<br/>  }<br/>}</span></pre><p id="bb35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显示给定输入要素时模型对此属性的值。现在，如果我们看一下打印到控制台的日志，您应该会看到:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/ebe556b347d1b2f369245c3a102c8bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWO1xTFWr7k843XbqRWLKQ.png"/></div></div></figure><p id="eedc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">日志揭示了对模型的请求、传递的参数以及请求是否失败。我们可以看到第一个失败的请求，因为<code class="fe nf ng nh ni b">is_house</code>必须是二进制值。接下来是我们的第二个请求，它满足模式并成功返回一个预测。</p><p id="945b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望你能明白为什么使用 Swagger 是你的 API 的一个必要工具，因为很少的工作你就能得到很多额外的功能，这是完全值得的。这个工具允许用户使用你的 API，查看它的约束，这将允许他们相应地计划他们的资源消耗。</p><h1 id="a6eb" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">结论</h1><p id="1fdb" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这里，我们构建了一个 API 来处理请求，并优雅地将错误返回给用户，使 API 更加透明，不再是一个黑盒。数据模式是一个很好的约束，因为这可以防止模型在它被训练的特性范围之外的意外使用，从而防止一些尴尬的问题。</p><p id="51b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！希望在这篇文章中，我已经向您展示了构建一个稳定且用户友好的 API 的重要性。最后，感谢您的阅读，如果您感兴趣，我可能会写一些关于为 API 添加测试的帖子，以及一篇关于集装箱化的帖子。</p></div></div>    
</body>
</html>