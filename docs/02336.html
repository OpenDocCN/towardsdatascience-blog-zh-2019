<html>
<head>
<title>Master the basics of machine learning by solving a hackathon problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过解决黑客马拉松问题掌握机器学习的基础知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/master-basics-of-machine-learning-by-solving-a-hackathon-problem-fca16768083e?source=collection_archive---------6-----------------------#2019-04-17">https://towardsdatascience.com/master-basics-of-machine-learning-by-solving-a-hackathon-problem-fca16768083e?source=collection_archive---------6-----------------------#2019-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="413c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何一步一步解决回归问题，并在黑客马拉松排行榜中获得体面的排名</h2></div><p id="684e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">黑客马拉松是在短时间内学习和实现新概念的好方法。今天，我们将讨论机器学习的基本步骤，以及如何在试图使用 MachineHack 黑客马拉松的数据集获得体面排名的同时，获得回归问题的良好准确性。</p><p id="eac0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决任何机器学习问题的基本步骤是</p><ol class=""><li id="5758" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kh ir">识别目标和独立特征</strong></li><li id="683a" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">清理数据集</strong></li><li id="eebb" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">特征工程</strong></li><li id="828c" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">特征编码和缩放</strong></li><li id="ada4" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">功能选择</strong></li><li id="ff76" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">检查目标变量的分布</strong></li><li id="74a6" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">从图表中获得微调特性的洞察力</strong></li><li id="c92a" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">模型应用和超参数整定</strong></li><li id="21db" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kh ir">组合不同的模型</strong></li></ol><p id="47ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唷…要涵盖很多步骤，初学者很容易被吓倒…所以让我们深入这个问题，一步一步来…</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8586" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过在<a class="ae lw" href="https://www.machinehack.com/register/" rel="noopener ugc nofollow" target="_blank"> MachineHack </a>网站上创建帐户来下载数据集，并通过注册以下黑客马拉松来下载数据集:- <a class="ae lw" href="https://www.machinehack.com/course/predict-the-flight-ticket-price-hackathon/" rel="noopener ugc nofollow" target="_blank">机票价格预测</a></p><p id="7a08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您从黑客马拉松获得的 zip 文件中提供了 3 个文件:-</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/c5418df5ce07772e76ea5431806d85ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*7uoZJNa_V2CuOoxT6AQTow.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Files provided in the dataset: 1)Data_train.xlsx 2)Sample_submission 3)Test_set</figcaption></figure><p id="0ace" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<code class="fe me mf mg mh b">Data_Train.xlsx</code>包含我们需要用来训练模型的数据集，<code class="fe me mf mg mh b">Sample_submission</code>顾名思义指定了在黑客马拉松中需要提交的输出的格式，<code class="fe me mf mg mh b">Test_set</code>是我们需要应用我们的模型来预测机票价格的数据集，我们在黑客马拉松中的分数将基于该数据集进行评估。</p><p id="7b47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们需要记住的一件事是，无论我们将对<code class="fe me mf mg mh b">Data_Train</code>数据集特征应用何种转换，都需要对<code class="fe me mf mg mh b">Test_set</code>数据集应用相同的转换，以便模型从两者获得相似类型的输入。</p><p id="58f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，从 GitHub 资源库下载 juptyer 笔记本，该资源库详细介绍了上述所有步骤:</p><p id="2def" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lw" href="https://github.com/saurabhnative/MachineHack-2019-Flight-Price-Prediction-Hackathon" rel="noopener ugc nofollow" target="_blank">黑客马拉松问题解决方案</a></p><p id="4c8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，如果你已经走到这一步，这意味着你对学习新事物是认真的，那么在另一个标签中开始一些好听的音乐，进入<strong class="kh ir"> <em class="mi">区</em> </strong>让我们开始吧…</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mj lv l"/></div></figure><p id="3845" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.<strong class="kh ir">识别目标和独立特征</strong></p><p id="70e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决任何机器学习问题的第一步是识别源变量(自变量)和目标变量(因变量)。</p><p id="cec9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在机器学习环境中，目标变量是应该输出的变量。例如，如果进行分类，它可以是二进制 0 或 1；如果进行回归，它可以是连续变量。</p><p id="78b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">独立变量<em class="mi">(也称为特征)</em>是被分析过程的输入。</p><p id="f7e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在官方网站上获得了关于数据集的以下信息:-</p><p id="7a60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">训练集的大小:10683 条记录</p><p id="7526" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试集大小:2671 条记录</p><p id="61b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">特性</strong> : <br/>航空公司:航空公司的名称。</p><p id="3c51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旅行日期:旅行的日期</p><p id="3fd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Source:服务开始的来源。</p><p id="9a8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目的地:服务结束的目的地。</p><p id="fe52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">路线:航班到达目的地所采用的路线。</p><p id="bbf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dep_Time:旅程从源头开始的时间。</p><p id="b57e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到达时间:到达目的地的时间。</p><p id="f7df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">持续时间:飞行的总持续时间。</p><p id="fcd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Total_Stops:出发地和目的地之间的总停靠站数。</p><p id="f902" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Additional_Info:关于航班的附加信息</p><p id="46be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">价格:门票的价格</p><p id="2dc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用<code class="fe me mf mg mh b">pd.read_excel</code>命令在 jupyter 笔记本中导入数据集。你可以在这里找到关于在熊猫<a class="ae lw" href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html" rel="noopener ugc nofollow" target="_blank">中导入各种文件的信息。</a></p><p id="3c2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在 pandas 中使用<code class="fe me mf mg mh b">df.head()</code>命令来了解数据集中的列。请记住，我已经将我们用来训练模型的数据集的名称保留为<code class="fe me mf mg mh b">df_train</code></p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/b99613035923395ebe31b707a6982767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dwl2igKoZdrY8VZhoSMqHw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">df.head() is used to print first 5 rows of the dataset</figcaption></figure><p id="d961" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们可以看到价格列是目标变量，因为它有连续的值，也就是说，它不能被分类到特定的类别，这个问题是一个监督回归问题。</p><p id="2083" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2。清理数据集:</strong></p><p id="0c69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们使用<code class="fe me mf mg mh b">df.isnull()</code>命令检查数据集中缺失值的数量:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Check null values</figcaption></figure><p id="805c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们的数据集中只有一个空值，我只是简单地删除它，因为试图估算一个值似乎不是一个好的选择。</p><p id="c162" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是请记住，一般的经验法则是，如果任何特定列中超过 30%的值丢失，那么我们可以排除该列。</p><p id="ad78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 pandas 中，通过运行下面的命令很容易删除空值:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="61b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此处<code class="fe me mf mg mh b">inplace</code>参数用于隐式执行操作，即将操作直接应用于指定的数据帧。</p><p id="955e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们应该检查我们的数据集是否有任何重复的行并删除它们:-</p><p id="d856" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">df.duplicated()</code>用于查找数据帧中重复条目的总数。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Check duplicate rows</figcaption></figure><p id="82da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要通过运行以下命令删除重复的条目:-</p><pre class="lp lq lr ls gt mp mh mq mr aw ms bi"><span id="4779" class="mt mu iq mh b gy mv mw l mx my">#remove duplicate rows in training dataset<br/>df_train.drop_duplicates(keep='first',inplace=True)</span></pre><p id="8cd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<code class="fe me mf mg mh b">drop_duplicates</code>命令中，<code class="fe me mf mg mh b">keep='first'</code>选项允许我们保留第一次出现的行值，同时删除所有后续出现的行值。</p><p id="7f38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您还可以只通过在这一步查看数据集来删除不必要的列。在当前的数据集中，没有这样的列，所以我们可以继续。</p><p id="7195" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您观察笔记本的<strong class="kh ir"> <em class="mi">数据清理</em> </strong>部分中采取的步骤，我们已经合并了<code class="fe me mf mg mh b">Additional_Info</code>列中的重复值，并重命名了<strong class="kh ir"> <em class="mi"> Total_Stops </em> </strong>列中的值。</p><p id="dd90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3) <strong class="kh ir">特征工程:- </strong></p><p id="84e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特征工程是使用问题的领域知识和一点常识来创建新特征的过程，这些新特征可以增加机器学习模型的预测能力。这一步确实需要相当多的想象力，对输入特性的批判性思考，以及运用你的创造性。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mz lv l"/></div></figure><p id="adb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Date_of_Journey</code>列本身并不十分有用，但我们可以从中创建新的功能，如航班是否在周末、星期几和月份。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Feature engineering</figcaption></figure><p id="f881" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">惊叹声...这看起来像是一段很难理解的复杂代码…相信我，这不是我一个人想出来的，可能永远也不会。但这就是 StackOverflow 前来救援的地方。你可以从下面的链接中进一步阅读代码，因为这将有助于你</p><p id="5906" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a)理解在 python 中完成相同任务的各种方式</p><p id="c7b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b)以防明天这段代码变得多余或对你不起作用，猜猜哪个网站会帮助你找到解决方案😉</p><p id="1210" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链接:-</p><p id="1575" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1) <a class="ae lw" href="https://stackoverflow.com/questions/9847213/how-do-i-get-the-day-of-week-given-a-date-in-python" rel="noopener ugc nofollow" target="_blank">用 python 获取星期几</a></p><p id="9ab5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看熊猫的某一天是否是周末</p><p id="5a21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从熊猫的日期时间变量中获取年、月和日</p><p id="aa55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将持续时间列的值转换为分钟:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Feature engineering on duration column</figcaption></figure><p id="abb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您看一下<code class="fe me mf mg mh b">Duration</code>列，值的格式类似于<code class="fe me mf mg mh b">2h 50m</code>,一些行只包含小时值，而一些行只包含分钟值(就像某人如何享受不到一小时就结束的飞行，但这是改天讨论的问题)</p><p id="edcb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在上面的代码中，最初的 for 循环将小时和分钟部分分开，而第二个 for 循环用于将持续时间转换为分钟。</p><p id="25d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我甚至试着转换成秒来提高准确度，但是请不要遵循这些愚蠢的步骤，除非你有大量的空闲时间，并且一心想要提高排行榜上的排名👻</p><p id="4709" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建了一个名为<code class="fe me mf mg mh b">Duration_minutes</code>的新列，并从 dataframe 中删除了原来的<code class="fe me mf mg mh b">Duration</code>列。</p><p id="e09b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也在 Arrival_Time 列执行了类似的步骤，您可以在笔记本中跟进。</p><p id="973d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4) <strong class="kh ir">特征编码和缩放:- </strong></p><p id="55bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通常对独立的输入变量进行特征缩放和编码，因此让我们在数据帧中将目标变量和输入变量彼此分开。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Split the dataset</figcaption></figure><p id="f347" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里<code class="fe me mf mg mh b">X</code>包含输入特征的数据框，而<code class="fe me mf mg mh b">y</code>是我们的目标变量。我将在下一节介绍对<code class="fe me mf mg mh b">y</code>应用对数转换的原因。现在，让我们关注我们的输入变量 dataframe，即<code class="fe me mf mg mh b">X</code></p><p id="088f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是将输入变量分为分类变量和数字变量。</p><p id="db03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分类变量包含有限数量的类别或不同的组。分类数据可能没有逻辑顺序。例如，分类预测包括性别、材料类型和支付方式。</p><p id="6daa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数值变量顾名思义包含连续或离散的数值。</p><p id="526a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">df.select_dtypes()</code>方法进行拆分:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">select_dtypes is used to separate numerical and categorical features</figcaption></figure><p id="bff7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在分类特征的情况下，我们可以应用标签编码或一个热编码。</p><p id="4719" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这里进一步了解这两种技术:</p><p id="b041" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lw" href="https://medium.com/@contactsunny/label-encoder-vs-one-hot-encoder-in-machine-learning-3fc273365621" rel="noopener">实施</a></p><p id="c0a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lw" href="https://datascience.stackexchange.com/questions/9443/when-to-use-one-hot-encoding-vs-labelencoder-vs-dictvectorizor" rel="noopener ugc nofollow" target="_blank">何时使用标签编码 vs 标签编码器</a></p><p id="52b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在当前数据集中，我们已经对分类要素进行了标注编码。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Label encoding variables</figcaption></figure><p id="7855" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数字特征，我们可以执行不同类型的缩放，如<a class="ae lw" href="https://machinelearningmastery.com/prepare-data-machine-learning-python-scikit-learn/" rel="noopener ugc nofollow" target="_blank">最小最大</a>、<a class="ae lw" href="https://machinelearningmastery.com/prepare-data-machine-learning-python-scikit-learn/" rel="noopener ugc nofollow" target="_blank">标准缩放器</a>或<a class="ae lw" href="https://nickcdryan.com/2017/04/19/the-box-cox-transformation/" rel="noopener ugc nofollow" target="_blank"> BoxCox </a>变换。</p><p id="f9bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我尝试了各种标准缩放、最小-最大缩放和数字的 boxcox 变换。最终，boxcox 变换给出了最好的准确度分数。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Boxcox transformation</figcaption></figure><p id="26dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Box-Cox 变换是一系列幂变换函数，用于稳定方差并使数据集看起来更像正态分布。关于 box-cox 变换的解释可以在这里找到<a class="ae lw" href="http://dataunderthehood.com/2018/01/15/box-cox-transformation-with-python/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a19e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">lam</code>变量指定要应用的转换类型:-</p><ul class=""><li id="1f47" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la na lh li lj bi translated"><em class="mi">λ</em>=-1。是一种互易变换。</li><li id="16cb" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la na lh li lj bi translated"><em class="mi">λ</em>=-0.5 是倒数平方根变换。</li><li id="2957" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la na lh li lj bi translated"><em class="mi">λ</em>= 0.0 是对数变换。</li><li id="93ef" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la na lh li lj bi translated"><em class="mi">λ</em>= 0.5 是平方根变换。</li><li id="d7f9" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la na lh li lj bi translated"><em class="mi">λ</em>= 1.0 就是没有变换。</li></ul><p id="6f55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成上述转换后，我们将分类和数字特征连接起来，得到一组转换后的输入变量。</p><p id="5abd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5) <strong class="kh ir">功能选择</strong> :-</p><p id="7372" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以应用基于树的回归模型，如随机森林回归器、额外树和 xgboost，来获得特性的重要性。</p><p id="bc0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，RandomForestRegressor 模型可应用于数据集，如下所示</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Random Forest</figcaption></figure><p id="82af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先使用<code class="fe me mf mg mh b">train_test_split</code>方法将数据集分成训练和测试样本。<code class="fe me mf mg mh b">test_size</code>参数指定了训练和测试数据的比例。值为 0.3(即 30%)会将数据分为 70:30 的训练数据和测试数据。然后，我们定义了 RandomForestRegressor 模型，并将其应用于训练样本(X_train，y_train)。</p><p id="5cf4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后对测试输入样本(X_test)进行预测，并与原始目标样本(y_test)进行比较，得到各种精度指标。我将在本文的后续部分讨论准确性度量。</p><p id="c2af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们使用下面的函数来看看模型预测的特征重要性:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Feature Importances</figcaption></figure><p id="23c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的函数中，我们根据模型提供的特征重要性，按照重要性降序创建了一个新的数据框架。</p><p id="090f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用 matplotlib 库创建一个水平条形图，以直观地查看特性的重要性。</p><p id="3bcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在随机森林回归的情况下，函数的输出为:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9e37e88c6d6e8c6568bf22e0ddd6df6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*-N33jXtAQMBoysShZST_2Q.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Feature Importances</figcaption></figure><p id="1b7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，持续时间列具有最高的重要性，而航班始发的来源城市具有最低的特征重要性。</p><p id="2c6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从上面生成的图表中手动选择特性，也可以使用<code class="fe me mf mg mh b">sklearn</code>中的<code class="fe me mf mg mh b">SelectFromModel</code>模块自动选择最合适的特性。</p><p id="fbdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我尝试根据上述功能的重要性在选定的功能上运行该模型，但准确性略有下降，如果我们在现实世界中部署该模型，这可能会很好，因为该模型现在有点更健壮，但对于黑客马拉松来说，准确性最重要，所以我最终保留了所有功能。</p><p id="7a9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">7) <strong class="kh ir">检查目标变量</strong>的分布:-</p><p id="1f05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该使用分布图来检查回归问题中目标变量的分布。如果它是偏斜的，那么对数、指数或 sqrt 变换的应用可以帮助减少偏斜以获得正态分布。</p><p id="7e40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，目标变量的分布最初有点向右倾斜</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d23ddc1c0351827c97bba5dae5464624.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*OrQ5ltpIQADbgrpAkoRqVQ.png"/></div></figure><p id="45bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用对数变换后，它呈正态分布:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c0b9b67747276a0a224a238c96c77263.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*Z2lyElwmD6H84Pniu4atOQ.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Normalized distribution</figcaption></figure><p id="dcbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，对数转换确实提高了模型的整体准确性，这也是我在上面第 4 步开始时对目标输入应用对数转换的原因。</p><p id="df1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">8) <strong class="kh ir">从图表中获得洞察力:- </strong></p><p id="f8aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查目标列相对于输入变量的变化以及各种输入变量的分布:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ab09aa37671c41105ecd01797b7fd1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*B0tj0wv7KE8q967B4b6l4Q.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Scatter plot</figcaption></figure><p id="3a32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">价格应该随着持续时间的增加而增加，但这里的情况并非如此。</p><p id="6351" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们检查价格相对于停靠点总数的变化:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4750a14455857838f9b08992c0a0602a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*3YXRte2QbXi8bhjQ2eMrdg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Total stops vs Price</figcaption></figure><p id="3597" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上图中可以看出:- <br/>正如所料，经停次数越多，机票价格越高</p><p id="2661" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数字特征的分布可以使用直方图来检查，而分类特征的分布可以使用条形图或箱线图来检查。</p><p id="6c49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在分类特征的情况下，检查是否有任何列值可以组合在一起，而在数字特征的情况下，检查分布是否可以归一化，即均匀分布。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1efbf93cc576b31de6ce255908141b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*VzkUYrMxNiI6xtEF4Yaxlg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Airlines frequency bar plot</figcaption></figure><p id="9e1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后来，我回到分类特征，把最后四个航空公司分类组合在一起。</p><p id="5090" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对<code class="fe me mf mg mh b">Additional_Info</code>列执行类似的步骤:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7d8071c932e86789e11aafba3d201a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*VJQH7_c5OK9FCP2z6jpa7g.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Additional Info frequency bar plot</figcaption></figure><p id="51be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在 jupyter 笔记本中找到数值特征的直方图，并根据需要进行必要的转换。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nh"><img src="../Images/e40afd7ecc686f5033904ec7f4314b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7g3KitUEwHTGZkcjrB3Aw.png"/></div></div></figure><p id="ae88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">9) <strong class="kh ir">模型应用和超参数调整:- </strong></p><p id="5f38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在尝试了不同类型的回归模型后，我发现 ExtraTrees、RandomForest 和 XGboost 比其他模型的精度略高，因此是时候对所有 3 个模型进行超参数调整以进一步提高精度了。</p><p id="0bdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在机器学习中，<strong class="kh ir">超参数</strong>是在学习过程开始之前设置其值的参数。我们需要得出超参数的最佳值，因为这些值在模型之外，并且它们的值不能从数据中估计。</p><p id="9e27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">超参数调整是为学习算法选择一组最佳超参数的过程。进行超参数调优的两种常见方法是 GridSearchCV 和 RandomisedSearchCV。</p><p id="fa1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然 GridSearchCV 是详尽的，但 RandomisedSearchCV 有助于快速获得一系列相关值。更多关于他们的信息可以在<a class="ae lw" href="https://www.analyticsindiamag.com/why-is-random-search-better-than-grid-search-for-machine-learning/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Randomized Search CV</figcaption></figure><p id="76a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 RandomForest 算法的例子中，下面这篇来自《走向数据科学》的文章有助于我们理解如何正确地进行超参数调优:- <a class="ae lw" rel="noopener" target="_blank" href="/hyperparameter-tuning-the-random-forest-in-python-using-scikit-learn-28d2aa77dd74">文章链接</a></p><p id="72cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似的方法可以应用于 ExtraTrees 和 XGBoost 回归模型。</p><p id="2c6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">10) <strong class="kh ir">组合不同型号</strong></p><p id="9357" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆叠是一种集成学习技术，其中我们可以通过元分类器或元回归器来组合多个回归模型。基于完整的训练集来训练基础级模型，然后基于基础级模型的输出作为输入特征来训练元模型。</p><p id="02bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最后一步中，我使用叠加技术将上述三个模型结合起来，以提高整体准确性</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Stacked model</figcaption></figure><p id="ad7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里使用的基本模型是 ExtraTrees、Random Forest 和 XGBoost 回归器，而使用的元模型是 Lasso。你可以在这里了解更多关于如何实现堆栈<a class="ae lw" href="https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="e8ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们拟合堆叠模型，并对测试数据样本进行预测</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Fit the model</figcaption></figure><p id="f8a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我创建了一个简单的函数来打印回归模型中所有可用的准确性指标</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Print accuracy report</figcaption></figure><p id="6f49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们训练了堆叠模型，我们只需将模型应用于预测数据集，并将值提交给 hackathon 网站，这就完成了解决机器学习问题所需的所有基本步骤。</p><p id="bfbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆叠模型的最终指标是:-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5630" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> R </strong> - <strong class="kh ir">平方</strong>在 0-1 范围内测量模型和因变量之间的关系强度。关于其他指标的信息可以在<a class="ae lw" href="https://www.dataquest.io/blog/understanding-regression-error-metrics/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0cd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望在完成上述所有步骤后，你至少对如何处理有监督的机器学习问题有了一点了解。如果你有任何疑问、建议或更正，请在评论区提出来，如果你喜欢这篇文章，请与他人分享，以示欣赏。</p><p id="f9c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后但并非最不愉快的编码🤓</p></div></div>    
</body>
</html>