<html>
<head>
<title>Deploying Iris Classifications with FastAPI and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 FastAPI 和 Docker 部署 Iris 分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-iris-classifications-with-fastapi-and-docker-7c9b83fdec3a?source=collection_archive---------15-----------------------#2019-11-21">https://towardsdatascience.com/deploying-iris-classifications-with-fastapi-and-docker-7c9b83fdec3a?source=collection_archive---------15-----------------------#2019-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/02c02c305fb374058c4ebf054844989b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iZQUlk0WrvIOxQkW"/></div></div></figure><h2 id="aed8" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">TLDR；</h2><p id="f6c2" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">我们使用 Docker 部署了一个 FastAPI 应用程序，根据虹膜的测量值对其进行分类。所有的代码都可以在这里找到<a class="ae ls" href="https://github.com/happilyeverafter95/iris-classifier-fastapi" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="f0d0" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">虹膜数据集</h2><p id="1dea" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">Iris 数据集是一个简单但广泛用于统计建模和机器学习的例子。该数据包含均匀分布在 3 个鸢尾亚类之间的 150 个观察值:<em class="lt"> setosa，versicolor，virginica。</em>每个观察值包含相应的子类以及这些测量值:萼片宽度、萼片长度、花瓣宽度、花瓣长度(所有单位均为厘米)。</p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/6be949051fbab760094dee10855bc054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w1AojAOVB0MqJ1lT"/></div></div></figure><h2 id="4a47" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">FastAPI</h2><blockquote class="lz ma mb"><p id="c32d" class="kx ky lt kz b la mc lc ld le md lg lh me mf lj lk mg mh lm ln mi mj lp lq lr im bi translated">FastAPI 是一个现代、快速(高性能)的 web 框架，用于基于标准 Python 类型提示用 Python 3.6+构建 API。</p></blockquote><p id="cc23" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">FastAPI 网站提供了关于 FastAPI 如何工作以及使用 FastAPI 的优势的更多细节。顾名思义，FastAPI 就是<em class="lt"> fast </em>。最重要的是，设置非常简单，框架带有一个 Swagger UI，它记录了 API 并使测试交互更加容易。</p><h1 id="b379" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">步骤 0:先决条件</h1><ol class=""><li id="38a4" class="nb nc it kz b la lb le lf kk nd ko ne ks nf lr ng nh ni nj bi translated"><a class="ae ls" href="https://docs.docker.com/v17.09/engine/installation/" rel="noopener ugc nofollow" target="_blank">安装对接器</a></li><li id="9f9d" class="nb nc it kz b la nk le nl kk nm ko nn ks no lr ng nh ni nj bi translated">按照<a class="ae ls" href="https://github.com/happilyeverafter95/iris-classifier-fastapi" rel="noopener ugc nofollow" target="_blank">自述文件</a>上的说明，确保安装了所有依赖项(<code class="fe np nq nr ns b">pip install requirements.txt</code></li></ol><p id="a885" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">我们将使用 Docker 和 FastAPI 将我们的模型部署为 REST API。API(应用程序编程接口)是一组定义其他应用程序如何与您的代码交互的函数和过程。REST APIs 利用 HTTP 方法如<code class="fe np nq nr ns b">GET, POST, PUT, DELETE</code>来管理这种交互。</p><p id="4de3" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">在本例中，我们将只使用两种 HTTP 方法:</p><ul class=""><li id="1323" class="nb nc it kz b la mc le md kk nt ko nu ks nv lr nw nh ni nj bi translated"><code class="fe np nq nr ns b">GET:</code>用于从应用程序中检索数据</li><li id="01d3" class="nb nc it kz b la nk le nl kk nm ko nn ks no lr nw nh ni nj bi translated"><code class="fe np nq nr ns b">POST:</code>用于向应用程序发送数据(推理所需)</li></ul><p id="f8ac" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">当我们发送一个 HTTP 请求时，服务器发出一个状态码。状态代码通知请求的状态。我们可以根据第一个数字对状态代码进行分类:</p><ul class=""><li id="4ae6" class="nb nc it kz b la mc le md kk nt ko nu ks nv lr nw nh ni nj bi translated">1xx:信息回应</li><li id="1561" class="nb nc it kz b la nk le nl kk nm ko nn ks no lr nw nh ni nj bi translated">2xx:请求成功</li><li id="80f2" class="nb nc it kz b la nk le nl kk nm ko nn ks no lr nw nh ni nj bi translated">3xx:需要进一步的操作来完成请求</li><li id="22e5" class="nb nc it kz b la nk le nl kk nm ko nn ks no lr nw nh ni nj bi translated">4xx:由于客户端错误(即语法错误)，请求失败</li><li id="f0c3" class="nb nc it kz b la nk le nl kk nm ko nn ks no lr nw nh ni nj bi translated">5xx:由于服务器问题(即功能未实现)，请求失败</li></ul><p id="c719" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">对于我们的应用程序，我们只会看到 2xx、4xx 和 5xx 代码。<code class="fe np nq nr ns b">200 OK</code>状态代码是我们<em class="lt">希望</em>看到的代码。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="2ac1" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">创建一个名为<code class="fe np nq nr ns b">iris</code>的新目录。该目录将包含用于构建应用程序的所有代码。</p><h1 id="e020" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">步骤 1:训练一个简单的分类器</h1><p id="470c" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">为了简单起见，让我们使用逻辑回归作为我们的算法。我们可以使用<code class="fe np nq nr ns b">sklearn</code>来提供虹膜数据集并进行建模。</p><p id="f0d8" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">为了可读性，我将分类器构造为一个<em class="lt">类</em>。<code class="fe np nq nr ns b">train_model</code>用于训练分类器，<code class="fe np nq nr ns b">classify_iris</code>用于按照以下格式对新观察值进行分类:</p><p id="7bf5" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated"><code class="fe np nq nr ns b">{'sepal_w': &lt;sepal width&gt;, 'sepal_l': &lt;sepal length&gt;, 'petal_w': &lt;petal_width&gt;, 'petal_l'l: &lt;petal length&gt;}</code></p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="583b" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">我整理的这个分类器有很多缺点。抛开简单性不谈，每次调用<code class="fe np nq nr ns b">classify_iris</code>时都会训练一个新的分类器。这是对时间的不必要的利用，也使得审核之前的预测更加困难。一个更好的选择是将模型文件保存为应用程序的一部分，并加载它进行推理。</p><h1 id="ecc7" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">步骤 2:定义路由器</h1><p id="26ab" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">在与我们在步骤 1 中编写的分类器脚本相同的目录中，创建一个名为<code class="fe np nq nr ns b">routers</code>的文件夹来存放我们的路由器。路由器用于将复杂的 API 分解成更小的部分。每台路由器都有自己的前缀来标记这种分离。</p><p id="f75b" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">在<code class="fe np nq nr ns b">routers</code>目录中，创建一个名为<code class="fe np nq nr ns b">iris_classifier_router.py</code>的脚本。这将<code class="fe np nq nr ns b">/classify_iris</code>路由到其相应的函数。响应与<code class="fe np nq nr ns b">IrisClassifier.classify_iris()</code>生成的响应相同</p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="94d0" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">步骤 3:定义应用程序</h1><p id="6b20" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">在与<code class="fe np nq nr ns b">routers</code>文件夹相同的目录下，创建另一个脚本<code class="fe np nq nr ns b">app.py</code>。在此脚本中，定义应用程序并指定路由器。</p><p id="bc33" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">我们还定义了一个<code class="fe np nq nr ns b">healthcheck</code>函数。健康检查 API 返回应用程序的运行状态。我们的健康检查返回了令人愉快的短语<em class="lt">虹膜分类器一切就绪！</em>应用健康时。请注意，这将调用一个<code class="fe np nq nr ns b">200</code>状态代码。</p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="c3a1" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">步骤 4:包含依赖项，Dockerfile</h1><p id="dd49" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">到这一步，文件结构应该如下所示:</p><p id="13dc" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">├──iris<br/>│├──iris _ classifier . py<br/>│├──app . py<br/>│└──路由器<br/>│└──——iris _ classifier _ router . py</p><p id="a3ca" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">转到上一个目录，创建一个<code class="fe np nq nr ns b">requirements.txt</code>文件，指定构建这个应用程序所需的所有依赖项。</p><p id="802d" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">我的<code class="fe np nq nr ns b">requirements.txt</code>长这样:</p><pre class="lv lw lx ly gt og ns oh oi aw oj bi"><span id="ce94" class="kb kc it ns b gy ok ol l om on">fastapi==0.38.1<br/>numpy==1.16.4<br/>scikit-learn==0.20.1<br/>uvicorn==0.9.0</span></pre><p id="bc56" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">我们还需要创建一个<code class="fe np nq nr ns b">Dockerfile</code>，它将包含组装图像所需的命令。一旦部署，其他应用程序将能够从我们的虹膜分类器进行消费，以做出关于花的酷推论。</p><p id="e389" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated"><code class="fe np nq nr ns b">Dockerfile</code>也可以在上面链接的 GitHub repo 中找到。</p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="26ba" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">第一行为我们的应用程序定义了 Docker 基本图像。python:3.7-slim-buster 是一个受欢迎的图片——它很轻量级，构建起来非常快。第二行指定维护者。使用<code class="fe np nq nr ns b">docker inspect</code>可以发现维护者信息。</p><p id="d5ad" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">我们的 Dockerfile 以一个<code class="fe np nq nr ns b">CMD</code>结束，它用于将默认命令设置为<code class="fe np nq nr ns b">uvicorn --host 0.0.0.0 --port 5000 iris.app:app</code>。默认命令在我们运行容器时执行。</p><h1 id="f751" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">步骤 5:运行 Docker 容器</h1><p id="4c87" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">使用<code class="fe np nq nr ns b">docker build . -t iris</code>构建 docker 图像。这一步需要一段时间才能完成。</p><p id="63a2" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">构建完映像后，使用<code class="fe np nq nr ns b">docker run -i -d -p 8080:5000 iris</code>生成 docker 容器。这将应用程序暴露给端口 8080。运行容器还会启动我们之前设置的默认命令——这有效地启动了应用程序！</p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="oo of l"/></div></figure><h1 id="9ffb" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">与 API 交互</h1><p id="fd19" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">使用<code class="fe np nq nr ns b">curl 'http://localhost:8080/healthcheck'</code>进行健康检查</p><p id="6e67" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">要获得推论，请使用以下请求。<code class="fe np nq nr ns b">-d</code>之后的 JSON 字符串是传递给<code class="fe np nq nr ns b">classify_iris.</code>的模型输入</p><pre class="lv lw lx ly gt og ns oh oi aw oj bi"><span id="ba7e" class="kb kc it ns b gy ok ol l om on">curl 'http://localhost:8080/iris/classify_iris' -X POST -H 'Content-Type: application/json' -d '{"sepal_l": 5, "sepal_w": 2, "petal_l": 3, "petal_w": 4}'</span></pre><p id="8880" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">前往<code class="fe np nq nr ns b">localhost:8080/docs</code>查看 Swagger UI。这使得测试请求<em class="lt">变得更加容易。</em></p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/1b51cf3d38f63792e66bb813e7aa0d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRa45GM6ryNGAN-f8kdQvA.png"/></div></div></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="6134" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">如果您有兴趣阅读更多关于模型部署的内容，我写了另一篇关于<a class="ae ls" rel="noopener" target="_blank" href="/deploying-kaggle-solution-with-tensorflow-serving-part-1-of-2-803391c9648">使用 TensorFlow 服务</a>部署 Keras 文本分类器的文章。</p><h1 id="6591" class="mk kc it bd kd ml mm mn kg mo mp mq kj mr ms mt kn mu mv mw kr mx my mz kv na bi translated">感谢您的阅读！</h1><p id="3246" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">如果你喜欢这篇文章，可以看看我关于数据科学、数学和编程的其他文章。<a class="ae ls" href="https://medium.com/@mandygu" rel="noopener">通过 Medium </a>关注我的最新动态。😃</p><p id="c4c4" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">作为一个业余爱好项目，我还在<a class="ae ls" href="http://www.dscrashcourse.com/" rel="noopener ugc nofollow" target="_blank">www.dscrashcourse.com</a>建立了一套全面的<strong class="kz iu">免费</strong>数据科学课程和练习题。</p><p id="fb9b" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">如果你想支持我的写作，下次你报名参加 Coursera 课程时，可以考虑使用我的会员链接。完全公开—我从每一次注册中获得佣金，但不会对您产生额外费用。</p><p id="99bf" class="pw-post-body-paragraph kx ky it kz b la mc lc ld le md lg lh kk mf lj lk ko mh lm ln ks mj lp lq lr im bi translated">再次感谢您的阅读！📕</p></div></div>    
</body>
</html>