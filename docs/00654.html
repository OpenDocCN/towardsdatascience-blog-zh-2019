<html>
<head>
<title>Build a Pipeline for Harvesting Medium Top Author Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个收集中顶级作者数据的渠道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-pipeline-for-harvesting-medium-top-author-data-c4d7ed73729f?source=collection_archive---------9-----------------------#2019-01-30">https://towardsdatascience.com/build-a-pipeline-for-harvesting-medium-top-author-data-c4d7ed73729f?source=collection_archive---------9-----------------------#2019-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3b47" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用 Luigi 和 Docker 为 Medium 构建简单的数据工程管道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/98d17fab4c8ec6e0b8a14cf4e170b263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vLTc89opy2roulRkaiCPg.jpeg"/></div></div></figure><h1 id="5c7c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="4606" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当我为数据工程管道编写的一些 Python 脚本失去控制时，这个项目的想法开始了:</p><ul class=""><li id="b486" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">管道需要数千个 API 调用 REST 服务，每个调用下载一个 JSON 文件。</li><li id="8008" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">管道的某些部分需要很长时间来运行，并且该过程有时会失败。</li></ul><p id="dd5e" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">我的过程是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/a38b6f88fd2864306997da1c42390a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLlcc3Y35b78lCEv8ilgQA.png"/></div></div></figure><p id="9aca" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这些累积的 API 调用累积起来:</p><ul class=""><li id="cddc" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">获取父对象(<em class="mz"> 1 请求</em></li><li id="dfd0" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">对于每个父节点获取子节点(<em class="mz"> 150 个请求</em></li><li id="94e6" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">为每个孩子获取信息(<em class="mz"> 5000 个请求</em>)</li><li id="c5fa" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">对于每个 info fetch 配置项(<em class="mz"> 14，000 个请求……这已经很多了！)</em></li></ul><p id="1536" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这是我使用的 API 的一个怪癖；没有办法进行批量请求。有许多问题:</p><ul class=""><li id="f102" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">这个序列运行了几个小时</li><li id="8f3d" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">如果出现故障，很难确定从哪里重新开始</li><li id="a871" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">没有办法检查进度；如果脚本已经运行了一个小时，它们是不是就要完成了？</li></ul><p id="eeb5" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">咨询谷歌，我发现我的设计与<a class="ae na" href="https://marcobonzanini.com/2015/10/24/building-data-pipelines-with-python-and-luigi/" rel="noopener ugc nofollow" target="_blank">这个不做事的例子</a>非常相似:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/9d4e0818a5395035ac3d09496de58d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7nAeKpHUu5hkHnQQ7SrXg.png"/></div></div></figure><p id="0f3d" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这东西已经长成了一个怪物。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="45df" class="kr ks iq bd kt ku nj kw kx ky nk la lb jw nl jx ld jz nm ka lf kc nn kd lh li bi translated">路易吉来救援了</h1><p id="1b62" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我四处寻找一个轻量级的数据工程框架，它可以支持:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0390e84c665092624810e671509da01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*W6DHlYRVdt6WcWGOCh315w.jpeg"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">A famous plumber</figcaption></figure><ul class=""><li id="ff78" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">工作流程编排</li><li id="7965" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">并行处理</li><li id="2b2f" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">简单部署</li><li id="d61b" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">快速学习曲线</li></ul><p id="7bad" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">考虑到这些要求，<a class="ae na" href="https://github.com/spotify/luigi" rel="noopener ugc nofollow" target="_blank"> Spotify Luigi </a>看起来刚刚好:</p><blockquote class="nt"><p id="822a" class="nu nv iq bd nw nx ny nz oa ob oc me dk translated"><em class="od"> Luigi 是一个 Python 模块，帮助您构建批处理作业的复杂管道。它处理依赖性解析、工作流管理、可视化等。</em></p></blockquote><p id="55b7" class="pw-post-body-paragraph lj lk iq ll b lm oe jr lo lp of ju lr ls og lu lv lw oh ly lz ma oi mc md me ij bi translated">Spotify 使用 Luigi 进行推荐音乐的数据工程批处理工作，例如 Discover Weekly 播放列表(尽管最近流行迪斯科，但我对 Discover Weekly 的选择还是很满意)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5bf91bfcce8765c25d6d723fc0b86eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*k9SgxdFB9ItDtRNArK42cw.jpeg"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk"><em class="od">My face when I saw Luigi do all the things</em></figcaption></figure><p id="541d" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">与 Luigi 一起工作令人惊讶地满足，我想知道如何在我的日常工作之外再次使用它。我想到在管道中重用这种方法来收集关于顶级媒体作者的数据，下面的文本描述了一个可以在其他领域重用的数据工程管道的简单框架。</p><p id="22b2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这是面向<a class="ae na" href="https://www.oreilly.com/ideas/data-engineers-vs-data-scientists" rel="noopener ugc nofollow" target="_blank">数据工程和</a>数据科学的，尽管 Luigi 的模块化架构应该可以直接添加分析组件。换句话说，这是一个用于提取数据的系统设计，而不是一种用于分析和从数据中获得洞察力的方法(可能是未来故事的主题)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/abb965dd88d97a023eed83dc64f659aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSlg7a3-HCZM_YtHSNF3Qw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Luigi gets to work on the pipes</figcaption></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="0908" class="kr ks iq bd kt ku nj kw kx ky nk la lb jw nl jx ld jz nm ka lf kc nn kd lh li bi translated">从媒体中获取有趣的顶级作者数据</h1><p id="a439" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们的管道将收集出版物中顶级作者的数据:</p><ol class=""><li id="c7f9" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me ol mn mo mp bi translated">这位顶级故事作者关注的作者列表</li><li id="a8b3" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me ol mn mo mp bi translated">他们写的故事总数</li><li id="1923" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me ol mn mo mp bi translated">每个故事获得了多少掌声</li><li id="c6ad" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me ol mn mo mp bi translated">他们故事的平均标题长度</li><li id="21de" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me ol mn mo mp bi translated">他们故事的平均字数</li><li id="3d02" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me ol mn mo mp bi translated">他们为之写作的出版物</li></ol><p id="81d8" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">关于 Medium API 的一个简短说明。API 本身相当有限。然而，您可以将<code class="fe om on oo op b">?format=json</code>附加到许多标准的中型 URL，这将返回通常显示在页面上的数据的 JSON 表示，以及一些额外的元数据。例如，<a class="ae na" href="https://towardsdatascience.com/" rel="noopener" target="_blank">《走向数据科学》</a>的首页用<code class="fe om on oo op b">?format=json</code>参数渲染成这样:</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="0581" class="ou ks iq op b gy ov ow l ox oy">{"success":true,"payload":{"collection":{"id":"7f60cf5620c9","name":"Towards Data Science","slug":"towards-data-science","tags":["DATA SCIENCE","MACHINE LEARNING","ARTIFICIAL INTELLIGENCE","BIG DATA","ANALYTICS"],"creatorId":"895063a310f4","description":"Sharing concepts, ideas, and codes.","shortDescription":"Sharing concepts, ideas, and codes.","image":{"imageId":"1*F0LADxTtsKOgmPa-_7iUEQ.jpeg","filter":"","backgroundSize":"","originalWidth":1275,"originalHeight":1275,"strategy":"resample","height":0,"width":0},"metadata":{"followerCount":171879,"...etc</span></pre><p id="543b" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">感谢<a class="oz pa ep" href="https://medium.com/u/d540942266d0?source=post_page-----c4d7ed73729f--------------------------------" rel="noopener" target="_blank"> Radu Raicea </a>的精彩文章<a class="ae na" href="https://medium.freecodecamp.org/how-i-used-python-to-find-interesting-people-on-medium-be9261b924b0" rel="noopener ugc nofollow" target="_blank">我如何使用 Python 找到有趣的人来关注 Medium </a>为我指出了这个特性。</p><p id="2987" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">JSON 结果需要一点清理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Remove invalid characters from the response</figcaption></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="0404" class="kr ks iq bd kt ku nj kw kx ky nk la lb jw nl jx ld jz nm ka lf kc nn kd lh li bi translated">具体细节</h1><p id="732d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一个关键需求是使我的 Luigi 工作流的部署非常简单。关于部署环境，我只想假设一件事；Docker 守护进程是可用的。有了 Docker，我就不需要担心 Python 版本不匹配或其他环境差异。</p><p id="16a4" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">不过，我花了一点时间才弄明白如何在 Docker 中运行 Luigi。</p><p id="fee2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">第一步是在它自己的容器中启动中央调度程序。你可以用一张现有的图片来做这件事，比如这张<a class="ae na" href="https://github.com/axiom-data-science/docker-luigi" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1d10" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">您可以向调度程序提交作业，如下所示:</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="718b" class="ou ks iq op b gy ov ow l ox oy">PYTHONPATH='.' luigi --module top_artists Top10Artists  --date-interval 2012-07</span></pre><p id="1e84" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这是用 Luigi docs 里的一个例子。</p><p id="838d" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">所以对于部署，这是我采取的方法；一个 docker 编写文件，包括:</p><ul class=""><li id="01fc" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">Luigi 中央调度程序</li><li id="29c6" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">Luigi 任务的独立的基于 Python 的容器</li><li id="e16a" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">公开报告的 nginx 容器</li></ul><p id="929a" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">tasks 容器的入口点休眠一段时间，然后启动 Luigi 管道，这个<code class="fe om on oo op b">sleep</code>代替了 cron 作业。</p><h2 id="d38d" class="ou ks iq bd kt pd pe dn kx pf pg dp lb ls ph pi ld lw pj pk lf ma pl pm lh pn bi translated">使用 Luigi 进行并行处理</h2><p id="3efe" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我的脚本非常慢，我需要一种方法来并行运行多个 URL 获取过程，这导致了这样的设计:</p><ul class=""><li id="8f22" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">一个<code class="fe om on oo op b">WrapperTask</code>包装了管道的所有组件</li><li id="c42f" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">第一次 URL 获取获得需要单独查询的许多项目的列表(这是一个单独的请求)</li><li id="fc3c" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">这些块在工人之间划分，他们的工作结果被放入一个以每个工人 id 命名的文件中(例如<code class="fe om on oo op b">1.json</code>)</li><li id="093e" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">从这一点来看，这些文件被下游工人使用</li></ul><p id="a349" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">该方法改编自<a class="ae na" href="http://engineering.pivotal.io/post/luigi-data-science/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><h2 id="f22e" class="ou ks iq bd kt pd pe dn kx pf pg dp lb ls ph pi ld lw pj pk lf ma pl pm lh pn bi translated">数据收集任务</h2><p id="8d64" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于中型数据采集管道，<code class="fe om on oo op b">WrapperTask</code>如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Pipeline wrapper</figcaption></figure><p id="b83c" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated"><code class="fe om on oo op b">requires()</code>方法完成了这里的大部分工作，建立了一个在<code class="fe om on oo op b">PipelineTask</code>被认为完成之前需要完成的任务列表。</p><p id="1df2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">流水线中的第一个任务是<code class="fe om on oo op b">FetchUserList</code>。这将从媒体出版物的首页获取媒体作者的列表。作者列表放在一个文件中，供下游任务使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Fetch a list of authors from a publication</figcaption></figure><p id="708b" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">在《走向数据科学》出版物上运行它，会给我们一个页面上提到的作者列表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">A list of publication authors</figcaption></figure><p id="44d2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">您可能会注意到，此结果中返回的作者列表与页面上显示的不匹配；那是怎么回事？原来，页面在加载时会向 Medium API 提交一系列请求，每个返回的 JSON 结果都包含一个指向该系列中下一组结果的指针。我们需要在获取数据时处理这种分页行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Handle Medium API paging</figcaption></figure><p id="2da4" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这个实现很大程度上借用了 Radu Raicea 的文章。</p><p id="854f" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">注意，在一个给定的管道中，只有一个<code class="fe om on oo op b">FetchUserList</code>任务将被执行，因为我们没有包含一个<code class="fe om on oo op b">file_number</code>参数。</p><p id="417e" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">下一个任务是<code class="fe om on oo op b">FetchUserFollowings</code>。这个任务将由许多工作器并发执行，并行化由<code class="fe om on oo op b">workers</code>配置参数控制。当任务开始执行时，它决定负责处理 JSON 文件的哪个部分。确定截面的逻辑由<code class="fe om on oo op b">get_part_of_list()</code>控制:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Split the whole list, so we can delegate a chunk to each worker</figcaption></figure><p id="20b7" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated"><code class="fe om on oo op b">ExtractUserMetrics</code>任务从帖子数据中挑选出一些有趣的数据点，例如每篇文章的总鼓掌次数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Extract metrics</figcaption></figure><p id="c56b" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">然后，我们可以从提取的故事数据中得出几个平均值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Calculate averages</figcaption></figure><p id="a1c7" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">最后，这一行启动了这个过程:</p><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="3233" class="ou ks iq op b gy ov ow l ox oy">luigi.build([PipelineTask()], workers=worker_count)</span></pre><h2 id="0640" class="ou ks iq bd kt pd pe dn kx pf pg dp lb ls ph pi ld lw pj pk lf ma pl pm lh pn bi translated">公开结果</h2><p id="4e16" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">您可能希望向最终用户公开这些报告，例如向您团队中的数据科学家公开。一个简单的方法是添加一个 nginx web 服务器，并列出输出目录的内容。这将允许任何人点击一个 URL 并下载报告，每天都有一个报告目录。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="9cb0" class="kr ks iq bd kt ku nj kw kx ky nk la lb jw nl jx ld jz nm ka lf kc nn kd lh li bi translated">尝试一下</h1><p id="5643" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">好吧，让我们踢轮胎这件事…</p><p id="23d7" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">首先，通过在 luigi.conf 文件中指定一个<code class="fe om on oo op b">collection_id</code>来指定 URL 抓取的起点。</p><p id="27b0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">配置完成后，有几种方法可以运行代码:</p><ol class=""><li id="05eb" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me ol mn mo mp bi translated">开发时，可以直接运行<code class="fe om on oo op b">__main__.py</code>。如果你想这样做，你需要先启动 Luigi。</li><li id="24fe" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me ol mn mo mp bi translated">您还可以使用 docker-compose 运行整个应用程序堆栈:</li></ol><pre class="kg kh ki kj gt oq op or os aw ot bi"><span id="5d43" class="ou ks iq op b gy ov ow l ox oy">docker-compose up -d</span></pre><p id="731d" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">这将启动 Luigi、nginx 和任务容器，这将触发<code class="fe om on oo op b">__main__.py</code>。</p><p id="2f42" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">检查总结报告，我们可以获得一些关于目前为《走向数据科学》撰写文章的一些顶级作者的信息。例如，我们可以获得当前顶级作者之一<a class="oz pa ep" href="https://medium.com/u/e2f299e30cb9?source=post_page-----c4d7ed73729f--------------------------------" rel="noopener" target="_blank"> Will Koehrsen </a>的一些汇总统计数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Some example metrics</figcaption></figure><p id="cbf3" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">干得好，威尔！</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="d7b8" class="kr ks iq bd kt ku nj kw kx ky nk la lb jw nl jx ld jz nm ka lf kc nn kd lh li bi translated">单元测试</h1><p id="b1b6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我选择了<a class="ae na" href="https://docs.pytest.org/en/latest/contents.html" rel="noopener ugc nofollow" target="_blank"> pytest </a>作为测试框架。我喜欢 pytest 有两个主要原因:</p><ul class=""><li id="bc69" class="mf mg iq ll b lm mh lp mi ls mj lw mk ma ml me mm mn mo mp bi translated">它需要更少的样板代码</li><li id="43f9" class="mf mg iq ll b lm mq lp mr ls ms lw mt ma mu me mm mn mo mp bi translated">您可以使用常规的 assert 语句，而不需要记住特殊的语法</li></ul><p id="90c0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">为了使用与生产版本不同的配置进行测试，您可以在测试中使用<code class="fe om on oo op b">luigi.configuration.add_config_path()</code>。这将从特定位置加载配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Find and load test configuration</figcaption></figure><p id="b92e" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">我使用了<code class="fe om on oo op b">MockTarget</code>类，这样我可以以可重复的方式运行测试。我不希望一个测试依赖于前一个测试创建的数据，或者测试在完成运行后留下结果文件。<code class="fe om on oo op b">MockTarget</code>模拟一个 Luigi 目标，它将结果存储在内存中，而不是将它们写到文件系统中。</p><p id="99ef" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">最后，为了允许在不要求端点可用的情况下测试 URL 请求，我使用了<code class="fe om on oo op b"><a class="ae na" href="https://pypi.org/project/requests-mock/" rel="noopener ugc nofollow" target="_blank">requests_mock</a></code>库。</p><p id="f979" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr ls mv lu lv lw mw ly lz ma mx mc md me ij bi translated">Github 上提供了该示例管道的完整源代码:</p><div class="po pp gp gr pq pr"><a href="https://github.com/lucrussell/docker-luigi" rel="noopener  ugc nofollow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd ir gy z fp pw fr fs px fu fw ip bi translated">吕克拉塞尔/多克尔-路易吉</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">从 Medium 获取顶级作者数据的数据工程管道— lucrussell/docker-luigi</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">github.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf kp pr"/></div></div></a></div></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="5be6" class="kr ks iq bd kt ku nj kw kx ky nk la lb jw nl jx ld jz nm ka lf kc nn kd lh li bi translated">结论</h1><p id="7348" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个项目是一个 Luigi 管道，用于从 Medium 收集顶级作者数据。该项目一开始只是一个简单的框架，用于编排一个有问题的数据工程过程。管道通过抓取出版物首页的 URL 来提取关于作者及其故事的信息，然后收集关于顶级作者的一些基本指标。它使用 Luigi 来协调 Python 逻辑，使用 Docker 来简化部署。</p></div></div>    
</body>
</html>