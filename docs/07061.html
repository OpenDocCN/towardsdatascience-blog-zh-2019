<html>
<head>
<title>Tensorflow 2.0 — Create and Train a Vanilla CNN on Google Colab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">tensor flow 2.0——在 Google Colab 上创建和训练一个普通的 CNN</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-2-0-create-and-train-a-vanilla-cnn-on-google-colab-c7a0ac86d61b?source=collection_archive---------5-----------------------#2019-10-06">https://towardsdatascience.com/tensorflow-2-0-create-and-train-a-vanilla-cnn-on-google-colab-c7a0ac86d61b?source=collection_archive---------5-----------------------#2019-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f249" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Colab 和 Tensorflow 2.0 简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c82f3189ab7042b2ae24a5b5d25ee618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpSmkJ8Yj-vtM1uUJwKypw.jpeg"/></div></div></figure><p id="924e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Tensorflow 2.0 在不到一周前发布，它一直是我的 twitter TL 上讨论最多的话题，所以我决定加入讨论并写这篇文章。Tensorflow 有一些重大改进，同时使任何人都可以轻松开始使用它。Tensorflow 2.0 现在与 Keras 高度集成，这使得用最少的专业知识构建和测试简单模型更加容易。谷歌还决定强调“热切执行”，而不是建立基于会话的模型。急切执行允许立即计算 python 操作，而不是构建计算图。这篇文章将一步一步地介绍如何使用 Google Colab 并在 Tensorflow 2.0 中构建 CNN 模型</p><p id="fd77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于那些不知道 Google Colab 是什么的人(如果你知道，你可以跳过下面几行)，它是一个在线 Jupyter 笔记本，让你编写和共享代码。最好的部分是代码在谷歌的服务器上执行。你甚至可以选择在谷歌的云 GPU 或 TPU 上训练你的模型。</p><p id="75b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在 GPU 或 TPU 上训练您的模型，请转到运行时→更改运行时类型→硬件加速器</p><h1 id="8056" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">资料组</h1><p id="7dd3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将使用的数据集是<a class="ae mn" href="http://benchmark.ini.rub.de/?section=gtsrb&amp;subsection=news" rel="noopener ugc nofollow" target="_blank">德国交通标志识别基准</a>。该数据集包含 50K 多幅图像和 40 多种交通标志。</p><h1 id="6f84" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">让我们从代码开始</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="8336" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">玩弄我们的数据</h2><p id="ef53" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">第一部分是将数据集导入 Google Colab。你可以把你的数据上传到你的 google drive，然后把它安装到你的 Colab 笔记本上。将数据集作为. zip 文件上传到驱动器后，在您的 Colab 笔记本中键入以下代码以挂载驱动器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fc40f83d2446e6a6a9b776353ad196fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*nfc7-VxixssO0oHTZu7QIw.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Mount your drive</figcaption></figure><p id="b643" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用 shell 命令 unzip 解压缩该文件。通过在命令前面加上“！”，可以在笔记本单元中调用 Shell 命令。看看下面的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/17fda51c11980a39d33c7f7b462ea62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVrZCNrd0YabnHyHlehiAA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">note: If you have spaces in your directory names, use escape sequence ‘\’</figcaption></figure><p id="e1e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据集已经分为训练和测试图像，其中 75%的图像用于训练，其余用于测试我们的模型。由于我们已经装载了驱动器，现在我们可以通过引用驱动器中的路径来访问数据集。看看下面的代码来加载训练和测试数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/2e3e17f8547d09a85d9a1342af460047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqhchIlfUUSxgVjDP2qcJA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Loading Training data</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/fadd63f0e35aa78531de85cf0b80fd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQFUxJE7Q_xUibRG0Qfk0A.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Loading Testing data</figcaption></figure><p id="eb90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用 PIL 从目录中加载图像，由于图像的尺寸不同，我们使用 im.resize()将每个图像的尺寸调整为 100x100 的标准尺寸。我们现在将 train_images、train_labels 和 test_images 从列表转换为 numpy 数组。numpy 数组“train_labels”在每一行中只有一个条目，因此我们使用下面的代码对它进行了整形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b5e69abcbe4e083519231946e3e2e9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8sxGcDTe58MMPes06o1YQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">reshape labels of training data</figcaption></figure><p id="cdf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:“-1”表示未知维度</p><p id="ed07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们已经重塑了我们的培训标签，我们可以将它们转换成一次性编码。要了解什么是一次性编码以及我们为什么要这样做，请点击<a class="ae mn" href="https://machinelearningmastery.com/why-one-hot-encode-data-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/a10e510b26b289c97d050272f93bdf84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e48r3cLLrxaosSiktDRvDA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">One-hot encoding our training labels</figcaption></figure><p id="418b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Scikit-learn 有一个预定义的函数，我们可以直接导入它来创建我们的一次性编码标签。我们现在通过将图像除以 255 来标准化它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/1493b026b873291c76af47665af0a7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*qNbMb10UTTP1jcyNVkNDQQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Image Normalization</figcaption></figure><p id="f0af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将图像除以 255.0 将每个图像中的像素值范围减少到 0.0–1.0，这从我们的模型中提供了更好的结果。</p><h2 id="e492" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">构建我们的模型</h2><p id="a26b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在我们开始编写模型之前，检查我们的 Colab 是否使用 Tensorflow 2.0 作为后端，我们可以通过输入以下命令来完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2072ccaebaba47f790464259b399ea56.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*_3LvZW4WtVSoMo0vHzrIiQ.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">check TensorFlow version</figcaption></figure><p id="ed17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果 Tensorflow 的早期版本被用作后端，我们可以通过在笔记本中键入以下命令来升级它</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6cdaf819eb2b7eef36f3b995974605f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*w_O0ll-qln0ArLGblI33vA.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Upgrade Tensorflow</figcaption></figure><p id="1887" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以开始进行必要的导入，并根据我们的训练数据创建批量张量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2767485f46b9f6ae68ecdf5c3563ac6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idmjO3J08H6euygB-3OpBw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Create tensor slices from training data</figcaption></figure><p id="0bb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Tensorflow 的数据集库(tf.data)在 2.0 版本中进行了扩展，并随着新的添加而变得更加复杂。</p><ol class=""><li id="b6d6" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">from_tensor_slices()函数接受 numpy 数组作为参数，并生成张量对象。</li><li id="16cf" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">shuffle()以 buffer_size 作为参数，从缓冲区中随机抽取元素。</li><li id="c5a3" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">batch()函数将 batch_size 作为参数，并将数据中的连续元素合并成与 batch_size 相等的批</li></ol><p id="9fef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住 Tensorflow 2.0 更强调“急切执行”，避免计算图。因此，一旦单元被执行，操作就被评估。因此，train_ds 有两个随机采样和批处理的张量。这些张量代表训练图像和标签。</p><p id="1d29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始对模型的架构进行编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c1910f72b7c18f22235c5b0d46cd34ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsRquAqKpmOStxf8U5cQBg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Model Architecture</figcaption></figure><p id="4d2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们创建我们的模型类(MyModel)作为模型的派生类。这为我们节省了大量编写自己的模型类的时间。我们将使用的架构是一个简单的 CNN，具有用于类别预测的密集层。想了解更多关于 CNN 的信息，请点击这里。在定义了我们的模型架构之后，我们为我们的模型创建一个对象，然后继续定义我们的损失函数、优化器和度量标准。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a3d9b1c305f8345845553998061008c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHB5Weczl0d5bwsK8BE7Pw.png"/></div></div></figure><p id="c4b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<a class="ae mn" href="https://peltarion.com/knowledge-center/documentation/modeling-view/build-an-ai-model/loss-functions/categorical-crossentropy" rel="noopener ugc nofollow" target="_blank">分类交叉熵</a>作为我们的损失函数，使用<a class="ae mn" href="https://machinelearningmastery.com/adam-optimization-algorithm-for-deep-learning/" rel="noopener ugc nofollow" target="_blank">亚当</a>作为我们的优化器。</p><ol class=""><li id="da87" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">train_loss 将是每个时期所有损失的平均值</li><li id="4824" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">train_accuracy 将是我们的模型在每个时期的精度度量</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a986f6a4e5c0ac33bccb45d1f84d15ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0S5v0uiunIyRdrJIbqhJA.png"/></div></div></figure><p id="8987" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述函数用于训练我们的模型。它接收图像和相应的标签，计算损失和梯度。</p><ol class=""><li id="a140" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">由于 Tensorflow 2.0 使用“热切执行”，性能和可部署性可能会受到挫折。为了确保出色的性能和普遍的可部署性，我们可以添加一个 decorator @tf.function，这个 decorator 将函数转换成一个图形。</li><li id="40cf" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">tf。GradientTape()是用于计算差异的高级 API。在上面的代码行中，我们根据真实标签和预测标签计算损失，并使用梯度磁带来计算损失相对于模型变量的梯度(微分)，并将它们应用于优化器</li><li id="8528" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">我们还会计算每一步的训练损失和准确度</li></ol><p id="c1ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们已经完成了构建模型的所有必要步骤，我们就开始训练它，但是要执行下面的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/533125c410c61f4a82ed673919373a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6KKouvPp31APsDyWz3nsg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">model training</figcaption></figure><p id="f6d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们为 5 个时期训练模型，并在每个时期后保存模型的权重。请注意，模型权重将保存在谷歌驱动器中。我们还重置了每个时期的训练损失和准确度值。</p><p id="d5c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">若要加载模型的权重，请创建 MyModel 类的实例，并使用 load_weights(path)函数。</p><h2 id="ad49" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">基于测试集的预测</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9440d79efaf9c38609344b2a1f2bf1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_S-aFczOGKyTTMGdqn9xsw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Model predictions</figcaption></figure><p id="e4f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过提供 test_images 作为参数来获得模型预测，由于模型返回概率分布，我们使用 np.argmax()来获得最高值。</p><h1 id="ff1f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="2d3d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过遵循以上步骤，您已经使用 Tensorflow 2.0 成功地对 CNN 进行了关于 Colab 的培训。如果您有任何疑问，请与我联系:)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9a97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">链接至完整代码:<a class="ae mn" href="https://github.com/grohith327/traffic_sign_detection" rel="noopener ugc nofollow" target="_blank">https://github.com/grohith327/traffic_sign_detection</a></p><h1 id="8b01" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">参考</h1><div class="oj ok gp gr ol om"><a href="https://www.tensorflow.org/guide/effective_tf2" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">有效张量流 2 |张量流核心</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">TensorFlow 2.0 有多种变化，以提高 TensorFlow 用户的工作效率。TensorFlow 2.0 消除了冗余…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">www.tensorflow.org</p></div></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://www.tensorflow.org/tutorials/quickstart/advanced" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">TensorFlow 2 专家快速入门| TensorFlow Core</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">这是一个谷歌协作笔记本文件。Python 程序直接在浏览器中运行——这是一种很好的学习和…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">www.tensorflow.org</p></div></div></div></a></div></div></div>    
</body>
</html>