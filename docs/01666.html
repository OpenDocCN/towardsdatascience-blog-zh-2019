<html>
<head>
<title>Productivity tips for Jupyter (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jupyter (Python)的生产力技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/productivity-tips-for-jupyter-python-a3614d70c770?source=collection_archive---------15-----------------------#2019-03-18">https://towardsdatascience.com/productivity-tips-for-jupyter-python-a3614d70c770?source=collection_archive---------15-----------------------#2019-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近几周我一直忙于我的 MRes 项目，睡眠很少。这让我在工作中最重要的工具:Jupyter Notebook/Jupyter Lab 中寻找改进工作流程的方法。我在这篇文章中收集了所有的窍门和技巧，希望其他研究人员可能会发现这些有用的东西:</p><ol class=""><li id="97f6" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" href="#3b5a" rel="noopener ugc nofollow">计算完成(或失败)后播放声音</a></li><li id="027e" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#ad45" rel="noopener ugc nofollow">将通知集成到您的操作系统中(为 GNOME shell 做好准备)</a></li><li id="76d2" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#3424" rel="noopener ugc nofollow">跳转到变量、函数或类的定义</a></li><li id="c86f" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#7a8a" rel="noopener ugc nofollow">启用 rpy2 的自动完成功能(非常适合 ggplot2) </a></li><li id="dafe" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#2c78" rel="noopener ugc nofollow">在一个漂亮的表格中总结字典和其他结构</a></li><li id="eea0" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#8dd4" rel="noopener ugc nofollow">有选择地从其他笔记本导入</a></li><li id="b096" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#68cb" rel="noopener ugc nofollow">出错或打开笔记本时，滚动到最近执行的单元格</a></li><li id="bfd0" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="#8313" rel="noopener ugc nofollow">长输出的交互(跟随)尾</a></li></ol><p id="781d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:为了方便使用，我将下面的代码片段收集到 Python3 包中(<a class="ae ku" href="https://github.com/krassowski/jupyter-helpers" rel="noopener ugc nofollow" target="_blank"> jupyter-helpers </a>)。您可以通过以下方式获得:</p><p id="a960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe la lb lc ld b">pip3 install jupyter_helpers</code></p><p id="4999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以开箱即用，但是如果您希望获得最佳体验，强烈推荐以下依赖项:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="9af9" class="lm ln iq ld b gy lo lp l lq lr">pip3 install ipywidgets<br/>jupyter labextension install @jupyter-widgets/jupyterlab-manager</span></pre><h1 id="3b5a" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">1.计算完成后播放一段声音</h1><p id="6831" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果一个单元(或一串单元)的执行时间超过几秒钟，您可以配置 Jupyter 来播放声音。我之前描述过两种方法，<a class="ae ku" href="https://stackoverflow.com/a/50648266/6646912" rel="noopener ugc nofollow" target="_blank">基于 Python 的方法</a>和<a class="ae ku" href="https://stackoverflow.com/a/50569680/6646912" rel="noopener ugc nofollow" target="_blank">基于 JavaScript 的方法</a>。python 的代码大致如下:</p><figure class="le lf lg lh gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，助手包得到了一个升级版本，它负责隐藏音频播放器和许多其他东西。像这样使用它:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="6837" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers.notifications import Notifications</span><span id="1e48" class="lm ln iq ld b gy mx lp l lq lr">Notifications(<br/>     success_audio='path/to/beep-07.wav', time_threshold=2<br/>)</span></pre><p id="3d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我使用了来自 soundjay.com 的<code class="fe la lb lc ld b">beep-07.wav</code>。如果你在 GNOME 中使用 Ubuntu 或其他发行版，你可以提供一个默认警告声音的路径，例如<code class="fe la lb lc ld b">/usr/share/sounds/gnome/default/alerts/bark.ogg</code>。</p><h2 id="af18" class="lm ln iq bd lt my mz dn lx na nb dp mb jy nc nd mf kc ne nf mj kg ng nh mn ni bi translated">异常时播放喇叭声音</h2><p id="fc2f" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">类似地，您可以添加一个钩子，在出现异常时发出不同的声音。这里有一个由 SO 的<a class="ae ku" href="https://stackoverflow.com/a/41603739/6646912" rel="noopener ugc nofollow" target="_blank"> Kevin 提出的非常简单的机制:</a></p><figure class="le lf lg lh gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="50b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，更先进的是<code class="fe la lb lc ld b">jupyter_helpers</code>包的一部分:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="af80" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers.notifications import Notifications</span><span id="9bb5" class="lm ln iq ld b gy mx lp l lq lr">Notifications(failure_audio='path/to/beep-05.wav')</span></pre><h1 id="ad45" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">2.将通知与您的操作系统集成</h1><p id="6bbb" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">当我在图书馆工作时，我需要一个哔哔声和喇叭声的替代品。对于我这个 GNOME 用户来说，Notify-send 变成了一个完美的工具(向下滚动查看其他桌面环境的说明)。<br/>设置事物使用:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="c662" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers.notifications import Notifications</span><span id="4fd8" class="lm ln iq ld b gy mx lp l lq lr">Notifications(<br/>    success_audio='path/to/beep-07.wav', time_threshold=2,<br/>    failure_audio='path/to/beep-05.wav',<br/>    integration='GNOME'<br/>)</span></pre><p id="7f31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对 GNOME 用户来说是现成的，尽管安装一个名为<code class="fe la lb lc ld b">notify-send.sh</code>的插件会让通知在不再需要时消失。这可以通过附加的<code class="fe la lb lc ld b">setup.sh</code>脚本来完成。</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/5d09d721f2e884502a214320140f610f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0e6UWteHV1sTe-IqD8gOmA.gif"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Figure 1: Fully integrated notifications</figcaption></figure><p id="3296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作系统集成已准备好与任何其他桌面环境挂钩，尽管它需要一些脚本:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2bac" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers.desktop_integration import DesktopIntegration</span><span id="03c8" class="lm ln iq ld b gy mx lp l lq lr">class WindowsIntegration(DesktopIntegration):</span><span id="50f8" class="lm ln iq ld b gy mx lp l lq lr">    def notify(self, title, text, notify_id=None, **kwargs):<br/>        pass   # add your code here</span><span id="3d69" class="lm ln iq ld b gy mx lp l lq lr">    def notify_close(self, notify_id):<br/>        pass   # add your code here</span><span id="0fdb" class="lm ln iq ld b gy mx lp l lq lr">Notifications(<br/>    success_audio='path/to/beep-07.wav', time_threshold=2,<br/>    failure_audio='path/to/beep-05.wav',<br/>    integration=WindowsIntegration<br/>)</span></pre><p id="6e1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您希望将它与您的操作系统集成，请考虑发送 PR。</p><h1 id="3424" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">3.跳转到变量/函数/类的定义</h1><p id="7dab" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">使用鼠标使用<code class="fe la lb lc ld b">Alt</code> + <code class="fe la lb lc ld b">click</code>跳转到一个定义，或者使用<code class="fe la lb lc ld b">Ctrl</code> + <code class="fe la lb lc ld b">Alt</code> + <code class="fe la lb lc ld b">B</code>带<a class="ae ku" href="https://github.com/krassowski/jupyterlab-go-to-definition" rel="noopener ugc nofollow" target="_blank">jupyterlab-go-to-definition</a>扩展的仅键盘选项:</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nu"><img src="../Images/97314c4360c5a78a32c121011eb1a70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zhQaX87SYMmAb95BRpPpWw.gif"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Jump-to-definition supports Python and R. PRs to support other languages are welcome</figcaption></figure><p id="99f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，使用<code class="fe la lb lc ld b">Alt</code> + <code class="fe la lb lc ld b">o</code>跳回到之前的位置:</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nv"><img src="../Images/93c70829a5849ffa77d087b0337f7e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MxBTo7EXdCiwsVeaAlDnng.gif"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">The ability to jump back is quite helpful for notebooks with longer outputs</figcaption></figure><p id="8126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安装扩展，请使用:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="bb6b" class="lm ln iq ld b gy lo lp l lq lr">jupyter labextension install @krassowski/jupyterlab_go_to_definition</span></pre><p id="cb99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2020 年更新:现在有了<a class="ae ku" href="https://github.com/krassowski/jupyterlab-lsp" rel="noopener ugc nofollow" target="_blank"> jupyterlab-lsp </a>更强劲的跳跃！</p><h1 id="7a8a" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">4.为 rpy2 启用自动完成功能(ggplot2！)</h1><p id="cd59" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果您的工作更多的是关于出版物而不是交互式仪表板，那么您很有可能熟悉 ggplot2。虽然有一些伟大的项目，如 plotnine，试图将其移植到 Python，但我仍然发现在使用 rpy2 R-Python 接口时，使用 ggplot(尤其是扩展)功能更完整。</p><p id="43e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，到目前为止，自动完成还不包括<code class="fe la lb lc ld b">%%R</code>单元格中的 R 对象(如果加载的话也不包括 ggplot 函数)。我准备了一个简单的解决方法:</p><figure class="le lf lg lh gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0d4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可能会在未来得到改进，正如本 GitHub 问题中所讨论的那样。</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e2c4f550d328aff7ae19a77c0bc52b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*WJwOEA_mMrj5GfP5TYkyiw.gif"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Auto-completion now also includes R objects and ggplot functions</figcaption></figure><p id="40d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，来自<code class="fe la lb lc ld b">jupyter_helpers</code>的一个简单导入将解决这个问题:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2360" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers import rpy2_autocompletion</span></pre><p id="4d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2020 年更新:现在也可以用<a class="ae ku" href="https://github.com/krassowski/jupyterlab-lsp" rel="noopener ugc nofollow" target="_blank"> upyterlab-lsp </a>完成！</p><h1 id="2c78" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">5.在一个漂亮的表格视图中总结字典</h1><p id="5ea5" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">这不是一个新颖的想法，尽管我希望分享我的比不太先进的类可以帮助别人。这是基于 Python3 <code class="fe la lb lc ld b">SimpleNamespace</code>的，但是为 Jupyter 扩展了一个支持熊猫和 numpy 的 HTML 表示:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="bea5" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers.namespace import NeatNamespace</span><span id="caed" class="lm ln iq ld b gy mx lp l lq lr">NeatNamespace(your_dict)</span></pre><p id="39e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长集合将被修剪，所以当浏览器努力呈现意外打印的字典时，不必担心空间或内存不足。水平和垂直方向可以更好地利用空间。</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/0efe4a5f4a0759e93241394f884b6f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXmow_ZSvv7BaN2IeY0ZWA.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Namespaces with HTML: when nested data needs to be looked at before converting to DataFrame</figcaption></figure><h1 id="8dd4" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">6.选择性地从其他笔记本导入</h1><p id="6746" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">有一段时间，我试图遵循数据/方法/结果分离，为每个更大的分析准备了三个 Jupyter 笔记本:<code class="fe la lb lc ld b">data.ipynb</code>、<code class="fe la lb lc ld b">methods.ipynb</code>和<code class="fe la lb lc ld b">results.ipynb</code>。为了节省对一些东西进行无用的重新计算的时间，我想从<em class="ny">数据</em>和<em class="ny">方法</em>笔记本中进行选择性导入，以便在<em class="ny">结果</em>笔记本中使用。</p><p id="b503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在可以(基于<a class="ae ku" href="https://github.com/grst/nbimporter" rel="noopener ugc nofollow" target="_blank"> nbimporter </a>)使用一个导入和一个魔法:</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nz"><img src="../Images/11ebe2e559fd71f4fc9254607fbf2089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWeX3c1rhXXIyy2qIxeHSQ.png"/></div></div></figure><p id="7bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个在本 SO 线程中<a class="ae ku" href="https://stackoverflow.com/questions/54317381/selectively-import-from-another-jupyter-notebook" rel="noopener ugc nofollow" target="_blank">有描述，还是希望看到一些建议。</a></p><h1 id="68cb" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">7.滚动到最近执行的单元格</h1><p id="9739" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">您可能已经注意到，之前显示的<code class="fe la lb lc ld b">Notifications</code>类使笔记本在异常情况下向下滚动到违规单元格(图 1)。通过<code class="fe la lb lc ld b">scroll_to_exceptions=False</code>可以禁用此功能。</p><p id="ee6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，如果您想要更多的自动滚动，您可以使用底层助手函数来标记您晚上结束工作的单元格，以便在早上快速打开笔记本:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2738" class="lm ln iq ld b gy lo lp l lq lr">from jupyter_helpers.utilities import scroll_to_current_cell</span><span id="0348" class="lm ln iq ld b gy mx lp l lq lr">scroll_to_current_cell(preserve=True)</span></pre><h1 id="8313" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">8.用于长输出的交互式尾部</h1><p id="81d0" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">最后，当运行第三方应用程序时(但不是在构建一个完全成熟的管道的时候)，人们可能只想看到当前运行的进程的尾部。在 bash 中，使用<code class="fe la lb lc ld b">tail -f</code>很容易实现。</p><p id="086c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要查看输出，并且在刷新到笔记本电脑时会降低计算机速度，或者只是生成冗长的输出，那么<code class="fe la lb lc ld b">FollowingTail</code> helper 可能适合您:</p><figure class="le lf lg lh gt mu gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8a39b43b10f2202c7b1891f3578f85ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*JGfa3synC4t4iY5lALCJyw.gif"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">Apply tail -f equivalent to keep the outputs at reasonable length!</figcaption></figure><h1 id="d249" class="ls ln iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">接下来还有更多！</h1><p id="b2ba" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我现在只有这么多时间，但我会分享更多已经写好的和新的助手和片段。这是一种回馈令人惊叹的科学计算社区的方式(从 Python 和 R 端)，它使我能够完成我的论文。我有另一个项目来，这可能需要克服其他挑战。</p><p id="cc50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦准备好了，我会在 Twitter 上分享这个消息。</p><p id="f95f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读——希望它值得至少为一位研究人员撰写。</p></div></div>    
</body>
</html>