<html>
<head>
<title>Hands-on End-to-End Automated Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动手端到端自动化机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-end-to-end-automated-machine-learning-a50e6bce6512?source=collection_archive---------18-----------------------#2019-12-15">https://towardsdatascience.com/hands-on-end-to-end-automated-machine-learning-a50e6bce6512?source=collection_archive---------18-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7939" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 AutoML 库在 Python 环境中进行 AutoML 编码的实践经验。</h2></div><p id="cf5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从 Python 中的一个基本管道方法开始，它实际上没有 AutoML，然后快速传递到著名的 AutoML 库。我们还将 OptiWisdom 的趋势自动 SaaS 解决方案(如 OptiScorer)与经典方法进行了比较。</p><p id="150f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是对端到端自动化机器学习过程的快速介绍，从不同的角度介绍了许多不同的库。此外，您将能够对 AutoML 库进行比较并做出战略决策。</p><p id="20f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不知道什么是 AutoML 或者它的用途，你也可以开始阅读下面的文章。</p><p id="f7df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" rel="noopener" target="_blank" href="/automl-end-to-end-introduction-from-optiwisdom-c17fe03a017f">https://towards data science . com/automl-end-to-end-introduction-from-opti wisdom-c 17 Fe 03 a 017 f</a></p><h1 id="9816" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">Python 中机器学习的流水线和端到端解决方案介绍。</h1><p id="e06f" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">从这一点开始，我们将实现一个逐步编码的例子，其思想是用 sklearn 库实现 python 中最<strong class="kk iu">原语</strong>编码风格的分类。在这个例子中有两个重要的问题。首先，我们将讨论 sklearn 中的流水线，这是一种非常类似于 AutoML 流程的整体方法，其次，我们将使用网格搜索方法进行非常原始的超参数优化。</p><p id="2361" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文的步骤如下图所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/645d1abcaf1cd366b1d78230c8f1afad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY9P1H0d5vUKmdjriE05Ng.png"/></div></div></figure><p id="5d57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Python 中，一种相对较新的称为流水线的方法是实现系统并将所有步骤结合在一起的经典方式。作为一种动手的编码实践，可以用 Python 编写如下的流水线方法:</p><ol class=""><li id="0340" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated"><strong class="kk iu">加载数据集:</strong>实际上，这一步是数据连接层，对于这个非常简单的原型，我们将保持它的简单性，就像从 sklearn 库加载数据集一样:</li></ol><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="af96" class="nc lg it my b gy nd ne l nf ng">"""<br/>@author: sadievrenseker<br/>"""<br/>import pandas as pd<br/>import numpy as np<br/><br/>from sklearn import datasets<br/>data = datasets.load_iris()</span></pre><p id="c7aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。上面的代码是从 sklearn 数据集加载的一个非常简单的数据集。直到数据被加载到数据层对象中，加载数据集的问题才结束。在本例中，我们将使用 pandas 作为数据访问层，并通过以下代码将数据集加载到 pandas 对象中:</strong></p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="e70a" class="nc lg it my b gy nd ne l nf ng">df = pd.DataFrame(data = np.column_stack((data.data, data.target)), columns=data.feature_names + ['Species'])<br/>df.head()</span></pre><p id="a428" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码将返回以下输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nh"><img src="../Images/0d01dc56b82bbaa83d90d3c019731a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngtZkDL1EnV58yeTC5a44A.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">DataFrame output for the data loading</figcaption></figure><p id="0f00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图展示了加载的数据框是 sklearn 数据集的原始版本。在某些数据集中，物种列可能是物种的名称，如“鸢尾”、“鸢尾-杂色”和“鸢尾-海滨”。</p><p id="d75c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。探索性数据分析(EDA): </strong>如果是这种情况，我们将在稍后的数据预处理中处理字符串类型，从这一点开始，如果数据科学家对数据集不熟悉，他/她可能会选择探索性数据分析(EDA)，这在大多数现实生活问题中都会发生。因此，上述代码后面的代码可能是一些可视化或信息，如下所示:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="69dc" class="nc lg it my b gy nd ne l nf ng">import seaborn as sns<br/>sns.pairplot(df, hue='Species', size=3)</span></pre><p id="8ae3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码将返回以下输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nm"><img src="../Images/891a898432f4280f1df7132c7ee57632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7I1w9ViBGrk6uhUUclHOTg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">EDA Output for Iris Data Set</figcaption></figure><p id="1b2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 seaborn 矩阵图上，</p><p id="7c77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保存所有可能的 2D 组合中的逐列匹配和数据分布的可视化。</p><p id="77eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于流水线操作，整个系统被插入到单个流水线中，在常规的 AutoML 方法中，有数据预处理和机器学习过程，如本章第一节中已经解释的。</p><p id="b28e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这种实践经验，我们将使用 K-NN 连同标准的定标器和标签编码器。</p><p id="621b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，标准缩放器和标签编码器是预处理阶段，而 K-NN 将是机器学习阶段。</p><p id="5102" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。编码:</strong>如果加载的数据集有带标签的物种列，那么标签编码器解决从字符串到数值的转换。在我们的数据集例子中，这不是问题，因为原始数据集在物种列中保存数值，如下面的代码所示:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="2b92" class="nc lg it my b gy nd ne l nf ng">df['Species'] = LabelEncoder().fit_transform(df['Species'])</span></pre><p id="d292" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码将返回以下输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nn"><img src="../Images/2f38fb4b03b2326770cc00c1c5061059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6S7kurRjk_FrZFanOmKXQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Encoded DataFrame</figcaption></figure><p id="8be0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 5。标准化:</strong>在标签编码之后，我们可以继续标准化。归一化将数据集要素转换到相同的范围内。我们将使用标准分布来转换所有功能:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="f125" class="nc lg it my b gy nd ne l nf ng">df.iloc[:,:4] = StandardScaler().fit_transform(df.iloc[:,:4])</span></pre><p id="edd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码将返回以下输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi no"><img src="../Images/969e5f55188765dcb18803f890cab2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sigfVwTvjTCnUaq1X2qHjQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Normalized version of DataFrame</figcaption></figure><p id="7923" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面显示了数据的缩放版本，现在数据已准备好进行分类。</p><p id="0aaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 6。测试和训练集:</strong>我们将使用 K-NN 算法进行分类，在常规编码中，我们可以将数据分为训练集和测试集，然后进行如下分类:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="d6d8" class="nc lg it my b gy nd ne l nf ng">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(df.iloc[:,:-1].values,<br/> df['Species'],<br/> test_size = 0.4,<br/> random_state = 123)</span></pre><p id="cd7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 7。机器学习:</strong>将数据拆分成 0.6 比 0.4 的训练/测试集后，现在可以应用 K-NN 算法了。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="5b7b" class="nc lg it my b gy nd ne l nf ng">from sklearn.neighbors import KNeighborsClassifier<br/>knn = KNeighborsClassifier(n_neighbors = 3)<br/>knn.fit(X_train,y_train)<br/>predictions = knn.predict(X_test)</span></pre><p id="da66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在上面的代码中很容易地注意到，在上面的示例中，n_neighbors 参数被设置为 3。</p><p id="76f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 8。超参数优化:</strong>参数优化的一个解决方案是使用网格搜索，但是在进入网格搜索之前，我们将使用如下混淆矩阵和计分器显示算法的成功:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="82dd" class="nc lg it my b gy nd ne l nf ng">from sklearn.metrics import confusion_matrix<br/>cm = confusion_matrix(y_test,predictions)<br/>print(cm)</span></pre><p id="fa56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码执行后，我们得到的混淆矩阵如下:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="6d39" class="nc lg it my b gy nd ne l nf ng">[[22 0 0]<br/> [ 0 15 1]<br/> [ 0 2 20]]</span></pre><p id="79ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 9。评价:</strong>对于已经熟悉混淆矩阵的读者来说，已经很清楚我们在 60 个数据点中只有 3 个错误。也是有经验的数据科学家，以前玩过 iris 数据集可以很容易地识别出第一类的清晰分类和第二类与第三类之间的问题。为了阐明数字上的成功，让我们计算准确性的分数，如下面的代码所示:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="3ce5" class="nc lg it my b gy nd ne l nf ng">from sklearn.metrics import accuracy_score<br/>score = accuracy_score(y_test,predictions)<br/>print(score)</span></pre><p id="4834" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 10。Score: </strong>我们案例的分数是 0.95，现在我们可以通过使用网格搜索来优化精确度。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="db98" class="nc lg it my b gy nd ne l nf ng">from sklearn.model_selection import GridSearchCV<br/>k_range = list(range(1, 31))<br/>print(k_range)<br/>param_grid = dict(n_neighbors=k_range)<br/>print(param_grid)<br/>grid = GridSearchCV(knn, param_grid, scoring='accuracy')<br/>grid.fit(X_train, y_train)<br/> <br/>print(grid.best_params_)</span></pre><p id="577b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码使用了 sklearn 库中的 GridSearchCV 类，它实际上使用了交叉验证来寻找最佳参数，我们给出了 k 从 1 到 31 的搜索空间。所以，这里的网格搜索基本上从 k= 1 开始，每次迭代增加 k 参数值 1。GridSearchCV 类也输出最佳参数，如下所示:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="2bab" class="nc lg it my b gy nd ne l nf ng">{'n_neighbors': 5}</span></pre><p id="03cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，针对虹膜数据集的 K-NN 模型的精度的优化参数是 k=5。</p><p id="3bf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 11。流水线:</strong>现在，我们可以把上面所有的代码放到一个流水线中，如下所示:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="eebf" class="nc lg it my b gy nd ne l nf ng">from sklearn.pipeline import Pipeline<br/>pipeline = Pipeline([<br/> ('normalizer', StandardScaler()), #Step1 - normalize data<br/> ('clf', KNeighborsClassifier()) #step2 - classifier<br/>])<br/>print(pipeline.steps)</span></pre><p id="7cf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">流水线步骤的输出如下:</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="0817" class="nc lg it my b gy nd ne l nf ng">[('normalizer', StandardScaler(copy=True, with_mean=True, with_std=True)), ('clf', KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',<br/> metric_params=None, n_jobs=None, n_neighbors=5, p=2,<br/> weights='uniform'))]</span></pre><p id="e5e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">12.现在，管道对任何设置都是开放的，并且在添加到管道时，规格化器或分类算法的参数也可以部署到构造函数中。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="2404" class="nc lg it my b gy nd ne l nf ng">from sklearn.model_selection import cross_validate<br/>scores = cross_validate(pipeline, X_train, y_train)<br/>print(scores)</span></pre><p id="dc1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面这段代码通过使用训练数据和标签来训练整个管道。在执行之后，scores 变量保存交叉验证的每一次得分的详细信息，如下所示。</p><pre class="md me mf mg gt mx my mz na aw nb bi"><span id="6fd5" class="nc lg it my b gy nd ne l nf ng">{'fit_time': array([0.00163412, 0.0012331 , 0.00207829]), 'score_time': array([0.00192475, 0.00164199, 0.00256586]), 'test_score': array([0.96875   , 1.        , 0.93103448]), 'train_score': array([0.96551724, 0.98360656, 1.        ])}</span></pre><h1 id="8155" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">摘要</h1><p id="fe72" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们实现了从数据源到机器学习算法评估分数的经典 python 机器学习过程，包括超参数优化，从上面的第一步开始，一直到步骤 11。在第 11 步和第 12 步，我们用 sklearn 下的流水线方法重新实现了整个过程，并立即执行。</p><p id="658a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请再次记住，我们的步骤可以演示如下:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/645d1abcaf1cd366b1d78230c8f1afad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY9P1H0d5vUKmdjriE05Ng.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Steps of operations in this article</figcaption></figure><p id="6a6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们的方法与 CRISP-DM 步骤非常相似:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/62e46986d5a783e765e76664f1b4694f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*dwL4QjJujLaQK9m5XWlkwA.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">CRISP-DM Steps</figcaption></figure><p id="3918" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是对 AutoML 过程的一个非常原始的介绍，我们实现流水线只是为了更好的理解。</p></div></div>    
</body>
</html>