<html>
<head>
<title>Efficiently Finding a Root of an Expensive Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效地寻找昂贵函数的根</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficiently-finding-a-root-of-an-expensive-function-80431c035bb?source=collection_archive---------34-----------------------#2019-11-17">https://towardsdatascience.com/efficiently-finding-a-root-of-an-expensive-function-80431c035bb?source=collection_archive---------34-----------------------#2019-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f472" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释了二次插值，用 Python 编写了示例代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8bcc0261b9dd9f70f31860d6ac1565f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y3cIc1rlCEVgj8K2"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@joshriemer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josh Riemer</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候在科学编程中，你需要使用一个平滑的实值函数<em class="lv"> f </em> ( <em class="lv"> t </em>)来计算开销。具体来说，你可能需要找到函数值变为零的地方。我最近在我的<a class="ae ky" href="https://github.com/cosinekitty/astronomy" rel="noopener ugc nofollow" target="_blank">开源天文图书馆</a>工作时遇到了这个问题。我想知道月出月落的时间。这包括计算地球的自转和月球绕地球的轨道，以确定在特定地理位置的观察者所看到的月球何时穿过地平线。</p><p id="e278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，<em class="lv"> f </em> ( <em class="lv"> t </em>)是观察者在时间<em class="lv"> t </em>看到的月亮在地平线以上或以下的视在角高度。找到月出或月落时间意味着找到<em class="lv"> t </em>的值，使得<em class="lv"> f </em> ( <em class="lv"> t </em> )=0。用数学术语来说，我想找到函数<em class="lv"> f </em>的<em class="lv">根</em>。</p><p id="8b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评估<em class="lv"> f </em> ( <em class="lv"> t </em>)包括计算月球位置，这需要上千次浮点运算。我想尽量减少我不得不评估<em class="lv"> f </em> ( <em class="lv"> t </em>)的次数，因为我找到了一个足够好的值<em class="lv"> t </em>。我寻找精确到几秒钟以内的时间。</p><p id="7731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这类问题的一个相当好的方法是在开根之前找到时间<em class="lv"> t </em> ₀，在开根之后找到另一个时间<em class="lv"> t </em> ₁。假设你知道时间间隔足够小，在它里面不会有一个以上的根。(在我的例子中，我知道一个小时内不可能有一次以上的月出。)</p><p id="7a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你确定<em class="lv"> f </em> ( <em class="lv"> t </em> ₀) &lt; 0，f( <em class="lv"> t </em> ₁) &gt; 0。情况看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/401099cdb96144e06f70c2531e10cca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*6GcapTBeTg1ZStu4QejXMQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">There must be at least one root in the interval indicated by the arrow.</figcaption></figure><p id="e5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于<em class="lv"> f </em>是一个连续函数，在<em class="lv"> t </em> ₀和<em class="lv"> t </em> ₁之间至少有一个<em class="lv"> t </em>的值，使得<em class="lv"> f </em> ( <em class="lv"> t </em> )=0。连续函数不可能不经过零就从负值变成正值。</p><p id="3a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了取得进展，我们在区间中间的时间<em class="lv"> t </em> ₂评估函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="eaf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你发现<em class="lv"> f </em> ( <em class="lv"> t </em> ₂) &lt; 0。现在你已经了解了一些新的信息。你已经发现根一定在更窄的区间内的某个地方<em class="lv">t</em>₂&lt;t<em class="lv">t</em>t&lt;t<em class="lv">t</em>₁:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/c5a18f662b14b0a77144446818dea3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*J-eIm3ZILpMnIWsRZvGBTQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The uncertainty of the root’s location has been cut in half.</figcaption></figure><p id="92e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您发现<em class="lv"> f </em> ( <em class="lv"> t </em> ₂) &gt; 0，您可以将您的搜索限制在左边的半区间，<em class="lv">t</em>₀&lt;t&lt;T6】t₂.</p><p id="c9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论哪种方式，您都可以将音程切成两半，并选择哪一半必须包含根。重复这样做被称为二分搜索法。您可以不断迭代，直到时间间隔变得相当小。</p><p id="d961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我所说，二分搜索法是一种相当快速的方法。但是在某些条件<strong class="lb iu">下，使用<em class="lv">二次插值</em>比二分搜索法</strong>求函数的根要快得多。以下是条件:</p><ul class=""><li id="c235" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">该功能为<strong class="lb iu">平滑连续</strong>。</li><li id="f175" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">该函数在很小的区间内很好地近似为抛物线<em class="lv">t</em>₀&lt;t&lt;t<em class="lv">t</em>₁.非正式地说，在给定的区间上，函数有少量的曲率。</li><li id="9885" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在函数值过零的<em class="lv"> t </em> ₀和<em class="lv"> t </em> ₁之间，必须有<strong class="lb iu">恰好一个<em class="lv"> t </em>的</strong>值。换句话说，函数在给定的时间间隔内必须有唯一的根。</li></ul><p id="f251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置类似于上面的二分搜索法，在三个等间距的参数值<em class="lv"> t </em>处评估函数。不同的是，你<strong class="lb iu">求的是经过三点</strong>的唯一二次函数。二次函数在小间隔上逼近昂贵函数<em class="lv"> f </em>的值。二次函数看起来像这里的红色曲线:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/05b6afabf7e1eb352fbc6534c1d794e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*RX1XxvTAM2QnXEIxVUc9cw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Finding an approximate root using a quadratic curve.</figcaption></figure><p id="f330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦有了通过三点的抛物线的公式，就可以使用二次公式来求解抛物线与<em class="lv"> t </em>轴相交的<em class="lv"> t </em>的值。</p><p id="2daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么你如何找到抛物线呢？让我们一步一步来。首先，我们将把在范围<em class="lv">t</em>₀≤<em class="lv">t</em>≤<em class="lv">t</em>₁内变化的时间变量<em class="lv"> t </em>替换为一个抽象参数<em class="lv"> x </em>，它具有更方便的范围 1≤ <em class="lv"> x </em> ≤+1。这将使数学更简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn ly l"/></div></figure><p id="336f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花点时间来验证一下</p><ul class=""><li id="1685" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">如果<em class="lv"> t </em> = <em class="lv"> t </em> ₀，那么<em class="lv">x</em>= 1；</li><li id="1a0e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如果<em class="lv"> t </em> = <em class="lv"> t </em> ₂，那么<em class="lv">x</em>= 0；</li><li id="9286" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">而如果<em class="lv"> t </em> = <em class="lv"> t </em> ₁，那么<em class="lv"> x </em> =+1。</li></ul><p id="b2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三种情况为真，因为₂位于₀和₁的中间，因此分子和分母相等。</p><p id="14b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步是写一个通用的抛物线函数<em class="lv"> p </em> ( <em class="lv"> x </em>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo ly l"/></div></figure><p id="ddd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总是恰好有一条抛物线通过这三个点。我们的下一个目标是找到导致抛物线<em class="lv"> p </em> ( <em class="lv"> x </em>)通过我们为昂贵函数<em class="lv"> f </em>评估的三个点的<em class="lv"> Q </em>、<em class="lv"> R </em>和<em class="lv"> S </em>的值。我们写出反映这一要求的三个线性方程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ly l"/></div></figure><p id="5a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据已知值<em class="lv"> f </em> ( <em class="lv"> t </em> ₀)、<em class="lv"> f </em> ( <em class="lv"> t </em> ₂)和<em class="lv"> f </em> ( <em class="lv"> t </em> ₁)解这个三线性方程组，我们发现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq ly l"/></div></figure><p id="4a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，你的算法必须检查特殊情况。<strong class="lb iu">如果<em class="lv"> Q </em> =0，表示直线，而不是抛物线，通过所有三点。</strong>换句话说，<em class="lv">p</em>(<em class="lv">x</em>)=<em class="lv">Rx</em>+<em class="lv">S</em>。求根求<em class="lv">x</em>=<em class="lv">S</em>/<em class="lv">R</em>。当 Q=0 时，还需要检查<em class="lv"> R </em> =0，以避免被零除。这种情况下，线是水平的，因此没有零交叉。否则，如果<em class="lv"> Q </em>不为零，则继续执行以下步骤来寻找 0、1 或 2 个实根。</p><p id="bbf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找到当<em class="lv"> Q </em> ≠0 时二次曲线<em class="lv"> p </em> ( <em class="lv"> x </em>)的根，我们使用熟悉的二次公式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ly l"/></div></figure><p id="b380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个特例是平方根<em class="lv">R</em>4<em class="lv">QS</em>是否为负。如果<em class="lv">R</em>4<em class="lv">QS</em>&lt;0，则<em class="lv"> p </em> ( <em class="lv"> x </em>)没有实根。当<em class="lv"> p </em> ( <em class="lv"> x </em>)对于<em class="lv"> x </em>的所有值总是为正或总是为负时，就会发生这种情况。因为抛物线从不穿过零点，所以您的求解器必须报告失败。</p><p id="215e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须在自己的应用中决定如何处理<em class="lv">R</em>4<em class="lv">QS</em>= 0 的情况。当平方根为零时，表示<em class="lv"> p </em> ( <em class="lv"> x </em>)有一个切根，表示抛物线的顶点刚好接触横轴，但不穿过横轴，如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/4bd662b27eede54c13d49d33fe7097b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*fMv0EVlZd_DBMokgntPFWw.png"/></div></figure><p id="f7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的天文学代码中，把这算作月出或月落是没有意义的。所以我选择将<em class="lv">R</em>—4<em class="lv">QS</em>≤0 视为失败。这种行为反映在下面的示例 Python 代码中。</p><p id="7505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经排除了上面提到的特例，现在你有两个候选值<em class="lv"> x </em>，这要感谢二次公式中的运算符。您的代码应该检查这两个值，看看它们中的哪一个(如果有的话)在 1≤ <em class="lv"> x </em> ≤+1 的范围内。超出此范围的任何值<em class="lv"> x </em>都应该被丢弃，因为它超出了您指定的搜索间隔。即使您想使用这些异常值中的一个，抛物线也不能被认为是原始函数<em class="lv"> f </em>在搜索区间之外很远的一个很好的近似。</p><p id="6490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的天文学用例中，我知道<em class="lv">先验地</em>我的搜索区间必须包含至多一个有效根。因此，如果<em class="lv"> x </em>的两个值满足搜索间隔，我也会报告失败。</p><p id="98f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您最终得到了唯一的有效值<em class="lv"> x </em>，最后一步是将<em class="lv"> x </em>转换回您的独立变量<em class="lv"> t </em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms ly l"/></div></figure><p id="cf59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了。通过仅评估一个昂贵的函数三次，并且假设该函数在封闭区间内是充分抛物线的，我们现在有了一个很好的近似<em class="lv"> t </em>，使得<em class="lv"> f </em> ( <em class="lv"> t </em> )=0。</p><p id="d8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<em class="lv"> t </em>有多准呢？这个问题没有简单的答案。您将不得不试验您自己的函数和区间大小来找出答案。</p><p id="08d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会发现混合方法很有帮助:首先使用二分搜索法缩小足够小的区间(基于实验测试)，然后使用二次插值完成这项工作。我自己的算法(参见天文引擎的<a class="ae ky" href="https://github.com/cosinekitty/astronomy/blob/master/source/python/astronomy.py" rel="noopener ugc nofollow" target="_blank"> Python 版本中的函数<code class="fe mt mu mv mw b">Search</code>)使用了一种更复杂的混合算法，试图猜测二次插值的非常小的区间，这种算法在大多数时候都有效。当猜测不正确时，它退回到二分搜索法。在我的性能测试中，这与“纯”二分搜索法一样准确，但是计算时间只有 1/6。</a></p><h2 id="58e3" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">Python 示例代码</h2><p id="93f1" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">以下是示例 Python 代码，演示了如何使用二次插值来寻找近似根。您可以随意使用函数<code class="fe mt mu mv mw b">QuadraticInterpolate</code>作为自己应用程序的起点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv ly l"/></div></figure></div></div>    
</body>
</html>