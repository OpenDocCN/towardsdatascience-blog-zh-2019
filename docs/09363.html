<html>
<head>
<title>Numpy and Pandas for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的 Numpy 和熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-and-pandas-for-data-scientists-2be4a093b4b5?source=collection_archive---------27-----------------------#2019-12-10">https://towardsdatascience.com/numpy-and-pandas-for-data-scientists-2be4a093b4b5?source=collection_archive---------27-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c914f9a1d2bdd3e565f371164f75fb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUTcK-0zEh1Rnrdy4UITaA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://www.pexels.com/@kevin-ku-92347" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae kf" href="https://www.pexels.com/photo/coding-computer-data-depth-of-field-577585/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="e9dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Numpy 是一个用于科学计算的 python 包。它支持大型多维数组和矩阵。Pandas 是用于数据操作和分析的 python 库。对这两个库有扎实的了解对于特征工程、数据插补和模型构建非常有用。</p><p id="e764" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将回顾 numpy 和 pandas 的一些简单应用，包括数据标注、工程特性和输入缺失值。</p><p id="36b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于本帖的目的，我们将使用来自<em class="le"> </em> UCI ML 回购的<em class="le">在线零售数据集</em>，该数据集可在<a class="ae kf" href="https://www.kaggle.com/jihyeseo/online-retail-data-set-from-uci-ml-repo" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到。该数据包含一家英国在线商店从 2010 年 1 月 12 日到 2011 年 9 月 12 日的交易信息。这家商店出售独特的节日礼品。</p><p id="510b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们开始吧！</p><p id="f635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们将数据读入 pandas 数据帧，并打印前五行:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="46b7" class="lo lp it lk b gy lq lr l ls lt">import pandas as pd <br/>df = pd.read_csv("online_retail.csv")<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/7eccf1f8122f8a297b56ef20bf396f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*4OslFMt-PwSNLovfVEv2Sw.png"/></div></figure><h1 id="bad7" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">输入缺失值</h1><p id="003c" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated"><em class="le">用零估算缺失/错误的数值</em></p><p id="d2a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在处理真实数据列时，经常会包含缺失值或错误值。缺少的值通常显示为“nan ”,它代表“不是一个数字”,错误的值可能是那些与现实中出现的值不一致的值。错误值的一个例子可能是负数或无穷大的价格。输入缺失数值的一种方法是用零替换它们。该数据不包括缺失值，因此我们可以人为地添加一些无穷大的缺失值:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="992f" class="lo lp it lk b gy lq lr l ls lt">np.random.seed(42)<br/>df['column_with_bad_values'] = df['UnitPrice']/np.random.randint(4, size = len(df))<br/>df['column_with_bad_values'].iloc[3] = np.nan<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/7ab7a5b8061bf7745581dedffd9eb783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*jmtzq1ErMAffJZrYGKZD8Q.png"/></div></figure><p id="5d8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用 fillna()将缺失的值替换为零:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2ed6" class="lo lp it lk b gy lq lr l ls lt">df['column_with_bad_values'].fillna(0, inplace = True)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/94aa5d9a86c609eee92141473e7832e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*k9fy5glZePFfOG7L4b-b_g.png"/></div></figure><p id="69d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用 np.isinf()对无穷大的值做类似的事情:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0fc6" class="lo lp it lk b gy lq lr l ls lt">df.loc[np.isinf(df['column_with_bad_values']), 'column_with_bad_values'] = 0</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1f47151895ba3098a7c60cfd84a90d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*NkvAk7fubdbv6hCMb4ZXjw.png"/></div></figure><p id="3c82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">用平均值估算缺失的数值</em></p><p id="7514" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们的数据有以下缺失值(注意，我已经删除了无限值):</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6689" class="lo lp it lk b gy lq lr l ls lt">np.random.seed(42)<br/>df['column_with_bad_values'] = np.random.randint(4, size = len(df))<br/>df['column_with_bad_values'].iloc[0] = np.nan<br/>df['column_with_bad_values'].iloc[2] = np.nan<br/>df['column_with_bad_values'].iloc[4] = np.nan<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5eac867b4611cef8fc740679bbdfc185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*V8Yu6RIv93e4BKouHPRQtg.png"/></div></figure><p id="31bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将“nan”值替换为该列的平均值，如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ba8d" class="lo lp it lk b gy lq lr l ls lt">df['column_with_bad_values'].fillna(df['column_with_bad_values'].mean(), inplace = True)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/232074e9eb288c0b68679cd40b23a6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*K4-YhJSuJZUZBHzjP7eqpw.png"/></div></figure><p id="8ed7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，所有以前的“nan”值都已替换为平均值 1.500803。如果我们保持无穷大的值，这就行不通了。让我们尝试在同时具有无穷大和“nan”值的情况下，使用均值法进行插补:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="64f7" class="lo lp it lk b gy lq lr l ls lt">np.random.seed(32)<br/>df['column_with_bad_values'] = df['UnitPrice']/np.random.randint(4, size= len(df))<br/>df['column_with_bad_values'].iloc[0] = np.nan<br/>df['column_with_bad_values'].iloc[2] = np.nan<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2c4701808bc6e9f554ab9321d548ed97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*74_Qqk9u4k9Cfk9WupjFCQ.png"/></div></figure><p id="aede" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有无限值和“nan”值，我们希望用平均值估算，我们可以将无限值转换为“nan”值，然后用平均值填充“nan”值:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e4df" class="lo lp it lk b gy lq lr l ls lt">df.loc[np.isinf(df['column_with_bad_values']), 'column_with_bad_values'] = np.nan<br/>df['column_with_bad_values'].fillna(df['column_with_bad_values'].mean(), inplace = True)</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/8c33a55cf1a61078dd260161d2a97edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*KCmEs8knC8SVm6xotwA7sg.png"/></div></figure><p id="eaa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，无穷大值和缺失值都被平均值 2.692406 所取代。请注意，这个平均值是不同的，因为我们更改了随机数种子，我们使用它来生成用于演示的随机整数。</p><p id="7b40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">用正态分布的随机数估算缺失/错误的数值</em></p><p id="0bf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用 fillna()和 np.random.normal()用正态分布的随机数填充缺失值。首先，让我们重新生成缺失值的数据帧:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d14b" class="lo lp it lk b gy lq lr l ls lt">np.random.seed(32)<br/>df['column_with_bad_values'] = np.random.randint(4, size= len(df))<br/>df['column_with_bad_values'].iloc[0] = np.nan<br/>df['column_with_bad_values'].iloc[2] = np.nan<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/eec7ca6876bbd6565c25326621712e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*e571h1v0AYiEvYtmd4yK-A.png"/></div></figure><p id="7e1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正态分布是根据列的平均值和标准差构建的。然后，我们可以使用 fillna()和 np.random.normal()的值来填充缺少的值:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b6da" class="lo lp it lk b gy lq lr l ls lt">mu, sigma = df['column_with_bad_values'].mean(), df['column_with_bad_values'].std()<br/>df['column_with_bad_values'].fillna(np.random.normal(mu, sigma), inplace = True)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5b95705812efd2e1de09d396fd877eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*dYFsyVSEtqKrIDhndlxlsQ.png"/></div></figure><p id="b89f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">用模式</em>估算缺失/错误的分类变量</p><p id="77a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用 fillna()和 mode()来估算缺失分类变量的值。首先，让我们生成测试数据框架:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="a401" class="lo lp it lk b gy lq lr l ls lt">df['column_with_bad_values'] = df['Description']<br/>df['column_with_bad_values'].iloc[0] = np.nan<br/>df['column_with_bad_values'].iloc[2] = np.nan<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6e2b1adc032bdc69669b08693550e293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*T06T2Rjii00e0HQKn8iYdA.png"/></div></figure><p id="cb6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以使用统计包中的模式来填充这些缺失值:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e128" class="lo lp it lk b gy lq lr l ls lt">from statistics import mode<br/>mode = mode(list(df['column_with_bad_values'].values))<br/>df['column_with_bad_values'].fillna(mode, inplace = True)<br/>print(df.head())</span></pre><h1 id="391d" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">特色工程</strong></h1><p id="9430" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated"><em class="le">数值数据的对数变换</em></p><p id="da62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于演示的目的，我将对数据进行一些过滤。我将只考虑单价大于或等于$5 且小于或等于$30 的记录。此外,“单价”列类型需要从字符串转换为数字类型。为了简单起见，我将价格转换为整数:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="cca6" class="lo lp it lk b gy lq lr l ls lt">df['UnitPrice'] = df['UnitPrice'].astype(int)<br/>df = df[df['UnitPrice'] &gt;= 5]<br/>df = df[df['UnitPrice'] &lt;= 30]<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/834d6f73c6b338b2701ec518fd4752d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*J4IaPDkOCzj0b0Fu34Jzjw.png"/></div></figure><p id="1ccd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特征工程的一个流行例子是获取数据集中某个数字列的日志。为了形象化，我们将比较记录前后的价格分布:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="4911" class="lo lp it lk b gy lq lr l ls lt">df['UnitPrice'].hist()</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0210d263c9f4454246b5b80e91368f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*pyknzBRb6uucaWDkW9Bskg.png"/></div></figure><p id="5442" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进行对数变换后，我们得到:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="fe6d" class="lo lp it lk b gy lq lr l ls lt">import numpy as np <br/>df['log_price'] = np.log(df['UnitPrice'])<br/>df['log_price'].hist()</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/45c09d01f91fc64bc19427159fcd7aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*BN9PbEavKdZOi2dZR-L2wg.png"/></div></figure><p id="a72b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，这种转换使价格值符合某种看起来更像正态分布的东西。当涉及到模型构建时，这具有有利的属性。</p><p id="e93d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">特征工程使用 np.where() </em></p><p id="31a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用 np.where()将新列定义为机器学习模型目标或作为模型输入的附加特征。例如，我们可以使用 np.where()创建一列布尔值。首先让我们看一下原始数据的前五行:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="18cf" class="lo lp it lk b gy lq lr l ls lt">df = pd.read_csv("online_retail.csv")<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/7eccf1f8122f8a297b56ef20bf396f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*4OslFMt-PwSNLovfVEv2Sw.png"/></div></figure><p id="ce8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建一个新列，该列的值为 True，描述值为“白色悬挂心形 T 形灯座”，对应于第一行:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="7748" class="lo lp it lk b gy lq lr l ls lt">df['bool_description'] = np.where(df['Description'] == 'WHITE HANGING HEART T-LIGHT HOLDER', True, False)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/70d8dc3d6b9c6ba0ef3782004a24484b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*xgdeITvF9UGp2Ez2j4Jwgg.png"/></div></figure><p id="6722" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以对多个描述值执行相同的操作。我们可以定义一个描述值列表，我们的新列将为其提供真实值:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d8b6" class="lo lp it lk b gy lq lr l ls lt">description_list = ['WHITE HANGING HEART T-LIGHT HOLDER',<br/>'CREAM CUPID HEARTS COAT HANGER', 'RED WOOLLY HOTTIE WHITE HEART.']</span><span id="943c" class="lo lp it lk b gy ni lr l ls lt">df['bool_description'] = np.where(df['Description'].isin(description_list), True, False)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9d4254412b0e2d92e95e57808b8334da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*_gePbYVU6DTt5-09ci27kQ.png"/></div></figure><p id="7de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以基于其他列生成字符串要素。这里我们生成字符串输出“是”和“否”:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="44ce" class="lo lp it lk b gy lq lr l ls lt">df['string_description'] = np.where(df['Description'].isin(description_list), 'Yes', 'No')<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2970726fa908f2deb3b48e44e916f91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*p8YkcGsw7Ep01vCK5rQ4Bg.png"/></div></figure><p id="d083" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">甚至二进制整数输出:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="4705" class="lo lp it lk b gy lq lr l ls lt">df['int_description'] = np.where(df['Description'].isin(description_list), 1, 0)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/87d04dc48bbb4c1d5313614629b57500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*ra0z1XzDZFdJaVxS3oi69A.png"/></div></figure><h1 id="54d0" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">数据标注</strong></h1><p id="cbe9" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">最后，我经常发现自己需要根据其他列的值来标记数据。假设我们想预测一个产品是否会卖出超过十个单位。我们可以使用 np.where()来分配二进制标签，其中值 1 被分配给销售十个或更多单位的产品，值 0 被分配给销售少于十个单位的产品:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="57c7" class="lo lp it lk b gy lq lr l ls lt">df['new_target'] = np.where(df['Quantity'] &gt;= 10, 1, 0)<br/>print(df.head())</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/625a4205e4ec5b7df69ed6e85a7f7303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*1Po9o-D-ddXhont_vv1b-A.png"/></div></figure><p id="d4a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我就停在这里。这篇文章的代码将在 GitHub 上发布。请随意摆弄数据和代码，如果有任何问题，请在下面留下。感谢您的阅读。祝你好运！</p></div></div>    
</body>
</html>