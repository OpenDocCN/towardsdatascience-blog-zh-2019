<html>
<head>
<title>Data Science as Software: from Notebooks to Tools [Part 3]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为软件的数据科学:从笔记本到工具[第 3 部分]</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-as-software-from-notebooks-to-tools-part-3-84023404d428?source=collection_archive---------23-----------------------#2019-06-14">https://towardsdatascience.com/data-science-as-software-from-notebooks-to-tools-part-3-84023404d428?source=collection_archive---------23-----------------------#2019-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3cb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是如何从 Jupyter 笔记本到数据科学软件解决方案系列的最后一部分。<a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-1-253a39e4fc0a">第 1 部分</a>讲述了设置工作环境和数据探索的基础知识。<a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-2-e1d1bf99d067">第二部分</a>深入数据预处理和建模。第 3 部分将讨论如何从 Jupyter、前端开发和日常代码工作中继续前进。该系列会议的总体议程如下:</p><ol class=""><li id="c19d" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">设置您的工作环境[ <a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-1-253a39e4fc0a">第 1 部分</a></li><li id="2eb5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">数据探索的重要模块[ <a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-1-253a39e4fc0a">第 1 部分</a></li><li id="41aa" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">机器学习第 1 部分:数据预处理[ <a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-2-e1d1bf99d067">第 2 部分</a> ]</li><li id="3397" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">机器学习第二部分:模型[ <a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-2-e1d1bf99d067">第二部分</a></li><li id="6ba5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">离开 Jupyter[第 3 部分]</li><li id="dbba" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">闪亮的东西:我们什么时候得到一个前端？[第三部分]</li><li id="3a22" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">您在代码中的日常工作:保持标准[第 3 部分]</li></ol></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="f71d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您已经完成了原型的第一次迭代:您有一个加载数据的管道，您对它进行预处理，根据需要进行转换，并且能够训练一个模型。现在你如何从这里继续前进？</p><p id="d472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是理解在 Jupyter 中编程和使用 IDE 之间的区别(PyCharm 将是我们的例子)。Jupyter 在以下方面非常出色:</p><ul class=""><li id="1c3b" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk lh ks kt ku bi translated"><strong class="jp ir">原型</strong>:你可以很容易地将代码组合在一起，然后在几个小时内就可以开始制作一些东西。</li><li id="a685" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated"><strong class="jp ir">直接输出</strong>:因为你的代码是在单元格中运行的，所以每个单元格的输出都是在运行完单元格后直接输出的。这增强了你制作原型或尝试新方法的能力，因为你能很快得到反馈。</li><li id="70b0" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated"><strong class="jp ir">可视化</strong> : Jupyter 非常适合可视化。因为你可以很容易地包含像 matplotlib 这样的库，所以你不仅可以得到变量值的反馈，还可以制作图表、图表、表格等等。</li><li id="1066" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated"><strong class="jp ir">内存中的变量</strong>:这是关于 Jupyter 的一个需要重点强调的特性。只要笔记本的变量不在方法中，它们就会被保存在内存中。这适用于任何直接运行的 python 脚本，但是由于 Jupyter 笔记本的原型性质，在 Jupyter 中提倡使用这种脚本。</li></ul><p id="2859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到 Jupyter 是一个很好的探索和原型工具，我强烈建议您在开始数据科学项目时使用这个工具。但是在第一个工作原型之后，是时候将一些软件工艺引入你的项目了。使用 IDE 有以下优点:</p><ul class=""><li id="7663" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk lh ks kt ku bi translated">模块化:你可以轻松地浏览你的代码，无论是方法、类还是模块(甚至是库)。这加强了对您的逻辑使用模块化的方法，意味着您将代码分成组件。</li><li id="6fb4" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated"><strong class="jp ir">代码质量</strong>:你的 IDE 提供了很多不同的工具，通过适当的编码指南(比如<a class="ae kl" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP 8 </a>)来提高代码质量，并且可以立即突出语法错误，还可以指出未使用的变量等等。</li><li id="1551" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">重构:重构意味着在不改变底层逻辑的情况下重构你的代码。简单的重构任务，如重命名变量或方法，使用复制和粘贴很简单，但是将方法实现从一个模块移动到另一个模块就比较困难了。IDE 提供的工具可以在这方面支持您。</li><li id="f3c0" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">Git 支持:当项目有不止一个人参与时，版本控制非常重要，即使这样，我也强烈建议使用 VCS(版本控制系统)。Git 可能是目前最著名的分布式 VCS，理想情况下，您的 IDE 可以集成它。</li><li id="34d6" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated"><strong class="jp ir">代码检查</strong>:每当你有 bug 或性能问题时，你可以做的不仅仅是打印语句。使用调试器一行一行地检查关键代码，使用分析器进行性能测量，这只是 IDE 支持的几件事情。</li></ul><p id="f853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的比较突出了 Jupyter 和 IDE 之间的区别。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/4bcc6a2806fb439f433b1784f87acd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxVjNoi1qh7338SOPTat3A.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Comparsion of using Jupyter vs. programming in an IDE (Image by Author)</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="5875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你如何开始更多地利用 ide，并从 Jupyter-only 继续前进？在我看来，实现这一点的最简单的方法如下。</p><ol class=""><li id="0d81" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">方法:把你的代码分成不同的方法，而不是“代码散文”(一个连续的脚本，一行一行地运行所有的东西)。用定义的输入和输出将您的逻辑分成不同的方法，并开始将逻辑分组到方法中。尽量保持抽象，这样你就可以用一种方法替换另一种方法，而不必重写大部分代码。</li><li id="049c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">模块:将你的方法组合在一起，并用它们创建模块或类。当您有多个想要单独操作的对象并且每个对象需要不同的属性时，就需要类。模块更加通用，将更大的方法组组合在一起，这些方法都遵循一个特定的目标。</li><li id="2d01" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">重构:重构是重构或精炼你的代码。没有完美的代码，从某种意义上说，一个编码项目永远不会结束。这就是为什么你应该以一种允许你重构代码的方式，尽量减少方法之间的依赖(例如，交换一个规范化方法和另一个)。重构应该定期进行，例如每天 20 分钟或者每周五几个小时(“重构周五”)。</li></ol><p id="b220" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这些只是您旅程中的第一步，但是它们会对您有很大的帮助，并提高代码质量和代码性能。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="d6da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道如何从 Jupyter 到软件工具是一回事，但是你必须在日常工作中实践这些知识。为此，您有一个指导原则:“干净的代码”。罗伯特·马丁的这本书给了你语言不可知论的原则和指南。不需要阅读这本书，你就可以学到一些东西:</p><ul class=""><li id="df74" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk lh ks kt ku bi translated">变量、模块和方法名称应该反映这些模块/方法中做了什么或者变量存储了什么。</li><li id="9b9e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">保持方法简短和一致，意思是:一个方法有一个明确定义的范围，并且只做一件事</li><li id="a6b5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">干:不要重复自己。代码中的知识应该保存在一个地方。如果你做一件事超过两次，你应该想出一个方法。</li><li id="65ae" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">吻:保持简单，笨蛋。为什么要把事情复杂化？尽可能争取最简单的解决方案。</li><li id="a4d4" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">定期重构。你的软件在成长，你不断得到新的见解或想法去尝试。花时间重构你所做的，整理你的代码。</li></ul><p id="b913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个非常重要的主题代码版本控制。您如何跟踪随着时间的推移对代码做了什么？为此，需要一个版本控制软件(VCS)。尽管存在不同的版本(集中式、非集中式)，git 可能是其中最著名的一个。</p><p id="ae8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最基本形式的 Git 遵循一种独特的模式，它足以让您入门。Git 由一个远程存储库和一个本地存储库组成，远程存储库是所有贡献者从中获取的全局代码库，本地存储库就是您正在使用的存储库。以下命令帮助您入门:</p><ul class=""><li id="ff9c" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk lh ks kt ku bi translated">git pull:从远程存储库中提取。</li><li id="e926" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">git add:添加为提交而更改的文件</li><li id="c751" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">git commit:将添加的文件提交到远程存储库</li><li id="f5d1" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">git push:将提交的文件推送到存储库</li></ul><p id="a35c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这当然是非常基本的，如果你对这个话题更感兴趣，我建议你阅读一下一般的<a class="ae kl" href="https://git-scm.com/docs/gittutorial" rel="noopener ugc nofollow" target="_blank"> git </a>，特别是<a class="ae kl" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> GitHub Flow </a>。</p><p id="b7fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要从中吸取的是，即使您独自处理代码，也需要进行代码版本控制，因为您可能想要回滚到以前的版本，或者您想要并行保持不同的分支。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="f770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们结束这个系列之前，我想谈谈一个非常重要但有时被忽视的话题:你如何分享你的结果？一个 Jupyter 笔记本只能让你到此为止，当涉及到专业环境时，分享结果至少与首先获得结果一样有价值。在这个地方分享成果意味着</p><ul class=""><li id="8de0" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk lh ks kt ku bi translated">如何在软件应用程序中访问你的模型？</li><li id="7616" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk lh ks kt ku bi translated">你如何可视化你的模型的结果？</li></ul><p id="7830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先:让你的模型在软件应用程序中可访问是通过软件接口来完成的。您可以将方法编码为模型的包装器，从而拥有一个接口。但是这只能在单一的应用程序中工作，这意味着任何代码、数据库和前端都连接在同一台机器上，这是很不现实的。</p><p id="1cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最基本的形式中，您有一个数据库、后端应用程序(包含您的模型和任何其他业务逻辑)和一个与后端通信的前端。这里显示了该基础设施的一个非常简单的示意图:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0394fec570e42cf253eed351e1709da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*oSxL2Yn_Ik7uDm6xWyRhLA.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Basic architecture of an integrated application (Image by Author)</figcaption></figure><p id="6d2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现这一点的最简单的方法是编写一个包含您的模型并提供接口的后端应用程序。Python 为流行的数据库(<a class="ae kl" href="https://api.mongodb.com/python/current/" rel="noopener ugc nofollow" target="_blank"> PyMongo </a>或<a class="ae kl" href="http://initd.org/psycopg/" rel="noopener ugc nofollow" target="_blank"> psycopg </a>)提供了许多包装器，以供您访问。</p><p id="8816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，提供一个接口最好的方法是创建 REST APIs，并通过作为 web 服务器的<a class="ae kl" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a>或<a class="ae kl" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>运行您的应用程序。关于如何做到这一点的独立文章将会接踵而至，敬请关注！</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="f39f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结这个系列，到目前为止我们已经讨论了什么？</p><p id="5e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-1-253a39e4fc0a">第 1 部分</a>展示了在 Python 中建立工作环境的基础，以及用于初始数据探索的模块，如 Jupyter notebook 和 Pandas。<a class="ae kl" rel="noopener" target="_blank" href="/data-science-as-software-from-notebooks-to-tools-part-2-e1d1bf99d067">第 2 部分</a>对数据预处理有更深入的了解，尤其是图像、语言和音频数据领域。它还涵盖了机器学习模型的库。这一部分讲述了如何超越 Jupyter，需要记住的编码标准以及架构的一般方法。</p></div></div>    
</body>
</html>