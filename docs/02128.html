<html>
<head>
<title>Basic data analysis techniques every data analyst should know, using Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据分析师都应该知道的基本数据分析技术，使用 Python。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basic-data-analysis-techniques-every-data-analyst-should-know-using-python-4de80ab52396?source=collection_archive---------10-----------------------#2019-04-08">https://towardsdatascience.com/basic-data-analysis-techniques-every-data-analyst-should-know-using-python-4de80ab52396?source=collection_archive---------10-----------------------#2019-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="101c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/basic-analysis-techniques" rel="noopener" target="_blank">基本分析技巧</a></h2><div class=""/><div class=""><h2 id="57c8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">迈向经验丰富的分析师的第一步</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0749b21817251c9694a95b12e8ec94b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKXC0FeXQc5LVmqhJ8HnVg.png"/></div></div></figure><p id="9da4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我作为数据分析师的日常工作中，我会看到各种各样的数据和来自客户的各种各样的分析请求。我注意到的是，你在大多数项目中需要的某些基本技术，与你正在从事的项目类型无关。我相信每个数据分析师/科学家都应该对这些技术有很好的理解。因此，本文的目标是带领读者了解这些技术，并在基础层面上解释这些技术。</p><p id="f5e0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些是我们将浏览和讨论的主题:</p><ol class=""><li id="7961" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">基本过滤</li><li id="c73b" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">多条件过滤</li><li id="439d" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">聚合</li><li id="edb7" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">连接</li></ol><p id="03f7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于我们的分析，我们将利用 Python 中的<code class="fe mn mo mp mq b"><a class="ae mr" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">pandas</strong></a></code>库。因此，如果您还没有安装这个库，请在您的命令提示符下使用以下代码之一来安装 pandas:</p><pre class="ks kt ku kv gt ms mq mt mu aw mv bi"><span id="f2e6" class="mw mx it mq b gy my mz l na nb"># If you use Anaconda, type the following in anaconda prompt<br/>conda install -c anaconda pandas</span><span id="a9d0" class="mw mx it mq b gy nc mz l na nb"># If you use pip, type the following in command prompt<br/>pip install pandas</span></pre><p id="9d64" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此外，我假设你已经对 Python 和 pandas 库有了基本的了解。但是不要担心，如果你还没有接触到上述任何一个，我们将从头到尾检查一遍。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/de412a2a6751d6f43a931e6fd99942f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*LQ-UAdZ0HBIFdEVj5swoeg.png"/></div></figure><h1 id="5524" class="ne mx it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">我们的数据集</h1><p id="eabc" class="pw-post-body-paragraph ld le it lf b lg nv kd li lj nw kg ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">为了能够通过提到的技术，我们需要数据。我们可以导入一个<code class="fe mn mo mp mq b"><strong class="lf jd">csv</strong></code>文件或者一个<code class="fe mn mo mp mq b"><strong class="lf jd">excel</strong></code>文件，但是现在我们保持简单，仅仅创建一个关于熊猫的小数据集。</p><p id="9237" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面的代码将生成一个<a class="ae mr" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">熊猫数据帧</a>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d745" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这给了我们下面的数据框架:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/95a8cd6fec5a449384e4a6f40949281c.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*yLv_mWKuCOHsbO1l1dFOGA.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">DataFrame 1</figcaption></figure><p id="9c82" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从上面可以看出，它包含 ID、值和日期。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="e461" class="ne mx it bd nf ng oo ni nj nk op nm nn ki oq kj np kl or km nr ko os kp nt nu bi translated">1.基本过滤</h1><p id="e637" class="pw-post-body-paragraph ld le it lf b lg nv kd li lj nw kg ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">现在我们加载了 pandas 模块并创建了一个数据集，我们可以从第一项技术开始。当您想要基于列中的值获得数据的子集时，我们讨论的是<em class="ot">过滤</em>数据。</p><p id="beb0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在熊猫身上，我们有多种方法做到这一点，现在我们来看看最常见的几种:</p><ol class=""><li id="0f4a" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">使用带方括号<code class="fe mn mo mp mq b"><strong class="lf jd">[]</strong></code>的<a class="ae mr" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html" rel="noopener ugc nofollow" target="_blank">布尔索引</a></li><li id="7985" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">通过<code class="fe mn mo mp mq b"><strong class="lf jd">.loc</strong></code>使用布尔索引</li></ol><p id="93dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以用方括号<strong class="lf jd"/><em class="ot"/>过滤如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b095" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">pandas 中过滤背后的逻辑是将条件传递给方括号中的数据帧:</p><pre class="ks kt ku kv gt ms mq mt mu aw mv bi"><span id="42b9" class="mw mx it mq b gy my mz l na nb">df[condition]</span></pre><p id="1cd6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">并给出了以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8731772f5343070f6075f538cf3bec8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*rKKbQgKBWQzxA4ISEgUYJg.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Filtering with square brackets</figcaption></figure><p id="47c8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">用<strong class="lf jd">过滤。loc </strong>看起来非常相似:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b9c7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如预期的那样，它给出了相同的输出，因为我们应用了相同的滤波器</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8731772f5343070f6075f538cf3bec8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*rKKbQgKBWQzxA4ISEgUYJg.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Filtering with .loc</figcaption></figure><p id="7711" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首选用哪个？对于基本过滤器，正如我们在上面看到的，没有区别或偏好，它归结为你喜欢什么代码语法明智。但是当你想对你的数据进行更高级的选择时，<code class="fe mn mo mp mq b"><strong class="lf jd">.loc</strong></code>提供了更复杂的选择和切片。但现在不用担心这个。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="6751" class="ne mx it bd nf ng oo ni nj nk op nm nn ki oq kj np kl or km nr ko os kp nt nu bi translated">2.带条件过滤</h1><p id="3f5d" class="pw-post-body-paragraph ld le it lf b lg nv kd li lj nw kg ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">我们应用了我们的第一个过滤器，它非常简单。但是，假设您想要应用一个具有多个条件的过滤器。我们如何在熊猫身上做到这一点？为此，我们研究了 Python 操作符。</p><p id="2d7a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">2.1<em class="ot">&amp;</em>运算符<br/> </strong>例如，您要过滤所有<code class="fe mn mo mp mq b"><strong class="lf jd">ID</strong></code>等于 C1、<code class="fe mn mo mp mq b"><strong class="lf jd">Value</strong></code>大于 100 的行。</p><p id="2634" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了应用这个过滤器，我们必须用<code class="fe mn mo mp mq b"><strong class="lf jd">&amp;</strong></code>操作符链接两个条件。看起来像下面这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f72c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">并将返回以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/0f8f1c04f72f1ffecd1be2efa4c9f882.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*h7QviMSKFiTrfTnDSl8ZAQ.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Filtering with and operator</figcaption></figure><p id="b7f8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如预期的那样，我们返回了一行，因为只有这一行符合我们在过滤器中设置的条件。</p><p id="0c1a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">2.2 |操作符</strong></p><p id="2765" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Python 中的<code class="fe mn mo mp mq b"><strong class="lf jd">|</strong></code>运算符代表<code class="fe mn mo mp mq b"><strong class="lf jd">or</strong></code>，如果满足其中一个条件就会返回<code class="fe mn mo mp mq b"><strong class="lf jd">True</strong></code>。</p><p id="1207" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以通过应用以下过滤器来显示这一点:给我们所有<code class="fe mn mo mp mq b"><strong class="lf jd">date</strong></code>晚于 2019–04–10<strong class="lf jd">或</strong> <code class="fe mn mo mp mq b"><strong class="lf jd">Value</strong></code> <strong class="lf jd"> </strong>大于 100 的行。</p><p id="76af" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 Python 代码中，这将如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="556b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">并将返回以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/03d9c341cd22417c91b802c653838ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*FlpXROj-1sgZyJRDcZU1rQ.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Filtering with or operator</figcaption></figure><p id="6d7e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如所料，返回的所有行的值都大于 100 <strong class="lf jd">或</strong>的日期在 2019-04-10 之后。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="022a" class="ne mx it bd nf ng oo ni nj nk op nm nn ki oq kj np kl or km nr ko os kp nt nu bi translated">3.协议</h1><p id="8e76" class="pw-post-body-paragraph ld le it lf b lg nv kd li lj nw kg ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">有时需要聚合数据，以便创建特定的概视图或进行一些计算。在熊猫中，我们用<code class="fe mn mo mp mq b"><strong class="lf jd">groupby</strong></code> <strong class="lf jd"> </strong>来表示这一点。</p><p id="f3a5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">那么 groupby 到底是什么？如果我们引用熊猫文献的话:</p><blockquote class="ox oy oz"><p id="9d63" class="ld le ot lf b lg lh kd li lj lk kg ll pa ln lo lp pb lr ls lt pc lv lw lx ly im bi translated">“分组依据”指的是涉及以下一个或多个步骤的过程:<br/> <strong class="lf jd"> *根据某些标准将数据分成组</strong>。<br/> <strong class="lf jd"> *将</strong>功能独立应用于每组。<br/> <strong class="lf jd"> *将</strong>结果组合成一个数据结构。</p></blockquote><p id="5c01" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，基本上它是根据一些指标对你的数据进行分组，使你能够对这些分组采取一些行动。</p><p id="6924" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> 3.1 Groupby #1:获取总和</strong> <br/>让我们来看一个例子。假设我们想根据<code class="fe mn mo mp mq b"><strong class="lf jd">ID</strong></code>得到每组的总数<code class="fe mn mo mp mq b"><strong class="lf jd">value</strong></code>。这就像 Python 代码中的以下内容:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f77e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这将为我们提供以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3277d395b18c461f59015682210585b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*CflyY02gL_geB7xT9B55Jw.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Aggregation with sum</figcaption></figure><p id="4cc0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们再看一下数据帧，我们会发现这是正确的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/95a8cd6fec5a449384e4a6f40949281c.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*yLv_mWKuCOHsbO1l1dFOGA.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Original dataframe</figcaption></figure><p id="b177" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，ID A1 的总值是<code class="fe mn mo mp mq b"><strong class="lf jd">100 + 120 = 220</strong></code> <strong class="lf jd"> </strong>，这是正确的。</p><p id="2619" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> 3.2 Groupby #2:获取最高日期</strong></p><p id="8d41" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">熊猫提供了一个大范围的功能，您可以在使用 groupby 后在您的组上使用。再来看一个。例如，我们可以通过使用<code class="fe mn mo mp mq b">.max()</code>函数获得每组的最高日期。</p><p id="222a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">看起来会像这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="167d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">并且会给我们以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/45c88c39027a29679077e2acddbdf64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*tnu4qhLZPCo6Zd5iZEww2w.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Aggregation with max date</figcaption></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="a92b" class="ne mx it bd nf ng oo ni nj nk op nm nn ki oq kj np kl or km nr ko os kp nt nu bi translated">4.连接</h1><p id="cb7a" class="pw-post-body-paragraph ld le it lf b lg nv kd li lj nw kg ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">连接是基于一个公共列以并排的方式组合两个数据帧。大多数时候这些列被称为<code class="fe mn mo mp mq b"><strong class="lf jd">key columns</strong></code>。</p><p id="51f5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">术语<code class="fe mn mo mp mq b"><strong class="lf jd">join</strong></code>源于数据库语言 SQL，之所以需要它是因为 SQL 数据库的数据建模大部分是通过使用关系建模来完成的。</p><p id="b0bb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">连接有很多种类型，您的输出将基于您执行的连接类型。因为这是入门教程，我们就看最常见的:<code class="fe mn mo mp mq b"><strong class="lf jd">inner join</strong></code>。在本系列的后面部分，我们将研究更复杂的连接。</p><p id="46da" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="ot">内连接</em>来源于<code class="fe mn mo mp mq b"><strong class="lf jd">venn diagrams</strong></code>，代表两个集合的<em class="ot">内</em>(交集)部分。因此，当我们将它转换成我们的数据时，一个内部连接返回出现在两个数据帧中的行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/9fda088c9d52e8f77451ab4b90e1296f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ktabzfAyfgZPj0I3fV-0A.png"/></div></div></figure><p id="25bc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> 4.1 我们的数据集</strong></p><p id="74fc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因为我们想要合并两个数据帧，所以我们将创建新数据。这两个假想数据集代表客户主表和订单表。</p><p id="c838" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用以下代码，我们创建了两个新的数据帧:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="be9f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它们看起来如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/b8064f994a338da17c19c397fa7534ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1HgpnvKVrRc2kaN1oCPjNw.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">dfA: Customers master</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/2f1c047f5baa840d92f2bdec5846a6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*ZW6aj3nu0VFAZvo77OCB2w.png"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">dfB: Orders</figcaption></figure><p id="6522" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们可以对这些新数据进行的一个逻辑分析是，获取 orders 表中每个订单旁边的客户的姓名和城市。这是一个典型的<code class="fe mn mo mp mq b"><strong class="lf jd">join</strong></code>问题，按行匹配两个数据帧，并用更多的列丰富数据。在这种情况下，我们的键列是<code class="fe mn mo mp mq b"><strong class="lf jd">Customer_ID</strong></code>。</p><p id="4b37" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在熊猫中，我们使用<code class="fe mn mo mp mq b"><a class="ae mr" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd">merge</strong></a></code> <strong class="lf jd"> </strong>的方法进行接合。我们将向该方法传递以下参数:</p><ol class=""><li id="335f" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">您要连接哪个数据框架(dfA，dfB)。</li><li id="e077" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">什么是关键列(Customer_ID)。</li><li id="1feb" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">要执行的联接类型(内部)。</li></ol><p id="0c95" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以在 merge 方法中使用比上面列出的更多的参数，但是现在这些已经足够了。</p><p id="727d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在 pandas 中，我们要执行的合并看起来像下面这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6427" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">并且输出如我们所料，在每个对应的<code class="fe mn mo mp mq b"><strong class="lf jd">customer_ID</strong></code> <strong class="lf jd">旁边添加了 name 和 city 列。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/dec677616078c695b06b39e2bab985bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m369h_YiWT62WW9xj0-bwQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Inner join</figcaption></figure><p id="470e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">这就是本部分的</strong>:每个数据分析师都应该知道的基本数据分析技术，使用 Python。</p><p id="38b6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以在我的 GitHub 上以 Jupyter 笔记本的形式找到这篇文章的代码:<a class="ae mr" href="https://github.com/ErfPy/MediumArticles" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="d676" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果这篇文章对你有用，请考虑给这篇文章点个赞，并与朋友和/或同事分享。</p><p id="afde" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于任何问题或其他讨论，请随时发表评论。</p><p id="0e9a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这里找到第二部分<a class="ae mr" rel="noopener" target="_blank" href="/basic-data-analysis-techniques-every-data-analyst-should-know-part-ii-412e28af849d">，我们在这里进行了更深入的探讨。</a></p></div></div>    
</body>
</html>