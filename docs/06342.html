<html>
<head>
<title>How data compression works: exploring LZ77</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据压缩如何工作:探索 LZ77</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-data-compression-works-exploring-lz77-3a2c2e06c097?source=collection_archive---------4-----------------------#2019-09-12">https://towardsdatascience.com/how-data-compression-works-exploring-lz77-3a2c2e06c097?source=collection_archive---------4-----------------------#2019-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ZIP 格式是如何工作的？</h2></div><p id="1098" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将探索 LZ77，一种由伦佩尔和齐夫在 1977 年创建的无损数据压缩算法。这种算法在我们当前的系统中广泛传播，因为，例如，ZIP 和 GZIP 是基于 LZ77 的。</p><h1 id="73f2" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">压缩</h1><p id="11f2" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">LZ77 依次遍历输入字符串，并将任何新的匹配存储到搜索缓冲区中。压缩过程可以分为 3 个步骤:</p><ol class=""><li id="7ec5" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated">查找从当前位置开始的字符串与搜索缓冲区中可用模式的最长匹配。</li><li id="be59" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">输出三元组(o，l，c ),其中，</li></ol><ul class=""><li id="1924" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mp mh mi mj bi translated"><em class="mq"> o </em> : offset，表示为了找到匹配字符串的开始，我们需要向后移动的位置数。</li><li id="621e" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mp mh mi mj bi translated"><em class="mq"> l </em>:长度，代表比赛的长度。</li><li id="b090" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mp mh mi mj bi translated"><em class="mq"> c </em>:字符，代表匹配后找到的字符。</li></ul><ol class=""><li id="61cc" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated">向右移动光标 l+1 个位置。</li></ol><p id="2257" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过一个例子更深入地了解一下:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="06b1" class="na lf it mw b gy nb nc l nd ne">a b a b c b a b a b a a</span></pre><p id="9136" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最初，我们的搜索缓冲区是空的，我们从左边开始，在那里我们找到一个“a”。假设在我们的搜索缓冲区中没有任何匹配模式，我们输出三元组(0，0，a)，因为我们没有向后移动(o = 0)，并且在搜索缓冲区中没有匹配模式(因此“匹配”一个空字符串:l = 0)。在这个(非)匹配之后，我们找到字符‘a’，所以 c = a。我们向右移动 l+1 个位置，发现自己在第二个位置。我们将使用方括号[]来表示光标的位置。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0208" class="na lf it mw b gy nb nc l nd ne">a [b] a b c b a b a b a a<br/>LZ77 encoding: (0,0,a)</span></pre><p id="d68f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们的搜索缓冲区中没有任何以“b”开头的模式。所以编码过程和上一步类似:(0，0，b)。此时，事情开始变得有趣起来:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3bc2" class="na lf it mw b gy nb nc l nd ne">a b [a] b c b a b a b a a<br/>LZ77 encoding: (0,0,a), (0,0,b)</span></pre><p id="a513" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们之前发现了一个“a”甚至“ab”，但没有发现“abc”，所以我们需要向左移动 2 个位置(o = 2)并读取 2 个字符(l = 2)。我们可以找到的下一个字符是“c”，因此输出三元组将是(2，2，c)。我们将光标向右移动 l+1 个位置，发现自己在字符‘b’中。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2f20" class="na lf it mw b gy nb nc l nd ne">a b a b c [b] a b a b a a<br/>LZ77 encoding: (0,0,a), (0,0,b), (2,2,c)</span></pre><p id="030d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经找到了一个“b”，甚至“ba”和“bab ”,但没有找到“baba ”,所以我们将向左移动 4 个位置(o = 4)并读取 3 个字符(l = 3)。我们可以找到的下一个字符是“a”，因此输出三元组将是(4，3，a)。我们将光标向右移动 l+1 个位置，发现自己在字符‘b’中。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="adbe" class="na lf it mw b gy nb nc l nd ne">a b a b c b a b a [b] a a<br/>LZ77 encoding: (0,0,a), (0,0,b), (2,2,c),  (4,3,a)</span></pre><p id="126f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们快完成了！我们已经看到了一个 b 和一个 ba，但没有看到一个 baa。我们需要向左移动 2 个位置(o = 2)，读取 2 个字符(l = 2)。在这个匹配之后，我们找到一个“a ”,所以最后的输出三元组将是(2，2，a)。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6fa1" class="na lf it mw b gy nb nc l nd ne">a b a b c b a b a b a a<br/>LZ77 encoding: (0,0,a), (0,0,b), (2,2,c), (4,3,a), (2,2,a)</span></pre><p id="4793" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到，考虑到在最坏的情况下，我们需要回到输入字符串的开头来寻找匹配模式(如果有的话)，压缩阶段的时间复杂度似乎不是太好。这意味着，在 0-索引位置 p，我们需要在最坏的情况下向左移动 p 个位置。考虑一种边缘情况，其中字符串的每个字符都不同(因此我们没有利用数据压缩)，我们需要处理第一个位置的 0 个字符+第二个位置的 1 个字符+第三个位置的 2 个字符… +最后一个位置的 n-1 个字符= n(n-1) / 2 = O(n2)时间复杂度。这就是为什么通常预定义搜索缓冲区大小的限制的原因之一，这允许我们重用多达例如光标左侧 6 个位置的内容。下面的例子可以帮助您说明这个概念，其中括号表示搜索缓冲区内的内容。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a4ca" class="na lf it mw b gy nb nc l nd ne">a b a b c (b a b a b a) [c] b a a a</span></pre><p id="3100" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们不会在搜索缓冲区中找到“c ”,因此，输出三元组将是(0，0，c)而不是(7，3，a)。然而，在最坏的情况下，在字符串的开头，我们可能不需要为每个处理过的字符付出代价来寻找一个匹配。总而言之，选择搜索缓冲区的大小成为压缩时间和所需内存之间的权衡:小的搜索缓冲区通常会让我们更快地完成压缩阶段，但最终的编码将需要更多的内存；另一方面，大的搜索缓冲区通常需要更长的时间来压缩我们的数据，但在内存使用方面会更有效。</p><p id="154d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">限制先行缓冲区的大小也很常见，先行缓冲区是从光标处开始的子字符串。让我们用一个例子来说明这个概念，其中前瞻缓冲区用两个*符号表示。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="48d4" class="na lf it mw b gy nb nc l nd ne">a b a b c (b a b a c a) *[b] a b a* c a a</span></pre><p id="7406" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们有一个大小为 6 的搜索缓冲区和一个大小为 4 的先行缓冲区。假设我们的前瞻缓冲区的内容是“baba ”,并且它包含在搜索缓冲区中，那么在这个位置的 LZ77 编码将是(6，4，c)。请注意，在本例中，如果我们的前瞻缓冲区更大，则此位置的输出三倍会有所不同。例如，如果我们的前瞻缓冲区的大小也是 6，它将包含字符串“babaca”，它完全包含在搜索缓冲区中，因此，输出三元组将是(6，6，a)。</p><p id="3576" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得一提的是，这种算法也被称为“滑动窗口”算法，因为当光标在输入文本中“滑动”时，搜索缓冲区和前瞻缓冲区都会更新。</p><h1 id="75ba" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">解压</h1><p id="014e" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">让我们看看 LZ77 如何使用它的编码形式来再现原始字符串。LZ77 被归类为无损数据压缩算法，这意味着我们应该能够完全恢复原始字符串。同样值得一提的是，在 LZ77 的例子中，我们不能从一个随机的 LZ77 三元组开始解压缩:相反，我们需要从最初的三元组开始解压缩。原因很简单，编码的三元组基于搜索缓冲区。</p><p id="7a9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了说明解压缩过程，让我们尝试解压缩上一节中获得的编码，旨在获得原始字符串。因此，本例中的编码如下:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3fc8" class="na lf it mw b gy nb nc l nd ne">(0,0,a), (0,0,b), (2,2,c), (4,3,a), (2,2,a)</span></pre><p id="2460" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从(0，0，a)开始，我们需要向左移动 o = 0 个位置，读取 l = 0 个字符(那只是一个空字符串)。之后写 c = 'a '。因此，这个三元组的解压缩值是‘a’。此时，我们的解压缩字符串如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="063b" class="na lf it mw b gy nb nc l nd ne">Current string: a<br/>Remaining LZ77 encoding: (0,0,b), (2,2,c), (4,3,a), (2,2,a)</span></pre><p id="d7f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们找到的下一个三元组是(0，0，b ),意思如下:向左移动 o = 0 个位置，读取 l = 0 个字符(空字符串)。之后，写 c = 'b '。因此，这个三元组的解压缩值是‘b’。我们的解压缩字符串现在看起来像这样:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8417" class="na lf it mw b gy nb nc l nd ne">Current string: a b<br/>Remaining LZ77 encoding: (2,2,c), (4,3,a), (2,2,a)</span></pre><p id="748c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们找到的下一个三元组是(2，2，c)，它更有趣一些。现在的意思是这样的:左移 o = 2 个位置，读 l = 2 个字符(' ab ')。之后，写 c = 'c '。因此，这个三元组的解压缩值是“abc”。我们的解压缩字符串现在看起来像这样:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9d14" class="na lf it mw b gy nb nc l nd ne">Current string: a b a b c<br/>Remaining LZ77 encoding: (4,3,a), (2,2,a)</span></pre><p id="af24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们找到的下一个三元组是(4，3，a)，意思如下:向左移动 o = 4 个位置，读取 l = 3 个字符(' bab ')。之后写 c = 'a '。因此，这个三元组的解压缩值是' baba '。我们的解压缩字符串现在看起来像这样:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="31a7" class="na lf it mw b gy nb nc l nd ne">Current string: a b a b c b a b a<br/>Remaining LZ77 encoding: (2,2,a)</span></pre><p id="2c8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们找到的最后一个三元组是(2，2，a)，意思如下:向左移动 o = 2 个位置，读 l = 2 个字符(' ba ')。之后写 c = 'a '。因此，这个三元组的解压缩值是“baa”。我们的解压缩字符串现在看起来像这样:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f771" class="na lf it mw b gy nb nc l nd ne">Fully decompressed string: a b a b c b a b a b a a</span></pre><p id="b05b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您检查前一节中要压缩的原始字符串，您会发现它们是相同的！</p></div></div>    
</body>
</html>