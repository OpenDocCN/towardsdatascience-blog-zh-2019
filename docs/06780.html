<html>
<head>
<title>Optimising a Machine Learning Model with the Confusion Matrix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用混淆矩阵优化机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-the-confusion-matrix-and-its-business-applications-c4e8aaf37f42?source=collection_archive---------10-----------------------#2019-09-27">https://towardsdatascience.com/understanding-the-confusion-matrix-and-its-business-applications-c4e8aaf37f42?source=collection_archive---------10-----------------------#2019-09-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/289aa1f958efbf66e26c74b42629b427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdXqwt9UjNq7L7_OlFft_A.jpeg"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk">Photo by <a class="ae jh" href="https://unsplash.com/@tomthompsonphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Thomas Thompson</a> on <a class="ae jh" href="https://unsplash.com/s/photos/tune?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="f33d" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">如何根据您的用例调整分类器，包括 python 中的演练</h2></div><p id="cb10" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">机器学习中的混淆矩阵是一个数值网格，有助于评估监督分类模型的性能。从这个网格中，您还可以计算一些指标来为模型打分，包括精确度、召回率和 F1 值。虽然从表面上看这个网格相当简单，而且措施只需要高中水平的数学计算，但矩阵背后的概念却很难掌握。</em></p><p id="8db5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在下面的帖子中，我将简单介绍以下内容:</p><ol class=""><li id="6a67" class="lw lx jk lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">混乱矩阵</li><li id="95fa" class="lw lx jk lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">精确度、召回率和 F1 分数</li><li id="8f93" class="lw lx jk lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">python 中的演练演示了如何选择正确的指标并优化模型性能以最大化该指标</li></ol><h2 id="391b" class="mk ml jk bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">混淆矩阵</h2><p id="6cee" class="pw-post-body-paragraph kz la jk lb b lc nd kl le lf ne ko lh li nf lk ll lm ng lo lp lq nh ls lt lu in bi translated">为了这个解释，让我们假设我们正在处理一个二元分类问题，以检测一个交易是否是欺诈性的。我们的模型使用用户和交易的特征，如果预测交易是欺诈性的，则返回 1，否则返回 0。</p><p id="c957" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">鉴于机器学习模型很少 100%准确，部署这种模型会有一定程度的风险。如果我们错误地将非欺诈交易归类为欺诈，那么我们很可能会失去该交易，甚至可能失去未来的客户业务。另一方面，如果我们错误地将欺诈性交易检测为非欺诈性交易，那么我们可能会损失该交易的价值。</p><p id="4fc3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">混淆矩阵实质上将结果预测分为四组。它们如下:</p><p id="e1b9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">真阳性(TP): </strong>模型预测欺诈，交易确实欺诈。</p><p id="2d37" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">误报(FP): </strong>模型预测欺诈，但交易不是欺诈。</p><p id="939f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">真阴性(TN): </strong>模型预测不存在欺诈，交易不存在欺诈。</p><p id="d990" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">假阴性(FN): </strong>模型预测不是欺诈，但交易实际上是欺诈。</p><p id="ee43" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了说明混淆矩阵的样子，我将使用一些人造数据。</p><p id="3b8c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有几个 python 库使得构建混淆矩阵相当简单，下面是几个例子；</p><p id="5656" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">创建一个非常简单的网格。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="bd3f" class="mk ml jk nl b gz nu nv l nw nx">from sklearn.metrics import confusion_matrix</span><span id="a33b" class="mk ml jk nl b gz ny nv l nw nx">y_true = [0,1,1,0,1,0,0,0,1,1]<br/>y_pred = [0,1,0,0,1,0,0,1,0,1]</span><span id="da34" class="mk ml jk nl b gz ny nv l nw nx">confusion_matrix(y_true, y_pred, labels=[0,1])</span></pre><figure class="nm nn no np gu iw gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/a53be512a4bc797a107bff17b1550374.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*Y0J0va1S3NpzOjizOKkmXw.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk">Output from sklearn confusion_matrix</figcaption></figure><p id="4fe5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">pandas_ml 库产生了一个可读性更好的输出。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="48de" class="mk ml jk nl b gz nu nv l nw nx">from pandas_ml import ConfusionMatrix</span><span id="6ebf" class="mk ml jk nl b gz ny nv l nw nx">ConfusionMatrix(y_true, y_pred)</span></pre><figure class="nm nn no np gu iw gi gj paragraph-image"><div class="gi gj oa"><img src="../Images/34ba41d4d72a487a825e860881285890.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*jQS6osvEph737oa6w5QCtg.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk">Output from panda_ml ConfusionMatrix</figcaption></figure><p id="2292" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们使用网格来确定我们上面讨论的 4 个组中每个组的数字。</p><p id="4fa6" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有 3 个样本，其中模型预测欺诈，并且交易是欺诈性的，因此 TP = 3。这是右下角的数字，其中行和列都为真。</p><p id="f7ce" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有 1 个样本，其中模型预测欺诈，但交易不是欺诈性的，因此 FP = 1。</p><p id="ff78" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有 2 个样本，模型预测不是欺诈，但交易是欺诈的，所以 FN = 2。</p><p id="574a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有 4 个样本，其中模型正确预测了非欺诈，而交易是欺诈性的，因此 TN = 4。</p><p id="9292" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果我们在一个企业中，像这样的模型将被部署并用于推动价值成果，混淆矩阵可以帮助确定一些事情。其中包括:</p><p id="1a1e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该模型在确定欺诈交易方面有多好？</p><p id="b714" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该模型区分欺诈性交易和非欺诈性交易的能力如何？</p><p id="fffb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">模型有多少次错误地预测欺诈性交易不是欺诈性的？</p><p id="5456" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我之前提到的你可以从混淆矩阵中得到的方法可以帮助回答这些问题。</p></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><h2 id="9c85" class="mk ml jk bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">精确度、召回率和 F1 分数</h2><p id="b93e" class="pw-post-body-paragraph kz la jk lb b lc nd kl le lf ne ko lh li nf lk ll lm ng lo lp lq nh ls lt lu in bi translated">从混淆矩阵中可以得出许多度量标准，这些标准都用于衡量模型的性能。我将介绍三种最常用的解释。</p><p id="2cb0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv"> Precision: </em>这基本上是对所有被预测为欺诈的样本中有多少是正确的测量。因此，计算是:</p><p id="a3f3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">TP / (TP + FP)</p><p id="a195" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">回忆(敏感度):</em>这是对那些欺诈性的样本中有多少被正确预测为欺诈性的度量。</p><p id="c5f6" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">TP /(TP + FN)</p><p id="adb5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这两个指标之间的差异很微妙，但非常重要。如果我们优化精确度，那么我们将得到更少的假阳性(更少的非欺诈交易被归类为欺诈)，0 假阳性将给出满分 1。如果我们对召回进行优化，那么我们会得到更少的假阴性，因此我们会捕获更多的欺诈交易，但这可能会有损于将更多的非欺诈交易错误地归类为欺诈。</p><p id="0dba" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv"> F1 分:</em>是精确度和召回率的“调和平均值”。</p><p id="bfe7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，F1 分数很好地指示了分类器的整体准确性，而精确度和召回率提供了关于模型在哪些方面表现良好或不太好的信息。最大化 F1 分数将创建一个平衡的模型，该模型具有精确度和召回率的最佳分数。您选择优化哪个指标将在很大程度上取决于用例。</p></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><h2 id="a849" class="mk ml jk bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">针对给定指标进行调整</h2><p id="abb5" class="pw-post-body-paragraph kz la jk lb b lc nd kl le lf ne ko lh li nf lk ll lm ng lo lp lq nh ls lt lu in bi translated">有几种方法可以针对适合您的特定用例的特定指标来调整机器学习模型。一个例子是 scikit-learn <code class="fe ni nj nk nl b">GridSearchCV</code>，它有一个<code class="fe ni nj nk nl b">scoring</code> <a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" rel="noopener ugc nofollow" target="_blank">参数</a>，允许您选择一个给定的指标。该函数在参数网格上执行<a class="ae jh" href="https://stackabuse.com/cross-validation-and-grid-search-for-model-selection-in-python/" rel="noopener ugc nofollow" target="_blank">交叉验证网格搜索</a>，并根据您提供的评分标准返回模型的最佳参数。</p><p id="82e8" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这篇文章的下一部分，我将介绍一个使用<code class="fe ni nj nk nl b">GridSearchCV</code>优化模型的例子。首先导入相关的库。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="1ad5" class="mk ml jk nl b gz nu nv l nw nx">import wget<br/>import pandas as pd<br/>import numpy as np<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import classification_report<br/>from pandas_ml import ConfusionMatrix<br/>from sklearn.metrics import precision_score<br/>from sklearn.metrics import recall_score<br/>from sklearn.metrics import f1_score<br/>from sklearn.datasets import load_breast_cancer<br/>from sklearn.model_selection import GridSearchCV<br/>from pandas_ml import ConfusionMatrix</span></pre><p id="e519" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个例子中，我将使用一个简单的数据集，它由患者样本的属性和一个描述他们是否患有乳腺癌的指标组成。这可以使用下面的代码直接从<a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>获得。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="0b2b" class="mk ml jk nl b gz nu nv l nw nx">X, y = load_breast_cancer(return_X_y=True)</span></pre><p id="1f02" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个数据集中，恶性类实际上是负类。为了使产生的混淆矩阵更容易解释，我将重新标记它们，使恶性类为阳性。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="b18e" class="mk ml jk nl b gz nu nv l nw nx">for i in range(len(y)):<br/>    if y[i] &gt; 0:<br/>        y[i] = 0<br/>    elif y[i] &lt; 1:<br/>        y[i] = 1</span></pre><p id="9688" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">接下来，我将数据分为测试集和训练集。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="2ee1" class="mk ml jk nl b gz nu nv l nw nx">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)</span></pre><p id="ea4d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后，我将训练一个简单的逻辑回归模型，并使用该模型进行一些预测。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="2c2b" class="mk ml jk nl b gz nu nv l nw nx">rf = LogisticRegression()<br/>model = rf.fit(X_train, y_train)<br/>y_pred = rf.predict(X_test)<br/>ConfusionMatrix(y_test, y_pred)</span></pre><p id="3f37" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">混乱矩阵是这样的。</p><figure class="nm nn no np gu iw gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/3973eeeaf1ef6d2651aeab7c6bdb63ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*ujnIQWHHygUiFW1bBuXEAw.png"/></div></figure><p id="fdd8" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们来计算一下指标。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="fae8" class="mk ml jk nl b gz nu nv l nw nx">print('Precision is:'+str(round(precision_score(y_test, y_pred),2)))<br/>print('Recall is:'+str(round(recall_score(y_test, y_pred, average='binary'),2)))<br/>print('F1 score is:'+str(round(f1_score(y_test, y_pred, average='binary'),2)))</span></pre><figure class="nm nn no np gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj oj"><img src="../Images/12375fca2dfe6c994cdce67eed46c148.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*adWT1ryd54uKblTSgjNBGQ.png"/></div></div></figure><p id="f89d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该模型在所有指标上都表现良好。然而，如果我们要用这个模型代替医生对乳腺癌的诊断，那么 8 个假阴性就太多了。因此，对于这个用例，我们希望最大限度地减少假阴性，因此希望优化召回模型。现在，我们将实施<code class="fe ni nj nk nl b">GridSearchCV</code>并针对该指标优化模型。</p><p id="7cf4" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">首先，我们为两个选择的<code class="fe ni nj nk nl b">LogisticRegression</code>参数创建超参数搜索空间。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="76be" class="mk ml jk nl b gz nu nv l nw nx">penalty = ['l1', 'l2']<br/>C = np.logspace(0, 4, 10)<br/>hyperparameters = dict(C=C, penalty=penalty)</span></pre><p id="07e9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后，我们调用逻辑回归模型并调用<code class="fe ni nj nk nl b">GridSearchCV</code>，选择<code class="fe ni nj nk nl b">scoring</code>参数作为召回。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="0aa0" class="mk ml jk nl b gz nu nv l nw nx">lr = LogisticRegression()<br/>clf = GridSearchCV(lr, hyperparameters, cv=5, verbose=0, scoring='recall')</span></pre><p id="0d45" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在，我们安装<code class="fe ni nj nk nl b">GridSearchCV</code>并打印最佳参数以供调用。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="871d" class="mk ml jk nl b gz nu nv l nw nx">best_model = clf.fit(X_train, y_train)<br/>print('Best Penalty:', best_model.best_estimator_.get_params()['penalty'])<br/>print('Best C:', round(best_model.best_estimator_.get_params()['C'],2))</span></pre><figure class="nm nn no np gu iw gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/947d09b6eb0784a423c3d594ad2ce2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*MQJOnrds6YaCQR7_WU9vdw.png"/></div></figure><p id="be92" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在让我们打印最佳模型的混淆矩阵和度量标准。</p><pre class="nm nn no np gu nq nl nr ns aw nt bi"><span id="5fab" class="mk ml jk nl b gz nu nv l nw nx">y_pred_gs = best_model.predict(X_test)<br/>cm_gs = ConfusionMatrix(y_test, y_pred_gs)<br/>print(cm_gs)</span><span id="9809" class="mk ml jk nl b gz ny nv l nw nx">print('Precision is:'+str(round(precision_score(y_test, y_pred_gs),2)))<br/>print('Recall is:'+str(round(recall_score(y_test, y_pred_gs, average='binary'),2)))<br/>print('F1 score is:'+str(round(f1_score(y_test, y_pred_gs, average='binary'),2)))</span></pre><p id="b486" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以从这些结果中看到，召回分数现在更高了，我们还提高了精确度和召回率。该模型现在能够更好地预测恶性和良性病例的正确标签。</p><figure class="nm nn no np gu iw gi gj paragraph-image"><div class="gi gj ol"><img src="../Images/a4f3d868bf4c9e720cd06a03813a1382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*AanQM97t0NlorrSX2ogaVA.png"/></div></figure><p id="b863" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有许多其他指标对全面评估分类模型的性能很重要，包括特异性、AUC 和 ROC。然而，我认为这些需要一篇自己的文章——这是一篇好文章。</p><p id="a3a2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢阅读！</p></div></div>    
</body>
</html>