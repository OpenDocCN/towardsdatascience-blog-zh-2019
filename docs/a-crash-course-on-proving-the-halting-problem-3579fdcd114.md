# 证明停机问题的速成教程

> 原文：<https://towardsdatascience.com/a-crash-course-on-proving-the-halting-problem-3579fdcd114?source=collection_archive---------8----------------------->

## 以非正式的严谨方式解释

![](img/8ee9707ffa3fe09ffd6312a98d1b120e.png)

A plan for Charles Babbage’s Analytical Engine circa 1840, which would have been a Turing complete mechanical computer had it ever been built. CC BY 4.0

> 在一堂课上，老师解释了“我”*:*
> 
> *《我是围的声音》他说*
> 
> 当学生要求解释他的意思时；大师说“它是你头脑中的一个声音”
> 
> “我脑袋里没有声音”学生想，他举起手告诉大师
> 
> *大师叫住学生，说“刚才说你脑袋里没有声音的声音；是我”*
> 
> *然后学生们就开窍了。*

杰夫·贝索斯在推特上宣布:“我将提供 10 亿美元给一个人，他可以编写一个程序，可以测试任何和所有其他可以想象的程序，看看在一些输入下，它们是否在有限的时间后产生正确的输出，或者永远继续运行。”

您立即开始在您的黑暗主题 IDE 中噼啪作响，并迅速着手为项目编写 Python 类结构。但是在你的内心深处，你感到某种不祥的预感，好像来自以太的一些深奥的知识在悄悄地警告你即将到来的徒劳。

正如所证明的，一般来说*不可能*编写一个程序或算法来确定任何任意的程序或算法(包括它自己)是否在某个任意的输入上停止或者永远继续运行。更有甚者，在所有可能的输入下，更不可能确定所述程序是否会停止或永远运行。在这篇文章中，我们将谈论前一个事实。

为了便于讨论，让我们假设我们的算法是完美的，并且除了暂停之外，将总是产生正确的结果。我们可以把一个通用算法(非正式地)想成类似于一个巨大的查找表(一个函数)，它把一些输入 *x* 映射到它相应的输出 *y =* f( *x* )，并且在 100%的时间里都可以预测。然而，与查找表不同，该算法可以由经典编程意义上的决策语句(if，else)、循环和递归组成，因此它是一个具有开始和结束状态的“动态”过程，它在输入 *x* 上计算一些输出 *y* 或永远继续运行。上述问题被称为*停机问题*，由艾伦·图灵于 1936 年著名地证明，根据他发明的算法的正式定义及其相关的计算模型，即现在普遍称为*图灵机*是不可计算的。事实上，并不是所有的函数都是可计算的，所以我们的算法不同于查找表函数，尽管上面的类比是有用的。

为了理解*为什么*会出现这种情况，请思考一下，我们将以一种非正式的严谨方式讨论兼容性和停顿问题背后的一些想法。事实上，我们甚至不需要正式定义什么是算法，也不需要像图灵机这样的计算模型。我们只会对一般的可计算性做简单的论证。

从一些定义开始。目前，我们提供给算法或程序的所有输入都是自然数 **N** 的子集，因此我们的输入由单个整数组成，如 2、3、12、23 或[2^82589933 1](https://en.wikipedia.org/wiki/Largest_known_prime_number)及其组合(在传递多个参数 *x* 、 *y* 、 *z* 到 *f* ( *x* 、 *y* 的意义上)这个想法就是，我们关心的输入到算法或函数中的唯一输入可以用自然数来编码。

**定义 1** :一个函数*p*(*x*)*= y*带 *x* ， *y* ∈ N 称为*部分可计算* (p.c.) 如果有一个算法在定义 *y* 时停止，但在 *y 时不停止(发散)该算法计算出 *y* 的值或一些相关值。直观上，部分函数 *p* 是不需要 *p* 将域 *X* 的每个*元素 *x* 映射到共域*y*的元素*的函数*

部分可计算函数的一个例子是带余数的非负整数除法。下面用 *a* ， *b* ∈ **Z+:** 定义

*a**b*=*p*(*a*，*b*)= {*φ*(*a*， *b* ) = *q* ，*r*if*b*如果 *b* 为 0，则未定义

在上面，实体 *φ* 是实际用来计算整数除以余数的结果的算法或过程，也就是函数 *p* 。我们可以很容易地从小学回忆起，带余数的除法规则定义得很好，适用于所有非负整数 *a* 和 *b* ，除了当 *b* 为 0 时。无余数的正则非负整数除法也是部分函数。

**定义 2** :一个函数 *f* 是全可计算的或者简单的*可计算 i* f 它被定义在它的输入子集 **N** 的整个定义域上，并且存在在*f*的定义域上停止的算法

我们可以用一些技巧使一般的整数除法(没有余数)可计算:

*a**b*=*p*(*a*，*b*)= {φ(*a*， *b* ) = *q* ， *r* 如果 *b* 不为 0；*南*如果 *b* 为 0 }

注意，如果 *b* 为 0，我们将 a[*NaN*](https://en.wikipedia.org/wiki/NaN)*作为输出，并且我们还升级了算法φ来处理负整数。*从技术上讲** 我们的函数是为 *a，b* ∈ **Z** 的整个定义域定义的，根据著名数学家乔治·康托的工作，这个定义域的大小[与自然数 **N**](https://en.wikipedia.org/wiki/Countable_set) 的某个子集的大小相同，或者是可数无穷的。*

**关于技术细节，它是数学和一阶逻辑中证明方法的基础，因为数学中的许多定义都相当精确，所以最好接受它。以后的证明将直接依赖于我们自己创造的定义的技术细节。*

***定义 3:** 对于某个算法 *φₖ* 一个(输入的)集合叫做*可计算可枚举*(也就是说，递归可枚举这个术语也很流行)如果它在一个 p.c .函数 *p = φₖ* 的域内。也就是说，如果所有元素 *x* 导致 *φₖ* 停止或导致 *φₖ* 分叉，而不是两者，则集合 *X* 在 *φₖ* 中是 c.e .*

*可计算可枚举的性质归因于特定的集合和特定的算法。因此，我们可以说整数集合 **Z** 是整数除余数算法的集合，因为在 **Z** 中有值导致除余数算法给出未定义的输出(例如 0 和负数)。同样， *φₖ* 对于某种计算模型来说是唯一的，但是所有具有正确特征但彼此仅略有不同的确定性计算模型在图灵意义上[是等价的](https://en.wikipedia.org/wiki/Turing_completeness)。因此，我们可以说 *φₖ* 是计算模型 *T.* 中所有可能算法集合中的第 *k* 个算法*

***定义 4:***称为 *X* 的 **N** 的子集是可计算的或递归的，如果它有一个可计算的特征函数或*指示函数*:**

**I( *x* ) = { 1 如果 *x* 在 *X* 中；如果 *x* 不在 *X* 中，则为 0**

**因此，指示器功能必须停止，并在整个域 **N** 上给出真或假的结果。**

**既然我们已经建起了操场，是时候去玩一玩了。在证明为什么停机问题是不可计算的之前，让我们先问一个问题:**

**在一个理发师只给自己不刮胡子的人刮胡子的城镇里，谁会给理发师刮胡子呢？在这个镇上，妻子、单身女子、母亲、孩子和外地人都不能给任何人刮胡子。**

**如果理发师不刮自己的胡子，那么他必须刮自己的胡子，反之，如果理发师刮自己的胡子，那么根据定义，他就不能刮。这是罗素悖论的一个应用版本，它询问所有集合中不包含自身的那个集合是否存在。罗素悖论是试图在“所有集合的集合”这一概念被[从标准集合论的公理中丢弃之前找到这一概念的幼稚想法的直接结果。另一个有趣的逻辑矛盾是著名的第 22 条军规:](https://en.wikipedia.org/wiki/Universal_set)**

**申请工作需要工作经验，但是要获得工作经验就需要一份工作。**

**原来我们可以用这些矛盾来表明某些前提(一个逻辑假设)的反面或复合前提一定是真的，即如果我们已经逻辑地推导出一个矛盾的前提，那么原前提的否定一定是真的。这就是著名的[反证法](https://en.wikipedia.org/wiki/Proof_by_contradiction)技术。例如，罗素悖论的存在意味着所有集合中的一个集合不可能存在。注意，可计算性理论中的许多重要定理，[有点像机器学习中的](https://en.wikipedia.org/wiki/Universal_approximation_theorem)，是*非构造性的*。换句话说，这个定理可能假设某个特定事物的存在，或者排除其他事物的存在，但实际上并没有提供这个事物的一个例子，所以这个证明可能是不直观的，完全不可思议的，但这就是可计算性的工作方式。**

**停机问题的设置导致了一个矛盾；让我们将一个*暂停集* *H* 定义为一组*所有*程序或算法，它们在一些任意输入时暂停。如果我们只讨论 H 的某些子集，这个证明就不会如此深刻。直觉上，这是一个可以接受的定义——尽管我们很快就会看到这是一个天真的定义。回想一下，在我们的计算模型 *T* 中，所有 *k* 索引算法都是唯一的。**

****定义 5:****h*:= {(*k，x* )使得算法或程序 *φₖ* 在输入 *x* 时停止运行***

****定理 1:** *H* 不可计算。**

****证明:****

**假设 *H* 是(总)可计算的，那么它一定有一个可计算的指示函数 I( *k* ， *x* )由 Def。4.如果 *H* 中的程序停止，该指示灯输出 1，否则输出 0；**

**I( *k* ， *x* ) = { 1 如果 *φₖ* 停在*x*；0 否则}。**

**假设我们按如下方式制作一个程序*φ*ₘ*t57】:***

***φ*ₘ(*x*)*:*=*{ 1 如果我( *m* ，*x*)= 0；如果 I( *m* ， *x* ) = 1，则未定义***

**函数 *φ* ₘ的伪代码如下所示:**

```
**def *φ*ₘ():
    if I(*φ*ₘ):
        while 1:
            pass
    return 1**
```

***φ* ₘ在 *H* (由于 *φ* ₘ在某个输入 *x* 上停止)，也是 p.c .(记住，只有指标需要是可计算的总量)。现在观察当我们将指标函数应用于ₘ:时会发生什么**

**我们想确定 *φ* ₘ是否在 *x.* 上停止。如果指示器 I( *m* ，*x*)= I(*φ*ₘ(*x*))确定*φ*ₘ(*x*)*停止，那么根据 *φ* ₘ的定义，它一定不会停止如果指示器确定 *φ* ₘ没有停止， *φ* ₘ必须停止并返回定义 1。在这种情况下，没有反对递归自引用的规则，因为 *H* 的定义足够宽泛，可以包含这样的程序。既然我们得出一个矛盾，我们就不能假设 *H* 是可计算的。 *□****

**显示 *H* 是 c.e .留给读者作为练习(提示:我们能为 *H* 建立一个 p.c .指示器函数吗？).**

**这类似于罗素悖论，因为我们对集合 *H* 的(幼稚)定义允许这样的 *φ* ₘ，其中当且仅当 *φ* ₘ不停止时 *φ* ₘ停止。在 *H* 的定义中*所有*程序的规定就是允许这种矛盾发生的原因。这看起来像是循环推理，从抽象的角度来说*就是*，但是当我们假设 *H* 是可计算的时候，我们对 *H* 的定义承认了这种矛盾。因此，为了保持 *H* 的[一致性](https://en.wikipedia.org/wiki/Consistency)，我们必须拒绝它，因为它是可计算的。**

**课程在现实生活中，如果我们小心避免编写类似于 *φ* ₘ的程序，那么我们的磕磕绊绊的测试人员可以在真实的程序上实现实际的性能，只是受到时间的限制。停滞问题的影响当然是显著的。可以想象，我们可以构建一个元系统来观察暂停检查器的子系统是否会遇到暂停问题。但是，我们需要多少元系统来覆盖它们下面的系统呢？情况变得像一个无限的套娃。令人着迷的是，人类可以从这些停止检查元系统的无限回归之外意识到这种情况，但也可以随意切换到这些系统的任意级别，并从外部和内部对它们进行推理。事实上，这就是一些人认为的*意识的标志性特征。正是这种力量让库尔特·哥德尔、艾伦·图灵、阿隆佐·邱奇等人在 20 世纪 30 年代证明了几个关于逻辑、计算和数学基础的深刻而又相关的定理***

**如果我们能建立一个确定性的，甚至是基于机器学习的停机测试器，来分析 CPU 指令，以确定一个程序是否正在进行有用的计算，或者是否已经进入了无用的无限循环，这将是一件有趣的事情。如果你喜欢这篇文章，请检查我的其他文章，如果你发现任何明显的错误或逻辑漏洞，请让我知道。**

***如果你有风险资本，有兴趣投资这个创意，请联系我。**

****补遗:****

**预计到人们会抱怨上面的证明是“手动的”或者太不正式(毕竟，我们大踏步地采用了递归自引用，并且没有很好地定义指示器将如何检查 *φ* ₘ是否停止)，我将在下面给出一个更加严格的证明。**

**我们将使用图灵机 *T* 的直观定义作为运行确定性过程的机器，满足以下条件:**

*   **能够进行循环和条件分支，并且是有状态的**
*   **能够运行子程序**
*   **能够复制数据(例如将数据复制到子程序中)**
*   **能够永远停止或者运行**

**这台机器 *T* 将计算函数 I( *m* ， *x* )如果它是可计算的*。缺乏对 T* 的精确定义不会过多地妨碍我们对这个证明的理解。**

****定理 2(定理 1 重述):** I( *m* ， *x* )不可计算。**

****证明:**再次假设 I( *m* ， *x* )是可计算的。为了避免怪异的递归自引用，我们做的一件事就是将 *φ* ₘ的*源代码*，S( *m* ) = *φ* ₘ作为输入提供给 I，即 I( *φ* ₘ， *φ* ₘ).在图灵机定义中，程序 *φ* ₘ和它们对应的源代码只是唯一的、真正大的自然数。从机械上讲，在 *H* 中给某个程序输入一个非常大的自然数是没有错的，即使这个数字是 *φ* ₘ本身的唯一“源代码号”。在这种情况下，函数调用自身时没有递归。**

**现在我们在下面定义一个程序控制函数 *h* (我们的候选停止检查器):**

***h*(*φ*):= { 0 if I '(*φ*，*φ*)= 0；否则未定义}**

**注意我们有一个不同的指示函数 I’。我们对可计算的定义只谈到了可计算指标的存在，它们不需要完全相同，但是它们应该表现相同(一致性)。计算*h*(*φ*)*的程序在 *H.* 中，因此我( *m* ， *x* )将能够检查 *h* ( *φ* )是否停止。我们将 *h* ( *φ* )的来源馈给 I( *m* ， *x* )，即 I( *h* ， *h* )。将 I( *h* ， *h* )视为我们的第一级暂停元检查器。***

**当 *h* ( *φ* )在某个程序源代码 *φ* 上运行时，如果 I’(*φ*， *φ* )没有暂停，而 I( *h，h* )返回 1 表示 *h* 暂停，当 I’(*φ*时发散根据可计算性的定义，我们不能让程序同时暂停和分叉(考虑一下*h*(*φ*)I 的一个子程序( *h* ， *h* ))。因此 I( *m* ， *x* )是不可计算的。 *□***

**链接到我的其他文章:**

1.  **[张量流和自定义损失函数](/custom-tensorflow-loss-functions-for-advanced-machine-learning-f13cdd1d188a)**
2.  **[随机森林](/decision-trees-and-random-forests-for-classification-and-regression-pt-1-dbb65a458df)**
3.  **[Softmax 分类](/the-softmax-function-neural-net-outputs-as-probabilities-and-ensemble-classifiers-9bd94d75932)**
4.  **[气候分析](/analyzing-climate-patterns-with-self-organizing-maps-soms-8d4ef322705b)**
5.  **[曲棍球骚乱和极端值](https://medium.com/@hhl60492/black-swans-and-hockey-riots-extreme-value-analysis-and-generalized-extreme-value-distributions-d4b4b84cd374)**