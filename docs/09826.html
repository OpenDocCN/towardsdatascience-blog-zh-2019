<html>
<head>
<title>Understanding Data Engineering Jargon: Schema and Master/Branch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解数据工程术语:模式和主/分支</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-data-engineering-jargon-schema-and-master-branch-525dff66fcb8?source=collection_archive---------17-----------------------#2019-12-24">https://towardsdatascience.com/understanding-data-engineering-jargon-schema-and-master-branch-525dff66fcb8?source=collection_archive---------17-----------------------#2019-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="079c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为非工程师解释的技术工程术语</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/487e3891da378c09b5ae34fdcc733667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j7UwaFRzLhuWDQfL"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Austin Distel</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kz"><p id="940d" class="la lb it bd lc ld le lf lg lh li lj dk translated">“如果一个人不了解一个人，他就会被认为是一个傻瓜。”——卡尔·荣格</p></blockquote><p id="612e" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">说得好，郑先生。我们很多人都这样。当跨职能项目中出现错误时，我们倾向于责怪我们最不了解的一方。我这篇文章的目的是解释一些您可能从您的数据工程、分析师或科学家朋友那里听到的技术术语和概念。本文将集中在定义模式和分支，它们是什么，它们有什么不同，以及它们如何协同工作。</p><h2 id="16f8" class="mf mg it bd mh mi mj dn mk ml mm dp mn lt mo mp mq lx mr ms mt mb mu mv mw mx bi translated">首先，简单介绍一下背景</h2><p id="fd8f" class="pw-post-body-paragraph lk ll it lm b ln my ju lp lq mz jx ls lt na lv lw lx nb lz ma mb nc md me lj im bi translated">让我们了解一下贵公司整体数据结构中发生了什么。一般来说，会有许多不同类型的数据进入并存储在公司的“数据湖”中。可以把数据湖想象成所有信息都被倾倒进去的地方，没有真正的结构。数据湖将以接收时的格式存储数据。可能有来自 Stripe 或 PayPal 的支付信息，可能有来自您的计费系统的发票信息，或者由移动应用程序提供的数据。数据也可以放入“数据仓库”中，在那里数据被更加结构化和格式化，以满足特定的用户需求。如果数据湖是一个通过溪流和雨水填充的大型水体，那么数据仓库将所有水源和瓶子按照体积、纯度和氟化物水平进行排列。我不会详细介绍数据湖或数据仓库中的数据结构，但只要知道这是数据的来源，就足以构建组织中其他成员使用的其他报告和表格。</p><p id="be70" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">这种数据收集是实时的，随着事件和事务的发生而实时发生。一天结束后，运行一个流程来收集完整的一天数据，并开始提取、转换和加载(也称为 ETL)这些数据到各种数据库中。用户和应用程序使用数据库中这些有组织的数据来进一步创建各种表格和报告。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/4503b6452ba308e1d4f705a49fc93c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBjjVJK4f59NBTDsWBdM8g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Data from different sources are stored into the data lake. From here on a regular interval (usually daily after working hours) the databases retrieve data from the data lake and transform it into a more structured form.</figcaption></figure><p id="750f" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">ETL 过程由一组主指令(主代码)定义，该主指令由数据库中的模式使用。为了理解这最后一点，让我们更深入地研究模式和主/分支代码。</p><h2 id="695b" class="mf mg it bd mh mi mj dn mk ml mm dp mn lt mo mp mq lx mr ms mt mb mu mv mw mx bi translated">图式之谜被解开了</h2><p id="ac7d" class="pw-post-body-paragraph lk ll it lm b ln my ju lp lq mz jx ls lt na lv lw lx nb lz ma mb nc md me lj im bi translated">模式可以定义为数据组织背后的逻辑。用于开发一个表(或一组表)的数据就是模式。它将定义一个给定的表如何与另一个表相关，以及一个表应该由什么组成。模式很像 DNA。它是数据库的一部分，也是定义如何构建数据库的一组指令。</p><p id="f18b" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">一个数据库通常包含一个主模式作为事实的来源。这个模式在主代码上运行，用于在其中创建表。当数据分析师和科学家查询数据时，他们通常会对这个主模式执行查询，因为它将提供最新的信息。</p><p id="8d3f" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">本质上，模式可以物理地位于服务器上。您可以直接进入服务器群，找到装有包含您的数据的磁盘的机架，该模式将始终由指导它的指令集来组织。</p><h2 id="8cbb" class="mf mg it bd mh mi mj dn mk ml mm dp mn lt mo mp mq lx mr ms mt mb mu mv mw mx bi translated">主和分支去神秘化</h2><p id="3b7c" class="pw-post-body-paragraph lk ll it lm b ln my ju lp lq mz jx ls lt na lv lw lx nb lz ma mb nc md me lj im bi translated">还记得我们一直在谈论模式背后的逻辑，或者主指令集吗？所有的代码都保存在一个代码库中，数据库将访问这个代码库来决定如何在其中构建表。你可能听说过 GitHub。GitHub 是模式代码所在的地方，存储库中有一个主代码库，简称为 master。当数据库从数据湖或其他来源获取数据时，它会查看主数据库来决定如何安排它的表。从这组代码中，创建了“主模式”。</p><p id="3e24" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">如果有人想改变主密码呢？更改它可能会造成混乱，如果其他人不知道什么时候更改了什么，他们会感到困惑。当用户想要试验或者需要更新主文件时，他们会创建一个分支。分支是主模式的副本，主模式在构建表时不会考虑它。在分支中，用户可以在不影响主节点的情况下进行任何他们想要的更改。一旦他们完成了所做的更改，他们就可以将更改提交给 master。此时，代码通常会通过同行评审。一旦收到审查和批准，分支就被合并到主分支，现在当模式更新它们的表时，它将遵循更新的指令集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/25f891cdfe34f41128e198f154eadb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMAejJTKDK9lvI2p6Y0paA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The database here will follow the master code when determining how to structure the data. Feature 1.1 instructs it to simply add the variables <strong class="bd nj">a </strong>and <strong class="bd nj">b</strong>. A branch is created during day 2, but the database will still follow the master code. Once the feature 1.2 is merged prior to day 3, the database will use the updated master code to utilize the new feature where it will subtract the sum of <strong class="bd nj">a</strong> and <strong class="bd nj">b</strong> with <strong class="bd nj">x</strong>.</figcaption></figure><p id="8811" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">由于一个组织将有许多主代码的用户，因此可以同时创建多个分支。GitHub 等应用程序将管理单个用户分支，并在对主用户进行多次更改时帮助反映所做的更改。</p><p id="bda3" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated"><strong class="lm iu">但是分行代码影响的是什么数据库？<br/> </strong>大问题！我们现在有一个问题，用户需要看到他们代码更改的结果，但是他们不应该针对当前模式运行分支代码，因为这会改变它们！这里的解决方案是制作一个不会按计划自动更新的模式副本。这有两个原因:</p><ol class=""><li id="c735" class="nk nl it lm b ln nd lq ne lt nm lx nn mb no lj np nq nr ns bi translated">如果有大量用户使用他们自己的主模式副本进行更改，那么定期更新每个副本所需的资源将会非常低效。</li><li id="8e3e" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated">我们希望避免对主模式进行任何更改，因为其他人可能会主动报告该模式。如果我们迭代代码更改并在模式中重建一个表，其他用户可能会查询不正确的数据。</li></ol><p id="2ed9" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">因此，有了一个给定模式的副本，以及一个可以自由编辑代码的主模式分支，我们的工程师和分析师就可以自由地开发和试验，而不会影响主模式。由于复制的模式中的表通常不会使用数据湖中的最新数据进行更新，因此这些复制的模式中的数据可能会变得“陈旧”。这不是问题，因为工程师只需要用新数据重建表。这是一个手动过程，因此为了节省时间，工程师将使用“陈旧的”数据来迭代他们的工作，直到他们真正需要用最新的数据来测试他们的工作。</p><h2 id="5679" class="mf mg it bd mh mi mj dn mk ml mm dp mn lt mo mp mq lx mr ms mt mb mu mv mw mx bi translated">综上所述，了解这些如何帮助你与你的分析师和工程师互动？</h2><p id="333e" class="pw-post-body-paragraph lk ll it lm b ln my ju lp lq mz jx ls lt na lv lw lx nb lz ma mb nc md me lj im bi translated">因此，主代码是模式逻辑所在的主要代码库，模式是在物理磁盘(可能是服务器)上维护的有组织的表，其中也可以制作模式的副本，主代码的分支允许工程师和分析师在不影响主模式的情况下构建新功能。</p><p id="902f" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">让我们用这些新发现的知识浏览几个用例:</p><ol class=""><li id="c383" class="nk nl it lm b ln nd lq ne lt nm lx nn mb no lj np nq nr ns bi translated">工程师向您提交了一份新创建的收入报告，但总额计算有误。 <br/> - &gt;分支代码可能是正确的，但是模式副本尚未更新到主模式的数据。<br/> - &gt;分支代码可能包含错误，导致报告不正确，但由于该代码尚未合并到主代码库中，因此不存在影响其他相关报告的风险。</li><li id="4816" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated"><strong class="lm iu">一份新的报告先前通过了测试，但第二天同样的报告失败了。</strong> <br/> - &gt;代码可能已经通过了您的审查，并已提交给主模块，但是代码还没有经过进一步的同行审查，而这是在代码与主模块合并之前所需要的。<br/> - &gt;代码可能已与 master 合并，但运行夜间批处理报告的数据库可能有延迟。代码仍然有效，工程师只需解决与工作负载相关的问题，即可完成夜间批处理过程。(这就是为什么我们不自动更新批处理中的每个模式，这会降低夜间批处理的速度)。</li></ol><p id="df2c" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">思考这些可能性有助于解决问题，并在工程师、分析师和他们的各种商业伙伴之间创造更好的期望。</p><p id="8ac0" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">从开发人员的角度来看，在与业务伙伴的沟通中保持透明，以帮助他们理解存在的开发阶段，并设置检查点，以便他们知道数据何时真正准备好进行审查。作为工程师提供的报告的消费者，您的关注点要清晰简洁，并询问您的工程师他们如何确保数据的完整性。</p><p id="5a0c" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me lj im bi translated">随着对这些术语的更多理解，以及对数据工程过程的更多了解，我希望每个商业伙伴在合作时能有更多的共识。</p></div></div>    
</body>
</html>