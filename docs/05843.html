<html>
<head>
<title>Guide to R and Python in a Single Jupyter Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一本 Jupyter 笔记本中的 R 和 Python 指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/guide-to-r-and-python-in-a-single-jupyter-notebook-ff12532eb3ba?source=collection_archive---------4-----------------------#2019-08-26">https://towardsdatascience.com/guide-to-r-and-python-in-a-single-jupyter-notebook-ff12532eb3ba?source=collection_archive---------4-----------------------#2019-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你可以同时使用两者时，为什么要选择一个？</p><blockquote class="kl km kn"><p id="d09e" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">r 主要用于统计分析，而 Python 为数据科学提供了更通用的方法。r 和 Python 是面向对象面向数据科学的编程语言。学习这两者是一个理想的解决方案。Python 是一种具有可读语法的通用语言。<strong class="jp ir"><em class="iq">——</em></strong><a class="ae ks" href="https://www.calltutors.com/blog/r-vs-python-why-python-preferred-over-r-for-data-analysis/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="iq"/></strong></a></p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/a80ce05b04e0db8e2a1d7a0bfd36d078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*xmql88Y4JK9AK992.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae ks" href="https://webhose.io/blog/machine-learning/machine-learning-showdown-python-vs-r/" rel="noopener ugc nofollow" target="_blank">Image Source</a></figcaption></figure><p id="3614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文基于哈佛大学 AC209b 讲座，大部分内容由 IACS 大学的威尔·克莱博撰写和教授。</p><p id="6230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">R 和 Python 用户之间的战争已经肆虐了好几年。由于大多数老派的统计学家都是在 R 上接受培训的，而且大多数大学的计算机科学和数据科学系都更喜欢 Python，所以两者都有利有弊。我在实践中注意到的主要缺点是每种语言都有可用的软件包。</p><p id="242d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">截至 2019 年，聚类分析和样条的 R 包优于同类型的 Python 包。在本文中，我将通过编码示例向您展示如何获取 R 函数和数据集，然后在基于 Python 的 Jupyter 笔记本中导入和利用它们。</p><p id="da9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的主题是:</p><ul class=""><li id="7d99" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated"><strong class="jp ir">导入(基本)R 函数</strong></li><li id="5c37" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">导入 R 库函数</strong></li><li id="d8f4" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">填充向量 R 理解</strong></li><li id="9da3" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">填充数据帧 R 理解</strong></li><li id="fbd9" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">填充公式 R 理解</strong></li><li id="717f" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">R 中的运行模式</strong></li><li id="7fc5" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">将结果返回给 Python </strong></li><li id="77fd" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">获取 R 中的模型预测</strong></li><li id="f5ca" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">在 R 中绘图</strong></li><li id="33b3" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">阅读 R 的文档</strong></li></ul><p id="880e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的 GitHub 页面上可以找到这篇文章的附带笔记本。</p><div class="lt lu gp gr lv lw"><a href="https://github.com/mrdragonbear/Articles" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">龙熊先生/文章</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">这个存储库包含与我的媒体文章相关的代码相关内容。此存储库是主存储库…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">github.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kz lw"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="d380" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">线性/多项式回归</h1><p id="5ed1" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">首先，我们将看看使用导入的 R 函数执行基本的线性和多项式回归。我们将研究一个关于糖尿病的数据集，其中包含 C 肽浓度和酸度变量的信息。不要担心模型的内容，这是广义可加模型领域中一个常用的例子，我们将在本文的后面讨论。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="7023" class="oa mt iq nw b gy ob oc l od oe">diab = pd.read_csv("data/diabetes.csv")</span><span id="f61d" class="oa mt iq nw b gy of oc l od oe">print("""<br/># Variables are:<br/>#   subject:   subject ID number<br/>#   age:       age diagnosed with diabetes<br/>#   acidity:   a measure of acidity called base deficit<br/>#   y:         natural log of serum C-peptide concentration<br/>#<br/># Original source is Sockett et al. (1987)<br/># mentioned in Hastie and Tibshirani's book <br/># "Generalized Additive Models".<br/>""")</span><span id="e56e" class="oa mt iq nw b gy of oc l od oe">display(diab.head())<br/>display(diab.dtypes)<br/>display(diab.describe())</span></pre><p id="393e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以绘制数据:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="82fd" class="oa mt iq nw b gy ob oc l od oe">ax0 = diab.plot.scatter(x='age',y='y',c='Red',title="Diabetes data") #plotting direclty from pandas!<br/>ax0.set_xlabel("Age at Diagnosis")<br/>ax0.set_ylabel("Log C-Peptide Concentration");</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/0b036130d65e3f9f913b11e424cec830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0Oo2HhLzg5z5Ds-dVXBxg.png"/></div></div></figure><p id="0a4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<code class="fe ol om on nw b">statsmodel</code>进行线性回归。你可能需要安装这个包来遵循代码，你可以用<code class="fe ol om on nw b">pip install statsmodel</code>来完成。</p><ul class=""><li id="5630" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">在 Python 中，我们从目标值的向量和我们自己构建的设计矩阵(例如，从多项式特征)开始工作。</li><li id="e896" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">现在，<code class="fe ol om on nw b">statsmodel</code>的公式界面可以帮助您构建目标值和设计矩阵。</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="78d1" class="oa mt iq nw b gy ob oc l od oe">#Using statsmodels<br/>import statsmodels.formula.api as sm<br/><br/>model1 = sm.ols('y ~ age',data=diab)<br/>fit1_lm = model1.fit()</span></pre><p id="fef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们构建一个数据框架来预测值(有时这只是测试或验证集)</p><ul class=""><li id="bee7" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">对于制作模型预测的漂亮图表非常有用-预测大量值，而不仅仅是训练集中的任何值</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="d47e" class="oa mt iq nw b gy ob oc l od oe">x_pred = np.linspace(0,16,100)<br/><br/>predict_df = pd.DataFrame(data={"age":x_pred})<br/>predict_df.head()</span></pre><p id="f9e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe ol om on nw b">get_prediction(&lt;data&gt;).summary_frame()</code>获得模型的预测(和误差线！)</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="8d20" class="oa mt iq nw b gy ob oc l od oe">prediction_output = fit1_lm.get_prediction(predict_df).summary_frame()<br/>prediction_output.head()</span></pre><p id="3844" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绘制模型和误差线</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="af49" class="oa mt iq nw b gy ob oc l od oe">ax1 = diab.plot.scatter(x='age',y='y',c='Red',title="Diabetes data with least-squares linear fit")<br/>ax1.set_xlabel("Age at Diagnosis")<br/>ax1.set_ylabel("Log C-Peptide Concentration")<br/><br/><br/>ax1.plot(predict_df.age, prediction_output['mean'],color="green")<br/>ax1.plot(predict_df.age, prediction_output['mean_ci_lower'], color="blue",linestyle="dashed")<br/>ax1.plot(predict_df.age, prediction_output['mean_ci_upper'], color="blue",linestyle="dashed");<br/><br/>ax1.plot(predict_df.age, prediction_output['obs_ci_lower'], color="skyblue",linestyle="dashed")<br/>ax1.plot(predict_df.age, prediction_output['obs_ci_upper'], color="skyblue",linestyle="dashed");</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oo"><img src="../Images/74b0676a39b2b3dea3a5c48b58327745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTpWiqebnkRdJFxlsOMadQ.png"/></div></div></figure><p id="daca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以拟合三次多项式模型，并以两种方式绘制模型误差线:</p><ul class=""><li id="ec43" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">Route1:为<code class="fe ol om on nw b">age</code>、<code class="fe ol om on nw b">age**2</code>、<code class="fe ol om on nw b">age**3</code>各建一个设计 df</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="e039" class="oa mt iq nw b gy ob oc l od oe">fit2_lm = sm.ols(formula="y ~ age + np.power(age, 2) + np.power(age, 3)",data=diab).fit()<br/><br/>poly_predictions = fit2_lm.get_prediction(predict_df).summary_frame()<br/>poly_predictions.head()</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi op"><img src="../Images/46e49e0b12271522d37ea6be7a6793d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxZA_FuuUgwEtbQ2dyG0qQ.png"/></div></div></figure><ul class=""><li id="7448" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">方法 2:编辑公式</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="8722" class="oa mt iq nw b gy ob oc l od oe">ax2 = diab.plot.scatter(x='age',y='y',c='Red',title="Diabetes data with least-squares cubic fit")<br/>ax2.set_xlabel("Age at Diagnosis")<br/>ax2.set_ylabel("Log C-Peptide Concentration")<br/><br/>ax2.plot(predict_df.age, poly_predictions['mean'],color="green")<br/>ax2.plot(predict_df.age, poly_predictions['mean_ci_lower'], color="blue",linestyle="dashed")<br/>ax2.plot(predict_df.age, poly_predictions['mean_ci_upper'], color="blue",linestyle="dashed");<br/><br/>ax2.plot(predict_df.age, poly_predictions['obs_ci_lower'], color="skyblue",linestyle="dashed")<br/>ax2.plot(predict_df.age, poly_predictions['obs_ci_upper'], color="skyblue",linestyle="dashed");</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oq"><img src="../Images/93768fc739e573a68470948d34ddfc1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fxd-AKxDsK5HnKhLuApxvw.png"/></div></div></figure><p id="616c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这没有使用 R 编程语言的任何特性。现在，我们可以使用 r 中的函数重复分析。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="5cea" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">线性/多项式回归，但使其为 R</h1><p id="149f" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">在这一节之后，我们将了解使用 R 模型所需的一切。实验室的其余部分只是应用这些概念来运行特定的模型。因此，这一节是你在 r 中工作的“备忘单”。</p><p id="323a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要知道的是:</p><ul class=""><li id="3db2" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">导入(基本)R 函数</li><li id="5140" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">导入 R 库函数</li><li id="1520" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">填充向量 R 理解</li><li id="d215" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">填充 R 理解的数据帧</li><li id="e7bf" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">填充 R 理解的公式</li><li id="0c09" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在 R 中运行模型</li><li id="bf07" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">将结果返回给 Python</li><li id="4e17" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在 R 中获取模型预测</li><li id="3ea0" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在 R 中绘图</li><li id="45b6" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">阅读 R 的文档</li></ul><p id="ca11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">导入 R 函数</strong></p><p id="af92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了导入 R 函数，我们需要<code class="fe ol om on nw b">rpy2</code>包。根据您的环境，您可能还需要指定 R 主目录的路径。下面我举了一个例子来说明如何指定这一点。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="c272" class="oa mt iq nw b gy ob oc l od oe"># if you're on JupyterHub you may need to specify the path to R<br/><br/>#import os<br/>#os.environ['R_HOME'] = "/usr/share/anaconda3/lib/R"<br/><br/>import rpy2.robjects as robjects</span></pre><p id="8a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要指定一个 R 函数，只需使用<code class="fe ol om on nw b">robjects.r</code>后跟方括号中的包名作为字符串。为了防止混淆，我喜欢对从 r 导入的函数、库和其他对象使用<code class="fe ol om on nw b">r_</code>。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="9e8a" class="oa mt iq nw b gy ob oc l od oe">r_lm = robjects.r["lm"]<br/>r_predict = robjects.r["predict"]<br/>#r_plot = robjects.r["plot"] # more on plotting later<br/><br/>#lm() and predict() are two of the most common functions we'll use</span></pre><p id="6cba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">导入 R 库</strong></p><p id="20ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以导入单个函数，但也可以导入整个库。要导入整个库，您可以从<code class="fe ol om on nw b">rpy2.robjects.packages</code>中提取<code class="fe ol om on nw b">importr</code>包。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="5860" class="oa mt iq nw b gy ob oc l od oe">from rpy2.robjects.packages import importr<br/>#r_cluster = importr('cluster')<br/>#r_cluster.pam;</span></pre><p id="de2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填充向量 R 理解</strong></p><p id="55c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要指定一个可以与 Python 包接口的浮点向量，我们可以使用<code class="fe ol om on nw b">robjects.FloatVector</code>函数。这个函数的参数引用了您希望转换成 R 对象的数据数组，在我们的例子中，是来自糖尿病数据集中的<code class="fe ol om on nw b">age</code>和<code class="fe ol om on nw b">y</code>变量。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="7eb0" class="oa mt iq nw b gy ob oc l od oe">r_y = robjects.FloatVector(diab['y'])<br/>r_age = robjects.FloatVector(diab['age'])<br/># What happens if we pass the wrong type?<br/># How does r_age display?<br/># How does r_age print?</span></pre><p id="6c13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填充数据帧 R 理解</strong></p><p id="e765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以指定单独的向量，也可以指定整个数据帧。这是通过使用<code class="fe ol om on nw b">robjects.DataFrame</code>功能完成的。这个函数的参数是一个字典，它指定了名称和与名称相关的向量(从<code class="fe ol om on nw b">robjects.FloatVector</code>获得)。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="bb38" class="oa mt iq nw b gy ob oc l od oe">diab_r = robjects.DataFrame({"y":r_y, "age":r_age})<br/># How does diab_r display?<br/># How does diab_r print?</span></pre><p id="4cfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填充公式 R 理解</strong></p><p id="825b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，要指定一个回归公式，我们可以使用<code class="fe ol om on nw b">robjects.Formula</code>函数。这遵循 R 语法<code class="fe ol om on nw b">dependent variable ~ independent variables</code>。在我们的例子中，输出<code class="fe ol om on nw b">y</code>被建模为<code class="fe ol om on nw b">age</code>变量的函数。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="ecd9" class="oa mt iq nw b gy ob oc l od oe">simple_formula = robjects.Formula("y~age")<br/>simple_formula.environment["y"] = r_y #populate the formula's .environment, so it knows what 'y' and 'age' refer to<br/>simple_formula.environment["age"] = r_age</span></pre><p id="1c16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在上面的公式中，我们必须指定与公式中每个变量相关的 FloatVector。我们必须这样做，因为公式不会自动将我们的变量名与我们之前指定的变量相关联——它们还没有与<code class="fe ol om on nw b">robjects.Formula</code>对象相关联。</p><p id="0038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">R 中的运行模式</strong></p><p id="27fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要指定一个模型，在本例中是一个使用我们之前导入的<code class="fe ol om on nw b">r_lm</code>函数的线性回归模型，我们需要将我们的公式变量作为参数传递(除非我们传递一个 R 公式对象，否则这将不起作用)。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="4543" class="oa mt iq nw b gy ob oc l od oe">diab_lm = r_lm(formula=simple_formula) # the formula object is storing all the needed variables</span></pre><p id="219f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在公式本身中引用数据集，而不是指定与<code class="fe ol om on nw b">robjects.Formula</code>对象相关的每个单独的浮点向量(只要它已经成为 R 对象本身)。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="e0a3" class="oa mt iq nw b gy ob oc l od oe">simple_formula = robjects.Formula("y~age") # reset the formula<br/>diab_lm = r_lm(formula=simple_formula, data=diab_r) #can also use a 'dumb' formula and pass a dataframe</span></pre><p id="5453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">将结果返回给 Python </strong></p><p id="78d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 R 函数和库是很棒的，但是我们也可以分析我们的结果，并将它们返回给 Python 进行进一步的处理。要查看输出:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="e589" class="oa mt iq nw b gy ob oc l od oe">diab_lm #the result is already 'in' python, but it's a special object</span></pre><p id="47f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以检查输出中的名称:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="4f9f" class="oa mt iq nw b gy ob oc l od oe">print(diab_lm.names) # view all names</span></pre><p id="0dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以我们输出的第一个元素为例:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="a4f5" class="oa mt iq nw b gy ob oc l od oe">diab_lm[0] #grab the first element</span></pre><p id="169e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要计算系数:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="98b9" class="oa mt iq nw b gy ob oc l od oe">diab_lm.rx2("coefficients") #use rx2 to get elements by name!</span></pre><p id="0235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将系数放入 Numpy 数组中:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="811c" class="oa mt iq nw b gy ob oc l od oe">np.array(diab_lm.rx2("coefficients")) #r vectors can be converted to numpy (but rarely needed)</span></pre><p id="d0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">得到预测</strong></p><p id="476d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用我们的 R 模型获得预测，我们可以创建一个预测数据帧并使用<code class="fe ol om on nw b">r_predict</code>函数，类似于使用 Python 的方式。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="17a5" class="oa mt iq nw b gy ob oc l od oe"># make a df to predict on (might just be the validation or test dataframe)<br/>predict_df = robjects.DataFrame({"age": robjects.FloatVector(np.linspace(0,16,100))})</span><span id="362e" class="oa mt iq nw b gy of oc l od oe"># call R's predict() function, passing the model and the data <br/>predictions = r_predict(diab_lm, predict_df)</span></pre><p id="9dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe ol om on nw b">rx2</code>函数提取“年龄”值:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="6ef1" class="oa mt iq nw b gy ob oc l od oe">x_vals = predict_df.rx2("age")</span></pre><p id="6c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以使用 Python 绘制数据:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="4bbf" class="oa mt iq nw b gy ob oc l od oe">ax = diab.plot.scatter(x='age',y='y',c='Red',title="Diabetes data")<br/>ax.set_xlabel("Age at Diagnosis")<br/>ax.set_ylabel("Log C-Peptide Concentration");</span><span id="fdf6" class="oa mt iq nw b gy of oc l od oe">ax.plot(x_vals,predictions); #plt still works with r vectors as input!</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oq"><img src="../Images/dc11e530f98bdd42fd18ac1bce977a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWDHGs0AaOfLrWP8paaqlQ.png"/></div></div></figure><p id="4e63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以使用 R 来绘图，尽管这稍微复杂一些。</p><p id="4604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在 R 中绘图</strong></p><p id="c513" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在 R 中绘图，我们需要使用以下命令打开%R magic 函数:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="5f92" class="oa mt iq nw b gy ob oc l od oe">%load_ext rpy2.ipython</span></pre><ul class=""><li id="6bec" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">以上开启了%R“魔法”。</li><li id="8a7e" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">r 的 plot()命令根据您传递给它的内容做出不同的响应；不同的模式得到不同的剧情！</li><li id="a136" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">对于任何特定的模型，搜索 plot.modelname。例如，对于 GAM 模型，搜索<code class="fe ol om on nw b">plot.gam</code>以获得绘制 GAM 模型的任何细节。</li><li id="d11e" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><code class="fe ol om on nw b">%R</code>“magic”在“笔记本”模式下运行 R 代码，所以数字显示得很好</li><li id="fb36" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在<code class="fe ol om on nw b">plot(&lt;model&gt;)</code>代码之前，我们传入 R 需要了解的变量(<code class="fe ol om on nw b">-i</code>代表“输入”)</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="6a00" class="oa mt iq nw b gy ob oc l od oe">%R -i diab_lm plot(diab_lm);</span></pre><p id="0276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">阅读 R 的文档</strong></p><p id="f612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ol om on nw b">lm()</code>功能的文档在这里是<a class="ae ks" href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/lm.html" rel="noopener ugc nofollow" target="_blank"/>，一个更漂亮的版本(相同内容)在这里是<a class="ae ks" href="https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/lm" rel="noopener ugc nofollow" target="_blank"/>。谷歌搜索时，尽可能选择 rdocumentation.org。部分:</p><ul class=""><li id="af73" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated"><strong class="jp ir">用法</strong>:给出函数签名，包括所有可选参数</li><li id="f9e8" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">参数</strong>:每个功能输入控制什么</li><li id="2318" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">细节</strong>:关于函数<em class="ko">做什么</em>以及参数如何交互的附加信息。<strong class="jp ir">经常从正确的地方开始阅读</strong></li><li id="92d0" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">值</strong>:函数返回的对象的结构</li><li id="3251" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">参考文献</strong>:相关学术论文</li><li id="03ee" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><strong class="jp ir">参见</strong>:其他感兴趣的功能</li></ul><p id="74a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">示例</strong></p><p id="0c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为测试我们新获得的知识的例子，我们将尝试以下内容:</p><ul class=""><li id="4b17" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">将 R 中计算的置信区间添加到上面的线性回归图中。使用<code class="fe ol om on nw b">interval=</code>参数到<code class="fe ol om on nw b">r_predict()</code>(文档<a class="ae ks" href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/predict.lm.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。你必须处理一个由 r 返回的矩阵。</li><li id="6857" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">用一个 5 次多项式拟合 r 中的糖尿病数据。在网上搜索一个比用所有 5 个多项式项写出一个公式更简单的方法。</li></ul><p id="3cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">置信区间:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="6be8" class="oa mt iq nw b gy ob oc l od oe">CI_matrix = np.array(r_predict(diab_lm, predict_df, interval="confidence"))<br/><br/>ax = diab.plot.scatter(x='age',y='y',c='Red',title="Diabetes data")<br/>ax.set_xlabel("Age at Diagnosis")<br/>ax.set_ylabel("Log C-Peptide Concentration");<br/><br/>ax.plot(x_vals,CI_matrix[:,0], label="prediction")<br/>ax.plot(x_vals,CI_matrix[:,1], label="95% CI", c='g')<br/>ax.plot(x_vals,CI_matrix[:,2], label="95% CI", c='g')<br/>plt.legend();</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oq"><img src="../Images/1a2b2998f2ebbca4fd1312ea94ebfa34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_i3HhKMDXLFNJthpBlXUfQ.png"/></div></div></figure><p id="dae1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">五次多项式:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="2cac" class="oa mt iq nw b gy ob oc l od oe">ploy5_formula = robjects.Formula("y~poly(age,5)") # reset the formula<br/>diab5_lm = r_lm(formula=ploy5_formula, data=diab_r) #can also use a 'dumb' formula and pass a dataframe<br/><br/>predictions = r_predict(diab5_lm, predict_df, interval="confidence")<br/><br/>ax = diab.plot.scatter(x='age',y='y',c='Red',title="Diabetes data")<br/>ax.set_xlabel("Age at Diagnosis")<br/>ax.set_ylabel("Log C-Peptide Concentration");<br/><br/>ax.plot(x_vals,predictions);</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oq"><img src="../Images/e3ebf3c862a963914f14c19c9509142c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8hJdOLdzugEjBxHwyiymQ.png"/></div></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="df9c" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">洛斯平滑</h1><p id="b373" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">现在我们知道了如何在 Python 中使用 R 对象和函数，我们可以看看我们可能想要这样做的情况。第一个例子是 Lowess 平滑。</p><p id="0a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lowess smoothing 在 Python 和 r 中都实现了。我们将在转换语言时使用它作为另一个例子。</p><p id="03ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Python </strong></p><p id="8484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Python 中，我们使用<code class="fe ol om on nw b">statsmodel.nonparametric.smoothers_lowess</code>来执行 lowess 平滑。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="b6d1" class="oa mt iq nw b gy ob oc l od oe">from statsmodels.nonparametric.smoothers_lowess import lowess as lowess</span><span id="aeb3" class="oa mt iq nw b gy of oc l od oe">ss1 = lowess(diab['y'],diab['age'],frac=0.15)<br/>ss2 = lowess(diab['y'],diab['age'],frac=0.25)<br/>ss3 = lowess(diab['y'],diab['age'],frac=0.7)<br/>ss4 = lowess(diab['y'],diab['age'],frac=1)</span><span id="d9d2" class="oa mt iq nw b gy of oc l od oe">ss1[:10,:] # we get back simple a smoothed y value for each x value in the data</span></pre><p id="94fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意绘制不同模型的清晰代码。一会儿我们会看到更干净的代码。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="ad7a" class="oa mt iq nw b gy ob oc l od oe">for cur_model, cur_frac in zip([ss1,ss2,ss3,ss4],[0.15,0.25,0.7,1]):</span><span id="8a5d" class="oa mt iq nw b gy of oc l od oe">    ax = diab.plot.scatter(x='age',y='y',c='Red',title="Lowess Fit, Fraction = {}".format(cur_frac))<br/>    ax.set_xlabel("Age at Diagnosis")<br/>    ax.set_ylabel("Log C-Peptide Concentration")<br/>    ax.plot(cur_model[:,0],cur_model[:,1],color="blue")<br/>    <br/>    plt.show()</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oq"><img src="../Images/01a2d182841be5a4c9213afc23ce1836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQRU00M8ye806dy-a-ThTA.png"/></div></div></figure><p id="06c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> R </strong></p><p id="e170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在 R 中实现 Lowess 平滑，我们需要:</p><ul class=""><li id="07f2" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">导入黄土功能。</li><li id="d337" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">把数据发给 r。</li><li id="397a" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">调用函数并获得结果。</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="c22b" class="oa mt iq nw b gy ob oc l od oe">r_loess = robjects.r['loess.smooth'] #extract R function<br/>r_y = robjects.FloatVector(diab['y'])<br/>r_age = robjects.FloatVector(diab['age'])</span><span id="a080" class="oa mt iq nw b gy of oc l od oe">ss1_r = r_loess(r_age,r_y, span=0.15, degree=1)</span><span id="b37a" class="oa mt iq nw b gy of oc l od oe">ss1_r #again, a smoothed y value for each x value in the data</span></pre><p id="71ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">可变跨度</strong> <br/>接下来，一些非常干净的代码，以适应和绘制具有各种参数设置的模型。(尽管之前看到的<code class="fe ol om on nw b">zip()</code>方法在标签和参数不同时非常有用)</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="9943" class="oa mt iq nw b gy ob oc l od oe">for cur_frac in [0.15,0.25,0.7,1]:<br/>    <br/>    cur_smooth = r_loess(r_age,r_y, span=cur_frac)</span><span id="1755" class="oa mt iq nw b gy of oc l od oe">    ax = diab.plot.scatter(x='age',y='y',c='Red',title="Lowess Fit, Fraction = {}".format(cur_frac))<br/>    ax.set_xlabel("Age at Diagnosis")<br/>    ax.set_ylabel("Log C-Peptide Concentration")<br/>    ax.plot(cur_smooth[0], cur_smooth[1], color="blue")<br/>    <br/>    plt.show()</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oq"><img src="../Images/aace42352aec3056a9c60c40f38d1298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Svg-Xik2XhdDNJDP7zWSoQ.png"/></div></div></figure><p id="cf12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要看的下一个例子是平滑样条，Python 不太支持这些模型，所以最好使用 R 函数。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="bc42" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">平滑样条</h1><p id="c57a" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">从现在开始，我们将使用 R 函数；Python 不(很好地)支持这些模型。</p><p id="f50a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了清楚起见:这是一个奇特的样条模型</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi or"><img src="../Images/33d4fb530b0414ed44ee4c5d3f3abc0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALLDYoZSOrsF8z_8AWLRpg.png"/></div></div></figure><p id="9dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跨越所有可能的功能<em class="ko"> f </em>。获胜者将始终是一个连续的三次多项式，在每个数据点都有一个结。</p><p id="0174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要考虑的一些事情是:</p><ul class=""><li id="9ec7" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">知道为什么赢家是立方吗？</li><li id="a5e8" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">这个模型的可解释性如何？</li><li id="1b57" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">有哪些可调参数？</li></ul><p id="7d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现平滑样条，我们只需要两条线。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="7439" class="oa mt iq nw b gy ob oc l od oe">r_smooth_spline = robjects.r['smooth.spline'] #extract R function</span><span id="7d03" class="oa mt iq nw b gy of oc l od oe"># run smoothing function<br/>spline1 = r_smooth_spline(r_age, r_y, spar=0)</span></pre><h2 id="bd3d" class="oa mt iq bd mu os ot dn my ou ov dp nc jy ow ox ng kc oy oz nk kg pa pb no pc bi translated">平滑样条交叉验证</h2><p id="6042" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">r 的<code class="fe ol om on nw b">smooth_spline</code>函数有一个内置的交叉验证来为 lambda 找到一个好的值。参见包<a class="ae ks" href="https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/smooth.spline" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="3d9c" class="oa mt iq nw b gy ob oc l od oe">spline_cv = r_smooth_spline(r_age, r_y, cv=True) </span><span id="4158" class="oa mt iq nw b gy of oc l od oe">lambda_cv = spline_cv.rx2("lambda")[0]</span><span id="f119" class="oa mt iq nw b gy of oc l od oe">ax19 = diab.plot.scatter(x='age',y='y',c='Red',title="smoothing spline with $\lambda=$"+str(np.round(lambda_cv,4))+", chosen by cross-validation")<br/>ax19.set_xlabel("Age at Diagnosis")<br/>ax19.set_ylabel("Log C-Peptide Concentration")<br/>ax19.plot(spline_cv.rx2("x"),spline_cv.rx2("y"),color="darkgreen")</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pd"><img src="../Images/11eb4e904ee3e3a3a88976cf41c6d733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXTVL9XTVd7xNNG2TSUpdg.png"/></div></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="dbeb" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">自然样条和基本样条</h1><p id="b374" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">这里，我们在模型复杂性上后退了一步，但在编码复杂性上前进了一步。我们将再次使用 R 的公式接口，所以我们需要填充公式和数据框架。</p><p id="c237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多值得思考的问题:</p><ul class=""><li id="b238" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">自然样条和基本样条在哪些方面不如我们刚刚使用的样条复杂？</li><li id="12ea" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">是什么让样条曲线变得“自然”？</li><li id="ba07" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">什么使样条成为“基础”？</li><li id="79f1" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">调优参数是什么？</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="5451" class="oa mt iq nw b gy ob oc l od oe">#We will now work with a new dataset, called GAGurine.<br/>#The dataset description (from the R package MASS) is below:<br/>#Data were collected on the concentration of a chemical GAG <br/># in the urine of 314 children aged from zero to seventeen years. <br/># The aim of the study was to produce a chart to help a paediatrican<br/># to assess if a child's GAG concentration is ‘normal’.</span><span id="1b76" class="oa mt iq nw b gy of oc l od oe">#The variables are:<br/># Age: age of child in years.<br/># GAG: concentration of GAG (the units have been lost).</span></pre><p id="929a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们导入并绘制数据集:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="9a64" class="oa mt iq nw b gy ob oc l od oe">GAGurine = pd.read_csv("data/GAGurine.csv")<br/>display(GAGurine.head())<br/><br/>ax31 = GAGurine.plot.scatter(x='Age',y='GAG',c='black',title="GAG in urine of children")<br/>ax31.set_xlabel("Age");<br/>ax31.set_ylabel("GAG");</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pd"><img src="../Images/a7dde0024cc36b70caaee1252e14ac58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLzAKjXkq87tgmcLvCwYFA.png"/></div></div></figure><p id="5e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标准的东西:导入函数，将变量转换成 R 格式，调用函数</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="5651" class="oa mt iq nw b gy ob oc l od oe">from rpy2.robjects.packages import importr<br/>r_splines = importr('splines')</span><span id="a6be" class="oa mt iq nw b gy of oc l od oe"># populate R variables<br/>r_gag = robjects.FloatVector(GAGurine['GAG'].values)<br/>r_age = robjects.FloatVector(GAGurine['Age'].values)<br/>r_quarts = robjects.FloatVector(np.quantile(r_age,[.25,.5,.75])) #woah, numpy functions run on R objects</span></pre><p id="234d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们从 r_splines 调用 ns 或 bs 函数时会发生什么？</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="451c" class="oa mt iq nw b gy ob oc l od oe">ns_design = r_splines.ns(r_age, knots=r_quarts)<br/>bs_design = r_splines.bs(r_age, knots=r_quarts)</span><span id="f29b" class="oa mt iq nw b gy of oc l od oe">print(ns_design)</span></pre><p id="ab3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ol om on nw b">ns</code>和<code class="fe ol om on nw b">bs</code>返回设计矩阵，而不是模型对象！这是因为它们应该与<code class="fe ol om on nw b">lm</code>的公式接口一起工作。为了得到一个模型对象，我们填充一个包含<code class="fe ol om on nw b">ns(&lt;var&gt;,&lt;knots&gt;)</code>的公式，并拟合数据。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="25ed" class="oa mt iq nw b gy ob oc l od oe">r_lm = robjects.r['lm']<br/>r_predict = robjects.r['predict']<br/><br/># populate the formula<br/>ns_formula = robjects.Formula("Gag ~ ns(Age, knots=r_quarts)")<br/>ns_formula.environment['Gag'] = r_gag<br/>ns_formula.environment['Age'] = r_age<br/>ns_formula.environment['r_quarts'] = r_quarts<br/>         <br/># fit the model<br/>ns_model = r_lm(ns_formula</span></pre><p id="c8c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像往常一样预测:构建一个数据框架进行预测并调用<code class="fe ol om on nw b">predict()</code>。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="4054" class="oa mt iq nw b gy ob oc l od oe"># predict<br/>predict_frame = robjects.DataFrame({"Age": robjects.FloatVector(np.linspace(0,20,100))})</span><span id="4264" class="oa mt iq nw b gy of oc l od oe">ns_out = r_predict(ns_model, predict_frame)</span><span id="a424" class="oa mt iq nw b gy of oc l od oe">ax32 = GAGurine.plot.scatter(x='Age',y='GAG',c='grey',title="GAG in urine of children")<br/>ax32.set_xlabel("Age")<br/>ax32.set_ylabel("GAG")<br/>ax32.plot(predict_frame.rx2("Age"),ns_out, color='red')<br/>ax32.legend(["Natural spline, knots at quartiles"]);</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pd"><img src="../Images/492faf0b0fc95ae1709dc823e003c60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pX4qZBhwgur0c2Q2sIPFCA.png"/></div></div></figure><p id="b4a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例题</strong></p><p id="d609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看两个实现基样条的例子。</p><ol class=""><li id="5c63" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk pe ll lm ln bi translated">用相同的结拟合一个基本样条模型，并将其添加到上面的图中。</li></ol><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="3703" class="oa mt iq nw b gy ob oc l od oe">bs_formula = robjects.Formula("Gag ~ bs(Age, knots=r_quarts)")<br/>bs_formula.environment['Gag'] = r_gag<br/>bs_formula.environment['Age'] = r_age<br/>bs_formula.environment['r_quarts'] = r_quarts<br/><br/>bs_model = r_lm(bs_formula)<br/>bs_out = r_predict(bs_model, predict_frame)</span><span id="0418" class="oa mt iq nw b gy of oc l od oe">ax32 = GAGurine.plot.scatter(x='Age',y='GAG',c='grey',title="GAG in urine of children")<br/>ax32.set_xlabel("Age")<br/>ax32.set_ylabel("GAG")<br/>ax32.plot(predict_frame.rx2("Age"),ns_out, color='red')<br/>ax32.plot(predict_frame.rx2("Age"),bs_out, color='blue')<br/>ax32.legend(["Natural spline, knots at quartiles","B-spline, knots at quartiles"]);</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pd"><img src="../Images/ad173a6b733484ab1059ebed051092cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3VD4d4IoNME-3oSSanYAA.png"/></div></div></figure><p id="3660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在[2，4，6…14，16]处用 8 个节点拟合一个基本样条，并将其添加到上面的图中。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="6b9f" class="oa mt iq nw b gy ob oc l od oe">overfit_formula = robjects.Formula("Gag ~ bs(Age, knots=r_quarts)")<br/>overfit_formula.environment['Gag'] = r_gag<br/>overfit_formula.environment['Age'] = r_age<br/>overfit_formula.environment['r_quarts'] = robjects.FloatVector(np.array([2,4,6,8,10,12,14,16]))<br/><br/>overfit_model = r_lm(overfit_formula)<br/>overfit_out = r_predict(overfit_model, predict_frame)</span><span id="2f3f" class="oa mt iq nw b gy of oc l od oe">ax32 = GAGurine.plot.scatter(x='Age',y='GAG',c='grey',title="GAG in urine of children")<br/>ax32.set_xlabel("Age")<br/>ax32.set_ylabel("GAG")<br/>ax32.plot(predict_frame.rx2("Age"),ns_out, color='red')<br/>ax32.plot(predict_frame.rx2("Age"),bs_out, color='blue')<br/>ax32.plot(predict_frame.rx2("Age"),overfit_out, color='green')<br/>ax32.legend(["Natural spline, knots at quartiles", "B-spline, knots at quartiles", "B-spline, lots of knots"]);</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pd"><img src="../Images/1c5b05e876fbfda9b6ed651617053bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZR4Xk8lZWAjKTQjeXvZfw.png"/></div></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0093" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">GAMs</h1><p id="0d2a" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">最后，我们来看看我们最先进的模型。这里的编码并不比我们以前做的更复杂，尽管幕后工作很棒。</p><p id="65cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们得到我们的多元数据。</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="4cc7" class="oa mt iq nw b gy ob oc l od oe">kyphosis = pd.read_csv("data/kyphosis.csv")</span><span id="75e6" class="oa mt iq nw b gy of oc l od oe">print("""<br/># kyphosis - wherther a particular deformation was present post-operation<br/># age - patient's age in months<br/># number - the number of vertebrae involved in the operation<br/># start - the number of the topmost vertebrae operated on</span><span id="19d2" class="oa mt iq nw b gy of oc l od oe">""")<br/>display(kyphosis.head())<br/>display(kyphosis.describe(include='all'))<br/>display(kyphosis.dtypes)</span><span id="ae0d" class="oa mt iq nw b gy of oc l od oe">#If there are errors about missing R packages, run the code below:<br/><br/>#r_utils = importr('utils')<br/>#r_utils.install_packages('codetools')<br/>#r_utils.install_packages('gam')</span></pre><p id="b244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了适应游戏，我们</p><ul class=""><li id="477b" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">导入<code class="fe ol om on nw b">gam</code>库</li><li id="8d62" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在我们想要平滑的变量上填充包含<code class="fe ol om on nw b">s(&lt;var&gt;)</code>的公式。</li><li id="dc64" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">调用<code class="fe ol om on nw b">gam(formula, family=&lt;string&gt;)</code>,其中<code class="fe ol om on nw b">family</code>是一个命名概率分布的字符串，根据响应变量被认为如何出现来选择。</li></ul><p id="0c1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">粗略的<code class="fe ol om on nw b">family</code>指导方针:</p><ul class=""><li id="b39f" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">响应是二进制的或“M 次尝试中的 N 次”，例如，患疾病的实验鼠(10 只中的)数量:选择<code class="fe ol om on nw b">"binomial"</code></li><li id="de80" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">响应是没有逻辑上限的计数，例如售出的冰淇淋数量:选择<code class="fe ol om on nw b">"poisson"</code></li><li id="e268" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">响应是真实的，有正态分布的噪声，如人的身高:选择<code class="fe ol om on nw b">"gaussian"</code>(默认)</li></ul><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="cbe8" class="oa mt iq nw b gy ob oc l od oe">#There is a Python library in development for using GAMs (https://github.com/dswah/pyGAM)<br/># but it is not yet as comprehensive as the R GAM library, which we will use here instead.<br/><br/># R also has the mgcv library, which implements some more advanced/flexible fitting methods<br/><br/>r_gam_lib = importr('gam')<br/>r_gam = r_gam_lib.gam<br/><br/>r_kyph = robjects.FactorVector(kyphosis[["Kyphosis"]].values)<br/>r_Age = robjects.FloatVector(kyphosis[["Age"]].values)<br/>r_Number = robjects.FloatVector(kyphosis[["Number"]].values)<br/>r_Start = robjects.FloatVector(kyphosis[["Start"]].values)<br/><br/>kyph1_fmla = robjects.Formula("Kyphosis ~ s(Age) + s(Number) + s(Start)")<br/>kyph1_fmla.environment['Kyphosis']=r_kyph<br/>kyph1_fmla.environment['Age']=r_Age<br/>kyph1_fmla.environment['Number']=r_Number<br/>kyph1_fmla.environment['Start']=r_Start<br/><br/><br/>kyph1_gam = r_gam(kyph1_fmla, family="binomial")</span></pre><p id="6187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拟合的 gam 模型包含许多有趣的数据:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="1e2f" class="oa mt iq nw b gy ob oc l od oe">print(kyph1_gam.names)</span></pre><p id="966c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得密谋吗？在 gam 模型上调用 R 的<code class="fe ol om on nw b">plot()</code>是查看拟合样条的最简单方法</p><p id="e20f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在[ ]:</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="b5f9" class="oa mt iq nw b gy ob oc l od oe">%R -i kyph1_gam plot(kyph1_gam, residuals=TRUE,se=TRUE, scale=20);</span></pre><p id="73c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测像正常情况一样工作(建立一个数据框进行预测，如果您还没有数据框，并调用<code class="fe ol om on nw b">predict()</code>)。但是,“预测”总是报告单个变量效果的总和。如果<code class="fe ol om on nw b">family</code>为非默认，这可能与该点的实际预测不同。</p><p id="2740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们正在进行“逻辑回归”,因此原始预测是对数概率，但我们可以通过使用 in <code class="fe ol om on nw b">predict(..., type="response")</code>获得概率</p><pre class="ku kv kw kx gt nv nw nx ny aw nz bi"><span id="3d9d" class="oa mt iq nw b gy ob oc l od oe">kyph_new = robjects.DataFrame({'Age': robjects.IntVector((84,85,86)), <br/>                               'Start': robjects.IntVector((5,3,1)), <br/>                               'Number': robjects.IntVector((1,6,10))})</span><span id="59bb" class="oa mt iq nw b gy of oc l od oe">print("Raw response (so, Log odds):")<br/>display(r_predict(kyph1_gam, kyph_new))<br/>print("Scaled response (so, probabilty of kyphosis):")<br/>display(r_predict(kyph1_gam, kyph_new, type="response"))</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="4355" class="ms mt iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">最终意见</h1><p id="6ca6" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">一旦您熟悉了这个过程，在 Python 中使用 R 函数就相对容易了，如果您需要使用 R 包来执行数据分析，或者您是一个已经获得了 R 代码的 Python 用户，那么它可以省去很多麻烦。</p><p id="906f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇文章，并发现它的信息和有用的。对于那些希望在 Jupyter 环境中体验 R 和 Python 函数和对象之间的接口的人来说，这本笔记本中使用的所有代码都可以在我的 GitHub 页面上找到。</p><h2 id="a1ed" class="oa mt iq bd mu os ot dn my ou ov dp nc jy ow ox ng kc oy oz nk kg pa pb no pc bi translated">时事通讯</h2><p id="578c" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">关于新博客文章和额外内容的更新，请注册我的时事通讯。</p><div class="lt lu gp gr lv lw"><a href="https://mailchi.mp/6304809e49e7/matthew-stewart" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">时事通讯订阅</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">丰富您的学术之旅，加入一个由科学家，研究人员和行业专业人士组成的社区，以获得…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">mailchi.mp</p></div></div><div class="mf l"><div class="pf l mh mi mj mf mk kz lw"/></div></div></a></div></div></div>    
</body>
</html>