<html>
<head>
<title>Computer Vision for Beginners: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的计算机视觉:第 2 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computer-vision-for-beginners-part-2-29b3f9151874?source=collection_archive---------3-----------------------#2019-03-26">https://towardsdatascience.com/computer-vision-for-beginners-part-2-29b3f9151874?source=collection_archive---------3-----------------------#2019-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cb00" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 中带滤波的图像处理基础</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/832727774710ca7567a1bcbee1c89279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PgfXAlo7co_D5f_D"/></div></div></figure><p id="9bb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">准备是指在实际开始一项任务之前为它做好准备的过程。这可能是写故事、工作面试或数据建模的准备步骤。做好充分的准备，其重要性怎么强调都不为过。如果我们没有进行足够的预处理，那么无论我们有多好的数据，都很难期望得到一个令人满意的结果。</p><p id="149f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是 OpenCV 初学者教程的第二部分，完整系列如下:</p><ol class=""><li id="42f8" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener" target="_blank" href="/computer-vision-for-beginners-part-1-7cca775f58ef">理解颜色模型并在图像上绘制图形</a></li><li id="3972" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir"> <em class="mc">带滤波的图像处理基础</em> </strong></li><li id="c30b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener" target="_blank" href="/computer-vision-for-beginners-part-3-79de62dbeef7">从特征检测到人脸检测</a></li><li id="507b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener" target="_blank" href="/computer-vision-for-beginners-part-4-64a8d9856208">轮廓检测和享受一点乐趣</a></li></ol><p id="7f24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天我们将讨论如何处理图像。这将是一个预处理阶段。在检测边缘和轮廓时，噪声对检测的准确性有很大影响。因此，去除噪声和控制像素值的强度可以帮助模型专注于一般细节并获得更高的精度。模糊、阈值处理和形态变换是我们用于此目的的技术。</p><p id="f0f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章假设你已经熟悉卷积的概念。但如果不是这样，我想推荐你先查一下<a class="ae lw" rel="noopener" target="_blank" href="/the-most-intuitive-and-easiest-guide-for-convolutional-neural-network-3607be47480"> <strong class="kt ir">这个帖子</strong> </a> <strong class="kt ir"> </strong>。本教程的完整代码也可以在<a class="ae lw" href="https://github.com/jjone36/vision_4_beginners/blob/master/part2_image_processing.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Github </strong> </a>上找到。现在让我们一个一个的来看看如何用 OpenCV 应用图像过滤。</p><h1 id="9c62" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">模糊</h1><p id="4d9e" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">模糊的目标是执行降噪。但是我们在这里要格外小心。如果我们对高分辨率的图像应用边缘检测算法，我们会得到太多我们不感兴趣的检测结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/8224112ae1bebc74113c954a9565d551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Py75v-74yoCNA8PgLU6wEw.png"/></div></div></figure><p id="2706" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，如果我们过度模糊图像，我们会丢失数据。因此，我们需要找到一个足够的模糊量，我们将申请没有失去理想的边缘。</p><p id="70ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有几种技术用于实现模糊效果，但我们将讨论 OpenCV 中使用的四种主要技术:<strong class="kt ir"> <em class="mc">平均模糊、高斯模糊、中值模糊</em> </strong> <em class="mc">和</em> <strong class="kt ir"> <em class="mc">双边滤波</em> </strong>。所有这四种技术都有一个共同的基本原理，即使用滤波器(内核)对图像应用卷积运算。在四种模糊方法之间，应用过滤器的值是不同的。</p><p id="88d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">平均模糊</strong>取给定内核区域下所有像素值的平均值，替换中心值。例如，假设我们有一个大小为 5X5 的内核。我们计算卷积结果的平均值，并将结果放在给定区域的中心。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/7559a176c97f60518a800a23fa4c6544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7o1lv_Xnkjct-426TAZeQ.png"/></div></div></figure><p id="69d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么如果我们增加内核的大小会是什么样的呢？随着过滤器的尺寸变大，像素值将更加规范化。因此，我们可以预期图像会变得更加模糊。让我们用如下代码检查一下结果。(为了比较，我将继续将原始图像附加到结果中)</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="c657" class="nh me iq nd b gy ni nj l nk nl"># Import the image and convert to RGB <br/>img = cv2.imread('text.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="2c94" class="nh me iq nd b gy nm nj l nk nl"># Plot the image with different kernel sizes<br/>kernels = [5, 11, 17]</span><span id="8e7f" class="nh me iq nd b gy nm nj l nk nl">fig, axs = plt.subplots(nrows = 1, ncols = 3, figsize = (20, 20))<strong class="nd ir"><br/>for </strong>ind, s <strong class="nd ir">in </strong>enumerate(kernels):<br/>    img_blurred = <strong class="nd ir">cv2.blur(img, ksize = (s, s))</strong><br/>    ax = axs[ind]<br/>    ax.imshow(img_blurred)<br/>    ax.axis('off')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/319c9f2c5d88fb229cdf071125711d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snCwfwgq5-0JMky-h4DmbQ.png"/></div></div></figure><p id="c99a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">中等模糊</strong>与平均模糊相同，只是它使用中值而不是平均值。因此，当我们必须处理图像中的突发噪声时，如“<a class="ae lw" href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise" rel="noopener ugc nofollow" target="_blank">椒盐噪声</a>”，使用中等模糊比平均模糊更好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e61e0d34af53d3854e7c73a2669ff9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*bhA819pLZlZc6w8sBC8AKQ.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk"><a class="ae lw" href="http://eric-yuan.me/bilateral-filtering/" rel="noopener ugc nofollow" target="_blank">The shape of a Gaussian filter (on the left) and a Bilateral filter (on the right)</a></figcaption></figure><p id="8338" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">高斯模糊</strong>无非是使用其值具有高斯分布的内核。这些值是由高斯函数生成的，因此它需要一个 sigma 值作为其参数。正如你在上面的图像中看到的，内核的值在中心附近变高，在角落附近变小。最好将这种方法应用于具有正态分布的<a class="ae lw" href="https://en.wikipedia.org/wiki/Gaussian_noise" rel="noopener ugc nofollow" target="_blank">噪声，例如</a><a class="ae lw" href="https://en.wikipedia.org/wiki/White_noise" rel="noopener ugc nofollow" target="_blank">白噪声</a>。</p><p id="8e60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">双边滤波</strong>是高斯模糊的高级版本。模糊不仅会产生溶解噪声，还会平滑边缘。双边滤波可以在去除噪声的同时保持边缘清晰。它使用高斯分布值，但同时考虑了距离和像素值的差异。因此需要<code class="fe nt nu nv nd b">sigmaSpace</code>和<code class="fe nt nu nv nd b">sigmaColor</code>作为参数。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="cc42" class="nh me iq nd b gy ni nj l nk nl"># Blur the image <br/>img_0 = <strong class="nd ir">cv2.blur</strong>(img, ksize = (7, 7))<br/>img_1 = <strong class="nd ir">cv2.GaussianBlur</strong>(img, ksize = (7, 7), sigmaX = 0)   <br/>img_2 = <strong class="nd ir">cv2.medianBlur</strong>(img, 7)<br/>img_3 = <strong class="nd ir">cv2.bilateralFilter</strong>(img, 7, <!-- -->sigmaSpace = <!-- -->75, sigmaColor =75)</span><span id="65f1" class="nh me iq nd b gy nm nj l nk nl"># Plot the images<br/>images = [img_0, img_1, img_2, img_3]<br/>fig, axs = plt.subplots(nrows = 1, ncols = 4, figsize = (20, 20))</span><span id="882b" class="nh me iq nd b gy nm nj l nk nl"><strong class="nd ir">for</strong> ind, p <strong class="nd ir">in</strong> enumerate(images):<br/>    ax = axs[ind]<br/>    ax.imshow(p)<br/>    ax.axis('off')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/6ccb80a423cf87f041205c9b1e3f611c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N22d0C7ZF6WocZngNCW9gA.png"/></div></div></figure><h1 id="a378" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">阈值处理</h1><p id="52d5" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">阈值处理将图像转换成二值图像。我们需要设置阈值和最大值，然后我们相应地转换像素值。有五种不同类型的阈值处理:<strong class="kt ir"> <em class="mc">二值化、二值化的逆、阈值为零、</em> </strong> <em class="mc">和</em> <strong class="kt ir"> <em class="mc">阈值截断</em> </strong>。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="554a" class="nh me iq nd b gy ni nj l nk nl">img = cv2.imread('gradation.png')</span><span id="125d" class="nh me iq nd b gy nm nj l nk nl"># Thresholding <br/>_, thresh_0 = cv2.threshold(img, 127, 255, <strong class="nd ir">cv2.THRESH_BINARY</strong>)<br/>_, thresh_1 = cv2.threshold(img, 127, 255, <strong class="nd ir">cv2.THRESH_BINARY_INV</strong>)<br/>_, thresh_2 = cv2.threshold(img, 127, 255, <strong class="nd ir">cv2.THRESH_TOZERO</strong>)<br/>_, thresh_3 = cv2.threshold(img, 127, 255, <strong class="nd ir">cv2.THRESH_TOZERO_INV</strong>)<br/>_, thresh_4 = cv2.threshold(img, 127, 255, <strong class="nd ir">cv2.THRESH_TRUNC</strong>)</span><span id="ba48" class="nh me iq nd b gy nm nj l nk nl"># Plot the images<br/>images = [img, thresh_0, thresh_1, thresh_2, thresh_3, thresh_4]</span><span id="f861" class="nh me iq nd b gy nm nj l nk nl">fig, axs = plt.subplots(nrows = 2, ncols = 3, figsize = (13, 13))<br/><strong class="nd ir">for </strong>ind, p <strong class="nd ir">in </strong>enumerate(images):<br/>    ax = axs[ind//3, ind%3]<br/>    ax.imshow(p)<br/>plt.show()</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nx kk ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/af9960a8fe58f4e5925c46fb282017b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*swjBYQOnuNfv1rHM3p39PQ.png"/></div></figure><figure class="nx kk od nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ad94cbb87c3ea28ce587f60aad2ce7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*gmOL367EAnlsSdtNFqjB-A.png"/></div></figure></div><p id="381c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到每种类型的阈值是如何用数学方法表示的，并且<strong class="kt ir"> I(x，y) </strong>是该点的强度，或者(x，y)处的像素值。但是我更喜欢直观的理解概念。看一下右边的图片。这些图片有助于你理解不同类型之间的区别。</p><p id="f4b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是你不认为只取一个阈值并将其应用于图像的所有部分太苛刻了吗？如果我们有一张在不同区域有不同亮度的照片会怎么样？在这种情况下，将一个值应用于整个图像将是一个糟糕的选择。更好的方法是对图像的每个部分使用不同的阈值。还有一种叫做<strong class="kt ir"> <em class="mc">自适应阈值</em> </strong>的技术，就是为这个问题服务的。通过计算图像邻域内的阈值，我们可以从光照变化的图像中获得更好的结果。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7445" class="nh me iq nd b gy ni nj l nk nl"># Convert the image to grayscale<br/>img = cv2.imread('text.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><span id="a1cd" class="nh me iq nd b gy nm nj l nk nl"># Adaptive Thresholding<br/>_, thresh_binary = cv2.threshold(img, thresh = 127, maxval = 255, type = cv2.THRESH_BINARY)<br/>adap_mean_2 = cv2.adaptiveThreshold(img, 255, <br/>                                    <strong class="nd ir">cv2.ADAPTIVE_THRESH_MEAN_C</strong>, <br/>                                    <strong class="nd ir">cv2.THRESH_BINARY</strong>, 7, 2)<br/>adap_mean_2_inv = cv2.adaptiveThreshold(img, 255, <br/>                                        <strong class="nd ir">cv2.ADAPTIVE_THRESH_MEAN_C</strong>, <br/>                                        <strong class="nd ir">cv2.THRESH_BINARY_INV</strong>, 7, 2)<br/>adap_mean_8 = cv2.adaptiveThreshold(img, 255, <br/>                                    <strong class="nd ir">cv2.ADAPTIVE_THRESH_MEAN_C</strong>, <br/>                                    cv2.THRESH_BINARY, 7, <strong class="nd ir">8</strong>)<br/>adap_gaussian_8 = cv2.adaptiveThreshold(img, 255, <br/>                                    <strong class="nd ir">cv2.ADAPTIVE_THRESH_GAUSSIAN_C</strong>, <br/>                                    cv2.THRESH_BINARY, 7, <strong class="nd ir">8</strong>)</span></pre><p id="fc8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要将彩色模式转换为灰度模式，以应用自适应阈值处理。自适应阈值的参数有<code class="fe nt nu nv nd b">maxValue</code>(上面我设置了 255)、<code class="fe nt nu nv nd b">adaptiveMethod</code>、<code class="fe nt nu nv nd b">thresholdType</code>、<code class="fe nt nu nv nd b">blockSize</code>、<code class="fe nt nu nv nd b">C</code>。而这里的自适应方法有两种:<code class="fe nt nu nv nd b">ADAPTIVE_THRESH_MEAN_C</code>、<code class="fe nt nu nv nd b">ADAPTIVE_THRESH_GAUSSIAN_C</code>。让我们看看图像是如何不同地产生的。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="e8c5" class="nh me iq nd b gy ni nj l nk nl"># Plot the images<br/>images = [img, thresh_binary, adap_mean_2, adap_mean_2_inv, <br/>          adap_mean_8, adap_gaussian_8]<br/>fig, axs = plt.subplots(nrows = 2, ncols = 3, figsize = (15, 15))</span><span id="87fd" class="nh me iq nd b gy nm nj l nk nl"><strong class="nd ir">for</strong> ind, p <strong class="nd ir">in </strong>enumerate(images):<br/>    ax = axs[ind%2, ind//2]<br/>    ax.imshow(p, cmap = 'gray')<br/>    ax.axis('off')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/bedfbcc73309a7ef28fbe33de05d0fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-x9AjrP7F0mlRo3xr822w.png"/></div></div></figure><p id="ac47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有原始图像，左边一行是二值化的图像。将此与上面一行的第二个和第三个图像进行比较，这是由<code class="fe nt nu nv nd b">ADAPTIVE_THRESH_MEAN_C</code>生成的。它显示了比二进制阈值更详细的结果。我们还可以看到，当 C 值较大时，它变得更加明显。<code class="fe nt nu nv nd b">C</code>表示我们将从平均值或加权平均值中减去多少。有了右边这两幅图，我们还可以比较 C 值相同的<code class="fe nt nu nv nd b">ADAPTIVE_THRESH_MEAN_C</code>和<code class="fe nt nu nv nd b">ADAPTIVE_THRESH_GAUSSIAN_C</code>的效果。</p><h1 id="175b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">梯度</h1><p id="2da3" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我相信我们已经熟悉了梯度的概念。在数学中，<a class="ae lw" href="https://en.wikipedia.org/wiki/Gradient" rel="noopener ugc nofollow" target="_blank">梯度</a>在几何上表示一个多变量函数的图形的斜率。因为它是一个向量值函数，所以它以方向和幅度作为其分量。这里我们也可以把同样的概念应用到图像的像素值上。<a class="ae lw" href="https://en.wikipedia.org/wiki/Image_gradient" rel="noopener ugc nofollow" target="_blank">图像梯度</a>表示强度或颜色模式的方向变化，我们可以使用这个概念来定位边缘。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2304" class="nh me iq nd b gy ni nj l nk nl"># Apply gradient filtering<br/>sobel_x = <strong class="nd ir">cv2.Sobel</strong>(img, cv2.CV_64F, <strong class="nd ir">dx = 1, dy = 0</strong>, ksize = 5)<br/>sobel_y = <strong class="nd ir">cv2.Sobel</strong>(img, cv2.CV_64F, <strong class="nd ir">dx = 0, dy = 1</strong>, ksize = 5)<br/>blended = <strong class="nd ir">cv2.addWeighted</strong>(src1=sobel_x, alpha=0.5, src2=sobel_y,<br/>                          beta=0.5, gamma=0)<br/>laplacian = <strong class="nd ir">cv2.Laplacian</strong>(img, cv2.CV_64F)</span></pre><p id="45e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lw" href="https://en.wikipedia.org/wiki/Sobel_operator" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">索贝尔运算</strong> </a>同时使用高斯平滑和微分。我们通过<code class="fe nt nu nv nd b">cv2.Sobel()</code>应用它，有两个不同的方向可用:垂直(<code class="fe nt nu nv nd b">sobel_x</code>)和水平(<code class="fe nt nu nv nd b">sobel_y</code>)。<code class="fe nt nu nv nd b">dx</code>和<code class="fe nt nu nv nd b">dy</code>表示衍生产品。当<code class="fe nt nu nv nd b">dx = 1</code>时，操作者计算像素值沿水平方向的导数以进行过滤。</p><p id="c10b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过对<code class="fe nt nu nv nd b">sobel_x</code>和<code class="fe nt nu nv nd b">sobel_y</code>两个滤波器求和，我们也可以在两个方向上应用。使用函数<code class="fe nt nu nv nd b">cv2.addWeighted()</code>，我们可以计算滤波器的加权和。正如你在上面的代码单元中看到的，我给了两个过滤器相同的权重。</p><p id="0446" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">拉普拉斯运算</strong>使用 x 和 y 的二阶导数，数学表达式如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/30caea3311de02d9ce4938006143a005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*CCoshNQzstEBBFejAQIMMw.png"/></div></figure><p id="17d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一张图胜过千言万语。让我们看看图像是什么样的。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1899" class="nh me iq nd b gy ni nj l nk nl"># Plot the images<br/>images = [sobel_x, sobel_y, blended, laplacian]<br/>plt.figure(figsize = (20, 20))<br/>for i in range(4):<br/>    plt.subplot(1, 4, i+1)<br/>    plt.imshow(images[i], cmap = 'gray')<br/>    plt.axis('off')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/9eae70ba389d43eb847156db4ff1e76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhA-rfgStylcIjyr5vrFKw.png"/></div></div></figure><p id="ee17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很明显，第一和第二图像具有方向性图案。通过第一张图片，我们可以清楚地看到垂直方向的边缘。在第二张图中，我们可以看到水平边缘。和第四图像，示出了两个方向上的边缘。</p><h1 id="f9d4" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">形态转换</h1><p id="8fc1" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">也可以通过过滤来操纵图像的形状，这被称为<strong class="kt ir"><em class="mc"/></strong>。先说侵蚀和膨胀。</p><p id="97df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">腐蚀</strong>是缩小图形的技术，通常以灰度处理。过滤器的形状可以是矩形、椭圆形和十字形。通过应用过滤器，我们移除给定区域下的任何 0 值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/2bc540c198b63566d9eb960acc52f4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hIEcVZNeNia9vcOmpYSNA.png"/></div></div></figure><p id="5642" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看这些如何在代码中实现。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="9584" class="nh me iq nd b gy ni nj l nk nl">img = cv2.imread('simpson.jpg')</span><span id="7304" class="nh me iq nd b gy nm nj l nk nl"># Create erosion kernels <br/>kernel_0 = np.ones((9, 9), np.uint8)<br/>kernel_1 = cv2.getStructuringElement(<strong class="nd ir">cv2.MORPH_ELLIPSE</strong>, (9, 9))<br/>kernel_2 = cv2.getStructuringElement(<strong class="nd ir">cv2.MORPH_CROSS</strong>, (9, 9))</span><span id="ca0d" class="nh me iq nd b gy nm nj l nk nl">kernels = [kernel_0, kernel_1, kernel_2]</span><span id="3304" class="nh me iq nd b gy nm nj l nk nl"># Plot the images<br/>plt.figure(figsize = (20, 20))<br/>for i in range(3):<br/>    img_copy = img.copy()<br/>    img_copy = cv2.erode(img_copy, kernels[i], iterations = 3)<br/>    plt.subplot(1, 3, i+1)<br/>    plt.imshow(img_copy)<br/>    plt.axis('off')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/2ac6ea70e9d2f405dce5332cf2466e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUxh8p-YQRgW1ClDEGJ96A.png"/></div></div></figure><p id="fb28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看看辛普森一家是如何通过使用不同类型的内核而缩小的。(对辛普森失去双手感到抱歉！)我们可以看到，具有椭圆过滤器的图像以“圆形”方式被侵蚀，而具有方形形状的基本过滤器的图像以“线性”方式被侵蚀。最后一个十字滤镜显示它以“对角线”方式收缩。</p><p id="f2e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">膨胀</strong>与侵蚀相反。它使物体膨胀，其操作也将与侵蚀相反。让我们用如下代码检查一下结果。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2a2c" class="nh me iq nd b gy ni nj l nk nl"># Apply dilation<br/>kernel = np.ones((9, 9), np.uint8)<br/>img_dilate = cv2.dilate(img, kernel, iterations = 3)</span><span id="fb52" class="nh me iq nd b gy nm nj l nk nl">plt.figure(figsize = (20, 10))<br/>plt.subplot(1, 2, 1); plt.imshow(img, cmap="gray")<br/>plt.subplot(1, 2, 2); plt.imshow(img_dilate, cmap="gray")<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/cefa1be2bd945cfd3e35e8c25be5a917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZGkk3Je_w1djUiVSYjMuQ.png"/></div></div></figure><p id="da29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">开启</strong>和<strong class="kt ir">关闭</strong>操作是腐蚀和膨胀的混合版本。打开先进行腐蚀，然后对腐蚀的结果进行膨胀，而关闭先进行膨胀，然后进行腐蚀。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/58153bedad6da0d62324254ecf26322c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIQO85byCuxy5-olcI_YZw.png"/></div></div></figure><p id="0d7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如上图所示，闭合有助于检测图形的整体轮廓，而打开则适合检测子模式。我们可以用下面显示的函数<code class="fe nt nu nv nd b">cv2.morphologyEx()</code>来实现这些操作符。参数<code class="fe nt nu nv nd b">op</code>表示我们将使用哪种类型的操作符。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8fd1" class="nh me iq nd b gy ni nj l nk nl"># Apply the operations<br/>kernel = np.ones((9, 9), np.uint8)</span><span id="58c6" class="nh me iq nd b gy nm nj l nk nl">img_open = cv2.morphologyEx(img, op= <strong class="nd ir">cv2.MORPH_OPEN</strong>, kernel)<br/>img_close = cv2.morphologyEx(img, op= <strong class="nd ir">cv2.MORPH_CLOSE</strong>, kernel)<br/>img_grad = cv2.morphologyEx(img, op= <strong class="nd ir">cv2.MORPH_GRADIENT</strong>, kernel)<br/>img_tophat = cv2.morphologyEx(img, op= <strong class="nd ir">cv2.MORPH_TOPHAT</strong>, kernel)<br/>img_blackhat = cv2.morphologyEx(img, op= <strong class="nd ir">cv2.MORPH_BLACKHAT</strong>, kernel)</span><span id="c122" class="nh me iq nd b gy nm nj l nk nl"># Plot the images<br/>images = [img, img_open, img_close, img_grad, <br/>          img_tophat, img_blackhat]</span><span id="8007" class="nh me iq nd b gy nm nj l nk nl">fig, axs = plt.subplots(nrows = 2, ncols = 3, figsize = (15, 15))<br/><strong class="nd ir">for</strong> ind, p <strong class="nd ir">in </strong>enumerate(images):<br/>    ax = axs[ind//3, ind%3]<br/>    ax.imshow(p, cmap = 'gray')<br/>    ax.axis('off')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/dca25551dfed946ed5db8d705aea60bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDSFRKt0SRC3feyTKrH8Bg.png"/></div></div></figure><p id="676c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，在打开滤镜和关闭滤镜的图像中，Simpson 的手被描绘得不同。梯度过滤器(<code class="fe nt nu nv nd b">MORPH_CGRADIENT</code>)是从膨胀到侵蚀减去的区域。礼帽滤镜(<code class="fe nt nu nv nd b">MORPH_TOPHAT</code>)是从打开到原始图像减去的区域，而黑色热滤镜(<code class="fe nt nu nv nd b">MORPH_BLACKHAT</code>)是从关闭减去的区域。我推荐你访问这里的<a class="ae lw" href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"/></a><strong class="kt ir"/>以获得关于形态运算符的进一步解释。</p><h1 id="aa26" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">下一步是什么？</h1><p id="a450" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">你喜欢各种各样的图像处理技术吗？除了我们已经讨论过的东西，OpenCV 中还有其他可用的东西。因此，请不要犹豫，赶快访问并查看<a class="ae lw" href="https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html?highlight=adaptivethreshold#https://datascienceschool.net/view-notebook/c4121d311aa34e6faa84f62ef06e43b0/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> OpenCV 文档</strong> </a>。下一次将是关于检测技术，如轮廓检测和面部检测。</p><p id="5c82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有你想改正的错误吗？请与我们分享您的见解。我总是乐于交谈，所以请在下面留下评论，分享你的想法。我还在<a class="ae lw" href="https://www.linkedin.com/in/jiwon-jeong/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> LinkedIn </strong> </a>上分享有趣和有用的资源，欢迎随时关注或联系我。我将带着故事的下一个系列回来。敬请期待！</p></div></div>    
</body>
</html>