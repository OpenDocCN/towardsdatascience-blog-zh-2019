<html>
<head>
<title>Generating Wine Recommendations using the Universal Sentence Encoder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用通用句子编码器生成葡萄酒推荐</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-wine-recommendations-using-the-universal-sentence-encoder-d086edd13d00?source=collection_archive---------17-----------------------#2019-08-22">https://towardsdatascience.com/generating-wine-recommendations-using-the-universal-sentence-encoder-d086edd13d00?source=collection_archive---------17-----------------------#2019-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi jx"><img src="../Images/a26150675a9909bd007f29a1affe2905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p46isspX_nanxMCeZ81_vg.png"/></div></div></figure><h2 id="254e" class="kj kk it bd kl km kn dn ko kp kq dp kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">探索自然语言处理</h2><p id="52b9" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp ks lq lr ls kw lt lu lv la lw lx ly lz im bi translated">自从我在大学学习修辞理论和技术交流时第一次读到图灵测试，自然语言处理(NLP)就让我着迷。我们交流的复杂性和微妙性似乎一直是使我们成为独特和智慧物种的决定性因素，因此训练机器理解语言将交流从如此模糊、有说服力和深情的东西转变为似乎机械、有序和可预测的东西。一旦我开始编码，没过多久我的好奇心就驱使我更好地理解我们如何使用机器学习来获得对自然语言的新见解，并推导出我们可能错过的细微差别。例如，最近发表的一篇论文讨论了 NLP 如何用于材料科学的新发现。</p><p id="0364" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">我一直在玩的 NLP 工具之一是托管在<a class="ae mf" href="https://tfhub.dev/google/universal-sentence-encoder/2" rel="noopener ugc nofollow" target="_blank"> Tensorflow-hub </a>上的<a class="ae mf" href="https://arxiv.org/pdf/1803.11175.pdf" rel="noopener ugc nofollow" target="_blank">通用句子编码器</a>(使用)。使用预先训练的模型，将文本编码成 512 维向量。它针对大于单词长度的文本进行了优化，并针对各种数据源进行了训练。有几种不同的用法。我选择了使用深度平均网络(DAN)训练的模型，因为它比基于变压器的模型占用的资源更少。我使用该工具的第一个项目是基于葡萄酒描述和我的搜索查询之间的语义相似性生成葡萄酒推荐。该项目在 www.robotsdodream.com<a class="ae mf" href="http://robotsdodream.com/" rel="noopener ugc nofollow" target="_blank">举办</a></p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi mg"><img src="../Images/2752f0ec8a1e08e462dffa65570dc9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mq3uFrvGXmyUO45aKPkyJQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">The Auto-Sommelier allows a user to input a query and generate three wine recommendations.</figcaption></figure></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><h1 id="168a" class="ml kk it bd kl mm mn mo ko mp mq mr kr ms mt mu kv mv mw mx kz my mz na ld nb bi translated">数据</h1><p id="bdc6" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp ks lq lr ls kw lt lu lv la lw lx ly lz im bi translated">由模型编码的葡萄酒数据来自在<a class="ae mf" href="https://www.kaggle.com" rel="noopener ugc nofollow" target="_blank">kaggle.com 上找到的</a><a class="ae mf" href="https://www.kaggle.com/zynicide/wine-reviews" rel="noopener ugc nofollow" target="_blank">葡萄酒评论</a>数据集。它包含大约 130，000 行数据，包括国家、描述、标题、品种、酒厂、价格和评级等列。将数据放入 dataframe 后，我删除了包含重复描述的行和价格为空的行。我还将数据限制在有超过 200 条评论的葡萄酒品种上。</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="be0f" class="kj kk it nd b gy nh ni l nj nk"><em class="nl">#import dependancies</em><br/><strong class="nd iu">import</strong> <strong class="nd iu">numpy</strong> <strong class="nd iu">as</strong> <strong class="nd iu">np</strong><br/><strong class="nd iu">import</strong> <strong class="nd iu">pandas</strong> <strong class="nd iu">as</strong> <strong class="nd iu">pd<br/>import</strong> <strong class="nd iu">tensorflow</strong> <strong class="nd iu">as</strong> <strong class="nd iu">tf</strong><br/><strong class="nd iu">import</strong> <strong class="nd iu">tensorflow_hub</strong> <strong class="nd iu">as</strong> <strong class="nd iu">tfhub<br/>import</strong> <strong class="nd iu">sqlite3<br/>from</strong> <strong class="nd iu">sqlite3</strong> <strong class="nd iu">import</strong> Error<br/><strong class="nd iu">import io</strong></span><span id="a5c5" class="kj kk it nd b gy nm ni l nj nk">#create a connection to the sqlite database.<br/>conn = sqlite3.connect('db\wine_data.sqlite', detect_types = sqlite3.PARSE_DECELTYPES)<br/>c = conn.cursor()</span><span id="3efc" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#read the table in the database.</em><br/>wine_df = pd.read_sql('Select * from wine_data', conn)</span><span id="eb20" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#Drop the duplicate descriptions.</em><br/>wine_df = wine_df.drop_duplicates('description')</span><span id="ae19" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#drop null prices.</em><br/>wine_df = wine_df.dropna(subset=['price'])</span><span id="034d" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#filter the dataframe to include only varieties with more than 200 reviews.</em><br/>wine_df = wine_df.groupby('variety').filter(<strong class="nd iu">lambda</strong> x: len(x) &gt; 200)</span></pre><p id="25ee" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">通过排除少于 200 条评论的品种来减少数据，我得到了 54 种葡萄酒。通过谷歌搜索剩下的品种，我可以添加一个颜色栏，这样用户就可以通过想要的葡萄酒颜色来限制他们的搜索。</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="e12a" class="kj kk it nd b gy nh ni l nj nk"><em class="nl">#create a column named color.</em><br/>wine_df["color"] = ""</span><span id="8f40" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#used to update the database with the wine color. Manually updated each wine variety.</em><br/>c.execute("update wine_data set color = 'red' where variety = 'Aglianico'  ")</span><span id="032d" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#commit the update to the database so it saves.</em><br/>conn.commit()</span><span id="76a1" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#remove all the records without a color.</em><br/>wine_df = pd.read_sql("select country, description,rating,price,province,title,variety, winery, color  from wine_data where color in ('red', 'white', 'other')", conn)<br/>wine_df.to_sql('wine_data', conn, if_exists = "replace")</span></pre><p id="28c6" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">清理完数据，就剩下 100228 行了。</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><h1 id="dfdb" class="ml kk it bd kl mm mn mo ko mp mq mr kr ms mt mu kv mv mw mx kz my mz na ld nb bi translated">设置通用句子编码器</h1><p id="2937" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp ks lq lr ls kw lt lu lv la lw lx ly lz im bi translated">基于 DAN 的模型大约有 800mb，所以我觉得在本地托管它很重要。使用 OS 库，我设置了模型缓存的位置，并且能够从本地目录调用它，而不是每次都下载它。</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="5139" class="kj kk it nd b gy nh ni l nj nk"><strong class="nd iu">import</strong> <strong class="nd iu">os</strong></span><span id="f546" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#create the directory in which to cache the tensorflow universal sentence encoder.</em><br/>os.environ["TFHUB_CACHE_DIR"] = 'C:/Users/Admin/Downloads'<br/>download = tfhub.Module("https://tfhub.dev/google/universal-sentence-encoder/2")</span></pre><p id="c030" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">下载完模型后，在指定的目录下会出现一个文件，名字类似于<em class="nl">1 FB 57 C3 FFE 1a 38479233 ee 9853 DDD 7 a 8 a 8 a 8 c 47。</em></p><h1 id="9091" class="ml kk it bd kl mm nn mo ko mp no mr kr ms np mu kv mv nq mx kz my nr na ld nb bi translated">创建函数</h1><p id="5b29" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp ks lq lr ls kw lt lu lv la lw lx ly lz im bi translated">即使下载了模型，应用程序的最初几个迭代也是资源密集型的，而且慢得令人恼火。经过一点研究和修改，我决定使用函数来减少 tensorflow 构建图形和编码数据的开销和时间。通过使用占位符，我相信性能会得到提高，因为它降低了图形的复杂性。以这种方式编码数据会比较快。</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="4e57" class="kj kk it nd b gy nh ni l nj nk">def embed_useT():<br/>    with tf.Graph().as_default():<br/>        text_input = tf.compat.v1.placeholder(dtype = tf.string, shape=[None])<br/>        embed = tfhub.Module('C:/Users/Admin/Downloads/1fb57c3ffe1a38479233ee9853ddd7a8ac8a8c47')<br/>        em_txt = embed(text_input)<br/>        session = tf.compat.v1.train.MonitoredSession()<br/>    return lambda x:session.run(em_txt, feed_dict={text_input:list(x)})</span><span id="02f0" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#run the model.</em><br/>embed_fn = embed_useT()</span><span id="a010" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#encode the wine descriptions.</em><br/>result = embed_fn(wine_df.description)</span></pre><p id="fc60" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">对所有描述进行编码会消耗系统资源，并占用 2gb 或更多的 RAM。为了节省系统内存，我将 numpy 数组保存到我的 SQLite 数据库中。从数据库调用数组而不是对其进行动态编码，这使我可以在使用 2g ram 的虚拟机上运行应用程序。在运行中对它们进行编码，我使用了一台至少有 4g 内存的机器，即使这样有时也不够。由于我在 stackoverflow 上找到了一个解决方案，将 numpy 数组保存到数据库变得很容易:</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="3282" class="kj kk it nd b gy nh ni l nj nk">def adapt_array(arr):<br/>    '''<br/>    <a class="ae mf" href="http://stackoverflow.com/a/31312102/190597" rel="noopener ugc nofollow" target="_blank">http://stackoverflow.com/a/31312102/190597</a> (SoulNibbler)<br/>    '''<br/>    out = io.BytesIO()<br/>    np.save(out, arr)<br/>    out.seek(0)<br/>    return sqlite3.Binary(out.read())<br/>  <br/>def convert_array(text):<br/>    out = io.BytesIO(text)<br/>    out.seek(0)<br/>    return np.load(out)<br/>   <br/># Converts np.array to TEXT when inserting.<br/>sqlite3.register_adapter(np.ndarray, adapt_array)</span><span id="ebfe" class="kj kk it nd b gy nm ni l nj nk"># Converts TEXT to np.array when selecting,<br/>sqlite3.register_converter("array", convert_array)</span><span id="3792" class="kj kk it nd b gy nm ni l nj nk">c.execute("create table embeddings (arr array)")</span><span id="a099" class="kj kk it nd b gy nm ni l nj nk">conn.commit()</span><span id="9d9b" class="kj kk it nd b gy nm ni l nj nk">c.execute("insert into embeddings (arr) values (?)", (result, ))</span><span id="830d" class="kj kk it nd b gy nm ni l nj nk">conn.commit()</span><span id="f8a0" class="kj kk it nd b gy nm ni l nj nk">#return the array<br/>c.execute("select * from embeddings")<br/>data = c.fetchone()[0]</span></pre><p id="3038" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">对葡萄酒描述进行编码后，我创建了一个函数，通过对用户查询进行编码并找到两个数组的点积来输出葡萄酒推荐:</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="96d9" class="kj kk it nd b gy nh ni l nj nk">def recommend_engine(query, color, embedding_table = result):</span><span id="55c7" class="kj kk it nd b gy nm ni l nj nk">    wine_df = pd.read_sql('Select * from wine_data', db.session.bind)</span><span id="3625" class="kj kk it nd b gy nm ni l nj nk">    embedding = embed_fn([query])</span><span id="1d10" class="kj kk it nd b gy nm ni l nj nk">#Calculate similarity with all reviews<br/>    similarity_score = np.dot(embedding, embedding_table.T)</span><span id="539c" class="kj kk it nd b gy nm ni l nj nk">    recommendations = wine_df.copy()<br/>    recommendations['recommendation'] = similarity_score.T<br/>    recommendations = recommendations.sort_values('recommendation', ascending=False)</span><span id="bfac" class="kj kk it nd b gy nm ni l nj nk">#filter through the dataframe to find the corresponding wine color records.<br/>    if (color == 'red'):<br/>        recommendations = recommendations.loc[(recommendations.color =='red')] <br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    elif(color == "white"):<br/>        recommendations = recommendations.loc[(recommendations.color =='white')] <br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    elif(color == "other"):<br/>        recommendations = recommendations.loc[(recommendations.color =='other')] <br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    else:<br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    <br/>    return recommendations.head(3).T</span></pre><p id="1b48" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">测试功能:</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="1584" class="kj kk it nd b gy nh ni l nj nk">query = "fruity, rich, easy to drink, sweet"<br/>color = 'red'</span><span id="5bb8" class="kj kk it nd b gy nm ni l nj nk">recommendation = recommend_engine(query, color)<br/>print(query)</span><span id="42b9" class="kj kk it nd b gy nm ni l nj nk">recommendation.head(3).T</span></pre><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ns"><img src="../Images/36845e31590b88c427ffa4da39c69486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0N3PvDdm_kRtkuhxv8gsHw.png"/></div></div></figure><p id="6455" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">探索所有的葡萄酒数据并提出一种基于搜索查询生成推荐的轻量级方法是很有趣的。我计划继续探索通用句子编码器，并思考新的项目来挑战自己和改进我的代码。点击这里查看我的 github 上的其余项目代码:</p><div class="nt nu gp gr nv nw"><a href="https://github.com/bendgame/WineRecommend" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">弯曲游戏/葡萄酒推荐</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div></div></a></div></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="24f9" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated">把所有的放在一起</p><pre class="jy jz ka kb gt nc nd ne nf aw ng bi"><span id="d45e" class="kj kk it nd b gy nh ni l nj nk"><strong class="nd iu">import</strong> <strong class="nd iu">numpy</strong> <strong class="nd iu">as</strong> <strong class="nd iu">np</strong><br/><strong class="nd iu">import</strong> <strong class="nd iu">pandas</strong> <strong class="nd iu">as</strong> <strong class="nd iu">pd<br/>import</strong> <strong class="nd iu">tensorflow</strong> <strong class="nd iu">as</strong> <strong class="nd iu">tf</strong><br/><strong class="nd iu">import</strong> <strong class="nd iu">tensorflow_hub</strong> <strong class="nd iu">as</strong> <strong class="nd iu">tfhub<br/>import</strong> <strong class="nd iu">sqlite3<br/>from</strong> <strong class="nd iu">sqlite3</strong> <strong class="nd iu">import</strong> Error<br/><strong class="nd iu">import io</strong></span><span id="a1c2" class="kj kk it nd b gy nm ni l nj nk">conn = sqlite3.connect('db\wine_data.sqlite', detect_types = sqlite3.PARSE_DECELTYPES)<br/>c = conn.cursor()</span><span id="2bfa" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#read the table in the database.</em><br/>wine_df = pd.read_sql('Select * from wine_data', conn)</span><span id="246d" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#Drop the duplicate descriptions.</em><br/>wine_df = wine_df.drop_duplicates('description')</span><span id="769e" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#drop null prices.</em><br/>wine_df = wine_df.dropna(subset=['price'])</span><span id="c40a" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#filter the dataframe to include only varieties with more than 200 reviews.</em><br/>wine_df = wine_df.groupby('variety').filter(<strong class="nd iu">lambda</strong> x: len(x) &gt; 200)</span><span id="adfe" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#create a column named color.</em><br/>wine_df["color"] = ""</span><span id="26c3" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#used to update the database with the wine color. Manually updated each wine variety.</em><br/>c.execute("update wine_data set color = 'red' where variety = 'Aglianico'  ")</span><span id="03e1" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#commit the update to the database so it saves.</em><br/>conn.commit()</span><span id="9be3" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#remove all the records without a color.</em><br/>wine_df = pd.read_sql("select country, description,rating,price,province,title,variety, winery, color  from wine_data where color in ('red', 'white', 'other')", conn)<br/>wine_df.to_sql('wine_data', conn, if_exists = "replace")</span><span id="eee2" class="kj kk it nd b gy nm ni l nj nk"><strong class="nd iu">import</strong> <strong class="nd iu">os</strong></span><span id="93ed" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#create the directory in which to cache the tensorflow universal sentence encoder.</em><br/>os.environ["TFHUB_CACHE_DIR"] = 'C:/Users/Admin/Downloads'<br/>download = tfhub.Module("https://tfhub.dev/google/universal-sentence-encoder/2")</span><span id="9e97" class="kj kk it nd b gy nm ni l nj nk">def embed_useT():<br/>    with tf.Graph().as_default():<br/>        text_input = tf.compat.v1.placeholder(dtype = tf.string, shape=[None])<br/>        embed = tfhub.Module('C:/Users/Admin/Downloads/1fb57c3ffe1a38479233ee9853ddd7a8ac8a8c47')<br/>        em_txt = embed(text_input)<br/>        session = tf.compat.v1.train.MonitoredSession()<br/>    return lambda x:session.run(em_txt, feed_dict={text_input:list(x)})</span><span id="a0ac" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#run the model.</em><br/>embed_fn = embed_useT()</span><span id="0747" class="kj kk it nd b gy nm ni l nj nk"><em class="nl">#encode the wine descriptions.</em><br/>result = embed_fn(wine_df.description)</span><span id="3504" class="kj kk it nd b gy nm ni l nj nk">def recommend_engine(query, color, embedding_table = result):</span><span id="bb77" class="kj kk it nd b gy nm ni l nj nk">    wine_df = pd.read_sql('Select * from wine_data', db.session.bind)</span><span id="4d43" class="kj kk it nd b gy nm ni l nj nk">    embedding = embed_fn([query])</span><span id="b612" class="kj kk it nd b gy nm ni l nj nk">#Calculate similarity with all reviews<br/>    similarity_score = np.dot(embedding, embedding_table.T)</span><span id="8cac" class="kj kk it nd b gy nm ni l nj nk">recommendations = wine_df.copy()<br/>    recommendations['recommendation'] = similarity_score.T<br/>    recommendations = recommendations.sort_values('recommendation', ascending=False)</span><span id="fb4a" class="kj kk it nd b gy nm ni l nj nk">#filter through the dataframe to find the corresponding wine color records.<br/>    if (color == 'red'):<br/>        recommendations = recommendations.loc[(recommendations.color =='red')] <br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    elif(color == "white"):<br/>        recommendations = recommendations.loc[(recommendations.color =='white')] <br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    elif(color == "other"):<br/>        recommendations = recommendations.loc[(recommendations.color =='other')] <br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    else:<br/>        recommendations = recommendations[['variety', 'title', 'price', 'description', 'recommendation'<br/>                                    , 'rating','color']]<br/>    <br/>    return recommendations.head(3).T</span><span id="cdae" class="kj kk it nd b gy nm ni l nj nk">query = "fruity, rich, easy to drink, sweet"<br/>color = 'red'</span><span id="6da3" class="kj kk it nd b gy nm ni l nj nk">recommendation = recommend_engine(query, color)<br/>print(query)</span><span id="b098" class="kj kk it nd b gy nm ni l nj nk">recommendation.head(3).T</span></pre><h1 id="730d" class="ml kk it bd kl mm nn mo ko mp no mr kr ms np mu kv mv nq mx kz my nr na ld nb bi translated">谢谢大家！</h1><ul class=""><li id="1c79" class="of og it lh b li lj lm ln ks oh kw oi la oj lz ok ol om on bi translated"><em class="nl">如果你喜欢这个，</em> <a class="ae mf" href="https://medium.com/@erickleppen" rel="noopener"> <em class="nl">跟我上 Medium </em> </a> <em class="nl">了解更多</em></li><li id="ca4e" class="of og it lh b li oo lm op ks oq kw or la os lz ok ol om on bi translated"><a class="ae mf" href="https://erickleppen.medium.com/membership" rel="noopener"> <em class="nl">通过订阅</em> </a>获得完全访问权限并帮助支持我的内容</li><li id="4ac1" class="of og it lh b li oo lm op ks oq kw or la os lz ok ol om on bi translated"><em class="nl">我们来连线一下</em><a class="ae mf" href="https://www.linkedin.com/in/erickleppen01/" rel="noopener ugc nofollow" target="_blank"><em class="nl">LinkedIn</em></a></li><li id="cf64" class="of og it lh b li oo lm op ks oq kw or la os lz ok ol om on bi translated"><em class="nl">用 Python 分析数据？查看我的</em> <a class="ae mf" href="https://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nl">网站</em> </a></li></ul><p id="fb74" class="pw-post-body-paragraph lf lg it lh b li ma lk ll lm mb lo lp ks mc lr ls kw md lu lv la me lx ly lz im bi translated"><a class="ae mf" href="http://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh iu"> —埃里克·克莱本</strong> </a></p></div></div>    
</body>
</html>