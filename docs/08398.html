<html>
<head>
<title>Time series prediction using Prophet in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中使用 Prophet 进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-prediction-using-prophet-in-python-35d65f626236?source=collection_archive---------1-----------------------#2019-11-15">https://towardsdatascience.com/time-series-prediction-using-prophet-in-python-35d65f626236?source=collection_archive---------1-----------------------#2019-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0b7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">在本帖中我们将探讨 facebook 的时间序列模型先知。我们将了解什么是先知和它的优势。我们探索 Prophet 使用一个数据集来了解变化点，如何包括假期，最后使用多个回归变量进行时间序列预测。</em>T3】</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/d241577acc2a24d88361309c6741afb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcYOnSk5J0pBC0Ye3fo22A.png"/></div></div></figure><h1 id="67db" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是先知？</h1><p id="cd21" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">Prophet 是 facebooks 的开源时间序列预测。Prophet 将时间序列分解为趋势性、季节性和假日性。它有直观的超级参数，很容易调整。</p><blockquote class="me"><p id="fb1a" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated">先知时间序列=趋势+季节性+假日+误差</p></blockquote><ul class=""><li id="7fc7" class="mo mp it js b jt mq jx mr kb ms kf mt kj mu kn mv mw mx my bi translated">趋势对时间序列值的非周期性变化进行建模。</li><li id="ba5f" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">季节性是周期性变化，如每日、每周或每年的季节性。</li><li id="f5e5" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">在一天或一段时间内不定期发生的假日效应。</li><li id="40cc" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">误差项是模型无法解释的。</li></ul><h1 id="03e4" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Prophet 的优势</h1><ul class=""><li id="c1b2" class="mo mp it js b jt lz jx ma kb ne kf nf kj ng kn mv mw mx my bi translated">适应多个时期的季节性</li><li id="7ee5" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">先知对缺失的价值观有弹性</li><li id="66ae" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">处理 Prophet 中异常值的最佳方法是删除它们</li><li id="76f6" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">模型的拟合是快速的</li><li id="0adb" class="mo mp it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">易于调整的直观超级参数</li></ul><h1 id="f9fe" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装 Prophet</h1><p id="210e" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">使用命令提示符或使用 pip 的 Anaconda 提示符安装 Prophet</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="1758" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">pip install fbprophet</strong></span></pre><p id="28df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以安装 plotly 为 prophet 绘制数据</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="548b" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">pip install plotly</strong></span></pre><h1 id="0aa1" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为 Prophet 创建输入数据</h1><p id="17ee" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated"><strong class="js iu">Prophet 的输入是一个至少有两列的数据帧:ds 和 y。</strong></p><p id="10dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> ds 是日期戳列</strong>，应该符合 pandas <strong class="js iu"> datatime 格式，时间戳为 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS。</strong></p><p id="af39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> y 是我们要预测或预报的数值列。</strong></p><p id="5217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Prophet 遵循 sklearn 模型 API 创建 Prophet 的实例，拟合 Prophet 对象上的数据，然后预测未来值。</p><p id="8519" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">我们现在直接进入代码，看看变化点，如何包括假期，然后添加多个回归变量。</em></p><p id="1c60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae nr" href="https://www.kaggle.com/neuromusic/avocado-prices#avocado.csv" rel="noopener ugc nofollow" target="_blank">文章中使用了鳄梨数据集</a></p><h2 id="e586" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">导入所需的库</h2><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="dbfa" class="nm lc it ni b gy nn no l np nq">from fbprophet import Prophet<br/>from fbprophet.plot import plot_plotly<br/>import numpy as np<br/>import pandas as pd</span><span id="408d" class="nm lc it ni b gy od no l np nq">import matplotlib.pyplot as plt<br/>import plotly.offline as py<br/>py.init_notebook_mode()<br/>%matplotlib inline</span></pre><h2 id="e236" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">从 csv 文件中读取数据</h2><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="2d61" class="nm lc it ni b gy nn no l np nq">dataset= pd.read_csv(“C:\\avocado-prices\\avocado.csv”)</span></pre><h2 id="974e" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">理解数据</h2><p id="f2d0" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">让我们首先来看看列和数据</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="f1d6" class="nm lc it ni b gy nn no l np nq">dataset.head(2)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oe"><img src="../Images/1d8e742411abe0f11db5d2e196efff1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncSZyDmxzrJwYIOJoNtvhQ.png"/></div></div></figure><p id="999c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们打印关于数据集的信息，包括列、列的数据类型以及列是否为空</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="9a59" class="nm lc it ni b gy nn no l np nq">dataset.info()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi of"><img src="../Images/951cb26e0922f7430de35167435a5949.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*fs4S1OJo3Xhpad8G-7c6Yg.png"/></div></figure><p id="c566" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到两个分类变量，类型和地区。让我们检查一下</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="ecf7" class="nm lc it ni b gy nn no l np nq">dataset.describe(include=’O’)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f28a2509b4f94e0f124d436454cce5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*XIqanXigStqtGIXUdKO1bQ.png"/></div></figure><h2 id="5479" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">使用 LabelEncoder 将分类变量转换为数值</h2><p id="026c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们将具有两个不同值的分类变量 type 转换为数值。为了将分类变量转换成数值，我们使用了 LabelEncoder。在这个例子中，我们没有转换分类变量 region。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="b511" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">from sklearn.preprocessing import LabelEncoder</strong></span><span id="6ec8" class="nm lc it ni b gy od no l np nq">le = LabelEncoder()<br/>dataset.iloc[:,10] = le.fit_transform(dataset.iloc[:,10])<br/>dataset.head(2)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/8c290a1ca607a65aea8d6c5f4bc88397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIDAwyLD77JZpY92jhgoRA.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">type is now converted to numeric</figcaption></figure><h2 id="df53" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">创建输入要素(X)和目标变量(y)</h2><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="1079" class="nm lc it ni b gy nn no l np nq">X= dataset[['Date',‘Total Volume’, ‘4046’, ‘4225’, ‘4770’,<br/> ‘Small Bags’, ‘Large Bags’, ‘XLarge Bags’, ‘type’]]<br/>y= dataset.iloc[:,1]</span></pre><p id="9d51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为 Prophet 创建数据集</strong></p><p id="d897" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，Prophet 的输入是一个至少包含两列的数据帧:ds 和 y</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="9d76" class="nm lc it ni b gy nn no l np nq">train_dataset= pd.DataFrame()<br/>train_dataset['ds'] = pd.to_datetime(X["Date"])<br/>train_dataset['y']=y<br/>train_dataset.head(2)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi om"><img src="../Images/1a7a4d66e7592984d9bf10f4f526607f.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*dzJP0VTC-M-4jL1loV0KsA.png"/></div></figure><h2 id="cf1e" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">使用默认值创建和拟合 Prophet 模型</h2><p id="c972" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们将首先探索默认的 Prophet 模型。使用所有默认值创建 Prophet 实例，以适应数据集。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="4bcd" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">prophet_basic = Prophet()<br/>prophet_basic.fit(train_dataset)</strong></span></pre><h2 id="7ea2" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">预测未来的价值</h2><p id="013d" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">为了使用 Prophet 预测值，我们需要创建一个带有 ds(datetime stamp)的 dataframe，其中包含我们要进行预测的日期。</p><p id="5da6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用<strong class="js iu"><em class="ko">make _ future _ data frame()</em></strong>给我们<strong class="js iu"> <em class="ko"> </em> </strong>指定的天数延伸到未来。默认情况下，它包括历史记录中的日期</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="e8dc" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">future= prophet_basic.make_future_dataframe(periods=300)<br/>future.tail(2)</strong></span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6e67d0b0a0ec5c520f8ae038d0fe4dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*S2QLvGn_fj3Nhixx6GzkYQ.png"/></div></figure><p id="06cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原始数据集中的总行数是 18249，我们看到我们为预测创建的未来数据框包含历史日期和另外 300 个日期。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="9759" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">forecast=prophet_basic.predict(future)</strong></span></pre><h2 id="28fa" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">绘制预测数据</h2><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="bdab" class="nm lc it ni b gy nn no l np nq">fig1 =prophet_basic.plot(forecast)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oo"><img src="../Images/69d3d3d3e49e448bbddac270175878c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtZzZNYu3pn6Kg3NzZC6Lg.png"/></div></div></figure><h2 id="3a91" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">绘制预测组件</h2><p id="14ca" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们可以绘制趋势和季节性，预测的组成部分。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="8619" class="nm lc it ni b gy nn no l np nq">fig1 = prophet_basic.plot_components(forecast)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi op"><img src="../Images/8bd0ef29770f527ed5f876185fe4659b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkCniiYNFXguvXmVZxgtYQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">Components of the forecast</figcaption></figure><h2 id="551d" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">给先知增加改变点</h2><p id="7ad9" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">变点是时间序列在轨迹中发生突变的日期时间点。</p><p id="5c23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，Prophet 向数据集的最初 80%添加 25 个变点。</p><p id="e6bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们画出发生潜在变化点的垂直线</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="5eda" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">from fbprophet.plot import add_changepoints_to_plot</strong></span><span id="c074" class="nm lc it ni b gy od no l np nq">fig = prophet_basic.plot(forecast)<br/><strong class="ni iu">a = add_changepoints_to_plot(fig.gca(), prophet_basic, forecast)</strong></span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oq"><img src="../Images/06dc438c0b76647a1fc53ddf07f54640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEqtXJV6SZ5vhwcuPL2mZQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">Vertical lines are where changepoints occurred</figcaption></figure><p id="d6ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以查看变化点发生的日期</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="d32a" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">prophet_basic.changepoints</strong></span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b5109b623b64466d1e182ad85bef0d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*iloZiwNwXjFzHTnBTAca6g.png"/></div></figure><p id="06ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过设置<strong class="js iu"> <em class="ko">变点 _ 范围</em> </strong>来改变推断的变点范围</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="068a" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">pro_change= Prophet(changepoint_range=0.9)</strong></span><span id="4b16" class="nm lc it ni b gy od no l np nq">forecast = pro_change.fit(train_dataset).predict(future)<br/>fig= pro_change.plot(forecast);<br/>a = add_changepoints_to_plot(fig.gca(), pro_change, forecast)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi os"><img src="../Images/60c556b351aea1baaefee9217460e8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaM96d9DfFcONWx7lJy5Ng.png"/></div></div></figure><p id="ba6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在初始化 prophet 时，可以使用<strong class="js iu"><em class="ko">n _ change points</em></strong>参数设置变点数</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="d036" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">pro_change= Prophet(n_changepoints=20, yearly_seasonality=True)</strong></span><span id="32b7" class="nm lc it ni b gy od no l np nq">forecast = pro_change.fit(train_dataset).predict(future)<br/>fig= pro_change.plot(forecast);<br/>a = add_changepoints_to_plot(fig.gca(), pro_change, forecast)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ot"><img src="../Images/231021986b5701401d2c2ad9b142996b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPkPhQdMmEpLM1S3K9U85g.png"/></div></div></figure><h2 id="90a1" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">调整趋势</h2><p id="b7a7" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">Prophet 允许您调整趋势，以防过度拟合或拟合不足。<strong class="js iu"><em class="ko">change point _ prior _ scale</em></strong>帮助调整趋势的强弱。</p><p id="f153" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"><em class="ko">change point _ prior _ scale 的默认值为</em> </strong> 0.05。减小该值会降低趋势的灵活性。增加<strong class="js iu"><em class="ko">change point _ prior _ scale</em></strong>的值，使趋势<em class="ko">更加</em>灵活。</p><p id="cb26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<strong class="js iu"><em class="ko">change point _ prior _ scale</em></strong>增加到 0.08，使趋势更加灵活</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="0a3c" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">pro_change= Prophet(n_changepoints=20, yearly_seasonality=True, changepoint_prior_scale=0.08)</strong><br/>forecast = pro_change.fit(train_dataset).predict(future)<br/>fig= pro_change.plot(forecast);<br/>a = add_changepoints_to_plot(fig.gca(), pro_change, forecast)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ou"><img src="../Images/fa0b0abc4f972bdff871b6c9ae903828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7usCMlZaqhLaIGfqQViN-g.png"/></div></div></figure><p id="ab8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<strong class="js iu"><em class="ko">change point _ prior _ scale</em></strong>减小至 0.001，以降低趋势的灵活性</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="8c1c" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">pro_change= Prophet(n_changepoints=20, yearly_seasonality=True, changepoint_prior_scale=0.001</strong>)<br/>forecast = pro_change.fit(train_dataset).predict(future)<br/>fig= pro_change.plot(forecast);<br/>a = add_changepoints_to_plot(fig.gca(), pro_change, forecast)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ov"><img src="../Images/26bc2762697b106fb68ee3a6419ab878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1acZzod5TN_6vbruiaJaw.png"/></div></div></figure><h2 id="ad8d" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">添加假日</h2><p id="6477" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">节假日和事件会导致时间序列发生变化。在我们的例子中，7 月 31 日的全国鳄梨日和 9 月 16 日的鳄梨日会影响鳄梨的价格。</p><p id="8fd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过创建一个包含两列 ds 和 holiday 的 dataframe 来为 Prophet 创建一个定制的假日列表。假日的每一个事件占一行</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="6680" class="nm lc it ni b gy nn no l np nq"><strong class="ni iu">avocado_season = pd.DataFrame({<br/>  'holiday': 'avocado season',<br/>  'ds': pd.to_datetime(['2014-07-31', '2014-09-16', <br/>                        '2015-07-31', '2015-09-16',<br/>                        '2016-07-31', '2016-09-16',<br/>                        '2017-07-31', '2017-09-16',<br/>                       '2018-07-31', '2018-09-16',<br/>                        '2019-07-31', '2019-09-16']),<br/>  'lower_window': -1,<br/>  'upper_window': 0,<br/>})</strong></span></pre><p id="f91e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下部窗口和上部窗口将假期延长至日期前后的天。如果我们想包含国家鳄梨日和鳄梨酱日之前的一天，我们设置<strong class="js iu"><em class="ko">lower _ window:-1 upper _ window:0</em></strong></p><p id="2f96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想使用假期后的一天，那么设置<strong class="js iu"><em class="ko">lower _ window:0 upper _ window:1</em></strong></p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="78bd" class="nm lc it ni b gy nn no l np nq">pro_holiday= Prophet(<strong class="ni iu">holidays=avocado_season</strong>)<br/>pro_holiday.fit(train_dataset)<br/>future_data = pro_holiday.make_future_dataframe(periods=12, freq = 'm')<br/> <br/>#forecast the data for future data</span><span id="c4b9" class="nm lc it ni b gy od no l np nq">forecast_data = pro_holiday.predict(future_data)<br/>pro_holiday.plot(forecast_data);</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ow"><img src="../Images/f389f884d0a8b63a2f4ab5db67988800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSZkSiPeBnXsXfdfhqJfSg.png"/></div></div></figure><h2 id="397c" class="nm lc it bd ld ns nt dn lh nu nv dp ll kb nw nx lp kf ny nz lt kj oa ob lx oc bi translated">添加多个回归变量</h2><p id="e121" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">可以向 Prophet 模型中添加额外的回归变量。这是通过使用<strong class="js iu"> <em class="ko"> add_regressor 来完成的。拟合和预测数据框架中都需要有额外的回归变量</em> </strong>列值。</p><p id="39b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用附加回归量创建拟合和预测数据集</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="cc20" class="nm lc it ni b gy nn no l np nq">train_dataset[‘type’] = X[‘type’]<br/>train_dataset[‘Total Volume’] = X[‘Total Volume’]<br/>train_dataset[‘4046’] = X[‘4046’]<br/>train_dataset[‘4225’] = X[‘4225’]<br/>train_dataset[‘4770’] = X[‘4770’]<br/>train_dataset[‘Small Bags’] = X[‘Small Bags’]</span><span id="fe43" class="nm lc it ni b gy od no l np nq">train_X= train_dataset[:18000]<br/>test_X= train_dataset[18000:]</span></pre><p id="9516" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们对数据集进行了分割，以展示额外回归变量的使用，因为我们需要拟合和预测数据框中所有额外回归变量的值</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="b995" class="nm lc it ni b gy nn no l np nq">#Additional Regressor<br/><strong class="ni iu">pro_regressor= Prophet()<br/>pro_regressor.add_regressor('type')<br/>pro_regressor.add_regressor('Total Volume')<br/>pro_regressor.add_regressor('4046')<br/>pro_regressor.add_regressor('4225')<br/>pro_regressor.add_regressor('4770')<br/>pro_regressor.add_regressor('Small Bags')</strong></span><span id="6637" class="nm lc it ni b gy od no l np nq">#Fitting the data<br/><strong class="ni iu">pro_regressor.fit(train_X)<br/>future_data = pro_regressor.make_future_dataframe(periods=249)</strong></span><span id="8efd" class="nm lc it ni b gy od no l np nq">#forecast the data for Test  data<br/><strong class="ni iu">forecast_data = pro_regressor.predict(test_X)</strong><br/>pro_regressor.plot(forecast_data);</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ox"><img src="../Images/003662f72a0e9eefb001b638966d5de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chnd16CNdmQ4USJejy6GVw.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">Prediction using additional regressor</figcaption></figure><p id="f6f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">预测数据是最后的蓝色阴影区域。</p><p id="5b79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Jupyter 笔记本可用<a class="ae nr" href="https://github.com/arshren/TimeSeries/blob/master/Prophet_Avacado.ipynb" rel="noopener ugc nofollow" target="_blank">此处</a></p><h1 id="c71c" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考资料:</h1><p id="558d" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated"><a class="ae nr" href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/prophet/docs/quick_start.html</a></p><p id="36a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae nr" href="https://peerj.com/preprints/3190.pdf" rel="noopener ugc nofollow" target="_blank">https://peerj.com/preprints/3190.pdf</a></p></div></div>    
</body>
</html>