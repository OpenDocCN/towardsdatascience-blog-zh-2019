<html>
<head>
<title>Practical NumPy — Understanding Python library through its functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用数字——通过函数理解 Python 库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-numpy-understanding-python-library-through-its-functions-adf2e3841894?source=collection_archive---------8-----------------------#2019-01-10">https://towardsdatascience.com/practical-numpy-understanding-python-library-through-its-functions-adf2e3841894?source=collection_archive---------8-----------------------#2019-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/04cf8cf97dcf7b5218089b1966e8358d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5tfpctX86Dz1rrVq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mika Baumeister</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">在开始数据科学和机器学习的旅程之前，了解一些在数据科学领域无处不在的 python 库是非常重要的，比如 Numpy、Pandas 和 Matplotlib。Numpy 就是这样一个用于数组处理的强大的库，以及一个大型的高级数学函数集合来操作这些数组。这些函数分为线性代数、三角学、统计学、矩阵操作等类别。今天我们将看到几个如此重要的函数的例子。</p><h1 id="c250" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">得到 NumPy</h1><p id="5ce8" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">要在本地机器上安装 NumPy，我建议从<a class="ae kc" href="https://www.anaconda.com/download/" rel="noopener ugc nofollow" target="_blank">这里</a>下载 anaconda 包发行版，它安装 python 和其他重要的 python 库，包括 NumPy、Pandas 和 Matplotlib，对机器学习很有用。Anaconda 支持 Windows、Mac 和 Linux。要快速开始使用 NumPy 而不在本地机器上安装任何东西，请查看<a class="ae kc" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>。它免费提供与你的 Google Drive 账户相关联的云端 Jupyter 笔记本，并且预装了所有重要的软件包。您也可以在 GPU 上运行您的代码，这有助于加快计算速度，尽管我们在本教程中不需要 GPU 计算。要快速开始使用 Google Colab，请查看同一网站上这篇令人惊叹的文章<a class="ae kc" href="https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d" rel="noopener">。</a></span></p><h1 id="3314" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">熟悉基础知识</h1><p id="dc71" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> N </span> umPy 的主要对象是一个同质多维数组。与 python 的 array 类只处理一维数组不同，NumPy 的<code class="fe mn mo mp mq b">ndarray </code>类可以处理多维数组，并提供更多功能。NumPy 的维度被称为轴。例如，下面的数组有 2 个维度或 2 个轴，即行和列。有时，维数也称为特定数组或矩阵的秩。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="596a" class="mz ll iq mq b gy na nb l nc nd">[[1, 4, 7],<br/> [2, 5, 8],<br/> [3, 6, 9]]</span></pre><h2 id="1cbe" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">导入数字</h2><p id="a07d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">使用以下命令导入 umPy。注意这里的<code class="fe mn mo mp mq b">np </code>是别名遵循的约定，这样我们就不需要每次都写<code class="fe mn mo mp mq b">numpy</code>。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="5c15" class="mz ll iq mq b gy na nb l nc nd">import numpy as np</span></pre><h2 id="ede9" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">创建数组</h2><p id="3d6d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">用 NumPy 创建数组有很多方法，但最常用的方法是使用<code class="fe mn mo mp mq b">array </code>函数。一旦创建了一个数组，我们也可以使用<code class="fe mn mo mp mq b">ndim </code>方法检查它的尺寸。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="88cb" class="mz ll iq mq b gy na nb l nc nd">#creating a one-dimensional array<br/>a = np.array([1 ,2 ,3])<br/>print (a)</span><span id="2efe" class="mz ll iq mq b gy np nb l nc nd">#ouptput<br/>[1 2 3]</span><span id="9f56" class="mz ll iq mq b gy np nb l nc nd">a.ndim</span><span id="3b97" class="mz ll iq mq b gy np nb l nc nd">#output<br/>1</span><span id="eccf" class="mz ll iq mq b gy np nb l nc nd">#creating a two-dimensional array<br/>b = np.array([<br/>             [1, 5 , 7], [2, 4, 6]<br/>             ])<br/>print (b)</span><span id="f74c" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[1 5 7]<br/> [2 4 6]]</span><span id="06d6" class="mz ll iq mq b gy np nb l nc nd">b.ndim</span><span id="01bd" class="mz ll iq mq b gy np nb l nc nd">#output<br/>2</span><span id="028b" class="mz ll iq mq b gy np nb l nc nd">#creating a three-dimensional array<br/>c = np.array([<br/>             [[1,2,3], [3,4,5]], <br/>             [[5,6,7], [7,8,9]]<br/>             ])<br/>print (c)</span><span id="9db8" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[[1,2,3]<br/> [3,4,5]]</span><span id="a863" class="mz ll iq mq b gy np nb l nc nd"> [[[5,6,7]<br/>   [7,8,9]]]</span><span id="ac5f" class="mz ll iq mq b gy np nb l nc nd">c.ndim</span><span id="20d2" class="mz ll iq mq b gy np nb l nc nd">#output<br/>3</span></pre><p id="8d1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以在创建数组时使用参数<code class="fe mn mo mp mq b">dtype </code>指定数组的数据类型，并使用它来检查数组的数据类型。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="57f8" class="mz ll iq mq b gy na nb l nc nd">d = np.array([1 , 4 , 7], dtype=float)<br/>print (d)</span><span id="9054" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[1. 4. 7.]</span><span id="ecbf" class="mz ll iq mq b gy np nb l nc nd">a.dtype</span><span id="bed0" class="mz ll iq mq b gy np nb l nc nd">#output<br/>dtype('int64')</span></pre><h2 id="52fe" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">创建数组的一些特殊方法</h2><p id="b4aa" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">umPy 提供了多种创建数组的方法。有像<code class="fe mn mo mp mq b">zeros</code>和<code class="fe mn mo mp mq b">ones</code>这样的特殊函数，它们分别创建只包含 0 和 1 的元素数组。您还可以将数组的长度(在一维情况下)或形状(在多维情况下)指定为参数。可以使用<code class="fe mn mo mp mq b">arange</code>方法创建在给定间隔内具有均匀间隔值的数组。默认情况下，值之间的间距假定为 1 个单位，但是我们可以在参数中指定值之间的间距以及间隔的起始值和结束值。注意<code class="fe mn mo mp mq b">arange</code>方法并不打印作为参数指定的间隔的最后一个值。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="d010" class="mz ll iq mq b gy na nb l nc nd">zeros_array = np.zeros(3, dtype=int)<br/>print (zeros_array)</span><span id="7a62" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[0 0 0]</span><span id="e3e2" class="mz ll iq mq b gy np nb l nc nd">zeros_array_nd = np.zeros((3,2), dtype=int)<br/>print (zeros_array_nd)</span><span id="efb8" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[0 0]<br/> [0 0]<br/> [0 0]]</span><span id="6673" class="mz ll iq mq b gy np nb l nc nd">ones_array = np.ones(4, dtype=int)<br/>print (ones_array)</span><span id="5463" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[1 1 1 1]</span><span id="cb4f" class="mz ll iq mq b gy np nb l nc nd">ones_array_nd = np.ones((2,3), dtype=int)<br/>print (ones_array_nd)</span><span id="e4ef" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[1 1 1]<br/> [1 1 1]]</span><span id="7a63" class="mz ll iq mq b gy np nb l nc nd">range_array = np.arange(2,5)<br/>print (range_array)</span><span id="fd32" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[2 3 4]</span><span id="3b5a" class="mz ll iq mq b gy np nb l nc nd">range_array_space = np.arange(1,7,2)<br/>print (range_array_space)</span><span id="1a91" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[1 3 5]</span></pre><h2 id="4708" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">数组的形状</h2><p id="6ec5" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">数组的 shape 属性返回一个描述其维度的元组。参考上面的例子，我们创建了数组<strong class="kf ir"> b </strong>，这是一个二维数组，因此我们得到它的形状为(2，3 ),这意味着它有 2 行 3 列。这里注意数组<strong class="kf ir"> c </strong>的 shape 属性返回(2，2，3)，这是因为数组<strong class="kf ir"> c </strong>是一个三维数组，它表示有两个各有 2 行 3 列的数组。NumPy 还提供了<code class="fe mn mo mp mq b">reshape</code>方法来调整数组的大小。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="3893" class="mz ll iq mq b gy na nb l nc nd">b.shape</span><span id="e34a" class="mz ll iq mq b gy np nb l nc nd">#output<br/>(2, 3)</span><span id="8fed" class="mz ll iq mq b gy np nb l nc nd">B = b.reshape(3,2)<br/>print (B)</span><span id="7ec4" class="mz ll iq mq b gy np nb l nc nd">#output <br/>[[1 5]<br/> [7 2]<br/> [4 6]]</span><span id="76a7" class="mz ll iq mq b gy np nb l nc nd">c.shape</span><span id="f295" class="mz ll iq mq b gy np nb l nc nd">#output<br/>(2, 2, 3)</span><span id="108f" class="mz ll iq mq b gy np nb l nc nd">C = c.resize(2,3,2)<br/>print (C)</span><span id="c288" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[[1 2]<br/>  [3 3]<br/>  [4 5]]</span><span id="5107" class="mz ll iq mq b gy np nb l nc nd"> [[5 6]<br/>  [7 8]<br/>  [8 9]]]</span></pre><h2 id="41ee" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">数组的索引</h2><p id="48ab" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">可以使用标准 python 语法<code class="fe mn mo mp mq b">x[obj]</code>索引 umPy 数组，其中 x 是数组，obj 是选择。在 NumPy 数组中，就像 python 一样，所有的索引都是从零开始的。NumPy 中的切片与 Python 中的类似。当<code class="fe mn mo mp mq b">obj</code>是由方括号内的<code class="fe mn mo mp mq b">start:stop:step</code>符号构造的切片对象时，就会发生基本切片。切片期间，并不总是需要所有三个<code class="fe mn mo mp mq b">start</code>、<code class="fe mn mo mp mq b">stop</code>和<code class="fe mn mo mp mq b">step</code>都出现在方括号内。如果切片时出现负整数 j，则索引将被视为 n+j，其中 n 是数组中元素的数量。在多维数组的情况下，切片是以在方括号内传递元组的形式完成的，具有相同的符号约定。在高级索引中，以列表形式传递的第一个参数只是我们想要选择的特定行，第二个参数的列表指示我们想要从该行中选择的特定元素。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ddda" class="mz ll iq mq b gy na nb l nc nd">#Basic Slicing<br/>x = np.array([9,8,7,6,5,4,3,2,1,0])<br/>print(x[2:5])                      #output: [7 6 5]<br/>print(x[5:])                       #output: [4 3 2 1 0]<br/>print(x[:4])                       #output: [9 8 7 6]<br/>print(x[1:7:3])                    #output: [8 5]<br/>print(x[-5:10])                    #output: [4 3 2 1 0]</span><span id="427c" class="mz ll iq mq b gy np nb l nc nd">#Boolean Indexing<br/>print(x[x&gt;4])                      #output: [9 8 7 6 5]</span><span id="f390" class="mz ll iq mq b gy np nb l nc nd">#Indexing in multidimensional array<br/>y = np.array([<br/>             [1, 3],<br/>             [4, 6],<br/>             [7, 9]])</span><span id="71af" class="mz ll iq mq b gy np nb l nc nd">#Advanced Indexing <br/>print(y[:2,1:2])                   #output: [[3]<br/>                                             [6]]</span><span id="2711" class="mz ll iq mq b gy np nb l nc nd">print(y[[0,1,2], [1,0,1]])         #output: [3, 4, 9]</span></pre><h1 id="8146" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">向量、矩阵及其基本运算</h1><p id="181f" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">在</span>线性代数和机器学习领域，一维数组称为向量，二维数组称为矩阵。一个更高级的或 n 维的数组称为 n 维张量。作为各种机器学习和深度学习模型的输入的数据仅仅是矩阵和张量的形式，因此学习矩阵运算变得非常重要。</p><h2 id="5a15" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">矩阵的转置</h2><p id="b138" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> E </span>在本文的前面，我们看到了二维数组的形状和整形的概念，其中<code class="fe mn mo mp mq b">shape</code>方法返回一个描述矩阵的行数和列数的元组。矩阵的转置是一个新的矩阵，它的行是原矩阵的列。这使得新矩阵的列成为原始矩阵的行。这是一个矩阵及其转置。让我们继续以矩阵“b”为例。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="b564" class="mz ll iq mq b gy na nb l nc nd">print (b)</span><span id="f872" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[1 5 7]<br/> [2 4 6]]</span><span id="efe1" class="mz ll iq mq b gy np nb l nc nd">b.shape</span><span id="45bf" class="mz ll iq mq b gy np nb l nc nd">#output<br/>(2, 3)</span><span id="cc89" class="mz ll iq mq b gy np nb l nc nd">b_transpose = b.T<br/>print (b_transpose)</span><span id="3570" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[1 2]<br/> [5 4]<br/> [7 6]]</span><span id="fbbd" class="mz ll iq mq b gy np nb l nc nd">b_transpose.shape</span><span id="1d47" class="mz ll iq mq b gy np nb l nc nd">#output<br/>(3, 2)</span></pre><h2 id="c4a6" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">算术运算</h2><p id="5cb6" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> M 个</span>如果形状相同，可以相加或相减。一个矩阵中的一个元素对应于另一个矩阵中相同位置的元素被加或减。</p><p id="8ea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">A</strong><em class="nq">ij+</em><strong class="kf ir">B</strong><em class="nq">ij =</em><strong class="kf ir">C</strong><em class="nq">ij</em></p><p id="b1be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以将标量值添加到矩阵中，这意味着将该值添加到矩阵的每个元素中。使用<code class="fe mn mo mp mq b">*</code>运算符或<code class="fe mn mo mp mq b">multiply</code>方法执行元素乘法。元素乘法不同于矩阵乘法，矩阵乘法我们将在线性代数一节中看到。类似地，我们可以按元素划分两个矩阵，并找到矩阵中每个元素的平方根和指数值，如下例所示。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="f92f" class="mz ll iq mq b gy na nb l nc nd">A = np.array([[5, 6], <br/>              [7, 8]])</span><span id="e12f" class="mz ll iq mq b gy np nb l nc nd">B = np.array([[4, 3],<br/>              [2, 1]])</span><span id="8d5f" class="mz ll iq mq b gy np nb l nc nd">add = A + B                #np.add(A,B) can also be used<br/>print (add)</span><span id="a99b" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[9 9]<br/> [9 9]]</span><span id="dd61" class="mz ll iq mq b gy np nb l nc nd">sub = A - B                #np.subtract(A,B)can also be used<br/>print (sub)</span><span id="b7e5" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[1 3]<br/> [5 7]]</span><span id="5db0" class="mz ll iq mq b gy np nb l nc nd">add_scalar = A + 5<br/>print (add_scalar)</span><span id="154b" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[10 11]<br/> [12 13]]</span><span id="02fc" class="mz ll iq mq b gy np nb l nc nd">multiply = A * B            #np.multiply(A,B) can also be used<br/>print (multiply)</span><span id="e5d8" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[20 18]<br/>  [14 8]]</span><span id="93bd" class="mz ll iq mq b gy np nb l nc nd">divide = A / B              #np.divide(A,B) can also be used<br/>print (divide)</span><span id="170d" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[1.25 2]<br/> [3.5  8]]</span><span id="7d03" class="mz ll iq mq b gy np nb l nc nd">square_root = np.sqrt(A)<br/>print (square_root)</span><span id="9112" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[2.23606798 2.44948974]<br/> [2.64575131 2.82842712]]</span><span id="48e3" class="mz ll iq mq b gy np nb l nc nd">exponential = np.exp(A)<br/>print (exponential)</span><span id="2da9" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[ 148.4131591   403.42879349]<br/> [1096.63315843 2980.95798704]]</span></pre><h2 id="d450" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">广播</h2><p id="13a3" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> B </span> roadcasting 是机器学习中的一个重要概念。广播基本上意味着将两个不同形状的矩阵相加。当两个不同形状的矩阵相加时，较小的矩阵通过自身延伸呈现较大矩阵的形状。在上面的例子中，我们向矩阵<strong class="kf ir"> A </strong>添加了一个标量，我们实际上使用了广播，其中标量采用了矩阵<strong class="kf ir"> A </strong>的形状。让我们看看下面的例子。这里，矩阵<strong class="kf ir"> X </strong>具有(3，3)的形状，矩阵<strong class="kf ir"> Y </strong>具有(3，1)的形状，但是两个矩阵相加的结果是新的(3，3)矩阵，因为矩阵 Y 将其自身扩展为(3，3)矩阵。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="05bc" class="mz ll iq mq b gy na nb l nc nd">X = np.array([<br/>             [1,2,3], <br/>             [4,5,6], <br/>             [7,8,9]<br/>                   ])</span><span id="c2ed" class="mz ll iq mq b gy np nb l nc nd">Y = np.array([[2],[4],[6]])</span><span id="3b7b" class="mz ll iq mq b gy np nb l nc nd">matrix_broad = X + Y<br/>print (matrix_broad)</span><span id="5269" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[3 4 5]<br/> [8 9 10]<br/> [13 14 15]]</span></pre><h1 id="fbdd" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">线性代数函数</h1><p id="a08f" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> T </span>点积(也称为内积)是行和列之间乘积的总和，如下图所示。NumPy 提供了<code class="fe mn mo mp mq b">dot</code>方法来计算两个矩阵的点积。为了计算两个矩阵的点积，第一个矩阵的列数应该等于第二个矩阵的行数。如果不遵守此规则，NumPy 将抛出一个错误，指出形状没有对齐。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/6c2ddebe10fb8761670fce59107db169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOq5f3PaIgs_n1Ukjm_2cg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Matrix multiplication or Dot product</figcaption></figure><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="7884" class="mz ll iq mq b gy na nb l nc nd">matrix_1 = np.array([<br/>                    [2, 3],<br/>                    [1, 4],<br/>                    [4, 5]])</span><span id="f539" class="mz ll iq mq b gy np nb l nc nd">matrix_2 = np.array([<br/>                    [2, 3, 5],<br/>                    [1, 6, 7]])</span><span id="880e" class="mz ll iq mq b gy np nb l nc nd">dot_product = np.dot(matrix_1, matrix_2)<br/>print (dot_product)</span><span id="9113" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[7 24 31]<br/> [6 27 33]<br/> [13 42 55]]</span></pre><p id="65b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，<strong class="kf ir"> matrix_1 </strong>的形状为(3，2)，而<strong class="kf ir"> matrix_2 </strong>的形状为(2，3)，即<strong class="kf ir"> matrix_1 </strong>的列数等于<strong class="kf ir"> matrix_2 </strong>的行数，得到的矩阵的形状为(3，3)。</p><h2 id="3af1" class="mz ll iq bd lm ne nf dn lq ng nh dp lu ko ni nj ly ks nk nl mc kw nm nn mg no bi translated">矩阵的行列式、逆矩阵和范数</h2><p id="5887" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">线性代数的函数可以在模块<code class="fe mn mo mp mq b">linalg</code>中找到。下面列出了一些功能。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6493" class="mz ll iq mq b gy na nb l nc nd">#Determinant for 2 dimensional matrix<br/>matrix_A = np.array([<br/>                    [1, 2],<br/>                    [3, 4]<br/>                          ])<br/>det_A = np.linalg.det(matrix_A)<br/>print (det_A)</span><span id="e54a" class="mz ll iq mq b gy np nb l nc nd">#output <br/>-2.0</span><span id="e4fd" class="mz ll iq mq b gy np nb l nc nd">#Determinant for 3 dimensional tensor (stack of matrices)<br/>matrix_A_3d = np.arange(1,13).reshape(3,2,2)<br/>det_A_3d = np.linalg.det(matrix_A_3d)<br/>print (det_A_3d)</span><span id="cb68" class="mz ll iq mq b gy np nb l nc nd">#output <br/>[-2. -2. -2.]</span><span id="277f" class="mz ll iq mq b gy np nb l nc nd">#Inverse of 2-D Matrix and 3-D Tensor<br/>inv_A = np.linalg.inv(matrix_A)<br/>inv_A_3d = np.linalg.inv(matrix_A_3d)</span><span id="4680" class="mz ll iq mq b gy np nb l nc nd">print (inv_A)<br/>print (inv_A_3d)</span><span id="d45d" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[-2.   1.]  <br/> [1.5 -0.5]]</span><span id="67cd" class="mz ll iq mq b gy np nb l nc nd">[[[-2.   1. ]   [ 1.5 -0.5]]   <br/> [[-4.   3. ]   [ 3.5 -2.5]]   <br/> [[-6.   5. ]   [ 5.5 -4.5]]]</span><span id="ee94" class="mz ll iq mq b gy np nb l nc nd">Norm of 2-D Matrix and 3-D Tensor<br/>norm_A = np.linalg.norm(matrix_A)<br/>norm_A_3d = np.linalg.norm(matrix_A_3d)</span><span id="b115" class="mz ll iq mq b gy np nb l nc nd">print (norm_A)<br/>print (Norm_A_3d)</span><span id="1255" class="mz ll iq mq b gy np nb l nc nd">#output<br/>5.47722557505<br/>25.49509756796</span></pre><h1 id="f429" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">统计功能</h1><p id="8bef" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> N </span> umPy 有一套丰富的函数来执行统计操作。NumPy 的<code class="fe mn mo mp mq b">random</code>模块的<code class="fe mn mo mp mq b">rand</code>和<code class="fe mn mo mp mq b">randn</code>方法用于分别生成所需维数的随机值和正态分布值的矩阵和张量。当我们想要为深度学习模型的第一次正向传播生成随机权重时，这些函数就很方便了。我们还可以计算输入数据的平均值、中值和标准差，如下所示。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6ed4" class="mz ll iq mq b gy na nb l nc nd">#Create array of desired shape with random values<br/>random_array = np.random.rand(3,2)<br/>print (random_array)</span><span id="376a" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[0.42598214 0.49227853]  <br/> [0.06742446 0.46793263]  <br/> [0.23422854 0.80702256]]</span><span id="e711" class="mz ll iq mq b gy np nb l nc nd">#Create array with values from a normal distribution<br/>random_normal_array = np.random.randn(3,2)<br/>print (random_normal_array)</span><span id="04d6" class="mz ll iq mq b gy np nb l nc nd">#output<br/>[[ 1.99670851  0.40954136]  <br/> [ 0.5125924  -0.04957141]  <br/> [ 0.33359663  0.26610965]]</span><span id="c10c" class="mz ll iq mq b gy np nb l nc nd">P = np.array([<br/>             [10, 12, 14],<br/>             [8, 10, 12],<br/>             [3, 5, 7]])</span><span id="2068" class="mz ll iq mq b gy np nb l nc nd">#Calculate mean of the whole array, columns and rows respectively<br/>P_mean = np.mean(P)                   #output: 9.0<br/>P_mean_column = np.mean(P, axis=0)    #output: [7. 9. 11.]<br/>P_mean_row = np.mean(P, axis=1)       #output: [12. 10. 5.] </span><span id="da98" class="mz ll iq mq b gy np nb l nc nd">#Calculate median of the whole array, columns and rows respectively<br/>print(np.median(P))                   #output: 10.0<br/>print(np.median(P, axis=0))           #output: [8. 10. 12.]<br/>print(np.median(P, axis=1))           #output: [12. 10. 5.]</span><span id="a533" class="mz ll iq mq b gy np nb l nc nd">#Calculate standard deviation of the whole array, columns and rows #respectively<br/>print(np.std(P))<br/>print(np.std(P, axis=0))<br/>print(np.std(P, axis=1))</span><span id="25c5" class="mz ll iq mq b gy np nb l nc nd">#output<br/>3.366501646120693 <br/>[2.94392029 2.94392029 2.94392029] <br/>[1.63299316 1.63299316 1.63299316]</span></pre><h1 id="c96d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="8b22" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi lb translated">umPy 是 Python 中科学计算的基本库，本文展示了一些最常用的函数。理解 NumPy 是机器学习和深度学习之旅的第一个重大步骤。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="f3d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章对你有用。请发表你的看法，评论和赞赏。</p></div></div>    
</body>
</html>