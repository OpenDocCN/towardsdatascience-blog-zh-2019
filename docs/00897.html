<html>
<head>
<title>6 Steps to Understanding a Heap with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 理解堆的 6 个步骤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-structure-heap-23d4c78a6962?source=collection_archive---------7-----------------------#2019-02-11">https://towardsdatascience.com/data-structure-heap-23d4c78a6962?source=collection_archive---------7-----------------------#2019-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2036" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">搜索算法的重要数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/059d7d54df39a849d175879c66a1646e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElL4jIZ18Ry8lx-CjpzTZg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/photos/2FaCKyEEtis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Rick Mason</a> on <a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我将解释堆，它是基本的数据结构之一。还有，著名的搜索算法像 Dijkstra 的算法或者 A*都使用堆。A*可以出现在常用于时间序列模式识别的<em class="lv">隐马尔可夫模型</em> (HMM)中。请注意，这篇文章不是关于搜索算法的。我将解释堆是如何工作的，以及它的时间复杂度和 Python 实现。麻省理工开放式课程的讲座真的帮助我理解了一堆。所以我遵循了那堂课的解释方式，但我做了一点总结，并添加了一些 Python 实现。这篇文章的结构如下，基于<a class="ae ky" href="https://www.youtube.com/watch?v=B7hVxCmfPtM" rel="noopener ugc nofollow" target="_blank">麻省理工学院的讲座</a>。我们开始吧！</p><ol class=""><li id="2d00" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">堆概述</li><li id="2f44" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">表现</li><li id="51e0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如何建立一个堆</li><li id="9446" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">时间复杂度</li><li id="b8c0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">履行</li><li id="c79f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">堆排序</li></ol><h1 id="6d32" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1.堆概述</h1><p id="c956" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">堆是优先级队列的<a class="ae ky" href="https://en.wikipedia.org/wiki/Priority_queue" rel="noopener ugc nofollow" target="_blank">的一种常见实现。优先级队列包含具有一定优先级的项目。您总是可以按照优先级顺序从优先级队列中取出一个项目。根据优先级取出项目是很重要的。当你环顾学术会议上的海报展示时，很有可能你是为了挑选一些展示而设置的。或者你会在去观光之前列出一个优先列表(在这种情况下，一个项目将是一个旅游景点。).堆栈和队列也包含项目。如果某个项目是最后一个添加到堆栈中的项目，则可以从堆栈中取出该项目。这是先进后出(费罗)。对于队列，如果一个项目是第一个添加到队列中的项目，您可以从队列中取出该项目。这是先进先出(FIFO)。您可以将这些视为特定类型的优先级队列。这是因为堆栈中插入项的优先级增加，队列中插入项的优先级降低。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/15e9656beac7a0bd7f9fb7ae014bce91.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*oN767xTYckRTUjTIyS3oyw.png"/></div></figure><h1 id="b367" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2.表现</h1><p id="c31b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">堆是树结构的一种，用二叉树来表示。我把图像堆在下面。您可以通过指针或数组来实现树结构。在这篇文章中，我选择使用如下的数组实现。就空间复杂性而言，数组实现比指针实现有更多的好处。数组的索引对应于下图中的节点号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5f7aee7062ce9b7deacde34b5d6ae357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*ds0JXOw3lLqNo6hw__NtZw.png"/></div></div></figure><p id="9121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的堆叫做<em class="lv">一个最小堆</em>，每个<strong class="lb iu">节点的值小于或等于子节点<em class="lv">的值。</em> </strong>我们称这种情况为堆属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/1a5dbe351f78b83343843ff13f676455.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*MaIob54cy5Z7iL1TAEDt1A.png"/></div></div></figure><p id="11b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最小堆中，当您查看父节点及其子节点时，父节点总是具有最小值。当一个堆有相反的定义时，我们称它为<em class="lv">最大堆</em>。在下面的讨论中，我们称最小堆为堆。</p><p id="5f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下索引访问数组中的父节点或子节点。</p><ul class=""><li id="1c34" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nk mc md me bi translated">根节点| <em class="lv"> i </em> = 1，数组的第一项</li><li id="e9e8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated">一个父节点|parent( <em class="lv"> i </em> ) = <em class="lv"> i </em> / 2</li><li id="d4b4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated">一个左子节点|left( <em class="lv"> i </em> ) = 2 <em class="lv"> i </em></li><li id="e840" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated">一个右子节点| right(<em class="lv">I</em>)= 2<em class="lv">I</em>+1</li></ul><p id="57da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您查看索引 4 的节点时，树中节点的关系对应于下面数组的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3eb4ff55e7378b9ed80cac761b40e55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*ysSV1xV0OMm-1amWBpFb0A.png"/></div></figure><p id="d791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父节点按父(<em class="lv"> i </em> ) = 4 / 2 = 2 对应索引 2 的项。子节点分别对应索引 8 和 9 的项目，左(<em class="lv"> i </em> ) = 2 * 2 = 4，右(<em class="lv"> i </em> ) = 2 * 2 + 1 = 5。</p><h1 id="5173" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">3.如何建立一个堆</h1><p id="b10f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">从任意数组构建一个堆需要两个操作。</p><ol class=""><li id="42b1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe nm nn no np b">min_heapify</code>|使某个节点及其后代节点满足堆属性。</li><li id="1582" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">从任意数组中产生一个堆。</li></ol><p id="2c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过对每个节点重复应用<em class="lv"> min_heapify </em>来构建一个堆。</p><h2 id="ebe4" class="nq ml it bd mm nr ns dn mq nt nu dp mu li nv nw mw lm nx ny my lq nz oa na ob bi translated">3.1 分钟 _ 健康</h2><p id="9e19" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在<em class="lv"> min_heapify </em>中，我们用它的子节点交换一些节点来满足下面这两个特性下的堆属性；</p><ol class=""><li id="156a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">某些节点及其子节点不满足堆属性，</li><li id="1741" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">子节点及其后代节点满足属性。</li></ol><p id="2bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树形结构具有以下两个特征。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d6c71b0e74fb22c1006d2072210f19d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*7GdM58KmWHBgEE-yOSRy4Q.png"/></div></figure><p id="c4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看被橙色方块包围的节点。我们发现 9 比 2 和 3 都大，所以这三个节点不满足堆属性(node 的值应该小于等于其子节点的值)。请检查下面的橙色节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d390a892284a9e3b19d712f2daa27f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*iDBRhJGiIyCBIAdVOMQnyg.png"/></div></figure><p id="1541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，看看蓝色的节点。这些节点满足堆属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8d7883c537cc4f2c1c3b7feadf6504eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*8DJyn5AJMYp4DqWgv0dJAg.png"/></div></figure><p id="284b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们定义<em class="lv"> min_heapify </em> ( <em class="lv">数组</em>，<em class="lv">索引</em>)。这个方法有两个参数，<em class="lv">数组，</em>和<em class="lv">索引</em>。我们假设该方法将<em class="lv">数组</em> [ <em class="lv">索引</em>的节点与其子节点交换，以满足堆属性。</p><p id="8593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看<em class="lv"> min_heapify </em>是如何从上面的树形结构中产生一个堆的。首先我们调用<em class="lv">min _ heap ify</em>(<em class="lv">array</em>，2)将索引 2 的节点与索引 4 的节点交换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b23b6f544596745671d59e8a0e4ee678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*6ZsaVxXdLu0fyOz99GD1vg.png"/></div></figure><p id="95ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将<em class="lv">min _ heap ify</em>(<em class="lv">array</em>，2)应用到子树之后，子树在下面发生变化，并满足堆属性。这个子树是蓝色的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d7f4db69ad66b8ecc7c3da7c2e20c05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Pg5r3aNAcMluu2YafmcOEw.png"/></div></figure><p id="378f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果子树将索引 2 的节点与索引 5 的节点交换，子树将不会满足如下所示的堆属性。因此子树与父节点交换子树中具有最小值的节点，以满足堆属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b5742510a4b0804ad9a75e4878e78eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*1MXtFjQWaWTqNTGakj4DNg.png"/></div></figure><p id="bd38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到正确交换的树。当我们看橙色的节点时，这个子树不满足堆属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/83f940b32402f5e5e8114127a4d2cd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*sE-XfLcquAc8u1Xzxe5PmA.png"/></div></figure><p id="ecb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以调用<em class="lv">min _ heap ify</em>(<em class="lv">array</em>，4)使子树满足堆属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/86b2d27e69f86123f63e08920d58e0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*NGqt-gG64O_X1GJei_MdJQ.png"/></div></figure><p id="9986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个子树通过将索引 4 的节点与索引 8 的节点交换来满足堆属性。</p><p id="9c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的这些操作从无序的树(数组)中产生堆。</p><h2 id="caed" class="nq ml it bd mm nr ns dn mq nt nu dp mu li nv nw mw lm nx ny my lq nz oa na ob bi translated">3.2 构建 _ 最小 _ 堆</h2><p id="7b2b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">下面的伪代码代表了<em class="lv"> build_min_heap </em>是如何工作的。</p><pre class="kj kk kl km gt ok np ol om aw on bi"><span id="1730" class="nq ml it np b gy oo op l oq or">build_min_heap(array)<br/>    for i=n/2 downto 1<br/>        do min_heapify(array, i)</span></pre><p id="36be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数使用 for 循环迭代除叶节点之外的节点，并将<em class="lv"> min_heapify </em>应用于每个节点。我们不需要将<em class="lv"> min_heapify </em>应用于<em class="lv"> n </em> /2+1 之后的索引项，它们都是叶子节点。我们在下面的橙色节点中应用了<em class="lv"> min_heapify。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f3598a8021dfe346f2ad8fd627069573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qa4zV-Ys8iXRbPCt2Xt3Zw.png"/></div></div></figure><p id="87b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个节点在满足能够应用<em class="lv"> min_heapfiy 的条件下可以满足堆属性。</em>这是因为该函数从底部(倒数第二层)到顶部(根节点层)迭代节点。例如，该函数首先将<em class="lv"> min_heapify </em>应用于索引 4 和索引 5 的节点，然后将<em class="lv"> min_heapify </em>应用于索引 2 的节点。因此，当应用<em class="lv"> min_heapify 时，索引的节点及其后代节点满足堆属性。</em></p><h1 id="afb9" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">4.时间复杂度</h1><p id="0101" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们来考虑一下<em class="lv"> build_min_heap 的时间复杂度。</em>首先我们认为<em class="lv"> min_heapify </em>的时间复杂度，它是<em class="lv"> build_min_heap 的一个主要部分。</em></p><p id="27f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> min_heapify </em>重复交换数组中项目的操作，该操作以固定时间运行。因此<em class="lv"> min_heapify </em>的时间复杂度将与重复次数成正比。在最坏的情况下，<em class="lv"> min_heapify </em>应该重复操作树的高度倍。这是因为在最坏的情况下，min_heapify 会用最深的叶子节点交换根节点。假设<em class="lv"> h </em>为根节点的高度，<em class="lv"> min_heapify </em>的时间复杂度将需要<em class="lv"> O </em> ( <em class="lv"> h </em>)的时间。</p><p id="17b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> min_heapify </em>在各深度的时间复杂度如下所示。节点的数量也显示在右侧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/6ed6425c3a8b8e57d70974794f087249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-h1jgMmLuIFq_ZhuMmBnw.png"/></div></div></figure><p id="401c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图中可以看出<em class="lv"> build_min_heap </em>的时间复杂度将是内部节点的时间复杂度之和。最终的时间复杂度变成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f2c2bb18cca8dc1ab83ecf55546a482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlTVz17IMbUwcrs6SxEWrw.png"/></div></div></figure><p id="206d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们应该知道树的高度来得到时间复杂度。</p><p id="cedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个深度的节点数之和会变成<em class="lv"> n </em>。所以我们会得到下面这个等式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ab03e4536a0eb4cfaf8d0a00fdcacce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*OA6ZyHHxwRFMDdspJooQ1A.png"/></div></figure><p id="aee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的等式代表几何序列，所以我们可以变形它，得到树的高度如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/2b00000d3619d0d744ed1c767272d78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etWYXqoPtFIl5C7j-K_TiA.png"/></div></div></figure><p id="9f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们得到<em class="lv"> O </em> ( <em class="lv"> n </em>)作为<em class="lv"> build_min_heap </em>的时间复杂度。同样，我们得到<em class="lv"> O </em> (log <em class="lv"> n </em>)作为<em class="lv"> min_heapify </em>的时间复杂度。</p><h1 id="5c96" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">5.履行</h1><p id="1e40" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这里我们用 Python 实现了<em class="lv"> min_heapify </em>和<em class="lv"> build_min_heap </em>。<em class="lv"> min_heapify </em>实现如下。</p><pre class="kj kk kl km gt ok np ol om aw on bi"><span id="4da5" class="nq ml it np b gy oo op l oq or">def min_heapify(array, i):<br/>    left = 2 * i + 1<br/>    right = 2 * i + 2<br/>    length = len(array) - 1<br/>    smallest = i</span><span id="73ac" class="nq ml it np b gy ox op l oq or">    if left &lt;= length and array[i] &gt; array[left]:<br/>        smallest = left<br/>    if right &lt;= length and array[smallest] &gt; array[right]:<br/>        smallest = right<br/>    if smallest != i:<br/>        array[i], array[smallest] = array[smallest], array[i]<br/>        min_heapify(array, smallest)</span></pre><p id="6a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，该方法计算索引为<em class="lv"> i </em>的节点及其子节点中值最小的节点，然后将值最小的节点与索引为<em class="lv"> i </em>的节点进行交换。当交换发生时，该方法将<em class="lv"> min_heapify </em>应用于被交换的节点。</p><p id="aa26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 中一个列表(一个数组)的索引从 0 开始，访问节点的方式会有如下变化。</p><ul class=""><li id="4023" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nk mc md me bi translated">根节点| <em class="lv"> i </em> = 0</li><li id="6937" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated">父节点|父节点(<em class="lv"> i </em> ) = ( <em class="lv"> i </em> -1) / 2</li><li id="1626" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated">左子节点| left(<em class="lv">I</em>)= 2<em class="lv">I</em>+1</li><li id="9b58" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated">右子节点| right(<em class="lv">I</em>)= 2<em class="lv">I</em>+2</li></ul><p id="da82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<em class="lv">最小</em>具有最小值节点的索引。如果<em class="lv">最小的</em>不等于<em class="lv"> i </em>，这意味着该子树不满足堆属性，该方法交换节点并对<em class="lv">最小的</em>的节点执行<em class="lv"> min_heapify </em>。</p><p id="5817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> build_min_heap </em>的实现和伪代码差不多。</p><pre class="kj kk kl km gt ok np ol om aw on bi"><span id="f85c" class="nq ml it np b gy oo op l oq or">def build_min_heap(array):<br/>    for i in reversed(range(len(array)//2)):<br/>        min_heapify(array, i)</span></pre><p id="23ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">for 循环不同于伪代码，但行为是相同的。这个 for 循环还从倒数第二层节点到根节点迭代节点。</p><h1 id="91ea" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">6.堆排序</h1><p id="d7cb" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Heapsort 是一种使用堆的排序算法。用<em class="lv"> min_heapify </em>和<em class="lv"> build_min_heap 真的很容易实现。分拣流程如下。请注意，排序的顺序是升序。</em></p><ol class=""><li id="aac1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">用<em class="lv"> build_min_heap 从任意数组构建一个堆。</em></li><li id="8a71" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将数组中的第一项与最后一项交换。</li><li id="d16b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">从数组中移除最后一项。</li><li id="f3dc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">运行<em class="lv"> min_heapify </em>到第一项。</li><li id="19ea" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">回到步骤 2。</li></ol><p id="eb85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在堆中，最小的项是数组的第一项。步骤 3 之后的数组满足应用<em class="lv"> min_heapify </em>的条件，因为我们在将第一项与最后一项交换之后移除了最后一项。根据这一特性，我们可以通过重复步骤 2 到 4 对数组进行排序。</p><p id="2936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">heapsort 实现将如下所示。</p><pre class="kj kk kl km gt ok np ol om aw on bi"><span id="23aa" class="nq ml it np b gy oo op l oq or">def heapsort(array):<br/>    array = array.copy()<br/>    build_min_heap(array)</span><span id="703d" class="nq ml it np b gy ox op l oq or">    sorted_array = []<br/>    for _ in range(len(array)):<br/>        array[0], array[-1] = array[-1], array[0]<br/>        sorted_array.append(array.pop())<br/>        min_heapify(array, 0)</span><span id="b133" class="nq ml it np b gy ox op l oq or">    return sorted_array</span></pre><p id="3b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">heapsort 的时间复杂度是<em class="lv">O</em>(<em class="lv">n</em>log<em class="lv">n</em>因为在最坏的情况下，我们要重复<em class="lv"> min_heapify </em>数组次数中的项数，也就是<em class="lv"> n </em>。</p><p id="64be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 的<a class="ae ky" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank">heapq 模块</a>中，已经实现了对堆的一些操作。我遵循了麻省理工学院讲座中的方法，实现与 Python 不同。如果你想知道 Python 的具体实现，请访问<a class="ae ky" href="https://github.com/python/cpython/blob/master/Lib/heapq.py" rel="noopener ugc nofollow" target="_blank">这里的源代码</a>。例如，这些方法是用 Python 实现的。</p><ul class=""><li id="7357" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nk mc md me bi translated"><code class="fe nm nn no np b">heapq.heapify</code> |对应<em class="lv"> build_min_heap </em></li><li id="f381" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nk mc md me bi translated"><code class="fe nm nn no np b">heapq.heapop</code> |对应交换项目，移除最后一个项目，<em class="lv"> min_heapify </em>立刻<em class="lv">。</em></li></ul><p id="62d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用上述方法，我们可以实现如下的堆排序。请注意，它与官方文件中的<a class="ae ky" href="https://docs.python.org/3/library/heapq.html#basic-examples" rel="noopener ugc nofollow" target="_blank">heap sort 的实现不同。</a></p><pre class="kj kk kl km gt ok np ol om aw on bi"><span id="77e7" class="nq ml it np b gy oo op l oq or">import heapq</span><span id="c40a" class="nq ml it np b gy ox op l oq or">def heapsort(array):<br/>    h = array.copy()<br/>    heapq.heapify(h)<br/>    return [heapq.heappop(h) for _ in range(len(array))]</span></pre><p id="b14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这个帖子到此为止。感谢您的阅读！</p><h2 id="9803" class="nq ml it bd mm nr ns dn mq nt nu dp mu li nv nw mw lm nx ny my lq nz oa na ob bi translated">参考</h2><ul class=""><li id="b4aa" class="lw lx it lb b lc nc lf nd li oy lm oz lq pa lu nk mc md me bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=B7hVxCmfPtM" rel="noopener ugc nofollow" target="_blank">麻省理工学院开放课件 4。堆和堆排序</a></li></ul></div></div>    
</body>
</html>