<html>
<head>
<title>Understanding Javascript ‘this’ keyword (Context)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Javascript“this”关键字(上下文)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/javascript-context-this-keyword-9a78a19d5786?source=collection_archive---------9-----------------------#2019-01-06">https://towardsdatascience.com/javascript-context-this-keyword-9a78a19d5786?source=collection_archive---------9-----------------------#2019-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/76bdae6ae786a26c6589d65716034838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uFpxUEweapysDtOl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@srz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">sydney Rae</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f9e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个人开始学习 javascript 时，上下文是总会造成很多困惑的话题之一，也是面试官经常问的话题。</p><blockquote class="le"><p id="1afb" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">让我们开始…</p></blockquote><h2 id="f838" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">什么是语境？</h2><p id="7b26" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">Context 总是关键字<code class="fe mm mn mo mp b">this</code>的值，它是对“拥有”当前正在执行的代码或函数的对象的引用。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/70d47f9d6a84bc695aaa8dee9251c946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNa6XWu7QZLjbE3eEkr_zQ.png"/></div></div></figure><p id="7e59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道<code class="fe mm mn mo mp b">window</code>在浏览器中是一个全局对象，所以如果我们在控制台中键入<code class="fe mm mn mo mp b">this</code>，它应该返回窗口对象，它确实返回了。</p><p id="4c49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 node.js CLI 中，如果你尝试做上面的事情，你会得到一个拥有所有全局使用的函数的对象，比如<code class="fe mm mn mo mp b">console</code>、<code class="fe mm mn mo mp b">process</code>等等。(试一次)。</p><blockquote class="mv mw mx"><p id="9a0a" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">注意:<code class="fe mm mn mo mp b"><em class="it">this</em></code>关键字的值取决于函数运行/调用/使用的对象。因此<code class="fe mm mn mo mp b">this</code>关键字有不同的值，这取决于它的使用场合。</p><p id="669c" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">注意:从现在开始，这个和上下文可以互换使用。</p></blockquote><h2 id="a7ef" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文—全局和函数内部。</h2><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/623ab1ad4793d4d378a6a9f3084c02d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFDg7qZc8HuBngRgmZOM3g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">this at the global level called on the global object</figcaption></figure><p id="f31f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mm mn mo mp b">foo</code>是在全局级定义的函数，在全局级对象上调用，即<code class="fe mm mn mo mp b">window</code>，所以调用<code class="fe mm mn mo mp b">foo</code>和<code class="fe mm mn mo mp b">window.foo</code>是一样的。因此上下文是一个<code class="fe mm mn mo mp b">window</code>对象。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/de7c23c32d7fa7d5051b4baa229b4ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*7hEYOMm_d94LKyoquUpr_g.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">this inside function called on function object at global level</figcaption></figure><p id="7ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们在全局层次上做<code class="fe mm mn mo mp b">new foo()</code>，那么将得到<code class="fe mm mn mo mp b">this</code>作为<code class="fe mm mn mo mp b">foo</code>对象。</p><blockquote class="mv mw mx"><p id="f2b9" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">注意:<code class="fe mm mn mo mp b">new</code>操作符创建一个对象的实例。函数的上下文将被设置为创建的对象实例。</p></blockquote><h2 id="2ff9" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated"><strong class="ak">上下文—在二级功能下</strong></h2><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/22c0c4cf1ab47df43a622d72261224dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*fPHsaWUXskdDV1g9dBFv3w.png"/></div></figure><h2 id="e38e" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated"><strong class="ak">上下文——当函数被全局定义并在对象下使用时(</strong>隐式绑定<strong class="ak">)。</strong></h2><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/81d7a10177333c39b88dcbf50bd8fbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*nDKtgIq_QqI8L_toIhnXyA.png"/></div></figure><blockquote class="mv mw mx"><p id="f7da" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">注意:从上面我们可以看出<code class="fe mm mn mo mp b">this</code>关键字的值取决于被调用的函数，而不是定义函数的地方。</p></blockquote><h2 id="bb28" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文在“使用严格”中如何表现？</h2><p id="b362" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">当在一个函数中使用<code class="fe mm mn mo mp b">use strict</code>时，上下文即该关键字的行为不同。上下文保持它被调用时的样子。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e3f5495b97edc74ea674bf989998cd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*G5Isgw89FW0d5czubAzR7g.png"/></div></figure><blockquote class="mv mw mx"><p id="4d77" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">注意:我们的整个程序可能应该是<code class="fe mm mn mo mp b">strict</code>或<code class="fe mm mn mo mp b">non-strict</code>。然而，有时你包含一个第三方库，它比你自己的代码有不同的严格性，所以必须注意这些微妙的兼容性细节。</p></blockquote><h2 id="8114" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文在箭头函数中如何表现？</h2><p id="a693" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">就上下文而言，箭头函数的工作方式不同于常规函数。<code class="fe mm mn mo mp b">this</code>将总是引用词法范围(<a class="ae kf" href="https://codeburst.io/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener" target="_blank">在这里是关于范围</a>)，即<code class="fe mm mn mo mp b">this</code>保留封闭词法上下文的值。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/ebe9152d7c6ff104a4169d91f1900c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*_UJVqU7UwJg35FSgRhm5cg.png"/></div></div></figure><p id="6bf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在全局代码中，它将被设置为全局对象，因此我们得到上面的 true。</p><h2 id="ab98" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文在对象的原型链上如何表现？</h2><p id="e258" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">上下文遵循同样的规则，即如果函数在对象的原型链上，<code class="fe mm mn mo mp b">this</code>指的是方法被调用的对象。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/fa5129549ccd6a13d53d8c0701dd2edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*G-WO8Pm0u0WLOuaXBe3zAA.png"/></div></figure><p id="b8a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们调用<code class="fe mm mn mo mp b">obj.func()</code>将会得到<code class="fe mm mn mo mp b">undefined</code>，如果<code class="fe mm mn mo mp b">func</code>被调用于从定义了<code class="fe mm mn mo mp b">x</code>的<code class="fe mm mn mo mp b">obj</code>创建的<code class="fe mm mn mo mp b">newObj</code>，那么它将会返回值 10。</p><h2 id="1282" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文在事件处理程序中如何表现？</h2><p id="73ec" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">案例事件处理程序中的上下文指的是接收事件的<strong class="ki iu">元素</strong>。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/1eb82fc0aec3db7201dd290578cf5581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEsXlS1iJ89nikd1uiv8WQ.png"/></div></div></figure><p id="af22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们在 DOM 的 body 标签上添加了一个 jquery click 事件，我们可以看到上下文返回了 body 元素。</p><h2 id="3ade" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文在执行上下文中是如何表现的？</h2><p id="b92e" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">如果你不知道什么是执行上下文(<a class="ae kf" href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article" rel="noopener ugc nofollow" target="_blank">这里读</a>)。简而言之，执行上下文是函数执行的“环境”或<a class="ae kf" href="https://codeburst.io/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener" target="_blank">范围</a>。每次调用一个函数，都会创建一个新的<code class="fe mm mn mo mp b">execution context</code>。对一个<code class="fe mm mn mo mp b">execution context</code>的每个调用有两个阶段</p><ol class=""><li id="17ed" class="np nq it ki b kj kk kn ko kr nr kv ns kz nt ld nu nv nw nx bi translated">创建—调用函数时</li><li id="b311" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated">激活—执行功能时</li></ol><p id="a89e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mm mn mo mp b">this</code>的值在创建阶段确定，而不是在执行时确定。然而，<code class="fe mm mn mo mp b">this</code>判定规则保持不变。</p><h2 id="337d" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">上下文和范围有什么不同？</h2><p id="1e09" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">范围和上下文是完全不同的概念，但通常被新开发人员互换使用。</p><p id="9404" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">范围是运行时代码中某个特定部分的变量、函数或对象的可访问性。<a class="ae kf" href="https://codeburst.io/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener" target="_blank">点击此处了解更多关于示波器的信息。</a></p><p id="e108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个函数调用都有一个关联的范围和上下文。</p><h2 id="e68d" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">如何显式改变上下文？</h2><p id="dbcf" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">我们可以通过使用<code class="fe mm mn mo mp b">call()</code>、<code class="fe mm mn mo mp b">apply()</code>和<code class="fe mm mn mo mp b">bind()</code>方法来动态地改变任何方法的上下文。</p><p id="17a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">调用— </strong>第一个参数<code class="fe mm mn mo mp b">call</code>是您想要使用的<strong class="ki iu">上下文</strong>。之后，您可以在<strong class="ki iu">中传递任意数量的逗号分隔值。</strong></p><pre class="mr ms mt mu gt od mp oe of aw og bi"><span id="a7c3" class="lo lp it mp b gy oh oi l oj ok">foo.call(context, param1, param2, param3 );</span></pre><p id="527e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">应用— </strong>这与<code class="fe mm mn mo mp b">call</code>相同，但在自变量数量的意义上有所不同。仅应用支持的 2 个参数，<strong class="ki iu">上下文和值数组</strong>。</p><pre class="mr ms mt mu gt od mp oe of aw og bi"><span id="c7c1" class="lo lp it mp b gy oh oi l oj ok">foo.apply( context,[param1, param2, param3]);</span></pre><p id="95ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Bind — </strong>它返回一个新函数，该函数永久绑定到<code class="fe mm mn mo mp b">bind</code>的第一个参数，不管该函数是如何使用的。<code class="fe mm mn mo mp b">bind</code>不立即调用绑定的函数，而是返回一个我们稍后可以运行的新函数。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/dcec5af01082834553a384d9dc406f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vENz6cOp5Re3JIm0mNpeTA.png"/></div></figure><p id="f365" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么我们需要显式地改变上下文？</p><ol class=""><li id="b75e" class="np nq it ki b kj kk kn ko kr nr kv ns kz nt ld nu nv nw nx bi translated">当我们需要调用定义在一个对象内部的函数时，比如说<code class="fe mm mn mo mp b">x</code>，但是在其他对象上，比如说<code class="fe mm mn mo mp b">y</code>，我们可以使用显式方法来这样做，以<strong class="ki iu">增加</strong> <strong class="ki iu">的可重用性</strong>。</li></ol><p id="984e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<a class="ae kf" href="https://codeburst.io/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener" target="_blank"><strong class="ki iu">Currying and partial application</strong></a>是另一个使用上下文显式变化的部分。</p><p id="a10b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.使<strong class="ki iu">效用函数</strong>像</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/a3dc07776f2e655c3956b65cbb295703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*rp42b_nuEFcXzTZPFIRmGA.png"/></div></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi on"><img src="../Images/96fd903fc865ff045c6776b70fe657cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*TYCEQruYJgB9PX1e8iEiWQ.png"/></div></figure><p id="05d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.<strong class="ki iu">继承</strong>是另一个可以使用上下文显式更改的地方。</p><blockquote class="le"><p id="af39" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">如果你知道更多原因，请在下面评论:)</p></blockquote><h2 id="b2fc" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">我们需要考虑上下文的情况有哪些？</h2><p id="03bc" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">我们可能会丢失上下文，即在中获取<code class="fe mm mn mo mp b">this</code>的<code class="fe mm mn mo mp b">undefined</code>值</p><h2 id="2205" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">1.嵌套函数</h2><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/9b974922f9ab3917dcc965a2b28cd0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiiWNOEBDGP7dBCf_x4tKQ.png"/></div></div></figure><p id="d141" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要保留调用回调函数时引用的<code class="fe mm mn mo mp b">obj</code>对象的上下文，在上面的例子中，这种情况不会发生，我们会得到错误。</p><p id="c301" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过用下面的代码替换<code class="fe mm mn mo mp b">exec</code>来消除上面的错误</p><pre class="mr ms mt mu gt od mp oe of aw og bi"><span id="ab4a" class="lo lp it mp b gy oh oi l oj ok">// use of bind<br/>exec: function () {<br/>    this.f2(function () {<br/>        this.f1();<br/>    }.bind(this));<br/>}</span><span id="b271" class="lo lp it mp b gy op oi l oj ok">// use of arrow function<br/>exec: function () {<br/>    this.f2(() =&gt; {<br/>        this.f1();<br/>    });<br/>}</span><span id="4798" class="lo lp it mp b gy op oi l oj ok">// another way not recommended though<br/>exec: function () {<br/>   var that = this;<br/>    this.f2(() =&gt; {<br/>        that.f1();<br/>    });<br/>}</span></pre><h2 id="1a6a" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">2.方法作为回调</h2><pre class="mr ms mt mu gt od mp oe of aw og bi"><span id="4383" class="lo lp it mp b gy oh oi l oj ok">let obj = {<br/>  name: "test",<br/>  waveHi() {<br/>    return ('Hi',this.name);<br/>  }<br/>};<br/><br/>setTimeout(obj.waveHi, 1000)</span></pre><p id="b9dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面会返回<code class="fe mm mn mo mp b">Hi undefined</code>，想一秒为什么？这是因为最后一行将会变成</p><pre class="mr ms mt mu gt od mp oe of aw og bi"><span id="5b7c" class="lo lp it mp b gy oh oi l oj ok">let f = obj.waveHi;<br/>setTimeout(f, 1000);</span></pre><p id="0cc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且，<code class="fe mm mn mo mp b">setTimeout</code>得到了与对象<code class="fe mm mn mo mp b">obj</code>分开的函数<code class="fe mm mn mo mp b">obj.waveHi</code></p><p id="d117" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是</p><pre class="mr ms mt mu gt od mp oe of aw og bi"><span id="74fe" class="lo lp it mp b gy oh oi l oj ok">// Wrapping function<br/>setTimeout(function() {<br/>  obj.waveHi(); // Hi Test<br/>}, 1000);</span><span id="02e6" class="lo lp it mp b gy op oi l oj ok">// Arrow function<br/>setTimeout(() =&gt; obj.waveHi(), 1000); // Hi Test</span><span id="552e" class="lo lp it mp b gy op oi l oj ok">// use of bind<br/>let waveHi = obj.waveHi.bind(obj);<br/>waveHi() // Hi Test</span></pre><blockquote class="mv mw mx"><p id="50f6" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">注意:</p><p id="4f67" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">1.创建“绑定方法引用”需要匿名包装函数和调用成本。在特定情况下，利用闭包可能是更好的选择。</p><p id="3138" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">2.任何类型的函数引用(作为值赋值，作为参数传递)都会失去函数的原始绑定。</p></blockquote></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="e99f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想被添加到我的电子邮件列表中，请考虑在这里输入您的电子邮件地址 和<strong class="ki iu">关注我的</strong> <a class="ae kf" href="https://medium.com/@ideepak.jsd" rel="noopener"> <strong class="ki iu"> medium </strong> </a> <strong class="ki iu">阅读更多关于 javascript 的文章，并关注</strong><a class="ae kf" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">github</strong></a><strong class="ki iu">查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="f656" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="9e1e" class="np nq it ki b kj kk kn ko kr nr kv ns kz nt ld nu nv nw nx bi translated"><a class="ae kf" href="https://levelup.gitconnected.com/javascript-execution-context-and-hoisting-c2cc4993e37d" rel="noopener ugc nofollow" target="_blank"> Javascript 执行上下文和提升</a></li><li id="ae72" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="edcb" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><a class="ae kf" href="https://levelup.gitconnected.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener ugc nofollow" target="_blank"> Javascript 数据结构与映射、归约、过滤</a></li><li id="201e" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="7b8f" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="a8af" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a>，<a class="ae kf" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li></ol></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h2 id="5efc" class="lo lp it bd lq lr nc dn lt lu nd dp lw kr ne ly lz kv nf mb mc kz ng me mf mg bi translated">如果你喜欢这篇文章，请随时分享，并帮助他人找到它！</h2><p id="4faf" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated"><strong class="ki iu">谢谢！</strong></p></div></div>    
</body>
</html>