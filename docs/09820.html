<html>
<head>
<title>Fun with HTML Canvas: Let’s make Lava Lamp Plasma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML 画布的乐趣:让我们制作熔岩灯等离子体</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fun-with-html-canvas-lets-make-lava-lamp-plasma-e4b0d89fe778?source=collection_archive---------11-----------------------#2019-12-24">https://towardsdatascience.com/fun-with-html-canvas-lets-make-lava-lamp-plasma-e4b0d89fe778?source=collection_archive---------11-----------------------#2019-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="ir is gp gr it iu"><div class="bz fp l di"><div class="iv iw l"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">Real time lava-lamp style plasma</figcaption></figure><div class=""/><p id="ddd0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在这篇文章中，你将学习如何创建上面嵌入的熔岩灯等离子体效果。该效果是实时计算的，并使用 HTML 画布进行渲染。</p><p id="36af" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">如果你在手机上，看不到嵌入，你可以<a class="ae ky" href="https://jci4z.codesandbox.io/" rel="noopener ugc nofollow" target="_blank">直接打开嵌入页面</a>。</p><p id="3f99" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">不需要高等数学。我会解释所有我们需要的数学概念。我们将使用<code class="fe kz la lb lc b">sin</code>和<code class="fe kz la lb lc b">cos</code>函数，这就是这个效果所需的所有数学复杂性。</p><p id="9b0f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">如果您想查看完成的代码，请在另一个窗口中打开<a class="ae ky" href="https://codesandbox.io/s/crazy-surf-jci4z" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><h1 id="64ff" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">HTML</h1><p id="17c7" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们的 HTML 结构是基本的。我们创建一个主体，在其中放置一个画布，并对我们的标记进行样式化，使我们的画布总是填充整个窗口。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="4a43" class="mo le jd lc b gy mp mq l mr ms">&lt;!DOCTYPE html&gt;<br/>&lt;body<br/>  style="position: fixed; left: 0px; right: 0px; top: 0px; bottom: 0px; overflow: hidden; margin: 0; padding: 0;"&gt;</span><span id="7e9f" class="mo le jd lc b gy mt mq l mr ms">  &lt;canvas <br/>    id="canvas"<br/>    style="width: 100%; height: 100%; padding: 0;margin: 0;"<br/>  &gt;&lt;/canvas&gt;</span><span id="485a" class="mo le jd lc b gy mt mq l mr ms">&lt;/body&gt;</span></pre><h1 id="fcd6" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设置</h1><p id="327d" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们将画布设置为固定大小的<code class="fe kz la lb lc b">512 x 512</code>像素。画布的像素被设计为拉伸填充整个窗口，但是内部像素缓冲区的大小是固定的<code class="fe kz la lb lc b">512 x 512</code>。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="6dd9" class="mo le jd lc b gy mp mq l mr ms">const canvas = document.getElementById("canvas");<br/>const c = canvas.getContext("2d");</span><span id="21a4" class="mo le jd lc b gy mt mq l mr ms"><em class="mu">// size of canvas<br/></em>const imgSize = 512;</span><span id="e491" class="mo le jd lc b gy mt mq l mr ms">canvas.width = imgSize;<br/>canvas.height = imgSize;</span></pre><p id="c748" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们不打算在画布上使用任何绘图功能，我们将把它当作一个像素缓冲区。我们不能直接操作画布上的像素值，但我们可以创建一个与画布大小相同的图像缓冲区，根据需要操作图像缓冲区，然后将其内容绘制到画布上。</p><p id="c441" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">对<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createImageData" rel="noopener ugc nofollow" target="_blank"> createImageData </a>的调用为我们提供了一个与画布大小相同的图像缓冲区。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="7fd6" class="mo le jd lc b gy mp mq l mr ms"><em class="mu">// init image data with black pixels</em></span><span id="e8e9" class="mo le jd lc b gy mt mq l mr ms">const image = c.createImageData(imgSize, imgSize);</span><span id="246a" class="mo le jd lc b gy mt mq l mr ms">for (let i = 0; i &lt; image.data.length; i += 4) {<br/>  image.data[i] = 0; <em class="mu">// R<br/>  </em>image.data[i + 1] = 0; <em class="mu">// G<br/>  </em>image.data[i + 2] = 0; <em class="mu">// B<br/>  </em>image.data[i + 3] = 255; <em class="mu">// A<br/></em>}</span></pre><p id="bd7a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">返回的图像数据是像素数据的一维数组。每个像素由四个连续的值表示。这四个值是 0-255 范围内的整数强度。它们依次保存像素的红色、绿色、蓝色和 alpha 分量的值。</p><p id="f58e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">该阵列按行存储所有图像像素。第一行的像素先出现，然后是第二行，依此类推，行与行之间没有间隙。</p><p id="7e5e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们将所有的图像像素初始化为不透明的黑色。</p><h1 id="8a51" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">效果总结</h1><p id="191e" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">该效果依赖于构造两个高度图，在相对运动时组合它们，并根据高度值的总和对输出进行着色。</p><h1 id="eae1" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">1 号高度图</h1><p id="b2e8" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们想填充第一个<code class="fe kz la lb lc b">1024 x 1024</code>高度图，平滑值范围从 0..128.</p><p id="61d9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们希望值的分布平滑，没有噪声。我们将在第二个高度图中添加噪声。第一个高度图的工作是给我们一些各个方向的平滑的波浪作为可预测的基础层。</p><p id="3acf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们希望生成一个高度图，当在透视图中渲染时，看起来像这样:</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/b169e958aee8cae2efb434cc54f002d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2Dc8h6_GdaVka1Xzf6lyg.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">height map 1</figcaption></figure><p id="cdc5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我在用正弦函数生成高度图。还记得窦的功能吗？以下是相关事实:</p><ul class=""><li id="f453" class="nc nd jd kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated">它产生连续的波浪</li><li id="f78b" class="nc nd jd kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">它是周期性的，频率为 2π</li><li id="dd70" class="nc nd jd kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">它生成-1 和 1 之间的值</li></ul><p id="bebd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们来看看。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nq"><img src="../Images/407eead4f544866addd6cf323f38c375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6nslXmv6M4FukFml_t6uA.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">plain sin(x)</figcaption></figure><p id="1b6d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们想要产生一个大约有 1.5 个完整振荡的波。这就是我们从 sin 函数中得到的，当我们给它 0 到 3π的值时。</p><p id="077d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">如果我们适当的缩放比例，我们可以得到任何我们需要的频率。例如，如果我们想要在 x = 0 和 x = 512 之间产生 1.5 次振荡，我们不会将<code class="fe kz la lb lc b">x</code>传递给 sin，但是<code class="fe kz la lb lc b">x × 3π/512</code><code class="fe kz la lb lc b">x</code>越接近 512，我们的转换输入值就越接近 3π。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nr"><img src="../Images/1aee82afa2feb213938e36cde851044e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_sgNqgD5RHGM1yaj7t8bg.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">graph of sin(x <code class="fe kz la lb lc b">× </code>3π/512)</figcaption></figure><p id="6fa4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">接下来我们需要关注的是输出范围。sin 函数给出了介于-1 和 1 之间的值。我们想要 0..128.</p><p id="7104" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们可以转换-1..1 到我们想要的范围，首先归一化到 0..1.为此，我们加 1，然后除以 2。值在 0 之间..1 我们可以到达 0..乘以 128 得到 128。</p><p id="a8b5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">因此，我们完成的发电机公式是:</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c117dc19b90ad472d1f93ebe9e4eb0b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*9ul1hcizlocfify5v0aBhQ.png"/></div></figure><p id="dd19" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">该图具有我们需要的所有属性:</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nt"><img src="../Images/7d423339110dcbc034436c2d763e0a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9o_-P2aXc3IMMNVqgrsXA.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk"><code class="fe kz la lb lc b">we have a wave in range (sin(x×3π/512)+1)/2*128</code></figcaption></figure><p id="4850" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们有一个很好的函数来生成我们的高度图。但是我们如何用合适的值填充 2D 高度图呢？</p><p id="ea86" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们确定每个像素到高度图中心的距离，并使用<em class="mu">距离</em>作为高度生成函数的输入。相同的距离像素产生相同的高度值，所以我们得到一个从中心出现的径向波值。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nu"><img src="../Images/9875d61573dafdc24c490db17f34b283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdMKFDPE--Uf1pDsc-lDwg.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">Same distance pixels generate the same height value</figcaption></figure><p id="ca66" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">为了计算像素到中心的距离，我们首先将像素坐标偏移地图宽度和高度的一半。这有效地将坐标移动到以原点为中心的坐标系。</p><p id="f26f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">像素坐标允许我们构建一个直角三角形，所以我们可以使用<a class="ae ky" href="https://medium.com/swlh/why-the-pythagorean-theorem-is-true-1d4c8a508510" rel="noopener">勾股定理</a>告诉我们<code class="fe kz la lb lc b">distance² = cx² + cy²</code></p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/acb75e819c5f3a2e7347a32d6f023e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*Z6gL1P8db8g0cT76VrBnzQ.png"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">the distance from origin is given by sqrt(cx²+cy²)</figcaption></figure><p id="8789" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">第一张高度图就这样了。对应的代码是:</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><h1 id="445f" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">二号高度图</h1><p id="04ba" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们想用 0 范围内的值填充第二个<code class="fe kz la lb lc b">1024 x 1024</code>高度图..127.这一次我们想要不规则。它们需要在空间上连贯一致，从山丘到山谷平滑过渡。</p><p id="cda7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">由于我们已经熟悉了 sin 函数，我将继续使用 trig 函数来生成第二个高度图。在透视图中，它看起来像这样:</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nx"><img src="../Images/a907a2e5ae5430284b2ef2d39a64ced6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTWWZwCBY7naGzhQtIBHpQ.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">Height map 2</figcaption></figure><p id="7860" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">这张地图不是随机的。事实上，这是非常有规律的。它甚至关于 x 轴和 y 轴都是对称的。它只是混杂在一起，足以有一个有机的感觉，这就是我们所要寻找的。</p><p id="5e23" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">它由正弦和余弦函数之和构成，这些函数在偏离中心的轴伪距离上运算。像以前一样，输入被缩小以产生适合我们的地图大小的波浪量，输出被缩放为 0..127.</p><h2 id="c1d8" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">构建高度函数</h2><p id="1202" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">主要思想是使用正弦和余弦之和来产生波状不规则性。出于我们的目的——这里纯粹是审美目的——我们将 cos 函数理解为 sin 函数的相移版本。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oj"><img src="../Images/13829bf38be1a4b750e72ae8e924e78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpZdoj_3DTSSiR1EwhPyjg.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">cos is just a phase shifted version of sin</figcaption></figure><p id="86f4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">这次我们不想要径向对称，所以我们不打算用距离作为这些函数的输入。相反，我们将使用轴倾斜版本的距离。</p><p id="27f1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">对于 sin 部分，我们将拉伸 y 坐标，收缩 x 坐标。然后，我们缩小输入，以达到一个适合我们地图大小的好看的频率。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a60f33243a4ac91f0ee915e66bc55abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*xTUVs_c5_geWdxR8s230iA.png"/></div></figure><p id="6708" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">对于 cos 部分，我们遵循同样的思路，但是沿 x 轴拉伸，沿 y 轴收缩。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7b9f56335942b7bbf074cb418aaf8c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*r4qRH_XKdYA2KGQYb9wFuQ.png"/></div></figure><p id="41d5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">这两个部分为我们产生了规则的椭圆波形。当我们把它们加起来，它们就形成了我们想要的不规则的山丘景观</p><div class="mg mh mi mj gt ab cb"><figure class="om iu on oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/816e4bea30a1d7d9fd936e205412fd3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*IqOJj2VqczotQT42itwCsA.png"/></div></figure><figure class="om iu os oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/67949dac2ff16619896e9c83efeaf209.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*W5CP7SHUIsFohdOKkVxkmA.png"/></div></figure><figure class="om iu ot oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/eb944ad69f440a1163437aef61c62edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*lTWWZwCBY7naGzhQtIBHpQ.png"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk ou di ov ow">sin, cos, and combined waves</figcaption></figure></div><p id="22b0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们仍然需要将输出标准化到 0..127.当我们将 sin 和 cos 的输出相加时，我们得到-2 范围内的值..2，所以我们加 2，除以 4，得到值 0..1，然后缩放 127 以得到我们想要的范围。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/4488fd3cce10a414d2969511e18ec766.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*ti1vu6opXDskZ4yVIQl37Q.png"/></div></figure><p id="3b8c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">第二张高度图到此为止。下面是相应的代码:</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><h1 id="bb84" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">渲染高度贴图</h1><p id="e9ec" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们将我们的高度图构造为<code class="fe kz la lb lc b">1024 x 1024</code>，与我们的可见图像尺寸<code class="fe kz la lb lc b">512 x 512</code>相比，它在每个方向上的尺寸都是两倍</p><p id="f82b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">为了使高度图可见，我们可以迭代任何<code class="fe kz la lb lc b">512 x 512</code>部分，从高度值中导出每个像素的显示颜色，并将颜色放入我们的图像缓冲区。</p><p id="860c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">因为高度图包含 0..128 和 0..127，我们可以将它们相加，得出范围为 0..255.最简单的开始是渲染相应的灰度值，其中红色、绿色和蓝色分量是相同的。</p><p id="2aa6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">如果我们对高度图 1、高度图 2 以及它们的值的总和(都从左上角开始)执行此操作，我们将得到以下图像:</p><div class="mg mh mi mj gt ab cb"><figure class="om iu oy oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/5c67f3078cdf4df33a6d4f41071a5582.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*J8dwxx_9qx2AeFl02Cadyg.png"/></div></figure><figure class="om iu oz oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/22a3ff3e90ce0aa76c37b6040a25e7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*wMIBFeQ3uFxRdjM3H0IbJA.png"/></div></figure><figure class="om iu pa oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/570073e3856a76857731fce28a1a77a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*x6ae_Zzm2vXNeOeh_6sYHw.png"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk pb di pc ow">height map 1, height map 2, and the sum of their values</figcaption></figure></div><p id="26a7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">下面是更新图像像素缓冲区的相应代码:</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><h1 id="84e6" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">高度场动画</h1><p id="39fa" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们应该开始制作我们的高度图来获得初步的视觉效果。我们应得的。</p><p id="a116" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">这个想法是动画的高度地图的位置相对于彼此。请记住，我们有<code class="fe kz la lb lc b">1024 x 1024</code>高度图，但只有一个<code class="fe kz la lb lc b">512 x 512</code>图像视图，因此在每个高度图上，对图像有贡献的第一个——左上角——像素可以是范围<code class="fe kz la lb lc b">[0..512]x[0..512]</code>内的任何像素</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi pd"><img src="../Images/f5bfd72542234d3a34339d96e4e98af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbH7xWxmJYqTXOhPfoMw9A.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">different offsets of height maps create different values in the view port</figcaption></figure><p id="cd2d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们将使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame</a>API 来启动我们的动画。当需要渲染下一帧时，它会调用我们的<code class="fe kz la lb lc b">tick</code>函数。浏览器会尽力给我们一点时间来绘制下一帧，通常目标是每秒 60 帧。我们需要请求在我们完成后再次被呼叫。</p><p id="88d8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在我们的 tick 函数中，我们将高度图偏移更新到新的位置，重新计算新的图像数据，并将图像呈现到画布上。</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><h2 id="53b6" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">随时间插值高度图偏移</h2><p id="b1a8" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">当我们的回调函数被调用时，浏览器会传入一个以毫秒为单位表示时间的高分辨率数值。每次调用我们的时候，这个参数都会比上次调用的毫秒数高。我们可以将这一事实用于基于时间的动画，从而独立于帧速率。</p><p id="fe7a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们将使用时钟值来驱动高度贴图偏移的动画。我们需要在两个高度图上的两个轴上插入 0 到 512 之间的值。我们将为四个偏移值中的每一个单独做这件事，因为我们不希望运动开始看起来太有规律或重复。</p><p id="3a2f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们的目标是移动高度贴图的中点，使其在视口中漫游，如下所示:</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/94026dfbc49a3397da5443abca3df029.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/1*R76Dt-wYYyHtoVFEZ8Lwjg.gif"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">desired middle point movement of our height maps within the viewport</figcaption></figure><p id="f0b8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">是的，既然我们已经对 sin 和 cos 有了充分的了解，我们就用它们来插值时间偏移。</p><p id="e920" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">给定一个进行中的时间值<code class="fe kz la lb lc b">t</code>,我们的插值必须给我们一个范围为 0 的值..512.</p><p id="72ac" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们在构建高度图时使用的相同原则在这里也适用。我们将缩小<code class="fe kz la lb lc b">t</code>来延长一个完整振荡发生的时间。然后，我们通过加 1，除以 2，然后乘以 512 来缩放到所需的范围。</p><p id="0369" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们还想增加一些变化，因为我们想对四个偏移量进行稍微不同的插值。为此，我们可以改变时间比例因子，并给<code class="fe kz la lb lc b">t</code>增加一个常数，以在输出中产生相移。</p><p id="22b9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">这是我们的基本公式:</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi pf"><img src="../Images/bd03e5808dfd506ec6232625be418b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdkHDU4YUUAijsITlgaANA.png"/></div></div></figure><p id="dfca" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">对于四个偏移中的每一个，我们将对<code class="fe kz la lb lc b">timeScale</code>和<code class="fe kz la lb lc b">phaseShift</code>使用稍微不同的值，以避免锁步重复动画。下面是相应的代码:</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><p id="7487" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">随着偏移动画的到位，我们已经得到了等离子体效果的灰度版本。</p><h1 id="c847" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我们迄今为止的进展</h1><p id="d35a" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">这是我们迄今为止取得的进展:<a class="ae ky" href="https://codesandbox.io/s/nameless-wood-rq5wy" rel="noopener ugc nofollow" target="_blank">动画灰度等离子体</a></p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi pg"><img src="../Images/5fe317251e7bbbb6acd5a29fc6ff607a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vEeIMiuNny9ojB2tCpNEw.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">screenshot of grey-scale plasma sandbox</figcaption></figure></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><h1 id="4bb7" class="ld le jd bd lf lg po li lj lk pp lm ln lo pq lq lr ls pr lu lv lw ps ly lz ma bi translated">添加颜色</h1><p id="9566" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们将通过添加颜色来改善我们的等离子效果。首先，我们将添加静态颜色，然后我们将提出一个随着时间改变颜色的策略。</p><h2 id="f59d" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">使用单一调色板</h2><p id="5d1d" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">主要思想是使用一组固定的 256 种颜色来对应范围 0..255.</p><p id="dbee" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">如果我们认为低值是谷，高值是山，我们可以决定将山设为蓝色<code class="fe kz la lb lc b">rgb 0,0,255</code>而将谷设为红色<code class="fe kz la lb lc b">rgb 255,0,0</code>，并在颜色之间进行线性插值。我们可以预先计算所有 256 种颜色，并将它们放入一个数组中，这样高度值为 0..255 索引成与高度相对应的颜色。</p><p id="3ede" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">如果我们用<code class="fe kz la lb lc b">r, g, and b</code>键将颜色表示为对象，我们可以使用辅助函数在两种颜色之间进行插值:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="f447" class="mo le jd lc b gy mp mq l mr ms">// c1 and c2 are colors<br/>// f is a fraction between 0..1<br/>//<br/>// returns an interpolated color between <br/>//   c1 (for f=0) and<br/>//   c2 (for f=1)<br/>//<br/>// pass f=0.5 to get the color half-way between c1 and c2</span><span id="8932" class="mo le jd lc b gy mt mq l mr ms">const interpolate = (c1, c2, f) =&gt; {<br/>  <br/>  return {<br/>    r: Math.floor(c1.r + (c2.r - c1.r) * f),<br/>    g: Math.floor(c1.g + (c2.g - c1.g) * f),<br/>    b: Math.floor(c1.b + (c2.b - c1.b) * f)<br/>  };<br/>};</span></pre><h2 id="b4d7" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">使用双色渐变</h2><p id="9bdd" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们可以生成 256 种颜色的渐变，如下所示:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="cea1" class="mo le jd lc b gy mp mq l mr ms">// generates an array of 256 colors <br/>// forming a linear gradient of the form<br/>// [c1, ..., c2]</span><span id="73c4" class="mo le jd lc b gy mt mq l mr ms">const linearGradient = (c1, c2) =&gt; {<br/>  const g = [];<br/>  <em class="mu">// interpolate between the colors in the gradient<br/>  </em>for (let i = 0; i &lt; 256; i++) {<br/>    const f = i / 255;<br/>    g[i] = interpolate(c1, c2, f);<br/>  }<br/>  return g;<br/>};</span></pre><p id="0330" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">有了这些助手，我们可以像这样定义一个调色板:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="ea38" class="mo le jd lc b gy mp mq l mr ms">let palette = linearGradient(<br/>   { r: 255, g: 255, b: 0 },  // c1 yellow<br/>   { r: 0, g: 54, b: 128 }    // c2 dark blue<br/>);</span></pre><p id="7aa6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在<code class="fe kz la lb lc b">updateImageData</code>中，我们可以使用调色板中对应于高度值的颜色:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="d35d" class="mo le jd lc b gy mp mq l mr ms"><em class="mu">// height value of 0..255<br/></em>let h = heightMap1[i] + heightMap2[k];</span><span id="d151" class="mo le jd lc b gy mt mq l mr ms"><em class="mu">// get color value from current palette<br/></em>let c = palette[h];</span></pre><p id="98fe" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">以下是使用两种颜色之间的线性渐变的一些结果:</p><div class="mg mh mi mj gt ab cb"><figure class="om iu oz oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/49836f4221403dd52ed6fc4a97daa967.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*w_kpzG82MplDnHum4tTUUA.png"/></div></figure><figure class="om iu pt oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/47b081f253f3f036a21a9267f15c8360.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*mjGMD7vY6C9twFqpqPX_iw.png"/></div></figure><figure class="om iu pu oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/4b675c7b56fd11b64130fa4dfbdc1705.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*YuF2YTjE0sq6oKbmfMOt9Q.png"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk pv di pw ow">Using a linear gradient between two colors</figcaption></figure></div><p id="a735" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">整体视觉效果还是和灰度着色差不多。我们可以通过在渐变中添加额外的不同颜色来创造更多样的外观。</p><h2 id="04d2" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">五色渐变</h2><p id="d03b" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">让我们创建一个渐变函数，它接受五种不同的颜色，并在它们之间进行插值。</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><p id="2901" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">创建五种颜色的调色板极大地增强了我们输出的多样性。</p><p id="146a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">通过在中等高度的部分选择任意的颜色，我们将我们对深度的感知与潜在的高度值分离。</p><p id="7a3d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们可以自由地为调色板的中间选择浅色，为相邻的颜色选择深色，以获得更高和更低的值。在我们的感知中，这使得高度图的中间色调看起来像脊线。这种效果是我们只有用两种以上颜色的渐变才能达到的。</p><div class="mg mh mi mj gt ab cb"><figure class="om iu px oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/c5320a8f2e9a1311ca5327a831af011c.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*xQxtz0cWtsX0op3ICGEqpg.png"/></div></figure><figure class="om iu py oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/1d01a0957d295ab991805444dbc81c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*TEtcyvwq2goTtuyh49upcA.png"/></div></figure><figure class="om iu pz oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/39c72913e40fcbce029b47a6dfa114b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*V1uATKe1nPr4ha3x7JHAUQ.png"/></div></figure></div><div class="ab cb"><figure class="om iu qa oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/d5f13887be97661a32f8536ac5910c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ItiwupPAibVqjUh68ZVdYg.png"/></div></figure><figure class="om iu qb oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/f67bec7095f8961d3cbc0ced2b9cc7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*NkigfhgIag25YoSphgzOTw.png"/></div></figure><figure class="om iu qc oo op oq or paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/8e1c0c9f869733c88b259a0198404d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*3652YfnJvTheaoQKR2CvcA.png"/></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk pb di pc ow">multi-color palettes can effectively accentuate or blur areas in our height map</figcaption></figure></div><h1 id="4867" class="ld le jd bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用两种调色板</h1><p id="7142" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">现在我们可以轻松地创建调色板，我们可以创建两个调色板，并随着时间的推移在它们之间进行插值。</p><p id="6b7a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们想开始创造性地使用颜色，所以在我们继续之前，让我们快速添加一个助手来创建一个随机的 5 色渐变调色板。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="39bc" class="mo le jd lc b gy mp mq l mr ms"><em class="mu">// returns a random color<br/></em>const randomColor = () =&gt; {<br/>  const r = Math.floor(Math.random() * 255);<br/>  const g = Math.floor(Math.random() * 255);<br/>  const b = Math.floor(Math.random() * 255);<br/>  <br/>  return { r, g, b };<br/>};</span><span id="10a1" class="mo le jd lc b gy mt mq l mr ms">// returns a random 5-color gradient palette<br/>const makeRandomPalette = () =&gt; {<br/>  const c1 = randomColor();<br/>  const c2 = randomColor();<br/>  const c3 = randomColor();<br/>  const c4 = randomColor();<br/>  const c5 = randomColor();<br/>  <br/>  return makeFiveColorGradient(c1, c2, c3, c4, c5);<br/>};</span></pre><p id="288d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">每一帧我们计算一个范围为 0 的值..1，并将当前帧的调色板创建为源调色板的相应颜色之间的插值。</p><p id="67aa" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们将使用 cos 函数进行插值。应用与之前相同的规则:我们拉伸<code class="fe kz la lb lc b">t</code>值来控制振荡时间，然后归一化为 0..通过加 1 除以 2 得到 1。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="8fd1" class="mo le jd lc b gy mp mq l mr ms"><em class="mu">// two palettes we interpolate between<br/></em>const palettes = [makeRandomPalette(), makeRandomPalette()];</span><span id="b01e" class="mo le jd lc b gy mt mq l mr ms"><em class="mu">// current palette is edstablished durting animation<br/></em>let palette = [];</span><span id="007c" class="mo le jd lc b gy mt mq l mr ms">const updatePalette = t =&gt; {<br/>  const timeScale = 0.0005;<br/>  const x = t * timeScale;<br/>  <br/>  <em class="mu">// normalized value 0..1 used to interpolate palette colors<br/>  </em>const inter = (Math.cos(x) + 1) / 2;</span><span id="94fd" class="mo le jd lc b gy mt mq l mr ms"><em class="mu">  // create interpolated palette for current frame<br/>  </em>for (let i = 0; i &lt; 256; i++) {<br/>    palette[i] = interpolate(palettes[0][i], palettes[1][i], inter);<br/>  }<br/>};</span></pre><p id="b4c9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">现在，我们可以使用两个调色板来实现我们的效果不同的艺术意境。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi qd"><img src="../Images/43be0832f86b07b50f3dc282274af9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toSVpFpgLqGx7rJKur2kCw.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">Given two color palettes we can interpolate between the two each frame</figcaption></figure><h2 id="415a" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">转向时生成新调色板</h2><p id="d0ad" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">两个调色板之间的混合很好，但仍然有些静态。最后，随着时间的推移，我们将生成新的调色板。</p><p id="1d73" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">当在两个调色板之间来回切换时，最好能知道我们何时到达插值的远端，也就是说<code class="fe kz la lb lc b">inter</code>何时分别到达<code class="fe kz la lb lc b">0</code>和<code class="fe kz la lb lc b">1</code>，并且即将开始向相反的方向移动。</p><p id="f904" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">一旦我们检测到这个事实，我们可以在另一端生成一个新的调色板，并平滑地插入一组新的颜色。</p><p id="cb5f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">仅仅检查<code class="fe kz la lb lc b">inter</code>的具体值是不够的。首先，我们不能指望准确地击中<code class="fe kz la lb lc b">0</code>或<code class="fe kz la lb lc b">1</code>。</p><p id="219f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">假设我们在<code class="fe kz la lb lc b">inter = 0.01</code>，直到下一帧足够长的时间过去，使得 cos 函数经过<code class="fe kz la lb lc b">0</code>并再次移动到<code class="fe kz la lb lc b">0.01</code>。这种情况也说明了我们的下一个问题:仅仅看插值并不能告诉我们前进的方向。我们应该重新生成两个调色板中的哪一个？</p><h2 id="0b02" class="mo le jd bd lf ny nz dn lj oa ob dp ln kl oc od lr kp oe of lv kt og oh lz oi bi translated">检测转向点</h2><p id="51a8" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">我们需要插值函数<code class="fe kz la lb lc b">cos</code>的<a class="ae ky" href="https://simple.wikipedia.org/wiki/Derivative_(mathematics)" rel="noopener ugc nofollow" target="_blank">导数</a>。我们需要看看<code class="fe kz la lb lc b">-sin</code>。</p><p id="f03f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated"><code class="fe kz la lb lc b">cos</code>的导数给出了<code class="fe kz la lb lc b">cos</code>任意给定点处切线的斜率。实际上:当一个函数在点<code class="fe kz la lb lc b">x</code>向下时，导数函数在点<code class="fe kz la lb lc b">x</code>为负。当函数在点<code class="fe kz la lb lc b">x</code>向上时，导数在点<code class="fe kz la lb lc b">x</code>为正。</p><p id="6851" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">因此，我们可以寻找导数符号的变化。如果前一帧的导数是负的，而当前帧的导数是正的，我们已经改变了方向，正在向第二个调色板插值。</p><p id="c65b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">同样的想法适用于相反的情况。如果前一帧的导数是正的，而当前帧的导数是负的，我们已经改变了方向，正在向第一个调色板插值。</p><p id="4dcb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated"><code class="fe kz la lb lc b">cos</code>的导数是<code class="fe kz la lb lc b">-sin</code>。通过查看图表，说服自己上述陈述是正确的。</p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi qe"><img src="../Images/7de25a514246f46c51379a2dfcef0b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80e97xeIbog-qqQf4h0W4w.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">cos(x) and its derivative -sin(x)</figcaption></figure><p id="a331" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">当<code class="fe kz la lb lc b">cos</code>向下时，<code class="fe kz la lb lc b">-sin</code>为负。当<code class="fe kz la lb lc b">cos</code>抬头时，<code class="fe kz la lb lc b">-sin</code>为正。在<code class="fe kz la lb lc b">cos</code>改变方向的点<code class="fe kz la lb lc b">-sin</code>是<code class="fe kz la lb lc b">0</code>。</p><p id="15db" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">我们将使用这些事实，并扩展我们的调色板插值，以在检测到导数符号变化时生成新的调色板。</p><p id="8f45" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">根据新的导数是正的还是负的，我们知道我们正在向哪个调色板插值，所以我们可以替换正确的那个。</p><figure class="mg mh mi mj gt iu"><div class="bz fp l di"><div class="nw iw l"/></div></figure><p id="81aa" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">对新生成的调色板插值结束了我们的工作。等离子效果完成了。</p><p id="2ec6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">恭喜你走到这一步！</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><h1 id="278c" class="ld le jd bd lf lg po li lj lk pp lm ln lo pq lq lr ls pr lu lv lw ps ly lz ma bi translated">结论</h1><p id="68ee" class="pw-post-body-paragraph ka kb jd kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx im bi translated">哇，那真是一段旅程。在这里找到完整的工作源码<a class="ae ky" href="https://codesandbox.io/s/crazy-surf-jci4z" rel="noopener ugc nofollow" target="_blank">。坐下来享受你创造的一切吧！</a></p><figure class="mg mh mi mj gt iu gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi qf"><img src="../Images/b62cf6bfc1f88f48a92f7d345f4e769f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GIYLcRJwpewzYk6wtIkEg.png"/></div></div><figcaption class="ix iy gj gh gi iz ja bd b be z dk">random screenshot of lava lamp plasma</figcaption></figure></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="df8f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">PS: 看看这篇用 HTML 创建星球大战标题抓取的文章。这比血浆更容易做到，但也相当值得。它看起来非常接近真实的交易。</p><div class="ir is gp gr it qg"><a href="https://medium.com/better-programming/create-a-star-wars-title-crawl-in-html-c25a76fea401" rel="noopener follow" target="_blank"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd je gy z fp ql fr fs qm fu fw jc bi translated">创建一个 HTML 格式的星球大战标题抓取</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">很久很久以前，在一个遥远的浏览器里</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">medium.com</p></div></div><div class="qp l"><div class="qq l qr qs qt qp qu na qg"/></div></div></a></div></div></div>    
</body>
</html>