<html>
<head>
<title>Is your Django app slow? Ask a data scientist, not an engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的 Django 应用慢吗？去问数据科学家，而不是工程师</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-your-django-app-slow-ask-a-data-scientist-not-an-engineer-3c120384ffd9?source=collection_archive---------16-----------------------#2019-03-12">https://towardsdatascience.com/is-your-django-app-slow-ask-a-data-scientist-not-an-engineer-3c120384ffd9?source=collection_archive---------16-----------------------#2019-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b737" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的职业是工程师。在调查一个缓慢的 Django 应用程序时，我依靠直觉。这些年来，我已经解决了很多性能问题，我的大脑采取的捷径经常奏效。然而，直觉可能会失败。它在复杂的 Django 应用程序中可能会失败，这些应用程序有许多层(例如:SQL 数据库、NoSQL 数据库、ElasticSearch 等)和许多视图。噪音太大了。</p><p id="92f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果我们不依赖工程师的直觉，而是像数据科学家一样进行性能调查，会怎么样？</strong>在这篇文章中，我将以数据科学家的身份，而不是工程师的身份，讲述一个性能问题。我将分享来自一个真实性能问题的时间序列数据和我用来解决这个问题的 Google Colab 笔记本。</p><h1 id="ec01" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">问题第一部分:噪音太大</h1><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/3cc3fbc556ce6e33e195afed0b62270f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*MdZSrDpShBLNO2CW"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Photo Credit: pyc<a class="ae ly" href="https://www.flickr.com/photos/pyc/4963466757/in/photolist-8yB4K4-pBRCcq-nZXkWu-bWsES4-29rmwqJ-boe2Vk-7vsTeb-9N2guL-ng4zzC-8hE5Cq-zouzT-areoZ2-nLQoy7-8hpHiQ-a5r9xQ-8hE5Ku-ofvatX-n3mHF-fHSwDM-inbd3a-7oT1q-4UsU2J-2526RGe-8LaPMa-32AUXJ-bka1JE-bka1Kf-9aBMJf-dqr3qB-dqrdUr-5sx8D-o4dwhQ-hR6gY-prMTu-4Tg8va-29MP5Hj-7F2BDK-7F6uoN-7EAp5f-7EAnS1-7E4qdX-JoapDG-7F6v6y-zosvP-7DrJvR-7Ewy2F-7F6v9N-6g9j2o-7Ewvci-7DrFoZ" rel="noopener ugc nofollow" target="_blank"> Carnoy</a></figcaption></figure><p id="7d9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多性能问题是由以下原因之一引起的:</p><ol class=""><li id="cdc9" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated"><strong class="js iu">一个缓慢的层</strong>——仅仅是许多层(数据库、应用服务器等)中的一层速度缓慢，影响了 Django 应用中的许多视图。</li><li id="f894" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated"><strong class="js iu">慢速视图</strong> —一个视图正在生成慢速请求。这对整个应用程序的性能有很大的影响。</li><li id="fa40" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated"><strong class="js iu">高吞吐量视图</strong> —一个很少使用的视图突然看到流量涌入，并触发应用程序整体响应时间的峰值。</li></ol><p id="09fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在调查性能问题时，我会从寻找相关性开始。</strong>是否有任何指标同时变差？这可能很难:<strong class="js iu">一个拥有 10 层和 150 个视图的普通 Django 应用程序有 3000 个不同的时间序列数据集组合要比较！</strong>如果我的直觉不能快速隔离问题，我自己也几乎不可能隔离问题。</p><h1 id="adf4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">问题第二部分:幻影相关性</h1><p id="ec3e" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">确定两个时间序列数据集是否相关是<a class="ae ly" href="https://www.kdnuggets.com/2015/02/avoiding-common-mistake-time-series.html" rel="noopener ugc nofollow" target="_blank">异常多变的</a>。例如，尼古拉斯·凯奇每年出现在电影中的次数和游泳池溺水事件有关联吗？</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/ca1df87c067472f4e97227ab41ace4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SERTuZpCGk7GlrITofMTPw.png"/></div></div></figure><p id="a72c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ly" href="https://www.indiebound.org/book/9780316339438" rel="noopener ugc nofollow" target="_blank">伪相关性</a>是一整本书都在讲述这些看似清晰却毫无关联的相关性！那么，<strong class="js iu">为什么看时间序列图时，趋势似乎会引发相关性呢？</strong></p><p id="fb27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个例子:五年前，我所在的科罗拉多地区经历了一场历史性的洪水。它关闭了进入埃斯蒂斯公园的两条主要路线之一，这是通往落基山国家公园的大门。如果你查看埃斯蒂斯帕克许多不同类型企业的销售收入，你会发现道路关闭时收入急剧下降，道路重新开放时收入增加。这并不意味着不同商店的收入是相关的。商店只是受到了相互依赖的影响:一条封闭的道路！</p><p id="2826" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从时间序列中去除趋势的最简单方法之一是计算<a class="ae ly" href="https://people.duke.edu/~rnau/411diff.htm" rel="noopener ugc nofollow" target="_blank"> <em class="mx">第一差值</em> </a>。要计算第一个差值，从每个点减去之前的点:</p><pre class="ln lo lp lq gt my mz na nb aw nc bi"><span id="1891" class="nd kp it mz b gy ne nf l ng nh">y'(t) = y(t) - y(t-1)</span></pre><p id="7a17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很好，但当我盯着图表时，我的视觉大脑无法将一个时间序列重新想象成它的第一个差异。</p><h1 id="3161" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">进入数据科学</h1><p id="49c4" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated"><strong class="js iu">我们面临的是数据科学问题，而不是性能问题！</strong>我们想要识别任何高度相关的时间序列指标。我们希望看到过去的误导趋势。为了解决这个问题，我们将使用以下工具:</p><ul class=""><li id="d237" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn ni mf mg mh bi translated"><a class="ae ly" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>，一个共享的笔记本环境</li><li id="344e" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn ni mf mg mh bi translated">常见的 Python 数据科学库，如<a class="ae ly" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>和<a class="ae ly" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> SciPy </a></li><li id="985d" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn ni mf mg mh bi translated">从应用程序性能监控(APM)产品<a class="ae ly" href="https://scoutapp.com/" rel="noopener ugc nofollow" target="_blank"> Scout </a>收集的性能数据。如果您还没有帐户，请注册免费试用。</li></ul><p id="ad21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在 Google Colab 上浏览一个<a class="ae ly" href="https://colab.research.google.com/drive/1VhCwtGLc-tWhB_gbGuBo_cfs7Q5J4dCI" rel="noopener ugc nofollow" target="_blank">共享笔记本。您可以轻松保存该笔记本的副本，从 Scout 输入您的指标，并在您的 Django 应用程序中确定最重要的相关性。</a></p><h1 id="235e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第一步:在 Scout 中查看应用程序</h1><p id="a0b8" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">我登录 Scout，看到下面的概览图:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nj"><img src="../Images/240135d36a8e0c850e31d664d9298dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KbaGPbeYQlGTljfD"/></div></div></figure><p id="601f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">花费在 SQL 查询上的时间从晚上 7 点到 9 点 20 分大幅增加。为什么？这很可怕，因为几乎每个视图都要接触数据库！</p><h1 id="e07c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤 2:将图层时间序列数据加载到 Pandas 中</h1><p id="1468" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">首先，我想寻找层(例如:SQL、MongoDB、View)和 Django 应用程序的平均响应时间之间的相关性。层(10)比视图(150+)少，所以这是一个简单的起点。我将从 Scout 获取这个时间序列数据，并初始化一个熊猫数据框架。我将把这个数据争论<a class="ae ly" href="https://colab.research.google.com/drive/1VhCwtGLc-tWhB_gbGuBo_cfs7Q5J4dCI#scrollTo=8KKzj89nfZ-9" rel="noopener ugc nofollow" target="_blank">留给笔记本</a>。</p><p id="1e88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将数据加载到熊猫数据框架后，我们可以<a class="ae ly" href="https://colab.research.google.com/drive/1VhCwtGLc-tWhB_gbGuBo_cfs7Q5J4dCI#scrollTo=j4PKi7wIfZ_L" rel="noopener ugc nofollow" target="_blank">绘制这些图层</a>:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nk"><img src="../Images/a3253142aaed4f2910d0dc164f131ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kjfe7AEqYRLmp5kJ"/></div></div></figure><h1 id="59c6" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤 3:层关联</h1><p id="fdc9" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">现在，让我们看看是否有任何层与 Django 应用程序的总体平均响应时间相关。在将每个层时间序列与响应时间进行比较之前，我们要计算每个时间序列的一阶差。对于熊猫，我们可以通过<code class="fe nl nm nn mz b">diff()</code>功能轻松做到这一点:</p><pre class="ln lo lp lq gt my mz na nb aw nc bi"><span id="aede" class="nd kp it mz b gy ne nf l ng nh">df.diff()</span></pre><p id="ac45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在计算了第一个差异之后，我们可以通过<code class="fe nl nm nn mz b">corr()</code>函数寻找每个时间序列之间的<a class="ae ly" href="https://en.wikipedia.org/wiki/Correlation_coefficient" rel="noopener ugc nofollow" target="_blank">相关性</a>。相关值的范围从 1 到+1，其中 1 表示最可能一致，0 表示最可能不一致。</p><p id="2248" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的笔记本生成了<a class="ae ly" href="https://colab.research.google.com/drive/1VhCwtGLc-tWhB_gbGuBo_cfs7Q5J4dCI#scrollTo=hwm0KcDzfZ_Z" rel="noopener ugc nofollow" target="_blank">以下结果</a>:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi no"><img src="../Images/d0f6026b701f430a5d8a383c7bd1996a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6dbNnPsm5iMdlred"/></div></div></figure><p id="6a91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nl nm nn mz b">SQL</code>似乎与 Django 应用的整体响应时间相关。可以肯定的是，我们来确定皮尔逊系数<a class="ae ly" href="http://www.eecs.qmul.ac.uk/~norman/blog_articles/p_values.pdf" rel="noopener ugc nofollow" target="_blank"> p 值。</a>低值(&lt; 0.05)表示总体响应时间很可能与 SQL 层相关:</p><pre class="ln lo lp lq gt my mz na nb aw nc bi"><span id="c4aa" class="nd kp it mz b gy ne nf l ng nh">df_diff = df.diff().dropna() p_value = scipy.stats.pearsonr(df_diff.total.values, df_diff[top_layer_correl].values)[1] print("first order series p-value:",p_value)</span></pre><p id="5801" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">p 值正好是</strong> <code class="fe nl nm nn mz b"><strong class="js iu">1.1e-54</strong></code> <strong class="js iu">。我非常确信缓慢的 SQL 查询与整体缓慢的 Django 应用程序有关。</strong>总是数据库，对吧？</p><p id="5d77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">层次只是我们应该评估的一个维度。另一个是 Django 意见的响应时间。</p><p id="7088" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果视图开始响应缓慢，应用程序的整体响应时间可能会增加。我们可以通过查看我们的视图响应时间与整体应用程序响应时间的相关性来了解这种情况是否会发生。我们使用与图层完全相同的流程，只是将图层换成 Django 应用中每个视图的时间序列数据:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi np"><img src="../Images/b1f6f4fdd089dd7bb9145300fda83c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D0IVEJy9GIRtIFh_"/></div></div></figure><p id="e1ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在计算每个时间序列的第一个差异后，<code class="fe nl nm nn mz b">apps/data</code>确实与整个 app 响应时间相关。<strong class="js iu">p 值仅为</strong> <code class="fe nl nm nn mz b"><strong class="js iu">1.64e-46</strong></code> <strong class="js iu">，</strong> <code class="fe nl nm nn mz b"><strong class="js iu">apps/data</strong></code> <strong class="js iu">极有可能与 app 整体响应时间相关。</strong></p><p id="d81b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们差不多完成了从噪音中提取信号。我们应该检查任何视图的流量是否会导致响应时间变慢。</p><h1 id="489a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤 5:冲洗+重复 Django 查看吞吐量</h1><p id="6b27" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">如果视图的吞吐量突然增加，很少使用的昂贵视图可能会影响应用程序的整体响应时间。例如，如果用户编写一个脚本来快速重新加载一个昂贵的视图，就会发生这种情况。为了确定相关性，我们将使用与之前完全相同的过程，只是交换每个 Django 视图的吞吐量时间序列数据:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nq"><img src="../Images/34d32a77e926abf22aec6f8209f84aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*USOdEfDBDRES_y-z"/></div></div></figure><p id="c05c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nl nm nn mz b">endpoints/sparkline</code>看似有小关联。p 值是<code class="fe nl nm nn mz b">0.004</code>，这意味着有 4/1000 的几率<em class="mx">不与<code class="fe nl nm nn mz b">endpoints/sparkline</code>的流量和整体应用响应时间相关。因此，<code class="fe nl nm nn mz b">endpoints/sparkline</code>视图的流量确实会导致应用程序整体响应时间变慢，但这比我们的其他两个测试更不确定。</em></p><h1 id="0681" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="5b14" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">使用数据科学，我们已经能够对比直觉多得多的时间序列指标进行排序。我们也能够在没有误导趋势搅浑水的情况下进行计算。</p><p id="ab40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们知道 Django 应用的响应时间是:</strong></p><ul class=""><li id="24bf" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn ni mf mg mh bi translated">与我们的 SQL 数据库的性能密切相关。</li><li id="e74c" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn ni mf mg mh bi translated">与我们的<code class="fe nl nm nn mz b">apps/data</code>视图的响应时间密切相关。</li><li id="5d27" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn ni mf mg mh bi translated">与<code class="fe nl nm nn mz b">endpoints/sparkline</code>流量相关。尽管我们对这种低 p 值的相关性很有信心，但它没有前两种相关性那么强。</li></ul><p id="8a94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">现在是工程师的时间了！</strong>有了这些见解，我会:</p><ul class=""><li id="0665" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn ni mf mg mh bi translated">调查数据库服务器是否受到应用程序外部的影响。例如，如果我们只有一台数据库服务器，备份过程可能会降低所有查询的速度。</li><li id="deea" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn ni mf mg mh bi translated">调查对<code class="fe nl nm nn mz b">apps/data</code>视图的请求的组成是否已经改变。例如，拥有大量数据的客户是否开始更多地使用这种视图？Scout 的<a class="ae ly" href="http://help.apm.scoutapp.com/#trace-explorer" rel="noopener ugc nofollow" target="_blank"> Trace Explorer </a>可以帮助调查这些高维数据。</li><li id="cf67" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn ni mf mg mh bi translated">推迟调查<code class="fe nl nm nn mz b">endpoints/sparkline</code>的性能，因为它与整个应用程序响应时间的相关性不是很强。</li></ul><p id="5f99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">重要的是要意识到所有来之不易的经验何时会失效。我的大脑根本无法像我们的数据科学工具那样分析成千上万的时间序列数据集。伸手拿另一个工具是可以的。</strong></p><p id="072d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想自己解决这个问题，请查看我在调查这个问题时使用的<a class="ae ly" href="https://colab.research.google.com/drive/1VhCwtGLc-tWhB_gbGuBo_cfs7Q5J4dCI" rel="noopener ugc nofollow" target="_blank">我的谷歌共享笔记本</a>。<strong class="js iu">下次您遇到性能问题时，只需从</strong> <a class="ae ly" href="https://scoutapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Scout </strong> </a> <strong class="js iu">导入您自己的数据，让笔记本为您工作！</strong></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="afea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mx">原载于</em><a class="ae ly" href="https://scoutapp.com/blog/is-your-django-app-slow-ask-a-data-scientist-not-an-engineer" rel="noopener ugc nofollow" target="_blank"><em class="mx">scoutapp.com</em></a><em class="mx">。</em></p></div></div>    
</body>
</html>