<html>
<head>
<title>Introduction to Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala 简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-scala-921fd65cd5bf?source=collection_archive---------11-----------------------#2019-08-08">https://towardsdatascience.com/introduction-to-scala-921fd65cd5bf?source=collection_archive---------11-----------------------#2019-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/27632fa093a9a8c91f6f1c37647cd865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*kz8ileuECZ9ubuwmpGUyHQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><a class="ae jy" href="https://www.slideshare.net/ViyaanJhiingade/introduction-to-scala-80328270" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="34dd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">W</span>Scala 是什么帽子？Scala 是一种高级语言，结合了函数式和面向对象编程以及高性能运行时。那么为什么要用 Scala 而不是 Python 呢？Spark 通常用于处理大数据的大多数情况。由于 Spark 是使用 Scala 构建的，因此学习它对于任何数据科学家来说都是一个很好的工具。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lg"><img src="../Images/bc803604cf875e597d9e6eb70e72225a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Mh17-YNCOiW1E6IEUaMWw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><a class="ae jy" href="http://Photo by Markus Spiske on Unsplash" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="0926" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">Scala 是一种强大的语言，可以利用许多与 Python 相同的功能，例如构建机器学习模型。我们将深入介绍 Scala，熟悉基本语法，并学习如何使用循环、映射和过滤器。在本指南中，我将使用社区版的<a class="ae jy" href="https://community.cloud.databricks.com/" rel="noopener ugc nofollow" target="_blank">databricks.com</a>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="c3bb" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">变量</h1><p id="a310" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">在 Scala 中，我们用<code class="fe mz na nb nc b">val</code>或<code class="fe mz na nb nc b">var</code>声明变量，我们将讨论两者之间的区别。值得注意的是，Scala 的语法约定是 camelCase，而 Python 在声明变量时使用 snake_case。让我们在 Scala 中创建第一个变量:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="140c" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">val</strong> counterVal = 0</span><span id="47d0" class="nh lx iq nc b gy nm nj l nk nl">counterVal: Int = 0</span></pre><p id="2552" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在让我们用<code class="fe mz na nb nc b">var</code>声明一个变量:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="b146" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">var</strong> counterVar = 0</span><span id="c117" class="nh lx iq nc b gy nm nj l nk nl">counterVar: Int = 0</span></pre><p id="501b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当我们运行细胞时，它们看起来一样，输出也一样，但它们本质上是不同的。当我们试图估算每个变量的值时，我们可以看到这一点:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="945d" class="nh lx iq nc b gy ni nj l nk nl">counterVar = 1</span><span id="774c" class="nh lx iq nc b gy nm nj l nk nl">counterVar: Int = 1</span></pre><p id="ee14" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当我们试图赋予反补贴一个新的价值时，会发生这样的情况:</p><p id="2625" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">笔记本:1:错误:重新分配到 val count val = 1 ^</p><p id="e4d7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">任何使用<code class="fe mz na nb nc b">val</code>声明的变量都是<strong class="kb ir">不可变的</strong>，<strong class="kb ir"> </strong>，因此我们不能改变它的值。当我们不希望一个变量被改变时，不管是有意还是无意，使用<code class="fe mz na nb nc b">val</code>是非常好的。例如，我们可能想用一个名字作为我们的<code class="fe mz na nb nc b">val</code>并存储它，这样就没有人能更改一个人的名字。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="11b7" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">val</strong> firstName = "John"</span><span id="e184" class="nh lx iq nc b gy nm nj l nk nl"><strong class="nc ir">val</strong> lastName = "Doe"</span><span id="900d" class="nh lx iq nc b gy nm nj l nk nl">firstName: String = John </span><span id="7c5e" class="nh lx iq nc b gy nm nj l nk nl">lastName: String = Doe</span></pre><p id="3379" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">注意，Scala 显示了我们的变量(字符串)在创建时的类型。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="8638" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">用线串</h1><p id="e303" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi translated">在 Scala 中，我们可以像在 Python 中一样处理字符串。字符串的一个常见用途是插入，这意味着在短语或句子中插入一个注释或单词。字符串插值如下所示:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="9173" class="nh lx iq nc b gy ni nj l nk nl">s"Hello, $firstName $lastName"</span><span id="4eb0" class="nh lx iq nc b gy nm nj l nk nl">res0: String = Hello, John Doe</span></pre><p id="b49c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">类似于 Python 如何使用<em class="nn"> f </em>字符串，这里我们使用<em class="nn"> s </em>。双引号在 Scala 中很重要，因为如果我们试图传递单引号，它会返回一个错误。Scala 使用<em class="nn"> $ </em>对传递到插值中的变量进行排序。请注意它是如何自动在单词之间添加空格的:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="194c" class="nh lx iq nc b gy ni nj l nk nl">s"Hello, ${firstName + lastName}"</span><span id="6418" class="nh lx iq nc b gy nm nj l nk nl">res1: String = Hello, JohnDoe</span></pre><p id="4cdd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在上面的方法中，名字和姓氏之间没有分隔。为了获得空间，我们必须明确使用:<code class="fe mz na nb nc b">${firstName + " " + lastName}"</code>。我更喜欢对每个变量使用<code class="fe mz na nb nc b">$</code>而不使用<code class="fe mz na nb nc b">{}</code>——你可以使用任何一种方法进行插值。</p><h2 id="c1fc" class="nh lx iq bd ly no np dn mc nq nr dp mg kk ns nt mk ko nu nv mo ks nw nx ms ny bi translated">字符串索引</h2><p id="3c8b" class="pw-post-body-paragraph jz ka iq kb b kc mu ke kf kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw ij bi kx translated">数据科学中最常用的技术可能是索引和使用范围。在这两种情况下，Scala 都使用了<code class="fe mz na nb nc b">.slice()</code>方法，其中第一个数字是包含性的，而最后一个数字是排他性的。让我们来看一些例子。</p><p id="1046" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">首先我创建了一个名为“fullName”的新变量。</p><p id="39e0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe mz na nb nc b">val fullName = firstName + " " + lastName</code></p><p id="d23b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在 Scala 中，我们可以简单地在变量后使用<code class="fe mz na nb nc b">()</code>来调用变量的第一个索引。</p><p id="8e6b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这将在我们的全名变量中返回<code class="fe mz na nb nc b">J</code>。为了在我们的变量中索引一个索引范围，我们需要调用<code class="fe mz na nb nc b">.slice()</code>并传入这个索引范围。</p><p id="ead7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行<code class="fe mz na nb nc b">fullName.slice(3, 6)</code>将从名字返回<code class="fe mz na nb nc b">n D</code>。Scala 包含 3，并将空间计为 4。在<code class="fe mz na nb nc b">D</code>处停止，因为设置范围时 6 是唯一的。这和其他编程语言类似。熟悉这一概念需要时间，但仍会有不正确设置范围的时候。这里需要注意的一点是，您不能索引负数。对于熟悉 Python 的人来说，使用<code class="fe mz na nb nc b">[-1]</code>会返回索引的结尾，而 Scala 会给出一个错误。超出变量范围的索引将只给出最后一个。要获得字符串的长度，请使用:<code class="fe mz na nb nc b">.length()</code>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="ff75" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">数组</h1><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nz"><img src="../Images/a6e1bada94371974e79a8dab3c67c96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTsFrFNywgcUqto8qpyKTQ.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><a class="ae jy" href="http://Photo by Glenn Carstens-Peters on Unsplash" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="9b13" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi kx translated">rrays 基本上就是 Scala 处理列表的方式。数组有类似 Python 的方法，但也有细微的差别，这使得 Scala 数组独一无二。创建数组时，请小心选择<code class="fe mz na nb nc b">var</code>,因为您可能想要更改数组值。因为数组只能改变它们的值，而不能改变数组本身的大小，所以我们将使用 ArrayBuffer 来演示。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="ffd1" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">var</strong> myArr = ArrayBuffer<strong class="nc ir">(</strong>2, 3 , 4, 5, 6<strong class="nc ir">)</strong></span><span id="de66" class="nh lx iq nc b gy nm nj l nk nl">myArr: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 3, 4, 5, 6)</span></pre><p id="b6a0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">注意，Scala 检测到我们的数组包含所有整数类型。现在我们有了一个数组，让我们来看一些例子，看看我们可以用它们做些什么。像字符串一样，我们可以对数组进行索引和切片，以查看任何给定位置的值。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="de47" class="nh lx iq nc b gy ni nj l nk nl">myArr(3)</span><span id="ee94" class="nh lx iq nc b gy nm nj l nk nl">res0: Int = 5</span><span id="5adc" class="nh lx iq nc b gy nm nj l nk nl">myArr.slice(3, 5)</span><span id="2f36" class="nh lx iq nc b gy nm nj l nk nl">res1: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(5, 6)</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="54ff" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">要向数组添加元素，使用<code class="fe mz na nb nc b">+=</code>添加一个值:</p><p id="fd49" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe mz na nb nc b">myArr += 10</code></p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="4308" class="nh lx iq nc b gy ni nj l nk nl">myArr</span><span id="a0ba" class="nh lx iq nc b gy nm nj l nk nl">res3: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 3, 4, 5, 6, 10)</span></pre><p id="4e28" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您可以看到 10 作为最后一个元素被添加到数组中。我们也可以用类似的方式删除一个项目:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="2b0e" class="nh lx iq nc b gy ni nj l nk nl">myArr -= 10</span><span id="8bd3" class="nh lx iq nc b gy nm nj l nk nl">myArr</span><span id="ac0e" class="nh lx iq nc b gy nm nj l nk nl">res7: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(2, 3, 4, 5, 6)</span></pre><p id="5084" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">要从列表中删除多个元素，我们需要像这样使用<code class="fe mz na nb nc b">()</code>:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="5a68" class="nh lx iq nc b gy ni nj l nk nl">myArr -= (2, 4)</span><span id="c168" class="nh lx iq nc b gy nm nj l nk nl">myArr</span><span id="57a4" class="nh lx iq nc b gy nm nj l nk nl">res8: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(3, 5, 6)</span></pre><p id="a096" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">通过索引删除元素可以使用<code class="fe mz na nb nc b">.remove(x)</code>方法完成，只需用<code class="fe mz na nb nc b">x</code>输入想要删除的索引。您还可以向该方法传递一个范围来移除该范围内的索引:<code class="fe mz na nb nc b">.remove(0, 3)</code>将移除索引元素 0 和 2。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h2 id="a6ec" class="nh lx iq bd ly no np dn mc nq nr dp mg kk ns nt mk ko nu nv mo ks nw nx ms ny bi translated">映射和过滤</h2><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oa"><img src="../Images/6da31d4faa02b63e443e8a715ff65ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZZfWFK50fIjaEcPhILOog.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><a class="ae jy" href="http://Photo by Tyler Nix on Unsplash" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="962f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi kx translated">我们经常想要过滤列表中的元素或者映射它们。在我们看这些之前，先看看我们如何在 Scala 中使用循环来遍历数组。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="f6e2" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">for</strong> (n &lt;- myArr) {<br/>  <strong class="nc ir">println</strong>(n)<br/>}</span><span id="a294" class="nh lx iq nc b gy nm nj l nk nl">3 5 6</span></pre><p id="c273" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">上面的代码将运行一个 for 循环，遍历数组中的每个元素，并打印出数组中的每个元素。<code class="fe mz na nb nc b">&lt;-</code>的使用告诉 Scala 我们想要迭代<code class="fe mz na nb nc b">myArr</code> print <code class="fe mz na nb nc b">n</code>中的<code class="fe mz na nb nc b">myArr</code>和<code class="fe mz na nb nc b">for</code>每个<code class="fe mz na nb nc b">n</code>(元素)。缩进是不必要的，因为使用<code class="fe mz na nb nc b">{}</code>将表示代码块的开始和结束。</p><p id="07c1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">Mapping 将遍历列表中的每一项，并将其转换为不同的元素。如果我们想一次改变数组中的所有值，这很好。</p><p id="5682" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这里我们将使用<code class="fe mz na nb nc b">.map()</code>方法将<code class="fe mz na nb nc b">myArr</code>中的每个元素乘以 5:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="ea18" class="nh lx iq nc b gy ni nj l nk nl">myArr.map<strong class="nc ir">(</strong>n =&gt; n * 5<strong class="nc ir">)</strong></span><span id="35f2" class="nh lx iq nc b gy nm nj l nk nl">res22: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(15, 25, 30)</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="3658" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi kx translated">如果满足我们设定的标准或条件，过滤将返回原始数据或数组的子集。很多时候，我们希望使用 filter 来获取数据或在数组或数据集中找到某些元素。我想把<code class="fe mz na nb nc b">myArr</code>过滤掉，这样它只会返回能被 2 整除的数字。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="a27f" class="nh lx iq nc b gy ni nj l nk nl">myArr.filter(n =&gt; n % 2 == 0)</span><span id="0bfe" class="nh lx iq nc b gy nm nj l nk nl">res26: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(6)</span></pre><p id="c282" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">上面的代码迭代<code class="fe mz na nb nc b">myArr</code>，返回能被 2 整除的数(基本上是偶数)。我们还可以将映射和过滤结合在一起，以增加我们的列表并检查偶数。实际上，我会在<code class="fe mz na nb nc b">myArr</code>上随机添加一些数字，这样我们就可以让它变得有趣！</p><p id="148f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这里，我们将多个元素追加到数组中:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="e8a2" class="nh lx iq nc b gy ni nj l nk nl">myArr += <strong class="nc ir">(</strong>10, 3, 7, 5, 12, 20<strong class="nc ir">)</strong></span><span id="ce72" class="nh lx iq nc b gy nm nj l nk nl">res30: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(3, 5, 6, 10, 3, 7, 5, 12, 20)</span></pre><p id="2263" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在我们将把映射和过滤结合起来返回<code class="fe mz na nb nc b">myArr</code>中的偶数:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="5f32" class="nh lx iq nc b gy ni nj l nk nl">myArr.map(n =&gt; n * 5).filter<strong class="nc ir">(</strong>n =&gt; n % 2 == 0<strong class="nc ir">)</strong></span><span id="b6c7" class="nh lx iq nc b gy nm nj l nk nl">res31: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(30, 50, 60, 100)</span></pre><p id="3b92" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们也可以对奇数做同样的事情，把<code class="fe mz na nb nc b">n % 2 == 0</code>改成<code class="fe mz na nb nc b">n % 3 == 0</code>。</p><p id="e4ac" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">映射和过滤对于数据科学工作流至关重要，这项技术在我们每次处理数据集时都会用到。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="88a7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">Scala 是我们作为数据科学家的一个很好的工具。我们可以用它来处理数据和建立机器学习模型。对 Scala 的介绍只涵盖了最基本的内容。现在该由您来深入研究这种语言了。</p></div></div>    
</body>
</html>