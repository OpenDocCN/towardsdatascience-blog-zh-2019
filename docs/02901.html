<html>
<head>
<title>Implementing a Data Warehouse with Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Django 实现数据仓库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-data-warehouse-with-django-e4856c92f146?source=collection_archive---------2-----------------------#2019-05-11">https://towardsdatascience.com/implementing-a-data-warehouse-with-django-e4856c92f146?source=collection_archive---------2-----------------------#2019-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/215a6c59a2780ff4aa5a33294569edd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kZO8kBIc4hQPRYS-Q47nQ.jpeg"/></div></div></figure><p id="1f8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将介绍如何利用 Django 及其 rest 框架来实现数据仓库。我们将特别关注来自外部 API 的数据源，但是同样的原则也适用于任何其他类型的数据源:平面文件或直接 ODBC 连接。</p><p id="cc41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用 Django 实现数据仓库的一个主要好处是，您将能够使用 Python 处理任何组件或任务:ETL、查询、数据操作、报告、web 应用程序应用程序…</p><p id="2c58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，Django 可能不适合您的用例，但是同样的原则也适用。</p><p id="5ee4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文使用的所有代码都可以在<a class="ae kz" href="https://github.com/aalepere/djangowarehouse" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="99fc" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">什么是数据仓库？</h2><p id="4e99" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">数据仓库的实现通常是为了整合整个公司的不同数据源。在我们的案例中，我们使用不同的外部和内部 API 来整合所有这些信息，以便进行分析、报告和预测建模。</p><p id="97d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主要挑战是将不同来源的数据提取、转换和加载为一种通用格式，并能够跟踪数据随时间的变化。</p><p id="1ee7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将在下面的章节中详细介绍这些挑战。</p><h2 id="9807" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">Django 和 rest 框架</h2><p id="587b" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">Django 是开源的 web 框架模板；并遵循模型、视图、模板(MVT)设计模式。</p><p id="f2db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将主要关注 Django 架构的模型组件。为了能够与数据库交互，Django 使用了对象关系映射器；这意味着它们将被表示为 Python 类，而不是使用 SQL 表。这意味着我们可以使用 Python 执行任何 CRUD 操作，而无需直接与 SQL 或数据库本身进行交互。<br/>这将是我们数据仓库实现的关键，因为我们将利用这个 ORM 来执行插入和更新。</p><p id="bc87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Rest-Framework 是 Django 生态系统的一部分，是创建 web APIs 的有用工具包。<br/>我们将使用的框架组件称为序列化器；它允许将复杂的数据结构序列化为一个呈现的 JSON(典型的 GET 请求)，还允许在首先验证传入的数据(也称为反序列化)之后解析要转换回复杂类型的数据。<br/>这在我们的情况下将非常有用，因为我们可以利用反序列化来确保信息以正确的格式出现，并且我们可以将每个元素映射到数据仓库中的正确字段。<br/>-<a class="ae kz" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank">https://www.djangoproject.com/</a><br/>-<a class="ae kz" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank">https://www.django-rest-framework.org/</a></p><h2 id="d6d1" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">基本模型</h2><p id="a507" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">一旦我们创建了 Django 项目和应用程序(<a class="ae kz" href="https://docs.djangoproject.com/en/2.1/intro/tutorial01/" rel="noopener ugc nofollow" target="_blank">https://docs.djangoproject.com/en/2.1/intro/tutorial01/</a>)；我们现在可以创建我们的模型了。</p><p id="9946" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ly"> Models.py </em>将包含所有允许 Django ORM 与数据库交互的逻辑；<em class="ly"> models.py </em>中的每个类都是数据库中的一个物理表。</p><p id="f4ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们将创建 3 个表:<br/>-<em class="ly">Person</em>；通过名字和姓氏<br/> - <em class="ly">车辆</em>唯一识别的自然人的实例；通过其注册号<br/> - <em class="ly">人员车辆</em>唯一识别的车辆；一个人拥有车辆的例子</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b16c" class="la lb it me b gy mi mj l mk ml">from <strong class="me iu">django.db </strong>import <strong class="me iu">models</strong></span><span id="d76d" class="la lb it me b gy mm mj l mk ml">class <strong class="me iu">Person</strong>(models.Model):<br/> <em class="ly">“”” Person class identifies a unique physical person by its first name, last name and email “””</em></span><span id="1a34" class="la lb it me b gy mm mj l mk ml">created_at = models.DateTimeField(auto_now_add=True)<br/> updated_at = models.DateTimeField(auto_now=True)<br/> first_name = models.CharField(max_length=100)<br/> last_name = models.CharField(max_length=100)<br/> email = models.CharField(max_length=100)</span><span id="6c4e" class="la lb it me b gy mm mj l mk ml">def __str__(self):<br/> return “{} {}”.format(self.first_name, self.last_name)</span><span id="67ba" class="la lb it me b gy mm mj l mk ml">class <strong class="me iu">Vehicle</strong>(models.Model):<br/> <em class="ly">“”” Vehicle class uniquely with the registration plate number “””</em></span><span id="81be" class="la lb it me b gy mm mj l mk ml">created_at = models.DateTimeField(auto_now_add=True)<br/> updated_at = models.DateTimeField(auto_now=True)<br/> registration_plate = models.CharField(max_length=100)</span><span id="d1b6" class="la lb it me b gy mm mj l mk ml">def __str__(self):<br/> return self.registration_plate</span><span id="c3dc" class="la lb it me b gy mm mj l mk ml">class <strong class="me iu">PersonVehicle</strong>(models.Model):<br/> <em class="ly">“”” PersonVehicle register the relationship between a vehicle in a person,<br/> in other words, the owner of the vehicle at a given point in time “””</em></span><span id="86dd" class="la lb it me b gy mm mj l mk ml">created_at = models.DateTimeField(auto_now_add=True)<br/> updated_at = models.DateTimeField(auto_now=True)<br/> vehicle = models.ForeignKey(Vehicle, on_delete=models.PROTECT)<br/> person = models.ForeignKey(Person, on_delete=models.PROTECT)</span><span id="3114" class="la lb it me b gy mm mj l mk ml">def __str__(self):<br/> return “{} {}”.format(self.vehicle, self.person)</span></pre><p id="cc5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ly"> created_at </em>、<em class="ly"> updated_at </em>是两个自动生成的字段，将记录创建或更新记录的日期时间。</p><p id="3eca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ly">保护</em>将禁止删除任何与其他表有关系的记录。如果您希望删除与该记录相关的所有记录，也可以使用<em class="ly">级联</em>。</p><p id="a898" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经创建了我们的模型，我们可以通过 Django shell ( <em class="ly">)插入信息。/manage.py shell </em>):</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/394e61f7c77c79562ec0a8770a372d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqm7bDbJJ858Ap_ZSNDeQA.png"/></div></div></figure><h2 id="ea55" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">跟踪更改</h2><p id="0916" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">为了能够跟踪随时间的变化，我们将使用<em class="ly">简单历史</em>；它允许在每次创建/更新/删除时存储 Django 模型状态:<a class="ae kz" href="https://django-simple-history.readthedocs.io/en/2.7.0/" rel="noopener ugc nofollow" target="_blank">https://django-simple-history.readthedocs.io/en/2.7.0/</a></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7efe" class="la lb it me b gy mi mj l mk ml">from django.db import models<br/>from <strong class="me iu">simple_history.models</strong> import <strong class="me iu">HistoricalRecords</strong></span><span id="be27" class="la lb it me b gy mm mj l mk ml">class Person(models.Model):<br/> <em class="ly">“”” Person class identifies a unique physical person by its first name, last name and email “””</em></span><span id="48a2" class="la lb it me b gy mm mj l mk ml">created_at = models.DateTimeField(auto_now_add=True)<br/> updated_at = models.DateTimeField(auto_now=True)<br/> first_name = models.CharField(max_length=100)<br/> last_name = models.CharField(max_length=100)<br/> email = models.CharField(max_length=100)<br/> <strong class="me iu">history = HistoricalRecords()</strong></span><span id="9005" class="la lb it me b gy mm mj l mk ml">class Meta:<br/> <strong class="me iu">unique_together = ((“first_name”, “last_name”),)</strong></span><span id="d465" class="la lb it me b gy mm mj l mk ml">def __str__(self):<br/> return “{} {}”.format(self.first_name, self.last_name)</span><span id="0b3b" class="la lb it me b gy mm mj l mk ml">class Vehicle(models.Model):<br/> <em class="ly">“”” Vehicle class uniquely with the registration plate number “””</em></span><span id="ab4f" class="la lb it me b gy mm mj l mk ml">created_at = models.DateTimeField(auto_now_add=True)<br/> updated_at = models.DateTimeField(auto_now=True)<br/> registration_plate = models.CharField(max_length=100)</span><span id="a369" class="la lb it me b gy mm mj l mk ml">def __str__(self):<br/> return self.registration_plate</span><span id="f5a2" class="la lb it me b gy mm mj l mk ml">class PersonVehicle(models.Model):<br/> <em class="ly">“”” PersonVehicle register the relationship between a vehicle in a person,<br/> in other words, the owner of the vehicle at a given point in time “””</em></span><span id="5ea4" class="la lb it me b gy mm mj l mk ml">created_at = models.DateTimeField(auto_now_add=True)<br/> updated_at = models.DateTimeField(auto_now=True)<br/> vehicle = models.ForeignKey(Vehicle, on_delete=models.PROTECT)<br/> person = models.ForeignKey(Person, on_delete=models.PROTECT)<br/> <strong class="me iu">history = HistoricalRecords()</strong></span><span id="2d8b" class="la lb it me b gy mm mj l mk ml">class Meta:<br/> <strong class="me iu">unique_together = ((“vehicle”),)</strong></span><span id="1d72" class="la lb it me b gy mm mj l mk ml">def __str__(self):<br/> return “{} {}”.format(self.vehicle, self.person)<br/>```</span></pre><p id="0d23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们在每个模型中添加了字段<em class="ly"> history </em>，以便跟踪随时间的变化。这些更改将存储在前缀为<em class="ly">历史</em>的镜像表中。</p><p id="09d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了能够跟踪变更，我们还需要定义<em class="ly">代理键，</em>这些键是记录唯一性的业务定义。例如，在<em class="ly"> Person </em>表中，我们将<em class="ly"> first_name </em>和<em class="ly"> last_name </em>定义为<em class="ly"> unique_together </em>，这意味着这些字段将不可更新，但是<em class="ly"> email </em>是可更新的。</p><p id="8a72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们尝试修改我们之前记录的记录:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/6420586a70a064efc40fbc444421d155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bF4gGaaf8KpjaIBSPExfrg.png"/></div></div></figure><p id="2d13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看一下历史表，看看这些变化是如何记录的:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/239413297e8cc6c571a7bd09325c87d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ue6pq_rInf6tK2w6-ESK6A.png"/></div></div></figure><h2 id="adc8" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">序列化程序</h2><p id="62b3" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">如前所述，在将输入数据插入相关的 SQL 表之前，将使用序列化程序来解析和验证输入数据。</p><p id="5ac2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们假设一个外部源通过 REST API 以下面的 JSON 格式向我们提供信息:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/b3ab2ba89f8c86e04fc1340481ccc5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fzq4tC6a3C1IJnIEABdIww.png"/></div></div></figure><p id="96af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JSON 提供了此人的身份和当前属于此人的车辆列表，以下是将用于解析此 JSON 的序列化程序:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="aa82" class="la lb it me b gy mi mj l mk ml">from <strong class="me iu">rest_framework</strong> import <strong class="me iu">serializers</strong></span><span id="1795" class="la lb it me b gy mm mj l mk ml">from dwh_app_simple_history.models import Person, PersonVehicle, Vehicle</span><span id="db70" class="la lb it me b gy mm mj l mk ml">class <strong class="me iu">VehicleSerializer</strong>(serializers.Serializer):<br/> <em class="ly">“””<br/> Nested serializer within the JSON source; in this example all vehicles that belong to the<br/> person nested in the JON as a list of all active vehicles.<br/> “””</em></span><span id="48cd" class="la lb it me b gy mm mj l mk ml">registration_plate = serializers.CharField(max_length=100)</span><span id="8f01" class="la lb it me b gy mm mj l mk ml">class <strong class="me iu">PersonVehicleSerializer</strong>(serializers.Serializer):<br/> <em class="ly">“””<br/> Serializer that will be used to deserialize the json to be then imported in the datawarehouse<br/> “””</em></span><span id="7cc0" class="la lb it me b gy mm mj l mk ml">first_name = serializers.CharField(max_length=100)<br/> last_name = serializers.CharField(max_length=100)<br/> email = serializers.CharField(max_length=100)<br/> vehicles = VehicleSerializer(many=True)</span><span id="2781" class="la lb it me b gy mm mj l mk ml">def <strong class="me iu">save</strong>(self):<br/> <em class="ly">“””<br/> Overwrite the save function on the serializer to be able to control how we want to<br/> insert/update the data provided by the source in our datawarehouse.<br/> “””</em></span><span id="6ef1" class="la lb it me b gy mm mj l mk ml"># First update or create the person<br/> person_obj, created = <strong class="me iu">Person.objects.update_or_create</strong>(<br/> first_name=self.validated_data[“first_name”],<br/> last_name=self.validated_data[“last_name”],<br/> defaults={“email”: self.validated_data[“email”]},<br/> )</span><span id="991c" class="la lb it me b gy mm mj l mk ml"># Then create each Vehicle and link it to the person created before<br/> for vehicle in self.validated_data[“vehicles”]:<br/> vehicle_obj, created =  <strong class="me iu">Vehicle.objects.get_or_create</strong>(registration_plate=vehicle[“registration_plate”])<br/> <br/>personvehicle_obj, created = <strong class="me iu">PersonVehicle.objects.update_or_create</strong>(<br/> vehicle=vehicle_obj, defaults={“person”: person_obj}<br/> )</span></pre><p id="2d2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建了一个嵌套的序列化器<em class="ly"> VehicleSerializer </em>来解析一辆车的实例，然后在父序列化器<em class="ly"> PersonVehicleSerializer </em>中，我们可以使用参数<em class="ly"> many=True </em>来告诉 Django 它们可以是多辆车。</p><p id="5010" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了正确保存所有信息，我们重写了<em class="ly"> save() </em>方法，首先我们创建或更新<em class="ly"> Person </em>，然后为嵌套字典中的每辆车创建一个<em class="ly"> Vehicle </em>，然后将它链接到<em class="ly"> PersonVehicle </em>中的<em class="ly"> Person </em>。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/063bb3146129677fb2d03f18eb6c0fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgFuHwmwEzxz_M5BIQFpsg.png"/></div></div></figure><p id="2cc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，如果需要，可以通过添加验证或转换规则来丰富序列化程序，就像在传统的 ETL 实现中一样。</p><h2 id="4f00" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">视图</h2><p id="fd7a" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在前面的例子中，我们使用 JSON 文件和 Django shell 将数据插入到我们的数据仓库中。</p><p id="e159" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们假设信息不是由外部提供者提供的，而是公司架构的源系统向数据仓库发送信息。这可以通过添加一个允许通过一个<em class="ly"> POST </em> API 请求插入数据的<em class="ly">视图</em>来实现。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d06e" class="la lb it me b gy mi mj l mk ml">from django.shortcuts import render<br/>from <strong class="me iu">rest_framework.decorators</strong> import <strong class="me iu">api_view</strong><br/>from <strong class="me iu">rest_framework.response</strong> import <strong class="me iu">Response</strong></span><span id="ce21" class="la lb it me b gy mm mj l mk ml">from dwh_app_simple_history.serializers import <strong class="me iu">PersonVehicleSerializer</strong></span><span id="c93e" class="la lb it me b gy mm mj l mk ml"><a class="ae kz" href="http://twitter.com/api_view" rel="noopener ugc nofollow" target="_blank">@api_view</a>([“<strong class="me iu">POST</strong>”])<br/>def PersonVehicle(request):<br/> <em class="ly">“””<br/> This view will be called through a POST request to add or update the information provided in<br/> the request<br/> “””</em></span><span id="aace" class="la lb it me b gy mm mj l mk ml"># Deserialize the information provided in the request<br/> ser = PersonVehicleSerializer(data=request.data)</span><span id="4701" class="la lb it me b gy mm mj l mk ml"># Validate the information provided<br/> ser.is_valid(raise_exception=True)</span><span id="53bf" class="la lb it me b gy mm mj l mk ml"># Save the information in the datawarehouse<br/> ser.save()</span><span id="b9d5" class="la lb it me b gy mm mj l mk ml">return Response({“All good, everything has been saved”})</span></pre><p id="1589" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，我们使用了与 Django shell 中相同的序列，但是使用了<em class="ly"> api_view </em> decorator 将这个端点暴露给另一个系统或用户。这意味着我们现在可以从任何系统与我们的数据仓库通信(您需要确保您的 Django 服务器正在运行)。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/1f26deafa49d2b639a639842329c5bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ig_9IqhaRqWWiPm2Ix4TOw.png"/></div></div></figure><h2 id="a45f" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">结论</h2><p id="759c" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在本文中，我们已经介绍了使用 Django 构建数据仓库的所有步骤和组件:<br/>——使用 Django ORM 创建第三范式数据模型；<br/> -使用简单的历史记录来跟踪随时间的变化；<br/> -使用 serializer rest 框架对来自外部提供者或内部系统的信息进行反序列化，并将结果保存在数据仓库中；和<br/>——使用来自 rest 框架的视图，允许源系统通过 POST 请求发送信息。</p><p id="9fc4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上所有内容应该为构建您的数据仓库提供了足够的信息，当然，您必须浏览所有不同的来源，了解数据将如何在下游以最有效的方式建模数据，并在您的 ETL 中添加所有转换/验证规则。</p></div></div>    
</body>
</html>