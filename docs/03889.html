<html>
<head>
<title>Programmatically Build REGEX (Regular Expression) in Python for Pattern Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以编程方式在 Python 中构建 REGEX(正则表达式)用于模式匹配</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/programmatically-build-regex-regular-expression-in-python-for-pattern-matching-3fee104fe42a?source=collection_archive---------8-----------------------#2019-06-19">https://towardsdatascience.com/programmatically-build-regex-regular-expression-in-python-for-pattern-matching-3fee104fe42a?source=collection_archive---------8-----------------------#2019-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bb2d46f5e341431a5198cf7da9b730a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96GelVDLLfmroQ2DfLPDOw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@atgranberry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Aidan Granberry</a> on <a class="ae kc" href="https://unsplash.com/search/photos/letters-computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3575" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您准备进行文本分析或自然语言处理时，正则表达式(Regex——通常读作<code class="fe lb lc ld le b">ri-je-x</code>或<code class="fe lb lc ld le b">reg-x</code>)非常有用。尽管 Regex 很有用，但它也非常令人困惑和难以理解，并且总是需要(至少对我来说)多次<a class="ae kc" href="https://duckduckgo.com/" rel="noopener ugc nofollow" target="_blank">点击并返回到多个堆栈溢出链接。</a></p><p id="0601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先:</p><h2 id="f341" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">什么是 Regex</h2><blockquote class="ly lz ma"><p id="e518" class="kd ke mb kf b kg kh ki kj kk kl km kn mc kp kq kr md kt ku kv me kx ky kz la ij bi translated">根据维基百科，一个<strong class="kf ir">正则表达式</strong>、<strong class="kf ir"> regex </strong>或<strong class="kf ir"> regexp </strong>是定义一个<em class="iq">搜索模式</em>的字符序列。</p></blockquote><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/ea269f9867596597c6af74c9760a657d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LXBrPhMAWeoDpO8c"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image Courtesy: <a class="ae kc" href="https://comidoc.com/master-regular-expressions-python-examples/" rel="noopener ugc nofollow" target="_blank">comidoc.com</a></figcaption></figure><h2 id="dcae" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">看起来怎么样？</h2><p id="da6c" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这是测试 URL 有效性的正则表达式模式:</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="cf00" class="lf lg iq le b gy mt mu l mv mw">^(http)(s)?(\:\/\/)(www\.)?([^\ ]*)$</span></pre><p id="ddd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">典型的正则表达式包含—字符(<code class="fe lb lc ld le b">http</code>)和元字符(<code class="fe lb lc ld le b">[]</code>)。这两者的结合形成了特定任务的有意义的正则表达式。</p><h2 id="b05e" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">那么，有什么问题呢？</h2><p id="57cd" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">记住字符和元字符的组合方式来创建一个有意义的正则表达式本身就是一个乏味的任务，有时比 NLP 的实际问题更大。事实上，这推动了迷因世界和互联网上的卡通节目。像这样:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/db14b0cf3fbea8b58a887778713354fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*fFwkj3yMSn-ifgv2"/></div></figure><h2 id="d2ff" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">手边的解决方案</h2><p id="79d5" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这个星球上的一些好人已经创建了一个开源的 Javascript 库<a class="ae kc" href="https://github.com/VerbalExpressions/JSVerbalExpressions" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">JSVerbalExpressions</strong></a>来简化正则表达式的创建。然后其他一些优秀的灵魂将 javascript 库移植到 Python 上—<a class="ae kc" href="https://github.com/VerbalExpressions/PythonVerbalExpressions" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">Python verbalexressions</strong></a>。这就是开源世界的美妙之处。抱歉我离题了，但我想提出一个观点。</p><h2 id="ebcd" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">安装—python verbalexceptions</h2><p id="0e23" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">基于您所拥有的 Python 版本，您可以使用 pip 安装 PythonVerbalExpressions。</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="a480" class="lf lg iq le b gy mt mu l mv mw">pip3 install VerbalExpressions</span></pre><h2 id="41c1" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">导入并启动</h2><p id="ba79" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">就像 ML 库<code class="fe lb lc ld le b">scikit-learn</code>如何使用一个基本的构造函数并在其上构建一样，<em class="mb"> VerbalExpressions </em>遵循类似的 API 语法。</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="1d1b" class="lf lg iq le b gy mt mu l mv mw">from verbalexpressions import VerEx<br/>verEx = VerEx()</span></pre><h2 id="64cf" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><strong class="ak">伪问题</strong></h2><p id="6a5a" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们创建一个伪问题，我们希望用 regex 来解决它，通过它我们可以理解这个包，以编程方式创建 regex。</p><p id="19b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更简单的例子，我们有多个这样的文本:</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="c55e" class="lf lg iq le b gy mt mu l mv mw">strings = ['123Abdul233',<br/>           '233Raja434',<br/>           '223Ethan Hunt444']</span></pre><p id="0d54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想从中提取名字。所以我们的结果应该是:</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="26a8" class="lf lg iq le b gy mt mu l mv mw">Abdul, Raja, Ethan Hunt</span></pre><h2 id="7c62" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">伪代码</h2><p id="c903" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在我们编码之前，最好在一张餐巾纸甚至一张纸上写下伪代码。也就是说，我们希望提取除数字(即数字)之外的名称(即字母的组合)。我们为一行代码构建一个正则表达式，然后为列表中的所有元素迭代它。</p><h2 id="a1b9" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">该表达式</h2><p id="9bd2" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们使用<code class="fe lb lc ld le b">range()</code>函数来表示给定范围内的任何内容。</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="7563" class="lf lg iq le b gy mt mu l mv mw">expression = verEx.range('a','z','A','Z',' ')</span></pre><p id="fbdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个表达式中，来自<code class="fe lb lc ld le b">a-z</code>或<code class="fe lb lc ld le b">A-Z</code>或<code class="fe lb lc ld le b">whitespace</code>的任何东西(空白:因为<code class="fe lb lc ld le b">Ethan Hunt</code>)。</p><p id="6854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解 python 代码如何实际转换成 regex 模式:</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="8a38" class="lf lg iq le b gy mt mu l mv mw">expression.source()</span><span id="2599" class="lf lg iq le b gy my mu l mv mw">#output: '([a-zA-Z\\ ])'</span></pre><h2 id="30fd" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">寻找和寻找</h2><p id="6b6c" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在表达式已经准备好了，我们可以用它以多种方式查找所需的子字符串。在这里，我们将求助于 Python 库中的任何 regex <code class="fe lb lc ld le b">re</code>。因为我们要处理<code class="fe lb lc ld le b">re</code>，我们将编译为<code class="fe lb lc ld le b">re</code>构建的<code class="fe lb lc ld le b">expression</code>。</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="1c3f" class="lf lg iq le b gy mt mu l mv mw">import re</span><span id="b9fd" class="lf lg iq le b gy my mu l mv mw">re_exp = expression.compile()</span></pre><p id="6ef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，<code class="fe lb lc ld le b">re</code>编译已经完成。我们将使用那个<code class="fe lb lc ld le b">re_exp</code>在一行中测试这个正则表达式(输入列表的一个元素)。</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="5fca" class="lf lg iq le b gy mt mu l mv mw">re.findall(re_exp,strings[0])</span><span id="6f41" class="lf lg iq le b gy my mu l mv mw">#output: ['A', 'b', 'd', 'u', 'l']</span></pre><p id="493c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是有前途的！让我们使用我们的字符串连接和 for 循环技巧来完成我们的伪问题！</p><pre class="mg mh mi mj gt mp le mq mr aw ms bi"><span id="48cc" class="lf lg iq le b gy mt mu l mv mw">[''.join(re.findall(re_exp,line)) for line in strings]</span><span id="3045" class="lf lg iq le b gy my mu l mv mw">#output: ['Abdul', 'Raja', 'Ethan Hunt']</span></pre><h2 id="b3af" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">结束了</h2><p id="9e7d" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">因此，我们设法在不了解正则表达式的情况下构建了正则表达式模式。简而言之，我们使用 Python 以编程方式生成了一个正则表达式模式(这不需要正则表达式模式的高级知识),并完成了一个小任务来展示其潜力。这里需要注意的是，这个 Python 包<code class="fe lb lc ld le b">VerbalExpressions</code>没有来自其父库<code class="fe lb lc ld le b">javascript</code>的所有函数，所以功能是有限的。要了解更多关于使用 Python 的 Regex 的信息，请查看这个 Datacamp 课程。完整的代码可在<a class="ae kc" href="https://github.com/amrrs/blogpost_codes/blob/master/Build%20REGEX%20Python%20for%20Pattern%C2%A0Matching.py" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div></div>    
</body>
</html>