<html>
<head>
<title>Pandas’ groupby explained in detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫小组详细解释了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-groupby-aggregate-transform-filter-c95ba3444bbb?source=collection_archive---------0-----------------------#2019-11-12">https://towardsdatascience.com/pandas-groupby-aggregate-transform-filter-c95ba3444bbb?source=collection_archive---------0-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4d85" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">熊猫终极指南</h2><div class=""/><div class=""><h2 id="ef23" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何掌握所有 Pandas 的 groupby 功能，如聚集、转换和过滤——这是一份附有大量示例的代码指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7000bf860d83631838a8a7dd8fd1a5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6d5dw6dPhy4vBp2vRW6uzw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk"><a class="ae lh" href="https://www.economist.com/china/2016/09/08/survival-of-the-cutest" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="890c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">写关于熊猫的文章是最好的。我最喜欢的部分是当我在网上搜索可爱的熊猫图片的时候。Cmon 你怎么能不爱熊猫呢？还有成群的熊猫，更好！反正我跑题了…</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0d07" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">介绍</h1><p id="07cc" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi me translated">andas 的 groupby 无疑是熊猫带来的最强大的功能之一。然而，<strong class="lk jd">大多数用户只利用了</strong> <code class="fe nr ns nt nu b"><strong class="lk jd">groupby</strong></code>的一小部分功能。</p><p id="164c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nr ns nt nu b">Groupby</code>允许对数据集采用拆分-应用-组合的方法。这种方法通常用于对数据进行分割，以便数据分析师可以回答特定的问题。</p><h2 id="4f62" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">在高级分组上，by 允许:</h2><ol class=""><li id="7302" class="og oh it lk b ll nm lo nn lr oi lv oj lz ok md ol om on oo bi translated">根据列/条件将数据分成组；</li><li id="4574" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">对所有组应用函数/变换，并将结果组合成输出</li></ol><h2 id="4179" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">在本文中，我们将讨论以下主题:</h2><ol class=""><li id="3bd1" class="og oh it lk b ll nm lo nn lr oi lv oj lz ok md ol om on oo bi translated"><a class="ae lh" href="#08dc" rel="noopener ugc nofollow">加载数据</a></li><li id="fc9a" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated"><a class="ae lh" href="#3a1f" rel="noopener ugc nofollow">分组依据—拆分数据</a></li><li id="f9f2" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated"><a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">应用并组合— </a> <code class="fe nr ns nt nu b"><a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">apply</a></code> <a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">，</a> <code class="fe nr ns nt nu b"><a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">agg(regate)</a></code> <a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">，</a> <code class="fe nr ns nt nu b"><a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">transform</a></code> <a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">，</a> <code class="fe nr ns nt nu b"><a class="ae lh" href="#d6c9" rel="noopener ugc nofollow">filter</a></code></li></ol><p id="47d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里找到完整的 Jupyter 笔记本。但是我强烈建议您亲自完成这些步骤。毕竟，熟能生巧。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="08dc" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">①加载数据</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/9d43ec413213993003f79a19ec4bde88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UlhZFIMA35p62wGP"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NASA</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="696f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">我们将使用一个假设的销售部门的数据。数据集由虚构的销售代表、订单线索、可能达成交易的公司、订单价值和线索日期等列组成。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="7f21" class="nv mv it nu b gy oz pa l pb pc">order_leads = pd.read_csv(<br/>    '<a class="ae lh" href="https://raw.githubusercontent.com/FBosler/Medium-Data-Exploration/master/order_leads.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/Medium-Data-Exploration/master/order_leads.csv'</a>,<br/>    parse_dates = [3]<br/>)<br/>sales_team = pd.read_csv(<br/>    '<a class="ae lh" href="https://raw.githubusercontent.com/FBosler/Medium-Data-Exploration/master/sales_team.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/Medium-Data-Exploration/master/sales_team.csv'</a>,<br/>    parse_dates = [3]<br/>)</span><span id="792a" class="nv mv it nu b gy pd pa l pb pc">df = pd.merge(<br/>  order_leads,<br/>  sales_team,<br/>  on=['Company Id','Company Name']<br/>)</span><span id="3ad0" class="nv mv it nu b gy pd pa l pb pc">df = df.rename(<br/>  columns={'Order Value':'Val','Converted':'Sale'}<br/>)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/5b4b5e8b95d7ca4e44a3789ecc63809d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdVezf0wUdENHwU3oFK3lw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">100k rows of order lead data</figcaption></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3a1f" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">②分组依据——拆分数据</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/629e6ee302d9f1441656d4eafab1c246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBETIXH-vrY2xgTxvoSDMQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@chris23?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Chris Child</a> on <a class="ae lh" href="https://unsplash.com/s/photos/splitting-wood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bc58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">调用 groupby 的默认方法是通过显式提供一个列名来拆分数据集。但是，还有一点不太为人所知，那就是您也可以将一个系列传递给 groupby。唯一的限制是序列的长度与数据帧的长度相同。<br/>能够传递一个序列意味着您可以根据一个列的处理版本进行分组，而不必为此创建一个新的帮助列。</p><h2 id="d4c6" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按销售代表分组</h2><p id="69c3" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">首先，让我们创建一个分组的数据框架，即将数据集拆分。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="ad01" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>grouped = df.groupby('Sales Rep')<br/>grouped</span><span id="4f3b" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x12464a160&gt;</span><span id="ff60" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">IN:<br/></strong>type(grouped)</span><span id="5596" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>pandas.core.groupby.generic.DataFrameGroupBy</span></pre><p id="b580" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在已经创建了一个<code class="fe nr ns nt nu b"><strong class="lk jd">DataFrameGroupBy</strong></code>对象。让我们进一步调查:</p><h2 id="0a81" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">显示所有组</h2><p id="d092" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在分组对象上调用<code class="fe nr ns nt nu b">groups</code>会返回每个组的索引列表(因为每一行都可以通过其索引唯一地标识)</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="0943" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:<br/></strong>grouped.groups</span><span id="a20f" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>{<br/><strong class="nu jd">'Aaron Hendrickson'</strong>: Int64Index(<br/>[25612, 25613, 25614, 25615, 25616, 25617, 25618, 25619, 25620, 25621,..., 25894, 25895, 25896, 25897, 25898, 25899, 25900, 25901, 25902, 25903], dtype='int64', length=292<br/>),</span><span id="ec2f" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">'Adam Sawyer'</strong>: Int64Index(<br/>[67140, 67141, 67142, 67143, 67144, 67145, 67146, 67147, 67148, 67149, ..., 67454, 67455, 67456, 67457, 67458, 67459, 67460, 67461, 67462, 67463], dtype='int64', length=324<br/>),</span><span id="27b3" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">...</strong></span><span id="0e58" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">'Yvonne Lindsey'</strong>: Int64Index([20384, 20385, 20386, 20387, 20388, 20389, 20390, 20391, 20392, 20393, 20394, 20395, 20396, 20397, 20398, 20399, 20400, 20401, ... , 20447, 20448, 20449, 20450], dtype='int64', length=67)<br/>}</span></pre><h2 id="c01f" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">选择特定的组</h2><p id="9489" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">通过用组名调用<code class="fe nr ns nt nu b">get_group</code>，我们可以返回各自的数据子集。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="624f" class="nv mv it nu b gy oz pa l pb pc">grouped.get_group('Aaron Hendrickson')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/f1109d380358bccb613aa9e256402704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Drwub3OL7kekJ-V921Svkw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">‘Aaron Hendrickson’ group</figcaption></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="e560" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了演示一些高级分组功能，我们将通过<code class="fe nr ns nt nu b">size</code>方法使用 apply 步骤的最简单版本(并计算每个组中的行数)。我们这样做是为了将重点放在 groupby 操作上。</p><p id="8b7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将在文章的第 2 部分更详细地讨论应用方法。</p><h2 id="b73f" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">计算每组中的行数</h2><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="1666" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:<br/></strong>grouped.size()</span><span id="5f7f" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Sales Rep<br/>Aaron Hendrickson    292<br/>Adam Sawyer          324<br/>Adele Kimmel         115<br/>Adrian Daugherty     369<br/>Adrianna Shelton      37<br/>                    ... <br/>Willie Lin            44<br/>Willie Rau            95<br/>Willie Sanchez       309<br/>Yvonne Jones          74<br/>Yvonne Lindsey        67<br/>Length: 499, dtype: int64</span></pre><h2 id="b084" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按销售代表的名字分组</h2><p id="074d" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">下面是第一个例子，我们根据一个现有列的变化进行分组。我发现这比一直创建助手列有了很大的改进。它只是让数据更干净。</p><p id="1a66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，我们使用一个字符串访问器来检索名字。你可以在这里阅读访问器<a class="ae lh" rel="noopener" target="_blank" href="/learn-advanced-features-for-pythons-main-data-analysis-library-in-20-minutes-d0eedd90d086#cfea"/>。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="8e84" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(<br/>  df['Sales Rep'].str.split(' ').str[0]<br/>).size()</span><span id="a7c4" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Sales Rep<br/>Aaron        292<br/>Adam         324<br/>Adele        115<br/>Adrian       369<br/>Adrianna      37<br/>            ... <br/>Wesley       144<br/>Wilbert      213<br/>William     1393 <strong class="nu jd"><em class="ph"># Plenty of Williams</em></strong><br/>Willie       448<br/>Yvonne       141<br/>Length: 318, dtype: int64</span></pre><h2 id="8e5e" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">根据代表姓名中是否有“William”进行分组</h2><p id="5246" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">我们看到似乎有很多 Williams，让我们将所有名字中有 William 的销售代表分组。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="ef91" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:<br/></strong>df.groupby(<br/>  df['Sales Rep'].apply(lambda x: 'William' in x)<br/>).size()</span><span id="a817" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Sales Rep<br/>False    97111<br/>True      2889<br/>dtype: int64</span></pre><h2 id="149d" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按随机系列分组(仅供说明)</h2><p id="b9be" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">不可否认，这个例子很傻，但是它说明了你可以很好地按照任意序列进行分组。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="7060" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:<br/></strong>df.groupby(<br/>    pd.Series(np.random.choice(list('ABCDG'),len(df)))<br/>).size()</span><span id="fa9c" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>A    19895<br/>B    20114<br/>C    19894<br/>D    20108<br/>G    19989<br/>dtype: int64</span></pre><h2 id="0950" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">通过三个均匀切割的“Val”桶进行分组</h2><p id="8281" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在下面的例子中，我们首先将<code class="fe nr ns nt nu b">qcut</code>应用于一个数字列。<code class="fe nr ns nt nu b">qcut</code>将数据平均分配到固定数量的箱中。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="7dd5" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(<br/>  pd.qcut(<br/>    x=df['Val'],<br/>    q=3,<br/>    labels=['low','mid','high']<br/>  )<br/>).size()</span><span id="9b48" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Val<br/>low     33339<br/>mid     33336<br/>high    33325<br/>dtype: int64</span></pre><h2 id="206a" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按定制大小的“有值”存储桶分组</h2><p id="1318" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">像前面的例子一样，我们将数据分配到桶中。然而，这一次我们也指定了容器的边界。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="7530" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(<br/>  pd.cut(<br/>    df['Val'],<br/>    [0,3000,5000,7000,10000]<br/>  )<br/>).size()</span><span id="0410" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Val<br/>(0, 3000]        29220<br/>(3000, 5000]     19892<br/>(5000, 7000]     20359<br/>(7000, 10000]    30529<br/>dtype: int64</span></pre><h1 id="3410" class="mu mv it bd mw mx pi mz na nb pj nd ne ki pk kj ng kl pl km ni ko pm kp nk nl bi translated"><code class="fe nr ns nt nu b">pd.Grouper</code></h1><p id="c98a" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">pd.Grouper</strong></code>重要！这个方法花了我很长时间才学会，因为它在处理时间序列数据时非常有用。</p><h2 id="8952" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按年份分组</h2><p id="437b" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在下面的例子中，我们将使用<code class="fe nr ns nt nu b">pd.Grouper(key=&lt;INPUT COLUMN&gt;, freq=&lt;DESIRED FREQUENCY&gt;)</code>根据指定列的指定频率对数据进行分组。在我们的例子中，频率是<code class="fe nr ns nt nu b">'Y'</code>，相关列是<code class="fe nr ns nt nu b">'Date'</code>。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="da31" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(<br/>  pd.Grouper(<br/>    key='Date',<br/><strong class="nu jd">    </strong>freq='Y'<strong class="nu jd"><br/>  </strong>)<br/>).size()</span><span id="0cee" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Date<br/>2014-12-31    19956<br/>2015-12-31    20054<br/>2016-12-31    20133<br/>2017-12-31    20079<br/>2018-12-31    19778<br/>Freq: A-DEC, dtype: int64</span></pre><h2 id="46ac" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按四分之一或其他频率分组</h2><p id="5940" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">代替<code class="fe nr ns nt nu b">'Y'</code>，我们可以使用不同的标准频率，如<code class="fe nr ns nt nu b">'D','W','M', or 'Q'</code>。有关不常用频率的列表，请查阅<a class="ae lh" href="http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases" rel="noopener ugc nofollow" target="_blank">文档</a>。<br/>我发现<code class="fe nr ns nt nu b">'SM'</code>的半月末频率(15 日和月末)是一个有趣的频率。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="61e2" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(pd.Grouper(key='Date',freq='Q')).size()</span><span id="166d" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Date<br/>2014-03-31    4949<br/>2014-06-30    4948<br/>2014-09-30    4986<br/>2014-12-31    5073<br/>2015-03-31    4958<br/>2015-06-30    4968<br/>2015-09-30    5109<br/>2015-12-31    5019<br/>2016-03-31    5064<br/>2016-06-30    4892<br/>2016-09-30    5148<br/>2016-12-31    5029<br/>2017-03-31    4959<br/>2017-06-30    5102<br/>2017-09-30    5077<br/>2017-12-31    4941<br/>2018-03-31    4889<br/>2018-06-30    4939<br/>2018-09-30    4975<br/>2018-12-31    4975<br/>Freq: Q-DEC, dtype: int64</span></pre><h2 id="ef1c" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">按多列分组</h2><p id="8aec" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">到目前为止，我们只按一个列或转换进行了分组。当我们想要通过多个列或转换进行分组时，同样的逻辑也适用。我们要做的就是传递一个列表给<code class="fe nr ns nt nu b">groupby</code>。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="d853" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(['Sales Rep','Company Name']).size()</span><span id="53ef" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Sales Rep          Company Name               <br/>Aaron Hendrickson  6-Foot Homosexuals             20<br/>                   63D House'S                    27<br/>                   Angular Liberalism             28<br/>                   Boon Blish'S                   18<br/>                   Business-Like Structures       21<br/>                                                  ..<br/>Yvonne Jones       Entry-Limiting Westinghouse    20<br/>                   Intractable Fairgoers          18<br/>                   Smarter Java                   17<br/>Yvonne Lindsey     Meretricious Fabrication       28<br/>                   Shrill Co-Op                   39<br/>Length: 4619, dtype: int64</span></pre><p id="95ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随机的名字，我发誓！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d6c9" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">③应用并组合— <code class="fe nr ns nt nu b">apply</code>、<code class="fe nr ns nt nu b">agg(regate)</code>、<code class="fe nr ns nt nu b">transform</code>和<code class="fe nr ns nt nu b">filter</code></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/cdbc2734991f15300c0723ace0233ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybLDn8JZ0u8ysrIY8pAyDw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@andrewwelch3?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">andrew welch</a> on <a class="ae lh" href="https://unsplash.com/s/photos/glue-together?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ed14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">在前面的章节中，我们讨论了如何根据各种条件对数据进行分组。本节讨论在将它们组合成最终结果之前，我们可以应用于这些组的可用函数。</span></p><h2 id="3867" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">本节围绕如何使用</h2><p id="04c1" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">🅐 <code class="fe nr ns nt nu b">apply</code>、<br/> 🅑 <code class="fe nr ns nt nu b">agg(regate)</code>、<br/> 🅒 <code class="fe nr ns nt nu b">transform</code>、<br/> 🅓 <code class="fe nr ns nt nu b">filter</code></p><p id="b251" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你在我开始使用 groupby 时和我一样，你可能正在使用🅐和🅑的组合，大致如下:</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="bec7" class="nv mv it nu b gy oz pa l pb pc">grouped = df.groupby('GROUP') and then:<br/>- group.apply(mean)<br/>- group.agg(mean)<br/>- group['INTERSTING COLUMN'].apply(mean)<br/>- group.agg({'INTERSTING COLUMN':mean})<br/>- group.mean()</span></pre><p id="2e3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中<code class="fe nr ns nt nu b">mean</code>也可以是另一个函数。</p><p id="64ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好消息是，它们全都有效。大多数时候，结果会和你预期的差不多。</p><p id="e2dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">坏消息:apply 和 agg 都有值得深究的细微差别。</p><p id="2621" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，更重要的是，两个鲜为人知的强大功能可以用在一个分组对象上，<code class="fe nr ns nt nu b">filter</code>和<code class="fe nr ns nt nu b">transform</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="3a99" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">🅐·阿普申:让我们把阿普申弄清楚</h2><p id="5abe" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">Apply 有点令人困惑，因为我们经常谈论应用函数，而实际上也有应用函数。但是请原谅我。<code class="fe nr ns nt nu b">apply</code>函数沿数据帧的轴应用一个函数。应用程序可以是按列或按行的。<br/> <code class="fe nr ns nt nu b">apply</code>严格来说并不是一个只能在 groupby 上下文中使用的函数。您还可以在完整的数据帧上使用<code class="fe nr ns nt nu b">apply</code>，如下例所示(我们使用<code class="fe nr ns nt nu b">_</code>作为抛弃变量)。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="9577" class="nv mv it nu b gy oz pa l pb pc">_ = pd.DataFrame(<br/>    np.random.random((2,6)),<br/>    columns=list('ABCDEF')<br/>)<br/>_</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/8fe5bf9ff447fb4146a56b667d9edd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*MwTlm5i9vL0uNmbgP86eJQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Random DataFrame with six columns</figcaption></figure><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="76a1" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>_.apply(sum, axis=0) <strong class="nu jd"><em class="ph"># axis=0 is default, so you could drop it</em></strong></span><span id="2dfd" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>A    0.620289<br/>B    0.818850<br/>C    0.672706<br/>D    1.269064<br/>E    1.156606<br/>F    0.934941<br/>dtype: float64</span><span id="0134" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">IN:<br/></strong>_.apply(sum, axis=1)</span><span id="ee08" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>0    2.868145<br/>1    2.604311<br/>dtype: float64</span></pre><p id="beea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是<code class="fe nr ns nt nu b">apply</code>也可以用在 groupby 上下文中。这很有意义，因为每个组本身就是一个更小的数据框架。请记住，该函数将应用于整个数据帧。将该函数应用于整个数据帧通常意味着您想要选择使用函数的列。我们将把它留在下面的两个例子中，而是集中在<code class="fe nr ns nt nu b">agg(regation)</code>上，这是聚合组的“预期”方式。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="07e7" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby(<br/>    pd.Grouper(key='Date',freq='Y')<br/>)['Sale'].apply(sum)</span><span id="e261" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Date<br/>2014-12-31    3681<br/>2015-12-31    3800<br/>2016-12-31    3881<br/>2017-12-31    3068<br/>2018-12-31    2478<br/>Freq: A-DEC, Name: Sale, dtype: int64</span><span id="2b1d" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">IN:<br/></strong>df.groupby(<br/>    pd.Grouper(key='Date',freq='Y')<br/>)['Val','Sale'].apply(sum)</span><span id="5283" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>Date       Val       Sale<br/>2014-12-31 100422394 3681<br/>2015-12-31 101724648 3800<br/>2016-12-31 101789642 3881<br/>2017-12-31 101957784 3068<br/>2018-12-31 100399962 2478</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="2398" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">🅑·阿格(雷加特)</h2><p id="5c3d" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">请注意<code class="fe nr ns nt nu b">agg</code>和<code class="fe nr ns nt nu b">aggregate</code>可以互换使用。<code class="fe nr ns nt nu b">agg</code>更短，所以我将继续使用它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/0b6b87fbb4e09376004f93a22882abc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTlC_t-5RQqeqS0tcbkCKQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Visualization of a typical split-apply-combine process with multiple aggregations functions that are being applied to each group individually</figcaption></figure><p id="f28d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总的来说，聚合是其中最强大的。让我们仔细分析上面的图像，主要关注这个过程的右边部分。下面的代码片段创建了上图的放大版本。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="c9d7" class="nv mv it nu b gy oz pa l pb pc">df.groupby('Sales Rep').agg({ <br/>    'Order Id':'size',<br/>    'Val':['sum','mean'],<br/>    'Sale':['sum','mean']<br/>})</span></pre><p id="a8fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将一个字典传递给聚合函数，其中键(即<code class="fe nr ns nt nu b">Order Id</code>、<code class="fe nr ns nt nu b">Val</code>、<code class="fe nr ns nt nu b">Sale</code>)是列，值(<code class="fe nr ns nt nu b">'size'</code>、<code class="fe nr ns nt nu b">['sum','mean']</code>、<code class="fe nr ns nt nu b">['sum','mean']</code>)是应用于各个列的函数。</p><p id="de1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，函数可以是单个函数，也可以是函数列表(所有函数都将被应用)。另外，请注意<code class="fe nr ns nt nu b">agg</code>可以使用函数名(即字符串)或实际函数(即 Python 对象)。在这里可以找到功能的非详尽列表<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#descriptive-statistics" rel="noopener ugc nofollow" target="_blank">。我最常用的是:</a></p><ul class=""><li id="8911" class="og oh it lk b ll lm lo lp lr pq lv pr lz ps md pt om on oo bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">'size'</strong></code> <strong class="lk jd"> : </strong>统计行数</li><li id="86ed" class="og oh it lk b ll op lo oq lr or lv os lz ot md pt om on oo bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">'sum'</strong></code> <strong class="lk jd"> : </strong>向上对列求和</li><li id="f03f" class="og oh it lk b ll op lo oq lr or lv os lz ot md pt om on oo bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">'mean'/'median'</strong></code> <strong class="lk jd"> : </strong>列的平均值/中值</li><li id="971f" class="og oh it lk b ll op lo oq lr or lv os lz ot md pt om on oo bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">'max'/'min'</strong></code> <strong class="lk jd"> : </strong>列的最大值/最小值</li><li id="4a33" class="og oh it lk b ll op lo oq lr or lv os lz ot md pt om on oo bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">'idxmax'/'idxmin'</strong></code> <strong class="lk jd"> : </strong>列的最大值/最小值索引。获取最小值或最大值的索引有助于映射其他列，例如，每个销售代表的最大交易的公司名称是什么</li><li id="19a1" class="og oh it lk b ll op lo oq lr or lv os lz ot md pt om on oo bi translated"><code class="fe nr ns nt nu b"><strong class="lk jd">pd.Series.nunique</strong></code> <strong class="lk jd"> : </strong>统计唯一值。注意，与前面的函数不同，这是一个实际的函数，而不是一个字符串。</li></ul><h2 id="902c" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">警察。NamedAgg</h2><p id="8929" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">现在，当以这种方式将多个聚合函数应用于多个列时，一个问题是结果会变得有点混乱，并且无法控制列名。在过去，我经常发现自己聚集了一个数据帧，然后直接重命名结果。我总觉得那有点低效。</p><p id="1acb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像这样的情况正是<code class="fe nr ns nt nu b">pd.NamedAgg</code>派上用场的时候。<code class="fe nr ns nt nu b">pd.NamedAgg</code>是在 Pandas 版本 0.25 中引入的，允许指定目标列的名称。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="4950" class="nv mv it nu b gy oz pa l pb pc">def cr(x):<br/>    return round(np.mean(x),2)</span><span id="086d" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd"># Long Form: Explictly specifying the NamedAgg</strong><br/>aggregation = {<br/>    'Potential Sales': pd.NamedAgg(column='Val', aggfunc='size'),<br/>    'Sales': pd.NamedAgg(column='Sale', aggfunc='sum'),<br/>    'Conversion Rate': pd.NamedAgg(column='Sale', aggfunc=cr)<br/>}</span><span id="da01" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd"># Alternative: Since the NamedAgg is just a tuple, we can also pass regular tuples</strong><br/>aggregation = {<br/>    'Potential Sales': ('Val','size'),<br/>    'Sales': ('Sale','sum'),<br/>    'Conversion Rate': ('Sale',cr)<br/>}</span><span id="b604" class="nv mv it nu b gy pd pa l pb pc">df.groupby('Sales Rep').agg(**aggregation)</span></pre><p id="917d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行上面的代码片段会导致:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/054853fb594b487be7cef1bde39cbe9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*3yQ0e29L1-ZUy3xJXK9hSw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Result of aggregation with built-in renaming of columns</figcaption></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="167e" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">🅒 <code class="fe nr ns nt nu b">transform</code></h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/a4877ef7dbf3baf368e88ff0c57e4205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxdhr6i-jlzeex7f5RkIlw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Visualization of a typical split-apply-combine process with transform being applied to the ‘Val’ column. Transform sums up the column on a group level and assigns the summed value back to every row.</figcaption></figure><p id="d6d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">agg 返回输入的简化版本，而 transform 返回完整数据的组级转换版本的。新输出数据的长度与输入数据的长度相同。对于来自 SQL 的用户，可以将 transform 看作一个窗口函数。</p><p id="bdd9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个典型的例子是通过除以组间总和来获得组总数的百分比。</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="c8c4" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/>df.groupby('Sales Rep')['Val'].transform(lambda x: x/sum(x))</span><span id="d94d" class="nv mv it nu b gy pd pa l pb pc"><strong class="nu jd">OUT:<br/></strong>0        0.004991<br/>1        0.005693<br/>2        0.003976<br/>3        0.000799<br/>4        0.003300<br/>           ...   <br/>99995    0.012088<br/>99996    0.000711<br/>99997    0.013741<br/>99998    0.010695<br/>99999    0.001533<br/>Name: Val, Length: 100000, dtype: float64</span></pre><p id="e13a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与<code class="fe nr ns nt nu b">agg</code>不同，<code class="fe nr ns nt nu b">transform</code>通常通过将结果分配给新列来使用。在上面的例子中，我们可以:</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="6798" class="nv mv it nu b gy oz pa l pb pc">df['%'] = df.groupby('Sales Rep')['Val'].transform(<br/>  lambda x: x/sum(x)<br/>)</span></pre><p id="0b53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">查看这篇文章，学习如何使用<code class="fe nr ns nt nu b">transform</code>来删除丢失的值。</p><div class="pw px gp gr py pz"><a rel="noopener follow" target="_blank" href="/using-pandas-transform-and-apply-to-deal-with-missing-data-on-a-group-level-cb6ccf060531"><div class="qa ab fo"><div class="qb ab qc cl cj qd"><h2 class="bd jd gy z fp qe fr fs qf fu fw jc bi translated">使用 Panda 的“转换”和“应用”在组级别处理缺失数据</h2><div class="qg l"><h3 class="bd b gy z fp qe fr fs qf fu fw dk translated">了解当您不想简单地丢弃丢失的数据时应该怎么做。</h3></div><div class="qh l"><p class="bd b dl z fp qe fr fs qf fu fw dk translated">towardsdatascience.com</p></div></div><div class="qi l"><div class="qj l qk ql qm qi qn lb pz"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="ab98" class="nv mv it bd mw nw nx dn na ny nz dp ne lr oa ob ng lv oc od ni lz oe of nk iz bi translated">🅓 <code class="fe nr ns nt nu b">filter</code></h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/7b845699e119eacb31337a946009ec39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDZgurT8zja-u77DW758KQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Visualization of a typical split-apply-combine process with the filter being applied to the ‘Sale’ column. The specified filter is used on a group level and will only leave groups with at least one Sale.</figcaption></figure><p id="c37a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顾名思义，Filter 不以任何方式改变数据，而是选择数据的子集。对于来自 SQL 的用户，可以把 filter 看作 HAVING 条件。</p><p id="0347" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，我们可以筛选所有至少赚了 20 万英镑的销售代表</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="40ef" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:<br/></strong>df.groupby('Sales Rep').filter(<br/>  lambda x: (x['Val'] * x['Sale']).sum() &gt; 200000<br/>)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/7a2690e5a103e6e3906b48e8ed8f6626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vis_mI0UDZ8elAoSPnApww.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Filtered DataFrame — Condition: Realized Sales &gt; 200k</figcaption></figure><p id="388c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者转化率&gt; 30%的所有销售代表:</p><pre class="ks kt ku kv gt ov nu ow ox aw oy bi"><span id="b8d7" class="nv mv it nu b gy oz pa l pb pc"><strong class="nu jd">IN:</strong><br/><strong class="nu jd"># Let's add this for verification</strong><br/>df['cr'] = df.groupby('Sales Rep')['Sale'].transform('mean')</span><span id="2a43" class="nv mv it nu b gy pd pa l pb pc">df.groupby('Sales Rep').filter(lambda x: x['Sale'].mean() &gt; .3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/418e12612a9afa05784da9fbf86f0035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfVSE2X5pc0JUVJjeeBcCg.png"/></div></div></figure><h1 id="a7f5" class="mu mv it bd mw mx pi mz na nb pj nd ne ki pk kj ng kl pl km ni ko pm kp nk nl bi translated">结束语</h1><p id="b587" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在本文中，您学习了如何像真正的熊猫专家一样对数据帧进行分组。您学习了许多对数据进行分组的方法。你学会了区分<code class="fe nr ns nt nu b">apply</code>和<code class="fe nr ns nt nu b">agg</code>。您学习并应用了最常见的聚合函数。你已经看到了不常用的<code class="fe nr ns nt nu b">transform</code>和<code class="fe nr ns nt nu b">filter</code>派上了用场。</p><p id="3635" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">想聊天请登陆<a class="ae lh" href="https://www.linkedin.com/in/fbosler/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>！我很乐意和你谈谈，或者回答你可能有的任何问题。</p><p id="d979" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，看看我在 Medium 上写的其他文章</p><p id="79b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">干得好，感谢您的阅读！</p></div></div>    
</body>
</html>