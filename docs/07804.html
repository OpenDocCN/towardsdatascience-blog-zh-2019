<html>
<head>
<title>My Favorite New Features in Python 3.8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.8 中我最喜欢的新特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/my-favorite-new-features-in-python-3-8-a95d7a0a31c9?source=collection_archive---------8-----------------------#2019-10-29">https://towardsdatascience.com/my-favorite-new-features-in-python-3-8-a95d7a0a31c9?source=collection_archive---------8-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c7a036023185cb59b36e2b355f5f2df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrK1VuTTMSg-zL9-z3ohQQ.png"/></div></div></figure><p id="2857" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python 3.8 在几周前发布，我没有急于谈论新特性，而是决定熟悉它们并加以利用，我想指出的是，我绝对会使用 Python 3 中实现的一些关键特性。不管这些新特性是否会被使用取决于程序员，但是我认为熟悉这些新特性是很重要的，这样我们就可以阅读 Python 之后的文章。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="46c4" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">海象操作数</h1><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/fb87bc0a11cb5759ecb336a9d6bc8128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*5qz5RNtVzRr0JpA2zbwfGw.jpeg"/></div></div></figure><p id="9651" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将以我最喜欢的新功能开始，</p><blockquote class="mj"><p id="2799" class="mk ml it bd mm mn mo mp mq mr ms ky dk translated">海象操作数</p></blockquote><p id="6a35" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">为什么这么叫？因为操作数看起来像一头侧翻的海象。这不仅是在 while 循环中使用的好工具，就像 Python 文档中的例子一样:</p><pre class="mf mg mh mi gt my mz na nb aw nc bi"><span id="d2da" class="nd lh it mz b gy ne nf l ng nh">while (line := file.readline()) != "end":<br/>    print(chunk)</span></pre><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/6ff02ce75782390734950d558f46f5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ohh2Wa3V3Iq8bojiut352A.png"/></div></div></figure><p id="77eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，对我来说更重要的是，Walrus 操作数具有在一行中返回和设置的优势，换句话说，我们可以在统计函数的末尾保存一个返回，例如，在最后一次计算时，只需使用 Walrus 操作数。</p><pre class="mf mg mh mi gt my mz na nb aw nc bi"><span id="d543" class="nd lh it mz b gy ne nf l ng nh">x  = 5<br/>y = 5<br/>b := y+b</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9280" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">仅位置参数</h1><p id="af0b" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">不那么花哨，但这也是一个很大的变化，不会影响函数参数的经典性质。要创建一个位置参数，我们只需要在定义函数时在参数的末尾添加一个斜杠。</p><pre class="mf mg mh mi gt my mz na nb aw nc bi"><span id="2601" class="nd lh it mz b gy ne nf l ng nh">def func(x,y,f=5,/):</span></pre><p id="6d36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以使用 f 等于σx+σy 的函数，如下所示:</p><pre class="mf mg mh mi gt my mz na nb aw nc bi"><span id="4d23" class="nd lh it mz b gy ne nf l ng nh">result = func(x,y,ournum = sum(x) + sum(y))</span></pre><p id="cc4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而在以前，我们必须添加更多的结构来实现这一点。</p><pre class="mf mg mh mi gt my mz na nb aw nc bi"><span id="e7ea" class="nd lh it mz b gy ne nf l ng nh">ournum = sum(x) + sum(y)<br/>result = func(x,y,ournum)</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e8cf" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">多重处理共享存储器</h1><p id="7704" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">共享内存归结为在整个 Python 中全局共享数据，而不是手动提取和传输数据，或者将其保存到文件中以供访问，现在可以使用多处理模型在 Python 内部跨位置全局访问数据，这将我们带入下一个添加内容，</p><h1 id="0ba5" class="lg lh it bd li lj no ll lm ln np lp lq lr nq lt lu lv nr lx ly lz ns mb mc md bi translated">新的酸洗协议</h1><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9b326a4b8e719dd298848581083199cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*0Lai5CY2T6TxQZEvVbdslw.jpeg"/></div></figure><p id="9cbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">pickle 是一个压缩和序列化数据和代码以在其他地方使用的出色工具，随着 Pickle 模块 Python 的新增加，您可以 Pickle 的序列化效率更高，通用性更强，这对于数据科学领域的我们来说非常令人兴奋，对于那些在 Flask 和 Django 中工作并且 VPS web 服务器上剩余空间有限的人来说，这绝对是一项值得贡献的事业。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6731" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">CPython —改进了！</h1><p id="8b0d" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">最后但同样重要的是，Python 吹嘘他们已经改进了 Python 的基于 C 引擎的后端，这是另一个我认为肯定需要注意的特性。作为一名数据科学家，我经常发现自己在处理数据时碰到了 Python 的极限，这很不幸，但确实存在。当仅仅读入数据就使 Jupyter 内核崩溃，并且您正准备尝试为所述数据安装一个管道时，这可能是很可怕的。</p><p id="ebfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好消息是，情况正在好转，并且有望在未来继续好转。当然，我们指的是 C API 中的 Python，而不是 Python 中的 Python，或者只是普通的 Python。当处理绝对庞大的数据集时，在没有配置上述 API 的情况下运行 Python 常常是一场噩梦。</p><p id="9289" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对我们来说更幸运的是，CPython 还做了一些工作来改进其 API 的配置，这是令人兴奋的，因为这将使优化更容易，并且很可能允许新用户使用 Python 中的 C 引擎。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="1e73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我真的希望 Python 在未来几年继续关注稳定性、速度和效率。这些改进虽然看起来很小，但肯定是一个大胆的方向，并且执行得很好，尤其是我一直很喜欢的东西。这些是我最喜欢的功能，但还增加了一些功能，包括:</p><ul class=""><li id="76ab" class="nu nv it kd b ke kf ki kj km nw kq nx ku ny ky nz oa ob oc bi translated">性能改进(针对原始 Python 本身)</li><li id="c9f1" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">可逆词典</li><li id="f297" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">打字模块返工</li><li id="14ae" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">f 字符串调试支持</li></ul><p id="ab4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些都是 Python 世界中受欢迎的进步，特别是对于那些处理大型数据集和修改内存限制的人来说。</p></div></div>    
</body>
</html>