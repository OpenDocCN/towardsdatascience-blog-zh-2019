<html>
<head>
<title>ML basics: Loan prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML 基础:贷款预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ml-basics-loan-prediction-d695ba7f31f6?source=collection_archive---------2-----------------------#2019-06-06">https://towardsdatascience.com/ml-basics-loan-prediction-d695ba7f31f6?source=collection_archive---------2-----------------------#2019-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d50a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个简单问题的完整数据科学管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dc66e8eba0a44e138bb2bbe5cebc874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eC1EUwoo6rMOypir"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@wildbook?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dmitry Demidko</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d8a0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">问题是:</h1><p id="9c1b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">梦想住房金融公司处理所有房屋贷款。他们遍布所有城市、半城市和农村地区。在公司确认客户贷款资格后，客户首先申请住房贷款。</p><p id="0a71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该公司希望根据填写在线申请表时提供的客户详细信息自动执行贷款资格流程(实时)。这些详细信息包括性别、婚姻状况、教育程度、受抚养人人数、收入、贷款金额、信用记录等。为了实现这一过程的自动化，他们提出了一个问题来确定客户群，即那些有资格获得贷款金额的客户，以便他们可以专门针对这些客户。</p><p id="7577" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一个分类问题，给定关于申请的信息，我们必须预测他们是否会偿还贷款。</p><p id="1d81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将从探索性数据分析开始，然后是预处理，最后我们将测试不同的模型，如逻辑回归和决策树。</p><p id="dac0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该数据由以下行组成:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0fa6" class="mx la it mt b gy my mz l na nb"><strong class="mt iu">Loan_ID : </strong>Unique Loan ID</span><span id="e1b4" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Gender : </strong>Male/ Female</span><span id="e280" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Married : </strong>Applicant married (Y/N)</span><span id="391c" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Dependents : </strong>Number of dependents </span><span id="315b" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Education : </strong>Applicant Education (Graduate/ Under Graduate)</span><span id="5035" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Self_Employed : </strong>Self employed (Y/N)</span><span id="6e7f" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">ApplicantIncome : </strong>Applicant income</span><span id="6a2b" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">CoapplicantIncome : </strong>Coapplicant income</span><span id="b489" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">LoanAmount : </strong>Loan amount in thousands of dollars</span><span id="62a6" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Loan_Amount_Term : </strong>Term of loan in months</span><span id="5fbe" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Credit_History : </strong>credit history meets guidelines yes or no</span><span id="11a9" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Property_Area : </strong>Urban/ Semi Urban/ Rural</span><span id="9db0" class="mx la it mt b gy nc mz l na nb"><strong class="mt iu">Loan_Status : </strong>Loan approved (Y/N) this is the target variable</span></pre><h1 id="9ed3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">探索性数据分析:</h1><p id="3bfb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用 seaborn 进行可视化，使用 pandas 进行数据处理。可以从这里下载数据集:<a class="ae ky" href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/" rel="noopener ugc nofollow" target="_blank">https://data hack . analyticsvidhya . com/contest/practice-problem-loan-prediction-iii/</a></p><p id="240d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将导入必要的库并加载数据:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="62ff" class="mx la it mt b gy my mz l na nb">import matplotlib.pyplot as plt<br/>import pandas as pd<br/>import seaborn as sns<br/>%matplotlib inline<br/>import numpy as np</span><span id="6470" class="mx la it mt b gy nc mz l na nb">train=pd.read_csv("train.csv")<br/>test=pd.read_csv("test.csv")</span></pre><p id="23b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用 head 函数来查看顶部的几行</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3970" class="mx la it mt b gy my mz l na nb">train.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b44686084823953259e9b9323ad69860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZr5Mmbw9vErMiEkWGlsPA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author</figcaption></figure><p id="1c03" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以看到有一些缺失的数据，我们可以使用 pandas describe 函数进一步探究这一点:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b24f" class="mx la it mt b gy my mz l na nb">train.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/90a108ba59d4486d2086f4d60c0bd378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v90EnHnMdSz5LjunB0o3Sg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author</figcaption></figure><p id="4a22" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一些变量有缺失值，我们必须处理，而且申请人收入、共同申请人收入和贷款金额似乎也有一些异常值。我们也看到大约 84%的申请者有信用记录。因为 Credit_History 字段的平均值为 0.84，并且它有两个值(1 表示有信用记录，0 表示没有)</p><p id="450e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">研究数字变量(主要是申请人收入和贷款金额)的分布是很有趣的。为此，我们将使用 seaborn 进行可视化。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="50aa" class="mx la it mt b gy my mz l na nb">sns.distplot(train.ApplicantIncome,kde=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/2e649c93423982e32096c22ed06f8d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*I13ZNw8VWHEitAIVSq6_ug.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author</figcaption></figure><p id="141e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">分布是偏斜的，我们可以注意到相当多的异常值。</p><p id="e388" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于贷款金额有缺失值，我们不能直接绘制它。一种解决方案是删除缺失的值行，然后绘制它，我们可以使用 dropna 函数来实现</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="32c6" class="mx la it mt b gy my mz l na nb">sns.distplot(train.ApplicantIncome.dropna(),kde=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/51ded9c9780f793325ae4d66e1b3a1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*NrCGWURr4W9Xjw7PBxcbEA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author</figcaption></figure><p id="cbbb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">受过良好教育的人通常应该有较高的收入，我们可以通过绘制教育水平与收入的关系来验证这一点。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6d72" class="mx la it mt b gy my mz l na nb">sns.boxplot(x='Education',y='ApplicantIncome',data=train)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a18f5f94432becde89f19e1aa197072b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*SzZv-uwE6H3FNv8gqB4IIQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author</figcaption></figure><p id="d96a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">分布非常相似，但我们可以看到毕业生有更多的离群值，这意味着高收入的人最有可能受过良好的教育。</p><p id="6157" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个有趣的变量是信用历史，为了检查它如何影响贷款状态，我们可以将其转换为二进制，然后计算信用历史每个值的平均值。接近 1 的值表示贷款成功率高</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7cea" class="mx la it mt b gy my mz l na nb">#turn loan status into binary <br/>modified=train<br/>modified['Loan_Status']=train['Loan_Status'].apply(lambda x: 0 if x=="N" else 1 )<br/>#calculate the mean<br/>modified.groupby('Credit_History').mean()['Loan_Status']</span><span id="fca2" class="mx la it mt b gy nc mz l na nb">OUT : <br/>Credit_History<br/>0.0    0.078652<br/>1.0    0.795789<br/>Name: Loan_Status, dtype: float64</span></pre><p id="00ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有信用记录的人更有可能还贷，比例为 0.07 比 0.79。这意味着信用历史将是我们模型中的一个有影响的变量。</p><h1 id="6575" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据预处理:</h1><p id="eb15" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先要做的是处理缺失值，让我们先检查每个变量有多少个缺失值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5e8e" class="mx la it mt b gy my mz l na nb">train.apply(lambda x: sum(x.isnull()),axis=0)<br/>OUT:<br/>Loan_ID               0<br/>Gender               13<br/>Married               3<br/>Dependents           15<br/>Education             0<br/>Self_Employed        32<br/>ApplicantIncome       0<br/>CoapplicantIncome     0<br/>LoanAmount           22<br/>Loan_Amount_Term     14<br/>Credit_History       50<br/>Property_Area         0<br/>Loan_Status           0<br/>dtype: int64</span></pre><p id="4939" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于数值，一个好的解决方案是用平均值填充缺失值，对于分类，我们可以用众数(出现频率最高的值)填充它们</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f217" class="mx la it mt b gy my mz l na nb">#categorical<br/>train['Gender'].fillna(train['Gender'].mode()[0], inplace=True)<br/>train['Married'].fillna(train['Married'].mode()[0], inplace=True)<br/>train['Dependents'].fillna(train['Dependents'].mode()[0], inplace=True)<br/>train['Loan_Amount_Term'].fillna(train['Loan_Amount_Term'].mode()[0], inplace=True)<br/>train['Credit_History'].fillna(train['Credit_History'].mode()[0], inplace=True)<br/>train['Self_Employed'].fillna(train['Self_Employed'].mode()[0], inplace=True)<br/>#numerical</span><span id="7620" class="mx la it mt b gy nc mz l na nb">df['LoanAmount'].fillna(df['LoanAmount'].mean(), inplace=True)</span></pre><p id="5c7d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们必须处理离群值，一个解决方案是删除它们，但我们也可以对它们进行对数变换，以消除它们的影响，这是我们在这里采用的方法。有些人可能收入很低，但有很强的共同收入，所以一个好主意是把他们放在一个总收入栏里。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fcd5" class="mx la it mt b gy my mz l na nb">train['LoanAmount_log']=np.log(train['LoanAmount'])<br/>train['TotalIncome']= train['ApplicantIncome'] +train['CoapplicantIncome'] train['TotalIncome_log']=np.log(train['TotalIncome'])</span></pre><p id="7fec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">绘制贷款金额日志的直方图我们可以看到它是一个正态分布！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a1b4ece8f3bbd85ce49e9510d7bdfc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*F-nKRRSkTiGgmFznRoRKfg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author</figcaption></figure><h1 id="568a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建模:</h1><p id="b185" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将在模型中使用 sklearn，在此之前，我们需要将所有分类变量转换为数字。我们将使用 sklearn 中的 LabelEncoder 来实现这一点</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dfbf" class="mx la it mt b gy my mz l na nb">from sklearn.preprocessing import LabelEncoder<br/>category= ['Gender','Married','Dependents','Education','Self_Employed','Property_Area','Loan_Status'] <br/>encoder= LabelEncoder()<br/> for i in category:   <br/>  train[i] = encoder.fit_transform(train[i]) <br/>  train.dtypes</span><span id="0e5c" class="mx la it mt b gy nc mz l na nb">OUT:<br/>Loan_ID               object<br/>Gender                 int64<br/>Married                int64<br/>Dependents             int64<br/>Education              int64<br/>Self_Employed          int64<br/>ApplicantIncome        int64<br/>CoapplicantIncome    float64<br/>LoanAmount           float64<br/>Loan_Amount_Term     float64<br/>Credit_History       float64<br/>Property_Area          int64<br/>Loan_Status            int64<br/>LoanAmount_log       float64<br/>TotalIncome          float64<br/>TotalIncome_log      float64<br/>dtype: object</span></pre><p id="6f57" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们所有的变量都变成了我们的模型可以理解的数字。</p><p id="9056" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了尝试不同的模型，我们将创建一个函数，该函数接受一个模型，对其进行拟合，并测量其准确性，这意味着在训练集上使用该模型，并在同一集上测量误差。我们将使用一种称为 Kfold cross validation 的技术，它将数据随机分为训练集和测试集，使用训练集训练模型，并用测试集验证它，它将重复 K 次，因此命名为 Kfold，并取平均误差。后一种方法可以更好地了解模型在现实生活中的表现。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0f22" class="mx la it mt b gy my mz l na nb">#Import the models<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.cross_validation import KFold   #For K-fold cross validation<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.tree import DecisionTreeClassifier, export_graphviz<br/>from sklearn import metrics</span><span id="4305" class="mx la it mt b gy nc mz l na nb">def classification_model(model, data, predictors, outcome):<br/>  #Fit the model:<br/>  model.fit(data[predictors],data[outcome])<br/>  <br/>  #Make predictions on training set:<br/>  predictions = model.predict(data[predictors])<br/>  <br/>  #Print accuracy<br/>  accuracy = metrics.accuracy_score(predictions,data[outcome])<br/>  print ("Accuracy : %s" % "{0:.3%}".format(accuracy))</span><span id="b7ea" class="mx la it mt b gy nc mz l na nb">#Perform k-fold cross-validation with 5 folds<br/>  kf = KFold(data.shape[0], n_folds=5)<br/>  error = []<br/>  for train, test in kf:<br/>    # Filter training data<br/>    train_predictors = (data[predictors].iloc[train,:])<br/>    <br/>    # The target we're using to train the algorithm.<br/>    train_target = data[outcome].iloc[train]<br/>    <br/>    # Training the algorithm using the predictors and target.<br/>    model.fit(train_predictors, train_target)<br/>    <br/>    #Record error from each cross-validation run<br/>    error.append(model.score(data[predictors].iloc[test,:], data[outcome].iloc[test]))<br/> <br/>  print ("Cross-Validation Score : %s" % "{0:.3%}".format(np.mean(error)))</span></pre><p id="3f17" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以测试不同的模型，我们将从逻辑回归开始:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fed6" class="mx la it mt b gy my mz l na nb">outcome_var = 'Loan_Status'<br/>model = LogisticRegression()<br/>predictor_var = ['Credit_History','Education','Married','Self_Employed','Property_Area']<br/>classification_model(model, train,predictor_var,outcome_var)<br/>OUT : <br/>Accuracy : 80.945%<br/>Cross-Validation Score : 80.946%</span></pre><p id="bb21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在将尝试一个决策树，它应该会给我们更准确的结果</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="af66" class="mx la it mt b gy my mz l na nb">model = DecisionTreeClassifier() predictor_var = ['Credit_History','Gender','Married','Education'] classification_model(model, df,predictor_var,outcome_var)</span><span id="b5a1" class="mx la it mt b gy nc mz l na nb">OUT:<br/>Accuracy : 80.945%<br/>Cross-Validation Score : 78.179%</span></pre><p id="83c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们在准确性上得到了相同的分数，但在交叉验证上得分更低，更复杂的模型并不总是意味着更好的分数。</p><p id="6c80" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们将尝试随机森林</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="afd4" class="mx la it mt b gy my mz l na nb">model = RandomForestClassifier(n_estimators=100)<br/>predictor_var = ['Gender', 'Married', 'Dependents', 'Education',<br/>       'Self_Employed', 'Loan_Amount_Term', 'Credit_History', 'Property_Area',<br/>        'LoanAmount_log','TotalIncome_log']<br/>classification_model(model, train,predictor_var,outcome_var)</span><span id="ed17" class="mx la it mt b gy nc mz l na nb">OUT: <br/>Accuracy : 100.000%<br/>Cross-Validation Score : 78.015%</span></pre><p id="2636" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该模型在准确性上给了我们满分，但在交叉验证上得分很低，这是过度拟合的一个很好的例子。该模型很难推广，因为它非常适合训练集。</p><p id="059e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对此的解决方案包括:减少预测器的数量或调整模型参数。</p><h1 id="224b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论:</h1><p id="e932" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们已经讨论了数据科学的大部分内容，即 EDA、预处理和建模，并且使用了基本的分类模型，如逻辑回归、决策树和随机森林。了解更多关于这些算法背后的主干逻辑，以及处理数据采集和部署阶段将会很有趣。我们将在下一篇文章中尝试这样做。</p></div></div>    
</body>
</html>