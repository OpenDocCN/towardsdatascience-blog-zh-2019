<html>
<head>
<title>LSTM Autoencoder for Anomaly Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于异常检测的 LSTM 自动编码器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lstm-autoencoder-for-anomaly-detection-e1f4f2ee7ccf?source=collection_archive---------0-----------------------#2019-09-25">https://towardsdatascience.com/lstm-autoencoder-for-anomaly-detection-e1f4f2ee7ccf?source=collection_archive---------0-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed5d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python、Keras 和 TensorFlow 创建 AI 深度学习异常检测模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/425a2b9a1cded64cc25427e1af5e24e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ekIh-ceu2OOc2w-c"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@ellenqin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ellen Qin</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的目标是通过使用 Python，Keras 和 TensorFlow 创建和训练用于异常检测的人工智能深度学习神经网络的步骤。我不会过多地钻研底层理论，并假设读者对底层技术有一些基本的了解。不过，我会提供更多详细信息的链接，你可以在我的<a class="ae ky" href="https://github.com/BLarzalere/LSTM-Autoencoder-for-Anomaly-Detection" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到这项研究的源代码。</p><h2 id="7afd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">分析数据集</strong></h2><p id="ce5b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将使用 NASA 声学和振动数据库中的振动传感器读数作为本次研究的数据集。在美国宇航局的研究中，传感器读数取自四个轴承，这些轴承在持续多天的恒定负载下发生故障。我们的数据集由单个文件组成，这些文件是以 10 分钟为间隔记录的 1 秒振动信号快照。每个文件包含每个方位的 20，480 个传感器数据点，这些数据点是通过以 20 kHz 的采样率读取方位传感器而获得的。</p><p id="6f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里下载传感器数据<a class="ae ky" href="https://github.com/BLarzalere/LSTM-Autoencoder-for-Anomaly-Detection" rel="noopener ugc nofollow" target="_blank"/>。由于 GitHub 大小的限制，方位传感器数据被分成两个 zip 文件(Bearing_Sensor_Data_pt1 和 2)。您需要解压缩它们，并将它们合并到一个单独的数据目录中。</p><h2 id="7f9b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">异常检测</h2><p id="2ad2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">异常检测的任务是确定什么时候某些东西偏离了“正常”。使用神经网络的异常检测以无监督/自监督的方式建模；与监督学习相反，在监督学习中，输入特征样本与其对应的输出标签之间存在一对一的对应关系。假设正常行为以及可用“正常”数据的数量是正常的，异常是正常的例外，在这种情况下，“正常”建模是可能的。</p><p id="f4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用自动编码器深度学习神经网络模型来从传感器读数中识别振动异常。目标是在未来轴承故障发生之前预测它们。</p><h2 id="0e58" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">LSTM 网络公司</h2><p id="0f48" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这项研究的概念部分来自 Vegard Flovik 博士的一篇优秀文章“异常检测和条件监控的机器学习”。在那篇文章中，作者在自动编码器模型中使用了密集的神经网络单元。这里，我们将在我们的自动编码器模型中使用长短期记忆(LSTM)神经网络细胞。LSTM 网络是更一般的递归神经网络(RNN)的子类型。递归神经网络的一个关键属性是它们保持信息或细胞状态的能力，以供以后在网络中使用。这使得它们特别适合于分析随时间演变的时态数据。LSTM 网络用于语音识别、文本翻译等任务，在这里，用于异常检测的顺序传感器读数的分析。</p><p id="77fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多优秀的文章，作者远比我更有资格讨论 LSTM 社交网络的细节。所以如果你好奇，这里有一个链接，链接到 LSTM 网络上的一篇优秀的<a class="ae ky" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">文章。这里也是所有 LSTM 事物的事实上的地方——</a><a class="ae ky" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" rel="noopener ugc nofollow" target="_blank">安德烈·卡帕西的博客</a>。理论讲够了，让我们继续写代码吧…</p><h2 id="b22d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">加载、预处理和检查数据</h2><p id="0c2e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我将使用 Anaconda 发行版 Python 3 Jupyter 笔记本来创建和训练我们的神经网络模型。我们将使用 TensorFlow 作为我们的后端，Keras 作为我们的核心模型开发库。第一项任务是加载我们的 Python 库。然后，我们设置我们的随机种子，以创造可重复的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7d21e8c01fc8c8bb44e3a1210b2f4fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAbDJDeIhzrppv05X4i3Sw.png"/></div></div></figure><p id="2ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设轴承中的机械退化随着时间逐渐发生；因此，我们将在分析中每 10 分钟使用一个数据点。通过使用 20，480 个数据点上振动记录的平均绝对值，汇总每 10 分钟的数据文件传感器读数。然后我们把所有的东西合并成一个熊猫数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/f05a942d14c6f4c9e7ae0808649b2b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4PovepPuQnVyy0axfNtHg.png"/></div></div></figure><p id="6d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义用于训练和测试神经网络的数据集。为此，我们执行一个简单的分割，在数据集的第一部分进行训练，这代表正常的操作条件。然后，我们测试数据集的剩余部分，该部分包含导致轴承故障的传感器读数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/13ad73c39a9d0cd2de3477e687430ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSzO1jOvYPZmjdv36HaHkQ.png"/></div></div></figure><p id="95d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经加载、聚合和定义了我们的训练和测试数据，让我们回顾一下传感器数据随时间变化的趋势模式。首先，我们绘制代表轴承正常运行条件的训练集传感器读数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/a2611a7089ffabf4432cd9fdf88a6383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERki03caQhkN7gCu2icRZw.png"/></div></div></figure><p id="059e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们来看看测试数据集传感器读数随时间的变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/1a903e87662181c925921c2aa7973911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaXW6ySqqHBTUFwpN6cs5w.png"/></div></div></figure><p id="8043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试集时间框架的中途，传感器模式开始改变。在故障点附近，轴承振动读数变得更强，并剧烈振荡。为了获得稍微不同的数据视角，我们将使用傅立叶变换将信号从时域变换到频域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/9ed73b7cd73c7ba385bd1a8948901270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IO-4Ss8_pPImwGAUELkx8g.png"/></div></div></figure><p id="0801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来看频域的训练数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/0f09e4a98aef2fc5ddec302b4dd018d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMeLTZLTmKG6PgFpPsTKKw.png"/></div></div></figure><p id="79c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常运行的传感器读数没有什么值得注意的。现在，让我们看看导致轴承故障的传感器频率读数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c4f780d60fa32b61667c931b9bf7fe32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mDMXiMlSxDC5eQzde3y8Q.png"/></div></div></figure><p id="c831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以清楚地看到，系统中频率振幅和能量的增加导致了轴承故障。</p><p id="ef53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成我们数据的预处理，我们将首先把它归一化到 0 和 1 之间的范围。然后，我们将数据改造成适合输入 LSTM 网络的格式。LSTM 单元期望一个形式为[数据样本，时间步长，特征]的三维张量。这里，输入到 LSTM 网络的每个样本代表一个时间步长，并包含 4 个特征-在该时间步长的四个方位的传感器读数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/9d34c41a2b2a2be55b58246416cbeec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9HjE79WIAA77o3SWjDNDQ.png"/></div></div></figure><p id="fca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 LSTM 像元的优势之一是能够在分析中包含多元特征。这里是每个时间步的四个传感器读数。但是，在在线欺诈异常检测分析中，可能是时间、金额、购买的商品、每个时间步长的互联网 IP 等特征。</p><h2 id="b2ac" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">神经网络模型</h2><p id="390f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将为我们的异常检测模型使用自动编码器神经网络架构。自动编码器架构本质上学习“身份”功能。它将获取输入数据，创建该数据的核心/主要驱动特征的压缩表示，然后再次学习重构它。例如，输入一张狗的图像，它会将数据压缩到构成狗图像的核心成分，然后学习从数据的压缩版本中重建原始图像。</p><p id="37e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种架构进行异常检测的基本原理是，我们根据“正常”数据训练模型，并确定产生的重建误差。然后，当模型遇到超出正常范围的数据并试图重建它时，我们将看到重建错误的增加，因为模型从未被训练为准确地重建超出正常范围的项目。</p><p id="77bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用 Keras 库创建我们的自动编码器神经网络模型作为 Python 函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/3a91f76b85b8e7db11216b17fac638d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycgKGlWpe0qfeCu_uMi5Pw.png"/></div></div></figure><p id="fe36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 LSTM 自动编码器网络结构中，第一对神经网络层创建输入数据的压缩表示，即编码器。然后，我们使用一个重复矢量层来跨解码器的时间步长分布压缩的表示矢量。解码器的最终输出层为我们提供重建的输入数据。</p><p id="c9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们实例化该模型，并使用 Adam 作为我们的神经网络优化器来编译它，并平均绝对误差来计算我们的损失函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/97db5a4372a6e05d41953352bc1a72f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVOCFCEGzfSK1ZYjTQQfHg.png"/></div></div></figure><p id="2434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将模型拟合到我们的训练数据，并对其进行 100 个时期的训练。然后，我们绘制训练损失图来评估我们的模型的性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/26194b73632d00310c7775f93d163c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*citNAFgrIKLEiAW0Vzx0WQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/04a604e92eb23b85589631c06520b063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Sf7RsuPca4dHAnSz0z07g.png"/></div></div></figure><h2 id="244a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">损失分布</h2><p id="4a7b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">通过绘制训练集中计算损失的分布，我们可以确定用于识别异常的合适阈值。在这样做时，可以确保该阈值被设置在“噪声水平”之上，从而不会触发假阳性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/6f4368aa213bb29800d4e6ce2ebff76f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNVsLe7MnFQBCFxIcyspcg.png"/></div></div></figure><p id="185f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上述损失分布，让我们尝试使用阈值 0.275 来标记异常。然后，我们计算训练集和测试集中的重建损失，以确定传感器读数何时超过异常阈值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/120174a7d5ccdc361f6f1a9eff63a228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htX9_vOBGgDU_a79u1k30g.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/3f97e344619e01ba408cd3f1a596d6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXxwUNi68w8McCknMMVVTQ.png"/></div></div></figure><p id="ffa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们已经将所有内容合并到一个数据帧中，以可视化随时间变化的结果。红线表示我们的阈值 0.275。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/5b2f1f85270807542c5ce810f0893b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKlRUMXQoYmZVuwj3nPiVQ.png"/></div></div></figure><p id="05a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的神经网络异常分析能够通过检测传感器读数何时开始偏离正常运行值，在实际的物理轴承故障之前很好地标记即将发生的轴承故障。</p><p id="9efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们以 h5 格式保存神经网络模型架构及其学习到的权重。经过训练的模型可以用于异常检测。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/beefd5d622171c55f91a26320456703d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAwAg-6U3KzZ36zF40Q8ow.png"/></div></div></figure><h2 id="4fe9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">更新:</h2><p id="5ca9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在下一篇<a class="ae ky" href="https://medium.com/swlh/containerized-ai-for-anomaly-detection-eb3e08225235" rel="noopener">文章</a>中，我们将使用 Docker 和 Kubernetes 将我们训练过的 AI 模型部署为 REST API，以将其公开为服务。</p></div></div>    
</body>
</html>