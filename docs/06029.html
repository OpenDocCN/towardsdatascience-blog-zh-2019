<html>
<head>
<title>How to download files in lightning speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何闪电般下载文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/https-towardsdatascience-com-how-to-download-files-in-a-lightning-speed-a8e8dcc694f7?source=collection_archive---------11-----------------------#2019-09-02">https://towardsdatascience.com/https-towardsdatascience-com-how-to-download-files-in-a-lightning-speed-a8e8dcc694f7?source=collection_archive---------11-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4dca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及不同解析工具之间的详细比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6a1806fb1b5f7058fdc14e1606510ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lMpku9ygA1Z_UBZzgE6mA.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><blockquote class="kw"><p id="7b53" class="kx ky it bd kz la lb lc ld le lf lg dk translated">你可以有没有信息的数据，但你不能有没有数据的信息。— <a class="ae lh" href="http://en.wikipedia.org/wiki/Daniel_Keys_Moran" rel="noopener ugc nofollow" target="_blank">丹尼尔·凯斯·莫兰</a></p></blockquote><p id="ca58" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc lg im bi translated">随着分析技能在最近几天受到高度重视，如何获得高质量的数据也很重要。如果没有更多或高质量的数据，伟大的分析总是无法进行。</p><p id="f1d6" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">有一天，</p><p id="1496" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">我的一个朋友问我。</p><p id="9d57" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">“伟鸿，在点击下载音乐文件的链接之前，你知道媒体文件是否会立即下载吗？</p><p id="c023" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">如果链接指向另一个网站，并显示错误信息，该怎么办？我不想下载邮件，我只需要媒体文件。"</p><p id="9f1b" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">我说，“这是个好问题。让我想清楚，然后尽快回复你。”</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="6186" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">过了一会儿，我说:“给你！”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/1edca08f12dfd1424b788d8e014b1e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2p5NsxTKOmaPZsbKjM1fzg.jpeg"/></div></div></figure><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="ce96" class="mv mw it mr b gy mx my l mz na">def is_downloadable(url):<br/>    """<br/>    Does the url contain a downloadable resource<br/>    """<br/>    h = requests.head(url, allow_redirects=True)<br/>    header = h.headers<br/>    content_type = header.get('content-type')<br/>    if 'text' in content_type.lower():<br/>        return False<br/>    if 'html' in content_type.lower():<br/>        return False<br/>    return True</span></pre><p id="521d" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">上述函数将用于检查 URL 是否包含可下载的源，其逻辑如下所示:</p><ol class=""><li id="83ee" class="nb nc it lk b ll md lo me lr nd lv ne lz nf lg ng nh ni nj bi translated">不是直接下载 URL 的内容并检查源的类型，而是检查 URL 的请求头。</li><li id="3af4" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated">检查标题的内容类型，如果它既不是文本也不是 Html，这意味着 URL 带有可以下载的源。</li></ol></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="8b09" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">接下来，我在考虑加速代码。除了使用 BeautifulSoup 来解析 Html，有没有其他替代方法可以得到同样的结果，但比 BeautifulSoup 更快？</p><p id="63f9" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">答案是肯定的，下面我将向你展示如何使用其他更快的 Html 解析器。在此之前，让我们比较一下从 Html 中提取数据的各种比较著名的工具。</p><ol class=""><li id="18d5" class="nb nc it lk b ll md lo me lr nd lv ne lz nf lg ng nh ni nj bi translated">美丽的声音</li><li id="9466" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated">Lxml</li><li id="0aa4" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated">html 解析器</li><li id="3d25" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated">Selectolax</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2296427b859abd398ffdd8d1f4b05ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4ahYISY59MaIet5BsqpLQ.png"/></div></div></figure><p id="6741" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">这是我们将要抓取的<a class="ae lh" href="http://kern.humdrum.org/search?s=t&amp;keyword=Bach%20Johann&amp;fbclid=IwAR39fsc8gUWjN6eYAUkewldNkeV499lX0Ew6VP8Nrrd_T1T7plaIIIb5nFQ" rel="noopener ugc nofollow" target="_blank">网站</a>，我们将点击<strong class="lk iu"> M </strong>来下载巴赫约翰的音乐。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="f188" class="mv mw it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of og bi translated">美丽的声音</h2><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="6371" class="mv mw it mr b gy mx my l mz na">from bs4 import BeautifulSoup<br/>import wget<br/>soup = BeautifulSoup(r.text, 'lxml')</span><span id="4dfd" class="mv mw it mr b gy oh my l mz na">css_path = 'tr &gt; td:nth-child(2) &gt; a:nth-child(3)'</span><span id="b06b" class="mv mw it mr b gy oh my l mz na">for node_link in soup.select(css_path):<br/>   url = node_link['href']<br/>   if is_downloadable(url):<br/>        wget.download(url, <br/>                     './data/' +\<br/>                     url.split('&amp;file=')[-1].split('&amp;format')[0] +\<br/>                     '.mid')</span></pre><p id="9549" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">上面的代码片段是使用 BeautifulSoup 作为我们工具的代码。</p><p id="f5d8" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">如 BeautifulSoup 文档中所述，</p><blockquote class="oi oj ok"><p id="e58c" class="li lj ol lk b ll md ju ln lo me jx lq om mf lt lu on mg lx ly oo mh mb mc lg im bi translated">漂亮的汤永远不会像它上面的解析器一样快。</p></blockquote><p id="3e48" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">因为它是建立在 LXML 之上的，所以我们将把它用作我们的解析器。如您所知，我们使用 CSS 来定位数据。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="c7c1" class="mv mw it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of og bi translated">LXML</h2><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="18e7" class="mv mw it mr b gy mx my l mz na">import lxml.html<br/>import wget</span><span id="239f" class="mv mw it mr b gy oh my l mz na">dom = lxml.html.fromstring(r.text)<br/>css_path = 'tr &gt; td:nth-child(2) &gt; a:nth-child(3)'</span><span id="faaf" class="mv mw it mr b gy oh my l mz na">for node_link in dom.cssselect(css_path):<br/>    url = node_link.get('href') # OR node_link.attrib['href']</span><span id="5fbf" class="mv mw it mr b gy oh my l mz na">    # check whether the url is downloadable<br/>    if is_downloadable(url):<br/>        wget.download(url, <br/>                     './data/' +\<br/>                     url.split('&amp;file=')[-1].split('&amp;format')[0] +\<br/>                     '.mid')</span></pre><p id="78a9" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">上面的代码说明了如何使用 LXML 解析器访问 HTML。正如您所观察到的，语法看起来非常类似于 BeautifulSoup。此外，Lxml 不仅支持 CSS，还支持 Xpath，因此如果您更熟悉使用 Xpath，那么 LXML 将是您更好的选择，而不是 BeautifulSoup。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="2b45" class="mv mw it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of og bi translated">html 解析器</h2><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="8c56" class="mv mw it mr b gy mx my l mz na">from html.parser import HTMLParser<br/>import wget</span><span id="61e2" class="mv mw it mr b gy oh my l mz na">class MyHTMLParser(HTMLParser):<br/>    links = []<br/>    def handle_starttag(self, tag, attrs):<br/>        if tag != 'a':<br/>            return</span><span id="09c4" class="mv mw it mr b gy oh my l mz na">for attr in attrs:<br/>            if 'href' in attr[0]:<br/>                if attr[1].endswith('format=midi'):<br/>                    self.links.append(attr[1])<br/>                    break</span><span id="d45b" class="mv mw it mr b gy oh my l mz na">parser = MyHTMLParser()<br/>parser.feed(r.text)</span><span id="05d0" class="mv mw it mr b gy oh my l mz na">for url in parser.links:<br/>   if is_downloadable(url):<br/>       wget.download(url, <br/>                     './data/' +\<br/>                     url.split('&amp;file=')[-1].split('&amp;format')[0] +\<br/>                     '.mid')</span></pre><p id="0063" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">Python 框架内置了一个<a class="ae lh" href="https://docs.python.org/3.7/library/html.parser.html?highlight=htmlparser" rel="noopener ugc nofollow" target="_blank"> HTML 解析器</a>，上面的代码用它来提取 URL。这有点复杂，因为我们需要创建自己的 HTMLParser 类来覆盖原始类中的<code class="fe op oq or mr b">handle_starttag</code>方法。对我来说，我很少使用 HTMLParser，因为其他可用的工具更容易实现。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="f044" class="mv mw it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of og bi translated">Selectolax</h2><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="25a5" class="mv mw it mr b gy mx my l mz na">from selectolax.parser import HTMLParser<br/>import wget</span><span id="1a4f" class="mv mw it mr b gy oh my l mz na">for node_link in dom.css(selector):<br/>   url = node_link.attributes['href']</span><span id="95ac" class="mv mw it mr b gy oh my l mz na">   if is_downloadable(url):<br/>       wget.download(url, <br/>                     './data/' +\<br/>                     url.split('&amp;file=')[-1].split('&amp;format')[0] +\<br/>                     '.mid')</span></pre><p id="3e02" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">我开始知道 Selectolax 包是当有人回复我的 Reddit 评论，告诉我试试这个包。(感谢这位 Reddit 的朋友！🤗)基本上，它是一个适度的引擎的 Cython 包装器。经过尝试，解析 HTML 页面的速度有所提高，但幅度不大。同样的建议，如果你更熟悉 XPATH，就用 LXML 代替。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1475c7c628b3b9c99474aa28b566f3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hIqmh3UXUlEk0dM5WA4ng.jpeg"/></div></div></figure><h2 id="2c3d" class="mv mw it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of og bi translated">性能概述</h2><p id="d61f" class="pw-post-body-paragraph li lj it lk b ll ot ju ln lo ou jx lq lr ov lt lu lv ow lx ly lz ox mb mc lg im bi translated">作为实验，我使用不同的工具总共下载了<strong class="lk iu"> 1349 个</strong> MID 文件。运行<strong class="lk iu"> 20 </strong>次后，平均每个工具所用的时间，结果如下:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="d183" class="mv mw it mr b gy mx my l mz na">+---------------+--------------------+<br/>| Package       | Average Time taken |<br/>+---------------+--------------------+<br/>| BeautifulSoup | 1300.94s           |<br/>| LXML          | 1258.89s           |<br/>| Selectolax    | 1241.85s           |<br/>| HTMLParser    | 1265.95s           |<br/>+---------------+--------------------+</span></pre><p id="8629" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">Selectolax 是最快的，但差别并不明显。</p><p id="09b8" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">总之，如果你真的需要提高你的铲运机或爬虫的速度，那么也许选择 Selectolax 更好。如果您更熟悉 Xpath，请使用 LXML。此外，也许你正在处理一个设计糟糕的网站(就 Html 文档结构而言)，最好选择 BeautifulSoup。最后但同样重要的是，如果您想挑战自己，那么就使用 HTMLParser 吧😎😎😎。</p><p id="6687" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">到目前为止，我希望您对用于解析 Html 页面的每个 Python 包有了更好的理解。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="e6f2" class="mv mw it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of og bi translated">参考</h2><ol class=""><li id="42a8" class="nb nc it lk b ll ot lo ou lr oy lv oz lz pa lg ng nh ni nj bi translated"><a class="ae lh" href="https://stackoverflow.com/questions/4967103/beautifulsoup-and-lxml-html-what-to-prefer" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/4967103/beautiful soup-and-lxml-html-what-to-preferred</a></li><li id="577a" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated"><a class="ae lh" href="https://www.mschweighauser.com/fast-url-parsing-with-python/" rel="noopener ugc nofollow" target="_blank">https://www . mschweighauser . com/fast-URL-parsing-with-python/</a></li><li id="8855" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated"><a class="ae lh" href="https://www.codementor.io/aviaryan/downloading-files-from-urls-in-python-77q3bs0un" rel="noopener ugc nofollow" target="_blank">https://www . code mentor . io/aviar Yan/downloading-files-from-URLs-in-python-77 q3b S10 un</a></li><li id="3619" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated"><a class="ae lh" href="https://stackoverflow.com/questions/71151/html-parser-in-python" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/71151/html-parser-in-python</a></li><li id="1cb3" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no lg ng nh ni nj bi translated"><a class="ae lh" href="https://stackoverflow.com/questions/6126789/selecting-attribute-values-from-lxml" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/6126789/selecting-attribute-values-from-lxml</a></li></ol></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="cfda" class="pb mw it bd nq pc pd pe nt pf pg ph nw jz pi ka nz kc pj kd oc kf pk kg of pl bi translated">关于作者</h1><p id="eb25" class="pw-post-body-paragraph li lj it lk b ll ot ju ln lo ou jx lq lr ov lt lu lv ow lx ly lz ox mb mc lg im bi translated"><a class="ae lh" href="https://www.linkedin.com/in/lowweihong/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Low 魏宏</a>是 Shopee 的数据科学家。他的经验更多地涉及抓取网站，创建数据管道，以及实施机器学习模型来解决业务问题。</p><p id="abdb" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">他提供爬行服务，能够为你提供你所需要的准确和干净的数据。你可以访问<a class="ae lh" href="https://www.thedataknight.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk iu">这个网站</strong> </a>查看他的作品集，也可以联系他获取<strong class="lk iu">抓取服务</strong>。</p><p id="3f3d" class="pw-post-body-paragraph li lj it lk b ll md ju ln lo me jx lq lr mf lt lu lv mg lx ly lz mh mb mc lg im bi translated">你可以在<a class="ae lh" href="https://www.linkedin.com/in/lowweihong/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://medium.com/@lowweihong?source=post_page---------------------------" rel="noopener"> Medium </a>上和他联系。</p><div class="pm pn gp gr po pp"><a href="https://medium.com/@lowweihong?source=post_page-----3efb6878f8db----------------------" rel="noopener follow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">低微红—中等</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">在媒体上阅读低纬鸿的作品。数据科学家|网络搜集服务:http://datainfinite.mystrikingly.com/…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">medium.com</p></div></div><div class="py l"><div class="pz l qa qb qc py qd ks pp"/></div></div></a></div></div></div>    
</body>
</html>