<html>
<head>
<title>A unified approach for downloading, extracting, processing &amp; using datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下载、提取、处理和使用数据集的统一方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-unified-method-for-downloading-extracting-processing-using-datasets-7482a3b27aff?source=collection_archive---------11-----------------------#2019-09-18">https://towardsdatascience.com/a-unified-method-for-downloading-extracting-processing-using-datasets-7482a3b27aff?source=collection_archive---------11-----------------------#2019-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fc6ae5b38690a80e0ca30602af05b5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8KqknP1zNfAUl0MFpzz-w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@oskarssylwan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Oskars Sylwan</a> on <a class="ae kf" href="https://unsplash.com/search/photos/organized?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5852" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何机器学习练习的第一个相当多的步骤都是关于数据集的。从哪里以及如何下载它们？编写脚本来组织和/或改变下载的档案、目录、数据库和数十种其他格式，使它们成为对手头项目有意义的东西。最后，一旦准备好数据，就开发管道将数据(或者更确切地说，我应该说是特征)馈送到正在训练的神经网络和/或机器学习算法。</p><p id="7eb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就构建管道而言，tensorflow core 已经使用<code class="fe le lf lg lh b"><a class="ae kf" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank">tf.data</a></code>模块提供了一个优秀的抽象。这个模块的核心是<code class="fe le lf lg lh b">tf.data.Dataset</code>类，它抽象出输入特性的底层来源。根据要素的大小，您可以使用简单的 numpy 数组，或者如果数据集很大，您可以使用<code class="fe le lf lg lh b">tfrecords</code>作为基于文件的底层存储。<code class="fe le lf lg lh b">tfrecords</code>根据您指定的特性模式，最终将您的特性样本存储为 protobufs。也就是说，你真的不需要担心<code class="fe le lf lg lh b">tfrecords</code>如何在内部存储数据。有趣的是，由于<code class="fe le lf lg lh b">tf.data.Dataset</code>提供的抽象，您可以在输入管道上应用相同的操作集。下面是一个简单的代码片段，显示了管道-</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="558e" class="lq lr it lh b gy ls lt l lu lv">d = tf.data.TFRecordDataset(input_files)<br/>d = d.shard(num_workers, worker_index)<br/>d = d.repeat(num_epochs)<br/>d = d.shuffle(shuffle_buffer_size)<br/>d = d.map(parser_fn, num_parallel_calls=num_map_threads)</span><span id="91fe" class="lq lr it lh b gy lw lt l lu lv">assert(isinstance(d, tf.data.Dataset))</span></pre><p id="30a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然<code class="fe le lf lg lh b">tf.data.Dataset</code>是一个很好的抽象&amp; <code class="fe le lf lg lh b">tfrecords</code>是一个很好的存储格式，但它仍然没有解决围绕下载、提取和准备数据的一致方法的问题。通常，与数据集下载、提取和转换相关的脚本/代码与用于培训和评估的主要管道是分开的，因此带来了挑战。其中一些列在下面-</p><ul class=""><li id="27fc" class="lx ly it ki b kj kk kn ko kr lz kv ma kz mb ld mc md me mf bi translated">脚本的数量在某种程度上与数据集的数量成比例。在我的个人项目中，每个数据集至少有 4 个脚本(其中有主/入口点)(在他们使用的可重用模块之上)，只是为了准备可处理的特性。</li><li id="ae7b" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">开发人员必须担心文件路径的健全性检查、正确读取图像(在 python 生态系统中，有多个包仅用于读取图像，甚至单个项目最终会使用其中的许多包)等。希望您能够理解，随着项目的增长，不同技能的开发人员对库和方法的偏好也会增加。</li><li id="8820" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">在培训和评估期间，在准备<code class="fe le lf lg lh b">tfrecords</code>时使用的特性规范与编写<code class="fe le lf lg lh b">parser_fn</code>用于映射时使用的特性规范之间要断开。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="9229" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可扩展和可维护的软件工程项目的一个关键组成部分是解决任务的一致性。这里的任务是获取和准备数据集。这篇文章是关于介绍来自 https://github.com/tensorflow/datasets<code class="fe le lf lg lh b">tensorflow_datasets(</code><a class="ae kf" href="https://github.com/tensorflow/datasets" rel="noopener ugc nofollow" target="_blank"/><code class="fe le lf lg lh b">tensorflow</code>生态系统的一个包，它为上面列出的挑战提供了有希望的解决方案。</p><p id="e8a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">tensorflow_datasets</code>是由谷歌的开发者发起的一个项目，然而它是由社区驱动的，并吸引了来自机器学习社区的大量贡献。</p><p id="1be8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一眼看到<code class="fe le lf lg lh b">tensorflow_datasets</code>会给你一个印象，这个包是关于各种数据集的集合，虽然它是正确的，但我感兴趣的部分是，为了支持各种数据集(音频、图像、视频、二进制等)，他们必须开发一个强大的基础，提供足够的抽象，以消除对平凡和重复任务的需求，同时保持用户代码足够灵活，以处理数据集的特殊性。</p><p id="5fcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是显示用法的列表:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="f4fa" class="lq lr it lh b gy ls lt l lu lv">import tensorflow as tf<br/>import tensorflow_datasets as tfds<br/><br/># tfds works in both Eager and Graph modes<br/>tf.enable_eager_execution()<br/><br/># See available datasets<br/>print(tfds.list_builders())<br/><br/># Load a given dataset by name, along with the DatasetInfo<br/>data, info = tfds.load("mnist", with_info=True)<br/>train_data, test_data = data['train'], data['test']<br/>assert isinstance(train_data, tf.data.Dataset)<br/>assert info.features['label'].num_classes == 10<br/>assert info.splits['train'].num_examples == 60000<br/><br/># You can also access a builder directly<br/>builder = tfds.builder("mnist")<br/>assert builder.info.splits['train'].num_examples == 60000<br/>builder.download_and_prepare()<br/>datasets = builder.as_dataset()</span></pre><p id="8bba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显而易见的是，这种方法提供了获得数据集的统一方法，而不考虑它们的类型。</p><p id="dfe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里需要特别注意的一个方法是<code class="fe le lf lg lh b">download_and_prepare</code>。这个方法实际上最终调用了数据集特定的实现(本例中为 MNIST ),下载、提取和准备<code class="fe le lf lg lh b">tfrecords</code>的逻辑就驻留在这个实现中。原始数据、原始数据和准备好的数据所在的位置也可以通过将参数传递给<code class="fe le lf lg lh b">download_and_prepare</code>来配置。</p><p id="4056" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以下载数据(因为有时可能需要身份验证和授权)，然后提供数据的路径。换句话说，它足够灵活，可以满足大多数场景。繁重的下载和准备任务只发生一次，对于后续的使用，它跳过了昂贵的操作。</p><p id="6bd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">tensorflow_datasets</code>的文档确实不错。它们不仅为使用提供了很好的指导，也为人们如何向他们的集合贡献新的数据集提供了很好的指导。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="dce1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文的其余部分将借助一个具体的例子来说明如何将这个框架用于您自己的私有数据集。</p><p id="3fec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我将使用<code class="fe le lf lg lh b">tiny-imagenet</code>数据集。该示例的完整源代码可在<a class="ae kf" href="https://github.com/ksachdeva/tiny-imagenet-tfds" rel="noopener ugc nofollow" target="_blank">https://github.com/ksachdeva/tiny-imagenet-tfds</a>获得。您也可以使用 pip 将这个包安装到您自己的项目/笔记本/colab 中:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c97a" class="lq lr it lh b gy ls lt l lu lv">pip install git+https://github.com/ksachdeva/tiny-imagenet-tfds.git</span></pre><blockquote class="ms mt mu"><p id="1b9c" class="kg kh mv ki b kj kk kl km kn ko kp kq mw ks kt ku mx kw kx ky my la lb lc ld im bi translated">我很可能会将此数据集贡献给 tensorflow_datasets 集合，这样它将作为其中的一部分可用，但源存储库将始终作为构建私有数据集支持的参考</p></blockquote><p id="9caa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们先来看看用法:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d540" class="lq lr it lh b gy ls lt l lu lv">import os<br/>import numpy as np<br/>import tensorflow as tf<br/><br/>import tensorflow_datasets as tfds<br/>from tiny_imagenet import TinyImagenetDataset<br/><br/># optional<br/>tf.compat.v1.enable_eager_execution()<br/><br/>tiny_imagenet_builder = TinyImagenetDataset()<br/><br/>tiny_imagenet_builder.download_and_prepare()<br/><br/>train_dataset = tiny_imagenet_builder.as_dataset(split="train")<br/>validation_dataset = tiny_imagenet_builder.as_dataset(split="validation")<br/><br/>assert(isinstance(train_dataset, tf.data.Dataset))<br/>assert(isinstance(validation_dataset, tf.data.Dataset))<br/><br/>for a_train_example in train_dataset.take(5):<br/>    image, label, id = a_train_example["image"], a_train_example["label"], a_train_example["id"]<br/>    print(f"Image Shape - {image.shape}")<br/>    print(f"Label - {label.numpy()}")<br/>    print(f"Id - {id.numpy()}")<br/><br/># print info about the data<br/>print(tiny_imagenet_builder.info)</span></pre><p id="0782" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望您能从上面的代码片段中了解到，它或多或少与前面显示的 MNIST 示例相同，下载、准备和特性模式的细节被隐藏起来了。</p><h1 id="1af7" class="mz lr it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">微型图像网</h1><p id="3052" class="pw-post-body-paragraph kg kh it ki b kj nw kl km kn nx kp kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">Tiny Imagenet 是 Imagenet 数据集的缩小版。这个数据集是由斯坦福的人们为他们的课程<a class="ae kf" href="http://cs231n.stanford.edu/" rel="noopener ugc nofollow" target="_blank">http://cs231n.stanford.edu/</a>创建的。</p><p id="051f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应该清楚的是，使用 tiny-imagenet-tfds 包并不要求您知道如何下载和准备数据集，但是因为我将向您展示如何开发实现，所以了解这个数据集是如何组织的非常重要。</p><p id="6af0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是提取 zip 文件时数据集的样子。</p><div class="li lj lk ll gt ab cb"><figure class="ob ju oc od oe of og paragraph-image"><img src="../Images/327b7bdafde736ae493227ddce5eab05.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*r95amAzv-WQ1fugmcgHGZA.png"/></figure><figure class="ob ju oh od oe of og paragraph-image"><img src="../Images/096232ed40343e628168dd7ed14dfbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*1QuMkQxOs9uOTEa68-W1TQ.png"/></figure></div><h2 id="99b1" class="lq lr it bd na oi oj dn ne ok ol dp ni kr om on nm kv oo op nq kz oq or nu os bi translated">特征</h2><ul class=""><li id="d89e" class="lx ly it ki b kj nw kn nx kr ot kv ou kz ov ld mc md me mf bi translated">200 个图像类别</li><li id="8829" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">100，000 幅图像的训练数据集</li><li id="9c8e" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">10，000 幅图像的验证数据集</li><li id="1198" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">10，000 幅图像的测试数据集。</li><li id="33ff" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">所有图片尺寸均为 64×64。</li><li id="c0ef" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">wnids.txt 包含类名列表(nXXXXXX)</li><li id="faa9" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">words.txt 包含与类名相关联的友好名称[在本练习中我们不打算使用]</li><li id="6065" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">val_annotations.txt 包含图像列表。对于每个图像，都有一个相应的列提供相关联的标签(即来自 wnids.txt 的标签)</li><li id="7e54" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">train 文件夹包含每个类的文件夹，在该文件夹中有一个名为 images 的目录，其中包含该类的 500 个 jpeg 文件。train 中的每个类都有 nXX_boxes.txt，它包含关于图像的边界框信息。在本练习中，我们不打算处理边界框信息。</li></ul><h1 id="f1b4" class="mz lr it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">tfds . core . generatorbasedbuilder</h1><p id="c0af" class="pw-post-body-paragraph kg kh it ki b kj nw kl km kn nx kp kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">在<code class="fe le lf lg lh b">tensorflow_datasets</code>中实现各种数据集的主要工具就是这个类。顾名思义，它希望您<strong class="ki iu">生成</strong>数据集的示例，并将其写入<code class="fe le lf lg lh b">tfrecords</code>中。</p><p id="0b21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">tensorflow_datasets</code>期望你实现一个从<code class="fe le lf lg lh b">tfds.core.GeneratorBasedBuilder</code>继承的类，并实现三个方法——<code class="fe le lf lg lh b">_info</code>、<code class="fe le lf lg lh b">_split_generators</code>和<code class="fe le lf lg lh b">_generate_examples</code>。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="e2f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">_info</code>方法是您将要返回关于数据集的元数据的地方。这里有一个片段展示了它在 tiny-imagenet 中的应用。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="8477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe le lf lg lh b">_info</code>返回的<code class="fe le lf lg lh b">tfds.core.DatasetInfo</code>最重要的元素是<strong class="ki iu">特征</strong>的规范。如果你已经熟悉<code class="fe le lf lg lh b">tfrecords</code>，你会注意到它与你习惯看到的不同。事实上,<code class="fe le lf lg lh b">tensorflow_datasets</code>提供了一些高效的包装器来构建大大简化了很多事情的特性。在这个例子中，我使用的是<code class="fe le lf lg lh b">tfds.features.Image</code>，而如果我手动构建<code class="fe le lf lg lh b">tfrecords</code>，我将不得不使用多个字段，例如一个用于存储原始数据，一个用于形状，另一个用于图像格式等。最重要的是，我必须从我的脚本中读取图像。正如您稍后将在 _ <strong class="ki iu"> generate_examples </strong>函数的实现中看到的，我们不需要做任何事情。</p><p id="b8fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我也很欣赏 DatasetInfo 有描述和引用字段的事实。这些元数据字段对于生成文档也很方便&amp;更重要的是对人们首先创建数据集的辛勤工作的认可。</p><p id="be80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个要实现的方法是<code class="fe le lf lg lh b">_split_generators</code>，它在很多方面都是这个实现的主力。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="edb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法中的第一行，即<code class="fe le lf lg lh b">extracted_path = dl_manager.extract(dl_manager.download(_URL))</code>，是负责下载和提取的那一行。本例中的<code class="fe le lf lg lh b">_URL</code>指向<a class="ae kf" href="http://cs231n.stanford.edu/tiny-imagenet-200.zip." rel="noopener ugc nofollow" target="_blank">http://cs231n.stanford.edu/tiny-imagenet-200.zip.</a>返回值，即<code class="fe le lf lg lh b">extracted_path</code>包含解压后的路径。这是我困惑和问题的第一个来源。当我调用<code class="fe le lf lg lh b">download_and_prepare</code>时，它会向我显示下载的进度条，但当我查看位置时，它会是这样的</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/a60a4259d319128f44697f6e8ee40eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3o1NHKtyP_DiaO7JlOU3aw.png"/></div></div></figure><p id="a8a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，下载和解压 zip 文件的默认路径是<code class="fe le lf lg lh b">~/tensorflow_datasets/downloads/extracted</code>。现在，由于目录以扩展名<code class="fe le lf lg lh b">.zip</code>结尾，我认为它是一个文件，解压缩失败。最后花了 15 分钟试图找出问题所在，最后注意到这是一个目录。</p><p id="fe89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果数据集被分成许多 zip/tar/rar/gz 文件会怎么样呢？…不要担心！，你被覆盖了。可以将字典作为参数，在这种情况下返回值将是包含相应值的字典。下面的清单显示了该用例的一个示例</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0b7e" class="lq lr it lh b gy ls lt l lu lv">def _split_generators(self, dl_manager):<br/>  # Equivalent to dl_manager.extract(dl_manager.download(urls))<br/>  dl_paths = dl_manager.download_and_extract({<br/>      'foo': 'https://example.com/foo.zip',<br/>      'bar': 'https://example.com/bar.zip',<br/>  })<br/>  dl_paths['foo'], dl_paths['bar']</span></pre><p id="dac8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将这个方法称为我的实现中的主力，因为这是我读取元数据文件(wnidx.txt、val_annotations.txt 等)和构建包含各种类的图像列表的字典并为这些类分配数字标签的地方。</p><p id="81c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，tiny-imagenet 中的训练和验证数据的组织是不同的，因此我有两种不同的方法来处理信息，但是我将它们合并为相同的字典格式。实现细节可以在—<a class="ae kf" href="https://github.com/ksachdeva/tiny-imagenet-tfds/blob/master/tiny_imagenet/_imagenet.py" rel="noopener ugc nofollow" target="_blank">https://github . com/ksachdeva/tiny-imagenet-tfds/blob/master/tiny _ imagenet/_ imagenet . py</a>查看</p><p id="ba64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">_split_generators</code>中，有趣的代码语句是我返回各种拆分生成器的返回值。代码应该足够清晰，不言自明。唯一需要注意的部分是<code class="fe le lf lg lh b">tfds.core.SplitGenerator</code>的<code class="fe le lf lg lh b">gen_kwargs</code>键。本质上，你传递的这个字段的值将作为<code class="fe le lf lg lh b">_generate_examples</code>的参数传递。</p><blockquote class="ms mt mu"><p id="d5e1" class="kg kh mv ki b kj kk kl km kn ko kp kq mw ks kt ku mx kw kx ky my la lb lc ld im bi translated">现在，你要实现这么多数据集类，当发出<code class="fe le lf lg lh b">download_and_prepare</code>时，你会得到一个错误通知，说它找不到<code class="fe le lf lg lh b">checksum</code>文件。这是第二步，花了我一点时间，大部分时间我花在这个问题上，而不是实现整个包。</p></blockquote><p id="74b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事情是这样的。对于您下载的每个远程存档文件(在本例中为<a class="ae kf" href="http://cs231n.stanford.edu/tiny-imagenet-200.zip." rel="noopener ugc nofollow" target="_blank">http://cs231n.stanford.edu/tiny-imagenet-200.zip</a>)，您需要提供校验和信息。校验和信息将存储在扩展名为<code class="fe le lf lg lh b">.txt</code>的文件中。因为我们正在开发自己的 python 包(即不在<code class="fe le lf lg lh b">tensorflow_datasets</code>中)，所以你还需要告诉<code class="fe le lf lg lh b">tensorflow_datasets</code>包含校验和的文件所在的目录。以下是你需要添加到你的模块中的内容，以便完成这个任务-</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="1b07" class="lq lr it lh b gy ls lt l lu lv">checksum_dir = os.path.join(os.path.dirname(__file__),'url_checksums/')</span><span id="99ac" class="lq lr it lh b gy lw lt l lu lv">checksum_dir = os.path.normpath(checksum_dir)</span><span id="3bbf" class="lq lr it lh b gy lw lt l lu lv">tfds.download.add_checksums_dir(checksum_dir)</span></pre><p id="f111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个方面是校验和文件的名称应该是什么？经过一段时间的反复试验，我发现它应该和你的类名同名，但是有蛇形的大小写，也就是说，对于<code class="fe le lf lg lh b">TinyImagenetDataset</code>，你应该把你的文件命名为<code class="fe le lf lg lh b">tiny_imagenet_dataset.txt</code>。这部分在他们的指南中不是很清楚，至少我在任何地方都找不到它，我必须自己想办法。</p><p id="9adf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这项工作还没有完成；您从哪里获得校验和本身呢？手动计算？幸运的是，这个框架会有所帮助。你所需要做的就是，当你第一次从一个使用你的数据集类的测试/例子中调用<code class="fe le lf lg lh b">download_and_prepare</code>时，你应该传递下面的参数</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="432e" class="lq lr it lh b gy ls lt l lu lv">dl_config = tfds.download.DownloadConfig(register_checksums=True)<br/>download_and_prepare(download_config=dl_config))</span></pre><p id="814a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您将看到下载成功，没有任何校验和错误，并且您的校验和文件(在本例中为 tiny_imagenet_dataset.txt)将有一个条目。从这一点开始，您可以删除 download_config 参数。</p><p id="b0b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在该看<code class="fe le lf lg lh b">_generate_examples</code>了。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="712d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从代码中可以看出，这是一个生成函数<code class="fe le lf lg lh b">yielding</code>的两个返回值。第一个是键，它是将在<code class="fe le lf lg lh b">tfrecords</code>中写入的样本的唯一标识符，第二个是对应于您在<code class="fe le lf lg lh b">_info</code>方法中指定的模式的字典。正如我前面提到的，你不再需要读取图像文件，而是简单地提供图像文件的路径，<code class="fe le lf lg lh b">tensorflow_datasets</code>会确保读取它并将其嵌入到<code class="fe le lf lg lh b">tfrecords</code>中</p><h1 id="881d" class="mz lr it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">打包您的实现(可选)</h1><p id="4db0" class="pw-post-body-paragraph kg kh it ki b kj nw kl km kn nx kp kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">如果您正在构建私有数据集，那么它很可能只是存储库中的一个 python 包。但是，如果您在您的组织中共享它，并且拥有某种 python 包存储库，您可能需要构建一个 wheel 文件。</p><p id="fdb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里没有关于构建 python pip 包的具体内容，除了您希望确保在最终的构建中包含校验和文件。</p><p id="edb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看看<a class="ae kf" href="https://github.com/ksachdeva/tiny-imagenet-tfds/blob/master/setup.py" rel="noopener ugc nofollow" target="_blank">https://github . com/ksachdeva/tiny-imagenet-tfds/blob/master/setup . py</a>如何做的例子。</p><h1 id="f369" class="mz lr it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">结束语</h1><p id="3c45" class="pw-post-body-paragraph kg kh it ki b kj nw kl km kn nx kp kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">根据我到目前为止使用<code class="fe le lf lg lh b">tensorflow_datasets</code>的经验，它确实实现了为日常和重复性任务提供必要的抽象和支持的目标，同时提供了处理各种数据集的灵活性。还可以很容易地添加对您可能不想公开的数据集和驻留在<code class="fe le lf lg lh b">tensorflow_datasets</code>之外的数据集的支持。</p><p id="9612" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望您发现<code class="fe le lf lg lh b">tensorflow_datasets</code>在您的项目中的效用，并且这篇文章可以帮助您实现。</p></div></div>    
</body>
</html>