<html>
<head>
<title>Command-Line Cartography for a UK Election</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">英国大选的命令行制图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/command-line-cartography-uk-election-edition-4c2ba6054799?source=collection_archive---------32-----------------------#2019-11-12">https://towardsdatascience.com/command-line-cartography-uk-election-edition-4c2ba6054799?source=collection_archive---------32-----------------------#2019-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1680" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为选举之夜制作英国选区地图。</h2></div><p id="05c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程改编自<em class="lb"> @mbostock 的</em> <a class="ae lc" href="https://medium.com/@mbostock/command-line-cartography-part-1-897aa8f8ca2c" rel="noopener"> <em class="lb">命令行制图教程</em> </a> <em class="lb"> </em>的步骤，展示如何使用免费开源 Javascript 工具轻松制作英国选举结果专题地图。然后，我还使用 Python/Pandas/GeoPandas 堆栈重复了数据管理部分，以比较每种方法的简便性。</p><p id="5829" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们将要做的观想:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/e3616b84b7a2c458e05797c9eb905d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*GEpb5wuH15yhGGYDu2OKsA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">UK General Election 2017 results: Winners by constituency.</figcaption></figure><p id="34e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这张专题地图通过根据获得最多选票的政党给每个议会选区着色，传达了上次英国选举的结果。在此过程中，我们还将按选区显示投票率。</p><h2 id="59ee" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">获取边界几何图形</h2><p id="7918" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">创建地图的第一步是获得一些代表英国选区边界的多边形。法令调查每年发布两次<a class="ae lc" href="https://www.ordnancesurvey.co.uk/business-government/products/boundaryline" rel="noopener ugc nofollow" target="_blank">边界线</a>产品。我在 mySociety.org 找到了一个更方便的副本——可以用命令行获取</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="2e29" class="lp lq iq mo b gy ms mt l mu mv">curl --progress-bar http://parlvid.mysociety.org/os/bdline_gb-2019-10.zip -O bdline_gb-2019-10.zip</span></pre><p id="5e3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">归档包含许多不同的管理边界，并且相当大(因此我添加了<code class="fe mw mx my mo b">--progress-bar</code>选项)。我们只需要为这个图表提取威斯敏斯特选区边界文件。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="470b" class="lp lq iq mo b gy ms mt l mu mv">unzip -o bdline_gb-2019-10.zip Data/GB/westminster_const_region.prj Data/GB/westminster_const_region.shp Data/GB/westminster_const_region.dbf Data/GB/westminster_const_region.shx</span><span id="4dd6" class="lp lq iq mo b gy mz mt l mu mv">mv Data/GB/westminster_const_region.* .</span></pre><p id="993f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如@mbostock 所建议的，访问<a class="ae lc" href="http://mapshaper.org/" rel="noopener ugc nofollow" target="_blank">mapshaper.org</a>并将<code class="fe mw mx my mo b">westminster_const_region.shp</code>拖到你的浏览器中是预览我们提取的内容的好方法:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi na"><img src="../Images/89217ab348a663e020f121363386540a.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*SYKzupMqk4qaZaLXxh428w.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk"><code class="fe mw mx my mo b">westminster_const_region.shp on </code><a class="ae lc" href="http://mapshaper.org/" rel="noopener ugc nofollow" target="_blank">mapshaper.org</a></figcaption></figure><p id="f817" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来不错，但是北爱尔兰选区不见了。原来这些可以从北爱尔兰测绘局单独得到:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="f1ff" class="lp lq iq mo b gy ms mt l mu mv">wget http://osni-spatial-ni.opendata.arcgis.com/datasets/563dc2ec3d9943428e3fe68966d40deb_3.zip</span><span id="c8ce" class="lp lq iq mo b gy mz mt l mu mv">unzip <a class="ae lc" href="http://parlvid.mysociety.org/os/osni-dec-2015.tar.gz" rel="noopener ugc nofollow" target="_blank">563dc2ec3d9943428e3fe68966d40deb_3.zip</a></span></pre><h2 id="dffa" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><strong class="ak">进行设置</strong></h2><p id="93b5" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们将使用一系列 Javascript 命令行工具，Mike Bostock 在他的教程中有更详细的描述。如果您还没有安装它们，可以使用以下命令进行安装[<em class="lb">您需要安装 node 和 npm，以便下一步工作</em>]:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="d21e" class="lp lq iq mo b gy ms mt l mu mv">npm install -g shapefile          # gives us shp2json<br/>npm install -g d3-geo-projection  # geoproject, geo2svg<br/>npm install -g topojson           # geo2topo, topo2geo<br/>npm install -g ndjson-cli<br/>npm install -g d3</span></pre><p id="ecc0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<strong class="kh ir"> shp2json </strong>将 Shapefiles 转换为 GeoJSON:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="82c3" class="lp lq iq mo b gy ms mt l mu mv">shp2json <!-- -->westminster_const_region.shp<!-- --> -o gb.json</span></pre><p id="60c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">英国(GB)边界文件数据已经被投影到<a class="ae lc" href="https://epsg.io/27700" rel="noopener ugc nofollow" target="_blank">英国国家网格</a> (EPSG:27700)上。然而，北爱尔兰(NI)边界的几何数据在<a class="ae lc" href="https://epsg.io/4326" rel="noopener ugc nofollow" target="_blank"> EPSG:4326 </a> (WSG 84)中定义。我试图找到一种方法来使用<code class="fe mw mx my mo b">d3-geo-projection</code>转换的镍几何 EPSG:27700，但我不得不承认，这超出了我。相反，我回过头来使用<code class="fe mw mx my mo b">ogr2ogr</code>来转换 NI shapefile。我在 MacOS 上，所以可以使用<a class="ae lc" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> brew </a>安装<code class="fe mw mx my mo b">ogr2ogr</code>:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="4569" class="lp lq iq mo b gy ms mt l mu mv">brew install gdal</span></pre><p id="3a56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我将 Shapefile 从 EPSG 4326 重新投影到 EPSG 27700，如下所示:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="2511" class="lp lq iq mo b gy ms mt l mu mv">ogr2ogr -f "ESRI Shapefile" ni.shp OSNI_Open_Data_Largescale_Boundaries__Parliamentary_Constituencies_2008.shp -t_srs EPSG:27700 -s_srs EPSG:4326</span></pre><p id="1a14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将此 Shapefile 转换为 GeoJSON，就像我们之前处理 GB 边界一样:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="c7a9" class="lp lq iq mo b gy ms mt l mu mv">shp2json ni.shp -o ni.json</span></pre><h2 id="edc3" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><strong class="ak">合并 GB 和 NI 几何图形</strong></h2><p id="231b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们已经将二进制 shapefiles 转换为更易于人类阅读的 GeoJSON。但是我们还有两份独立的文件。将所有边界放在一个文件中会方便得多。</p><p id="c811" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在他的教程的第 2 部分，Mike 介绍了<code class="fe mw mx my mo b">ndjson-cli</code>，这是他创建和操作 ndjson 的工具。我想我们可以使用这个工具将 GeoJSON 文件转换成换行符分隔的 JSON，然后简单地将它们<code class="fe mw mx my mo b">cat</code>在一起。我还需要取出选区标识符，并使用<code class="fe mw mx my mo b">ndjson-map</code>使其在每个文件中通用:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="6554" class="lp lq iq mo b gy ms mt l mu mv">ndjson-split ‘d.features’ &lt; gb.json \<br/>| ndjson-map '{id: d.properties.CODE, properties:d.properties, type:d.type, geometry:d.geometry}' &gt; gb_id.ndjson</span><span id="0ad7" class="lp lq iq mo b gy mz mt l mu mv">ndjson-split 'd.features' &lt; ni.json \<br/>| ndjson-map '{id: d.properties.PC_ID, properties:d.properties, type:d.type, geometry:d.geometry}' &gt; ni_id.ndjson</span><span id="167f" class="lp lq iq mo b gy mz mt l mu mv">cat gb_id.ndjson ni_id.ndjson &gt; uk.ndjson</span></pre><p id="0413" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我试着从这一点开始用<code class="fe mw mx my mo b">ndjson</code>将几何图形导入<code class="fe mw mx my mo b">geoprojection</code>，但这并不成功。我发现在继续投影之前，有必要使用<code class="fe mw mx my mo b">ndjson-reduce</code>命令将连接的边界转换回单个 JSON 对象:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="32dd" class="lp lq iq mo b gy ms mt l mu mv">ndjson-reduce 'p.features.push(d), p' '{type: "FeatureCollection", features: []}' &lt; uk.ndjson &gt; uk.json</span></pre><p id="00ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，我们在一个 JSON 文件中包含了所有的边界。但是，这个文件大约有 120M。很明显，这些几何图形的定义比我们基于网络的可视化所需要的更加详细。为了减小文件大小，我们可以为图表定义一个边界框(以像素为单位),然后在不明显丢失细节的情况下，适当简化该框的多边形。</p><p id="3b00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<strong class="kh ir"> geoproject </strong>工具和<code class="fe mw mx my mo b">d3.geoIdentity()</code>的<code class="fe mw mx my mo b">.fitsize()</code>方法将点映射到我们选择的边界框中[ <em class="lb">我还利用这个机会垂直翻转多边形定义，因为我们最终将渲染为 svg </em>:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="7165" class="lp lq iq mo b gy ms mt l mu mv">geoproject 'd3.geoIdentity().reflectY(true).fitSize([960, 960], d)'\<br/>&lt; uk.json &gt; uk-960.json</span></pre><p id="a680" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过切换到 TopoJSON，然后<em class="lb">简化</em>、<em class="lb">量化、</em>和<em class="lb">压缩</em>多边形定义来减小 GeoJSON 文件的大小。请阅读<a class="nb nc ep" href="https://medium.com/u/c918c478bb49?source=post_page-----4c2ba6054799--------------------------------" rel="noopener" target="_blank"> Mike Bostock </a>的教程的<a class="ae lc" href="https://medium.com/@mbostock/command-line-cartography-part-3-1158e4c55a1e" rel="noopener">第 3 部分</a>以获得这些步骤的更详细的解释，我在下面复制了这些步骤。</p><p id="67a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用<a class="ae lc" href="https://github.com/topojson/topojson-server/blob/master/README.md#geo2topo" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> geo2topo </strong> </a>转换为 TopoJSON，然后使用<a class="ae lc" href="https://github.com/topojson/topojson-simplify/blob/master/README.md#toposimplify" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">topo simplify</strong></a><strong class="kh ir"/>和<strong class="kh ir"> topoquantize </strong>工具将文件大小从 120M 减少到 385K:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="84b7" class="lp lq iq mo b gy ms mt l mu mv">geo2topo const=uk-960.json \<br/>| toposimplify -p 1 -f \<br/>| topoquantize 1e5 \<br/>&gt; uk-simpl-topo.json</span></pre><p id="8493" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们快速查看一下我们的输出。要在命令行生成 svg，我们可以使用<code class="fe mw mx my mo b">geo2svg</code>工具。首先，我们使用<code class="fe mw mx my mo b">topo2geo</code>转换回 GeoJSON:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="ff7b" class="lp lq iq mo b gy ms mt l mu mv">topo2geo const=- &lt; uk-simpl-topo.json \<br/>| geo2svg -p 1 -w 960 -h 960 &gt; uk.svg</span></pre><p id="d4d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">svg 文件可以拖到 web 浏览器中，让我们快速浏览。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7d6fc71a71370ce440f792aa56dc743b.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*lhRi0pZXe6f389mopVtNqA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">The United Kingdom of Great Britain &amp; Northern Ireland in SVG via TopoJSON!</figcaption></figure><h2 id="f6bb" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">添加选举结果</h2><p id="604b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">所以我们准备了我们的选区边界。现在我们想根据一些选举结果给这些多边形着色。</p><p id="5e58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在英国议会网站上找到了一个包含 1918 年选举结果的 csv:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="4c05" class="lp lq iq mo b gy ms mt l mu mv">wget <a class="ae lc" href="http://researchbriefings.files.parliament.uk/documents/CBP-8647/1918-2017election_results.csv" rel="noopener ugc nofollow" target="_blank">http://researchbriefings.files.parliament.uk/documents/CBP-8647/1918-2017election_results.csv</a> -O <a class="ae lc" href="http://researchbriefings.files.parliament.uk/documents/CBP-8647/1918-2017election_results.csv" rel="noopener ugc nofollow" target="_blank">1918_2017election_results.csv</a></span></pre><p id="9763" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用命令行工具<code class="fe mw mx my mo b">gawk</code>来过滤这个 csv，以获得 2017 年的结果，并用零填充空值。棘手的部分是一些选区名称包含逗号，需要忽略。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="4f23" class="lp lq iq mo b gy ms mt l mu mv">gawk -F ',' -v OFS=',' '{for (i=1;i&lt;=NF;i++) { if ($i=="") $i="0" }; print}' &lt; 1918_2017election_results.csv | gawk 'NR==1 {print}; { if ($18 == 2017) print}' FPAT='([^,]+)|("[^"]+")' &gt; 2017_results.csv</span></pre><p id="86f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mike 展示了如何通过首先转换成换行符分隔的 json 来将这样的数据与几何连接起来。以他为例，我使用<code class="fe mw mx my mo b">csv2json</code>和他的<code class="fe mw mx my mo b">ndjson-cli</code>工具首先转换选举结果:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="99a8" class="lp lq iq mo b gy ms mt l mu mv">csv2json &lt; 2017_results.csv | tr -d '\n' | ndjson-split &gt; 2017_results.ndjson</span></pre><p id="3ef2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，我们将边界几何准备为 ndjson:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="271f" class="lp lq iq mo b gy ms mt l mu mv">topo2geo const=- &lt; uk-simpl-topo.json | \<br/>ndjson-split 'd.features' &gt; uk-simpl.ndjson</span></pre><p id="f47d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并将两者结合在一起:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="af8c" class="lp lq iq mo b gy ms mt l mu mv">ndjson-join 'd.id' 'd.constituency_id' uk-simpl.ndjson 2017_results.ndjson \<br/>| ndjson-map 'd[0].results = d[1], d[0]' \<br/>&gt; uk_2017_results.ndjson</span></pre><p id="e49a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mike 的示例是根据该区域的人口密度值给地图的多边形着色。我在选举结果中拥有的最相似的量——即连续量——是投票率。因此，为了能够效仿他的例子，我决定在继续寻找获胜者之前，利用这些投票率信息制作一个氯普勒斯图。</p><p id="172b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下代码使用<code class="fe mw mx my mo b">ndjson-map</code>为 GeoJson 中的每个要素(即选区)分配一个名为<code class="fe mw mx my mo b">fill</code>的属性。当我们使用<code class="fe mw mx my mo b">geo2svg</code>来生成我们的图像时，它会选择这个属性，并用它来给多边形着色。<code class="fe mw mx my mo b">fill</code>的值需要是一个字符串，包含我们希望每个多边形颜色的十六进制代码(如<code class="fe mw mx my mo b">#0087dc</code>)。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="c07e" class="lp lq iq mo b gy ms mt l mu mv">ndjson-map -r d3 'z = d3.scaleSequential(d3.interpolateViridis).domain([0.5, .8]), d.properties.fill = z(d.results["turnout "]), d' &lt; uk_2017_results.ndjson \<br/>| geo2svg -n --stroke none -p 1 -w 960 -h 960 &gt; uk_2017_turnout.svg</span></pre><p id="03e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能值得尝试将这个一行程序分解一点，以了解发生了什么。我们使用 d3 将投票率信息(一个介于 0 和 1 之间的数字，代表在该选区实际投票的选民比例)转换成一个十六进制代码。<code class="fe mw mx my mo b">ndjson-map</code>工具让我们遍历每个选区并应用某种操作。我们传递给<code class="fe mw mx my mo b">ndjson-map</code>的参数是三行 Javascript 代码。</p><p id="15da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二行:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="1a87" class="lp lq iq mo b gy ms mt l mu mv">d.properties.fill = z(d.results["turnout "])</span></pre><p id="4a26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为每个特性创建一个名为<code class="fe mw mx my mo b">fill</code>的属性，其值是函数<code class="fe mw mx my mo b">z</code>的输出。该函数<code class="fe mw mx my mo b">z</code>获取投票率的值——我们在之前的连接中已经将其附加到该特征上——并返回一个代表颜色的 hexcode。这个<code class="fe mw mx my mo b">z</code>函数在 Javascript 的第一行中定义:</p><p id="04dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my mo b">z = d3.scaleSequential(d3.interpolateViridis).domain([0.5,0.8])</code></p><p id="627c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它使用<a class="ae lc" href="https://github.com/d3/d3-scale-chromatic" rel="noopener ugc nofollow" target="_blank"> d3 的配色方案</a>将代表投票率的数字从绿色配色方案转换为适当的颜色。我检查了选举数据中的投票率值，以便设置<code class="fe mw mx my mo b">domain</code>的界限，从而尽可能多地使用色标。</p><p id="f263" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在浏览器中打开那个<code class="fe mw mx my mo b">uk_2017_turnour.svg</code>文件:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/dc229ec7f12d86046e4ac0ddb9b990b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*hCnXyEAbP0nj6nssuiduvQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">A green and pleasant land: turnout in the 2017 UK General Election</figcaption></figure><p id="a374" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图例在<a class="ae lc" href="https://observablehq.com/@wooduk/creating-legends-for-charts" rel="noopener ugc nofollow" target="_blank">可观察笔记本</a>中单独创建，并复制粘贴到“svg”文件中。</p><h2 id="4129" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">将方法应用于情节赢家</h2><p id="29a8" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">实际上，我在本教程中的目标是创建一个显示每个选区获胜者的地图。为此，我们重做最后一步，使用 ndjson-map 查找拥有最高投票份额的政党，然后将几何体的<code class="fe mw mx my mo b">fill</code>属性设置为代表该政党的颜色。</p><p id="20ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我传递给<code class="fe mw mx my mo b">ndjson-map</code>的 Javascript 在这里感觉有点笨拙，因为我定义了一个对象来保存对每一方的颜色的查找。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="aa69" class="lp lq iq mo b gy ms mt l mu mv">ndjson-map -r d3 's={"con_share":"#0087dc", "lib_share":"#FDBB30", "lab_share":"#d50000", "natSW_share":"#3F8428", "pld":"#3F8428", "oth_share":"#aaaaaa"}, u = ({ con_share, lab_share, lib_share, oth_share, natSW_share }) =&gt; ({ con_share, lab_share, lib_share, oth_share, natSW_share }),<br/>d.properties.fill = s[Object.keys(u(d.results)).reduce((a, b) =&gt; d.results[a] &gt; d.results[b] ? a : b)], d' &lt; uk_2017_results.ndjson \<br/>| geo2svg -n --stroke none -p 1 -w 960 -h 960 &gt; uk_2017_winner.svg</span></pre><p id="fadc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再一次，将 javascript 分解一点，第一行:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="ffd3" class="lp lq iq mo b gy ms mt l mu mv">s={"con_share":"#0087dc", "lib_share":"#FDBB30", "lab_share":"#d50000", "natSW_share":"#3F8428", "pld":"#3F8428", "oth_share":"#aaaaaa"}</span></pre><p id="cf71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地定义了从当事人到颜色的查找。第二行:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="bfd3" class="lp lq iq mo b gy ms mt l mu mv">u = ({ con_share, lab_share, lib_share, oth_share, natSW_share }) =&gt; ({ con_share, lab_share, lib_share, oth_share, natSW_share })</span></pre><p id="0ad0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是一个<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构赋值</a>，我们用它从选举结果对象中提取 voteshare 数字。然后是最后一行:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="2b7c" class="lp lq iq mo b gy ms mt l mu mv">d.properties.fill = s[Object.keys(u(d.results)).reduce((a, b) =&gt; d.results[a] &gt; d.results[b] ? a : b)]</span></pre><p id="fbaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">找到投票份额最大的一方的密钥，并在查找对象<code class="fe mw mx my mo b">s</code>中使用该密钥将所需颜色写入<code class="fe mw mx my mo b">fill</code>属性。</p><p id="a251" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看结果:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/e3616b84b7a2c458e05797c9eb905d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*GEpb5wuH15yhGGYDu2OKsA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">2017 General Election UK results constituencies coloured by winner.</figcaption></figure><p id="b7b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有结果了。您可以就此打住，除非您想看看如何使用 Python 堆栈实现同样的功能。</p><h1 id="3e86" class="nf lq iq bd lr ng nh ni lu nj nk nl lx jw nm jx ma jz nn ka md kc no kd mg np bi translated">第 2 部分:Python 中的数据管理</h1><p id="0579" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在本教程的第一部分，我们在命令行上使用 Javascript 工具制作了一个英国选举地图，下面是迈克·博斯托克的命令行制图教程。对于数据管理，我通常倾向于 Python 环境。所以在第二部分中，我回过头来看看如何在 Python REPL 中使用熊猫和 GeoPandas 来实现同样的效果。</p><p id="36bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更接近“命令行”风格，我将使用 Python REPL 来做这件事，当然，Jupyter 笔记本/实验室会议也很好。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="0e9a" class="lp lq iq mo b gy ms mt l mu mv">python</span></pre><p id="16cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<a class="ae lc" href="http://geopandas.org/" rel="noopener ugc nofollow" target="_blank"> GeoPandas </a>库以及 Pandas 进行一些常规的数据操作:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="4ab0" class="lp lq iq mo b gy ms mt l mu mv">import pandas as pd<br/>import geopandas as gpd</span></pre><p id="167a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们将英国的选区多边形边界读入地理数据框架:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="229d" class="lp lq iq mo b gy ms mt l mu mv">gb_shape = gpd.read_file('westminster_const_region.shp')</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/e8e7150b808e63c99f3a7beb92c52884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E7kHS5SKMngPNegG.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">A quick look at the imported shapefile as a DataFrame.</figcaption></figure><p id="8781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想更直观地检查几何图形，我们可以导入 matplotlib，然后只需在地理数据框架上调用<code class="fe mw mx my mo b">.plot()</code>:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="fd8b" class="lp lq iq mo b gy ms mt l mu mv">import matplotlib.pyplot as plt<br/>gb_shape.plot(); plt.show()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/42f8a61f34b5604737a8a1f00316b82d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/0*euwFd1AMhtKV2Go_.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">A quick visual check on the content of the GB shapefile.</figcaption></figure><p id="173b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我注意到在后来的图中设得兰群岛从地图上消失了，我认为这个数据中的<code class="fe mw mx my mo b">CODE</code>字段有错误:<code class="fe mw mx my mo b">S1400005</code>应该是<code class="fe mw mx my mo b">S14000051</code>。所以现在让我们快速改变这种情况。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="c045" class="lp lq iq mo b gy ms mt l mu mv">gb_shape['CODE']=gb_shape.CODE.apply(lambda s: 'S14000051' if s == 'S1400005' else s)</span></pre><p id="99c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在加载北爱尔兰的选区边界:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="ba21" class="lp lq iq mo b gy ms mt l mu mv">ni_shape = gpd.read_file(‘OSNI_Open_Data_Largescale_Boundaries__Parliamentary_Constituencies_2008.shp’)</span></pre><p id="65d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望将两组边界连接成一个数据帧。为此，我首先需要调整列名，使它们匹配:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="3465" class="lp lq iq mo b gy ms mt l mu mv">ni_shape.rename(columns={'PC_NAME':'NAME','PC_ID':'CODE'},inplace=True)</span></pre><p id="2ad7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二，正如我们在前面的教程中发现的，GB 和 NI 边界几何在不同的坐标系中提供。英国(GB)边界文件数据已经被投影到<a class="ae lc" href="https://epsg.io/27700" rel="noopener ugc nofollow" target="_blank">英国国家网格</a> (EPSG:27700)。然而，北爱尔兰(NI)边界的几何数据在<a class="ae lc" href="https://epsg.io/4326" rel="noopener ugc nofollow" target="_blank"> EPSG:4326 </a>中定义。我们可以使用 GeoPandas 来完成这种转换，而不是使用<code class="fe mw mx my mo b">ogr2ogr</code>:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="9371" class="lp lq iq mo b gy ms mt l mu mv">ni_shape.to_crs({‘init’:’epsg:27700'},inplace=True)</span></pre><p id="eb2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们应该准备好使用<code class="fe mw mx my mo b">pd.concat</code>连接两组几何图形，这将产生另一个<code class="fe mw mx my mo b">GeoDataFrame</code>。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="0ea1" class="lp lq iq mo b gy ms mt l mu mv">uk_boundaries = pd.concat([gb_shape[['NAME','CODE','geometry']],ni_shape[['NAME','CODE','geometry']]], sort=False)</span></pre><h1 id="875a" class="nf lq iq bd lr ng nh ni lu nj nk nl lx jw nm jx ma jz nn ka md kc no kd mg np bi translated">将选举结果与几何图形合并</h1><p id="ef5f" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在把我们的选举结果读入数据框:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="2c20" class="lp lq iq mo b gy ms mt l mu mv">results=pd.read_csv(‘<a class="ae lc" href="http://researchbriefings.files.parliament.uk/documents/CBP-8647/1918-2017election_results.csv" rel="noopener ugc nofollow" target="_blank">1918_2017election_results.csv</a>’)</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ca"><img src="../Images/3fde34d1f46edf6a0fca186fbe6b0f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xmiiJOM43jeO2Xlk.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">First 10 rows of the election results csv file.</figcaption></figure><p id="29f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想过滤此数据框架，以仅包含 2017 年选举的结果。[ <em class="lb">我还首先重命名了一些列，以纠正尾随空白，并着眼于以后与几何数据合并] </em>。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="16fd" class="lp lq iq mo b gy ms mt l mu mv"># rename a few columns<br/>results.rename(columns={<br/>‘turnout ‘:’turnout’,<br/>’constituency_id’:’CODE’,<br/>},inplace=True)# keep only the 2017 election results<br/>results=results[results.election=='2017']# keep only the columns we need<br/>results=results[[‘CODE’,’constituency’,’country/region’,’con_share’,’lib_share’,’lab_share’,’natSW_share’,’oth_share’,’turnout’]]uk_results = uk_boundaries.merge(results, on='CODE')</span></pre><p id="bf5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my mo b">uk_results</code>数据框包含每个选区的几何图形和选举结果。</p><p id="1770" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在命令行制图教程中，我们简化了几何体，使生成的文件更小。可以使用 GeoPandas 来完成这个<a class="ae lc" href="https://shapely.readthedocs.io/en/stable/manual.html#object.simplify" rel="noopener ugc nofollow" target="_blank">简化</a>(通过 Shapely):</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="466c" class="lp lq iq mo b gy ms mt l mu mv">uk_results[‘geometry’] = uk_results.geometry.simplify(tolerance=500)</span></pre><h1 id="da51" class="nf lq iq bd lr ng nh ni lu nj nk nl lx jw nm jx ma jz nn ka md kc no kd mg np bi translated">准备演示</h1><p id="6334" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">虽然当然可以使用 Python 堆栈生成 svg，但我的第一个目标是从合并的数据中创建 GeoJSON 输出。这将允许我退回到 javascript 的命令行制图世界，或者在最终的演示文稿中制作工作。</p><p id="4f28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了方便起见——我仍然觉得 Javascript 中的数据管理不够直观——我现在使用 Pandas 将几何图形的填充颜色合并到数据帧中。一方面，我对这种将表示和底层数据混为一谈的做法感到有点不舒服。另一方面，这并不妨碍我或其他人忽略这种嵌入的填充颜色，并从将保留在 GeoJSON 中的底层数据中导出新的表示。</p><p id="614f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我做了一个定义派对颜色的小字典，摘自<a class="ae lc" href="http://www.blog.richardallen.co.uk/uk-political-party-web-colours/" rel="noopener ugc nofollow" target="_blank">这里</a>:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="368c" class="lp lq iq mo b gy ms mt l mu mv">party_colours={<br/>   “con”:”#0087dc”, <br/>   “lib”:”#FDBB30", <br/>   “lab”:”#d50000", <br/>   "snp":"#FFF95D", <br/>   “pld”:”#3F8428"<br/>}</span></pre><p id="7dd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们算出每个选区的获胜者。和以前一样，获胜者只是拥有最高的投票份额。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="4f46" class="lp lq iq mo b gy ms mt l mu mv">uk_results['winner']= uk_results[['con_share','lab_share','lib_share','natSW_share','oth_share']].fillna(0.).astype(float).idxmax(axis=1).apply(lambda s: s[:3])</span></pre><p id="842b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人稍感不满的是，我获得的选举结果数据没有将苏格兰和威尔士的主要民族主义政党分开，而是将它们归为一类。但是，因为苏格兰民族党不在威尔士竞选候选人，而格子党在苏格兰竞选候选人，所以我们可以使用选区区域来确定每种情况下的特定民族党，从而分配适当的颜色。</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="d764" class="lp lq iq mo b gy ms mt l mu mv">def sub_nat(winner, region):<br/>   if winner=='nat':<br/>      if region=='Wales':<br/>         return 'pld'<br/>      else:<br/>         return 'snp'<br/>   else:<br/>      return winneruk_results['winner']=uk_results[['country/region','winner']].apply(lambda r: sub_nat(r[1],r[0]), axis=1)uk_results['winner_fill']=uk_results.winner.apply(lambda s: party_colours.get(s,”#aaaaaa”))</span></pre><p id="2ae0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并没有解决北爱尔兰政党的色彩问题。我必须寻找一个更详细的选举结果数据集来提供这种分类。</p><p id="f723" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以写出这个数据帧:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="7b96" class="lp lq iq mo b gy ms mt l mu mv">uk_results.to_file(‘gdp_uk_results.json’,driver=’GeoJSON’)</span></pre><p id="d9b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，我们可以切换回命令行制图并生成一个 svg:</p><pre class="le lf lg lh gt mn mo mp mq aw mr bi"><span id="9641" class="lp lq iq mo b gy ms mt l mu mv">geoproject 'd3.geoIdentity().reflectY(true).fitSize([960, 960], d)' &lt; gdp_uk_results.json \<br/>| ndjson-split 'd.features' \<br/>| ndjson-map -r d3 'd.properties.fill = d.properties.winner_fill, d' \<br/>| geo2svg -n --stroke none -p 1 -w 960 -h 960 &gt; gdp_uk_winner.svg</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/234f7d943f2bd347167062b1649e1fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/0*rUO_n_9UUxBpX6CO.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">The rendered SVG</figcaption></figure><p id="073b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们有它。我使用 Python 和 Pandas 进行数据操作的频率比使用命令行工具如<code class="fe mw mx my mo b">awk</code> Javascript 要高得多。因此，不可避免地，我发现通过本教程一起操作几何图形和选举结果比在第 1 部分中更容易和更直观。也许这只是我的熟悉偏见。</p><p id="3f83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我仍然更喜欢可观察的笔记本和数据驱动的文档哲学，以便在网上展示结果。但是我对探索 Altair 的能力很感兴趣，特别是输出织女星的描述，这些描述很容易嵌入网页。也许在以后的文章中。</p><p id="6fe4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一天，我们可以讨论在地理地图上显示这些数据的优点，而不是，比如说，在选区上放置相等面积的地图。</p><p id="30ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢<em class="lb"> @mbostock </em>提供的所有工具和鼓舞人心的文章。</p></div></div>    
</body>
</html>