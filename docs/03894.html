<html>
<head>
<title>A Gentle Introduction to IoT/GPS Trajectory Clustering and Geospatial Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">物联网/GPS 轨迹聚类和地理空间聚类简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-introduction-to-iot-gps-trajectory-clustering-and-geospatial-clustering-daba8da8c41e?source=collection_archive---------13-----------------------#2019-06-19">https://towardsdatascience.com/a-gentle-introduction-to-iot-gps-trajectory-clustering-and-geospatial-clustering-daba8da8c41e?source=collection_archive---------13-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e5e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当谈到开发增值主张时，物联网、互联设备和地理空间数据都是热门话题。在这篇文章中，我将温和地介绍应用于 GPS 轨迹的无监督学习技术。</p><p id="e716" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据来自<a class="ae ko" href="https://www.microsoft.com/en-us/download/details.aspx?id=52367&amp;from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fdownloads%2Fb16d359d-d164-469e-9fd4-daa38f2b2e13%2F" rel="noopener ugc nofollow" target="_blank">微软亚洲研究院</a>，包含 2007 年 4 月至 2012 年 8 月间 182 名用户和 17621 次旅行的数据。数据大多是密集的，每 1 到 5 秒记录一次经度和纬度。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="1e43" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据准备和清理</h1><p id="1611" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">现在让我们来看看数据文件本身。嗯。plt '格式，一个我没见过的格式，不过还是用文本编辑打开吧。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/fe4f9bf3b7c358597fe359032bdb9d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FFk160TtkYRV_DgBsvjxQ.png"/></div></div></figure><p id="f0c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好极了，看起来熊猫 read_csv 函数可以很好地与。plt 文件格式，附带的关于数据结构的文档看起来很准确。</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="8893" class="mq kx it mm b gy mr ms l mt mu">import pandas as pd</span><span id="4567" class="mq kx it mm b gy mv ms l mt mu">colnames = ['lat','long', 'null', 'alt' ,'DateTime','Date','Time']</span><span id="7177" class="mq kx it mm b gy mv ms l mt mu">df = pd.read_csv('20090724005608.plt', skiprows=6, names = colnames)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mw"><img src="../Images/2ad12db24882fa05e12395132ea5c5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EClXmwO_-7uwPCYioYu0Og.png"/></div></div></figure><p id="c137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将时间序列放在一个数据框中很好，但是我们需要将每个数据框转换成具有多个特征的单个观察值。这样做将格式化数据，以便加载到聚类分析算法中。让我们合计速度、加速度和加加速度的第 10、25、50、75、90 和平均值。为此，我们将编写几个 python 函数来应用于每个文件。</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="620b" class="mq kx it mm b gy mr ms l mt mu">def add_feat(df_input):<br/>    """<br/>    This function takes in raw lat long time series from the microsoft geolife data.</span><span id="8146" class="mq kx it mm b gy mv ms l mt mu">Preprocessing notes: skip the first six lines before doing pandas read csv , expecting columns in ['lat','long', 'null', 'alt' ,'DateTime','Date','Time']</span><span id="266d" class="mq kx it mm b gy mv ms l mt mu">Requres: pandas imported as pd<br/>             from vincenty import vincenty<br/>         <br/>    Adds:<br/>        speed<br/>        acceleration<br/>        jerk<br/>        bearing rate<br/>        distance travelled<br/>    """<br/>    df = df_input<br/>    # add some initial shifts<br/>    df['lat_shift'] = df.lat.shift(-1)<br/>    df['long_shift'] = df.long.shift(-1)<br/>    df['time_shift'] = df.DateTime.shift(-1)<br/>    # add speed<br/>    def speed(x):<br/>        try:<br/>            s = vincenty((x[-3],x[-2]),(x[0],x[1]), miles = True) / ((x[-1]-x[4]) * 24)<br/>        except:<br/>            s= np.nan<br/>        return s<br/>    df['speed_mph'] = df.apply(speed,axis =1)<br/>    df['speed_shift'] = df.speed_mph.shift(-1)<br/>    # add acceleration<br/>    def accel(x):<br/>        try:<br/>            a = (x[-1] - x[-2]) / ((x[9] - x[4]) *24*60*60)<br/>        except:<br/>            a = np.nan<br/>        return a<br/>    df['acceleration'] = df.apply(accel, axis =1)<br/>    df['acceleration_shift'] = df.acceleration.shift(-1)<br/>    # add jerk<br/>    def jerk(x):<br/>        try:<br/>            j = (x[-1] - x[-2]) / ((x[9] - x[4]) *24*60*60)<br/>        except:<br/>            j = np.nan<br/>        return a<br/>    df['jerk'] = df.apply(accel, axis =1)<br/>    df['jerk_shift'] = df.jerk.shift(-1)<br/>    # add y for bearing calculator<br/>    def y(x):<br/>        try:<br/>            yy = np.sin((x[8] - x[0]) * np.pi/180) *np.cos( x[7]* np.pi/180)<br/>        except:<br/>            yy= np.nan<br/>        return yy<br/>    df['y'] = df.apply(y, axis =1)<br/>    # add x for bearing calculator <br/>    def x(x):<br/>        try:<br/>            xx = np.cos(x[0] * np.pi/180) *np.sin(x[7]* np.pi/180) - np.sin(x[0]* np.pi/180) * np.cos(x[7]* np.pi/180)*np.cos((x[8]-x[1])* np.pi/180)<br/>        except:<br/>            xx = np.nan<br/>        return xx<br/>    df['x'] = df.apply(x,axis =1)<br/>    # calculate bearing<br/>    def bearing(x):<br/>        try:<br/>            b = np.arctan2(x[-2],x[-1])*180/np.pi<br/>        except:<br/>            b = np.nan<br/>        return b<br/>    df['bearing'] = df.apply(bearing,axis=1)</span><span id="8bf0" class="mq kx it mm b gy mv ms l mt mu">df['brearing_shift'] = df.bearing.shift(-1)<br/>    # calculate bearing rate (rate of change of direction)<br/>    def bearing_rate(x):<br/>        try:<br/>            br = abs(x[-1]-x[-2])<br/>        except:<br/>            br = np.nan<br/>        return br<br/>    df['bearing_rate'] = df.apply(bearing_rate,axis=1)<br/>    # calculate distance travelled<br/>    def distance(x):<br/>        try:<br/>            dist = vincenty((x[7],x[8]),(x[0],x[1]), miles = True)<br/>        except:<br/>            dist= np.nan<br/>        return dist<br/>    df['distance'] = df.apply(distance,axis = 1)<br/>    <br/>    df.drop(df.tail(4).index,inplace=True)<br/>    return df</span><span id="ef4a" class="mq kx it mm b gy mv ms l mt mu">def list_df_summary(input_df):<br/>    '''<br/>    Converts output from add_feat function into an observation for machine learning<br/>    '''<br/>    names = ['speed_10','speed_25','speed_50','speed_75','speed_90','speed_ave',<br/>            'accel_10','accel_25','accel_50','accel_75','accel_90','accel_ave',<br/>            'jerk_10','jerk_25','jerk_50','jerk_75','jerk_90','jerk_ave',<br/>            'bearingRate_10','bearingRate_25','bearingRate_50','bearingRate_75','bearingRate_90','bearingRate_ave',<br/>            'distance_traveled','time_traveled' ,'last_lat','last_long','start_lat','start_long'<br/>            <br/>            ]<br/>    values = list()<br/>    #speed<br/>    values.append(input_df.quantile(.10)[8])<br/>    values.append(input_df.quantile(.25)[8])<br/>    values.append(input_df.quantile(.50)[8])<br/>    values.append(input_df.quantile(.75)[8])<br/>    values.append(input_df.quantile(.90)[8])<br/>    values.append(input_df.mean()[8])<br/>    #accel<br/>    values.append(input_df.quantile(.10)[10])<br/>    values.append(input_df.quantile(.25)[10])<br/>    values.append(input_df.quantile(.50)[10])<br/>    values.append(input_df.quantile(.75)[10])<br/>    values.append(input_df.quantile(.90)[10])<br/>    values.append(input_df.mean()[10])<br/>    #jerk<br/>    values.append(input_df.quantile(.10)[12])<br/>    values.append(input_df.quantile(.25)[12])<br/>    values.append(input_df.quantile(.50)[12])<br/>    values.append(input_df.quantile(.75)[12])<br/>    values.append(input_df.quantile(.90)[12])<br/>    values.append(input_df.mean()[12])<br/>    #bearing<br/>    values.append(input_df.quantile(.10)[18])<br/>    values.append(input_df.quantile(.25)[18])<br/>    values.append(input_df.quantile(.50)[18])<br/>    values.append(input_df.quantile(.75)[18])<br/>    values.append(input_df.quantile(.90)[18])<br/>    values.append(input_df.mean()[18])<br/>    #distance travelled<br/>    values.append(input_df.distance.sum())<br/>    #time travelled<br/>    values.append((input_df.iloc[-1,4] - input_df.iloc[0,4])*24*60)<br/>    #lat long<br/>    values.append(input_df.iloc[-1,0])<br/>    values.append(input_df.iloc[-1,1])<br/>    values.append(input_df.iloc[0,0])<br/>    values.append(input_df.iloc[0,1])<br/>    <br/>    <br/>    return pd.DataFrame([values],columns=names)</span></pre><p id="3f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了遍历文件目录，我使用了一个名为 glob 的包。下面的代码完成了为每个。GeoLife 目录中的 plt 文件。然后通过运行 for 循环。plt 列出并应用前面的函数让我们为机器学习做好准备！</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="cd60" class="mq kx it mm b gy mr ms l mt mu">plts = []<br/>for folder in glob('Geolife Trajectories 1.3/Data/*/Trajectory'):<br/>    for file in glob(folder +'/*.plt'):<br/>        plts.append(file)</span><span id="1cc7" class="mq kx it mm b gy mv ms l mt mu">large_df = []<br/>for i, file in enumerate(plts):<br/>    print( int(i*100 / len(plts)))<br/>    try:<br/>        large_df.append(list_df_summary(add_feat(pd.read_csv(file, skiprows=6,names=colnames))))<br/>    except:<br/>        print('error at: ' + file)<br/>df = pd.concat(large_df)</span></pre><p id="668d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我的例子，我将使用 modeling_df 特性的一个子集来创建集群。不是每个特征都有有用的信息(<a class="ae ko" href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" rel="noopener ugc nofollow" target="_blank">阅读更多关于维度的诅咒</a>)。这是一个迭代的过程，你可以尝试不同的子集来开发不同的集群。最初，我查看每个特征的分布，猜测它是否对无监督学习算法有价值。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="0ba4" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">GPS 轨迹聚类</h1><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="4718" class="mq kx it mm b gy mr ms l mt mu">from sklearn.cluster import KMeans<br/>from sklearn.preprocessing import StandardScaler<br/>import seaborn as sns<br/>from collections import Counter</span><span id="a54a" class="mq kx it mm b gy mv ms l mt mu">## Remove longer trips<br/>df_local_all_feat=df[(df.time_traveled &lt; 300) &amp; (df.distance_traveled &lt; 100)&amp; (df.speed_90&lt;75)]</span><span id="6b9e" class="mq kx it mm b gy mv ms l mt mu">## Select Features with unique distributions<br/>df_local = df_local_all_feat[['speed_90','speed_ave','accel_75','speed_50','accel_ave','distance_traveled','time_traveled']]</span><span id="fa09" class="mq kx it mm b gy mv ms l mt mu">## Scale Data for KMeans<br/>X = StandardScaler()<br/>X = X.fit_transform(df_local)</span><span id="349f" class="mq kx it mm b gy mv ms l mt mu">#################################<br/>### PERFORM KMeans CLUSTERING ###<br/>#################################</span><span id="be7c" class="mq kx it mm b gy mv ms l mt mu">Sum_of_squared_distances = []<br/>scores = []<br/>cluster_count = []<br/>K= range(2,15,1)<br/>for i in K:<br/>    km = KMeans(n_clusters=i)<br/>    km.fit(X)<br/>    pred =km.predict(X)<br/>    Sum_of_squared_distances.append(km.inertia_)<br/>    scores.append(silhouette_score(X, pred))<br/>    cluster_count.append(i)<br/>    print(Counter(pred))<br/>    print(str(silhouette_score(X, pred)) + ' clusters:' +str(i))<br/>    print('------')</span><span id="beb5" class="mq kx it mm b gy mv ms l mt mu">########################################<br/>### Elbow plot with silhouette score ###<br/>########################################</span><span id="73c9" class="mq kx it mm b gy mv ms l mt mu">sns.set_context('talk')<br/>sns.lineplot(cluster_count,scores)<br/>plt.xlabel('Cluster Count')<br/>plt.ylabel('Silhouette Score')<br/>plt.title('Elbow Method For Optimal Cluster Count')<br/>plt.show()</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mx"><img src="../Images/97ba83e4673c8e541c6bd89f5aea2b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siRC_JH1cXbXIe_Ku915nQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">The elbow plot is telling us to investigate either 6 or 7 clusters.</figcaption></figure><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="548f" class="mq kx it mm b gy mr ms l mt mu">df_local_all_feat['cluster'] = KMeans(n_clusters=7).fit_predict(X)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nc"><img src="../Images/34909045c88a6fbd0ff0d568a6cf939b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZX5SQ9DCHRmgJE_2wHeNg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Trajectory Clusters</figcaption></figure><p id="2822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">聚类 4，5 包含很少数量的观察值，因此不包括在此分析中。</p><p id="643a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看最终目的地和轨迹簇。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/0a5fd26f9922cf49346c6ec220fafc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzSA7c19oOG-VJITJHKYKQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Tsinghua University, Trajectory Cluster</figcaption></figure><p id="4554" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看清华大学，我们可以看到大量的集群 0 和 1。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/49d821f495d11f59fc45620160859590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SNHIyFD7GazWu0eDjvBcw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Tencent Office, Trajectory Cluster</figcaption></figure><p id="b7f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看腾讯的办公室，我们可以开始看到更多的地铁乘坐，集群 5 和 6。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/35ce71554537049ae53f839ff3cdcb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4ah1hQpMVuVbB4apuww0g.png"/></div></div></figure><p id="f000" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看一下当地的购物区，地铁/火车出行较少，但火车出行通常距离更长(大小是行驶的总距离)。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="d527" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">目标地理空间聚类</h1><p id="d589" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">上面部分的放大图可以在下面找到。我们已经确定了 3 个一般的兴趣点，现在是时候将它们聚集在一起了。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/c95b448848f508ca19cfab445223cd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJdwsI3nJ2wnBrLhzA3Axw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Tsinghua University on top, shopping center on lower left, and Tencent on lower right</figcaption></figure><p id="00b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来我们需要一种算法，既能结合距离和接近度，又能排除噪音。听起来 DB 扫描将是这个应用程序的算法。</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="f29b" class="mq kx it mm b gy mr ms l mt mu">from sklearn.cluster import DBSCAN</span><span id="9636" class="mq kx it mm b gy mv ms l mt mu"># pull out the only the location metrics<br/>df_cluster = df_local_all_feat[['Last Lat', 'Last Long']]</span><span id="e544" class="mq kx it mm b gy mv ms l mt mu">X = StandardScaler()<br/>X = X.fit_transform(df_cluster)</span><span id="3d19" class="mq kx it mm b gy mv ms l mt mu">scores = []<br/>EP =[]<br/>number =[]<br/>eps= [.08,.10,.15,.20,.25,.30,.40,.50,.60]<br/>size= [200,250,300]<br/>for ep in eps:<br/>    for siz in size:<br/>        db = DBSCAN(eps=ep, min_samples=siz)   <br/>        pred = db.fit_predict(X)<br/>        <br/>        print('ep:'+ str(ep) + ' size:'+ str(siz))<br/>        print(Counter(pred))<br/>        try:<br/>            scores.append(silhouette_score(X, pred))<br/>        except:<br/>            scores.append(np.nan)<br/>        EP.append(ep)<br/>        number.append(siz)</span></pre><p id="ca93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变量 eps 和 size 将允许您为您的应用网格搜索适当的超参数。最后，我选择了下面的价值观。</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="d8e8" class="mq kx it mm b gy mr ms l mt mu">db = DBSCAN(eps= 0.37, min_samples = 250)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ne"><img src="../Images/5615f505f3a25528d0b238bcba794268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7LeSEcHvR_532JH7hW0Rg.png"/></div></div></figure></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="959b" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结合两种聚类算法</h1><p id="58f0" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">通过结合两种聚类算法，我们可以基于兴趣点过滤特定的行程，以确定人们来自哪里以及到达所述兴趣点所使用的交通方式。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nf"><img src="../Images/5eb15564a659f9fb73b6420b342cd3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5Y8qW1TPpW9vTwXpc4GJA.png"/></div></div></figure><p id="8629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于清华大学，我们可以看到人们通常从附近短途旅行。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nf"><img src="../Images/f03e5ae2b9004b2c71ae82ff252eb88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89RYU2xDb0-tMfcIDzGt6g.png"/></div></div></figure><p id="c448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于购物区，我们可以看到人们的出行距离更远，并且大多使用交通模式 0。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nf"><img src="../Images/e92f8bfa14d6f1102528084709576ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMnLcvWTF0_FqGmTE2huoQ.png"/></div></div></figure><p id="501c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于腾讯办公室来说，人们从最远的地方出发。然而，从附近通勤的人通常选择交通模式 0，而从更远通勤的人选择交通模式 6。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="ce9e" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="fa0c" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">使用各种无监督学习算法，我们能够确定人们如何前往特定位置，如何限制兴趣点，以及人们来自哪里。</p><p id="aa06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过调整，在数据收集架构中，根据出行距离和交通方式等因素来确定人们在一个地点的居住方式将会很有意义。</p></div></div>    
</body>
</html>