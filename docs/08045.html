<html>
<head>
<title>3 Programming Concepts for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的 3 个编程概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-programming-concepts-for-data-scientists-c264fc3b1de8?source=collection_archive---------11-----------------------#2019-11-05">https://towardsdatascience.com/three-programming-concepts-for-data-scientists-c264fc3b1de8?source=collection_archive---------11-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c30e1ac96fcce4b20ed130959c878d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZM8D8gMNkQ2J2gp1F-8pEA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/sasint-3639875/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1822704" rel="noopener ugc nofollow" target="_blank">Sasin Tipchai</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1822704" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h2 id="4eae" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/algorithms-interview" rel="noopener" target="_blank">算法面试</a></h2><div class=""/><div class=""><h2 id="e887" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">更少的数学和更多的代码</h2></div><p id="4f01" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">算法是数据科学不可或缺的一部分。虽然我们大多数数据科学家在学习时没有上过适当的算法课程，但它们仍然很重要。</p><p id="fa6e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">许多公司在招聘数据科学家的面试过程中会询问数据结构和算法。</p><p id="e4dd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，许多人在这里问的问题是，问一个数据科学家这样的问题有什么用。<strong class="lj jt"> <em class="md">我喜欢这样描述，一个数据结构问题可以被认为是一个编码能力测试。</em> </strong></p><p id="e8b7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们都在人生的不同阶段进行过能力倾向测试，虽然它们不是判断一个人的完美代理，但几乎没有什么是真的。那么，为什么没有一个标准的算法测试来判断人的编码能力。</p><p id="8d8e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但我们不要自欺欺人，他们需要像你的数据科学面试一样的热情来破解，因此，你可能需要花一些时间来研究算法。</p><p id="e306" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="md">这个帖子是关于快速跟踪的，以一种容易理解的方式为数据科学家研究和平移一些基本的算法概念。</em>T12】</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b0f3" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">1.递归/记忆</h1><p id="59bf" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">递归是被定义的函数在它自己的定义中被应用。简单来说；递归是函数调用自己。当你在那里搜索递归的时候，谷歌做了一些非常有趣的事情。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/1c57c6ed801f69cb6dc1aae10f3afa31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNEYutd-DBmNOuYtJTw72g.png"/></div></div></figure><p id="d924" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">希望你明白这个笑话。虽然递归对于初学者来说可能有点令人生畏，但它非常容易理解。一旦你知道了，这是一个美丽的概念。</p><p id="5504" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我找到的解释递归的最好例子是计算一个数的阶乘。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="f844" class="ns mm jj no b gy nt nu l nv nw">def factorial(n):<br/>    if n==0:<br/>        return 1<br/>    return n*factorial(n-1)</span></pre><p id="8797" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以很容易地看出阶乘是一个递归函数。</p><p id="9178" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nx ny nz no b">Factorial(n) = n*Factorial(n-1)</code></p><p id="db5c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="md">那么它如何翻译成编程呢？</em> </strong></p><p id="0e63" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">递归调用的函数通常由两部分组成:</p><ul class=""><li id="8656" class="oa ob jj lj b lk ll ln lo lq oc lu od ly oe mc of og oh oi bi translated">基本情况——递归结束的情况。</li><li id="d526" class="oa ob jj lj b lk oj ln ok lq ol lu om ly on mc of og oh oi bi translated">递归公式--向基本情况发展的公式化方法。</li></ul><p id="c2a7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你最终解决的很多问题都是递归的。它也适用于数据科学。</p><p id="ee1d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">比如决策树只是二叉树，树算法一般是递归的。或者说，我们确实在很多时候使用了 sort。负责这个的算法叫做<strong class="lj jt"> <em class="md"> mergesort，</em> </strong>本身就是一个递归算法。还有一个是<strong class="lj jt"> <em class="md">二分搜索法，</em> </strong>其中包括寻找数组中的一个元素。</p><p id="3414" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们有了递归的基本窍门，让我们试着找出第 n 个斐波那契数。斐波纳契数列是一系列数字，其中每个数字(<em class="md">斐波纳契数</em>)是前面两个数字的和。最简单的是 1，1，2，3，5，8 等系列。答案是:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="dba8" class="ns mm jj no b gy nt nu l nv nw">def fib(n):<br/>    if n&lt;=1:<br/>        return 1<br/>    return fib(n-1) + fib(n-2)</span></pre><p id="85c7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="md">但是你发现这里的问题了吗？</em> </strong></p><p id="fa6d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您尝试计算 fib(n=7 ),它会运行 fib(5)两次，fib(4)三次，fib(3)五次。随着 n 变大，对同一个号码进行了很多次调用，我们的递归函数一次又一次地计算。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/1e5e012c502c7759847fdf024423c2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/0*ucgB_F9l4JCu4fVh"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://www.rubyguides.com/2015/08/ruby-recursion-and-memoization/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="152f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们能做得更好吗？是的，我们可以。我们可以稍微改变一下我们的实现，添加一个字典来为我们的方法增加一些存储空间。现在，每当计算出一个数字时，这个备忘录字典就会更新。如果该数字再次出现，我们不会再次计算它，而是从备忘录字典中给出结果。这种存储的增加叫做<strong class="lj jt"> <em class="md">记忆</em> </strong>。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="8061" class="ns mm jj no b gy nt nu l nv nw">memo = {}<br/>def fib_memo(n):<br/>    if n in memo:<br/>        return memo[n]<br/>    if n&lt;=1:<br/>        memo[n]=1<br/>        return 1<br/>    memo[n] = fib_memo(n-1) + fib_memo(n-2)<br/>    return memo[n]</span></pre><p id="fb12" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通常，我喜欢先编写递归函数，如果它反复调用相同的参数，我会添加一个字典来记忆解决方案。</p><p id="e637" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="md">有多大帮助？</em>T13】</strong></p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/00677733b3a0c98b7db4bf548c2d7ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtYIJJ_AilfKYmia73jyJg.png"/></div></div></figure><p id="3c5b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是不同 n 值的运行时间比较。我们可以看到，没有记忆的<strong class="lj jt"> <em class="md">斐波那契函数的运行时间呈指数增长，而有记忆的函数的运行时间呈线性增长。</em></strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7729" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">2.动态规划</h1><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/135f3a8b6718710381c92c16081e86e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l_3lx4nYVGeMyQiq"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Bottoms Up</figcaption></figure><p id="33ea" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">递归本质上是一种自顶向下的方法。当计算斐波那契数 n 时，我们从 n 开始，然后递归调用 n-2 和 n-1 等等。</p><p id="d913" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在动态编程中，我们采用自底向上的方法。它本质上是一种迭代编写递归的方法。我们首先计算 fib(0)和 fib(1 ),然后使用以前的结果生成新的结果。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="53bf" class="ns mm jj no b gy nt nu l nv nw">def fib_dp(n):<br/>    dp_sols = {0:1,1:1}<br/>    for i in range(2,n+1):<br/>        dp_sols[i] = dp_sols[i-1] + dp_sols[i-2] <br/>    return dp_sols[n]</span></pre><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/3df9c89a18362934dc8a9160870c2840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcycy-ISJeUK7IQsGh8UDQ.png"/></div></div></figure><p id="9336" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以上是 DP 与 Memoization 的运行时比较。我们可以看到，它们都是线性的，但 DP 还是快一点。</p><p id="497b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为什么？因为在这种情况下，动态编程只对每个子问题进行一次调用。</p><p id="82fe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有一个关于开发动态编程的贝尔曼如何构建术语<em class="md"> : </em>的精彩故事</p><blockquote class="os ot ou"><p id="2e07" class="lh li md lj b lk ll kt lm ln lo kw lp ov lr ls lt ow lv lw lx ox lz ma mb mc im bi translated">动态编程这个名字是怎么来的？20 世纪 50 年代不是数学研究的好年头。我们在华盛顿有一位非常有趣的绅士，名叫<a class="ae jg" href="https://en.wikipedia.org/wiki/Charles_Erwin_Wilson" rel="noopener ugc nofollow" target="_blank">威尔森</a>。他是国防部长，他实际上对研究这个词有一种病态的恐惧和憎恨。我能选择什么头衔，什么名字？首先，我对计划、决策和思考感兴趣。但是规划，由于种种原因，并不是一个好词。因此，我决定使用“编程”一词。我想让大家明白这是动态的，是多阶段的，是时变的。我想，一石二鸟吧。因此，我认为动态编程是一个好名字。<strong class="lj jt">这是连国会议员都不会反对的事情。</strong>所以我把它当活动用的雨伞。</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="93d4" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">3.二进位检索</h1><p id="cfa3" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">假设我们有一个有序的数字数组，我们想从这个数组中找出一个数字。我们可以走直线路线，逐一检查每个数字，如果找到数字就停下来。问题是，如果数组包含数百万个元素，那么时间会太长。这里我们可以使用二分搜索法。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/b49e3733f84fb12546dac0b143f38379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*QzOblj22OzMQe1ZQOtaxtQ.gif"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="http://mathwarehouse.com/programming" rel="noopener ugc nofollow" target="_blank">Source</a>: Finding 37 — There are 3.7 trillion fish in the ocean, they’re looking for one</figcaption></figure><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="5aa5" class="ns mm jj no b gy nt nu l nv nw"># Returns index of target in nums array if present, else -1 <br/>def binary_search(nums, left, right, target):   <br/>    # Base case <br/>    if right &gt;= left: <br/>        mid = int((left + right)/2)<br/>        # If target is present at the mid, return<br/>        if nums[mid] == target: <br/>            return mid <br/>        # Target is smaller than mid search the elements in left<br/>        elif nums[mid] &gt; target: <br/>            return binary_search(nums, left, mid-1, target) <br/>        # Target is larger than mid, search the elements in right<br/>        else: <br/>            return binary_search(nums, mid+1, right, target) <br/>    else: <br/>        # Target is not in nums <br/>        return -1</span><span id="8d76" class="ns mm jj no b gy oz nu l nv nw">nums = [1,2,3,4,5,6,7,8,9]<br/>print(binary_search(nums, 0, len(nums)-1,7))</span></pre><p id="c097" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个基于递归算法的高级例子，我们利用了数组是有序的这一事实。这里我们递归地查看中间的元素，看看我们是想在中间元素的左边还是右边进行搜索。这使得我们的搜索空间每走一步就缩小 2 倍。</p><p id="0764" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此该算法的运行时间是<code class="fe nx ny nz no b">O(logn)</code>，与线性搜索的<code class="fe nx ny nz no b">O(n)</code>相反。</p><p id="0bda" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这有多重要？下面是运行时间的比较。我们可以看到，与线性搜索相比，二分搜索法非常快。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/748e11b872e6480815833c46a4a86c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slUbdLxbQMskzYoDKDPOUQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">For n=10000, Binary search takes around 13 steps, and the Linear search takes 10000 steps.</figcaption></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="3214" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">结论</h1><p id="6f1b" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">在这篇文章中，我谈到了一些最激动人心的算法，它们构成了编程的基础。T9】</p><p id="2957" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些算法是数据科学面试中一些最常被问到的问题的背后，对这些算法的良好理解可能会帮助你获得理想的工作。</p><p id="6ffe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然您可以在不学习它们的情况下在数据科学中走得更远，但您可以为了一点乐趣而学习它们，也许是为了提高您的编程技能。</p><p id="d0a8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想学习算法和数据结构，也可以看看我在<a class="ae jg" href="https://towardsdatascience.com/tagged/algorithms-interview" rel="noopener" target="_blank">系列</a>的其他帖子。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6a2e" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">继续学习</h1><p id="9e9e" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">如果你想在算法方面读得更多，这里有一个 UCSanDiego 在 Coursera 上的<a class="ae jg" href="https://coursera.pxf.io/15MOo6" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">算法专门化</strong> </a> <strong class="lj jt">，</strong>我强烈推荐学习算法基础。</p><p id="bbd3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae jg" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"><strong class="lj jt"/></a>关注我或者订阅我的<a class="ae jg" href="http://eepurl.com/dbQnuX?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p><p id="9330" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，一个小小的免责声明——这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p></div></div>    
</body>
</html>