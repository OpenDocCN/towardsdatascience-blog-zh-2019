<html>
<head>
<title>Natural Gas Price Prediction using Neural Network &amp; Classification Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于神经网络的天然气价格预测&amp;分类用例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/power-of-xgboost-lstm-in-forecasting-natural-gas-price-f426fada80f0?source=collection_archive---------6-----------------------#2019-10-29">https://towardsdatascience.com/power-of-xgboost-lstm-in-forecasting-natural-gas-price-f426fada80f0?source=collection_archive---------6-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6856" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">由连续价格和价格运动方向解决的预测问题</h2><div class=""/><div class=""><h2 id="4a44" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><strong class="ak">回归时序分析&amp;分类用例</strong></h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5f5c699f362998ef5422f960718c063d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6A_V0dPjA3nI3cC9uQcgA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Image by author</figcaption></figure><p id="4f1b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">【https://sarit-maitra.medium.com/membership T2】号</p><p id="dfa0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> F </span>时间序列预测是一项困难的任务，尤其是当我们处理股票数据的随机价格序列时。这里的随机指的是真正意义上的混沌，带有非平稳性。此外，由于股票数据的复杂性，开发有效的预测模型非常困难。然而，回报确实表现出某种可预测性和现代 ML 技术的应用，有效的特征工程有助于推动预测股票回报的极限。</p><p id="7baf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我将使用机器学习算法在历史价格记录上训练我的机器，并预测预期的未来价格。让我们看看我们的算法能预测多准确。我将使用回归用例，并通过实现 LSTM 来解决问题；随后，将使用分类用例通过应用各种分类算法来解决问题。</p><p id="a58f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我使用的是天然气每日现货价格，可在<a class="ae md" href="https://www.eia.gov/dnav/ng/hist/rngwhhdM.htm" rel="noopener ugc nofollow" target="_blank">https://www.eia.gov/dnav/ng/hist/rngwhhdM.htm</a>获取。因此，我们上传数据并做一些处理来清理数据，使数据为机器学习做好准备。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mn"><img src="../Images/7c3643289bef128c3bf70ee18624d628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKIENv205O50htGTLpc3YA.png"/></div></div></figure><p id="93e4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据集从 1997 年 1 月 7 日到 2019 年 10 月 21 日，有 5732 个数据点。</p><h1 id="3cb2" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">数据准备</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ng"><img src="../Images/289f728092aab96cc3dc1cd96bb99036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNvYcVLQvwVjxu6KdDP4kg.png"/></div></div></figure><p id="f042" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们需要检查数据集中是否存在任何 NaN 值，如果存在，需要修复或删除以便机器理解。在这里，我用以前的值填充了缺少的值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nh"><img src="../Images/4833c82eed156e2a6bd51d492506a0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQVXY1DQSQf7JflsJIlJtQ.png"/></div></div></figure><p id="539d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们确保最终数据集中不存在缺失值。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5332" class="nn mp it nj b gy no np l nq nr">df.plot(figsize=(10, 5))<br/>plt.title('Daily Natural Gas Spot Prices', fontsize=12)<br/>plt.ylabel('Dollars per Million Btu', fontsize=12)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/6b77d0a2b8d721a4571a79ef487dbf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5huQhsM60C1pDeqVQVD9iQ.png"/></div></div></figure><h1 id="87c8" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">数据质量检查</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/05789969ac82c79bf71215e5316d3427.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*l_p8mLR_ImldWswgEo9NbA.png"/></div></figure><h1 id="c2d7" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated"><strong class="ak">技术指标</strong></h1><p id="cf0a" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">技术指标是基于“气价”的数学计算。通过分析历史数据，我们可以使用指标来预测未来的价格走势。一些众所周知的技术指标如下—</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/b14aedde95ff03111ef8f45cfbab79aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hwv6k2e4t44tt8a-Z_PvZw.png"/></div></div></figure><p id="f697" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">移动平均线收敛-发散(MACD)比较价格的两个移动平均线。第一条移动平均线是 26 天指数移动平均线(EMA)，第二条移动平均线是 12 天 EMA。从 12 日均线中减去 26 日均线。</p><p id="784b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">布林线由基于标准差的上下波段组成，随着波动性收缩和扩大。波段是分析趋势强度和监控反转何时发生的有用工具。标准偏差通常设置为 2.0，决定了波段的宽度。标准差越高，价格越难达到上限或下限。标准差越低，价格越容易突破波段。</p><p id="4ce1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">计算 MACD 的公式是:</p><blockquote class="oa ob oc"><p id="ce93" class="lh li od lj b lk ll kd lm ln lo kg lp oe lr ls lt of lv lw lx og lz ma mb mc im bi translated">MACD = EMA12(价格)EMA26(价格)</p><p id="51f7" class="lh li od lj b lk ll kd lm ln lo kg lp oe lr ls lt of lv lw lx og lz ma mb mc im bi translated">上限= 21 天 SMA + (21 天价格标准差 x 2)</p><p id="7fdc" class="lh li od lj b lk ll kd lm ln lo kg lp oe lr ls lt of lv lw lx og lz ma mb mc im bi translated">较低波段= 21 天 SMA-(21 天价格标准差 x 2)</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/0a6773cb1114ac9a498fded29f4083c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQmbubFY1PknM0t0UmAyuw.png"/></div></div></figure><p id="4b1a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，这样我们就创建了 10 个可以用来预测未来价格的特征。然而，我们不会在我们的用例中使用所有这些特性。我们的数据量很小，我们需要使用一种简单的技术来获得最好的输出。</p><p id="a5dd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让拟合预处理和拟合原始单变量价格序列到 LSTM 网络。我们最初的单变量序列如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5e697f495e3da32fc6fb3a1c17b56ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*rpJHr1HDFww2ZRKhtIr59A.png"/></div></figure><h2 id="8291" class="nn mp it bd mq oj ok dn mu ol om dp my lq on oo na lu op oq nc ly or os ne iz bi translated">将数据分成训练集和测试集:</h2><p id="1ca5" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">我们将 2018 年 12 月 31 日作为训练集，其余时间作为测试集。因此，我们将根据 21 年的数据(5530 个数据点)训练我们的模型，以测试(202 个数据点)并验证我们开发的模型可以预测的精确度。</p><p id="afb2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">显然，我们想知道如何确保模型在投入生产时表现良好，并看到前所未见的数据。这里，在没有用于训练预测模型的数据集上的测试性能是样本外性能。这些结果被认为代表了模型投入生产时的预期。出于模型的目的，我们将对数据集训练和测试进行分区。下面我们将我们的系列分成训练/测试样本。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b73d40eb22dae1b2ee636a8c40f7efc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*NmJIQ0Dyq4SCx7UOcAQW-A.png"/></div></figure><h2 id="1277" class="nn mp it bd mq oj ok dn mu ol om dp my lq on oo na lu op oq nc ly or os ne iz bi translated">可视化训练/测试分割:</h2><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="00f5" class="nn mp it nj b gy no np l nq nr">ax = train_data.plot(figsize=(10, 5))<br/>test_data.plot(ax=ax, color='r')<br/>plt.legend(['train', 'test']);</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/abf02ac32ca1fccc2a93cab83f528f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*1O8imvuL6H_MWAGUuoqyxQ.png"/></div></figure><h2 id="4eb8" class="nn mp it bd mq oj ok dn mu ol om dp my lq on oo na lu op oq nc ly or os ne iz bi translated">数据标准化</h2><p id="23b2" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">我们缩小范围(0，1)中的值，并对数据进行归一化。在缩放时，我们将测试和训练数据相对于训练数据进行标准化，因为在此阶段我们无法访问测试数据。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="cc8f" class="nn mp it nj b gy no np l nq nr">scaler = MinMaxScaler(feature_range = (0,1))<br/>train_data_scaled = scaler.fit_transform(train_data)<br/>print(train_data_scaled); print(train_data_scaled.shape)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/442afbaa36cc4b66edac1caf67520be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*mpOXQ0helEKcy0Iortm1ug.png"/></div></figure><p id="0bc4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们创建一个具有 60 个时滞和 1 个输出的数据结构。目标是允许我们的网络回顾 60 个时间步，以预测下一步(61)。因此，每次网络预测输出时，它都检查前 60 个时间步，这是我们的回顾时间周期。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a9ef" class="nn mp it nj b gy no np l nq nr">X_train = []<br/>y_train = []</span><span id="fa5a" class="nn mp it nj b gy ow np l nq nr">for i in range(60, len(train_data_scaled)):<br/>    X_train.append(train_data_scaled[i-60:i,0])<br/>    y_train.append(train_data_scaled[i,0])</span><span id="9511" class="nn mp it nj b gy ow np l nq nr">X_train, y_train = np.array(X_train), np.array(y_train)<br/>print(X_train); print(); print(y_train)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/7b686fee6e18365715a398c31d999c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7D7_bP-MWaNcZeO1snxFwQ.png"/></div></div></figure><p id="70e6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们需要重塑数据；张量接受 3D 形状(batch_size，timesteps，input_dim)。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="188c" class="nn mp it nj b gy no np l nq nr">X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))<br/>print(X_train.shape); print(); print(X_train)</span></pre><p id="a15a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们准备初始化 RNN 架构并构建模型。</p><h1 id="0924" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">递归神经网络</h1><p id="6e6b" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">LSTM 细胞可以记住任意时间间隔内的数值，并产生 LSTM 记忆。存储器由三个不同的门处理:(1)输入门，(2)遗忘门，和(3)输出门。下面的等式表达了单个 LSTM 的计算过程</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl oy"><img src="../Images/98f6f13a2a48ff3a315bd0b46276eb7b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6VdQ75rukSQxfJh8rzteHg.png"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="9f9b" class="nn mp it nj b gy no np l nq nr">model = tf.keras.Sequential()</span><span id="9536" class="nn mp it nj b gy ow np l nq nr"># adding 1st LSTM layer and some dropout regularization<br/>model.add(tf.keras.layers.LSTM(units=50, input_shape=(X_train.shape[1], 1), return_sequences=True, activation = 'relu'))<br/>model.add(tf.keras.layers.Dropout(0.2))</span><span id="7f9e" class="nn mp it nj b gy ow np l nq nr"># adding 2nd LSTM layer and some dropout regularization<br/>model.add(tf.keras.layers.LSTM(units=50, return_sequences=True))<br/>model.add(tf.keras.layers.Dropout(0.2))</span><span id="6323" class="nn mp it nj b gy ow np l nq nr"># adding 3rd LSTM layer and some dropout regularization<br/>model.add(tf.keras.layers.LSTM(units=50, return_sequences=True))<br/>model.add(tf.keras.layers.Dropout(0.2))</span><span id="6b73" class="nn mp it nj b gy ow np l nq nr"># adding 4th LSTM layer and some dropout regularization<br/>model.add(tf.keras.layers.LSTM(units=50))<br/>model.add(tf.keras.layers.Dropout(0.2))</span><span id="a1b5" class="nn mp it nj b gy ow np l nq nr"># adding output layer<br/>model.add(tf.keras.layers.Dense(units=1))</span><span id="29e3" class="nn mp it nj b gy ow np l nq nr">#compiling RNN<br/>model.compile(loss='mean_squared_error', optimizer='adam')</span><span id="1779" class="nn mp it nj b gy ow np l nq nr">early_stopping = EarlyStopping(monitor='loss', patience=10)</span><span id="cf8a" class="nn mp it nj b gy ow np l nq nr"># fitting RNN on training set<br/>model.fit(X_train, y_train, epochs= 100, batch_size=32, <br/>          verbose=2, callbacks=[early_stopping])</span></pre><p id="7568" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">默认的 sigmoid 激活函数用于 LSTM 模块。该网络被训练 100 个时期，并且使用 32 的批量大小。一旦模型合适，我们就可以估计模型在训练和测试数据集上的性能。</p><p id="aabe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了更好地显示，下面的消息被截断。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/de954324a31716b821065ea6551e004d.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*J24jeXwQrV62kFDsqUcSDQ.png"/></div></figure><p id="764d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们得到 2019 年的预测天然气价格；我们需要将训练集中的前 60 条记录追加到测试集中</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a633" class="nn mp it nj b gy no np l nq nr">dataset_total = pd.concat((train_data, test_data), axis=0)<br/>print(dataset_total)<br/>dataset_total = pd.concat((train_data, test_data), axis=0)</span><span id="bb36" class="nn mp it nj b gy ow np l nq nr">inputs = dataset_total[len(dataset_total) - len(test_data)- 60:].values<br/>inputs = inputs.reshape(-1,1)<br/>inputs = scaler.transform(inputs) # transforming input data</span><span id="b2b3" class="nn mp it nj b gy ow np l nq nr">X_test = []<br/>y_test = []</span><span id="63e5" class="nn mp it nj b gy ow np l nq nr">for i in range (60, 262):<br/>    X_test.append(inputs[i-60:i, 0])<br/>    y_test.append(train_data_scaled[i,0])<br/>      <br/>X_test, y_test = np.array(X_test), np.array(y_test)<br/>X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))<br/>pred_price = model.predict(X_test)<br/>pred_price = scaler.inverse_transform(pred_price)<br/>print(pred_price)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/9b51efe16cc1764faff8d79aac2e1878.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*FyCT8ptGeg5P40ggQBvmxw.png"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="15ce" class="nn mp it nj b gy no np l nq nr">a = pd.DataFrame(pred_price)<br/>a.rename(columns = {0: 'Predicted'}, inplace=True); <br/>a.index = test_data.index<br/>compare = pd.concat([test_data, a],1)<br/>compare</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/c7a75f9141aa8018ca1429fd98f594c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*4m6YoHgbSkYpjwrsIeKIGQ.png"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="327d" class="nn mp it nj b gy no np l nq nr">plt.figure(figsize= (15,5))<br/>plt.plot(compare['gas price'], color = 'red', label ="Actual Natural Gas Price")<br/>plt.plot(compare.Predicted, color='blue', label = 'Predicted Price')<br/>plt.title("Natural Gas Price Prediction")<br/>plt.xlabel('Time')<br/>plt.ylabel('Natural gas price')<br/>plt.legend(loc='best')<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/bcd6a897f4152ad7a449a799c2c9c753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQV7M80uvm-jXJtSeaxdBw.png"/></div></div></figure><p id="a6fc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，如下所示，我们的得分指标并不令人印象深刻，我们还有改进的空间。我们需要重新访问数据、选定的特征、选择正确的超参数，还需要更新的数据。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="e4c2" class="nn mp it nj b gy no np l nq nr">test_score = math.sqrt(mean_squared_error(compare['gas price'], compare.Predicted))<br/>print('Test Score: %.2f RMSE' % (test_score))<br/># Explained variance score: 1 is perfect prediction<br/>print('Variance score (test): %.2f' % r2_score(test_data, pred_price))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/556f6cb73549a2e838030a41d7b09c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*lsCf9rS__KEjmN-LvzduSg.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/ccf7683c86626b41e68d59072131ed50.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*wBElgv2HhVoecWRn4bzlpA.png"/></div></figure><h1 id="13ad" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">分类用例</h1><p id="81e7" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">对于分类用例，让我们创建一些滞后序列，如下所示。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0035" class="nn mp it nj b gy no np l nq nr">k = df.copy()</span><span id="54ee" class="nn mp it nj b gy ow np l nq nr">lags = 5<br/># Create the shifted lag series of prior trading period close values<br/>for i in range(0, lags):<br/>    k["Lag%s" % str(i+1)] = k["gas price"].shift(i+1).pct_change()</span><span id="f0ed" class="nn mp it nj b gy ow np l nq nr">k['price_diff'] = k['gas price'].diff()<br/>k['ret'] = k['gas price'].pct_change()<br/>k.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/6579981ee2fa2ef7b3a3cb05bcd7ee2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcuWT5PFOjbAcRPHJZyqUQ.png"/></div></div></figure><h2 id="5b25" class="nn mp it bd mq oj ok dn mu ol om dp my lq on oo na lu op oq nc ly or os ne iz bi translated">目标变量:</h2><p id="2cb3" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">这里的目标是根据前 N 天的信息预测(t+1)值。因此，定义输出值为<em class="od">“target”</em>，这是一个二进制变量，在明天的价格差&gt;今天的时候存储 1。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0937" class="nn mp it nj b gy no np l nq nr"># positive value = 1, otherwise, 0<br/>k["target"] = np.where(k['price_diff']&gt; 0, 1.0, 0.0)<br/>k.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/ff63e0b32e0db9cfdbe2ea4288f5b1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXwnD4GWHdrIvQNsx6WxVg.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/f0c60f88830ecd95ec35a334e404d3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*wwWXJmcZHqpUbuk51AYlnQ.png"/></div></figure><p id="0ef0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，为了简单起见，我们将只使用 2 个 lags 和返回值。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a231" class="nn mp it nj b gy no np l nq nr">x = k[['Lag1', 'Lag2', 'ret']].dropna()<br/>y = k.target.dropna()</span><span id="de98" class="nn mp it nj b gy ow np l nq nr"># # Create training and test sets<br/>gkcv = GapKFold(n_splits=5, gap_before=2, gap_after=1)</span><span id="1ac6" class="nn mp it nj b gy ow np l nq nr">"""<br/>Introduced gaps between the training and test set to mitigate the temporal dependence.<br/>Here the split function splits the data into Kfolds. <br/>The test sets are untouched, while the training sets get the gaps removed<br/>"""</span><span id="7c2e" class="nn mp it nj b gy ow np l nq nr">for tr_index, te_index in gkcv.split(x, y):<br/>    xTrain, xTest = x.values[tr_index], x.values[te_index];<br/>    yTrain, yTest = y.values[tr_index], y.values[te_index];<br/>        <br/>print('Observations: %d' % (len(xTrain) + len(xTest)))<br/>print('Training Observations: %d' % (len(xTrain)))<br/>print('Testing Observations: %d' % (len(xTest)))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/6c7bf63ce3932d339a2be3b7c5d329d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*OnZqofYju2stNTmDRqKGdw.png"/></div></figure><h1 id="8cf8" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">分类模型:</h1><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="020b" class="nn mp it nj b gy no np l nq nr"># Create the models<br/>print("Accuracy score/Confusion Matrices:\n")<br/>models = [("LR", LogisticRegression()),<br/>          ("LDA", LinearDiscriminantAnalysis()),<br/>          ("QDA", QuadraticDiscriminantAnalysis()),<br/>          ("LSVC", LinearSVC()),<br/>          ("RSVM", SVC(C=1000000.0, cache_size=200, class_weight=None,<br/>                       coef0=0.0, degree=3, gamma=0.0001, kernel='rbf',<br/>                       max_iter=-1, probability=False, random_state=None,<br/>                       shrinking=True, tol=0.001, verbose=False)),<br/>          ("RF", RandomForestClassifier(<br/>              n_estimators=1000, criterion='gini',<br/>              max_depth=None, min_samples_split=2,<br/>              min_samples_leaf=1, max_features='auto',<br/>              bootstrap=True, oob_score=False, n_jobs=1,<br/>              random_state=None, verbose=0))]<br/># iterate over the models<br/>for m in models:<br/>    # Train each of the models on the training set<br/>    m[1].fit(xTrain, yTrain)<br/>    # array of predictions on the test set<br/>    pred = m[1].predict(xTest)<br/>    # Accuracy score and the confusion matrix for each model<br/>    print("%s:\n%0.3f" % (m[0], m[1].score(xTest, yTest)))<br/>    print("%s\n" % confusion_matrix(pred, yTest))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/1c3832a4880aa186cf3981f4aaf0cc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*2UXo9wkrtVYExc3_JsIlMA.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/13788040684af3c777d5a526f7eb6bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*FjMTk0fLg4sHRBgn6fYzeA.png"/></div></div></figure><p id="fc19" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，虽然随机森林有 51.9%的准确率，但对真阳性和真阴性的分类相对较好。因此，我们将为现有用例考虑随机森林。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0e63" class="nn mp it nj b gy no np l nq nr">rfc = RandomForestClassifier(<br/>              n_estimators=1000, criterion='gini',<br/>              max_depth=None, min_samples_split=2,<br/>              min_samples_leaf=1, max_features='auto',<br/>              bootstrap=True, oob_score=False, n_jobs=1,<br/>              random_state=None, verbose=0).fit(xTrain, yTrain)</span><span id="4cd3" class="nn mp it nj b gy ow np l nq nr">pd.set_option('float_format', '{:f}'.format)</span><span id="0ad8" class="nn mp it nj b gy ow np l nq nr">train_pred = rfc.predict(xTrain)<br/>rmse = np.sqrt(mean_squared_error(yTrain, train_pred))<br/>print("RMSE_train: %f" % (rmse))<br/>print('Train prediction values:')<br/>train_pred = pd.DataFrame(train_pred); <br/>train_pred.rename(columns = {0: 'TrainPrediction'}, inplace=True); <br/>print(train_pred);print()</span><span id="e0dc" class="nn mp it nj b gy ow np l nq nr">pd.set_option('float_format', '{:f}'.format)<br/>test_pred = rfc.predict(xTest)<br/>print('Test prediction values:')<br/>test_pred = pd.DataFrame(test_pred)<br/>test_pred.rename(columns = {0: 'TestPrediction'}, inplace=True); <br/>actual = pd.DataFrame(yTest)<br/>actual.rename(columns = {0: 'Actual PriceDiff'}, inplace=True); <br/>compare = pd.concat([actual, test_pred], 1)<br/>print(compare)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/916ac4b8a8cf9a0101b4afb9263babd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*W_xWD2VwqMyN65CB4c1yCQ.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/18e0b4bf93e2695c7a0f40e1222f4d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*i7e8YTZKnkp2ErlKDieuLQ.png"/></div></figure><h1 id="c900" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">摘要</h1><p id="79b0" class="pw-post-body-paragraph lh li it lj b lk nu kd lm ln nv kg lp lq nw ls lt lu nx lw lx ly ny ma mb mc im bi translated">在这里，我们看到了如何在同一数据集上使用回归和分类来解决预测问题。虽然我们只使用 LSTM 回归用例，但是，这也可以与其他算法进行比较，如线性回归或弹性网络等。</p><p id="b022" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="od">我可以到达</em> </strong> <a class="ae md" href="https://www.linkedin.com/in/saritmaitra/" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd"> <em class="od">这里的</em> </strong> </a> <strong class="lj jd"> <em class="od">。</em>T15】</strong></p><p id="1c4b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="od">免责声明:</em>所有此类使用风险自负。</p></div></div>    
</body>
</html>