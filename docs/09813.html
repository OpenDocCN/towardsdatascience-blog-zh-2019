<html>
<head>
<title>Image Augmentation using Python, Numpy, Opencv and Skimage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python、Numpy、Opencv 和 Skimage 的图像增强</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-augmentation-using-python-numpy-opencv-and-skimage-ef027e9898da?source=collection_archive---------4-----------------------#2019-12-24">https://towardsdatascience.com/image-augmentation-using-python-numpy-opencv-and-skimage-ef027e9898da?source=collection_archive---------4-----------------------#2019-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="00ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图像增强是一种策略，使从业者能够显著增加可用于训练模型的图像的多样性，而无需实际收集新图像。对于训练任何机器学习模型，特别是深度学习模型，拥有大型数据集非常重要，可以显著提高模型的性能。当我们在图像上训练深度学习模型时，我们至少需要数万张图像来概括图像的模式。</p><p id="83ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生成图像数据是昂贵且乏味的工作。没有数据，机器是盲目的。在这种情况下，我们可以通过对现有图像应用不同的变换技术来生成更多的图像。有不同的技术，如旋转、翻转、移动等。这可以帮助我们使图像数据多样化。如果我们至少有 4-5 种变换技术，我们可以生成 10 倍或 100 倍以上的图像。我们也可以使用模糊图像和添加随机噪声的方法来生成更多的图像。</p><blockquote class="ko"><p id="80e8" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated">“即使是世界上最强大的模型也不过是没有适当数据的几行代码”。</p></blockquote><p id="397d" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">在这篇文章中，我们将看到如何使用一些变换和方法从 289 幅图像生成 2000 幅图像。我已经使用 NumPy，Skimage 对图像执行了不同的操作，这些操作非常简单，任何人都很容易理解，即使是 python 和 opencv 的新手。我使用了随机图像的数据集，其中一些图像是彩色的，而一些是灰度图像。</p><p id="13f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">彩色图像和灰度图像的区别在于，彩色图像有 R、G 和 B 三个通道，它们相互叠加，而灰度图像只有一个灰色通道。我说的通道是指矩阵。我们都知道<strong class="js iu">图像只是一个像素阵列</strong>。例如:高度为 720，宽度为 1200 图像被表示为包含像素值的 720 行和 1200 列的二维阵列。</p><p id="f128" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NumPy 是一个非常强大且易于使用的数字操作库。由于图像只是一组数字，numpy 让我们的工作变得如此简单。</p><p id="52f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们跳到操作。我们将使用翻转、旋转、移动、添加噪声和模糊图像等方法。不要担心编码部分，我已经在接下来的段落中解释了每一个操作。我在文章的最后还提供了源代码的 Github 链接，如果有帮助的话可以参考一下。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/714f936500ebce20aa3210cbfb42123f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*fcwLWixk10G27dEqiHOM-Q.gif"/></div></figure><p id="79c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">翻转:</strong>要水平翻转图像，我们需要颠倒矩阵列的顺序，这将导致图像水平改变。NumPy 有一个名为 fliplr()的方法，它通过反转列的顺序来返回数组。以同样的方式，有另一个方法 flipud()颠倒行的顺序，导致垂直翻转图像，如下所示。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/6021b69f8db35f0d7bcf2e8bfdd3910b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvmQ5Itb8fSAS7gcjjEzJg.png"/></div></div></figure><p id="16cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">旋转:</strong>我们将使用 sklearn 对图像进行旋转、移位添加噪点和模糊处理。Sklearn 提供了 rotate()方法，该方法以角度为参数，返回旋转后的图像。角度的正值逆时针旋转图像，而角度的负值顺时针旋转图像。请参考下图。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lx"><img src="../Images/c8e6768df4514f8230734490b047add3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVQRaYWMHNem8g_uS8-Zcg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">45 degree clockwise rotation and vice versa using rotate method</figcaption></figure><p id="e920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">移动:</strong>我们可以向右、向左、向上、向下或对角移动图像。我们只需要将 dx 和 dy 值传递给函数。在移位操作之后，存在于输入图像中的位置(X，Y)处的对象被移位到新的位置(X，Y): <br/> X = x + dx <br/> Y = y + dy</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/a61120ec59b1a4736c8e5840723a0a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu1uqNqGcdtd7q0Yxw0yZA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Image after shifting operation</figcaption></figure><p id="0b97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加噪声:为了添加噪声，我们将使用 skimage 库中的 random_noise()方法。这种方法将随机噪声添加到图像中，噪声对于正则化的目的是非常有用的。它防止模型过度拟合。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mc"><img src="../Images/8b72c5e39c72d9a3ceda4017875bd0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7TvkGubrUf_N3L0T4OFqg.png"/></div></div></figure><p id="dde9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">模糊:</strong>对于模糊图像，我们使用了 opencv 中的 gaussian_blur()方法，该方法以图像和内核大小为参数。内核越大，图像越模糊。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lx"><img src="../Images/b6cf95b2636b1c5f4c1d6df8b50fc74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BHOOSbiHo0i0nniwXFUngw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Blurring image</figcaption></figure><p id="6ea2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们使用所有的方法，并将它们应用于我们的数据集，以生成新的图像。我们将从目录中逐个读取图像，并将它们的名称存储到数组中。我们这样做是为了从目录中随机选择图像。我们将在随机图像上应用随机数的变换，直到生成 2000 个图像。</p><p id="ffbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看代码部分，并阐明它的每一部分。</p><p id="8bb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经为将在图像上执行的每个操作定义了函数，并将它们的名称存储在字典中，以便我们可以在运行时随机调用它们。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lx"><img src="../Images/eac3d73a11205cb880a770f2bc8e8cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLnUL5Ms-NOJVOhUfTqfHA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Define functions and create dictionary to store them</figcaption></figure><p id="6991" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看在对图像执行操作后读取图像并生成增强图像的主要代码。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lx"><img src="../Images/9c3eb6b6decd844ff4461063d2156aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyKfABV6F3R6ECQNn7TU4A.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Heart of the augmentation code.</figcaption></figure><p id="7492" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了两条路径，一条用于读取图像，另一条用于写入图像。我们已经指定了希望生成的图像数量。</p><p id="4e9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦外部 while 循环从图像数组中选择了一个随机图像，我们将读取该图像。使用 randint()方法从<strong class="js iu"> random </strong>库中随机选择应用于读取图像的变换数量。这个外部 while 循环将一直运行，直到 counts (i)达到 2000(要生成的图像数)。</p><p id="6109" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">内部 while 循环随机选择方法，并将原始图像传递给该方法，并将转换后的图像存储到 transformed_image 变量中。如果转换次数&gt; 1，那么我们将再次随机选择方法名，并传递转换后的图像，使其再次转换。</p><p id="8108" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对图像执行随机选择数量的转换后，在将它写入磁盘之前，我们将它传递给 image_as_ubyte()方法。skimage 库中的 image_as_ubyte()函数用于将像素值保持在 0–255 范围内。最后，我们将把我们的图像转换成 RGB 并保存到 Augmented_Image 文件夹，这是我们的目的地。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi md"><img src="../Images/65902276b7537804179be5a669506ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*d2lO5DZ-NndVhL4wBEs3eQ.gif"/></div></figure><p id="1551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">万岁！！我们已经成功地从 289 张图片中创建了 2000 张图片。我们可以使用 7 种变换方法创建更多的图像。你可以在这里找到数据集<a class="ae me" href="http://web.cecs.pdx.edu/~fliu/project/kernelfusion/Image_Collection_Color.zip" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到源代码<a class="ae me" href="https://github.com/govinda007/Images/tree/master" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7952" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想阅读更多关于 Python 中数据扩充的内容，你可以点击查看其中一篇有趣的文章<a class="ae me" href="https://neptune.ai/blog/data-augmentation-in-python" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bac2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读:)</p></div></div>    
</body>
</html>