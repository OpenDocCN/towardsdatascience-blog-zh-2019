<html>
<head>
<title>Best Investment Portfolio Via Monte-Carlo Simulation In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 进行蒙特卡罗模拟的最佳投资组合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/best-investment-portfolio-via-monte-carlo-simulation-in-python-53286f3fe93?source=collection_archive---------1-----------------------#2019-08-18">https://towardsdatascience.com/best-investment-portfolio-via-monte-carlo-simulation-in-python-53286f3fe93?source=collection_archive---------1-----------------------#2019-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf99" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头到尾使用 Python 中的蒙特卡罗模拟寻找最佳投资组合</h2></div><p id="8a78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文着重于通过蒙特卡罗模拟生成最优投资组合。我已经用 Python 实现了一个端到端的应用程序，本文记录了该解决方案，以便更多的读者能够从中受益。</p><p id="3c14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文章将以通俗易懂的方式讲解投资管理所需的金融、数学和编程知识。</p><p id="64dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这篇文章对数据科学家、程序员、数学家和那些对金融感兴趣的人很有用。</p><p id="ade6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">请阅读 fintech explained</em><a class="ae lf" href="https://medium.com/p/87dba77241c7?source=your_stories_page---------------------------" rel="noopener"><em class="le">isclaimer</em></a><em class="le">。这个应用程序是基于我的意见，他们可能是错误的。在投资之前，一定要向专业理财顾问寻求建议。</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/1a352a01fc7c9946543440d697fa3621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HyGKh2Nku01rkiB6SBWRQ.png"/></div></div></figure><h1 id="0b2a" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">1.我们想达到什么目的？</h1><p id="75ba" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">假设我想投资 1000 美元一年。我所在的当地商业街银行提供的一年定期存款利率很低。因此，我对它提供的年回报率并不满意。因此，我决定投资股票，用我的 1000 美元购买不同公司的股票。尽管它们相对来说风险更大，但它们可能会帮助我在承担风险后获得更多回报。<strong class="kk iu">到目前为止，一切顺利。</strong></p><p id="2ea6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想以这样一种方式投资，即我可以通过承担最少的风险来获得最高的回报。对我来说，这是最佳投资组合，我将在本文中演示的应用程序将解释我们如何实现它。</p><p id="81f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lf" href="https://github.com/fintechexplained/PortfolioOptimisation" rel="noopener ugc nofollow" target="_blank">代码上传到 Github 上，这里提供了链接</a></p><h1 id="0a26" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">2.高层次的概念</h1><p id="a241" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我已经选择了 7 家有潜力的公司，我想通过购买它们的股票找到投资的最佳方式。</p><p id="25ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，我将执行以下步骤:</p><ul class=""><li id="f664" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld mu mv mw mx bi translated">我有兴趣将我的 1000 美元投资于以下 7 家公司的股票(资产):ZM、优步、SWI、RNG、CRWD、工作、SYMC。</li></ul><p id="66f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:在我以后的文章中，我将用 Python 实现一个解决方案，它将决定我们应该投资的合适公司。它将使用传统的分析概念以及先进的机器学习概念。</em></p><ul class=""><li id="60df" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld mu mv mw mx bi translated">现在我们来问这个问题。我应该从我的 1000 美元投资资金中拿出多少来购买这些股票？传统上，新的投资者会平等地投资于他们的目标公司，但是资产可以互相转移，一些资产可能互相负相关。</li></ul><blockquote class="my"><p id="9488" class="mz na it bd nb nc nd ne nf ng nh ld dk translated">因此，我们需要找到最佳的投资组合。最佳投资组合是以最低风险产生最高回报的投资组合。</p></blockquote><ul class=""><li id="4c79" class="mp mq it kk b kl ni ko nj kr nk kv nl kz nm ld mu mv mw mx bi translated">生成每一个可能的投资组合可能是压倒性的。因此，我将使用蒙特卡罗方法在 Python 中生成 10，000 多个不同的投资组合。</li></ul><blockquote class="my"><p id="89ac" class="mz na it bd nb nc nd ne nf ng nh ld dk translated">该方法围绕这样一个概念，即随着投资组合数量的增加，我们将更接近实际的最优投资组合。</p></blockquote><ul class=""><li id="edbd" class="mp mq it kk b kl ni ko nj kr nk kv nl kz nm ld mu mv mw mx bi translated">对于每个投资组合，我将生成其回报和风险。因此，我需要获取投资组合中每项资产的股票价格。</li><li id="27ed" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld mu mv mw mx bi translated">最后，我将得出回报率/风险比，并从 10，000+个投资组合中选择回报率/风险比最高的投资组合。</li></ul><p id="c974" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将是我们选择的最佳投资组合。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ns"><img src="../Images/1be26e9c8d99f3a23cda64f922e7c9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mSl-cQEH2NnF-GM_"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Photo by <a class="ae lf" href="https://unsplash.com/@benwhitephotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ben White</a> on <a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a200" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:由于我对这个应用程序有很大的未来计划，我将以组件化的方式来架构和设计这个应用程序，以便这个应用程序在未来可以很容易地增强。我还将在本文中解释应用程序的架构和设计。</em></p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="0e84" class="ls lt it bd lu lv oe lx ly lz of mb mc jz og ka me kc oh kd mg kf oi kg mi mj bi translated">3.让我们开始吧:戴上我的金融帽子</h1><ul class=""><li id="0967" class="mp mq it kk b kl mk ko ml kr oj kv ok kz ol ld mu mv mw mx bi translated">存在一种无风险利率，即投资者在不承担任何风险的情况下从其投资中获得的利率，例如购买政府国库券。</li><li id="c85f" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld mu mv mw mx bi translated">风险和回报之间有一个权衡。如果投资者期望投资于比无风险利率风险更高的投资选择，那么他/她期望获得更多回报。这是为了补偿投资者承担的风险。<strong class="kk iu">到目前为止，这一切都说得通！</strong></li><li id="b91a" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld mu mv mw mx bi translated">投资者可以通过购买不同公司的股票开始他/她的投资之旅。让我从现在开始把这些交易称为<strong class="kk iu"> <em class="le">资产</em> </strong>。我们可以获得资产的历史股票价格，并计算它们的风险和回报。当我们开始在我们的投资组合中增加资产时，我们开始意识到这些资产中有一些是相互关联的。因此，资产可以彼此有关系，因此它们可以彼此一起移动。</li><li id="bed0" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld mu mv mw mx bi translated">一个<strong class="kk iu"> <em class="le">投资组合</em> </strong>将资产组合在一起。我们知道，当资产组合在一起时，它们的净风险不仅仅是它们各自风险的简单总和。这里的诀窍是将投资组合视为一种资产，并计算其集体风险和回报。</li></ul><p id="1bce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阅读这篇解释投资管理如何运作的文章</p><div class="om on gp gr oo op"><a href="https://medium.com/fintechexplained/investment-management-and-factors-ee9eb5aa0a24" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">投资管理和因素</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">了解如何明智地投资</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd lq op"/></div></div></a></div><h1 id="abf6" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">4.流程的 7 个步骤</h1><p id="e9a1" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">概括地说，我们需要执行以下七个<strong class="kk iu">步骤，如下图所示:</strong></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi pe"><img src="../Images/52986466af5f8848d0cd916e8890a29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gP3DHc3Dwjj3zevwzgHR8Q.png"/></div></div></figure><p id="9b90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们的商业案例。我们需要实现的应用程序将以一种我们可以在未来轻松扩展和增强每个步骤的方式来执行这些步骤。我会在这篇文章中详细解释。</p><h1 id="3d9d" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">5.让我们专注于上述流程的第 5 步——风险和回报的衡量标准</h1><p id="9acf" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">对于每项资产，我们将生成以下衡量标准:</p><h2 id="e5cc" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">5.1.资产回报</h2><p id="d6ad" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">第一步是计算你投资组合中资产的回报。</p><p id="97a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了计算资产回报，我们需要执行以下两个步骤:</p><ol class=""><li id="b30a" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated">我们需要获取资产的历史每日价格</li></ol><p id="1c30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.然后，我们需要通过计算以下等式来计算它们的几何收益:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/50491548b91ddd124252f6dcd2f54984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/0*YMdsjUg2pRT8v9CS.png"/></div></figure><p id="f91e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">产生回报是为了让我们能够标准化股票价格，以便进行比较。</p><h2 id="0f0f" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">5.2.资产预期平均收益</h2><p id="349d" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">上面计算的资产回报都是二维的，因为有一个时间轴。我们现在需要计算一个数字来表示资产的收益。最常见的方法之一是计算回报的平均值，即预期回报。</p><p id="9879" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了计算资产预期平均收益，我们需要每只股票收益的<strong class="kk iu">均值</strong>:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/763d5586d5379f6b4627987d4e5cfd90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W_aZz4hWQ3fvuWKm.png"/></div></figure><h2 id="a259" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">5.3.从资产到投资组合预期收益</h2><p id="d39d" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在准备计算投资组合的预期收益。投资组合将资产组合在一起。投资组合中的资产已被分配了总投资额的一部分。例如，投资组合可能持有 40%的资产 ABC 和 60%的资产 DEF。</p><p id="b8b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从资产的预期收益，我们可以计算出投资组合的预期收益。它通过计算加权平均值来计算:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/97c2fd138a27e3853c9ed81b95e51e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C7Qg9zq8EkKtTDs3.png"/></div></figure><h2 id="d91d" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">5.4.投资组合风险</h2><p id="be50" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">资产的风险可以用许多风险度量来计算。其中一个指标是标准差，它可以告诉我们资产的价格是如何偏离其均值的。例如，一些资产可能彼此负相关，这意味着随着第一个资产的价值下降，负相关资产的价值增加。这向我们表明，投资组合的风险不是单个资产风险的简单总和。</p><p id="8c05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">投资组合的波动性就是投资组合的风险。波动率的计算方法是使用以下公式计算每只股票收益的标准差以及每对股票之间的协方差:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/9ca8651ee7a26133ff9bdaed512d224c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H79no_fvBCSqWRsY.png"/></div></figure><p id="e8b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，波动率是标准差，即投资组合的总风险。</p><blockquote class="my"><p id="6663" class="mz na it bd nb nc pu pv pw px py ld dk translated">标准差衡量平均值周围的值的离差。</p></blockquote><h2 id="12db" class="pf lt it bd lu pg pz dn ly pi qa dp mc kr qb pl me kv qc pn mg kz qd pp mi pq bi translated">5.5 使用夏普比率寻找最佳投资组合</h2><p id="8765" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们本可以把钱投资到一个储蓄账户(无风险)，在不承担任何风险的情况下获得回报。我们如何决定我们获得的回报是否值得我们承担的风险？因此，我们可以计算夏普比率。</p><p id="f596" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步是计算每个投资组合的夏普比率。夏普比率是相对于无风险利率的超额回报率，作为风险的相关衡量标准:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/b08e070af818d35273b984e035ad06b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VXvuv2jPeIDlOmEz.png"/></div></figure><p id="0f01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想了解更多有关投资绩效衡量的信息，请阅读本文:</p><div class="om on gp gr oo op"><a href="https://medium.com/fintechexplained/how-do-we-measure-investment-performance-7970042c6ae8" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">我们如何衡量投资业绩？</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">解释我们如何评估和计算投资业绩</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="qe l pa pb pc oy pd lq op"/></div></div></a></div><h1 id="1375" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">6.端到端运行 7 个步骤</h1><p id="e10d" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">为了简单起见，在我记录技术细节之前，我想一步一步地展示最终结果。我将采用自下而上的方法，因为这有助于我们更好地理解概念。</p><p id="0504" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一节中，我将使用应用程序为每个步骤生成的可视图表来演示这个概念，以便我们可以更好地理解这个概念。</p><p id="6c62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:我将在下面解释的所有数据都由代码自动保存在 Excel 电子表格中。</em></p><h2 id="9495" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated"><strong class="ak"> 6.1 最终结果:</strong>展示最优组合</h2><p id="0369" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">到目前为止，我们已经了解到，该应用程序将获取我们选择的 7 家公司的历史股票价格。然后，它将通过计算每个投资组合的回报、风险和夏普比率，生成 10，000+个投资组合。</p><p id="e3e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这些投资组合中，它将指明以下三个投资组合:</p><ol class=""><li id="8ec4" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated"><strong class="kk iu">具有最大夏普比率的投资组合。</strong>这是我们的最佳投资组合</li><li id="b764" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated"><strong class="kk iu">风险最小的投资组合。这是为那些有风险意识但不想承担高风险的投资者准备的投资组合。</strong></li><li id="d4b1" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated"><strong class="kk iu">对每项资产的投资平均分配的投资组合。如果我不使用这个应用程序，我会盲目地在资产中平均分配我的投资。因此，这个投资组合将表明，同等投资是否比我所有的其他选择表现更好。</strong></li></ol><p id="0054" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，总共将有 10，001 个投资组合:</p><ol class=""><li id="1907" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated">资产平均分配的投资组合</li><li id="653e" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">10，000 个随机生成的投资组合</li></ol><p id="b6ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我执行应用程序后，显示了 10'001 个投资组合及其风险回报权衡:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi qf"><img src="../Images/be59a4557c168384c9da4c26a14400f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ce5pD9HQcWCsiEHwLGHliA.png"/></div></div></figure><p id="85c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">我们来回顾一下图表:</strong></p><blockquote class="my"><p id="a7ef" class="mz na it bd nb nc pu pv pw px py ld dk translated">每个圈都是一个独特的投资组合。x 轴是风险，y 轴是投资组合的回报。投资组合的颜色是夏普比率。</p></blockquote><p id="fe3a" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr qg kt ku kv qh kx ky kz qi lb lc ld im bi translated">我们可以看到，这种关系并不是完全线性的。当投资者将资产组合在一个投资组合中时，资产的同步运动可以帮助我们分散风险，这就是所谓的风险回报权衡。图表上有三颗钻石:</p><ol class=""><li id="0b2f" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated"><strong class="kk iu">绿钻组合:</strong>这是我们选择的最优组合。对于每个投资组合，我们生成夏普比率。这是夏普比率最大的投资组合。它以最低的风险给了我们最高的回报。这个投资组合被命名为投资组合 2187。</li><li id="346b" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated"><strong class="kk iu">黑钻石投资组合:</strong>这是我们平均分配的投资组合。我们可以看到平均分配的投资组合处于中间位置。它不如标有绿钻的投资组合 2187。我们还可以看到，如果我们平等地投资，对于同样的风险，有许多投资组合会产生更高的回报。因此，这意味着应用程序为我们生成了优秀的投资组合。事实上，所有位于 y 轴黑钻石上方、x 轴价值相同的投资组合都是比平均分配投资组合更好的投资组合，因为对于相同的风险，它们会产生更高的回报。</li><li id="8981" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated"><strong class="kk iu">红钻组合</strong>:这是产生最低风险的组合。</li></ol><p id="0b49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">这些是投资组合 2187 的细节。</strong></p><p id="79aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的两个要点是:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/14ff64cc3255bad1c4fe87a75a7ff70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*hR8iEkCKV79jLVNRQ8qgzQ.png"/></div></figure><ol class=""><li id="2875" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated">它建议我们不要在工作上投资。</li><li id="1dec" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">这也突显出，我们应该将大部分资金投资于 RNG 和 CRWD。</li></ol><p id="ef96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过承担 41%的风险，投资组合的投资组合回报率为 130%。它的夏普比率大约是 316% (=130/41)。</p><h2 id="bd3f" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">6.2 第一步是获取股票价格</h2><p id="4559" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们构建了一个获取过去 3 年历史股票价格的组件:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/56b61084a53d23d187373c7194ccde06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*zWeuzp2VmFV7MPj_frKdXA.png"/></div></figure><p id="4057" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">股票价格是时间序列数据。</p><p id="9fa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是代码存储在 excel 电子表格的 StockPrices 表中的数据快照，如下所示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/b1086d48f2f4e1e5ec8610598c9bd670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*c_AIhlYznUXZk9rOFrA5Mw.png"/></div></figure><p id="93bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，我们不能简单地比较 ZM 和 SYMC，因为它们的股票价格是不同的。因此，我们需要计算回报率来标准化股票价格。</p><h2 id="fca7" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">6.3 然后我们需要产生回报</h2><p id="2313" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们计算了每日几何收益:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/a4394fe91b79041535fa7c12f7048b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*uqcByVTG3etxTolSlUvv2w.png"/></div></figure><p id="cd18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回的是时间序列数据。这是存储在 excel 电子表格的返回表中的数据的快照，如下所示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/082d2091b0087b7b6505523080f0accc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*bFe3TqLjoYXVYoXuIzdvag.png"/></div></figure><p id="1046" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:历史回报是正确的选择吗？我们是否应该制定不同的衡量标准？我将在未来实现一个优秀的应用程序，演示我们如何实现时间加权回报。</p><h2 id="6ca3" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">6.4 根据回报，我们需要生成协方差矩阵</h2><p id="91a8" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">然后，代码准备协方差矩阵:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/1e1c7d404712a1190dc401f4e6537fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*B9tQBCGoADPan4EaJ8qSvQ.png"/></div></figure><p id="3b7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">协方差矩阵存储在 Excel 电子表格的协方差表中，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/58859a93710ce8bcb163374d558fea1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*FkK5ynRrVWJ5x-ITAhOFxg.png"/></div></figure><h2 id="4030" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">6.5 下一步是生成 10001 个投资组合</h2><p id="ebcf" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">代码生成 10'001 个投资组合，其中一个投资组合是我们在 7 项资产上平均分配投资的投资组合。对所有 10，000 个投资组合施加了一个约束，即它们的分配总和必须是 100%。这意味着我们只打算购买资产。</p><p id="fbb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码将投资组合绘制在风险回报图上，其中 y 轴是投资组合的回报，x 轴是投资组合的风险。</p><p id="0b9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到这三个投资组合都有标记。绿钻是我们的最佳投资组合。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/944816ee44d1e8123435df02394522e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*R4JTT3PI0-ybZIn7ybFwyg.png"/></div></figure><p id="fea0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">投资组合存储在 Excel 电子表格的 MonteCarloPortfolios 表中，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi qr"><img src="../Images/632be0bcfbfffb87e0c3166a00581d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*QqLUryK8uR-ZcmnMFj2WFA.png"/></div></div></figure><p id="c098" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以找到投资组合 2187 的配置(我们的最佳投资组合如图所示)，然后对该投资组合进行投资。</p><p id="aa2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有生成的投资组合的风险、回报和夏普比率存储在 MonteCarloPortfolioRatios 表中，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/b50d188be414c16fbe0b4e17726c60e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*1s5DiGPVQlTT5v9J3oWsNQ.png"/></div></figure><h1 id="daf4" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">7.让我们来设计应用程序:戴上我的技术帽子</h1><p id="2a36" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">最后，我将记录我实现的代码。</p><p id="4427" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将从解释如何架构和设计应用程序开始这一部分。我将详细解释每个组件和代码。</p><p id="167d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该应用程序的设计核心仅围绕一个概念:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi qt"><img src="../Images/8929d58c8a4d67d8f047e85497ab207d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qyx9gvkHUiwOevodtI-YPg.png"/></div></div></figure><blockquote class="my"><p id="0d87" class="mz na it bd nb nc nd ne nf ng nh ld dk translated">当应用程序运行时，它将产生大量的数据，如股票价格、回报、协方差矩阵、投资组合及其分配以及风险、回报和夏普比率。Python 代码还会将所有这些数据保存在 Excel 电子表格中。</p></blockquote><h1 id="caa5" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz qu ka me kc qv kd mg kf qw kg mi mj bi translated">7.1 应用程序结构</h1><p id="98e4" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">请点击<a class="ae lf" href="https://github.com/fintechexplained/PortfolioOptimisation" rel="noopener ugc nofollow" target="_blank">这里</a>访问 GitHub 上的全部代码</p><p id="5fe0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下文件夹结构是在 C: drive 中创建的。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/65962b21726b5941c99d705ba0844137.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*jhAKzF-zkP3bmqIU_Y6yiA.png"/></div></figure><p id="6de2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下 Python 文件放在<code class="fe qy qz ra rb b">code</code>文件夹中</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi rc"><img src="../Images/21b241a76e6519e6d7e7345d82589708.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*G6OuVwk1jRj8YNjX2lT0UQ.png"/></div></figure><p id="27f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">我们将在以后的文章中处理文档和测试文件夹。</em></p><h1 id="23dc" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">7.2 让我们了解每个 Python 文件</h1><h2 id="5301" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated"><strong class="ak"> Python 包</strong></h2><p id="7487" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">certify = = 2020 . 4 . 5 . 1<br/>chardet = = 3 . 0 . 4<br/>cycler = = 0 . 10 . 0<br/>idna = = 2.9<br/>kiwi solver = = 1 . 2 . 0<br/>lxml = = 4 . 5 . 0<br/>matplotlib = = 3 . 2 . 1<br/>numpy = = 1 . 18 . 2<br/>pandas = = 0 . 22 . 0<br/>pandas-pandas</p><h2 id="a268" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">1.配置设置</h2><p id="1812" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">目标是实现一个可配置的应用程序。未来的计划是实施更好的风险和回报指标。此外，我们希望代码自动获取正确的公司。</p><p id="2507" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我在代码中实现了一个存储可配置设置的区域:</p><p id="fbde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:settings.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="9e7e" class="pf lt it rb b gy rh ri l rj rk">import numpy as np<br/>import datetime as dt<br/>from calculator import risk_return_calculator</span><span id="428a" class="pf lt it rb b gy rl ri l rj rk">class settings:</span><span id="3d55" class="pf lt it rb b gy rl ri l rj rk">PriceEvent = 'Adj Close'<br/>    ReturnType = 'Geometric'<br/>    NumberOfPortfolios = 10000<br/>    YearsToGoBack = 3<br/>    RiskFreeRate = 0<br/>    CompanyFetchMode = "PreFixed" #Auto<br/>    MyCompanies = ['ZM','UBER','SWI','RNG','CRWD', 'WORK', 'SYMC']<br/>    PortfolioOptimisationPath = 'C:\Temp\PortfolioOptimisation.xlsx'<br/>    RiskFunction = risk_return_calculator.calculate_portfolio_risk<br/>    ReturnFunction = risk_return_calculator.calculate_portfolio_expectedreturns<br/>    AssetsExpectedReturnsFunction = risk_return_calculator.calculate_assets_expectedreturns<br/>    AssetsCovarianceFunction = risk_return_calculator.calculate_assets_covariance<br/>    DailyAssetsReturnsFunction = risk_return_calculator.calculate_daily_asset_returns</span><span id="294a" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def get_my_targets(min_risk):<br/>        return np.arange(min_risk, 1.5, 0.05)</span><span id="b230" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def get_end_date():<br/>        return dt.date.today()</span><span id="54d2" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def get_start_date(end_date):<br/>        return end_date - dt.timedelta(days=settings.YearsToGoBack*365)</span></pre><p id="c75e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的关键是，风险和回报函数，以及投资组合的数量和公司的符号都存储在这里。这将允许我们添加新的公司或生成新的投资组合，并改变风险函数，而不改变代码的其他部分。</p><p id="6b62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当代码执行时，它将输出 excel 电子表格中的数据，这些数据将存储在<code class="fe qy qz ra rb b">PortfolioOptimisationPath = ‘C:\Temp\PortfolioOptimisation.xlsx’</code>中</p><h2 id="6065" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">2.对象工厂</h2><p id="b70e" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">该应用程序大量使用面向对象的设计。因此，在应用程序中实例化了许多对象。我们想从对象的使用中提取对象的创建。因此，对象工厂的职责是为我们实例化所需的对象。</p><p id="454c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想改变实现，那么我们只需要改变那里的逻辑。这将允许我们在将来轻松扩展功能。</p><p id="5f6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:object_factory.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="6b17" class="pf lt it rb b gy rh ri l rj rk">from chart_plotter import chart_plotter<br/>from file_repository import file_repository<br/>from monte_carlo_simulator import monte_carlo_simulator<br/>from companies_extractor import static_companies_extractor as static_companies_extractor<br/>from price_extractor import price_extractor<br/>from calculator import metrics_calculator</span><span id="107e" class="pf lt it rb b gy rl ri l rj rk">class object_factory:<br/>    def __init__(self, settings):<br/>        self.__settings = settings <br/>    <br/>    def get_price_extractor(self, companies):<br/>        return price_extractor(self.__settings.API, companies)</span><span id="164e" class="pf lt it rb b gy rl ri l rj rk">def get_metrics_calculator(self):<br/>        return metrics_calculator</span><span id="779b" class="pf lt it rb b gy rl ri l rj rk">def get_charts_plotter(self):<br/>        return chart_plotter(self.get_metrics_calculator())</span><span id="43b1" class="pf lt it rb b gy rl ri l rj rk">def get_companies_extractor(self):<br/>        return static_companies_extractor(self.__settings.MyCompanies)</span><span id="a0ab" class="pf lt it rb b gy rl ri l rj rk">def get_portfolio_generator(self):<br/>        return monte_carlo_simulator(self.get_metrics_calculator(), self.__settings.RiskFunction, self.__settings.ReturnFunction, self.__settings.NumberOfPortfolios)</span><span id="0dc4" class="pf lt it rb b gy rl ri l rj rk">def get_file_repository(self):<br/>        return file_repository(self.__settings.PortfolioOptimisationPath)</span></pre><p id="cb44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，在下一阶段，我们可以实现一个<code class="fe qy qz ra rb b">web_companies_extractor </code>类，通过删除维基百科网页来获取纳斯达克 100 公司的名称。我们所需要做的就是从函数<code class="fe qy qz ra rb b">get_companies_extractor()</code>中返回<code class="fe qy qz ra rb b">web_companies_extractor</code>，而不改变其余的代码。</p><h2 id="ffff" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">3.公司提取器获取目标公司</h2><p id="7873" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">公司提取器的唯一目的是返回一个数据框，其中填充了所有必需的公司信息。</p><p id="dcdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:companies_extractor.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="e2a6" class="pf lt it rb b gy rh ri l rj rk">import pandas as pd<br/>class static_companies_extractor:<br/>    def __init__(self, my_companies):<br/>        self.__my_companies = my_companies</span><span id="3505" class="pf lt it rb b gy rl ri l rj rk">def get_companies_list(self, current_portfolio=None):<br/>        return pd.DataFrame({'Ticker':self.__my_companies})</span></pre><p id="4938" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个实例中，顾名思义，静态公司提取器返回在 settings.py 文件中配置的公司的静态列表。</p><h2 id="b9c2" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">4.提取资产价格的价格提取器</h2><p id="978f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">价格提取器的目的是获取目标开始和结束日期所需资产的股票价格。</p><p id="7a6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:price_extractor.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="07da" class="pf lt it rb b gy rh ri l rj rk">import pandas as pd<br/>import numpy as np<br/>import pandas_datareader.data as web<br/>import matplotlib.pyplot as plt<br/>import scipy.optimize as solver<br/>import datetime as dt<br/>from functools import reduce</span><span id="c771" class="pf lt it rb b gy rl ri l rj rk">class price_extractor:</span><span id="8768" class="pf lt it rb b gy rl ri l rj rk">def __init__(self, api, companies):<br/>        print('Initialised Price Extractor')<br/>        self.__api = api<br/>        self.__companies = companies<br/>        pass</span><span id="1794" class="pf lt it rb b gy rl ri l rj rk">def get_prices(self,  event, start_date, end_date):<br/>        prices = pd.DataFrame()<br/>        symbols = self.__companies['Ticker']<br/>        tmp={}<br/>        for i in symbols:<br/>            try:<br/>                tmp = web.DataReader(i, self.__api, start_date, end_date)<br/>                print('Fetched prices for: '+i)                <br/>            except:<br/>                print('Issue getting prices for: '+i)<br/>            else:<br/>                prices[i] = tmp[event]            <br/>        return prices</span></pre><h2 id="b3e6" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">5.度量计算器计算夏普比率，并给我们我们的目标投资组合</h2><p id="36e2" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><strong class="kk iu">文件名:calculator.py 第一类</strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="7d2b" class="pf lt it rb b gy rh ri l rj rk">class metrics_calculator:</span><span id="4e3f" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def calculate_sharpe_ratio(risk, returns, risk_free_rate):<br/>        return (returns-risk_free_rate)/risk</span><span id="343f" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def get_max_sharpe_ratio(df):<br/>        return df.ix[df['SharpeRatio'].astype(float).idxmax()]</span><span id="110d" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def get_min_risk(df):<br/>        return df.ix[df['Risk'].astype(float).idxmin()]</span></pre><h2 id="96ad" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">6.风险回报计算器，用于计算风险和回报</h2><p id="a359" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">计算风险和回报的代码位于<code class="fe qy qz ra rb b">risk_return_calculator </code>类中。</p><p id="0b53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:calculator.py 第一类</strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="abac" class="pf lt it rb b gy rh ri l rj rk">import numpy as np<br/>from functools import reduce<br/>import pandas as pd</span><span id="ebe2" class="pf lt it rb b gy rl ri l rj rk">class risk_return_calculator:<br/>    <a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def calculate_assets_expectedreturns(returns):        <br/>            return returns.mean() * 252</span><span id="7c7e" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def calculate_assets_covariance(returns):        <br/>            return returns.cov() * 252</span><span id="4100" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def calculate_portfolio_expectedreturns(returns, allocations):<br/>        return sum(returns * allocations)</span><span id="3052" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a>    <br/>    def calculate_portfolio_risk(allocations, cov):<br/>        return np.sqrt(reduce(np.dot, [allocations, cov, allocations.T]))</span><span id="2494" class="pf lt it rb b gy rl ri l rj rk"><a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def calculate_daily_asset_returns(stock_prices, return_type):<br/>        return np.log(stock_prices / stock_prices.shift(1))</span></pre><p id="0612" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们引入高级风险指标时，我们将在这里添加指标，并相应地更改配置文件。这将允许我们在将来轻松地维护和增强这些特性。作为一个实例，我计划实现 EWMA 来计算资产的预期收益。我所要做的就是实现<code class="fe qy qz ra rb b">risk_return_calculator </code>中的方法，并指向<code class="fe qy qz ra rb b">settings.py </code>文件中所需的方法。</p><h2 id="09c3" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">7.生成投资组合的蒙特卡罗模拟器</h2><p id="2bf7" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这是为我们生成 10，001 个投资组合的主要类。</p><p id="23e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:monte_carlo_simulator.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="1aa5" class="pf lt it rb b gy rh ri l rj rk">import pandas as pd<br/>import numpy as np</span><span id="78f3" class="pf lt it rb b gy rl ri l rj rk">class monte_carlo_simulator:<br/>    def __init__(self, mc, risk_function, return_function, numberOfPortfolios):<br/>        self.__numberOfPortfolios = numberOfPortfolios<br/>        self.__risk_function = risk_function<br/>        self.__return_function = return_function<br/>        self.__mc = mc</span><span id="be27" class="pf lt it rb b gy rl ri l rj rk">def generate_portfolios(self, returns, covariance, risk_free_rate):<br/>        <br/>        portfolios_allocations_df = pd.DataFrame({'Symbol':returns.index,'MeanReturn':returns.values})<br/>        extra_data = pd.DataFrame({'Symbol':['Return','Risk','SharpeRatio'], 'MeanReturn':[0,0,0]})<br/>        portfolios_allocations_df = portfolios_allocations_df.append(extra_data, ignore_index=True)</span><span id="3426" class="pf lt it rb b gy rl ri l rj rk">portfolio_size = len(returns.index)<br/>        np.random.seed(0)</span><span id="bb4f" class="pf lt it rb b gy rl ri l rj rk">#Adding equal allocation so I can assess how good/bad it is<br/>        equal_allocations = self.get_equal_allocations(portfolio_size)<br/>        portfolio_id = 'EqualAllocationPortfolio'<br/>        self.compute_portfolio_risk_return_sharpe_ratio(portfolio_id, equal_allocations, portfolios_allocations_df, returns, covariance, risk_free_rate)</span><span id="7027" class="pf lt it rb b gy rl ri l rj rk">#Generating portfolios        <br/>        for i in range(self.__numberOfPortfolios):<br/>            portfolio_id = 'Portfolio_'+str(i)<br/>            allocations = self.get_random_allocations(portfolio_size)<br/>            self.compute_portfolio_risk_return_sharpe_ratio(portfolio_id, allocations, portfolios_allocations_df,returns, covariance, risk_free_rate)<br/>        return portfolios_allocations_df</span><span id="23e9" class="pf lt it rb b gy rl ri l rj rk">def compute_portfolio_risk_return_sharpe_ratio(self, portfolio_id, allocations, portfolios_allocations_df, returns, covariance, risk_free_rate):<br/>    <br/>        #Calculate expected returns of portfolio<br/>        expected_returns = self.__return_function(returns, allocations)<br/>        #Calculate risk of portfolio<br/>        risk = self.__risk_function(allocations,covariance)<br/>        #Calculate Sharpe ratio of portfolio<br/>        sharpe_ratio = self.__mc.calculate_sharpe_ratio(risk, expected_returns, risk_free_rate)<br/>        <br/>        portfolio_data = allocations<br/>        portfolio_data = np.append(portfolio_data,expected_returns)<br/>        portfolio_data = np.append(portfolio_data,risk)<br/>        portfolio_data = np.append(portfolio_data,sharpe_ratio)<br/>        #add data to the dataframe            <br/>        portfolios_allocations_df[portfolio_id] = portfolio_data</span><span id="0109" class="pf lt it rb b gy rl ri l rj rk">def get_equal_allocations(self, portfolio_size):<br/>        n = float(1/portfolio_size)<br/>        allocations = np.repeat(n, portfolio_size)<br/>        return allocations</span><span id="e03e" class="pf lt it rb b gy rl ri l rj rk">def get_random_allocations(self, portfolio_size):<br/>        <br/>        allocations = np.random.rand(portfolio_size)<br/>        allocations /= sum(allocations)<br/>        return allocations</span></pre><p id="d948" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的关键是，它是用风险和回报函数实例化的。它只是生成一个分配相等的投资组合和 10，000 个分配随机生成的投资组合。每个投资组合的分配总和是 100%，这意味着我们只对购买资产感兴趣。</p><p id="6ff7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后计算每个投资组合的风险、回报和夏普比率。</p><h2 id="ad7f" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">8.图表绘图仪绘制投资组合并标记最佳投资组合</h2><p id="f85c" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这个文件为我们准备了所需的图表。</p><p id="cb89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:chart_plotter.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="1cbd" class="pf lt it rb b gy rh ri l rj rk">import matplotlib.pyplot as plt</span><span id="0c1b" class="pf lt it rb b gy rl ri l rj rk">class chart_plotter:</span><span id="bec6" class="pf lt it rb b gy rl ri l rj rk">def __init__(self, mc):<br/>        self.__mc = mc</span><span id="cd7c" class="pf lt it rb b gy rl ri l rj rk">def show_plots(self):<br/>        plt.show()</span><span id="6bef" class="pf lt it rb b gy rl ri l rj rk">def plot_single_point(self, x,y,title,colour):<br/>        plt.scatter(x=x, y=y, c=colour, marker='D', s=200)<br/>        plt.annotate(title, # this is the text<br/>                 (x,y), # this is the point to label<br/>                 textcoords="offset points", # how to position the text<br/>                 xytext=(0,10), # distance from text to points (x,y)<br/>                 ha='center') # horizontal alignment can be left, right or center</span><span id="b7c5" class="pf lt it rb b gy rl ri l rj rk">def plot_portfolios(self, df):<br/>        # find min Volatility &amp; max sharpe values in the dataframe (df)<br/>        <br/>        max_sharpe_ratio = self.__mc.get_max_sharpe_ratio(df)<br/>        min_risk = self.__mc.get_min_risk(df)</span><span id="5f77" class="pf lt it rb b gy rl ri l rj rk">plt.scatter(df['Risk'], df['Return'],c=df['SharpeRatio'],cmap='RdYlGn', edgecolors='black')<br/>        x = max_sharpe_ratio['Risk']<br/>        y = max_sharpe_ratio['Return']<br/>        name = max_sharpe_ratio['Portfolio']<br/>        <br/>        plt.title(str(len(df))+" Portfolios Risk-Return")<br/>        plt.xlabel("Risk")<br/>        plt.ylabel("Return")</span><span id="81ff" class="pf lt it rb b gy rl ri l rj rk">self.plot_single_point(x,y,'Max Sharpe Ratio: '+name, 'green')<br/>        x = min_risk['Risk']<br/>        y = min_risk['Return']<br/>        name = min_risk['Portfolio']<br/>        self.plot_single_point(x,y,'Min Risk: '+name, 'red')</span><span id="025d" class="pf lt it rb b gy rl ri l rj rk">equal_allocations_portfolio = df.loc[df['Portfolio'] == 'EqualAllocationPortfolio']<br/>        x = equal_allocations_portfolio['Risk'].values[0]<br/>        y = equal_allocations_portfolio['Return'].values[0]<br/>        name = equal_allocations_portfolio['Portfolio'].values[0]<br/>        self.plot_single_point(x,y,'Portfolio: '+name, 'black')</span><span id="2e6a" class="pf lt it rb b gy rl ri l rj rk">def plot_prices(self, closing_prices):<br/>        ax = plt.gca()<br/>        columns = [c for c in closing_prices.columns if c not in 'Date']<br/>        closing_prices.plot(kind='line',use_index=True,y=columns,ax=ax, title='Asset (Stock) Prices')<br/>        plt.show()</span><span id="5244" class="pf lt it rb b gy rl ri l rj rk">def plot_returns(self, returns):<br/>        ax = plt.gca()<br/>        columns = [c for c in returns.columns if c not in 'Date']<br/>        returns.plot(kind='line',use_index=True, y=columns,ax=ax, title='Asset (Stock) Returns')<br/>        plt.show()</span><span id="4edc" class="pf lt it rb b gy rl ri l rj rk">def plot_correlation_matrix(self, df):<br/>        cols = df.columns.values<br/>        fig = plt.figure()<br/>        ax = fig.add_subplot(111)<br/>        cax = ax.matshow(df.corr(), interpolation='nearest')<br/>        fig.colorbar(cax)</span><span id="0df2" class="pf lt it rb b gy rl ri l rj rk">ax.set_xticklabels(cols)<br/>        ax.set_yticklabels(cols)<br/>        plt.show()</span></pre><h2 id="59b6" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">9.文件存储库将所有数据保存在一个文件中</h2><p id="3fd5" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">中间数据和最终投资组合一起存储在一个 excel 文件中。数据的保存由文件存储库执行。</p><p id="4e60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名:file_repository.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="0315" class="pf lt it rb b gy rh ri l rj rk">import pandas as pd</span><span id="24fb" class="pf lt it rb b gy rl ri l rj rk">class file_repository:</span><span id="71cc" class="pf lt it rb b gy rl ri l rj rk">def __init__(self, directory):<br/>        self.__writer = pd.ExcelWriter(directory, engine='xlsxwriter')</span><span id="6c45" class="pf lt it rb b gy rl ri l rj rk">def save_to_file(self, data, sheet_name=None):        <br/>        data.to_excel (self.__writer, sheet_name=sheet_name, header=True)</span><span id="3d1b" class="pf lt it rb b gy rl ri l rj rk">def close(self):<br/>        self.__writer.save()</span></pre><h2 id="eda9" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">10.地图绘制者</h2><p id="21d3" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">蒙特卡洛模拟器在具有以下形状的数据框架中为每个投资组合生成分配以及风险、回报和夏普比率:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi qr"><img src="../Images/632be0bcfbfffb87e0c3166a00581d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*QqLUryK8uR-ZcmnMFj2WFA.png"/></div></div></figure><p id="8e2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，海图绘制者期望风险、回报和夏普比率的 3x1D 阵列:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/b50d188be414c16fbe0b4e17726c60e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*1s5DiGPVQlTT5v9J3oWsNQ.png"/></div></figure><p id="daa1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射器将蒙特卡洛模拟器输出的数据映射为海图绘图仪所需的输入格式。</p><blockquote class="my"><p id="273f" class="mz na it bd nb nc pu pv pw px py ld dk translated">这是单一责任模式的一个例子。每个组件/类都有自己明确的职责。这个特性允许我们在将来轻松地维护和扩展应用程序。</p></blockquote><p id="0ed8" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr qg kt ku kv qh kx ky kz qi lb lc ld im bi translated"><strong class="kk iu">文件名:mappers.py </strong></p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="84d3" class="pf lt it rb b gy rh ri l rj rk">import pandas as pd<br/>class portfolios_allocation_mapper:<br/>    <a class="ae lf" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def map_to_risk_return_ratios(input):<br/>        portfolios = input.columns.values[2:]<br/>        returns = input.loc[input['Symbol'] == 'Return'].values[0][2:]<br/>        risks = input.loc[input['Symbol'] == 'Risk'].values[0][2:]<br/>        sharpe_ratios = input.loc[input['Symbol'] == 'SharpeRatio'].values[0][2:]<br/>        df = pd.DataFrame(<br/>            {'Portfolio': portfolios,<br/>            'Return': returns,<br/>            'Risk': risks, <br/>            'SharpeRatio': sharpe_ratios})<br/>        return df</span></pre><h2 id="e45d" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">11.最后一部分——主文件——胶水</h2><p id="8b88" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">当我们开始这篇文章时，我们概述了这个过程的 7 个步骤。</p><p id="9bd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主文件按照正确的顺序执行这些步骤</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi pe"><img src="../Images/e9ce62f7b3b83e934c825e4fe4f29469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLB0MUxp9xef7eJwWB4Ikw.png"/></div></div></figure><h2 id="e848" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">我们是如何实现的？</h2><p id="4077" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们实现了一个 Main.py 文件，它运行上述所有步骤:</p><pre class="lh li lj lk gt rd rb re rf aw rg bi"><span id="42cb" class="pf lt it rb b gy rh ri l rj rk">from settings import settings<br/>from object_factory import object_factory<br/>from mappers import portfolios_allocation_mapper</span><span id="ac3f" class="pf lt it rb b gy rl ri l rj rk">def generate_optimum_portfolio():</span><span id="0b4d" class="pf lt it rb b gy rl ri l rj rk">#instantiate the objects with the settings<br/>    obj_factory = object_factory(settings)<br/>    ce = obj_factory.get_companies_extractor()<br/>    cp = obj_factory.get_charts_plotter()<br/>    mcs = obj_factory.get_portfolio_generator()<br/>    fr = obj_factory.get_file_repository()<br/>    mc = obj_factory.get_metrics_calculator()</span><span id="c896" class="pf lt it rb b gy rl ri l rj rk">#1. Get companies<br/>    companies = ce.get_companies_list()</span><span id="2b9b" class="pf lt it rb b gy rl ri l rj rk">#2. Get company stock prices<br/>    <br/>    end_date = settings.get_end_date()<br/>    start_date = settings.get_start_date(end_date)<br/>    closing_prices = obj_factory.get_price_extractor(companies).get_prices(settings.PriceEvent, start_date, end_date)</span><span id="7742" class="pf lt it rb b gy rl ri l rj rk">#plot stock prices &amp; save data to a file<br/>    cp.plot_prices(closing_prices)    <br/>    fr.save_to_file(closing_prices, 'StockPrices')</span><span id="7a8e" class="pf lt it rb b gy rl ri l rj rk">#3. Calculate Daily Returns    <br/>    returns = settings.DailyAssetsReturnsFunction(closing_prices, settings.ReturnType)<br/>    #plot stock prices &amp; save data to a file<br/>    cp.plot_returns(returns)<br/>    fr.save_to_file(returns, 'Returns')</span><span id="d9cc" class="pf lt it rb b gy rl ri l rj rk">#4. Calculate Expected Mean Return &amp; Covariance<br/>    expected_returns = settings.AssetsExpectedReturnsFunction(returns)<br/>    covariance = settings.AssetsCovarianceFunction(returns)<br/>    #Plot &amp; Save covariance to file<br/>    cp.plot_correlation_matrix(returns)<br/>    fr.save_to_file(covariance, 'Covariances')</span><span id="4fe3" class="pf lt it rb b gy rl ri l rj rk">#5. Use Monte Carlo Simulation<br/>    #Generate portfolios with allocations<br/>    portfolios_allocations_df = mcs.generate_portfolios(expected_returns, covariance, settings.RiskFreeRate)<br/>    portfolio_risk_return_ratio_df = portfolios_allocation_mapper.map_to_risk_return_ratios(portfolios_allocations_df)<br/>    <br/>    #Plot portfolios, print max sharpe portfolio &amp; save data<br/>    cp.plot_portfolios(portfolio_risk_return_ratio_df)<br/>    max_sharpe_portfolio = mc.get_max_sharpe_ratio(portfolio_risk_return_ratio_df)['Portfolio']<br/>    max_shape_ratio_allocations = portfolios_allocations_df[[ 'Symbol', max_sharpe_portfolio]]<br/>    print(max_shape_ratio_allocations)<br/>    fr.save_to_file(portfolios_allocations_df, 'MonteCarloPortfolios')<br/>    fr.save_to_file(portfolio_risk_return_ratio_df, 'MonteCarloPortfolioRatios')   <br/>    <br/>    <br/>  fr.close()<br/>#This function will execute the steps above</span><span id="d0a0" class="pf lt it rb b gy rl ri l rj rk">generate_optimum_portfolio()</span></pre><p id="e31a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意函数<code class="fe qy qz ra rb b">generate_optimum_portfolio() </code>按正确的顺序执行步骤:</p><ol class=""><li id="d68e" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated">它首先实例化所需的对象</li><li id="a70e" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">获取公司提取器以获取所需的公司。</li><li id="5c0a" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">获取价格提取器以检索资产价格</li><li id="6573" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">计算资产的日收益和协方差</li><li id="793c" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">调用蒙特卡洛模拟器生成投资组合及其回报、风险和夏普比率。</li><li id="95ea" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">然后，绘图仪绘制所需的数据，文件存储库保存数据以供分析。</li></ol><p id="2c0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此功能演示了我们如何实现一个解决方案，将任务委托给负责执行其职责的功能。然后它帮助我们构建一个可维护的应用程序。</p><h2 id="dde1" class="pf lt it bd lu pg ph dn ly pi pj dp mc kr pk pl me kv pm pn mg kz po pp mi pq bi translated">7.3.GitHub 中的完整代码</h2><p id="e050" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">请点击<a class="ae lf" href="https://github.com/fintechexplained/PortfolioOptimisation" rel="noopener ugc nofollow" target="_blank">此处</a>访问 GitHub 上的完整代码</p><h1 id="14a0" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">8.后续步骤</h1><p id="928d" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这是一个可行的解决方案，可以让我们获得最佳的投资组合。现在框架已经构建好了，我们可以轻松地增强它。我将添加以下功能:</p><ol class=""><li id="712d" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld pr mv mw mx bi translated">使用优化器来建立一个有效的边界。这将通过先进的优化技术产生大量优秀的投资组合。</li><li id="9fc0" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">扩展 companies extractor 以生成包含所有 NASDAQ 100 公司的投资组合。</li><li id="1403" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">实施卓越的风险和回报措施，以及前瞻性协方差矩阵。</li><li id="b786" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">使用数据科学和机器学习的概念来帮助我们获得卓越和最佳的投资组合。</li><li id="34d8" class="mp mq it kk b kl nn ko no kr np kv nq kz nr ld pr mv mw mx bi translated">构建一个应用程序，为我们找到前 x 名，例如 10 家公司，然后运行最佳投资组合应用程序。</li></ol><h1 id="ac53" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">9.摘要</h1><p id="3403" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如果您希望看到这些后续步骤得以实施，请告诉我。此外，让我知道你如何喜欢这篇文章。</p><p id="2694" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文的重点是通过蒙特卡罗模拟生成最优投资组合。我已经用 Python 实现了一个端到端的应用程序，本文记录了该解决方案，以便更多的读者能够从中受益。</p><p id="14b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文章还深入浅出地解释了投资管理所需的金融、数学和编程知识。</p><p id="9d3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望有帮助。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="1c33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">注来自《走向数据科学》的编辑:</em> </strong> <em class="le">虽然我们允许独立作者根据我们的</em> <a class="ae lf" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="le">规则和指导方针</em> </a> <em class="le">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae lf" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="le">读者术语</em> </a> <em class="le">。</em></p></div></div>    
</body>
</html>