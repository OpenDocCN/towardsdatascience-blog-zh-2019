<html>
<head>
<title>A Keras CNN to Predict if a Dog is a Poodle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">美国有线电视新闻网预测狗是不是狮子狗</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/poodle-not-poodle-a-keras-cnn-to-predict-if-a-dog-is-a-poodle-17fff85eaf03?source=collection_archive---------32-----------------------#2019-12-06">https://towardsdatascience.com/poodle-not-poodle-a-keras-cnn-to-predict-if-a-dog-is-a-poodle-17fff85eaf03?source=collection_archive---------32-----------------------#2019-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="380a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 Keras 构建二进制卷积神经网络分类器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a9addf52f385d571d8d5b1dfc855d154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*zKBOuXY2EIJH36FTq8GR-Q.jpeg"/></div></figure><p id="3fd4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我想把我的迷你狮子狗放在柱子上。因此，我们将建立一个 CNN 来检测照片中是否包含狮子狗(而不是另一种狗)，而不是一个对数字图像进行分类的无聊教程。</p><p id="95aa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我称之为:狮子狗不是狮子狗。</p><p id="be4e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我发现了一个<a class="ae lm" href="# https://www.kaggle.com/c/dog-breed-identification/data" rel="noopener ugc nofollow"> Kaggle </a>数据集，包含大约 10k 张狗的照片，按品种分类。下载并保存在与笔记本相同的目录中。</p><p id="b976" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">附带的 CSV 包含从品种到照片名称的映射。用熊猫进口。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="f5e4" class="ls lt it lo b gy lu lv l lw lx">import pandas as pd<br/>df = pd.read_csv('dog-breed-identification/labels.csv')<br/>df.head(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/6e99af7d5220768ced6ecfca8da6722c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTBTjMEi2I_9Mh0gUNJ2wg.png"/></div></div></figure><p id="bb9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，通过计算每个品种的数量，并按降序排列，了解不同品种之间的分布情况。熊猫使这变得容易。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="1b4a" class="ls lt it lo b gy lu lv l lw lx">grouped_df = df.groupby('breed').count()<br/>grouped_df.sort_values('id', ascending=False, inplace=True)<br/>grouped_df.head(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi md"><img src="../Images/2e396bdaebacd5a8ac24abc2a87a3fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTZI-NCQftFBIyCU8_MsLQ.png"/></div></div></figure><p id="4805" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">太好了。但是我对狮子狗感兴趣。里面有多少只贵宾犬的例子？我从 Kaggle 上的数据集了解到，这里有 3 个不同的狮子狗品种。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="fadb" class="ls lt it lo b gy lu lv l lw lx">POODLES = ['miniature_poodle', 'standard_poodle', 'toy_poodle']</span><span id="9a3c" class="ls lt it lo b gy me lv l lw lx"># count examples per breed<br/>poodle_grouped_df = grouped_df.loc[POODLES]</span><span id="fabf" class="ls lt it lo b gy me lv l lw lx"># add total for all poodles<br/>poodle_grouped_df.loc['Total',:]= poodle_grouped_df.sum(axis=0)<br/>poodle_grouped_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mf"><img src="../Images/4fd362254f9fe5b252ecffcf8f1e10c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-qErvTM7jNnztVh6vXDGQ.png"/></div></div></figure><p id="1a64" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">很好。接下来，我们将构建一个分类器来检测微型狮子狗。我们还将挑选一种其他特定品种的狗(而不是混合品种)，以方便 CNN 的采访。我们必须训练的每个品种的数据量并不多！</p><p id="1e51" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">创建 2 个数据框，贵宾犬和非贵宾犬。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="0049" class="ls lt it lo b gy lu lv l lw lx">poodle_df = df.loc[df['breed'].isin(['miniature_poodle'])]</span><span id="3ad7" class="ls lt it lo b gy me lv l lw lx">non_poodle_df = df.loc[df['breed'].isin(['bernese_mountain_dog'])]</span></pre><p id="6f4b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mg mh mi lo b">poodle_df</code> = &gt;包含迷你贵宾犬。<br/> <code class="fe mg mh mi lo b">non_poodle_df</code> = &gt;包含伯恩山犬。</p><p id="b2af" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">定义一个函数来构建下载数据集中图像的路径。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="5a64" class="ls lt it lo b gy lu lv l lw lx">import os</span><span id="8baf" class="ls lt it lo b gy me lv l lw lx">def build_path_for_dataset(dframe):<br/>    train_file_names = os.listdir('dog-breed-identification/train')</span><span id="6265" class="ls lt it lo b gy me lv l lw lx">    DIR = 'dog-breed-identification/train/'</span><span id="4f0d" class="ls lt it lo b gy me lv l lw lx">    paths = []<br/>    for idx, row in dframe.iterrows():<br/>        file_name = row['id']+ '.jpg'</span><span id="4362" class="ls lt it lo b gy me lv l lw lx">        if file_name in train_file_names:<br/>            paths.append(DIR + file_name)</span><span id="0f7c" class="ls lt it lo b gy me lv l lw lx">    return paths</span></pre><p id="9c86" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为每个数据集生成路径。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="9b64" class="ls lt it lo b gy lu lv l lw lx">poodle_df['path'] = build_path_for_dataset(poodle_df)<br/>poodle_df.head(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mj"><img src="../Images/af6239b90de70f8b16ed1271f9fbe334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnP-cToyUWVuVVPJ0hdn-Q.png"/></div></div></figure><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="5ab6" class="ls lt it lo b gy lu lv l lw lx">non_poodle_df['path'] = build_path_for_dataset(non_poodle_df)<br/>non_poodle_df.head(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mk"><img src="../Images/a4a2cf990b0dabdef25972de1092f058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rqVp4gWfMz2U8d0C-y8rg.png"/></div></div></figure><p id="5378" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">完美。现在让我们为每个表添加一个布尔列，指定图片是否是狮子狗的。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="42ab" class="ls lt it lo b gy lu lv l lw lx">poodle_df['is_poodle'] = 1<br/>poodle_df.head(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ml"><img src="../Images/e596398464628a59dca6cf496c99d4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXZH-XV2TEVkhDt_1id1BQ.png"/></div></div></figure><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="7cd1" class="ls lt it lo b gy lu lv l lw lx">non_poodle_df['is_poodle'] = 0<br/>non_poodle_df.head(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mm"><img src="../Images/c4d44f29437405a3605b30415cae03c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QA9LQ6oGAvDZ_aFof_B_LA.png"/></div></div></figure><p id="4537" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">组合两个数据帧(现在我们有一个布尔列来区分例子)。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="73ac" class="ls lt it lo b gy lu lv l lw lx">combined_df = pd.concat([poodle_df, non_poodle_df], ignore_index=True)</span></pre><p id="65dd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">把它们排好，这样所有的狮子狗就不会在最上面或者最下面。通过使用<code class="fe mg mh mi lo b">frac=1</code>,我们实际上是在抽取一个包括全部人口的样本，并且在这个过程中，改变顺序。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="6926" class="ls lt it lo b gy lu lv l lw lx">shuffled_combined_df = combined_df.sample(frac=1)</span></pre><p id="b03b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">再次将数据帧分割成 2 个数据帧。但是这一次，一个是训练集，另一个是测试集。这里我们使用的是 70/30 分割。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="14c3" class="ls lt it lo b gy lu lv l lw lx">example_count = len(shuffled_combined_df)<br/>break_point = int(0.7 * example_count)</span><span id="90f5" class="ls lt it lo b gy me lv l lw lx">train_df = shuffled_combined_df[:break_point]<br/>test_df = shuffled_combined_df[break_point:]</span></pre><p id="a4a6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">差不多到了有趣的部分。</p><p id="31f3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些图像的大小都不一样，所以让我们看看图像的平均大小。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="abfc" class="ls lt it lo b gy lu lv l lw lx">from PIL import Image</span><span id="2573" class="ls lt it lo b gy me lv l lw lx">widths = []<br/>heights = []</span><span id="e53b" class="ls lt it lo b gy me lv l lw lx">for idx, row in shuffled_combined_df.iterrows():<br/>    path = row['path']<br/>    im = Image.open(path)<br/>    width, height = im.size<br/>    widths.append(width)<br/>    heights.append(height)</span><span id="e71b" class="ls lt it lo b gy me lv l lw lx">avg_width = int(sum(widths) / len(widths))<br/>avg_height = int(sum(heights) / len(heights))</span><span id="7220" class="ls lt it lo b gy me lv l lw lx">print(avg_width, avg_height)</span><span id="b6f2" class="ls lt it lo b gy me lv l lw lx">#=&gt; 448 385</span></pre><p id="1fbc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">平均宽度为<code class="fe mg mh mi lo b">448</code>，平均高度为<code class="fe mg mh mi lo b">385</code>。</p><p id="9831" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使宽度和高度相等会使以后的变换更简单。因此，我们将图像的大小调整为 300x300。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="38da" class="ls lt it lo b gy lu lv l lw lx"># we'll use this in a minute<br/>WIDTH = 300<br/>HEIGHT = 300</span></pre><p id="8454" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">编写一个函数来:<br/> -加载一个图像<br/> -转换为灰度<br/> -调整大小为 300x300</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="b99f" class="ls lt it lo b gy lu lv l lw lx">from keras.preprocessing.image import load_img</span><span id="e005" class="ls lt it lo b gy me lv l lw lx">def load_resize_color_image(path):</span><span id="d608" class="ls lt it lo b gy me lv l lw lx">    # load image<br/>    image = load_img(path)</span><span id="98f3" class="ls lt it lo b gy me lv l lw lx">    # convert to greyscale<br/>    image = image.convert('L')</span><span id="6831" class="ls lt it lo b gy me lv l lw lx">    # resize<br/>    # 'Image.ANTIALIAS' minimizes distortion when resizing<br/>    image = image.resize((WIDTH,HEIGHT), Image.ANTIALIAS) </span><span id="9e3c" class="ls lt it lo b gy me lv l lw lx">    return image</span></pre><p id="aeef" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一个函数为每个传入的图像创建 2 个转换。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="1028" class="ls lt it lo b gy lu lv l lw lx">from keras.preprocessing.image import ImageDataGenerator<br/>from numpy import expand_dims</span><span id="1998" class="ls lt it lo b gy me lv l lw lx">def random_transform_image(image):<br/>    augmentations = []<br/>    <br/>    samples = expand_dims(image, 0)<br/>    datagen = ImageDataGenerator(rotation_range=90)<br/>    it = datagen.flow(samples, batch_size=1)</span><span id="35e7" class="ls lt it lo b gy me lv l lw lx">    for i in range(2):<br/>        batch = it.next()</span><span id="14bb" class="ls lt it lo b gy me lv l lw lx">        # convert to unsigned integers    <br/>        augmentations.append(batch[0].astype('uint8'))</span><span id="1345" class="ls lt it lo b gy me lv l lw lx">    return augmentations</span></pre><p id="eecd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面的函数获取一幅图像，并通过随机旋转创建两幅图像。然后我们将完全忽略传入的图像，只训练转换。</p><p id="9853" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">训练图像的变换在使用 CNN 时很重要，因为默认情况下它们不是<a class="ae lm" href="https://en.wikipedia.org/wiki/Rotational_invariance" rel="noopener ugc nofollow" target="_blank">旋转不变的</a>。也就是说，一个直立的图像和同一个图像翻转 90 度，对你的模型来说可能看起来完全不同。所以这两方面的训练都很有帮助。</p><p id="6d36" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">生成我们的训练数据。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="e280" class="ls lt it lo b gy lu lv l lw lx">X_train = []<br/>y_train = []</span><span id="7222" class="ls lt it lo b gy me lv l lw lx">from keras.preprocessing.image import img_to_array</span><span id="b075" class="ls lt it lo b gy me lv l lw lx">for idx, row in train_df.iterrows():<br/>    path = row['path']<br/>    is_poodle = row['is_poodle']</span><span id="0b40" class="ls lt it lo b gy me lv l lw lx">    image = load_resize_color_image(path)</span><span id="b511" class="ls lt it lo b gy me lv l lw lx">    image = img_to_array(image)    <br/>    <br/>    images = random_transform_image(image)</span><span id="226f" class="ls lt it lo b gy me lv l lw lx">    for i in images:<br/>        image = i.tolist()</span><span id="09ee" class="ls lt it lo b gy me lv l lw lx">        X_train.append(i)<br/>        y_train.append(is_poodle)</span></pre><p id="08b6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">生成测试数据，我们不会为此生成额外的转换。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="c977" class="ls lt it lo b gy lu lv l lw lx">X_test = []<br/>y_test = []</span><span id="87a8" class="ls lt it lo b gy me lv l lw lx">for idx, row in test_df.iterrows():<br/>    path = row['path']<br/>    is_poodle = row['is_poodle']</span><span id="5165" class="ls lt it lo b gy me lv l lw lx">    image = load_resize_color_image(path)</span><span id="eaef" class="ls lt it lo b gy me lv l lw lx">    image = img_to_array(image)    </span><span id="a008" class="ls lt it lo b gy me lv l lw lx">    image = image.tolist()<br/>    <br/>    X_test.append(image)<br/>    y_test.append(is_poodle)</span></pre><p id="c318" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将我们的特征转换为 numpy 数组。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="5ac1" class="ls lt it lo b gy lu lv l lw lx">X_train = np.array(X_train, dtype=np.uint8)<br/>X_test = np.array(X_test, dtype=np.uint8)</span></pre><p id="f62f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">二进制化我们的标签。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="8d65" class="ls lt it lo b gy lu lv l lw lx">y_train = label_binarize(y_train, neg_label=0, pos_label=1, classes=[0,1])<br/>y_train = np.hstack((1 - y_train, y_train))</span><span id="12d7" class="ls lt it lo b gy me lv l lw lx">y_test = label_binarize(y_test, neg_label=0, pos_label=1, classes=[0,1])<br/>y_test = np.hstack((1 - y_test, y_test))</span></pre><p id="5170" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">构建模型。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="8594" class="ls lt it lo b gy lu lv l lw lx">import keras<br/>from keras.models import Sequential<br/>from keras.layers import Dense, Dropout, Flatten<br/>from keras.layers import Conv2D, MaxPooling2D<br/>from keras.layers. normalization import BatchNormalization</span><span id="720e" class="ls lt it lo b gy me lv l lw lx">model = Sequential()</span><span id="dd5b" class="ls lt it lo b gy me lv l lw lx">model.add(Conv2D(32, kernel_size = (3, 3), activation='relu', input_shape=(300, 300, 1)))<br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(BatchNormalization())</span><span id="9e50" class="ls lt it lo b gy me lv l lw lx">model.add(Conv2D(64, kernel_size=(3,3), activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(BatchNormalization())</span><span id="a6b9" class="ls lt it lo b gy me lv l lw lx">model.add(Conv2D(128, kernel_size=(3,3), activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(BatchNormalization())</span><span id="a2a0" class="ls lt it lo b gy me lv l lw lx">model.add(Dropout(0.2))<br/>model.add(Flatten())</span><span id="c82d" class="ls lt it lo b gy me lv l lw lx">model.add(Dense(128, activation='relu'))<br/>model.add(Dense(2, activation = 'softmax'))</span></pre><p id="600c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是一个非常典型的模型，卷积层的大小会增加。</p><p id="ad6b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">编译模型。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="a2ca" class="ls lt it lo b gy lu lv l lw lx">model.compile(loss='binary_crossentropy', optimizer='adam', metrics = ['accuracy'])</span></pre><p id="7a71" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">跑起来！</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="e459" class="ls lt it lo b gy lu lv l lw lx">for i in range(10):</span><span id="e3dc" class="ls lt it lo b gy me lv l lw lx">    model.fit(X_train, y_train, batch_size=30, epochs=1)<br/>    loss, acc = model.evaluate(X_test, y_test, verbose = 0)<br/>    print(acc * 100)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mn"><img src="../Images/73fb4134e090d1c9750c692d1f6fb0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaA52LPJsyYY1D12ojhovQ.png"/></div></div></figure><p id="1150" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">考虑到少量的训练数据，这实际上比我预期的要好。虽然我们只选择了两个品种的狗，这让我们自己变得容易多了。</p><p id="cf2b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了好玩，我们会把我给你看的狮子狗的照片分类放在最上面。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="0ea4" class="ls lt it lo b gy lu lv l lw lx">X_me = []<br/>y_me = []</span><span id="592c" class="ls lt it lo b gy me lv l lw lx">path = 'my_poodle.jpg'</span><span id="83a5" class="ls lt it lo b gy me lv l lw lx">image = load_resize_color_image(path)<br/>image = img_to_array(image)<br/>image = image.tolist()</span><span id="8898" class="ls lt it lo b gy me lv l lw lx">X_me.append(image)<br/>y_me.append(1)</span><span id="5b30" class="ls lt it lo b gy me lv l lw lx">X_me = np.array(X_me, dtype=np.uint8)</span><span id="a7c8" class="ls lt it lo b gy me lv l lw lx">y_me = label_binarize(y_me, neg_label=0, pos_label=1, classes=[0,1])<br/>y_me = np.hstack((1 - y_me, y_me))</span><span id="71c0" class="ls lt it lo b gy me lv l lw lx">loss, acc = model.evaluate(X_me, y_me, verbose = 0)<br/>print(acc * 100)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mo"><img src="../Images/5f7d6e4c69fb6ab9f6150c29eda85d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbNRX_jmQG3iKMvNU_gcWg.png"/></div></div></figure><p id="33f5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">成功！！</p><p id="7d68" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们能做得更好吗？当然啦！更多不同类型的变换，如翻转、亮度和缩放可能会有所帮助。但最重要的是，更多的数据。</p><p id="ee85" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管我们应该对目前的结果感到满意。</p></div></div>    
</body>
</html>