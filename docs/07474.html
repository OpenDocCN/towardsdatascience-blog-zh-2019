<html>
<head>
<title>Dueling Deep Q Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">决斗深度 Q 网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dueling-deep-q-networks-81ffab672751?source=collection_archive---------4-----------------------#2019-10-19">https://towardsdatascience.com/dueling-deep-q-networks-81ffab672751?source=collection_archive---------4-----------------------#2019-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9db3" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/Dqn-family" rel="noopener" target="_blank"> DQN 家族</a></h2><div class=""/><div class=""><h2 id="0311" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">用于深度强化学习的决斗网络架构</h2></div><h1 id="7b87" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">回顾和介绍</h1><p id="c6c5" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">让我们先回顾一下一些重要的定义，然后再看 DQN 论文。这些大部分应该都不陌生。</p><ul class=""><li id="189c" class="mc md iq li b lj me lm mf lp mg lt mh lx mi mb mj mk ml mm bi translated">给定代理的策略π，动作值和状态值分别定义为:</li></ul><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/9d0812ebf8ab3defaef14cfe4cab7f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBCrQ2L--lWrEcwQ7Td-Eg.png"/></div></div></figure><ul class=""><li id="caa5" class="mc md iq li b lj me lm mf lp mg lt mh lx mi mb mj mk ml mm bi translated">上面的 Q 函数也可以写成:</li></ul><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mz"><img src="../Images/37802d1a2692947348a553e466de22ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68bsDWx-D0gih5fIART2GA.png"/></div></div></figure><ul class=""><li id="b451" class="mc md iq li b lj me lm mf lp mg lt mh lx mi mb mj mk ml mm bi translated"><strong class="li ja">优势</strong>是通过用 V 值减去 Q 值获得的量:</li></ul><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi na"><img src="../Images/61ecc7c17e655ff9da09bc8f661575a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMtO3kVsRllKxw_FmmeKhg.png"/></div></div></figure><p id="9e8a" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">回想一下，Q 值表示在给定状态下选择特定动作的值，V 值表示不管采取什么动作都给定状态的值。然后，直观地，优势值显示了在给定状态下选择一个动作相对于其他动作有多有利。</p><h1 id="2c43" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">什么变化和动机</h1><ul class=""><li id="b26a" class="mc md iq li b lj lk lm ln lp ne lt nf lx ng mb mj mk ml mm bi translated">(王等)提出了新颖的<em class="nh">决斗架构</em>，它通过两个独立的流明确地分离了状态值和依赖于状态的动作优势的表示。</li><li id="532a" class="mc md iq li b lj ni lm nj lp nk lt nl lx nm mb mj mk ml mm bi translated">这种架构背后的关键动机是，对于一些游戏来说，没有必要知道每个动作在每个时间步的值。作者举了一个 Atari 游戏 Enduro 的例子，在这个游戏中，在碰撞即将发生之前，不需要知道应该采取什么行动。</li></ul><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9a85ffabf38262ec40bd63dace55b3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/1*UJXzq34DAg2L-9SsUA_I0w.gif"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Atari Enduro. Source: <a class="ae ns" href="https://gfycat.com/clumsypaleimpala" rel="noopener ugc nofollow" target="_blank">https://gfycat.com/clumsypaleimpala</a></figcaption></figure><ul class=""><li id="5b8e" class="mc md iq li b lj me lm mf lp mg lt mh lx mi mb mj mk ml mm bi translated">通过显式分离两个估计器，决斗架构可以了解哪些状态是(或不是)有价值的，而不必了解每个状态的每个动作的效果。就像 Enduro 的例子一样，这种架构在一些任务中变得尤其重要，在这些任务中，行动可能并不总是以有意义的方式影响环境。</li></ul><h1 id="a5f3" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">体系结构</h1><p id="16f1" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">像标准的 DQN 架构一样，我们有卷积层来处理游戏帧。从那里，我们将网络分成两个独立的流，一个用于估计状态值，另一个用于估计依赖于状态的动作优势。在这两个流之后，网络的最后一个模块组合状态值和优势输出。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nt"><img src="../Images/10c76114e6f3b1e91bbcc1218101732b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKZ-cS0mCdXMOO_bfBlN0Q.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Dueling Architecture, Source: <a class="ae ns" href="https://www.freecodecamp.org/news/improvements-in-deep-q-learning-dueling-double-dqn-prioritized-experience-replay-and-fixed-58b130cc5682/" rel="noopener ugc nofollow" target="_blank">https://www.freecodecamp.org/news/improvements-in-deep-q-learning-dueling-double-dqn-prioritized-experience-replay-and-fixed-58b130cc5682/</a></figcaption></figure><p id="e9e9" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">现在，我们如何组合/聚合这两个值呢？</p><p id="0f34" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">将两个值相加似乎很直观，从优势值的定义中可以立即看出:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nu"><img src="../Images/fec0010867fe8b44919deb5af876cb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRwaYI9RFrf4KoVYW1AJgA.png"/></div></div></figure><p id="6fa9" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">然而，作者提出了关于该方法的两个问题:</p><ol class=""><li id="4d38" class="mc md iq li b lj me lm mf lp mg lt mh lx mi mb nv mk ml mm bi translated">假设和分别给出状态值和动作优势的合理估计是有问题的。因此，天真地将这两个值相加是有问题的。</li><li id="ecce" class="mc md iq li b lj ni lm nj lp nk lt nl lx nm mb nv mk ml mm bi translated">两者的简单和是“不可识别的”，因为给定 Q 值，我们不能唯一地恢复 V 和 A。Wang 等人的实验表明，这种可识别性的缺乏会导致较差的实际性能。</li></ol><p id="3445" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">因此，神经网络的最后一个模块实现了如下所示的正向映射:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nw"><img src="../Images/961874228282dfc550acf4f214d133dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ik1BTbPH5YZTaDaVdW3dFg.png"/></div></div></figure><p id="3065" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">这将迫使最大化动作的 Q 值等于 V，解决了可识别性问题。</p><p id="bba5" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">或者，如在王等人的实验中所使用的，我们也可以使用:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/f2d912a9307ed3f20b6d50a203626655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEhyDCFRY-28sTdU4aE9pg.png"/></div></div></figure><p id="0d13" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">然后，我们根据以下因素选择最佳行动<code class="fe ny nz oa ob b">a*</code>:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/bfad543eccf70dd67de5c70a16e7c5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbSKStfEUQmKL0I6-Y8mbg.png"/></div></div></figure><h1 id="75db" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">培养</h1><p id="7d1f" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">因为决斗架构与标准 DQN 架构共享相同的输入输出接口，所以训练过程是相同的。我们将模型的损失定义为均方误差:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi od"><img src="../Images/3fe04c3df8a89e727a7bb1decef54b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCuiE2XNc7yM_PjD9qLRGg.png"/></div></div></figure><p id="4d21" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">并采取梯度下降步骤来更新我们的模型参数。</p><h1 id="0ad2" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">履行</h1><p id="4653" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">所以，我们将通过决斗 DQN 的实施。</p><p id="9646" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">1.网络架构:如上所述，我们希望将状态相关的动作优势和状态值分成两个独立的流。如上所述，我们还使用正向映射来定义网络的正向传递:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3cf0" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">2.接下来，我们将实现更新功能:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5729" class="pw-post-body-paragraph lg lh iq li b lj me ka ll lm mf kd lo lp nb lr ls lt nc lv lw lx nd lz ma mb ij bi translated">除此之外，标准的 DQN 建筑没有什么变化；关于完整的实现，请查看我的香草 DQN 邮报，或者我的 Github 库:</p><div class="og oh gp gr oi oj"><a href="https://github.com/cyoon1729/deep-Q-networks" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ja gy z fp oo fr fs op fu fw iz bi translated">cy oon 1729/深度 Q 网络</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">Q-learning 家族(PyTorch)算法的模块化实现。实现包括:DQN，DDQN，决斗…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox mx oj"/></div></div></a></div><h1 id="448c" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">参考</h1><ul class=""><li id="c333" class="mc md iq li b lj lk lm ln lp ne lt nf lx ng mb mj mk ml mm bi translated"><a class="ae ns" href="https://arxiv.org/abs/1511.06581" rel="noopener ugc nofollow" target="_blank">深度强化学习的决斗网络架构(王等，2015) </a></li></ul></div></div>    
</body>
</html>