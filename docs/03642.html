<html>
<head>
<title>Deploy a Machine Learning Model as an API on AWS Elastic Beanstalk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 AWS Elastic Beanstalk 上部署一个机器学习模型作为 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-a-machine-learning-model-as-an-api-on-aws-43e92d08d05b?source=collection_archive---------8-----------------------#2019-06-10">https://towardsdatascience.com/deploy-a-machine-learning-model-as-an-api-on-aws-43e92d08d05b?source=collection_archive---------8-----------------------#2019-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0a75" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/towards-data-science/data-science-in-the-real-world/home" rel="noopener">现实世界中的数据科学</a></h2><div class=""/><div class=""><h2 id="09b5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">循序渐进的教程</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/198043d682a570598723e0051a392403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dfz4AdSKheQ28GQC19JXRw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Sorry, I don’t use Instagram, so I have to post pictures of my dog here.</figcaption></figure><p id="9d74" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每天都有几十篇很棒的文章和教程在讨论如何开发各种机器学习模型。但是，我很少看到解释如何将模型投入生产的文章。<strong class="lj jd">如果你想让你的模型对现实世界产生影响，它需要对其他用户和应用程序是可访问的。</strong></p><p id="734e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个分步指南将向您展示<strong class="lj jd">如何将模型部署为 API。</strong>为您的模型构建一个 API 是将您的工作集成到您公司系统中的一个很好的方式——其他开发人员只需要学习如何与您的 API 交互来使用您的模型。对于有抱负的数据科学家来说，这也是让他们的投资组合项目脱颖而出的绝佳方式。</p><p id="2673" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本教程面向数据科学家和有抱负的数据科学家，他们在将应用程序和 API 部署到 web 方面没有什么经验。到最后，你会知道如何:</p><ol class=""><li id="ec6a" class="md me it lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">使用 Python 的 web 微框架 Flask 开发一个模型 API。</li><li id="212c" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">使用 Docker 将 API 容器化为微服务。</li><li id="c53d" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">使用 AWS Elastic Beanstalk 将模型 API 部署到 web 上。</li></ol><h1 id="ba83" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">为什么要构建 API？</h1><p id="e6c2" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">在深入研究代码之前，让我们讨论一下为什么我们更喜欢这种方法，而不是将模型代码放在主应用程序中。构建一个可以被主应用程序调用的独立服务有几个优点:</p><ul class=""><li id="aaba" class="md me it lj b lk ll ln lo lq mf lu mg ly mh mc no mj mk ml bi translated">更新更加简单，因为每个系统的开发人员不需要担心破坏其他系统。</li><li id="2f5a" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc no mj mk ml bi translated">更具弹性，因为主应用程序中的故障不会影响模型 API，反之亦然。</li><li id="1c86" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc no mj mk ml bi translated">易于扩展(当对 API 使用微服务架构时)。</li><li id="3121" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc no mj mk ml bi translated">易于与多个系统集成，即网络和移动系统。</li></ul><h1 id="8619" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">模型</h1><p id="0154" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">如果你正在开发一个项目组合，最好使用不太传统的数据集来帮助你在雇主面前脱颖而出。然而，为了本教程，我将使用著名的<a class="ae np" href="https://scikit-learn.org/stable/datasets/index.html#boston-dataset" rel="noopener ugc nofollow" target="_blank">波士顿房价数据集</a>。该数据集包含几个可用于预测 1980 年前后波士顿住宅价值的要素。</p><p id="2490" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我选择使用<a class="ae np" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank">随机森林</a>来处理这个回归问题。我任意选择了一个特征子集来包含在模型中。如果我正在开发一个“真实世界”的模型，我会尝试许多不同的模型并仔细选择特性。</p><p id="22ff" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">查看我的 GitHub <a class="ae np" href="https://github.com/brent-lemieux/model_api" rel="noopener ugc nofollow" target="_blank"> repo </a>获取快速构建和保存模型的说明。跟着做，然后为您的建模项目构建一个 API！</p><h1 id="fc95" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">API</h1><p id="1732" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">在<code class="fe nq nr ns nt b">app/</code>目录下创建脚本<code class="fe nq nr ns nt b">app.py</code>。如果你遵循了<a class="ae np" href="https://github.com/brent-lemieux/model_api" rel="noopener ugc nofollow" target="_blank">回购</a>中的说明，这个目录也应该包含保存的模型(<code class="fe nq nr ns nt b">model.pkl</code>)。</p><p id="3a2c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nq nr ns nt b">app/app.py</code>中的前几行从 Flask、NumPy 和 pickle 导入了有用的功能。我们也从下面包含的<code class="fe nq nr ns nt b">app/features.py</code>进口<code class="fe nq nr ns nt b">FEATURES</code>。接下来，我们初始化应用程序并加载模型。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="d53b" class="ny ms it nt b gy nz oa l ob oc"># app/app.py</span><span id="967e" class="ny ms it nt b gy od oa l ob oc"># Common python package imports.<br/>from flask import Flask, jsonify, request, render_template<br/>import pickle<br/>import numpy as np</span><span id="ccb9" class="ny ms it nt b gy od oa l ob oc"># Import from app/features.py.<br/>from features import FEATURES</span><span id="67c5" class="ny ms it nt b gy od oa l ob oc"># Initialize the app and set a secret_key.<br/>app = Flask(__name__)<br/>app.secret_key = 'something_secret'</span><span id="8084" class="ny ms it nt b gy od oa l ob oc"># Load the pickled model.<br/>MODEL = pickle.load(open('model.pkl', 'rb'))</span></pre><h2 id="8adf" class="ny ms it bd mt oe of dn mx og oh dp nb lq oi oj nd lu ok ol nf ly om on nh iz bi translated">特征</h2><p id="b47d" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我将特性列表存储在一个单独的脚本中，以保证 API 中模型训练和预测的一致性。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="890e" class="ny ms it nt b gy nz oa l ob oc"># app/features.py</span><span id="b653" class="ny ms it nt b gy od oa l ob oc">FEATURES = ['INDUS', 'RM', 'AGE', 'DIS', 'NOX', 'PTRATIO']</span></pre><h2 id="7c34" class="ny ms it bd mt oe of dn mx og oh dp nb lq oi oj nd lu ok ol nf ly om on nh iz bi translated">端点</h2><p id="1341" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我们的 Flask app 对象(上面定义为<code class="fe nq nr ns nt b">app = Flask(__name__)</code>)有一个有用的 decorator 方法，使得定义端点<code class="fe nq nr ns nt b">.route()</code>变得容易。在下面的代码中，<code class="fe nq nr ns nt b">@app.route('/api')</code>告诉服务器每当 http://{your_ip_address}/api 接收到一个请求时，就执行直接在它下面定义的<code class="fe nq nr ns nt b">api()</code>函数。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="0f9c" class="ny ms it nt b gy nz oa l ob oc"># app/app.py (continued)</span><span id="c66e" class="ny ms it nt b gy od oa l ob oc"><a class="ae np" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/api', methods=['GET'])<br/>def api():<br/>    """Handle request and output model score in json format."""<br/>    # Handle empty requests.<br/>    if not request.json:<br/>        return jsonify({'error': 'no request received'})</span><span id="338a" class="ny ms it nt b gy od oa l ob oc">    # Parse request args into feature array for prediction.<br/>    x_list, missing_data = parse_args(request.json)<br/>    x_array = np.array([x_list])</span><span id="aa08" class="ny ms it nt b gy od oa l ob oc">    # Predict on x_array and return JSON response.<br/>    estimate = int(MODEL.predict(x_array)[0])<br/>    response = dict(ESTIMATE=estimate, MISSING_DATA=missing_data)</span><span id="e05c" class="ny ms it nt b gy od oa l ob oc">    return jsonify(response)</span></pre><h2 id="ade5" class="ny ms it bd mt oe of dn mx og oh dp nb lq oi oj nd lu ok ol nf ly om on nh iz bi translated">解析请求</h2><p id="3f6e" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我们需要包含<code class="fe nq nr ns nt b">parse_args()</code>函数来解析 JSON 请求中的特性。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="951a" class="ny ms it nt b gy nz oa l ob oc"># app/app.py (continued)</span><span id="8d04" class="ny ms it nt b gy od oa l ob oc">def parse_args(request_dict):<br/>    """Parse model features from incoming requests formatted in    <br/>    JSON."""<br/>    # Initialize missing_data as False.<br/>    missing_data = False</span><span id="f333" class="ny ms it nt b gy od oa l ob oc"># Parse out the features from the request_dict.<br/>    x_list = []<br/>    for feature in FEATURES:<br/>        value = request_dict.get(feature, None)<br/>        if value:<br/>            x_list.append(value)<br/>        else:<br/>            # Handle missing features.<br/>            x_list.append(0)<br/>            missing_data = True<br/>    return x_list, missing_data</span></pre><h2 id="85f8" class="ny ms it bd mt oe of dn mx og oh dp nb lq oi oj nd lu ok ol nf ly om on nh iz bi translated">启动应用程序</h2><p id="206f" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">最后，在 Flask 的开发服务器上运行应用程序，确保它能够正常工作。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="f95b" class="ny ms it nt b gy nz oa l ob oc"># app/app.py (continued)</span><span id="4c11" class="ny ms it nt b gy od oa l ob oc">if __name__ == '__main__':<br/>    app.run(host='0.0.0.0', port=5000, debug=True)</span></pre><p id="8530" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">用<code class="fe nq nr ns nt b">$ python app.py</code>启动服务器。在另一个终端窗口中，使用<code class="fe nq nr ns nt b">curl</code>向 API 发送请求。以 JSON 格式传递带有<code class="fe nq nr ns nt b">--data</code>标志的特性。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="c540" class="ny ms it nt b gy nz oa l ob oc">$ curl -X GET "<a class="ae np" href="http://0.0.0.0:5000/api" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/api</a>" -H "Content-Type: application/json" --data '{"INDUS":"5.9", "RM":"4.7", "AGE":"80.5", "DIS":"3.7", "NOX":"0.7", "PTRATIO":"13.6"}'</span><span id="1b62" class="ny ms it nt b gy od oa l ob oc">{<br/>  "ESTIMATE": 18,<br/>  "MISSING_DATA": false<br/>}</span></pre><h2 id="2ed7" class="ny ms it bd mt oe of dn mx og oh dp nb lq oi oj nd lu ok ol nf ly om on nh iz bi translated">生产 Web 堆栈</h2><p id="eac1" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">Flask 的开发 web 服务器非常适合测试，但是由于我不在这里讨论的原因，我们需要在其他地方寻找我们的生产栈。你可以在这里阅读更多关于这个<a class="ae np" href="https://vsupalov.com/flask-web-server-in-production/" rel="noopener ugc nofollow" target="_blank">的内容</a>。我们将使用 Gunicorn 作为应用服务器，使用 Nginx 作为 web 服务器。幸运的是，AWS Elastic Beanstalk 默认为我们处理 Nginx 部分。要安装 Gunicorn，运行<code class="fe nq nr ns nt b">$ pip install gunicorn</code>。创建脚本<code class="fe nq nr ns nt b">app/wsgi.py</code>并添加两行:</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="86c2" class="ny ms it nt b gy nz oa l ob oc"># app/wsgi.py</span><span id="b077" class="ny ms it nt b gy od oa l ob oc">from app import app<br/>app.run()</span></pre><p id="4339" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，运行<code class="fe nq nr ns nt b">$ gunicorn app:app --bind 0.0.0.0:5000</code>。您应该能够执行与上面相同的<code class="fe nq nr ns nt b">curl</code>命令来从 API 获得响应。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="80c5" class="ny ms it nt b gy nz oa l ob oc">$ curl -X GET "<a class="ae np" href="http://0.0.0.0:5000/api" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/api</a>" -H "Content-Type: application/json" --data '{"INDUS":"5.9", "RM":"4.7", "AGE":"80.5", "DIS":"3.7", "NOX":"0.7", "PTRATIO":"13.6"}'</span><span id="fadf" class="ny ms it nt b gy od oa l ob oc">{<br/>  "ESTIMATE": 18,<br/>  "MISSING_DATA": false<br/>}</span></pre><h1 id="e7a6" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">码头工人</h1><p id="f8bd" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">Docker 现在非常流行，关于它的好处已经写了很多。如果你有兴趣学习更多关于 Docker 的知识并获得更深入的介绍，请阅读这个。</p><p id="3b2b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于本教程，您需要在您的计算机上设置 Docker，按照这里的说明<a class="ae np" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">进行操作</a>。你还需要一个 Docker Hub 账户。</p><p id="880e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦你都设置好了，让我们开始吧！构建 Docker 映像需要两个主要文件，<code class="fe nq nr ns nt b">Dockerfile</code>和<code class="fe nq nr ns nt b">requirements.txt</code>。</p><p id="73c9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nq nr ns nt b">Dockerfile</code>包括创建环境、安装依赖项和运行应用程序的说明。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="035d" class="ny ms it nt b gy nz oa l ob oc"># app/Dockerfile</span><span id="853a" class="ny ms it nt b gy od oa l ob oc"># Start with a base image<br/>FROM python:3-onbuild</span><span id="82fa" class="ny ms it nt b gy od oa l ob oc"># Copy our application code<br/>WORKDIR /var/app<br/>COPY . .<br/>COPY requirements.txt .</span><span id="4ef3" class="ny ms it nt b gy od oa l ob oc"># Fetch app specific dependencies<br/>RUN pip install --upgrade pip<br/>RUN pip install -r requirements.txt</span><span id="0125" class="ny ms it nt b gy od oa l ob oc"># Expose port<br/>EXPOSE 5000</span><span id="877f" class="ny ms it nt b gy od oa l ob oc"># Start the app<br/>CMD ["gunicorn", "app:app", "--bind", "0.0.0.0:5000"]</span></pre><p id="6c44" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nq nr ns nt b">requirements.txt</code>包含我们的应用程序所需的所有 Python 包。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="8722" class="ny ms it nt b gy nz oa l ob oc"># app/requirements.txt</span><span id="380d" class="ny ms it nt b gy od oa l ob oc">Flask==1.0.2<br/>itsdangerous==1.1.0<br/>Jinja2==2.10.1<br/>MarkupSafe==1.1.1<br/>simplejson==3.16.0<br/>Werkzeug==0.15.2<br/>numpy==1.16.4<br/>pandas==0.24.2<br/>scikit-learn==0.19.1<br/>scipy==1.0.0<br/>requests==2.22.0<br/>gunicorn==19.9.0</span></pre><p id="ccf8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe nq nr ns nt b">app/</code>目录中，运行:</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="bde2" class="ny ms it nt b gy nz oa l ob oc">$ docker build -t &lt;your-dockerhub-username&gt;/model_api .</span><span id="8384" class="ny ms it nt b gy od oa l ob oc">$ <!-- -->docker run -p 5000:5000 blemi/model_api</span></pre><p id="7323" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您的应用程序现在运行在 Docker 容器中。重新运行<code class="fe nq nr ns nt b">curl</code>命令，会得到同样的输出！</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="b342" class="ny ms it nt b gy nz oa l ob oc">$ curl -X GET "<a class="ae np" href="http://0.0.0.0:5000/api" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/api</a>" -H "Content-Type: application/json" --data '{"INDUS":"5.9", "RM":"4.7", "AGE":"80.5", "DIS":"3.7", "NOX":"0.7", "PTRATIO":"13.6"}'</span><span id="640b" class="ny ms it nt b gy od oa l ob oc">{<br/>  "ESTIMATE": 18,<br/>  "MISSING_DATA": false<br/>}</span></pre><p id="6e39" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">运行<code class="fe nq nr ns nt b">$ docker push &lt;your-dockerhub-username&gt;/model_api</code>将图像推送到您的 Docker Hub 帐户。在部署到 AWS Elastic Beanstalk 时，这最后一步会非常方便。</p><h1 id="6344" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">AWS 弹性豆茎</h1><p id="d43e" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">是时候把我们的 API 放到网上了，这样我们的朋友和同事就可以访问它了！创建一个<a class="ae np" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS 帐户</a>并登录控制台。<strong class="lj jd"> <em class="oo">注意:您需要提供一张信用卡来创建您的帐户。如果您按照下面的说明操作，不修改任何选项，您的应用程序将符合自由层资格，并且成本将最低。一旦你启动了你的应用程序，导航到你的账单仪表板，在那里你可以看到你估计的每月费用。</em> </strong></p><p id="95cb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们将创建一个文件，告诉 AWS 在哪里访问我们的图像。这叫<code class="fe nq nr ns nt b">Dockerrun.aws.json</code>。这里的关键部分是“名称”值。我的 Docker Hub 用户名是“blemi ”,我将图像命名为“model_api ”,所以我将把<code class="fe nq nr ns nt b">blemi/model_api:latest</code>作为“name”值。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="dee2" class="ny ms it nt b gy nz oa l ob oc">{<br/>  "AWSEBDockerrunVersion": "1",<br/>  "Image": {<br/>    "Name": "&lt;your-dockerhub-username&gt;/model_api:latest",<br/>    "Update": "true"<br/>  },<br/>  "Ports": [<br/>    {<br/>      "ContainerPort": "5000"<br/>    }<br/>  ],<br/>  "Logging": "/var/log/nginx"<br/>}</span></pre><p id="9405" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在 AWS 控制台中，搜索“Elastic Beanstalk”并选择它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/312418219644fc648e65da7fa926db40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-STTAuX4dnZixrUqWyuOcw.png"/></div></div></figure><p id="e6a1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">选择右上角的“创建新应用程序”，为您的应用程序添加名称和描述，然后单击“创建”</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/c986b9b618b67781d54209f965acb43d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0K2co-fEZaVWw5ulWsmcA.png"/></div></div></figure><p id="df59" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">点按“立即创建一个”</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/29b4584a025c05f03892da55712238f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCCOnDQcZOhWpUkdOxBM8g.png"/></div></div></figure><p id="99e0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">保持“Web 服务器环境”处于选中状态，然后单击“选择”继续。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/e893bdec205c69f676a2ee434e752433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2GPRPit-MX9JRrUd6aNZQ.png"/></div></div></figure><p id="7bf7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果愿意，为“域”和“描述”填写一个自定义值。对于“平台”，选择“预配置的平台”，并在下拉列表中选择“Docker”。对于“应用程序代码”，选择“上传您的代码”并单击“上传”按钮。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/05090e313bd44dbe37f3ea0f5a7ebe13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u__-qm12HBdSRNX9IG4pnA.png"/></div></div></figure><p id="449c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">点击“选择文件”按钮，打开我们在上面创建的<code class="fe nq nr ns nt b">Dockerrun.aws.json</code>文件。<strong class="lj jd"> <em class="oo">注意:只有当你把你的 Docker 镜像推送到 Docker Hub 时，这个功能才会起作用。</em> </strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/ffc5d8be08c62def5068982636c07512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCAL7tJdUzB724GgwC_rtQ.png"/></div></div></figure><p id="2ffa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">单击“上传”,然后单击“创建环境”来部署应用程序。</p><p id="426d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="oo">注意:如果您正在创建一个生产级 API，在选择“创建环境”之前，您可能需要在这里选择“配置更多选项”——如果您有兴趣了解其他一些增强安全性和可伸缩性的选项，请联系我。我的信息在这篇文章的底部。</em>T9】</strong></p><p id="274e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该应用程序需要几分钟的时间来部署，但部署完成后，您可以通过屏幕顶部提供的 URL 进行访问:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/5928f9fbcb8f657158ce84167910b23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBwZX3zfhHeaUciRh-Rz2A.png"/></div></div></figure><p id="f3e0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们在 web 上托管的 API 上运行<code class="fe nq nr ns nt b">curl</code>命令。</p><pre class="ks kt ku kv gt nu nt nv nw aw nx bi"><span id="1b94" class="ny ms it nt b gy nz oa l ob oc">$ curl -X GET "<a class="ae np" href="http://api-demo-dattablox.us-west-2.elasticbeanstalk.com/api" rel="noopener ugc nofollow" target="_blank">http://api-demo-dattablox.us-west-2.elasticbeanstalk.com/api</a>" -H "Content-Type: application/json" --data '{"INDUS":"5.9", "RM":"4.7", "AGE":"80.5", "DIS":"3.7", "NOX":"0.7", "PTRATIO":"13.6"}'</span><span id="be66" class="ny ms it nt b gy od oa l ob oc">{"ESTIMATE":18,"MISSING_DATA":false}</span></pre><h1 id="0d78" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">总结和最终想法</h1><p id="db49" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我们用 Python Flask 构建了一个简单的模型 API，用 Docker 将其容器化，用 AWS Elastic Beanstalk 将其部署到 web 上。您现在可以利用这些知识为您的模型和项目开发 API 了！这使得与其他开发人员的合作变得更加容易。他们只需要学习如何使用你的 API 将你的模型集成到他们的应用和系统中。</p><p id="fe11" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要使这个 API 可以投入生产，还需要做更多的工作。在 AWS 和 Flask 应用程序本身中，您可以设置许多配置来增强安全性。如果使用量很大，还有许多选项可以帮助提高可伸缩性。Flask-RESTful 是一个 Flask 扩展，使得符合 REST API 最佳实践变得容易。如果你对使用 Flask-RESTful 感兴趣，可以看看这个伟大的<a class="ae np" rel="noopener" target="_blank" href="/deploying-a-machine-learning-model-as-a-rest-api-4a03b865c166">教程</a>。</p><h1 id="8895" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">取得联系</h1><p id="a05a" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">如果您有任何反馈或批评，请分享。如果您觉得本指南有用，请务必关注我，这样您就不会错过未来的文章。</p><p id="36bc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想联系，<strong class="lj jd">在</strong><a class="ae np" href="https://www.linkedin.com/in/brent-lemieux/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd">LinkedIn</strong></a>上联系我。感谢阅读！</p></div></div>    
</body>
</html>