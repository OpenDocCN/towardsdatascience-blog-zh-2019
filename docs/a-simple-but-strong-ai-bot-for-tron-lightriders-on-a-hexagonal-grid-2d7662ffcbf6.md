# 一个简单但强大的人工智能机器人，用于六边形网格上的创/光骑士

> 原文：<https://towardsdatascience.com/a-simple-but-strong-ai-bot-for-tron-lightriders-on-a-hexagonal-grid-2d7662ffcbf6?source=collection_archive---------17----------------------->

## 基于寻路的简单启发式算法如何找到通往排行榜顶层的路径。

新的学年，意味着新一批聪明的学生开始了他们工程生涯的第一步。[和去年](https://medium.com/@gillesvandewiele/creating-the-perfect-connect-four-ai-bot-c165115557b0)一样，我和我的三个课程助理同事([埃利亚斯](https://telefoonboek.ugent.be/nl/people/802001314384)、[彼得](https://telefoonboek.ugent.be/nl/people/802002430187)和[奥赞](https://telefoonboek.ugent.be/nl/people/802001937309))为一个人工智能机器人竞赛创建了一个[平台，将在根特大学的](https://hexatron.ilabt.imec.be/)[教授 Dhoedt](https://www.ugent.be/ea/idlab/en/members/bart-dhoedt.htm) 讲授的信息学课程(他们在该课程中学习 Python 编程)期间举办。今年，我们决定主办 Tron(有时称为连续蛇或 Lightriders)的游戏，如下所示。

![](img/ddd98c7548160f6f0b73711b13f61d77.png)

A more advanced implementation of the game Tron, called [Armagetron](http://www.armagetronad.org/)

既然[谜语. io](https://www.riddles.io/) 和 [CodinGame](https://www.codingame.com) (如果你对 AI 机器人感兴趣的话绝对应该去看看！)也为 Tron 举办一场人工智能比赛，我们决定稍微修改游戏，让它在六边形网格上玩，而不是正方形。这可以避免学生只是复制粘贴那些平台的可用解决方案。游戏截图可以在下面找到。

![](img/e445101a74f596c4fee12bd1eba81f46.png)

A visualization of a match between two bots, which I lost. The darker colored tiles are starting positions.

和去年一样，我决定自己参加比赛，但没有那么多空闲时间。因此，我的解决方案不是很强。尽管如此，我最终在排行榜上名列前茅(第五名)，拥有最少的代码基础和简单的启发式搜索，基于路径查找。

![](img/5b76131796624552abc1bff76aed4019.png)

The top 10 of the final leaderboard. Again this year, we were amazed by the quantity and quality of many submitted agents by students. Notice how [jvdhooft,](http://users.ugent.be/~jvdrhoof/) my partner in crime of last year, regretted his decision of not collaborating this year ;).

为了讨论我的解决方案，我不需要像去年那样多的时间/行数，因此我决定添加一些额外的内容。我把这篇博文分成几个部分:

# 目录

1.  [游戏和竞赛规则](https://medium.com/p/2d7662ffcbf6#6e39)
2.  [我的强启发式的详细概述(附代码)](https://medium.com/p/2d7662ffcbf6#3953)
3.  一些顶级竞争对手写的文章
4.  [竞赛平台制作概述(另文)](https://medium.com/p/1184666f32e4)

# 1.游戏和竞赛规则

## 1.1 游戏规则

游戏规则相当简单明了。两个玩家都从一个随机的位置(镜像在地图的中心)开始，并且有一个随机的方向(总共有 6 个方向)。每个玩家必须决定是否要旋转他们的蛇(120°或 60°顺时针/逆时针或 0°)，然后向前移动(如下图所示)。每条蛇都会留下难以穿越的痕迹。第一条撞到墙壁或自己或对手的踪迹的蛇输掉游戏。

![](img/98529b1926804a6fdb23b53ba6b07333.png)

The five possible moves a player can make in each turn.

## 1.2 竞赛规则和代理界面

提交的代理必须遵循预定义的界面:

```
def **generate_move**(board, positions, orientations):
  """Generate a move.
     Args:
        board (np.array):    playing field
        positions (list):    list of positions `(x, y)`
        orientations (list): list of orientations (int in [0,5]) Returns:
        move (int):          integer in [-2,2]
    """
  return 0
```

此外，每个代理必须遵守以下限制:

*   它不包含`import`语句，除了:`numpy, functools, itertools, collections, operator, heapq, math, random, time`
*   文件大小不得大于 1 兆字节
*   `generate_move`的执行时间不得超过 1 秒

向我们的平台提交您的第一个代理后，您将每 30 分钟与另一名玩家配对一次。每场比赛结束后，双方玩家的排名( [TrueSkill](https://en.wikipedia.org/wiki/TrueSkill) 或 [ELO](https://en.wikipedia.org/wiki/Elo_rating_system) )会根据比赛结果进行调整，这些排名用于排行榜。关于排名系统的更多信息，请参考[我的下一篇文章](https://medium.com/p/1184666f32e4)。

## 1.3 定期比赛和附加赛

比赛持续了 1 个月左右。我们注意到运气对你的最终排名有很大的影响(由于匹配算法)。为了克服这一点，并尽可能客观地结束排名，我们在一段时间后从排行榜上剔除了排名靠前的竞争者(仅限一年级学生)。这些竞争者被挑选出来参加“附加赛”，每个代理人与所有其他代理人比赛四次。每赢一场，代理人被分配三分，而平局(有很多场)导致双方代理人被奖励一分。

# 2.我的基于寻路的强启发式算法

## 2.1 主回路

在实现更复杂的技术之前，比如强化学习、遗传算法和阿尔法-贝塔剪枝，首先实现一个基于启发式的代理总是一个好的实践。这些可以用来测试你对手的实力，但更重要的是你代理的后期版本的实力。不幸的是，由于时间不够，我今年没有实现更复杂的技术，只上传了我的基线代理，基于一个启发式的(结果非常强大)。我现在将彻底讨论我的实现。

我的代理人背后的主要推理相当简单:“总是选择导致你可以首先到达的牌的数量与你的对手可以首先到达的牌的数量之间的最大差异的移动。”很明显，会有很多情况下，每一个可能的走法的结果都是相同的分数(尤其是在游戏开始的时候)。我们通过最小化某一步后剩余合法走法的数量和最小化到中间的距离(如果还能到达的话)来打破平局。主游戏循环如下所示:

The main loop of our agent. In each turn, we iterate over all possible legal moves

## 2.2 获得所有合法移动

现在让我们把所有事情都分解开来，从(可能)代码中最简单的部分开始:获得所有合法的移动(`get_legal_moves`)。在这个函数中，我们迭代区间[-2，2]中的每个整数，这是五个可能的移动。我们将每个整数映射到一个偏移量元组(`get_steps`)，该偏移量元组对应于我们的移动，并根据这些偏移量更新我们假设的位置和方向(`_update_pos_orient`)。然后，我们计算我们是否仍然居住在六边形网格中(`_valid_position`)以及我们是否没有撞上一个已经被占用的单元(`_no_crash`):

代码相当简单，可能不需要太多的阐述。为了检查我们是否仍然在六边形网格中，我们必须通过检查我们的`x`和`y`坐标是否没有超出我们游戏区域的边界来确保我们没有得到`IndexError`。此外，由于棋盘表示是一个带有一些不可到达的单元格的正方形，我们需要确保我们的代理不会移动到这些单元格中的任何一个上。通过检查主页上描绘的较小(`7x7`)游戏场，我们注意到合法单元的`x`和`y`之和以 3 和 9 为界。

![](img/73ba15a58937b8049fd8e16a5313f68b.png)

The x and y coordinates of the allowed tiles on a 7x7 field are bounded by 3 and 9.

这适用于所有比赛场地，因此我们可以说:

![](img/6aaa58ebfc07731db24b388afad11e42.png)

k 是运动场的大小。此外，为了检查我们是否没有在已经被占用的单元上移动，我们可以只沿着我们的游戏板的最终轴进行求和(记住这个游戏板的最终轴包含每个玩家的位图),并检查我们想要移动到的坐标的值是否等于 0。此外，`_get_steps`中偏移的顺序是特定的顺序，这样我们可以使用我们新计算的方向(等于`(orientation + action) % 6`)直接索引它们。使用这个新的方向，我们可以得到相应的偏移量，并将它们添加到我们当前的坐标中，以计算我们的新坐标。

## 2.3 计算游戏状态的效用或分数

现在我们有了一个不会导致我们立即失败的所有移动的列表，我们可以根据启发式算法计算每个移动的分数。我们使用的试探法是基于到游戏区域中每个可能牌的距离。我们希望在比对手少走几步的情况下，尽可能多的拿到牌，同时尽可能少的先拿到牌。下面展示了一个不错的 GIF，取自谷歌 Tron 人工智能挑战赛中[获胜解决方案的报道。](https://www.a1k0n.net/2010/03/04/google-ai-postmortem.html)

![](img/4a58ef20f686d059805ca028a4e453ce.png)

Maximizing the cells we (red) can reach first, while minimizing the cells our opponent (blue) can reach first results in a strong, but not optimal, heuristic.

为了计算从某个坐标到另一个单元的最小距离，我们可以使用 [A*寻路算法](https://en.wikipedia.org/wiki/A*_search_algorithm)或 [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) 。但是因为我们需要计算到网格中所有单元的距离，所以我们使用一个稍加修改的版本。我们跟踪仍然需要访问的单元列表(以及到每个单元的距离)，称为`frontier`。对于我们的边界中的每个单元，我们在所有可能的方向上扩展，并且如果它们还没有被探索或者如果我们发现了具有较小移动量的路径，则将这些新单元添加到我们的边界中(距离等于我们的旧距离+ 1)。一旦我们计算了两个玩家到所有单元的距离，我们就可以很容易地计算出两个玩家可以首先到达的牌的数量:

> 就是这样！就这么简单。简而言之，我们检索所有可能合法行动的列表，然后迭代这些合法行动并计算每个行动的得分。分数是基于我们在移动后可以从新的位置首先到达的牌的数量，以及我们的对手可以首先到达的牌的数量。还有一些额外的细节，例如，如果我们离对手太近，无法避免正面碰撞，则从分数中减去一个惩罚项，以及平局情况下的处理(平局的打破基于填满棋盘的剩余合法移动的数量以及到中间的距离，因为这在游戏开始时很重要)。

## 2.4 可能的改进和其他方向

如前所述，今年只花了有限的时间写我的经纪人。因此，许多可能的改进是开放的。最重要的列举如下:

*   启发式函数的适应可以导致显著的收益。根据谷歌 Tron 人工智能挑战赛的报道，这导致作者赢得了比赛。在他的博客文章中，提供了一个很好的游戏状态示例，其中用于我的代理的启发式函数将分配一个负的分数，而我们(再次是红色的)实际上是赢的一方:

![](img/197d8511403ac56214104a298c65f8da.png)

According to our heuristic, red has much less tiles he can reach first than blue. But no matter what move blue makes now, red can easily win the game since it is impossible for blue to fill up all his tiles.

*   我们可以为每一步可能的棋计算分数，而不是为每一步可能的棋计算分数，从而预测不止一步棋。为了解决这个问题，我们通常使用诸如[阿尔法-贝塔剪枝](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning)这样的技术，但是由于两个玩家同时移动，所以需要做一些额外的考虑。一个简单的方法是首先为你的对手检索所有合法的移动，然后迭代你所有的合法移动(改变游戏状态)，然后递归地调用你的对手，传递这些移动。这确保了两个玩家都可以计算他们的合法移动，在递归过程中使用相同的游戏状态。
*   使用[蒙特卡罗模拟](https://en.wikipedia.org/wiki/Monte_Carlo_tree_search)，而不是使用启发式函数，计算每个可能的移动(或移动序列)的分数。在这里，我们将模拟从某个游戏状态开始的大量游戏，其中每个代理人将进行随机但合法的移动。我们从这些模拟中赢得的游戏分数可以很好地表明某个游戏状态的实力。当然，需要注意的是，出招的最大时间只有一秒。我没有测试一个人在一秒钟内可以做多少次模拟。
*   [进化神经网络](https://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies)为你玩游戏，是一个非常通用的策略，不需要游戏本身的知识。为此编写一个框架(或者配置一个已经存在的框架)将需要相当多的工作，但是一旦编写好了(或者掌握了现有框架的窍门)，它就可以很容易地适用于其他游戏。我发现很多单人贪吃蛇游戏的例子(比如这里的[这里的](https://www.youtube.com/watch?v=edyRAnQO7N0)和[这里的](https://www.youtube.com/watch?v=zIkBYwdkuTk))但是连续贪吃蛇或者 tron 的例子非常少(比如这里的[这里的](https://www.youtube.com/watch?v=JnBzhrEjlPo))。
*   阅读其他顶级竞争对手的评论，并结合所有人最重要的见解来创建一个超级机器人。

# 3.顶级竞争对手的报道

以下是一些最终排名高于我的代理的学生的答案:

## **3.1。Michiel Platteau(决赛排行榜第一，附加赛第二)**

> 这个机器人是它所有前身的产物。每次我做了很多元函数，而不是重新编写新代码。很多更小的功能总是可以回收到下一代。这些功能包括确定移动是否合法，计算可用单元的数量以及到这些单元的距离。但是将所有这些功能结合起来会变得相当复杂。
> 
> 代码首先计算对手是否和他在同一个领域，如果他不在，他用最大数量的可用单元进行最左边的移动(floodfill)。如果他们在同一个领域，这都是为了在未来拥有最好的防洪堤。它从去中心(6，6)开始。如果蛇从边界开始，他尽可能走得宽些，试图欺骗对手，否则他会走最中间的路线，试图把场地分成两半。比赛场地的中央是一个非常重要的位置。我为这个动作做了一个特殊的函数。他观察哪些位置可以给他优势而不给对手优势。如果他没有找到一个这样的位置，他就向中间移动，导致许多可能的选择。
> 
> 一旦机器人完成了对中心的争夺，我已经定义了一个函数来模拟如果我的蛇在每个可能的方向上直线前进的情况。它分析我的机器人是否可以从那里利用优势(更大的洪水)，以及到那个地点的距离是否更短。它分析了“成功”、“可能平局”或“成功但距离更远”的情况。对于我能做的移动，他也像对对手那样运行那个功能，并且不做可能导致对对手有利的移动。这可能需要一段时间，所以它在 0.7 秒后停止这样做，它只是假设对手不会有优势。如果没有成功的移动是可能的，他试着尽可能靠近中心和敌人。

## 3.2. [Kristiaan Bogaerts](https://www.linkedin.com/in/kristiaanbogaerts) (决赛排行榜第 2 名，附加赛第 3 名)

> 在每一回合开始时，代理根据它收到的数据生成几个**变量**，其中一些是长度和宽度等于棋盘长度和宽度的 2D 数组，其他的是单元素整数或布尔。这些**变量**作为**输入**用于最终决定邻近代理的哪个六边形是最适合下一个去的，并且因此代理应该如何旋转以到达那个六边形，这是**输出**。
> 
> 代理生成的前述**变量**包括:
> 
> *一个 2D 阵列，其中对应于一个六边形的每个元素表示未被两个代理之一或其轨迹占据的相邻六边形的数量
> 
> * 2D 数组，其中对应于一个六边形的每个元素指的是从该六边形到棋盘边缘的最短可能距离(以六边形表示)
> 
> *一个布尔值，表示两个代理是否仍能相互联系
> 
> 计算完这些**变量**后，代理根据单元素变量的值为 2D 数组分配权重。2D 阵列被乘以它们各自的权重，随后被加在一起以构建最终的 2D 阵列**。在这个**最终数组**中对应于棋盘上的六边形的每个元素都被分配了一个值，如果代理通过移动到该六边形估计赢得游戏的机会相对较高，则该值相对较高，如果代理估计的机会相对较低，则该值相对较低。最后，代理将检查其位置周围的每个六边形，寻找在**最终数组**中具有最高对应值的六边形，并将输出到达该六边形所需的旋转。**

## 3.3.马克西姆·德·克勒克( [LinkedIn](http://www.linkedin.com/in/maxim-d-716472160) ， [GitHub](http://github.com/maximdeclercq) )(最终排行榜第三，附加赛第一)

> 最终代理有两个主要版本，v8 和 v10，其中 v10 的策略几乎与 v8 完全相同，只是它的速度更快，因为它用图形表示棋盘(我将在后面解释)。
> 
> 两个代理都有一大组实用函数，允许更快地编写代码，因为这些函数可以在版本之间复制，因为它们的实现保持不变(例如，位置 x 可以播放吗？代理从 x 位置可以到达多少个单元格？位置 x 和 y 之间的距离是多少？集合 s 中离位置 x 最近的位置是什么？).
> 
> 代码的其余部分由算法组成，以确定最佳行动。这些算法中的大多数过滤可玩的棋步，并将它们传递给另一个算法来打破平局。第一种算法确定我们是否必须在两个或更多区域之间做出决定，并且只传递导致更大区域的移动。然后代理检查我们是否能到达对手，如果不可能，我们可以用填充算法填充剩余的区域。
> 
> 在所有其他情况下，去棋盘的中心几乎总是最佳的。如果代理将要走到棋盘的中心，它首先检查对手是否也能到达中心。如果可以，那么代理人可以通过稍微向左或向右移动来切断对手，但前提是开始位置在棋盘的边缘，并且切断的区域比对手的区域大。
> 
> 如果上述特殊情况都没有发生，代理就退回到它的通用洪泛算法，该算法使移动产生它能首先到达的最多的单元。如果对手能和代理同时到达一个单元格，则算作半个单元格。
> 
> 如果泛洪在几个移动中得到相同的分数，它会将这些移动传递给多光线投射算法，这是一种相当古老的算法(v6 ),它从两个玩家的位置投射光线，并确定哪个移动会产生最大的区域。
> 
> v8 和 v10 最大的区别在于填充算法。v8 只从玩家的位置投射单条光线来确定最大可能的区域，而 v10 从网格中组成一个图形。这是通过将网格中的每个位置映射到一个从 0 到 126 的数字来实现的。因为光线投射仍然有用，所以我必须为图中的节点定义一个方向，所以我定义了一个 127×5 的网格，其中 get _ next _ nodes()[node][direction % 6]将为我提供代理在该方向上可以到达的节点。然后，一个相当复杂的转换函数会将网格转换成邻接表。代理现在可以确定图形中的[关节点](https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/)，而不是光线投射。代理现在可以通过在接下来的两个移动中产生最少关节点的移动来填充该区域。这导致任何区域的完美填充。

**重要:** Maxim 在[他的 GitHub](http://github.com/maximdeclercq) 上发布了代码。请务必查看比赛的获胜方案。你甚至可以模拟我和他经纪人之间的游戏！

# 结束语

这篇博文中讨论的所有代理代码都可以在 [GitHub](https://github.com/GillesVandewiele/Hexatron-Bot) 上获得。我尽了最大努力清理和优化代码，但它肯定还不够完美。因此，我们非常欢迎您提交拉动请求或开放问题！

> 此外，和往常一样，如果这篇博文中有什么不清楚或者需要进一步澄清的地方，请随时发表评论，或者联系我！如果你对明年的游戏有任何酷的建议，请随时留下评论！

哇，你已经到达这篇博文的结尾了！向你致敬。第三届 AI 大赛明年见；)，
张卫