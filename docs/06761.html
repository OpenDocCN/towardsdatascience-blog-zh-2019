<html>
<head>
<title>Feature Engineering techniques in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的特征工程技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-techniques-in-python-97977ecaf6c8?source=collection_archive---------19-----------------------#2019-09-26">https://towardsdatascience.com/feature-engineering-techniques-in-python-97977ecaf6c8?source=collection_archive---------19-----------------------#2019-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="620a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特征工程是每个机器学习项目中至关重要的一部分。在这篇文章中，我们将围绕一些技术来处理这项任务。请不要犹豫提出新的想法，我会尽可能保持这篇文章的更新。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/20fccf8442b96bf6ef27d6174986c770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ULMCum7EqEynGF8bvFweQ.jpeg"/></div></div></figure><h2 id="17e6" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">合并训练和测试</strong></h2><p id="2ee7" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">当执行特征工程时，为了有一个通用的模型，如果你有两个文件，只需将它们合并(训练和测试)就可以了。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="8970" class="kx ky iq lw b gy ma mb l mc md">df = pd.concat([train[col],test[col]],axis=0)<br/>#The label column will be set as NULL for test rows</span><span id="d665" class="kx ky iq lw b gy me mb l mc md"># FEATURE ENGINEERING HERE</span><span id="dead" class="kx ky iq lw b gy me mb l mc md">train[col] = df[:len(train)]<br/>test[col] = df[len(train):]</span></pre><h2 id="2c69" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">记忆减少</h2><p id="ecc2" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">有时，列的类型编码不是最佳选择，例如，用 int32 编码只包含 0 到 10 的值的列。最流行的函数之一是使用一个函数，通过将列的类型转换为尽可能最好的类型来减少内存的使用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="da95" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">移除异常值</h2><p id="2925" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">移除异常值的常用方法是使用 Z 值。</p><p id="1b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您希望删除至少有一列包含异常值(用 Z 得分定义)的每一行，您可以使用以下代码:</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="18a5" class="kx ky iq lw b gy ma mb l mc md">from scipy import stats<br/>df[(np.abs(stats.zscore(df)) &lt; 3).all(axis=1)]</span></pre><h2 id="d118" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">南诡计</h2><p id="8627" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">一些基于树的算法可以处理 NAN 值，但他会在 NAN 和非 NAN 值之间有一个步骤，这有时可能是无意义的。一个常见的技巧是用低于所考虑的列中最低值的值填充所有 nan 值(例如-9999)。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="78a2" class="kx ky iq lw b gy ma mb l mc md">df[col].fillna(-9999, inplace=True)</span></pre><h2 id="4476" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">分类特征</h2><p id="29ae" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">您可以使用标注编码来处理分类要素，将其作为数字来处理。您也可以决定将它们视为类别。我建议两者都尝试一下，并通过这一行代码(在标签编码之后)保持交叉验证。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="d26a" class="kx ky iq lw b gy ma mb l mc md">df[col] = df[col].astype('category')</span></pre><h2 id="78df" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">组合/拆分</h2><p id="c29f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">有时字符串变量在一个变量中包含多个信息。比如<code class="fe mh mi mj lw b">FRANCE_Paris</code>。您将需要使用正则表达式或使用拆分方法来拆分它，例如:</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="4795" class="kx ky iq lw b gy ma mb l mc md">new <strong class="lw ir">=</strong> <!-- -->df["localisation"].str.split("_", n <strong class="lw ir">=</strong> <!-- -->1, expand <strong class="lw ir">=</strong> <!-- -->True)<br/>df['country'] = new[0]<br/>df['city']=new[1]</span></pre><p id="a13a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，两个(字符串或数字)列可以合并为一列。例如，包含法国某个部门(75 代表巴黎)和地区代码(001)的列可以变成邮政编码:75001)</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="7633" class="kx ky iq lw b gy ma mb l mc md">df['zipcode'] = df['departement_code'].astype(str)<br/>                +'_'<br/>                +df['disctrict_code'].astype(str)</span></pre><h2 id="52da" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">线性组合</h2><p id="d8d8" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">特征工程的一个共同特点是应用简单的数学运算来创造新的特征。例如，如果我们有一个矩形的宽度和高度，我们可以计算面积。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="ccb4" class="kx ky iq lw b gy ma mb l mc md">df['area'] = df['width'] * df['height']</span></pre><h2 id="fd93" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">计数栏</h2><p id="b88c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">创建列从流行的<code class="fe mh mi mj lw b">value_count</code>方法创建列对于基于树的算法来说是一种强大的技术，用来定义一个值是稀有的还是常见的。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="95da" class="kx ky iq lw b gy ma mb l mc md">counts = df[col].value_counts.to_dict()</span><span id="143b" class="kx ky iq lw b gy me mb l mc md">df[col+'_counts'] = df[col].map(counts)</span></pre><h2 id="dcf0" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">处理日期</h2><p id="d058" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">为了分析事件，处理日期和解析日期的每个元素是至关重要的。</p><p id="0626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要转换日期列(通常被认为是熊猫的字符串列)。其中最重要的一个领域是知道如何使用<code class="fe mh mi mj lw b">format</code>参数。强烈推荐将<a class="ae mk" href="http://strftime.org/" rel="noopener ugc nofollow" target="_blank">这个站点</a>保存为书签！:)</p><p id="0d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果我们要用下面的格式转换一个日期列:<code class="fe mh mi mj lw b">30 Sep 2019</code>我们将使用这段代码:</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="8445" class="kx ky iq lw b gy ma mb l mc md">df['date'] =  pd.to_datetime(df[col], format='%d %b %Y')</span></pre><p id="7e87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您的列被转换为<code class="fe mh mi mj lw b">datetime</code>，我们可能需要提取新闻列中的日期部分:</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="d739" class="kx ky iq lw b gy ma mb l mc md">df['year'] =  df['date'].year<br/>df['month'] = df['date'].month<br/>df['day']<!-- --> = df['date'].day</span></pre><h2 id="14a2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">聚合/组统计</h2><p id="ec94" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">为了继续检测稀有和常见的值，这对于机器学习预测非常重要，我们可以决定基于静态方法来检测一个值在子组中是稀有还是常见。例如，我们想通过计算每个子类的平均值来了解哪个智能手机品牌用户的通话时间最长。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="bf4d" class="kx ky iq lw b gy ma mb l mc md">temp = df.groupby('smartphone_brand')['call_duration']<br/>       .agg(['mean'])<br/>       .rename({'mean':'call_duration_mean'},axis=1)</span><span id="cede" class="kx ky iq lw b gy me mb l mc md">df = pd.merge(df,temp,on='smartphone_brand',how=’left’)</span></pre><p id="5357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用这种方法，ML 算法将能够辨别哪个呼叫具有与智能手机品牌相关的 call_duration 的非公共值。</p><h2 id="9f33" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">标准化/规范化</h2><p id="72ba" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">规范化有时非常有用。</p><p id="3764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现列自身的规范化:</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="5483" class="kx ky iq lw b gy ma mb l mc md">df[col] = ( df[col]-df[col].mean() ) / df[col].std()</span></pre><p id="d7d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者可以根据另一列对一列进行规范化。例如，如果您创建一个组统计数据(如上所述),表明每周<code class="fe mh mi mj lw b">call_duration</code>的平均值。然后，您可以通过以下方式消除时间依赖性</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="9240" class="kx ky iq lw b gy ma mb l mc md">df[‘call_duration_remove_time’] = df[‘call_duration’] — df[‘call_duration_week_mean’] </span></pre><p id="8621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的变量<code class="fe mh mi mj lw b">call_duration_remove</code>不再随着时间的推移而增加，因为我们已经针对时间的影响对其进行了标准化。</p><h2 id="d5e6" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">Ultime 特色工程技巧</h2><blockquote class="ml mm mn"><p id="3703" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated">每一篇专栏文章都为预处理和模型训练增加了时间计算。我强烈建议测试一个新特性，看看这些特性如何改进(或不改进…)您的评估指标。<strong class="jp ir"> <em class="iq">如果不是这样，你应该删除创建/修改的特征。</em> </strong></p></blockquote></div></div>    
</body>
</html>