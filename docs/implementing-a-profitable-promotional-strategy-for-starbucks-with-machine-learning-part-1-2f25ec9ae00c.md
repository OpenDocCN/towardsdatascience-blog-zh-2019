# 用机器学习实现星巴克的盈利促销策略(上)

> 原文：<https://towardsdatascience.com/implementing-a-profitable-promotional-strategy-for-starbucks-with-machine-learning-part-1-2f25ec9ae00c?source=collection_archive---------11----------------------->

在这个系列中，我们将为星巴克设计一个促销策略，并介绍从数据预处理到建模的整个过程。这是我为 Udacity 数据科学家 Nanodegree Capstone 项目设计的解决方案。

![](img/b7f216b2994797da58853fc3d5a78e71.png)

*在本系列的第一部分，我们将介绍项目介绍、数据集描述、可用促销类型、缺失值输入、数据预处理和探索性数据分析。*

[*链接*](https://medium.com/@joshxinjielee/implementing-a-profitable-promotional-strategy-for-starbucks-with-machine-learning-part-2-8dd82b21577c) *到本文第二部分。*

*本文附带的代码可以在* [*这里*](https://github.com/joshxinjie/Data_Scientist_Nanodegree/tree/master/capstone) *找到。*

# 一.导言

在这一系列文章中，我们将探索星巴克奖励移动应用程序的数据，并利用机器学习来设计促销策略。我们还将浏览整个数据预处理工作流程，并设计一个指标来测试我们的促销策略。

我们希望在本文结尾回答的问题是:

我们能通过采取更具选择性的促销策略来增加星巴克的利润吗？

作为 Udacity 数据科学家 Nanodegree Capstone 项目的一部分，星巴克友好地提供了一个模拟数据集，模拟客户在他们的奖励移动应用程序上的行为。数据集也可以在我的 [GitHub](https://github.com/joshxinjie/Data_Scientist_Nanodegree/tree/master/capstone) 仓库中找到。

情况是这样的:每隔几天，星巴克就会在手机 app 上向顾客发出促销信息。这些可以是折扣优惠、买一送一优惠(BOGO)或信息优惠。

促销通常需要一定的成本。在我们的例子中，买一送一或打折促销会导致公司的“利润损失”，因为公司牺牲了一些利润来给予顾客金钱激励(免费产品或折扣)。

如果顾客已经愿意在没有任何促销的情况下购买星巴克的产品，那么我们应该放弃给这部分顾客任何促销。

此外，还有一群人被称为“睡狗”。“睡狗”是购买你的产品的人，但如果他们被包括在你的营销活动中，他们会停止这样做。

因此，向每个人发送促销信息并不是一个合理的商业策略。理想情况下，我们希望将促销信息发送给那些只有在收到优惠信息时才会购买的人，同时我们也希望避免将促销信息发送给“睡觉的狗”。

我们的目标是制定一个促销策略，该策略可以确定我们应该向哪些人进行促销，以实现公司利润的最大化。

为了帮助我们解决这个问题，我们将利用抬升模型。提升模型允许我们对治疗(在我们的案例中是促销)对客户购买行为的增量影响进行建模。

如果您有兴趣了解关于提升模型的更多信息，请查看这篇[文章](https://medium.com/datadriveninvestor/simple-machine-learning-techniques-to-improve-your-marketing-strategy-demystifying-uplift-models-dc4fb3f927a2)。

虽然提升模型确实非常有益，但它们有时很难实现。值得注意的是，最大的挑战是找到最佳方法来模拟促销对个人反应的增量影响。

尽管如此，这些模型为我们提供了提高促销效果的最佳机会。所以，我们应该试一试！

# 二。资料组

Starbucks 为此项目提供了 3 个数据文件。下面列出了数据文件及其模式:

## 作品集. json

1.  id(字符串)—优惠 id
2.  offer_type (string) —优惠的类型，如 BOGO、折扣、信息
3.  难度(int)——完成报价所需的最低花费
4.  奖励(int) —为完成一项提议而给予的奖励
5.  duration (int) —报价的有效期
6.  渠道(字符串列表)—发送要约的媒介

投资组合数据集包含有关 10 种可通过应用程序获得的促销活动的信息。

有三种主要的促销方式:信息促销、折扣促销和买一送一(BOGO)促销。

在数据集中，术语“优惠类型”用于指代类似促销的集合。例如，它可以指一系列的折扣促销。

我发现这个术语令人困惑，所以我将把类似的促销统称为简单的家庭型优惠。我将使用术语“优惠类型”或“促销类型”来指代 10 种促销类型中的每一种。

信息提供没有附加的金钱奖励。这些促销活动主要是饮料广告。

折扣优惠通常提供少量的金钱奖励，前提是顾客在优惠期限内消费了一定数量的钱。

解锁奖励所需花费的金额将被称为提供的难度。

BOGO 类似于折扣优惠，除了他们提供相当于优惠难度的金钱奖励。

优惠详情可在下面查看:

![](img/45b2628f3fb3ff4d83aca8611ed2c0da.png)

Portfolio dataset with offer id re-encoded

请注意，为了简化工作过程，我将原始报价 id 从它们的原始哈希值重新编码为整数(0–9)。

## profile.json

1.  年龄(整数)—客户的年龄
2.  变成 _ 成员 _ 开(整数)—客户创建应用帐户时的数据
3.  性别(str) —客户的性别
4.  id (str) —客户 id
5.  收入(浮动)—客户的收入

![](img/6e5453ea1a919685d2528307aba64e91.png)

Snapshot of original profile dataset

简档数据集包含关于客户的人口统计信息。

只有 4 个人口统计属性，我们可以工作:年龄，收入，性别和会员开始日期。一部分配置文件数据集有缺失值，这些问题将在本文后面讨论。

## 抄本. json

1.  事件(str) —记录描述(即交易、收到的报价、查看的报价等)
2.  人员(字符串)—客户 id
3.  time (int) —以小时为单位的时间。数据开始于时间 t=0
4.  value(字符串字典)—根据记录，可以是报价 id，也可以是交易金额。

![](img/9322ecff174e8ef229c6a9e63fc5592c.png)

Snapshot of original transcript dataset

副本数据集记录了在应用程序上进行购买的时间戳，以及收到、查看或完成报价的时间戳。

在我们继续之前，有几个关于数据集的细节需要强调。

1.  客户不需要在一次交易中花光所有的钱来激活优惠。只要他们在要约的持续时间内达到要求的金额，无论他们进行了多少次交易，他们都将获得要约的奖励。
2.  即使用户实际上没有查看报价而是花费了所需的金额，报价也可以被记录为已完成。
3.  即使优惠已过期，也可以将优惠记录为已完成。例如，让我们考虑在时间 7 到期的报价。如果客户在稍后的时间(可能是时间 20)花费了所需的金额，该报价仍将被记录为已完成。实际上，这一优惠并未“完成”，客户也不会享受到促销的回报。因此，在处理数据时，我们需要考虑这种情况。
4.  每个报价、人员和时间组合都没有唯一的序列号。这可能会导致关于转录数据集的解释的混乱。例如，客户可能在时间 7 收到 10 美元的 BOGO 折扣，在时间 31 收到另一个相同的报价。该应用然后可以在时间 52 记录要约完成。但是，我们不知道哪个是在时间 52 完成的相关报价，因为问题编号为 3。

![](img/aa450f2a06229b29d8abcc0a322be1b1.png)

An example illustrating problems 3 and 4\. Note the events at time 0, 6, 132\. This offer has a validity of 7 days and should have been expired at time 7\. Nonetheless, it was “completed” 132 days after it was sent.

这些特性意味着，尽管我们应该能够恢复其中的大部分，但重新获得每个报价的确切结果可能是不可能的。

# 三。可用优惠

以下是通过该应用程序提供的优惠:

***优惠 id 号:优惠家庭类型、有效期、难度、奖励***

1.  优惠 id 0:折扣 10/20/5
2.  优惠 id 1:折扣 7/7/3
3.  优惠 id 2:折扣 7/10/2
4.  报价 id 3:信息 4/0/0
5.  优惠 id 4:BOGO 2010 年 10 月 5 日
6.  报价 id 5:信息 3/0/0
7.  报价 id 6: BOGO 7 月 5 日
8.  优惠 id 7:BOGO 2010 年 7 月 10 日
9.  报价 id 8: BOGO 5 月 5 日
10.  优惠 id 9:折扣 10/10/2

我将在整篇文章中使用相同的报价参考系统。

注意:我将使用 Offer id 10 来表示非 Offer 情况。这一点过一会儿就清楚了。

# 四。预测缺失值

大约 12.8%的个人资料数据集包含性别和收入的缺失值。巧合的是，个人要么缺少年龄和收入数据，要么一个都没有。此外，性别和收入信息缺失的个人都有相同的 118 岁。

很可能这些人实际上并没有 118 岁。

![](img/d733df020cd2ba79fdbe7f3f1e59eb95.png)

Distribution of Age. Note the outlier group at age 118.

合理的解释是，在处理缺失的人口统计数据时，118 是应用程序的默认输入年龄。

由于年龄、收入和性别是唯一可用的人口统计数据(除了会员开始日期)，因此解决这些缺失数据非常重要。

一种解决方案是删除丢失数据的个人。然而，这也将意味着丢失很大一部分数据。

由于该群体的规模，这些人可能具有不同的人口统计属性。因此，我决定使用基于机器学习的方法来预测缺失值，而不是用单个值(如平均值)来输入缺失值。

## 特征工程

由于会员开始日期是唯一可以用于我们的机器学习模型的人口统计信息，我希望不同性别、收入水平和年龄组的个人之间存在交易行为的差异。

交易行为的统计数据将在单个基础上进行汇总。对于每个人，我都记录了:

1.  收到的报价数量
2.  成功完成的出价数
3.  已尝试但未完成的聘用数量
4.  成功完成的出价百分比
5.  尝试出价的百分比
6.  报价总支出
7.  为报价进行的交易总数
8.  报价的平均每笔交易支出

这些数字是在累积的基础上(所有报价加无报价)、每种报价类型(id0–9 加 id 10 代表无报价)和每种报价系列类型(BOGO、折扣、信息)汇总的。

*注:成功/尝试报价的定义可在第五节定义成功/尝试/失败报价小节中找到。数据预处理:生成月度数据*

还计算了其他比率，例如:

1.  优惠类型和优惠系列类型的支出占总支出的比率
2.  优惠类型和优惠系列类型的交易数量占交易总数的比率
3.  收到的优惠类型和优惠系列类型的数量与收到的优惠总数的比率

由于创建了大量的特性，所以我不会在本文中一一列出。要了解更多细节，请参考我的 [GitHub](https://github.com/joshxinjie/Data_Scientist_Nanodegree/tree/master/capstone) 存储库中的文件 *input_missing_data.ipynb* 中的代码。

任何空值都将被替换为 0，因为空值通常表示没有收到/查看/完成报价或没有支出。

为了区分 1)收到一份工作邀请但没有回应的情况和 2)根本没有收到工作邀请的情况，跟踪了每个人收到的工作邀请的数量。

模型的输入特征将是新设计的特征和成员资格开始日期。

由于特征的高度稀疏性，很大程度上由于低完成率和报价的低支出，对这些输入特征进行了降维。

为了防止具有较大值的特征支配其他特征，对特征进行了归一化。标准缩放用于将这些特征减少到平均值 0 和标准偏差 1。

## 模型

创建了 3 个独立的模型，每个模型对应一个缺失的属性:年龄、收入和性别。没有缺失值的概况数据集部分将用于训练模型(约占概况数据的 87.2%)。

年龄和收入模型都是回归问题，而性别模型是多类分类问题。在网格搜索过程中使用具有 5 个折叠的 k 折叠交叉验证来优化模型。

XGBRegressor 和 XGBClassifier 分别是为回归和分类任务选择的模型。这些是相对快速和准确的基于树的非线性模型。

这些模型唯一的主要缺点是它们不能天生地提取特征交互。

例如，如果我们的数据集只跟踪每种优惠类型的总支出(例如，BOGO 5/5/5 为 10 美元，BOGO 7/10/10 为 30 美元，等等。)，但并非针对每种家庭类型(例如，所有 BOGO 优惠均为 40 美元)，XGBoost 模型将仅基于每种优惠类型的支出做出建模决策。它无法提取任何关于 BOGO 优惠等级总支出的信息，也无法在建模过程中使用这些信息。

因此，如果我们想要我们的模型利用它们，我们将需要手工设计这些特性交互。

## 韵律学

均方根误差(RMSE)被选为年龄和收入模型的优化指标，因为我想优先考虑预测的准确性。

请注意，最小化 RMSE 等同于最小化均方误差(MSE)，因为 RMSE 是 MSE 的平方根(线性变换)。

RMSE 是这样计算的:

![](img/d08780a38f1e0250b815318415b668c3.png)

In our case, Pi is the predicted age/gender and Oi is the actual age/gender for each sample i.

另一方面，微观平均 F1 分数被用作性别模型的优化指标。微观平均 F1 分数将按以下方式计算:

![](img/84b6974143d687ad7f8d4c791391d5c9.png)

在哪里

*   TP —真阳性。预测属于性别 *g* ，实际属于性别 *g* 的样本数。
*   FP —误报。预测属于性别 *g* 但实际不属于性别 *g* 的样本数。
*   TN——真正的否定。预测不属于性别 *g* ，实际不属于性别 *g* 的样本数。
*   FN —假阴性。预测不属于性别 *g* 但实际属于性别 *g* 的样本数。

f、M、O 分别代表“女性”、“男性”和“其他”性别。

## 结果

预测个人年龄的模型实现了大约 16.5 的 RMSE，而预测个人收入的模型实现了大约 13，500 的 RMSE。这些数字意味着，平均而言，年龄预测误差 16.5 岁，而收入预测误差 13500 美元。

另一方面，在性别预测模型的测试集上记录了 0.6 的 F1 分数(1 是最佳可能模型的分数)。一个有趣的观察是，性别的预测值似乎由男性主导。如果时间允许，可以进行更多的调查，以查明为什么会出现这种情况。

这些模型指标远非理想。然而，考虑到可用的信息量有限，这些结果是可以接受的。尽管如此，这些估算的数字应该比用常数填充缺失值的替代方法更好地为我们服务。

![](img/f8565051ac17b1ffbc511671b45b4a77.png)

Left: Original Distribution of Age, Middle: Distribution of Predicted Age for Missing Data, Right: Final Combined Distribution of Age

![](img/93595545da01c26ff9bbfc0075796dc0.png)

Left: Original Distribution of Income, Middle: Distribution of Predicted Income for Missing Data, Right: Final Combined Distribution of Income

![](img/478bbb59d060df501092649332e866d7.png)

Left: Original Distribution of Gender, Middle: Distribution of Predicted Gender for Missing Data, Right: Final Combined Distribution of Gender

# 动词 （verb 的缩写）数据预处理:生成每月数据

为了将数据集转换成有用的东西，我们必须执行大量的数据清理和预处理。

在本节的最后，我们将生成一个数据集，如下所示:

![](img/25f8ea49cd163693d694cbbadf96ae44.png)

Snapshot of Monthly Data After Data Preprocessing

主要任务是确定与没有收到报价相比，收到报价时可能会花更多钱的人。因此，我们需要一个数据集来反映用户在促销和非促销情况下的反应。

我们还对顾客的行为是否会随着时间的推移而改变感兴趣。

因此，我选择每月汇总客户的反馈。由于没有给出实际的日期，我将估计一个月为 30 天，并将第 0 天视为第 0 个月的开始。

从上面的快照中，我们知道“人员 id 2”在第 0 个月收到了促销“优惠 id 2”。这个人在这个月里没有在这个提议上花任何钱。同样，“人物标识 2”也没有在非促销场合花任何钱。

请注意，为简单起见，我将使用“优惠 id 10”来表示非促销支出。

每个月，数据集应该跟踪:

1.  如果客户收到优惠，他们在优惠有效期内消费了多少。如果他们不花钱，这个数字可能是 0。
2.  顾客在没有优惠的时候花了多少钱。如果他们不花钱，这个数字也可能是 0。

对随机选择的个人交易的检查表明，客户通常一个月不会收到超过 1 个报价。因此，与每月的促销日相比，消费者暴露于更多的非促销日。

每月汇总数据比每天/每周汇总数据更受欢迎，因为大多数客户每隔几个月就会收到一次报价。如果每天/每周汇总数据，将会有太多天/周没有任何促销活动。

我现在将讨论生成每月数据集的过程。这是一个冗长的讨论，最好遵循代码。因此，如果您想跳过这一部分，请继续阅读第六部分。本页末尾附近的“探索性数据分析”。

## 定义成功/尝试/失败的报价

在我们跟踪顾客在促销有效期内花了多少钱之前，我们需要根据可能的结果对优惠进行分类。有三种可能性:成功、尝试和失败。

要将要约归类为成功，必须在要约到期前收到、查看并完成要约。这意味着客户知道促销活动，并因此进行交易。

如果客户在查看报价之前完成了报价，则报价不会被分类为成功，因为客户在进行交易时不受报价的影响。

如果顾客在查看报价之前进行了一些交易，但是没有花足够的钱来完成报价。如果他/她在要约仍然有效时查看了要约，并在要约到期前花了更多的钱来完成要约，那么要约也将被归类为成功。

因此，成功报价的事件流程是:

*   已收到报价-> *可选:已成交* - >已查看报价- >已成交- >已完成报价- >已到期报价

“尝试过的优惠”是指顾客在优惠到期前查看了优惠，花了一些钱，但没有完成它。因此，客户没有花足够的钱来完成要约的要求。

由于信息性要约没有要约完成事件，如果客户在要约有效期内查看了要约并花费了一些钱，则它们将被视为尝试性要约。

尝试报价的事件流程如下:

*   报价已收到-> *可选:成交- >* 报价已查看- >成交- >报价已到期- > *可选:报价已完成*

失败的报价将不属于前面提到的两个类别。

例如，如果收到并查看了要约，但在要约到期之前没有进行交易，则该要约将是失败的要约。

如果要约在到期前收到但未被查看，也将被归类为失败的要约，即使在要约的有效期内花了钱。这是因为顾客在消费时不受优惠的影响。

跟踪促销期间花费的金额相当于找到成功和尝试过的优惠花费的金额。

## 分割抄本数据集

预处理的第一步包括将原始转录物分成 4 个更小的子集:

1.  *抄本 _ 报价 _ 已收*:跟踪客户何时收到报价以及他们收到了何种报价
2.  *文字记录 _ 报价 _* 已查看:跟踪客户查看报价的时间以及他们查看的报价类型
3.  *抄本 _ 报价 _ 已完成*:跟踪客户何时完成报价以及他们完成了何种报价
4.  *transcript_trans* :跟踪客户进行的所有交易

## 生成带标签的月度交易数据

首先，我们将确定成功或尝试过的产品。我们首先将*抄本 _ 报价 _ 接收、抄本 _ 报价 _ 查看*和*抄本 _ 报价 _ 完成*合并在一起*。*生成的数据帧将如下所示。

![](img/7e897a8774b95eeda9124a0581c1f459.png)

在这个阶段，合并过程中产生的许多报价将是无意义的。

我们可以通过保留符合以下条件的产品来消除大量虚假产品:

1.  完成的报价时间>查看的报价时间>收到的报价时间
2.  (查看的报价时间>收到的报价时间)和(完成的报价时间为空)
3.  查看的时间报价和完成的时间报价均为空

现阶段虚假要约依然存在，需要进一步处理。

我们可以通过将要约的持续时间与要约的接收时间相加来计算所有要约的到期时间。

接下来，我们可以将这些提议分为可能的结果:成功、尝试或失败/错误。请注意，在这个阶段的分类并不一定意味着要约是真正成功的或尝试。我们稍后将需要交易信息来找出答案。

满足以下条件的报价将被归类为可能成功的报价:

1.  (收到的优惠时间≤查看的优惠时间)和(查看的优惠时间≤完成的优惠时间)以及(完成的优惠时间≤优惠到期时间)

满足以下条件的要约被归类为可能尝试的要约:

1.  (收到报价时间≤查看报价时间)和(查看报价时间≤报价到期时间)以及(报价到期时间
2.  (收到的时间报价≤查看的时间报价)和(查看的时间报价≤时间报价到期)以及完成的时间报价为空

不满足这些条件的其余提议或者是失败的或者是错误的提议，并且将被丢弃。

除了第一次出现的情况之外，任何具有重复的“接收时间”、“人员标识”和“报价标识”值的报价都将被删除。一个人不太可能一次收到同一种聘用不止一次，这些重复的条目是在合并过程中生成的错误条目。

我们将调用结果数据帧*succ _ tryed _ offers*。

![](img/718964ede2d6ed93646ccd153e3691e2.png)

A snapshot of succ_tried_offers at this stage of processing

接下来，我们可以将*的抄本 _ 交易*与*的成功 _ 尝试 _ 报价*合并，以获得成功/尝试报价和交易之间所有可能的交叉积。

我们可以标记每笔交易，看看它们是否发生在报价有效期内。换句话说，我们将检查消费是否发生在收到报价之后和报价过期之前。

![](img/de48e97c142378aee999429331a4b239.png)

在有效期内发生交易的*succ _ tryed _ offers*中的任何报价都可能是实际成功或已尝试的报价。

然后，我们可以将带标签的事务执行左合并，返回到原始的事务副本，以避免任何潜在的事务重复计算。这也将使我们能够确定哪些交易发生在非促销期间。

![](img/70ecb28b48e1c01d8499504a7b6b3f07.png)

The labelled transactions

接下来，我们可以分配交易发生的月份，并根据月份号、人员 id 和优惠 id 聚合数据。这将每月生成一份客户在促销和非促销期间消费金额的汇总。我们将该数据帧称为*月度交易*。

![](img/941053c3b12248d8c9b4113c12cce416.png)

A snapshot of monthly_transactions

## 寻找没有每月交易的优惠

从*succ _ tryed _ offers*中，我们知道哪些报价是成功的或尝试过的。

![](img/96340907a5a4482f7e529b0f188582b0.png)

Offers that were successful or tried

我们可以从*抄本 _received 中获得星巴克发出的所有报价的列表。*

![](img/152df4effb3d54ed0944db2d9e357d11.png)

Snapshot of all offers sent

两者之间的差异可以告诉我们哪些提议失败了。这些要约在有效期内没有引发任何货币交易。

接下来，我们可以指定收到这些失败报价的月份号，并将结果数据帧命名为 *monthly_failed_offers。*

![](img/e8ecec191bdc7941337ba9aa78258291.png)

Snapshot of *monthly_failed_offers*

## 找出个人没有进行非要约交易的月份

请注意 *monthly_transactions* 已经跟踪了客户在非促销期间的花费。我们的目标是找出哪些月份的顾客在非促销期间没有花钱。

首先，我们生成月份号、人员 id 和报价 id 10(非促销曝光)的所有可能组合。我们把这个数据帧称为 *non_offer_trans* 。

然后，我们可以将 *monthly_transactions* 数据框架合并到 *non_offer_trans* 中，以找出哪些月份-个人组合在非促销期间没有货币交易。

因此，我们将获得客户在非促销情况下不花钱的月度账户。我们姑且称这个数据帧 *no_offer_no_trans* 。

![](img/6883b0fc3a150bed6c14a0fb3bb916c0.png)

Snapshot of no_offer_no_trans

## 将它们聚集在一起

最后，我们可以将 *monthly_transactions* 、 *monthly_failed_offers* 和 *no_offer_no_trans* 串联在一起*，生成 *monthly_data* 。*产生的数据集每月追踪每个人在发送给他们的不同促销活动上花了多少钱，以及他们花了多少非促销费用。

![](img/d170fac52ca9554bf6d7c0de1b1e7a76.png)

Snapshot of monthly data at this stage

## 计算利润并生成标签

接下来，我们必须计算数据集的每个实例产生的利润。我们首先需要计算每个人每月收到的报价数量。这使我们能够计算与报价相关的成本。

一个简单的方法是检查个人是否在一个月内接触到每种类型的一个以上的报价。通过检查*抄本 _ 已接收*，我们注意到以下内容:

1.  没有人在同一个月内多次收到相同的报价类型。
2.  如果个人收到下个月到期的要约，他/她在下个月将不会收到类似的要约。例如，如果个人在第 16 个月收到“要约 id 2 ”,而要约在第 17 个月到期。他/她不会在第 17 个月收到另一个“要约 id 2”。

因此，我们可以得出结论，客户每月最多只能接触到一次优惠类型。

这意味着 *monthly_data* 中的成本只是完成促销的奖励。

我们可以通过以下 3 条规则来计算每个人每个月为每种优惠类型创造的利润:

1.  如果要约成功，利润将是每月收入减去要约的成本。请注意，提供信息是没有成本的。
2.  如果要约不成功，利润将是在该实例中产生的收入。
3.  如果交易不是要约的一部分，利润就是收入，因为不涉及成本。

我们将使用的提升模型涉及在两种情况下对给定人员和月份的利润概率进行建模:

1.  如果这个人收到一份工作邀请。
2.  如果这个人没有收到聘书。

因为我们想要预测利润的概率，我们的标签( *has_profit)* 将只是一个指示变量，指示该实例是否有利润。

![](img/25f8ea49cd163693d694cbbadf96ae44.png)

Resulting monthly_data obtained at the end of the process

# 不及物动词探索性数据分析

## 大多数优惠都没有被顾客尝试过

![](img/6fe7a66f033279fb913e3d2dbb74a009.png)

从上面的图表中，我们注意到绝大多数的优惠都没有被顾客尝试过。

一个普遍的观察是，具有更长有效期、更高回报和更低难度的报价往往具有更高的成功/尝试率。

请注意，信息性报价无法完成，因为它们缺乏难度。因此，他们要么尝试或失败。

## 只有少数客户成功完成或尝试了一次以上的优惠

![](img/b6a2c8a6299e60adb392b9faf2d9b368.png)

在研究期间，大多数客户收到了 3 到 6 份报价。

![](img/e942d3ac2effd6c8754f7e46e039265d.png)

然而，绝大多数客户没有成功完成任何优惠。他们中只有一小部分人完成了 1 次报价，更少的人完成了 2 次或更多次报价。

![](img/bb0c58190a49c9c6258371c77bf1ae16.png)

对于尝试过(但未成功完成)的要约也是如此。面对优惠，很少有顾客做出反应(花钱)。对两个或两个以上的提议做出回应的情况极为罕见。

总的来说，优惠似乎效力有限。

## 月度利润趋势

左边的图表显示了每月获得晋升的人数。此外，图表将显示这些人中有多少人每月产生促销利润和非促销利润。盈利实例也可以定义为来自 *monthly_data* 数据集的数据点，其 *has_profit* 标签为 1。

右边的图表显示了接受促销的个人每月产生的总利润，以及他们的促销和非促销支出的总利润。

从这些图表中，我们可以衡量促销的有效性，并评估这些促销的有效性是否随时间而变化。

**折扣 10/20/5(优惠 ID 0)**

![](img/395c7ebe9a9506ee274bb4829e4a5737.png)![](img/9bcc150fa55f40d5f5c750e5c90c1cf1.png)

Plotted from individuals who received Discount 10/20/5 offers each month

**折扣 7/7/3(优惠 ID 1)**

![](img/bfd8219b698cfc2c26f0fc69f7ac3058.png)![](img/482fe431d626de1b9cfedfd3200a5d4e.png)

Plotted from individuals who received Discount 7/7/3 offers each month

**折扣 7/10/2(优惠 ID 2)**

![](img/4ad9ef84471c874b2204e4bbb281cba2.png)![](img/d03ef833ebb67794d0742ed1b3b754ca.png)

Plotted from individuals who received Discount 7/10/2 offers each month

**信息 4/0/0(报价 ID 3)**

![](img/3d95bd7eafd44060994907818ad68845.png)![](img/632ce69af4bed4459aaee9b44361e0cc.png)

Plotted from individuals who received Informational 4/0/0 offers each month

**BOGO 2010 年 5 月 10 日(报价 ID 4)**

![](img/9bf27e6ee6144156e7e47eddf32b52e2.png)![](img/c60d2d62aa3a1176bc26a3a3d52c4199.png)

Plotted from individuals who received BOGO 5/10/10 offers each month

**信息 3/0/0(报价 ID 5)**

![](img/a2715416b178a33a34b1d0fb585b7b5e.png)![](img/173ffc509db5d9461f5f5c56ad082f86.png)

Plotted from individuals who received Informational 3/0/0 offers each month

**BOGO 5 月 7 日(报价 ID 6)**

![](img/a2348560d3bb6daa856b1f8aeb27ae53.png)![](img/85f2f9d05fd7329037b5749b198ebba6.png)

Plotted from individuals who received BOGO 7/5/5 offers each month

**BOGO 2010 年 7 月 10 日(报价 ID 7)**

![](img/f67a2def9267f342299b38628d928198.png)![](img/3bbfb1158b682c24e7457ba2e17af05b.png)

Plotted from individuals who received BOGO 7/10/10 offers each month

**BOGO 5/5/5(报价 ID 8)**

![](img/20931b89629403dcf2c195e2333ccc18.png)![](img/af9e8bcefaa50baca664c23579816b42.png)

Plotted from individuals who received BOGO 5/5/5 offers each month

**折扣 10/10/2(优惠 ID 9)**

![](img/bf448290fbd653aead0cdb7efd7061ae.png)![](img/bc2473944acc40b85455a1bf7a3700f6.png)

Plotted from individuals who received Discount 10/10/2 offers each month

一个反复出现的观察结果是，在每月接受促销的人中，他们更有可能在没有任何促销活动的日子里购物，而不是在有促销活动的日子里。因此，非促销利润实例的数量通常超过促销利润实例的数量。

在促销和非促销期间产生的利润总额中也观察到类似的情况，非促销利润经常超过促销利润。

当然，一个人接受要约的天数通常低于一个人没有接受任何要约的天数。

每个月，个人受要约影响的天数受到要约有效期的限制，该有效期可以是 3 至 10 天。请注意，没有人在一个月内收到相同的报价超过一次。

然而，即使我们考虑了暴露期之间的差异，在大多数情况下，非促销利润仍然会超过促销利润。

因此，这表明促销在诱导顾客比平时多花钱方面的效果有限。

如果顾客普遍愿意购买星巴克的产品，而没有得到任何促销，那么发送更多的促销信息将不符合星巴克的最佳利益，因为这样做可能会由于促销成本而侵蚀公司的盈利能力。

我们的希望是，我们将能够识别出那些只有在获得促销时才消费的人。限制向这些人发送促销信息将有助于最小化成本和最大化利润。

在本系列的第 2 部分中，我们将介绍特征工程、提升模型的实现、对模型和数据的额外调整、结果以及项目的结论。[将](https://medium.com/@joshxinjielee/implementing-a-profitable-promotional-strategy-for-starbucks-with-machine-learning-part-2-8dd82b21577c)链接到文章的第 2 部分。

*本文附带的代码可以在这里*[](https://github.com/joshxinjie/Data_Scientist_Nanodegree/tree/master/capstone)**找到。**