<html>
<head>
<title>Going Serverless with OpenFaaS and Golang — The Ultimate Setup and Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OpenFaaS 和 Golang 实现无服务器——终极设置和工作流程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/going-serverless-with-openfaas-and-golang-the-ultimate-setup-and-workflow-52a4a85a7951?source=collection_archive---------20-----------------------#2019-11-16">https://towardsdatascience.com/going-serverless-with-openfaas-and-golang-the-ultimate-setup-and-workflow-52a4a85a7951?source=collection_archive---------20-----------------------#2019-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7e89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:此文最初发布于</em><a class="ae kp" href="https://martinheinz.dev/blog/10" rel="noopener ugc nofollow" target="_blank"><em class="ko">martinheinz . dev</em></a></p><p id="f319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无服务器应用已经流行了一段时间，一些有趣且有用的平台/工具/框架正在出现。其中之一是<em class="ko"> OpenFaaS </em>，它是开源<em class="ko">功能的服务</em>工具，用于开发<em class="ko">云原生无服务器应用</em>。</p><p id="6ff4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇博文中，我想向你展示如何设置(IMHO)开发<em class="ko"> OpenFaaS </em>函数的理想项目和工作流程，以及如何使用<em class="ko"> Golang </em>创建你的第一个函数。</p><p id="92a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:这篇文章的完整源代码可以在这里找到:</em><a class="ae kp" href="https://github.com/MartinHeinz/openfaas-functions" rel="noopener ugc nofollow" target="_blank">【https://github.com/MartinHeinz/openfaas-functions】T21</a></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/b5fb926c9656f77bc808dec43980b8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*zhzBhv0JZjGYgdch2sX54Q.png"/></div></figure><h1 id="8aeb" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么选择 OpenFaaS</h1><p id="1d4a" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">你可能会问，为什么——在所有像<em class="ko"> AWS Lambda </em>、<em class="ko"> Google Cloud Run </em>、<em class="ko">open whish</em>等框架中。—我会选择<em class="ko"> OpenFaaS </em>吗？嗯，对我来说有几个原因:</p><ul class=""><li id="c0e3" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><strong class="js iu">无供应商锁定</strong> —我选择<em class="ko"> OpenFaaS </em>而不是其他选择的一个重要原因是，我不会被供应商锁定。但是，为什么它如此重要呢？这很重要，因为在某些时候，你可能会决定，你想要转移到其他平台，甚至完全远离<em class="ko">无服务器</em>，这是你无法用像<em class="ko"> AWS Lambda </em>这样的工具真正做到的，这迫使你使用 AWS。</li><li id="5254" class="mb mc it js b jt mk jx ml kb mm kf mn kj mo kn mg mh mi mj bi translated"><strong class="js iu">云原生</strong> —下一个优势是它运行在云环境中，比如<em class="ko"> Kubernetes </em>、<em class="ko"> OpenShift </em>或者<em class="ko"> k3s </em>(在本教程中使用)。我认为这是一个优势，因为现在构建小型<em class="ko"> Kubernetes </em>集群非常便宜、快速和简单，在其中部署 OpenFaaS 也很简单，正如您将在下面看到的。</li><li id="5ffd" class="mb mc it js b jt mk jx ml kb mm kf mn kj mo kn mg mh mi mj bi translated"><strong class="js iu">任何语言</strong> — <em class="ko"> OpenFaaS </em>都能够使用任何运行时，这要归功于所有函数都在<em class="ko"> Docker </em>容器中运行这一事实。您甚至可以构建自己的模板，并以此为基础构建您的函数。</li><li id="e2f6" class="mb mc it js b jt mk jx ml kb mm kf mn kj mo kn mg mh mi mj bi translated"><strong class="js iu">性能</strong>—<em class="ko">open FAAS</em>的另一个好处是它的性能，更具体地说——或者换句话说——空闲时将 pods 扩展到零的能力，以及具有更低延迟、缓存和持久连接的<a class="ae kp" href="https://github.com/openfaas-incubator/of-watchdog" rel="noopener ugc nofollow" target="_blank">基于 HTTP(beta)的模板</a>(你将在下一篇博客文章中看到)。</li></ul><h1 id="343e" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安装</h1><p id="ab6c" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">要开始构建一些很酷的功能，我们首先需要安装一些工具。以下是它们的列表和说明:</p><ul class=""><li id="cfe5" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><em class="ko"> k3s </em> —为了运行这些功能，我们需要一个云环境，并且考虑到我们将使用本地机器，我们应该尽可能选择最轻量级的选项，这里我将使用<em class="ko"> Ranchers k3s </em>(或者您也可以使用<em class="ko">类</em>)。要安装，请使用以下命令:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><ul class=""><li id="f636" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><em class="ko"> OpenFaaS </em> —如前所述，<em class="ko"> OpenFaaS </em>是一个云原生平台，所以我们需要把它放到我们的云环境中(<em class="ko"> k3s </em>):</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><ul class=""><li id="f3f2" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated">为了能够与部署的 OpenFaaS 进行交互，我们还需要它的 CLI:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><ul class=""><li id="e42b" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated"><em class="ko">任务文件</em>——最后，我们的设置使用<em class="ko">任务文件</em>——代替<em class="ko">Make</em>——来自动化常见任务。要安装它，您需要运行:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="4fbe" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第一功能</h1><p id="0469" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">现在我们已经准备好了所有的工具，让我们构建我们的第一个<em class="ko"> OpenFaaS </em>函数。在我们实际进行任何编码之前，我们需要提取模板，在此基础上我们将构建函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6935" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面，我们可以看到我们感兴趣的一个模板——<code class="fe mr ms mt mu b">go</code>模板。让我们用它来创建函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1cbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从输出中，我们可以看到创建了哪些文件— <code class="fe mr ms mt mu b">handler.go</code>和<code class="fe mr ms mt mu b">first-func.yml</code>。第一个包含负责处理传入请求的函数，另一个是描述函数的<em class="ko"> YAML </em>堆栈文件——它包含像图像名称、处理程序路径、语言等信息。也有更多的值可以指定，你可以在这里找到<a class="ae kp" href="https://docs.openfaas.com/reference/yaml/" rel="noopener ugc nofollow" target="_blank"/>。你可能注意到我们还指定了<code class="fe mr ms mt mu b">prefix</code>标志——我们需要它，以便能够将我们构建的函数的映像推送到远程存储库，在本例中是<em class="ko"> Docker Hub </em>并且<code class="fe mr ms mt mu b">prefix</code>是<em class="ko"> Docker Hub </em>用户名。当我们部署该功能时，OpenFaaS 将使用远程注册表中的这个映像。</p><p id="cbf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将把摆弄代码和实现酷功能的工作留给你，我将只构建、推送和部署<em class="ko"> Hello World </em>函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="491e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样，我们在<em class="ko"> k3s </em>上的<em class="ko"> OpenFaaS </em>中运行我们的函数。我们可以在 UI 和命令行中查看它。对于 UI 视图，您可以导航到<code class="fe mr ms mt mu b">OPENFAAS_URL</code>(应该是<a class="ae kp" href="http://127.0.0.1:31112" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:31112 </a>)，对于 shell，您可以运行以下命令来显示和调用该函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="02c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为，这很简单，我们可以在此基础上进行构建。在下一篇博文中，我们将探讨如何利用更新的(beta) <code class="fe mr ms mt mu b">of-watchdog</code>模板，以及如何使用<em class="ko"> Go </em>模块构建我们自己的模板库，包括我们的优化模板。你可以在我的模板库<a class="ae kp" href="https://github.com/MartinHeinz/openfaas-templates" rel="noopener ugc nofollow" target="_blank">这里</a>先睹为快。</p><h1 id="9bfe" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">单元测试</h1><p id="90a7" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">看起来我们已经完成了，但是我们还缺少一样东西——单元测试。</p><p id="4903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要编写我们的单元测试，我们只需在<code class="fe mr ms mt mu b">handler.go</code>旁边创建<code class="fe mr ms mt mu b">handler_test.go</code>文件，并将这个测试放在那里:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9bbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经注意到，<code class="fe mr ms mt mu b">go test</code>命令是在<em class="ko"> Docker </em>构建过程中运行的，所以我们运行测试所需要的只是像以前一样构建函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="439b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能认为测试像这种<em class="ko">无服务器</em>功能的小代码片段是多余的，但是你不应该仅仅因为代码简单或简短就忽视测试，如果可能的话，一切都应该被测试。</p><h1 id="5b1a" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">通过任务文件变得简单</h1><p id="67f1" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在这篇文章的开始，我要求您安装<em class="ko">任务文件</em>，但是我们实际上还没有使用它，所以让我们改变它，使工作流更简单，并使用我已经为您创建的<em class="ko">任务文件</em>目标来创建、构建、部署或调试功能:</p><p id="3cf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步—使用某个模板创建具有指定名称的函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="afab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该任务在后台为您下载模板，创建函数，然后将文件添加到 git staging 区域。</p><p id="b4e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们来构建它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7471" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没什么特别的，它只是构建函数，但是您也可以继续，在一个命令中构建、推送和部署函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0bcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了检查一切是否按预期工作，让我们检查日志:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1fb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将给出 Kubernetes 部署对象的描述以及如下所示的功能日志:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果日志还不够，您可以使用以下命令调试该函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3f10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在<em class="ko"> Docker </em>中本地运行该功能，并将终端连接到<code class="fe mr ms mt mu b">watchdog</code>进程日志。现在，这个函数已经在您的机器上运行了，您可以使用<code class="fe mr ms mt mu b">cURL</code>来调用它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="763f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要查看<code class="fe mr ms mt mu b">Taskfile.yml</code>中发生的事情或查看更详细的文档，请查看我的知识库中的<code class="fe mr ms mt mu b">Taskfile.yml</code><a class="ae kp" href="https://github.com/MartinHeinz/openfaas-functions/blob/master/Taskfile.yml" rel="noopener ugc nofollow" target="_blank">这里的</a>和<code class="fe mr ms mt mu b">README.md</code> <a class="ae kp" href="https://github.com/MartinHeinz/openfaas-functions/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="1d53" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最简单的 CI/CD</h1><p id="426e" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">我们需要设置的最后一件事是 CI/CD 管道，我们可以使用最后一个<em class="ko">任务文件</em>目标来完成，我在上一节中省略了这个目标——<code class="fe mr ms mt mu b">task verify</code>——这个命令下载<code class="fe mr ms mt mu b">faas-cli</code>(如果机器上没有的话)，并使用存储在<code class="fe mr ms mt mu b">functions</code>目录中的<em class="ko"> YAMLs </em>在存储库中构建每个函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6fd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获得完整的代码清单，请查看存储库中的文件，特别是这里的<code class="fe mr ms mt mu b">.travis.yml</code> <a class="ae kp" href="https://github.com/MartinHeinz/openfaas-functions/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank">和这里的<code class="fe mr ms mt mu b">verify.sh</code></a><a class="ae kp" href="https://github.com/MartinHeinz/openfaas-functions/blob/master/verify.sh" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="bd69" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="59de" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">正如你从这篇文章中看到的，开始开发<em class="ko">无服务器</em>应用程序真的很容易，考虑到<em class="ko">无服务器</em>不再只是炒作，这些技术已经相当成熟，我希望你能尝试一下。如果你想从这篇文章中看到更多的细节和完整的源代码，请查看我的知识库<a class="ae kp" href="https://github.com/MartinHeinz/openfaas-functions" rel="noopener ugc nofollow" target="_blank">这里</a>，如果你有一些建议/改进/问题，请随时提交问题或开始讨论。🙂</p><p id="e8af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述——在下一篇博文中，我们将看看如何建立自己的模板库，创建自定义模板，并使用它来创建更好的功能。</p></div></div>    
</body>
</html>