<html>
<head>
<title>Proximal Policy Optimization Tutorial (Part 2/2: GAE and PPO loss)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">近似政策优化教程(第二部分:GAE 和 PPO 损失)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/proximal-policy-optimization-tutorial-part-2-2-gae-and-ppo-loss-fe1b3c5549e8?source=collection_archive---------5-----------------------#2019-08-12">https://towardsdatascience.com/proximal-policy-optimization-tutorial-part-2-2-gae-and-ppo-loss-fe1b3c5549e8?source=collection_archive---------5-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="07d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们从头开始编写一个 RL 足球代理！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6d2afb99c546e29ae5dcec92b9f4ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Yoj9fGhks_Xz43JdMTmDJQ.gif"/></div></div></figure><blockquote class="ku kv kw"><p id="ed3b" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">第一部分链接:</strong> <a class="ae lu" rel="noopener" target="_blank" href="/proximal-policy-optimization-tutorial-part-1-actor-critic-method-d53f9afffbf6">近端政策优化教程(第一部分:演员-评论家法)</a></p></blockquote><p id="9a01" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">欢迎来到强化学习数学和代码教程系列的第二部分。在本系列的第一部分<a class="ae lu" rel="noopener" target="_blank" href="/proximal-policy-optimization-tutorial-part-1-actor-critic-method-d53f9afffbf6">中，我们看到了如何设置谷歌足球环境，然后实现了一个演员-评论家模型框架来与这个游戏环境进行交互并从中收集示例体验。</a></p><p id="d5a0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">今天，我们将通过使用该批示例体验来训练我们的模型在游戏中得分，从而完成教程的剩余部分。关于我们上次实施的<a class="ae lu" href="https://gist.github.com/ChintanTrivedi/665dd40d21227fbf6ac646c99cb8976d#file-train-py" rel="noopener ugc nofollow" target="_blank">代码</a>,回想一下到目前为止我们已经收集了以下信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/98865938fdfd289fef1b345c3246575f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MztEbI2UJK1vO5L2HIKjeA.png"/></div></div></figure><p id="1cc6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">利用这些信息，我们现在可以继续计算优势。</p><h1 id="b583" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">广义优势估计(GAE)</h1><p id="9e86" class="pw-post-body-paragraph kx ky it la b lb mr ju ld le ms jx lg lv mt lj lk lw mu ln lo lx mv lr ls lt im bi translated">优势可以被定义为当我们处于特定的状态时，通过采取特定的行动来衡量我们可以变得多好的一种方式。我们希望使用我们在每个时间步骤收集的奖励，并计算通过采取我们所采取的行动我们能够获得多少优势。因此，如果我们采取了一个好的行动，比如朝着一个目标射击，我们想要计算我们通过采取那个行动，不仅在短期内，而且在更长的一段时间内，有多好。这样，即使我们没有在射门后的下一个时间步立即进球，我们仍然会在那个动作后的几个时间步看更长的未来，看看我们是否进球了。</p><p id="17f6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">为了计算这一点，我们将使用一种称为<em class="kz">广义优势估计</em>或<em class="kz"> GAE </em>的算法。所以让我们用我们收集的那批经验来看看这个算法是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/1eda746c84139157a0308f8d8c412193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kblzxnv17WBFetf8ID4DnQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Generalized Advantage Estimation Algorithm</figcaption></figure><ul class=""><li id="35cd" class="nb nc it la b lb lc le lf lv nd lw ne lx nf lt ng nh ni nj bi translated">这里，使用掩码值<code class="fe nk nl nm nn b"><em class="kz">m</em></code>,因为如果游戏结束，那么我们批次中的下一个状态将来自新重启的游戏，所以我们不想考虑它，因此掩码值取为 0。</li><li id="95b5" class="nb nc it la b lb no le np lv nq lw nr lx ns lt ng nh ni nj bi translated">Gamma <code class="fe nk nl nm nn b"><em class="kz">γ</em></code>只不过是一个常数，称为<em class="kz">折扣因子</em>，目的是减少未来状态的值，因为我们希望更多地强调当前状态而不是未来状态。考虑到这一点，现在进球比将来进球更有价值，因此我们不考虑将来的目标，这样我们可以给现在的目标更多的价值。</li><li id="4cf9" class="nb nc it la b lb no le np lv nq lw nr lx ns lt ng nh ni nj bi translated">λ<code class="fe nk nl nm nn b">λ</code><em class="kz"/>是平滑参数，用于减少训练中的方差，使其更加稳定。该论文中建议的该平滑参数的值是 0.95。因此，这给了我们在短期和长期采取行动的优势。</li><li id="6b7a" class="nb nc it la b lb no le np lv nq lw nr lx ns lt ng nh ni nj bi translated">在最后一步中，我们简单地反转返回列表，因为我们从最后一个时间步骤循环到第一个时间步骤，所以我们获得了原始订单。</li></ul><p id="7532" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这基本上是 GAE 算法，可以在我们的代码中实现，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a139" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">下面的视频是对这个算法的逐行解释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nu l"/></div></figure><p id="c8ba" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们现在有了训练演员和评论家模特所需的一切。因此，我们将了解如何使用这些信息来计算自定义 PPO 损失，并使用该损失来训练参与者模型。</p><h1 id="37dd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">自定义 PPO 损失</h1><p id="ef3b" class="pw-post-body-paragraph kx ky it la b lb mr ju ld le ms jx lg lv mt lj lk lw mu ln lo lx mv lr ls lt im bi translated">这是近似策略优化算法中最重要的部分。那么我们先来了解一下这个损失函数。</p><p id="9184" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">回想一下<code class="fe nk nl nm nn b"><em class="kz">π</em></code> <strong class="la iu"> </strong>表示由我们的 Actor 神经网络模型定义的策略。通过训练这个模型，我们希望改进这个策略，以便随着时间的推移，它给我们提供越来越好的行动。现在，一些强化学习方法的一个主要问题是，一旦我们的模型采用了一个坏的策略，它只会在游戏中采取坏的行动，因此我们无法从那里产生任何好的行动，从而导致我们在训练中走上不可恢复的道路。PPO 试图通过在更新步骤中只对模型进行小的更新来解决这个问题，从而稳定训练过程。PPO 损失可计算如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/ae684e548ac9cd8c98b7f4a4381eb40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hin-YDbzm2oZx7vt9RAdcQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Custom PPO loss calculation</figcaption></figure><ul class=""><li id="3fd7" class="nb nc it la b lb lc le lf lv nd lw ne lx nf lt ng nh ni nj bi translated">PPO 在更新步骤中使用新更新的策略和旧策略之间的比率。从计算上来说，用对数形式表示更容易。</li><li id="9378" class="nb nc it la b lb no le np lv nq lw nr lx ns lt ng nh ni nj bi translated">利用这个比率，我们可以决定我们愿意容忍多大程度的政策变化。因此，我们使用限幅参数ε<code class="fe nk nl nm nn b"><em class="kz">ε</em></code>来确保我们一次只对我们的策略进行最大限度的<code class="fe nk nl nm nn b"><em class="kz">ε%</em></code>改变。文中建议ε值保持在<code class="fe nk nl nm nn b">0.2</code>。</li><li id="7411" class="nb nc it la b lb no le np lv nq lw nr lx ns lt ng nh ni nj bi translated">批评家损失只不过是收益的平均平方误差损失。</li><li id="521c" class="nb nc it la b lb no le np lv nq lw nr lx ns lt ng nh ni nj bi translated">如果我们想用一个折扣系数使演员和评论家的损失达到相同的数量级，我们可以把他们结合起来。添加熵项是可选的，但它鼓励我们的参与者模型探索不同的政策，并且我们想要实验的程度可以由熵β参数来控制。</li></ul><p id="3726" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这个自定义损失函数可以用 Keras 使用下面的代码来定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d4f3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">下面是这个自定义损失函数在下面嵌入的视频中的逐行解释和实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nu l"/></div></figure><h1 id="61b8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">模型训练和评估</h1><p id="28ec" class="pw-post-body-paragraph kx ky it la b lb mr ju ld le ms jx lg lv mt lj lk lw mu ln lo lx mv lr ls lt im bi translated">现在终于可以开始模特训练了。为此，我们如下使用 Keras 的<code class="fe nk nl nm nn b">fit</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="51b8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">现在，您应该能够在屏幕上看到模型采取不同的行动，并从环境中收集奖励。在训练过程的开始，当随机初始化的模型探索游戏环境时，动作可能看起来相当随机。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c193f287b810aa641b93881b8b8b7c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/1*U-PbfBxKpgr4gpmj59o5Lw.gif"/></div></figure><p id="1585" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">好了，现在让我们实现一些模型评估代码。这将在模型训练期间告诉我们，就成功得分而言，模型的最新更新版本有多好。因此，为了评估这一点，我们将计算平均奖励，定义为从零开始多次玩游戏所获得的所有奖励的平均值。如果我们在 5 场比赛中的 4 场比赛中进球，我们的平均回报将是 80%。这可以如下实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c388" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">一旦模型开始学习哪一组行动产生最好的长期回报，测试阶段将如下所示。在我们的例子中，向右击球被观察到产生了最好的回报，因此我们的演员模型将产生正确的方向和射击动作，作为它的首选输出动作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/32baadf757309e281f6e594a72658fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/1*8N1g9zhfv8BzrTsVdGmy_Q.gif"/></div></figure><p id="8925" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">用于将所有内容联系在一起的其余代码可以在 GitHub 资源库的<code class="fe nk nl nm nn b">train.py</code>脚本中找到。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/ChintanTrivedi/rl-bot-football" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">中国机器人足球</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">此代码实现了近似策略优化(PPO)算法的基本版本，目的是…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div></div></a></div><p id="2ab1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果你想通过逐行解释来学习这个实现，你可以看下面的视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nu l"/></div></figure><h1 id="6ff2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="a4d8" class="pw-post-body-paragraph kx ky it la b lb mr ju ld le ms jx lg lv mt lj lk lw mu ln lo lx mv lr ls lt im bi translated">我希望这篇教程能让你对基本的 PPO 算法有一个很好的了解。现在，您可以通过并行执行多个环境来继续构建，以便收集更多的训练样本，并解决更复杂的游戏场景，如完整的 11 对 11 模式或角球得分。一些有用的参考资料可以对此有所帮助，也是我在本教程中使用的，可以在<a class="ae lu" href="https://www.youtube.com/watch?v=WxQfQW48A4A" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lu" href="https://www.youtube.com/watch?v=5P7I-xPq8u8" rel="noopener ugc nofollow" target="_blank">这里</a>找到。祝你好运！</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><blockquote class="ku kv kw"><p id="9038" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。如果你喜欢这篇文章，你可以关注我在<a class="ae lu" href="https://medium.com/@chintan.t93" rel="noopener">媒体</a>、<a class="ae lu" href="https://github.com/ChintanTrivedi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的更多作品，或者订阅我的<a class="ae lu" href="http://youtube.com/c/DeepGamingAI" rel="noopener ugc nofollow" target="_blank"> YouTube 频道</a>。</p></blockquote></div></div>    
</body>
</html>