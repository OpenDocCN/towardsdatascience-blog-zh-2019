<html>
<head>
<title>Python Module for easy data pre-processing for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 模块，方便初学者进行数据预处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-module-for-easy-data-pre-processing-for-beginners-40f0f6b407a8?source=collection_archive---------21-----------------------#2019-01-31">https://towardsdatascience.com/python-module-for-easy-data-pre-processing-for-beginners-40f0f6b407a8?source=collection_archive---------21-----------------------#2019-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d1b3883ecb67a72d6dd0b4b24a8ac77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mQc7zT2rFscfTHMc"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mika Baumeister</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="33dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构化数据中的特征可以有多种形式，包括连续、分类、日期时间等。通常，为了构建预测模型，我们会查看特征选择或特征工程，以收集更多见解或将更多相关数据输入到模型中。然而，在数据具有大量特征的情况下，特征工程会变得非常快。需要快速处理这些数据，并创建一个初始模型来更好地理解您的数据集或手头的问题。在任何特征工程之前创建模型有以下好处:</p><ol class=""><li id="290e" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">了解所有特性的相对特性和重要性</li><li id="de82" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">大致了解哪些模型可行，哪些不可行</li><li id="9256" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">提供帮助特征工程/特征选择的洞察力</li></ol><p id="654c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank">fast . ai 的程序员机器学习简介</a>使用了这种方法，并实现了杰瑞米·霍华德所说的“机器学习驱动的 EDA”。探索性数据分析是根据模型告诉你的内容进行的，而不是领域知识或预先确定的问题假设。</p><p id="a9c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我用自己编写的 python 模块给出了一个简单的数据预处理实现。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="62d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该模块可以在 https://github.com/Benlau93/easy_processing 的 GitHub 中找到</p><p id="bff3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以下载该模块并将其放在与笔记本相同的目录中，然后使用</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="69a1" class="mi mj it me b gy mk ml l mm mn">import easy_processing as ep</span></pre><p id="5da7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试这个模块，我将在 kaggle 竞赛的两个数据集上使用它。一个是回归问题，另一个是分类任务。两者都使用来自<a class="ae kf" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.ensemble" rel="noopener ugc nofollow" target="_blank"> sklearn.ensemble </a>库中的 RandomForest 模型。</p><p id="45cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，房价:高级回归技术数据集。</p><p id="181a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导入库和数据集</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="34a3" class="mi mj it me b gy mk ml l mm mn">import numpy as np<br/>import pandas as pd</span><span id="1390" class="mi mj it me b gy mo ml l mm mn">df = pd.read_csv("train.csv",low_memory=False)<br/>X = df.drop(["SalePrice"],axis = 1)<br/>y=df["SalePrice"]</span></pre><p id="eee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从处理数据中缺失的值开始。<code class="fe mp mq mr me b">proc_miss</code>将连续变量中的 NaN 替换为相应特征列中非缺失值的中值</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0fec" class="mi mj it me b gy mk ml l mm mn">X, missing_val = ep.proc_miss(X)</span></pre><p id="709d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回的 missing_val 是一个字典，其中包含缺失值的列作为键，中值作为值被替换</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/f0e232bd57f0b420a30157950c34e6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*PcG68wx4CN-l_TcJVU7QiA.png"/></div></figure><p id="89c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了处理分类变量，<code class="fe mp mq mr me b">proc_cat</code>将用户以列表形式给出的分类列转换成 pandas 分类对象。在没有给定<code class="fe mp mq mr me b">cat_cols</code>的情况下，具有“对象”数据类型的列被转换。<code class="fe mp mq mr me b">max_cardi</code>是将被转换为虚拟变量的特征的最大基数。基数只是指每个分类特征中的类的数量。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f611" class="mi mj it me b gy mk ml l mm mn">X, cat_dict = ep.proc_cat(X,max_cardi=5)</span></pre><p id="d3c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回的 cat_dict 是一个字典，其中分类列作为键，Series.cat.categories 作为值</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/f0339e0322da62b4f7b79b147e1a4749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBPZaJFU3a2Ggy3lyKGzsA.png"/></div></div></figure><p id="bddd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只需两行代码，您的数据就可以输入到模型中了。要检查是否所有要素都是数字格式，</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/3c97b7e169cd07df69a819b64ae9e0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*28o-XTztwoo533lgfQvOCw.png"/></div></div></figure><p id="fcde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">训练模型，</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c627" class="mi mj it me b gy mk ml l mm mn">from sklearn.ensemble import RandomForestRegressor<br/>m = RandomForestRegressor(n_jobs=-1)<br/>m.fit(X,y)<br/>m.score(X,y)</span></pre><p id="5c3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">获得的分数是 0.9711 (R2)</p><p id="7881" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以在我们的测试数据集上测试它，获得一个初始预测，提交给 kaggle 并获得一个初始分数。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="630d" class="mi mj it me b gy mk ml l mm mn">df_test = pd.read_csv("test.csv",low_memory=False)<br/>X_test, missing_val = ep.proc_miss(df_test,missing_val)<br/>X_test, cat_dict = ep.proc_cat(X_test,cat_dict=cat_dict,max_cardi=5)<br/>y_pred = m.predict(X_test)</span></pre><p id="1f95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于测试/验证集，<code class="fe mp mq mr me b">proc_miss</code>需要一个 missing_val 参数，以便它替换测试集每一列中的相同中值。如果在不在训练集中的测试集的列中发现缺失值，将更新 missing_val 变量。同样的逻辑也适用于<code class="fe mp mq mr me b">proc_cat</code>，这里需要 cat_dict 作为参数，以确保编码的一致性。</p><p id="7bb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">y_pred 现在可以导出为 csv 格式，提交给 kaggle。该数据集的得分为 0.15296，在排行榜中排名前 68%。现在，您可以查看相对特性重要性、超参数调整和特性工程，以进一步提高您的分数。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="93a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个数据集我将使用<a class="ae kf" href="https://www.kaggle.com/c/prudential-life-insurance-assessment" rel="noopener ugc nofollow" target="_blank">保诚人寿保险评估</a></p><p id="7399" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">库和数据的加载</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f0c0" class="mi mj it me b gy mk ml l mm mn">import numpy as np<br/>import pandas as pd<br/>import easy_processing as ep</span><span id="974c" class="mi mj it me b gy mo ml l mm mn">df = pd.read_csv("insurance_train.csv",low_memory=False)<br/>X = df.drop(["Response"],axis = 1)<br/>y=df["Response"]</span></pre><p id="35c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经历与之前完全相同的步骤，但是使用<a class="ae kf" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank"> RandomForestClassifier </a>而不是<a class="ae kf" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank"> RandomForestRegressor </a></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e4cb" class="mi mj it me b gy mk ml l mm mn">X, missing_val = ep.proc_miss(X)<br/>X, cat_dict = ep.proc_cat(X,max_cardi=5)</span><span id="5a7f" class="mi mj it me b gy mo ml l mm mn">from sklearn.ensemble import RandomForestClassifier<br/>m = RandomForestClassifier(n_jobs=-1)<br/>m.fit(X,y)<br/>m.score(X,y)</span></pre><p id="5960" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里得到的分数是 0.98939054</p><p id="01ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理测试集，</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b305" class="mi mj it me b gy mk ml l mm mn">df_test = pd.read_csv("insurance_test.csv",low_memory=False)<br/>X_test, missing_val = ep.proc_miss(df_test,missing_val)<br/>X_test, cat_dict = ep.proc_cat(X_test,cat_dict=cat_dict,max_cardi=5)<br/>y_pred = m.predict(X_test)</span></pre><p id="9f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将 y_pred 提交给 kaggle 后，我在公开评分中获得了 0.50516 的分数，在私人排行榜中获得了 0.51187 的分数。远远不够好，但这是一个开始。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="4eec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">声明:fastai 对此有一个类似的、更优化、更高效的库。我的实现是一个简洁的版本，可以帮助初学者浏览整个代码并理解每个实现。所有文档也可以在 GitHub(<a class="ae kf" href="https://github.com/Benlau93/easy_processing" rel="noopener ugc nofollow" target="_blank">https://github.com/Benlau93/easy_processing</a>)中找到。</p><p id="222f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。</p></div></div>    
</body>
</html>