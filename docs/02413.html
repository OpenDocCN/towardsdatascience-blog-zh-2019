<html>
<head>
<title>Building A Movie Recommendation Engine Using Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用熊猫构建电影推荐引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-movie-recommendation-engine-using-pandas-e0a105ed6762?source=collection_archive---------9-----------------------#2019-04-20">https://towardsdatascience.com/building-a-movie-recommendation-engine-using-pandas-e0a105ed6762?source=collection_archive---------9-----------------------#2019-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3d9f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索推荐引擎背后的基本直觉。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4a0b899cb6d7ad6a494d63079e5f75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIrwK-4pIITXoh1VBy11Pg.jpeg"/></div></div></figure><h1 id="04cb" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">概观</h1><p id="8529" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">推荐引擎是基本上计算两个实体之间相似性的程序，在此基础上，它们给我们有针对性的输出。如果我们看看任何推荐引擎的根源，它们都试图找出两个实体之间的相似性。然后，所计算的相似性可以用于推导各种类型的推荐以及它们之间的关系。</p><p id="3275" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir">推荐引擎大多基于以下技术:</strong></p><ol class=""><li id="a416" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">基于流行度的过滤。</li><li id="d032" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">协作过滤(基于用户/基于项目)。</li><li id="73f3" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">基于混合用户项目的协同过滤。</li><li id="ad2b" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">基于内容的过滤。</li></ol><h2 id="671e" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated"><strong class="ak">基于人气的过滤</strong></h2><p id="4ed6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">推荐引擎最基本的形式是引擎向所有用户推荐最受欢迎的项目。这将是普遍的，因为每个人都会得到类似的建议，因为我们没有个性化的建议。这些类型的推荐引擎是基于<strong class="ll ir">的基于流行度的过滤</strong>。这种模式的使用案例是新闻网站上当天的“头条新闻”部分，在这里，不管每个用户的兴趣如何，对每个人来说最受欢迎的新闻都是一样的，因为这符合逻辑，因为新闻是一种一般化的东西，与用户的兴趣无关。</p><h2 id="1c7d" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated">协同过滤</h2><p id="5709" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在协同过滤中，两个实体基于它们之间的某些相似性来协作推断推荐。这些过滤技术大致有两种类型:</p><ol class=""><li id="b01a" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated"><strong class="ll ir">基于用户的协同过滤:</strong>在基于用户的协同过滤中，我们找出两个用户之间的相似性得分。基于相似性得分，我们将一个用户购买/喜欢的项目推荐给其他用户，假设他可能基于相似性喜欢这些项目。当我们着手实施时，这一点会更加清楚。主要的在线流媒体服务，<strong class="ll ir">网飞</strong>都有基于用户协同过滤的推荐引擎。</li><li id="be93" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><strong class="ll ir">基于项目的协同过滤:</strong>在基于项目的协同过滤中，项目的相似度是用现有用户正在消费的现有项目来计算的。然后，基于相似性的数量，我们可以说，如果用户 X 喜欢项目 A，并且新的项目 P 与项目 A 最相似，那么我们向用户 X 推荐项目 P 是非常有意义的</li><li id="c427" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><strong class="ll ir">基于混合用户项目的协同过滤:</strong>这种技术基本上是上述两种技术的适当混合，其中推荐不仅仅基于任一种。像亚马逊这样的电子商务网站采用这种技术向顾客推荐商品。</li><li id="0b57" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><strong class="ll ir">基于内容的过滤:</strong>在这种技术中，向用户推荐他们以前最用过/看过/喜欢的相似内容。例如，如果用户一直在听相似类型的歌曲(比特率、bps、曲调等)。)，他将被推荐属于基于某些特征决定的相同类别的歌曲。这一类别最好的例子是<strong class="ll ir"> Pandora Radio </strong>，这是一个音乐流媒体和自动音乐推荐网络电台服务。</li></ol><h2 id="6ff8" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated">编码和实现</h2><p id="c36b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们有一个电影镜头数据库，我们的目标是使用 pandas 从头开始应用各种推荐技术，并找出用户、最受欢迎的电影和基于基于用户的协同过滤的目标用户个性化推荐之间的相似性。(我们只探索其中一种类型，因为这些文章是关于获得推荐引擎背后的基本直觉。)</p><p id="b4c4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们正在从<strong class="ll ir">数学</strong>库中导入<strong class="ll ir">熊猫</strong>和一些基本的数学函数，并将数据集导入 dataframe 对象。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="0b7b" class="my ks iq nl b gy np nq l nr ns"><strong class="nl ir"># Importing the required libraries.</strong><br/>import pandas as pd<br/>from math import pow, sqrt</span><span id="d12a" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Reading ratings dataset into a pandas dataframe object.</strong><br/>r_cols = ['user_id', 'movie_id', 'rating', 'unix_timestamp']<br/>ratings = pd.read_csv('data/ratings.dat', sep='::', names=r_cols,<br/> encoding='latin-1')</span><span id="6959" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Getting number of users and movies from the dataset.</strong><br/>user_ids = ratings.user_id.unique().tolist()<br/>movie_ids = ratings.movie_id.unique().tolist()<br/>print('Number of Users: {}'.format(len(user_ids)))<br/>print('Number of Movies: {}'.format(len(movie_ids)))</span><span id="4c84" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir">Output:<br/></strong>Number of Users: <strong class="nl ir">6040</strong><br/>Number of Movies: <strong class="nl ir">3706</strong></span></pre><p id="6f81" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是我们的数据集的前 5 行的样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c950b4bcc902218a2d6123c310de34aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*JKDwFmQ0WHSvOILCypHpSw.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Ratings Dataset</figcaption></figure><p id="38eb" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这个数据集中，我们有 4 列和大约 1M 行。除了，<strong class="ll ir"> unix_timestamp，</strong>所有的列都是自解释的。无论如何，我们不会在代码中使用这个列。接下来，让我们看看我们的电影数据集是什么样子的。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="e5f6" class="my ks iq nl b gy np nq l nr ns"><strong class="nl ir"># Reading movies dataset into a pandas dataframe object.</strong><br/>m_cols = ['movie_id', 'movie_title', 'genre']<br/>movies = pd.read_csv('data/movies.dat', sep='::', names=m_cols, encoding='latin-1')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4acdc266bea7417a5195d206b53cbef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*Vb9FhouqJ5UZdca9p5Dpdw.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Movie Dataset</figcaption></figure><p id="f5e3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">所有的列名都是不言自明的。如上面的数据帧所示，<strong class="ll ir">类型</strong>列包含带有管道分隔符的数据，这些数据不能作为建议进行处理。因此，我们需要为每个流派类型生成列，这样，如果电影属于该流派，其值将为 1，否则为 0(类似于一种热门编码)。此外，我们需要从<strong class="ll ir"> movie_title </strong>列中分离出年度发布，并为其生成一个新列，这也是一个新的重要特性。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6f1f" class="my ks iq nl b gy np nq l nr ns"><strong class="nl ir"># Getting series of lists by applying split operation.</strong><br/>movies.genre = movies.genre.str.split('|')</span><span id="68ca" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Getting distinct genre types for generating columns of genre type.</strong><br/>genre_columns = list(set([j for i in movies['genre'].tolist() for j in i]))</span><span id="7990" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Iterating over every list to create and fill values into columns.</strong><br/>for j in genre_columns:<br/>    movies[j] = 0<br/>for i in range(movies.shape[0]):<br/>    for j in genre_columns:<br/>        if(j in movies['genre'].iloc[i]):<br/>            movies.loc[i,j] = 1</span><span id="1a38" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Separting movie title and year part using split function.</strong><br/>split_values = movies['movie_title'].str.split("(", n = 1, expand = True)</span><span id="1f56" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># setting 'movie_title' values to title part.</strong><br/>movies.movie_title = split_values[0]</span><span id="426d" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># creating 'release_year' column.</strong><br/>movies['release_year'] = split_values[1]</span><span id="228b" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Cleaning the release_year series.</strong><br/>movies['release_year'] = movies.release_year.str.replace(')','')</span><span id="20fb" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># dropping 'genre' columns as it has already been one hot encoded.</strong><br/>movies.drop('genre',axis=1,inplace=True)</span></pre><p id="784b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">以下是数据帧处理后的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/33de3acf5332b8fdd22ddbc2607c6395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eE-CWuiDXN91J_7grMvfkA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/0f5c0e97de0007f0e6fcf3df544e3560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRu5X025NJ9w1dXt6lRLlQ.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Data Frame View for Movies Dataset After Pre-Processing</figcaption></figure><p id="c057" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在，让我们写下一些在我们的代码中经常使用的 getter 函数，这样我们就不需要一遍又一遍地编写它们，这也增加了代码的可读性和可重用性。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3ed2" class="my ks iq nl b gy np nq l nr ns"><strong class="nl ir"># Getting the rating given by a user to a movie.</strong><br/><strong class="nl ir">def get_rating_(userid,movieid):</strong><br/>    return (ratings.loc[(ratings.user_id==userid) &amp; (ratings.movie_id == movieid),'rating'].iloc[0])</span><span id="bc95" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Getting the list of all movie ids the specified user has rated.</strong><br/><strong class="nl ir">def get_movieids_(userid):</strong><br/>    return (ratings.loc[(ratings.user_id==userid),'movie_id'].tolist())</span><span id="1e27" class="my ks iq nl b gy nt nq l nr ns"><strong class="nl ir"># Getting the movie titles against the movie id.</strong><br/><strong class="nl ir">def get_movie_title_(movieid):</strong><br/>    return (movies.loc[(movies.movie_id == movieid),'movie_title'].iloc[0])</span></pre><h2 id="f573" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated">相似性得分</h2><p id="c933" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在该实现中，将基于两个用户之间的距离(即欧几里德距离)并通过计算两个用户之间的皮尔逊相关来计算两个用户之间的相似性。</p><p id="cac3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们将编写两个函数，一个基于欧几里得距离计算相似性，另一个基于皮尔逊相关，这样你就知道我们为什么要编写两个函数了。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d6da" class="my ks iq nl b gy np nq l nr ns"><strong class="nl ir">def distance_similarity_score(user1,user2):</strong><br/>    '''<br/>    user1 &amp; user2 : user ids of two users between which similarity        score is to be calculated.<br/>    '''<br/>    # Count of movies watched by both the users.<br/>    both_watch_count = 0<br/>    for element in ratings.loc[ratings.user_id==user1,'movie_id'].tolist():<br/>        if element in ratings.loc[ratings.user_id==user2,'movie_id'].tolist():<br/>            both_watch_count += 1<br/>    if both_watch_count == 0 :<br/>        return 0<br/>    <br/>    # Calculating distance based similarity between both the users.<br/>    distance = []<br/>    for element in ratings.loc[ratings.user_id==user1,'movie_id'].tolist():<br/>        if element in ratings.loc[ratings.user_id==user2,'movie_id'].tolist():<br/>            rating1 = get_rating_(user1,element)<br/>            rating2 = get_rating_(user2,element)<br/>            distance.append(pow(rating1 - rating2, 2))<br/>    total_distance = sum(distance)<br/>    <br/>    # Adding one to the denominator to avoid divide by zero error.<br/>    return 1/(1+sqrt(total_distance))</span><span id="6878" class="my ks iq nl b gy nt nq l nr ns">print('Distance based similarity between user ids 1 &amp; 310: {}'.format(distance_similarity_score(1,310)))</span><span id="cafa" class="my ks iq nl b gy nt nq l nr ns">Output:<br/>Distance based similarity between user ids 1 &amp; 310: <strong class="nl ir">0.14459058185587106</strong></span></pre><p id="20e4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">基于距离计算相似性得分有一个固有的问题。我们没有阈值来决定在计算用户是否足够近或足够远时要考虑两个用户之间的距离。另一方面，皮尔逊相关方法解决了这个问题，因为它总是返回-1 &amp; 1 之间的值，这清楚地为我们提供了我们喜欢的接近度的边界。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="21ac" class="my ks iq nl b gy np nq l nr ns"><strong class="nl ir">def pearson_correlation_score(user1,user2):</strong><br/>    '''<br/>    user1 &amp; user2 : user ids of two users between which similarity score is to be calculated.<br/>    '''<br/>    # A list of movies watched by both the users.<br/>    both_watch_count = []<br/>    <br/>    # Finding movies watched by both the users.<br/>    for element in ratings.loc[ratings.user_id==user1,'movie_id'].tolist():<br/>        if element in ratings.loc[ratings.user_id==user2,'movie_id'].tolist():<br/>            both_watch_count.append(element)<br/>    <br/>    # Returning '0' correlation for bo common movies.<br/>    if len(both_watch_count) == 0 :<br/>        return 0<br/>    <br/>    # Calculating Co-Variances.<br/>    rating_sum_1 = sum([get_rating_(user1,element) for element in both_watch_count])<br/>    rating_sum_2 = sum([get_rating_(user2,element) for element in both_watch_count])<br/>    rating_squared_sum_1 = sum([pow(get_rating_(user1,element),2) for element in both_watch_count])<br/>    rating_squared_sum_2 = sum([pow(get_rating_(user2,element),2) for element in both_watch_count])<br/>    product_sum_rating = sum([get_rating_(user1,element) * get_rating_(user2,element) for element in both_watch_count])<br/>    <br/>    # Returning pearson correlation between both the users.<br/>    numerator = product_sum_rating - ((rating_sum_1 * rating_sum_2) / len(both_watch_count))<br/>    denominator = sqrt((rating_squared_sum_1 - pow(rating_sum_1,2) / len(both_watch_count)) * (rating_squared_sum_2 - pow(rating_sum_2,2) / len(both_watch_count)))<br/>    <br/>    # Handling 'Divide by Zero' error.<br/>    if denominator == 0:<br/>        return 0<br/>    return numerator/denominator</span><span id="39d9" class="my ks iq nl b gy nt nq l nr ns">print('Pearson Corelation between user ids 11 &amp; 30: {}'.format(pearson_correlation_score(11,30)))</span><span id="e289" class="my ks iq nl b gy nt nq l nr ns">Output:<br/>Pearson Corelation between user ids 11 &amp; 30: <strong class="nl ir">0.2042571684752679</strong></span></pre><h2 id="8d2b" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated">最相似的用户</h2><p id="cd9d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">目标是找出与目标用户最相似的用户。这里，我们有两个指标来计算分数，即距离和相关性。现在，我们将为此编写一个函数。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="5cb2" class="my ks iq nl b gy np nq l nr ns">def most_similar_users_(user1,number_of_users,metric='pearson'):<br/>    '''<br/>    user1 : Targeted User<br/>    number_of_users : number of most similar users you want to user1.<br/>    metric : metric to be used to calculate inter-user similarity score. ('pearson' or else)<br/>    '''<br/>    # Getting distinct user ids.<br/>    user_ids = ratings.user_id.unique().tolist()<br/>    <br/>    # Getting similarity score between targeted and every other suer in the list(or subset of the list).<br/>    if(metric == 'pearson'):<br/>        similarity_score = [(pearson_correlation_score(user1,nth_user),nth_user) for nth_user in user_ids[:100] if nth_user != user1]<br/>    else:<br/>        similarity_score = [(distance_similarity_score(user1,nth_user),nth_user) for nth_user in user_ids[:100] if nth_user != user1]<br/>    <br/>    # Sorting in descending order.<br/>    similarity_score.sort()<br/>    similarity_score.reverse()<br/>    <br/>    # Returning the top most 'number_of_users' similar users. <br/>    return similarity_score[:number_of_users]</span><span id="e8b1" class="my ks iq nl b gy nt nq l nr ns">print(most_similar_users_(23,5))</span><span id="5071" class="my ks iq nl b gy nt nq l nr ns">Output:<br/><strong class="nl ir">[(0.936585811581694, 61), (0.7076731463403717, 41), (0.6123724356957956, 21), (0.5970863767331771, 25), (0.5477225575051661, 64)]</strong></span></pre><p id="b91a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正如我们所看到的，输出是元组列表，指示使用用户 id 查询的前 5 个相似数量的用户相对于目标用户的相似性得分。这里使用的指标是皮尔逊相关。</p><p id="4496" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我不知道是否很少有人注意到，最相似的用户的逻辑可以通过考虑其他因素，如年龄、性别、职业等来加强。这里，我们仅根据一个特征(即评级)创建了我们的逻辑。</p><h2 id="8432" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated">为目标用户获取电影推荐</h2><p id="3414" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">概念很简单。首先，我们需要只迭代那些没有被目标用户观看(或评级)的电影，以及基于与目标用户高度相关的用户的子设置项。这里，我们使用了加权相似性方法，其中我们考虑了评级和分数的乘积，以确保高度相似的用户比不太相似的用户对推荐的影响更大。然后，我们根据分数和电影 id 对列表进行排序，并根据这些电影 id 返回电影标题。让我们为此写一个函数。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="fb23" class="my ks iq nl b gy np nq l nr ns">def get_recommendation_(userid):<br/>    user_ids = ratings.user_id.unique().tolist()<br/>    total = {}<br/>    similariy_sum = {}<br/>    <br/>    # Iterating over subset of user ids.<br/>    for user in user_ids[:100]:<br/>        <br/>        # not comparing the user to itself (obviously!)<br/>        if user == userid:<br/>            continue<br/>        <br/>        # Getting similarity score between the users.<br/>        score = pearson_correlation_score(userid,user)<br/>        <br/>        # not considering users having zero or less similarity score.<br/>        if score &lt;= 0:<br/>            continue<br/>        <br/>        # Getting weighted similarity score and sum of similarities between both the users.<br/>        for movieid in get_movieids_(user):<br/>            # Only considering not watched/rated movies<br/>            if movieid not in get_movieids_(userid) or get_rating_(userid,movieid) == 0:<br/>                total[movieid] = 0<br/>                total[movieid] += get_rating_(user,movieid) * score<br/>                similariy_sum[movieid] = 0<br/>                similariy_sum[movieid] += score<br/>    <br/>    # Normalizing ratings<br/>    ranking = [(tot/similariy_sum[movieid],movieid) for movieid,tot in total.items()]<br/>    ranking.sort()<br/>    ranking.reverse()<br/>    <br/>    # Getting movie titles against the movie ids.<br/>    recommendations = [get_movie_title_(movieid) for score,movieid in ranking]<br/>    return recommendations[:10]</span><span id="6503" class="my ks iq nl b gy nt nq l nr ns">print(get_recommendation_(32))</span><span id="a46d" class="my ks iq nl b gy nt nq l nr ns">Output:<br/><strong class="nl ir">['Invisible Man, The ', 'Creature From the Black Lagoon, The ', 'Hellraiser ', 'Almost Famous ', 'Way of the Gun, The ', 'Shane ', 'Naked Gun 2 1/2: The Smell of Fear, The ', "Kelly's Heroes ", 'Official Story, The ', 'Everything You Always Wanted to Know About Sex ']</strong></span></pre><p id="139a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正如我们在输出中看到的，我们已经使用度量皮尔逊相关性为用户 id 为 32 的用户获得了前 10 部强烈推荐的电影。你可以用欧几里得距离做同样的练习，我相信结果会不同。</p><h2 id="fa8e" class="my ks iq bd kt mz na dn kx nb nc dp lb ls nd ne ld lw nf ng lf ma nh ni lh nj bi translated">学习和结论</h2><p id="79cb" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们通过使用熊猫和基本的数学库函数实现了一个电影推荐引擎。此外，我们了解了推荐引擎背后的基本直觉。显然，推荐引擎的功能远不止这些，因为有多种功能和因素会影响推荐，而不仅仅是评级。此外，在下一篇博客中，我们还将基于用户和电影的其他特征来实现和推断我们的推荐，并探索推荐引擎的臭名昭著的技术，即使用<strong class="ll ir"> turicreate </strong>库的<strong class="ll ir">矩阵分解</strong>。</p><p id="7215" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">博客中代码的 GitHub 存储库可以在<a class="ae oc" href="https://github.com/nishitjain/movie-recommendation-system-scratch" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>