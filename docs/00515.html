<html>
<head>
<title>Bitwise sorting in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby 中的按位排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bitwise-sorting-in-ruby-47f27bbd9ebf?source=collection_archive---------12-----------------------#2019-01-23">https://towardsdatascience.com/bitwise-sorting-in-ruby-47f27bbd9ebf?source=collection_archive---------12-----------------------#2019-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c2c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，你运营着一个 NBA 篮球招募网站。您希望根据以下三个属性对全国所有大学篮球运动员进行排名:</p><ol class=""><li id="0dd6" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">玩家的个人评分(1-10)</li><li id="61a8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">玩家的团队等级(1-10)</li><li id="9a1c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">玩家的会议等级(1-10)</li><li id="a6f5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">玩家的 ID(任意数字)</li></ol><p id="9b38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个玩家的例子，排名是这样的:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="63d2" class="li lj iq le b gy lk ll l lm ln">Player 1: rating 10, team rating 10, conference rating 10<br/>Player 2: rating 10, team rating 10, conference rating 5<br/>Player 3: rating 10, team rating 5,  conference rating 10<br/>Player 4: rating 10, team rating 5,  conference rating 5<br/>Player 5: rating 5,  team rating 10, conference rating 10<br/>Player 6: rating 5,  team rating 10, conference rating 5</span></pre><p id="0de6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你采用天真的方法，对所有球队的所有球员进行排序可能是一个昂贵的计算。举例来说，让我们假设有 1，000，000 个玩家需要评估。使用嵌套排序，我们可以构建如下内容:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="bedf" class="li lj iq le b gy lk ll l lm ln">Player = Struct.new(:id, :rating, :team_rating, :conf_rating)</span><span id="a118" class="li lj iq le b gy lo ll l lm ln"># setup</span><span id="ce29" class="li lj iq le b gy lo ll l lm ln">id = 1.step<br/><a class="ae lp" href="http://twitter.com/players" rel="noopener ugc nofollow" target="_blank">@players</a> = 1_000_000.times.map do <br/>  Player.new(id.next, rand(0..10), rand(0..10), rand(0..10))<br/>end</span><span id="ffa1" class="li lj iq le b gy lo ll l lm ln"># I want to sort by player rating descending,<br/># then team rating descending,<br/># then conference rating descending,<br/># then by id descending.</span><span id="4d81" class="li lj iq le b gy lo ll l lm ln">def sort_naively<br/>  <a class="ae lp" href="http://twitter.com/players" rel="noopener ugc nofollow" target="_blank">@players</a>.group_by(&amp;:rating).sort.reverse.map do |rb|<br/>    rb[1].group_by(&amp;:team_rating).sort.reverse.map do |tb|<br/>      tb[1].group_by(&amp;:conf_rating).sort.reverse.map do |cb|<br/>        cb[1].group_by(&amp;:id).sort.reverse.map do |ib|<br/>          ib[1]<br/>        end<br/>      end.flatten<br/>    end.flatten<br/>  end.flatten<br/>end</span></pre><p id="a194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">平均来说，使用这种方法对 1，000，000 条记录进行排序需要大约 2000 毫秒。考虑到记录集的大小，这还不错。然而，深度嵌套的数组结构使用了大量的内存，大约 219MB。这是 Ruby 应用程序中的一个常见问题，但是因为我们有一个 GC，所以我们通常是安全的。总而言之，对于较小的数据集来说，这是一个可用的算法，但我认为我们可以对它进行改进。</p><p id="5497" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe lq lr ls le b">Array.sort_by</code>进行排序，它看起来更漂亮，并传入一个值数组进行排序:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="bfcf" class="li lj iq le b gy lk ll l lm ln">@players.sort_by do |p| <br/>  [p.rating, p.team_rating, p.conf_rating, p.id]<br/>end.reverse</span></pre><p id="c406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…但这更慢。在我的测试中，平均需要 10 秒钟。然而，它使用了 80MB 的内存，所以这是一个小的改进。在低内存环境中，这可能会派上用场，但让我们探索另一种排序方法，一种通过利用巧妙的位运算来节省时间和内存的方法。</p><p id="0725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉按位运算，它们在 C 等低级语言中被广泛用于对位进行运算。在 Ruby 中，主要的按位运算符有:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="16cc" class="li lj iq le b gy lk ll l lm ln">&amp;  -&gt; AND<br/>|   -&gt; OR<br/>^   -&gt; XOR<br/>~   -&gt; NOT<br/>&lt;&lt;  -&gt; LEFT SHIFT<br/>&gt;&gt;  -&gt; RIGHT SHIFT</span></pre><p id="9b97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这些功能的详细解释可以在<a class="ae lp" href="https://www.calleerlandsson.com/posts/rubys-bitwise-operators/" rel="noopener ugc nofollow" target="_blank">这里</a>找到，这超出了本文的范围。对于这篇文章，我们只需要一个关于<code class="fe lq lr ls le b">| (OR)</code>和<code class="fe lq lr ls le b">&lt;&lt; (LEFT SHIFT)</code>的解释者</p><p id="8706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经了解了这么多，你可能对计算机的工作原理有了很好的了解，这些位就是 1 和 0。按位运算符对这些位进行运算。</p><p id="d611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Bitwise <code class="fe lq lr ls le b">| (OR)</code>基本上接受两个参数，第一个和第二个位，并返回一个新位，其中第一个位的值为 1，第二个位的值为 1，在缺少 1 的地方添加 1。例如:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="292d" class="li lj iq le b gy lk ll l lm ln">integer  |  bit  | operator | other bit  |  new bit |  result<br/>      0  | 0000  |    |     |      0001  |    0001  |       1<br/>      1  | 0001  |    |     |      0001  |    0000  |       1<br/>      2  | 0010  |    |     |      0001  |    0011  |       3<br/>      3  | 0011  |    |     |      0001  |    0011  |       3<br/>      4  | 0100  |    |     |      0001  |    0101  |       5<br/>      5  | 0101  |    |     |      0010  |    0111  |       7<br/>     10  | 1010  |    |     |      0101  |    1111  |      15</span></pre><p id="682f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，按位<code class="fe lq lr ls le b">&lt;&lt; (LEFT SHIFT)</code>将位左移一定数量的位置，在该位的末尾添加 0。例如:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1b12" class="li lj iq le b gy lk ll l lm ln">integer  |   bit  |  operator  |  number  |  result  | integer<br/>      1  |     1  |     &lt;&lt;     |     1    |      10  |       2<br/>      2  |    10  |     &lt;&lt;     |     1    |     100  |       4<br/>      3  |    11  |     &lt;&lt;     |     1    |     110  |       6<br/>     10  |  1010  |     &lt;&lt;     |     2    |  101000  |      40</span></pre><p id="0212" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以利用这两个操作来使我们的排序算法变得更加智能。由于排序优先顺序总是<code class="fe lq lr ls le b">rating &gt; team_rating &gt; conf_rating &gt; id</code>，因此，无论其他等级是什么，等级为 10 的玩家将总是排在等级为 9 的玩家之上，以此类推。在评级相同的玩家之间，具有较好团队评级的玩家将被整体评级更高，等等。</p><p id="a206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用按位操作符实现这种排序，我们应该在 Player 结构中添加一个新参数<code class="fe lq lr ls le b">bit_rank</code>。新代码如下所示:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="f64d" class="li lj iq le b gy lk ll l lm ln">Player = Struct.new(<br/>  :id, <br/>  :rating, <br/>  :team_rating, <br/>  :conf_rating, <br/>  :bit_rank  # &lt;- new attribute<br/>)</span><span id="0781" class="li lj iq le b gy lo ll l lm ln"># setup</span><span id="fc91" class="li lj iq le b gy lo ll l lm ln">id = 1.step<br/><a class="ae lp" href="http://twitter.com/players" rel="noopener ugc nofollow" target="_blank">@players</a> = 1_000_000.times.map do <br/>  Player.new(id.next, rand(0..2), rand(0..2), rand(0..2))<br/>end</span><span id="dfb5" class="li lj iq le b gy lo ll l lm ln">#now, calculate the bit rank for each player<br/>@players.each do |p| <br/>  p.bit_rank = p.rating &lt;&lt; 30 |<br/>    p.team_rating &lt;&lt; 25 |<br/>    p.conf_rating &lt;&lt; 20 |<br/>    p.id<br/>end</span></pre><p id="e37e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，这个新的<code class="fe lq lr ls le b">bit_rank</code>属性是一个数字(一个很大的数字),代表玩家的整体等级。我们在 30 个位置上移动评级，团队评级 25 个位置，会议评级 20 个位置，然后对所有三个位置加上 ID 运行按位<code class="fe lq lr ls le b">OR</code>。例如，一个 ID 为 1 并且在所有三个类别中都被评为 10 的玩家将拥有<code class="fe lq lr ls le b">11_083_448_321</code>的<code class="fe lq lr ls le b">bit_rank</code>。当查看该值的位表示时，这是很直观的，它是:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="5b01" class="li lj iq le b gy lk ll l lm ln">01010010100101000000000000000000001</span><span id="d597" class="li lj iq le b gy lo ll l lm ln">01010 01010 01010 0000000000000000000001<br/>^     ^     ^     ^<br/>|     |     |     |__player ID = 1<br/>|     |     |<br/>|     |     |__player conference rating (10 = 01010)<br/>|     |<br/>|     |__player team rating (10 = 01010)<br/>|<br/>|__player rating (10 = 01010)</span></pre><p id="650a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同一个全是 5 的玩家会有一个<code class="fe lq lr ls le b">5_541_724_161</code>的<code class="fe lq lr ls le b">bit_rank</code>，当在 bit 镜头中看到时:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="4ee0" class="li lj iq le b gy lk ll l lm ln">00101001010010100000000000000000001</span><span id="eda1" class="li lj iq le b gy lo ll l lm ln">00101 00101 00101 00000000000000000001<br/>^     ^     ^     ^                   <br/>|     |     |     |__player ID = 1<br/>|     |     |<br/>|     |     |__player conference rating (5 = 00101)<br/>|     |<br/>|     |__player team rating (5 = 00101)<br/>| <br/>|__player rating (5 = 00101)</span></pre><p id="a356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…有道理。</p><p id="16c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls le b">bit_rank</code>将排序优先级嵌入到自身中，其中玩家各自的评级被转移到位等级的适当区域，并且它们都被向左移动足够远，以在最后仍然按 ID 排序。</p><p id="248d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经了解了<code class="fe lq lr ls le b">bit_rank</code>正在做什么，让我们看看运行这样一个复杂的操作需要什么代码:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="5809" class="li lj iq le b gy lk ll l lm ln">@players.sort_by(&amp;:bit_rank)</span></pre><p id="2edd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对，就是这样。因为<code class="fe lq lr ls le b">bit_rank</code>是 Struct 的一个属性，所以可以使用旧的<code class="fe lq lr ls le b">Symbol.to_proc</code> ruby magic 来调用它。如果我们在 Rails 领域，这可能是模型的一个属性，使得排序和排名非常容易。</p><p id="9edf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，当您查看时间和内存使用情况时，使用这种方法确实很出色。</p><p id="e17a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">平均而言，将该属性添加到百万个玩家对象中的每一个会使设置阶段增加 200 毫秒，但是基于该属性的排序会将排序时间减少到 500 毫秒。总之，以前的<code class="fe lq lr ls le b">800ms build + 2000ms sort = 2800ms</code>操作现在变成了<code class="fe lq lr ls le b">1000ms build + 500ms sort = 1500ms</code>！我们将排序时间减少了 1300 毫秒，提高了 46%!我们添加的排序属性越多，效率也会成倍提高。</p><p id="9dda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，内存的使用是难以置信的。为了刷新，最初的简单排序使用了 219MB 的内存，主要是因为它要排序到<code class="fe lq lr ls le b">10 + (10*10) + (10*10*10) + (10*10*10*10) = 11,110</code>个独立的、已排序的数组中。当使用<code class="fe lq lr ls le b">bit_rank</code>排序方法时，我们的操作只使用了 16MB，也就是少了 203MB，减少了 92%，因为我们没有任何嵌套数组。实际上，所有的内存占用都来自于构建 1，000，000 个玩家的数组。</p><p id="e389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这种方法非常适合大型数据集上的简单排序，提供了一种简单的方法来对多个值进行排序，并且在内存不足的环境中非常有用。</p><p id="fd6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探索位操作符背后的想法来自参与代码的<a class="ae lp" href="https://adventofcode.com/" rel="noopener ugc nofollow" target="_blank">问世，我强烈推荐参与其中。如果你还没有完成挑战，你也可以完成。</a></p><p id="4392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你喜欢这篇文章。你可以在<a class="ae lp" href="https://twitter.com/ni3t" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae lp" href="http://github.com/ni3t" rel="noopener ugc nofollow" target="_blank"> github </a>上找到我。</p></div></div>    
</body>
</html>