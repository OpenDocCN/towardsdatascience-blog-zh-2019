<html>
<head>
<title>The 5 Sampling Algorithms every Data Scientist need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据科学家都需要知道的 5 种采样算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-5-sampling-algorithms-every-data-scientist-need-to-know-43c7bc11d17c?source=collection_archive---------3-----------------------#2019-07-21">https://towardsdatascience.com/the-5-sampling-algorithms-every-data-scientist-need-to-know-43c7bc11d17c?source=collection_archive---------3-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/13743f934dc0c44c1a3587cbd0156052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qEU64d66stCxgLCa"/></div></div></figure><h2 id="2e85" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/ds-algorithms" rel="noopener" target="_blank"> DS 算法</a></h2><div class=""/><div class=""><h2 id="a772" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">或者至少应该听说过</h2></div><p id="efbb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">数据科学是对算法的研究。</p><p id="f91e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我每天都在努力学习许多算法，所以我想列出一些最常见和最常用的算法，这些算法将会在这个新的<a class="ae ly" href="https://towardsdatascience.com/tagged/ds-algorithms" rel="noopener" target="_blank"> DS 算法系列</a>中使用。</p><p id="d66e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo"> <em class="lz">这篇文章是关于在处理数据时可以使用的一些最常见的采样技术。</em> </strong></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="726f" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated"><strong class="ak">简单随机抽样</strong></h1><p id="3bd6" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated"><em class="lz">假设您想要选择一个群体的子集，其中该子集的每个成员被选中的概率相等。</em></p><p id="a5dd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">下面我们从数据集中选择 100 个样本点。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0580" class="nn mi je nj b gy no np l nq nr">sample_df = df.sample(100)</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5b1d" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated"><strong class="ak">分层抽样</strong></h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/589588f55eeb9f8e2e179acee5b7c381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UbRxwPDLU_-sbtTN.jpg"/></div></div></figure><p id="798a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">假设我们需要估计选举中每个候选人的平均票数。假设这个国家有 3 个城镇:</p><p id="ab0f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">A 镇有一百万工厂工人，</p><p id="cc08" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">B 镇有 200 万工人</p><p id="4ae8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">C 镇有 300 万退休人员。</p><p id="354c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们可以选择在整个人口中随机抽取 60 个样本，但是随机样本有可能在这些城镇中不平衡，因此有偏差，导致估计中的重大误差。</p><p id="ce34" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">相反，如果我们选择从城镇 A、B 和 C 分别随机抽取 10、20 和 30 个样本，那么对于相同的样本总量，我们可以产生较小的估计误差。</p><p id="7f21" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">使用 Python 可以很容易地完成这样的事情:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ada2" class="nn mi je nj b gy no np l nq nr">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,<br/>                                                    stratify=y, <br/>                                                    test_size=0.25)</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="21cf" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated"><strong class="ak">油藏取样</strong></h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/08eb2558277555c537bfdbca77099c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h-o588UdygwTHREs.jpg"/></div></div></figure><p id="f6e9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我喜欢这个问题陈述:</p><p id="5059" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo"> <em class="lz">假设您有一个长度未知的大型项目流，我们只能迭代一次。</em>T19】</strong></p><p id="5fbe" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo"> <em class="lz">创建一个算法，从这个流中随机选择一个项目，这样每个项目都有同等的可能性被选中。</em> </strong></p><p id="cc83" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们如何做到这一点？</p><p id="c608" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们假设我们必须从一个无限的流中抽取 5 个对象，这样每个元素被选中的概率是相等的。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="41d3" class="nn mi je nj b gy no np l nq nr">import random</span><span id="4b08" class="nn mi je nj b gy nt np l nq nr">def generator(max):<br/>    number = 1<br/>    while number &lt; max:<br/>        number += 1<br/>        yield number</span><span id="31ff" class="nn mi je nj b gy nt np l nq nr"># Create as stream generator<br/>stream = generator(10000)</span><span id="06d7" class="nn mi je nj b gy nt np l nq nr"># Doing Reservoir Sampling from the stream<br/>k=5<br/>reservoir = []<br/>for i, element in enumerate(stream):<br/>    if i+1&lt;= k:<br/>        reservoir.append(element)<br/>    else:<br/>        probability = k/(i+1)<br/>        if random.random() &lt; probability:<br/>            # Select item in stream and remove one of the k items already selected<br/>             reservoir[random.choice(range(0,k))] = element</span><span id="8c81" class="nn mi je nj b gy nt np l nq nr">print(reservoir)<br/>------------------------------------<br/>[1369, 4108, 9986, 828, 5589]</span></pre><p id="15cf" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">可以从数学上证明，在样本中，每个元素从流中被选择的概率是相同的。</p><p id="9c51" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">怎么会？</p><p id="90a9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当涉及到数学时，想一个更小的问题总是有帮助的。</p><p id="f4ca" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，让我们考虑一个只有 3 项的流，我们必须保留其中的 2 项。</p><p id="3580" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们看到第一项，我们把它放在列表中，因为我们的容器有空间。我们看到第二个项目，我们把它放在列表中，因为我们的容器有空间。</p><p id="172e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们看到第三项。这就是事情变得有趣的地方。我们以 2/3 的概率选择列表中的第三个项目。</p><p id="4749" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在让我们看看第一项被选中的概率:</p><p id="ac39" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">移除第一项的概率是元素 3 被选择的概率乘以元素 1 被从库中的 2 个元素中随机选择作为替换候选的概率。这个概率是:</p><p id="fb0a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe nu nv nw nj b">2/3*1/2 = 1/3</code></p><p id="e66a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此 1 被选中的概率是:</p><p id="0117" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe nu nv nw nj b">1–1/3 = 2/3</code></p><p id="ae36" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于第二个元素，我们可以有完全相同的论点，我们可以扩展到许多元素。</p><p id="28ec" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此每个项目都有相同的概率被选中:<code class="fe nu nv nw nj b">2/3</code>或者一般来说<code class="fe nu nv nw nj b">k/n</code></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9621" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">随机欠采样和过采样</h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/2f9c79c96e810d229a1e83a0efe3f375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u6pKLqdCDsG_5kXa.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk"><a class="ae ly" href="https://www.kaggle.com/rafjaa/resampling-strategies-for-imbalanced-datasets#t1" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="7231" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们经常会遇到不平衡的数据集。</p><p id="0d50" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一种广泛采用的处理高度不平衡数据集的技术被称为重采样。它包括从多数类中移除样本(欠采样)和/或从少数类中添加更多样本(过采样)。</p><p id="11db" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们首先创建一些不平衡数据的例子。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="b2a7" class="nn mi je nj b gy no np l nq nr">from sklearn.datasets import make_classification</span><span id="6b61" class="nn mi je nj b gy nt np l nq nr">X, y = make_classification(<br/>    n_classes=2, class_sep=1.5, weights=[0.9, 0.1],<br/>    n_informative=3, n_redundant=1, flip_y=0,<br/>    n_features=20, n_clusters_per_class=1,<br/>    n_samples=100, random_state=10<br/>)</span><span id="aa61" class="nn mi je nj b gy nt np l nq nr">X = pd.DataFrame(X)<br/>X['target'] = y</span></pre><p id="e125" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们现在可以使用以下工具进行随机过采样和欠采样:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c400" class="nn mi je nj b gy no np l nq nr">num_0 = len(X[X['target']==0])<br/>num_1 = len(X[X['target']==1])<br/>print(num_0,num_1)</span><span id="a0af" class="nn mi je nj b gy nt np l nq nr"># random undersample</span><span id="f0ba" class="nn mi je nj b gy nt np l nq nr">undersampled_data = pd.concat([ X[X['target']==0].sample(num_1) , X[X['target']==1] ])<br/>print(len(undersampled_data))</span><span id="958a" class="nn mi je nj b gy nt np l nq nr"># random oversample</span><span id="fac9" class="nn mi je nj b gy nt np l nq nr">oversampled_data = pd.concat([ X[X['target']==0] , X[X['target']==1].sample(num_0, replace=True) ])<br/>print(len(oversampled_data))</span><span id="e1cf" class="nn mi je nj b gy nt np l nq nr">------------------------------------------------------------<br/>OUTPUT:<br/>90 10<br/>20<br/>180</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="38ad" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">使用不平衡学习的欠采样和过采样</h1><p id="8180" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">不平衡学习(imblearn)是一个 Python 包，用来解决不平衡数据集的问题。</p><p id="2fcc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">它提供了多种欠采样和过采样方法。</p><h2 id="ad6b" class="nn mi je bd mj oc od dn mn oe of dp mr ll og oh mt lp oi oj mv lt ok ol mx jk bi translated">a.使用 Tomek 链接的欠采样:</h2><p id="1ee2" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">它提供的一种方法叫做 Tomek 链接。托梅克链是相邻的相反类的成对例子。</p><p id="bdbe" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在该算法中，我们最终从 Tomek 链接中移除多数元素，这为分类器提供了更好的决策边界。</p><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/99d0ea4b4fb18a5176712002c7b66999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*huy_9J15wzYJ2o5S"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk"><a class="ae ly" href="https://www.kaggle.com/rafjaa/resampling-strategies-for-imbalanced-datasets#t1" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="5811" class="nn mi je nj b gy no np l nq nr">from imblearn.under_sampling import TomekLinks<br/><br/>tl = TomekLinks(return_indices=True, ratio='majority')<br/>X_tl, y_tl, id_tl = tl.fit_sample(X, y)</span></pre><h2 id="1401" class="nn mi je bd mj oc od dn mn oe of dp mr ll og oh mt lp oi oj mv lt ok ol mx jk bi translated">b.使用 SMOTE 进行过采样:</h2><p id="a16e" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">在 SMOTE(合成少数过采样技术)中，我们在已经存在的元素附近合成少数类的元素。</p><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/12518bff305bc47af3a120e420ca95e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UrGYcz_Ab-HTo4-B.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk"><a class="ae ly" href="https://www.kaggle.com/rafjaa/resampling-strategies-for-imbalanced-datasets#t1" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f01f" class="nn mi je nj b gy no np l nq nr">from imblearn.over_sampling import SMOTE<br/><br/>smote = SMOTE(ratio='minority')<br/>X_sm, y_sm = smote.fit_sample(X, y)</span></pre><p id="2ca7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<a class="ae ly" href="https://github.com/scikit-learn-contrib/imbalanced-learn#id3" rel="noopener ugc nofollow" target="_blank"> imblearn </a>包中有各种各样的其他方法用于欠采样(聚类质心、近似缺失等)。)和过采样(ADASYN 和 bSMOTE)，您可以查看一下。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cdb3" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">结论</h1><p id="3ddd" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">算法是数据科学的命脉。</p><p id="fbbe" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo"> <em class="lz">采样是数据科学中的一个重要话题，我们实际上并没有尽可能多地谈论它。</em>T11】</strong></p><p id="3124" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一个好的抽样策略有时可以推动整个项目向前发展。糟糕的采样策略可能会给我们错误的结果。因此，在选择采样策略时应该小心谨慎。</p><p id="365d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所以，无论是在工作场所还是在酒吧，都要进行抽样调查。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="2227" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你想了解更多关于数据科学的知识，我想调出吴恩达的这个<a class="ae ly" href="https://coursera.pxf.io/NKERRq" rel="noopener ugc nofollow" target="_blank"> <strong class="le jo"> <em class="lz">精品课程</em> </strong> </a>。这是我开始的原因。一定要去看看。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="9d8b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae ly" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"> <strong class="le jo">中</strong> </a>跟踪我或订阅我的<a class="ae ly" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="le jo">博客</strong> </a>了解他们。和往常一样，我欢迎反馈和建设性的批评，可以在推特<a class="ae ly" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">@ mlwish it</a>上找到。</p></div></div>    
</body>
</html>