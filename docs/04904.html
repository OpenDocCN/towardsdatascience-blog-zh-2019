<html>
<head>
<title>How to get an unbiased RNG from an unbalanced one</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从一个不平衡的 RNG 得到一个无偏的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-get-an-unbiased-rng-from-an-unbalanced-one-dbb44850e5f7?source=collection_archive---------13-----------------------#2019-07-24">https://towardsdatascience.com/how-to-get-an-unbiased-rng-from-an-unbalanced-one-dbb44850e5f7?source=collection_archive---------13-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a8ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中的一个随机抽取器，适用于从倾斜的硬币到莎士比亚</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/636a9ee1e2871c4ebb94f4b089501d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXGp4kXEtFX0oqq7sXEKDw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Stars, quasars, and other celestial objects generate photons in a random way that can be used to generate random numbers</figcaption></figure><blockquote class="ky"><p id="dba6" class="kz la it bd lb lc ld le lf lg lh li dk translated">"当然，任何考虑用算术方法产生随机数的人都是有罪的."<br/> —约翰·冯·诺依曼</p></blockquote><p id="1687" class="pw-post-body-paragraph lj lk it ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md li im bi translated">有可能从一枚不公平的硬币中获得公平的投掷吗？或者，一般来说，是否有可能从具有非均匀分布输出的源中提取随机性？还是从任何一种文字中？也就是说，<strong class="ll iu">我们怎样才能平衡不平衡呢？</strong></p><p id="fba7" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">假设我们有一枚硬币正面朝上的概率是 30%。你能使用这样一枚硬币(以任何你想要的方式，但只有这枚硬币)并期望总是有 50%的机会得到正面或反面吗？</p><p id="3487" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这里是一个简单的 Python lambda 函数，它定义了不偏不倚的硬币的投掷:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/fee75d56794c91921b86c4b6841305f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ib6WfDG3AnV2cIMwJmlYhA.png"/></div></div></figure><p id="9085" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">头部编码为“0”，尾部编码为“1”，所以<em class="mk"> flip_a_biased_coin() </em>实际上是一个非平衡二进制随机生成器。</p><p id="8245" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">现在让我们定义函数<em class="mk"> flip_the_coin() </em>，该函数必须使用<em class="mk"> flip_a_biased_coin() </em>才能创建一个均匀分布的二进制生成器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/31fe5ce149edfcea2390dc05db03cc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJHRW1LhKxqbF3HVkyBMnw.png"/></div></div></figure><p id="7fe9" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">在求职面试中，我见过很多关于这个问题的答案，包括基于二叉树或哈希表的怪异策略，以及过度设计的决策算法。</p><p id="5bb8" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">但是解决方案更简单。你要做的就是玩…</p><h1 id="13fe" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">可能性</h1><p id="7cb4" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">用<em class="mk"> flip_a_biased_coin() </em>得到连续两个“0”的概率是多少？我们把这个概率命名为<strong class="ll iu"> <em class="mk"> p </em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8a52e69fca2a9fdd946588f1c1ec5ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*1pnFNoORH96VHvwjGqDvrg.png"/></div></figure><p id="73e2" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">连续得到两个“1”的概率是多少？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5a5dbff07e1caacbbc258f1950ab26bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*Gsz_tyfQUUoBaQ5wP5jBMw.png"/></div></figure><p id="5da0" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">好吧…这些概率好像没啥用。但是得到一个“01”或者“10”序列的概率有多大呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/bc4dd92839d8eb7eaa0faf3187577145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyoeUyploIJ7QNT891mUIg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/240b5c7122b553b67512bc1ad118d70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIkKRoGWPJrf_JiRUjvDLw.png"/></div></div></figure><p id="29c8" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">最后一丝平衡！</p><p id="9176" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><em class="mk"> flip_a_biased_coin() </em>输出一个“01”序列或“10”序列，概率相同:21%。</p><p id="301b" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">为了利用这一特性，每个“01”序列都被编码为“0 ”,或者换句话说，每次抛两次硬币，先投正面，然后投反面，结果是正面。反之亦然,“10”序列被编码为“1 ”,也就是说，每次抛两次硬币，一次是正面，一次是反面。</p><p id="d280" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">可以简化说，每两次投掷，如果结果不同，返回第一次；否则继续抛硬币两次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/e29c3dbca212dbec79b96839b9748779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mTGQldefjlhysiJ_Z9gPg.png"/></div></div></figure><p id="63be" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这是一个完美平衡的随机发生器！</p><p id="3dad" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">您可以粗略地检查这种发电机的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/278d1087e276c90b831d35f5a9937ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YluuA96_BNIzRetjym_o1A.png"/></div></div></figure><p id="1953" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><code class="fe nl nm nn no b">Number of 0s: 495 <br/>Number of 1s: 505</code></p><h1 id="b570" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">另一个有趣的属性</h1><p id="adfa" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">你可以用这种方法作为随机抽取器来抽取任意序列的比特！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c2d3b17afe558ad5cdee1686cf731258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*A-WG8b8BXZaE7z9QGNknbQ.jpeg"/></div></figure><p id="0513" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">例如，让我们用二进制编码莎士比亚戏剧《罗密欧与朱丽叶》第二幕第二场最著名的部分:</p><blockquote class="nq nr ns"><p id="9fcd" class="lj lk mk ll b lm me ju lo lp mf jx lr nt mg lu lv nu mh ly lz nv mi mc md li im bi translated">噢，罗密欧，罗密欧！你为什么是罗密欧？否认你的父亲，拒绝你的名字。<br/>或者，如果你不愿意，只要你发誓做我的爱人，我就不再是凯普莱特家族的人了。</p><p id="2ed1" class="lj lk mk ll b lm me ju lo lp mf jx lr nt mg lu lv nu mh ly lz nv mi mc md li im bi translated">100111111000001010010111111110111101111011001000010011011111111110111101110111001111001110111001111111001111111111111000111111101111111111111111111111111111111100……共 1040 位</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/be63707eeb0bb6b57a9095772a7d2898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cs_R6FVp2txc4VY1zoCXTA.png"/></div></div></figure><p id="ed5c" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">我们可以通过使用为<em class="mk"> flip_the_coin() </em>函数所采用的相同策略，以诗意的方式提取具有均匀分布的比特序列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/80df31c01e29b8fc073487e6f49ddf53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QfkOOwTilXfCayFjtvNrQ.png"/></div></div></figure><p id="d0f8" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">对于每一对比特，如果比特不同，则打印第一个比特；否则不会打印任何内容。这就是结果:</p><blockquote class="nq nr ns"><p id="2870" class="lj lk mk ll b lm me ju lo lp mf jx lr nt mg lu lv nu mh ly lz nv mi mc md li im bi">100010101111110010110000000010010010001100100111100000111001010111111010000101110110101000100100010001011001000001010011101101110100001000100110000001110001110011001100100100001100111001110110101011010011111110010100101100110101001011100100101111011</p></blockquote><p id="c6ed" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这个序列是从原始的 1040 位中提取出来的，包含 130 个“0”和 119 个“1”，这意味着有 52%的概率得到“0”(或头部)，有 48%的概率得到“1”(或尾部)。</p><p id="4fbd" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">🎲你能找到一个装骰子的策略吗？🎲</strong></p><p id="9a78" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">对于这种简单的算法来说，这确实很好，但是您可以注意到，该算法丢弃了 1040 位中的 791 位，导致了大约 76%的拒绝率…非常糟糕！</p><p id="81e0" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">还能改进吗？</p><h1 id="37fe" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">熵的浪费</h1><p id="6f7b" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated"><em class="mk"> flip_the_coin() </em>和<em class="mk">debias _ Romeo _ and _ Juliet()</em>使用的原始策略在产生一个比特之前丢弃了许多比特。</p><p id="a2f5" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">如前所述，丢弃一个“00”序列(或两个头)的概率是<strong class="ll iu"><em class="mk"/></strong>，丢弃一个“11”序列(或两个尾)的概率是<strong class="ll iu"><em class="mk">【1-p】</em></strong>。这意味着期望拒绝率<strong class="ll iu"> <em class="mk"> rej(p) </em> </strong>为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/37f095d0c59ce6837e92ac8382e376ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHb-dmVXPYp5ImJ-4IIWiQ.png"/></div></div></figure><p id="290e" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这意味着</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4f9a9023908483cfd6d7c6de5e89bf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:212/format:webp/1*4ZtCRxz1i4bjKB2NSIVYdg.png"/></div></figure><p id="ec4a" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">换句话说，考虑到硬币已经平衡的最佳情况，一半的硬币投掷将被丢弃。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/6cec1bc093f9290f51ad85c8bff2c977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxT6EMtm74LIWYu889d0Lw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">graph as a function of <strong class="bd nz">p</strong> (x axis) and <strong class="bd nz">rej</strong> (y axis)</figcaption></figure><p id="0831" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">实际上，我们浪费了大量可以从序列中提取的“随机性”,使我们的输出变得更短，或者需要一个必须生成很长比特序列的源！</p><p id="8d59" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">因此，这个简单的策略似乎能完成任务，但远非最佳。该算法没有以任何方式使用其浪费的“00”和“11”序列。</p><p id="edb2" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">让我们想办法使用它们吧！</p><h1 id="56f4" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">简单有效的方法</h1><p id="77eb" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">主要概念是重新使用“00”和“11”序列，并在进一步的提取循环中将它们转换成新的“0”和“1”序列。</p><p id="76ac" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">新策略将通过使用两个不同的来源递归地回收“浪费的随机性”:序列“丢弃/非丢弃”(即<em class="mk"> discard_seq </em>)和丢弃对的值(“00”编码为“0”，“11”编码为“1”，即<em class="mk"> new_seq </em>)。直觉上，它依赖于这样一个事实，即给定已经生成的序列，这两个源仍然是可交换的比特序列，因此有资格进行另一轮提取。</p><p id="9937" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">让我们看一个输入“10011011”的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9f14adca74afa91218f475379e20d08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sX1YbT3xdY446tDveSj4jQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Step 1 with initial input</figcaption></figure><p id="f175" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">根据初始输入，我们计算 3 个序列:</p><ul class=""><li id="1eca" class="ob oc it ll b lm me lp mf ls od lw oe ma of li og oh oi oj bi translated"><em class="mk"> discard_seq </em>:如果初始输入没有被<em class="mk"> flip_coin() </em>丢弃，则每一位为“1”，否则为“0”。这个序列将被相同的策略递归地重复使用。</li><li id="06f7" class="ob oc it ll b lm ok lp ol ls om lw on ma oo li og oh oi oj bi translated"><em class="mk"> new_seq </em>:将“00”映射成“0”，将“11”映射成“1”。这个序列将被相同的策略递归地重复使用。</li><li id="bb9c" class="ob oc it ll b lm ok lp ol ls om lw on ma oo li og oh oi oj bi translated">简单的<em class="mk">抛硬币</em>:这是我们在文章中使用的第一个策略。这将不会被重复使用，是最终输出的一部分。</li></ul><p id="c9d4" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">图像中使用的颜色将被重新用作后续步骤的参考(相同的颜色，相同的来源)。</p><p id="6359" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">现在我们继续第 2 步，使用<em class="mk"> discard_seq </em>作为输入:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c25baaf267fd3902f246c83240611f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*yXETh11GMDqRJXYlRvTVew.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Step 2 with discard_seq from Step 1 as input</figcaption></figure><p id="453b" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这里我们还有 3 个新的序列，它们具有与上一步完全相同的属性。请注意，当没有产生输出时，会出现一个红色的<strong class="ll iu"> X </strong>。</p><p id="afae" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">现在我们以同样的方式将此步骤的<em class="mk"> discard_seq </em>用于下一步(步骤 2.1):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9ef167d35763b47430f81adb5c7261e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*DrYEWh9JjLwrzqayIt9fyw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Step 2.1 with discard_seq from Step 2 as input</figcaption></figure><p id="fb9c" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">如上所述，该算法创建了 3 个新序列，其中 2 个被递归地重复使用，然后以固定顺序相互连接。当每个计算步骤都没有输出时，该过程结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/debeeaa95a3f1a438a3a79071d25b657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8w32QAEp-Nrf3f3tAy0E1w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">In one image, Step 2.1.1 with discard_seq from Step 2.1, Step 2.2 with new_seq from Step 2 and Step 3 with new_seq from Step 1</figcaption></figure><p id="6dda" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">从步骤 2.1 我们可以只使用一个“1”，我们不能从中提取随机性，因为没有熵了，对于步骤 2.2 和 3 也是一样。</p><p id="084c" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这里是每一步算法的递归可视化，以便让您更好地了解该过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/8c10e5e996990c6ff04be7fedb678bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*-a6nUSViQm6399-9ja5_6Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">A visual diagram with the step executed with input “10011011”</figcaption></figure><p id="e00e" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">最终的结果是“10110”，而简单的<em class="mk"> flip_coin() </em>在相同的输入下只会产生“101”！现在让我们来看一个快速的 Python 实现，名为<em class="mk"> better_flip_coin() </em>函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/aa136ba7f1f6a5efc364be2364a3b049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2g1OnNC5qUiaNro9pMyog.png"/></div></div></figure><p id="14fa" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">您会注意到，如果一个序列的位数为奇数，最后一位将被丢弃。该函数返回一个列表并直接对列表进行操作:一个用于经典的<em class="mk"> flip_coin() </em>，一个用于<em class="mk"> new_seq </em>，一个用于<em class="mk"> discard_seq </em>。</p><p id="1329" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">好了，现在我们已经完成了作业，我们可以使用所学的知识并将其应用于…</p><h1 id="6d39" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">第二幕，第二场…算法反击了</h1><p id="f2e3" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">这里是相同的函数，但是应用于一个字符串位序列(注意 better_flip_coin()生成的是字符串位列表，而不是位列表):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f45c8972bd845520bf2ef7bf2434a01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fnOtP-i8hQ_OhfHR9Tktg.png"/></div></div></figure><p id="1dfe" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">结果非常有希望:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/37a6827ddce999f935d54c1498c4ec9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_J5M9NqF7kgBG1JszJeLA.png"/></div></div></figure><p id="2b01" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><code class="fe nl nm nn no b">Number of extracts bits: 893<br/>Number of 0s: 450<br/>Number of 1s: 443</code></p><p id="9b37" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这意味着我们刚刚丢弃了 147 位，这意味着丢弃率仅为 15%！甚至分布似乎更好，得到“0”(头)的概率为<strong class="ll iu"> 50.39% </strong>，得到“1”(尾)的概率为<strong class="ll iu"> 49.61% </strong>！！！</p><p id="7911" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">现在让我们检查每对比特(或每对掷硬币)由两种算法产生的比特的平均值<strong class="ll iu"><em class="mk">(p)</em></strong>。</p><p id="3561" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">我们已经发现<em class="mk"> flip_coin() </em>的拒绝率是<br/><strong class="ll iu"><em class="mk">rej(p)= 1–2p(1-p)</em></strong>，因此平均<strong class="ll iu"><em class="mk">ā(p)</em></strong>只是它的“互补”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/4f8475bb9b5a87896a88d34df23e77d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*X8SP4TkAreaKNWBoaxOcLw.png"/></div></figure><p id="a405" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">为了计算<em class="mk"> better_flip_coin() </em>的平均值<strong class="ll iu"><em class="mk">ā’【p】</em></strong>，需要进行非平凡的分析，但是可以证明</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/f5d5f25365f71a598eda6444f4b3c98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*a-W5FYl_3kWP6r_xhFvuVw.png"/></div></figure><p id="ab91" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">我不打算在这里写演示，因为它很长。</p><p id="537d" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">注意，描述由<em class="mk"> better_flip_coin() </em>产生的平均比特的函数等于<a class="ae ow" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)" rel="noopener ugc nofollow" target="_blank">熵函数</a>的定义！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/f30b8d6305332f753314cc84bbff86cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuzksInQ8YjBDbs9R8_8PA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">two graphs as function of <strong class="bd nz">p</strong> (x axis) and the average of bits produced by each algorithm (y axis)</figcaption></figure><p id="90d4" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这意味着<em class="mk"> better_flip_coin() </em>函数本质上是你能得到的最好的！如果源已经具有均匀分布，则该算法将为来自源的每个被处理的比特产生 1 个比特。</p><p id="3758" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">感谢你阅读这篇文章(或者至少感谢你来到这里)。<br/> <strong class="ll iu">让我知道你对这篇文章的看法，以及是否有人可以将<em class="mk"> flip_coin() </em>策略应用到一个已装载的骰子上！</strong></p></div></div>    
</body>
</html>