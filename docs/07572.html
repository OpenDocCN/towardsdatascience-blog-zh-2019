<html>
<head>
<title>Building RESTful APIs in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Golang 中构建 RESTful APIs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-restful-apis-in-golang-e3fe6e3f8f95?source=collection_archive---------10-----------------------#2019-10-22">https://towardsdatascience.com/building-restful-apis-in-golang-e3fe6e3f8f95?source=collection_archive---------10-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5da6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:这最初发布在</em><a class="ae kp" href="https://martinheinz.dev/blog/8" rel="noopener ugc nofollow" target="_blank"><em class="ko">martinheinz . dev</em></a></p><p id="58c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一篇文章中，我们讨论了如何为你的<em class="ko"> Golang </em>项目创建<em class="ko">“终极”</em>设置，现在是时候将它应用到真实的东西上了——RESTful API。这篇文章将涵盖数据库、单元测试、API 测试、示例应用程序以及实际项目中你需要的一切。所以，让我们直接开始吧。</p><p id="a0cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这篇文章是这些系列文章<a class="ae kp" rel="noopener" target="_blank" href="/ultimate-setup-for-your-next-golang-project-1cc989ad2a96?source=friends_link&amp;sk=2be68bb1ae993c17afc7d5c39a8be909">的后续文章，为你的下一个 Golang 项目</a>最终设置，所以如果你没有读那篇文章，那么你可能想先看看。</p><p id="1df0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">TL；DR:这里是我的资源库(</em> <code class="fe kq kr ks kt b"><em class="ko">rest-api</em></code> <em class="ko">分支)-</em><a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://github . com/Martin Heinz/go-project-blue print/tree/rest-API</em></a></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/dfe9817c2e4caeeea82aa317c8a0646c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*hV308VnNWS1xlrSaztOHkw.png"/></div></figure><h1 id="6ef2" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">框架和库</h1><p id="3ec4" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">首先，我们要用什么来建造它？</p><ul class=""><li id="b15f" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><em class="ko"> Gin </em> —我们将使用<em class="ko"> Gin </em> HTTP web 框架。它是构建在<code class="fe kq kr ks kt b">net/http</code>之上的高性能框架，提供了最基本的特性、库和必要的功能。它也有相当干净和全面的 API。</li><li id="82f1" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">GORM  —是在<code class="fe kq kr ks kt b">database/sql</code>之上开发的<em class="ko"> Golang </em> ORM 库。它包括所有奇特的功能，如预加载、回调、事务等。它有一些学习曲线，没有那么好的文档，所以如果你是那种喜欢写原始 SQL 的人，那么你可以选择<code class="fe kq kr ks kt b">sqlx</code>。</li><li id="453c" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">Viper — <em class="ko"> Go </em>配置库，可以处理各种格式、命令行标志、环境变量等。这个库的设置和使用已经在之前的帖子<a class="ae kp" rel="noopener" target="_blank" href="/ultimate-setup-for-your-next-golang-project-1cc989ad2a96?source=friends_link&amp;sk=2be68bb1ae993c17afc7d5c39a8be909">这里</a>解释过了，所以我就不在这里赘述了。</li></ul><h1 id="760f" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">项目和包结构</h1><p id="d42c" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">接下来，让我们检查项目中的单个包。除了<code class="fe kq kr ks kt b">main</code>还有以下包，每个包都有单独的责任。让我们从数据库开始，通过查询，一直到 API 端点:</p><h2 id="fcbb" class="mt ld it bd le mu mv dn li mw mx dp lm kb my mz lq kf na nb lu kj nc nd ly ne bi translated">模型</h2><p id="d943" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">模型包(<code class="fe kq kr ks kt b">models</code>)有一个文件，它定义了反映数据库表结构的类型。在存储库中的例子中，有两个<code class="fe kq kr ks kt b">struct</code>类型- <code class="fe kq kr ks kt b">Model</code>和<code class="fe kq kr ks kt b">User</code>:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b62b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kq kr ks kt b">Model</code>是与<code class="fe kq kr ks kt b">gorm.Model</code>相同的类型，只是增加了 json 标签，使得生成包含其字段的 JSON 响应更加容易。其次，<code class="fe kq kr ks kt b">User</code>用<em class="ko"> GORM </em>标签描述了简单的应用程序用户，这些标签指定了字段应该与哪一列相关联。还有很多标签，比如索引、类型或关联，你可以在这里<a class="ae kp" href="http://gorm.io/docs/models.html" rel="noopener ugc nofollow" target="_blank">找到更多。</a></p><h2 id="5dd3" class="mt ld it bd le mu mv dn li mw mx dp lm kb my mz lq kf na nb lu kj nc nd ly ne bi translated">数据访问对象</h2><p id="31c2" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">接下来是<code class="fe kq kr ks kt b">daos</code>包，是<em class="ko">数据访问对象</em> ( <em class="ko"> DAOs </em>)的简称。<em class="ko">道</em>是一个负责访问数据的对象(惊喜，惊喜...)，这实质上意味着它使用<em class="ko"> GORM </em>或原始 SQL 进行 SQL 查询。在下面的例子中，我们有一个简单的函数，它根据 ID 检索用户数据，并以前面提到的<code class="fe kq kr ks kt b">User</code>模型的形式连同错误(如果有的话)一起返回:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="10e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以根据 Dao 访问的表、相似的业务逻辑或者您想要的任何其他指标来分离 Dao，但不要将它们混为一谈，否则会变得一团糟。</p><h2 id="824e" class="mt ld it bd le mu mv dn li mw mx dp lm kb my mz lq kf na nb lu kj nc nd ly ne bi translated">服务</h2><p id="9f28" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">当我们将数据很好地加载到模型中时，我们可以在提供数据之前执行额外的逻辑来处理数据，这就是<em class="ko">服务</em>发挥作用的地方。这个额外的逻辑可以是例如过滤、聚集、修改结构或验证数据。最重要的是，它允许我们将数据库查询从业务逻辑中分离出来，这使得代码更干净、更易于维护，最重要的是(对我来说)更易于测试(稍后将详细介绍)。所以，让我们看看代码:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="44bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们首先定义了 interface，它将所有之前创建的<em class="ko"> DAO </em>函数组合在一起，在本例中只是来自前面部分的<code class="fe kq kr ks kt b">Get(id uint)</code>。接下来，我们定义<em class="ko">用户</em>服务，它包含我们的<em class="ko"> DAO </em>和一个使用作为参数提供的<em class="ko"> DAO </em>创建它的函数。最后，我们定义一个函数，它可以执行一些额外的逻辑，并使用来自<code class="fe kq kr ks kt b">UserService</code>的<em class="ko"> DAO </em>，然而，这里为了简单起见，我们只使用<em class="ko"> DAO </em>为用户查询数据库并返回它。此处可以执行的逻辑示例将是模型验证或错误检查。</p><h2 id="2b6f" class="mt ld it bd le mu mv dn li mw mx dp lm kb my mz lq kf na nb lu kj nc nd ly ne bi translated">蜜蜂</h2><p id="c14b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">最后，有了准备好为我们提供经过处理的有效数据的服务，我们可以将它们提供给我们的用户。那么，让我们看看代码:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0c5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个代码片段中，我们可以看到可用于服务 API 端点的函数。这里，我们首先用提供的用户<em class="ko"> DAO </em>创建服务，这在前面已经描述过了。接下来，我们解析 ID，我们希望它在 URL 中(类似于— <code class="fe kq kr ks kt b">/users/{id}</code>)，然后我们使用服务从数据库中获取用户数据，最后，如果找到数据，我们以 JSON 格式返回它，并带有<code class="fe kq kr ks kt b">200</code>状态代码。</p><h2 id="a598" class="mt ld it bd le mu mv dn li mw mx dp lm kb my mz lq kf na nb lu kj nc nd ly ne bi translated">将它们连接在一起</h2><p id="bb93" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">前几节中展示的东西都很好，但是现在我们实际上需要在<code class="fe kq kr ks kt b">main</code>中设置它，以便<em class="ko"> Gin </em>知道在哪里提供我们的 API:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="593c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，我们首先需要创建<em class="ko"> Gin </em>的实例，然后我们将中间件附加到它上面，例如记录器或<em class="ko"> CORS </em>。最后一部分——也是最重要的一部分——我们创建了一组端点，这些端点都以<code class="fe kq kr ks kt b">api/v1/</code>开始，并注册我们上一节中的<code class="fe kq kr ks kt b">GetUser</code>函数，该函数将在<code class="fe kq kr ks kt b">/api/v1/users</code>处专门提供服务，然后是用户 ID 参数，就这样，现在我们可以运行我们的应用程序了！</p><p id="0180" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时你可能会想<em class="ko">“为什么要创建所有的包、单独的文件、函数层等等？”</em> —好吧，答案是——如果你的应用程序足够大，那么如果你把所有东西都集中在一起，这将成为可维护性的噩梦，而且——在我看来，更重要的是——这种分离对于更好的可测试性是必要的，因为单独测试每一层——数据库访问、数据操作和 API——比在一个地方测试要容易得多。所以，当我们谈到测试的话题时，我想是时候写一些…</p><p id="e485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:在上面的代码片段中，为了清楚起见，我省略了几行代码和注释，比如连接到数据库或加载配置，这些可以在资源库</em> <a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/blob/rest-api/cmd/blueprint/main.go" rel="noopener ugc nofollow" target="_blank"> <em class="ko">这里</em> </a> <em class="ko">中找到，包括一些更多的注释用于解释。</em></p><h1 id="58ae" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">测试一切</h1><p id="658e" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">现在，对于我最喜欢的部分——测试——让我们从<code class="fe kq kr ks kt b">test_data</code>包开始。这个包包含与测试数据库和测试数据相关的实用函数。这个包中我想注意的一个函数是<code class="fe kq kr ks kt b">init</code>:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f282" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该功能比较特殊，因为<em class="ko"> Go </em>在导入包时执行。这是设置测试的好地方——更具体地说，我们首先加载配置，然后创建我们的测试数据库，它是内存中的 SQLite，我们还为它启用了外键。最后，我们使用<em class="ko">GORM</em>T0】函数创建数据库表。</p><p id="dba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问<em class="ko">“为什么使用 SQLite 内存数据库，不是更好吗？”</em>——是的，我自己在每个项目中都使用<em class="ko"> PostgreSQL </em>，但是当涉及到测试时，您需要一致、快速(<em class="ko">内存中</em>)并且独立于主机系统/数据库服务器的东西，这正是本设置所提供的。</p><p id="a2ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会重复这个包的剩余功能，因为这篇文章已经很长了，它们在这里的代码<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/blob/rest-api/cmd/blueprint/test_data/init.go" rel="noopener ugc nofollow" target="_blank">中有记录。</a></p><p id="1e78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了初始化函数之外，我们还在这个包中存储了一些数据，即包含 SQL 插入的<code class="fe kq kr ks kt b">db.sql</code>文件，这些 SQL 插入在运行测试之前填充了我们的<em class="ko"> SQLite </em>数据库，还有 JSON 测试用例，它们被用作 API 端点的预期输出。</p><p id="3331" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经设置好了，让我们检查一下每个包中的测试:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5f8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，<code class="fe kq kr ks kt b">daos</code>，上面的测试非常简单，我们只需创建<em class="ko"> DAO </em>并调用被测函数(<code class="fe kq kr ks kt b">Get</code>)并根据期望值进行测试，这些都是在设置过程中插入到<em class="ko"> SQLite </em>数据库中的，其他的就没什么可说的了。让我们继续看<code class="fe kq kr ks kt b">services</code>:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5922" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是相当多的一点代码，让我们从下往上看。我们首先需要的是模拟<em class="ko">道</em> ( <code class="fe kq kr ks kt b">mockUserDAO</code>)，这样我们就独立于真正的<em class="ko">道</em>的实现了。为了让这个模拟有用，我们需要用一些测试数据填充它，这就是在<code class="fe kq kr ks kt b">newMockUserDAO</code>中发生的事情。接下来，我们还需要定义模仿真实版本的<code class="fe kq kr ks kt b">Get</code>的模拟版本——在这里，我们不需要查询数据库，只需查看假记录，如果发现提供的 ID，就返回一个。</p><p id="da3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，对于实际的测试——我们创建了<code class="fe kq kr ks kt b">NewUserService</code>,但是我们没有传入真正的<em class="ko"> DAO </em>,而是使用具有可预测行为的模拟，因此我们能够将测试中的函数与底层的<em class="ko"> DAO </em>隔离开来。之后，测试就非常简单了——我们使用 mock <code class="fe kq kr ks kt b">Get</code>方法，测试插入到 mock 中的预期值是否存在。</p><p id="1076" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后要测试的是 API，这些测试实际上是一行程序，但是我们需要做一点准备:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="65b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的这 3 个函数模拟 HTTP 请求，用于我们的测试目的。首先在测试模式下创建<em class="ko"> Gin </em>并重置数据库。第二个服务并随后命中特定的 API 端点，最后一个运行测试用例列表并检查状态代码是否相同，并且可选地检查 JSON 输出是否也相同。现在，让我们看看测试用例的例子:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b4d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参数很多，但很简单，让我们一个一个来看:</p><ul class=""><li id="1494" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">"t1 - get a User"</code> -测试用例的名称-编号，这样在调试时更容易找到</li><li id="e3f0" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">"GET"</code> - HTTP 方式</li><li id="a33b" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">"/users/:id"</code> -正在服务/测试的 URL</li><li id="abbb" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">"/users/1"</code> -被点击的 URL 带有填充的参数</li><li id="39a5" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">""</code> -请求体-在本例中为空</li><li id="a582" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">GetUser</code> -附加到端点的方法</li><li id="3ac0" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">http.StatusOK</code> -预期状态代码-此处为<code class="fe kq kr ks kt b">200</code></li><li id="cbd6" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe kq kr ks kt b">path + "/user_t1.json"</code> -预期 JSON 输出的路径——这些存储在前面提到的<code class="fe kq kr ks kt b">test_data</code>包中</li></ul><h1 id="e0cb" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="3590" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">就这样——在<em class="ko"> Golang </em>中创建 RESTful API 所需要的一切。希望在构建您的下一个项目时，这些内容至少会对您有所帮助。您可以在这里找到所有源代码<a class="ae kp" href="https://github.com/MartinHeinz/go-project-blueprint/tree/rest-api" rel="noopener ugc nofollow" target="_blank"/>，如果您有任何建议或改进，请随意创建问题、拉式请求或直接分叉/启动存储库。如果您喜欢这篇文章，请寻找下一篇，在那里我将展示如何将<em class="ko"> Swagger </em>文档添加到这个项目中。</p></div></div>    
</body>
</html>