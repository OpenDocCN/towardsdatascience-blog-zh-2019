<html>
<head>
<title>How to master Python’s main data analysis library in 20 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 20 分钟内掌握 Python 的主要数据分析库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-master-pandas-8514f33f00f6?source=collection_archive---------1-----------------------#2019-09-12">https://towardsdatascience.com/how-to-master-pandas-8514f33f00f6?source=collection_archive---------1-----------------------#2019-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6160" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">熊猫终极指南——第一部分</h2><div class=""/><div class=""><h2 id="73c4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">熊猫基本功能的代码指南。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fabebf25a7fad6c0fbd751e62d0628b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qcqYt1wH5OePFDMr"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@itookthose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sid Balachandran</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="14fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文阐述了有抱负的数据科学家和数据分析师经常面临的典型问题和挑战。我们将通过利用 Python 最强大的数据操作和分析库<strong class="lk jd"> Pandas </strong>来解决这些问题和应对这些挑战。</p><h2 id="b936" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">在本文中，我们将讨论以下主题:</h2><ol class=""><li id="7cd7" class="mw mx it lk b ll my lo mz lr na lv nb lz nc md nd ne nf ng bi translated"><a class="ae lh" href="#95a4" rel="noopener ugc nofollow">设置</a></li><li id="692c" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><a class="ae lh" href="#5813" rel="noopener ugc nofollow">加载数据</a></li><li id="bf96" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><a class="ae lh" href="#71ac" rel="noopener ugc nofollow">检查/分类/过滤数据</a></li><li id="570e" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><a class="ae lh" href="#a364" rel="noopener ugc nofollow">分析功能</a></li></ol><p id="75bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里找到完整的 Jupyter 笔记本。但是我强烈建议您亲自完成这些步骤。毕竟，熟能生巧。</p><h2 id="1acb" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">先决条件:</h2><p id="97b3" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">一个工作的 Python 环境(我建议 Jupyter 笔记本)。如果你还没有设置这个，不要担心。在上周的文章中，我们讨论了如何设置 Anaconda，并解释了如何打开您的第一个 Jupyter 笔记本。如果你还没有这样做，看看链接的文章。做好一切准备只需不到 10 分钟。</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/get-started-with-python-e50dc8c96589"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">所以你想成为一名数据科学家？</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">到底是什么阻止了你？下面是如何开始！</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og lb ns"/></div></div></a></div></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="b1ed" class="oo mf it bd mg op oq or mj os ot ou mm ki ov kj mp kl ow km ms ko ox kp mv oy bi translated">1.设置</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/4f7c471b76c31ced4b0fe1edc1b37d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OC9kc-lkqEQlgVWm"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@vania_zhu1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ivan Zhukevich</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="95a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在进行任何数据操作之前，我们先获取一些数据。我们将使用 2019 年世界幸福报告中的数据。我将提供一个稍微调整过的原始数据版本，其中也包括各大洲。</p><p id="38e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个<a class="ae lh" href="https://github.com/FBosler/you-datascientist" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>保存数据和代码。如果不熟悉 GitHub，还可以<strong class="lk jd">从这个</strong> <a class="ae lh" href="https://github.com/FBosler/you-datascientist/archive/master.zip" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">链接</strong> </a> <strong class="lk jd">下载一个打包的 zip 文件！</strong>解压文件并将内容(尤其是<code class="fe pa pb pc pd b">happiness_with_continent.csv</code>)移动到 Jupyter 笔记本所在的文件夹中(如果还没有，创建一个)。</p><p id="d338" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在新笔记本中运行<code class="fe pa pb pc pd b">import pandas as pd</code>(即，将 Pandas 库导入到工作簿中，以访问这些功能。</p><p id="73f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我喜欢这样调整我的笔记本设置:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="e9b9" class="me mf it pd b gy pi pj l pk pl">from IPython.core.display import display, HTML<br/>display(HTML("&lt;style&gt;.container {width:90% !important;}&lt;/style&gt;"))</span></pre><p id="cd82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些命令使笔记本变得更宽，从而利用屏幕上的更多空间(通常笔记本有固定的宽度，这与宽屏很不一样)。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="5522" class="oo mf it bd mg op oq or mj os ot ou mm ki ov kj mp kl ow km ms ko ox kp mv oy bi translated">2.加载数据</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/7fec113a7953ef1bc8861f354b3325bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y88AAjoraSA8_Adu"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5813" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Pandas 将数据存储为序列(一列)或数据帧(一列或多列)，后者只是一个或多个序列的组合。</p><p id="c54a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>每当我们用以下加载函数之一加载数据时，结果将存储在 DataFrame 中。</p><h2 id="2116" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">pd.read_csv</h2><p id="6330" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">对我来说，加载数据的主要方式是熊猫。它完全符合我对数据的思考方式，那就是大量的表格。</p><p id="8fda" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以像这样从本地文件加载数据<strong class="lk jd">:</strong></p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="b1d0" class="me mf it pd b gy pi pj l pk pl">data = pd.read_csv('happiness_with_continent.csv')</span></pre><p id="0186" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者您可以从 web 直接读取数据<strong class="lk jd">到数据帧中，如下所示:</strong></p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="1f1f" class="me mf it pd b gy pi pj l pk pl">data = pd.read_csv('<a class="ae lh" href="https://raw.githubusercontent.com/FBosler/you-datascientist/master/happiness_with_continent.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/you-datascientist/master/happiness_with_continent.csv'</a>)</span></pre><h2 id="a4df" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">从 Excel 或 Google 工作表</h2><p id="c5d7" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">从 Excel 中读取数据非常简单。Google Sheets 有点棘手，因为它要求你首先通过一个认证程序。你可以在这里阅读所有关于从 Excel 和 Google 工作表中提取数据的内容:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/replacing-sheets-with-python-f1608e58d2ca"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">用 Python 从各种工作表中提取数据</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">或者如何学习统一 Google 工作表、Excel 和 CSV 文件——代码指南</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="pn l od oe of ob og lb ns"/></div></div></a></div><h2 id="c135" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">pd.read_clipboard</h2><p id="b8df" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">这个我很少用，但是对于较小的表肯定有效。例如，只需标记并复制(ctrl+c)Google sheets 中的一个表格，然后运行<code class="fe pa pb pc pd b">pd.read_clipboard()</code>。</p><p id="5a68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">示例:</strong>导航<a class="ae lh" href="https://docs.google.com/spreadsheets/d/1Wl3Ad_Y_izZM8J5UizPbAMuOZGpb2FzAZfbAJ-aU2Tc/edit#gid=779395260" rel="noopener ugc nofollow" target="_blank">此处</a>(我找到的第一个公共表单)并标记一个区域，如截图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/2fe7f233704e33c6b6de69a4029588f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Rwom6osoQVuXIfxIylYDw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">After hitting ctrl+c the data will be in your clipboard, you can now use pd.read_clipboard</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/b710fe271af597ddf66c42d848222024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bT2EomRtbuaDxJ4U8bTeXA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Running pd.read_clipboard on previously copied data with parameter index_col=’name’</figcaption></figure><p id="b51e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于 read_csv 的函数(和 read_clipboard)的一些值得注意的参数:</p><ul class=""><li id="5ae9" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">sep</code>:分栏符(默认为<code class="fe pa pb pc pd b">,</code>，也可以是 tab)</li><li id="a993" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">header</code>:默认为<code class="fe pa pb pc pd b">'infer'</code>(即熊猫猜测你的头是什么)，可选为整数或整数列表(多级名称)。例如，您可以做<code class="fe pa pb pc pd b">header=3</code>，数据帧将从第 4 行开始(因为 Python 是 0 索引的)作为标题。如果您的数据没有标题，请使用<code class="fe pa pb pc pd b">header=None</code></li><li id="8a28" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">names</code>:栏目名称。如果您想使用这个参数来覆盖 Pandas 推断出的任何列名，那么您应该指定<code class="fe pa pb pc pd b">header=0</code>(或者您的列名所在的行)，如果您不这样做，那么您的名称将作为列名，然后在第一行中显示原始的列名。<code class="fe pa pb pc pd b">names</code>参数需要一个列表，例如<code class="fe pa pb pc pd b">['your col 1', 'your col 2', ... 'your last col name']</code></li><li id="03e7" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">index_col</code>:设置加载时的索引(即我们将索引设置为<code class="fe pa pb pc pd b">name</code>)。稍后我们将了解更多关于索引的内容)</li><li id="f621" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">skiprows</code>:跳过前 x 行，当文件开头包含一些元数据，如作者和其他信息时，这很有用</li><li id="096b" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">skipfooter</code>:跳过最后 x 行，当文件末尾有元数据(例如脚注)时很有用</li><li id="a448" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">parse_date</code>:这个参数告诉熊猫，它应该把哪些列解释为日期(例如<code class="fe pa pb pc pd b">pd.read_csv(happiness_with_continent.csv,parse_dates=['Year'])</code>)。默认的解析器开箱即可正常工作。在遇到奇怪的数据格式时，Pandas 可以使用定制的日期解析器(为此，您必须指定解析逻辑)。</li></ul><p id="0d02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一堆额外的(很少使用的)参数。您可以通过在单元格中运行<code class="fe pa pb pc pd b">pd.read_csv?</code>来阅读这些内容(在命令后添加一个问号将打印帮助文本)。</p><p id="1377" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论我们如何读取数据，我们都希望将它存储在一个变量中。我们通过将读取结果赋给一个变量来实现，比如<code class="fe pa pb pc pd b">data = pd.read_clipboard()</code>或<code class="fe pa pb pc pd b">data = pd.read_csv('NAME_OF_YOUR_FILE.csv')</code></p><h2 id="b8c7" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">其他读取方法:</h2><p id="ed39" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">下面的阅读方法很少出现在我身上，但是在熊猫身上也实现了:</p><ul class=""><li id="1f61" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated">阅读 _ 羽毛</li><li id="9911" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_fwf</li><li id="0da1" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_gbq</li><li id="f550" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_hdf</li><li id="5736" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_html</li><li id="5cbd" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_json</li><li id="875e" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_msgpack</li><li id="f098" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">阅读 _ 拼花地板</li><li id="4087" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">阅读 _ 泡菜</li><li id="7d3e" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">读取 _sas</li><li id="c2e7" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">读取 _sql</li><li id="3c9f" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">读取 sql 查询</li><li id="9a5e" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">读取 sql 表</li><li id="2072" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">read_stata</li><li id="0cfc" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">读取 _ 表格</li></ul></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="455a" class="oo mf it bd mg op oq or mj os ot ou mm ki ov kj mp kl ow km ms ko ox kp mv oy bi translated">3.检查/分类/过滤数据</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/c77b1c808634e8cd35edfc5cde4067ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_ja1puOxEfKahFDk"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@maxboettinger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Böttinger</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="71ac" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">①检查—第一行、最后一行、随机行</h2><p id="3752" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在笔记本中显示数据有三种标准方式，<code class="fe pa pb pc pd b">head</code>、<code class="fe pa pb pc pd b">tail</code>和<code class="fe pa pb pc pd b">sample</code>。<code class="fe pa pb pc pd b">head</code>显示第一行，<code class="fe pa pb pc pd b">tail</code>显示最后一行，<code class="fe pa pb pc pd b">sample</code>显示随机选择的行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/db726faf06c708ed097b6c2fdf0883d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1r2PoDMYgTMgJ5nfxlh2Mw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.head(x) previews the first x rows of the data</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/e9d5b74e2fa225bd684466a3ba6abcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7HkeGsiH5q6ZVl0hu3ifg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.tail(x) previews the last x rows of the data</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/6f02a913a698fbee5f427fdb87de2375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0u9jaPMPOdYbLFz2pjFKcw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.sample(x) previews x randomly selected rows of the data</figcaption></figure><p id="350e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<code class="fe pa pb pc pd b">gini of household income reported in Gallop, by wp5-year</code>栏前有圆点。圆点表示存在未显示的列。要更改笔记本设置以显示更多列/行，请运行以下命令:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="a34c" class="me mf it pd b gy pi pj l pk pl">pd.set_option('display.max_columns', &lt;number of columns you want&gt;)<br/>pd.set_option('display.max_rows', &lt;number of rows you want&gt;)</span><span id="1f9b" class="me mf it pd b gy px pj l pk pl"># I typically use</span><span id="b733" class="me mf it pd b gy px pj l pk pl">pd.set_option('display.max_columns', 50)<br/>pd.set_option('display.max_rows', 8)</span></pre><p id="2924" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，请注意，您正在加载的文件通常非常大(1GB 以上),因此出于性能原因，不可能显示所有数据。因此，您应该尝试在更高的层次上熟悉数据，而不要依赖于直观地浏览行。</p><h2 id="7d3a" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">②检查—形状、列、索引、信息、描述</h2><p id="1b28" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated"><code class="fe pa pb pc pd b">data.shape</code>返回数据帧的尺寸。在我们的例子中，1704 行，27 列。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="5bb9" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.shape</span><span id="b451" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>(1704, 27)</span></pre><p id="324d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pa pb pc pd b">data.columns</code>返回数据帧中所有列名的列表。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="348b" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>data.columns</span><span id="0b3a" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:</strong><br/>Index(['Country name', 'Year', 'Life Ladder', 'Log GDP per capita',<br/>       'Social support', 'Healthy life expectancy at birth',<br/>       'Freedom to make life choices', 'Generosity',<br/>       'Perceptions of corruption', 'Positive affect', 'Negative affect',<br/>       'Confidence in national government', 'Democratic Quality',<br/>       'Delivery Quality', 'Standard deviation of ladder by country-year',<br/>       'Standard deviation/Mean of ladder by country-year',<br/>       'GINI index (World Bank estimate)',<br/>       'GINI index (World Bank estimate), average 2000-16',<br/>       'gini of household income reported in Gallup, by wp5-year',<br/>       'Most people can be trusted, Gallup',<br/>       'Most people can be trusted, WVS round 1981-1984',<br/>       'Most people can be trusted, WVS round 1989-1993',<br/>       'Most people can be trusted, WVS round 1994-1998',<br/>       'Most people can be trusted, WVS round 1999-2004',<br/>       'Most people can be trusted, WVS round 2005-2009',<br/>       'Most people can be trusted, WVS round 2010-2014',<br/>       'Continent'],<br/>      dtype='object')</span></pre><p id="f9b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pa pb pc pd b">data.index</code>返回关于索引的信息。我们将在排序和过滤部分更详细地讨论索引。把索引想象成行名/编号。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="28fd" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.index</span><span id="01c7" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>RangeIndex(start=0, stop=1704, step=1)</span></pre><p id="3c8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pa pb pc pd b">data.info()</code>返回有关数据帧中非空值观察的类型和数量的信息</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="fa34" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.info()</span><span id="f08e" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 1704 entries, 0 to 1703<br/>Data columns (total 27 columns):<br/>Country name                                                1704 non-null object<br/>Year                                                        1704 non-null datetime64[ns]<br/>Life Ladder                                                 1704 non-null float64<br/>Log GDP per capita                                          1676 non-null float64<br/>Social support                                              1691 non-null float64<br/>Healthy life expectancy at birth                            1676 non-null float64<br/>Freedom to make life choices                                1675 non-null float64<br/>Generosity                                                  1622 non-null float64<br/>Perceptions of corruption                                   1608 non-null float64<br/>Positive affect                                             1685 non-null float64<br/>Negative affect                                             1691 non-null float64<br/>Confidence in national government                           1530 non-null float64<br/>Democratic Quality                                          1558 non-null float64<br/>Delivery Quality                                            1559 non-null float64<br/>Standard deviation of ladder by country-year                1704 non-null float64<br/>Standard deviation/Mean of ladder by country-year           1704 non-null float64<br/>GINI index (World Bank estimate)                            643 non-null float64<br/>GINI index (World Bank estimate), average 2000-16           1502 non-null float64<br/>gini of household income reported in Gallup, by wp5-year    1335 non-null float64<br/>Most people can be trusted, Gallup                          180 non-null float64<br/>Most people can be trusted, WVS round 1981-1984             125 non-null float64<br/>Most people can be trusted, WVS round 1989-1993             220 non-null float64<br/>Most people can be trusted, WVS round 1994-1998             618 non-null float64<br/>Most people can be trusted, WVS round 1999-2004             491 non-null float64<br/>Most people can be trusted, WVS round 2005-2009             630 non-null float64<br/>Most people can be trusted, WVS round 2010-2014             671 non-null float64<br/>Continent                                                   1704 non-null object<br/>dtypes: datetime64[ns](1), float64(24), object(3)<br/>memory usage: 372.8+ KB</span></pre><p id="d63e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pa pb pc pd b">data.describe()</code>返回关于数据帧的数字列的一些描述性统计信息(计数、平均值、标准差、最小值、25%、50%、75%、最大值):</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/1ef63735695a89a057211366e8f75d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Fh047DPTmiy3Qg-iQV-Yg.png"/></div></div></figure><h2 id="ab22" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">①排序— data.sort_values()</h2><p id="7b50" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在没有参数的数据上调用<code class="fe pa pb pc pd b">sort_values</code>对我们没有任何好处。事实上，它将引发一个错误，告诉我们它缺少一个名为<code class="fe pa pb pc pd b">by</code>的参数。这个错误是有道理的。我们必须告诉熊猫我们想要按哪个(哪些)列排序。</p><p id="1697" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，我们可以按年份或年份和国家名称对数据进行排序，如下所示:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="db8d" class="me mf it pd b gy pi pj l pk pl">data.sort_values(by='Year')<br/>data.sort_values(by=['Year','Country name'])<br/>data.sort_values(by=['Country name','Year'])</span></pre><p id="7e49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>如果传递多个值，它会按照值的顺序按值排序。</p><p id="e368" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">默认情况下，排序将从“最低值”开始。然而，改变这种行为很容易。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="ad26" class="me mf it pd b gy pi pj l pk pl">data.sort_values(by='Year', ascending=True)</span><span id="378e" class="me mf it pd b gy px pj l pk pl">data.sort_values(<br/>  by=['Country name','Year'], <br/>  ascending=[False,True]<br/>)</span></pre><p id="2760" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong> Ascending 默认为真，即最小值优先，如果你想要最大值优先，你必须指定 ascending=False</p><h2 id="c32c" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">②排序— data.sort_index()</h2><p id="21c0" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">除了基于列的排序，还有基于索引的排序。按索引调用排序:<code class="fe pa pb pc pd b">data.sort_index()</code>或<code class="fe pa pb pc pd b">data.sort_index(ascending=False)</code>。第一个是升序，第二个是降序。</p><h2 id="c2d9" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">①过滤—列</h2><p id="17c3" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">排序固然很好，但我们通常关心的是数据的特定子集。有时您可能只想查看一列或多列。</p><p id="dda0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">选择一列:<br/> </strong>选择一个特定的列有两种方法。假设我们想要选择<code class="fe pa pb pc pd b">Year</code>列。我们可以选择:</p><ul class=""><li id="6c7f" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">data['Year']</code>，或者</li><li id="839c" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b">data.Year</code>(不使用这种方法)</li></ul><p id="dcde" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两者做同样的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/48ca55a6f7819605abbedcdde1f7214d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9_WTVvn4aUTxowa3qxhvw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">The two ways of selecting columns in Pandas</figcaption></figure><p id="ff81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>你可能会问，为什么完全相同的事情有两种方法？原因是方便。第二种方法稍微快一点，因为只需要两个点和列名。而在第一种方法中，您需要列名、两个上勾号和两个括号。</p><p id="a885" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我强烈建议使用第一种方法，因为它避免了一些小问题，并且与选择多个列相一致。</p><p id="4b60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">选择多个列:<br/> </strong>假设您想要选择<code class="fe pa pb pc pd b">Country name</code>和<code class="fe pa pb pc pd b">Life Ladder</code>，那么您应该这样做(小心:双括号):</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/e893babb92a4dfd297dd0c0283d3fe9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmOJ-zLWw64h-st0DkbAsg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Selecting “Country name” and “Life Ladder” columns and sampling five random rows</figcaption></figure><p id="9f03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:要特别注意您要选择的第一列和最后一列前后的双括号！无论何时使用双括号，结果都将是一个 DataFrame(即使只选择一个带有双括号的列)。我怎么强调这一点都不为过，因为我有时仍然会遇到这些错误！如果要选择多列，但只打开一组括号，括号之间的内容将被视为一列。不用说，您的数据不包含意外组合的列。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/fdd955332c9ca524512a33195a13e74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJ_9jBHnjm-V2wHfnfUdyg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">KeyError: If you only open and close one set of brackets.</figcaption></figure><h2 id="05d5" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">②过滤—行</h2><p id="f4e2" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">能够选择特定的列只是完成了一半。然而，选择行也同样简单。</p><p id="6156" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">熊猫中的行通过索引</strong>选择。您可以将索引视为行的名称。每当您从一个数据帧中选择行时，都会用一个具有相同索引的序列覆盖该数据帧，该序列只包含<code class="fe pa pb pc pd b">True</code>和<code class="fe pa pb pc pd b">False</code>值(<code class="fe pa pb pc pd b">True</code>表示应该选择该行，<code class="fe pa pb pc pd b">False</code>表示不应该选择该行)。然而，大多数时候，这种显式的索引选择是从用户那里抽象出来的。我仍然认为理解行选择过程是如何工作的非常重要。</p><p id="c9fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以通过索引选择一行或多行。有两种方法可以做到这一点:</p><ul class=""><li id="29ce" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated"><code class="fe pa pb pc pd b"><a class="ae lh" href="#7d8b" rel="noopener ugc nofollow">data.iloc</a></code>或者</li><li id="f408" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><code class="fe pa pb pc pd b"><a class="ae lh" href="#86f2" rel="noopener ugc nofollow">data.loc</a></code></li></ul><p id="7d8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> iloc: <br/> </strong> <code class="fe pa pb pc pd b">data.iloc</code>允许通过位置(即通过行数)选择行(以及可选的列)<strong class="lk jd">。</strong></p><p id="17fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> iloc —选择一行:</strong> <br/>语法如下<code class="fe pa pb pc pd b">data.iloc[row_number (,col_number)]</code>，括号中的部分是可选的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/12eb363aa2f7cc738d30751bc90aa99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMy1YGIYCy1sr2eWyMaAhg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.iloc[10] selects the 10th row</figcaption></figure><p id="b62b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>格式看起来有点不常规，这是因为当选择一行且仅选择一行时，将返回一个<a class="ae lh" href="#5522" rel="noopener ugc nofollow">系列</a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/73f6e4f56e0258634d6a1063af5dc8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAbk3Z5CE8FlwGWCPaaMLQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.iloc[10,5] selects the 5th column out of the 10th row</figcaption></figure><p id="8ee0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> iloc —选择多行:<br/> </strong>语法如下<code class="fe pa pb pc pd b">data.iloc[start_row:end_row (,start_col:end_col)]</code>所示，括号中的部分是可选的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qe"><img src="../Images/57f7acb2db02054aeba9c7d6046fa2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ebbKjr4gtA7o63B7lXoBQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.iloc[903:907] selects the 903rd to 907th row</figcaption></figure><p id="b9a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，您还可以指定要选择的列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/494d404da6f2d2590135623fedf3f975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJ-pcWRa0uJMjvJCgLNX3Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.iloc[903:907,0:3] selects for the 903rd to 907th row the 0th to 3rd column</figcaption></figure><p id="86f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> loc: <br/> </strong> <code class="fe pa pb pc pd b">data.loc</code>与<code class="fe pa pb pc pd b">iloc</code>相反，允许通过以下方式选择行(和列):</p><ol class=""><li id="56ae" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md nd ne nf ng bi translated"><strong class="lk jd">标签/索引或</strong></li><li id="64ff" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><strong class="lk jd">使用布尔/条件查找</strong></li></ol><p id="dd10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地解释第一点，也为了更好地将其与<code class="fe pa pb pc pd b">iloc</code>区分开来，我们将把国家名称转换成数据帧的索引。为此，运行以下命令:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="c258" class="me mf it pd b gy pi pj l pk pl">data.set_index('Country name',inplace=True)</span></pre><p id="a1e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pa pb pc pd b">set_index</code>命令在数据帧上设置一个新的索引。通过指定<code class="fe pa pb pc pd b">inplace=True</code>，我们确保数据帧将被改变。如果我们没有指定 inplace=True，我们将只能看到数据帧在应用操作后的样子，但底层数据不会发生任何变化。</p><p id="e364" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据帧现在应该如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/6f20fae415fa886cc0d0ee8578d00757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWYEnHIPdved66Kdlbkugg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">DataFrame after setting ‘Country name’ as the index</figcaption></figure><p id="1298" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，DataFrame 丢失了它的行号(以前的)索引，并获得了一个新的索引:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/aa7a7beecd626ecd129b8f782851a5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kqf2TtPzmaGs4UZ0TBFDuw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">New Index of the DataFrame</figcaption></figure><p id="a5c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> loc —通过一个索引标签选择行:<br/> </strong>语法如下<code class="fe pa pb pc pd b">data.loc[index_label (,col_label)]</code>，括号中的部分是可选的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/6c9d7add290ccdb441b21917ce75c273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjvjgJn5E4RleVLN0Ykwfw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.loc[‘United States’] selects all rows with ‘United States’ as the index</figcaption></figure><p id="b2b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> loc —通过索引标签和列标签选择行和列:</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qj"><img src="../Images/e09598974d0ff947691aeea60831639d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeDm5TqE0rwHvnWwCueJFQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.loc[‘United States’,’Life Ladder’] selects the column ‘Life Ladder’ for all rows with ‘United States’ as the index</figcaption></figure><p id="ac8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">位置——通过多个索引标签选择行:</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/7def6ca0db50251418f12cc17be840cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_VdKMTNubmV8dSgbq-CKQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">data.loc[[‘United States’,’Germany’]] selects all rows with ‘United States’ or ‘Germany’ as the index</figcaption></figure><p id="d659" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">备注:</strong></p><ul class=""><li id="da9b" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated">像前面一样，当选择多个列时，我们必须确保将它们放在双括号中。如果我们忘记这样做，列将被认为是一个长的(不存在的)名称。</li><li id="ad7c" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">我们使用样本(5)来表明在混合中有一些德国。假设我们使用 head(5)来代替，我们将只能在 12 行美国之后看到德国。</li><li id="29f9" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">Loc 按照提供的顺序返回行，而不考虑它们的实际顺序。例如，如果我们首先指定德国，然后指定美国，我们将得到 13 行德国，然后 12 行美国</li></ul><p id="e446" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">loc-通过多个索引标签选择行和列:<br/> </strong>您还可以为要返回的选定行指定列名。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ql"><img src="../Images/7a39212cbe5c91000b6d55151c0aeac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFyoM3apER9YxhUKvqAPRA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Selecting rows and columns by label name</figcaption></figure><p id="51d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>我们将行选择<code class="fe pa pb pc pd b">['Germany','United States]</code>和列选择<code class="fe pa pb pc pd b">['Year','Life Ladder']</code>分布在两行上。我发现将语句拆分有助于提高可读性。</p><p id="b178" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> loc —通过一系列索引标签选择行:<br/> </strong>这种选择行的方式可能有点奇怪，因为标签范围(<code class="fe pa pb pc pd b">'Denmark':'Germany'</code>)不像 iloc 使用数字范围(<code class="fe pa pb pc pd b">903:907</code>)那样直观。</p><p id="8875" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">指定标签范围是基于索引的当前排序，对于未排序的索引将会失败。</p><p id="6905" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，假设您的索引已经排序，或者您在选择范围之前已经排序，您可以执行下列操作:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/bd5d903417b86f055e5467536d309eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GS9EKVSCuq0uP9I97vEDdQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Using loc with a range of rows is going to return all rows between (including) Denmark and Germany</figcaption></figure><p id="4b32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> loc —布尔/条件查找<br/> </strong>布尔或条件查找才是真正的关键所在。正如前面提到的<a class="ae lh" href="#05d5" rel="noopener ugc nofollow">和</a>，无论何时选择行，这都是通过用真值和假值的掩码覆盖数据帧来实现的。</p><p id="6c59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的例子中，我们用索引<code class="fe pa pb pc pd b">['A','B','A','D']</code>和 0 到 10 之间的一些随机值创建了一个小的数据帧。</p><p id="a9f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们创建一个具有相同索引值<code class="fe pa pb pc pd b">[True,False,True,False]</code>的<code class="fe pa pb pc pd b">overlay</code>。</p><p id="5de8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们使用<code class="fe pa pb pc pd b">df.loc[overlay]</code>只选择索引值为真的行。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="7d18" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>from numpy.random import randint<br/>index = ['A','B','A','D']</span><span id="210a" class="me mf it pd b gy px pj l pk pl">## create dummy DataFrame ##<br/>df = pd.DataFrame(<br/>    index = index,<br/>    data = {<br/>    'values':randint(10,size=len(index))<br/>})<br/>print('DataFrame:')<br/>print(df)</span><span id="55bd" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>DataFrame:<br/>   values<br/>A       8<br/>B       2<br/>A       3<br/>D       2</span><span id="171e" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">IN:</strong><br/>## create dummy overlay ##<br/>overlay = pd.Series(<br/>    index=index,<br/>    data=[True,False,True,False]<br/>)<br/>print('\nOverlay:')<br/>print(overlay)</span><span id="797b" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Overlay:<br/>A     True<br/>B    False<br/>A     True<br/>D    False<br/>dtype: bool</span><span id="d00a" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">IN:</strong><br/>## select only True rows ##<br/>print('\nMasked DataFrame:')<br/>print(df.loc[overlay])</span><span id="1c22" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:</strong><br/>Masked DataFrame:<br/>   values<br/>A       8<br/>A       3</span></pre><p id="afdf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于一个(或多个)条件，可以使用相同的逻辑来选择行。</p><p id="fb6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们首先创建一个布尔掩码，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/8ab27c61b022cd57f7e8ab40402aef26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*orFU9k3sFyD7yttsxHuC5g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Filtering based on the value of ‘Life Ladder’ returns Series with True/False values</figcaption></figure><p id="fa33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后使用该掩码只选择符合指定条件的行，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/eaf1918b145c984bb09f847c060137ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OgQ--cwqGPN6lSDja323g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Selecting rows based on a condition</figcaption></figure><p id="2177" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">选项 1 作为替代方案也产生完全相同的结果。然而，另一种选择更清晰一些。当应用多种条件时，易读性的提高变得更加明显:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/a0f2945e314af12a6aa6f5de69ed1a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYA03VmjbjFWOw_FapVn2Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Chaining various conditions together</figcaption></figure><p id="d906" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>我们使用了<code class="fe pa pb pc pd b">&amp;</code>(按位 and)来过滤行，其中多个条件同时适用。我们可以使用<code class="fe pa pb pc pd b">|</code>(按位 or)来过滤符合其中一个条件的列。</p><p id="d197" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> loc —带有自定义公式的高级条件查找</strong></p><p id="13bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也可以使用定制的函数作为条件，并将它们应用于选择列，这非常容易。</p><p id="becd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的例子中，我们只选择能被三整除的年份和包含单词 America 的大洲。这个案例是人为的，但却说明了一个问题。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/6e63864b273da3d5d74307b04f6bf2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bM3-jAckGtlA_nDoihm-HA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Row selection based on custom formulas conditions</figcaption></figure><p id="f29d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了 lambda(匿名)函数，您还可以定义和使用更复杂的函数。您甚至可以(我并不推荐)在自定义函数中进行 API 调用，并使用调用的结果来过滤您的数据帧。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="b99e" class="oo mf it bd mg op oq or mj os ot ou mm ki ov kj mp kl ow km ms ko ox kp mv oy bi translated">4.分析功能</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qr"><img src="../Images/ac953076d201a004d806aa1a2cf78fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VX-uQ1KXziA_4AZtw99FQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Image by <a class="ae lh" href="https://pixabay.com/users/xresch-7410129/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3041437" rel="noopener ugc nofollow" target="_blank">xresch</a> from <a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3041437" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="a364" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">既然我们已经习惯了从前到后对数据进行过滤和排序，反之亦然，那么让我们转向一些更高级的分析功能。</p><h2 id="0903" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">标准功能:</h2><p id="e703" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">像 read 函数一样，Pandas 也实现了很多分析函数。</p><p id="26f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将强调并解释我最常用的方法。然而，这也是它美丽的一部分，甚至我会不时地发现新的有用的功能。所以千万不要开始阅读和探索！</p><ul class=""><li id="8190" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated">①最大/最小</li><li id="38f7" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">②总和</li><li id="2f36" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">③平均值/中位数/分位数</li><li id="88a6" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated">④ idxmin/idxmax</li></ul><p id="b3d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:所有函数都可以按列应用，也可以按行应用。</strong>在我们的例子中，行方式的应用没有什么意义。然而，通常情况下，您有数据，您想比较不同的列，在这种情况下，行方式的应用程序确实有意义。</p><p id="d8cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当我们调用上述函数时，都会传递一个默认参数<code class="fe pa pb pc pd b">axis=0</code>(对于按列的应用程序)。然而，我们可以覆盖这个参数并传递<code class="fe pa pb pc pd b">axis=1</code>(对于行方式的应用)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qs"><img src="../Images/484ebf9387553c903cc9cca1f0841fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmEsk6FliMVBEjNlwPtJ9w.png"/></div></div></figure><p id="b22a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> ① max/min <br/> </strong>对数据调用<code class="fe pa pb pc pd b">max()</code>，将(尽可能)返回每列的最大值。<code class="fe pa pb pc pd b">min()</code>恰恰相反。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="a46a" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>data.max() <strong class="pd jd"># COLUMNWISE MAXIMUM</strong></span><span id="afdc" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT: <br/></strong>Year                                                        2018<br/>Life Ladder                                              8.01893<br/>Log GDP per capita                                       11.7703<br/>Social support                                          0.987343<br/>                                                       ...      <br/>Most people can be trusted, WVS round 1999-2004         0.637185<br/>Most people can be trusted, WVS round 2005-2009         0.737305<br/>Most people can be trusted, WVS round 2010-2014         0.661757<br/>Continent                                          South America<br/>Length: 26, dtype: object</span><span id="8155" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.max(axis=1) <strong class="pd jd"># ROW-WISE MAXIMUM</strong></span><span id="12d4" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT: </strong><br/>Country name<br/>Afghanistan    2008.0<br/>Afghanistan    2009.0<br/>Afghanistan    2010.0<br/>Afghanistan    2011.0<br/>                ...  <br/>Zimbabwe       2015.0<br/>Zimbabwe       2016.0<br/>Zimbabwe       2017.0<br/>Zimbabwe       2018.0<br/>Length: 1704, dtype: float64</span></pre><p id="a462" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> ② sum <br/> </strong>对数据调用<code class="fe pa pb pc pd b">sum()</code>，将(尽可能)返回每一列的总和。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="648d" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.sum()</span><span id="04b1" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year                                                                                         3429014<br/>Life Ladder                                                                                  9264.91<br/>Log GDP per capita                                                                           15456.8<br/>Social support                                                                               1370.67<br/>                                                                         ...                        <br/>Most people can be trusted, WVS round 1999-2004                                              131.623<br/>Most people can be trusted, WVS round 2005-2009                                              166.532<br/>Most people can be trusted, WVS round 2010-2014                                              159.358<br/>Continent                                          AsiaAsiaAsiaAsiaAsiaAsiaAsiaAsiaAsiaAsiaAsiaEu...<br/>Length: 26, dtype: object</span></pre><p id="6aae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong> Sum 会将字符串连接成一个长字符串，这将为 Continent 列生成 asiasiasiasiasiasiasiasiasiasiasiasiasiasiasiaaiaeu…。</p><p id="2aca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> ③均值/中值/分位数<br/> </strong>对数据调用<code class="fe pa pb pc pd b">mean</code>、<code class="fe pa pb pc pd b">median</code>或<code class="fe pa pb pc pd b">quantile</code>将分别返回均值或中值。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="3e19" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.mean()</span><span id="5689" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year                                               2012.332160<br/>Life Ladder                                           5.437155<br/>Log GDP per capita                                    9.222456<br/>Social support                                        0.810570<br/>                                                      ...     <br/>Most people can be trusted, WVS round 1994-1998       0.249574<br/>Most people can be trusted, WVS round 1999-2004       0.268070<br/>Most people can be trusted, WVS round 2005-2009       0.264336<br/>Most people can be trusted, WVS round 2010-2014       0.237493<br/>Length: 25, dtype: float64</span><span id="f657" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.median()</span><span id="466f" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:</strong><br/>Year                                               2012.000000<br/>Life Ladder                                           5.339557<br/>Log GDP per capita                                    9.406206<br/>Social support                                        0.833098<br/>                                                      ...     <br/>Most people can be trusted, WVS round 1994-1998       0.229924<br/>Most people can be trusted, WVS round 1999-2004       0.232000<br/>Most people can be trusted, WVS round 2005-2009       0.198380<br/>Most people can be trusted, WVS round 2010-2014       0.193531<br/>Length: 25, dtype: float64</span><span id="00dc" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.quantile(q=.8)</span><span id="43f0" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year                                               2016.000000<br/>Life Ladder                                           6.497157<br/>Log GDP per capita                                   10.375623<br/>Social support                                        0.913667<br/>                                                      ...     <br/>Most people can be trusted, WVS round 1994-1998       0.304498<br/>Most people can be trusted, WVS round 1999-2004       0.388611<br/>Most people can be trusted, WVS round 2005-2009       0.415082<br/>Most people can be trusted, WVS round 2010-2014       0.373906<br/>Name: 0.8, Length: 25, dtype: float64</span></pre><p id="1467" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">④idx min/idx max<br/>T32】对数据调用<code class="fe pa pb pc pd b">idxmax</code>或<code class="fe pa pb pc pd b">idxmin</code>将返回找到第一个最小值/最大值的行的索引。然而，只可能在一些普通的列上调用这个函数。</strong></p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="dd0a" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.iloc[:,:-1].idxmax() # We exclude the Continent Column</span><span id="a14b" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year                                               Afghanistan<br/>Life Ladder                                            Denmark<br/>Log GDP per capita                                       Qatar<br/>Social support                                     New Zealand<br/>                                                      ...     <br/>Most people can be trusted, WVS round 1994-1998         Norway<br/>Most people can be trusted, WVS round 1999-2004         Sweden<br/>Most people can be trusted, WVS round 2005-2009         Norway<br/>Most people can be trusted, WVS round 2010-2014    Netherlands<br/>Length: 25, dtype: object</span></pre><p id="9562" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着，例如，丹麦的社会支持值最高<code class="fe pa pb pc pd b">Life Ladder</code>，卡塔尔最高<code class="fe pa pb pc pd b">Log GDP per capita</code>和<code class="fe pa pb pc pd b">New Zealand</code>。</p><p id="9bc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pa pb pc pd b">idxmin</code>的工作原理与<code class="fe pa pb pc pd b">idxmax</code>相同。</p><p id="d799" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">总结:</strong>不要忘记，您可以按列(轴=0)或行(轴=1)应用所有这些函数</p><h2 id="da99" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">应用/自定义功能:</h2><p id="5e99" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">您还可以编写自定义函数，并在行或列上使用它们。有两种自定义函数:</p><ul class=""><li id="62ec" class="mw mx it lk b ll lm lo lp lr pq lv pr lz ps md pt ne nf ng bi translated"><strong class="lk jd">命名函数</strong></li><li id="a0e2" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md pt ne nf ng bi translated"><strong class="lk jd">λ函数</strong></li></ul><p id="8d48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">命名函数是用户定义的函数。它们是通过使用保留关键字<code class="fe pa pb pc pd b">def</code>来定义的，如下所示:</p><p id="889b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">命名函数:</strong></p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="4c7d" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">FUNCTION:</strong><br/>def above_1000_below_10(x):<br/>    try:<br/>        pd.to_numeric(x)<br/>    except:<br/>        return 'no number column'<br/>    <br/>    if x &gt; 1000:<br/>        return 'above_1000'<br/>    elif x &lt; 10:<br/>        return 'below_10'<br/>    else:<br/>        return 'mid'</span><span id="13cc" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">IN:<br/></strong>data['Year'].apply(above_1000_below_10)</span><span id="f265" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    above_1000<br/>Afghanistan    above_1000<br/>Afghanistan    above_1000<br/>Afghanistan    above_1000<br/>                  ...    <br/>Zimbabwe       above_1000<br/>Zimbabwe       above_1000<br/>Zimbabwe       above_1000<br/>Zimbabwe       above_1000<br/>Name: Year, Length: 1704, dtype: object</span></pre><p id="03b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们定义了一个名为<code class="fe pa pb pc pd b">above_1000_below_10</code>的函数，并将其应用于我们的数据。</p><p id="b7f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该函数首先检查该值是否可转换为数字，如果不可转换，将返回“无数字列”否则，如果值大于 1000，函数返回 above_1000，如果值小于 10，函数返回 below_10，否则返回 mid。</p><p id="17d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Lambda 函数:<br/> </strong>对我来说，Lambda 函数出现的频率比命名函数高得多。本质上，这些都是简短的一次性函数。这个名字听起来很笨拙，但是一旦你掌握了窍门，它们就很方便了。例如，我们可以首先在空间上拆分大陆列，然后获取结果的最后一个词。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="8c87" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data['Continent'].apply(lambda x: x.split(' ')[-1])</span><span id="43c0" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan      Asia<br/>Afghanistan      Asia<br/>Afghanistan      Asia<br/>Afghanistan      Asia<br/>                ...  <br/>Zimbabwe       Africa<br/>Zimbabwe       Africa<br/>Zimbabwe       Africa<br/>Zimbabwe       Africa<br/>Name: Continent, Length: 1704, dtype: object</span></pre><p id="8e5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>命名函数和 lambda 函数都应用于单独的列，而不是整个数据帧。将函数应用于特定列时，函数逐行执行。当将函数应用于整个数据帧时，函数逐列执行，然后应用于整个列，并且必须以稍微不同的方式编写，如下所示:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="278d" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>def country_before_2015(df):<br/>    if df['Year'] &lt; 2015:<br/>        return df.name<br/>    else:<br/>        return df['Continent']</span><span id="030b" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd"># Note the axis=1<br/></strong>data.apply(country_before_2015, axis=1)</span><span id="c044" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    Afghanistan<br/>Afghanistan    Afghanistan<br/>Afghanistan    Afghanistan<br/>Afghanistan    Afghanistan<br/>                  ...     <br/>Zimbabwe            Africa<br/>Zimbabwe            Africa<br/>Zimbabwe            Africa<br/>Zimbabwe            Africa<br/>Length: 1704, dtype: object</span></pre><p id="1147" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，我们也是逐行进行的(由<code class="fe pa pb pc pd b">axis=1</code>指定)。当该行的年份小于 2015 年或该行的洲时，我们返回该行的名称(恰好是索引)。当您必须进行条件数据清理时，这样的任务确实会出现。</p><h2 id="4bef" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">合并列:</h2><p id="ebce" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">有时你想增加、减少或合并两列或多列，这真的再简单不过了。</p><p id="4de2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们想要添加<code class="fe pa pb pc pd b">Year</code>和<code class="fe pa pb pc pd b">Life Ladder</code>(我知道这是人为的，但我们这样做是为了便于讨论)。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="9f10" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>data['Year'] + data['Life Ladder']</span><span id="a195" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    2011.723590<br/>Afghanistan    2013.401778<br/>Afghanistan    2014.758381<br/>Afghanistan    2014.831719<br/>                  ...     <br/>Zimbabwe       2018.703191<br/>Zimbabwe       2019.735400<br/>Zimbabwe       2020.638300<br/>Zimbabwe       2021.616480<br/>Length: 1704, dtype: float64</span></pre><p id="217e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和<code class="fe pa pb pc pd b">-, *, /</code>一样，你还可以做更多的字符串操作，就像这样:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="ed0c" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data['Continent'] + '_' + data['Year'].astype(str)</span><span id="2170" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan      Asia_2008<br/>Afghanistan      Asia_2009<br/>Afghanistan      Asia_2010<br/>Afghanistan      Asia_2011<br/>                  ...     <br/>Zimbabwe       Africa_2015<br/>Zimbabwe       Africa_2016<br/>Zimbabwe       Africa_2017<br/>Zimbabwe       Africa_2018<br/>Length: 1704, dtype: object</span></pre><p id="893f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>在上面的例子中，我们想把两列组合成字符串。为此，我们必须将<code class="fe pa pb pc pd b">data['Year']</code>解释为一个字符串。我们通过在列上使用<code class="fe pa pb pc pd b">.astype(str)</code>来实现。为了简洁起见，我们不会在本文中深入探讨类型和类型转换，而是在另一篇文章中讨论这些主题。</p><h2 id="d719" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">分组依据</h2><p id="337a" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">到目前为止，我们应用的所有计算都是针对整个集合、一行或一列的。然而——这正是令人兴奋的地方——我们还可以对数据进行分组，并计算各个组的指标。</p><p id="b3a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们想知道每个国家的最高<code class="fe pa pb pc pd b">Life Ladder</code>值。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="a35c" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.groupby(['Country name'])['Life Ladder'].max()</span><span id="e4cc" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    4.758381<br/>Albania        5.867422<br/>Algeria        6.354898<br/>Angola         5.589001<br/>                 ...   <br/>Vietnam        5.767344<br/>Yemen          4.809259<br/>Zambia         5.260361<br/>Zimbabwe       4.955101<br/>Name: Life Ladder, Length: 165, dtype: float64</span></pre><p id="d593" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们希望每年有最高的<code class="fe pa pb pc pd b">Life Ladder</code>的国家。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="1619" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.groupby(['Year'])['Life Ladder'].idxmax()</span><span id="b2ab" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year<br/>2005    Denmark<br/>2006    Finland<br/>2007    Denmark<br/>2008    Denmark<br/>         ...   <br/>2015     Norway<br/>2016    Finland<br/>2017    Finland<br/>2018    Finland<br/>Name: Life Ladder, Length: 14, dtype: object</span></pre><p id="c151" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者多级组，假设我们想要每个洲/年组合中<code class="fe pa pb pc pd b">Life Ladder</code>最高的国家。</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="2929" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>data.groupby(['Year','Continent'])['Life Ladder'].idxmax()</span><span id="4545" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year  Continent    <br/>2005  Africa                  Egypt<br/>      Asia             Saudi Arabia<br/>      Europe                Denmark<br/>      North America          Canada<br/>                           ...     <br/>2018  Europe                Finland<br/>      North America          Canada<br/>      Oceania           New Zealand<br/>      South America           Chile<br/>Name: Life Ladder, Length: 83, dtype: object</span></pre><p id="6546" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像之前的<a class="ae lh" href="#e703" rel="noopener ugc nofollow">一样，我们可以使用许多标准函数或自定义函数(命名或未命名)，例如，为每组返回一个随机国家:</a></p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="f82f" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>def get_random_country(group):<br/>    return np.random.choice(group.index.values)</span><span id="e116" class="me mf it pd b gy px pj l pk pl"># Named function<br/>data.groupby(['Year','Continent']).apply(get_random_country)</span><span id="0247" class="me mf it pd b gy px pj l pk pl"># Unnamed function<br/>data.groupby(['Year','Continent']).apply(<br/>  lambda group: np.random.choice(group.index.values)<br/>)</span><span id="402b" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Year  Continent    <br/>2005  Africa                  Egypt<br/>      Asia                   Jordan<br/>      Europe                 France<br/>      North America          Mexico<br/>                           ...     <br/>2018  Europe           North Cyprus<br/>      North America       Nicaragua<br/>      Oceania             Australia<br/>      South America           Chile<br/>Length: 83, dtype: object</span></pre><p id="8a3d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong> groupby 总是为每组返回<strong class="lk jd">一个</strong>值。因此，除非您按只包含唯一值的列进行分组，否则结果将是一个较小的(聚合的)数据集。</p><h2 id="9b51" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">改变</h2><p id="ef4f" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">有时，您不希望每个组只有一个值，而是希望属于该组的每一行都有您为该组计算的值。您可以通过以下方式完成此操作:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="1b89" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.groupby(['Country name'])['Life Ladder'].transform(sum)</span><span id="87bd" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    40.760446<br/>Afghanistan    40.760446<br/>Afghanistan    40.760446<br/>Afghanistan    40.760446<br/>                 ...    <br/>Zimbabwe       52.387015<br/>Zimbabwe       52.387015<br/>Zimbabwe       52.387015<br/>Zimbabwe       52.387015<br/>Name: Life Ladder, Length: 1704, dtype: float64</span></pre><p id="c710" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们得到一个国家所有得分的总和。我们还可以做:</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="546e" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:<br/></strong>data.groupby(['Country name'])['Life Ladder'].transform(np.median)</span><span id="86e9" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    3.782938<br/>Afghanistan    3.782938<br/>Afghanistan    3.782938<br/>Afghanistan    3.782938<br/>                 ...   <br/>Zimbabwe       3.826268<br/>Zimbabwe       3.826268<br/>Zimbabwe       3.826268<br/>Zimbabwe       3.826268<br/>Name: Life Ladder, Length: 1704, dtype: float64</span></pre><p id="6dbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">得到每个国家的中位数。然后，我们可以像这样计算每一年的值的差异(因为转换保留了索引):</p><pre class="ks kt ku kv gt pe pd pf pg aw ph bi"><span id="4179" class="me mf it pd b gy pi pj l pk pl"><strong class="pd jd">IN:</strong><br/>data.groupby(['Country name'])['Life Ladder'].transform(np.median) \<br/>- data['Life Ladder']</span><span id="fc81" class="me mf it pd b gy px pj l pk pl"><strong class="pd jd">OUT:<br/></strong>Country name<br/>Afghanistan    0.059348<br/>Afghanistan   -0.618841<br/>Afghanistan   -0.975443<br/>Afghanistan   -0.048782<br/>                 ...   <br/>Zimbabwe       0.123077<br/>Zimbabwe       0.090868<br/>Zimbabwe       0.187968<br/>Zimbabwe       0.209789<br/>Name: Life Ladder, Length: 1704, dtype: float64</span></pre><p id="70ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章应该给你一些思考。最初，我还想包括访问器、类型操作和连接、合并和连接数据帧，但是考虑到文章的长度，我将这些主题移到了本系列的第二部分:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/learn-advanced-features-for-pythons-main-data-analysis-library-in-20-minutes-d0eedd90d086"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">在 20 分钟内了解 Python 主数据分析库的高级功能</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">熊猫高级功能代码指南。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="qt l od oe of ob og lb ns"/></div></div></a></div><p id="c43b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到时见，继续探索！</p><p id="9801" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哦，如果你喜欢阅读这样的故事，并想支持我成为一名作家，考虑注册成为一名灵媒成员。每月 5 美元，你可以无限制地阅读媒体上的故事。如果你用我的链接注册，我甚至会得到一些🍩。</p><div class="np nq gp gr nr ns"><a href="https://medium.com/@fabianbosler/membership" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">通过我的推荐链接加入 Medium-Fabian Bosler</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="qu l od oe of ob og lb ns"/></div></div></a></div></div></div>    
</body>
</html>