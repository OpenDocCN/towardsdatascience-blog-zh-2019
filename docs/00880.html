<html>
<head>
<title>An Introduction to SQLAlchemy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的 SQLAlchemy 简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-and-etl-an-introduction-to-sqlalchemy-in-python-fc66e8be1cd4?source=collection_archive---------11-----------------------#2019-02-10">https://towardsdatascience.com/sql-and-etl-an-introduction-to-sqlalchemy-in-python-fc66e8be1cd4?source=collection_archive---------11-----------------------#2019-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e6d9408ad63089b71885ee34376e894a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovEbmCfyU1mLIF4Qh1vTLQ.png"/></div></div></figure><div class=""/><p id="ef87" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SQL 比 Pandas 更简单，可读性更好，这就是为什么许多人使用它，除了它也是一个遗留系统。虽然它很快，但它是与数据库对话和从数据仓库提取数据的语言。这是大规模数据科学的东西！</p><p id="87bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将浏览一下我的笔记本，它大致模拟了这种扩展数据科学的核心工作流:ETL。ETL 代表提取、转换和加载。虽然这个例子是我本地计算机上的一个笔记本，但是如果数据库文件来自一个源系统，提取就需要将它移动到一个数据仓库中。从那里，它将被转换使用 SQL 查询。最后一步是将数据加载到 Python 和 Pandas 之类的东西中，以进行机器学习和其他很酷的事情。</p><p id="2f51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用的是 SQLAlchemy，引擎盖下用的是 SQLite。SQLAlchemy 有自己的一套运行 SQL 查询的类和方法，但是我写出了原始的 SQL，以供更有兴趣或更熟悉它的读者使用。我这样做也是为了显示我的查询的逻辑，因为所有这些都会被 SQLAlchemy 抽象掉。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="c745" class="ld le jb bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">安装</h2><p id="5ad4" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我在这里下载了 chinook.db 数据库文件<a class="ae mb" href="http://www.sqlitetutorial.net/sqlite-sample-database/" rel="noopener ugc nofollow" target="_blank">开始使用。这是一个 zip 文件夹，所以我用下面的 shell 脚本将它解压缩并复制到我笔记本的工作目录中:</a></p><p id="3538" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mc md me mf b">!cd ..\..\..\Downloads &amp;&amp; powershell.exe -NoP -NonI -Command 'Expand-Archive'.\chinook.zip''.\chinook\ &amp;&amp; cd C:\Users\riley\Downloads\chinook\ &amp;&amp; copy chinook.db C:\Users\riley\Documents\Coding\ETL</code></p><p id="fc2e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的命令对您来说会有所不同，因为您有不同的文件夹，但这是可以修改的。这也是一个 powershell 脚本，所以它只适用于 Windows。但是这是一种快速而巧妙的解压文件并将内容拷贝移动到目标目录的方法。“！”向 Jupyter 表明该行是一个 shell 脚本。相当整洁！</p><h2 id="7604" class="ld le jb bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">"摘录"</h2><p id="1984" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">将数据库文件放在工作目录中后，我继续编写导入语句，并使用 Sqlite 通过 SQLAlchemy 库创建连接到数据库的引擎。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Import statements and connection to the database via sqlite</figcaption></figure><p id="09c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我做任何事情之前，我查阅了下面的表模式。这让我了解了哪些变量是可用的，以及表之间的关系。在 SQL 中，关系和模式是预定义的，必须在创建表和随后用数据填充表之前声明。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/2b05b8ec56f22eac98f95f50799009a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-l2I5kAgzn2FWxka.jpg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Chinook.db table schemas</figcaption></figure><p id="fb65" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我需要定义元数据，它实例化组成表的对象。我还看了一下“雇员”表中的列，因为这是我很好奇的开始部分。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Metadata instantiation and column inspection</figcaption></figure><p id="5c21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码返回“雇员”表的列。</p><p id="d5ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">言归正传，我调用了对‘employees’表的第一个查询，并查看了结果。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Connects to the engine, which is connected to the database, then returns the query written in raw SQL on line 4.</figcaption></figure><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mr"><img src="../Images/2eb19bc4b81b8e1ed072c43247977cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyr9b6h8YPF7IjkXLZYhgw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">The output of the code above for the employees in that table</figcaption></figure><p id="ce76" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mc md me mf b">SELECT * FROM table_name</code>基本上是 SQL 的 hello world。你可以把它想成<code class="fe mc md me mf b">df</code>。不过，我不建议在没有<code class="fe mc md me mf b">LIMIT n</code>(相当于<code class="fe mc md me mf b">df.head(n)</code>)语句的情况下这样做，其中 n 是要返回的行数。这将保护你和你的电脑，以防你的桌子太大。</p><p id="0d6b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了查看数据库中的其他表，我调用了<code class="fe mc md me mf b">inspector.get_table_names()</code>，它返回一个列表。这是一种便捷的方式来查看有什么可探索的。</p><p id="a19c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于这些数据，我对一些事情产生了兴趣:</p><ol class=""><li id="edf3" class="ms mt jb ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">有多少员工？</li><li id="903b" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">每个销售代表帮助了多少客户？</li><li id="14bd" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">销售代表在公司的资历和他们帮助了多少客户之间有联系吗？</li><li id="9818" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">我如何利用不同表格中的信息来回答另一个问题:购买了多少分钟的音乐，按国家汇总？</li></ol><h2 id="fcd0" class="ld le jb bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">改变</h2><p id="c1a3" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">第一个问题很容易回答。我没有限制<code class="fe mc md me mf b">SELECT * FROM employees</code>的输出，所以它把它们都给我看了。显然有 8 个条目。但是知道这一点很容易，因为桌子很大。如果是 300 万员工呢？不管表的大小如何，计算雇员数量的代码如下。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Returns the number of employees in the employees table</figcaption></figure><p id="341a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了回答我的第二个问题，我查看了“customers”表中的“SalesRepId”变量，对其进行了计数，并将其分组，以查看每个“SalesRepId”有多少个实例。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Returns the number of customers employees 3, 4, and 5 helped respectively</figcaption></figure><p id="8140" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">员工 3 帮助了 21 个客户，4 帮助了 20 个客户，5 帮助了 18 个客户。为了回答我的第三个问题，我接下来检查了员工的雇佣日期。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Returns the hire date and employee ID for employees 3–5 ordered in ascending order (note: the BETWEEN clause in SQL is inclusive of the lower and upper bound of the range given)</figcaption></figure><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f76453177a9d873e38c1c40010f67932.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*3ISN7e2w8q-hz3C38N3qNg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">The output of the code above shows the difference in hiring date for employees 3–5</figcaption></figure><p id="fe29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了找到最资深的雇员，我编写了下面的查询。在这么小的桌子上，这是不必要的，但我还是把它写了出来，因为这就是如何缩放！</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Returns the hire date and employee ID of the most senior employee (the “smallest” hire date — which translates to furthest date back)</figcaption></figure><p id="1be8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">似乎存在某种线性关系，至少在这个非常有限的数据集上。随着任期的延长，得到帮助的客户数量也在增加。显然，这些信息不足以推断技能——某人在某处工作的时间越长，他们完成的[在此插入任务]就越多。</p><h2 id="06cc" class="ld le jb bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">把这一切联系起来</h2><p id="ccb3" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我想回答一个更复杂/有趣的问题，并为此编写同样更复杂的 SQL 查询。我还想使用不同表中的数据，因为有太多的数据可供选择。为此，我需要连接这些表。</p><p id="5b7a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在关系数据库中，表之间有关系。“客户”表有一个主键“客户 Id”。这是每个客户的唯一标识符。这一点很重要，因为虽然可能有多个 Joe，但不会有多个“CustomerId”编号 2355。</p><p id="8617" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个原则，我开始着手解决一个挑战，即调查每个国家销售了多少分钟的音乐。</p><p id="2605" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“曲目”表中的歌曲长度以毫秒为单位。“客户”表告诉我们国家。</p><p id="3dac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将“tracks”表连接到“invoice_items”表，该表包含一个公共键:“TrackId”。“TrackId”是“tracks”表的主键，但却是“invoice_items”表的外键。因为这些表共享该列，所以它们可以根据该列合并在一起。</p><p id="c1ca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mb" href="https://medium.com/launch-school/sql-joins-and-you-21448802b795" rel="noopener">如果你喜欢</a>，这里有一篇很好的中型文章详细介绍了 joins。</p><p id="a1df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，我使用所需的外键将“tracks”与“invoice_items”、“invoice_items”与“invoice”以及“invoice”与“customers”连接起来。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Returns a table of various attributes of various tables, the last column of which being the total length of music sold in minutes to each country</figcaption></figure><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/4c3bec4c1e70a79d862dc311d34b70ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xc4Jhvk2_7vDKVvtxMXkTQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Minutes of music sold to customers in the US, Canada, and so on</figcaption></figure><p id="5322" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3277 分钟的音乐卖给了 494 个美国人！酷！🎵🎶</p><h2 id="1861" class="ld le jb bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">负荷</h2><p id="8080" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">转换方面完成后，我继续加载它作为最后一步。一旦完成，你就可以深入到更复杂的分析中去，熊猫和 Python 宇宙就是以这些分析而闻名的！</p><p id="6847" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码是相同的查询，作为 Pandas 的<code class="fe mc md me mf b">pd.read_sql_query()</code>方法的第一个参数输入。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Creates a Pandas dataframe from the SQL query (note: the engine.connect() argument must be included)</figcaption></figure><p id="09fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后这里是调用<code class="fe mc md me mf b">df.head()</code>的输出:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/5060cd77ef3660a126fc3d1bc29e8a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuUQo9k_g6JMTf5GurpR1w.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Back to the world of Pandas dataframes</figcaption></figure><h2 id="cda2" class="ld le jb bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">结论</h2><p id="4cb0" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我简要概述了 ETL(提取、转换和加载)及其在大数据世界中的作用。这是对我的代码的一次演练，并附带了对关键 SQL 概念的解释。我在 SQLAlchemy for Python 中工作，它有一系列抽象的类和方法，所以如果我使用它们，SQL 查询看起来不会完全一样。您可以在<a class="ae mb" href="https://docs.sqlalchemy.org/en/latest/orm/examples.html" rel="noopener ugc nofollow" target="_blank">文档页面</a>上看到该语法。</p><p id="870d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个项目的完整代码可以在我的 GitHub 上找到。</p><p id="e3f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你喜欢这本书！</p><p id="57ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你学到了新的东西，并想把它交给下一个学习者，<a class="ae mb" href="https://www.patreon.com/rileypredum" rel="noopener ugc nofollow" target="_blank">考虑捐赠</a>你觉得合适的任何数量，谢谢！</p><p id="0cb1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p><p id="6201" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">奢侈的生活</p></div></div>    
</body>
</html>