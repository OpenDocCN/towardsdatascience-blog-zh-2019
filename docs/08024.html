<html>
<head>
<title>Point Operations in Image Processing with skimage-Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">skimage-Python 在图像处理中的点操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/point-operations-in-image-processing-with-skimage-python-5dfeb523ed5c?source=collection_archive---------34-----------------------#2019-11-04">https://towardsdatascience.com/point-operations-in-image-processing-with-skimage-python-5dfeb523ed5c?source=collection_archive---------34-----------------------#2019-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="762c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们用手机拍照时，我们在社交媒体上发布之前会做什么？当然，我们调整亮度、对比度等等。你有没有想过我们在屏幕后面的形象发生了什么变化？</p><p id="481d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一切都可以通过一个叫做<strong class="js iu">点操作的简单技巧来实现。</strong>有很多点操作，也有很多点操作的用例。有些是，</p><ul class=""><li id="6649" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">修改亮度或对比度</li><li id="9700" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">应用任意强度变换</li><li id="f074" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">量化图像</li><li id="6f97" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">全局阈值</li><li id="3dba" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">非线性校正</li><li id="a6a3" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">颜色变换等等。</li></ul><h1 id="6158" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是点操作？</h1><p id="1977" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们都知道图像只是简单地用 2D 有序矩阵来表示。用于修改像素值而不影响相邻像素的操作称为<strong class="js iu">点操作。</strong>点操作将、</p><ol class=""><li id="949e" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mf ku kv kw bi translated">不改变图像的大小</li><li id="c73c" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mf ku kv kw bi translated">不改变图像的几何形状</li><li id="c7b6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mf ku kv kw bi translated">不改变图像的局部结构</li><li id="e0f5" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mf ku kv kw bi translated">不影响相邻像素</li></ol><p id="f347" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，简单的点操作可以表示为，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ff2b" class="mp ld it ml b gy mq mr l ms mt">a' &lt;------- f(a) #here "a" is the intensity value of a pixel</span><span id="2d18" class="mp ld it ml b gy mu mr l ms mt">OR</span><span id="359b" class="mp ld it ml b gy mu mr l ms mt">I'(u,v) &lt;------- f(I(u,v)) #here "u,v"are the coordinates of the image I</span></pre><p id="adbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存在两种类型的点操作。<strong class="js iu">同质或全局点运算，</strong>其中函数 f()与图像坐标无关。如上式所示，v 仅用于获取特定像素的亮度值。</p><p id="b646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种类型的点操作是<strong class="js iu">非齐次点操作</strong>，其中使用了<strong class="js iu">映射函数</strong> g()。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="56d3" class="mp ld it ml b gy mq mr l ms mt">a' &lt;------- g(a,u,v) <br/>#here "a" is the current pixel value and u,v are the coordinates of the pixel which should be considered in calculations</span><span id="5b3e" class="mp ld it ml b gy mu mr l ms mt">OR</span><span id="9957" class="mp ld it ml b gy mu mr l ms mt">I' &lt;-------g(I(u,v), u,v)</span></pre><p id="bd37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非同质点操作的一个示例用例是<strong class="js iu">对比度或亮度的局部调整。</strong></p><h1 id="361a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">同质点操作的示例</h1><h2 id="542c" class="mp ld it bd le mv mw dn li mx my dp lm kb mz na lq kf nb nc lu kj nd ne ly nf bi translated"><strong class="ak">对比度修改</strong></h2><p id="85f9" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">让我们将图像的对比度增加 50%。你能猜到我们应该对每个像素执行什么操作吗？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3534" class="mp ld it ml b gy mq mr l ms mt">f_contrast(a) = a x (1.5)</span><span id="0acb" class="mp ld it ml b gy mu mr l ms mt">#We should iteratively get pixel values in image one by one modify them and we have to put the result into the same location.</span></pre><p id="0208" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在 skimage 库的帮助下尝试一下。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="00c5" class="mp ld it ml b gy mq mr l ms mt">from skimage import io<br/>import matplotlib.pyplot as plt</span><span id="84f2" class="mp ld it ml b gy mu mr l ms mt">def f(x):<br/>    return x * 1.5</span><span id="d412" class="mp ld it ml b gy mu mr l ms mt">def point_operation(image, method):<br/>    for row in range(0, image.shape[0]):<br/>        for col in range(0, image.shape[1]):<br/>            image[row][col] = method(image[row][col])</span><span id="40aa" class="mp ld it ml b gy mu mr l ms mt">    return image</span><span id="a085" class="mp ld it ml b gy mu mr l ms mt">if __name__ == '__main__':<br/>   image = io.imread('~/Desktop/Lenna_gray.png')<br/>   image_modified = point_operation(image.copy(), f)</span><span id="835d" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image)</span><span id="b7c8" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image_modified)</span><span id="36db" class="mp ld it ml b gy mu mr l ms mt">   plt.show()</span><span id="a185" class="mp ld it ml b gy mu mr l ms mt"><br/>Output: Figure-1</span></pre><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ng"><img src="../Images/1a748904fcc5a064e904398a77f5b6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRDNQ9iefpRi892JP5OkVQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-1 (Before and After contrast modification)</figcaption></figure><h2 id="cfe3" class="mp ld it bd le mv mw dn li mx my dp lm kb mz na lq kf nb nc lu kj nd ne ly nf bi translated">亮度修改</h2><p id="3abd" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">让我们将图像的对比度增加 50 个单位。你能猜到我们应该对每个像素执行什么操作吗？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="46cb" class="mp ld it ml b gy mq mr l ms mt">f_contrast(a) = a + 50</span><span id="89d0" class="mp ld it ml b gy mu mr l ms mt">#We should iteratively get pixel values in image one by one modify them and we have to put the result into the same location.</span></pre><p id="1139" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在 skimage 库的帮助下尝试一下。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="cf4e" class="mp ld it ml b gy mq mr l ms mt">from skimage import io<br/>import matplotlib.pyplot as plt</span><span id="e046" class="mp ld it ml b gy mu mr l ms mt">def f(x):<br/>    return x + 50</span><span id="7dd4" class="mp ld it ml b gy mu mr l ms mt">def point_operation(image, method):<br/>    for row in range(0, image.shape[0]):<br/>        for col in range(0, image.shape[1]):<br/>            image[row][col] = method(image[row][col])<br/>    return image</span><span id="cc6c" class="mp ld it ml b gy mu mr l ms mt">if __name__ == '__main__':<br/>   image = io.imread('~/Desktop/Lenna_gray.png')<br/>   image_modified = point_operation(image.copy(), f)</span><span id="89fd" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image)</span><span id="8ed5" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image_modified)</span><span id="66aa" class="mp ld it ml b gy mu mr l ms mt">   plt.show()</span><span id="13ef" class="mp ld it ml b gy mu mr l ms mt">Output: Figure-2</span></pre><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/67aba3cfffdec9a3fe23d1cd2f5e3b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxGQiJXUQ6swyTei9orcjw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-2 (Before and After Brightness Modification</figcaption></figure><p id="bb3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是你有没有注意到在我们修改过的图像中有一种连线行为？是的，它们没有我们想象的那么干净。图像中的某些区域破坏了图像的结构。有什么问题吗？</p><p id="67db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们使用算术运算修改像素值时，我们应该记住修改后的值应该在可接受的亮度值范围内。在我们的例子中，它应该在[0–255]之间，因为我们使用的是 8 位表示。</p><p id="ebc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们可以使用一种叫做<strong class="js iu">夹紧的技术。</strong>实现夹紧非常容易。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b279" class="mp ld it ml b gy mq mr l ms mt">a' &lt;------- f(a)</span><span id="e05e" class="mp ld it ml b gy mu mr l ms mt">if a' &gt; 255 then a' &lt;------- 255<br/>if a' &lt; 0   then a' &lt;------- 0<br/>else a' &lt;------- a'</span></pre><p id="8305" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以简单地在代码中实现箝位，只需修改如下的点操作函数，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bb0a" class="mp ld it ml b gy mq mr l ms mt">def point_operation(image, method):<br/>    for row in range(0, image.shape[0]):<br/>        for col in range(0, image.shape[1]):<br/>            temp = method(image[row][col])<br/>            if temp &gt; 255: <br/>               image[row][col] = 255<br/>            elif temp &lt; 0:<br/>               image[row][col] = 0<br/>            else:<br/>               image[row][col] = temp</span><span id="aa07" class="mp ld it ml b gy mu mr l ms mt">    return image</span></pre><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ng"><img src="../Images/2cbd31bc1d1f3699e86be7e2dca00184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu-9BKtjza6bNoAXfwMkbQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-3 (Contrast modification after Clamping)</figcaption></figure><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nt"><img src="../Images/edf63a18596529c3791c179f0316a78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMUzi4weAEI2DwZsThiXAA.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-4 (Brightness modification after Clamping)</figcaption></figure><h2 id="ac2b" class="mp ld it bd le mv mw dn li mx my dp lm kb mz na lq kf nb nc lu kj nd ne ly nf bi translated">反转图像</h2><p id="5037" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">反转图像只是反转像素值的顺序。这是通过，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8ca4" class="mp ld it ml b gy mq mr l ms mt">a' = (a x -1) + a_max</span><span id="a7f1" class="mp ld it ml b gy mu mr l ms mt">Here we multiply the pixel value by -1 and then add it with the constant of maximum intensity value of that image, to map the result with in the acceptable range. </span></pre><p id="868a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python 代码反转，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6d6e" class="mp ld it ml b gy mq mr l ms mt">from skimage import io<br/>import matplotlib.pyplot as plt</span><span id="9286" class="mp ld it ml b gy mu mr l ms mt">def point_operation(image):<br/>    a_max = image.max()<br/>    for row in range(0, image.shape[0]):<br/>        for col in range(0, image.shape[1]):<br/>            image[row][col] = (image[row][col] * -1) + a_max</span><span id="487d" class="mp ld it ml b gy mu mr l ms mt">    return image</span><span id="617c" class="mp ld it ml b gy mu mr l ms mt">if __name__ == '__main__':<br/>   image = io.imread('~/Desktop/Lenna_gray.png')<br/>   image_modified = point_operation(image.copy())</span><span id="c7fa" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image)</span><span id="749e" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image_modified)</span><span id="3d06" class="mp ld it ml b gy mu mr l ms mt">   plt.show()</span></pre><h2 id="2295" class="mp ld it bd le mv mw dn li mx my dp lm kb mz na lq kf nb nc lu kj nd ne ly nf bi translated">阈值化图像</h2><p id="b162" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">阈值处理是一种特殊的量化操作，用于将图像修改为其二进制版本。这项技术非常简单，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ed92" class="mp ld it ml b gy mq mr l ms mt">if a &gt;= threshold then a' = 255<br/>else a' = 0</span><span id="7033" class="mp ld it ml b gy mu mr l ms mt">#Here threshold can be any value within the acceptable intensity range of a perticular image, in our case within [0-255]</span></pre><p id="c2dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python 代码反转，</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a7d5" class="mp ld it ml b gy mq mr l ms mt">from skimage import io<br/>import matplotlib.pyplot as plt</span><span id="a428" class="mp ld it ml b gy mu mr l ms mt">def point_operation(image, threshold):<br/>    for row in range(0, image.shape[0]):<br/>        for col in range(0, image.shape[1]):<br/>            if image[row][col] &gt;= threshold:<br/>               image[row][col] = 255<br/>            else:<br/>               image[row][col] = 0</span><span id="336a" class="mp ld it ml b gy mu mr l ms mt">    return image</span><span id="b122" class="mp ld it ml b gy mu mr l ms mt">if __name__ == '__main__':<br/>   image = io.imread('~/Desktop/Lenna_gray.png')<br/>   image_modified = point_operation(image.copy(), 100)</span><span id="3cc4" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image)</span><span id="ffcc" class="mp ld it ml b gy mu mr l ms mt">   plt.figure()<br/>   _ = io.imshow(image_modified)</span><span id="ad90" class="mp ld it ml b gy mu mr l ms mt">   plt.show()</span></pre><p id="7291" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自己尝试上述反相和阈值函数的代码，以可视化输出。在 skimage 中有 API 函数可以用来执行上述操作，你可以自由探索。</p><p id="deed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望大家对点算符及其一些应用有更好的了解！！！</p></div></div>    
</body>
</html>