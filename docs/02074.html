<html>
<head>
<title>How you can change the world by learning Data Structures and Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过学习数据结构和算法来改变世界</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-you-can-change-the-world-by-learning-data-structures-and-algorithms-84566c1829e3?source=collection_archive---------19-----------------------#2019-04-05">https://towardsdatascience.com/how-you-can-change-the-world-by-learning-data-structures-and-algorithms-84566c1829e3?source=collection_archive---------19-----------------------#2019-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6317a39aa50e5c14a99f9b3864608415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7ErXDCmWawXlvHVvW7rfg.jpeg"/></div></div></figure><p id="cdca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为开发者，你有改变世界的力量！你可以编写支持新技术的程序。例如，开发软件来发现疾病的早期诊断。但是，这不是唯一的方法，你可以通过创建项目间接做到这一点，让人们更有效率，并帮助他们腾出时间做其他令人惊叹的事情。无论你做什么，它都有可能影响使用它的社区。</p><p id="f146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这些成就只有在我们编写快速且可伸缩的软件时才有可能实现。学习如何测量你的代码性能是这篇文章的目标。</p><p id="81c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将探索如何使用算法分析来测量代码性能:<strong class="kd iu">时间复杂度</strong>和<strong class="kd iu">大 O 符号</strong>。</p><p id="bede" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们看一个真实的故事来了解为什么这很重要。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="94ca" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">拯救了数百万人生命的算法</h1><p id="9a6e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在第二次世界大战期间，德国人使用调幅无线电信号与欧洲各地的军队通信。任何一个有 AM 频率无线电和一些莫尔斯电码知识的人都可以截获这个信息。然而，信息被编码了！所有被攻击的国家都试图破译它。有时，他们很幸运，能够在一天结束时理解一些信息。不幸的是，纳粹每天都在改变编码！</p><p id="167c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一位名叫艾伦·图灵的杰出数学家加入了英国军队，破解了德国的“谜”密码。他知道如果他们继续用笔和纸来计算，他们将永远不会成功。所以经过几个月的努力，他们造出了一台机器。不幸的是，这个设备的第一个版本需要很长时间来解码一条信息！所以，它不是很有用。</p><p id="ea3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">艾伦的团队发现每条加密信息都以同样的字符串结尾:“希特勒万岁”啊哈！改变算法后，机器解码传输的速度快了很多！他们用这些信息来更快地结束战争，拯救数百万人的生命！</p><p id="6ad7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">同一台即将因故障而关闭的机器变成了一个活的拯救者。同样，当你编写高效的代码时，你可以用你的计算资源做更多的事情。这就是我们在这个帖子系列中要学习的内容！</em></p><p id="3425" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个流行的算法是谢尔盖·布林和拉里·佩奇(谷歌创始人)在 1998 年开发的<code class="fe mk ml mm mn b">PageRank</code>。这种算法曾经(现在也是)被谷歌搜索引擎用来理解数万亿的网页。谷歌不是唯一的搜索引擎。然而，由于他们的算法返回了更好的结果，大多数竞争者逐渐消失了。今天，它为每天 30 亿次搜索中的大部分提供了快速的动力。这就是可扩展算法的力量！🏋🏻‍</p><h1 id="49e6" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">那么，为什么要学习写高效的算法呢？</h1><p id="f22c" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">优点很多；这些只是其中的一部分:</p><ul class=""><li id="bbdc" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">你会成为一名更好的软件开发人员(并获得更好的工作/收入)。</li><li id="6a99" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">花更少的时间调试、优化和重写代码。</li><li id="9422" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">您的软件将在相同的硬件上运行得更快(扩展成本更低)。</li><li id="2cb2" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">你的程序可能被用来帮助拯救生命的发现(也许？).</li></ul><p id="f470" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事不宜迟，让我们加紧我们的游戏！</p><h1 id="bad0" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">什么是算法？</h1><p id="fa6a" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">算法(你可能知道)是如何完成某项任务的步骤。例如，当你做饭时，你按照一个<strong class="kd iu">食谱</strong>来准备一道菜。如果你玩游戏，你正在设计<strong class="kd iu">策略</strong>来帮助你获胜。同样，计算机中的算法是用来解决问题的一组指令。</p><blockquote class="nh ni nj"><p id="b514" class="kb kc mj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated"><em class="it">算法是执行任务的指令</em></p></blockquote><p id="2951" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有“好”和“坏”的算法。好的很快；坏的很慢。缓慢的算法花费更多的钱，并使一些计算在我们的生命周期内不可能！</p><p id="0feb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将探索算法的基本概念。此外，我们将学习如何区分“快”和“慢”。更好的是，您将能够“测量”您的算法的性能并改进它们！</p><h1 id="e570" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">如何提高自己的编码技能？</h1><p id="284e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">改善某事的第一步是衡量它。</p><blockquote class="nh ni nj"><p id="ef62" class="kb kc mj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated">测量是控制并最终改进的第一步。如果你不能衡量一件事，你就不能理解它。如果你不能理解它，你就不能控制它。如果你不能控制它，你就不能改善它。</p><p id="a0f4" class="kb kc mj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it"> H. J .哈灵顿</em> </strong></p></blockquote><p id="bca7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你如何“测量”你的代码？你会计算跑步需要“多长时间”吗？如果你在移动设备或者量子计算机上运行同样的程序呢？同样的代码会给你不同的结果吧？</p><p id="571c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要回答这些问题，我们需要先确定一些概念，比如<strong class="kd iu">时间复杂度</strong>！</p><h1 id="a848" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">时间复杂度</h1><p id="59fd" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">时间复杂度(或<strong class="kd iu">运行时间</strong>)是算法运行所需的估计时间。然而，你不用秒来度量时间复杂度，而是作为输入的<strong class="kd iu">函数</strong>。(我知道这很奇怪，但请原谅我)。</p><blockquote class="nh ni nj"><p id="ced9" class="kb kc mj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated"><em class="it"/><strong class="kd iu"><em class="it">时间复杂度</em> </strong> <em class="it">不是关于计时算法需要多长时间。而是执行</em>多少个操作<em class="it">。一个程序执行的指令数量受输入大小和元素排列方式的影响。</em></p></blockquote><p id="83e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么时间复杂度被表示为输入的函数？好吧，假设你想对一组数字进行排序。如果元素已经排序，程序将执行较少的操作。相反，如果项目顺序相反，将需要更多的时间来排序。因此，程序执行的时间与输入大小和元素的排列方式直接相关。</p><p id="91d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以说对于每一个算法都有如下的运行时间:</p><ul class=""><li id="0289" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">最坏情况下的时间复杂度(例如，输入元素顺序相反)</li><li id="485e" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">最佳情况时间复杂度(例如，已经排序)</li><li id="7ccd" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">平均情况时间复杂度(例如，随机顺序的元素)</li></ul><p id="68a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通常更关心<strong class="kd iu">最坏情况下的时间复杂度</strong>(我们抱着最好的希望，但也在为<em class="mj">最坏的情况</em>做准备)。</p><h1 id="f587" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">计算时间复杂度</h1><p id="5ad6" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">这里有一个如何计算时间复杂度的代码示例:<em class="mj">在一个数组中找到最小的数</em>。</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="df44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将<code class="fe mk ml mm mn b">getMin</code>表示为输入<code class="fe mk ml mm mn b">n</code>大小的函数，基于它必须执行的操作数量。为了简单起见，让我们假设每行代码在 CPU 中花费相同的时间来执行。让我们算一下总数:</p><ul class=""><li id="a45d" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">线 6: 1 操作</li><li id="fe38" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">线 7: 1 操作</li><li id="0b18" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">第 9–13 行:这是一个执行大小为<code class="fe mk ml mm mn b">n</code>倍的循环</li><li id="cd8e" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">—10 号线:1 操作</li><li id="cfa5" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">—第 11 行:这个比较棘手。它在一个条件中。我们将假设最坏的情况，即数组按升序排序。每次都会执行条件(<code class="fe mk ml mm mn b">if</code>块)。因此，1 次操作</li><li id="37b1" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">第 14 行:1 操作</li></ul><p id="472a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总而言之，我们在循环外有<code class="fe mk ml mm mn b">3</code>操作，在<code class="fe mk ml mm mn b">forEach</code>块内有<code class="fe mk ml mm mn b">2</code>操作。因为循环的大小是<code class="fe mk ml mm mn b">n</code>，所以我们只有<code class="fe mk ml mm mn b">2(n) + 3</code>。</p><p id="da9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，这个表达式有些过于具体，很难用它来比较算法。我们将应用<strong class="kd iu">渐近分析</strong>来进一步简化这个表达式。</p><h1 id="dedc" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">渐近分析</h1><p id="91a3" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">渐近分析只是评估函数，因为它们的值接近无穷大。在我们之前的例子<code class="fe mk ml mm mn b">2(n) + 3</code>中，我们可以将其概括为<code class="fe mk ml mm mn b">k(n) + c</code>。随着<code class="fe mk ml mm mn b">n</code>值的增长，值<code class="fe mk ml mm mn b">c</code>越来越不重要，如下表所示:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2f8e9feafa98aaf0d41ef51c4178cadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*jykEg4zqwuNjOgO8UohNCQ.png"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">Input size vs Number of Operation</figcaption></figure><p id="02ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">信不信由你，常量<code class="fe mk ml mm mn b">k</code>也不会有太大的区别。使用这种渐近分析，我们采用高阶元素，在这种情况下:<code class="fe mk ml mm mn b">n</code>。</p><p id="2edc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再做一个例子，这样我们就可以得到这个概念。假设我们有下面的函数:3 n + 2n + 20。使用渐近分析的结果会是什么？</p><blockquote class="nh ni nj"><p id="26e5" class="kb kc mj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated"><em class="it"> `3 n + 2n + 20 `随着` n '越长越大；最重要的术语是“n”。</em></p></blockquote><p id="a56e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到我们的例子<code class="fe mk ml mm mn b">getMin</code>，我们可以说这个函数的时间复杂度为<code class="fe mk ml mm mn b">n</code>。正如你所看到的，我们可以把它近似为<code class="fe mk ml mm mn b">2(n)</code>，去掉<code class="fe mk ml mm mn b">+3</code>，因为随着‘n’不断变大，它不会增加太多的价值。</p><p id="4968" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们感兴趣的是这里的大图，我们将使用渐近分析来帮助我们。有了这个框架，对比算法，就舒服多了。我们可以用它们最重要的术语来比较运行时间:n 或 n 或`2^n`.</p><h1 id="b236" class="lg lh it bd li lj mo ll lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md bi translated">函数的 Big-O 符号和增长率</h1><p id="777d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">大 O 符号结合了我们在上两节学到的关于<strong class="kd iu">最坏情况时间复杂度</strong>和<strong class="kd iu">渐近分析</strong>的内容。</p><blockquote class="nh ni nj"><p id="dab9" class="kb kc mj kd b ke kf kg kh ki kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ky im bi translated"><em class="it">字母‘o’指的是某个功能的</em> <strong class="kd iu"> <em class="it">顺序</em> </strong> <em class="it">。</em></p></blockquote><p id="c8ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大 O 符号用于根据算法的最差运行时间对算法进行分类，也称为函数增长率的上限。</p><p id="3dfd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们之前使用<code class="fe mk ml mm mn b">getMin</code>函数的例子中，我们可以说它的运行时间为<code class="fe mk ml mm mn b">O(n)</code>。有许多不同的运行时间。以下是我们将在下一篇文章中讨论的最常见的问题，以及它们与时间的关系:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/6bfcc23f24da4ddcc78941b11e572d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNttU1Wgihyk2ppJqWlvFg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">Input size (n) vs Time Taken by Growth Rate</figcaption></figure><p id="2836" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，有些算法非常耗时。一个小至 100 的输入大小，即使我们有一个 1 PHz(100 万 GHz)的 CPU 也无法计算！！硬件的可扩展性不如软件。</p><p id="2c5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一篇文章中，我们将通过一两个代码示例来探究所有这些时间复杂性！你准备好成为一名超级程序员并扩展你的代码了吗？！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="8cd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他资源:</p><ul class=""><li id="900a" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><a class="ae nz" href="https://github.com/amejiarosario/dsa.js-data-structures-algorithms-javascript" rel="noopener ugc nofollow" target="_blank">使用 JS-Github 解释的数据结构和算法</a></li><li id="40bb" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><a class="ae nz" href="https://adrianmejia.com/tags/tutorial-algorithms/" rel="noopener ugc nofollow" target="_blank">算法教程——帖子</a></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="f217" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">原载于 2019 年 4 月 5 日</em><a class="ae nz" href="https://adrianmejia.com/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="mj">https://adrianmejia.com</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>