<html>
<head>
<title>A Simple Approach To Templated SQL Queries In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中模板化 SQL 查询的一种简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-approach-to-templated-sql-queries-in-python-adc4f0dc511?source=collection_archive---------1-----------------------#2019-04-09">https://towardsdatascience.com/a-simple-approach-to-templated-sql-queries-in-python-adc4f0dc511?source=collection_archive---------1-----------------------#2019-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="330e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">加速和自动化您的分析</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d8d9d6ed217c1585f856dcd441a7708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSiyHGaSRE_l9zrriRANsw.jpeg"/></div></div></figure><p id="b637" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在许多情况下，人们都希望在 SQL 查询中插入参数，并且有许多方法可以在 python 中实现模板化的 SQL 查询。在不比较不同方法的情况下，这篇文章解释了一种使用<a class="ae ln" href="https://github.com/hashedin/jinjasql" rel="noopener ugc nofollow" target="_blank"> JinjaSql </a>参数化 SQL 的简单而有效的方法。除了<a class="ae ln" href="http://jinja.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Jinja2 </a>的许多强大功能，如条件语句和循环，JinjaSql 还提供了一种简单明了的方法，不仅可以参数化代入<code class="fe lo lp lq lr b">where</code>和<code class="fe lo lp lq lr b">in</code>子句的值，还可以参数化 Sql 语句本身，包括参数化表和列名，以及通过组合整个代码块来组合查询。</p><h1 id="9715" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本参数替代</h1><p id="388f" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">假设我们有一个保存金融交易记录的表<code class="fe lo lp lq lr b">transactions</code>。该表中的列可以是<code class="fe lo lp lq lr b">transaction_id</code>、<code class="fe lo lp lq lr b">user_id</code>、<code class="fe lo lp lq lr b">transaction_date</code>和<code class="fe lo lp lq lr b">amount</code>。要计算给定用户在给定日期的交易数量和总金额，直接对数据库的查询可能如下所示</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="e9f9" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">select</strong><br/>    user_id<br/>    , count(*) as num_transactions<br/>    , sum(amount) as total_amount<br/><strong class="lr ir">from</strong><br/>    transactions<br/><strong class="lr ir">where</strong><br/>    user_id = 1234<br/>    and transaction_date = '2019-03-02'<br/><strong class="lr ir">group by</strong><br/>    user_id</span></pre><p id="9de3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们假设数据库会自动将日期的字符串表示形式的<code class="fe lo lp lq lr b">YYYY-MM-DD</code>格式转换成适当的日期类型。</p><p id="1b32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想要为任意用户和日期运行上面的查询，我们需要参数化<code class="fe lo lp lq lr b">user_id</code>和<code class="fe lo lp lq lr b">transaction_date</code>值。在 JinjaSql 中，相应的模板将简单地变成</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="a86b" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">select</strong><br/>    user_id<br/>    , count(*) as num_transactions<br/>    , sum(amount) as total_amount<br/><strong class="lr ir">from</strong><br/>    transactions<br/><strong class="lr ir">where</strong><br/>    user_id = {{ uid }}<br/>    and transaction_date = {{ tdate }}<br/><strong class="lr ir">group by</strong><br/>    user_id</span></pre><p id="6e4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，值被占位符替换，python 变量名用双花括号<code class="fe lo lp lq lr b">{{ }}</code>括起来。注意，选择变量名<code class="fe lo lp lq lr b">uid</code>和<code class="fe lo lp lq lr b">tdate</code>只是为了证明它们是变量名，与列名本身没有任何关系。存储在 python 变量中的同一模板的一个可读性更好的版本是</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="7982" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">user_transaction_template</strong> = '''<br/><strong class="lr ir">select</strong><br/>    user_id<br/>    , count(*) as num_transactions<br/>    , sum(amount) as total_amount<br/><strong class="lr ir">from</strong><br/>    transactions<br/><strong class="lr ir">where</strong><br/>    user_id = {{ user_id }}<br/>    and transaction_date = {{ transaction_date }}<br/><strong class="lr ir">group by</strong><br/>    user_id<br/>'''</span></pre><p id="fef7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要为查询设置参数。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="5657" class="mt lt iq lr b gy mu mv l mw mx">params = {<br/>    'user_id': 1234,<br/>    'transaction_date': '2019-03-02',<br/>}</span></pre><p id="69c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，从这个模板生成 SQL 查询非常简单。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="7bf3" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">from</strong> jinjasql <strong class="lr ir">import</strong> JinjaSql<br/>j = JinjaSql(param_style='pyformat')<br/>query, bind_params = j.prepare_query(user_transaction_template, params)</span></pre><p id="2a94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们打印<code class="fe lo lp lq lr b">query</code>和<code class="fe lo lp lq lr b">bind_params</code>，我们会发现前者是一个参数化的字符串，而后者是一个参数化的<code class="fe lo lp lq lr b">OrderedDict</code>:</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="3e11" class="mt lt iq lr b gy mu mv l mw mx">&gt;&gt;&gt; print(query)<br/><strong class="lr ir">select</strong><br/>    user_id<br/>    , count(*) as num_transactions<br/>    , sum(amount) as total_amount<br/><strong class="lr ir">from</strong><br/>    transactions<br/><strong class="lr ir">where</strong><br/>    user_id = %(user_id)s<br/>    and transaction_date = %(transaction_date)s<br/><strong class="lr ir">group by</strong><br/>    user_id</span><span id="4749" class="mt lt iq lr b gy my mv l mw mx">&gt;&gt;&gt; print(bind_params)<br/><strong class="lr ir">OrderedDict</strong>([('user_id', 1234), ('transaction_date', '2018-03-01')])</span></pre><h1 id="bb43" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行参数化查询</h1><p id="d27c" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">许多数据库连接都可以选择将<code class="fe lo lp lq lr b">bind_params</code>作为参数传递给在连接上执行 SQL 查询的方法。对于数据科学家来说，在 Pandas 数据框中获得查询结果可能是很自然的事情。一旦我们有了连接<code class="fe lo lp lq lr b">conn</code>，就像运行<code class="fe lo lp lq lr b">read_sql</code>一样简单:</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="b041" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">import</strong> pandas <strong class="lr ir">as</strong> pd<br/>frm = pd.read_sql(query, conn, params=bind_params)</span></pre><p id="5e3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其他示例参见<a class="ae ln" href="https://github.com/hashedin/jinjasql" rel="noopener ugc nofollow" target="_blank"> JinjaSql 文档</a>。</p><h1 id="8407" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从模板到最终的 SQL 查询</h1><p id="4d8c" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">通常希望在运行查询之前用所有参数完全展开查询。例如，记录完整的查询对于调试批处理过程非常重要，因为可以将查询从日志中直接复制粘贴到 interactive SQL 界面中。使用 python 内置的字符串替换将<code class="fe lo lp lq lr b">bind_params</code>替换到<code class="fe lo lp lq lr b">query</code>中是很诱人的。然而，我们很快发现字符串参数需要加引号才能产生正确的 SQL。例如，在上面的模板中，日期值必须用单引号括起来。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="0744" class="mt lt iq lr b gy mu mv l mw mx">&gt;&gt;&gt; print(query % bind_params)<br/>​<br/><strong class="lr ir">select</strong><br/>    user_id<br/>    , count(*) as num_transactions<br/>    , sum(amount) as total_amount<br/><strong class="lr ir">from</strong><br/>    transactions<br/><strong class="lr ir">where</strong><br/>    user_id = 1234<br/>    and transaction_date = 2018-03-01<br/><strong class="lr ir">group by</strong><br/>    user_id</span></pre><p id="9f68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理这个问题，我们需要一个助手函数来正确地引用字符串参数。我们通过调用来检测参数是否是字符串</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="6cad" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">from</strong> six <strong class="lr ir">import</strong> string_types<br/>isinstance(value, string_types)</span></pre><p id="4f9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这对 python 3 和 2.7 都适用。字符串参数被转换为<code class="fe lo lp lq lr b">str</code>类型，名称中的单引号被另一个单引号转义，最后，整个值被括在单引号中。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="4463" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">from</strong> six <strong class="lr ir">import</strong> string_types</span><span id="bc9a" class="mt lt iq lr b gy my mv l mw mx"><strong class="lr ir">def</strong> quote_sql_string(value):<br/>    '''<br/>    If `value` is a string type, escapes single quotes in the string<br/>    and returns the string enclosed in single quotes.<br/>    '''<br/>    <strong class="lr ir">if</strong> isinstance(value, string_types):<br/>        new_value = str(value)<br/>        new_value = new_value.replace("'", "''")<br/>        return "'{}'".format(new_value)<br/>    <strong class="lr ir">return</strong> value</span></pre><p id="8659" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，为了将模板转换成正确的 SQL，我们循环遍历<code class="fe lo lp lq lr b">bind_params</code>，引用字符串，然后执行字符串替换。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="c316" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">from</strong> copy <strong class="lr ir">import</strong> deepcopy</span><span id="5728" class="mt lt iq lr b gy my mv l mw mx"><strong class="lr ir">def</strong> get_sql_from_template(query, bind_params):<br/>    <strong class="lr ir">if</strong> <strong class="lr ir">not</strong> bind_params:<br/>        <strong class="lr ir">return</strong> query<br/>    params = deepcopy(bind_params)<br/>    <strong class="lr ir">for</strong> key, val <strong class="lr ir">in</strong> params.items():<br/>        params[key] = quote_sql_string(val)<br/>    <strong class="lr ir">return</strong> query % params</span></pre><p id="b614" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以很容易地得到最终的查询，我们可以记录或交互运行:</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="c302" class="mt lt iq lr b gy mu mv l mw mx">&gt;&gt;&gt; print(get_sql_from_template(query, bind_params))</span><span id="45d5" class="mt lt iq lr b gy my mv l mw mx"><strong class="lr ir">select</strong><br/>    user_id<br/>    , count(*) as num_transactions<br/>    , sum(amount) as total_amount<br/><strong class="lr ir">from</strong><br/>    transactions<br/><strong class="lr ir">where</strong><br/>    user_id = 1234<br/>    and transaction_date = '2018-03-01'<br/><strong class="lr ir">group by</strong><br/>    user_id</span></pre><p id="97f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将所有这些放在一起，另一个 helper 函数包装 JinjaSql 调用，简单地获取模板和一个<code class="fe lo lp lq lr b">dict</code>参数，并返回完整的 Sql。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="a358" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">from</strong> jinjasql <strong class="lr ir">import</strong> JinjaSql<br/>​<br/><strong class="lr ir">def</strong> apply_sql_template(template, parameters):<br/>    '''<br/>    Apply a JinjaSql template (string) substituting parameters (dict) and return<br/>    the final SQL.<br/>    '''<br/>    j = JinjaSql(param_style='pyformat')<br/>    query, bind_params = j.prepare_query(template, parameters)<br/>    return get_sql_from_template(query, bind_params)</span></pre><h1 id="c64f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算列的统计信息</h1><p id="a78f" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">无论是在第一次浏览数据时还是在生产中进行数据验证时，对存储在特定数据库列中的值计算统计数据都很方便。因为我们只想演示模板的一些特性，为了简单起见，让我们只使用<code class="fe lo lp lq lr b">integer</code>列，比如上面表<code class="fe lo lp lq lr b">transactions</code>中的<code class="fe lo lp lq lr b">user_id</code>列。对于整数列，我们感兴趣的是唯一值的数量、最小值和最大值以及空值的数量。有些列可能有一个默认值，比如说，<code class="fe lo lp lq lr b">-1</code>，它的缺点超出了本文的范围，但是，我们确实想通过报告默认值的数量来捕获它。</p><p id="0009" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑下面的模板和函数。该函数将表名、列名和默认值作为参数，并返回用于计算统计数据的 SQL。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="1651" class="mt lt iq lr b gy mu mv l mw mx"><strong class="lr ir">COLUMN_STATS_TEMPLATE</strong> = '''<br/><strong class="lr ir">select</strong><br/>    {{ column_name | sqlsafe }} as column_name<br/>    , count(*) as num_rows<br/>    , count(distinct {{ column_name | sqlsafe }}) as num_unique<br/>    , sum(case when {{ column_name | sqlsafe }} is null then 1 else 0 end) as num_nulls<br/>    {% if default_value %}<br/>    , sum(case when {{ column_name | sqlsafe }} = {{ default_value }} then 1 else 0 end) as num_default<br/>    {% else %}<br/>    , 0 as num_default<br/>    {% endif %}<br/>    , min({{ column_name | sqlsafe }}) as min_value<br/>    , max({{ column_name | sqlsafe }}) as max_value<br/><strong class="lr ir">from</strong><br/>    {{ table_name | sqlsafe }}<br/>'''<br/>​<br/>​<br/><strong class="lr ir">def</strong> get_column_stats_sql(table_name, column_name, default_value):<br/>    '''<br/>    Returns the SQL for computing column statistics.<br/>    Passing None for the default_value results in zero output for the number<br/>    of default values.<br/>    '''<br/>    params = {<br/>        'table_name': table_name,<br/>        'column_name': column_name,<br/>        'default_value': default_value,<br/>    }<br/>    <strong class="lr ir">return</strong> apply_sql_template(COLUMN_STATS_TEMPLATE, params)</span></pre><p id="15a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数很简单而且非常强大，因为它适用于任何表中的任何列。注意模板中的<code class="fe lo lp lq lr b">{% if default_value %}</code>语法。如果传递给函数的默认值是<code class="fe lo lp lq lr b">None</code>，SQL 将在<code class="fe lo lp lq lr b">num_default</code>字段中返回零。</p><p id="fe18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe lo lp lq lr b">default_value</code>设置为 None，上面的函数和模板也可以处理字符串、日期和其他数据类型。然而，为了更智能地处理不同的数据类型，有必要扩展该函数，以将数据类型作为参数，并构建特定于不同数据类型的逻辑。例如，可能想知道字符串长度的最小值和最大值，而不是值本身的最小值和最大值。</p><p id="855e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看<code class="fe lo lp lq lr b">transactions.user_id</code>列的输出。</p><pre class="kg kh ki kj gt mp lr mq mr aw ms bi"><span id="af66" class="mt lt iq lr b gy mu mv l mw mx">&gt;&gt;&gt; print(get_column_stats_sql('transactions', 'user_id', None))</span><span id="1351" class="mt lt iq lr b gy my mv l mw mx"><strong class="lr ir">select</strong><br/>    user_id as column_name<br/>    , count(*) as num_rows<br/>    , count(distinct user_id) as num_unique<br/>    , sum(case when user_id is null then 1 else 0 end) as num_nulls<br/>    , 0 as num_default<br/>    , min(user_id) as min_value<br/>    , max(user_id) as max_value<br/><strong class="lr ir">from</strong><br/>    transactions</span></pre><p id="f4d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，空行出现在<code class="fe lo lp lq lr b">{% %}</code>子句的位置，可以被删除。</p><h1 id="df01" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="ba2a" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">有了上面的帮助函数，用 python 创建和运行模板化的 SQL 查询就非常容易了。因为参数替换的细节是隐藏的，所以可以专注于构建模板和参数集，然后调用单个函数来获得最终的 SQL。</p><p id="742e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个重要的警告是代码注入的风险。对于批处理来说，这应该不是问题，但是在 web 应用程序中使用<code class="fe lo lp lq lr b">sqlsafe</code>构造可能会有危险。<code class="fe lo lp lq lr b">sqlsafe</code>关键字表明用户(您)确信不可能进行代码注入，并负责将参数中传递的任何字符串直接放入查询中。</p><p id="88de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，在查询中放入任意字符串的能力允许将整个代码块传递到模板中。例如，可以不通过上面的<code class="fe lo lp lq lr b">table_name='transactions'</code>，而是通过<code class="fe lo lp lq lr b">'(select * from transactions where transaction_date = 2018-03-01) t'</code>，查询仍然可以工作。</p><p id="f64a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要探索 SQL 模板更强大的特性，也可以参考关于使用 JinjaSql 的 Python 中的<a class="ae ln" rel="noopener" target="_blank" href="/advanced-sql-templates-in-python-with-jinjasql-b996eadd761d">高级 SQL 模板教程</a>。</p><p id="4dc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本帖中的<a class="ae ln" href="https://github.com/sizrailev/life-around-data-code/blob/master/pylad/sql_templates_base.py" rel="noopener ugc nofollow" target="_blank">代码获得了</a><a class="ae ln" href="https://opensource.org/licenses/MIT" rel="noopener ugc nofollow" target="_blank">麻省理工学院许可</a>的许可。这篇文章最初出现在<a class="ae ln" href="http://www.lifearounddata.com/templated-sql-queries-in-python/" rel="noopener ugc nofollow" target="_blank">生活数据</a>博客上。</p><p id="2dd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Sergei Izrailev 的照片和图片</p></div></div>    
</body>
</html>