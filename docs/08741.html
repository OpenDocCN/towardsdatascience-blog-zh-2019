<html>
<head>
<title>Bounded Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有界聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bounded-clustering-7ac02128c893?source=collection_archive---------23-----------------------#2019-11-23">https://towardsdatascience.com/bounded-clustering-7ac02128c893?source=collection_archive---------23-----------------------#2019-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi ca"><img src="../Images/1ffbf1f1a7120b77913ee828a2635719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFLuzLM_0t3RlCwh8YYl4Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="ea3a" class="pw-subtitle-paragraph jx iz ja bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">一种适用于有限规模聚类的聚类算法</h2></div><p id="ec87" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">想象一个非常现实的场景，你所在城镇的几个家庭计划一起去旅行。</p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi ll"><img src="../Images/402a6e31dcfe8a7be0b888458004e55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwEoHRLX5IlEU2mIWI8zoA.png"/></div></div></figure><p id="15ff" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">为了节省运输费用，他们想租几辆小型公共汽车。当然，越少越好。为了使交通安排高效和愉快，他们希望每个家庭都呆在同一辆小巴上，并根据地理位置将这些家庭分开，以避免多余的弯路。</p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/07f915db7b752945e00010ffc382f177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*6DEGUURS4D5AFpYM6tH-uA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Our input data of families, each pin indicates location and number of people who want to join the roadtrip.</figcaption></figure><p id="b6b4" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">用数学的方法来说，我们有<code class="fe lv lw lx ly b">n</code>个家庭，每个家庭<code class="fe lv lw lx ly b">f</code>的家庭成员数量是<code class="fe lv lw lx ly b">s(f)</code>，每辆小型货车的座位数量是<code class="fe lv lw lx ly b">m</code>。<code class="fe lv lw lx ly b">n</code>至<code class="fe lv lw lx ly b">k</code>小巴中家庭的有效划分是指每辆小巴中家庭成员的总数不超过小巴的载客量。一个<strong class="kr jb">好的</strong>隔断是指每辆小型货车经过的距离最小。一个<strong class="kr jb">大的</strong>分区，是一个在最小化小客车数量和最小化每辆小客车行驶距离之间进行权衡的优化分区。</p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi lz"><img src="../Images/26d9fcc30f7d3e0f935d67ac412bcf07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFvc21Urr4JX4UAp7b__kA.png"/></div></div></figure><blockquote class="ma mb mc"><p id="c9b3" class="kp kq md kr b ks kt kb ku kv kw ke kx me kz la lb mf ld le lf mg lh li lj lk ij bi translated"><strong class="kr jb">本帖包含伪代码。对于真正的代码你可以去</strong> <a class="ae mh" href="https://github.com/DalyaG/CodeSnippetsForPosterity/tree/master/BoundedClustering" rel="noopener ugc nofollow" target="_blank"> <strong class="kr jb">这里</strong> </a> <strong class="kr jb">。</strong></p></blockquote><h1 id="e4cf" class="mi mj ja bd mk ml mm mn mo mp mq mr ms kg mt kh mu kj mv kk mw km mx kn my mz bi translated">听起来相当困难，是吗？</h1><p id="42d1" class="pw-post-body-paragraph kp kq ja kr b ks na kb ku kv nb ke kx ky nc la lb lc nd le lf lg ne li lj lk ij bi translated">确实如此。一辆小型公共汽车的情况可以很容易地简化为<a class="ae mh" href="https://en.wikipedia.org/wiki/Knapsack_problem" rel="noopener ugc nofollow" target="_blank">背包</a>，使得手头的问题在计算上是 NP 困难的(更准确地说，是 NP 完全的，但是谁在计算)。因此，很明显，如果我们想大规模解决这个问题，我们并不是在寻找一个精确的解决方案。</p><p id="7f26" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">我们能做什么？</p><p id="6407" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">让我们把它分成两步:</p><ol class=""><li id="06b5" class="nf ng ja kr b ks kt kv kw ky nh lc ni lg nj lk nk nl nm nn bi translated">给定一个常数<code class="fe lv lw lx ly b">k</code>，找到一个<code class="fe lv lw lx ly b">k</code>小型公共汽车家庭的(启发式)最佳划分。</li><li id="d65d" class="nf ng ja kr b ks no kv np ky nq lc nr lg ns lk nk nl nm nn bi translated">找最好的<code class="fe lv lw lx ly b">k</code>。</li></ol><p id="cc7a" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">步骤(1)将为我们构建好的分区，而步骤(2)将帮助我们找到一个好的分区。</p><h1 id="7061" class="mi mj ja bd mk ml mm mn mo mp mq mr ms kg mt kh mu kj mv kk mw km mx kn my mz bi translated">步骤 I -有界 K-均值聚类</h1><p id="d266" class="pw-post-body-paragraph kp kq ja kr b ks na kb ku kv nb ke kx ky nc la lb lc nd le lf lg ne li lj lk ij bi translated">顾名思义，要为给定的<code class="fe lv lw lx ly b">k</code>找到一个分区，我们将使用著名的<a class="ae mh" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank"> K-Means 聚类</a>算法的一个变体，该算法受本文中<a class="ae mh" href="https://core.ac.uk/download/pdf/61217069.pdf" rel="noopener ugc nofollow" target="_blank">的启发。</a></p><p id="b1b7" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">类似于 K-Means，我们将实现迭代算法，该算法在寻找每个聚类的质心(<em class="md">更新</em>步骤)和将点分配到最近的质心(<em class="md">分配</em>步骤)之间交替。在这个变体中，<em class="md">分配</em>步骤也将确保集群保持它们的有界大小。</p><p id="0076" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">让我们更精确些，从头开始。经典的 K 均值算法大致是这样的:</p><pre class="lm ln lo lp gt nt ly nu nv aw nw bi"><span id="93f9" class="nx mj ja ly b gy ny nz l oa ob">1    centroids &lt;- random <em class="md">k</em> points<br/>2    do <em class="md">n_iter</em> times:<br/>2.1     clusters &lt;- each point assigned to closest centroid<br/>2.2     centroids &lt;- point closest to center in each cluster<br/>3    return clusters</span></pre><p id="b924" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">现在，考虑到有界簇的变化，我们将以如下方式修改步骤<code class="fe lv lw lx ly b">2.1</code>，即<em class="md">分配</em>步骤:</p><pre class="lm ln lo lp gt nt ly nu nv aw nw bi"><span id="f706" class="nx mj ja ly b gy ny nz l oa ob">(<!-- -->2.1).<!-- -->1   points &lt;- sort points by weight, in descending order<br/>(<!-- -->2.1).<!-- -->2   for each point in points:<br/>(<!-- -->2.1).<!-- -->2.1    centroids &lt;- sort centroids by distance from point<br/>(<!-- -->2.1).<!-- -->2.2    centroid &lt;- first centroid in centroids for which total<br/>                         weight + point's weight does not exceed <em class="md">m</em><br/>(<!-- -->2.1).<!-- -->2.3    add point to cluster corresponding to centroid</span></pre><p id="8969" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">你可以在这里看到代码<a class="ae mh" href="https://github.com/DalyaG/CodeSnippetsForPosterity/tree/master/BoundedClustering" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7518937ee119d6120a884c147596c31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*dJylqJVfROl8coNW.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Iterative process of updating clusters, starting from random guess of centroids.</figcaption></figure><p id="518d" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">K-Means 需要记住的另一件事是，这个过程容易不稳定，它可能终止的局部最小值高度依赖于第一次随机猜测。<br/>因此，习惯上要重复执行几次算法，并选择最佳结果。根据 <code class="fe lv lw lx ly b">sklearn.cluster.KMeans</code>的<a class="ae mh" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" rel="noopener ugc nofollow" target="_blank">默认是 10 次重复，我们也跟着做。</a></p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi od"><img src="../Images/ca3b4bdce12c4e966d699e38f2f85ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*903ug7KEI2OswLP19Mmtvg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Example of 4 different repetitions of the algorithm, with 4 different random initial centroids. In bold is the best outcome. Circled are areas where clusters are not well separated, indicating the suboptimality of the outcome.</figcaption></figure><h1 id="63d7" class="mi mj ja bd mk ml mm mn mo mp mq mr ms kg mt kh mu kj mv kk mw km mx kn my mz bi translated">第二步-选择最佳 K 值的肘法</h1><p id="10af" class="pw-post-body-paragraph kp kq ja kr b ks na kb ku kv nb ke kx ky nc la lb lc nd le lf lg ne li lj lk ij bi translated">好了，现在我们知道了如何为固定数量的小巴<code class="fe lv lw lx ly b">k</code>找到一个<strong class="kr jb">好的</strong>分区，那么我们如何才能找到“最好的”<code class="fe lv lw lx ly b">k</code>？</p><p id="692c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">在最小化小公共汽车的数量和最小化每辆小公共汽车行驶的距离之间做出适当的权衡并不容易。</p><p id="f329" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">幸运的是，有些聪明人已经想了很多，常见的做法是用<a class="ae mh" href="https://en.wikipedia.org/wiki/Elbow_method_(clustering)" rel="noopener ugc nofollow" target="_blank">肘法</a>，大致是这样的:</p><pre class="lm ln lo lp gt nt ly nu nv aw nw bi"><span id="ad12" class="nx mj ja ly b gy ny nz l oa ob">1   min_k &lt;- sum(weights) / max cluster size<br/>2   max_k &lt;- min_k + number of sizes to try<br/>3   for each k between min_k and max_k:<br/>3.1    cost_k, clustrs_k &lt;- Bounded K-Means Clustering<br/>4   l &lt;- line between (min_k, kcost_min_k) and (max_k, cost_max_k)<br/>5   opt_k &lt;- (k, cost_k) of maximal distance from l</span></pre><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/7c7e1ccf892ad0c2b13596cc3ba287fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*V-SbjR7UcjxFr0XC3B6KLQ.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Elbow Method: (i) perform K-Means Clustering for a range of different values of k, (ii) draw line between edge values, (iii) find value of k that its cost is furthest from the line.</figcaption></figure><p id="db71" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">让我们看看我们的家庭旅行数据是什么样的:</p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi of"><img src="../Images/ce8f6234e7c2e7e628e5ec3a62c3e7d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hB7KGm1C5NcKZN_LJzI4Sw.png"/></div></div></figure><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi og"><img src="../Images/688ad73413fdf973c2b8ec485200b485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWfZW-PblUVxAl3XJJ6ReA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Partitioning our input data into the optimal number of clusters, <em class="oh">k=8. In our input we had 45 families, with total 82 people, and minibuses of size 12.</em></figcaption></figure><h1 id="0b6a" class="mi mj ja bd mk ml mm mn mo mp mq mr ms kg mt kh mu kj mv kk mw km mx kn my mz bi translated">复杂性分析</h1><p id="fa7b" class="pw-post-body-paragraph kp kq ja kr b ks na kb ku kv nb ke kx ky nc la lb lc nd le lf lg ne li lj lk ij bi translated">让我们分析我们的有界 K 均值聚类的一次迭代。记住我们表示:<code class="fe lv lw lx ly b">n</code>家庭数量，<code class="fe lv lw lx ly b">m</code>小型公共汽车最大尺寸，<code class="fe lv lw lx ly b">k</code>小型公共汽车数量。</p><ul class=""><li id="3993" class="nf ng ja kr b ks kt kv kw ky nh lc ni lg nj lk oi nl nm nn bi translated">在每个<em class="md">赋值</em>步骤中，我们有:<br/> ➪按权重排序点:<code class="fe lv lw lx ly b">n*log(n)</code> <br/> ➪对于每个点:排序质心<code class="fe lv lw lx ly b">k*log(k)</code>，添加到第一个有效质心<code class="fe lv lw lx ly b">k</code> <br/> ➪总计<code class="fe lv lw lx ly b">O(n*log(n) + n*(k*log(k) + k)) = O(n*log(n)*k*log(k))</code></li><li id="f26b" class="nf ng ja kr b ks no kv np ky nq lc nr lg ns lk oi nl nm nn bi translated">在每个<em class="md">更新</em>步骤中:<br/>每个聚类中的最大点数为<code class="fe lv lw lx ly b">n</code>，或者当权重为整数时为<code class="fe lv lw lx ly b">m</code>。<br/>所以，对于每个集群我们需要:<br/> ➪计算集群的中心:<code class="fe lv lw lx ly b">n</code> <br/> ➪找到离中心最近的点:<code class="fe lv lw lx ly b">n</code> <br/>所以对于所有集群:<code class="fe lv lw lx ly b">O(k*n)</code></li><li id="1729" class="nf ng ja kr b ks no kv np ky nq lc nr lg ns lk oi nl nm nn bi translated">因此，每次迭代都有<code class="fe lv lw lx ly b">O(n*log(n)*k*log(k))</code>复杂度</li></ul><p id="5824" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">如果我们在每次聚类运行中执行<code class="fe lv lw lx ly b">x</code>迭代直到收敛，并且<code class="fe lv lw lx ly b">y</code>以不同的随机初始状态运行，我们得到<code class="fe lv lw lx ly b">O(x*y*n*log(n)*k*log(k))</code>。</p><p id="7ef5" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">现在记住，我们要对不同数量的<code class="fe lv lw lx ly b">k</code>进行此操作。让我们将<code class="fe lv lw lx ly b">K</code>表示为我们想要尝试的最大值，将<code class="fe lv lw lx ly b">z</code>表示为不同<code class="fe lv lw lx ly b">k</code>的数量，然后我们得到总数<code class="fe lv lw lx ly b">O(x*y*z*n*log(n)*K*log(K))</code>。</p><p id="7c80" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">肘方法在<code class="fe lv lw lx ly b">K</code>中具有线性复杂度，这不会改变我们的最终结果😅。</p><figure class="lm ln lo lp gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="gh gi oj"><img src="../Images/eec1c7c97e8545838755d8804d63d0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEteGsCQsIKxmHzOArtUTw.png"/></div></div></figure><h1 id="5a60" class="mi mj ja bd mk ml mm mn mo mp mq mr ms kg mt kh mu kj mv kk mw km mx kn my mz bi translated">收场白</h1><p id="eb5d" class="pw-post-body-paragraph kp kq ja kr b ks na kb ku kv nb ke kx ky nc la lb lc nd le lf lg ne li lj lk ij bi translated">我个人在这个问题上的经历是，我真的不得不在工作中解决类似的问题。我的第一反应是使用贪婪的局部搜索，我知道这在类似的几何问题中非常有效。</p><p id="6d1d" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">然而，我挑战自己走出自己的舒适区，并向一些同事和同行寻求建议。很高兴，<a class="ae mh" href="https://www.linkedin.com/in/orian-sharoni/" rel="noopener ugc nofollow" target="_blank"> Orian Sharoni </a>很快作出回应，向我推荐了两篇论文(有界 K 均值聚类+肘方法),这两篇论文总结了所有内容。比我想象的多花了几个小时，但是我设计的解决方案更优雅，而且很可能更接近最优(没有测试过，但是我的直觉告诉我)。</p><p id="2ca1" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">总之，作为一名算法开发人员，尤其是在快节奏的初创企业中工作的人，当我只想完成某件事时，使用 go-to-methods 会有所帮助。但是，偶尔，它甚至更有助于探索新的想法，学习新的方法，并扩大我的大脑“去算法”库。</p><p id="6500" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">希望你喜欢和我一起踏上这段旅程，也希望你今天拓展了你的心智图书馆🤓</p></div></div>    
</body>
</html>