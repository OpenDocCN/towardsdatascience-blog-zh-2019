<html>
<head>
<title>Shortest Path Similarity: A Fresh Breath to Item-based Recommendations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短路径相似性:基于项目的推荐的一股清新之风</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shortest-path-similarity-a-fresh-breath-to-item-based-recommendations-9ac3d6ba7240?source=collection_archive---------13-----------------------#2019-04-04">https://towardsdatascience.com/shortest-path-similarity-a-fresh-breath-to-item-based-recommendations-9ac3d6ba7240?source=collection_archive---------13-----------------------#2019-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我描述了最短路径相似性——一种替代的基于项目的协同过滤推荐算法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c8313da2207e7c1dca618f725f744fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cL5YzEvytic6BqKT4mD0tA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by bertvthul from Pixabay</figcaption></figure><p id="26ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何推荐系统的目标都是吸引消费者。新闻网站希望读者阅读更多的新闻，视频主机希望观众观看更多的视频，在线商店希望买家购买更多的东西，等等。在这方面，常见的方法是找到与消费者刚刚阅读/观看/购买的内容相似的内容，并建议他们作为下一个要考虑的内容。这种类型的推荐通常被称为<em class="lu">基于项目的</em>，这就是我要解决的问题。</p><p id="24ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的十年里，推荐系统有一个相当稳定的配方。简而言之，其内容如下:</p><ol class=""><li id="19d1" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">尝试使用<a class="ae me" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度</a></li><li id="ddea" class="lv lw it la b lb mf le mg lh mh ll mi lp mj lt ma mb mc md bi translated">当后者不够好的时候，试试<a class="ae me" href="https://en.wikipedia.org/wiki/Singular_value_decomposition" rel="noopener ugc nofollow" target="_blank"> SVD </a></li><li id="8460" class="lv lw it la b lb mf le mg lh mh ll mi lp mj lt ma mb mc md bi translated">当以上两者都纠结的时候，就去做<a class="ae me" href="https://en.wikipedia.org/wiki/Deep_learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></li></ol><p id="21cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的建议是在列表中设置第 1a 段。也就是说，除了传统的协同过滤，还有另一种选择:最短路径相似性算法。</p><p id="3569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，它不存在冷启动问题。也就是说，在有一部新电影上映的情况下，我们知道十个人对后者进行了评级，我们也知道这十个人对二十部其他电影进行了评级:我们的余弦相似性算法有二十部电影可供选择，以推荐给新电影。不多，真的，特别是考虑到收视率不一定相等，也就是说，这二十部电影不太可能相似。同时,《最短路径》将遍历这个图，达到你想要的深度，并且可能会有更多的电影放在桌面上，这些最近的二十部电影中的大多数可能会排在一些更远但更相关的电影之后。</p><p id="e763" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，在应用程序中，当<em class="lu">相似性</em>是必要的，但对于<em class="lu">相关性</em>来说是不充分的，最短路径产生更多的逻辑推荐。我们生活中做的很多事情都是有因果关系的。当一个人不打算喝咖啡的时候，他是不会给自己冲咖啡的，对吗？我们看了《真探》第一集后就不会看第三集了，但不会看第二集。余弦相似度算法在检查了用户的评分后对这三集了解多少？他们彼此几乎一样相似。猜顺序没线索。同时，最短路径确实说明了事情发生的顺序。无论何时定义用户的分级权利(例如，设置:观看整集:正面，中途停止观看:负面，加上忽略明星、喜欢和类似的其他人)，最短路径毫不费力地预测最可能的序列。</p><p id="6ff0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，我并不是说余弦相似度算法本身有问题。当您将一个文档与已学习的特征矩阵进行匹配以找到相似的文档时(例如，针对 TFIDF 矩阵的搜索查询)，它非常有用。它的常见问题是误用，余弦相似度不太适合用作独立的推荐算法，例如，在视频托管和新闻网站上，文章的相似度不一定转化为高点击概率。</p><p id="beac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请查看<a class="ae me" href="https://github.com/grinya007/sp_i2i" rel="noopener ugc nofollow" target="_blank">脚本</a>，它使您能够通过余弦相似性和最短路径相似性并排比较推荐。该脚本是用 Python 编写的，包含对实现方面的详细解释。推荐基于<a class="ae me" href="http://files.grouplens.org/datasets/movielens/ml-latest-small-README.html" rel="noopener ugc nofollow" target="_blank"> MovieLens 最新的小型</a>数据集。示例输出如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="5884" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我试着解释一下它是如何工作的。考虑以下五部电影的图表，这五部电影由五个用户进行评估:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/4f5dcf1e6f3599d1794a3d06b885ba89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4C6AZw6hMiTmEKEQ00hO1Q.png"/></div></div></figure><p id="6481" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中每个用户给出一个如表中所示的等级:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/32f51387e50788d02bc9d082786b64a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MBEhqxXGk-5fgJzBzXvtw.png"/></div></div></figure><p id="cb41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们对给定的输入应用余弦相似度。实际上，我们只需要第二个数字。设θ是矢量 M1 和 M2 之间的角度。为了求出该角度的余弦值，我们使用以下公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/a2a21c134b6252345d0d4f287bbd49ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cil7RB1htVxoTzHT8TG0bA.png"/></div></div></figure><p id="ad7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<a class="ae me" href="https://en.wikipedia.org/wiki/Euclidean_vector#Dot_product" rel="noopener ugc nofollow" target="_blank">欧几里得点积</a>的公式中导出。请注意，在这种情况下，n = 3，我们无法考虑 U2 和 U3 给出的评级，因为他们对 M1 的评级是未知的。我们得到的是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/cff462b3895b2f8a14a585529debcded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDaye0AXZOtlObaXxQ0CtQ.png"/></div></div></figure><p id="0703" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇，看起来他们非常相似，虽然，一切都是相对的。让我们看看所有的相似之处:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/5d0d71827fa7f289334cd7ad89cdb710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r1ATDMTSY1eRJwd2xufhAw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Cosine similarity item-to-item recommendations</figcaption></figure><p id="cc6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看，M5 碰巧更相似。请注意，在实际应用中，标准化输入值总是更好(例如，按比例缩放它们，使它们落在 0 和 1 之间)。在这种特殊情况下，规范化不会对排名产生任何影响，但是当相似性值之间的差异越来越接近浮点数的精度限制时，规范化就派上了用场。</p><p id="7cc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，现在我们有了一些结果。但并不是所有的 5 部电影都得到了 4 个推荐，即使输入矩阵的稀疏度没有那么高。这就是通常所说的冷启动问题，也称为稀疏性问题。余弦相似性不仅需要更多的数据来产生更好的推荐，而且需要更多的数据来产生推荐。</p><p id="53c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另一个问题，没有前者那么明显。相似之处是镜像的。这意味着，例如，sim(M1-M2) = sim(M2-M1)。嗯，这听起来合乎逻辑，因为这是<em class="lu">的相似性</em>。但我们正试图在第一时间提出建议。想象一下，M1 是《回到未来》，M2 是《回到未来 2》。虽然它们在两个方面都很相似，但作为推荐，它们是否同样相关？你可能会说，当然，马蒂在第二集的开头就回到了 1955 年。但是让我请你向上滚动一点，看第一个图，沿着 M1 和 M2 之间的所有箭头。是的，两个用户选择了同一个方向，没有人选择相反的方向。如果这是相关性不平等的有效指示呢？用深度学习来整理会是一个很好的答案。但是有一个更简单的方法。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="c7cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看最短路径相似性算法在这种情况下是否有什么好处。首先，为了清楚起见，让我们将原始图形展平成一个用户路径表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/c6ee5dd8b765c1eea7c57c4af555adff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDCxD6-haaBHsFQhyz5yeA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Path of each user</figcaption></figure><p id="9076" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，现在，既然我们有了一个图，我们可以给它的边分配不同的长度。在这种特殊情况下，最符合逻辑的是从电影分级中导出长度。我想出了下面的公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e5005b85e7a02fcb220fa12851064cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*k-8mVc33NhNS7ihVG07SMw.png"/></div></figure><p id="0d8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中 v 和 v’是连接的顶点，r_iv 和 r _ iv’是由第 I 个用户给出的评级，w_r_i 是第 I 个用户意见的权重，w _ v’是给定推荐候选的全局权重。但是，当您想要尝试其他数据的最短路径相似性时，我鼓励您仔细考虑计算长度的最佳方式。我提出的公式对于最短路径相似性算法来说并不重要，也并不完美。顺便说一下，余弦距离可能是一个很好的选择。</p><p id="aac5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在现实世界的应用中，用户意见和推荐候选的权重可以从学习数据集中的出现频率中导出。例如，当一个用户对一部电影的评价高于平均水平时，降低后者的权重是有意义的。如果一部电影太受欢迎，我们可以减轻它的重量。为了简单起见，在这种情况下，有 5 部电影和 5 个用户，我假设所有用户的权重相等，所有电影的权重相等。因此，我以下面的邻接表结束:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/4208dd6413f1ed647de2baf37a92cfea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hL0J-ADjoNWGAnJ3axwRVA.png"/></div></div></figure><p id="e7eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，这还不是推荐列表，尽管每个最近的顶点将不可避免地成为最相关的推荐。现在，该说的都说了，该做的都做了，是时候寻找最短的路径了。我建议使用带有优先级队列的<a class="ae me" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Using_a_priority_queue" rel="noopener ugc nofollow" target="_blank"> Dijkstra 算法，对于 M1，该算法将如下工作:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/783f2be0bcdd5d57bd8e79cf3681cbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*qtJwo2G1X0zUW4yVKg-HDw.png"/></div></figure><p id="8354" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从 M1 出发，它将引导我们前往 M2，然后通过 M2 到达 M4，因为没有直达航班，然后通过 M2 到达 M5，最后通过 M2 和 M4 到达 M3。通过每个顶点进入图表后，我们得到了以下建议表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/21a5d5a2365104b8090e4087885aec03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HblJfEDqSIrVpnbu343Meg.png"/></div></div></figure><p id="29f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，现在我们有完整的推荐，我们不能从五部电影中获得更多。虽然，我不会说这是一个伟大的成就，因为我们允许单个用户连接一些顶点，这在实际应用程序中不一定是一个好主意。但更重要的是，现在，尽管 M2 是与 M1 最相关的推荐，反过来，M1 与 M2 最不相关。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="119d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，就这么简单:跟随用户的路径，记录用户对每对文档的意见，找出对每对文档的平均意见，以确定它们之间的距离，使用最短路径算法，其中记录每个访问过的文档作为对你已经开始的文档的推荐，就这样。这样做是很自然的，因为推荐系统的目标是预测用户想要一个接一个消费的最可能的<em class="lu">序列</em>。在我提出的最短路径相似性算法中没有费马定理的证明。它的所有部分都是肤浅的，在软件开发中被广泛使用。如果您对更多细节感兴趣，或者有一个数据集或应用程序，您想尝试最短路径相似性:请不要犹豫联系我们。请查看<a class="ae me" href="https://recom.live/" rel="noopener ugc nofollow" target="_blank"> https://recom.live </a>，这是一个基于最短路径相似度的实时推荐系统。</p></div></div>    
</body>
</html>