<html>
<head>
<title>A Comprehensive Guide to Pandas’ Advanced Features in 20 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">20 分钟熊猫高级功能综合指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-advanced-features-for-pythons-main-data-analysis-library-in-20-minutes-d0eedd90d086?source=collection_archive---------2-----------------------#2019-09-20">https://towardsdatascience.com/learn-advanced-features-for-pythons-main-data-analysis-library-in-20-minutes-d0eedd90d086?source=collection_archive---------2-----------------------#2019-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ac10" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">熊猫终极指南——第二部分</h2><div class=""/><div class=""><h2 id="fbf7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">熊猫高级功能代码指南。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d526958f365af02b5805a2f18c3559be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bpom2atJm6Kc_SPc"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Red Panda — Photo by <a class="ae lh" href="https://unsplash.com/@linneaherner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Linnea Herner</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="939b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">我大胆假设小熊猫比它们的黑白同胞更聪明，也更高级。因此，封面图片。</p><p id="e8cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个<strong class="lk jd">熊猫系列的<strong class="lk jd">第一部</strong>中，</strong>我们探索了熊猫的<strong class="lk jd">基础，</strong>包括<strong class="lk jd"> : </strong></p><ul class=""><li id="7263" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated">如何加载数据；</li><li id="eb50" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated">如何检查、分类和过滤数据；</li><li id="f510" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated">如何使用 and groupby/transform 分析数据</li></ul><p id="8283" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果这些概念对你来说是新的，回到<strong class="lk jd">第一部分</strong>，快速复习一下。</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/how-to-master-pandas-8514f33f00f6"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">如何在 20 分钟内掌握 Python 的主要数据分析库</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">熊猫基本功能的代码指南。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lb ne"/></div></div></a></div></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="13fd" class="oa ob it bd oc od oe of og oh oi oj ok ki ol kj om kl on km oo ko op kp oq or bi translated">在今天的文章中，我们将讨论以下主题:</h1><ol class=""><li id="37f2" class="mn mo it lk b ll os lo ot lr ou lv ov lz ow md ox mt mu mv bi translated">数据类型和转换</li><li id="e773" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ox mt mu mv bi translated">对某些数据类型有用的访问器方法</li><li id="73b9" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ox mt mu mv bi translated">组合数据帧</li><li id="574c" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ox mt mu mv bi translated">重塑数据帧</li></ol><h1 id="9ef0" class="oa ob it bd oc od oy of og oh oz oj ok ki pa kj om kl pb km oo ko pc kp oq or bi translated">先决条件</h1><p id="3b50" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">一个</span> Python 环境(建议 Jupyter 笔记本)。如果你还没有设置这个，不要担心。这是毫不费力的，不到 10 分钟。</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/get-started-with-python-e50dc8c96589"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">所以你想成为一名数据科学家？</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">到底是什么阻止了你？下面是如何开始！</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="pg l np nq nr nn ns lb ne"/></div></div></a></div></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="5bf9" class="oa ob it bd oc od oe of og oh oi oj ok ki ol kj om kl on km oo ko op kp oq or bi translated">设置</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/e81c782f6daefaec9c5d35b577a12592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wVf77uAhB3jf-Y9x"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@dylan_nolte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">dylan nolte</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="000c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">T21:在进行任何数据操作之前，让我们先获取一些数据。我们将使用一些虚构的销售数据。这个<a class="ae lh" href="https://github.com/FBosler/you-datascientist" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>保存了本文的数据和代码。</p><p id="1c82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">新建一个笔记本，导入熊猫(<code class="fe pi pj pk pl b">import pandas as pd</code>)。我倾向于这样调整我的笔记本设置:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="6e62" class="pq ob it pl b gy pr ps l pt pu">from IPython.core.display import display, HTML<br/>display(HTML("&lt;style&gt;.container {width:90% !important;}&lt;/style&gt;"))</span></pre><p id="33d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些命令使笔记本变得更宽，从而利用更多的屏幕空间(通常笔记本的宽度是固定的，这与宽屏很不一样)。</p><h2 id="acef" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">加载数据</h2><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="1a9c" class="pq ob it pl b gy pr ps l pt pu">invoices = pd.read_csv('<a class="ae lh" href="https://raw.githubusercontent.com/FBosler/you-datascientist/master/invoices.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/you-datascientist/master/invoices.csv'</a>)</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="05ec" class="oa ob it bd oc od oe of og oh oi oj ok ki ol kj om kl on km oo ko op kp oq or bi translated">①数据类型和转换</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/c639f5b6deac102a26a0ba234c4075b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N_wRAnrqqgRPY4VV"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@guibolduc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Guillaume Bolduc</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="a793" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">可用的数据类型</h2><p id="a22c" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">在开始研究数据之前，让我们快速总结一下所有可用的 Pandas 数据类型。<strong class="lk jd">总共有七种:</strong></p><ul class=""><li id="7b09" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">object</strong></code>:该数据类型用于字符串(即字符序列)</li><li id="948d" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">int64</strong></code>:用于整数(整数，无小数)</li><li id="40de" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">float64</strong></code>:用于浮点数(即带小数/分数的数字)</li><li id="9a98" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">bool</strong></code>:用于只能为真/假的值</li><li id="d605" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">datetime64</strong></code>:用于日期和时间值</li><li id="459c" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">timedelta</strong></code>:用来表示日期时间的差异</li><li id="b3e4" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">category</strong></code>:用于从有限数量的可用选项中选择一个选项的值(类别不是必须的，但可以有明确的排序)</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="7bec" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">显示数据类型</h2><p id="ee6d" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">答</span>在读取数据并运行快速<code class="fe pi pj pk pl b">invoices.sample(5)</code>后，我们观察到数据集似乎相当大，但结构良好。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/127d2499abd8f4ca92215d8f7f59574d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvgPPCH6sFAngdpXjHJZBw.png"/></div></div></figure><p id="c1ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了对数据有所了解，我通常会先从<code class="fe pi pj pk pl b">sample</code>开始，然后是<code class="fe pi pj pk pl b">info</code>和<code class="fe pi pj pk pl b">describe</code>，但是我们在这里是为了学习数据类型，现在将跳过典型的探索步骤。毫不奇怪，有一个命令可以打印出数据帧的数据类型。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="c4b6" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices.dtypes</span><span id="10d4" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>Order Id               object<br/>Date                   object<br/>Meal Id                object<br/>Company Id             object<br/>Date of Meal           object<br/>Participants           object<br/>Meal Price            float64<br/>Type of Meal           object<br/>Super Hero Present       bool<br/>dtype: object</span></pre><p id="c464" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在没有任何类型转换的情况下加载数据，所以 Pandas 在分配类型时做出了最好的猜测。我们可以看到，除了<code class="fe pi pj pk pl b">Meal Price</code>和<code class="fe pi pj pk pl b">Super Hero Present</code>之外，所有的列都是类型<code class="fe pi pj pk pl b">object</code>(即字符串)。根据我们之前的快速检查，似乎有些列可以被分配一个更明确的数据类型。所以让我们改变这一点。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="53c8" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">转换数据类型</h2><p id="6e0c" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">有两种转换 pandas 数据类型的标准方法:</p><ul class=""><li id="9f40" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">&lt;column&gt;.astype(&lt;desired type&gt;)</code></li><li id="1ff8" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated">转换辅助函数，如<code class="fe pi pj pk pl b">pd.to_numeric</code>或<code class="fe pi pj pk pl b">pd.to_datetime</code></li></ul><h2 id="22c6" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">ⓐ原型</h2><p id="0654" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">astype 速度很快，适用于干净的数据和直接转换，例如从 int64 转换到 float64(反之亦然)。<br/>必须在要转换的列上直接调用 astype。像这样:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="5ac7" class="pq ob it pl b gy pr ps l pt pu">invoices['Type of Meal'] = invoices['Type of Meal'].astype('category')</span><span id="a2ff" class="pq ob it pl b gy qh ps l pt pu">invoices['Date'] = invoices['Date'].astype('datetime64')</span><span id="bb20" class="pq ob it pl b gy qh ps l pt pu">invoices['Meal Price'] = invoices['Meal Price'].astype('int')</span></pre><p id="cd08" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了验证我们的类型转换的效果，我们再次运行<code class="fe pi pj pk pl b">invoices.dtypes</code>:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="970c" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">OUT:<br/></strong>Order Id                      object<br/>Date                  datetime64[ns]<br/>Meal Id                       object<br/>Company Id                    object<br/>Date of Meal                  object<br/>Participants                  object<br/>Meal Price                     int64<br/>Type of Meal                category<br/>Super Hero Present              bool<br/>dtype: object</span></pre><p id="1264" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注:</strong>熊猫版本有点差别。对于 Pandas 版本<code class="fe pi pj pk pl b">0.23.x</code>，可以使用<code class="fe pi pj pk pl b">.astype('datetime64')</code>转换<code class="fe pi pj pk pl b">Date of Meal</code>列，Pandas 将自动转换为<a class="ae lh" href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" rel="noopener ugc nofollow" target="_blank"> UTC </a>。UTC 格式很有用，因为它是一种标准化的时间格式，允许我们从其他日期中减去或加上日期。</p><p id="f140" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这对于 Pandas 版本<code class="fe pi pj pk pl b">0.25.x</code>不再有效，我们将得到一个 ValueError，让我们知道 Tz-aware(time zone-aware)datetime 在没有进一步调整的情况下不能被转换。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="f6c9" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">ⓑ转换辅助函数</h2><p id="a824" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">有三个<code class="fe pi pj pk pl b">pd.to_&lt;some_type&gt;</code>函数，但对我来说，其中只有两个经常出现:</p><ul class=""><li id="4c40" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">pd.to_numeric()</code></li><li id="b857" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">pd.to_datetime()</code></li><li id="9bc3" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">pd.to_timedelta()</code>(老实说，我不记得我是否用过这个)</li></ul><p id="1c95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">与</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">astype</strong></code> <strong class="lk jd">相比，它们的主要优势在于，可以指定遇到无法转换的值时的行为。</strong> <br/>两个函数都接受一个额外的参数<code class="fe pi pj pk pl b">errors</code>，该参数定义了应该如何处理错误。我们可以选择通过传递<code class="fe pi pj pk pl b">errors='ignore'</code>来忽略错误，或者通过传递<code class="fe pi pj pk pl b">errors='coerce'</code>将有问题的值转化为<code class="fe pi pj pk pl b">np.nan</code>值。默认行为是引发错误。</p><p id="e93e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我发现没有 cutty cutter 解决方案，我通常会在做出决定之前进行调查。与你观察到的数量相比，不合适的值越少，我就越有可能强迫它们。</p><p id="b6dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">pd.to_numeric()<br/></strong></code>为了便于讨论，让我们把数据稍微弄乱一点:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="31d3" class="pq ob it pl b gy pr ps l pt pu">invoices.loc[45612,'Meal Price'] = 'I am causing trouble'<br/>invoices.loc[35612,'Meal Price'] = 'Me too'</span></pre><p id="9753" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pi pj pk pl b">invoices['Meal Price'].astype(int)</code>现在将失败，并返回一个<em class="qi">值错误:以 10 为基数的 int()的文本无效:“我也是。”</em>因为没有明显的方法把字符串转换成整数。每当我遇到意外的转换错误时，我通常会显式地检查列的值，以便更好地理解奇怪值的大小。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="000e" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:</strong><br/>invoices['Meal Price'].apply(lambda x: type(x)).value_counts()</span><span id="64fc" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>&lt;class 'int'&gt;    49972<br/>&lt;class 'str'&gt;        2<br/>Name: Meal Price</span></pre><p id="cb96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，您可以通过执行以下操作来识别违规的行:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="663e" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Meal Price'][invoices['Meal Price'].apply(<br/>  lambda x: isinstance(x,str)<br/>)]</span><span id="d259" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>35612                  Me too<br/>45612    I am causing trouble<br/>Name: Meal Price, dtype: object</span></pre><p id="111a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从这里开始，可以快速修复这些值，或者做出明智的决定，决定如何处理失败的转换。</p><p id="f639" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子是一个很好的例子，通过像这样将<code class="fe pi pj pk pl b">errors='coerce'</code>传递给<code class="fe pi pj pk pl b">pd.to_numeric()</code>来将值转换成<code class="fe pi pj pk pl b">np.nan</code>是非常合理的:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="238b" class="pq ob it pl b gy pr ps l pt pu">pd.to_numeric(<!-- -->invoices['Meal Price'], errors='coerce'<!-- -->)</span></pre><p id="48bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在应该注意的是，您的数据中构造有两个<code class="fe pi pj pk pl b">np.nan</code>值，所以就地处理它们可能是个好主意。<code class="fe pi pj pk pl b">np.nan`s</code>的问题是整数列不知道如何处理它们。因此，该列将是一个浮动列。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="f917" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd"># convert the offending values into np.nan</strong><br/>invoices['Meal Price'] = pd.to_numeric(invoices['Meal Price'],errors='coerce')</span><span id="dc50" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd"># fill np.nan with the median of the data</strong><br/>invoices['Meal Price'] = invoices['Meal Price'].fillna(invoices['Meal Price'].median())</span><span id="75f7" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd"># convert the column into integer</strong><br/>invoices['Meal Price'].astype(int)</span></pre><p id="4e5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">pd.to_datetime()</strong></code> <strong class="lk jd"> <br/> </strong>顾名思义，该方法将<strong class="lk jd">字符串</strong>转换为日期时间格式。要在一个列上调用<code class="fe pi pj pk pl b">to_datetime</code>，你可以做:<code class="fe pi pj pk pl b">pd.to_datetime(invoices['Date of Meal'])</code>。Pandas 将猜测格式，并尝试从输入中解析日期。它做得非常好:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="5014" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:</strong><br/>print(pd.to_datetime('2019-8-1'))<br/>print(pd.to_datetime('2019/8/1'))<br/>print(pd.to_datetime('8/1/2019'))<br/>print(pd.to_datetime('Aug, 1 2019'))<br/>print(pd.to_datetime('Aug - 1 2019'))<br/>print(pd.to_datetime('August - 1 2019'))<br/>print(pd.to_datetime('2019, August - 1'))<br/>print(pd.to_datetime('20190108'))</span><span id="226f" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:</strong><br/>2019-08-01 00:00:00<br/>2019-08-01 00:00:00<br/>2019-08-01 00:00:00<br/>2019-08-01 00:00:00<br/>2019-08-01 00:00:00<br/>2019-08-01 00:00:00<br/>2019-08-01 00:00:00<br/>2019-01-08 00:00:00</span></pre><p id="b694" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，有时您可能会遇到一些非典型的格式，就像上面列表中的最后一个例子。在这种情况下，您可能希望提供一个自定义格式，您可以这样做:<code class="fe pi pj pk pl b">pd.to_datetime('20190108',format='%Y%d%m')</code>。可以把格式字符串看作一个掩码，用来检查日期字符串，如果这个掩码合适，转换就会发生。查看<a class="ae lh" href="https://www.programiz.com/python-programming/datetime/strftime#format-code" rel="noopener ugc nofollow" target="_blank">链接</a>获取所有可能的日期格式组件列表。使用定制格式时，另一个值得注意的参数是<code class="fe pi pj pk pl b">exact=False</code>。<code class="fe pi pj pk pl b">print(pd.to_datetime('yolo 20190108', format='%Y%d%m', exact=False))</code>将会工作，但是如果没有确切的参数，它将会失败。Pandas 试图匹配日期字符串中任何位置的模式。</p><p id="1d60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在继续之前，让我们转换我们的<code class="fe pi pj pk pl b">Date of Meal</code>列，像这样<code class="fe pi pj pk pl b">invoices['Date of Meal'] = pd.to_datetime(invoices['Date of Meal'], utc=True)</code></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="b6fa" class="oa ob it bd oc od oe of og oh oi oj ok ki ol kj om kl on km oo ko op kp oq or bi translated">②对某些数据类型有用的访问器方法</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qj"><img src="../Images/9f3f050c17092f1a776bc528e889d3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uHOebHQlDpI-4g90"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Todd Quackenbush</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="qk"><p id="85e9" class="ql qm it bd qn qo qp qq qr qs qt md dk translated">如果你唯一的工具是锤子，那么每个问题看起来都像钉子。</p></blockquote><p id="02ca" class="pw-post-body-paragraph li lj it lk b ll qu kd ln lo qv kg lq lr qw lt lu lv qx lx ly lz qy mb mc md im bi me translated">把 Pandas 访问器看作是一个属性，它充当特定于你试图访问的类型的方法的接口。那些方法是高度专业化的。他们只为一项工作服务。然而，对于特定的工作来说，它们非常优秀而且非常简洁。</p><p id="7d48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有三种不同的访问器:</p><ul class=""><li id="1194" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">dt</code></li><li id="4de3" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">str</code></li><li id="5a49" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b">cat</code></li></ul><p id="8c4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过在选择的列上调用<code class="fe pi pj pk pl b">.&lt;accessor&gt;.method</code>可以访问所有的方法，就像这样:<code class="fe pi pj pk pl b">invoices['Date of Meal'].dt.date</code></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="dcfb" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">存取器— dt</h2><p id="42f3" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">我认为他的方法是最有用和最直接的访问器方法:</p><ul class=""><li id="fc24" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">date</strong></code> <strong class="lk jd"> </strong>(返回日期时间的日期值)，或者</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="f5b2" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.date</span><span id="b8b5" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        2015-01-29<br/>1        2017-10-30<br/>            ...    <br/>49972    2017-09-06<br/>49973    2015-08-20<br/>Name: Date of Meal, Length: 49974, dtype: object</span></pre><ul class=""><li id="ecf5" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">weekday_name</strong></code> <strong class="lk jd"> </strong>(返回当天的名称)、<code class="fe pi pj pk pl b"><strong class="lk jd">month_name()</strong></code> <strong class="lk jd"> </strong>(这种实现方式有些不一致，因为 weekday_name 是一个属性，而 month_name 是一个方法，需要用括号调用)</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="07da" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.weekday_name</span><span id="a787" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0         Thursday<br/>1           Monday<br/>           ...    <br/>49972    Wednesday<br/>49973     Thursday<br/>Name: Date of Meal, Length: 49974, dtype: object</span><span id="abb7" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.month_name()</span><span id="2763" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0          January<br/>1          October<br/>           ...    <br/>49972    September<br/>49973       August<br/>Name: Date of Meal, Length: 49974, dtype: object</span></pre><ul class=""><li id="fc61" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">days_in_month</strong></code></li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="bccb" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.days_in_month</span><span id="72f1" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        31<br/>1        31<br/>         ..<br/>49972    30<br/>49973    31<br/>Name: Date of Meal, Length: 49974, dtype: int64</span></pre><ul class=""><li id="44a4" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">nanosecond</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">microsecond</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">second</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">minute</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">hour</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">day</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">week</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">month</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">quarter</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">year</strong></code>得到对应频率的整数。</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="5463" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">EXAMPLES: (same logic applies for </strong><strong class="pl jd">nanosecond</strong>, <strong class="pl jd">microsecond</strong>, <strong class="pl jd">second</strong>, <strong class="pl jd">minute</strong>, <strong class="pl jd">hour)</strong></span><span id="d4ad" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices<!-- -->['Date of Meal'].dt.day</span><span id="0091" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        29<br/>1        30<br/>         ..<br/>49972     6<br/>49973    20<br/>Name: Date of Meal, Length: 49974, dtype: int64</span><span id="0079" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.week</span><span id="7b08" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0         5<br/>1        44<br/>         ..<br/>49972    36<br/>49973    34<br/>Name: Date of Meal, Length: 49974, dtype: int64</span><span id="6c2e" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices<!-- -->['Date of Meal'].dt.month</span><span id="da79" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0         1<br/>1        10<br/>         ..<br/>49972     9<br/>49973     8<br/>Name: Date of Meal, Length: 49974, dtype: int64</span><span id="5e5e" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices<!-- -->['Date of Meal'].dt.quarter</span><span id="67f9" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        1<br/>1        4<br/>        ..<br/>49972    3<br/>49973    3<br/>Name: Date of Meal, Length: 49974, dtype: int64</span><span id="7293" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices<!-- -->['Date of Meal'].dt.year</span><span id="9345" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        2015<br/>1        2017<br/>         ... <br/>49972    2017<br/>49973    2015<br/>Name: Date of Meal, Length: 49974, dtype: int64</span></pre><ul class=""><li id="5126" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">is_leap_year</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">is_month_start</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">is_month_end</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">is_quarter_start</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">is_quarter_end</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">is_year_start</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">is_year_end</strong></code>分别为每个值返回 True 或 False。<code class="fe pi pj pk pl b">is_month_end</code>见下例</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="30a0" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.is_month_end</span><span id="8c04" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        False<br/>1        False<br/>         ...  <br/>49972    False<br/>49973    False<br/>Name: Date of Meal, Length: 49974, dtype: bool</span></pre><p id="1dcc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用结果过滤我们的数据，只保留行，其中<code class="fe pi pj pk pl b">Date of Meal</code>在月末。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qz"><img src="../Images/54ac35e30c58adfccca2825f06d93346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YotYYr9JMHB1wDjFMBpEMA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Invoices filtered for Date of Meal is_month_end</figcaption></figure><ul class=""><li id="9809" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">to_pydatetime()</strong></code>，它将 Pandas datetime 转换成常规的 Python datetime 格式(有时您可能会用到)，以及<code class="fe pi pj pk pl b"><strong class="lk jd">to_period(&lt;PERIOD&gt;)</strong></code> <strong class="lk jd"> </strong>【可用的周期有 W、M、Q 和 Y】，它将日期转换成周期。</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="e938" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.to_pydatetime()</span><span id="6f50" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>array([datetime.datetime(2015, 1, 29, 8, 0),<br/>       datetime.datetime(2017, 10, 30, 20, 0),<br/>       datetime.datetime(2015, 2, 10, 11, 0), ...,<br/>       datetime.datetime(2017, 3, 7, 19, 0),<br/>       datetime.datetime(2017, 9, 6, 6, 0),<br/>       datetime.datetime(2015, 8, 20, 18, 0)], dtype=object)</span><span id="b95d" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Date of Meal'].dt.to_period('W')</span><span id="7b22" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0       2015-01-26/2015-02-01<br/>1       2017-10-30/2017-11-05<br/>                 ...         <br/>49972   2017-09-04/2017-09-10<br/>49973   2015-08-17/2015-08-23<br/>Name: Date of Meal, Length: 49974, dtype: object</span></pre><h2 id="cfea" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">存取器—字符串</h2><p id="a336" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">str 访问器也非常有用，不是因为它支持额外功能，而是因为它使代码更加可读。</p><ul class=""><li id="0904" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">lower()</strong></code> <strong class="lk jd"> / </strong> <code class="fe pi pj pk pl b"><strong class="lk jd">upper()</strong></code> <strong class="lk jd"> </strong>管理字符串的大小写</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="6022" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.lower()</span><span id="9dc9" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        breakfast<br/>1           dinner<br/>           ...    <br/>49972    breakfast<br/>49973       dinner<br/>Name: Type of Meal, Length: 49974, dtype: object</span><span id="27f7" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.upper()</span><span id="7434" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        BREAKFAST<br/>1           DINNER<br/>           ...    <br/>49972    BREAKFAST<br/>49973       DINNER<br/>Name: Type of Meal, Length: 49974, dtype: object</span></pre><ul class=""><li id="3b56" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">ljust(width)</strong></code><strong class="lk jd"/><code class="fe pi pj pk pl b"><strong class="lk jd">rjust(width)</strong></code><strong class="lk jd"/><code class="fe pi pj pk pl b"><strong class="lk jd">center(width)</strong></code><strong class="lk jd"/><code class="fe pi pj pk pl b"><strong class="lk jd">zfill(width)</strong></code><strong class="lk jd"/>来控制琴弦的定位。它们都将所需结果字符串的总宽度作为输入。<code class="fe pi pj pk pl b">ljust</code>、<code class="fe pi pj pk pl b">rjust</code>和<code class="fe pi pj pk pl b">center</code>用空格将差值填充至所需长度。添加许多前导零。<code class="fe pi pj pk pl b">ljust</code>是向左的，<code class="fe pi pj pk pl b">rjust</code>是向右的。</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="75c3" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.ljust(width=15)</span><span id="6ba9" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        Breakfast      <br/>1        Dinner         <br/>              ...       <br/>49972    Breakfast      <br/>49973    Dinner         <br/>Name: Type of Meal, Length: 49974, dtype: object</span><span id="3886" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.rjust(width=15)</span><span id="b360" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0              Breakfast<br/>1                 Dinner<br/>              ...       <br/>49972          Breakfast<br/>49973             Dinner<br/>Name: Type of Meal, Length: 49974, dtype: object</span><span id="fbaa" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.center(width=15)</span><span id="52df" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0           Breakfast   <br/>1             Dinner    <br/>              ...       <br/>49972       Breakfast   <br/>49973         Dinner    <br/>Name: Type of Meal, Length: 49974, dtype: object</span><span id="da40" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.zfill(width=15)</span><span id="8960" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        000000Breakfast<br/>1        000000000Dinner<br/>              ...       <br/>49972    000000Breakfast<br/>49973    000000000Dinner<br/>Name: Type of Meal, Length: 49974, dtype: object</span></pre><ul class=""><li id="ec67" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">startswith(&lt;substring&gt;)</strong></code> <strong class="lk jd">、</strong>、<code class="fe pi pj pk pl b"><strong class="lk jd">endswith(&lt;substring&gt;)</strong></code>、、<code class="fe pi pj pk pl b"><strong class="lk jd">contains(&lt;substring&gt;)</strong></code>、<strong class="lk jd">、</strong>检查子串的存在</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="fd71" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.endswith('ast')</span><span id="afaa" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0         True<br/>1        False<br/>         ...  <br/>49972     True<br/>49973    False<br/>Name: Type of Meal, Length: 49974, dtype: bool</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ra"><img src="../Images/164ff82893c03216240678d66010356a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJ4uJPJfpvKwK4oU9mhLqA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">using str.contains to filter for rows that include ‘Bruce.’</figcaption></figure><ul class=""><li id="a280" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">swapcase()</strong></code> <strong class="lk jd">、</strong>、<strong class="lk jd">、</strong>为<strong class="lk jd">、</strong>的拳打脚踢</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="6f3f" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.swapcase()</span><span id="c690" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        bREAKFAST<br/>1           dINNER<br/>           ...    <br/>49972    bREAKFAST<br/>49973       dINNER<br/>Name: Type of Meal, Length: 49974, dtype: object</span><span id="c8e0" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].str.repeat(2)</span><span id="e11d" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        BreakfastBreakfast<br/>1              DinnerDinner<br/>                ...        <br/>49972    BreakfastBreakfast<br/>49973          DinnerDinner<br/>Name: Type of Meal, Length: 49974, dtype: object</span></pre><h2 id="6e20" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">访问者— cat</h2><p id="01e2" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">在我看来是三个中最不强大的，或者至少是我最不常用的。<code class="fe pi pj pk pl b">cat</code>提供对几个类别操作的访问，如:</p><ul class=""><li id="e157" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">ordered</strong></code> <strong class="lk jd"> </strong>让您知道列是否有序</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="7e94" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].cat.ordered</span><span id="6982" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:</strong><br/>False</span></pre><ul class=""><li id="91fd" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">categories</strong></code> <strong class="lk jd"> </strong>返回类别</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="b796" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:<br/></strong>invoices['Type of Meal'].cat.categories</span><span id="1ee9" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>Index(['Breakfast', 'Dinner', 'Lunch'], dtype='object')</span></pre><ul class=""><li id="7615" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">codes</strong></code> <strong class="lk jd"> </strong>用于将类别快速转换成其数值表示</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="5c5c" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:</strong><br/>invoices['Type of Meal'].cat.codes</span><span id="3e6b" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        0<br/>1        1<br/>2        2<br/>3        2<br/>4        2<br/>        ..<br/>49969    1<br/>49970    2<br/>49971    1<br/>49972    0<br/>49973    1<br/>Length: 49974, dtype: int8</span></pre><ul class=""><li id="213a" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">reorder_categories</strong></code> <strong class="lk jd"> </strong>改变现有类别的顺序</li></ul><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="9f59" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd">IN:</strong><br/>invoices['Type of Meal'].cat.reorder_categories(<br/>    ['Lunch','Breakfast','Dinner']<br/>)</span><span id="a423" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>0        Breakfast<br/>1           Dinner<br/>2            Lunch<br/>3            Lunch<br/>4            Lunch<br/>           ...    <br/>49969       Dinner<br/>49970        Lunch<br/>49971       Dinner<br/>49972    Breakfast<br/>49973       Dinner<br/>Name: Type of Meal, Length: 49974, dtype: category<br/>Categories (3, object): [Lunch, Breakfast, Dinner]</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="661b" class="oa ob it bd oc od oe of og oh oi oj ok ki ol kj om kl on km oo ko op kp oq or bi translated">③组合数据帧</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rb"><img src="../Images/919b39f260bbe576aee0d8a2ac4fc6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDBGjLOk3_qcDv2nb1d9FA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Image by <a class="ae lh" href="https://pixabay.com/users/Pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2178625" rel="noopener ugc nofollow" target="_blank">Pexels</a> from <a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2178625" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h2 id="e547" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">连结</h2><p id="d558" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">当你有相似的数据(结构上和内容上)分布在多个文件中时，oncatenating 就很方便了。您可以垂直连接数据(即，将数据堆叠在一起)或水平连接数据(即，将数据堆叠在一起)。</p><h2 id="472c" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">ⓐ串联—垂直堆叠</h2><p id="b4bb" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">作为一个例子，假设一个客户每月或每年向你提供一个文件的数据(例如，因为他们的报告在月末运行)。这些文件在概念上是相同的，因此是垂直堆叠的主要例子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rc"><img src="../Images/c599d202f2b25e5d0646897c3ad2417e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMXOJ-99ioV4RY0zu6Slow.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">A simplified example of vertical stacking</figcaption></figure><p id="df26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看如何用 Python 的熊猫来做这件事。让我们人为地把发票文件按年份分开。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="55c7" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd"># Use dt accessor to count all the years<br/>IN:<br/></strong>invoices['Date of Meal'].dt.year.value_counts().sort_index()</span><span id="6220" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd">OUT:<br/></strong>2013       38<br/>2014     9988<br/>2015    10060<br/>2016     9961<br/>2017     9964<br/>2018     9931<br/>2019       32<br/>Name: Date of Meal, dtype: int64</span><span id="b9d1" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd"># Split the data <br/></strong>y_2013 = invoices[invoices['Date of Meal'].dt.year == 2013].copy()<br/>y_2014 = invoices[invoices['Date of Meal'].dt.year == 2014].copy()<br/>y_2015 = invoices[invoices['Date of Meal'].dt.year == 2015].copy()<br/>y_2016 = invoices[invoices['Date of Meal'].dt.year == 2016].copy()<br/>y_2017 = invoices[invoices['Date of Meal'].dt.year == 2017].copy()<br/>y_2018 = invoices[invoices['Date of Meal'].dt.year == 2018].copy()<br/>y_2019 = invoices[invoices['Date of Meal'].dt.year == 2019].copy()</span></pre><p id="92db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用<code class="fe pi pj pk pl b">.copy()</code>来确保生成的数据帧是数据的副本，而不仅仅是对原始数据帧的引用。</p><p id="e5ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们验证一下拆分是否有效。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rd"><img src="../Images/a176537eaca2de2930e01e6540586040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yaIMIC1fb1W8WRw_BZewtw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">All Invoices where the date of the meal was in 2017</figcaption></figure><p id="b19e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，为了将数据连接成一个统一的数据帧，我们将像这样调用<code class="fe pi pj pk pl b">pd.concat(&lt;LIST OF DATAFRAMES&gt;)</code>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi re"><img src="../Images/89449d8f19bf6ce651f68bc5c6a051f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcA7jjANPkHQgp4Rfozfag.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Stacking multiple DataFrames on top of each other</figcaption></figure><p id="5ff2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pi pj pk pl b">pd.concat</code>在您调用<code class="fe pi pj pk pl b">concat</code>的数据帧列表旁边，接受几个<strong class="lk jd">可选</strong>参数:</p><ul class=""><li id="3523" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">axis</strong></code> : <code class="fe pi pj pk pl b">0</code>为垂直，<code class="fe pi pj pk pl b">1</code>为水平。<code class="fe pi pj pk pl b"><strong class="lk jd">axis</strong></code> <strong class="lk jd"> </strong>默认为<strong class="lk jd"> </strong> <code class="fe pi pj pk pl b"><strong class="lk jd">0</strong></code></li><li id="64f7" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">join</strong></code> : <code class="fe pi pj pk pl b">'inner'</code>为交集，<code class="fe pi pj pk pl b">'outer'</code>为非连接轴索引的并集。当我们使用<code class="fe pi pj pk pl b">axis=0</code>和<code class="fe pi pj pk pl b">join='inner'</code>时，我们将只考虑重叠的列。当使用<code class="fe pi pj pk pl b">axis=1</code>和<code class="fe pi pj pk pl b">join='inner'</code>时，我们只考虑重叠指数。在<code class="fe pi pj pk pl b">outer</code>的情况下，非重叠列/索引将用<code class="fe pi pj pk pl b">nan</code>值填充。<code class="fe pi pj pk pl b"><strong class="lk jd">join</strong></code> <strong class="lk jd"> </strong>默认为<strong class="lk jd"> </strong> <code class="fe pi pj pk pl b"><strong class="lk jd">outer</strong></code></li><li id="2cc9" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">ignore_index</strong></code> <strong class="lk jd"> : </strong> <code class="fe pi pj pk pl b">True</code>忽略预先存在的索引，而使用从 0 到 n-1 的标签作为结果数据帧。<code class="fe pi pj pk pl b"><strong class="lk jd">ignore_index</strong></code> <strong class="lk jd"> </strong>默认为<code class="fe pi pj pk pl b"><strong class="lk jd">False</strong></code></li><li id="b6ce" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">keys</strong></code> <strong class="lk jd"> : </strong>如果我们提供一个列表(必须与数据帧的数量相同的长度)，一个层次索引将被构建。<code class="fe pi pj pk pl b">keys</code>默认为<code class="fe pi pj pk pl b">None</code> <strong class="lk jd">。</strong>以<code class="fe pi pj pk pl b">keys</code>为例，添加数据的来源。最好与名字连用。</li><li id="43fd" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">names</strong></code> <strong class="lk jd"> : </strong>假设您提供了键，那么这些名称将用于标记生成的层次索引。<code class="fe pi pj pk pl b"><strong class="lk jd">names</strong></code> <strong class="lk jd"> </strong>默认为<code class="fe pi pj pk pl b"><strong class="lk jd">None</strong></code> <strong class="lk jd">。</strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rf"><img src="../Images/fab003b23dc5b00f9b9dd3169ecec5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chG2sPthfOYEslYvjYrNOg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Stacking multiple DataFrames on top of each other with keys</figcaption></figure><h2 id="c99f" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">ⓑ串联—水平堆叠</h2><p id="4713" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">水平堆叠<strong class="lk jd">的一个</strong></span>用例是指多个时间序列具有重叠但不相同的索引。在这种情况下，您不会希望最终得到一个可能有数千列的数据帧，而是一个有数千行的数据帧。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rg"><img src="../Images/d91c9ab1b6ef574583f9df5e490fad6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3kHYY_BgoyA3q4FPCJacg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">A simplified example of horizontal stacking</figcaption></figure><p id="294f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Python 中运行下面的代码片段将得到下面的屏幕截图:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="df56" class="pq ob it pl b gy pr ps l pt pu">range_a = pd.date_range(<br/>    datetime.datetime(2019,1,2),<br/>    datetime.datetime(2019,1,8)<br/>)<br/>df_a = pd.DataFrame(<br/>    index=range_a, <br/>    data=np.random.randint(2,10,size=len(range_a)),<br/>    columns=['observations_A']<br/>)</span><span id="c3fc" class="pq ob it pl b gy qh ps l pt pu">range_b = pd.date_range(<br/>    datetime.datetime(2019,1,5),<br/>    datetime.datetime(2019,1,12)<br/>)</span><span id="12e0" class="pq ob it pl b gy qh ps l pt pu">df_b = pd.DataFrame(<br/>    index=range_b, <br/>    data=np.random.randint(2,10,size=len(range_b)),<br/>    columns=['observations_B']<br/>)</span><span id="4b23" class="pq ob it pl b gy qh ps l pt pu">pd.concat([df_a,df_b],axis=1)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/b49dd142a89a0976f982f9d819cd3c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*wuhksg0iAlJytV2MtMVVvA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Horizontally stacked DataFrames</figcaption></figure><p id="2f5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关于<strong class="lk jd"> </strong> <code class="fe pi pj pk pl b"><strong class="lk jd">Append</strong></code> <strong class="lk jd"> : <br/> </strong>你可能已经看到<code class="fe pi pj pk pl b">append</code>的用法和<code class="fe pi pj pk pl b">concat</code>一样的结尾。<strong class="lk jd">我建议不要使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">append</strong></code>，因为它只是<code class="fe pi pj pk pl b">concat</code>的一个特例，并没有提供比串联更好的优势。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="e072" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">合并</h2><p id="ccb4" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">与将数据帧连接在一起相反，合并允许我们以一种更传统的 SQL 查询方式将两个数据帧组合在一起。当合并数据帧时，大多数情况下，您希望一些信息来自一个源，另一些信息来自另一个源。而当连接数据帧时，它们在结构上和内容上非常相似，您希望将它们组合成一个统一的数据帧。</p><p id="7320" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我喜欢在面试中使用的一个简单例子是这样的:</p><blockquote class="ri rj rk"><p id="2f66" class="li lj qi lk b ll lm kd ln lo lp kg lq rl ls lt lu rm lw lx ly rn ma mb mc md im bi translated">假设你有两张桌子。一个表包含员工姓名和位置 id，另一个表包含位置 id 和城市名称。你怎么能得到每个雇员的名单和他们工作的城市？</p></blockquote><p id="3036" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Pandas 中合并两个数据帧是用<code class="fe pi pj pk pl b">pd.merge</code>完成的。让我们来看看函数的签名(签名是指函数所有可能参数的列表，通常还包括输出)。我加粗了最相关的参数。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="6925" class="pq ob it pl b gy pr ps l pt pu">pd.merge(<br/><strong class="pl jd"> left, <br/> right, </strong><br/><strong class="pl jd"> how='inner', <br/> on=None,</strong> <br/> <strong class="pl jd">left_on=None, </strong><br/> <strong class="pl jd">right_on=None,         </strong><br/> <strong class="pl jd">left_index=False,</strong><br/> <strong class="pl jd">right_index=False, </strong><br/> sort=True,<br/> <strong class="pl jd">suffixes=('_x', '_y'), </strong><br/> copy=True, <br/> indicator=False,<br/> validate=None<br/>) -&gt; pd.DataFrame</span></pre><p id="b23d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们一个一个地检查参数:</p><ul class=""><li id="8266" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">left/right</strong></code>:要合并的左、右数据帧</li><li id="bcf4" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">how</strong></code> : <code class="fe pi pj pk pl b">'left'</code>，<code class="fe pi pj pk pl b">'right'</code>，<code class="fe pi pj pk pl b">'outer'</code>，<code class="fe pi pj pk pl b">'inner'</code>。<code class="fe pi pj pk pl b"><strong class="lk jd">how</strong></code> <strong class="lk jd"> </strong>默认为<strong class="lk jd"> </strong> <code class="fe pi pj pk pl b"><strong class="lk jd">'inner'</strong></code> <strong class="lk jd">。下面是它们各自功能的示意图。稍后我们将讨论具体的例子。</strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ro"><img src="../Images/86cf90569b6cc369950097992becd17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*DhTppnBct_rr9QMX_cHXNg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Image from <a class="ae lh" href="http://www.datasciencemadesimple.com/join-merge-data-frames-pandas-python/" rel="noopener ugc nofollow" target="_blank">DataScienceMadeSimple</a></figcaption></figure><ul class=""><li id="f22e" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">left_index/right_index</strong></code> <strong class="lk jd"> : </strong>如果<code class="fe pi pj pk pl b">True</code>，使用左/右数据帧的索引合并。<code class="fe pi pj pk pl b"><strong class="lk jd">left_index/right_index</strong></code> <strong class="lk jd"> </strong>默认为<strong class="lk jd"> </strong> <code class="fe pi pj pk pl b">False</code></li><li id="ca77" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">on</strong></code> <strong class="lk jd"> : </strong>要合并的列名。列名必须同时存在于左侧和右侧数据框架中。如果未通过且<code class="fe pi pj pk pl b">left_index</code>和<code class="fe pi pj pk pl b">right_index</code>为<code class="fe pi pj pk pl b">False</code>，<strong class="lk jd">两个数据帧中的列的交集将被推断为连接。</strong></li><li id="d974" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">left_on/right_on</strong></code> <strong class="lk jd"> : </strong>左/右数据框中要连接的列名。<strong class="lk jd">典型用例:</strong>您正在连接的键在您的数据帧中有不同的标签。例如，您左侧数据帧中的<code class="fe pi pj pk pl b">location_id</code>可能是您右侧数据帧中的<code class="fe pi pj pk pl b">_id</code>。在这种情况下，你会做<code class="fe pi pj pk pl b"><strong class="lk jd">left_on='</strong>location_id', <strong class="lk jd">right_on</strong>='_id'</code>。</li><li id="c0b9" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">suffixes</strong></code>:应用于重叠列的字符串后缀元组。<code class="fe pi pj pk pl b"><strong class="lk jd">suffixes</strong></code>默认为<code class="fe pi pj pk pl b">('_x', '_y')</code>。我喜欢用<code class="fe pi pj pk pl b">('_base', '_joined')</code>。</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="3e1c" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">合并—加载和检查新数据</h2><p id="4eef" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">理论够了，我们来看一些例子。为此，我们需要一些额外的数据来合并。</p><p id="9342" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">加载数据:</strong></p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="cf5d" class="pq ob it pl b gy pr ps l pt pu"><strong class="pl jd"># Load some additional Data</strong><br/>order_data = pd.read_csv('<a class="ae lh" href="https://raw.githubusercontent.com/FBosler/you-datascientist/master/order_leads.csv',parse_dates=[3" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/you-datascientist/master/order_leads.csv', parse_dates=[3</a>])</span><span id="e74e" class="pq ob it pl b gy qh ps l pt pu"><strong class="pl jd"># Note the parse_dates? We need this to have consistent types with invoices, otherwise the subsequent merges would throw errors</strong></span><span id="6a63" class="pq ob it pl b gy qh ps l pt pu">sales_team = pd.read_csv('<a class="ae lh" href="https://raw.githubusercontent.com/FBosler/you-datascientist/master/sales_team.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/FBosler/you-datascientist/master/sales_team.csv'</a>)</span></pre><p id="c839" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">检查数据:</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rp"><img src="../Images/a013d099d0cfcd7a49a4a83186119def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVJkAyhQnRps5FdQI8IlEg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Some overlapping (keys), some unique columns (features) spread out across three DataFrames</figcaption></figure><p id="dced" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们马上就能看到，<code class="fe pi pj pk pl b"><strong class="lk jd">Order ID</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">Company ID</strong></code>、<strong class="lk jd">、</strong>和<code class="fe pi pj pk pl b"><strong class="lk jd">Date </strong></code>出现在多个数据帧中，因此是很好的合并对象。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="1085" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">合并—如何进行</h2><p id="ce60" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">让我们将<code class="fe pi pj pk pl b"><strong class="lk jd">invoices</strong></code>与<code class="fe pi pj pk pl b"><strong class="lk jd">order_data</strong></code> <strong class="lk jd"> </strong>合并，并对参数进行一点试验。</p><ul class=""><li id="8eea" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><strong class="lk jd">未提供参数:</strong>所有参数将使用其默认值。<br/>合并将是一个内部合并(相当于<code class="fe pi pj pk pl b"><strong class="lk jd">how='inner'</strong></code>)。<br/>将对所有公共列进行合并，即<code class="fe pi pj pk pl b"><strong class="lk jd">Date</strong></code>、<code class="fe pi pj pk pl b"><strong class="lk jd">Order Id</strong></code>和<code class="fe pi pj pk pl b"><strong class="lk jd">Company Id</strong></code>(相当于<code class="fe pi pj pk pl b"><strong class="lk jd">on=['Date','Order Id','Company Id]</strong></code>)。<br/>后缀是不相关的，因为所有公共列都将用于合并，所以不会剩下重复的列。<br/>运行<code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge(order_data,invoices)</strong></code> <strong class="lk jd"> : </strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rq"><img src="../Images/1372e16b49b43c5981aee1a540a94764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDYcfKkkbLsLwuGbaXugyg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Merge with no parameters. Defaults to inner, i.e., only rows where there is data in both tables. <strong class="bd rr">Note how this results in ~50k rows.</strong></figcaption></figure><ul class=""><li id="962a" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">how='left'</strong></code>:同样，合并基于所有公共列。后缀是不相关的，因为所有公共列都将用于合并，所以不会留下重复的列。<br/>然而，这一次，我们与<code class="fe pi pj pk pl b"><strong class="lk jd">how='left'</strong></code>合并，这意味着我们将从左侧帧中取出所有行，并且只添加右侧帧中我们找到的一些数据。运行<code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge(order_data,invoices,how='left')</strong></code> <strong class="lk jd"> : </strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rq"><img src="../Images/aa8d0e51ac43e0165e38a5eedbd8c2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GawHYRNPN9yUYAYwqkfELw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">“left-sided” merge, i.e., we take all rows from the left DataFrame and combine data from the right DataFrame, where we find some. <strong class="bd rr">Note how this results in 100k rows.</strong></figcaption></figure><ul class=""><li id="75c1" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">how='right'</strong></code>:同样，合并基于所有公共列。后缀是不相关的，因为所有公共列都将用于合并，所以不会留下重复的列。<br/>然而，这一次，我们与<code class="fe pi pj pk pl b"><strong class="lk jd">how='right'</strong></code>合并，这意味着我们将从右帧中取出所有行，并且只添加我们在左帧中找到的一些数据。这种情况相当于我们示例中的<code class="fe pi pj pk pl b"><strong class="lk jd">'inner'</strong></code>,因为左侧数据帧中的每一行在右侧数据帧中都有相应的行。<br/>运行<code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge(order_data,invoices,how='right')</strong></code> <strong class="lk jd"> : </strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rs"><img src="../Images/1272beab31d0783293492ee07cb566bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPu_temdmhiUQ9-vJlEtNA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">“right-sided” merge, i.e., we take all rows from the right DataFrame and add data from the left DataFrame, where we find some. <strong class="bd rr">Note how this results in ~50k rows</strong></figcaption></figure><ul class=""><li id="2257" class="mn mo it lk b ll lm lo lp lr mp lv mq lz mr md ms mt mu mv bi translated"><code class="fe pi pj pk pl b"><strong class="lk jd">how='outer'</strong></code>:同样，合并是基于所有公共列的。后缀是不相关的，因为所有公共列都将用于合并，所以不会留下重复的列。<br/>然而，这一次，我们与<code class="fe pi pj pk pl b"><strong class="lk jd">how='outer'.</strong></code>合并，我们从左侧或右侧数据帧中取出所有行，并在其他数据帧中找到的位置添加相应的数据。这种情况相当于我们示例中的<code class="fe pi pj pk pl b"><strong class="lk jd">'left'</strong></code>,因为左侧数据帧中的每一行在右侧数据帧中都有相应的行。运行<code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge(order_data,invoices,how='outer')</strong></code> <strong class="lk jd"> : </strong></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rt"><img src="../Images/d04a34cd008aa8ac76c369cb7989261f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxSDVVpSIz5JNr3X5695Kg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">“outer” merge, i.e., we take all rows from both DataFrames and add data from the corresponding other DataFrame, where we find some. <strong class="bd rr">Note how this results in 100k rows.</strong></figcaption></figure><h2 id="6425" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">合并—开/后缀</h2><p id="181a" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">如果我们确实显式提供了一个<code class="fe pi pj pk pl b"><strong class="lk jd">on</strong></code>参数，这将覆盖默认行为，并尝试在两个数据帧中找到所提供的列。未用于合并的剩余重复列将被加上后缀。</p><p id="aa30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的例子中，我们只在<code class="fe pi pj pk pl b"><strong class="lk jd">Order Id</strong></code>进行合并。然而，由于<code class="fe pi pj pk pl b"><strong class="lk jd">Date</strong></code> <strong class="lk jd"> </strong>和<code class="fe pi pj pk pl b"><strong class="lk jd">Company Id</strong></code> <strong class="lk jd"> </strong>列同时出现在两个数据帧中。这些列足以表明它们来自哪个源数据帧，如下例所示。</p><p id="81fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行:<code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge(order_data,invoices,on='Order Id')</strong></code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ru"><img src="../Images/a2cb0b985768d24abc05e79331255e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kp_MvIq2vO-p3EyhdsOOQA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Merge on one common column, default suffixes</figcaption></figure><p id="a9c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们也可以像这样指定自定义后缀:<br/> <code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge(order_data,invoices,on='Order Id',suffixes=('_base','_join'))</strong></code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rv"><img src="../Images/9d25de4c7d3546dd559421d5fd951ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EG_BFdxhuHlRIze3x6pWAA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Merge on one common column, custom suffixes (_base and _join)</figcaption></figure><h2 id="74d6" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">合并—左开/右开</h2><p id="7d52" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">当两个数据帧中的列名称不同时，通常会使用<code class="fe pi pj pk pl b"><strong class="lk jd">left_on</strong></code>和<code class="fe pi pj pk pl b"><strong class="lk jd">right_on</strong></code> <strong class="lk jd"> </strong>参数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rv"><img src="../Images/5aa6339368c8cc2bb6f3ea0cae675643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwqm18DCWJhaiDtr_P3JHg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Contrived example, where we first rename “Order Id” to “New Id” to then use it as our right_on target column</figcaption></figure><p id="7d29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> </strong> <code class="fe pi pj pk pl b"><strong class="lk jd">Join</strong></code> <strong class="lk jd">注:<br/> </strong>你可能见过<code class="fe pi pj pk pl b">join</code>的用法跟<code class="fe pi pj pk pl b">merge</code>一个下场。<code class="fe pi pj pk pl b">join</code>默认情况下，合并两个数据帧的索引。<strong class="lk jd">我建议不要使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">join</strong></code>，因为它只是<code class="fe pi pj pk pl b">merge</code>的一个特例，并不能提供比合并更好的好处。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="01c5" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">地图</h2><p id="a90f" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">到</span>结束关于组合数据帧的章节，我们应该快速讨论一下<code class="fe pi pj pk pl b">map</code>。<code class="fe pi pj pk pl b">map</code>可以在 DataFrame 列或其索引上调用，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rw"><img src="../Images/27a1c19fee56896b2e6279f6a254e6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIzgDMLnA9fvrw5DTYIlew.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">We create a new column based on the Sales Rep for the associated company by mapping the company column against a previously created lookup</figcaption></figure><p id="58cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pi pj pk pl b">map</code>的参数(在我们的例子中是<code class="fe pi pj pk pl b">lookup</code>)必须是一个序列或一个字典。虽然不完全相同，但熊猫系列和普通字典有很多共同的功能，并且经常可以互换使用。就像通过字典一样，你可以通过调用<code class="fe pi pj pk pl b">for k,v in series.items():</code>来循环遍历一个系列。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="a8cf" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">组合数据帧的摘要:</h2><ul class=""><li id="e50e" class="mn mo it lk b ll os lo ot lr ou lv ov lz ow md ms mt mu mv bi translated"><strong class="lk jd">使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">pd.concat</strong></code>将多个数据帧“堆叠”在一起。默认情况下，堆叠是垂直的。要覆盖默认设置，使用<code class="fe pi pj pk pl b">axis=1</code>。默认情况下，堆栈将覆盖所有列/索引。使用<code class="fe pi pj pk pl b">join='inner'</code>限制公共列/索引。</li><li id="1b44" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><strong class="lk jd">不要使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">pd.DataFrame.append</strong></code>，因为它只是<code class="fe pi pj pk pl b">pd.concat</code>的一种特殊的、有限的情况，只会让你的代码不那么标准化，不那么连贯。而是使用<code class="fe pi pj pk pl b">pd.concat</code>。</li><li id="50ad" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><strong class="lk jd">使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">pd.merge</strong></code>合并两个数据帧的信息。Merge 默认为内部连接，并将从数据帧中最大的公共列子集推断要合并的列。</li><li id="ebba" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><strong class="lk jd">不要使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">pd.DataFrame.join</strong></code>，因为它只是<code class="fe pi pj pk pl b">pd.merge</code>的一种特殊的、有限的情况，只会让你的代码不那么标准化，不那么连贯。相反，使用<code class="fe pi pj pk pl b">pd.merge</code>。</li><li id="3c81" class="mn mo it lk b ll mw lo mx lr my lv mz lz na md ms mt mu mv bi translated"><strong class="lk jd">使用</strong> <code class="fe pi pj pk pl b"><strong class="lk jd">pd.Series.map</strong></code> <strong class="lk jd"> </strong>作为类似查找的功能，从序列/字典中获取特定索引/键的值。</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="3a67" class="oa ob it bd oc od oe of og oh oi oj ok ki ol kj om kl on km oo ko op kp oq or bi translated">④重塑数据帧(融合、旋转、转置、堆叠、拆分)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rx"><img src="../Images/6088a2808a703ed12c9a144046fa2f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K24ZWrxyUV48sjsb"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Lawton</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="7f8f" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">移项</h2><p id="cbd0" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> T </span>转换数据帧意味着交换索引和列。换句话说，你是在围绕原点旋转数据帧。转置不会改变数据帧的内容。数据帧仅改变方向。让我们用一个例子来形象地说明这一点:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ry"><img src="../Images/896598a5bb2d0244f6b359303b60fdd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3x_sKuGXP9hhrO0XLFLgQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">The first seven rows of invoices DataFrame and first seven rows of invoices DataFrame transposed</figcaption></figure><p id="b200" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过简单地调用数据帧上的<code class="fe pi pj pk pl b">.T</code>来转置数据帧，例如<code class="fe pi pj pk pl b">invoices.T</code>。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="b7d4" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">熔化</h2><p id="4f58" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">M  elt 将数据帧从宽格式转换成长格式。Melt 为如何进行转换提供了灵活性。换句话说，melt 允许抓取列并将其转换为行，同时保持其他列不变。融化最好用一个例子来解释。让我们创建一些样本数据:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="8d28" class="pq ob it pl b gy pr ps l pt pu">melt_experiment = pd.merge(<br/>    invoices,<br/>    pd.get_dummies(invoices['Type of Meal']).mul(invoices['Meal Price'].values,axis=0),<br/>    left_index=True,<br/>    right_index=True<br/>)<br/>del melt_experiment['Type of Meal']<br/>del melt_experiment['Meal Price']<br/>melt_experiment</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rz"><img src="../Images/57dd5001e6f8551931fbfde55e4017d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUtOZjtyNRXQyavzWXJSSw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">melt_experiment (unpacked Type of Meal into columns)</figcaption></figure><p id="0383" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">诚然，这个例子有点做作，但说明了这一点。我们将<code class="fe pi pj pk pl b">Type of Meal</code>转换成列，并将价格分配到相应的行中。现在把它转换回一个版本，其中食物类型是一个列，值是价格，我们可以像这样使用<code class="fe pi pj pk pl b">pd.melt</code>:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="4473" class="pq ob it pl b gy pr ps l pt pu">pd.melt(<br/>    frame=melt_experiment,<br/>    id_vars=['Order Id', 'Date', 'Meal Id', 'Company Id', 'Date of Meal','Participants', 'Heroes Adjustment'],<br/>    value_vars=['Breakfast', 'Dinner', 'Lunch'],<br/>    var_name='Type of Meal',<br/>    value_name='Expenses'<br/>)</span></pre><p id="d3e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">导致:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sa"><img src="../Images/37a924633850318f70e6a1af334e23ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTBeUZpQl18VPXdgUXDT2Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">“melted” DataFrame</figcaption></figure><p id="b747" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Melt 有助于将数据帧转换成一种格式，其中一列或多列是标识符变量(<code class="fe pi pj pk pl b">id_vars</code>)，而所有其他列，即测量变量(<code class="fe pi pj pk pl b">value_vars</code>)，被移动到行轴，只留下两个非标识符列。对于我们融合的每一列(<code class="fe pi pj pk pl b">value_vars</code>)，对应的现有行被复制，以适应将数据融合到一列中，并且我们的数据框架扩展。熔化后，我们的行数是之前的三倍(因为我们使用了三个<code class="fe pi pj pk pl b">value_vars</code>，因此每行三倍)。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="d305" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">分组依据</h2><p id="fd99" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">我们在上一篇文章中讨论过，但是在这里快速回顾一下是有意义的，特别是在堆叠和拆堆方面，我们将在后面讨论。其中转置和熔化保持数据帧的内容不变，并且“仅”重新排列外观分组，并且以下方法以一种或另一种形式聚集数据。Groupby 将产生一个具有新索引(分组所依据的列的值)的聚合数据帧。如果按多个值进行分组，得到的数据帧将具有多重索引。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="83bd" class="pq ob it pl b gy pr ps l pt pu">invoices.groupby(['Company Id','Type of Meal']).agg(<br/>    {'Meal Price':np.mean}<br/>)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi sb"><img src="../Images/b44d05eb9c4dc5da2bb707aa3eb8718b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LGEuBuBQleVBvQqd4p9h8A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">groupby result with multi-index</figcaption></figure><p id="cc1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从 pandas 版本 0.25.1 开始，也有了命名聚合，这使得 groupby 可读性更好一些。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="f66c" class="pq ob it pl b gy pr ps l pt pu">invoices.groupby(['Company Id','Type of Meal']).agg(<br/>    Avg_Price = pd.NamedAgg(column='Meal Price', aggfunc=np.mean)<br/>)</span></pre><p id="93d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果实际上与前面的计算相同。但是，该列在此过程中会被重命名。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi sc"><img src="../Images/9ee5aa8e49305e5753a37e3bf0aa76a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*fLtfHyOevnPXOv_URorYCg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">groupby result with multi-index and renamed output column</figcaption></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="9d24" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">在枢轴上转动</h2><p id="01aa" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">和 Excel 的数据透视表一样，andas 也包含了一个<code class="fe pi pj pk pl b">pivot_table</code>功能。但是我必须承认，我从来没有使用过<code class="fe pi pj pk pl b">pivot</code>，因为我看不出它比 groupby 操作有什么优势。总的来说，我认为使用你感到舒适的东西并坚持这样做是有意义的。我建议不要在没有必要的时候混合使用不同的方法。不过，<code class="fe pi pj pk pl b">pivot_table</code>有一个优势就是<code class="fe pi pj pk pl b">margin=True</code></p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="3858" class="pq ob it pl b gy pr ps l pt pu">pd.pivot_table(<br/>    invoices,<br/>    index=['Company Id','Type of Meal'],<br/>    values='Meal Price',<br/>    aggfunc=np.mean,<br/>    margins=True<br/>)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi sd"><img src="../Images/3efb713560d54862a1540fed26806999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*7NE7Jg0-f6R0Uy9h4EkAPQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">result of pivot_table operation with margins=True</figcaption></figure><p id="78ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果应该看起来有些熟悉，因为我们基本上重新创建了 groupby 功能。然而，除了单个组的结果之外，我们还获得了跨所有组的计算值的额外好处(如最后一行所示)。</p><p id="2611" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以为数据透视表指定列:</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="3647" class="pq ob it pl b gy pr ps l pt pu">pd.pivot_table(<br/>    invoices,<br/>    index=['Company Id'],<br/>    columns=['Type of Meal'],<br/>    values='Meal Price',<br/>    aggfunc=np.mean,<br/>    margins=True<br/>)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi se"><img src="../Images/dec573350e60f7cefc7af8ccce0c2401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJlGv6jC9ftvMrQPJ51dRw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Pivot table with index and columns specified</figcaption></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="1477" class="pq ob it bd oc pv pw dn og px py dp ok lr pz qa om lv qb qc oo lz qd qe oq iz bi translated">堆叠/拆分</h2><p id="a9be" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi me translated">重新排列列和索引时,<span class="l mf mg mh bm mi mj mk ml mm di">S</span>stack 和 unstack 非常方便。默认情况下，将在索引的最外层调用 Unstack，正如在下面的示例中可以很好地看到的那样，调用<code class="fe pi pj pk pl b">unstack()</code>会将<code class="fe pi pj pk pl b">Heroes Adjustment</code>索引变成两列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sf"><img src="../Images/e241d91bd4138f622b37d35d53163488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvqVBusfFGxwcVfuQV75-A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">calling unstack() on three-level index DataFrame rotates the outmost index into columns</figcaption></figure><p id="a33a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以拆分特定级别的索引，如下例所示，其中我们拆分了<code class="fe pi pj pk pl b">Type of Meal</code>列</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sg"><img src="../Images/21480f8c0053e6e7105bdcdc8968edc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaHeH0y-Q0l_DR7gbvKD2g.png"/></div></div></figure><p id="61e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，堆叠的作用正好相反。堆叠将列转化为行，但是也在这个过程中扩展了索引(与<code class="fe pi pj pk pl b">melt</code>相反)。让我们看一个例子。</p><p id="d7bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们必须首先构建一些数据，在这些数据中，堆叠会派上用场。执行下面的代码片段会产生一个多索引、多级别列的数据框架。</p><pre class="ks kt ku kv gt pm pl pn po aw pp bi"><span id="0985" class="pq ob it pl b gy pr ps l pt pu">stack_test = invoices.groupby(['Company Id','Type of Meal']).agg({<br/>    'Meal Price':[max,min,np.mean],<br/>    'Date of Meal':[max,min],<br/>})<br/>stack_test</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sh"><img src="../Images/a78ace5d6199e2cf72ec4336f47e1512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7i1pPrL4ZlHNVNW4rJFJhw.png"/></div></div></figure><p id="2769" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想要堆叠这个数据帧，我们将调用<code class="fe pi pj pk pl b">stack_test.stack()</code>并得到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi si"><img src="../Images/03ca32af41792c424eb128900621e0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5p5pwBmpJAzMnw6ilATEQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">stacked groupby result</figcaption></figure><p id="36b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，stack 使用了我们的多级列的最外层，并将其转换为一个索引。我们现在只有单层列。或者，我们也可以用<code class="fe pi pj pk pl b">level=0</code>调用 stack，得到如下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sj"><img src="../Images/ec438004574e99270bc30ea02af557f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTlCxRxL7VDCYOTgeBlSCw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">stacked (on level=0) groupby result</figcaption></figure><h1 id="7d6c" class="oa ob it bd oc od oy of og oh oz oj ok ki pa kj om kl pb km oo ko pc kp oq or bi translated">摘要</h1><p id="23e3" class="pw-post-body-paragraph li lj it lk b ll os kd ln lo ot kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">在这篇文章中，你学会了如何成为一个真正的熊猫忍者。您了解了如何将数据转换成所需的类型以及在类型之间进行转换。您了解了如何为这些类型使用独特的方法来访问功能，否则需要一行又一行的代码。您学习了如何组合不同的数据帧，方法是将它们堆叠在一起，或者从数据帧中逻辑地提取信息，并将它们组合成更有意义的内容。你学会了如何翻转你的数据框，就像翻转煎饼一样。您学习了在其原点旋转、将列移入行、通过 pivot 或 groupby 聚合数据，然后堆叠和拆分结果。</p><p id="cb41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">干得好，感谢您的阅读！</p></div></div>    
</body>
</html>