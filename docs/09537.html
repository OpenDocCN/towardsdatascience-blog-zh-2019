<html>
<head>
<title>Databases: Fundamentals of SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库:SQL 基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fundamentals-of-sql-d0182bc1346b?source=collection_archive---------25-----------------------#2019-12-15">https://towardsdatascience.com/fundamentals-of-sql-d0182bc1346b?source=collection_archive---------25-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7932" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有客户交易实例的简单易懂的解释。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f1906ca44ff99e800cec619e8c17bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWtC4_lHG9BITgvAekHYDA.jpeg"/></div></div></figure><p id="3538" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章不可能完全涵盖 SQL 功能的每个方面，但是，我试图创建一个快速参考指南，提供 SQL 的实用方面，并以简洁的方式展示重要的功能。如果你发现任何错误，请毫不犹豫地评论出来。</p><h1 id="eae3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">第 1 级<br/>选择、从、在、分组依据、拥有、排序依据</h1><blockquote class="mi mj mk"><p id="d309" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">当我们编写 SQL 语句时，它们的顺序应该和上面写的一样。我们还可以看到下面的代码:</p></blockquote><blockquote class="mp"><p id="626c" class="mq mr it bd ms mt mu mv mw mx my lp dk translated">从&lt; <em class="mz">中选择* <br/>条件&gt; </em> <br/>其中&lt; <em class="mz">条件&gt; <br/> </em>分组按<em class="mz"> &lt;条件&gt; <br/> </em>有<em class="mz"> &lt;条件&gt; </em> <br/>顺序按&lt; <em class="mz">条件&gt; </em></p></blockquote><blockquote class="mi mj mk"><p id="a8c7" class="ku kv ml kw b kx na ju kz la nb jx lc mm nc lf lg mn nd lj lk mo ne ln lo lp im bi translated">然而，在执行方面，流程是不同的。这意味着，当 SQL 语句在服务器端运行时，其读取顺序与下面写的顺序相同:</p></blockquote><p id="09ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">FROM(它选择所需的表)<br/> WHERE(它根据条件过滤行)<br/> GROUP BY(它聚合过滤的结果)<br/> HAVING(聚合值的附加过滤级别)<br/> SELECT(从结果中选择适当的列)<br/> ORDER BY(按升序或降序排列值)</p><p id="17da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="302e" class="nk lr it ng b gy nl nm l nn no">SELECT OrderQty, Count(*) AS counts</span><span id="3cba" class="nk lr it ng b gy np nm l nn no">FROM Sales.SalesOrderDetail</span><span id="e28b" class="nk lr it ng b gy np nm l nn no">WHERE UnitPrice &gt; 1000</span><span id="e588" class="nk lr it ng b gy np nm l nn no">GROUP BY OrderQty</span><span id="715b" class="nk lr it ng b gy np nm l nn no">HAVING count(*) &lt; 500</span><span id="02bb" class="nk lr it ng b gy np nm l nn no">ORDER BY counts desc;</span></pre><p id="3310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/81020fc2319f7eb5419df0f2cf8cb4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*QzMF38fmNDoXj_bpB9U9Ig.jpeg"/></div></figure><p id="2217" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果显示，对于单价大于 1000 的所有订单，我们有 481 个数量为 6 的订单实例(意味着 6 个项目)和 266 个数量为 7 的订单实例，依此类推。因此，数量越高，计数越低。</p><h1 id="ca96" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">第二级<br/>子查询，别名</h1><p id="f57a" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">我们从子查询中得到的结果被传递给主查询，以便生成复杂且更精确的结果。此外，别名用于为列或表提供临时名称。让我们看看使用这两种方法生成结果的例子。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="97af" class="nk lr it ng b gy nl nm l nn no">SELECT OrderQty, LineTotal</span><span id="79e1" class="nk lr it ng b gy np nm l nn no">FROM Sales.SalesOrderDetail AS s1</span><span id="b6a6" class="nk lr it ng b gy np nm l nn no">WHERE UnitPrice = </span><span id="f9ce" class="nk lr it ng b gy np nm l nn no">(SELECT MIN(UnitPrice) FROM Sales.SalesOrderDetail AS s2</span><span id="5265" class="nk lr it ng b gy np nm l nn no">WHERE s1.SalesOrderDetailID = s2.SalesOrderDetailID )</span></pre><p id="03a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的子查询返回每个特定 ID 的最小单价。因此，如果 1 的 SalesOrderDetailID 有 5 件商品，它将返回所有这 5 件商品中的最低价格，ID 2 也是如此。</p><p id="18b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，主查询将返回单价与子查询输出的单价匹配的订单数量和行合计。s1 和 s2 称为别名，对于连接表非常有帮助。</p><p id="187d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7c79f0e747e02833c3f0955a1da14fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*48PDwSJ2MCSuTfWpHqAWvQ.jpeg"/></div></figure><p id="c0b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，我们有一个实例，其中数量为 1，行总计为 2024.99400，属于一个 ID 的最小单价。然后是另一个数量为 1 的实例，具有基于最低价格的特定行合计。</p><h1 id="f177" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">三级<br/>在，存在，之间</h1><blockquote class="mi mj mk"><p id="3414" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">IN 子句可用于子查询，如下所示:</p></blockquote><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="500e" class="nk lr it ng b gy nl nm l nn no">SELECT FirstName, LastName</span><span id="80de" class="nk lr it ng b gy np nm l nn no">FROM Person.Person</span><span id="71e3" class="nk lr it ng b gy np nm l nn no">WHERE BusinessEntityID IN</span><span id="70aa" class="nk lr it ng b gy np nm l nn no">       (SELECT BusinessEntityID FROM Sales.SalesPerson</span><span id="a616" class="nk lr it ng b gy np nm l nn no">                    WHERE SalesLastYear &gt; 2000000)</span></pre><p id="1ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此语句中，我们仅从 person 表中获取那些 BusinessEntityID 也存在于子查询中的人员的姓名，并且子查询从 Sales 表中返回销售额高于 2000000 的 business 的 BusinessEntityID。</p><blockquote class="mi mj mk"><p id="5363" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">EXISTS 子句可用于子查询，如下所示:</p></blockquote><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="c1b5" class="nk lr it ng b gy nl nm l nn no"> SELECT AccountNumber</span><span id="f81d" class="nk lr it ng b gy np nm l nn no"> FROM Sales.Customer AS c1</span><span id="84c6" class="nk lr it ng b gy np nm l nn no"> WHERE EXISTS </span><span id="ff8e" class="nk lr it ng b gy np nm l nn no">(SELECT * FROM Sales.SalesOrderHeader AS SOH</span><span id="1928" class="nk lr it ng b gy np nm l nn no"> WHERE SOH.CustomerID = c1.CustomerID AND OnlineOrderFlag=1)</span></pre><p id="f59d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">子查询只返回布尔值，而不是可以与其他列匹配的某些值。因此，只要在线订单被标记为 1，它就返回 TRUE，否则返回 FALSE。换句话说，外部查询仅基于子查询提供的 TRUE 和 FALSE 条件工作。</p><blockquote class="mi mj mk"><p id="dd2f" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">介于两者之间的例子</p></blockquote><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="73c9" class="nk lr it ng b gy nl nm l nn no">SELECT SalesOrderDetailID, UnitPrice FROM Sales.SalesOrderDetail</span><span id="5908" class="nk lr it ng b gy np nm l nn no">   WHERE OrderQty BETWEEN 4 AND 6</span></pre><p id="b0af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它只是检查订单数量在 4 和 6 之间的行。</p><h1 id="62f4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">四级<br/>窗口功能&amp;案例报表</h1><blockquote class="mi mj mk"><p id="c963" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">案例陈述真的很酷。</p></blockquote><p id="9528" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这仅仅是一个<strong class="kw iu"> if-then-else </strong>语句。它检查一个条件，如果它是真的，那么它返回一个特定的值，如果不是，它移动到 else 部分。我们可以定义许多 if-then 语句和一个 else 语句。只要遵循 SQL 的规则，就可以在整个脚本的任何地方使用它</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="ac27" class="nk lr it ng b gy nl nm l nn no">SELECT  SalesOrderID,</span><span id="1d13" class="nk lr it ng b gy np nm l nn no">CASE OrderQty</span><span id="f9e2" class="nk lr it ng b gy np nm l nn no">    WHEN 1 THEN 'Order quantity is 1'</span><span id="3b05" class="nk lr it ng b gy np nm l nn no">    WHEN 2 THEN 'Order quantity is 2'</span><span id="b7a1" class="nk lr it ng b gy np nm l nn no">    WHEN 3 THEN 'Order quantity is 3'</span><span id="48b5" class="nk lr it ng b gy np nm l nn no">    ELSE 'Greater Than 3'</span><span id="5a18" class="nk lr it ng b gy np nm l nn no">END AS Order_Quantity</span><span id="61cf" class="nk lr it ng b gy np nm l nn no">FROM Sales.SalesOrderDetail</span></pre><p id="4bbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码只是说，选择 OrderQty 列，如果它是 1，则打印“order quantity is 1 ”,并对其他列进行类似的操作，直到您点击 else，其余的值将被打印为“大于 3”</p><blockquote class="mi mj mk"><p id="055b" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">窗口函数对于销售、利润和其他指标的比较非常有用。</p></blockquote><p id="0835" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们将对其应用窗口函数的真实表的快照。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e3eb95f6b9ad2a8bb3c1f753633ecb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4Qo7BxW4Y6BZrRM-mXvxw.jpeg"/></div></div></figure><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="d51c" class="nk lr it ng b gy nl nm l nn no"><br/>SELECT OrderQty,</span><span id="963e" class="nk lr it ng b gy np nm l nn no">AVG(UnitPrice) OVER(PARTITION BY OrderQty) AS average,</span><span id="1d23" class="nk lr it ng b gy np nm l nn no">MAX(UnitPrice) OVER(PARTITION BY OrderQty) AS maximum,</span><span id="93b6" class="nk lr it ng b gy np nm l nn no">MIN(UnitPrice) OVER(PARTITION BY OrderQty) AS minimum FROM</span><span id="419c" class="nk lr it ng b gy np nm l nn no">Sales.SalesOrderDetail;</span></pre><p id="ca6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是结果的快照。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/05fbd5f5fc929866c5988ab89212a65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*NGsZavm2DgosT-LmPfuOSg.jpeg"/></div></figure><h1 id="2bde" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">第 5 级<br/>存储过程和 IF-ELSE (T-SQL)</h1><p id="b175" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">当我们不得不反复编写一段代码时，存储过程是很有用的。相反，我们可以创建一个存储过程，定义一个参数，然后使用 execute 命令执行该过程。我们定义的变量写在@之后，然后用在 WHERE 子句中。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="65c5" class="nk lr it ng b gy nl nm l nn no">CREATE PROCEDURE attempt @cost_limit int</span><span id="fe1a" class="nk lr it ng b gy np nm l nn no">      AS</span><span id="f196" class="nk lr it ng b gy np nm l nn no">      SELECT * FROM Production.ProductCostHistory</span><span id="beff" class="nk lr it ng b gy np nm l nn no">      WHERE StandardCost &gt; @cost_limit and endDate is null</span><span id="87c1" class="nk lr it ng b gy np nm l nn no">      GO</span><span id="d8a6" class="nk lr it ng b gy np nm l nn no">EXECUTE attempt @COST_LIMIT = 10</span></pre><p id="88d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果给出了标准成本大于执行期间传递给 cost_limit 变量的值的所有值(在本例中为 10)。</p><blockquote class="mi mj mk"><p id="9cd8" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">下一个例子</p></blockquote><p id="53a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们声明变量，然后，我们启动 IF 语句并检查事务类型的计数是否大于 1。如果条件为真，将执行 BEGIN 部分。SET 关键字用于将 select 语句的值存储到变量中。一旦设置了变量，我就使用 print 语句通过 SQL 的串联功能打印变量值。请注意，CAST 函数在转换变量的数据类型时非常有用。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="af6e" class="nk lr it ng b gy nl nm l nn no">DECLARE @TYPE1 int</span><span id="7080" class="nk lr it ng b gy np nm l nn no">DECLARE @TYPE2 int</span><span id="d562" class="nk lr it ng b gy np nm l nn no">DECLARE @TYPE3 int</span><span id="13d6" class="nk lr it ng b gy np nm l nn no">IF</span><span id="3282" class="nk lr it ng b gy np nm l nn no">(SELECT COUNT(*) TransactionType FROM Production.TransactionHistory) &gt; 1</span><span id="5bac" class="nk lr it ng b gy np nm l nn no">BEGIN</span><span id="fc81" class="nk lr it ng b gy np nm l nn no">SET @TYPE1 =</span><span id="64bf" class="nk lr it ng b gy np nm l nn no">(SELECT COUNT(*) FROM Production.TransactionHistory WHERE TransactionType = 'W');</span><span id="f8b4" class="nk lr it ng b gy np nm l nn no">SET @TYPE2 =</span><span id="6482" class="nk lr it ng b gy np nm l nn no">(SELECT COUNT(*) FROM Production.TransactionHistory WHERE TransactionType = 'S');</span><span id="b87d" class="nk lr it ng b gy np nm l nn no">SET @TYPE3 =</span><span id="fd70" class="nk lr it ng b gy np nm l nn no">(SELECT COUNT(*) FROM Production.TransactionHistory WHERE TransactionType = 'P');</span><span id="be6f" class="nk lr it ng b gy np nm l nn no">PRINT 'Total count of W type transactions ' + CAST(@type1 as varchar(10)) + '.' ;</span><span id="00b5" class="nk lr it ng b gy np nm l nn no">PRINT 'Total count of s type transactions ' + CAST(@type2 as varchar(10)) + '.' ;</span><span id="bb17" class="nk lr it ng b gy np nm l nn no">PRINT 'Total count of p type transactions ' + CAST(@type3 as varchar(10)) + '.' ;</span><span id="2f1d" class="nk lr it ng b gy np nm l nn no">END</span></pre><blockquote class="mi mj mk"><p id="03c4" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">使用存储过程和 IF-ELSE 函数输出结果的附加查询。</p></blockquote><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="033d" class="nk lr it ng b gy nl nm l nn no">CREATE PROCEDURE Learning</span><span id="b91b" class="nk lr it ng b gy np nm l nn no">@quantity int,</span><span id="9439" class="nk lr it ng b gy np nm l nn no">@cost INT</span><span id="4640" class="nk lr it ng b gy np nm l nn no">AS</span><span id="cf47" class="nk lr it ng b gy np nm l nn no">BEGIN</span><span id="4bd5" class="nk lr it ng b gy np nm l nn no">DECLARE @COUNT INT</span><span id="6527" class="nk lr it ng b gy np nm l nn no">SET @COUNT =</span><span id="4629" class="nk lr it ng b gy np nm l nn no">(SELECT count(*) from Production.TransactionHistory where Quantity &gt; @quantity and actualcost &gt; @cost)</span><span id="988e" class="nk lr it ng b gy np nm l nn no">PRINT @COUNT</span><span id="92ec" class="nk lr it ng b gy np nm l nn no">IF @count &gt; 1000</span><span id="68bc" class="nk lr it ng b gy np nm l nn no">BEGIN</span><span id="e551" class="nk lr it ng b gy np nm l nn no">PRINT 'There are more than 1000 instances with quantity =' + cast(@quantity as varchar)+ ' and cost =' + + cast(@cost as varchar)</span><span id="f96d" class="nk lr it ng b gy np nm l nn no">END</span><span id="9e2c" class="nk lr it ng b gy np nm l nn no">ELSE</span><span id="4356" class="nk lr it ng b gy np nm l nn no">BEGIN</span><span id="d9fb" class="nk lr it ng b gy np nm l nn no">PRINT 'THERE ARE LESS THAN 1000 such INSTANCES'</span><span id="de02" class="nk lr it ng b gy np nm l nn no">END</span><span id="0862" class="nk lr it ng b gy np nm l nn no">END</span><span id="21a2" class="nk lr it ng b gy np nm l nn no">GO</span><span id="7ce7" class="nk lr it ng b gy np nm l nn no">EXECUTE Learning @COST=10 , @QUANTITY = 10</span></pre></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><blockquote class="mi mj mk"><p id="ebe0" class="ku kv ml kw b kx ky ju kz la lb jx lc mm le lf lg mn li lj lk mo lm ln lo lp im bi translated">请注意一些要点</p></blockquote><ul class=""><li id="43ae" class="og oh it kw b kx ky la lb ld oi lh oj ll ok lp ol om on oo bi translated">取决于子查询输出的布尔值。</li><li id="7bf4" class="og oh it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">IN 取决于子查询输出的匹配值。</li><li id="4d5f" class="og oh it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">在 SQL 中，子句的顺序很重要，它根据执行的顺序而不同。</li><li id="52f9" class="og oh it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">为存储过程定义的变量不同于声明的变量。</li><li id="1a3a" class="og oh it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">任何内容都可以放在开始和结束之间，并作为单个批处理运行。</li></ul></div></div>    
</body>
</html>