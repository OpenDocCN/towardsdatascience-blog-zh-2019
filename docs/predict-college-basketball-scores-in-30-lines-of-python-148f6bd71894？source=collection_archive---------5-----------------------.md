# 用 30 行 Python 预测大学篮球成绩

> 原文：<https://towardsdatascience.com/predict-college-basketball-scores-in-30-lines-of-python-148f6bd71894?source=collection_archive---------5----------------------->

## [深度分析](https://medium.com/towards-data-science/in-depth-analysis/home)

## 创建一个机器学习算法，用不到 30 行 Python 代码预测大学篮球成绩

![](img/8c5bf93002e7dbbe69ddc12d525c230e.png)

Don’t worry, we’ve all been beaten by a Very Good Boy at least once. Photo by [Jenny Marvin](https://unsplash.com/@jennymarvin?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

又在你办公室的疯狂三月泳池里获得最后一名？有没有一只金毛或者你邻居家女儿的宠物石头选了一个比你更好的支架？创建一个获胜的阵营是困难的，甚至会绊倒大学篮球的专家分析师。与其让猜测工作听天由命，或者每个赛季看几千个小时的篮球比赛(我想我反正是这样做的，但那不是重点)，为什么不训练一台计算机来为你做预测呢？

在 Python 和一些令人敬畏的库的帮助下，您可以构建自己的机器学习算法，用不到 30 行代码预测 NCAA 男子 I 级大学篮球比赛的最终得分。本教程旨在解释创建机器学习应用程序所需的所有步骤，包括设置、数据检索和处理、训练模型以及打印最终预测。

# 设置

## 先决条件

要学习本教程，强烈建议您对 Python 有一个基本的了解，尽管这不是必需的。了解导入模块、获取和设置变量、字典和实例化类的目的是一个很好的基础，而使用`Pandas`和`sklearn`的经验是一个巨大的优势。

## 开发要求

*   **Python 3** :下面的所有代码也适用于 Python 2，但是当 Python 2 在 2020 年初[寿终正寝的时候，建议使用 Python 3 来帮助从 Python 2 过渡过来。](https://www.python.org/dev/peps/pep-0373/)
*   **pandas，sportsreference，sklearn** :我们所需的依赖项，将在下面进一步详细解释。它们可以通过 PIP 与以下内容一起安装:

```
pip install pandas sklearn sportsreference
```

*   **活跃的网络连接**:这对于大多数人来说可能不是问题，但是您最终使用的开发环境必须能够访问外部 web，以便从我们的代码中下载数据集。

# 构建应用程序

现在我们的开发环境已经设置好了，让我们开始构建实际的应用程序。

## 完整算法

Complete machine learning program to predict college basketball scores

对于那些喜欢直接跳到代码的人来说，上面的要点是我们将使用的最终程序。如果你已经熟悉了`pandas`和`sklearn`，你可以跳到本教程的底部，看看这个程序是如何运行的，以及如何扩展它以获得更高的精度、更快的运行时间和改进的可用性。对于其他想进一步了解这段代码的人，请继续阅读下面的内容，了解每一步的目的。

## 导入依赖关系

Importing all required dependencies

几乎每一个 Python 程序都以一个`import`部分开始，其中包含了模块后面要用到的必需依赖项。对于这个项目，我们需要导入我们之前安装的以下包:

*   **pandas** :一个流行的 Python 数据科学库，我们将使用它来存储和操作我们的数据集。
*   **sportsreference** :一个免费的 Python sports API，我们将使用它从 NCAAB 游戏中提取数据。更多信息可以在[这篇博文](https://medium.com/clarktech-sports/python-sports-analytics-made-simple-part-1-14569d6e9a86)中找到。
*   **sk learn**:Python 最大的机器学习库之一，包括几个预制的算法，比如我们将使用的`RandomForestRegressor`，以及一些有用的工具来帮助数据创建管道，比如自动创建训练和测试数据集的`train_test_split`。

## 正在初始化数据集

Initializing our dataset using sportsreference

没有数据集，任何机器学习应用都是不完整的。为了帮助我们预测 NCAAB 比赛的最终得分，我们希望创建一个包含所有单个比赛统计数据(如投篮命中率、失误次数和盖帽次数、篮板百分比等)的数据集，然后我们可以用它来预测这些因素与最终得分的关系。

为了创建这个数据集，我们首先需要初始化一个空的`Pandas DataFrame`，我们将使用它来存储我们的最终数据。接下来，我们从`sportsreference`初始化`Teams`类，它包含当前或最近一个赛季的每个 NCAA 男子篮球队的信息，并允许我们轻松地获取每个队的统计数据。

在提取数据之前，我们需要通过运行`for team in teams:`来迭代每支球队，其中每次迭代对应于联盟中唯一的一支球队。`sportsreference`公开了每个团队的日程和 boxscore 信息，并使我们能够编写类似于`team.schedule.dataframe_extended`的代码，该代码收集该团队在当前赛季参加的每场比赛的统计信息。`dataframe_extended`属性返回一个`pandas DataFrame`，其中每个索引对应一个不同的游戏。

在收集了每个游戏的 boxscore 信息后，我们希望将它添加到我们的整体数据集中，这样我们就有了一个单一的数据源。这可以通过将我们现有的数据集与包含当前团队完整 boxscore 信息的本地`DataFrame`连接起来来实现。通过用得到的连接覆盖我们现有的数据集，我们确保数据集总是不仅包括最近的团队的信息，还包括以前查询过的所有团队的信息。

## 预处理数据集

Preprocess our dataset by dropping unused values, creating our X and y, and separating a training and testing dataset

在我们的数据集完成自我构建后，我们需要从我们的数据集中过滤出一些我们不想使用的类别(或在机器学习中经常被称为**特征**)——即那些属于`string`类型(或**分类**)的类别，如团队名称或日期和地点。有时，基于字符串的要素会很有用，例如，在预测房屋价值和确定列为“海滨”的房产比列为“内陆”的房产价值更高的情况下。尽管该功能对房价预测很有用，但大多数机器学习算法无法处理基于字符串的数据。替换这些类型的特征的一种方法称为**一键编码**，它自动用唯一特征列替换相似的分类值，其中落入该特征的每个索引的值为 1，否则为 a。通过将类别更改为 1 和 0，机器学习算法能够更有效地处理这些特征。

然而，出于我们的目的，我们将简单地删除这些特性，因为它们要么太多(即可能的比赛场地非常大)，没有意义(在根据统计数据确定结果时，比赛是在 11 月 18 日还是 12 月 2 日并不重要)，或者会引入偏见(我们希望算法根据球队的表现来确定最终得分——而不仅仅是因为他们的名字是“杜克”)。因此，我们将放弃所有这些类别。

在这一点上，有些人可能想知道为什么我将`home_points`和`away_points`包含在要删除的字段列表中。这两个字段是我们想要预测的最终输出(通常称为**标签**),因此我们不希望它们包含在我们的主要特征中，而是应该将它们专门保留给我们的输出标签。

通过上面的代码，我们首先从数据集中删除所有不需要的特征，并将修剪后的输出保存为`X`。删除未使用的特性后，我们接下来删除所有数据不完整的行。如果 sports-reference.com 上的数据没有正确填充，或者如果一支球队没有执行某个统计动作，例如没有盖帽或罚球，这种情况有时会发生。有两种方法可以处理这种不完整的数据，一种是用一组数字设置缺失值(例如类别的平均值或默认值为零)，另一种是删除任何无效的行。因为对于我们的数据集来说，无效单元格的数量非常少，所以我们将删除所有数据不完整的行，因为这不会影响我们的最终结果。

因为探戈是两个人跳的(嗯，一场比赛有两个参赛队)，所以当两个队的时间表被拉出来时，每场比赛都有一个副本(一个是主队的，一个是客场队的)。这只是污染了我们的数据集，并没有提供任何价值，因为行是完全相同的，所以我们想删除任何副本，只保留每个游戏的一个实例。为此，我们只需将`drop_duplicates()`添加到我们的数据集中，以确保每个索引都是唯一的。

接下来，我们需要创建输出标签，用于在训练时确定模型权重的准确性，并测试最终算法的准确性。我们可以通过创建一个只包含主客场点的两列向量来生成标签，并将结果设置为`y`。

最后，通常的做法是将数据集分成训练和测试子集，以确保训练模型是准确的。理想情况下，我们希望将大约 75%的数据集用于训练，将剩余的 25%用于测试。这些子集应该随机选取，以防止模型偏向某一组特定的信息。使用定型数据集对模型进行定型后，应该对测试数据集运行该模型，以确定模型的预测性能，并查看它是否过度拟合。

幸运的是，`sklearn`有一个内置函数可以为我们创建这些子集。通过将我们的`X`和`y`帧输入到`train_test_split`中，我们能够检索具有预期分割的训练和测试子集。

## 创建和训练模型

Setting hyperparameters and training our model

既然我们的数据集已经被处理，现在是时候创建和训练我们的模型了。我决定在这个例子中使用一个 **RandomForestRegressor** ,因为该算法易于使用，相对准确，而且与标准决策树相比，它可以减少过拟合。随机森林算法创建了几个决策树，在特征权重中注入了一些随机性。这些决策树然后被组合以创建一个森林(因此是决策*树* ) 的*随机森林*，用于训练、验证或推断时的最终分析。该算法既支持**分类**也支持**回归**，使其非常灵活地适用于各种应用。

分类确定属于固定数量类别的输出标签，例如学生在测验中收到的字母等级(“A”、“B”、“C”、“D”或“F”)。只能有五个类别(或**类**)，因此模型将只尝试将输出放入这五个类别中的一个。另一方面，回归确定可以取值范围不确定的输出标签，例如房屋的价格。尽管有一个标准房价的范围，但是房子的售价是没有限制的，任何正数都是合理的。因为篮球比赛的最终比分从技术上讲可以是任何正数(或者零！)，我们要用回归。

在我们构建和训练我们的模型之前，我们首先需要设置一些**超参数**。超参数是在训练之前输入到模型中的参数，影响模型的构建和优化。对于机器和深度学习领域的大多数初学者来说，这些参数往往是最大的障碍，因为这些设置通常没有一个“完美”的值，如果有什么的话，确定应该放什么会变得非常困难。

一般的经验法则是，最初坚持使用这些超参数的默认值，然后一旦模型被训练和完成，并且您能够测试它，就开始使用试错法来调整这些值，直到您对最终结果满意为止。对于我们的模型，我选择了六个不同的超参数，并找到了这组特定的值来提供性能和精度之间的最佳平衡。关于这些具体设置的更多细节可在[官方 scikit-learn 文档](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html)中找到。

在选择了我们的超参数之后，终于到了创建模型的时候了。首先，我们需要实例化我们之前导入的`RandomForestRegressor`类，并包含我们的超参数。通过使用`(**parameters)`，我们将字典的键-值对扩展为该类的命名参数，其功能与以下内容相同:

An example of how dictionary expansion works for function calls

既然我们的模型已经实例化了，剩下的就是训练它了。`sklearn`通过将`fit`方法与`RandomForestRegressor`结合在一起，使这变得非常容易，所以我们只需要用我们的输入特性和相应的输出标签来运行它。这个方法就地运行，所以我们的`model`变量现在将自动指向一个经过训练的模型，我们可以用它来进行预测！

## 打印结果

Print the final results

我们应用程序的最后一步是根据我们的测试子集运行预测，并将它们与我们的预期结果进行比较。这个 print 语句将预测结果和我们的实际预期结果输出为两个不同的两列向量。

# 运行应用程序

我们期待已久的时刻终于到来了！我们的应用程序现在已经完成，剩下的就是运行算法了。我将我的程序命名为`ncaab-machine-learning-basic.py`，所以我只需要运行下面的代码来初始化算法:

```
python ncaab-machine-learning-basic.py
```

请注意**该程序可能需要很长时间** **才能完成**，因为大部分处理时间都花在了为 I 级大学篮球赛的所有 350+支球队构建数据集上。如果您只是希望看到一个工作的算法，您可以通过在数据连接行之后的第一个循环中添加一个`break`语句来提前停止数据创建。

一旦程序完成，它将输出类似如下的内容(为了节省空间，我减少了行数):

```
(array([[86, 86],
       [71, 71],
       [78, 77],
       [74, 72],
       [90, 81],
       ...
       [52, 66],
       [68, 65]]),
array([[ 83,  89],
       [ 71,  73],
       [ 80,  76],
       [ 77,  72],
       [ 92,  84],
       ...
       [ 46,  73],
       [ 66,  65]]))
```

该输出包含两个部分:预测输出和预期输出。从`array([[86, 86]`到`[68, 65]])`的所有内容都是预测输出，而`array([[83, 89]`到`[66, 65]])`是实际数据。如前所述，第一列是指*主场*队的预期得分，第二列是*客场*队的预计得分。

预测输出中的行也与预期输出中的行匹配，因此`[86, 86]`与`[83, 89]`相关，依此类推。如果我们比较下面的列表，我们会发现我们的预测并不太差！在大多数情况下，预计分数与实际结果只差几分。另一个有希望的迹象是，当实际分数与 70 分左右的典型结果不同时，我们的算法能够识别差异，并生成高于或低于正常分数的分数。

# 改进应用程序

如果这是你的第一个机器学习程序，恭喜你！希望本教程足以让您入门，并表明一个基本的机器学习应用程序不需要多年的教育或数千行代码。

虽然这个计划是一个很好的开始，但我们有很多方法可以扩展它，使它变得更好。下面是我将对应用程序进行的一些改进，以提高性能、准确性和可用性:

*   **将数据集保存到本地目录**:如前所述，该计划需要很长时间才能完成，因为它为所有 350 多个团队从头开始构建数据集。目前，如果您想要再次运行该算法，您将需要重新构建数据集，即使它没有发生变化。在第一次构建数据集之后，可以通过将`DataFrame`的副本转换成 CSV 或 Pickle 文件保存到本地文件系统来简化这个过程。然后，下次运行该程序时，您可以选择测试 CSV 或 Pickle 文件是否存储在本地，如果是，则从该文件加载它并跳过构建数据集。这将大大减少首次保存数据集后运行程序所需的时间。
*   **特征工程**:改进机器学习模型的一种常见做法被称为**特征工程**。这与创建或修改特征的过程有关，这些特征有助于模型找到各种类别之间的相关性。特征工程通常是一项困难的任务，就像超参数一样，没有一个定义好的方法可以用来持续提高性能。然而，一些经验法则是修改数字特征，使它们处于相同的数量级。例如，我们的数据集包含许多百分比和累计总数。百分比范围从 0 到 1，而总数可以是大于或等于 0 的任何数字(想想“分数”或“上场时间”)。修改这些特征使它们处于相同的数量级有助于模型的创建。特征工程的另一个例子是创建一个新的特征，比如著名的每个团队的[四因素评分](https://medium.com/@patrickoxford/an-introduction-to-four-factors-rating-3e9ee475ceed)。我们可以生成这个新特征，并将其包含在我们的数据集中，以确定它是否会改进整个模型。
*   **显示特定球队的预测**:虽然我们的程序很好地介绍了机器学习和预测篮球比分，但它并不能完全用于确定特定比赛或比赛的结果。一个很好的扩展是为特定的团队生成预测。这样，我们可以回答类似“印第安纳大学在普渡大学比赛”这样的问题。预测的分数是多少？”正如我们在构建数据集时所做的那样，我们可以利用`sportsreference`来生成特定于各个团队的数据，并在进行预测时将其用作我们的输入。
*   **为相似的代码块编写函数**:为了更加 Pythonic 化，并使我们的应用程序模块化以适应未来的变化，函数应该用于所有具有特定目的的代码块，例如构建数据集、处理数据、构建和训练模型。这也提高了代码的可读性，以帮助将来可能使用它的其他人。

既然您已经有了一个可以工作的应用程序，请尝试实现这些建议来提高模型的准确性和性能。如果您生成了一个您满意的模型，您可以使用它来为 NCAA 锦标赛创建预测，或者可能[参加比赛](https://www.kaggle.com/c/mens-machine-learning-competition-2019)。

虽然要打败金毛猎犬或莎莉的宠物岩石仍然很难，但这种算法可能会让你今年在公司的人才库中获得竞争优势。为什么不把这个三月**变成你的**并把吉姆从会计部赶下台呢？