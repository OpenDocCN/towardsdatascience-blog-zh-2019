<html>
<head>
<title>Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apache-spark-mllib-tutorial-part-3-complete-classification-workflow-a1eb430ad069?source=collection_archive---------15-----------------------#2019-06-05">https://towardsdatascience.com/apache-spark-mllib-tutorial-part-3-complete-classification-workflow-a1eb430ad069?source=collection_archive---------15-----------------------#2019-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="93ca" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Apache Spark ML 教程</h2><div class=""/><div class=""><h2 id="1b2b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">构建完整的分类工作流程</h2></div><p id="fac7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意:本文是系列文章的一部分。查看完整系列: <a class="ae lo" rel="noopener" target="_blank" href="/apache-spark-mllib-tutorial-ec6f1cb336a9"> <em class="ln">第 1 部分:回归</em> </a> <em class="ln">，</em> <a class="ae lo" rel="noopener" target="_blank" href="/apache-spark-mllib-tutorial-7aba8a1dce6e"> <em class="ln">第 2 部分:特征转化</em> </a> <em class="ln">，</em> <strong class="kt jd"> <em class="ln">第 3 部分:分类</em> </strong> <em class="ln">，第 4 部分及以上即将推出。</em></p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/41b76e34e040b64dca853e6d41434b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XNf7FP564eDVUpOqMNAzA.jpeg"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Image by <a class="ae lo" href="https://pixabay.com/users/pixel2013-2364555/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3401500" rel="noopener ugc nofollow" target="_blank">pixel2013 </a>from <a class="ae lo" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h1 id="5287" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">介绍</h1><p id="9ea9" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">在这个系列的这一部分中，我们将把我们所学的一切放在一起训练一个<strong class="kt jd">分类模型</strong>。目标是学习如何从头到尾建立一个完整的分类工作流程。</p><h1 id="cbef" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">问题定义</h1><p id="53c7" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们要解决的问题是臭名昭著的<a class="ae lo" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank"> <em class="ln">泰坦尼克号生存问题</em> </a>。我们被要求建立一个机器学习模型，该模型获取乘客信息，并预测他/她是否幸存。数据集包含 12 列，描述如下:[从<a class="ae lo" href="https://drive.google.com/open?id=1wI5UtWvoE_n9bvX8nMSp3v6tWr4NRb22" rel="noopener ugc nofollow" target="_blank">这里</a>下载]</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nj"><img src="../Images/26cc29f5158acbf40d2655f5c6006069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YBVHmYSEhj2yKVgZp6FRQ.png"/></div></div></figure><h1 id="1ece" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">准备开发环境</h1><p id="a010" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">你现在应该很熟悉这一步了。我们将打开一个新的<em class="ln"> Jyputer 笔记本</em>，导入并初始化<em class="ln"> findspark </em>，创建<em class="ln"> spark 会话</em>，最后<em class="ln">加载</em>数据。</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="fc88" class="np mn it nl b gy nq nr l ns nt">import findspark<br/>findspark.init('/opt/spark')<br/>from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.getOrCreate()<br/>data = spark.read.csv('./datasets/titanic.csv', inferSchema=True, header=True)</span></pre><p id="2d41" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们看看数据及其统计:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nu"><img src="../Images/9be7d1a5a217d67c8e98f94218944d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJuHzx0_GgfFdQfLkvGXCQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Top 20 rows of the dataset</figcaption></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nv"><img src="../Images/cc98c146c3e663d64f336a75bb3c0e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ja4ybZIdfx5MMhh4sVzNlQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Statistics</figcaption></figure><p id="01fa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面是一个关于某人如何通过分析上述表格来选择/更新其特征的示例:</p><ul class=""><li id="3e18" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">包含一些功能是没有意义的，例如:<em class="ln">乘客 ID </em>、<em class="ln">姓名</em>和<em class="ln">车票</em> →我们将删除它们</li><li id="ef34" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated"><em class="ln">小屋</em>有很多空值→我们也会删除它</li><li id="9581" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">也许<em class="ln">登上</em>柱与生存无关→让我们移除它</li><li id="e255" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">我们在<em class="ln">年龄</em>列中缺少 177 个值→ <em class="ln">年龄</em>很重要，我们需要找到一种方法来处理缺少的值</li><li id="172c" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated"><em class="ln">性别</em>有标称值→需要编码</li></ul><p id="bcb4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们过滤掉不需要的列:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="b5db" class="np mn it nl b gy nq nr l ns nt">data = data.select(['Survived', 'Pclass', 'Gender', 'Age', 'SibSp', 'Parch', 'Fare'])</span></pre><h1 id="04b0" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">特征转换</h1><p id="61b2" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们将逐个处理转换。在以后的文章中，我将讨论如何使用<strong class="kt jd">管道来改进这个过程。但是让我们先用无聊的方法来做。</strong></p><h2 id="77dd" class="np mn it bd mo ok ol dn ms om on dp mw la oo op my le oq or na li os ot nc iz bi translated">计算年龄缺失值</h2><p id="be40" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated"><em class="ln">年龄</em>是重要特征；因为一些缺失的值而丢弃它是不明智的。我们能做的是在现有价值的帮助下填补缺失的价值。这个过程被称为<strong class="kt jd">数据插补</strong>。有许多可用的策略，但我们将遵循一个简单的策略，用从样本中计算出的<em class="ln">平均值</em>来填充缺失值。</p><p id="dc43" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用<strong class="kt jd">估算器</strong>类，Spark ML 使这项工作变得简单。首先，我们定义估计量，使其适合模型，然后我们对数据应用转换器。</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="92d2" class="np mn it nl b gy nq nr l ns nt">from pyspark.ml.feature import Imputer<br/>imputer = Imputer(strategy='mean', inputCols=['Age'], outputCols=['AgeImputed'])<br/>imputer_model = imputer.fit(data)<br/>data = imputer_model.transform(data)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/a625e97a6be9612649cd7544b70e6cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*iCUpioBIVSalS8BoDZnSfA.png"/></div></figure><p id="a53b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不再有缺失值！让我们继续下一步…</p><h2 id="dab7" class="np mn it bd mo ok ol dn ms om on dp mw la oo op my le oq or na li os ot nc iz bi translated">性别价值观编码</h2><p id="f00f" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们了解到机器学习算法无法处理分类特征。所以，我们需要索引<em class="ln">性别</em>值:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="9f54" class="np mn it nl b gy nq nr l ns nt">from pyspark.ml.feature import StringIndexer<br/>gender_indexer = StringIndexer(inputCol='Gender', outputCol='GenderIndexed')<br/>gender_indexer_model = gender_indexer.fit(data)<br/>data = gender_indexer_model.transform(data)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/836a1473f59aa6dabd56520f358f5ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*yxMuH_QilE2ksjCp8j5u6w.png"/></div></figure><p id="0a76" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">没有更多的分类值…注意，我们不需要对索引值进行一次热编码，它们自然是用 0 和 1 值进行二进制编码的。</p><h2 id="d407" class="np mn it bd mo ok ol dn ms om on dp mw la oo op my le oq or na li os ot nc iz bi translated">创建特征向量</h2><p id="f67a" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们之前了解到<em class="ln"> Spark ML </em>期望数据在两列中表示:一个<em class="ln">特征向量</em>和一个<em class="ln">标签列</em>。我们已经准备好了<em class="ln">标签</em>列(<em class="ln">幸存</em>，所以让我们准备<em class="ln">特征向量</em>。</p><p id="9c74" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">注意，我们添加了<em class="ln">年龄估算</em>和<em class="ln">性别索引</em>，而不是<em class="ln">年龄</em>和<em class="ln">性别</em>。</strong></p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="030b" class="np mn it nl b gy nq nr l ns nt">from pyspark.ml.feature import VectorAssembler<br/>assembler = VectorAssembler(inputCols=['Pclass', 'SibSp', 'Parch', 'Fare', 'AgeImputed', 'GenderIndexed'], outputCol='features')<br/>data = assembler.transform(data)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/ee6c9d4cae03598687ea39b376dbdb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*ZGwdguUSsf5YJk6uwwVs_Q.png"/></div></figure><p id="19eb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们准备出发了！机器学习时间到了…</p><h1 id="08f8" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">训练模型</h1><p id="9726" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">对于这个问题，我们将使用一个<strong class="kt jd">随机森林分类器</strong>。您可以自由选择任何其他您认为合适的分类器。</p><p id="96f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">步骤:</p><ol class=""><li id="28b7" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ox oc od oe bi translated">创建评估者</li><li id="0d25" class="nw nx it kt b ku of kx og la oh le oi li oj lm ox oc od oe bi translated">指定要素列和标注列的名称</li><li id="8d55" class="nw nx it kt b ku of kx og la oh le oi li oj lm ox oc od oe bi translated">符合模型</li></ol><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="87e0" class="np mn it nl b gy nq nr l ns nt">from pyspark.ml.classification import RandomForestClassifier<br/>algo = RandomForestClassifier(featuresCol='features', labelCol='Survived')<br/>model = algo.fit(data)</span></pre><p id="d13f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">搞定了。</p><h1 id="f8b0" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">生成预测</h1><p id="0b27" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们调用模型的变换方法来获得我们的预测:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="404a" class="np mn it nl b gy nq nr l ns nt">predictions = model.transform(data)</span></pre><p id="5068" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们检查一下预测值:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="eba4" class="np mn it nl b gy nq nr l ns nt">predictions.select(['Survived','prediction', 'probability']).show()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/9a31044aa1c7be9b7f24e5c0243e6ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*473yShq-Lc4tGeXVrNaUrQ.png"/></div></figure><p id="9a59" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">到目前为止一切顺利，但是仔细检查记录并逐一验证这些记录不符合逻辑。我们需要计算一些指标来获得模型的整体性能。<strong class="kt jd">评估时间… </strong></p><h1 id="0f82" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">模型评估</h1><p id="36d8" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们将使用一个<strong class="kt jd">binary classification evaluator</strong>来评估我们的模型。它需要知道<em class="ln">标签列的名称</em>和<em class="ln">公制名称</em>。这里我们将使用 ROC 曲线 下的<a class="ae lo" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank"> <em class="ln">区域。</em></a></p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="f9c1" class="np mn it nl b gy nq nr l ns nt">from pyspark.ml.evaluation import BinaryClassificationEvaluator<br/>evaluator = BinaryClassificationEvaluator(labelCol='Survived', metricName='areaUnderROC')</span></pre><p id="ee75" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">调用 evaluate 方法获得结果:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="1eea" class="np mn it nl b gy nq nr l ns nt">evaluator.evaluate(predictions)</span></pre><p id="92a9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过使用上述设置，我的评估器返回:<strong class="kt jd"> 0.90 </strong></p><p id="0dfe" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">鉴于我们没有配置<em class="ln">预处理程序</em>，最初的结果是有希望的。我知道我没有根据测试数据进行评估，但我相信你能做到。</p><h1 id="3f42" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">使用 SciKit-Learn 进行模型评估</h1><p id="9721" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">如果您想生成其他评估，如混淆矩阵或分类报告，您总是可以使用<a class="ae lo" href="https://scikit-learn.org" rel="noopener ugc nofollow" target="_blank"> scikit-learn 库</a>。</p><p id="ee4a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你只需要从你的数据帧中提取<em class="ln"> y_true </em>和<em class="ln"> y_pred </em>。别担心，我会告诉你怎么做:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="3117" class="np mn it nl b gy nq nr l ns nt">y_true = predictions.select(['Survived']).collect()<br/>y_pred = predictions.select(['prediction']).collect()</span></pre><p id="b793" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">导入您的指标:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="48e5" class="np mn it nl b gy nq nr l ns nt">from sklearn.metrics import classification_report, confusion_matrix</span></pre><p id="e35d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过传递<em class="ln"> y_true </em>和<em class="ln"> y_pred </em>调用函数:</p><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="5343" class="np mn it nl b gy nq nr l ns nt">print(classification_report(y_true, y_pred))</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/78ceab2936f48497a92089831ed28892.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*uXXz19czDdO-ekEEwoMUQA.png"/></div></figure><pre class="lx ly lz ma gt nk nl nm nn aw no bi"><span id="de82" class="np mn it nl b gy nq nr l ns nt">print(confusion_matrix(y_true, y_pred))</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/32a2a536a1b672c086fa85638667a841.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*LCzJvUAPFUdqTUnVbWIOPQ.png"/></div></figure><h1 id="b5b7" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">最后的想法</h1><p id="8727" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">恭喜你。您已经成功完成了另一个教程。你现在应该对自己的<em class="ln"> Spark ML </em>技能更有信心了。在未来的教程中，我们将通过使用<strong class="kt jd"> <em class="ln">管道</em> </strong>来改进预处理阶段，我将向您展示更多令人兴奋的<em class="ln"> Spark ML </em>特性。敬请关注…</p><p id="71d9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你喜欢这篇文章，请点击“鼓掌”按钮，我将不胜感激👏所以可能会传染给他人。也可以在 <a class="ae lo" href="https://twitter.com/alimasri1991" rel="noopener ugc nofollow" target="_blank"> <em class="ln">推特</em> </a> <em class="ln">，</em> <a class="ae lo" href="https://www.facebook.com/alimasri91" rel="noopener ugc nofollow" target="_blank"> <em class="ln">脸书</em> </a> <em class="ln">，</em> <a class="ae lo" href="mailto:alimasri1991@gmail.com" rel="noopener ugc nofollow" target="_blank"> <em class="ln">上关注我直接发邮件给我</em> </a> <em class="ln">或者在</em><a class="ae lo" href="https://www.linkedin.com/in/alimasri/" rel="noopener ugc nofollow" target="_blank"><em class="ln">LinkedIn</em></a><em class="ln">上找我。</em></p></div></div>    
</body>
</html>