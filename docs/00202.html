<html>
<head>
<title>Introduction to Deep Learning with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Keras 深度学习简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-deep-learning-with-keras-17c09e4f0eb2?source=collection_archive---------3-----------------------#2019-01-09">https://towardsdatascience.com/introduction-to-deep-learning-with-keras-17c09e4f0eb2?source=collection_archive---------3-----------------------#2019-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e575" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用 Keras 深度学习库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f125b2c4f2126dcd2a36e5d350d9a5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hsMHZrp2FYa0TsoS"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Figure 1: Photo by <a class="ae kv" href="https://unsplash.com/@blakeconnally?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blake Connally</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>是一个高级神经网络 API，能够运行在<a class="ae kv" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>、<a class="ae kv" href="https://github.com/Theano/Theano" rel="noopener ugc nofollow" target="_blank"> Theano、</a>和<a class="ae kv" href="https://github.com/Microsoft/cntk" rel="noopener ugc nofollow" target="_blank"> CNTK </a>之上。它通过高级、用户友好、模块化和可扩展的 API 实现快速实验。Keras 也可以在 CPU 和 GPU 上运行。</p><p id="c689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Keras 由<a class="ae kv" href="https://twitter.com/fchollet?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor" rel="noopener ugc nofollow" target="_blank"> Francois Chollet </a>开发和维护，是 Tensorflow 核心的一部分，这使其成为 tensor flow 首选的高级 API。</p><p id="dba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是解释如何使用 Keras 进行深度学习的系列文章的第一篇。</p><p id="3990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将介绍 Keras 的基础知识，包括两个最常用的 Keras 模型(<a class="ae kv" href="https://keras.io/getting-started/sequential-model-guide/" rel="noopener ugc nofollow" target="_blank">顺序</a>和<a class="ae kv" href="https://keras.io/getting-started/functional-api-guide/" rel="noopener ugc nofollow" target="_blank">功能</a>)、核心层以及一些预处理功能。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="09e6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">安装 Keras</h1><p id="6466" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我假设你已经有了一个可以工作的 Tensorflow 或 Theano 或 CNTK。如果你不检查上面的链接。</p><p id="904a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Keras 可以使用 pip 或 conda 安装:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3438" class="nb ma iq mx b gy nc nd l ne nf">pip install keras<br/>or<br/>conda install keras</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dfa0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在数据集中加载</h1><p id="0261" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Keras 提供了<a class="ae kv" href="https://keras.io/datasets/" rel="noopener ugc nofollow" target="_blank">七个不同的数据集</a>，可以使用 Keras 直接加载。这些包括图像数据集以及<a class="ae kv" href="https://www.kaggle.com/vikrishnan/boston-house-prices" rel="noopener ugc nofollow" target="_blank">房价</a>和<a class="ae kv" href="https://www.kaggle.com/iarunava/imdb-movie-reviews-dataset" rel="noopener ugc nofollow" target="_blank">电影评论</a>数据集。</p><p id="c701" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用<a class="ae kv" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST 数据集</a> <a class="ae kv" href="https://www.cs.toronto.edu/~kriz/cifar.html" rel="noopener ugc nofollow" target="_blank">，</a>，它包含 70000 张 28x28 灰度图像和 10 个不同的类别。Keras 将其分为一个包含 60000 个实例的训练集和一个包含 10000 个实例的测试集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将图像输入到<a class="ae kv" href="http://cs231n.github.io/convolutional-networks/" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>中，我们将数据帧转换为四维。这可以使用 numpys <code class="fe ni nj nk mx b">reshape</code>方法来完成。我们还将把数据转换成浮点数，并使其正常化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将使用 Keras 的<code class="fe ni nj nk mx b">to_categorical</code>方法将我们的标签转换成<a class="ae kv" href="https://hackernoon.com/what-is-one-hot-encoding-why-and-when-do-you-have-to-use-it-e3c6186d008f" rel="noopener ugc nofollow" target="_blank">一键编码</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3f6e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用顺序 API 创建模型</h1><p id="b015" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在 Keras 中创建模型最简单的方法是使用顺序 API，它允许您一层一层地堆叠。顺序 API 的问题是，它不允许模型有多个输入或输出，而这对于某些问题是需要的。</p><p id="f9dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，对于大多数问题，顺序 API 是一个完美的选择。</p><p id="2b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个<a class="ae kv" href="http://cs231n.github.io/convolutional-networks/" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>，我们只需要创建一个<code class="fe ni nj nk mx b">Sequential</code>对象，并使用<code class="fe ni nj nk mx b">add</code>函数添加层。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9b9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码首先创建了一个<code class="fe ni nj nk mx b">Sequential</code>对象，并添加了一些卷积、最大池和漏失层。然后，它使输出变平，并在将其传递给输出层之前，将其传递给最后一个密集层和漏失层。如果你没有信心建立一个卷积神经网络(CNN ),看看这个伟大的教程。</p><p id="c5c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺序 API 还支持另一种语法，其中层被直接传递给构造函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c6aa" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用函数式 API 创建模型</h1><p id="2457" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">或者，函数式 API 允许您创建相同的模型，但是以简单性和可读性为代价为您提供了更多的灵活性。</p><p id="1a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可用于多个输入和输出图层以及共享图层，从而使您能够构建真正复杂的网络结构。</p><p id="f9a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用函数式 API 时，我们总是需要将前一层传递给当前层。它还需要使用输入层。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9ead" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式 API 也经常用于<a class="ae kv" href="https://machinelearningmastery.com/transfer-learning-for-deep-learning/" rel="noopener ugc nofollow" target="_blank">迁移学习</a>，我们将在另一篇文章中讨论。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ea22" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">编译模型</h1><p id="666d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在开始训练我们的模型之前，我们需要配置学习过程。为此，我们需要指定一个优化器、一个损失函数和一些可选的度量标准，如准确性。</p><p id="f310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=IVVVjBSk9N0" rel="noopener ugc nofollow" target="_blank">损失函数</a>是对我们的模型在实现给定目标方面有多好的度量。</p><p id="600b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/types-of-optimization-algorithms-used-in-neural-networks-and-ways-to-optimize-gradient-95ae5d39529f">优化器</a>用于通过使用梯度更新权重来最小化损失(目标)函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="99a5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">扩充图像数据</h1><p id="a4fc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">扩充是从现有数据中创建更多数据的过程。对于图像，你可以做一些小的变换，比如旋转图像，放大图像，添加噪声等等。</p><p id="04d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有助于使模型更加稳健，并解决没有足够数据的问题。Keras 有一个叫做<code class="fe ni nj nk mx b">ImageDataGenerator</code>的方法，可以用来扩充图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ni nj nk mx b">ImageDataGenerator </code>将创建已经旋转、放大或缩小、宽度和高度发生变化的新图像。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ee23" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">符合模型</h1><p id="70ea" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">既然我们已经定义并编译了我们的模型，那么就可以开始训练了。为了训练一个模型，我们通常会使用<code class="fe ni nj nk mx b">fit</code>方法，但是因为我们使用的是数据生成器，我们将使用<code class="fe ni nj nk mx b">fit_generator </code>并向其传递我们的生成器、X 数据、y 数据以及<a class="ae kv" rel="noopener" target="_blank" href="/epoch-vs-iterations-vs-batch-size-4dfb9c7ce9c9">历元数和批量大小</a>。我们还将向它传递一个验证集，以便我们可以监控这两个集的损失和准确性，以及使用生成器时所需的 steps_per_epoch，它被设置为训练集的长度除以 batch_size。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="839b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将输出:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b960" class="nb ma iq mx b gy nc nd l ne nf">Epoch 1/5<br/>1875/1875 [==============================] - 22s 12ms/step - loss: 0.1037 - acc: 0.9741 - val_loss: 0.0445 - val_acc: 0.9908<br/>Epoch 2/5<br/>1875/1875 [==============================] - 22s 12ms/step - loss: 0.0879 - acc: 0.9781 - val_loss: 0.0259 - val_acc: 0.9937<br/>Epoch 3/5<br/>1875/1875 [==============================] - 22s 12ms/step - loss: 0.0835 - acc: 0.9788 - val_loss: 0.0321 - val_acc: 0.9926<br/>Epoch 4/5<br/>1875/1875 [==============================] - 22s 12ms/step - loss: 0.0819 - acc: 0.9792 - val_loss: 0.0264 - val_acc: 0.9936<br/>Epoch 5/5<br/>1875/1875 [==============================] - 22s 12ms/step - loss: 0.0790 - acc: 0.9790 - val_loss: 0.0220 - val_acc: 0.9938</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a839" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可视化培训过程</h1><p id="c361" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们可以可视化每个时期的训练和测试精度和损失，这样我们就可以直观地了解模型的性能。各代的精度和损失保存在我们训练时获得的历史变量中，我们将使用 Matplotlib 来可视化这些数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5bbe10b22bcefd1584dce0ad4e174bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*AXTzWyU8JG2LZJffye9LxQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Figure 2: Training/Testing accuracy over epochs</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f165014350e6070e26065ca22542b834.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*tfkat3Y2p_yGMmFiH-TTyA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Figure 3: Training/Testing loss over epochs</figcaption></figure><p id="ff67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的图表中，我们可以看到我们的模型没有过度拟合，我们可以训练更多的纪元，因为验证损失仍在减少。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9249" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">推荐读物</h1><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/building-a-book-recommendation-system-using-keras-1fba34180699"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">使用 Keras 构建图书推荐系统</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">如何使用嵌入创建图书推荐系统？</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c1b5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="186a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><a class="ae kv" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>是一个高级神经网络 API，能够运行在<a class="ae kv" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>、<a class="ae kv" href="https://github.com/Theano/Theano" rel="noopener ugc nofollow" target="_blank"> Theano </a>和<a class="ae kv" href="https://github.com/Microsoft/cntk" rel="noopener ugc nofollow" target="_blank"> CNTK </a>之上。它通过高级、用户友好、模块化和可扩展的 API 以及在 CPU 和 GPU 上运行来实现快速实验。</p><p id="cdd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是介绍 Keras 工作原理的系列文章的第一篇。在这篇文章中，我们讨论了安装以及如何创建一个简单的卷积神经网络。</p><p id="a10a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，可以考虑订阅我的 Youtube 频道并在社交媒体上关注我。</p><p id="22da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文涵盖的代码可以从<a class="ae kv" href="https://github.com/TannerGilbert/Tutorials/blob/master/Introduction%20to%20Deep%20Learning%20with%C2%A0Keras/Introduction%20to%20Deep%20Learning%20with%20Keras.ipynb" rel="noopener ugc nofollow" target="_blank"> Github 资源库</a>获得。</p><p id="98db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有任何问题、建议或批评，可以通过<a class="ae kv" href="https://twitter.com/Tanner__Gilbert" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或评论区联系我。</p></div></div>    
</body>
</html>