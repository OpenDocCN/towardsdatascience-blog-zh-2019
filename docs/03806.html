<html>
<head>
<title>Introduction to forecasting Philippine stock prices using Facebook’s Prophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍使用脸书的先知预测菲律宾股票价格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-forecasting-philippine-stock-prices-fd4df5dad9c3?source=collection_archive---------9-----------------------#2019-06-16">https://towardsdatascience.com/introduction-to-forecasting-philippine-stock-prices-fd4df5dad9c3?source=collection_archive---------9-----------------------#2019-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="77c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">预测菲律宾 Jollibee Food Corp (JFC)公司股票价格的基本 python 工作流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab9839e92fbd7a0ae2ff1713019fb97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtSUo_zTPcKWmkxQ5iQ96g.png"/></div></div></figure><p id="ba41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我从大学开始就在菲律宾从事股票交易，并立即确信这是一个预测模型非常有用的领域。为什么？因为你在股市赚钱的能力取决于你预测未来价格的能力。</p><p id="a07e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将使用 python 上强大的 Prophet 包演示一种快速预测菲律宾股票 Jollibee Foods Corporation (JFC)每日收盘价的方法。Prophet 是脸书公司开发的一款开源预测工具，它可以将标准的预测工作流程从通常需要几天或几周的时间缩短到几分钟(假设你已经有了正确格式的数据)。</p><p id="4a86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有相关数据和代码可在本<a class="ae lq" href="https://github.com/enzoampil/data-science-demos" rel="noopener ugc nofollow" target="_blank">回购</a>的<em class="lr">时序</em>目录中找到。</p><p id="0632" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将遵循以下工作流程:</p><ol class=""><li id="a0e3" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">安装并导入必要的软件包</li><li id="f1a5" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">获取数据</li><li id="c831" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">绘制时间序列</li><li id="85e3" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">训练先知模型</li><li id="8df8" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">预测未来！</li><li id="1007" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">评估准确性</li></ol><p id="37ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧！</p><h1 id="79a5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.安装并导入必要的软件包</h1><p id="ef18" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">只是先知+基础。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="75aa" class="ni mh it ne b gy nj nk l nl nm"># Run these on your terminal<br/>pip install pandas<br/>pip install datetime<br/>pip install fbprophet<br/>pip install numpy<br/>pip install matplotlib</span><span id="b100" class="ni mh it ne b gy nn nk l nl nm"># Alternatively, you can run these from jupyter this way<br/>!pip install pandas<br/>!pip install datetime<br/>!pip install fbprophet<br/>!pip install numpy<br/>!pip install matplotlib</span></pre><h1 id="4d79" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.获取数据</h1><p id="acae" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们所需要的是一个文件，我们可以读入 python 作为熊猫数据帧，其中包含 2 列对应于股票的收盘价和日期。</p><p id="e7c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个介绍，我在这个<a class="ae lq" href="https://github.com/enzoampil/data-science-demos" rel="noopener ugc nofollow" target="_blank">回购</a>的<em class="lr">时间序列</em>目录中保存了一份 JFC 从 2013 年 9 月 1 日到 2019 年 4 月 26 日的收盘价(以及这里的其余代码)。我们可以通过克隆这个<a class="ae lq" href="https://github.com/enzoampil/data-science-demos" rel="noopener ugc nofollow" target="_blank"> repo </a>并导航到<em class="lr">时序</em>目录来访问数据。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4f67" class="ni mh it ne b gy nj nk l nl nm"># Run these on your terminal<br/>git clone <a class="ae lq" href="https://github.com/enzoampil/data-science-demos.git" rel="noopener ugc nofollow" target="_blank">https://github.com/enzoampil/data-science-demos.git</a><br/>cd data-science-demos/time-series</span><span id="5b94" class="ni mh it ne b gy nn nk l nl nm"># Alternatively, you can run these from jupyter this way<br/>!git clone <a class="ae lq" href="https://github.com/enzoampil/data-science-demos.git" rel="noopener ugc nofollow" target="_blank">https://github.com/enzoampil/data-science-demos.git</a><br/>!cd data-science-demos/time-series</span><span id="6ca2" class="ni mh it ne b gy nn nk l nl nm"># Read the JFC data (csv) as a pandas DataFrame<br/>jfc = pd.read_csv("<a class="ae lq" href="https://github.com/enzoampil/data-science-demos/blob/master/time-series/jfc_20130901_to_20190426.csv" rel="noopener ugc nofollow" target="_blank">jfc_20130901_to_20190426.csv</a>")</span><span id="7799" class="ni mh it ne b gy nn nk l nl nm"># Convert the date column to datetime format<br/>jfc['CHART_DATE'] = pd.to_datetime(jfc.CHART_DATE)</span></pre><h1 id="c42c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.绘制时间序列</h1><p id="bcf2" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">为此，我们可以使用直接从 pandas 数据框架中访问的基本绘图功能。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1402" class="ni mh it ne b gy nj nk l nl nm"># Plot the time series<br/># 'CHART_DATE' is the date and 'CLOSE' is the closing price<br/>jfc.set_index('CHART_DATE').CLOSE.plot(figsize=(15, 10))<br/>plt.title('Jollibee Daily Closing Price', fontsize=25)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/5aa66515be5e415cbf6d193c47ccf67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJYdj2atoYgUJ9o6rFdh9g.png"/></div></div></figure><p id="bc33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到，JFC 的收盘价在上升和下降的周期中波动，但整体趋势仍在上升。Prophet 的优势之一是，在进行预测时，它可以自动考虑趋势中发现的季节性。</p><h1 id="7c89" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.训练先知模型</h1><p id="16c9" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">现在，我们可以训练先知模型了！要做到这一点，我们必须首先过滤数据框架，使其只有两列:日期，“CHART_DATE”和收盘价“CLOSE”。然后，我们将它们的名称分别改为“ds”和“y ”,因为 Prophet 会自动将“ds”列读取为日期，将“y”列读取为被预测的变量。最后，我们根据训练数据训练模型，训练数据是指在指定的维持期开始之前的数据。在这种情况下，“HOLDOUT_START”是对应于保持期开始的日期(设置为 2019-03-01)。</p><p id="6ce1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，维持期的数据将被视为我们的验证集，并将用于评估已训练的 Prophet 模型的性能。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e8ce" class="ni mh it ne b gy nj nk l nl nm"># Set holdout (validation) set start<br/>HOLDOUT_START = '2019-03-01'</span><span id="e6d8" class="ni mh it ne b gy nn nk l nl nm"># Import the Prophet package<br/>from fbprophet import Prophet</span><span id="68f3" class="ni mh it ne b gy nn nk l nl nm"># Filter to only the date and closing price columns<br/>ts = jfc[['CHART_DATE', 'CLOSE']]</span><span id="b2e4" class="ni mh it ne b gy nn nk l nl nm"># Rename the date and closing price columns to 'ds', and 'y', respectively<br/># We do this since prophet automatically reads the 'ds' column as the date and the 'y' column as the variable that we are forecasting<br/>ts.columns = ['ds', 'y']</span><span id="720b" class="ni mh it ne b gy nn nk l nl nm"># Fit the Prophet model to the training data (before the start of the holdout set)<br/># We set daily_seasonality and yearly_seasonality to True to account for daily and yearly seasonality, respectively<br/>m = Prophet(daily_seasonality=True, yearly_seasonality=True).fit(ts[ts.ds &lt; HOLDOUT_START])</span></pre><h1 id="5776" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.预测未来！</h1><p id="afd1" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在 Prophet 中，我们首先创建一个未来数据帧<em class="lr">，</em>，在这里我们指定我们想要预测的未来有多远；在本例中，我们将其设置为 336 天。接下来，我们调用在已训练的 prophet 模型中找到的 predict 方法(使用未来数据帧<em class="lr"> </em>作为参数),这将返回预测。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="477a" class="ni mh it ne b gy nj nk l nl nm"># Set the forecast period, "periods", in the specified unit, "freq"<br/># In this case, we're predicting 336 days into the future<br/>future = m.make_future_dataframe(periods=7*4*12, freq='D')</span><span id="dc19" class="ni mh it ne b gy nn nk l nl nm"># Make the actual predictions<br/>pred = m.predict(future)</span><span id="1df7" class="ni mh it ne b gy nn nk l nl nm"># Visualise the predictions using Prophet's plotting method<br/>from matplotlib import pyplot as plt<br/>fig1 = m.plot(pred)<br/>plt.title('Jollibee: Forecasted Daily Closing Price', fontsize=25)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/ec76557c0eec1c8f3f6801e3bd68fcf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZ9VjY3H9ADV1dYfZWLRWA.png"/></div></div></figure><p id="7b7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">预测以及历史收盘价如上所示。蓝线对应于预测的收盘价，而黑点对应于训练集中的历史收盘价。抵制期的预测收盘价表明价格将在该期间(2019 年 3 月 1 日至 2019 年 4 月 26 日)下跌。</p><p id="e176" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">蓝色阴影区域对应于预测的 95%置信区间。您会注意到，距离更远的预测也具有更宽的预测置信区间。</p><h1 id="994e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.评估准确性</h1><p id="5a6b" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">为了评估我们训练的 Prophet 模型的准确性，我们将计算我们对 2019 年 3 月 1 日至 2019 年 4 月 26 日的维持集的预测的均方根误差(RMSE)。为了更详细地展示业绩，我们还绘制了 57 天维持期的预测 JFC 收盘价与实际 JFC 收盘价的对比图。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="86d6" class="ni mh it ne b gy nj nk l nl nm"># Concatenate holdout (validation) set predictions and targets into one dataframe for easy comparison<br/>pred_holdout = pred[(pred.ds &gt;= HOLDOUT_START)&amp;(pred.ds &lt;= ts.ds.max())].set_index('ds').yhat<br/>target_holdout = ts[ts.ds &gt;= HOLDOUT_START].set_index('ds')<br/>comb = pd.concat([pred_holdout, target_holdout], axis=1).dropna()</span><span id="5555" class="ni mh it ne b gy nn nk l nl nm"># Calculate root mean squared error (RMSE)<br/>import numpy as np<br/>rmse_holdout = np.sqrt(comb.yhat.subtract(comb.y).pow(2).mean())</span><span id="9f3b" class="ni mh it ne b gy nn nk l nl nm"># Plot predicted vs target while displaying accuracy based on rmse<br/>comb.columns = ['Predicted', 'Actual']<br/>comb.plot(figsize=(15, 10))<br/>plt.title('Predicted (yhat) vs Actual (y) JFC Closing Price \n Validation Set RMSE: {}'.format(rmse_holdout), fontsize=25)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/ea4f62639ef184d60d44a012780e1eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pkDblJNJGsz1e8JruQAcw.png"/></div></div></figure><p id="5043" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，维持集的预测价格(蓝色)表明，在维持集的持续时间内，价格会整体下降。有趣的是，实际价格(橙色)也显示了 JFC 收盘价的总体下降，尽管比预测的要快。</p><p id="8eb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，短期运动似乎也反映在预测中。实际趋势显示，到 4 月 8 日开始上升，然后在 4 月 26 日开始下降。预测再次显示了类似的变化，尽管没有那么剧烈。</p><p id="9434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计算出的均方根误差(RMSE)为 5.56，这告诉我们，对于 2019 年 3 月 1 日至 2019 年 4 月 26 日的坚守期，Prophet 模型的 JFC 收盘价预测平均误差为 5.56 PHP。这个误差足够小，让我们相信预测吗？这将取决于我们承担风险的意愿，但保守的经验法则是，即使在预期价格向下偏离预测价格的情况下，也只根据显示盈利机会的预测进行交易。</p><h1 id="a595" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">下一步是什么？</h1><p id="47f4" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">恭喜你！您现在知道如何使用强大的 Prophet 包执行基本的预测工作流。这包括以下步骤:1)安装和导入必要的软件包，2)获取数据，3)绘制时间序列，4)训练 Prophet 模型，5)使用该模型预测未来，最后，6)评估准确性。除了预测股票价格之外，还可以使用其他预测模型和用例来应用相同的工作流。</p><p id="e25a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，仍有许多方法可以改进我们当前的预测工作流程:</p><ol class=""><li id="792c" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated"><strong class="kw iu">利用外生变量和衍生指标进行预测。</strong>我们可以明确说明股票过去收盘价以外的信息(外生变量)。例如股票的交易量、其他股票的价格和交易量、利率、通货膨胀、最近发布的广告的成功以及其他衍生指标，如波动性、RSI、短期&amp;长期移动平均线等。</li><li id="27db" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated"><strong class="kw iu">识别可能引发价格波动的事件。</strong>例如与公司相关的公告(通常在 twitter 上披露),如绩效、合并&amp;收购、新法律等。我们可以专门对这些进行建模，以估计它们对价格的影响。</li><li id="64d0" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated"><strong class="kw iu">试验其他强大的模型。</strong>我经常使用 Prophet 作为基准，但最终还是使用了其他性能超过基准模型的模型。例如梯度推进机器(如 LightGBM)、深度学习模型(如 LSTM RNNs)和其他前沿时间序列模型(如 TBATS、SARIMAX)。</li><li id="c0cf" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated"><strong class="kw iu">提高预测模型不确定性的准确性。除了点预测的性能，更重要的是预测不确定性的准确性，这可以指导我们知道何时更信任模型的预测。这是最近研究的一个焦点，一些<a class="ae lq" href="https://eng.uber.com/neural-networks-uncertainty-estimation/" rel="noopener ugc nofollow" target="_blank">已经成功地创建了模型，这些模型准确地预测了 95%的置信区间，实际上覆盖了 95%的目标。</a></strong></li><li id="af84" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">通过模拟引擎可视化估计的影响。通过创建能够解释外部因素和事件的模型，我们可以将这些模型转化为模拟引擎，以可视化不同情景下价格的变化(即情景分析)。例如，如果明年经济衰退，利率上升 2%,价格会如何？</li></ol><p id="8841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上只是改进我们当前预测工作流程的许多方法中的一部分，我计划在未来的博客文章中详细讨论这些方法。如果你对从哪一个开始有任何建议，请随时评论或发电子邮件给我，地址是 lorenzo.ampil@gmail.com<em class="lr"/>。敬请期待！</p><p id="8898" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lr">来自《走向数据科学》编辑的提示:</em> </strong> <em class="lr">虽然我们允许独立作者根据我们的</em> <a class="ae lq" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="lr">规则和指导方针</em> </a> <em class="lr">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae lq" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="lr">读者术语</em> </a> <em class="lr">。</em></p></div></div>    
</body>
</html>