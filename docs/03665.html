<html>
<head>
<title>How to Interpolate Time Series Data in Python Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Python Pandas 中内插时间序列数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-interpolate-time-series-data-in-apache-spark-and-python-pandas-part-1-pandas-cff54d76a2ea?source=collection_archive---------2-----------------------#2019-06-11">https://towardsdatascience.com/how-to-interpolate-time-series-data-in-apache-spark-and-python-pandas-part-1-pandas-cff54d76a2ea?source=collection_archive---------2-----------------------#2019-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/203fcf52de28fca9714c93328b5997c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dq96yEYCKo-nkNUCmM8mWA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Time Series Interpolation for Pandas: Eating Bamboo Now — Eating Bamboo Later (Photo by <a class="ae kf" href="https://unsplash.com/@jmeyer1220?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jonathan Meyer</a> on <a class="ae kf" href="https://unsplash.com/search/photos/panda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><p id="b649" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注:熊猫 0.20.1 版(2017 年 5 月)更改了分组 API。这篇文章反映了更新版本的功能。</p><p id="f842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何处理数据的人都知道现实世界中的数据通常是不完整的，清理数据会占用你大量的时间(有人知道 80/20 法则吗？).最近从 Pandas 搬到 Pyspark，我已经习惯了 Pandas 提供的便利，而 Pyspark 由于它的分布式特性有时会缺乏这些便利。我特别欣赏的一个特性是 Pandas 提供的内插(或填充)时间序列数据的直接方式。这篇文章旨在使用在一组房屋中收集的传感器读取数据的示例，以简单易懂的方式展示这种能力。这篇文章的完整笔记本可以在我的 GitHub 中找到<a class="ae kf" href="https://github.com/walkenho/tales-of-1001-data/blob/master/timeseries-interpolation-in-spark/interpolating_time_series_p1_pandas.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b1e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">准备数据和初步可视化</h1><p id="a503" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们用一些测试数据生成一个熊猫数据帧 df0。我们创建了一个包含两个房屋的模拟数据集，并使用 sin 和 cos 函数为一组日期生成一些传感器读取数据。为了生成缺失值，我们随机丢弃一半的条目。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c1e5" class="mq lf it mm b gy mr ms l mt mu">data = {'datetime' : pd.date_range(start='1/15/2018',<br/>                                  end='02/14/2018', <br/>                                  freq='D')\<br/>                     .append(pd.date_range(start='1/15/2018',<br/>                                           end='02/14/2018',<br/>                                           freq='D')),<br/>        'house' : ['house1' for i in range(31)] <br/>                  + ['house2' for i in range(31)],<br/>        'readvalue' : [0.5 + 0.5*np.sin(2*np.pi/30*i) <br/>                       for i in range(31)]\<br/>                     + [0.5 + 0.5*np.cos(2*np.pi/30*i) <br/>                       for i in range(31)]}</span><span id="d407" class="mq lf it mm b gy mv ms l mt mu">df0 = pd.DataFrame(data, columns = ['readdatetime', <br/>                                    'house', <br/>                                    'readvalue'])</span><span id="42a1" class="mq lf it mm b gy mv ms l mt mu"># Randomly drop half the reads<br/>random.seed(42)<br/>df0 = df0.drop(random.sample(range(df0.shape[0]),<br/>                             k=int(df0.shape[0]/2)))</span></pre><p id="f5ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成的表格如下所示:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Raw read data with missing values</figcaption></figure><p id="2286" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图显示了生成的数据:一个 sin 和一个 cos 函数，两者都有大量缺失的数据点。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/4f57a66cd2a5cbb6f6fc90e651d29ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w66MLr6OLdOqkNV2.png"/></div></div></figure><p id="351c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在来看三种不同的内插缺失读取值的方法:前向填充、后向填充和内插。请记住，为每项任务选择合适的插值方法至关重要。特别是对于预测任务，我们需要考虑在进行预测时是否有插值数据。例如，如果你需要插值数据来预测天气，那么你不能用明天的天气来插值今天的天气，因为明天的天气还是未知的(合乎逻辑，不是吗？).</p><h1 id="685d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">插入文字</h1><p id="2d93" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了对数据进行插值，我们可以使用<em class="mz"> groupby()- </em>函数，然后是<em class="mz"> resample() </em>。但是，首先我们需要将读取的日期转换为 datetime 格式，并将它们设置为数据帧的索引:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4d8c" class="mq lf it mm b gy mr ms l mt mu">df = df0.copy()<br/>df['datetime'] = pd.to_datetime(df['datetime'])<br/>df.index = df['datetime']<br/>del df['datetime']</span></pre><p id="9549" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们想分别对每栋房子进行插值，所以在使用带有选项“D”的<em class="mz"> resample() </em>函数将数据重新采样到每日频率之前，我们需要按“房子”对数据进行分组。</p><p id="eabb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是使用均值填充、前向填充或后向填充来确定新生成的网格应该如何填充。</p><h2 id="ef26" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">平均值()</h2><p id="a5a4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为我们使用<em class="mz"> mean() </em>方法进行严格的上采样，所以所有缺失的读取值都用 nan 填充:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e679" class="mq lf it mm b gy mr ms l mt mu">df.groupby('house').resample('D').mean().head(4)</span></pre><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Filling using mean()</figcaption></figure><h2 id="e64a" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">pad() —向前填充</h2><p id="9066" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用<em class="mz"> pad() </em>代替<em class="mz"> mean() </em>向前填充 NaNs。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7912" class="mq lf it mm b gy mr ms l mt mu">df_pad = df.groupby('house')\<br/>            .resample('D')\<br/>            .pad()\<br/>            .drop('house', axis=1)<br/>df_pad.head(4)</span></pre><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Filling using pad()</figcaption></figure><h2 id="15d3" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">bfill() —反向填充</h2><p id="b502" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用<em class="mz"> bfill() </em>代替<em class="mz"> mean() </em>后向填充 NaNs:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f8c3" class="mq lf it mm b gy mr ms l mt mu">df_bfill = df.groupby('house')\<br/>            .resample('D')\<br/>            .bfill()\<br/>            .drop('house', axis=1)</span><span id="04db" class="mq lf it mm b gy mv ms l mt mu">df_bfill.head(4)</span></pre><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Filling using bfill()</figcaption></figure><h2 id="75a5" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">插值()-插值</h2><p id="4ebb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想要对缺失值进行插值，我们需要分两步来完成。首先，我们通过使用<em class="mz"> mean()生成底层数据网格。</em>这会生成以 NaNs 为值的网格。然后，我们通过调用 read value 列上的<em class="mz"> interpolate() </em>方法，用插值填充 nan:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4274" class="mq lf it mm b gy mr ms l mt mu">df_interpol = df.groupby('house')\<br/>                .resample('D')\<br/>                .mean()<br/>df_interpol['readvalue'] = df_interpol['readvalue'].interpolate()<br/>df_interpol.head(4)</span></pre><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Filling using interpolate()</figcaption></figure><h1 id="b604" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可视化结果</h1><p id="5768" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最后，我们可以可视化三种不同的填充方法，以更好地了解它们的结果。不透明点显示原始数据，透明点显示插值。</p><p id="7fdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，在上面的图中，间隙是如何用先前已知的值填充的，在中间的图中，间隙是如何用即将到来的现有值填充的，在下面的图中，差异是线性插值的。由于插值过程的线性，请注意插值线中的边缘。根据任务的不同，我们可以使用高阶方法来避免这些问题，但是对于这篇文章来说这样做太过分了。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/ef8914d22bc26f019fde2cbeed04cea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lVLRpUA9oeIB7B2B.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Original data (dark) and interpolated data (light), interpolated using (top) forward filling, (middle) backward filling and (bottom) interpolation.</figcaption></figure><h1 id="84b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="8112" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这篇文章中，我们看到了如何使用 Python 的 Pandas 模块，通过回填、前向填充或插值方法来插值时间序列数据。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="cf8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mz">原载于 2019 年 1 月 14 日</em><a class="ae kf" href="https://walkenho.github.io/interpolating-time-series-p1-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://walken ho . github . io</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>