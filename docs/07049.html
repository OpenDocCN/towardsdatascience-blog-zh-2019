<html>
<head>
<title>Python Tips and Tricks, You Haven’t Already Seen, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您还没有看过的 Python 技巧和诀窍，第 2 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tips-and-tricks-you-havent-already-seen-part-2-952828cfd0bf?source=collection_archive---------16-----------------------#2019-10-05">https://towardsdatascience.com/python-tips-and-tricks-you-havent-already-seen-part-2-952828cfd0bf?source=collection_archive---------16-----------------------#2019-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5c48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">注意:这最初发布在</em><a class="ae km" href="https://martinheinz.dev/blog/4" rel="noopener ugc nofollow" target="_blank"><em class="kl">martinheinz . dev</em></a></p><p id="257c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前，我发表了一篇文章(<a class="ae km" href="https://medium.com/@martin.heinz/python-tips-and-trick-you-havent-already-seen-937f14a08a08" rel="noopener">此处为</a>)关于一些不太为人所知的 Python 特性，很多人似乎都喜欢它，所以这里有另一轮 Python 特性，希望你还没有看到。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/cb8e7f1fdfceb4fd60d10324cdb4773d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qplDceAY84tdlnllh7wlEg.jpeg"/></div></div></figure><h1 id="6f37" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用<code class="fe lx ly lz ma b">slice</code>功能命名切片</h1><p id="d9ec" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">使用大量硬编码的索引值很快会导致维护和可读性方面的混乱。一种选择是对所有索引值使用常量，但我们可以做得更好:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0cf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们可以看到我们可以避免神秘的索引，首先使用<code class="fe lx ly lz ma b">slice</code>函数命名它们，然后在切掉字符串的一部分时使用它们。您还可以使用切片对象的属性<code class="fe lx ly lz ma b">.start</code>、<code class="fe lx ly lz ma b">.stop</code>和<code class="fe lx ly lz ma b">.step</code>来获得更多关于切片对象的信息。</p><p id="942e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多命令行工具或脚本需要用户名和密码才能操作。因此，如果您碰巧编写了这样的程序，您可能会发现<code class="fe lx ly lz ma b">getpass</code>模块很有用:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个非常简单的包允许您提示用户输入密码，并通过提取当前用户的登录名来获取他们的用户名。请注意，不是每个系统都支持隐藏密码。Python 会试图警告你这一点，所以只需在命令行中阅读警告。</p><p id="65f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，对于 Python 标准库的一个更难理解的特性。如果您发现自己需要使用类似于<a class="ae km" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank">Levenshtein distance</a>Python 和<code class="fe lx ly lz ma b">difflib</code>的工具来查找类似于某个输入字符串的单词，您会得到支持。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="82bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">difflib.get_close_matches</code>找到最佳的<em class="kl">【足够好】</em>匹配。这里，第一个参数与第二个参数相匹配。我们还可以提供可选参数<code class="fe lx ly lz ma b">n</code>，它指定要返回的最大匹配数。可以设置另一个可用的关键字参数<code class="fe lx ly lz ma b">cutoff</code>(默认为 0.6)来改变匹配字符串得分的阈值。</p><p id="162e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你必须用 Python 做一些网络工作，你可能会发现<code class="fe lx ly lz ma b">ipaddress</code>模块非常有用。一个用例是从 CIDR 生成 ip 地址列表(<em class="kl">无类域间路由</em>):</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ed2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个很好的特性是 ip 地址的网络成员检查:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="11ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有很多更有趣的特性我就不赘述了，因为你可以在这里找到那些<a class="ae km" href="https://docs.python.org/3/howto/ipaddress.html" rel="noopener ugc nofollow" target="_blank"/>。但是请注意，在<code class="fe lx ly lz ma b">ipaddress</code>模块和其他网络相关模块之间只有有限的互操作性。例如，您不能使用<code class="fe lx ly lz ma b">IPv4Network</code>的实例作为地址字符串——它们需要首先使用<code class="fe lx ly lz ma b">str</code>进行转换。</p><p id="38e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是一个拒绝使用 IDE 并且用 Vim 或 Emacs 编码的人，那么你可能会遇到这样一种情况，在 IDE 中使用调试器是很有用的。你知道吗？你有一个——用<code class="fe lx ly lz ma b">python3.8 -i</code>运行你的程序——<code class="fe lx ly lz ma b">-i</code>会在你的程序终止时启动交互式 shell，从那里你可以探索所有变量并调用函数。很好，但是<em class="kl">实际的</em>调试器(<code class="fe lx ly lz ma b">pdb</code>)怎么样？</p><p id="b5a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用下面的程序(<code class="fe lx ly lz ma b">script.py</code>):</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="b001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<code class="fe lx ly lz ma b">python3.8 -i script.py</code>运行脚本</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到了崩溃的位置，现在让我们设置一个断点:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c72a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在再运行一次:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ed89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数情况下，打印语句和回溯对于调试来说已经足够了，但有时，您需要开始探索一下，以了解程序内部发生了什么。在这些情况下，您可以设置断点，当您运行程序时，执行将在断点处停止，您可以检查您的程序，例如，列出函数参数、计算表达式、列出变量或如上所示单步执行。<code class="fe lx ly lz ma b">pdb</code>是全功能的 python shell，所以你可以执行任何文学上的东西，但是你需要一些调试器命令，你可以在这里找到<a class="ae km" href="https://docs.python.org/3/library/pdb.html#debugger-commands" rel="noopener ugc nofollow" target="_blank"/></p><p id="98f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个在编程语言中很常见，但在 Python 中不常见的特性是函数重载。即使不能重载普通函数，也可以使用类方法重载构造函数:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会倾向于将备选构造函数的所有逻辑放到<code class="fe lx ly lz ma b">__init__</code>中，并使用<code class="fe lx ly lz ma b">*args</code>、<code class="fe lx ly lz ma b">**kwargs</code>和一堆<code class="fe lx ly lz ma b">if</code>语句来解决它，而不是使用类方法。这可能行得通，但可能会变得难以阅读和维护。因此，我建议在<code class="fe lx ly lz ma b">__init__</code>中加入很少的逻辑，并在不同的方法/构造函数中执行所有的操作。通过这种方式，对于类的维护者和用户来说，你将得到干净清晰的代码。</p><p id="b32f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您是否曾经编写过执行昂贵的 I/O 操作的函数，或者可以从缓存(内存化)结果中获益的相当慢的递归函数？如果你这样做了，那么使用来自<code class="fe lx ly lz ma b">functools</code>的<code class="fe lx ly lz ma b">lru_cache</code>有一个简单的解决方案:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们正在缓存<em class="kl"> GET </em>请求(最多 32 个缓存结果)。您还可以看到，我们可以使用<code class="fe lx ly lz ma b">cache_info</code>方法检查我们函数的缓存信息。装饰器还提供了一个使缓存结果无效的<code class="fe lx ly lz ma b">clear_cache</code>方法。我还想指出，这不应该用于有副作用的函数或每次调用都会创建可变对象的函数。</p><p id="a6e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在列表中找到最常见的项目是一项非常普通的任务，你可以使用<code class="fe lx ly lz ma b">for</code>循环和字典(map)来完成，但这将是浪费时间，因为在<code class="fe lx ly lz ma b">collections</code>模块中有<code class="fe lx ly lz ma b">Counter</code>类:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3064" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在幕后，<code class="fe lx ly lz ma b">Counter</code>只是一个将条目映射到出现次数的字典，因此您可以像使用普通的<code class="fe lx ly lz ma b">dict</code>一样使用它:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="f760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，您还可以使用<code class="fe lx ly lz ma b">update(more_words)</code>方法轻松地添加更多的元素到计数器中。<code class="fe lx ly lz ma b">Counter</code>的另一个很酷的特性是，你可以使用数学运算(加法和减法)来组合和减去<code class="fe lx ly lz ma b">Counter</code>的实例。</p><p id="3ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为，如果你正在使用 Python，这次我在这里分享的大多数技巧几乎每天都有用，所以我希望它们能派上用场。此外，如果你对这些 Python 技巧和诀窍有任何想法，或者如果你知道解决上述问题的任何更好的方法，请告诉我！🙂</p></div></div>    
</body>
</html>