<html>
<head>
<title>Catch me if you can: Outlier Detection in Streaming Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你能抓住我:流数据中的异常检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/catch-me-if-you-can-outlier-detection-taxi-trajectory-streams-1bb6df584db0?source=collection_archive---------24-----------------------#2019-10-15">https://towardsdatascience.com/catch-me-if-you-can-outlier-detection-taxi-trajectory-streams-1bb6df584db0?source=collection_archive---------24-----------------------#2019-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="101f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用流数据(轨迹流)进行优步需求预测</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a3c582c5b81434481774e1ce370ed970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VX8HYDhXByzX2PGk"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@zhipeng_ya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zhipeng Ya</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="078e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">离群点检测是一项有趣的数据挖掘任务，广泛用于检测数据中的异常。异常值是显示出与大多数点明显不同的属性的点。为此，离群点检测具有非常有趣的应用，例如信用卡欺诈检测(可疑交易)、交通管理(醉酒/鲁莽驾驶)或网络入侵(黑客攻击)等。由于这些应用的时间关键特性，需要可扩展的异常检测技术。</p><p id="accb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，我们的目标是检测出租车数据集(北京)中的异常值，使用一种仅使用时空特征来检测超大型数据集中的异常值的技术。我们将使用这些出租车上的地理坐标和 GPS 收集的时间戳。</p><h1 id="c53f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">数据集</strong></h1><p id="9d56" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于这个项目，我们将使用<a class="ae kv" href="https://www.microsoft.com/en-us/research/publication/t-drive-trajectory-data-sample/" rel="noopener ugc nofollow" target="_blank"> T-Drive </a>数据集。该数据集有 1500 万个点，覆盖北京总共 10，357 辆出租车的 900 万公里总距离。这是一个很好的样本数据集，因为它包含大量的点，模拟了我们上面讨论的真实场景。该数据集中的每一行都对应于出租车的地理坐标和时间戳。</p><h1 id="96fe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">算法</strong></h1><p id="76f5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将在这个问题上使用的算法是大规模轨迹流上的<a class="ae kv" href="https://dl.acm.org/citation.cfm?id=3013527" rel="noopener ugc nofollow" target="_blank">异常值检测。为了实现这个算法，我们需要一些技术术语的背景信息。</a></p><p id="f8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">轨迹</strong></p><p id="e61f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">移动物体 O 的轨迹被定义为在时间元 t <em class="mp"> 1 </em>，t <em class="mp"> 2 </em>产生的轨迹点序列..t <em class="mp"> j </em>表示为 Tri = {P <em class="mp"> 1i </em>，P <em class="mp"> 2i </em>，…..纪</p><p id="b70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">点邻居</strong></p><p id="c371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果两个轨迹点 P <em class="mp"> ij </em>，P <em class="mp"> ik </em>在同一时间点 T <em class="mp"> i </em>中，彼此的距离在<em class="mp"> d </em>之内，其中<em class="mp"> d </em>是距离阈值，那么这两个点被认为是彼此的点邻居。</p><p id="6a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">轨迹邻居</strong></p><p id="25b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在特定窗口 W <em class="mp"> c </em>中，当且仅当对于至少<em class="mp"> thr </em>时间元，轨迹在这些时间元的每一个中共享点邻居时，轨迹被称为邻居轨迹。</p><p id="99aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">轨迹异常值</strong></p><p id="e21d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果至少在<em class="mp"> thr </em>时间仓中，作为点邻居的点的数量少于<em class="mp"> k </em>个，则轨迹 T <em class="mp"> ri </em>被认为是窗口 W <em class="mp"> c </em>中的异常值，其中<em class="mp"> k </em>是邻居计数阈值。</p><p id="6852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定义试图抓住这样一个概念:如果一个轨迹是正常的，那么它应该在空间和时间上有相近的点。换句话说，这些轨迹需要表现得非常相似和一致，才能被归类为特定窗口中的内层。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c1dd5f15250debfcb67d1bc210713458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*jeK-ks_neBYu7noYYANtag.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Example Trajectories | Tr4 is an outlier</figcaption></figure><p id="cb66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释算法，让我们看一下上面的例子。我们将分析轨迹 Tr3 和 Tr4。虚线圆表示轨迹的相邻点。让我们取<em class="mp"> thr=2 </em>和<em class="mp"> K=3: </em></p><p id="7786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tr4 至少具有<em class="mp"> thr (2) </em>个仅与 Tr1 (t2，t4) &amp; Tr3 (t2，T4)相邻的点。因为它只有少于<em class="mp"> K </em>轨迹的<em class="mp"> thr </em>点邻居(在这种情况下只有 2 个轨迹)，所以它是异常值。</p><p id="5b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tr3 与 Tr1 (t1，T2，t3，t4)，Tr2 (t1，T2，t3) &amp; Tr4 (t2，T4)至少有<em class="mp"> thr (2) </em>个数的点邻居。由于它对于至少<em class="mp"> K=3 </em>轨迹(Tr1，Tr2，Tr4)具有<em class="mp"> thr </em>点邻居，所以它是<em class="mp">而不是</em>异常值。更多信息，你可以阅读<a class="ae kv" href="https://dl.acm.org/citation.cfm?id=3013527" rel="noopener ugc nofollow" target="_blank">论文</a>中的例子。</p><h1 id="e6dd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">实施</strong></h1><p id="d53b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">加载数据</strong></p><p id="9143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步包括加载数据集(*。txt)。因为数据集分为。txt 文件，我们需要读取 T-Drive 文件夹中的所有文件。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="f69a" class="mw lt iq ms b gy mx my l mz na">path = 'C:\\Users\\User\\Downloads\\T-drive Taxi Trajectories\\release\\taxi_log_2008_by_id\\*.txt'<br/>files = glob.glob(path)</span><span id="b790" class="mw lt iq ms b gy nb my l mz na">for file in files:</span><span id="062c" class="mw lt iq ms b gy nb my l mz na">        f = open(file,'r')</span><span id="1189" class="mw lt iq ms b gy nb my l mz na">            #2nd element contains date(yyyy-mm-dd)            <br/>            date = x[0].split(',') </span><span id="0e50" class="mw lt iq ms b gy nb my l mz na">            #1st element contains time(HH:MM::SS) <br/>            time1 = x[1].split(',')</span><span id="1d52" class="mw lt iq ms b gy nb my l mz na">            lat = time1[1]  #Latitude<br/>            lon = time1[2]  #Longitude<br/>            <br/>            day = date[1].split('-')[2]      #Day<br/>            hour = time1[0].split(':')[0]    #HOUR<br/>            min_ = time1[0].split(':')[1]    #MINS<br/>            secs = time1[0].split(':')[2]    #SECS</span></pre><p id="5a86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要提取时间戳(月、日、小时、分钟)、纬度和经度的值。<strong class="ky ir"> Split() </strong>是拆分每行中各个值的最快方法</p><p id="f132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数据准备</strong></p><p id="24a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与任何数据任务一样，下一步是清理数据。快速浏览数据集可以发现数据集中出租车的采样速率不一致。一些出租车每分钟记录一次位置，而另一些则跳过几分钟。为了解决这个问题，我们将使用线性插值来填充缺失的值。下面的示例显示了时间戳(T <em class="mp"> 2 </em>)的一个缺失值。缺失值的计算方法是，取 T1 和 T3 之间的平均差值，并将其加到 T1 上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/064520fe950dd3a5098fce94dece708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*1Ft37BwW62oGA4BjnIV2Wg.png"/></div></figure><p id="4f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">距离功能</strong></p><p id="c4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所知，每个样本的位置标记都是地理坐标。但是，我们需要也需要计算两个坐标之间的距离来检查这些点是否是邻居(<strong class="ky ir"> <em class="mp"> d </em> </strong>阈值)。为了解决这个问题，我们使用<a class="ae kv" href="https://www.movable-type.co.uk/scripts/latlong.html" rel="noopener ugc nofollow" target="_blank">哈弗辛近似</a>。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="659a" class="mw lt iq ms b gy mx my l mz na">def distance(lat1, lon1, lat2, lon2):</span><span id="80a7" class="mw lt iq ms b gy nb my l mz na">R = 6373.0   #Radius of earth</span><span id="b6d0" class="mw lt iq ms b gy nb my l mz na">    lat1 = radians(lat1)<br/>    lon1 = radians(lon1)<br/>    lat2 = radians(lat2)<br/>    lon2 = radians(lon2)</span><span id="86b9" class="mw lt iq ms b gy nb my l mz na">    dlon = lon2 - lon1<br/>    dlat = lat2 - lat1</span><span id="0eb7" class="mw lt iq ms b gy nb my l mz na">    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2<br/>    c = 2 * atan2(sqrt(a), sqrt(1 - a))</span><span id="842e" class="mw lt iq ms b gy nb my l mz na">    distance = R * c<br/>  <br/>    return distance*1000</span></pre><p id="54a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">异常值检测</strong></p><p id="3fe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一下算法，很明显算法中最慢的部分是搜索查询。为了实现优化的性能，我们将使用 KD-tree 来处理多维点(在我们的例子中是 lat/long)。我们可以使用 Scipy 库来构建带有地理坐标的 kd 树。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1c4c" class="mw lt iq ms b gy mx my l mz na">from scipy import spatial<br/>tree = spatial.KDTree(geocoordinates)</span><span id="27f4" class="mw lt iq ms b gy nb my l mz na">def tree_once(tree,traj_arr):</span><span id="05ab" class="mw lt iq ms b gy nb my l mz na">    final = []</span><span id="f6f4" class="mw lt iq ms b gy nb my l mz na">    for i in range(0,len(traj_arr)):<br/>    neighbors = tree.query_ball_point([traj_arr[i][0],traj_arr[i]    [1]], 0.0001)<br/>    final.append(neighbors)</span><span id="c66d" class="mw lt iq ms b gy nb my l mz na">    return final</span></pre><p id="af9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">树构建完成后，我们将使用<strong class="ky ir"><em class="mp">query _ ball _ point()</em></strong>函数来查找我们的<strong class="ky ir"> <em class="mp"> d </em> </strong>阈值内的邻居。</p><p id="c394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出</strong></p><p id="31b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">T-Drive 数据集没有为我们提供基本的真实值。将结果可视化的一种方法是在谷歌地图上绘制出来。我使用了谷歌地图 API Web 服务的 Python 客户端库来绘制轨迹，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/806bfd1fdf183e113b2aacdc023ce81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Q77wzXdfas55SwnMHPlsg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Trajectory Outliers in a single window. The red lines represent trajectories that were identified as outliers where as blue lines represent normal trajectories. Most of the isolated trajectories, as shown, are correctly identified as outlying.</figcaption></figure><p id="a99b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从图中可以看出，大多数拥塞轨迹都被正确识别为内点。时空不接近的轨迹被识别为异常值，存在一些误差，如地图所示。</p><h1 id="43ea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论&amp;未来工作</strong></h1><p id="0792" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该算法还可以用于其他场景，如信用卡欺诈检测或股票监控。例如，就像地理坐标一样，我们可以使用股价/成交量作为特征来确定一支股票的表现是好是坏。</p><p id="b627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他工作包括使用分割和分区来改善离群点检测结果。在另一篇文章中，我将介绍如何使用多个内核在多个 CPU 之间分配工作负载，以实现更高的性能。</p><p id="0f16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的 Git:h<a class="ae kv" href="https://github.com/UsmanGohar/Trajectory-Outlier-Detection" rel="noopener ugc nofollow" target="_blank">ttps://github . com/UsmanGohar/Trajectory-Outlier-Detection</a>中找到完整的代码</p></div></div>    
</body>
</html>