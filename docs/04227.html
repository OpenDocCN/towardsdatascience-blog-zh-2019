<html>
<head>
<title>Database Normalization Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了数据库规范化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/database-normalization-explained-53e60a494495?source=collection_archive---------4-----------------------#2019-07-02">https://towardsdatascience.com/database-normalization-explained-53e60a494495?source=collection_archive---------4-----------------------#2019-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过设计和修改示例数据库模式来了解数据库规范化！</h2></div><p id="7382" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">规范化是一种在数据库中组织数据的技术。对数据库进行规范化以最小化冗余(重复数据)并确保每个表中只存储相关数据是很重要的。它还可以防止由数据库修改(如插入、删除和更新)引起的任何问题。</p><p id="a32f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组织的阶段被称为<strong class="kk iu">范式</strong>。在本教程中，我们将为一家建筑公司重新设计一个数据库，并确保它满足三种范式:</p><h2 id="7614" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">第一范式</strong> ( <strong class="ak"> 1NF </strong>):</h2><ul class=""><li id="ed86" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld me mf mg mh bi translated">数据存储在表中，表中的行由主键唯一标识</li><li id="5f3b" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">每个表中的数据以最简化的形式存储在各个列中</li><li id="93de" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">没有重复的组</li></ul><h2 id="c2c2" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">第二范式(<strong class="ak"> 2NF </strong>):</h2><ul class=""><li id="5f07" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld me mf mg mh bi translated">来自 1NF 的一切</li><li id="bdab" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">每个表中只存储与表的主键相关的数据</li></ul><h2 id="0df6" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">第三范式(3NF):</h2><ul class=""><li id="e46f" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld me mf mg mh bi translated">来自 2NF 的一切</li><li id="f784" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">每个表中的列之间没有表内依赖关系</li></ul><p id="c384" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，实际上有六个级别的规范化；然而，第三范式被认为是大多数应用程序所必需的最高层次，所以我们将只讨论前三种形式。</p><p id="b6e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们开始吧！</p><blockquote class="mn mo mp"><p id="d44d" class="ki kj mq kk b kl km ju kn ko kp jx kq mr ks kt ku ms kw kx ky mt la lb lc ld im bi translated">本教程改编自 Next Tech 的<strong class="kk iu">数据库基础</strong>课程，该课程带有一个浏览器内 MySQL 数据库以及需要完成的交互式任务和项目。这里可以免费上手<a class="ae mu" href="https://c.next.tech/2LwLAXB" rel="noopener ugc nofollow" target="_blank">！</a></p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="d1b3" class="nc lf it bd lg nd ne nf lj ng nh ni lm jz nj ka lp kc nk kd ls kf nl kg lv nm bi translated">我们的数据库:科迪的建设</h1><figure class="no np nq nr gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nn"><img src="../Images/88ec21ec22d668040053d0dc7b7a09a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPv4DOE-6Vaa4IyNVpF3JA.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk"><em class="od">Codey’s Construction’s database schema with a new table that causes the database to violate the rules of normalization.</em></figcaption></figure><p id="eaba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在本教程中使用的数据库是为 Codey 的建筑公司(Codey 是一个有用的编码机器人，在前面提到的课程中与您一起工作)。从上面的模式可以看出，数据库包含了表<code class="fe oe of og oh b">projects</code>、<code class="fe oe of og oh b">job_orders</code>、<code class="fe oe of og oh b">employees</code>和<code class="fe oe of og oh b">project_employees</code>。最近，添加了<code class="fe oe of og oh b">customers</code>表来存储客户数据。</p><p id="cef7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，这个表的设计没有满足三种形式的规范化…让我们来解决这个问题！</p><h1 id="03a6" class="nc lf it bd lg nd oi nf lj ng oj ni lm jz ok ka lp kc ol kd ls kf om kg lv nm bi translated">第一范式</h1><p id="d0c6" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr on kt ku kv oo kx ky kz op lb lc ld im bi translated">第一范式与表和列中数据的重复和分组有关。</p><p id="fbd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Codey 的构造的表<code class="fe oe of og oh b">customers</code>违反了 1NF 的全部三条规则。</p><ol class=""><li id="2836" class="lx ly it kk b kl km ko kp kr oq kv or kz os ld ot mf mg mh bi translated">没有主键！数据库用户将被迫按公司名称查找公司，但不能保证公司名称是唯一的(因为唯一的公司名称是在各州注册的)。</li><li id="13fd" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ot mf mg mh bi translated">这些数据不是最简化的形式。列<code class="fe oe of og oh b">contact_person_and_role</code>可以进一步分为两列，如<code class="fe oe of og oh b">contact_person</code>和<code class="fe oe of og oh b">contact_role</code>。</li><li id="55d5" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ot mf mg mh bi translated">有两组重复的列— ( <code class="fe oe of og oh b">project1_id</code>、<code class="fe oe of og oh b">project1_feedback</code>)和(<code class="fe oe of og oh b">project2_id</code>、<code class="fe oe of og oh b">project2_feedback</code>)。</li></ol><p id="c6a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下 SQL 语句用于创建<code class="fe oe of og oh b">customers</code>表:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><figure class="no np nq nr gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ow"><img src="../Images/6bd03b649db4ec11590d9f71a6216075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgiLgPzzxck4kFqhClz7bQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Example data for `<code class="fe oe of og oh b">customers</code>` table.</figcaption></figure><p id="c19f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过修改一些列，我们可以帮助重新设计这个表，使它满足 1NF。</p><p id="a39a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要添加一个名为<code class="fe oe of og oh b">id</code>的主键列，数据类型为<code class="fe oe of og oh b">INT(6)</code>:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8ca8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这个语句，我们添加了一个自动递增的主键作为表中的第一列。</p><p id="a388" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了满足第二个条件，我们需要拆分<code class="fe oe of og oh b">contact_person_and_role</code>列:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="4c01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们简单地将其重命名为<code class="fe oe of og oh b">contact_person</code>，并在它后面紧接着增加了一列<code class="fe oe of og oh b">contact_person_role</code>。</p><p id="c52e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了满足第三个条件，我们需要将包含项目 id 和项目反馈的列移动到一个名为<code class="fe oe of og oh b">project_feedbacks</code>的新表中。首先，让我们从<code class="fe oe of og oh b">customers</code>表中删除这些列:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="db22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后创建<code class="fe oe of og oh b">project_feedbacks</code>表:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="06e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是数据库模式现在的样子:</p><figure class="no np nq nr gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ox"><img src="../Images/9d6adb4f6c8dffefc247de80d852738b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwDESbncE3kV-T2NznKxHA.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Modified schema that now satisfies 1NF.</figcaption></figure><p id="bb94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，在<code class="fe oe of og oh b">project_feedbacks</code>表或<code class="fe oe of og oh b">customers</code>表中不再有重复组。我们仍然知道哪个客户说了什么，因为<code class="fe oe of og oh b">project_feedbacks.customer_id</code>引用了<code class="fe oe of og oh b">customers</code>表。</p><p id="951a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们的<code class="fe oe of og oh b">customers</code>表满足 1NF！让我们继续第二范式。</p><h1 id="0dc9" class="nc lf it bd lg nd oi nf lj ng oj ni lm jz ok ka lp kc ol kd ls kf om kg lv nm bi translated">第二范式</h1><p id="087f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr on kt ku kv oo kx ky kz op lb lc ld im bi translated">要实现第二范式，数据库必须首先满足 1NF 的所有条件。此后，满足 2NF 要求每个表中的所有数据都直接与表的主键标识的记录相关。</p><p id="9aa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们违反了 2NF，因为<code class="fe oe of og oh b">contact_person</code>、<code class="fe oe of og oh b">contact_person_role</code>和<code class="fe oe of og oh b">phone_number</code>列跟踪的数据与联系人有关，而不是客户。如果客户的联系人发生变化，我们将不得不编辑所有这些列，这样做的风险是，我们将更改其中一列中的值，但忘记更改另一列。</p><p id="40e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了帮助 Codey 的构造修复这个表以满足 2NF，应该将这些列移动到包含联系人数据的表中。首先，让我们删除“客户”中与我们的主键无关的列:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8400" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们保留了<code class="fe oe of og oh b">contact_person_id</code>，因此我们仍然知道应该联系谁。现在，让我们创建新表<code class="fe oe of og oh b">contact_persons</code>,这样我们就有地方存储每个联系人的数据了。</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="e591" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Codey's Construction 的数据库模式现在如下所示:</p><figure class="no np nq nr gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oy"><img src="../Images/f4ff978102090e73e5c153987451ea77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjlKqCICWWRCC1UmspW0yw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Modified schema that now satisfies 2NF.</figcaption></figure><p id="0e05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果客户的联系人发生变化，建筑公司只需在<code class="fe oe of og oh b">contact_persons</code>表中插入一条记录，并更改<code class="fe oe of og oh b">customers</code>表中的<code class="fe oe of og oh b">contact_person_id</code>。</p><h1 id="3768" class="nc lf it bd lg nd oi nf lj ng oj ni lm jz ok ka lp kc ol kd ls kf om kg lv nm bi translated">第三范式</h1><p id="6195" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr on kt ku kv oo kx ky kz op lb lc ld im bi translated">对于处于第三范式的数据库，它必须首先满足 2NF(因此也是 1NF)的所有标准。</p><p id="bae2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，每一列必须<strong class="kk iu">非传递依赖</strong>于表的主键。这意味着表中的所有列都应该依赖于主键，而不是其他列。如果<code class="fe oe of og oh b">column_a</code>依赖于主键，也依赖于<code class="fe oe of og oh b">column_b</code>，那么<code class="fe oe of og oh b">column_a</code>过渡依赖于主键，所以表不满足 3NF。</p><p id="91b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你读那个会不会头疼？放心吧！下面会有更多解释。</p><p id="d443" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们满足 1NF 和 2NF 后的<code class="fe oe of og oh b">customers</code>表:</p><figure class="no np nq nr gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oz"><img src="../Images/7f684fd4a6b42ea0f946fa42e731edeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkpTWCxRKXrfxoJz9HbcBw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Example data for modified `customers` table.</figcaption></figure><p id="885b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该表当前有依赖于传递的列。过渡依赖关系在<code class="fe oe of og oh b">city</code>和<code class="fe oe of og oh b">zip</code>之间。客户所在的城市依赖于客户，所以这满足了 2NF 然而，城市也取决于邮政编码。如果客户搬迁，我们可能会更新一列，而不更新另一列。因为存在这种关系，所以数据库不在 3NF 中。</p><p id="d09a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了修复我们的数据库以满足 3NF，我们需要从<code class="fe oe of og oh b">customers</code>中删除<code class="fe oe of og oh b">city</code>列，并创建一个新表<code class="fe oe of og oh b">zips</code>来存储该数据:</p><figure class="no np nq nr gt ns"><div class="bz fp l di"><div class="ou ov l"/></div></figure><figure class="no np nq nr gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi pa"><img src="../Images/3c80395ad366a66060f0cdc14bda8f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fah4_3AsV-TZFNJY_q0a3Q.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Modified schema that now satisfies 3NF.</figcaption></figure><p id="3640" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！发现违反 3NF 的问题可能很困难，但是确保数据库能够抵御仅部分更新数据所导致的错误是值得的。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="4ceb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢这篇关于数据库规范化的教程！Codey's Construction 的数据库现在满足三种形式的规范化。</p><p id="5b41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mq">如果你想继续学习数据库，Next Tech 的</em> <strong class="kk iu"> <em class="mq">数据库基础</em> </strong> <em class="mq">课程涵盖了你入门数据库和 SQL 所需的所有知识。通过帮助一个名为 Codey 的交互式编码机器人，您将学习如何创建和设计数据库，修改数据，以及编写 SQL 查询来回答业务问题。这里</em>  <em class="mq">可以免费上手</em> <a class="ae mu" href="https://c.next.tech/2LwLAXB" rel="noopener ugc nofollow" target="_blank"> <em class="mq">！</em></a></p></div></div>    
</body>
</html>