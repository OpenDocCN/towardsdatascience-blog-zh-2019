<html>
<head>
<title>The Little Known OGrid Function in Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy 中鲜为人知的 OGrid 函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-little-known-ogrid-function-in-numpy-19ead3bdae40?source=collection_archive---------2-----------------------#2019-12-20">https://towardsdatascience.com/the-little-known-ogrid-function-in-numpy-19ead3bdae40?source=collection_archive---------2-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">…以及如何使用它轻松转换图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6d1009eca969bc62506ff47f9d1c5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PagNguEDHxx2d6qxj6lng.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@mojoblogs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Zara Walker</a> on <a class="ae ky" href="https://unsplash.com/s/photos/city-grid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的这个季度，我帮助我的学生学习 Python 中强大的数值处理库，称为<strong class="lb iu"> Numpy </strong>。在课程的大部分时间里，我们都在使用 Numpy 对图像进行转换，因为图像毕竟只是数字的大数组。</p><p id="b01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很快，我们开始讨论如何变换图像，从基本的变换，如使图像黑白化，到更复杂的编辑，如在图像周围添加光环。正是在这次讨论中，我了解到 Numpy 中鲜为人知的<strong class="lb iu"> <em class="lv"> ogrid </em> </strong>函数，以及我们如何利用它来更轻松地转换图像。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="3795" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">什么是<em class="mw"> ogrid </em>？</h2><p id="dea5" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Ogrid 代表<strong class="lb iu">“开放网格”</strong>，基本上提供了一种基于行和列索引对图像的特定像素进行操作的方法。从基础开始，这里是如何在 Numpy 中调用 ogrid 函数，假设您已经将 Numpy 作为 np 导入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/897548924e77d5be3a35e08451382f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpTV8tpMOozhRwcWidMCXw.png"/></div></div></figure><p id="9dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里看到 ogrid 接受一个 x 坐标范围(0 到 10，不包括 10)和一个 y 坐标范围(0 到 5，不包括 5)。我们将 ogrid 的结果存储在两个变量中，<strong class="lb iu"> x 和 y </strong>。</p><p id="477c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显示 x 的内容会发现它是一个大小为 1 的列表，每个列表都是 0 到 9 之间的数字。显示 y 的内容，发现它是一个单列表的列表，只是 0 到 4 之间的数字。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="15a3" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">奥格里德如何帮助我们？</h2><p id="0925" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">假设你有一个 10 乘 5 的矩阵，就像 ogrid 的维度一样。我们在下面看到，使用 ogrid 索引矩阵会准确地返回矩阵本身。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/912e4f816b338dac23b346cf198990bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YotyvLjXd3z8vTrocDZU1g.png"/></div></div></figure><p id="a824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，我们可以使用 ogrid 返回的 x 和 y 来创建一个叫做<strong class="lb iu">“mask”</strong>的东西，根据它们的行和列索引，只隔离我们关心的矩阵元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/72f78ef088f447ea736dbc5e7efedf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*ZdscYE8n9jXIZ__dJtBNbA.png"/></div></figure><p id="8e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，注意我们只关心行索引(x)大于 5 或者列索引(y)小于 3 的矩阵元素。结果是一个掩码，它是一个真/假的<strong class="lb iu">数组，指示条件在哪里成立，在哪里不成立。</strong></p><p id="1349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">为什么这样有帮助？</em> </strong></p><p id="91c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为现在，我们可以使用这个掩码只作用于矩阵中掩码为真(或者等价地，假)的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/da3df816d78ae9294bd0877f7b7cadef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYg_3q8SCFIlokX1VnVUHw.png"/></div></div></figure><p id="435f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们将掩码为真的任何矩阵元素设置为 0，给出了结果矩阵。将同样的思路应用于整个图像，我们看到我们可以使用 ogrid 来创建遮罩，帮助我们对图像的特定像素进行操作。我们来看几个例子！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="8470" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">读取图像</h2><p id="559f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">让我们首先读入我们将要处理的图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果就是我们最爱的电动鼠标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ced2e33c6718efd398597639f6e9eb89.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*9wP89yaeq9NgaCNIRlOOFA.png"/></div></figure><p id="c1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们为这个图像生成 ogrid。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个重要的注意事项是 Numpy 中的轴的方向。与我们习惯看到的 x 轴和 y 轴相反，Numpy 图像中的轴如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8646f0d09ba1b1a56c42df966913cc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*GMUpEYbk6PX01RF7Fs2wNQ.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="ab9f" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">添加几何形状</h2><p id="154f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">ogrid 最酷、最有启发性的图像转换之一是向图像添加几何形状。由于大多数基本几何形状都有简单的数学公式，我们可以对 ogrid 返回的 x 和 y 执行函数来重新创建这些公式。例如，让我们看一些代码在我们的图像中间创建一个黑色的圆圈。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码的关键部分在第 9 行，在这里你会从代数课上学到一个圆的公式。这个特殊的圆位于我们图像的中心，半径为 100 像素。然后，我们使用这个圆形蒙版来涂黑蒙版中包含的所有像素，得到下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e5f139536f7ca2fcda0d213c84d7150a.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*lVy2b4ptCn4yJLcTw8EzYw.png"/></div></figure><p id="f9ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！如果我们想做一个正方形呢？嗯，可以说甚至更容易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是将正方形(或矩形)构造为 ogrid 返回的 x 和 y 上的四个过滤器的组合。然后，我们将包含在正方形蒙版中的图像中的任何像素设置为红色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c76d59cc58d7b0d055a7564ee6253f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*zq3wFzwV528Qldu7XGVUfA.png"/></div></figure><p id="02e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果我们想要一个青色的三角形在图像的右下角呢？嗯，我们可以算出数学公式，编码如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="aad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给出以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8bfda67c5e70cae543452b3f7fdd51ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*6yIHif2BDn_Rm1IpE70GDw.png"/></div></figure><p id="9284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">牛逼！</em> </strong>看来我们刚刚创造了一些不错的艺术品。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="bdf1" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">90 度旋转</h2><p id="1c18" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">接下来，让我们看看如何使用 ogrid 将图像旋转 90 度。其实这里就不多写代码了，重要的是理解概念。</p><p id="007c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们拍摄一个简单的 3x3 图像，并将其逆时针旋转 90 度，我们会得到以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/48c4f13cee6fa8ebb184f69eae69b2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-xc0rpMwNRgTm7284YMeg.png"/></div></div></figure><p id="e0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数学上来说，这就像把位于索引<strong class="lb iu"> (i，j) </strong>的像素映射到一个新的位置<strong class="lb iu"> (j，-i) </strong>。将这种转换应用到图像中的每个像素可能会令人望而生畏，似乎我们需要编写一些 for 循环，但是使用 ogrid，这项任务变成了一行程序。</p><p id="422b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果我们的图像被称为<strong class="lb iu"><em class="lv">【img】</em></strong>，那么将图像索引为<strong class="lb iu"><em class="lv">【img[y，-x】</em></strong>，使用 ogrid 返回的 x 和 y，我们得到的就是旋转后的图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/46abe6d1afbb65480cd03088ac0e6df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*QI2A7osYtFg1xMg8eQy8Dg.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="786c" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">创造一个光环</h2><p id="ac4a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">最后，让我们看一个稍微复杂一点的图像转换。也就是说，我们想要在图像周围创建一个<strong class="lb iu">光晕</strong>。</p><p id="8e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，我们想给我们图像的所有像素加上一些正值，一个像素离中心越远，我们加的值就越大。总的来说，这将有“洗去”靠近角落和边缘的像素的效果，而对靠近图像中心的像素几乎没有影响。下面是完整的注释代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有大量的代码，我鼓励您阅读并亲自尝试。简言之，我们:</p><ul class=""><li id="770d" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">获得每个像素到中心的平方距离</li><li id="6095" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">归一化这些平方距离</li><li id="df73" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将归一化的平方距离添加到图像中的每个像素。通过这种方式，远离中心的像素获得较大的附加值，而靠近中心的像素获得非常小的附加值</li><li id="db61" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">总的效果是我们形象上的一个“光环”</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9280ad1b7e1019a41172e9adee17f55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*40Xo7S6y1gDsDfeUizA4tQ.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="38d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！希望您已经了解了 Numpy 中非常有用的 ogrid 函数。</p><p id="d36f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运！~ </p></div></div>    
</body>
</html>