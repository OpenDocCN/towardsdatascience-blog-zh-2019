<html>
<head>
<title>How to teach your computer to recognize names and surnames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何教你的电脑识别姓名</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-an-unsupervised-problem-with-a-supervised-algorithm-df1e36096aba?source=collection_archive---------18-----------------------#2019-11-11">https://towardsdatascience.com/solving-an-unsupervised-problem-with-a-supervised-algorithm-df1e36096aba?source=collection_archive---------18-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b7f9dcbc7f2a0ded1ca479d639a6b7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8Wd6bfkUHH1xVtAVbVcIg.png"/></div></div></figure><p id="316d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章来自一个非常具体的现实生活中的问题，这个问题产生于一个现实生活的数据集，并且通过所描述的方法成功地解决了这个问题。希望这一应用可以作为其他类似案例研究的灵感。</p><h1 id="224c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">问题是:混淆了名和姓</h1><p id="2ad9" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">假设您有一个巨大的数据集(超过 2000 万行)，其中包含关于某些人的个人数据。数据集遭遇<strong class="kd iu">强重复问题</strong>，因为数据来自不同的来源。此外，唯一的 id(如社会保险号)很少出现，这使得重复数据删除变得困难。</p><p id="202d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，唯一可行的方法是<strong class="kd iu">概率记录链接</strong>:一组能够量化数据集的两行或多行被引用到同一个人的概率的方法。当然，<strong class="kd iu">名和姓是记录关联的基本特征</strong>。</p><p id="8555" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个设置中，您会注意到在<strong class="kd iu">行中发现一个人的姓和名被调换</strong>的情况并不少见(错误率约为 3%)，如下表的第三行所示:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/6705525a78b998ce68886094a4822911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qab9pZqvvxIdmwNmwQ3JsQ.png"/></div></div></figure><p id="aed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么会这样？因为收集数据的方式不同。数据输入一直是由人类进行的，人类会犯错误。</p><p id="1d89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，<strong class="kd iu">这种现象会严重影响概率记录链接</strong>。因此，我们的目标是检测这样的错误，并通过转换姓名来修改它们。</p><p id="4da2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑到<strong class="kd iu">标签不可用且无法获得(由于时间/资金限制)</strong>，我们如何解决该问题？</p><h1 id="e8df" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">让我们假设标签存在</h1><p id="388f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们假设每行都有一个标签。如果存在这样的标签，它可以采用下列值之一:</p><ul class=""><li id="bdfd" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">'正确':如果人的名字出现在“姓名”列，而人的姓氏出现在“姓氏”列</li><li id="7ba4" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">“错误”:如果这个人的名和姓被错误地交换了</li></ul><p id="db29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(这里我们不考虑打字错误或任何其他类型的错误)</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/e63aeb9f0f44ee80850602a73c96acfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0Ior1hPWIGHRGZ1945O_w.png"/></div></div></figure><p id="076e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们真的有标签，我们会怎么做？</p><p id="e8ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">朴素贝叶斯是一个很好的起点</strong>。这种算法通常用作文本分类的基线，因为它可以轻松处理许多级别(在我们的例子中，有几千个可能的字符串)并且高度可伸缩。</p><p id="d0f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该问题的简单朴素贝叶斯分类器的数学公式如下:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/dd875c4da905ac7944cc3a894056fb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*RiV14CXzc-uxs5jzgoZvyQ.png"/></div></figure><p id="c2f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">朴素贝叶斯模仿人类思考的方式</strong>(针对一些简单的问题)。的确，是什么推理过程让我们相信 Name='Smith'/Surname='Will '很可能是数据录入错误？因为——基于我们对世界的了解——我们知道:</p><ul class=""><li id="572d" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">P('Smith' =姓名|正确)=低</li><li id="28d8" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">P('Will' =姓氏|正确)=低</li></ul><p id="2e5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们隐含地计算:</p><ul class=""><li id="6ee9" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">p(正确| '史密斯' =姓名，'威尔' =姓氏)=非常低</li></ul><h1 id="b637" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">发明标签</strong></h1><p id="629d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在我们有一种机器学习方法可以帮助我们解决这个问题。唯一缺少的是标签。所以问题是:我们如何获得标签？</p><p id="9154" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提示是:<strong class="kd iu">数据集高度不平衡</strong>。因此，即使存在错误，记录在大多数情况下也是正确的。因此，直觉是:<strong class="kd iu">如果我们认为记录都是正确的，我们就很少会出错。</strong></p><p id="d4ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设观察结果都是正确的(错误的)假设不会造成太大的伤害，因为:</p><ul class=""><li id="7014" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">错误很少，所以经验概率不会受到它们太多的影响，因此它将接近真实概率，</li><li id="f4b1" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">这些错误并不取决于具体的名字或姓氏。事实上，没有理由认为某些名字或姓氏比其他名字或姓氏更容易被交换。</li></ul><p id="9796" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于上面看到的例子，这相当于制造一个总是“正确”的标签。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/6801e2633cfd0cc67998da449fc37d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QR6hEK7k4b7bVueU_eROVw.png"/></div></div></figure><p id="bac6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我知道这看起来很疯狂，但是坚持住。如果所有的观察都被标记为正确，那么上面看到的公式可以归结为:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2953a504a6e5d47c29aa232bbca7bdb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*P0XQbXFHdtFBk8C6SCniuw.png"/></div></figure><p id="3111" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/66ec605377ee805a2c6adf9671772f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ASb4cRQ53ioLydBoYneD0A.png"/></div></figure><p id="5f17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们现在能够计算将朴素贝叶斯应用于手头问题所需的每个量。</p><h1 id="843e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">数据</h1><p id="9479" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们将使用模拟数据集，以便我们能够量化结果的好坏。</p><p id="97fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用于产生数据的基本事实由来自美国人口的统计数据提供:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/9a04e5107af26b21a721335e5ab10c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*cZ3mwxkb98gZtwLarF3rzQ.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Ground truth</figcaption></figure><p id="0651" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前两列(<em class="nd"> distrib_firstname </em>和<em class="nd"> distrib_lastname </em>)分别包含名字或姓氏的任何字符串的相对计数。这些列中的每一列总计为 1。</p><p id="48e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后两列(<em class="nd"> proba_firstname </em>和<em class="nd"> proba_lastname </em>)包含每个字符串作为名字或姓氏出现的概率。每行的这两列之和等于 1。</p><p id="45b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，通过对名字和姓氏进行随机采样，并考虑<em class="nd"> distrib_firstname </em>和<em class="nd"> distrib_lastname，获得数据集。</em> <strong class="kd iu">数据集由 100 万行组成。错误率</strong> <strong class="kd iu">(名字和姓氏已经被交换的行的百分比)是 3% </strong>，这意味着 30，000 行。</p><p id="7093" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个数据集预览。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/fece07e19604ae6cac4f285390fe6f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*csYLkQI0E1FCUh1_Ek0AfA.png"/></div></figure><p id="8554" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，我们有最后一列(也就是标签)，只是因为这是一个模拟数据集。但是，我们永远不会使用它，除了性能测量。</p><h1 id="e320" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">应用朴素贝叶斯</h1><p id="3523" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">下一步是计算每个可能的字符串成为名字或姓氏的概率。基于我们在前面的段落中所看到的，一切都归结为简单地计算一个字符串作为名字或姓氏出现的次数。</p><p id="2497" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只是做了一个额外的假设:如果一个字符串在整个数据集中出现的次数少于 10 次，我们将赋予它 50%的概率。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/24a6a6bda465a001f754544aa801ad8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*dOV7motiyW-PjQ0HwHOYdw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Empirical probability</figcaption></figure><p id="291b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以计算数据集的每一行实际上是正确的概率。使用上面看到的公式，我们得到:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0833ef76e0966a81bc3ffc0939518634.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*uMih3Vr-LPpRGNsnYPKnsg.png"/></div></figure><p id="abae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，第一行的概率如下获得:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1897dbee15d2b703b0736f3e9551115f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kaPaSadroMlMgWBV4D2Utw.png"/></div></figure><p id="7b2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了一个新的列，称为<em class="nd"> proba_correct </em>，它为每一行分配一个正确的概率，我们只需要选择<strong class="kd iu">一个概率阈值:低于该水平的观察将被视为错误</strong>。</p><p id="6919" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们如何选择阈值？</p><p id="b83c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于这是一个任意的选择，它取决于几个方面，其中最主要的是<strong class="kd iu">假阳性和假阴性的成本</strong>。无论如何，看看分布总是一个好主意。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0d46402a2a48d8b8b4d04e5a368e8884.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*ueatOlEwsyhuEd6u1uvTuw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Empirical cumulative distribution of P(Correct | Name, Surname)</figcaption></figure><p id="ba59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，<strong class="kd iu">因为我们知道错误的发生率在 3%左右，我们将选择第 3 个百分位数<em class="nd"> proba_correct </em>，它等于 0.0394921 </strong>。</p><p id="c12b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在最初的实际问题中，我们没有标签，因此评估我们模型性能的唯一方法是对结果进行定性检查。</p><p id="a2d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，由于我们使用了模拟数据，我们有能力计算输出质量的定量测量。例如，通过所选阈值获得的混淆矩阵为:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6f14c781127a653d4245d8641bcb4e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*y_J9cMPM9f-n07B_2XejMA.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Confusion matrix</figcaption></figure><p id="7558" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，<strong class="kd iu">精度等于 99.8248 % </strong>。记住<strong class="kd iu">原始数据集的准确性是 97% </strong>，这是一个非常强的结果，特别是考虑到模型是如此简单和可解释。</p><p id="6836" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">混淆矩阵意味着我们有 875 个假阳性和 877 个假阴性，总共 1752 个错误。出于好奇，我们可以看看其中的一些:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bea2af634a7186de1f3d7354e66cc362.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*rOAx8TLnfWar1PYXD2Vt_w.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Errors (type I and type II)</figcaption></figure><p id="62eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，<strong class="kd iu">即使是人类操作员</strong>也很难正确分类这些案例，从而确认我们工作的整体价值。</p></div></div>    
</body>
</html>