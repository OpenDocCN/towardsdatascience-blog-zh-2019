<html>
<head>
<title>Code: The New Data To Look At</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码:要查看的新数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/code-the-new-data-to-look-at-7eaf1c7d5484?source=collection_archive---------20-----------------------#2019-06-18">https://towardsdatascience.com/code-the-new-data-to-look-at-7eaf1c7d5484?source=collection_archive---------20-----------------------#2019-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6278ac161e6d31fd0c6fed20bee73234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwm1UjHPxBagfa_J7OK3LQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">the source — <a class="ae kc" href="https://fossbytes.com/microsoft-ai-system-deepcoder/" rel="noopener ugc nofollow" target="_blank">https://fossbytes.com/microsoft-ai-system-deepcoder/</a></figcaption></figure><p id="bcdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脸书、汽车和波音有什么共同点？它们都运行在超过 2000 万行代码的源代码上。</p><p id="72b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">六年前，马克·安德森说“<a class="ae kc" href="https://www.wsj.com/articles/SB10001424053111903480904576512250915629460" rel="noopener ugc nofollow" target="_blank">软件正在吞噬世界</a>”，看看大卫·麦坎多斯<a class="ae kc" href="https://informationisbeautiful.net/visualizations/million-lines-of-code/" rel="noopener ugc nofollow" target="_blank">visuali</a>z<a class="ae kc" href="https://informationisbeautiful.net/visualizations/million-lines-of-code/" rel="noopener ugc nofollow" target="_blank">ating</a>我们就能明白这有多真实。我们被源代码及其日益增加的复杂性和挑战所淹没:影子 IT、缺乏文档、语言和框架异构性、缺乏代码历史的可见性、没有维护代码的简单方法…</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/a6b51cb44b50dd4768c44a9e0285532a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Us2e2XxrV_OiN4MuhOahg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The size of code bases in different systems</figcaption></figure><p id="f932" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像网络上的大量数据一样，支持大数据应用程序，现在大型程序库(例如 GitHub、Bitbucket 中的开源代码)支持一种新的应用程序:“大代码”。我们已经积累了数十亿字节的开放源代码数据，但很少有人尝试充分利用这些封存在内部的知识。<strong class="kf ir">代码是要看的新数据</strong>！</p><p id="0559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对源代码使用机器学习意味着从现有代码中自动学习，以便解决诸如预测程序错误、预测程序行为、预测标识符名称或自动创建新代码等任务。这种新方法打开了软件和代码开发方式中极其令人兴奋的机会之门。</p><h1 id="d138" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">源代码上的机器学习:是什么？</h1><p id="9a74" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">源代码上的机器学习(#MLonCode)是一个新兴的令人兴奋的研究领域，它位于深度学习、自然语言处理、软件工程和编程语言的十字路口。</p><p id="a7b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在机器学习领域，源代码分析目前不如图像或自然语言分析重要。因此，对于使用源代码作为预测的数据源，还没有成熟的标准技术。我们站在一个前沿技术领域，仍然需要大量的研究。</p><h1 id="8b71" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">处理代码数据</h1><p id="2223" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">机器学习是应用于数据的数学算法:因此，任何输入数据都必须有一个数学表示。例如，当你想处理一幅图像时，你必须把它转换成一个矩阵。这很容易描述:图像是像素的矩阵，像素是用来描述颜色的数字阵列。</p><p id="a573" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当涉及到编码时，挑战就有点棘手了。代码包含不同层次的理解:</p><ul class=""><li id="a27f" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">语义层:写的是什么</li><li id="5c8d" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">结构层次:它是如何写的</li><li id="ed49" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">图流级别:代码的每个部分如何与代码的其余部分交互</li></ul><p id="4ebd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">源代码的意图和意义依赖于这三个层次的理解。</p><p id="6898" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何应用于源代码的机器学习技术都应该确保这三个理解层次的数学嵌入。嵌入的质量将影响模型的质量</p><p id="92ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">(这个话题会在后面的文章中详细介绍)</em></p><h1 id="e654" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">代码上的机器学习:用例</h1><h2 id="7a07" class="my lh iq bd li mz na dn lm nb nc dp lq ko nd ne lu ks nf ng ly kw nh ni mc nj bi translated">自动测试您的代码</h2><p id="2aee" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">许多软件开发过程必须覆盖大量的单元和集成测试用例，这需要很长(很长，很长……)的时间来完全实现。作为开发人员，尤其是在测试中，持续集成(CI)涉及到测试用例的优先排序、选择以及每个周期的执行。</p><p id="7e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果对提交的代码变更的影响存在不确定性，或者如果代码和测试之间的可追溯性链接不可用，那么选择最有希望的测试用例来检测 bug 是很困难的。</p><p id="dc58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天对代码的自动理解，可以帮助你根据测试用例的持续时间、上次执行和失败历史来区分它们的优先级。在不断变化的环境中，一些算法如<a class="ae kc" href="https://arxiv.org/abs/1811.04122" rel="noopener ugc nofollow" target="_blank"> Retecs </a>方法学会对容易出错的测试用例进行优先排序。</p><p id="b961" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">现实世界的例子:</em>网飞的工程师们运行了一系列测试和基准测试，从多个维度验证这项服务，包括音视频播放质量、许可证处理、加密、安全性……所有这些导致了大量的测试案例，其中大部分是自动化的，需要执行这些测试来验证运行网飞的设备的功能。为了加快测试过程，网飞工程师使用了<em class="mx">s</em>T8】Retecs 工艺。当针对设备运行持续集成时，它可以帮助他们从成千上万个可用的测试用例中选择最有希望的测试子集，或者推荐一组针对设备执行的测试用例，这将增加设备实时失败的概率。</p><h2 id="92a3" class="my lh iq bd li mz na dn lm nb nc dp lq ko nd ne lu ks nf ng ly kw nh ni mc nj bi translated">代码建议和完成</h2><p id="9aed" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">多年来，开发人员就像装配线上的工人一样，一遍又一遍地编写同一行代码来解决同一类问题。有多少次我在寻找解决某个具体问题的方法，却发现自己每六个月都在寻找同样的答案！(而且我知道……不止我一个人在)。</p><p id="ab40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工程师在处理问题时，通常会寻找一种已经实现的方法来解决问题。多年来，已经提出了许多代码搜索工具和平台(保佑你 StackOverflow)来帮助开发人员。通常的方法通常将源代码视为文本文档，并利用信息检索模型来检索与给定查询匹配的相关代码片段。他们缺乏对查询和源代码语义的深刻理解。</p><p id="5191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天对代码的机器学习使得能够在问题域中运行<strong class="kf ir">语义相似性搜索</strong>，而不是在解决方案域中搜索。</p><p id="375f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用最多的技术是<a class="ae kc" href="https://code2vec.org/" rel="noopener ugc nofollow" target="_blank"> Code2Vec </a>。比如著名的自然语言处理例子:</p><pre class="lc ld le lf gt nk nl nm nn aw no bi"><span id="10cd" class="my lh iq nl b gy np nq l nr ns">vec(“man”)-vec(“woman”) = vec(“king”)-vec(“queen”)</span></pre><p id="d785" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Code2Vec 模型学习与源代码相关的类比，例如:</p><pre class="lc ld le lf gt nk nl nm nn aw no bi"><span id="40ed" class="my lh iq nl b gy np nq l nr ns">vec("receive")-vec("send") = vec("downlaod")-vec("upload")</span></pre><p id="cad2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">现实世界的例子:</em>脸书今年发布了<a class="ae kc" href="https://ai.facebook.com/blog/aroma-ml-for-code-recommendation/" rel="noopener ugc nofollow" target="_blank"> Aroma </a>，这是一个代码到代码的搜索和推荐工具，它使用机器学习(ML)来使从大型代码库中获得洞察力的过程变得更加容易。让我们记住脸书，有超过 2B 行的代码…</p><h2 id="61d7" class="my lh iq bd li mz na dn lm nb nc dp lq ko nd ne lu ks nf ng ly kw nh ni mc nj bi translated">代码审查</h2><p id="5a4c" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">确定程序的正确性需要对程序的预期行为有精确的理解，并有一种方法以适合自动化检查的形式明确地传达这种理解。</p><p id="9eeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天的代码审查工具缺乏对代码理解的深度，这会导致不愉快的情况(例如高测试覆盖率，同时有一个不工作的程序或高水平的代码文档，而每个注释都是过时的)。</p><p id="2a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对代码的机器学习为(深入)理解代码的意图并对其进行分析打开了一扇新的大门。这就像将二维图像与三维图像进行比较。是的，当前的代码审查工具确实提供了对代码的洞察，但与 ML 驱动的工具所能做的相比，这根本不算什么。</p><p id="e35c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">真实世界示例</em> : <a class="ae kc" href="http://autosoft.dev" rel="noopener ugc nofollow" target="_blank"> Autosoft </a>发布了第一个版本的代码审查工具，该工具评估代码及其注释的一致性，如果注释与代码有偏差，则自动建议更新。下一个版本将会比较单元测试和代码的有用性。当审查代码时，这使开发人员能够对如何提高任何代码的长期可读性和可维护性有真正可行的见解:<a class="ae kc" href="https://medium.com/why-does-it-take-so-long-for-developers-to-really/why-does-it-take-so-long-for-developers-to-really-understand-legacy-code-2e3dcc5bd3d2" rel="noopener">这对我们来说很关键。</a></p><h2 id="d4d5" class="my lh iq bd li mz na dn lm nb nc dp lq ko nd ne lu ks nf ng ly kw nh ni mc nj bi translated">程序归纳和综合</h2><p id="098e" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这将是计算机科学自 200 年前创立以来的圣杯:获得一个完全自动化的编程系统。在计算机科学中，程序综合是自动构造满足给定高级规范的程序的任务。我们目前处于指导性编程的世界。作为开发人员，当我们必须解决一个复杂的问题时，我们将它分解成更小的问题，并编写解决这些问题的代码(我们讨论首要原则)。程序合成的工作方式正好相反:我们给计算机提供一个复杂的问题(我们想要的)，把如何解决它的细节留给计算机。</p><p id="3cc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在还不能确定(<em class="mx">请等一等，发言先生</em>)但是最近研究人员和公司方面都取得了巨大的进步。今天我们可以谈谈增强编程。</p><p id="0dd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">现实世界的例子</em>:</p><p id="2b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/tonybeltramelli/pix2code" rel="noopener ugc nofollow" target="_blank"> Pix2Code </a>:虽然传统上前端开发人员的任务是将设计师的工作从原始的图形用户界面模型转化为实际的源代码，但这种趋势可能很快就会成为过去。他们的代码检测实体模型中的形状，解释它们的含义(段落、标题、图像……)并生成相关代码。</p><h1 id="7903" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="2a4c" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">让我们的想象力更进一步。如果 ML 生成的代码至少和最好的人类程序员可能产生的代码一样好，那可能会加速大多数开发人员再也不需要接触一行可执行代码的那一天。</p><p id="669b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">粗略地考虑一下，上面引用的解决方案的执行准确率在 60%到 80%之间，ML 驱动的软件工程师不会很快淘汰人类程序员。</p><p id="e41d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而与此同时，我们仍然可以享受增强编程来挑战当今软件工程的许多缺陷(文档自动生成、适当的测试编写、代码优化、建议……)</p><p id="3163" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于代码的机器学习来了！</p></div></div>    
</body>
</html>