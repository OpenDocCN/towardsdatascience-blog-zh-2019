<html>
<head>
<title>The F-Test for Regression Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回归分析的 f 检验</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fisher-test-for-regression-analysis-1e1687867259?source=collection_archive---------0-----------------------#2019-10-27">https://towardsdatascience.com/fisher-test-for-regression-analysis-1e1687867259?source=collection_archive---------0-----------------------#2019-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/edd562c99dcbc2cfbf4428b27f97030f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*_spiuVoG6E6Pnz0s3sfgLw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk"><a class="ae jc" href="https://commons.wikimedia.org/wiki/File:F-distribution_pdf.svg" rel="noopener ugc nofollow" target="_blank">The F-distribution</a> (Source: Wikimedia Commons under <a class="ae jc" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</figcaption></figure><div class=""/><div class=""><h2 id="8b29" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">如何使用它，如何解释它的结果</h2></div><p id="60aa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当用于回归分析时，f 检验允许您比较两个竞争回归模型“解释”因变量方差的能力。</p><p id="b61b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">f 检验主要用于方差分析和回归分析。我们将研究它在<em class="lq">线性</em>回归中的应用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="bb1d" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">为什么在回归分析中使用 f 检验</h2><p id="ce5c" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在线性回归中，f 检验可用于回答以下问题:</p><ul class=""><li id="9702" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">你能通过使你的线性回归模型变得更复杂来改进它吗，例如，通过增加更多的线性回归变量？</li><li id="7fa6" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">如果您已经有了一个复杂的回归模型，您是否会更好地用仅截距模型(这是您可以构建的最简单的线性回归模型)来交换您的复杂模型？</li></ul><p id="2773" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个问题是第一个问题的特例。在这两种情况下，这两个模型被称为是<strong class="kw jg">嵌套</strong>。更简单的模型被称为<strong class="kw jg">限制模型。</strong>这就好像我们在限制它使用更少的回归变量。复杂模型被称为<strong class="kw jg">无限制模型。</strong>它包含了受限模型的所有变量和至少一个以上的变量。</p><p id="a431" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">受限模型被称为嵌套在非受限模型中。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c091c276ea0fccdc8171e449075beaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Ms1Vf5i46UB9NsjQmZApMw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Linear regression models: unrestricted, restricted and intercept-only restricted (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="58c7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过一个真实世界的时间序列示例来探索 f 检验的使用。我们将首先构建一个仅拦截模型，即受限模型。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="69e1" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">简单看一下仅拦截模型</h2><p id="26b1" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">以下时间序列显示了道琼斯工业平均指数在 3 个月内的每日收盘价。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/88e8503158ff3e8600dea38d77fa46d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NymLzt-UIxQFnuQvPXQxDQ.png"/></div></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Dow Jones Industrial Average closing price over a 3-month period (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="e468" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们希望为这个时间序列创建一个回归模型。但是我们不知道什么因素影响收盘价。我们也不想在数据集中假设任何通货膨胀、趋势或季节性。</p><p id="0409" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在没有任何关于通货膨胀、趋势、季节性或存在解释变量的假设的情况下，我们能做的最好的事情是仅截距模型(有时被称为<strong class="kw jg">均值模型</strong>)。对于我们的时间序列示例，它采用以下形式:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/903ec481f0c75bc768e19cb99c822cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*nAKFBbcoGagPPVsjltUDxQ.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Intercept-only model for the DJIA data set (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="092d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在仅截距模型中，所有预测都采用截距 Beta_0 的值。下图显示了实际时间序列背景下拟合的仅截距模型:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nv"><img src="../Images/4241f2dd555352dbabe535a6f3596183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrYqi-F0jMpt9LCEnuxBDw.png"/></div></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Actual and predicted Closing Price of DJIA using the mean model (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="76cd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是产生上述结果的 Python 代码:</p><p id="7114" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导入所有必需的包:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="3517" class="ly lz jf nx b gy ob oc l od oe"><strong class="nx jg">import </strong>pandas <strong class="nx jg">as </strong>pd<br/><strong class="nx jg">import </strong>numpy <strong class="nx jg">as </strong>np<br/><strong class="nx jg">import </strong>matplotlib.pyplot <strong class="nx jg">as </strong>plt</span></pre><p id="c4bf" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将数据集读入熊猫数据框:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="58e0" class="ly lz jf nx b gy ob oc l od oe">df = pd.read_csv(<strong class="nx jg">'djia.csv'</strong>, header=0, infer_datetime_format=<strong class="nx jg">True</strong>, parse_dates=[0], index_col=[0])</span></pre><p id="ba35" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计算样本平均值，并将所有预测值设置为该平均值:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="0559" class="ly lz jf nx b gy ob oc l od oe">mean = round(df[<strong class="nx jg">'Closing Price'</strong>].mean(),2)</span><span id="4894" class="ly lz jf nx b gy of oc l od oe">y_pred = np.full(len(df[<strong class="nx jg">'Closing Price'</strong>]), mean)</span></pre><p id="6e63" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绘制实际值和预测值:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="8fcb" class="ly lz jf nx b gy ob oc l od oe">fig = plt.figure()</span><span id="7b73" class="ly lz jf nx b gy of oc l od oe">fig.suptitle(<strong class="nx jg">'DJIA Closing Price'</strong>)</span><span id="c604" class="ly lz jf nx b gy of oc l od oe">actual, = plt.plot(df.index, df[<strong class="nx jg">'Closing Price'</strong>], <strong class="nx jg">'go-'</strong>, label=<strong class="nx jg">'Actual Closing Price'</strong>)</span><span id="fca2" class="ly lz jf nx b gy of oc l od oe">predicted, = plt.plot(df.index, y_pred, <strong class="nx jg">'ro-'</strong>, label=<strong class="nx jg">'Predicted Closing Price'</strong>)</span><span id="9441" class="ly lz jf nx b gy of oc l od oe">plt.xlabel(<strong class="nx jg">'Date'</strong>)</span><span id="7d27" class="ly lz jf nx b gy of oc l od oe">plt.ylabel(<strong class="nx jg">'Closing Price (USD)'</strong>)</span><span id="0110" class="ly lz jf nx b gy of oc l od oe">plt.legend(handles=[predicted, actual])</span><span id="bcb1" class="ly lz jf nx b gy of oc l od oe">plt.show()</span></pre><p id="d654" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能比均值模型做得更好吗？也许我们可以。让我们试着为这个时间序列开发一个竞争性的、无限制的模型。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="6655" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">竞争模型</h2><p id="a94f" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">假设通过一些分析，我们已经推断出 DJIA 收盘价的今天的值可能是明天收盘价的一个很好的预测值。</p><p id="4bd1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了测试这一理论，我们将开发一个由单个回归变量组成的线性回归模型。该变量将是时间序列的时间滞后值。以下 Python 代码说明了回归过程:</p><p id="5c65" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导入所需的包:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="430b" class="ly lz jf nx b gy ob oc l od oe"><strong class="nx jg">import </strong>pandas <strong class="nx jg">as </strong>pd<br/><strong class="nx jg">import </strong>numpy <strong class="nx jg">as </strong>np<br/><strong class="nx jg">import </strong>statsmodels.api <strong class="nx jg">as </strong>sm</span></pre><p id="00c1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将数据集读入熊猫数据框:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="faeb" class="ly lz jf nx b gy ob oc l od oe">df = pd.read_csv(<strong class="nx jg">'djia.csv'</strong>, header=0, infer_datetime_format=<strong class="nx jg">True</strong>, parse_dates=[0], index_col=[0])</span></pre><p id="632e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加延时栏:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="8ef8" class="ly lz jf nx b gy ob oc l od oe">df['CP_LAGGED'] = df['Closing Price'].shift(1)</span></pre><p id="83fa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是修改后的数据框的前几行。第一行包含一个 NaN，因为该值后面没有任何东西:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="1d44" class="ly lz jf nx b gy ob oc l od oe">            <strong class="nx jg">Closing Price    CP_LAGGED<br/>Date<br/></strong>2019-07-24    27269.97070          NaN<br/>2019-07-25    27140.98047  27269.97070<br/>2019-07-26    27192.44922  27140.98047<br/>2019-07-29    27221.34961  27192.44922<br/>2019-07-30    27198.01953  27221.34961<br/></span></pre><p id="2358" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们去掉第一行，去掉 NaN:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="b23b" class="ly lz jf nx b gy ob oc l od oe">df_lagged = df.drop(df.index[0])</span></pre><p id="2806" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们创建我们的训练和测试数据集:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="b133" class="ly lz jf nx b gy ob oc l od oe">split_index = round(len(df_lagged)*0.8)</span><span id="23fb" class="ly lz jf nx b gy of oc l od oe">split_date = df_lagged.index[split_index]</span><span id="f1bb" class="ly lz jf nx b gy of oc l od oe">df_train = df_lagged.loc[df_lagged.index &lt;= split_date].copy()</span><span id="0f4d" class="ly lz jf nx b gy of oc l od oe">df_test = df_lagged.loc[df_lagged.index &gt; split_date].copy()</span><span id="4e1b" class="ly lz jf nx b gy of oc l od oe">X_train = df_train[<strong class="nx jg">'CP_LAGGED'</strong>].values</span><span id="2cec" class="ly lz jf nx b gy of oc l od oe"><em class="lq">#Add a placeholder for the constant so that model computes an intercept value. The OLS regression equation will take the form: y = Beta_0 + Beta_1*x<br/></em>X_train = sm.add_constant(X_train)</span><span id="9f97" class="ly lz jf nx b gy of oc l od oe">y_train = df_train[<strong class="nx jg">'Closing Price'</strong>].values</span><span id="c381" class="ly lz jf nx b gy of oc l od oe">X_test = df_test[<strong class="nx jg">'CP_LAGGED'</strong>].values</span><span id="547c" class="ly lz jf nx b gy of oc l od oe"><em class="lq">#Add a placeholder for the constant<br/></em>X_test = sm.add_constant(X_test)</span><span id="28a9" class="ly lz jf nx b gy of oc l od oe">y_test = df_test[<strong class="nx jg">'Closing Price'</strong>].values</span></pre><p id="59a1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构建 OLS ( <strong class="kw jg"> O </strong>副<strong class="kw jg"> L </strong>东<strong class="kw jg"> S </strong>方)回归模型并将其拟合到时间序列数据集；</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="2d49" class="ly lz jf nx b gy ob oc l od oe">ols_model = sm.OLS(y_train,X_train)</span><span id="a14c" class="ly lz jf nx b gy of oc l od oe">ols_results = ols_model.fit()</span></pre><p id="8b88" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用拟合的模型对训练和测试数据集进行预测:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="c76d" class="ly lz jf nx b gy ob oc l od oe">y_pred_train = ols_results.predict(X_train)</span><span id="54d3" class="ly lz jf nx b gy of oc l od oe">y_pred_test = ols_results.predict(X_test)</span></pre><p id="c3dd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对照<em class="lq">测试数据集</em>绘制模型的性能:</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="95c6" class="ly lz jf nx b gy ob oc l od oe">fig = plt.figure()</span><span id="849f" class="ly lz jf nx b gy of oc l od oe">fig.suptitle('DJIA Closing Price')</span><span id="82a9" class="ly lz jf nx b gy of oc l od oe">actual, = plt.plot(df_test.index, y_test, 'go-', label='Actual Closing Price')</span><span id="1aeb" class="ly lz jf nx b gy of oc l od oe">predicted, = plt.plot(df_test.index, y_pred_test, 'ro-', label='Predicted Closing Price')</span><span id="9cf0" class="ly lz jf nx b gy of oc l od oe">plt.xlabel('Date')</span><span id="1d07" class="ly lz jf nx b gy of oc l od oe">plt.ylabel('Closing Price (USD)')</span><span id="af73" class="ly lz jf nx b gy of oc l od oe">plt.legend(handles=[predicted, actual])</span><span id="5477" class="ly lz jf nx b gy of oc l od oe">plt.show()</span></pre><p id="2201" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果看起来像这样:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi og"><img src="../Images/04ccfd0d812d85002fd7186720de8884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Y7dca9L8xQR9ST_KUwp4g.png"/></div></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Predicted versus actual Closing Price of DJIA using the OLS regression model on the test data set (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="95bf" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">乍一看，这个模型的性能看起来比我们从均值模型中得到的要好得多。但是仔细观察发现，在每一个时间步，模型只是学会了预测实际上是先前观察到的值偏移了一定的量。</p><p id="4763" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，这种滞后变量模型<em class="lq">可能</em>在解释收盘价的变化量时在统计上比仅截距模型表现得更好。我们将使用 f 检验来确定这是否属实。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="9327" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">测试方法</h2><p id="4c73" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们的测试方法如下:</p><p id="db89" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们从两个假设开始:</p><ul class=""><li id="43d5" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><strong class="kw jg">h0:零假设:</strong>滞后变量模型并不能比单纯截距模型更好地解释 DJIA 收盘价的变化。</li><li id="888a" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw jg">h1:替代假设:</strong>滞后变量模型比仅截距模型更好地解释了 DJIA 收盘价的变化(以统计显著的方式)。</li></ul><p id="f313" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将对两个模型使用 f 检验:仅截距模型和滞后变量模型，以确定是否:</p><ul class=""><li id="f4b8" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">在一定的误差范围内，可以拒绝零假设(并接受替代假设),或者</li><li id="cbba" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">应该接受零假设。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="520e" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">使用 f 检验的分步过程</h2><p id="66e9" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">为了实现上述目标，我们将遵循以下步骤:</p><ol class=""><li id="f3a5" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp oh nc nd ne bi translated">制定 f 检验的检验统计量，即<strong class="kw jg"> F 检验统计量</strong>。</li><li id="148b" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp oh nc nd ne bi translated">在假设零假设为真的情况下，确定 F 统计量所代表的随机变量<em class="lq">的<strong class="kw jg"> P </strong>概率<strong class="kw jg"> D </strong>密度<strong class="kw jg"> F </strong>函数。</em></li><li id="29ba" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp oh nc nd ne bi translated">将这些值代入 F 统计的公式，并使用步骤 2 中找到的<strong class="kw jg"> P </strong>概率<strong class="kw jg"> D </strong>密度<strong class="kw jg"> F </strong>函数计算相应的概率值。这是假设零假设为真时观察到 F 统计值<em class="lq">的概率。</em></li><li id="b857" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp oh nc nd ne bi translated">如果步骤 3 中发现的概率小于误差阈值，例如 0.05，则拒绝零假设，并接受置信水平为(1.0 —误差阈值)的替代假设，例如 1–0.05 = 0.95(即 95%置信水平)。否则，接受误差概率等于阈值误差的零假设，例如 0.05%或 5%。</li></ol><p id="9ce2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们深入这些步骤。</p><h2 id="0375" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">步骤 1:开发测试统计的直觉</h2><p id="c587" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">回想一下，f 检验衡量的是一个复杂模型在解释因变量方差的能力上比同一模型的一个简单版本好多少。</p><p id="5be4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑两个回归模型 1 和 2:</p><ul class=""><li id="3165" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">设模型 1 有<strong class="kw jg"> <em class="lq"> k_1 </em> </strong>参数。模型 2 有<strong class="kw jg"> <em class="lq"> k_2 </em> </strong>参数。</li><li id="4aed" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">让<strong class="kw jg"><em class="lq">k _ 1</em></strong>&lt;<strong class="kw jg"><em class="lq">k _ 2</em></strong></li><li id="e91b" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">因此，模型 1 是模型 2 的简化版本。即模型 1 是受限模型，而模型 2 是非受限模型。模型 1 可以嵌套在模型 2 中。</li><li id="8361" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">设<strong class="kw jg"> <em class="lq"> RSS_1 </em> </strong>和<strong class="kw jg"> <em class="lq"> RSS_2 </em> </strong>为模型 1 和模型 2 拟合到同一数据集后的残差平方和。</li><li id="5d00" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">设<strong class="kw jg"> <em class="lq"> n </em> </strong>为数据样本数。</li></ul><p id="ab18" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了上述定义，回归的 f 检验的检验统计量可以表示为如下比率:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oi"><img src="../Images/d25246e10737ab645aa316f999ae2cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95FtCBBwG1CTTRq-jts9hA.png"/></div></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Formula for the F-statistic when applied to regression analysis (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="edf7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F 统计公式允许您计算因变量中有多少方差，简单模型与复杂模型相比<em class="lq">不能</em>解释，表示为复杂模型中未解释方差的分数。</p><p id="a1b5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在回归分析中，拟合模型的均方误差是无法解释的方差的极好度量。这解释了分子和分母中的 RSS 项。</p><p id="17fa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用相应的可用自由度来适当地缩放分子和分母。</p><p id="65ff" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">F 统计量本身就是一个随机变量。</p><p id="383b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们确定 F-统计量服从哪一个<strong class="kw jg"> P </strong>概率<strong class="kw jg"> D </strong>强度<strong class="kw jg"> F </strong>函数。</p><h2 id="50e8" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">步骤 2:确定 F 统计的概率密度函数</h2><p id="7712" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">请注意，测试统计的分子和分母都包含残差平方和。还记得在回归中，残差恰好是具有某种概率密度(或概率质量)函数的随机变量，即 PDF 或 PMF，取决于它是连续的还是离散的。在这种情况下，我们关心的是找到 F 统计的 PDF。</p><p id="e381" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们假设两个模型的残差 1)是独立的，2)是正态分布的，这恰好是二次回归的要求，那么可以看到 F 统计公式的分子和分母包含独立的正态分布随机变量的平方和。</p><p id="db34" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以证明 k 个独立的标准正态随机变量的平方和遵循卡方(k)分布的 PDF。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/3fbd3f15709381246df933b0e21d9109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*gQmERXqIzWYJTrLCt6NRlg.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">PDF of the Chi-Squared distribution (Source: <a class="ae jc" href="https://commons.wikimedia.org/wiki/File:Chi-square_pdf.svg" rel="noopener ugc nofollow" target="_blank">Wikimedia Commons</a> under <a class="ae jc" href="https://creativecommons.org/licenses/by/3.0/deed.en" rel="noopener ugc nofollow" target="_blank">CC BY 3.0</a>)</figcaption></figure><p id="b1ab" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，F 统计公式的分子和分母可以显示为各自服从两个卡方分布的缩放版本。</p><p id="84a0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">利用一点数学知识，还可以证明两个适当缩放的卡方分布随机变量的比率本身是一个随机变量，遵循<strong class="kw jg"> F 分布</strong>，其 PDF 如下所示。</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/edd562c99dcbc2cfbf4428b27f97030f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*_spiuVoG6E6Pnz0s3sfgLw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk"><a class="ae jc" href="https://commons.wikimedia.org/wiki/File:F-distribution_pdf.svg" rel="noopener ugc nofollow" target="_blank">The F-distribution</a> (Source: Wikimedia Commons under <a class="ae jc" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</figcaption></figure><p id="8fe6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说:</p><p id="90cb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果随机变量<strong class="kw jg"> <em class="lq"> X </em> </strong>具有带参数<em class="lq">D1</em>和<em class="lq">D2</em>的 f 分布的 PDF，即:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f752b943391ce53a7ad8b08e8ee03d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*cj-i7H6-JCX0suo3fRhnTw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">(Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="9f05" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，<strong class="kw jg"> <em class="lq"> X </em> </strong>可以表示为两个适当缩放的随机变量<strong class="kw jg"> <em class="lq"> X_1 </em> </strong>和<strong class="kw jg"> <em class="lq"> X_2 </em> </strong>的比值，每个随机变量都具有卡方分布的 PDF。即:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8bb071edbb1738c9b4fb87f7cb61ec7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*ArZjgLk1sYBM69h4KJ0trw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">An F-distributed random variable X, expressed as the ratio of two scaled Chi-squared distributed random variables X_1 and <em class="ol">X_2 </em>(Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="7c0a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在回想一下，k1 和 k2 是之前 M1 和 M2 介绍的简单和复杂模型中的变量个数，<em class="lq"> n </em>是数据样本的个数。</p><p id="5640" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将 D1 和 D2 替换如下:</p><p id="deca" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">d_1 = (k_2 — k_1 ),这是要比较的两个模型 M1 和 M2 的残差的自由度差，以及</p><p id="54ff" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">D2 =(n—k2)是复模型 M2 残差的自由度，</p><p id="f784" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这些替换，我们可以将 F 分布的公式改写如下:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e5e0c2f1766cd5f30eeaea22e9e08932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*X--qyKZ47hLSrcDcZq2uqA.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Alternate formula for the F-distribution’s PDF (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="4f50" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将上面的公式与 F 统计量的公式(复制如下)进行比较，其中我们知道分子和分母包含适当缩放的卡方分布的 pdf:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/cecf8c8e21b1c301aaeeb4167043e08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*OQ7EX2cmEPmGIXpVSloH6w.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Formula for the F-test’s test statistic (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><p id="1741" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比较这两个公式，很明显:</p><ol class=""><li id="c386" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp oh nc nd ne bi translated">分子中卡方分布的自由度'<em class="lq"> a' </em>为(k1 — k2)。</li><li id="ba7c" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp oh nc nd ne bi translated">分母中卡方分布的自由度'<em class="lq"> b' </em>为(n — k2)。</li><li id="e3bd" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp oh nc nd ne bi translated">f 检验的检验统计量具有与 f 分布相同的 PDF。</li></ol><p id="8999" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，F 统计量遵循 F 分布。</p><h2 id="a824" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">步骤 3:计算 F 统计值</h2><p id="aa69" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果您使用<em class="lq"> statsmodels 的</em> s OLS 估计器，这一步是一行操作。你需要做的就是打印<em class="lq"> OLSResults.summary() </em>然后你会得到:</p><ol class=""><li id="4c1a" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp oh nc nd ne bi translated">F 统计量的值，</li><li id="4eb7" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp oh nc nd ne bi translated">对应的“p”值，即在 F 分布的 PDF 中遇到该值的概率。</li></ol><p id="d9f3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq"> statsmodels </em>库将完成这两种计算的繁重工作。</p><pre class="nl nm nn no gt nw nx ny nz aw oa bi"><span id="bbd0" class="ly lz jf nx b gy ob oc l od oe">print(ols_results.summary())</span></pre><p id="a846" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这会打印以下内容:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oo"><img src="../Images/13969fac922e8fda4b0b5edd04187d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFgJVgavYdENdtkssTS6pA.png"/></div></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">Output of OLSResults.summary() (Image by <a class="ae jc" href="https://sachin-date.medium.com/" rel="noopener">Author</a>)</figcaption></figure><h2 id="086b" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">步骤 4:确定是否可以接受零假设</h2><p id="1423" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">因为<em class="lq"> OLSResults.summary() </em>在假设零假设为真的情况下打印出 F 统计的出现概率，所以我们只需要将这个概率与我们的阈值 alpha 值进行比较。在我们的例子中，<em class="lq">返回的 p 值。summary() </em>是 4.84E-16 这是一个极小的数。远小于甚至α= 0.01。因此，在一个有效的零假设的假设下，136.7 的 F-统计量偶然出现的概率远小于 1%。</p><p id="b142" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们拒绝零假设，接受另一个假设 h1，即复杂模型，即滞后变量模型，尽管有明显的缺陷，但它能够比仅截距模型更好地解释因变量收盘价的方差。</p><p id="a63a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是本文中显示的完整 Python 源代码:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="56ae" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">包含 DJIA 收盘价的数据文件在这里<a class="ae jc" href="https://gist.github.com/sachinsdate/4efeec7adfe9d8b8d415659ba3a849d4" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="a85f" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">结论</h2><ul class=""><li id="7201" class="mw mx jf kw b kx mr la ms ld or lh os ll ot lp nb nc nd ne bi translated">f 检验可用于回归分析，以确定在解释因变量的方差时，复杂模型是否优于同一模型的简单版本。</li><li id="c82d" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">f 检验的检验统计量是一个随机变量，其概率函数是假设零假设为真时的 f 分布。</li><li id="f548" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">回归的 f 检验的检验程序在结构上与其他重要的参数检验(如 t 检验)相同。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="b9cc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">感谢阅读！我撰写关于数据科学的主题，重点是时间序列分析和预测。</em></p><p id="a5f0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">如果你喜欢这篇文章，请关注我的</em><a class="ae jc" href="https://timeseriesreasoning.medium.com" rel="noopener"><strong class="kw jg"><em class="lq">Sachin Date</em></strong></a><em class="lq">获取关于时间序列分析和预测主题的提示、操作方法和编程建议。</em></p></div></div>    
</body>
</html>