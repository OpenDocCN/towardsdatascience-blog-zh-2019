<html>
<head>
<title>Deploy TensorFlow models with Istio on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Kubernetes 上使用 Istio 部署 TensorFlow 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-tensorflow-models-with-istio-on-kubernetes-dd0b2bd3e388?source=collection_archive---------10-----------------------#2019-05-19">https://towardsdatascience.com/deploy-tensorflow-models-with-istio-on-kubernetes-dd0b2bd3e388?source=collection_archive---------10-----------------------#2019-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/91248b3d35fe1240bfd7a09611b398c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFJyN7U-oareaED8IqPo7w.png"/></div></div></figure><p id="1902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">部署、版本控制、扩展和监控的典型云应用需求也是机器学习(ML)服务的常见运营挑战。</p><p id="e70a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将关注于构建一个 ML <em class="kw">服务基础设施</em>来持续更新、版本化和部署模型。</p><h1 id="469c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基础设施堆栈</h1><p id="2f9b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在构建我们的 ML 服务基础设施时，我们将在云环境中设置一个 Kubernetes 集群，并利用 Istio 来处理服务级别操作。接下来，我们将使用 TensorFlow Serving 来部署和服务托管在 S3 存储桶上的 ResNet 模型。最后，我们将看看如何执行新模型版本的阶段性 canary 部署，并最终使用 Flagger 自动化部署过程。</p><p id="2827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">概括地说，我们的基础架构包括:</p><ul class=""><li id="2010" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae mj" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Kubernetes </strong> </a>:面向应用基础设施和管理的开源容器编排系统。</li><li id="d237" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Istio </strong> </a>:开源“service-mesh”实现分布式环境下微服务的运营管理。</li><li id="5900" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">tensor flow Serving</strong></a>:开源的高性能 ML 模型服务系统。</li><li id="8208" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> S3 存储</strong> </a> : AWS 云对象存储。</li><li id="b211" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://docs.flagger.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Flagger </strong> </a>:作为 Kubernetes 操作员的开源自动化金丝雀部署管理器。</li></ul><h1 id="862d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">库伯内特星团</h1><p id="ba8a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Kubernetes 在重塑云基础架构格局方面创造了奇迹。多种环境都支持构建集群，几乎所有主要的云提供商都提供托管 Kubernetes 作为托管解决方案。</p><p id="b5bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将借此机会测试一个最新的解决方案，DigitalOcean 的托管 Kubernetes 解决方案。首先在选定的数据中心和节点池配置上创建一个新的<a class="ae mj" href="https://www.digitalocean.com/docs/kubernetes/quickstart/" rel="noopener ugc nofollow" target="_blank"> DigitalOcean Kubernetes </a>集群。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/16855cdfaf6a04871e33e3d4ce165540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6Rwp8vqLa8taSCX-Mbf1g.png"/></div></div></figure><p id="506f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下载配置文件并将其添加到 bash 会话中。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ba44" class="mz ky iq mv b gy na nb l nc nd">export KUBECONFIG=k8s-1-13-5-do-1-sfo2-1555861262145-kubeconfig.yaml</span></pre><p id="8ef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查节点的状态，并验证它是否运行正常，是否准备好接受工作负载。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8598" class="mz ky iq mv b gy na nb l nc nd">kubectl get nodes</span><span id="ce99" class="mz ky iq mv b gy ne nb l nc nd">NAME                                        STATUS    ROLES     AGE       VERSION</span><span id="8de4" class="mz ky iq mv b gy ne nb l nc nd">k8s-1-13-5-do-1-sfo2-1555861262145-1-msa8   Ready     &lt;none&gt;    57s       v1.13.5</span></pre><h1 id="c756" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">伊斯迪奥</h1><p id="0a58" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Istio 是一个开源的“服务网格”,它将自己透明地分层到现有的分布式基础设施上。</p><p id="71bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“服务网格”是相互连接的服务相互交互的抽象。这种抽象有助于降低分布式环境中管理应用程序的连接性、安全性和可观察性的复杂性。</p><p id="00f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Istio 通过提供一个完整的解决方案来帮助解决这些问题，该解决方案对“网格”内的连接服务进行洞察和操作控制。Istio 的一些核心功能包括:</p><ul class=""><li id="321c" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">HTTP、gRPC、TCP 连接上的负载平衡</li><li id="cea3" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">具有路由、重试和故障转移功能的流量管理控制</li><li id="0043" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">包括度量、跟踪和可观察性组件的监控基础架构</li><li id="bff9" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">端到端 TLS 安全性</li></ul><p id="459a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在现有的 Kubernetes 集群上安装 Istio 非常简单。关于安装指南，看看<a class="ae mj" href="https://medium.com/@nethminiromina" rel="noopener"> @nethminiromina </a>的这篇精彩帖子:</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/devopslinks/istio-step-by-step-part-02-getting-started-with-istio-c24ed8137741" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Istio 分步指南第 2 部分—开始使用 Istio</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">嗨！欢迎来到我的 Istio 循序渐进教程系列。通过这个教程，我会告诉你如何安装 Istio 在…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jw ni"/></div></div></a></div><p id="ebd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从下载的 Istio 包目录创建自定义资源定义(CRD ):</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0292" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml</span></pre><p id="d1d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，从打包的“一体化”清单中将 Istio 运营商资源部署到集群:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2966" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f install/kubernetes/istio-demo.yaml</span></pre><p id="ae42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">部署完成后，我们应该会在<code class="fe nx ny nz mv b">istio-system</code>名称空间中看到以下服务列表:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/91e16723df447987bc0d26e3c620d319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9feyD8Mh0zlF6jovkXt-Q.png"/></div></div></figure><p id="f617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保所有吊舱都处于<code class="fe nx ny nz mv b">Running</code>状态，并且上述服务可用。根据安装设置，启用对<code class="fe nx ny nz mv b">default</code>名称空间的侧车注入:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f54e" class="mz ky iq mv b gy na nb l nc nd">kubectl label namespace default istio-injection=enabled --overwrite</span></pre><h2 id="e3d4" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated"><strong class="ak"> Istio 交通管理</strong></h2><p id="893b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Istio 提供简单的规则和流量路由配置来设置服务级别属性，如断路器、超时和重试，以及部署级别任务，如 A/B 测试、canary 部署和分阶段部署。</p><p id="adcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Istio 交通管理的核心是<a class="ae mj" href="https://istio.io/docs/concepts/what-is-istio/#pilot" rel="noopener ugc nofollow" target="_blank">飞行员</a>和<a class="ae mj" href="https://istio.io/docs/concepts/what-is-istio/#envoy" rel="noopener ugc nofollow" target="_blank">特使</a>。Pilot 是管理服务发现和所有服务之间的智能流量路由的中心运营商，它通过翻译高级路由规则并将它们传播到必要的特使侧车代理。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/85d60eaa6f52a5092c61c07b126511cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0guGyiZZ4THRv_gmgfJDQ.png"/></div></div></figure><p id="dd26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Envoy 是一个高性能代理，用于协调网格中服务的所有入站和出站流量。它被部署为一个侧车集装箱，所有 Kubernetes 豆荚都在网格内。Envoy 的一些内置功能包括:</p><ul class=""><li id="5fa0" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">服务发现</li><li id="b7b4" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">负载平衡</li><li id="ea45" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">HTTP 和 gRPC 代理</li><li id="be95" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">基于%流量分割的分阶段部署</li><li id="8b68" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">丰富的指标</li><li id="4b21" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">TLS 终端、断路器、故障注入等等！</li></ul><p id="a870" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用 Istio 的流量管理和遥测功能在我们的集群中部署、服务和监控 ML 模型。</p><h2 id="bbaf" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">出口和入口</h2><p id="511a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Istio 通过简单的规则配置将流量管理从基础设施中分离出来，以管理和控制服务之间的流量。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/0fc884d5d2b85ec0d4d5a7dd98853e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FE9I4IBvHUT3-poT-kF8g.png"/></div></div></figure><p id="846b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让流量流入和流出我们的“网格”,我们必须设置以下 Istio 配置资源:</p><ul class=""><li id="419c" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe nx ny nz mv b">Gateway</code>:在“网格”边缘运行的负载均衡器，处理传入或传出的 HTTP/TCP 连接。</li><li id="7b15" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><code class="fe nx ny nz mv b">VirtualService</code>:管理“网格”内 Kubernetes 服务之间流量路由的配置。</li><li id="aeea" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><code class="fe nx ny nz mv b">DestinationRule</code>:路由后服务的策略定义。</li><li id="d9f2" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><code class="fe nx ny nz mv b">ServiceEntry</code>:内部服务配置附加条目；可以为内部或外部端点指定。</li></ul><p id="4728" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">配置出口</strong></p><p id="321d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，支持 Istio 的应用程序无法访问集群外部的 URL。由于我们将使用 S3 存储桶来托管我们的 ML 模型，我们需要设置一个<a class="ae mj" href="https://istio.io/docs/reference/config/networking/v1alpha3/service-entry/" rel="noopener ugc nofollow" target="_blank"> ServiceEntry </a>来允许从我们的 Tensorflow 服务部署到 S3 端点的出站流量:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建<code class="fe nx ny nz mv b">ServiceEntry</code>规则以允许出站流量通过定义的端口到达 S3 端点:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d4a0" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f resnet_egress.yaml</span><span id="6635" class="mz ky iq mv b gy ne nb l nc nd">serviceentry "aws-s3" created</span></pre><p id="dfde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">配置入口</strong></p><p id="22dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了允许传入流量进入我们的“网格”，我们需要<a class="ae mj" href="https://istio.io/docs/tasks/traffic-management/ingress/#configuring-ingress-using-an-istio-gateway" rel="noopener ugc nofollow" target="_blank">设置一个入口</a> <code class="fe nx ny nz mv b"><a class="ae mj" href="https://istio.io/docs/tasks/traffic-management/ingress/#configuring-ingress-using-an-istio-gateway" rel="noopener ugc nofollow" target="_blank">Gateway</a></code>。我们的<code class="fe nx ny nz mv b">Gateway</code>将通过公开端口<code class="fe nx ny nz mv b">31400</code>接收流量来充当负载平衡代理:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="f685" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过指定标签选择器<code class="fe nx ny nz mv b">istio=ingressgateway</code>使用 Istio 默认控制器，这样我们的入口网关 Pod 将是接收该网关配置并最终公开端口的设备。</p><p id="f694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建我们上面定义的<code class="fe nx ny nz mv b">Gateway</code>资源:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5730" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f resnet_gateway.yaml</span><span id="b57f" class="mz ky iq mv b gy ne nb l nc nd">gateway "resnet-serving-gateway" created</span></pre><h1 id="8e70" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">张量流服务</h1><p id="70b3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Tensorflow 服务提供灵活的 ML 服务架构，旨在为 gRPC/REST 端点上的 ML 模型提供服务。</p><p id="10f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将使用一个预先训练好的、导出的<a class="ae mj" href="https://github.com/tensorflow/models/tree/master/official/resnet#pre-trained-model" rel="noopener ugc nofollow" target="_blank"> ResNet 模型</a>作为我们在服务基础设施上部署的例子。</p><h2 id="d6c0" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">S3 模型库</h2><p id="a449" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了访问 ML 模型，Tensorflow Serving 将任意文件系统路径的<em class="kw">加载器</em>抽象为接口，并提供 GCS 和 S3 云存储文件系统的开箱即用实现。</p><p id="3a1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae mj" href="https://s3.console.aws.amazon.com/s3/home" rel="noopener ugc nofollow" target="_blank"> AWS 控制台</a>创建<code class="fe nx ny nz mv b">ml-models-repository</code> S3 桶，在桶上设置 IAM 用户和角色。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/11e78ca0d098fd91d4b570dd346112e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJrxYGjUOKHM4hRnlohRpQ.png"/></div></div></figure><p id="14b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<em class="kw">NHWC</em>T1】模型架构上传到<code class="fe nx ny nz mv b">ml-models-repository</code>桶中，目录结构如下:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9820" class="mz ky iq mv b gy na nb l nc nd">resnet/  <br/>  1/<br/>    saved_model.pb<br/>    variables/<br/>      variables.data-00000-of-00001<br/>      variables.index</span></pre><p id="ac8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了安全地从我们的桶中读取，使用 S3 访问凭证创建一个 Kubernetes 秘密:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1bb0" class="mz ky iq mv b gy na nb l nc nd">kubectl create secret generic s3-storage-creds \<br/>  --from-literal=access_id=$AWS_ACCESS_KEY_ID \<br/>  --from-literal=access_key=$AWS_SECRET_ACCESS_KEY</span><span id="29ee" class="mz ky iq mv b gy ne nb l nc nd">secret "s3-storage-creds" created</span></pre><h2 id="d5da" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">Kubernetes 部署</h2><p id="07eb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">以下清单将 Tensorflow 定义为 Kubernetes <code class="fe nx ny nz mv b">Deployment</code>，以<code class="fe nx ny nz mv b">Service</code>为前端，以公开服务器的 gRPC 和 REST 端点:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="1114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面清单定义中的一些要点需要注意:</p><ul class=""><li id="2568" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">展开有两个标签<code class="fe nx ny nz mv b">app=resnet-serving</code>和<code class="fe nx ny nz mv b">version=v1</code>。</li><li id="24cf" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">该服务选择并公开 gRPC 端口<code class="fe nx ny nz mv b">9000</code>和 REST 端口<code class="fe nx ny nz mv b">9001</code>的<code class="fe nx ny nz mv b">app=resnet-serving</code>标签上的部署。</li><li id="3b01" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">ConfigMap 中的<code class="fe nx ny nz mv b">model_config_list</code> <a class="ae mj" href="https://github.com/tensorflow/serving/blob/master/tensorflow_serving/config/model_server_config.proto#L19" rel="noopener ugc nofollow" target="_blank"> protobuf </a>可用于定义模型路径和版本策略；在我们的例子中，我们已经将模型固定在版本<code class="fe nx ny nz mv b">1</code>上进行加载。</li></ul><p id="ab99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将 Tensorflow 服务资源部署到集群中:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d05e" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f resnet_serving_v1.yaml</span><span id="014c" class="mz ky iq mv b gy ne nb l nc nd">deployment "resnet-serving" created<br/>service "resnet-serving" created<br/>configmap "tf-serving-models-config" created</span><span id="3715" class="mz ky iq mv b gy ne nb l nc nd"><br/>NAME                              READY     STATUS    RESTARTS   AGE<br/>resnet-serving-65b954c449-6s8kc   2/2       Running   0          11s</span></pre><p id="0b6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如所料，Pod 应显示有两个集装箱在其中运行，主<code class="fe nx ny nz mv b">tensorflow-serving</code>集装箱和<code class="fe nx ny nz mv b">istio-proxy</code>侧车。</p><p id="4f72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查 Pod 中的<code class="fe nx ny nz mv b">tensorflow-serving</code>容器日志，以验证服务器正在运行，并且已经成功加载了从我们的 S3 存储库中指定的模型:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6c0b" class="mz ky iq mv b gy na nb l nc nd">kubectl logs resnet-serving-65b954c449-6s8kc -c tensorflow-serving</span><span id="aecf" class="mz ky iq mv b gy ne nb l nc nd">2019-03-30 22:31:23.741392: I external/org_tensorflow/tensorflow/contrib/session_bundle/bundle_shim.cc:363] <strong class="mv ir">Attempting to load native SavedModelBundle in bundle-shim from: s3://ml-models-repository/resnet/1</strong></span><span id="9b37" class="mz ky iq mv b gy ne nb l nc nd">2019-03-30 22:31:23.741528: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:31] <strong class="mv ir">Reading SavedModel from: s3://ml-models-repository/resnet/1</strong></span><span id="e1db" class="mz ky iq mv b gy ne nb l nc nd">2019-03-30 22:31:33.864215: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:285] <strong class="mv ir">SavedModel load for tags { serve }; Status: success. Took 10122668 microseconds.</strong></span><span id="b8a2" class="mz ky iq mv b gy ne nb l nc nd">2019-03-30 22:31:37.616382: I tensorflow_serving/core/loader_harness.cc:86] <strong class="mv ir">Successfully loaded servable version {name: resnet version: 1}</strong></span><span id="ba72" class="mz ky iq mv b gy ne nb l nc nd">2019-03-30 22:31:37.622848: I tensorflow_serving/model_servers/server.cc:313] <strong class="mv ir">Running gRPC ModelServer at 0.0.0.0:9000 ...</strong></span><span id="ac45" class="mz ky iq mv b gy ne nb l nc nd">2019-03-30 22:31:37.626888: I tensorflow_serving/model_servers/server.cc:333] <strong class="mv ir">Exporting HTTP/REST API at:localhost:9001 ...</strong></span></pre><blockquote class="or os ot"><p id="75f0" class="jy jz kw ka b kb kc kd ke kf kg kh ki ou kk kl km ov ko kp kq ow ks kt ku kv ij bi translated">Tensorflow 服务中 S3 客户端的<a class="ae mj" href="https://github.com/tensorflow/serving/issues/789" rel="noopener ugc nofollow" target="_blank">错误导致大量垃圾警告日志。这可以通过设置<code class="fe nx ny nz mv b"><em class="iq">TF_CPP_MIN_LOG_LEVEL=3</em></code>环境变量来关闭。</a></p></blockquote><h1 id="1686" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模型部署和 Canary 推广</h1><p id="6805" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">到目前为止，我们已经用 Kubernetes、Istio 和 Tensorflow 服务建立了我们的基础设施。现在，我们可以开始对我们的模型进行版本控制，设置到指定部署的路由，然后利用 Istio 的流量分割规则执行模型服务器部署的阶段性 canary 部署。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/283bc5c47e1b60298443745c67165539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cxrn69TfiKoriOegyB9Ieg.png"/></div></div></figure><h2 id="763d" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">设置 V1 路由</h2><p id="026a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们需要设置流量规则，以便<code class="fe nx ny nz mv b">Gateway</code>在接收请求时知道路由到什么服务。</p><p id="61b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该规则由一个<code class="fe nx ny nz mv b">VirtualService</code>定义，它允许路由到目的地“网状”服务，而无需了解基础设施中的底层部署。下面的<code class="fe nx ny nz mv b">VirtualService</code>连接到我们之前定义的<code class="fe nx ny nz mv b">Gateway</code>上，将 100%的流量路由到端口<code class="fe nx ny nz mv b">9000.</code>上<code class="fe nx ny nz mv b">v1</code>子集的<code class="fe nx ny nz mv b">resnet-serving</code>。<code class="fe nx ny nz mv b">DestinationRule</code>资源用于定义<code class="fe nx ny nz mv b">VirtualService</code>的路由策略。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="dbd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用以下<code class="fe nx ny nz mv b">VirtualService</code>和<code class="fe nx ny nz mv b">DestinationRule</code>清单:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ee03" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f resnet_v1_routing.yaml</span><span id="bde1" class="mz ky iq mv b gy ne nb l nc nd">virtualservice "resnet-serving" created<br/>destinationrule "resnet-serving" created</span></pre><p id="1fab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们没有公开任何公共负载平衡器或者在我们的集群上设置 TLS。因此，目前可以在端口转发网关端口上发送测试流量:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="80e1" class="mz ky iq mv b gy na nb l nc nd">kubectl -n istio-system port-forward istio-ingressgateway-5b64fffc9f-xh9lg 31400:31400</span><span id="8955" class="mz ky iq mv b gy ne nb l nc nd">Forwarding from 127.0.0.1:31400 -&gt; 31400</span></pre><p id="4a22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用以下 Tensorflow 服务<a class="ae mj" href="https://gist.github.com/masroorhasan/5db291a6d1f7651758600873bc09ad37" rel="noopener ugc nofollow" target="_blank"> python gRPC 客户端</a>对输入图像进行预测请求:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="29e5" class="mz ky iq mv b gy na nb l nc nd">python tf_serving_client.py --port=31400 --image=images/001.jpg</span><span id="74da" class="mz ky iq mv b gy ne nb l nc nd">name: "resnet"<br/>version {<br/>  value: 1<br/>}<br/>signature_name: "serving_default"</span><span id="734e" class="mz ky iq mv b gy ne nb l nc nd">dtype: DT_INT64<br/>tensor_shape {<br/>  dim {<br/>    size: 1<br/>  }<br/>}<br/>int64_val: 228</span></pre><p id="f2ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行一个小负载测试，并在 Istio Mesh Grafana dashboard 上观察 p50、p90 和 p99 服务器端延迟:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/6a0f472f6fbfb767ee25b3a766dd09f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rc7uByjzEisuQ0vdUnpdoQ.png"/></div></div></figure><p id="e2b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种延迟时间非常糟糕，原因有几个:</p><ul class=""><li id="6702" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">(相对)低计算配置文件—每个节点 2 个 CPU。</li><li id="560a" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">Vanilla Tensorflow 服务二进制文件未针对底层 CPU 平台进行优化。</li></ul><p id="c5fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<a class="ae mj" href="https://mux.com/blog/" rel="noopener ugc nofollow" target="_blank"> Mux 工程博客</a>的以下帖子中，解释了构建 CPU 优化 Tensorflow 服务二进制的技术，以及针对延迟/吞吐量的性能调整。</p><div class="nf ng gp gr nh ni"><a href="https://mux.com/blog/tuning-performance-of-tensorflow-serving-pipeline/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">我们如何将 Tensorflow 服务性能提高 70%以上</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Tensorflow 已经发展成为事实上的 ML 平台，在行业和研究领域都很受欢迎。需求和支持…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">mux.com</p></div></div><div class="nr l"><div class="oz l nt nu nv nr nw jw ni"/></div></div></a></div><h2 id="b18f" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">模型部署 V2</h2><p id="9cf3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">比方说，我们的<code class="fe nx ny nz mv b">v1</code>模型表现不佳，我们希望部署新的模型版本以及优化的 TensorFlow 服务二进制文件。对模型部署的更改应该始终以迭代的方式进行，以便新模型的行为和性能可以在作为 GA 推广到所有客户端之前得到适当的测试和验证。</p><p id="413b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的新模型部署将使用新的<code class="fe nx ny nz mv b">Resnet-50 v2</code>模型和更新的 CPU 优化 Tensorflow 服务映像。</p><p id="8641" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<code class="fe nx ny nz mv b">ResNet-50 v2</code> <a class="ae mj" href="https://github.com/tensorflow/models/tree/master/official/resnet#pre-trained-model" rel="noopener ugc nofollow" target="_blank">保存的模型</a>上传到<code class="fe nx ny nz mv b">resnet/2/</code>路径下的 S3 桶中，目录层次与之前相同。然后，创建一个新的部署和配置图，它将加载并提供<code class="fe nx ny nz mv b">resent</code>模型的<code class="fe nx ny nz mv b">2</code>版本。</p><p id="5cd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与以前的清单相比，更改如下:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="352a" class="mz ky iq mv b gy na nb l nc nd">diff --git a/tf_serving.yaml b/tf_serving_v2.yaml<br/>index 90d133d..05047a3 100644<br/><strong class="mv ir">--- a/tf_serving.yaml<br/>+++ b/tf_serving_v2.yaml</strong></span><span id="2fe2" class="mz ky iq mv b gy ne nb l nc nd">@@ -1,10 +1,10 @@<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/><strong class="mv ir">-  name: resnet-serving<br/>+  name: resnet-serving-v2</strong><br/>@@ -13,7 +13,7 @@ spec:<br/>   metadata:<br/>     labels:<br/>       app: resnet-serving<br/><strong class="mv ir">-        version: v1<br/>+        version: v2<br/>    </strong>spec:<br/>      containers:<br/>       - name: tensorflow-serving<br/><strong class="mv ir">-        image: tensorflow/serving:latest<br/>+        image: masroorhasan/tensorflow-serving:cpu</strong></span><span id="d4fe" class="mz ky iq mv b gy ne nb l nc nd">@@ -55,32 +55,15 @@ spec:<br/>       volumes:<br/>       - name: tf-serving-models-config<br/>         configMap:<br/><strong class="mv ir">-          name: tf-serving-models-config<br/>+          name: tf-serving-models-config-v2</strong><br/>___<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/><strong class="mv ir">-  name: tf-serving-models-config<br/>+  name: tf-serving-models-config-v2</strong><br/>@@ -90,19 +73,8 @@ data:<br/>         model_platform: "tensorflow",<br/>         model_version_policy: {<br/>           specific: {<br/><strong class="mv ir">-            versions: 1<br/>+            versions: 2</strong></span></pre><p id="c888" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里可以找到<code class="fe nx ny nz mv b">v2</code>部署和配置图的完整清单<a class="ae mj" href="https://gist.github.com/masroorhasan/664948b1521df2a59f92833b776851ce" rel="noopener ugc nofollow" target="_blank">。这里需要注意一些重要部分:</a></p><ul class=""><li id="a581" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">新部署更新了版本标签<code class="fe nx ny nz mv b">version=v2</code>。</li><li id="b686" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">更新 Docker 镜像<code class="fe nx ny nz mv b">masroorhasan/tensorflow-serving:cpu</code> <strong class="ka ir"> </strong>是预建的 CPU 优化二进制。</li><li id="5554" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">ConfigMap 还与新版本策略相冲突，以专门获取模型的版本<code class="fe nx ny nz mv b">2</code>。</li></ul><p id="a107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将部署应用到群集:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0e52" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f resnet_serving_v2.yaml</span><span id="455e" class="mz ky iq mv b gy ne nb l nc nd">deployment "resnet-serving-v2" created<br/>configmap "tf-serving-models-config-v2" created</span></pre><p id="b5f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们不需要更新<code class="fe nx ny nz mv b">resnet-serving</code>服务，它在标签选择器<code class="fe nx ny nz mv b">app=resnet-serving</code>上位于两个部署的前面。</p><h2 id="baea" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">设置 V2 金丝雀路由</h2><p id="f659" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们已经有了新的模型部署，我们希望逐步向一部分用户推广它。</p><p id="65ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以通过更新我们的<code class="fe nx ny nz mv b">VirtualService</code>来实现，将一小部分流量路由到<code class="fe nx ny nz mv b">v2</code>子集。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d351" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将保持谨慎，更新我们的<code class="fe nx ny nz mv b">VirtualService</code>以将 30%的传入请求路由到<code class="fe nx ny nz mv b">v2</code>模型部署:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="accb" class="mz ky iq mv b gy na nb l nc nd">kubectl replace -f resnet_v2_canary.yaml</span><span id="d3c5" class="mz ky iq mv b gy ne nb l nc nd">virtualservice "resnet-serving" replaced<br/>destinationrule "resnet-serving" replaced</span></pre><p id="818e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行另一个负载测试，观察 Istio Mesh 仪表板，了解两个版本的<code class="fe nx ny nz mv b">resnet-serving</code>工作负载的延迟指标。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/89f424ceb85f0a620b9363d310bda05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQHNEzUWhQzZRl6HYlcVAQ.png"/></div></div></figure><p id="ce66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按目的地划分的请求显示了类似的模式，流量在<code class="fe nx ny nz mv b">resnet-serving</code>和<code class="fe nx ny nz mv b">resnet-serving-v2</code>部署之间分流。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/8cff203d824394440750a41e69140020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOuhIMmRXDH80Ez9Bt7kHQ.png"/></div></div></figure><h2 id="f5e2" class="mz ky iq bd kz ob oc dn ld od oe dp lh kj of og ll kn oh oi lp kr oj ok lt ol bi translated">设置 V2 路由</h2><p id="71ee" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一旦 canary 版本满足模型行为和性能阈值，部署就可以升级为面向所有用户的 GA。下面的<code class="fe nx ny nz mv b">VirtualService</code>和<code class="fe nx ny nz mv b">DestinationRule</code>被配置为将 100%的流量路由到我们的模型部署的<code class="fe nx ny nz mv b">v2</code>。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新路由规则，以将<code class="fe nx ny nz mv b">v2</code>提升为所有传入流量的 GA:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e214" class="mz ky iq mv b gy na nb l nc nd">kubectl replace -f resnet_v2_routing.yaml</span><span id="2eb7" class="mz ky iq mv b gy ne nb l nc nd">virtualservice "resnet-serving" replaced<br/>destinationrule "resnet-serving" replaced</span></pre><p id="d9de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个负载测试正在运行时，网格仪表板将显示流量完全从<code class="fe nx ny nz mv b">v1</code>转移，而是流入我们部署的<code class="fe nx ny nz mv b">v2</code>。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/823810b84cbc13bfabaabb2b4b7c43ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SO2MNDLzTjm1qQE9-ibJg.png"/></div></div></figure><h1 id="0328" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">自动化金丝雀释放</h1><p id="9704" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">到目前为止，我们已经对集群监控的模型性能进行了新模型版本的逐步、分阶段部署。然而，手动更新流量规则不符合操作可扩展性的精神。</p><p id="5edf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Istio 流量路由配置可用于通过编程调整下游服务版本之间流量的相对权重来执行 canary 发布。在本节中，我们将使用 Weaveworks 的开源渐进式金丝雀部署工具来自动化金丝雀部署:<a class="ae mj" href="https://docs.flagger.app/" rel="noopener ugc nofollow" target="_blank"> Flagger </a>。</p><p id="91b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Flagger 是一家 Kubernetes 运营商，它使用 Istio 和 App Mesh 流量路由功能，基于自定义的 Prometheus 指标，自动迭代部署和推广 canary 版本。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/52b01b7d511398ba2267db1d81484b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjqOyB1mUMDxyhkkzZitiQ.png"/></div></div></figure><p id="02b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们克隆 Flagger 存储库并创建服务帐户、CRD 和 Flagger 操作员:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="884f" class="mz ky iq mv b gy na nb l nc nd">git clone git@github.com:weaveworks/flagger.git</span></pre><p id="d057" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照以下顺序创建服务帐户、CRDs 和操作员:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d59c" class="mz ky iq mv b gy na nb l nc nd"># service accounts<br/>kubectl apply -f flagger/artifacts/flagger/account.yaml</span><span id="df17" class="mz ky iq mv b gy ne nb l nc nd"># CRD<br/>kubectl apply -f flagger/artifacts/flagger/crd.yaml</span><span id="c7de" class="mz ky iq mv b gy ne nb l nc nd"># Deployment<br/>kubectl apply -f flagger/artifacts/flagger/deployment.yaml</span></pre><p id="4db2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应该在<code class="fe nx ny nz mv b">istio-system</code>名称空间中创建 Flagger 部署。这是将对标有<code class="fe nx ny nz mv b">kind: Canary</code>的客户资源进行操作的主要操作员。</p><p id="07f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Flagger 采用了 Kubernetes 部署，如<code class="fe nx ny nz mv b">resnet-serving</code>，并创建了一系列资源，包括 Kubernetes 部署(初级 vs 金丝雀)、<code class="fe nx ny nz mv b">ClusterIP</code>服务和 Istio 虚拟服务。</p><p id="986d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于大量手动流量路由服务将由 Flagger 运营商负责，我们需要清理之前 Istio 流量路由相关资源和<code class="fe nx ny nz mv b">v2</code>服务部署的集群。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9cf2" class="mz ky iq mv b gy na nb l nc nd"># clean up routing<br/>kubectl delete -f resnet_v1_routing.yaml<br/>kubectl delete -f resnet_serving_v2.yaml<br/>kubectl delete -f resnet_v2_routing.yaml</span><span id="e2d1" class="mz ky iq mv b gy ne nb l nc nd"># clean up svc<br/>kubectl delete svc/resnet-serving</span></pre><p id="db33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义一个将引用我们的<code class="fe nx ny nz mv b">resnet-serving</code>模型部署的 Flagger Canary 定制资源:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0b99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用清单来创建 Canary 资源:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8fa1" class="mz ky iq mv b gy na nb l nc nd">kubectl apply -f flagger_canary.yaml</span><span id="b9fa" class="mz ky iq mv b gy ne nb l nc nd">canary "resnet-serving" created</span></pre><p id="ebf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，这将在创建一系列 Kubernetes 资源的同时初始化金丝雀。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pe"><img src="../Images/18c766510120d1d1026a6b9c20790ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mHaV_DcTdDR8UbE7gVeTA.png"/></div></div></figure><p id="0de3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要触发自动 canary 升级，请通过更新容器映像来触发部署:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d1bc" class="mz ky iq mv b gy na nb l nc nd">kubectl set image deployment/resnet-serving \<br/>  tensorflow-serving=masroorhasan/tensorflow-serving:cpu</span></pre><p id="0e28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，Flagger 操作员将检测到部署修订中的更改，并对新的部署进行排队:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/5f48209586e7a980395fe9f3c1be8bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuCzSP-myuS_8WdJTouXew.png"/></div></div></figure><p id="c860" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当 canary 部署升级为 GA 时，Flagger 将自动缩减旧部署。在部署期间应用对部署的更改将触发 Flagger 重新开始分析和重新部署。</p><h1 id="5f97" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包扎</h1><p id="28c7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这篇文章中，我们通过在 Kubernetes 基础设施上部署 TensorFlow 服务来构建一个 ML 服务环境。然后，我们利用 Istio 的智能流量路由功能，以分阶段部署的方式管理模型部署。最后，我们在集群上部署了 Flagger operator，以自动化分阶段部署 canary 的过程。</p><p id="9f9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我们选择关注 ML 模型的<em class="kw">服务</em>方面，但是有许多框架和工具可以帮助整合端到端的 ML 管道。其中一些包括(除其他外):</p><ul class=""><li id="bdd8" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae mj" href="http://kubeflow.org/" rel="noopener ugc nofollow" target="_blank"> Kubeflow </a>:在 Kubernetes 上提供内聚培训和服务基础设施的工具和框架的集合。</li><li id="e557" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://www.seldon.io/" rel="noopener ugc nofollow" target="_blank"> SeldonCore </a>:提供一个运行时 ML 图形引擎来管理 Kubernetes 上的服务 ML 模型。</li><li id="2392" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">Clipper :一个预测服务系统，供数据科学家在 Docker-only 或 Kubernetes 环境中使用。</li><li id="5dd6" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://pipeline.ai/" rel="noopener ugc nofollow" target="_blank"> Pipeline.ai </a>:汇集了许多流行的开源工具来构建、实验端到端的机器学习管道。</li><li id="77df" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">云 ML 服务:<a class="ae mj" href="https://cloud.google.com/ml-engine/\" rel="noopener ugc nofollow" target="_blank"> Google ML 引擎</a>、<a class="ae mj" href="https://docs.aws.amazon.com/sagemaker/latest/dg/how-it-works-mlconcepts.html" rel="noopener ugc nofollow" target="_blank"> AWS SageMaker </a>和<a class="ae mj" href="https://azure.microsoft.com/en-us/services/machine-learning-service/" rel="noopener ugc nofollow" target="_blank"> Azure ML 服务</a></li></ul></div><div class="ab cl pg ph hu pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ij ik il im in"><p id="0eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，我希望这篇文章有助于在 Kubernetes 上构建 TensorFlow 模型部署。我很想听听你对 ML 服务基础设施的设置——请随意联系 Twitter。感谢阅读！</p><p id="5b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考文献</strong></p><div class="nf ng gp gr nh ni"><a href="https://www.digitalocean.com/products/kubernetes/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">数字海洋上的 Kubernetes</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">在云中部署和管理容器工作负载的最简单方式。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">www.digitalocean.com</p></div></div><div class="nr l"><div class="pn l nt nu nv nr nw jw ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">服务模型| TFX | TensorFlow</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">TensorFlow 服务是一个灵活、高性能的机器学习模型服务系统，专为生产…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">www.tensorflow.org</p></div></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://istio.io/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">伊斯迪奥</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">连接、保护、控制和观察服务。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">istio.io</p></div></div><div class="nr l"><div class="po l nt nu nv nr nw jw ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://aws.amazon.com/s3/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">云对象存储|随处存储和检索数据|亚马逊简单存储服务</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">亚马逊简单存储服务(亚马逊 S3)是一种对象存储服务，提供行业领先的可扩展性、数据…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">aws.amazon.com</p></div></div><div class="nr l"><div class="pp l nt nu nv nr nw jw ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://mux.com/blog/tuning-performance-of-tensorflow-serving-pipeline/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">将 Tensorflow 性能提高 70%</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Tensorflow 已经发展成为事实上的 ML 平台，在行业和研究领域都很受欢迎。需求和支持…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">mux.com</p></div></div><div class="nr l"><div class="pq l nt nu nv nr nw jw ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://docs.flagger.app" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">介绍</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Flagger 是一家渐进式交付 Kubernetes 运营商</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">docs.flagger.app</p></div></div><div class="nr l"><div class="pr l nt nu nv nr nw jw ni"/></div></div></a></div></div></div>    
</body>
</html>