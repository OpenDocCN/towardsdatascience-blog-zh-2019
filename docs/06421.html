<html>
<head>
<title>Why not Mean Squared Error(MSE) as a loss function for Logistic Regression? 🤔</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不把均方差(MSE)作为 Logistic 回归的损失函数？🤔</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-not-mse-as-a-loss-function-for-logistic-regression-589816b5e03c?source=collection_archive---------3-----------------------#2019-09-15">https://towardsdatascience.com/why-not-mse-as-a-loss-function-for-logistic-regression-589816b5e03c?source=collection_archive---------3-----------------------#2019-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="341f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">作者:</strong><a class="ko kp ep" href="https://medium.com/u/b81bfc8a2350?source=post_page-----589816b5e03c--------------------------------" rel="noopener" target="_blank"/>*，<a class="ko kp ep" href="https://medium.com/u/629a094c91b8?source=post_page-----589816b5e03c--------------------------------" rel="noopener" target="_blank"> Souradip Chakraborty </a> * (*表示同等贡献)。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/362972e150410f05d6fc9103edd99231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy95jZ6ff8vdujww5XgKng.png"/></div></div></figure><blockquote class="lc ld le"><p id="4c4c" class="jq jr lf js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">在这篇博文中，我们主要比较了逻辑回归的“<strong class="js iu">对数损失</strong>与<strong class="js iu">“均方误差”</strong>，并基于经验和数学分析，说明了为什么同样推荐使用<strong class="js iu">对数损失</strong>。</p></blockquote><p id="5947" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两个损失函数的等式如下:</p><p id="3553" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">日志丢失:</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lj"><img src="../Images/0ba7e28786a5e7719227efba2d9c7fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zU7AU2zALgFKl1DGoxPLWQ.png"/></div></div></figure><p id="aa4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">均方损失:</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lk"><img src="../Images/3fbd090db9e2b636d842ead66157dd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCRKJJPz-0O04a_cH7N-JQ.png"/></div></div></figure><p id="57fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的两个等式中</p><p id="39ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">y:实际标签</p><p id="b1b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ŷ:预测值</p><p id="3998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">n:类别数</p><p id="f5d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个包含 2 个类(n = 2)的数据集，标签分别表示为<strong class="js iu">“0”</strong>和<strong class="js iu">“1”。</strong></p><p id="71a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们计算预测值和实际标签完全不匹配时的损失值，并了解 log-loss 如何优于 MSE。</p><p id="117b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">比如:</strong></p><p id="034d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比方说</p><ul class=""><li id="d78d" class="ll lm it js b jt ju jx jy kb ln kf lo kj lp kn lq lr ls lt bi translated">数据集中给定样本的实际标签是“1”</li><li id="51de" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn lq lr ls lt bi translated">应用 sigmoid 函数= 0 后模型的预测</li></ul><p id="05c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用 MSE 时的损失值:</strong></p><p id="1fe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">(1- 0)² = 1</p><p id="6ad3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用测井损耗时的损耗值:</strong></p><p id="4fde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在插入损耗方程的值之前，我们可以看看<strong class="js iu"> <em class="lf"> log(x) </em> </strong>的图形是什么样的。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/8382b539eea5973a17ee4d28f768fd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*gFI_OkR7RfjiJkWe.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk"><strong class="bd me">Figure 3: f(x) = log(x)</strong></figcaption></figure><p id="88c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图可以看出随着<strong class="js iu"> x 趋于 0，</strong> <strong class="js iu"> <em class="lf"> log(x)趋于-无穷大。</em> </strong></p><p id="0f51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，损失值为:</p><p id="08e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf"> -(1 * log(0) + 0 * log(1) ) =趋于无穷大！！</em> </strong></p><p id="62fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">如上所述，与使用对数损失函数计算的损失值相比，使用 MSE 的损失值要小得多。因此，对我们来说非常清楚的是，MSE 不会强烈地惩罚错误分类，即使是完美的不匹配！</em> </strong></p><p id="b936" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果预测值和实际标签完全匹配，则两个损失值都将为“0”，如下所示。</p><p id="5eb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际标签:<strong class="js iu">“1”</strong></p><p id="26ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">预测:<strong class="js iu">“1”</strong></p><p id="9b79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf"> MSE: (1 - 1) = 0 </em> </strong></p><p id="f603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">日志损失:-(1 * Log(1)+0 * Log(0))= 0</em></strong></p><p id="9955" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">这里我们已经说明了 MSE 对于二元分类问题并不是一个很好的选择。但是如果目标值是一次性编码的，这同样可以扩展到多类分类问题。</em>T59】</strong></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="965f" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">Logistic 回归中的均方误差和非凸性问题。</h1><p id="e783" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">在分类场景中，我们经常使用基于梯度的技术(牛顿拉夫森，梯度下降等..)通过最小化损失函数来找到系数的最佳值。因此，如果损失函数不是凸的，就不能保证我们总是达到全局最小值，而是我们可能会陷入局部最小值。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c1d8a7328b359b906565405ce872c136.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/0*vTqhydzUxLusIx9v.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Figure 4: Convex and non-Convex functions</figcaption></figure><p id="8066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在深入探讨为什么 MSE 在逻辑回归中使用时不是凸函数之前，首先，我们来看看函数是凸的条件是什么。</p><p id="4a55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定义在一个<a class="ae nq" href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Multi-dimensional_intervals" rel="noopener ugc nofollow" target="_blank">n 维区间</a>上的一个<a class="ae nq" href="https://en.wikipedia.org/wiki/Real-valued_function" rel="noopener ugc nofollow" target="_blank">实值函数</a>，如果函数的<a class="ae nq" href="https://en.wikipedia.org/wiki/Graph_of_a_function" rel="noopener ugc nofollow" target="_blank">图上任意两点之间的</a><a class="ae nq" href="https://en.wikipedia.org/wiki/Line_segment" rel="noopener ugc nofollow" target="_blank">线段</a>位于图的上方或图上，则称该函数为<strong class="js iu">凸</strong>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nr"><img src="../Images/71c4073941a13dd78521c13ded11e04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sifm_z3Nx-YEBvws.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Figure 5: Convexity of a function</figcaption></figure><p id="c2c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<strong class="js iu"> f </strong>是两次可微的，并且定义域是实直线，那么我们可以将它刻画如下:</p><p id="1b70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> f </strong>为<strong class="js iu"> </strong>凸当且仅当<strong class="js iu">f”(x)≥0</strong>对于所有<strong class="js iu"> <em class="lf"> x </em> </strong> <em class="lf">。因此，如果我们能证明损失函数的二重导数≥ 0，那么我们就可以说它是凸的。</em>  <em class="lf">更多详情，可以参考</em> <a class="ae nq" href="https://www.youtube.com/watch?v=u8JrE9JlZPM" rel="noopener ugc nofollow" target="_blank"> <em class="lf">这段视频。</em> </a></p><p id="9f4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们从数学上证明了逻辑回归的 MSE 损失函数是非凸的。</p><p id="7735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简单起见，我们假设对于给定的数据集，我们有一个特征<strong class="js iu">【x】</strong>和<strong class="js iu">【二进制标签】</strong>。在下图<strong class="js iu">中，f(x) = MSE </strong>，ŷ是应用 sigmoid 函数后获得的预测值。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ns"><img src="../Images/c63be78fa01927db6c80a8543768a6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOVd6NRlWZvNTAZbk0oV0g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Figure 6: MSE double derivative</figcaption></figure><p id="e0a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的等式中，<strong class="js iu"> ŷ * (1 - ŷ) </strong>位于[0，1]之间。因此，我们必须检查<strong class="js iu"> H(ŷ) </strong>对于<strong class="js iu">“x”</strong>的所有值是否为正，是否为凸函数。</p><p id="3a00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们知道<strong class="js iu"> y </strong>可以取两个值<strong class="js iu"> 0 </strong>或<strong class="js iu"> 1。让我们检查两种情况下的凸性条件。</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nt"><img src="../Images/dddb36d0ffa35c8e85b6c3fc20b6ac4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoY50BDq57x0SF16zRim-g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Figure 7: Double derivate of MSE when y=0</figcaption></figure><p id="32a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以在上述情况下，当 y = 0 时，从方程中可以清楚地看出，当 ŷ位于区间<strong class="js iu">【0，2/3】</strong>时，函数<strong class="js iu">【h(ŷ】</strong><strong class="js iu">≥0，当 ŷ位于区间<strong class="js iu">【2/3，1】</strong>时，函数<strong class="js iu">【h(ŷ)≤0。</strong>这说明函数不是凸的。</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nu"><img src="../Images/d40cdc37fe781d2c85f426dc0f29697e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oro7dr2nUZtUdZfopIZ_4A.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Figure 8: Double derivative of MSE when y=1</figcaption></figure><p id="6f14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当<strong class="js iu"> y = 1 </strong>时，从等式中可以清楚地看出，当 ŷ位于区间<strong class="js iu">【0，1/3】</strong>时，函数<strong class="js iu"> H(ŷ) </strong> ≤ <strong class="js iu"> 0，当 ŷ位于区间<strong class="js iu">【1/3，1】</strong>时，函数<strong class="js iu"> H(ŷ) ≥ 0。</strong>这也说明函数是不凸的。</strong></p><p id="9a02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，基于凸性定义，我们从数学上证明了逻辑回归的 MSE 损失函数是非凸的，不推荐使用。</p><p id="5c50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是“对数损失”函数的<strong class="js iu">凸性问题！！我们将从数学上证明对数损失函数对于逻辑回归是凸的。</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nv"><img src="../Images/771d735810af5fc4cface08ce6e63ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpLPxK-4YJRDiqEHtBylkQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Figure 9: Double derivative of log loss</figcaption></figure><p id="2b66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">θ:自变量“x”的系数。</p><p id="e4ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如最终表达式(对数损失函数的双导数)所示，平方项总是≥0，而且，一般来说，我们知道<strong class="js iu"> e^x </strong>的范围是<strong class="js iu"> (0，无穷大)。因此，最终项总是≥0，这意味着在这种情况下对数损失函数是凸的！！T29】</strong></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="2759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">最终想法:</strong></p><p id="f6a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望这篇文章能够让你理解在逻辑回归中使用 MSE 作为损失函数的缺点。<strong class="js iu"> <em class="lf"> </em> </strong>如果您有任何想法、意见或问题，请在下面留下评论或在 LinkedIn 上联系我们，别忘了点击👏如果你喜欢邮报。</p><div class="nw nx gp gr ny nz"><a href="https://www.linkedin.com/in/rajeshshreedhar/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Rajesh Shreedhar Bhat -数据科学家-印度沃尔玛实验室| LinkedIn</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">查看 Rajesh Shreedhar Bhat 在世界上最大的职业社区 LinkedIn 上的个人资料。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.linkedin.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on la nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://www.linkedin.com/in/souradip-chakraborty/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Souradip Chakraborty -统计分析师-沃尔玛印度实验室| LinkedIn</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">查看 Souradip Chakraborty 在全球最大的职业社区 LinkedIn 上的个人资料。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.linkedin.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on la nz"/></div></div></a></div><p id="98e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考资料:</p><div class="nw nx gp gr ny nz"><a href="https://en.wikipedia.org/wiki/Convex_function" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">凸函数</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在数学中，定义在 n 维区间上的实值函数称为凸(或下凸或…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">en.wikipedia.org</p></div></div><div class="oi l"><div class="op l ok ol om oi on la nz"/></div></div></a></div></div></div>    
</body>
</html>