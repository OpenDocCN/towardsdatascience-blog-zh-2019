<html>
<head>
<title>Twitter data collection tutorial using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 的 Twitter 数据收集教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/twitter-data-collection-tutorial-using-python-3267d7cfa93e?source=collection_archive---------0-----------------------#2019-12-14">https://towardsdatascience.com/twitter-data-collection-tutorial-using-python-3267d7cfa93e?source=collection_archive---------0-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“没有数据，你只是另一个有观点的人”——w·爱德华兹·戴明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06e4d9af19aa80f5cf28253c41842428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8jvOd0T1E3oTKiDd"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Carlos Muza</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的一年里，我在 Twitter 上变得更加活跃，随着互动次数的增加，我需要回答一些基本问题，比如:</p><ul class=""><li id="6e5e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我的追随者来自哪里？</li><li id="2e33" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我的推文平均有多少赞？</li><li id="21b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我关注的客户分布情况如何？</li></ul><p id="de0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我认为这可能是一个有趣的编程练习。但是在我进行任何分析之前，我们需要收集所需的数据。</p><p id="4be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将学习如何使用 Twitter 的 API 和一些 Python 库来收集 Twitter 数据。我们将介绍如何设置开发环境、连接 Twitter 的 API 以及收集数据。</p><p id="acc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于“只给我看代码”的人来说，这是笔记本:</p><div class="mj mk gp gr ml mm"><a href="https://colab.research.google.com/drive/1cwefy0vNKHjW_XUZeyvKvc0U-no3gKGt#scrollTo=EaGv0ePkydNz" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">谷歌联合实验室</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">编辑描述</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">colab.research.google.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><h1 id="325c" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">工具和 Python 库</h1><p id="a29e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">这是我们将使用的工具清单</p><ul class=""><li id="9b9a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">用于开发环境的 Google Colab </strong></li><li id="e1fb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> Google Drive </strong>存储数据</li></ul><p id="4a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是免费的，只需一个基本的谷歌账户，将有助于让事情变得简单。</p><p id="f1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于 Python 库，下面是我们需要的</p><ul class=""><li id="c018" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://tweepy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> tweepy </strong> </a>用于使用 Python 访问 Twitter API。</li><li id="69c7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> google.colab </strong>将 Google Drive 链接到 colab 笔记本</li><li id="297f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> json </strong>用于加载和保存<code class="fe ny nz oa ob b">json</code>文件</li><li id="3cdc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> csv </strong>用于加载和保存<code class="fe ny nz oa ob b">csv</code>文件</li><li id="c7c7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">日期时间</strong>用于处理日期数据</li><li id="68c2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">时间</strong>为定时代码执行</li></ul><p id="bd4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将导入我们需要的所有库，如下所示</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="3534" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Import all needed libraries</strong></span><span id="b113" class="og nc it ob b gy ol oi l oj ok">import tweepy                   <strong class="ob iu"># Python wrapper around Twitter API</strong><br/>from google.colab import drive  <strong class="ob iu"># to mount Drive to Colab notebook</strong><br/>import json<br/>import csv<br/>from datetime import date<br/>from datetime import datetime<br/>import time</span></pre><h1 id="4db9" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">将 Google Drive 连接到 Colab</h1><p id="194c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">要将 Google Drive <em class="om">(存储数据的地方)</em>连接到 Colab 笔记本<em class="om">(处理数据的地方)</em>运行以下命令。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="31fe" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Connect Google Drive to Colab<br/></strong>drive.mount('/content/gdrive')</span><span id="6e1d" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu"># Create a variable to store the data path on your drive<br/></strong>path = './gdrive/My Drive/path/to/data'</span></pre><p id="104b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行上面的代码块将提示您跟随一个 URL 来验证您的帐户，并允许 Google Drive 和 Colab 之间的数据流。只需点击提示，当硬盘安装成功时，您将在笔记本中收到一条消息。</p><h1 id="2751" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">向 Twitter 的 API 认证</h1><p id="5900" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">首先，<a class="ae ky" href="https://developer.twitter.com/en/apply-for-access" rel="noopener ugc nofollow" target="_blank">申请一个开发者账号</a>访问 API。对于本教程来说，标准 API 已经足够了。它们是免费的，但是有一些限制，我们将在本教程中学习如何解决。</p><p id="42ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置好您的开发者账户后，点击右上角的用户名打开下拉菜单，然后点击<em class="om">“应用”</em>，创建一个将使用 API 的应用，如下所示。然后选择<em class="om">“创建应用”</em>，并填写表格。出于本教程的目的，使用 Google Colab 笔记本的 URL 作为应用程序的 URL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/0079be3b872fced3893d8b4fc97cd803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZU1rUUZZq34fMSKARDuhVw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Select “Apps” from the top right corner once you log into your developer account</figcaption></figure><p id="fc0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经创建了一个开发人员帐户和一个应用程序，您应该有一组连接到 Twitter API 的密钥。具体来说，你会有一个</p><ul class=""><li id="fd00" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">API 密钥</li><li id="3a5d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">API 密钥</li><li id="4191" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">访问令牌</li><li id="7f26" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">访问令牌秘密</li></ul><p id="14ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些可以直接插入到您的代码中，或者从外部文件加载以连接到 Twitter API，如下所示。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="7e48" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Load Twitter API secrets from an external JSON file<br/></strong>secrets = json.loads(open(path + 'secrets.json').read())<br/>api_key = secrets['api_key']<br/>api_secret_key = secrets['api_secret_key']<br/>access_token = secrets['access_token']<br/>access_token_secret = secrets['access_token_secret']</span><span id="1695" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu"># Connect to Twitter API using the secrets<br/></strong>auth = tweepy.OAuthHandler(api_key, api_secret_key)<br/>auth.set_access_token(access_token, access_token_secret)<br/>api = tweepy.API(auth)</span></pre><h1 id="1c6d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">Twitter 数据收集</h1><h2 id="d261" class="og nc it bd nd oo op dn nh oq or dp nl li os ot nn lm ou ov np lq ow ox nr oy bi translated">概观</h2><p id="df7d" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们将创建函数来收集</p><ul class=""><li id="ebc3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> Tweets: </strong>这也包括转发，以及作为<a class="ae ky" href="https://developer.twitter.com/en/docs/tweets/data-dictionary/overview/tweet-object" rel="noopener ugc nofollow" target="_blank"> Tweet 对象</a>收集的回复。</li><li id="17a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">关注者:</strong>作为<a class="ae ky" href="https://developer.twitter.com/en/docs/tweets/data-dictionary/overview/user-object" rel="noopener ugc nofollow" target="_blank">用户对象</a>收集的所有关注者信息。</li><li id="1a67" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">关注:</strong>我关注的所有账户的信息<em class="om">(又名好友)</em>收集为<a class="ae ky" href="https://developer.twitter.com/en/docs/tweets/data-dictionary/overview/user-object" rel="noopener ugc nofollow" target="_blank">用户对象</a>。</li><li id="0a2e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">今日统计:</strong>当日跟随者及跟随者统计。</li></ul><p id="b005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们将创建两个助手函数来简化我们的工作</p><ul class=""><li id="22b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">保存 JSON: </strong>将收集到的数据保存在 Google Drive 上的<code class="fe ny nz oa ob b">json</code>文件中</li><li id="f621" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">速率限制处理:</strong>管理免费版本附带的 Twitter API 限制，主要是 15 分钟内允许的 API 调用数量。</li></ul><h2 id="1fad" class="og nc it bd nd oo op dn nh oq or dp nl li os ot nn lm ou ov np lq ow ox nr oy bi translated">助手功能</h2><p id="cfe0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><strong class="lb iu">保存 JSON </strong></p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="0ce2" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Helper function to save data into a JSON file<br/># file_name: the file name of the data on Google Drive<br/># file_content: the data you want to save</strong></span><span id="0c6d" class="og nc it ob b gy ol oi l oj ok">def save_json(file_name, file_content):<br/>  with open(path + file_name, 'w', encoding='utf-8') as f:<br/>    json.dump(file_content, f, ensure_ascii=False, indent=4)</span></pre><p id="a222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">费率限额处理</strong></p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="8c4c" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Helper function to handle twitter API rate limit</strong></span><span id="520a" class="og nc it ob b gy ol oi l oj ok">def limit_handled(cursor, list_name):<br/>  while True:<br/>    try:<br/>      yield cursor.next()</span><span id="7f53" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">    # Catch Twitter API rate limit exception and wait for 15 minutes</strong><br/>    except tweepy.RateLimitError:<br/>      print("\nData points in list = {}".format(len(list_name))))<br/>      print('Hit Twitter API rate limit.')<br/>      for i in range(3, 0, -1):<br/>        print("Wait for {} mins.".format(i * 5))<br/>        time.sleep(5 * 60)</span><span id="4b8f" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">    # Catch any other Twitter API exceptions</strong><br/>    except tweepy.error.TweepError:<br/>      print('\nCaught TweepError exception' )</span></pre><p id="08d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解开这段代码，让我们从定义什么是<em class="om">光标</em>开始。下面是来自<a class="ae ky" href="https://tweepy.readthedocs.io/en/latest/cursor_tutorial.html" rel="noopener ugc nofollow" target="_blank"> Tweepy 文档</a>的介绍:</p><blockquote class="oz pa pb"><p id="9cf3" class="kz la om lb b lc ld ju le lf lg jx lh pc lj lk ll pd ln lo lp pe lr ls lt lu im bi translated">我们在 Twitter API 开发中大量使用分页。遍历时间表、用户列表、直接消息等。为了执行分页，我们必须为每个请求提供一个 page/cursor 参数。这里的问题是这需要大量的 boiler plate 代码来管理分页循环。<strong class="lb iu">为了使分页更容易，需要更少的代码，Tweepy 有了光标对象。</strong></p></blockquote><p id="e2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的解释是，Cursor 对象是 Tweepy 管理和传递跨多页数据的方式，就像您最喜欢的书的内容分布在多页上一样。</p><p id="12c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点，上面的函数首先请求下一个数据指针(或页面)。如果在过去 15 分钟内收集的数据量超过了 API 限制，就会引发一个<code class="fe ny nz oa ob b">tweepy.RateLimitError</code>异常，在这种情况下，代码将等待 15 分钟。最后一个异常是为了捕捉执行过程中可能出现的任何其他<code class="fe ny nz oa ob b">tweepy.error.TweepError</code>，比如 Twitter API 的连接错误。</p><h2 id="73ce" class="og nc it bd nd oo op dn nh oq or dp nl li os ot nn lm ou ov np lq ow ox nr oy bi translated">数据收集功能</h2><p id="f51a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><strong class="lb iu">推文</strong></p><p id="b036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将重用 Github 上稍加修改的实现</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="246f" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Helper function to get all tweets of a specified user<br/># NOTE:This method only allows access to the most recent 3200 tweets<br/># Source: </strong><a class="ae ky" href="https://gist.github.com/yanofsky/5436496" rel="noopener ugc nofollow" target="_blank"><strong class="ob iu">https://gist.github.com/yanofsky/5436496</strong></a></span><span id="d14d" class="og nc it ob b gy ol oi l oj ok">def get_all_tweets(screen_name):</span><span id="a1e2" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # initialize a list to hold all the Tweets</strong><br/>  alltweets = []</span><span id="c213" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # make initial request for most recent tweets <br/>  # (200 is the maximum allowed count)<br/>  </strong>new_tweets = api.user_timeline(screen_name = screen_name,count=200)</span><span id="19b5" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # save most recent tweets</strong><br/>  alltweets.extend(new_tweets)</span><span id="304b" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # save the id of the oldest tweet less one to avoid duplication</strong><br/>  oldest = alltweets[-1].id - 1</span><span id="a7ef" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # keep grabbing tweets until there are no tweets left</strong><br/>  while len(new_tweets) &gt; 0:<br/>    print("getting tweets before %s" % (oldest))</span><span id="1204" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">    # all subsequent requests use the max_id param to prevent<br/>    # duplicates</strong><br/>    new_tweets = api.user_timeline(screen_name = screen_name,count=200,max_id=oldest)</span><span id="2d72" class="og nc it ob b gy ol oi l oj ok">    <strong class="ob iu"># save most recent tweets</strong><br/>    alltweets.extend(new_tweets)</span><span id="720f" class="og nc it ob b gy ol oi l oj ok">    <strong class="ob iu"># update the id of the oldest tweet less one</strong><br/>    oldest = alltweets[-1].id - 1<br/>    print("...%s tweets downloaded so far" % (len(alltweets)))<br/><strong class="ob iu">    ### END OF WHILE LOOP ###</strong></span><span id="227a" class="og nc it ob b gy ol oi l oj ok">  <strong class="ob iu"># transform the tweepy tweets into a 2D array that will <br/>  # populate the csv<br/>  </strong>outtweets = [[tweet.id_str, tweet.created_at, tweet.text, tweet.favorite_count,tweet.in_reply_to_screen_name, tweet.retweeted] for tweet in alltweets]</span><span id="da4b" class="og nc it ob b gy ol oi l oj ok">  <strong class="ob iu">#</strong> <strong class="ob iu">write the csv</strong><br/>  with open(path + '%s_tweets.csv' % screen_name, 'w') as f:<br/>    writer = csv.writer(f)<br/>    writer.writerow(["id","created_at","text","likes","in reply to","retweeted"])<br/>    writer.writerows(outtweets)<br/>  pass</span></pre><p id="f066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码块基本上由两部分组成:一个 while 循环用于收集列表中的所有 tweet，以及一些命令用于将 tweet 保存到一个<code class="fe ny nz oa ob b">csv</code>文件中。</p><p id="9247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们解释 while 循环中发生了什么之前，让我们先了解一下使用的两个关键方法</p><ul class=""><li id="0087" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ny nz oa ob b">api.user_timeline([,count][,max_id])</code>返回指定用户最近的推文。<code class="fe ny nz oa ob b">count</code>参数指定了我们希望一次检索的推文数量，最多 200 条。<code class="fe ny nz oa ob b">max_id</code>参数告诉该方法只返回 ID 小于(即早于)或等于指定 ID 的 tweets。</li><li id="348a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ny nz oa ob b">list.extend(<em class="om">iterable</em>)</code>将<code class="fe ny nz oa ob b"><em class="om">iterable</em></code> <em class="om"> </em>中的所有项目添加到列表中，不像<code class="fe ny nz oa ob b">append</code>只将单个元素添加到列表的末尾。</li></ul><p id="73e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们分析一下 while 循环中发生了什么</p><ol class=""><li id="61fd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu pf mb mc md bi translated">这里有三个变量:<code class="fe ny nz oa ob b">alltweets</code>是一个存储所有收集的 tweet 的列表，<code class="fe ny nz oa ob b">new_tweets</code>是一个存储最新一批收集的 tweet 的列表，因为我们一次只能检索 200 条 tweet，而<code class="fe ny nz oa ob b">oldest</code>存储我们迄今检索的最早的 tweet 的 ID，所以下一批检索的 tweet 在它之前。</li><li id="4a22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pf mb mc md bi translated">变量在循环开始前被初始化。注意，如果指定的用户没有任何 tweets，<code class="fe ny nz oa ob b">new_tweets</code>将为空，循环将不会执行。</li><li id="ba93" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pf mb mc md bi translated">在每次迭代中，检索在<code class="fe ny nz oa ob b">oldest</code>之前发布的 200 条推文的新列表，并将其添加到<code class="fe ny nz oa ob b">alltweets</code>。</li><li id="c903" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pf mb mc md bi translated">while 循环将继续迭代，直到在<code class="fe ny nz oa ob b">oldest</code>之前没有找到 tweet，或者达到 3200 条 tweet 的<a class="ae ky" href="https://developer.twitter.com/en/docs/tweets/timelines/api-reference/get-statuses-user_timeline" rel="noopener ugc nofollow" target="_blank">限制。</a></li></ol><p id="1585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了将 tweet 数据写入一个<code class="fe ny nz oa ob b">csv</code>文件，我们首先从每条 tweet 中提取我们关心的信息。这是通过使用一个列表理解来完成的，在这个列表中，我们将 tweet ID、文本和赞数等信息捕获到一个名为<code class="fe ny nz oa ob b">outtweets</code>的新列表中。最后，我们打开一个<code class="fe ny nz oa ob b">CSV</code>文件，首先用我们的表的标题名写一行，然后在下面的行中写<code class="fe ny nz oa ob b">outtweets</code>中的所有数据。</p><p id="db38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">追随者</strong></p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="3bd6" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Function to save follower objects in a JSON file.</strong></span><span id="9715" class="og nc it ob b gy ol oi l oj ok">def get_followers():<br/><strong class="ob iu">  <br/>  # Create a list to store follower data<br/>  </strong>followers_list = []</span><span id="fe23" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # For-loop to iterate over tweepy cursors<br/>  </strong>cursor = tweepy.Cursor(api.followers, count=200).pages()<strong class="ob iu"><br/>  </strong>for i, page in enumerate(limit_handled(cursor, followers_list)):  <br/>    print("\r"+"Loading"+ i % 5 *".", end='')<br/>    <br/>    <strong class="ob iu"># Add latest batch of follower data to the list</strong><br/>    followers_list += page<br/>  <br/><strong class="ob iu">  # Extract the follower information</strong><br/>  followers_list = [x._json for x in followers_list]</span><span id="62a5" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # Save the data in a JSON file</strong><br/>  save_json('followers_data.json', followers_list)</span></pre><p id="01bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们使用了上面创建的助手函数。此外，<code class="fe ny nz oa ob b">tweepy.Cursor(api.followers, count=200).pages()</code>创建一个 Cursor 对象，一次返回 200 个关注者的数据。我们现在可以将这个光标和<code class="fe ny nz oa ob b">followers_list</code>一起传递给我们的<code class="fe ny nz oa ob b">limited_handled</code>函数。注意，检索到的用户对象包含两个键<code class="fe ny nz oa ob b">_api</code>和<code class="fe ny nz oa ob b">_json</code>，因此我们只需使用 List comprehension <code class="fe ny nz oa ob b">[x._json for x in followers_list]</code>提取我们关心的数据。</p><p id="2221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">跟随</strong></p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="2910" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Function to save friend objects in a JSON file.</strong></span><span id="4370" class="og nc it ob b gy ol oi l oj ok">def get_friends():<br/><strong class="ob iu">  <br/>  # Create a list to store friends data<br/>  </strong>friends_list = []</span><span id="0970" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # For-loop to iterate over tweepy cursors<br/>  </strong>cursor = tweepy.Cursor(api.friends, count=200).pages()<strong class="ob iu"><br/>  </strong>for i, page in enumerate(limit_handled(cursor, friends_list)):  <br/>    print("\r"+"Loading"+ i % 5 *".", end='')<br/>    <br/>    <strong class="ob iu"># Add latest batch of friend data to the list</strong><br/>    friends_list += page<br/>  <br/><strong class="ob iu">  # Extract the friends information</strong><br/>  friends_list = [x._json for x in friends_list]</span><span id="d45d" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # Save the data in a JSON file</strong><br/>  save_json('friends_data.json', friends_list)</span></pre><p id="5b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，这与我们的<code class="fe ny nz oa ob b">get_followers()</code>函数完全一样，只是我们使用<code class="fe ny nz oa ob b">api.friends</code>来定义我们的光标对象，因此我们可以检索我们所关注的用户的数据。</p><p id="ab8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">今天的统计数据</strong></p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="371b" class="og nc it ob b gy oh oi l oj ok"><strong class="ob iu"># Function to save daily follower and following counts in a JSON file</strong></span><span id="d3ec" class="og nc it ob b gy ol oi l oj ok">def todays_stats(dict_name):</span><span id="9c86" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # Get my account information</strong><br/>  info = api.me()</span><span id="75e1" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # Get follower and following counts</strong><br/>  followers_cnt = info.followers_count  <br/>  following_cnt = info.friends_count</span><span id="7b69" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # Get today's date</strong><br/>  today = date.today()<br/>  d = today.strftime("%b %d, %Y")</span><span id="2fb7" class="og nc it ob b gy ol oi l oj ok"><strong class="ob iu">  # Save today's stats only if they haven't been collected before</strong><br/>  if d not in dict_name:<br/>    dict_name[d] = {"followers":followers_cnt, "following":following_cnt}<br/>    save_json("follower_history.json", dict_name)<br/>  else:<br/>    print('Today\'s stats already exist')</span></pre><p id="17e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">api.me()</code>返回认证用户的信息，在本例中是我。从那里，收集追随者和以下计数是简单的。我指定的日期格式<code class="fe ny nz oa ob b">%b %d, %Y</code>将以类似于<em class="om">2019 年 11 月 11 日、</em>的格式返回日期。有许多格式可供选择。</p><h1 id="7f38" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结束语</h1><p id="87a0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我希望你喜欢这篇介绍 Twitter 数据收集的教程。写这篇文章对澄清我对自己代码的理解很有帮助。例如，我更好地理解了 tweepy 光标对象。这让我想起了那句名言</p><blockquote class="pg"><p id="a576" class="ph pi it bd pj pk pl pm pn po pp lu dk translated">如果你想学什么，就去教它</p></blockquote></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在寻找提高写作的方法，所以如果你有任何反馈或想法，请随时分享。感谢阅读！</p></div></div>    
</body>
</html>