<html>
<head>
<title>Serverless TensorFlow workflow with EC2 auto-training</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带 EC2 自动训练的无服务器 TensorFlow 工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serverless-tensorflow-workflow-with-ec2-auto-training-495f47bd892d?source=collection_archive---------22-----------------------#2019-10-12">https://towardsdatascience.com/serverless-tensorflow-workflow-with-ec2-auto-training-495f47bd892d?source=collection_archive---------22-----------------------#2019-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2c74e99b16b71595f46c0ba1b41d81e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBMt7cjWIkz0SsZmIHpdXQ.png"/></div></div></figure><p id="e32a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">机器学习培训工作通常是时间和资源密集型的，因此将这一过程纳入实时自动化工作流可能是一项挑战。</p><p id="4a36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" href="https://medium.com/@mike.p.moritz/running-tensorflow-on-aws-lambda-using-serverless-5acf20e00033" rel="noopener">之前的一篇文章</a>中，我展示了一个在 AWS Lambda 上运行无服务器 TensorFlow 训练作业的原型。这种情况的激励用例是当有有限的标记数据，并且新的输入条目需要非常快速地合并到模型中时。</p><p id="51c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然可以在 Lambda 上运行标准的 Python TensorFlow 库，但很可能许多应用程序很快就会遇到部署包大小和/或执行时间的限制，或者需要额外的计算选项。</p><p id="3b1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文将介绍如何保持数据管理和预测无服务器，但是将培训任务卸载到一个临时 EC2 实例。这种创建实例的模式将建立在为在云中运行<a class="ae kz" rel="noopener" target="_blank" href="/keras-hyperparameter-optimization-on-aws-cbd494a7ea15">经济高效的超参数优化</a>而开发的模式之上。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/d277353746f39c424402185519b761ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWNpNJ3Y0rqX92xoSOkyyQ.png"/></div></div></figure><p id="5011" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在 Lambda 中保留预测功能意味着由于加载 TensorFlow，仍然可能存在大小约束。为了减轻这一点，所有的 Lambda 函数都将为 Node.js 编写，这也将允许我们使用<a class="ae kz" href="https://www.tensorflow.org/js" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>而不是标准的 Python 库。</p><p id="63f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TensorFlow.js 有浏览器版本和节点版本，后者包含 C++绑定以提高性能。节点版本似乎是显而易见的选择，但是它解压缩到 690MB(！)这使得它立即不适用于 Lambda。考虑到我们不会在 Lambda 函数中进行训练，预测的性能损失是可以接受的，因此我们将使用解压缩到 55MB 的浏览器版本。</p><p id="4583" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于底层机器学习模型，我们将尝试基于以下输入参数来预测一个人的舒适度:</p><ul class=""><li id="1b27" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">温度(°F)</li><li id="f31f" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">相对湿度(%)</li><li id="b873" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">衣服隔热(以“克罗”为单位)</li><li id="7915" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">风速(米/秒)</li></ul><p id="9c4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际模型将使用使用 TensorFlow 的 Keras API 构建的简单(非优化)神经网络。</p><p id="7a2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于数据存储，我们将在 DynamoDB 中创建两个表:</p><ul class=""><li id="de8e" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">data</code> —将为训练保留带标签的输入数据</li><li id="f47f" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">model</code> —存储培训作业的元数据和指标</li></ul><h1 id="f7a2" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">环境设置</h1><h2 id="e00d" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">初始化</h2><p id="1e68" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">由于我们的项目将与 Node Lambda 文件和 Python EC2 文件混合在一起，我们将在如下所示的文件夹结构中将它们分开。我们还将利用无服务器框架，它将保留在顶层，而节点和 Python 部分将在各自的文件夹中初始化。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="8ba3" class="mv ly it lw b gy nq nr l ns nt">├── LambdaAutoTraining<br/>│   ├── js<br/>│   │   ├── ...<br/>│   ├── py<br/>│   │   ├── ...</span></pre><p id="67fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，安装 Serverless 并使用节点模板初始化一个新项目。应该会出现一个样板处理程序(<code class="fe lt lu lv lw b">handler.js</code>)和配置文件(<code class="fe lt lu lv lw b">serverless.yml</code>)。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="408c" class="mv ly it lw b gy nq nr l ns nt">$ npm install -g serverless<br/>$ mkdir -p LambdaAutoTraining/{js,py}<br/>$ cd LambdaAutoTraining<br/>$ <!-- -->serverless create --template aws-nodejs</span></pre><h2 id="d37a" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">节点设置</h2><p id="7045" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">导航到<code class="fe lt lu lv lw b">js</code>文件夹，初始化一个新的节点项目，安装 Tensorflow.js(仅限浏览器版本！).</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="331b" class="mv ly it lw b gy nq nr l ns nt">$ cd js<br/>$ npm init<br/>...follow prompts<br/>$ <!-- -->npm install @tensorflow/tfjs</span></pre><p id="f62a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，使用架构图作为指南，创建必要的 JavaScript 文件，这些文件将映射到最终的 Lambda 函数。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="48dd" class="mv ly it lw b gy nq nr l ns nt">$ touch test.js upload.js train.js infer.js s3proxy.js</span></pre><p id="42ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，将<code class="fe lt lu lv lw b">handler.js</code>中的样板代码复制到每个文件中，然后删除<code class="fe lt lu lv lw b">handler.js</code>。</p><h2 id="aff1" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">Python 设置</h2><p id="f2ca" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">导航到<code class="fe lt lu lv lw b">py</code>文件夹并创建一个新的虚拟环境。为了创建培训方案，我们将使用 Jupyter 笔记本，我们还需要<code class="fe lt lu lv lw b">tensorflowjs</code>模块，以便我们可以将保存的模型转换为 TensorFlow.js 可以理解的格式。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="49fa" class="mv ly it lw b gy nq nr l ns nt">$ cd ../py<br/>$ pyenv virtualenv 3.7.3 autotraining<br/>$ pyenv activate autotraining<br/>$ pip install tensorflow tensorflowjs jupyter<br/>$ pip freeze &gt; requirements.txt</span></pre><p id="6cab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一部分，我们只需要创建 Jupyter 笔记本文件和 Dockerfile。Python 文件将作为 Docker 构建过程的一部分创建。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="5776" class="mv ly it lw b gy nq nr l ns nt">$ touch train.ipynb Dockerfile</span></pre><p id="c0f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您的项目结构现在应该如下所示:</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="930a" class="mv ly it lw b gy nq nr l ns nt">├── LambdaAutoTraining<br/>│   ├── serverless.yml<br/>│   ├── js<br/>│   │   ├── test.js<br/>│   │   ├── upload.js<br/>│   │   ├── train.js<br/>│   │   ├── infer.js<br/>│   │   ├── s3proxy.js<br/>│   │   ├── package.json<br/>│   │   ├── package_lock.json<br/>|   │   ├── node_modules<br/>|   │   │   ├── ...<br/>│   ├── py<br/>│   │   ├── requirements.txt<br/>│   │   ├── train.ipynb<br/>│   │   ├── Dockerfile</span></pre><h1 id="7f48" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">无服务器设置</h1><p id="fd2b" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated"><code class="fe lt lu lv lw b">serverless.yml</code>文件是项目的主要配置。首先删除文件中的所有样板文本(如果需要，您可以稍后参考<a class="ae kz" href="https://serverless.com/framework/docs/providers/aws/guide/serverless.yml/" rel="noopener ugc nofollow" target="_blank">文档</a>中的所有选项)，然后开始构建提供者部分。</p><p id="839d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与大多数 AWS 无服务器示例的一个关键区别是，我们将定义自己的 IAM 角色。通常情况下,<code class="fe lt lu lv lw b">role</code>将替换为<code class="fe lt lu lv lw b">iamRoleStatements</code>部分，该部分允许无服务器与其自身的整体 IAM 角色合并的定制策略。然而，我们需要将 EC2 作为可信实体，这在<code class="fe lt lu lv lw b">iamRoleStatements</code>中是不可用的。稍后将在参考资料一节中进行构建。</p><p id="c138" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">环境部分让我们可以访问 Lambda 函数中的部署相关变量。创建 EC2 实例策略需要用到<code class="fe lt lu lv lw b">IAM_ROLE</code>，而<code class="fe lt lu lv lw b">test.js</code>和<code class="fe lt lu lv lw b">infer.js</code>都将使用<code class="fe lt lu lv lw b">API_URL</code>来调用我们的 API 网关端点。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="efe4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，使用图表和创建的文件作为指导来定义每个功能。为了简单起见，每个处理函数名和 API 端点将与文件名相同。</p><p id="3f21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lt lu lv lw b">upload</code>、<code class="fe lt lu lv lw b">infer</code>和<code class="fe lt lu lv lw b">s3proxy</code>将通过 API 网关调用，因此将有<code class="fe lt lu lv lw b">http</code>事件。对于<code class="fe lt lu lv lw b">s3proxy</code>,我们将使用路径参数来定义所请求的文件，其中<code class="fe lt lu lv lw b">key</code>是 S3 桶中的文件夹。</p><p id="ffd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<code class="fe lt lu lv lw b">train</code>函数，我们将使用 DynamoDB 流触发器，它将包含在参考资料部分。当至少有一个新事件并且<em class="nw">满足以下任一限制</em>时，该事件将被触发:</p><ul class=""><li id="efac" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">batchSize</code> —创建的最大项目数</li><li id="662e" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">batchWindow</code> —创建第一个项目后的最长时间</li></ul><p id="26be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于<code class="fe lt lu lv lw b">train</code>将主要负责启动 EC2 实例，我们还将定义一些额外的特定环境变量。在本例中，我们的 Docker 图像将存储在 AWS Docker 注册表(ECR)中，但是也可以使用其他图像。</p><ul class=""><li id="7430" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">AMI_ID</code> —我们将在本例中使用 ami-0f812849f5bc97db5，因为它是为 Docker 预先构建的</li><li id="a748" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">KEY_NAME</code> —这是 SSH 访问实例所需的 pem 文件的名称；请确保您可以访问私钥！</li><li id="df27" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">INSTANCE_TYPE</code> —有效值是该图像可用的 EC2 风格</li><li id="d405" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">SPOT_DURATION</code>—spot 实例被中断前的最短时间(分钟)</li><li id="2594" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">VALID_HRS</code> —如果没有实现，现货请求将持续的最长时间</li><li id="4715" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">ECR_ID</code> —应该与您的 AWS 帐户 id 相同</li><li id="97a5" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lt lu lv lw b">ECR_REPO</code>—ECR 储存库和项目的名称</li></ul><p id="b3bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，<code class="fe lt lu lv lw b">test</code>将仅用于手动触发，因此没有关联事件。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8bb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，创建 S3 存储桶和两个 DynamoDB 表(在此阶段提供的吞吐量有限)。请注意，<code class="fe lt lu lv lw b">data</code>表还包含用于触发<code class="fe lt lu lv lw b">train</code>功能的<code class="fe lt lu lv lw b">StreamSpecification</code>。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bba8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要创建的最后一个资源是我们的自定义 IAM 角色，它将被所有功能使用，无服务器的<a class="ae kz" href="https://serverless.com/framework/docs/providers/aws/guide/iam#one-custom-iam-role-for-all-functions" rel="noopener ugc nofollow" target="_blank">文档</a>提供了一个很好的起点模板。为了将角色从 Lambda 转移到 EC2，我们需要两件事情:</p><ul class=""><li id="ca98" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">将<code class="fe lt lu lv lw b">ec2.amazonaws.com</code>添加到<code class="fe lt lu lv lw b">AssumeRolePolicyDocument</code>部分</li><li id="fb5f" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">在<code class="fe lt lu lv lw b">Policies</code>部分为<code class="fe lt lu lv lw b">iam:PassRole</code>添加一个允许动作</li></ul><p id="02ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<code class="fe lt lu lv lw b">Policies</code>部分，我们将首先复制默认的无服务器日志策略和 S3 部署桶(通常这些是自动创建的)。接下来，我们将为之前定义的 S3 桶和 DynamoDB 表添加自定义语句。请注意，在创建自定义策略时，不会自动创建 DynamoDB 流策略，因此我们需要显式地定义它。</p><p id="7a5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们将添加创建 EC2 实例所需的策略:</p><ul class=""><li id="f62d" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">EC2 —创建并运行实例。</li><li id="597d" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">CloudWatch —创建、描述和启用警报，以便我们可以在训练完成时自动终止实例。</li><li id="7fd0" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">ECR —允许提取 Docker 图像(这将仅由 EC2 使用，而不由 Lambda 函数使用)。</li><li id="8884" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">IAM 获取、创建角色并将其添加到实例配置文件中。当从控制台启动 EC2 实例并选择 IAM 角色时，会自动创建这个概要文件，但是我们需要在我们的函数中手动创建。</li></ul><p id="0169" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nw">安全注意事项:在部署到生产环境之前，这些策略应该仅限于所需的资源</em></p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2ff5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为您已经向每个函数添加了样板代码，所以现在可以部署和测试所有的配置是否正确。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="f66e" class="mv ly it lw b gy nq nr l ns nt">$ serverless deploy --stage dev<br/>...<br/>$ curl -X POST "https://&lt;api_id&gt;.execute-api.&lt;region&gt;.amazonaws.com/dev/upload"</span><span id="c168" class="mv ly it lw b gy nx nr l ns nt">Go Serverless v1.0! Your function executed successfully!</span></pre><p id="a957" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经准备好构建应用程序了！</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/c2ee6fcb719c7d4cd725be830b4e6e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t3LuTN0Lk5FDcGmm"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@shs521?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Susan Holt Simpson</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="665d" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">λ:upload . js</h1><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/4c5296722b65dc06a43fed5d819ffae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4bZv1Dph6lgHtP890ZS7w.png"/></div></div></figure><p id="c07c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lt lu lv lw b">upload</code>函数将接受一组新标记的数据作为输入，并将其存储在 DynamoDB 表中。该更新将启动一个流触发器来启动<code class="fe lt lu lv lw b">train</code>功能。</p><p id="0d49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe lt lu lv lw b">upload.js</code>中，首先导入并设置 AWS SDK。由于这个函数是由一个 HTTP 事件触发的，我们将读取<code class="fe lt lu lv lw b">body</code>字段，然后构造一个表示各个 DynamoDB 插入项的对象数组。注意，即使字段有不同的类型(例如“N”或“S”分别代表数字和字符串)，实际值也需要作为字符串传入。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="822e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果有新的项目要写，我们将构造一个新的对象，然后使用来自<a class="ae kz" href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/dynamodb-example-table-read-write-batch.html" rel="noopener ugc nofollow" target="_blank"> DynamoDB AWS SDK </a>的<code class="fe lt lu lv lw b">batchWriteItem</code>来写新的项目。<code class="fe lt lu lv lw b">batchWriteItem</code>比一系列<code class="fe lt lu lv lw b">putItem</code>请求更高效，并且也是原子性的。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="57fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经构建了<code class="fe lt lu lv lw b">upload</code>函数，您还可以构建<code class="fe lt lu lv lw b">test.js</code>来生成随机数据，以测试工作流并填充数据库。详见<a class="ae kz" href="https://github.com/mikepm35/LambdaAutoTraining/blob/master/js/test.js" rel="noopener ugc nofollow" target="_blank"> Github 文件</a>。</p><p id="5bf4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新部署到<code class="fe lt lu lv lw b">dev</code>阶段并测试端点。此时，开始用数据填充 DynamoDB 是有价值的，这可以通过手动调用<code class="fe lt lu lv lw b">test.js</code>函数来完成。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="cd0a" class="mv ly it lw b gy nq nr l ns nt">$ severless deploy --stage dev<br/>...<br/>$ curl -X POST "https://&lt;api_id&gt;.execute-api.&lt;region&gt;.amazonaws.com/dev/upload" -d '[{"created": 1570323309012, "temp": 75, "rh": 60, "wind": 0.6, "clo": 1.0, "label": "ok", "score": -1}]'</span><span id="28a1" class="mv ly it lw b gy nx nr l ns nt">1 records created successfully</span></pre><p id="4926" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管<code class="fe lt lu lv lw b">train.js</code>函数还没有构建出来，但是一旦达到批处理窗口或批处理大小，您仍然会看到它被调用。</p><h1 id="86f0" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">EC2: train.py</h1><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/61097d564293a83cd3c8af15161da1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrLn26jUCZ0SS_AJJlEMEA.png"/></div></div></figure><p id="aa16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上传新数据的功能完成后，我们现在将重点转移到 Python 训练部分。这里转移焦点而不是完成 JavaScript Lambda 函数的动机是，如果 EC2/ECR 集成完成了，验证<code class="fe lt lu lv lw b">train</code>函数会容易得多，否则我们将无法验证启动脚本是否工作。</p><p id="d2a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要开始使用 TensorFlow 模型，请打开 Jupyter 笔记本(您的虚拟环境应该已经激活)。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="5951" class="mv ly it lw b gy nq nr l ns nt">$ cd py<br/>$ jupyter notebook</span></pre><p id="8c62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开之前创建为空文件的<code class="fe lt lu lv lw b">train.ipynb</code>。我们希望将关键字段作为环境参数传递给 Docker 容器，但是为了便于测试，我们将提供这些值。接下来创建代表两个 DynamoDB 表的变量。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/6b75b5c29693404a93482fe638df802b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7L5sH41EtNFJT957Mp9PQ.png"/></div></div></figure><p id="ff91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于输入数据，我们将对 DynamoDB 数据表执行一次<a class="ae kz" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/dynamodb.html#DynamoDB.Client.scan" rel="noopener ugc nofollow" target="_blank">扫描</a>。如果结果被分页，那么<code class="fe lt lu lv lw b">LastEvaluatedKey</code>就会出现，这种情况发生在响应大于 1MB 的时候。</p><p id="c03e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DynamoDB 返回一个 Decimal 数据类型，所以我们将遍历数据集，转换为 floats，并对标签数据进行一次性编码。最后，这个列表被转换成 numpy 数组，以便输入到 TensorFlow 模型中。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/b8866f108a35212d71b255e683c82b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIax2MNrNaAVOIaXg7a7QQ.png"/></div></div></figure><p id="53cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建模型，我们将使用 TensorFlow 的<a class="ae kz" href="https://www.tensorflow.org/guide/keras" rel="noopener ugc nofollow" target="_blank"> Keras API </a>，更具体地说，是允许我们构建神经网络层的顺序模型。本文的重点不是超参数优化，因此我们将使用一个非常简单的配置。请务必注意，必须定义输入形状，以便稍后导入 TensorFlow.js。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/f29a66acfbde5e187bde39c0abaf3859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AGstOP0DWLw69GwThX6rA.png"/></div></div></figure><p id="e2eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦模型完成，我们将使用来自<code class="fe lt lu lv lw b">tfjs</code>模块的转换器直接将其保存为可由 TensorFlow.js 导入的格式。然后，这些文件被上传到 S3 的一个新文件夹中，并以当前纪元为关键字。我们还将维护一个“最新”文件夹，以定义客户应该使用哪个模型进行预测。最后，每个模型拟合的结果将存储在 DynamoDB 的<code class="fe lt lu lv lw b">model</code>表中。</p><p id="bcd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于应该填充了<code class="fe lt lu lv lw b">data</code>表，现在您可以在本地运行这个笔记本并验证其功能。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/33d55063d5fd38bb27a5d3191e525c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdhS9atMBHpFuvdTntZStQ.png"/></div></div></figure><p id="a77a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着模型开发的完成，我们现在将开始准备 Docker 映像，从提供构建映像的指令的 Docker 文件开始。</p><p id="bc25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开 docker 文件进行编辑，并按如下所示进行更新，目的如下:</p><ul class=""><li id="b322" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">从标准 Python 3.7 基础映像开始</li><li id="29e7" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">创建新用户<code class="fe lt lu lv lw b">lambdaautotraining</code></li><li id="5486" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">复制到 Jupyter 笔记本和需求文件中</li><li id="b3c6" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">从需求文件安装 Python 库</li><li id="f4ff" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">将 Jupyter 笔记本转换为标准 Python 文件，并在图像启动时运行</li></ul><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="2cc4" class="mv ly it lw b gy nq nr l ns nt">FROM python:3.7</span><span id="2efb" class="mv ly it lw b gy nx nr l ns nt">RUN echo $(python3 --version)</span><span id="3484" class="mv ly it lw b gy nx nr l ns nt">RUN useradd -ms /bin/bash lambdaautotraining</span><span id="84c5" class="mv ly it lw b gy nx nr l ns nt">WORKDIR /home/lambdaautotraining</span><span id="e892" class="mv ly it lw b gy nx nr l ns nt">RUN apt-get update -y</span><span id="a378" class="mv ly it lw b gy nx nr l ns nt">COPY train.ipynb requirements.txt ./</span><span id="4cb0" class="mv ly it lw b gy nx nr l ns nt">RUN pip install -r requirements.txt</span><span id="5844" class="mv ly it lw b gy nx nr l ns nt">RUN chown -R lambdaautotraining:lambdaautotraining ./</span><span id="80dc" class="mv ly it lw b gy nx nr l ns nt">USER lambdaautotraining</span><span id="ec0a" class="mv ly it lw b gy nx nr l ns nt">RUN jupyter nbconvert --to script train.ipynb</span><span id="3448" class="mv ly it lw b gy nx nr l ns nt">CMD ["python3","-u","train.py"]</span></pre><p id="adf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在本地构建 Docker 容器，用 ECR URI 标记，登录 ECR，然后推送到存储库。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="e9c4" class="mv ly it lw b gy nq nr l ns nt">$ docker build -t lambda-auto-training-dev .<br/>...<br/>$ docker tag \<br/>  lambda-auto-training-dev:latest \<br/>  &lt;ecr_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/lambda-auto-training/lambda-auto-training-dev:latest</span><span id="80c1" class="mv ly it lw b gy nx nr l ns nt">$ $(aws ecr get-login --no-include-email --region &lt;region&gt;)<br/>...<br/>$ docker push \<br/>  &lt;ecr_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/lambda-auto-training/lambda-auto-training-dev:latest</span></pre><p id="f53f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以手动启动 EC2 实例并执行命令来运行这个映像，但是我们将创建触发 Lambda 函数并一起测试它。</p><h1 id="4a4f" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">Lambda: train.js</h1><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/7f219646153409fbfbc74fd1af896fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkLe5in_MN2Pa5U5aQrOsg.png"/></div></div></figure><p id="4bb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lt lu lv lw b">train</code> Lambda 函数的主要目的是对新的一批标记数据做出反应，然后启动一个新的 EC2 实例来完全执行训练工作流。与使用回调样式处理程序的<code class="fe lt lu lv lw b">upload</code>函数不同，这里我们将使用 async/await 模式。</p><p id="b138" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数中定义的第一个变量是初始化脚本，它将被传递给 EC2 实例进行启动。这值得作为一个单独的 shell 脚本进行测试，但是为了简单起见，这里仅以字符串形式显示。该脚本的主要职责如下:</p><ul class=""><li id="78f0" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">下载并安装 AWS CLI</li><li id="2b63" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">登录到 ECR</li><li id="e8a8" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">下拉所需的 Docker 图像</li><li id="5483" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">运行 Docker 映像</li></ul><p id="5321" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意,<code class="fe lt lu lv lw b">run</code>命令有一系列我们通过 replace 语句定义的环境属性。这些将在我们的训练 Python 脚本中使用，以与 DynamoDB 和 S3 进行交互。</p><p id="f8b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，该字符串需要按照 EC2 要求进行 base64 编码。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bdfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，检索实例配置文件，它定义了 EC2 实例将使用的 IAM 角色。需要阻塞的每个调用都使用带有 await 关键字的 promise 形式。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7a99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了实例概要文件，我们将为 spot 实例定义完整的 EC2 参数集。另一种选择是单独创建一个模板并直接启动它。我们还将在关闭时终止实例，这里的一个额外优化是根据需要停止/启动一个持久性实例。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="88fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在准备开始创建 EC2。成功后，我们将创建并启用一个警报，当 CPU 下降到某个阈值以下时，该警报将自动终止实例，我们将该阈值用作训练完成的代理。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="fb71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以用新功能更新开发环境。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="9cca" class="mv ly it lw b gy nq nr l ns nt">$ cd ../js<br/>$ serverless deploy --stage dev</span></pre><p id="03f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">已经验证了<code class="fe lt lu lv lw b">train.js</code>的触发工作，我们将使用控制台测试培训工作流程。在 AWS 中，打开 Lambda、DynamoDB、S3 和 EC2 的服务页面，并执行以下操作:</p><ul class=""><li id="58af" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">λ:用空输入触发训练函数</li><li id="ce53" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">EC2:验证实例是使用正确的警报创建的</li><li id="6f02" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">DynamoDB:验证模型信息是否更新</li><li id="60ac" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">S3:确认模型文件已经上传</li><li id="acb1" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">EC2:大约 10 分钟后，验证实例是否已终止</li></ul><h1 id="724e" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">Lambda: infer.js</h1><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/72f39741cc1ea07fc988ab360667b79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pH8SHlQsdG0OmRk-W7Opkw.png"/></div></div></figure><p id="77e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完整的培训工作流完成后，我们现在准备构建预测/推理部分。<code class="fe lt lu lv lw b">infer</code>的主要目的是下载模型，加载到 TensorFlow.js 中，然后根据 HTTP 触发器提供给它的一组输入进行预测。该函数期望输入是一个对象数组，其中的键表示所需的模型输入字段。</p><p id="cfc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TensorFlow.js 的浏览器版本使用的<code class="fe lt lu lv lw b">fetch</code>在 Node.js 中不是标准的。为了解决这个问题，我们将安装<code class="fe lt lu lv lw b">node-fetch</code>，并在全局范围内使用它来代替<code class="fe lt lu lv lw b">fetch</code>。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="42ca" class="mv ly it lw b gy nq nr l ns nt">$ npm install node-fetch</span></pre><p id="1bda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，必须下载模型。我们将再次需要解决这样一个事实，即我们使用的是浏览器版本，它不期望访问标准的本地文件系统。我们可以将必要的模块从<code class="fe lt lu lv lw b">tfjs-node</code>提取到我们的项目中，但是在这个例子中，我们将利用<code class="fe lt lu lv lw b">loadLayersModel</code>中的直接 HTTP 下载选项。</p><p id="e921" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，由于我们的 S3 存储桶没有对世界开放，我们需要确定如何允许这种访问。对于对 S3 的 HTTP 访问，使用<a class="ae kz" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#getSignedUrl-property" rel="noopener ugc nofollow" target="_blank">签名的 url </a>是一个合理的选择，但是在下载步骤<a class="ae kz" href="https://js.tensorflow.org/api/latest/#loadLayersModel" rel="noopener ugc nofollow" target="_blank">中，TensorFlow 实际上做了两件事</a>:</p><ol class=""><li id="4959" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky of ll lm ln bi translated">下载 model . JSON——我们可以在这里传入签名的 url</li><li id="f300" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky of ll lm ln bi translated">使用 url 根目录下载模型拓扑—步骤 1 中签名的 url 将不再有效！</li></ol><p id="543c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们将使用一个单独的代理来接收每个请求，并将其重定向到一个适当的签名 url。更新<code class="fe lt lu lv lw b">s3proxy</code>以支持此功能，如下所示:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bb00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到<code class="fe lt lu lv lw b">infer</code>函数，加载模型后，我们将输入转换为 2D 张量并运行预测。<code class="fe lt lu lv lw b">arraySync</code>会将结果转换为标准浮点数，每组输入被转换为跨输出维度的一组预测。通过寻找最大值，这个预测被转换成一个简单的标签映射，然后在一个新的 JSON 对象中返回。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="bea2" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">测试整个工作流程</h1><p id="d8ef" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">如果您创建了<code class="fe lt lu lv lw b">test</code>函数，那么您可以设置一个 cron 作业，在一个定义的时间间隔执行，这将模拟真实的流量。为此，我们需要在我们的<code class="fe lt lu lv lw b">serverless.yml</code>配置中添加一个 CloudWatch 事件触发器(默认禁用):</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="4d1f" class="mv ly it lw b gy nq nr l ns nt">test:<br/>    handler: js/test.test  <br/>    events:<br/>      - schedule:<br/>          rate: rate(2 minutes)<br/>          enabled: false</span></pre><p id="839a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">手动启用触发器可能<a class="ae kz" href="https://github.com/serverless/serverless/issues/5111" rel="noopener ugc nofollow" target="_blank">有点令人困惑</a>，因为 Lambda UI 会显示为“enabled ”,但实际上您需要转到 CloudWatch 来启用底层事件:</p><blockquote class="og oh oi"><p id="8095" class="kb kc nw kd b ke kf kg kh ki kj kk kl oj kn ko kp ok kr ks kt ol kv kw kx ky im bi translated">问题是在 Lambda UI 中既有<code class="fe lt lu lv lw b">AWS::Events::Rule</code>(可以启用/禁用)也有触发器(可以启用/禁用)。Lambda UI 显示<em class="it">触发器</em>状态，该状态已启用。然而，我们实际上不能用云的形成来触摸它。<code class="fe lt lu lv lw b">AWS::Events::Rule</code>设置为 disabled，这是我们用 CloudFormation 设置的。如果触发器或规则被禁用，它将不会触发您的 Lambda。</p></blockquote><p id="ca33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于预测方面，我们可以像以前一样手动测试，或者扩展我们的测试功能策略，以包括推理。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/b5d5d03f6eb1f465e4a5ca353de690b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AxMOCufq3mlXwiCm"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9c16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">准备就绪后，您现在可以部署到“生产”阶段。对于 Docker 映像，我们只需向现有映像添加一个新标签，并将其推入生产存储库。</p><pre class="lb lc ld le gt nm lw nn no aw np bi"><span id="6b76" class="mv ly it lw b gy nq nr l ns nt">$ serverless deploy --stage prod<br/>...<br/>$ docker tag \<br/>  lambda-auto-training-dev:latest \<br/>  &lt;ecr_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/lambda-auto-training/lambda-auto-training-prod:latest<br/>...<br/>$ docker push \<br/>  &lt;ecr_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/lambda-auto-training/lambda-auto-training-prod:latest</span></pre><h1 id="5c06" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">最后的想法</h1><p id="de22" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">鉴于这是一个原型，在部署到真实的生产环境之前，应该考虑许多方面:</p><ul class=""><li id="cffd" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">持久 API 端点的域集成(见<code class="fe lt lu lv lw b">serverless-domain-manager</code>插件)。</li><li id="5ba8" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">HTTP 事件输入应该经过验证并包含错误处理。</li><li id="ed05" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">可以向面向客户端的端点添加预热功能，以限制冷启动时的长调用时间。</li><li id="ac8e" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">应该加强 IAM 资源权限。将这个环境封装在 VPC 中是一个不错的选择，它还提供了允许 HTTP 访问 S3 的代理的替代方案。</li><li id="4342" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">DynamoDB 流触发器相对简单，在高容量环境中可能会过于激进。一个更健壮的解决方案可能是将新事件附加到一个文件中，并单独对新事件进行计数，这也可以减少每次训练运行时扫描整个表的工作量。</li><li id="c696" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">如果 EC2 实例在每次运行后被终止，最终未使用的警报将需要被清除。如果使用停止/启动一个实例的替代模式，警报也可以重复使用。</li><li id="2b1b" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">对于生产中的保护，应在培训工作中应用阈值，以便不引入表现不佳的模型进行预测。</li></ul><p id="0d94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p><p id="8f38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在 GitHub 上查看所有代码:<a class="ae kz" href="https://github.com/mikepm35/LambdaAutoTraining" rel="noopener ugc nofollow" target="_blank">https://github.com/mikepm35/LambdaAutoTraining</a></p></div></div>    
</body>
</html>