<html>
<head>
<title>Time Series Data Munging — Lagging Variables that are Distributed Across Multiple Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据管理—分布在多个组中的滞后变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/timeseries-data-munging-lagging-variables-that-are-distributed-across-multiple-groups-86e0a038460c?source=collection_archive---------10-----------------------#2019-01-13">https://towardsdatascience.com/timeseries-data-munging-lagging-variables-that-are-distributed-across-multiple-groups-86e0a038460c?source=collection_archive---------10-----------------------#2019-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/c2519334e175935d9e43d17fad415239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*uqYaEHQzMmcCMe87H2tHtA.jpeg"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk">Photo by <a class="ae iz" href="https://unsplash.com/@jontyson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae iz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="6c3d" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">方法链接、分组和索引操作</h2></div></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="ffaa" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对时间序列数据建模可能具有挑战性，因此一些数据爱好者(包括我自己)推迟学习这个主题直到他们绝对必须这样做是有道理的。在将机器学习模型应用于时间序列数据之前，您必须将其转换为模型的“可吸收”格式，这通常涉及计算滞后变量，这可以测量自相关，即变量的过去值如何影响其未来值，从而释放预测值。以下是我最近用来生成熊猫滞后变量的三种不同方法:</p><p id="c7e9" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jd"> 1。在一组中滞后一个或多个变量—使用</strong> <em class="lu">移位</em> <strong class="la jd">方法</strong></p><p id="d855" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jd"> 2。跨多个组延迟一个变量—使用</strong> <em class="lu">分解</em> <strong class="la jd">方法</strong></p><p id="c5b2" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jd"> 3。跨多个组延迟多个变量—使用</strong> <em class="lu"> groupby </em></p><p id="ecf3" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，让我们生成一些虚拟时间序列数据，因为它将“在野外”出现，并将它放入三个<em class="lu">数据帧</em>中用于说明目的(<a class="ae iz" href="https://tichmangono.github.io/tutorials/2018/05/04/time-series-data-munging-lagging-variables-across-multiple-groups" rel="noopener ugc nofollow" target="_blank">所有代码在一个地方</a>)。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0eb3" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">其次，做一些转换，让 pandas 将您的 dates 列识别为一个<em class="lu"> datetime </em>变量。这对我们以后会有帮助。旁注，显然是熊猫的策划者，韦斯·麦金尼，特别发明了熊猫来解决处理时间索引数据的问题。因此，在生成虚拟数据并转换日期列之后，您现在应该有 3 个<em class="lu">数据帧</em>，如下所示。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/2c6fe593027df45b76b21ff0f8d11bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wymf8lCTbI4QHrgKs35Rlg.png"/></div></div></figure><p id="738f" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在是有趣的部分！第一种方法非常简单，如下所示。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="b960" class="mg mh jc bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak"> 1。在一个组/类别中滞后一个或多个变量——使用“移位”方法</strong></h1><p id="7deb" class="pw-post-body-paragraph ky kz jc la b lb my kd ld le mz kg lg lh na lj lk ll nb ln lo lp nc lr ls lt ij bi translated">这里，我们简单地使用可用于<em class="lu"> dataframe </em>的<em class="lu"> shift </em>方法，并指定在将日期列设置为索引后要延迟的步数(在我们的例子中，是 1“天”)。记住，你也可以使用负数作为位移，这意味着未来的值正在影响过去(时间机器，有人知道吗？😊).</p><pre class="lv lw lx ly gt nd ne nf ng aw nh bi"><span id="1f6f" class="ni mh jc ne b gy nj nk l nl nm">df_onegrp.set_index(["date"]).shift(1)</span></pre><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nn"><img src="../Images/385cbce0ca39ca8975f6f2db8a1703bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KF-m6C6lAvwPrdC3ghRk8A.png"/></div></div></figure><p id="a98e" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">注意第一行现在有空值，表明我们确实滞后了数据。如果您落后两步，前两行将为空等。对于这个例子，索引已经是惟一的了，但是您可能希望对其他数据进行检查，以避免意外的后果。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="f6a2" class="mg mh jc bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak"> 2。将一个变量延迟到多个组——使用“拆分”方法</strong></h1><p id="2222" class="pw-post-body-paragraph ky kz jc la b lb my kd ld le mz kg lg lh na lj lk ll nb ln lo lp nc lr ls lt ij bi translated">这种方法稍微复杂一些，因为有几个组，但易于管理，因为只有一个变量需要滞后。总的来说，我们应该意识到，我们希望首先对数据进行索引，然后在应用 lag 函数之前，通过 T2 分解来分离组。不这样做实际上会对您的数据做错误的事情。例如，它可以将前一个组的最后一个值移动到下一个组的第一个值上，从而跨组混合数据。想象一下，如果这些群体是国家，变量是以年为单位的人口。如果你犯了这样的错误，这就像假设宾夕法尼亚州晚年的人口会影响罗德岛早年的人口，因为这两个州按字母顺序相邻。这说不通。这可能是一个巨大的陷阱，会导致完全错误的分析。</p><p id="ebd6" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，将索引设置为您的日期和组。然后使用<em class="lu">拆垛</em>拉出组，然后<em class="lu">移动</em>列，就像前面的方法一样。更多关于<em class="lu">堆叠</em>、<em class="lu">拆解</em>技巧的信息，请看我的另一篇<a class="ae iz" rel="noopener" target="_blank" href="/seven-clean-steps-to-reshape-your-data-with-pandas-or-how-i-use-python-where-excel-fails-62061f86ef9c"> <strong class="la jd">文章这里</strong> </a> <strong class="la jd">。</strong></p><p id="7e68" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在<em class="lu">将</em>组放回行中。注意如何保存空值，然后对它们做任何你想做的事情(<em class="lu">替换</em>，<em class="lu">删除</em>等等)。)</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b99c" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了便于说明，我选择保留空值/缺失值并重新排列数据</p><pre class="lv lw lx ly gt nd ne nf ng aw nh bi"><span id="f579" class="ni mh jc ne b gy nj nk l nl nm">df.reset_index().sort_values("group")</span></pre><figure class="lv lw lx ly gt is gh gi paragraph-image"><div class="gh gi no"><img src="../Images/c70d1a8202422de3ef9919025fa24f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*f-N72Du1x79MWgMXgAL_1A.png"/></div></figure><p id="69db" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，如果你密切关注，你会注意到这种方法也适用于许多组中的许多变量，但是我想把这个场景留给另一种技术，在下一节中使用<em class="lu"> groupby </em>来代替。所以，你可以停止阅读，使用上面的方法。但是你很好奇，所以我们继续…</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi np"><img src="../Images/c3705d4c494d89321328e657a07d061e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6TGVEeETNxV0H0IJORCgg.jpeg"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk">Photo by <a class="ae iz" href="https://unsplash.com/@jhonkasalo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joakim Honkasalo</a> on <a class="ae iz" href="https://unsplash.com/s/photos/curious?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="5737" class="mg mh jc bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak"> 3。</strong> <strong class="ak">同时延迟分布在多个组中的多个变量——使用“分组依据”方法</strong></h1><p id="8232" class="pw-post-body-paragraph ky kz jc la b lb my kd ld le mz kg lg lh na lj lk ll nb ln lo lp nc lr ls lt ij bi translated">这个方法依赖于 pandas <em class="lu"> groupby </em>函数结合我们在前面的方法中学到的所有招数。所以我不会花时间解释我们已经讨论过的概念。关键步骤是使用“组”列对数据进行分组；制作一个函数，使<em class="lu">对</em>进行排序，<em class="lu">按日期对</em>进行索引，<em class="lu">对每组中的数据进行移位</em>，然后<em class="lu">通过</em>对象对<em class="lu">组中的</em>进行迭代，将函数应用于每组。最后，我们使用便利的<em class="lu">列表理解</em>，然后<em class="lu">将这个列表连接</em>回其原始格式。</p><p id="5a4a" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这种方法中使用的一些很酷的概念是:</p><ul class=""><li id="3a17" class="nq nr jc la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><strong class="la jd"> <em class="lu">赋值</em> : </strong>我最近发现了<em class="lu">数据帧</em>可用的<em class="lu">赋值</em>方法。它清理了您的代码，允许您生成一个新列并为其分配新值，而不必使用中间的<em class="lu"> dataframe </em>。它会自动返回数据的副本。</li><li id="64af" class="nq nr jc la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la jd"> <em class="lu">方法链接</em> : </strong>该函数还在返回语句中使用括号，以便允许方法链接，这是编写干净、易读代码的另一种方式。</li></ul><p id="f145" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">将数据分组:</p><pre class="lv lw lx ly gt nd ne nf ng aw nh bi"><span id="844f" class="ni mh jc ne b gy nj nk l nl nm">grouped_df = df_combo.groupby(["group"])</span></pre><p id="76c3" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<em class="lu">赋值</em>和<em class="lu">方法-链接</em>创建功能:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3455" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用列表理解对每个组应用函数，然后垂直连接:</p><pre class="lv lw lx ly gt nd ne nf ng aw nh bi"><span id="84cd" class="ni mh jc ne b gy nj nk l nl nm">dflist = [lag_by_group(g, grouped_df.get_group(g)) for g in grouped_df.groups.keys()]</span><span id="1374" class="ni mh jc ne b gy oe nk l nl nm">pd.concat(dflist, axis=0).reset_index())</span></pre><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi of"><img src="../Images/9fcced4ed9e9000a8911ab15f79711c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jywYWCP1zOic8UUD7wFvw.png"/></div></div></figure><p id="d95f" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就对了。滞后时间序列的三种不同方法。可能还有更多，例如，您可以通过<em class="lu"> x </em>步骤移动数据，然后删除每个组的第一个<em class="lu"> x </em>步骤，但是我认为上述解决方案更加健壮和灵活，允许您对空值做任何您想做的事情。下面让我知道你的想法。</p><p id="c2ec" class="pw-post-body-paragraph ky kz jc la b lb lc kd ld le lf kg lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">编码快乐！</p></div></div>    
</body>
</html>