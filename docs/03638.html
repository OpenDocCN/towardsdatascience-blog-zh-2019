<html>
<head>
<title>Graph Algorithms (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形算法(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-algorithms-part-2-dce0b2734a1d?source=collection_archive---------4-----------------------#2019-06-10">https://towardsdatascience.com/graph-algorithms-part-2-dce0b2734a1d?source=collection_archive---------4-----------------------#2019-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e88b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/towards-data-science/inside-ai/home" rel="noopener">内线艾</a></h2><div class=""/><div class=""><h2 id="dda3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python 中的主要概念、属性和应用</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4f552b14d8ab20a075924a1257418625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlbIGZg9-onMNUcxFy8C8w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Corsica, France</figcaption></figure><p id="ce54" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated">这些天来，无论你是想通过预测潜在的联系来了解社交网络的结构，检测欺诈，了解汽车租赁服务的客户行为，还是提出实时建议，raphs 都成为机器学习的核心。</p><p id="cc8b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我们将讨论:</p><ul class=""><li id="fa20" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc mr ms mt mu bi translated">主要的图形算法</li><li id="5a66" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">插图和使用案例</li><li id="6efe" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">Python 中的示例</li></ul><p id="bd14" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本文原载于我的个人博客:<a class="ae na" href="https://maelfabien.github.io/ml/#" rel="noopener ugc nofollow" target="_blank">https://maelfabien.github.io/ml/#</a></p><p id="4f5a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我在这个资源库上发布我所有的文章和相应的代码:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/maelfabien/Machine_Learning_Tutorials" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">mael fabien/机器学习教程</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">本报告包含练习、代码、教程和我的个人博客文章</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lb ne"/></div></div></a></div><p id="8a19" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您还没有，请务必阅读我的第一篇文章:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/introduction-to-graphs-part-1-2de6cda8c5a5"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">图表介绍(第一部分)</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Python 中的主要概念、属性和应用</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns lb ne"/></div></div></a></div><p id="af78" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">新</strong>:第 3 部出来了！</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/learning-in-graphs-with-python-part-3-8d5513eef62d"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">用 Python 学习图形(第 3 部分)</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Python 的概念、应用和示例</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns lb ne"/></div></div></a></div></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="5d63" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，打开 Jupyter 笔记本，导入以下包:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="266e" class="oh oi it od b gy oj ok l ol om">import numpy as np<br/>import random<br/>import networkx as nx<br/>from IPython.display import Image<br/>import matplotlib.pyplot as plt</span></pre><p id="085b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下文章将使用最新版本的<code class="fe on oo op od b">networkx</code><code class="fe on oo op od b">2.x</code>。NetworkX 是一个 Python 包，用于创建、操作和研究复杂网络的结构、动态和功能。</p><p id="f3a1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我将尽量保持一种实用的方法，并举例说明每个概念。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="f29b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上一篇文章中，我们介绍了图的主要种类，以及描述图的基本特征。我们现在将更详细地介绍图形分析/算法以及分析图形的不同方法。</p><p id="97e4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了理解上下文，下面是一些图算法的用例:</p><ul class=""><li id="03f5" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc mr ms mt mu bi translated">实时欺诈检测</li><li id="9026" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">实时推荐</li><li id="9cf3" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">简化法规遵从性</li><li id="e8cb" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">复杂网络的管理和监控</li><li id="f423" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">身份和访问管理</li><li id="1bae" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">社交应用/功能</li><li id="216f" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi">…</li></ul><p id="7eac" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">目前大多数框架都支持三种主要的图形算法(例如 Python 中的<code class="fe on oo op od b">networkx</code>或 Neo4J):</p><ul class=""><li id="da3d" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc mr ms mt mu bi translated"><strong class="lj jd">寻路</strong>:根据可用性和质量等确定<em class="oq">最佳路径</em>。我们还将在这一类别中包括<strong class="lj jd">搜索算法</strong>。例如，这可用于识别<em class="oq">最快路线或交通路线</em>。</li><li id="f981" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated"><strong class="lj jd">中心性</strong>:确定网络中节点的重要性。这可以用来<em class="oq">识别社交媒体中的影响者</em>或者识别网络中的潜在攻击目标。</li><li id="1c7f" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated"><strong class="lj jd">社区检测</strong>:评估一个<em class="oq">群体是如何聚集的</em>。这可用于<em class="oq">细分客户</em>和<em class="oq">检测欺诈</em>等。</li></ul><p id="7bb1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还将在下周发表的第三篇文章中开发图形中的机器学习基础和<strong class="lj jd">图形学习</strong>。在 Networkx 中实现的所有算法都可以在这里找到:</p><div class="nb nc gp gr nd ne"><a href="https://networkx.github.io/documentation/stable/reference/algorithms/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">算法- NetworkX 2.3 文档</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">编辑描述</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">networkx.github.io</p></div></div></div></a></div><p id="157d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您会注意到，我们将只讨论在 Networkx 中实现的基本和最常见的算法。</p><h1 id="5a08" class="or oi it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">I .寻路和图搜索算法</h1><ul class=""><li id="f673" class="mm mn it lj b lk pi ln pj lq pk lu pl ly pm mc mr ms mt mu bi translated"><strong class="lj jd">寻路算法</strong>试图通过最小化跳数找到两个节点之间的<strong class="lj jd">最短路径</strong>。</li><li id="b540" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated"><strong class="lj jd">搜索算法</strong>没有给出最短路径。取而代之的是，他们通过考虑图的邻居或深度来探索图。这可以用于信息检索。</li></ul><h2 id="85ba" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated"><strong class="ak"> 1。搜索算法</strong></h2><p id="3fe8" class="pw-post-body-paragraph lh li it lj b lk pi kd lm ln pj kg lp lq px ls lt lu py lw lx ly pz ma mb mc im bi translated">有两种主要的图形搜索算法:</p><ul class=""><li id="b2aa" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc mr ms mt mu bi translated"><strong class="lj jd">广度优先搜索(BFS) </strong>首先搜索每个节点的邻居，然后是邻居的邻居…</li><li id="b5fd" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated"><strong class="lj jd">深度优先搜索(DFS) </strong>尝试尽可能地沿着一条路径走下去，如果可能的话，访问新邻居。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/0680d460e747730196bae156c68d258f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4IsgWldgJagW21QQ67v6A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Search Algorithms</figcaption></figure><h2 id="deb6" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated"><strong class="ak"> 2。寻路算法</strong></h2><p id="0057" class="pw-post-body-paragraph lh li it lj b lk pi kd lm ln pj kg lp lq px ls lt lu py lw lx ly pz ma mb mc im bi translated"><strong class="lj jd"> a .最短路径</strong></p><blockquote class="qb qc qd"><p id="e596" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">最短路径计算一对节点之间最短的加权(如果图是加权的)路径。</em></p></blockquote><p id="f067" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，它用于识别社交网络上两个人之间的最佳驾驶方向或分离程度。</p><p id="30e4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有许多方法可以计算图中的最短路径，包括<strong class="lj jd"> Dijkstra 的算法</strong>，Networkx 中的默认算法。</p><p id="a4a2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据维基百科，该算法的伪代码如下:</p><ol class=""><li id="21bb" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc qh ms mt mu bi translated">将图中的所有节点标记为未访问。创建所有未访问节点的集合，称为<em class="oq">未访问集合</em>。</li><li id="6381" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">给每个节点分配一个试探性的距离值:对于初始节点，将其设置为零；对于所有其他节点，将其设置为无穷大。将初始开始节点设置为当前节点。</li><li id="a9b1" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">对于当前节点，考虑其所有未访问的邻居，并计算它们通过当前节点的<em class="oq">暂定</em>距离。将新计算的<em class="oq">暂定</em>距离与当前分配值进行比较，并分配较小的一个。例如，如果当前节点<em class="oq"> A </em>被标记为距离 6，并且连接它和邻居<em class="oq"> B </em>的边的长度为 2，那么通过<em class="oq"> A </em>到<em class="oq"> B </em>的距离将是 6 + 2 = 8。如果 B 之前标记的距离大于 8，则将其更改为 8。否则，保持当前值。</li><li id="2f73" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">当我们考虑完当前节点的所有未访问邻居后，将当前节点标记为已访问，并将其从<em class="oq">未访问集合</em>中移除。被访问的节点将不再被检查。</li><li id="491b" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">如果目的地节点已经被标记为已访问(当计划两个特定节点之间的路线时)或者如果<em class="oq">未访问集合</em>中的节点之间的最小暂定距离是无穷大(当计划完整遍历时；当初始节点和剩余的未访问节点之间没有连接时发生)，然后停止。算法已经完成。</li><li id="2f24" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">否则，选择标有最小暂定距离的未访问节点，将其设置为新的“当前节点”，并返回步骤 3。</li></ol><p id="4db6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想了解更多关于最短路径的问题，请看这篇文章:<a class="ae na" href="https://en.wikipedia.org/wiki/Shortest_path_problem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Shortest_path_problem</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/c84e702204b49bf5dac77d28aab887b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/1*2jRCHqAbTCY7W7oG5ntMOQ.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Wikipedia’s illustration of the <strong class="bd qj">Dijkstra’s algorithm</strong></figcaption></figure><p id="d53f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在 Python 中，实现非常简单:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="49b4" class="oh oi it od b gy oj ok l ol om"># Returns shortest path between each node<br/>nx.shortest_path(G_karate)</span></pre><p id="fce8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这将返回图中每个节点之间的最短路径列表:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="2ffc" class="oh oi it od b gy oj ok l ol om">{0: {0: [0],<br/>    1: [0, 1],<br/>    2: [0, 2],<br/>    ...</span></pre><p id="6a16" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> b .单源最短路径</strong></p><blockquote class="qb qc qd"><p id="ef54" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">单源最短路径(SSSP)查找图中给定节点和所有其他节点之间的最短路径。</em></p></blockquote><p id="7138" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，它通常用于 IP 网络的路由协议。</p><p id="aada" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> c .所有对最短路径</strong></p><blockquote class="qb qc qd"><p id="1dcb" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">“所有对最短路径”(APSP)算法寻找所有节点对之间的最短路径。</em></p></blockquote><p id="d283" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">尽管提供了相似的结果，但它比针对每对节点调用单一源最短路径更快。该算法通常可用于确定交通网格不同路段的预期交通负荷。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="fb40" class="oh oi it od b gy oj ok l ol om"># Returns shortest path length between each node<br/>list(nx.all_pairs_shortest_path_length(G_karate))</span></pre><p id="5c4a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它返回:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="199c" class="oh oi it od b gy oj ok l ol om">[(0,<br/>    {0: 0,<br/>    1: 1,<br/>    2: 1,<br/>    3: 1,<br/>    4: 1,<br/>    ...</span></pre><p id="5c62" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> d .最小重量生成树</strong></p><blockquote class="qb qc qd"><p id="7ed2" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated">最小生成树是连接图中所有节点的边权重之和最小的图(树)的子图。</p></blockquote><p id="e73d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最小生成树应该应用于无向图。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="00b3" class="oh oi it od b gy oj ok l ol om">from networkx.algorithms import tree<br/>mst = tree.minimum_spanning_edges(G_karate, algorithm='prim', data=False)<br/>edgelist = list(mst)<br/>sorted(edgelist)</span></pre><p id="0b69" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它返回:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="db4e" class="oh oi it od b gy oj ok l ol om">[(0, 1),<br/>(0, 2),<br/>(0, 3),<br/>(0, 4),<br/>(0, 5),<br/>(0, 6),<br/>...</span></pre><h1 id="dd1b" class="or oi it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">二。社区检测</h1><blockquote class="qb qc qd"><p id="8f68" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">社区检测根据给定的</em> <strong class="lj jd"> <em class="it">质量准则</em> </strong> <em class="it">将节点划分成若干个</em> <strong class="lj jd"> <em class="it">组</em> </strong> <em class="it">。</em></p></blockquote><p id="0e10" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它通常用于识别社交社区、客户行为或网页主题。</p><p id="fcad" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="oq">社区</em>是一组连接的节点。然而，尽管社区内的节点应该是紧密连接的，但是没有一个通用的定义可以用来定义社区。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/9724325d82eb92609e2779cb9610377a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqv4rHJHZobt-9k-7P5IOQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Communities</figcaption></figure><p id="f951" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">寻找社区的一种常见算法是格文纽曼算法。它通过逐步移除网络中的边来识别社区。我们将把中间性称为“边中间性”。它是一个与通过这条边的节点对之间的最短路径数成比例的分数。</p><p id="407d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该算法的步骤如下:</p><ol class=""><li id="6170" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc qh ms mt mu bi translated">计算网络中所有现有边的介数。</li><li id="514f" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">移除具有最高介数的边。</li><li id="9ed2" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">移除此边后，重新计算所有边的介数。</li><li id="1331" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc qh ms mt mu bi translated">重复第 2 步和第 3 步，直到没有剩余的边。</li></ol><p id="9801" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要在 Python 中实现这一点，可以使用以下代码:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="6806" class="oh oi it od b gy oj ok l ol om">from networkx.algorithms import community</span><span id="c64a" class="oh oi it od b gy ql ok l ol om">k = 1<br/>comp = community.girvan_newman(G_karate)</span><span id="1598" class="oh oi it od b gy ql ok l ol om">for communities in itertools.islice(comp, k):<br/>    print(tuple(sorted(c) for c in communities))</span></pre><p id="7a24" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是属于每个社区的节点列表的开头(k=1 表示我们期望 2 个社区):</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="713c" class="oh oi it od b gy oj ok l ol om">([0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21], [2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])</span></pre><p id="efca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如上所述，这种方法没有真正的规模。由于这个原因，已经开发了诸如 Louvain 方法的方法。然而，这种方法在大型图上运行起来确实很长。</p><h2 id="f546" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">3.鲁汶模块化</h2><p id="94da" class="pw-post-body-paragraph lh li it lj b lk pi kd lm ln pj kg lp lq px ls lt lu py lw lx ly pz ma mb mc im bi translated">在定义 Louvain 方法之前，引入模块化的概念是很重要的。模块性是对组被划分为集群的良好程度的度量:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/5588aedeeea336db81c7356acf606c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIbbKwJw4lo5dwz4VF9hKA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Modularity</figcaption></figure><p id="af31" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">卢万方法的<strong class="lj jd">伪码</strong>如下:</p><ul class=""><li id="5708" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc mr ms mt mu bi translated">首先为每个节点分配一个社区</li><li id="a549" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">交替接下来的 2 个步骤，直到收敛:</li><li id="8bbf" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">创建一个具有相邻节点的新社区，以最大化模块化</li><li id="fe25" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">创建新的加权图。前一步的社区成为图的节点</li></ul><p id="240c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在这可能看起来有点混乱。事实上，我们所做的唯一事情就是对最近的节点进行分组，以便优化模块化标准。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/7300be92653c6add46092ed66d314c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Atj8zjMczzSolLdGup285Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Louvain Method</figcaption></figure><p id="b8ba" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请注意，卢万方法没有理论上的保证，但在实践中效果很好。卢万的方法作为 NetworkX 的一个子项目出现，就在这里:<a class="ae na" href="https://python-louvain.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://python-louvain.readthedocs.io/en/latest/</a></p><p id="d1a7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，安装软件包:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="a8f6" class="oh oi it od b gy oj ok l ol om">pip install python-louvain</span></pre><p id="b1fc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，计算最佳分区(基于 Louvain 方法):</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="782c" class="oh oi it od b gy oj ok l ol om">import community<br/>partition = community.best_partition(G_karate)</span><span id="24cd" class="oh oi it od b gy ql ok l ol om">pos = nx.spring_layout(G_karate)<br/>plt.figure(figsize=(8, 8))<br/>plt.axis('off')<br/>nx.draw_networkx_nodes(G_karate, pos, node_size=600, cmap=plt.cm.RdYlBu, node_color=list(partition.values()))<br/>nx.draw_networkx_edges(G_karate, pos, alpha=0.3)<br/>plt.show(G_karate)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/6223d5392d082cb362d22feff9f722d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66VfXxJW-LvMICjEfXSxmQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Best partition of the Karate Graph using Louvain</figcaption></figure><h2 id="b86e" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">4.强连通分量</h2><blockquote class="qb qc qd"><p id="7a82" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">强连通分量(SCC)算法在有向图中找到多组</em> <strong class="lj jd"> <em class="it">连通节点</em> </strong> <em class="it">。注意，每个节点必须是从同一组中的任何其他节点在</em> <strong class="lj jd"> <em class="it">两个方向</em> </strong> <em class="it">上</em><em class="it">可达</em>  <em class="it">。</em></p></blockquote><p id="6a4d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它通常在图表分析过程的早期使用，让我们了解我们的图表是如何构建的，例如，当我们查看谁拥有哪个公司的股份时，探索财务报表数据(例如，想想巴拿马文件)。</p><h2 id="dbb3" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">5.弱连通分量(联合查找)</h2><blockquote class="qb qc qd"><p id="b01b" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">弱连通分量或联合查找算法在有向图中查找</em> <strong class="lj jd"> <em class="it">连通节点</em> </strong> <em class="it">的集合，其中每个节点是从同一集合中的任何其他节点可达的</em><strong class="lj jd"><em class="it"/></strong><em class="it">。</em></p></blockquote><p id="a30d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它只需要在一个方向的节点对之间存在一条路径，而 SCC 需要在两个方向都存在一条路径。与 SCC 一样，Union Find 通常在分析的早期用于理解图的结构。</p><p id="7312" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Union-Find 是一个预处理步骤，对于理解图的结构来说，在任何算法之前都是必不可少的。</p><p id="f973" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以使用以下方法测试连通有向图:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="9e5c" class="oh oi it od b gy oj ok l ol om">nx.is_weakly_connected(G)<br/>nx.is_strongly_connected(G)</span></pre><p id="b110" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">或者对于无向图，使用:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="761f" class="oh oi it od b gy oj ok l ol om">nx.is_connected(G_karate)</span></pre><p id="b59c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它返回一个布尔值。</p><p id="0545" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">确保查看关于实施连接的<a class="ae na" href="https://networkx.github.io/documentation/stable/reference/algorithms/component.html" rel="noopener ugc nofollow" target="_blank"> Networkx 文档</a>。</p><h2 id="2bdb" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">6.分层聚类</h2><blockquote class="qb qc qd"><p id="6697" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">在层次聚类中，我们构建一个</em><strong class="lj jd"><em class="it"/></strong><em class="it">的层次聚类。我们用一个</em> <strong class="lj jd"> <em class="it">树状图来表示下面的聚类。</em>T49】</strong></p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/f02d7551b6cc65a6fc4425ae65572a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJLOphg-Pp-s6ZpOKhxqGQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Dendrogram</figcaption></figure><p id="baa1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个想法是分析不同尺度的社区结构。我们通常自底向上构建树状图。我们从每个节点的一个集群开始，合并两个“最近”的节点。</p><p id="b5a3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是我们如何测量星团是否很接近呢？我们使用相似距离。设 d(i，j)是 I 和 j 之间最短路径的长度。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/9e216e0571a5104666ce6f86fb0ac304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5O5tXK6kz38VOCZ8FM31HQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Similarity Distances</figcaption></figure><p id="a59e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于最大链接，在每一步，由最短距离分开的两个聚类被组合。相似性距离可以如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qr"><img src="../Images/18e0f349eefe57991ad59baaf7ecf0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pot5fvxSLZGXLD_t3RxAYw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Linkage</figcaption></figure><p id="773c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">回到我们空手道的例子。在应用层次聚类之前，我们需要定义每个节点之间的距离矩阵。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="63f7" class="oh oi it od b gy oj ok l ol om">pcc_longueurs=list(nx.all_pairs_shortest_path_length(G_karate))<br/>distances=np.zeros((n,n))</span><span id="8494" class="oh oi it od b gy ql ok l ol om"># distances[i, j] is the length of the shortest path between i and j<br/>for i in range(n):<br/>    for j in range(n):<br/>        distances[i, j] = pcc_longueurs[i][1][j]</span></pre><p id="d2b6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们将使用<code class="fe on oo op od b">sklearn</code>的<code class="fe on oo op od b">AgglomerativeClustering</code>函数来识别层次聚类。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="66f9" class="oh oi it od b gy oj ok l ol om">from sklearn.cluster import AgglomerativeClustering</span><span id="68f9" class="oh oi it od b gy ql ok l ol om">clustering = AgglomerativeClustering(n_clusters=2,linkage='average',affinity='precomputed').fit_predict(distances)</span></pre><p id="5760" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，根据分类用不同的颜色绘制结果图:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="0f0c" class="oh oi it od b gy oj ok l ol om">nx.draw(G_karate,  node_color = clustering)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qs"><img src="../Images/0ecf0c9122ab9e57da87dc7c32c92566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4ZFObc3-n7nv4UrRF4mEw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Hierarchical Clustering</figcaption></figure><h2 id="6036" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">7.聚类系数</h2><blockquote class="qb qc qd"><p id="c171" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">聚类系数衡量两个节点趋向于</em> <strong class="lj jd"> <em class="it">聚类</em> </strong> <em class="it">在一起的程度。</em></p></blockquote><p id="aef2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">局部聚类系数是以节点 I 为中心的三角形的数量与以节点 I 为中心的三元组的数量之比。在某种意义上，它衡量节点 I 及其邻居与完整图形的接近程度。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qt"><img src="../Images/cf52791ef18fab92f0294e69ebfa86de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKjxZNxcW4U8Uy7aozXD7A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Clustering Coefficient</figcaption></figure><p id="6431" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我尝试用下图来说明聚类系数的计算:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qu"><img src="../Images/976cdf8d55173ed3899e9f890a343185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWjE3SgnfDie7d5MX_qiLQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Clustering Coefficient</figcaption></figure><p id="e044" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">全局</strong>系数测量图形中三角形(局部聚类)的密度:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qv"><img src="../Images/cc23a57ca2a8d3f75c803abfa6aa0e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaqgFH_d6eRXZ9lGR8wYpA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Global Clustering Coefficient</figcaption></figure><p id="90dc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上图中，聚类系数等于:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qw"><img src="../Images/8b5fb0de39bb2f7a692fe14fca785507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TV9hGbRIJ-W8ewAkK-y4MQ.png"/></div></div></figure><p id="a789" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于<strong class="lj jd"> Erdos-Rényi </strong>随机图，E[聚类系数]=E[Ci]=p 其中 p 为上一篇文章定义的概率。</p><p id="8008" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于<strong class="lj jd"> Baràbasi-Albert </strong>随机图，全局聚类系数根据节点数遵循幂律。度为 k 的节点的平均聚类系数与 k 的倒数成正比:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/ae5dffffec90b45345d44a9bbb1d254d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*4eEkIZc3I3VXNbMKFz0Nwg.png"/></div></figure><p id="e56a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">具有低等级的节点连接到其社区中的其他节点。度数高的节点链接到不同社区的节点。</p><p id="1cd0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于给定的图，在<code class="fe on oo op od b">networkx</code>中，可以很容易地计算出聚类系数。首先，让我们从局部聚类系数开始:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="a06b" class="oh oi it od b gy oj ok l ol om"># List of local clustering coefficients<br/>list(nx.clustering(G_barabasi).values())</span></pre><p id="0087" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这应该会返回类似于以下内容的内容:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="7485" class="oh oi it od b gy oj ok l ol om">0.13636363636363635,<br/>0.2,<br/>0.07602339181286549,<br/>0.04843304843304843,<br/>0.09,<br/>0.055384615384615386,<br/>0.07017543859649122,<br/>...</span></pre><p id="84c0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">并对结果进行平均，以找到图的全局聚类系数:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="f838" class="oh oi it od b gy oj ok l ol om"># Global clustering coefficient<br/>np.mean(list(nx.clustering(G_barabasi).values()))</span></pre><p id="a288" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">哪些标题:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="2c1b" class="oh oi it od b gy oj ok l ol om">0.0965577637155059</span></pre><h1 id="bf67" class="or oi it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">三。中心算法</h1><p id="deef" class="pw-post-body-paragraph lh li it lj b lk pi kd lm ln pj kg lp lq px ls lt lu py lw lx ly pz ma mb mc im bi translated">中心性衡量一个节点的重要性。这不是一个清晰的定义，但当我们想要识别重要的网页、交通网络中的瓶颈时，这很有用…</p><p id="8bbc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一条<strong class="lj jd">步行</strong>是一条可以多次通过同一个节点的路径。中心性度量随着所考虑的行走类型和计算它们的方式而变化。</p><h2 id="8365" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">1.PageRank 算法</h2><blockquote class="qb qc qd"><p id="ee05" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><strong class="lj jd"><em class="it">page rank</em></strong><em class="it">从其链接的邻居，然后再从它们各自的邻居，估计当前节点的重要性。</em></p></blockquote><p id="2db1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然是由谷歌推广的，但这是一种检测任何网络中有影响力节点的方法。例如，它被用来暗示社交网络上的联系。</p><p id="c36d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">PageRank 是通过迭代地将一个节点的等级(最初基于度)分配给它的邻居，或者通过随机遍历图形并计算在这些遍历期间命中每个节点的频率来计算的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qy"><img src="../Images/cfae2e23ee337eaac5e5e708d8cd49dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGWF_IAymWFyrsMMGJ_qQQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Neo4J summary of the Page Rank Algorithm</figcaption></figure><p id="ee7d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">PageRank 通常是在有向图上计算的。但是，它也可以通过将有向图中的每条边转换为两条边来在无向图上执行。</p><p id="5c83" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，空手道图的 PageRank 可以通过以下方式访问:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="2502" class="oh oi it od b gy oj ok l ol om">nx.pagerank(G_karate, alpha=0.9)</span></pre><p id="5eb1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中，alpha 是阻尼参数(默认为 0.85)。作为回报，它会给你一个排名列表:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="d43a" class="oh oi it od b gy oj ok l ol om">{0: 0.09923208031303203,<br/> 1: 0.0543403155825792,<br/> 2: 0.05919704684187155,<br/> 3: 0.036612460562853694,<br/>...</span></pre><h2 id="c2fc" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">2.程度中心性</h2><blockquote class="qb qc qd"><p id="e52f" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">度中心性</em> </strong> <em class="it">统计结束于节点 I 的长度为 1 的行走次数</em></p></blockquote><p id="9770" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它衡量传入和传出的关系。它由 C(Xi)=di 给出。例如，度中心性用于识别社交网络上最有影响力的人。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="8e45" class="oh oi it od b gy oj ok l ol om">c_degree = nx.degree_centrality(G_karate)<br/>c_degree = list(c_degree.values())</span></pre><h2 id="27bb" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">3.特征向量中心性</h2><blockquote class="qb qc qd"><p id="a845" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><em class="it">特征向量中心性是在节点 I 结束的无限长的行走的数量。</em></p></blockquote><p id="0741" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这使得具有良好连接的邻居的节点更加重要。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qz"><img src="../Images/27016a7a4c8abbd26623517e4e557479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2CXj6oa2zJL8Xs6VTSC2g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Eigenvector Centrality</figcaption></figure><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="d3e7" class="oh oi it od b gy oj ok l ol om">c_eigenvector = nx.eigenvector_centrality(G_karate)<br/>c_eigenvector = list(c_eigenvector.values())</span></pre><h2 id="5e18" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">4.接近中心性</h2><blockquote class="qb qc qd"><p id="bbf8" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">接近中心度</em> </strong> <em class="it">通过图形检测能够有效传播信息的节点。</em></p></blockquote><p id="2298" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它可以用来识别假新闻账户或恐怖分子的细胞，以隔离那些可以传播信息的个人。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/51b151bc32669bc80294a1e0cc587719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*QgdwJ_CnBFdhAHARJSZ-Vw.png"/></div></figure><p id="a49e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接近中心性与到其他节点的最短路径的长度之和成反比。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="9884" class="oh oi it od b gy oj ok l ol om">c_closeness = nx.closeness_centrality(G_karate)<br/>c_closeness = list(c_closeness.values())</span></pre><h2 id="92cf" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">5.中间中心性</h2><blockquote class="qb qc qd"><p id="47f8" class="lh li oq lj b lk ll kd lm ln lo kg lp qe lr ls lt qf lv lw lx qg lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">中间中心性</em> </strong> <em class="it">检测一个节点对图中信息流的影响程度。</em></p></blockquote><p id="ecdf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它通常用于查找充当从图的一部分到另一部分的桥梁的节点，例如在电信网络中的包裹递送处理器中，或者在假新闻的传播中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi rb"><img src="../Images/cbf3247a45aadcf31c8fda5a06528582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*vE1bQBOtsOyDwdb046wvzQ.png"/></div></figure><p id="1b4b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中:</p><ul class=""><li id="cf31" class="mm mn it lj b lk ll ln lo lq mo lu mp ly mq mc mr ms mt mu bi translated">σJK j 和 k 之间的最短路径数</li><li id="8e31" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">σJK(I)j 和 k 之间经过 I 的最短路径数</li></ul><p id="73e1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">介数中心性测量一个节点作为两个节点之间的桥梁的次数。例如:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rc"><img src="../Images/d97342f2030a7b9cc7d481debf922210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISPY0qy6I9C88BGnJWmgdA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Centrality Measure</figcaption></figure><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="057e" class="oh oi it od b gy oj ok l ol om">c_betweenness = nx.betweenness_centrality(G_karate)<br/>c_betweenness = list(c_betweenness.values())</span></pre><p id="20c9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在 Python 中，实现依赖于<code class="fe on oo op od b">networkx</code>的内置函数:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="b977" class="oh oi it od b gy oj ok l ol om"># Plot the centrality of the nodes<br/>plt.figure(figsize=(18, 12))</span><span id="c157" class="oh oi it od b gy ql ok l ol om"># Degree Centrality<br/>f, axarr = plt.subplots(2, 2, num=1)<br/>plt.sca(axarr[0,0])<br/>nx.draw(G_karate, cmap = plt.get_cmap('inferno'), node_color = c_degree, node_size=300, pos=pos, with_labels=True)<br/>axarr[0,0].set_title('Degree Centrality', size=16)</span><span id="36d4" class="oh oi it od b gy ql ok l ol om"># Eigenvalue Centrality<br/>plt.sca(axarr[0,1])<br/>nx.draw(G_karate, cmap = plt.get_cmap('inferno'), node_color = c_eigenvector, node_size=300, pos=pos, with_labels=True)<br/>axarr[0,1].set_title('Eigenvalue Centrality', size=16)</span><span id="60b3" class="oh oi it od b gy ql ok l ol om"># Proximity Centrality<br/>plt.sca(axarr[1,0])<br/>nx.draw(G_karate, cmap = plt.get_cmap('inferno'), node_color = c_closeness, node_size=300, pos=pos, with_labels=True)<br/>axarr[1,0].set_title('Proximity Centrality', size=16)</span><span id="6b2e" class="oh oi it od b gy ql ok l ol om"># Betweenness Centrality<br/>plt.sca(axarr[1,1])<br/>nx.draw(G_karate, cmap = plt.get_cmap('inferno'), node_color = c_betweenness, node_size=300, pos=pos, with_labels=True)<br/>axarr[1,1].set_title('Betweenness Centrality', size=16)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rd"><img src="../Images/2cac54d85337f552b6b60bd75a370ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ydhxYoENdKC3hpgX74QPw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">The different centrality measures</figcaption></figure><p id="681a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们观察到由中心性度量突出显示的不同节点是非常不同的。例如，中间中心性产生的结果与其他方法相差甚远，因为它们测量的不是同样的东西。</p><h1 id="1087" class="or oi it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">四。结论</h1><p id="658c" class="pw-post-body-paragraph lh li it lj b lk pi kd lm ln pj kg lp lq px ls lt lu py lw lx ly pz ma mb mc im bi translated">我们现在已经介绍了图的介绍、图的主要类型、不同的图算法以及它们在 Python 和 Networkx 中的实现。</p><p id="9043" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在下一篇文章中，我们将讨论图学习，它提供了预测图中节点和边的方法，以处理丢失的值或预测新的关系。</p><p id="500c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您有任何问题或意见，请随时评论。敬请期待，本系列的最后一篇文章将于下周问世:)</p><h2 id="d73a" class="oh oi it bd os pn po dn ow pp pq dp pa lq pr ps pc lu pt pu pe ly pv pw pg iz bi translated">来源:</h2><ul class=""><li id="0682" class="mm mn it lj b lk pi ln pj lq pk lu pl ly pm mc mr ms mt mu bi translated">Neo4j 中的图形算法综合指南</li><li id="326c" class="mm mn it lj b lk mv ln mw lq mx lu my ly mz mc mr ms mt mu bi translated">网络 x 文档，【https://networkx.github.io/documentation/stable/ T21】</li></ul><p id="b6c7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想从我这里读到更多，我以前的文章可以在这里找到:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/introduction-to-graphs-part-1-2de6cda8c5a5"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">图表介绍(第一部分)</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Python 中的主要概念、属性和应用</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns lb ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/learning-in-graphs-with-python-part-3-8d5513eef62d"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">用 Python 学习图形(第 3 部分)</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Python 的概念、应用和示例</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns lb ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/markov-chains-and-hmms-ceaf2c854788"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">马尔可夫链和 hmm</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在本文中，我们将关注马尔可夫模型，何时何地应该使用它们，以及隐马尔可夫模型。这个…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="re l np nq nr nn ns lb ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/a-guide-to-face-detection-in-python-3eab0f6b9fc1"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">Python 中的人脸检测指南</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在本教程中，我们将看到如何使用 OpenCV 和 Dlib 在 Python 中创建和启动人脸检测算法。我们会…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="rf l np nq nr nn ns lb ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/boosting-and-adaboost-clearly-explained-856e21152d3e"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">升压和 AdaBoost 解释清楚</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">直观的解释</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="rg l np nq nr nn ns lb ne"/></div></div></a></div></div></div>    
</body>
</html>