<html>
<head>
<title>If Marie Kondo did SQL…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果玛丽·近藤做了 SQL…</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/if-marie-kondo-did-sql-be86374b7cd8?source=collection_archive---------23-----------------------#2019-06-10">https://towardsdatascience.com/if-marie-kondo-did-sql-be86374b7cd8?source=collection_archive---------23-----------------------#2019-06-10</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="bce0" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">…她会使用 dbplyr</h2></div><p id="83ba" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在以前的一些帖子中，我提到过<code class="fe lg lh li lj b">dbplyr</code>包是一种在 r 中处理 SQL 数据库的非常酷的方式。<code class="fe lg lh li lj b">dbplyr</code>是一个非常聪明的 SQL 翻译器，随着每次更新，它变得越来越强大。它允许您将数据库表视为一个 R dataframe 对象，并使用简单、干净的 tidyverse 命令来操作它。在 R 控制台中处理所有这些乱七八糟的 SQL 字符串要好得多，也更直观。</p><p id="a738" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我想我会用一个简单的例子来说明<code class="fe lg lh li lj b">dbplyr</code>是如何工作的，我希望你能拿起这个例子并进一步发挥它。不知不觉中，你就再也不想用 SQL 写东西了！</p><h2 id="1daf" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">使用 chinook 数据库</h2><p id="11a1" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated"><code class="fe lg lh li lj b">chinook</code>是一个 SQLite 数据库，可以在<a class="ae mi" href="http://www.sqlitetutorial.net/sqlite-sample-database/" rel="noopener ugc nofollow" target="_blank">这里</a>下载，练习用起来真的很方便。一旦你把它解压到一个文件夹，打开你的 R 会话，我们将使用下面的包:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="b612" class="lk ll iv lj b gy mr ms l mt mu">library(tidyverse)<br/>library(dbplyr)<br/>library(DBI)<br/>library(RSQLite)</span></pre><p id="401d" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">首先，我们将建立与 SQLite 数据库的连接。虽然这个数据库只是一个本地保存的文件，但是您可以使用类似的连接到您的 Oracle 或 MSSQL 数据库或其他数据库[1]。</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="7f77" class="lk ll iv lj b gy mr ms l mt mu">chinook &lt;- DBI::dbConnect(<br/>  drv = RSQLite::SQLite(),<br/>  dbname = "chinook.db"<br/>)</span></pre><p id="8390" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们现在可以有效地连接到<code class="fe lg lh li lj b">chinook</code>数据库。我们可以使用<code class="fe lg lh li lj b">RSQLite::dbListTables(chinook)</code>来浏览其中的表格，这表明其中有以下表格:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="1c8d" class="lk ll iv lj b gy mr ms l mt mu">"albums"          "artists"         "customers"       "employees"       "genres"         "invoice_items"   "invoices"        "media_types"     "playlist_track"  "playlists"      "sqlite_sequence" "sqlite_stat1"    "tracks"</span></pre><p id="d115" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们将使用<code class="fe lg lh li lj b">dbplyr</code>对其中的一些表格进行试验，特别是以下表格:</p><ul class=""><li id="99f3" class="mv mw iv km b kn ko kq kr kt mx kx my lb mz lf na nb nc nd bi translated"><code class="fe lg lh li lj b">employees </code> —公司员工的详细信息</li><li id="301f" class="mv mw iv km b kn ne kq nf kt ng kx nh lb ni lf na nb nc nd bi translated"><code class="fe lg lh li lj b">customers </code> —客户详情表</li><li id="a5ca" class="mv mw iv km b kn ne kq nf kt ng kx nh lb ni lf na nb nc nd bi translated"><code class="fe lg lh li lj b">invoices </code> —附在客户 id 上的发票明细表</li><li id="14d9" class="mv mw iv km b kn ne kq nf kt ng kx nh lb ni lf na nb nc nd bi translated"><code class="fe lg lh li lj b">invoice_items</code> —每个发票 ID 中订购单位和价格的详细信息表</li></ul><p id="3a0c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们可以很容易地使用<code class="fe lg lh li lj b">dplyr</code>将这些表设置为数据库对象，如下所示[2]:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="7531" class="lk ll iv lj b gy mr ms l mt mu">employees &lt;- dplyr::tbl(chinook, "employees")<br/>customers &lt;- dplyr::tbl(chinook, "customers")<br/>invoices &lt;- dplyr::tbl(chinook, "invoices")<br/>invoice_items &lt;- dplyr::tbl(chinook, "invoice_items")</span></pre><p id="747d" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这些表现在都是 R 会话中的 SQL 数据库对象，您可以像操作数据帧一样操作它们。注意，只需在 R 控制台中键入表名，就可以看到每个表中的数据摘录。重要的是，在定义这些表时，<em class="nj">您并没有实际下载它们</em>，只是创建了一个最少的摘录来使用。</p><figure class="mj mk ml mm gt nl gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nk"><img src="../Images/b66ccd4a90c9fd5a46f28fbcd6dc514c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqbC8sdWRNUFnni0SYbueQ.png"/></div></div></figure><h2 id="3dff" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">使用 dbplyr 查询</h2><p id="6225" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">现在让我们试着做一个非常简单的查询，比如我们按照雇佣他们的年份分组了多少员工。如果我们把它写成一个简单的 SQL 查询，它看起来会像这样:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="8fad" class="lk ll iv lj b gy mr ms l mt mu">qry &lt;- "SELECT HireYear, COUNT(EmployeeId) FROM<br/>(SELECT SUBSTR(HireDate, 1, 4) AS HireYear, EmployeeId<br/>FROM employees)<br/>GROUP BY HireYear"</span></pre><p id="0ea0" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在，如果我们运行<code class="fe lg lh li lj b">DBI::dbGetQuery(chinook, qry)</code>,就会得到这个返回:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="6b4e" class="lk ll iv lj b gy mr ms l mt mu">   HireYear count(EmployeeId)<br/>1     2002                 3<br/>2     2003                 3<br/>3     2004                 2</span></pre><p id="9db1" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">但是我们也可以使用如下的代码来实现:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="16e7" class="lk ll iv lj b gy mr ms l mt mu">employees_by_hire_year &lt;- employees %&gt;% <br/>  dplyr::mutate(HireYear = substr(HireDate, 1, 4)) %&gt;% <br/>  dplyr::group_by(HireYear) %&gt;% <br/>  summarize(Total = n())</span></pre><p id="5b36" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">由于这是一个非常小的表，您只需在控制台中键入它的名称就可以看到它，它确实会返回与上面的表相同的表。如果它比较大，您就必须从数据库中收集它——稍后会详细介绍。</p><p id="0fb7" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这种魔力似乎是如何发生的？因为 R 将<code class="fe lg lh li lj b">employees</code>识别为 SQL 数据库对象，所以 R 在后台调用<code class="fe lg lh li lj b">dbplyr</code>将管道化的 tidyverse 代码翻译成 SQL。您可以使用<code class="fe lg lh li lj b">dbplyr::sql_render()</code>函数查看翻译后的 SQL。例如，<code class="fe lg lh li lj b">dbplyr::sql_render(employees_by_hire_year)</code>返回这个:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="5ef2" class="lk ll iv lj b gy mr ms l mt mu">&lt;SQL&gt; SELECT `HireYear`, COUNT() AS `Total`<br/>FROM (SELECT `EmployeeId`, `LastName`, `FirstName`, `Title`, `ReportsTo`, `BirthDate`, `HireDate`, `Address`, `City`, `State`, `Country`, `PostalCode`, `Phone`, `Fax`, `Email`, SUBSTR(`HireDate`, 1, 4) AS `HireYear`<br/>FROM `employees`)<br/>GROUP BY `HireYear`</span></pre><h2 id="31a8" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">让复杂的查询变得简单</h2><p id="2d30" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">上面的例子非常简单，直到你的查询变得非常复杂，你才能真正看到使用<code class="fe lg lh li lj b">dbplyr</code>的好处。</p><p id="8510" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">假设您想计算出客户每年在订单上花了多少钱。这意味着您必须从发票日期中提取年份，然后使用<code class="fe lg lh li lj b">InvoiceId</code>将<code class="fe lg lh li lj b">invoice</code>连接到<code class="fe lg lh li lj b">invoice_items</code>，然后按年份分组，然后计算该年的总单价乘以订购数量。多亏了<code class="fe lg lh li lj b">dbplyr</code>，我们可以使用我们漂亮的 tidyverse 语法来做到这一点:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="1294" class="lk ll iv lj b gy mr ms l mt mu">amount_per_year &lt;- invoices %&gt;% <br/>  dplyr::mutate(InvoiceYear = substr(InvoiceDate, 1, 4) %&gt;%          <br/>                  as.integer()) %&gt;% <br/>  dplyr::inner_join(invoice_items, by = "InvoiceId") %&gt;% <br/>  dplyr::mutate(ItemTotal = UnitPrice * Quantity) %&gt;% <br/>  dplyr::group_by(InvoiceYear) %&gt;% <br/>  dplyr::summarise(Total = sum(ItemTotal))</span></pre><p id="dcc3" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这比它的 SQL 等价物好得多，也更容易使用。注意，在其当前形式下,<code class="fe lg lh li lj b">amount_per_year</code>仍然只是一个数据库对象，数据还没有正式从数据库中提取出来。要正式提取数据，您可以使用<code class="fe lg lh li lj b">dplyr</code>的<code class="fe lg lh li lj b">collect()</code>函数，如下所示:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="422e" class="lk ll iv lj b gy mr ms l mt mu">amount_per_year %&gt;% dplyr::collect()</span></pre><p id="a137" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">它将返回:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="9aee" class="lk ll iv lj b gy mr ms l mt mu"># A tibble: 5 x 2<br/>  InvoiceYear Total<br/>        &lt;int&gt; &lt;dbl&gt;<br/>1        2009  449.<br/>2        2010  481.<br/>3        2011  470.<br/>4        2012  478.<br/>5        2013  451.</span></pre><p id="57b6" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果您在远程数据库上工作，而不是在本地 SQLite 数据库上工作，额外的优势是<code class="fe lg lh li lj b">dbplyr</code>确保所有的操作都在数据库上完成，您只需收集结果，而不必将所有数据提取到您的会话中。</p><h2 id="2b69" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">练习练习</h2><p id="8b96" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">通过尝试以下练习，看看您能否让<code class="fe lg lh li lj b">dbplyr</code>为您的<code class="fe lg lh li lj b">chinook</code>数据集工作:</p><ol class=""><li id="800b" class="mv mw iv km b kn ko kq kr kt mx kx my lb mz lf ns nb nc nd bi translated">按国家分有多少客户？</li><li id="7699" class="mv mw iv km b kn ne kq nf kt ng kx nh lb ni lf ns nb nc nd bi translated">2009 年第一季度开出了多少张发票，按客户所在国家分组？</li><li id="d327" class="mv mw iv km b kn ne kq nf kt ng kx nh lb ni lf ns nb nc nd bi translated">卖给美国顾客的前十首歌曲的名字是什么？(对于这一个，您还需要<code class="fe lg lh li lj b">tracks</code>表)。</li></ol><h2 id="af3b" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">附录</h2><p id="f6fd" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">[1]连接远程数据库的一般代码如下:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="9865" class="lk ll iv lj b gy mr ms l mt mu">conn &lt;- DBI::dbConnect(<br/>  drv = [database driver, eg odbc::odbc()],<br/>  dsn = "database_name",<br/>  uid = "User_ID",<br/>  pwd = "Password"<br/>)</span></pre><p id="589f" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">[2]要在远程数据库的模式中创建一个类似的表，可以使用<code class="fe lg lh li lj b">dbplyr</code>中的<code class="fe lg lh li lj b">in_schema()</code>函数:</p><pre class="mj mk ml mm gt mn lj mo mp aw mq bi"><span id="42a8" class="lk ll iv lj b gy mr ms l mt mu">my_db_tbl &lt;- dplyr::tbl(<br/>  conn, <br/>  dbplyr::in_schema("SCHEMA_NAME", "TABLE_NAME")<br/>)</span></pre><p id="56aa" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">[3]下面是我写的最后一个<code class="fe lg lh li lj b">dbplyr</code>查询的 SQL 翻译:</p><figure class="mj mk ml mm gt nl gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nt"><img src="../Images/a7a573003d6e3d198935fd2afa50938d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoCGbQGWmnD-f1N8hBgyng.png"/></div></div></figure><p id="622c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本 RPG 的超级粉丝。在 <a class="ae mi" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"> <em class="nj"> LinkedIn </em> </a> <em class="nj">或</em><a class="ae mi" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="nj">Twitter</em></a><em class="nj">上找我。</em></p><figure class="mj mk ml mm gt nl gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nu"><img src="../Images/aaf5b7cd4009809e7c4b9782447f5b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_QqtXc4m3ZyAjMF0qK6yA.jpeg"/></div></div></figure></div></div>    
</body>
</html>