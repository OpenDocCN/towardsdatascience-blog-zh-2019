<html>
<head>
<title>Simple plotting in python (so you can concentrate on the bigger thing)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python 中的简单绘图(因此您可以专注于更大的事情)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simple-plotting-library-in-python-43e8ac687d23?source=collection_archive---------33-----------------------#2019-10-10">https://towardsdatascience.com/simple-plotting-library-in-python-43e8ac687d23?source=collection_archive---------33-----------------------#2019-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9688ba02647964c086255efb326b1037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZacvYg5nYi_xs-UyCfXIw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Today it’s all about having the numbers</figcaption></figure><p id="4164" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> TLDR </strong>:使用<a class="ae ld" href="https://github.com/ikamensh/pennpaper" rel="noopener ugc nofollow" target="_blank">的纸笔</a>在建造原型时快速启动你的绘图和洞察力</p><p id="6896" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以你有了新的实验想法💡。也许是一种新的强化学习算法？新哈希表？我不会再尝试猜测了:)为什么要猜测，当我确定你需要做一件事，无论这个想法是什么，来验证它——你需要绘制一些实验数据。所以你知道如何用 python 实现你的想法，而且你在一个令人惊讶的短时间内就做到了。现在是时候观察这个想法在一些不同的输入上的表现了。并查看性能是否可靠，或者每次运行代码时性能是否会发生变化。</p><p id="df07" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么，抽象地说，你将采取什么步骤来可视化你正在运行的过程？以下是我在实验中的想法:</p><ol class=""><li id="d2b8" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">定义我要测量的量'<strong class="kh iu"> Y' </strong>。示例:批次损失</li><li id="3c7f" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">定义<strong class="kh iu"> Y </strong>所依赖的数量'<strong class="kh iu"> x </strong>'(考虑时间步长或输入大小)</li><li id="5d58" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">在我的代码中找到便于记录这些量的值的地方</li><li id="e17c" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">重复几次实验，也许是针对系统的一些不同配置。</li><li id="2eb3" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">产生那些美丽而有见地的情节。</li></ol><p id="5569" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个明确的计划。然而，很少有技术挑战逃过我们的注意:如果我们运行几次实验，以某种方式在图中平均结果并显示它们的方差/标准差是有意义的。</p><p id="7dd5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">..此外，从长远来看，将所有信息存储在一个巨大的全球字典中可能是一件痛苦的事情。</p><p id="2c33" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…此外，这些噪声图可以使用一些过滤。</p><p id="00f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看一个例子，看看我们如何解决它。让我们假设一些添加了噪声的数学函数是您正在开发的新原型:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2743" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">结果，嗯，不是很好:</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/92033cc576280f93bdd2e42fc5ff1e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*jnPEIbVQzaPt6Z6i98Zdhw.png"/></div></figure><p id="8dbb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">介绍<a class="ae ld" href="https://github.com/ikamensh/pennpaper" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">pen ' n ' paper</strong></a>—一个简单方便绘图的 python 库；</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="0110" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">import </strong>pennpaper <strong class="ma iu">as </strong>pp<br/><br/>metrics = <strong class="ma iu">[]<em class="mk"><br/></em>for </strong>name, func <strong class="ma iu">in </strong>funcs.items<strong class="ma iu"><em class="mk">()</em></strong>:<br/>    m = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/>    </em></strong>m.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, func<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/>    </em></strong>metrics.append<strong class="ma iu"><em class="mk">(</em></strong>m<strong class="ma iu"><em class="mk">)<br/><br/></em></strong>pp.plot_group<strong class="ma iu"><em class="mk">(</em></strong>metrics, smoothen=<strong class="ma iu">True<em class="mk">)</em></strong></span></pre><p id="383b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好了，这给了我们一个有名字的传说，并且去掉了大部分的噪音:</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/e49eb0276e586d19cef2150a003bc39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ma_OmZiCjjVVNsJvreO7hw.png"/></div></div></figure><p id="5b07" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来我想做的是，通过对过程进行多次采样，并将有关标准差的信息添加到图中，进一步降低噪声。为了简化代码，让我们从一个函数开始——正弦波。</p><p id="4662" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们得到了单独策划的罪恶:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="5817" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">import </strong>pennpaper <strong class="ma iu">as </strong>pp<br/><br/>name = <strong class="ma iu">'sin'<br/></strong>func = funcs<strong class="ma iu"><em class="mk">[</em></strong>name<strong class="ma iu"><em class="mk">]<br/><br/></em></strong>m1 = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/></em></strong>m1.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, func<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/></em></strong>pp.plot<strong class="ma iu"><em class="mk">(</em></strong>m1, smoothen=<strong class="ma iu">True<em class="mk">)</em></strong></span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/c740adf424cf2a34322b96882c205fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Nmf24R3cXUQfNaKHPi0hIA.png"/></div></figure><p id="cffa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以做的是将纸笔指标相加:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="b6e7" class="me mf it ma b gy mg mh l mi mj">m1 = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/></em></strong>m1.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, func<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/><br/></em></strong>m2 = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/></em></strong>m2.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, func<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/><br/></em></strong>m3 = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/></em></strong>m3.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, func<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/><br/></em></strong>pp.plot<strong class="ma iu"><em class="mk">(</em></strong>m1 + m2 + m3, smoothen=<strong class="ma iu">True<em class="mk">)</em></strong></span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/52986fa3b3bef34fb3c79dda8115ddfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9xQxnUUBJJYRhgWnxgnrLw.png"/></div></figure><p id="2fb4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">似乎有 3 个度量标准有所帮助。让我们有 300？</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="5530" class="me mf it ma b gy mg mh l mi mj">metrics = <strong class="ma iu"><em class="mk">[]<br/><br/></em>for </strong>i <strong class="ma iu">in </strong>range<strong class="ma iu"><em class="mk">(</em></strong>300<strong class="ma iu"><em class="mk">)</em></strong>:<br/>    m = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/>    </em></strong>m.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, func<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/>    </em></strong>metrics.append<strong class="ma iu"><em class="mk">(</em></strong>m<strong class="ma iu"><em class="mk">)<br/><br/><br/></em></strong>pp.plot<strong class="ma iu"><em class="mk">(</em></strong>sum<strong class="ma iu"><em class="mk">(</em></strong>metrics<strong class="ma iu"><em class="mk">)</em></strong>, smoothen=<strong class="ma iu">True<em class="mk">)</em></strong></span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/5e31a28276f47428b7254a78abe73a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*TBHPy-AjWbG96qyILjJRag.png"/></div></figure><p id="59b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大数定律在我们这边，我们得到相当精确的图。另请注意，阴影区域的大小代表标准差，与正弦波相差 2 个单位，这正是我们在噪声公式中输入的值:y += np.random.normal(0，2，size=y.size)。</p><p id="a4f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们把我们所学的放在一起，画出所有 3 个函数，画出一个带平滑的图和一个不带平滑的图:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="ea46" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">import </strong>pennpaper <strong class="ma iu">as </strong>pp<br/><strong class="ma iu">from </strong>collections <strong class="ma iu">import </strong>defaultdict<br/><br/>metrics = defaultdict<strong class="ma iu"><em class="mk">(</em></strong>list<strong class="ma iu"><em class="mk">)<br/><br/></em>for </strong>i <strong class="ma iu">in </strong>range<strong class="ma iu"><em class="mk">(</em></strong>90<strong class="ma iu"><em class="mk">)</em></strong>:<br/>    <strong class="ma iu">for </strong>name, f <strong class="ma iu">in </strong>funcs.items<strong class="ma iu"><em class="mk">()</em></strong>:<br/>        m = pp.Metric<strong class="ma iu"><em class="mk">(</em></strong>name<strong class="ma iu"><em class="mk">)<br/>        </em></strong>m.add_arrays<strong class="ma iu"><em class="mk">(</em></strong>X, f<strong class="ma iu"><em class="mk">(</em></strong>X<strong class="ma iu"><em class="mk">))<br/>        </em></strong>metrics<strong class="ma iu"><em class="mk">[</em></strong>m.name<strong class="ma iu"><em class="mk">]</em></strong>.append<strong class="ma iu"><em class="mk">(</em></strong>m<strong class="ma iu"><em class="mk">)<br/><br/></em></strong>metrics = <strong class="ma iu"><em class="mk">[</em></strong>sum<strong class="ma iu"><em class="mk">(</em></strong>v<strong class="ma iu"><em class="mk">) </em>for </strong>v <strong class="ma iu">in </strong>metrics.values<strong class="ma iu"><em class="mk">()]<br/><br/></em></strong>pp.plot_group<strong class="ma iu"><em class="mk">(</em></strong>metrics<strong class="ma iu"><em class="mk">)<br/></em></strong>pp.plot_group<strong class="ma iu"><em class="mk">(</em></strong>metrics, smoothen=<strong class="ma iu">True<em class="mk">)</em></strong></span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/a818960241464d37965db53d06b90e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9NAEe3eX4dLk6X3CyNbQw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">No smoothing, just the effect of averaging 90 tries</figcaption></figure><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/b6bd82896082eb1e35e4fa994127050c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGKxrWp2SOLKAzkpFpf8sg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Smooth version</figcaption></figure><p id="6252" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">总结</strong>:我们已经学会了如何使用 pen'n'paper Metric class 轻松组合多个测量值，并使用。plot()和。plot_many()方法。您可以使用以下方式安装笔和纸:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="ec16" class="me mf it ma b gy mg mh l mi mj">pip install pennpaper</span></pre><p id="bf9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">给它一颗星🌟这里:<a class="ae ld" href="https://github.com/ikamensh/pennpaper" rel="noopener ugc nofollow" target="_blank">https://github.com/ikamensh/pennpaper</a></p><p id="29a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个我为个人使用而写的便利工具，但是我想你可能会发现它的用处！:)</p></div></div>    
</body>
</html>