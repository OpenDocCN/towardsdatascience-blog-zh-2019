# 面向对象编程的简单混合如何增强你的深度学习原型

> 原文：<https://towardsdatascience.com/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd?source=collection_archive---------3----------------------->

## 通过混合面向对象编程的简单概念，如函数化和类继承，您可以为深度学习原型代码添加巨大的价值。

![](img/04c167081852552c52a3e3dbbe443e98.png)

# 介绍

这篇文章不适合经验丰富的软件工程师。**这是面向数据科学家和机器学习(ML)实践者**的，他们和我一样，没有软件工程背景。

我们在工作中经常使用 Python。为什么？因为这对 ML 和数据科学社区来说太棒了。

它正在成为现代数据驱动分析和人工智能(AI)应用发展最快的主要语言。

然而，它也用于简单的脚本目的，以[自动化东西](https://automatetheboringstuff.com/)，以[测试假设](https://machinelearningmastery.com/statistical-hypothesis-tests-in-python-cheat-sheet/)，为头脑风暴创建[交互图，以](https://mode.com/blog/python-interactive-plot-libraries)[控制实验室仪器](https://hackaday.com/2016/11/16/how-to-control-your-instruments-from-a-computer-its-easier-than-you-think/)等。

但问题是。

**用于软件开发的 Python 和用于脚本编写的 Python 并不完全是同一只野兽——至少在数据科学领域是这样。**

脚本(大部分)是你为自己写的代码。软件是你(和其他队友)为他人编写的代码的集合。

明智的做法是承认，当(大多数)并非来自软件工程背景的数据科学家为 AI/Ml 模型和统计分析编写 Python 程序时，他们倾向于为自己编写这样的代码*。*

*他们只想得到隐藏在数据中的模式的核心。很快。没有深入思考正常凡人- *用户*。*

*他们写了一段代码，产生了丰富而美丽的情节。但是他们没有创造出 ***功能*** 出来，以备后用。*

*他们从标准库中导入大量的 ***方法*** 和 ***类*** 。但是他们没有通过*继承来创建自己的 ***子类*** 并为其添加方法以扩展功能。**

> **脚本(大部分)是你为自己写的代码。软件是你(和其他队友)为他人编写的代码的集合。**

*****、函数、继承、方法、类***——这些是健壮的**面向对象编程(OOP)** 的核心，但是如果你只想用你的数据分析和绘图创建一个 Jupyter 笔记本，它们多少是可以避免的。**

**您可以避免使用 OOP 原则的最初痛苦，但这几乎总是会导致您的笔记本代码不可重用和不可扩展。**

**简而言之，这段代码只为你服务(直到你忘记你到底编码了什么逻辑)，而不是为其他人服务。**

**但是 [**可读性(以及可重用性)至关重要**](https://devblogs.microsoft.com/oldnewthing/20070406-00/?p=27343) 。这是对你作品价值的真正考验。不是为了你自己。但对其他人来说。**

**事实上，数据科学家威尔·科尔森刚刚就这个想法写了一篇精彩的文章。**

**[](/notes-on-software-construction-from-code-complete-8d2a8a959c69) [## 从代码完成看软件构造

### “代码完成:软件构造实用手册”的经验教训及其在数据科学中的应用

towardsdatascience.com](/notes-on-software-construction-from-code-complete-8d2a8a959c69) 

更糟糕的是，数百种关于数据科学和 AI/ML 的流行 MOOC 或在线课程也不强调编码的这一方面，因为这对年轻、热情的学习者来说感觉是一种负担。他/她是来学习很酷的算法和神经网络优化的，而不是 Python 中的 OOP。因此，这一方面仍然被忽视。

那么，你能做什么？

> 您可以避免使用 OOP 原则的最初痛苦，但这几乎总是会导致您的笔记本代码不可重用和不可扩展。

# 简单的 OOP 组合可以强化你的深度学习(DL)代码

我不是软件工程师，这辈子从来没有过。因此，当我开始探索 ML 和数据科学时，我写了大量草率的、不可重用的代码。

渐渐地，我试图变得更好，并对我的编码风格进行简单的改进，使它们更有用(对世界上的任何人)。

而且，我发现在你的数据科学代码中开始混合 OOP 原则并不需要太多。

即使你一生中从未上过软件工程课程，一些想法也可能自然而然地出现在你面前。你所要做的就是站在别人的立场上，想想那个人会如何以一种建设性的方式接受和使用你的代码。

*   如果您有一个代码块在您的分析中出现了不止一次(以完全相同的形式或略有不同)，您能把它变成一个函数吗？
*   当你做这样一个函数时，会传递什么参数？哪一个是可选的？默认值会是什么？
*   如果您遇到不知道需要传递多少参数的情况，[您是否在使用 Python 提供的*args、* * kwargs](https://www.geeksforgeeks.org/args-kwargs-python/)？
*   你是否为函数写了一个 [docstring 来让其他人知道这个函数做什么以及它期望什么参数，举个例子？](https://www.geeksforgeeks.org/python-docstrings/)
*   当你收集了一堆这样的实用函数后，你是否还在同一个笔记本上工作，或者[切换到一个新的、干净的笔记本，并从*my _ utility _ script*import*func 1，func2，func3* (你是否创建了一个 *my_utility_script* 作为一个简单的 Python 文件而不是 Jupyter 笔记本)？](http://web.cs.iastate.edu/~smkautz/cs127f16/notes/chapter07/)
*   有没有把 *my_utility_script* 放到一个目录里，[放一个 *__init__。py* 文件(即使是一个空文件)放在同一个目录中，并使它成为 Python 模块](https://timothybramlett.com/How_to_create_a_Python_Package_with___init__py.html)以便像 NumPy 或 Pandas 一样可以导入？
*   你是否在考虑不仅仅是从像 NumPy 和 TensorFlow 这样的优秀包中导入类和方法，而是向它们添加你自己的方法并扩展它们的功能？

我说的这些到底是什么意思？让我们用一个简单的案例来演示一下——一个关于[时尚 MNIST](https://github.com/zalandoresearch/fashion-mnist) 数据集的 DL 图像分类问题。

> 而且，我发现在你的数据科学代码中开始混合 OOP 原则并不需要太多。

# DL 分类任务的案例说明:

## 方法

详细的笔记本在我的 Github repo 中给出。鼓励你去过一遍，叉一下，供自己使用和扩展。

代码对于构建优秀的软件来说是必不可少的，但不一定适合中等水平的文章，你阅读这些文章是为了获得洞察力，而不是练习调试或重构。

因此，我将只选择一些代码片段，并尝试指出我是如何试图在本笔记本中对一些原则进行编码的，这些原则在前面已有详细介绍。

## 核心 ML 任务和高阶业务问题

ML 的核心任务很简单——为 [**时尚 MNIST**](https://github.com/zalandoresearch/fashion-mnist) 数据集构建深度学习分类器，这是对最初著名的 MNIST 手写数字数据集的有趣旋转。“时尚 MNIST”由 60，000 幅 28 x 28 像素大小的训练图像组成，包括与时尚相关的对象，如帽子、鞋子、裤子、t 恤、连衣裙等。它还包含 10，000 张测试图像，用于模型验证和测试。

![](img/6d69f990be0234a75d9805f76ef8672e.png)

**Fashion MNIST (**[**https://github.com/zalandoresearch/fashion-mnist**](https://github.com/zalandoresearch/fashion-mnist)**)**

但是，如果围绕这个核心 ML 任务有一个更高阶的优化或可视化分析问题— ***模型架构的复杂性如何影响达到期望精度所需的最小时期*** 呢？

> 读者应该很清楚，我们为什么要为这样一个问题而烦恼。**因为这关系到整体的业务优化**。[训练一个神经网络不是一件微不足道的计算事情](https://www.technologyreview.com/s/613630/training-a-single-ai-model-can-emit-as-much-carbon-as-five-cars-in-their-lifetimes/)。因此，有必要调查一下**要达到目标性能指标必须花费的最少培训工作量，以及架构的选择如何影响**。

在这个例子中，我们甚至不使用卷积网络，因为简单的密集连接的神经网络可以实现相当高的精度，事实上，需要某种次优的性能来说明我们上面提出的高阶优化问题的要点。

## 我们的解决方案

所以，我们必须解决两个问题-

*   如何确定达到所需精度目标的最小历元数？
*   模型的具体架构如何影响这个数字或训练行为？

为了实现目标，我们将使用两个简单的 OOP 原则，

*   从基类对象创建一个[继承类](https://www.digitalocean.com/community/tutorials/understanding-class-inheritance-in-python-3)
*   创建实用函数，并从紧凑的代码块中调用它们，这些代码块可以呈现给外部用户，以便进行更高阶的优化和分析

## 展示良好实践的代码片段

这里我们展示了一些代码片段来说明简单的 OOP 原则是如何被用来实现我们的解决方案的。为了便于理解，这些片段标有注释。

*首先，我们继承了一个 Keras 类，并编写了我们自己的子类，添加了一个方法来检查训练准确性，并根据该值采取行动。*

![](img/497202a921a80c06257377cd3e473551.png)

这个[简单的回调](http://keras.io/callbacks/)导致**对历元**的动态控制——当精度达到期望的阈值时，训练自动停止。

![](img/b2285212ade05a3650c944225f8fc6cf.png)

我们将 Keras 模型构造代码放在一个效用函数中，这样**一个任意数量的层和架构(只要它们是紧密连接的)的模型可以使用一些函数参数形式的简单用户输入来生成**。

![](img/af9af43c717b1e29cd41d1c1e6ed8cf3.png)

我们甚至可以将编译和训练代码放入一个实用函数中，以便**在高阶优化循环**中方便地使用这些超参数。

![](img/30ca985629fb46ae1612de42d87961a1.png)

接下来，是可视化的时候了。在这里，我们再次通过功能化的实践。通用绘图函数将原始数据作为输入。然而，如果我们有一个特定的目的来绘制训练集准确性的演变并显示它如何与目标进行比较，那么我们的**绘图函数应该只是将深度学习模型作为输入**并生成所需的绘图。

![](img/6a9acca6c082516ba1b7e0ded37d2b34.png)

典型结果如下所示:

![](img/297ea767297823aca0bae5b9757acb32.png)

## 最终分析代码—超级简洁

现在，我们可以利用前面定义的所有函数和类，将它们组合起来完成更高级的任务。

因此，我们的最终代码将非常紧凑，但对于各种精度阈值和神经网络架构，它会生成相同的随时间变化的损失和精度曲线，如上文所示。

这将使用户能够使用最少量的代码来产生关于性能度量(在这种情况下是精度)和神经网络架构的选择的可视化分析。**这是建立优化的机器学习系统的第一步。**

我们生成一些案例进行调查，

![](img/d4cffb18140ca876c30f81842d0be33d.png)

对于不需要了解 Keras 模型构建或回调类的复杂性的高级用户来说，我们最终的分析/优化代码简洁易懂**。**

> 这是 OOP 背后的核心原则——复杂性层的抽象，我们能够完成我们的深度学习任务。

注意，我们是如何将`print_msg=False`传递给类实例的。虽然我们需要基本的状态打印来进行初始检查/调试，但是我们应该静默地执行优化任务的分析。如果我们的类定义中没有这个参数，那么我们就没有办法停止打印调试消息。

我们展示了一些有代表性的结果，这些结果是通过执行上面的代码块自动生成的。它清楚地表明，如何用最少量的高级代码，我们能够生成可视化分析，以判断各种性能指标水平的各种神经架构的相对性能。这使得用户在不调整较低级功能的情况下，根据他/她的性能需求，容易地对型号的选择做出判断。

![](img/86bacc0fbfdc770b4ee18c3bcf1ec774.png)

此外，请注意每个图的自定义标题。这些标题清楚地阐明了神经网络的目标性能和复杂性，从而使分析变得容易。

这是对绘图实用程序功能的一个小小的补充，但这表明在创建这样的功能时需要仔细规划。如果我们没有为函数设计这样一个参数，就不可能为每个图生成一个自定义标题。API(应用程序接口)的精心规划是良好 OOP 的重要组成部分。

# 最后，将脚本转换成简单的 Python 模块

到目前为止，您可能正在使用一个 Jupyter 笔记本，但是您可能希望将这个练习变成一个整洁的 Python 模块，您可以随时从它导入。

就像你写“*从 matplotlib 导入 pyplot* ”一样，你可以在任何地方导入这些实用函数(Keras 模型构建、训练和绘图)。

![](img/11defc1c4997c53285773a8988252040.png)

# 总结和结论

我们展示了一些简单的好的实践，借用了 OOP，应用于一个 DL 分析任务。对于经验丰富的软件开发人员来说，几乎所有这些都可能看起来微不足道，但**这篇文章是为初露头角的数据科学家写的，他们可能没有这方面的背景，但应该明白在他们的机器学习工作流程中灌输这些良好实践的重要性**。

[笔记本在这里](https://github.com/tirthajyoti/Deep-learning-with-Python/blob/master/Notebooks/OOP_principle_deep_learning.ipynb)。

冒着重复太多遍的风险，让我再次总结一下好的实践，

*   只要有机会，**将重复的代码块转化为实用函数**
*   **仔细考虑函数**的 API，即需要什么样的最小参数集，以及它们将如何为更高级别的编程任务服务
*   不要忘记为一个函数写一个 docstring ,即使它只是一行描述
*   如果你开始积累与同一个对象相关的许多实用函数，考虑**将那个对象变成一个类**并将这些实用函数作为方法
*   **只要有机会使用继承完成复杂的分析，就扩展类的功能**
*   **不要停留在 Jupyter 笔记本**。将它们转换成**可执行脚本**并放入**小模块**。养成将工作模块化的习惯，这样任何人、任何地方都可以轻松重用和扩展工作。

谁知道呢，当你积累了足够多有用的类和子模块的时候，你可能会在 Python 包存储库(PyPi 服务器)上发布一个实用程序包。你将有权利吹嘘自己发布了一个原始的开源软件包，然后:-)** 

**如您有任何疑问或想法可分享，请通过[**tirthajyoti[AT]Gmail . com**](mailto:tirthajyoti@gmail.com)与作者联系。此外，您还可以在作者的 [**GitHub**](https://github.com/tirthajyoti?tab=repositories) **知识库**中查找 Python、R 或 MATLAB 中其他有趣的代码片段以及机器学习资源。如果你像我一样，对机器学习/数据科学充满热情，请随时在领英上添加我或在推特上关注我。**

**[](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/) [## Tirthajyoti Sarkar - Sr .首席工程师-半导体，人工智能，机器学习- ON…

### 乔治亚理工学院理学硕士- MS，Analytics 本 MS 课程教授理论和实践…

www.linkedin.com](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/)**