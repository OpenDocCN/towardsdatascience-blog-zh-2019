<html>
<head>
<title>Moving from Keras to Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从喀拉斯到皮托尔彻</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/moving-from-keras-to-pytorch-f0d4fff4ce79?source=collection_archive---------2-----------------------#2019-05-28">https://towardsdatascience.com/moving-from-keras-to-pytorch-f0d4fff4ce79?source=collection_archive---------2-----------------------#2019-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1272" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么？怎么会？没那么难。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3764db002117b9cd3c8e0912d83eadd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eaz3ynVqdcI2TYBA"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Clode</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="26b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pytorch 很棒。但这对初学者来说并不容易。</p><p id="e7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我在 Kaggle 上与一个关于文本分类的竞赛合作，作为竞赛的一部分，我不得不设法转移到 Pytorch 以获得确定性的结果。结果不会随着网络的每次运行而改变，以尝试不同的模型并获得一致的结果。</p><p id="230d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我过去一直与 keras 一起工作，它给了我相当好的结果，但不知何故，我知道 Keras 中的<strong class="lb iu"> CuDNNGRU/CuDNNLSTM 层不是确定性的</strong>，即使在设置种子之后。</p><p id="206b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<a class="ae ky" href="https://amzn.to/2LxRTe6" rel="noopener ugc nofollow" target="_blank"> Pytorch </a>确实来救援了。我很高兴我考虑过搬家。</p><p id="d303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为<strong class="lb iu">边注</strong>:如果你想了解更多关于<strong class="lb iu"> NLP </strong>的知识，我想推荐<a class="ae ky" href="https://coursera.pxf.io/7mKnnY" rel="noopener ugc nofollow" target="_blank">深度学习专精</a>中关于<a class="ae ky" href="https://coursera.pxf.io/7mKnnY" rel="noopener ugc nofollow" target="_blank">序列建模</a>的这门牛逼课程。本课程涵盖了自然语言处理中从基础到高级的各种任务:情感分析、摘要、对话状态跟踪等等。</p><p id="a6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">虽然 Keras 在深度学习方面起步很好，但随着时间的推移，你会对它的一些局限性感到不满。</em> </strong></p><p id="007c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也想过搬到 Tensorflow。这似乎是一个很好的过渡，因为 TF 是 Keras 的后端。</p><p id="b547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这很难吗？</p><p id="b0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于整个<code class="fe lw lx ly lz b">session.run</code>命令和张量流会话，我有点困惑。它根本不是毕氏的。</p><p id="9477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pytorch 在这方面有所帮助，因为它更像 Pythonic。一切都在你的掌控之中，在性能方面没有任何损失。也许真的有所收获。</p><p id="3902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用安德烈·卡帕西的话说:</p><blockquote class="ma mb mc"><p id="f2e4" class="kz la lv lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">我已经使用 PyTorch 几个月了，从来没有感觉这么好过。我有更多的精力。我的皮肤更干净了。我的视力提高了。</p><p id="45ca" class="kz la lv lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><em class="it"> —安德烈·卡帕西(@卡帕西)</em><a class="ae ky" href="https://twitter.com/karpathy/status/868178954032513024?ref_src=twsrc%5Etfw" rel="noopener ugc nofollow" target="_blank"><em class="it">2017 年 5 月 26 日</em> </a></p></blockquote><p id="9e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以事不宜迟，让我为你把 Keras 翻译成 Pytorch。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="6b95" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">写你的网络的经典方式？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/160484064a1e87f04e9a73d116aeeacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4gkeS7kykNe-lrkA"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">OOPs: Object-Oriented Programming</figcaption></figure><p id="110d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先在 keras 中创建一个示例网络，我们将尝试将它移植到 Pytorch 中。</p><p id="18c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我也想给你一个建议。当你试图从 Keras 迁移到 Pytorch <strong class="lb iu">时，使用你拥有的任何网络，并尝试将其移植到 Pytorch </strong>。这会让你更好地理解 Pytorch。</p><p id="6fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我试着写一个在 Quora 虚假问题分类挑战中给我很好结果的网络。</p><p id="8ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模型具有至少任何文本分类深度学习网络可以包含的所有功能，包括 GRU、LSTM 和嵌入层，以及元输入层。因此可以作为一个很好的例子。</p><p id="378d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于比尔斯特姆/GRU 和注意力模型是如何工作的，请访问我的帖子<a class="ae ky" href="https://mlwhiz.com/blog/2018/12/17/text_classification/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此 pytorch 中的模型被定义为一个从<code class="fe lw lx ly lz b">nn.module</code>继承而来的类(因此更优雅一点)。每个类都必须包含一个<code class="fe lw lx ly lz b">__init__</code>程序块和一个<code class="fe lw lx ly lz b">forward</code>通道块。</p><ul class=""><li id="2121" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">在<code class="fe lw lx ly lz b">__init__</code>部分，用户定义了网络将要拥有的所有层，但还没有定义这些层如何相互连接</li><li id="a8da" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">在正向传递模块中，用户定义数据如何在网络中从一层流向另一层。</li></ul><h1 id="e03e" class="mn mo it bd mp mq nw ms mt mu nx mw mx jz ny ka mz kc nz kd nb kf oa kg nd ne bi translated">为什么这是经典？</h1><p id="573c" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我发现这是有益的，原因如下:</p><p id="c200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)它让你对如何构建你的网络有很大的控制权。</p><p id="5a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)当您构建网络时，您对网络有很多了解，因为您必须指定输入和输出维度。所以<strong class="lb iu">出错的几率</strong>更少。(虽然这个真的要看技能水平了)</p><p id="b24a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3) <strong class="lb iu">易于调试的</strong>网络。任何时候你发现网络有任何问题，只要在正向传递中使用类似<code class="fe lw lx ly lz b">print("avg_pool", avg_pool.size())</code>的东西来检查层的大小，你就可以很容易地调试网络</p><p id="9067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)您可以<strong class="lb iu">从正向层返回多个输出</strong>。这在编码器-解码器架构中非常有用，因为您可以返回编码器和解码器的输出。或者在 autoencoder 的情况下，您可以返回模型的输出和数据的隐藏层嵌入。</p><p id="b0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5) <strong class="lb iu"> Pytorch 张量的工作方式与 numpy 数组非常相似</strong>。例如，我可以使用 Pytorch Maxpool 函数来编写 Maxpool 层，但是<code class="fe lw lx ly lz b">max_pool, _ = torch.max(h_gru, 1)</code>也可以。</p><p id="4422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6)您可以用不同的初始化方案设置<strong class="lb iu">不同的层。一些你在喀拉斯做不到的事。例如，在下面的网络中，我改变了我的 LSTM 层的初始化方案。LSTM 图层对于偏差、输入图层权重和隐藏图层权重具有不同的初始化。</strong></p><p id="aba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7)等到你看到 Pytorch 中的<strong class="lb iu">训练环，你会对它提供的那种<strong class="lb iu">控制</strong>感到惊讶。</strong></p><p id="164c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在 Pytorch 中的同一个模型看起来会像这样。请仔细阅读代码注释，了解更多关于如何移植的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你还和我在一起。我想在这里强调的一点是，你需要用 Pytorch 编写一些代码来真正理解它是如何工作的。</p><p id="5456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且知道一旦你这样做了，你会很高兴你付出了努力。进入下一部分。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c3a8" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">高度可定制的训练循环</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/1c397f455901dc568d778730f877ec0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*387SBS-9wqXQ2Udo"/></div></div></figure><p id="e50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的部分，我写道，一旦你看到训练循环，你会感到惊讶。这是一种夸张。</p><p id="fd54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次尝试时，你会有点困惑。</p><p id="c621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是一旦你不止一次地通读这个循环，你会有很多直观的感觉。再次阅读注释和代码以获得更好的理解。</p><p id="1db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该训练循环对训练数据进行 k 重交叉验证，并输出对测试数据的运行进行平均的非折叠 train_preds 和 test_preds。</p><p id="e2b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个流程看起来像是从 kaggle 竞赛中直接出来的，我很抱歉，但是如果你明白这一点，你就能够为自己的工作流程创建一个训练循环。这就是 Pytorch 的魅力。</p><p id="8d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这个循环的简要总结如下:</p><ul class=""><li id="0d76" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">使用培训数据创建分层拆分</li><li id="d10d" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">循环遍历拆分。</li><li id="8f4d" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe lw lx ly lz b">X_train_fold = torch.tensor(x_train[train_idx.astype(int)], dtype=torch.long).cuda()</code>命令将训练和 CV 数据转换为张量并将数据加载到 GPU</li><li id="dcbd" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe lw lx ly lz b">model.cuda()</code>命令将模型加载到 GPU 上</li><li id="725c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">定义损失函数、调度程序和优化程序</li><li id="6e72" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">创建<code class="fe lw lx ly lz b">train_loader</code>和 valid_loader `来迭代批处理。</li><li id="04b8" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">开始运行纪元。在每个时代</li><li id="6fdf" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe lw lx ly lz b">model.train()</code>将模型模式设置为训练。</li><li id="d9dc" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">检查<code class="fe lw lx ly lz b">train_loader</code>中的批次并向前运行</li><li id="3019" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">运行调度程序步骤以更改学习率</li><li id="5016" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">计算损失</li><li id="8c49" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">将优化器中的现有梯度设置为零</li><li id="73a8" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">通过网络反向传播损失</li><li id="af25" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">剪切渐变</li><li id="2ab8" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">采取优化步骤来改变整个网络中的权重</li><li id="4db9" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe lw lx ly lz b">model.eval()</code>将模型模式设置为评估。</li><li id="6ddd" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe lw lx ly lz b">valid_loader</code>获得验证数据的预测，并存储在变量<code class="fe lw lx ly lz b">valid_preds_fold</code>中</li><li id="5499" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">计算损失并打印</li><li id="fe26" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">所有历元完成后，预测测试数据并存储预测。这些预测将在分割循环结束时进行平均，以获得最终的<code class="fe lw lx ly lz b">test_preds</code></li><li id="8370" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe lw lx ly lz b">train_preds[valid_idx] = valid_preds_fold</code>获得列车组的脱叠(OOF)预测</li><li id="384d" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">然后，这些 OOF 预测可用于计算模型的局部 CV 分数。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="a7a9" class="oh mo it bd mp oi oj dn mt ok ol dp mx li om on mz lm oo op nb lq oq or nd os bi translated">但是为什么呢？为什么这么多代码？</h2><p id="33c4" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">好吧。我明白了。这可能是少数。在 keras 中用一个简单的<code class="fe lw lx ly lz b">.fit</code>就可以完成的事情，在 Pytorch 中需要大量代码才能完成。</p><p id="aaa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但要明白，你也获得了很多权力。您需要了解的一些使用案例:</p><ul class=""><li id="a56e" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">在<a class="ae ky" href="https://amzn.to/2LxRTe6" rel="noopener ugc nofollow" target="_blank"> Keras </a>中，你可以像<code class="fe lw lx ly lz b">ReduceLROnPlateau</code>一样预先指定调度程序(编写它们是一项任务)，而在 Pytorch 中，你可以疯狂地尝试。<strong class="lb iu">如果你知道如何写 Python，你会过得很好</strong></li><li id="98fa" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">想在两个时期之间改变模型的结构。是的，你能做到。动态更改卷积网络的输入大小。</li><li id="cf82" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">还有更多。只有你的想象会阻止你。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="652b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">想自己经营吗？</h1><p id="2a2e" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">这里还有一个小小的坦白。</p><p id="e02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将不会运行，因为有一些代码工件，我没有在这里显示。我这样做是为了让帖子更具可读性。就像你在上面的代码中看到的<code class="fe lw lx ly lz b">seed_everything</code>、<code class="fe lw lx ly lz b">MyDataset</code>和<code class="fe lw lx ly lz b">CyclicLR</code>(来自杰瑞米·霍华德课程)函数和类，它们并没有真正包含在 Pytorch 中。但别担心，我的朋友。</p><p id="dcc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试过用完整的运行代码写一个<a class="ae ky" href="https://www.kaggle.com/mlwhiz/third-place-model-for-toxic-comments-in-pytorch" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Kaggle 内核</strong> </a> <strong class="lb iu"> </strong>。<a class="ae ky" href="https://www.kaggle.com/mlwhiz/third-place-model-for-toxic-comments-in-pytorch" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="lv">您可以在这里看到代码，并将其包含在您的项目中。</em> </strong> </a></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="7a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看 Google Cloud Specialization 上的<a class="ae ky" href="https://coursera.pxf.io/5bDx3b" rel="noopener ugc nofollow" target="_blank">高级机器学习。本课程将讨论模型的部署和生产。绝对推荐。</a></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="58a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以后也会写更多这样的帖子。让我知道你对这个系列的看法。在<a class="ae ky" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="lb iu">中</strong> </a>关注我或者订阅我的<a class="ae ky" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae ky" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p></div></div>    
</body>
</html>