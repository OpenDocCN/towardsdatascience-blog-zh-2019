<html>
<head>
<title>Speeding up Model Training with Multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用多线程加速模型训练</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speeding-up-model-training-with-multithreading-462df558d4f4?source=collection_archive---------20-----------------------#2019-08-12">https://towardsdatascience.com/speeding-up-model-training-with-multithreading-462df558d4f4?source=collection_archive---------20-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/2430dfa2fc2672228b35bf7f636c01a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*4_Tz82H6xxgYd7YE-2NtYA.png"/></div></figure><p id="949f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">等待模特训练结束有时会让人感到沮丧。加速这一过程可能是每个数据科学家心中最优先考虑的事情之一。有几种方法可以尝试，仅举几个例子:硬件升级(更快的 CPU/GPU)和特定于模型的调整(例如，对于反向传播，可以尝试不同的优化器以实现更快的收敛)。但是，如果您的硬件升级预算申请一直悬而未决，或者现有的优化器都没有带来显著的改进，该怎么办呢？</p><p id="d04e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并非所有的希望都破灭了。我们仍然可以使我们的计划更加有效。今天，我要谈谈多线程。具体来说，如何同时运行(1)从磁盘到 RAM 的数据加载(这是 CPU 密集型的)和(2)模型训练(这通常是 GPU 密集型的)。</p><h2 id="d779" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated"><strong class="ak">一个虚拟的例子</strong></h2><p id="3c6d" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">首先，让我们加载库依赖项。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b222" class="kv kw it ly b gy mc md l me mf">import threading<br/>import time</span><span id="e7bc" class="kv kw it ly b gy mg md l me mf">from tqdm import tqdm</span></pre><p id="eb85" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设我们有两个功能:数据加载和模型训练。出于本教程的考虑，我将用一种延时方法来代替实函数。在这种情况下，数据加载需要 2 秒，而模型训练需要 3 秒。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a08c" class="kv kw it ly b gy mc md l me mf"># replace with train model - suppose it takes 3 seconds to train<br/>def _trainModel():<br/>  time.sleep(3)<br/>  return</span><span id="43af" class="kv kw it ly b gy mg md l me mf"># replace with load data function - suppose it takes 2 seconds to load<br/>def _loadData():<br/>  time.sleep(2)<br/>  return</span></pre><p id="eb60" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设我们的模型训练是反向传播的形式，这需要运行许多纪元。我们选择了任意数量的历元进行循环:10 次</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0ea6" class="kv kw it ly b gy mc md l me mf"># assume we loop 10 times<br/>epochs = 10</span></pre><p id="e78c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们按照常规运行循环，即在数据加载和模型训练之间交替，我们可以看到完成 10 个时期总共需要 50 秒。从下面的图(由<a class="ae mh" href="https://tqdm.github.io/" rel="noopener ugc nofollow" target="_blank"> tqdm </a>生成)中，我们看到每个历元大约需要 5 秒(2 秒加载数据，3 秒训练模型)。</p><blockquote class="mi mj mk"><p id="410a" class="jx jy ml jz b ka kb kc kd ke kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt ku im bi translated">原始时间=数据 _ 加载 _ 时间+训练 _ 模型 _ 时间</p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="11c6" class="kv kw it ly b gy mc md l me mf"># without multithreading<br/># use with for tqdm to properly shut tqdm down if exception appears<br/>with tqdm(range(epochs)) as epochLoop:<br/>  for _ in epochLoop:<br/>    # loadData<br/>    _loadData()<br/>    <br/>    # trainModel<br/>    _trainModel()</span></pre><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/1ef3f941df7152d99b7e4e35aa8a9d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMzj61Vx3Df1AKxhsPMOqA.png"/></div></div></figure><p id="3f47" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们将尝试使用 python 的线程模块并行运行数据加载和模型训练。首先，我们必须为每个函数创建一个类，扩展线程。线程父类。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="73d6" class="kv kw it ly b gy mc md l me mf">class TrainModel (threading.Thread):<br/>    def __init__(self, data):<br/>        threading.Thread.__init__(self)<br/>        self.data = data<br/>    def run(self):<br/>        # return model loss<br/>        self._return = _trainModel()    <br/>    def join(self):<br/>        threading.Thread.join(self)<br/>        return self._return</span><span id="da05" class="kv kw it ly b gy mg md l me mf">class LoadData (threading.Thread):<br/>    def __init__(self, filenames):<br/>        threading.Thread.__init__(self)<br/>        self.filenames = filenames<br/>    def run(self):        <br/>        # return data<br/>        self._return = _loadData()<br/>    def join(self):<br/>        threading.Thread.join(self)<br/>        return self._return</span></pre><p id="b82c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们可以通过调用生成的线程类再次运行这些函数。在这里，我们可以观察到 10 个纪元所用的时间已经下降到 30 秒。这比之前的 50 秒提高了 40%！这里发生的情况是，我们并行运行数据加载和模型训练。每个历元所用的时间不再是这两个函数的总和。现在是两者中的最大值。</p><blockquote class="mi mj mk"><p id="faff" class="jx jy ml jz b ka kb kc kd ke kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt ku im bi translated">多线程时间= max(数据加载时间，训练模型时间)</p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9a87" class="kv kw it ly b gy mc md l me mf"># with multithreading<br/># use with for tqdm to properly shut tqdm down if exception appears<br/>with tqdm(range(epochs)) as epochLoop:<br/>  for _ in epochLoop:<br/>    # loadData<br/>    loadThread = LoadData(None)<br/>    loadThread.start()<br/>    <br/>    # trainModel<br/>    trainThread = TrainModel(None)<br/>    trainThread.start()<br/>    <br/>    # only continue if both threads are done<br/>    modelLoss = trainThread.join()<br/>    data = loadThread.join()</span></pre><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mu"><img src="../Images/43e5bd3d06873ec96b4317919c300890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o116xgr3yc7ghrMXYd0PIA.png"/></div></div></figure><h2 id="51fd" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated"><strong class="ak">结论</strong></h2><p id="ec86" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">我们刚刚看到多线程可以帮助减少模型训练中每个时期所花费的时间。请注意，如果出现以下情况，此方法不会有太大帮助:</p><ol class=""><li id="54ac" class="mv mw it jz b ka kb ke kf ki mx km my kq mz ku na nb nc nd bi translated">没有更多的 CPU 资源来产生另一个线程</li><li id="c6ce" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">最初花费的时间是由一个过程决定的。如果模型训练需要 10 秒，数据加载需要 0.1 秒，那么通常总共需要 101 秒(10 个时期)的时间将变成 100 秒。这相当于只有大约 1%的改善。换句话说，为了使多线程有效，所有进程的最大时间应该比它们的总和小得多。</li></ol></div></div>    
</body>
</html>