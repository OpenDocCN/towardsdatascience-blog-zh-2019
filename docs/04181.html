<html>
<head>
<title>Apply and Lambda usage in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫的应用和λ的使用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apply-and-lambda-usage-in-pandas-b13a1ea037f7?source=collection_archive---------0-----------------------#2019-07-01">https://towardsdatascience.com/apply-and-lambda-usage-in-pandas-b13a1ea037f7?source=collection_archive---------0-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b7b29f0c12a53461e3c4df80e10d1800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WprttYz2ksxsdXBH"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="b3a3" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">学习这些来掌握熊猫</h2></div><p id="1346" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熊猫是你可以随意使用的一个很好的工具。</p><p id="c1ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经和熊猫一起工作了很多年，它的新功能、快捷方式和做一件特定事情的多种方式一直让我感到惊讶。</p><p id="f1cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但我意识到，坚持我学到的一些惯例多年来对我很有帮助。</p><p id="3134" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">apply</code>和<code class="fe lu lv lw lx b">lambda</code>是我在熊猫身上学到的一些最好的东西。</p><p id="ba95" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我为一个新的列或过滤器构建复杂的逻辑时遇到困难，我就会使用<code class="fe lu lv lw lx b">apply</code>和<code class="fe lu lv lw lx b">lambda</code>。</p><p id="4ab1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当企业向您提出定制请求时，这种情况经常发生。</p><p id="685f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">这个帖子是向你展示</em> </strong> <code class="fe lu lv lw lx b"><strong class="la jk"><em class="ly">apply</em></strong></code> <strong class="la jk"> <em class="ly">和</em> </strong> <code class="fe lu lv lw lx b"><strong class="la jk"><em class="ly">lambda</em></strong></code> <strong class="la jk"> <em class="ly">的威力。</em> </strong></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="9319" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将使用 IMDB 上过去 10 年中 1000 部流行电影的数据集。你也可以跟随在<a class="ae jg" href="https://www.kaggle.com/mlwhiz/apply-and-lambda-for-pandas" rel="noopener ugc nofollow" target="_blank"> Kaggle 内核</a>中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ff07" class="mg mh jj bd mi mj mk ml mm mn mo mp mq kp mr kq ms ks mt kt mu kv mv kw mw mx bi translated">创建列</h1><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/33003c86228b03b076d77d6da28c8cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVNQOYLhxUqlzzf6t3aFkg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Complex columns</figcaption></figure><p id="fbfc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过多种方式创建新列。</p><p id="1d7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想要一个列是列的和或差，你可以使用简单的基本算法。在这里，我得到了基于 IMDB 和标准化 Metascore 的平均评级。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="5555" class="nh mh jj lx b gy ni nj l nk nl">df['AvgRating'] = (df['Rating'] + df['Metascore']/10)/2</span></pre><p id="5309" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是有时我们可能需要围绕新列的创建构建复杂的逻辑。</p><p id="1b34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举一个复杂的例子，假设我们想要基于各种因素构建一个自定义的电影评分。</p><p id="276c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">比如说，如果电影是惊悚片，我想在 IMDB 评分保持小于等于 10 的条件下，在 IMDB 评分上加 1。如果一部电影是喜剧，我想从评分中减去 1。</em> </strong></p><p id="6c3e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">我们怎么做呢？</em> </strong></p><p id="8103" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我掌握了如此复杂的问题，我就使用<code class="fe lu lv lw lx b">apply/lambda</code>。让我首先向您展示我将如何做这件事。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="f858" class="nh mh jj lx b gy ni nj l nk nl">def custom_rating(genre,rating):<br/>    if 'Thriller' in genre:<br/>        return min(10,rating+1)<br/>    elif 'Comedy' in genre:<br/>        return max(0,rating-1)<br/>    else:<br/>        return rating<br/>        <br/>df['CustomRating'] = df.apply(lambda x: custom_rating(x['Genre'],x['Rating']),axis=1)</span></pre><p id="6a91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般结构是:</p><ul class=""><li id="b258" class="nm nn jj la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">您定义了一个函数，该函数将接受您想要处理的列值，以得出您的逻辑。在这里，我们最终使用的两列是流派和评级。</li><li id="f98e" class="nm nn jj la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">沿着 axis=1 的行使用带有 lambda 的应用函数。一般语法是:</li></ul><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="4a7a" class="nh mh jj lx b gy ni nj l nk nl">df.apply(lambda x: func(x['col1'],x['col2']),axis=1)</span></pre><p id="5fff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该能够使用 apply/lambda 创建几乎任何逻辑，因为您只需担心自定义函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="da8d" class="mg mh jj bd mi mj mk ml mm mn mo mp mq kp mr kq ms ks mt kt mu kv mv kw mw mx bi translated">过滤数据帧</h1><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/3123d5369072b950fe0ccf92662c1c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V1JJVAtxAes7o30g"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Filtering….</figcaption></figure><p id="2509" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熊猫使过滤和子集化数据框架变得相当容易。您可以使用普通运算符和<code class="fe lu lv lw lx b">&amp;,|,~</code>运算符对数据帧进行过滤和子集化。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="5a5b" class="nh mh jj lx b gy ni nj l nk nl"># Single condition: dataframe with all movies rated greater than 8</span><span id="dad1" class="nh mh jj lx b gy ob nj l nk nl">df_gt_8 = df[df['Rating']&gt;8]</span><span id="3bc5" class="nh mh jj lx b gy ob nj l nk nl"># Multiple conditions: AND - dataframe with all movies rated greater than 8 and having more than 100000 votes</span><span id="504e" class="nh mh jj lx b gy ob nj l nk nl">And_df = df[(df['Rating']&gt;8) &amp; (df['Votes']&gt;100000)]</span><span id="fe78" class="nh mh jj lx b gy ob nj l nk nl"># Multiple conditions: OR - dataframe with all movies rated greater than 8 or having a metascore more than 90</span><span id="db6e" class="nh mh jj lx b gy ob nj l nk nl">Or_df = df[(df['Rating']&gt;8) | (df['Metascore']&gt;80)]</span><span id="9996" class="nh mh jj lx b gy ob nj l nk nl"># Multiple conditions: NOT - dataframe with all emovies rated greater than 8 or having a metascore more than 90 have to be excluded</span><span id="e124" class="nh mh jj lx b gy ob nj l nk nl">Not_df = df[~((df['Rating']&gt;8) | (df['Metascore']&gt;80))]</span></pre><p id="a4d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很简单的东西。</p><p id="b636" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但有时我们可能需要进行复杂的过滤操作。</p><p id="0201" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时我们需要做一些操作，而仅仅使用上面的格式是做不到的。</p><p id="1694" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:我们假设<strong class="la jk"> <em class="ly">我们想要过滤电影标题中字数大于或等于 4 的那些行。</em>T13】</strong></p><p id="6498" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">你会怎么做？</em> </strong></p><p id="fcb0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尝试下面的会给你一个错误。显然，你不能做任何简单的事情，比如用一个系列分割。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="dfcc" class="nh mh jj lx b gy ni nj l nk nl">new_df = df[len(df['Title'].split(" "))&gt;=4]<br/>-------------------------------------------<br/>AttributeError: 'Series' object has no attribute 'split'</span></pre><p id="0843" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一种方法是首先使用 apply 创建一个标题中包含字数的列，然后对该列进行过滤。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="c241" class="nh mh jj lx b gy ni nj l nk nl">#create a new column<br/>df['num_words_title'] = df.apply(lambda x : len(x['Title'].split(" ")),axis=1)</span><span id="2fd8" class="nh mh jj lx b gy ob nj l nk nl">#simple filter on new column<br/>new_df = df[df['num_words_title']&gt;=4]</span></pre><p id="86fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个非常好的方法，只要你不需要创建很多列。但是，我更喜欢这个:</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="25f1" class="nh mh jj lx b gy ni nj l nk nl">new_df = df[df.apply(lambda x : len(x['Title'].split(" "))&gt;=4,axis=1)]</span></pre><p id="1081" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里做的是<strong class="la jk"> <em class="ly">我的 apply 函数返回一个可以用来过滤的布尔值。</em> </strong></p><p id="d17c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，一旦你理解了你只需要创建一个布尔列来过滤，你就可以在你的<code class="fe lu lv lw lx b">apply</code>语句中使用任何函数/逻辑来得到你想要构建的复杂逻辑。</p><p id="0ca4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看另一个例子。我会试着做一些稍微复杂的事情来展示它的结构。</p><p id="07d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想找到收入低于该年平均收入的电影？T25】</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="c373" class="nh mh jj lx b gy ni nj l nk nl">year_revenue_dict = df.groupby(['Year']).agg({'Rev_M':np.mean}).to_dict()['Rev_M']</span><span id="638d" class="nh mh jj lx b gy ob nj l nk nl">def bool_provider(revenue, year):<br/>    return revenue&lt;year_revenue_dict[year]<br/>    <br/>new_df = df[df.apply(lambda x : bool_provider(x['Rev_M'],x['Year']),axis=1)]</span></pre><p id="fc90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个函数，可以用来写任何逻辑。只要我们能够处理简单的变量，这就为高级过滤提供了强大的功能。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="29ba" class="mg mh jj bd mi mj mk ml mm mn mo mp mq kp mr kq ms ks mt kt mu kv mv kw mw mx bi translated">更改列类型</h1><p id="b839" class="pw-post-body-paragraph ky kz jj la b lb oc kk ld le od kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">我甚至使用 apply 来更改列类型，因为我不想记住更改列类型的语法，也因为它让我可以做更复杂的事情。</p><p id="d81d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 Pandas 中，改变列类型的正常语法是<code class="fe lu lv lw lx b">astype</code>。因此，如果我的数据中有一个名为 price 的列，格式为<code class="fe lu lv lw lx b">str</code>。我可以这样做:</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="0f92" class="nh mh jj lx b gy ni nj l nk nl">df['Price'] = newDf['Price'].astype('int')</span></pre><p id="0dd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但有时并不会如预期般奏效。</p><p id="6805" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会得到错误:<code class="fe lu lv lw lx b">ValueError: invalid literal for long() with base 10: ‘13,000’.</code>也就是说你不能把一个带有<code class="fe lu lv lw lx b">“,”</code>的字符串转换成一个整型。要做到这一点，我们首先要去掉逗号。</p><p id="ad4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一次又一次地面对这个问题之后，我现在已经完全停止使用<code class="fe lu lv lw lx b">astype</code>了，只使用 apply 来改变列类型。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="63a1" class="nh mh jj lx b gy ni nj l nk nl">df['Price'] = df.apply(lambda x: int(x['Price'].replace(',', '')),axis=1)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="02ae" class="mg mh jj bd mi mj mk ml mm mn mo mp mq kp mr kq ms ks mt kt mu kv mv kw mw mx bi translated">最后还有<code class="fe lu lv lw lx b">progress_apply</code></h1><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/27175a6bc0603554f38279fefdedc68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SB2hWajkwtNqFz1Qcsqqlw.png"/></div></div></figure><p id="710b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">progress_apply</code>是<code class="fe lu lv lw lx b">tqdm</code>包附带的单一功能。</p><p id="97a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这为我节省了很多时间。</p><p id="72c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时，当您的数据中有很多行，或者您最终编写了一个非常复杂的 apply 函数时，您会发现 apply 可能需要很长时间。</p><p id="1fb5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我见过应用程序在使用 Spacy 时花费数小时。在这种情况下，您可能希望看到带有应用的进度条。</p><p id="83b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以使用<code class="fe lu lv lw lx b">tqdm</code>来实现。</p><p id="37bd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在笔记本顶部的初始导入之后，只需将<code class="fe lu lv lw lx b">apply</code>替换为<code class="fe lu lv lw lx b">progress_apply</code>，一切都保持不变。</p><pre class="mz na nb nc gt nd lx ne nf aw ng bi"><span id="a4cd" class="nh mh jj lx b gy ni nj l nk nl">from tqdm import tqdm, tqdm_notebook<br/>tqdm_notebook().pandas()</span><span id="ad84" class="nh mh jj lx b gy ob nj l nk nl">df.progress_apply(lambda x: custom_rating_function(x['Genre'],x['Rating']),axis=1)</span></pre><p id="d698" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会看到进度条。</p><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/ab183152acfaf8ac0cf640054b1f2739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhybLvFWb4NYQSnHfTcaDQ.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c5a8" class="mg mh jj bd mi mj mk ml mm mn mo mp mq kp mr kq ms ks mt kt mu kv mv kw mw mx bi translated">结论</h1><p id="801e" class="pw-post-body-paragraph ky kz jj la b lb oc kk ld le od kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated"><code class="fe lu lv lw lx b">apply</code>和<code class="fe lu lv lw lx b">lambda</code>功能让你在操作数据的同时处理很多复杂的事情。</p><p id="ec93" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我觉得用熊猫不用担心很多事情，因为我可以很好地使用<code class="fe lu lv lw lx b">apply</code>。</p><p id="3106" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我试图解释它是如何工作的。可能还有其他方法来做我上面做的事情。</p><p id="efcc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我喜欢用<code class="fe lu lv lw lx b">apply</code> / <code class="fe lu lv lw lx b">lambda</code>来代替<code class="fe lu lv lw lx b">map</code> / <code class="fe lu lv lw lx b">applymap</code>，因为我觉得它可读性更强，也更适合我的工作流程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="c909" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于<a class="ae jg" href="https://amzn.to/2XPSiiG" rel="noopener ugc nofollow" target="_blank"> Python </a> 3 的知识，我想从密歇根大学调出一门关于学习<a class="ae jg" href="https://coursera.pxf.io/RyEZZX" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">中级 Python </strong> </a>的优秀课程。一定要去看看。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="0667" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我以后也会写更多这样的帖子。让我知道你对这个系列的看法。在<a class="ae jg" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="la jk">媒体</strong> </a>关注我或者订阅我的<a class="ae jg" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p></div></div>    
</body>
</html>