<html>
<head>
<title>How To Make Your Pandas Loop 71803 Times Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的熊猫循环快 71803 倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-your-pandas-loop-71-803-times-faster-805030df4f06?source=collection_archive---------0-----------------------#2019-08-23">https://towardsdatascience.com/how-to-make-your-pandas-loop-71-803-times-faster-805030df4f06?source=collection_archive---------0-----------------------#2019-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a98" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">循环通过熊猫数据帧可能会非常慢——我将向您展示一些非常快速的选项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/133d27b6dba74b581117212d36e5a20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7fxK_4DK2QqpGNzoTADAA.png"/></div></div></figure><p id="6489" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">如果用 Python 和 Pandas 做数据分析，用不了多久，第一次就想用循环了。然而，即使对于小的数据帧，使用标准循环也是非常耗时的，您很快就会意识到对于较大的数据帧，这可能需要很长时间。当我第一次等了半个多小时来执行代码时，我寻找了一些替代方法，我想与大家分享一下。</em></p><h1 id="1e15" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">标准循环</h1><p id="f6e9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">数据帧是熊猫——有行和列的对象。如果你使用循环，你将遍历整个对象。Python 不能利用任何内置函数，而且速度非常慢。在我们的例子中，我们得到了一个 65 列 1140 行的数据帧。它包含 2016 - 2019 赛季的足球结果。我们希望创建一个新列来指示某个特定的球队是否打了平局。我们可以这样开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/3ad2a850e68863ead0f0828df2208cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*053vIoQmvMZfMoqQhYLxNA.png"/></div></div></figure><p id="d8b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们的数据框架中有英超联赛的每一场比赛，我们必须检查感兴趣的球队(阿森纳)是否参加了比赛，如果适用，他们是主队还是客场队。如您所见，这个循环非常慢，执行时间为 20.7 秒。让我们看看如何才能更有效率。</p><h1 id="5df6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">熊猫的内置函数:iterrows() —快 321 倍</h1><p id="6c41" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在第一个例子中，我们循环了整个数据帧。<code class="fe mr ms mt mu b">iterrows()</code>为每一行返回一个序列，因此它将一个数据帧作为一对索引进行迭代，将感兴趣的列作为序列进行迭代。这使得它比标准循环更快:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/b53b76f8506332b8b29c2bfaf9df49f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3lJIodikDPGVx5kR-fegw.png"/></div></div></figure><p id="0cfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码运行需要 68 毫秒，比标准循环快 321 倍。然而，许多人建议不要使用它，因为仍然有更快的选择，而且<code class="fe mr ms mt mu b">iterrows()</code>不能跨行保存 dtypes。这意味着如果你在你的数据帧上使用<code class="fe mr ms mt mu b">iterrows()</code>，数据类型会被改变，这会导致很多问题。要保留数据类型，您也可以使用<code class="fe mr ms mt mu b">itertuples()</code>。这里就不赘述了，因为要注重效率。您可以在这里找到官方文档:</p><div class="mw mx gp gr my mz"><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">熊猫。data frame . ITER tuples-pandas 0 . 25 . 1 文档</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">如果列名是无效的 Python 标识符、重复或以…开头，它们将被重命名为位置名</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">pandas.pydata.org</p></div></div></div></a></div><h1 id="a46a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">apply()方法—速度快 811 倍</h1><p id="dcfe" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><code class="fe mr ms mt mu b">apply</code>本身并不快，但与数据帧结合使用时有优势。这取决于<code class="fe mr ms mt mu b">apply</code>表达式的内容。如果能在 Cython 空间执行，<code class="fe mr ms mt mu b">apply</code>要快很多(这里就是这种情况)。</p><p id="b164" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将<code class="fe mr ms mt mu b">apply</code>与<code class="fe mr ms mt mu b">Lambda</code>函数一起使用。我们要做的就是指定轴。在这种情况下，我们必须使用<code class="fe mr ms mt mu b">axis=1</code>,因为我们想要执行列操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/87fad4c06156db21b1c5de38aa427081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbSLPStTRvNHp16BuxiVgQ.png"/></div></div></figure><p id="22e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码甚至比以前的方法更快，用了 27 毫秒才完成。</p><h1 id="7deb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">熊猫矢量化—速度提高 9280 倍</h1><p id="5094" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在我们可以谈一个新的话题了。我们利用矢量化的优势来创建真正快速的代码。重点是避免 Python 级的循环，就像[1]前面的例子一样，并使用优化的 C 代码，这样可以更有效地使用内存。我们只需要稍微修改一下函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5865" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以创建以熊猫系列作为输入的新列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/4f670cf72f62d5ecd0353f35545e5c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMDYBMxPo-7N1khETGtCOg.png"/></div></div></figure><p id="3aae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们甚至不需要循环。我们要做的就是调整函数的内容。现在，我们可以直接将 Pandas 系列传递给我们的函数，这将大大提高速度。</p><h1 id="7bf9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Numpy 矢量化—速度提高 71.803 倍</h1><p id="89a2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在前面的例子中，我们将熊猫系列传递给了我们的函数。通过添加。值我们接收一个 Numpy 数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/109b1e6c4b6417932e597e3a4739f6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1j9btjHRfG2KJWBn7N298Q.png"/></div></div></figure><p id="9804" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Numpy 数组如此之快是因为我们得到了引用局部性的好处[2]。我们的代码运行耗时 0，305 毫秒，比开始时使用的标准循环快 71803 倍。</p><h1 id="6361" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="bb22" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果你使用 Python，Pandas 和 Numpy 进行数据分析，你的代码总会有一些改进的空间。我们比较了五种不同的方法，根据一些计算在我们的数据框架中添加一个新的列。我们注意到了速度上的巨大差异:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8187f830ffec202d6e7c814f479a97e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npKBAOiZVHpiajrO59H4BQ.png"/></div></div></figure><p id="6884" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你能从这篇文章中得到两条规则，我会很高兴:</p><ol class=""><li id="12d2" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">如果您确定需要使用循环，您应该始终选择 apply 方法。</li><li id="4c42" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">否则，矢量化总是更好，因为它更快。</li></ol><h1 id="1b77" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">来源:</h1><p id="0bd1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">[1]<a class="ae nx" href="https://stackoverflow.com/questions/52673285/performance-of-pandas-apply-vs-np-vectorize-to-create-new-column-from-existing-c" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/52673285/performance-of-pandas-apply-vs-NP-vectorize-to-create-new-column-from-existing-c</a><br/>【2】<a class="ae nx" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Locality_of_reference</a></p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="253b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nx" href="https://medium.com/@droste.benedikt/membership" rel="noopener">如果您喜欢中级数据科学，并且尚未注册，请随时使用我的推荐链接加入该社区。</a></p></div></div>    
</body>
</html>