<html>
<head>
<title>How to compute f1 score for named-entity recognition in Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何计算 Keras 中命名实体识别的 f1 值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-compute-f1-score-for-named-entity-recognition-in-keras-6f28b31dccca?source=collection_archive---------14-----------------------#2019-04-23">https://towardsdatascience.com/how-to-compute-f1-score-for-named-entity-recognition-in-keras-6f28b31dccca?source=collection_archive---------14-----------------------#2019-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在命名实体识别中，f1 分数用于评估训练模型的性能，特别是，该评估是针对每个实体的，而不是令牌。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/abec844718345e75434bff31cf271225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZ05Leb-HMn0xlv5Kmiucw.png"/></div></div></figure><p id="a955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在许多机器学习框架中都实现了评估 f1 分数的功能。然而，它的目标是分类任务，而不是像命名实体识别那样的序列标记。</p><p id="13a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，Keras 允许我们通过<a class="ae kx" href="https://keras.io/callbacks/#callback" rel="noopener ugc nofollow" target="_blank">回调类</a>在训练期间访问验证数据。通过扩展回调，我们可以评估命名实体识别的 f1 值。</p><p id="af8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个示例代码，用于在每个时期结束时计算和打印 f1 分数、召回率和精确度。你不必自己实现这段代码，它包含在<a class="ae kx" href="https://github.com/chakki-works/seqeval" rel="noopener ugc nofollow" target="_blank"> seqeval </a>包中:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="1f94" class="ld le iq kz b gy lf lg l lh li">import numpy as np<br/>from keras.callbacks import Callback<br/>from seqeval.metrics import f1_score, classification_report<br/><br/><br/>class F1Metrics(Callback):<br/><br/>    def __init__(self, id2label, pad_value=0, validation_data=None):<br/>        """<br/>        Args:<br/>            id2label (dict): id to label mapping.<br/>            (e.g. {1: 'B-LOC', 2: 'I-LOC'})<br/>            pad_value (int): padding value.<br/>        """<br/>        super(F1Metrics, self).__init__()<br/>        self.id2label = id2label<br/>        self.pad_value = pad_value<br/>        self.validation_data = validation_data<br/>        self.is_fit = validation_data is None<br/><br/>    def find_pad_index(self, array):<br/>        """Find padding index.<br/>        Args:<br/>            array (list): integer list.<br/>        Returns:<br/>            idx: padding index.<br/>        Examples:<br/>             &gt;&gt;&gt; array = [1, 2, 0]<br/>             &gt;&gt;&gt; self.find_pad_index(array)<br/>             2<br/>        """<br/>        try:<br/>            return list(array).index(self.pad_value)<br/>        except ValueError:<br/>            return len(array)<br/><br/>    def get_length(self, y):<br/>        """Get true length of y.<br/>        Args:<br/>            y (list): padded list.<br/>        Returns:<br/>            lens: true length of y.<br/>        Examples:<br/>            &gt;&gt;&gt; y = [[1, 0, 0], [1, 1, 0], [1, 1, 1]]<br/>            &gt;&gt;&gt; self.get_length(y)<br/>            [1, 2, 3]<br/>        """<br/>        lens = [self.find_pad_index(row) for row in y]<br/>        return lens<br/><br/>    def convert_idx_to_name(self, y, lens):<br/>        """Convert label index to name.<br/>        Args:<br/>            y (list): label index list.<br/>            lens (list): true length of y.<br/>        Returns:<br/>            y: label name list.<br/>        Examples:<br/>            &gt;&gt;&gt; # assumes that id2label = {1: 'B-LOC', 2: 'I-LOC'}<br/>            &gt;&gt;&gt; y = [[1, 0, 0], [1, 2, 0], [1, 1, 1]]<br/>            &gt;&gt;&gt; lens = [1, 2, 3]<br/>            &gt;&gt;&gt; self.convert_idx_to_name(y, lens)<br/>            [['B-LOC'], ['B-LOC', 'I-LOC'], ['B-LOC', 'B-LOC', 'B-LOC']]<br/>        """<br/>        y = [[self.id2label[idx] for idx in row[:l]]<br/>             for row, l in zip(y, lens)]<br/>        return y<br/><br/>    def predict(self, X, y):<br/>        """Predict sequences.<br/>        Args:<br/>            X (list): input data.<br/>            y (list): tags.<br/>        Returns:<br/>            y_true: true sequences.<br/>            y_pred: predicted sequences.<br/>        """<br/>        y_pred = self.model.predict_on_batch(X)<br/><br/>        # reduce dimension.<br/>        y_true = np.argmax(y, -1)<br/>        y_pred = np.argmax(y_pred, -1)<br/><br/>        lens = self.get_length(y_true)<br/><br/>        y_true = self.convert_idx_to_name(y_true, lens)<br/>        y_pred = self.convert_idx_to_name(y_pred, lens)<br/><br/>        return y_true, y_pred<br/><br/>    def score(self, y_true, y_pred):<br/>        """Calculate f1 score.<br/>        Args:<br/>            y_true (list): true sequences.<br/>            y_pred (list): predicted sequences.<br/>        Returns:<br/>            score: f1 score.<br/>        """<br/>        score = f1_score(y_true, y_pred)<br/>        print(' - f1: {:04.2f}'.format(score * 100))<br/>        print(classification_report(y_true, y_pred, digits=4))<br/>        return score<br/><br/>    def on_epoch_end(self, epoch, logs={}):<br/>        if self.is_fit:<br/>            self.on_epoch_end_fit(epoch, logs)<br/>        else:<br/>            self.on_epoch_end_fit_generator(epoch, logs)<br/><br/>    def on_epoch_end_fit(self, epoch, logs={}):<br/>        X = self.validation_data[0]<br/>        y = self.validation_data[1]<br/>        y_true, y_pred = self.predict(X, y)<br/>        score = self.score(y_true, y_pred)<br/>        logs['f1'] = score<br/><br/>    def on_epoch_end_fit_generator(self, epoch, logs={}):<br/>        y_true = []<br/>        y_pred = []<br/>        for X, y in self.validation_data:<br/>            y_true_batch, y_pred_batch = self.predict(X, y)<br/>            y_true.extend(y_true_batch)<br/>            y_pred.extend(y_pred_batch)<br/>        score = self.score(y_true, y_pred)<br/>        logs['f1'] = score<br/><br/>id2label = {1: 'B-LOC', 2: 'I-LOC'}<br/>f1score = F1Metrics(id2label)</span></pre><p id="1675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义模型，并在拟合函数中添加回调:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="1738" class="ld le iq kz b gy lf lg l lh li">model.fit(x_train, y_train, <br/>          validation_data=(x_valid, y_valid),<br/>          epochs=1,<br/>          batch_size=32,<br/>          callbacks=[f1score])</span></pre><p id="6c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">培训期间的打印输出如下所示:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="ef95" class="ld le iq kz b gy lf lg l lh li">Epoch 1/1<br/>541/541 [==============================] - 46s 85ms/step - loss: 9.5729<br/> - f1: 53.24<br/><br/>             precision    recall  f1-score   support<br/><br/>        PER     0.5754    0.4484    0.5040      1617<br/>        ORG     0.3798    0.4395    0.4075      1661<br/>       MISC     0.4202    0.4387    0.4293       702<br/>        LOC     0.6886    0.7650    0.7248      1668<br/><br/>avg / total     0.5320    0.5381    0.5315      5648</span></pre><p id="4998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">格式类似于 scikit-learn 的<a class="ae kx" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html" rel="noopener ugc nofollow" target="_blank">分类 _ 报告</a>功能。</p><p id="bda3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。祝您愉快！</p><p id="0f64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/chakki-works/seqeval" rel="noopener ugc nofollow" target="_blank">https://github.com/chakki-works/seqeval</a></p></div></div>    
</body>
</html>