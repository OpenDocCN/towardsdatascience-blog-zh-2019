<html>
<head>
<title>How to Fuzzy Match Datsets in Amazon Redshift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在亚马逊红移中模糊匹配数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bringing-fuzzy-matching-to-redshift-d487ce98d170?source=collection_archive---------11-----------------------#2019-03-28">https://towardsdatascience.com/bringing-fuzzy-matching-to-redshift-d487ce98d170?source=collection_archive---------11-----------------------#2019-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python UDF 实现 Amazon 红移中的模糊匹配连接</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5eba577efe78def7f11face8eaf25cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MrXLKvG8Ssokx01A"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fuzzy Merging — Photo by <a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果幸运的话，当在数据仓库中处理多个数据集时，会有某种类型的连接列可用于您想要放在一起的表。</p><p id="24e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这种情况发生时，生活是美好的。然而，现代<em class="lv">大数据</em>解决方案正在开辟一个用例，将来自不同来源的各种数据整合在一起。</p><p id="5842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们可以<a class="ae ky" href="https://medium.com/@lewisdgavin/how-to-architect-the-perfect-data-warehouse-b3af2e01342e" rel="noopener">轻松地将这些数据存储在一个地方</a>，但是将它们连接起来进行分析并不总是那么简单，因为这些数据集通常不是由同一个源系统生成的，所以要连接的干净的 ID 列并不总是可用的。即使为您提供相同信息的列也不总是以相同的格式提供，如果是用户捕获的，您永远无法保证一致性。</p><p id="a75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于相似性将数据集连接在一起的一种方法是模糊匹配，特别是当您知道每个数据集中有基于文本的字段几乎相似时，例如用户输入的公司名称或产品名称。</p><p id="ab29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章不会详细讨论模糊匹配的所有细节，但是会向你展示如何在 Redshift 中使用 Python 实现。</p><h1 id="7852" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">模糊匹配</h1><p id="7a23" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在最简单的层面上，模糊匹配看起来产生两个事物有多相似的相似性分数。我将着重比较字符串来解释这个概念。</p><p id="e52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为人类，我们很容易发现打字错误，或者在概念上理解两个相似的东西是相同的。模糊匹配算法试图帮助计算机做到这一点。两个字符串之间的匹配不是布尔真或假，即完全相同或不相同，模糊匹配给出的是接近度分数。</p><p id="993d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以“布鲁克林大桥”和“布鲁克林大桥”为例。即使在第二个字符串中有拼写错误，人类也很容易发现这是同一个东西。</p><p id="72db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种模糊匹配算法，例如给出相似性百分比分数的<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein distance </a>，可能会将这两个字符串评分为至少 90%相似。我们可以使用它来设置我们希望“相似”的阈值，即任何两个模糊分数超过 80%的字符串都是匹配的。</p><h1 id="51ac" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Python 实现</h1><p id="1b2e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这些天你可以找到很多 Python 包，所以我不打算重新发明轮子。一个体面的使用 Levenshtein 实现模糊匹配的 python 包是<a class="ae ky" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> fuzzy wuzzy </strong> </a> <strong class="lb iu">。</strong></p><p id="0666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照文档中说明的安装过程，您最终会得到一堆用于比较字符串的函数。</p><p id="7dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这个例子中使用的是一个简单的比率函数，它接受两个字符串并给出一个接近比率。这里有一个示例实现，展示了前面的布鲁克林大桥示例。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9703" class="my lx it mu b gy mz na l nb nc">&gt;from fuzzywuzzy import fuzz<br/>&gt;fuzz.ratio(“brooklyn bridge”, “brooklin bridge”)</span><span id="ef72" class="my lx it mu b gy nd na l nb nc">&gt; 93</span></pre><p id="1d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，这返回了一个相当高的分数，因为两者非常相似。</p><h1 id="4571" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">红移 UDF</h1><p id="b1b7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">用户定义的函数允许您使用 SQL 或 Python 向 Redshift 添加可重复的代码块。python 支持将允许我们采用上一节中的实现并添加到 Redshift 中，这样我们就可以像调用任何其他原生 SQL 函数一样简单地调用它。</p><p id="10a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要添加 fuzzywuzzy 库到红移。有一些<a class="ae ky" href="https://docs.aws.amazon.com/redshift/latest/dg/udf-python-language-support.html#udf-importing-custom-python-library-modules" rel="noopener ugc nofollow" target="_blank">完整的文档</a>，但是我将在下面概述基本步骤。</p><ol class=""><li id="8c95" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">从 github 下载<a class="ae ky" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank"> fuzzywuzzy </a>回购</li><li id="0ed8" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在回购中复制一份 fuzzywuzzy 文件夹，并将其压缩。</li><li id="be9f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">将此压缩文件夹复制到 S3 桶中</li><li id="89d0" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在 Redshift 中运行以下命令来导入 fuzzywuzzy 库</li></ol><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="63d1" class="my lx it mu b gy mz na l nb nc">CREATE LIBRARY fuzzywuzzy LANGUAGE plpythonu FROM 's3://&lt;bucket_name&gt;/fuzzywuzzy.zip' CREDENTIALS 'aws_access_key_id=&lt;access key id&gt;;aws_secret_access_key=&lt;secret key&gt;'</span></pre><p id="b3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们现在可以继续使用红移中的这个库来创建函数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="900c" class="my lx it mu b gy mz na l nb nc">CREATE FUNCTION fuzzy_test (string_a TEXT,string_b TEXT) RETURNS FLOAT IMMUTABLE<br/>AS<br/>$$<br/>  FROM fuzzywuzzy import fuzz <br/>  RETURN fuzz.ratio (string_a,string_b) <br/>$$ LANGUAGE plpythonu;</span></pre><p id="26a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以测试它，并检查我们看到的结果是否与我们在本地看到的结果相同。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a270" class="my lx it mu b gy mz na l nb nc">SELECT fuzzy_test('brooklyn bridge', 'brooklin bridge');</span><span id="1982" class="my lx it mu b gy nd na l nb nc">&gt; 93</span></pre><h1 id="6e14" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">包裹</h1><p id="8c8e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">就这么简单。这是一个很好的特性，由于 Python 中可用的库的范围，Python UDF 给了你很大的灵活性。</p><p id="1101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于红移星团的力量，这意味着大规模的模糊匹配是可能的，这可能永远不会在笔记本电脑上完成。然而…</p><p id="d4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打算将它用于连接，需要考虑的一件事是，它显然会比通常慢，因为在连接上不会发生太多优化。因此，如果您要匹配大型字符串数据集，那么请做好等待的准备:)</p></div></div>    
</body>
</html>