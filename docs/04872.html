<html>
<head>
<title>Multi-Class Image Classification With Transfer Learning In PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PySpark 中基于迁移学习的多类图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transfer-learning-with-pyspark-729d49604d45?source=collection_archive---------4-----------------------#2019-07-23">https://towardsdatascience.com/transfer-learning-with-pyspark-729d49604d45?source=collection_archive---------4-----------------------#2019-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/37dcce9c6d55200967ca2b1e2e958b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59adAh12G53ibaOQJozNZw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">src: Photo by <a class="ae jd" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pixabay </a>from <a class="ae jd" href="https://www.pexels.com/photo/close-up-of-a-book-over-white-background-256424/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><div class=""/><div class=""><h2 id="74fc" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">Apache Spark 深度学习管道的计算机视觉问题的简短演示。</h2></div><h1 id="60fc" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">介绍</h1><p id="dd72" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本文中，我们将使用 Keras (TensorFlow 后端)、PySpark 和<strong class="lp jh">深度学习管道</strong>库来构建一个端到端的深度学习计算机视觉解决方案，用于在 Spark 集群上运行的多类图像分类问题。Spark 是一个强大的开源分布式分析引擎，可以高速处理大量数据。PySpark 是用于 Spark 的 Python API，它允许我们使用 Python 编程语言并利用 Apache Spark 的强大功能。</p><p id="e8d6" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在本文中，我们将主要使用<strong class="lp jh"> </strong> <a class="ae jd" href="https://docs.databricks.com/applications/deep-learning/single-node-training/deep-learning-pipelines.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">深度学习管道</strong> </a> <strong class="lp jh"> (DLP) </strong>，这是一个高级深度学习框架，通过<a class="ae jd" href="https://spark.apache.org/mllib/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh"> Spark MLlib </strong> </a>管道 API 来促进常见的深度学习工作流。它目前通过 TensorFlow 后端支持 TensorFlow 和 Keras。在本文中，我们将使用这个<strong class="lp jh"> DLP </strong>构建一个将在 Spark 集群上运行的多类图像分类器。要设置好一切，请遵循本<a class="ae jd" href="https://gist.github.com/innat/b0ab252c954eb2a28a984774e3ee1f2d" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">安装说明</strong> </a> <strong class="lp jh">。</strong></p><div class="ip iq gp gr ir mo"><a href="https://docs.databricks.com/applications/deep-learning/single-node-training/deep-learning-pipelines.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jh gy z fp mt fr fs mu fu fw jf bi translated">深度学习管道—数据块文档</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">深度学习管道库包含在 Databricks Runtime ML 中，这是一个机器学习运行时，它提供了一个…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">docs.databricks.com</p></div></div></div></a></div><p id="e88a" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">该库来自<strong class="lp jh"> Databricks </strong>，并利用 Spark 的两个最强方面:</p><ol class=""><li id="cefd" class="mx my jg lp b lq mj lt mk lw mz ma na me nb mi nc nd ne nf bi translated">本着 Spark 和<a class="ae jd" href="https://spark.apache.org/mllib/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh"> Spark MLlib </strong> </a>的精神，它提供了易于使用的 API，可以在非常少的几行代码中实现深度学习。</li><li id="c952" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi nc nd ne nf bi translated">它使用 Spark 强大的分布式引擎在海量数据集上扩展深度学习。</li></ol><p id="12ce" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我的目标是用<strong class="lp jh"> DLP </strong>将深度学习整合到 PySpark 管道中。我在本地机器上使用 Jupyter Notebook 运行整个项目来构建原型。然而，我发现把这个原型放在一起有点困难，所以我希望其他人会发现这篇文章很有用。我将把这个项目分成几个步骤。有些步骤是不言自明的，但对于其他步骤，我会尽可能解释清楚，让它变得不那么痛苦。如果你只想看有解释和代码的笔记本，你可以直接去<a class="ae jd" href="https://github.com/innat/Transfer-Learning-PySpark" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h2 id="e4da" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">计划</h2><ul class=""><li id="ad74" class="mx my jg lp b lq lr lt lu lw nx ma ny me nz mi oa nd ne nf bi translated"><strong class="lp jh">迁移学习</strong>:深度学习管道的简短直觉(来自<strong class="lp jh">数据块</strong></li><li id="b438" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated"><strong class="lp jh">数据集</strong>:引入多类图像数据。</li><li id="be51" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated"><strong class="lp jh">建模</strong>:建立模型，训练。</li><li id="6782" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated"><strong class="lp jh">评估</strong>:使用各种评估指标评估模型性能。</li></ul><h1 id="7012" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">迁移学习</h1><p id="bb68" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">迁移学习是机器学习中的一种技术，通常专注于保存在解决一个问题时获得的知识(权重和偏差)，并进一步将其应用于不同但相关的问题。</p><p id="11be" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">深度学习管道</strong>提供对图像执行迁移学习的实用程序，这是开始使用深度学习的最快方法之一。借助<strong class="lp jh"> <em class="ob">特征器的概念，</em> </strong>深度学习管道能够在 Spark-Cluster 上实现快速迁移学习。目前，它为迁移学习提供了以下神经网络:</p><ul class=""><li id="2413" class="mx my jg lp b lq mj lt mk lw mz ma na me nb mi oa nd ne nf bi translated">InceptionV3</li><li id="777f" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">例外</li><li id="4f2d" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">ResNet50</li><li id="6719" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">VGG16</li><li id="245c" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">VGG19</li></ul><p id="26f7" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">出于演示的目的，我们将只研究<strong class="lp jh"> InceptionV3 </strong>模型。你可以在这里阅读这款<a class="ae jd" href="https://arxiv.org/abs/1512.00567" rel="noopener ugc nofollow" target="_blank">的技术细节。</a></p><p id="755d" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">以下示例结合了 Spark 中的<strong class="lp jh"> InceptionV3 </strong>模型和<strong class="lp jh">多项式逻辑回归</strong>。来自深度学习管道的一个名为<strong class="lp jh"> DeepImageFeaturizer </strong>的实用函数自动剥离预训练神经网络的最后一层，并使用所有先前层的输出作为逻辑回归算法的<strong class="lp jh">特征</strong>。</p><h1 id="4230" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">数据集</h1><p id="5c4a" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">孟加拉文字有十个<a class="ae jd" href="https://en.wikipedia.org/wiki/Numerical_digit" rel="noopener ugc nofollow" target="_blank">数字</a>(表示从 0 到 9 的数字的字母或符号)。大于 9 的数字用孟加拉语书写，使用基数为 10 的位置数字系统。</p><p id="ed67" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们选择<strong class="lp jh"/><a class="ae jd" href="https://arxiv.org/abs/1806.02452" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">numtab</strong></a>作为我们数据集的来源。这是孟加拉手写数字数据的集合。该数据集包含来自 2，700 多个贡献者的 85，000 多个数字。但是这里我们不打算处理整个数据集，而是随机选择每一类的 50 张图片。</p><figure class="od oe of og gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/46b9aeab979565ba906d0ac5d8ee3b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZE5ZondmsQ42sgYRisRYQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig 1: Each Folder Contains 50 Images [ Classes (0 to 9) ]</figcaption></figure><p id="2bce" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们看看上面十个文件夹里都有什么。出于演示目的，我将下面显示的每个图像重命名为其对应的类标签。</p><figure class="od oe of og gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/c9d68db79d874b8de021acfa65813521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jMDcpRcUEvSZKpuW0ZyNA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig 2: Bengali Handwritten Digit</figcaption></figure></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="aea9" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">首先，我们将所有图像加载到 SparkData Frame。然后我们建立模型并训练它。之后，我们将评估我们训练好的模型的性能。</p><h2 id="53aa" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">加载图像</h2><p id="3e6a" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">数据集(从 0 到 9)包含近 500 个手写孟加拉数字(每类 50 个图像)。这里，我们手动将每个图像加载到带有目标列的<strong class="lp jh"> spark 数据帧</strong>中。在加载了整个数据集之后，我们将训练集和最终测试集随机分成 8:2 的比例。</p><p id="5d0d" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的目标是用训练数据集训练模型，最后用测试数据集评估模型的性能。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="39bf" class="ou kw jg oq b be ov ow l ox oy"># necessary import <br/>from pyspark.sql import SparkSession<br/>from pyspark.ml.image import ImageSchema<br/>from pyspark.sql.functions import lit<br/>from functools import reduce<br/># create a spark session<br/>spark = SparkSession.builder.appName('DigitRecog').getOrCreate()<br/># loaded image<br/>zero = ImageSchema.readImages("0").withColumn("label", lit(0))<br/>one = ImageSchema.readImages("1").withColumn("label", lit(1))<br/>two = ImageSchema.readImages("2").withColumn("label", lit(2))<br/>three = ImageSchema.readImages("3").withColumn("label", lit(3))<br/>four = ImageSchema.readImages("4").withColumn("label", lit(4))<br/>five = ImageSchema.readImages("5").withColumn("label", lit(5))<br/>six = ImageSchema.readImages("6").withColumn("label", lit(6))<br/>seven = ImageSchema.readImages("7").withColumn("label", lit(7))<br/>eight = ImageSchema.readImages("8").withColumn("label", lit(8))<br/>nine = ImageSchema.readImages("9").withColumn("label", lit(9))<br/>dataframes = [zero, one, two, three,four,<br/>             five, six, seven, eight, nine]<br/># merge data frame<br/>df = reduce(lambda first, second: first.union(second), dataframes)<br/># repartition dataframe <br/>df = df.repartition(200)<br/># split the data-frame<br/>train, test = df.randomSplit([0.8, 0.2], 42)</span></pre><p id="6a8e" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这里，我们可以对火花数据帧进行各种探索性的数据分析。我们还可以查看数据框的模式。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="fe03" class="ou kw jg oq b be ov ow l ox oy">df.printSchema()<br/>root<br/> |-- image: struct (nullable = true)<br/> |    |-- origin: string (nullable = true)<br/> |    |-- height: integer (nullable = false)<br/> |    |-- width: integer (nullable = false)<br/> |    |-- nChannels: integer (nullable = false)<br/> |    |-- mode: integer (nullable = false)<br/> |    |-- data: binary (nullable = false)<br/> |-- label: integer (nullable = false)</span></pre><p id="3ae8" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们也可以使用<strong class="lp jh">将 Spark-DataFrame 转换成 Pandas-DataFrame。托潘达斯()。</strong></p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="015a" class="kv kw jg bd kx ky oz la lb lc pa le lf km pb kn lh kp pc kq lj ks pd kt ll lm bi translated">模特培训</h1><p id="90ac" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这里我们结合 Spark 中的<strong class="lp jh"> InceptionV3 </strong>模型和<strong class="lp jh"> logistic 回归</strong>。<strong class="lp jh">deepimagefeaturezer</strong>自动剥离预训练神经网络的最后一层，并使用所有先前层的输出作为逻辑回归算法的特征。</p><p id="00a4" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">由于<strong class="lp jh"> logistic 回归</strong>是一种简单快速的算法，所以这种迁移学习训练能够快速收敛。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="1ff5" class="ou kw jg oq b be ov ow l ox oy">from pyspark.ml.evaluation import MulticlassClassificationEvaluator<br/>from pyspark.ml.classification import LogisticRegression<br/>from pyspark.ml import Pipeline<br/>from sparkdl import DeepImageFeaturizer<br/># model: InceptionV3<br/># extracting feature from images<br/>featurizer = DeepImageFeaturizer(inputCol="image",<br/>                                 outputCol="features",<br/>                                 modelName="InceptionV3")<br/># used as a multi class classifier<br/>lr = LogisticRegression(maxIter=5, regParam=0.03, <br/>                        elasticNetParam=0.5, labelCol="label")<br/># define a pipeline model<br/>sparkdn = Pipeline(stages=[featurizer, lr])<br/>spark_model = sparkdn.fit(train) # start fitting or training</span></pre></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="fca9" class="kv kw jg bd kx ky oz la lb lc pa le lf km pb kn lh kp pc kq lj ks pd kt ll lm bi translated">估价</h1><p id="81a7" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在，是时候评估模型性能了。我们现在要评估四个评估指标，比如测试数据集上的得分、精确度、召回率和准确度。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="e712" class="ou kw jg oq b be ov ow l ox oy">from pyspark.ml.evaluation import MulticlassClassificationEvaluator<br/># evaluate the model with test set<br/>evaluator = MulticlassClassificationEvaluator() <br/>tx_test = spark_model.transform(test)<br/>print('F1-Score ', evaluator.evaluate(<br/>                          tx_test, <br/>                          {evaluator.metricName: 'f1'})<br/>)<br/>print('Precision ', evaluator.evaluate(<br/>                          tx_test,<br/>                          {evaluator.metricName: 'weightedPrecision'})<br/>)<br/>print('Recall ', evaluator.evaluate(<br/>                          tx_test, <br/>                          {evaluator.metricName: 'weightedRecall'})<br/>)<br/>print('Accuracy ', evaluator.evaluate(<br/>                          tx_test, <br/>                          {evaluator.metricName: 'accuracy'})<br/>)</span></pre><p id="3809" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这里我们得到了结果。到现在都很有希望。</p><pre class="od oe of og gt op oq pe pf aw pg bi"><span id="27c8" class="nl kw jg oq b gy ph pi l pj oy">F1-Score  0.8111782234361806<br/>Precision  0.8422058244785519<br/>Recall  0.8090909090909091<br/>Accuracy  0.8090909090909091</span></pre></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h2 id="a638" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">混乱矩阵</h2><p id="c737" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这里，我们将使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a>总结分类模型的性能。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="a5d0" class="ou kw jg oq b be ov ow l ox oy">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import itertools<br/>def plot_confusion_matrix(cm, classes,<br/>                          normalize=False,<br/>                          title='Confusion matrix',<br/>                          cmap=plt.cm.GnBu):<br/>      plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>      plt.title(title)<br/>      tick_marks = np.arange(len(classes))<br/>      plt.xticks(tick_marks, classes, rotation=45)<br/>      plt.yticks(tick_marks, classes)<br/>      fmt = '.2f' if normalize else 'd'<br/>      thresh = cm.max() / 2.<br/><br/>      for i, j in itertools.product(<br/>          range(cm.shape[0]), range(cm.shape[1])<br/>      ):<br/>        plt.text(j, i, format(cm[i, j], fmt),<br/>                 horizontalalignment="center",<br/>                 color="white" if cm[i, j] &gt; thresh else "black")<br/><br/>      plt.tight_layout()<br/>      plt.ylabel('True label')<br/>      plt.xlabel('Predicted label')</span></pre><p id="70f1" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为此，我们需要将<strong class="lp jh"> Spark-DataFrame </strong>转换为<strong class="lp jh"> Pandas-DataFrame </strong>首先是<strong class="lp jh"> </strong>和<strong class="lp jh"> </strong>然后是<strong class="lp jh"> </strong>调用带有<strong class="lp jh">真</strong>和<strong class="lp jh">预测</strong>标签的混淆矩阵。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="5d91" class="ou kw jg oq b be ov ow l ox oy">from sklearn.metrics import confusion_matrix<br/><br/>y_true = tx_test.select("label")<br/>y_true = y_true.toPandas()<br/><br/>y_pred = tx_test.select("prediction")<br/>y_pred = y_pred.toPandas()<br/><br/>cnf_matrix = confusion_matrix(y_true, y_pred,labels=range(10))</span></pre><p id="f212" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们来想象一下<strong class="lp jh">混淆矩阵</strong></p><pre class="od oe of og gt op oq or bn os ot bi"><span id="7531" class="ou kw jg oq b be ov ow l ox oy">import seaborn as sns<br/>%matplotlib inline<br/><br/>sns.set_style("darkgrid")<br/>plt.figure(figsize=(7,7))<br/>plt.grid(False)<br/><br/># call pre defined function<br/>plot_confusion_matrix(cnf_matrix, classes=range(10))</span></pre><figure class="od oe of og gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pk"><img src="../Images/8314c8ebf9abab78785e45d3af0766f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-aK6ORJ0YPGi0N67mk-SA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fig 3: Confusion Matrix for 10 Bengali Digits (0 to 9)</figcaption></figure></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h2 id="e73a" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">分类报告</h2><p id="ca7f" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这里我们还可以通过评估矩阵得到每个类的分类报告。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="3a19" class="ou kw jg oq b be ov ow l ox oy">from sklearn.metrics import classification_report<br/><br/>target_names = ["Class {}".format(i) for i in range(10)]<br/>print(classification_report(y_true, y_pred, target_names = target_names))</span></pre><p id="9b5b" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">它将更好地展示每个类别标签预测的模型性能。</p><pre class="od oe of og gt op oq pe pf aw pg bi"><span id="9fb7" class="nl kw jg oq b gy ph pi l pj oy">precision  recall   f1-score   support</span><span id="e31a" class="nl kw jg oq b gy pl pi l pj oy">     Class 0       1.00      0.92      0.96        13<br/>     Class 1       0.57      1.00      0.73         8<br/>     Class 2       0.64      1.00      0.78         7<br/>     Class 3       0.88      0.70      0.78        10<br/>     Class 4       0.90      1.00      0.95         9<br/>     Class 5       0.67      0.83      0.74        12<br/>     Class 6       0.83      0.62      0.71         8<br/>     Class 7       1.00      0.80      0.89        10<br/>     Class 8       1.00      0.80      0.89        20<br/>     Class 9       0.70      0.54      0.61        13</span><span id="c068" class="nl kw jg oq b gy pl pi l pj oy">   micro avg       0.81      0.81      0.81       110<br/>   macro avg       0.82      0.82      0.80       110<br/>weighted avg       0.84      0.81      0.81       110</span></pre></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h2 id="095b" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">ROC AUC 得分</h2><p id="d6b1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们也来找一下这个模型的 ROC AUC 评分点。我在这里找到了下面这段来自<a class="ae jd" href="https://medium.com/@plog397/auc-roc-curve-scoring-function-for-multi-class-classification-9822871a6659" rel="noopener"> h </a>的代码。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="4dda" class="ou kw jg oq b be ov ow l ox oy">from sklearn.metrics import roc_curve, auc, roc_auc_score<br/>from sklearn.preprocessing import LabelBinarizer<br/><br/>def multiclass_roc_auc_score(y_test, y_pred, average="macro"):<br/>    lb = LabelBinarizer()<br/>    lb.fit(y_test)<br/>    y_test = lb.transform(y_test)<br/>    y_pred = lb.transform(y_pred)<br/>    return roc_auc_score(y_test, y_pred, average=average)<br/><br/>print('ROC AUC score:', multiclass_roc_auc_score(y_true,y_pred))</span></pre><p id="cd33" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">它的得分<strong class="lp jh">为 0.901。</strong></p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h2 id="e281" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">预测样本</h2><p id="1ca0" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们来看看它的一些预测，与真正的标签相比较。</p><pre class="od oe of og gt op oq or bn os ot bi"><span id="c03a" class="ou kw jg oq b be ov ow l ox oy"># all columns after transformations<br/>print(tx_test.columns)<br/><br/># see some predicted output<br/>tx_test.select('image', "prediction", "label").show()</span></pre><p id="5ad7" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">并且，结果将如下所示</p><pre class="od oe of og gt op oq pe pf aw pg bi"><span id="e5b2" class="nl kw jg oq b gy ph pi l pj oy">['image', 'label', 'features', 'rawPrediction', 'probability', 'prediction']<br/>+------------------+----------+--------+<br/>|       image      |prediction|  label |<br/>+------------------+----------+--------+<br/>|[file:/home/i...|       1.0|    1|<br/>|[file:/home/i...|       8.0|    8|<br/>|[file:/home/i...|       9.0|    9|<br/>|[file:/home/i...|       1.0|    8|<br/>|[file:/home/i...|       1.0|    1|<br/>|[file:/home/i...|       1.0|    9|<br/>|[file:/home/i...|       0.0|    0|<br/>|[file:/home/i...|       2.0|    9|<br/>|[file:/home/i...|       8.0|    8|<br/>|[file:/home/i...|       9.0|    9|<br/>|[file:/home/i...|       0.0|    0|<br/>|[file:/home/i...|       4.0|    0|<br/>|[file:/home/i...|       5.0|    9|<br/>|[file:/home/i...|       1.0|    1|<br/>|[file:/home/i...|       9.0|    9|<br/>|[file:/home/i...|       9.0|    9|<br/>|[file:/home/i...|       1.0|    1|<br/>|[file:/home/i...|       1.0|    1|<br/>|[file:/home/i...|       9.0|    9|<br/>|[file:/home/i...|       3.0|    6|<br/>+--------------------+----------+-----+<br/>only showing top 20 rows</span></pre></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="fa78" class="kv kw jg bd kx ky oz la lb lc pa le lf km pb kn lh kp pc kq lj ks pd kt ll lm bi translated">尾注</h1><p id="9a91" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">虽然我们已经使用了一个<strong class="lp jh"/><a class="ae jd" href="http://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">ImageNet</strong></a>权重，但是我们的模型在识别手写数字方面表现得非常好。此外，为了更好的泛化，我们也没有执行任何<strong class="lp jh">图像处理</strong>任务。此外，与 ImageNet 数据集相比，该模型是在非常少量的数据上训练的。</p><p id="bd1b" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在一个非常高的层次上，每个 Spark 应用程序都由一个驱动程序组成，该程序在一个集群上启动各种并行操作。驱动程序包含我们的应用程序的主要功能，定义集群上的分布式数据集，然后对它们应用操作。</p><p id="4edb" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是一个独立的应用程序，我们首先将应用程序链接到 Spark，然后在我们的程序中导入 Spark 包，并使用<strong class="lp jh"> SparkSession </strong>创建一个<strong class="lp jh"> SparkContext </strong>。虽然我们在单台机器上工作，但是我们可以将同一个 shell 连接到一个集群，并行训练数据。</p><p id="7060" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但是，您可以从下面的链接获得今天演示的源代码，也可以关注我的<a class="ae jd" href="https://github.com/innat" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh"> GitHub </strong> </a>以获取未来的代码更新。:)</p><div class="ip iq gp gr ir mo"><a href="https://github.com/innat/Transfer-Learning-PySpark" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jh gy z fp mt fr fs mu fu fw jf bi translated">innat/迁移-学习-PySpark</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">计算机视觉问题的一个有前途的解决方案，结合了最先进的技术:深度…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ix mo"/></div></div></a></div></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="4eec" class="kv kw jg bd kx ky oz la lb lc pa le lf km pb kn lh kp pc kq lj ks pd kt ll lm bi translated">下一步是什么？</h1><p id="b509" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">接下来，我们将使用 Spark 进行<strong class="lp jh">分布式超参数调整</strong> <strong class="lp jh">，并将尝试自定义<strong class="lp jh"> Keras </strong>模型和一些新的具有挑战性的示例。取得联系:)</strong></p><p id="ba4e" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">打招呼上:</strong> <a class="ae jd" href="http://innat1994@gmail.com" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">邮箱</strong></a><strong class="lp jh">|</strong><a class="ae jd" href="https://www.linkedin.com/in/innat2k14/" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">LinkedIn</strong></a><strong class="lp jh">|</strong><a class="ae jd" href="https://www.quora.com/profile/Mohammed-Innat#" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">Quora</strong></a><strong class="lp jh">|</strong><a class="ae jd" href="https://github.com/innat" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">GitHub</strong></a><strong class="lp jh">|</strong><a class="ae jd" href="https://twitter.com/innat_2k14" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">推特</strong></a><strong class="lp jh">|</strong><a class="ae jd" href="https://www.instagram.com/i_innat/" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">insta gram<strong class="lp jh"/></strong></a></p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h2 id="6caa" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">相关技术</h2><ul class=""><li id="9369" class="mx my jg lp b lq lr lt lu lw nx ma ny me nz mi oa nd ne nf bi translated">配有 Keras &amp; PySpark 的分布式 DL—<a class="ae jd" href="https://github.com/maxpumperla/elephas?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">Elephas</a></li><li id="af79" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">Apache Spark 的分布式深度学习库— <a class="ae jd" href="https://github.com/intel-analytics/BigDL" rel="noopener ugc nofollow" target="_blank"> BigDL </a></li><li id="0ca4" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">到阿帕奇火花星团的张量流— <a class="ae jd" href="https://github.com/yahoo/TensorFlowOnSpark" rel="noopener ugc nofollow" target="_blank">张量流 OnSpark </a></li></ul><h2 id="bb11" class="nl kw jg bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">参考</h2><ul class=""><li id="d92c" class="mx my jg lp b lq lr lt lu lw nx ma ny me nz mi oa nd ne nf bi translated">Databricks: <a class="ae jd" href="https://docs.databricks.com/applications/deep-learning/index.html" rel="noopener ugc nofollow" target="_blank">深度学习指南</a></li><li id="8cb1" class="mx my jg lp b lq ng lt nh lw ni ma nj me nk mi oa nd ne nf bi translated">Apache Spark: <a class="ae jd" href="https://spark.apache.org/docs/latest/api/python/index.html" rel="noopener ugc nofollow" target="_blank"> PySpark 机器学习</a></li></ul></div></div>    
</body>
</html>