<html>
<head>
<title>The Unreasonable Effectiveness of Method Chaining in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫中方法链接的不合理有效性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-unreasonable-effectiveness-of-method-chaining-in-pandas-15c2109e3c69?source=collection_archive---------3-----------------------#2019-01-27">https://towardsdatascience.com/the-unreasonable-effectiveness-of-method-chaining-in-pandas-15c2109e3c69?source=collection_archive---------3-----------------------#2019-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="a1f2" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">方法链接如何提高代码的可读性，用 lambda 函数编写自定义管道以实现最大的灵活性，并以代码格式化技巧结束。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/618798845e6dba8543c424e6cd6d1d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtkcdkkiZc2mLLzgnd_LMA.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Image by <a class="ae lf" href="https://texturex.com/metal-textures/chain-metal-texture-steel-8-links-chains-stock-photo/" rel="noopener ugc nofollow" target="_blank">Texturex</a></figcaption></figure><h1 id="fe26" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">介绍</h1><p id="e960" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">方法链接是一种编程风格，依次调用<strong class="jt ir">多个方法调用</strong>，每个调用在同一个对象上执行一个动作并返回它。它<strong class="jt ir">消除了在每个中间步骤命名变量</strong>的认知负担。<a class="ae lf" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank"> Fluent 接口</a>，一种创建面向对象 API 的方法依赖于方法级联(又名方法链)。这类似于 Unix 系统中的管道。</p><p id="a1da" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">方法链接大大增加了代码的可读性。如果你不相信我，我们去问问杰克和吉尔。</p><p id="dc2d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><em class="js">让我们尝试使用嵌套函数调用和方法链接来讲述杰克和吉尔的故事</em>，</p><p id="e1d5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><strong class="jt ir">嵌套调用:</strong></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e3bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><strong class="jt ir">方法链接:</strong></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="844a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">方法链接的一个明显的优点是，它是一种<strong class="jt ir">自顶向下的方法</strong>，参数放在函数旁边，不像嵌套调用，在嵌套调用中，跟踪各个函数调用到其参数是很费力的。</p><p id="9216" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">Pandas 为方法链接提供了几个函数，</p><p id="c43d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">向数据帧<code class="fe mo mp mq mr b">assign</code>添加新列，重命名列<code class="fe mo mp mq mr b">rename</code>，过滤数据帧<code class="fe mo mp mq mr b">query</code>等。让我们来看看教育学的<code class="fe mo mp mq mr b">wine</code>数据集。它包含 178 种葡萄酒的化学成分。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ms"><img src="../Images/6928fdb6af460ec246db6717ff5a8e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osSFkD3yQbOsALncoT1Mww.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Wine dataset</figcaption></figure><p id="d04b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">下面的代码从重命名<code class="fe mo mp mq mr b">color intensity</code>开始，因为它的缩写是<code class="fe mo mp mq mr b">ci</code>。然后，它基于<code class="fe mo mp mq mr b">hue </code>和<code class="fe mo mp mq mr b">ci</code>上的值创建一个新列<code class="fe mo mp mq mr b">color filter</code>。然后，它过滤酒精含量超过 14 的葡萄酒，并通过彩色过滤器。最后，它根据酒精含量对数据框进行排序，并显示我们感兴趣的列。<strong class="jt ir">如果在没有方法链接的情况下重复相同的步骤，则必须在每个步骤创建一个新的数据帧。</strong></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="eb74" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">方法链接的好处和坏处:</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mt"><img src="../Images/5feb06aa7c0306d94967fdbe5d3a1cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w52sm-yWyb3kOLd1EO9OwQ.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Image by <a class="ae lf" href="https://onmogul.com/stories/by-sally-dasouki-is-internet-a-boon-or-a-bane-for-the-youngsters" rel="noopener ugc nofollow" target="_blank">Sally Dasouki</a></figcaption></figure><p id="4477" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">与 Python 相比，R 的一个优势是它的<code class="fe mo mp mq mr b">tidyverse </code>包具有丰富的方法链接功能。再加上<code class="fe mo mp mq mr b">margrittr</code>，你经常可以找到一种方法来做你想在管道中做的事情。另一方面，Pandas 没有一个可理解的方法列表用于方法链接。但是为了弥补它，熊猫从版本<em class="js"> 0.16.2 </em>开始引入了<a class="ae lf" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pipe.html" rel="noopener ugc nofollow" target="_blank">管道</a>功能。管道在方法链中启用用户定义的方法。</p><p id="2da9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">随着 pipe 的引入，你几乎可以在一个方法链中写任何东西，这引发了一个问题，<strong class="jt ir">多少链是太多了？</strong>。这是一个完全主观的问题，必须由程序员来决定。大多数人发现在一个单独的链中有 7 或 8 个方法是最合适的。我对一个链中的方法数量没有任何硬性限制。相反，<em class="js">我试图用一个方法链</em>来表示一个连贯的思想。</p><p id="682e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><strong class="jt ir">一些方法链的坚定批评者指责它增加了代码的可读性，但却增加了调试的难度，这是事实</strong>。想象一下，一个月之后，你正在调试一个十个方法长的链。从那时起，数据帧结构或列名已经改变，现在您的链开始抛出错误。尽管您可以很容易地找到哪个方法调用破坏了代码，但是现在不可能在整个链中进行调试，并在您沿着链移动时看到它对数据帧所做的更改。在生产或笔记本中开始使用长方法链之前，需要解决这个问题。</p><h1 id="6385" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">组合管道和 lambda 函数:</h1><div class="kq kr ks kt gt ab cb"><figure class="mu ku mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><img src="../Images/916ccc131f0b8b04023cd81cfac7e534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*HDy1duiFbo7zFMXFFkLHJw.jpeg"/></div></figure><figure class="mu ku na mw mx my mz paragraph-image"><img src="../Images/194216afc1a316b69e058e753928fbed.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*WLMjsEfe9-7_OJT7g60Q6w@2x.png"/><figcaption class="lb lc gj gh gi ld le bd b be z dk nb di nc nd">Image by <a class="ae lf" href="https://lambda.grofers.com/" rel="noopener ugc nofollow" target="_blank">Grofers</a></figcaption></figure></div><p id="b716" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">每当数据框架的形状改变时，我经常会遇到方法链接的问题。如果你能沿着链跟踪形状，调试就容易多了。让我们定义一个自定义管道函数。编写管道函数的关键是它应该接收数据帧并返回数据帧。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b89e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这个函数中需要注意的两件事是可以接受 lambda 函数的<code class="fe mo mp mq mr b">fn</code>参数和<code class="fe mo mp mq mr b">display</code>函数调用。Lambda 函数提供了灵活性，display 函数调用使 Jupyter 实验室或笔记本电脑环境中的数据框和绘图显示更加美观。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/57e7ef5bddd8945b830b992b5e5ab195.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*HoE8PQBcJ_psuO4J-epOog.png"/></div></figure><p id="3c99" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">在这个例子中，我们可以看到我们从 13 列开始，<code class="fe mo mp mq mr b">assign</code>将列数增加到 14，随后的<code class="fe mo mp mq mr b">query</code>将行数减少到 22。末尾的管道从数据帧中随机打印出 5 行。这可以很容易地更改为 head 或 tail 函数。由于自变量是一个 lambda 函数，它给出了无数种可能性。当你开始写一个链时，在末尾添加一个带有<code class="fe mo mp mq mr b">csnap </code>函数的管道有助于你看到链上的变化。完成后，您可以删除管道或注释掉该行。这是拆除管道的一种幼稚的方法。相反，如果要将代码转移到生产环境中，可以使用 logger 对象并将其写入外部文件。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/bbedbf63f512243b40a4052324b822bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*nwoU4yoDO9AXfXD6vW5RjA.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Example of logging to a file</figcaption></figure><p id="4eea" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">日志记录为我们提供了不删除管道语句的灵活性，而是将日志记录级别更改为 INFO，以避免在生产过程中获得调试信息。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4271" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">让我们看看其他自定义管道函数。<code class="fe mo mp mq mr b">setcols</code>用于设置链中的列名。通常，当我们从外部源读取数据时，列名将包含大小写以及空格和特殊字符。这些问题可以这样解决，</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8f900e83221e477fab01626ddaa4308b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*1bdGwoVG3Tqshn8pUcalpA.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Iris data set before and after column rename</figcaption></figure><p id="8c5d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><strong class="jt ir">与</strong> <code class="fe mo mp mq mr b"><strong class="jt ir">csnap </strong></code> <strong class="jt ir">函数不同</strong> <code class="fe mo mp mq mr b"><strong class="jt ir">setcols </strong></code> <strong class="jt ir">函数创建数据帧的副本，这使得函数调用代价很高</strong>。但这是必要的，以确保我们没有在数据帧的全局副本上写入。大多数 pandas 函数的工作方式类似，都有一个就地标志，用于返回新的数据框或重新分配顶级引用。</p><p id="e33e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><em class="js">杰夫·雷巴克说，</em></p><blockquote class="jn jo jp"><p id="a5f9" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">不能保证</strong>就地操作确实更快。通常，它们是对副本进行的相同操作，但是顶级引用被重新分配。</p></blockquote><p id="67a2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">让我们用最后一个例子来结束这一部分。r 有一个多功能的选择函数，可以选择/取消选择宽数据框中的列，而不是列出所有内容。<code class="fe mo mp mq mr b">cfilter </code>使用 lambda 函数帮助我们实现同样的多功能性。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f501a2bc3d4440585b59097d10ce572b.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*uoiVPsu9AG3OHdRyNjq06Q.png"/></div></figure><h1 id="b954" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">代码格式:</h1><p id="edb6" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated"><strong class="jt ir">当多人使用不同的 IDE 在同一个代码库上工作时，代码格式的一致性是一个令人头疼的问题</strong>。在多行函数调用的情况下，方法链接使这个过程更加复杂。</p><h1 id="d26e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">输入黑色:</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/ce67e4e6e3bc0a377ce900507d36b8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TICvJdfOpy5jBQksnpAagA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Image from <a class="ae lf" href="https://github.com/ambv/black" rel="noopener ugc nofollow" target="_blank">Black</a></figcaption></figure><p id="e731" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><em class="js">摘自他们的 GitHub 描述，</em></p><blockquote class="jn jo jp"><p id="e2fc" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">布莱克</em>是不折不扣的 Python 代码格式化程序。通过使用它，您同意放弃对手写格式的细节的控制。作为回报，<em class="iq"> Black </em>为您提供了速度、确定性以及摆脱 pycodestyle 对格式的困扰。你将节省时间和精力去做更重要的事情。</p><p id="fdfb" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">不管你在读什么项目，黑化的代码看起来都一样。一段时间后，格式变得透明，您可以专注于内容。</p><p id="013e" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">黑色</em>通过产生尽可能小的差异，使代码审查更快。</p></blockquote><p id="1231" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><strong class="jt ir">使用 black 的一个主要优点是它理解 fluent 接口</strong>并相应地自动格式化函数调用，不像任何其他 IDE 的默认格式化程序。</p><h1 id="58f5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">为 Pycharm 设置黑色:</h1><p id="a247" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">第一步是<code class="fe mo mp mq mr b">pip install black</code>。在 pycharm 中，您可以将它集成为一个文件监视器，这样每次保存文件时，都会自动完成格式化；也可以将它集成为一个预提交挂钩，这样每次提交时，都会对代码进行格式化，从而保持整个项目的格式化完整性。详细的设置说明可在<a class="ae lf" href="https://github.com/ambv/black" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="3752" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">为 Jupyter 笔记本/实验室设置黑色</strong>:</h1><p id="f36d" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">第一步是<code class="fe mo mp mq mr b">pip install nb_black</code>。下一步是根据环境加载适当的扩展。如果是笔记本，那么使用<code class="fe mo mp mq mr b">%load_ext nb_black</code>其他实验室用<code class="fe mo mp mq mr b">%load_ext lab_black </code>。</p><p id="3ddb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">一个快速演示布莱克的行动，</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/a6f38976e21e147f9a1b476dea1ccee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1Cadi1Sg6oBQrpMlZMKkfw.gif"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Before and after of Black Formatting</figcaption></figure><p id="ff25" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">参考:</p><p id="4674" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">1)<a class="ae lf" href="https://tomaugspurger.github.io/method-chaining" rel="noopener ugc nofollow" target="_blank">https://tomaugspurger.github.io/method-chaining</a></p><p id="a2d1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">2)<a class="ae lf" href="https://stackoverflow.com/questions/22532302/pandas-peculiar-performance-drop-for-inplace-rename-after-dropna/22533110#22533110" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/22532302/pandas-specular-performance-drop-in-place-rename-after-drop na/22533110 # 22533110</a></p><p id="af3c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">3)<a class="ae lf" href="https://github.com/ambv/black" rel="noopener ugc nofollow" target="_blank">https://github.com/ambv/black</a></p></div></div>    
</body>
</html>