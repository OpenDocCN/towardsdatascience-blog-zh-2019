<html>
<head>
<title>Animating the Traveling Salesman Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作旅行推销员问题的动画</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/animating-the-traveling-salesman-problem-56da20b95b2f?source=collection_archive---------21-----------------------#2019-01-08">https://towardsdatascience.com/animating-the-traveling-salesman-problem-56da20b95b2f?source=collection_archive---------21-----------------------#2019-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ce29a39d37e8e14d9d05bff77583e646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ct_bqpIsDVnMEJh6R29Hw.png"/></div></div></figure><div class=""/><div class=""><h2 id="c7c9" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">从制作模型动画中学到的经验</h2></div><p id="1551" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">动画可以是一个强大的工具。用文字甚至图片来解释一个复杂的主题是一回事，但是动态的视觉效果有一种惊人的品质，可以将抽象的想法变得生动。这在诸如优化和机器学习等复杂的计算机科学领域尤其有用。</p><p id="0685" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">2018 年 10 月，我在 KotlinConf 做了一个关于优化和机器学习的<a class="ae lm" href="https://youtu.be/-zTqtEcnM7A" rel="noopener ugc nofollow" target="_blank">演讲</a>。在这几个例子中，有一个是<a class="ae lm" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行推销员问题(又名“TSP”)</a>。这是一个如此有趣和迷人的问题，它经常作为优化和<a class="ae lm" href="http://www.iro.umontreal.ca/~dift6751/paper_potvin_nn_tsp.pdf" rel="noopener ugc nofollow" target="_blank">甚至机器学习算法</a>的基准。然而，解释一些算法(如局部搜索和模拟退火)在没有视觉辅助的情况下不太直观。因此，我通过<a class="ae lm" href="https://github.com/edvin/tornadofx" rel="noopener ugc nofollow" target="_blank"> TornadoFX </a>用 JavaFX 做了这个开源项目。</p><p id="6622" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">会议上和网上的许多人都对动画视觉效果感到惊讶，评论它看起来多么“集成”和流畅。事实是我一起破解了这个应用程序，JavaFX 在其中起了很大的作用。它替我处理了动画，所以我可以专注于算法本身。这就是我想在这篇文章中写的内容。</p><p id="99be" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您可以在这里观看这个应用程序的视频演示(带有对 TSP 的详细解释)。我建议在继续阅读之前先看看这个。</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8d8a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这篇博文的重点将放在动画和它是如何实现的。要深入了解 TSP 以及如何解决它，请观看上面的视频。</p><h1 id="f167" class="lt lu jb bd lv lw lx ly lz ma mb mc md kh me ki mf kk mg kl mh kn mi ko mj mk bi translated">该结构</h1><p id="d7c9" class="pw-post-body-paragraph kq kr jb ks b kt ml kc kv kw mm kf ky kz mn lb lc ld mo lf lg lh mp lj lk ll ij bi translated">为了建立这一点，让我们首先布局我们的视觉框架的结构。我将用 Kotlin 语言来表达这一点，并通过 TornadoFX 来利用 JavaFX。幸运的是，TornadoFX 没有隐藏或抑制 JavaFX 的任何功能，而是用富于表现力的 Kotlin DSL 来增强它。所以你可以用 Java，Kotlin，Scala，或者任何可以使用 JavaFX 的 JVM 语言来实现。</p><p id="4cc6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我在应用程序中要做的第一件事是声明一个<code class="fe mq mr ms mt b">Pane</code>，并在其中放置一个带有简单欧洲地图图像的<code class="fe mq mr ms mt b">ImageView </code>。然后从我的领域模型中，我将导入我的<code class="fe mq mr ms mt b">City</code>对象，并在相对于欧洲地图的 x 和 y 屏幕坐标上放置一个红色的<code class="fe mq mr ms mt b">Circle </code>。最后，我将从我的域中导入<code class="fe mq mr ms mt b">Edge</code>对象，其中每个对象都绑定到一个<code class="fe mq mr ms mt b">City</code>，并将每个对象绑定到一个<code class="fe mq mr ms mt b">Line</code>。每个<code class="fe mq mr ms mt b">Edge </code>代表两个城市之间的一个连接，它以同一个城市为起点和终点进行初始化。因此，<code class="fe mq mr ms mt b">Line</code>将通过停留在<code class="fe mq mr ms mt b">Circle</code>内作为一个小点来初始化。<code class="fe mq mr ms mt b">Line</code>也将绑定到其所属<code class="fe mq mr ms mt b">Edge</code>的<code class="fe mq mr ms mt b">startX</code>、<code class="fe mq mr ms mt b">endX</code>、<code class="fe mq mr ms mt b">startY</code>和<code class="fe mq mr ms mt b">endY</code>属性。</p><pre class="ln lo lp lq gt mu mt mv mw aw mx bi"><span id="e5a3" class="my lu jb mt b gy mz na l nb nc">pane {<br/>    imageview(Image("europe.png")) {<br/>        fitHeight = 1000.0<br/>        fitWidth = 1000.0<br/><br/>        CitiesAndDistances.cities.forEach { city -&gt;<br/>            circle(city.x,city.y,10.0) {<br/>                fill = Color.RED<br/>            }<br/>        }<br/><br/>        Model.edges.forEach { edge -&gt;<br/>            line {<br/>                startXProperty().bind(edge.edgeStartX)<br/>                startYProperty().bind(edge.edgeStartY)<br/>                endXProperty().bind(edge.edgeEndX)<br/>                endYProperty().bind(edge.edgeEndY)<br/>                strokeWidth = 3.0<br/>                stroke = Color.RED<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="1c9c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这一点上，我应该有这样的渲染:</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="nd ls l"/></div></figure><p id="304e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当我们制作动画时，我们将改变每个边的<code class="fe mq mr ms mt b">startX</code>、<code class="fe mq mr ms mt b">endX</code>、<code class="fe mq mr ms mt b">startY</code>和<code class="fe mq mr ms mt b">endY</code>属性。例如，当我们想要连接两个城市时，我可以更改<code class="fe mq mr ms mt b">endX</code>和<code class="fe mq mr ms mt b">endY</code>属性，使这条线延伸到另一个城市的坐标。</p><h1 id="dcf8" class="lt lu jb bd lv lw lx ly lz ma mb mc md kh me ki mf kk mg kl mh kn mi ko mj mk bi translated">策划动画</h1><p id="e666" class="pw-post-body-paragraph kq kr jb ks b kt ml kc kv kw mm kf ky kz mn lb lc ld mo lf lg lh mp lj lk ll ij bi translated">有了这个结构，接下来我确实需要考虑一些事情。我应该实时制作算法的动画，还是将动画排队并使其可播放？我是想把算法做的每一件事都做成动画，还是过滤掉噪音，只把关键事件做成动画？</p><p id="bcd4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">乍一看，这些决定似乎不重要，我甚至告诉自己“为什么不把一切都做成动画呢？”。当然，这很快就适得其反了，因为动画已经降低了算法的速度……而且在算法中制作无效事件的动画只会增加噪音。这也使得动画变得异常冗长和乏味。</p><p id="1622" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你会问，什么是非生产性事件？正如视频中所解释的，该算法通过进行数千次随机<code class="fe mq mr ms mt b">Edge </code>交换来工作。当互换没有改善解决方案时(或者在模拟退火方法中抛硬币失败了)，我会取消互换，把所有东西都放回去。我了解到最好不要将这些事件动画化，因为大多数迭代都是失败的交换，并且最好将成功动画化来显示进展，而不是每个迭代都包括失败。</p><p id="dc1a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我最终做的另一个调整是首先运行算法，然后用<em class="ne">然后用</em>动画显示结果。这样做的好处是能够重放结果，而不必再次运行整个过程。我在 JavaFX 库中需要的关键实用程序是<code class="fe mq mr ms mt b">SequentialTransition</code>，它允许我将动画排队并按顺序播放(而不是一次播放)。</p><p id="43d4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后我可以让我的算法给<code class="fe mq mr ms mt b">SequentialTransition </code>添加动画，当它完成后就可以播放了。我将每个算法(“贪婪”、“二次选择”、“模拟退火”等)存储为可枚举的，所以我给每个算法赋予了自己的<code class="fe mq mr ms mt b">SequentialTransition</code>。我还创建了一些方便的扩展函数，这样我就可以使用<code class="fe mq mr ms mt b">+=</code>操作符来添加动画。</p><pre class="ln lo lp lq gt mu mt mv mw aw mx bi"><span id="94a6" class="my lu jb mt b gy mz na l nb nc">enum class SearchStrategy {<br/><br/>    RANDOM {<br/>        ... <br/>    },<br/><br/>    GREEDY {<br/>        ... <br/>    },<br/><br/>    REMOVE_OVERLAPS {<br/>        ... <br/>    },<br/>    TWO_OPT {<br/>        ... <br/>    },<br/><br/>    SIMULATED_ANNEALING {<br/>        ... <br/>    }<br/>    <br/>    val animationQueue = SequentialTransition()<br/><br/>    abstract fun execute()<br/>}<br/><br/><br/>// extension functions for SequentialTransition<br/>operator fun SequentialTransition.plusAssign(timeline: Timeline) {   <br/>     children += timeline }</span><span id="21a5" class="my lu jb mt b gy nf na l nb nc">fun SequentialTransition.clear() = children.clear()</span><span id="cd8a" class="my lu jb mt b gy nf na l nb nc">operator fun SequentialTransition.plusAssign(<br/>    other:SequentialTransition) { <br/>        children.addAll(other) <br/>}</span></pre><h1 id="2627" class="lt lu jb bd lv lw lx ly lz ma mb mc md kh me ki mf kk mg kl mh kn mi ko mj mk bi translated">执行路径遍历</h1><p id="bf5b" class="pw-post-body-paragraph kq kr jb ks b kt ml kc kv kw mm kf ky kz mn lb lc ld mo lf lg lh mp lj lk ll ij bi translated">在领域模型方面，我有最初属于一个<code class="fe mq mr ms mt b">City</code>的<code class="fe mq mr ms mt b">Edge</code>项目。然而，<code class="fe mq mr ms mt b">startCity</code>和<code class="fe mq mr ms mt b">endCity</code>可以变异，在每次变异时，<code class="fe mq mr ms mt b">Edge</code>都有一个<code class="fe mq mr ms mt b">animateChange()</code>函数返回一个延迟的<code class="fe mq mr ms mt b">Timeline</code>来播放那个变化。</p><p id="a3dc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但这是我最后做的有趣的设计决定。我创建了<code class="fe mq mr ms mt b">edgeStartX</code>、<code class="fe mq mr ms mt b">edgeStartY</code>、<code class="fe mq mr ms mt b">edgeEndX</code>和<code class="fe mq mr ms mt b">edgeEndY</code>，使其不与各自的<code class="fe mq mr ms mt b">startCity</code>和<code class="fe mq mr ms mt b">endCity</code>同步。相反，它们纯粹用于动画执行。当我决定在<code class="fe mq mr ms mt b">startCity </code>或<code class="fe mq mr ms mt b">endCity</code>中制作一个变化的动画时，我调用<code class="fe mq mr ms mt b">animateChange()</code>来创建一个<code class="fe mq mr ms mt b">Timeline</code>来制作坐标变化的动画。它将获取保存坐标值的每个 JavaFX 属性中的当前值，并通过在这段时间内逐渐增加/减少到指定值来制作动画(这是<code class="fe mq mr ms mt b">KeyFrame</code>的<code class="fe mq mr ms mt b">speed</code>)。</p><p id="c843" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意，虽然这个<code class="fe mq mr ms mt b">Timeline</code>不执行，但这取决于函数调用程序如何使用这个动画。</p><pre class="ln lo lp lq gt mu mt mv mw aw mx bi"><span id="9ac5" class="my lu jb mt b gy mz na l nb nc">class Edge(city: City) {<br/><br/>    val startCityProperty = SimpleObjectProperty(city)<br/>    var startCity by startCityProperty<br/><br/>    val endCityProperty = SimpleObjectProperty(city)<br/>    var endCity by endCityProperty<br/><br/>    val distance get() = CitiesAndDistances.distances[CityPair(startCity.id, <br/>      endCity.id)]?:0.0<br/><br/>    // animated properties<br/>    val edgeStartX = SimpleDoubleProperty(startCity.x)<br/>    val edgeStartY = SimpleDoubleProperty(startCity.y)<br/>    val edgeEndX = SimpleDoubleProperty(startCity.x)<br/>    val edgeEndY = SimpleDoubleProperty(startCity.y)<br/><br/>    fun animateChange() = timeline(play = false) {<br/>            keyframe(speed) {<br/>                keyvalue(edgeStartX, startCity?.x ?: 0.0)<br/>                keyvalue(edgeStartY, startCity?.y ?: 0.0)<br/>                keyvalue(edgeEndX, endCity?.x ?: 0.0)<br/>                keyvalue(edgeEndY, endCity?.y ?: 0.0)<br/>                keyvalue(Model.distanceProperty, <br/>                     Model.totalDistance)<br/>            }<br/>        }<br/>}</span></pre><p id="89f5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个特殊的函数用于第一次将一个<code class="fe mq mr ms mt b">Edge</code>扩展到另一个城市，这发生在<code class="fe mq mr ms mt b">GREEDY</code>和<code class="fe mq mr ms mt b">RANDOM</code>算法中。将这些按顺序缝合在一起会产生一条光滑的路径，从而创建一个往返行程。下面是在<code class="fe mq mr ms mt b">RANDOM</code>算法中如何利用<code class="fe mq mr ms mt b">animateChange()</code>函数。请注意，当我遍历每个随机的<code class="fe mq mr ms mt b">City</code>时，我是如何分别通过它们的<code class="fe mq mr ms mt b">startcity</code>和<code class="fe mq mr ms mt b">endCity</code>连接每个连续的<code class="fe mq mr ms mt b">Edge</code>对的。然后我调用<code class="fe mq mr ms mt b">animateChange()</code>返回一个<code class="fe mq mr ms mt b">Timeline</code>并添加到<code class="fe mq mr ms mt b">animationQueue</code>中。</p><pre class="ln lo lp lq gt mu mt mv mw aw mx bi"><span id="ef7b" class="my lu jb mt b gy mz na l nb nc">RANDOM {<br/>    override fun execute() {<br/>        animationQueue.clear()<br/><br/>        val capturedCities = mutableSetOf&lt;Int&gt;()<br/><br/>        val startingEdge = Model.edges.sample()<br/>        var edge = startingEdge<br/><br/>        while(capturedCities.size &lt; <br/>                CitiesAndDistances.cities.size) {</span><span id="f8f9" class="my lu jb mt b gy nf na l nb nc">            capturedCities += edge.startCity.id<br/><br/>            val nextRandom = Model.edges.asSequence()<br/>                    .filter { it.startCity.id !in capturedCities }<br/>                    .sampleOrNull()?:startingEdge<br/><br/>            edge.endCity = nextRandom.startCity<br/>            animationQueue += edge.animateChange()<br/>            edge = nextRandom<br/>        }<br/>        <br/>        Model.bestDistanceProperty.set(Model.totalDistance)<br/>    }<br/>}</span></pre><p id="3241" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当绿色 play 按钮被按下时，我的 UI 可以调用<code class="fe mq mr ms mt b">animationQueue.play()</code>来执行更改。</p><h1 id="f6ed" class="lt lu jb bd lv lw lx ly lz ma mb mc md kh me ki mf kk mg kl mh kn mi ko mj mk bi translated">执行交换</h1><p id="781b" class="pw-post-body-paragraph kq kr jb ks b kt ml kc kv kw mm kf ky kz mn lb lc ld mo lf lg lh mp lj lk ll ij bi translated">交换比制作路径遍历的动画要复杂一些。当<code class="fe mq mr ms mt b">TWO_OPT</code>或<code class="fe mq mr ms mt b">SIMULATED_ANNEALING</code>算法选择随机边并试图以某种方式交换它们的城市(顶点)时，有时会失败，有时会成功。如果交换中断了旅程，则会发生故障，并且会调用<code class="fe mq mr ms mt b">reverse()</code>函数。如果成功，可以调用一个<code class="fe mq mr ms mt b">animate()</code>函数并返回一个等待排队或执行的<code class="fe mq mr ms mt b">Timeline</code>。</p><pre class="ln lo lp lq gt mu mt mv mw aw mx bi"><span id="edd9" class="my lu jb mt b gy mz na l nb nc">class TwoSwap(val city1: City,<br/>          val city2: City,<br/>          val edge1: Edge,<br/>          val edge2: Edge<br/>) {<br/><br/>fun execute() {<br/>    edge1.let {      <br/>          sequenceOf(it.startCityProperty,it.endCityProperty)      <br/>    }.first { it.get() == city1 }<br/>    .set(city2)</span><span id="4f0c" class="my lu jb mt b gy nf na l nb nc">    edge2.let { <br/>       sequenceOf(it.startCityProperty,it.endCityProperty) <br/>    }.first { it.get() == city2 }<br/>    .set(city1)<br/>}</span><span id="cfce" class="my lu jb mt b gy nf na l nb nc">fun reverse() {<br/>    edge1.let { <br/>        sequenceOf(it.startCityProperty, it.endCityProperty) <br/>    }.first { it.get() == city2 }<br/>    .set(city1)<br/>    <br/>    edge2.let {<br/>        sequenceOf(it.startCityProperty,it.endCityProperty)     <br/>    }.first { it.get() == city1 }<br/>     .set(city2)</span><span id="318f" class="my lu jb mt b gy nf na l nb nc">}<br/><br/><br/>fun animate() = timeline(play = false) {<br/>        keyframe(speed) {<br/>            sequenceOf(edge1,edge2).forEach {<br/>                keyvalue(it.edgeStartX, it.startCity?.x ?: 0.0)<br/>                keyvalue(it.edgeStartY, it.startCity?.y ?: 0.0)<br/>                keyvalue(it.edgeEndX, it.endCity?.x ?: 0.0)<br/>                keyvalue(it.edgeEndY, it.endCity?.y ?: 0.0)<br/>            }<br/>        }<br/>        keyframe(1.millis) {<br/>            sequenceOf(edge1,edge2).forEach {<br/>                keyvalue(Model.distanceProperty, <br/>                   Model.totalDistance)<br/>            }<br/>        }<br/>    }<br/><br/>}<br/><br/>fun attemptTwoSwap(otherEdge: Edge): TwoSwap? {<br/><br/>    val e1 = this<br/>    val e2 = otherEdge<br/><br/>    val startCity1 = startCity<br/>    val endCity1 = endCity<br/>    val startCity2 = otherEdge.startCity<br/>    val endCity2 = otherEdge.endCity<br/><br/>    return sequenceOf(<br/>        TwoSwap(startCity1, startCity2, e1, e2),<br/>        TwoSwap(endCity1, endCity2, e1, e2),<br/><br/>        TwoSwap(startCity1, endCity2, e1, e2),<br/>        TwoSwap(endCity1, startCity2, e1, e2)<br/><br/>    ).filter {<br/>        it.edge1.startCity !in it.edge2.let { <br/>           setOf(it.startCity, it.endCity) <br/>        } &amp;&amp; it.edge1.endCity !in it.edge2.let {  <br/>           setOf(it.startCity, it.endCity) <br/>       }<br/>    }<br/>    .firstOrNull { swap -&gt;<br/>        swap.execute()<br/>        val result = Model.tourMaintained<br/>        if (!result) {<br/>        swap.reverse()<br/>        }<br/>        result<br/>    }<br/>}</span></pre><p id="aeb6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这可用于<code class="fe mq mr ms mt b">TWO_OPT</code>和<code class="fe mq mr ms mt b">SIMULATED_ANNEALING</code>算法。请注意，对于这两种算法，我首先清理<code class="fe mq mr ms mt b">animationQueue</code>，执行<code class="fe mq mr ms mt b">RANDOM</code>算法并获取其所有动画，并将它们添加到该算法的动画中。对于<code class="fe mq mr ms mt b">TWO_OPT</code>，我尝试了 2000 次随机交换，并且只添加了增加旅程距离的动画。否则我调用<code class="fe mq mr ms mt b">reverse()</code>并且不对交换进行动画处理(就好像它从未发生过一样)。</p><pre class="ln lo lp lq gt mu mt mv mw aw mx bi"><span id="0be3" class="my lu jb mt b gy mz na l nb nc">TWO_OPT {<br/>    override fun execute() {<br/>        animationQueue.clear()<br/>        SearchStrategy.RANDOM.execute()<br/>        animationQueue += SearchStrategy.RANDOM.animationQueue<br/><br/>        (1..2000).forEach { iteration -&gt;<br/>        Model.edges.sampleDistinct(2).toList()<br/>                .let { it.first() to it.last() }<br/>                .also { (e1,e2) -&gt;<br/><br/>                    val oldDistance = Model.totalDistance<br/>                    e1.attemptTwoSwap(e2)?.also {<br/>                        when {<br/>                            oldDistance &lt;= Model.totalDistance -&gt; <br/>                                it.reverse()<br/>                            oldDistance &gt; Model.totalDistance -&gt; <br/>                                animationQueue += it.animate()<br/>                        }<br/>                    }<br/>                }<br/>        }<br/>        Model.distanceProperty.set(Model.totalDistance)<br/>        Model.bestDistanceProperty.set(Model.totalDistance)<br/><br/>        println("TWO-OPT BEST DISTANCE: ${Model.totalDistance}")<br/><br/>    }<br/>}</span></pre><p id="5062" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦算法完成，就在期望的<code class="fe mq mr ms mt b">SearchStrategy</code>可枚举上调用<code class="fe mq mr ms mt b">animationQueue.play()</code>并观看焰火。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/0c7e44cdc7c9f51ab2f43aaa661ccbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a_S34gig2cqzS1JK.png"/></div></div></figure></div></div>    
</body>
</html>