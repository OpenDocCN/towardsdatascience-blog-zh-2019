<html>
<head>
<title>What Can We Demonstrate With Lathe 0.0.8?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用车床 0.0.8 可以演示什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-can-we-demonstrate-with-lathe-0-0-8-for-julia-1-3-b262dce24dd9?source=collection_archive---------31-----------------------#2019-12-20">https://towardsdatascience.com/what-can-we-demonstrate-with-lathe-0-0-8-for-julia-1-3-b262dce24dd9?source=collection_archive---------31-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2336" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">(对于朱莉娅 1.3)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/3e8e07166278e00bc19d97a8069e0722.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*KVWCHitQICfx-Kf2nTUZ5g.png"/></div></figure><p id="cec1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">车床 0.0.8“文件和调度”是车床画布上一个相当大的发布。顾名思义，这个版本有大量的文档。但这还不是全部，速度已经被优先考虑，大多数功能现在都优化了很多。此外，模型构造函数现在通过 Julia 的类型调度使用参数多态，而不是条件。</p><blockquote class="lm"><p id="9868" class="ln lo it bd lp lq lr ls lt lu lv ll dk translated"><a class="ae lw" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Parametric%20Polymorphism-Dox%20Lathe.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p><p id="d15e" class="ln lo it bd lp lq lr ls lt lu lv ll dk translated"><a class="ae lw" href="https://github.com/emmettgb/Lathe.jl" rel="noopener ugc nofollow" target="_blank">车床(Github) </a></p></blockquote><figure class="ly lz ma mb mc kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/f3045f4740dd7eaae0733480262adc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/1*xSJPL4aA0OsyVsMNLl-uhQ.png"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="ae13" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参数多态性</h1><p id="80a1" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">如果您想知道当谈到函数式编程时，我是否会经常谈到这个概念，</p><blockquote class="lm"><p id="dcb4" class="ln lo it bd lp lq lr ls lt lu lv ll dk translated">是的，我是。</p></blockquote><p id="c954" class="pw-post-body-paragraph kq kr it ks b kt nh ju kv kw ni jx ky kz nj lb lc ld nk lf lg lh nl lj lk ll im bi translated">Lathe 中的参数多态允许更简洁地使用 Lathe 中的“预测”函数作为结构的属性，而不是接受结构输入的函数。不用说，这要快得多，也简洁得多。但是事情远不止如此。</p><p id="49bd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过 Julia(awesome)的调度使用这种形式的参数多态性，我们可以使用同一个函数做数百万件事情，越来越容易，甚至不需要访问代码库就可以<strong class="ks iu">。</strong></p><p id="71e6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这意味着任何头脑正常的人都可以为车床编写扩展，同样，车床可以做比现在更多的事情。有了 Julia 的参数多态性，来自 Lathe 的函数基本上可以做任何事情。为了让您了解添加结构有多简单，我们来快速做一下。</p><p id="4777" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步是从车床导入预测功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4e41057419b1e4cb72386d306ae64193.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*vUlWkYHTo1GEogwWWJ0YsQ.png"/></div></figure><p id="06a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们可以制造任何构造函数，甚至可以使用车床模型并为它重写一个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/be0b70a23a2da24350d9364702c6f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*-lTm3JqCJre-2Hl6aMG3WQ.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">4</figcaption></figure><p id="93a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我选择将我的可变结构命名为“Emmett”我选中这个名字的原因是<strong class="ks iu"> <em class="ns">还是</em> </strong>未知。接下来，我们构造一个名为 emdawg 的变量(真的？)并且我们可以断言我的身高和体重。既然在构造函数中已经有了我的身高和体重，我们可以打印单独的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/093dac3da6412ea5b1d19475cdf05dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*VjbztimOXM67ZOiWYYI-mQ.png"/></div></figure><p id="9e80" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">酷！因此，让我们编写一个利用该构造函数的函数，然后我们将从 Lathe.models.predict()中调度它。我决定写一个函数来计算身体质量指数，因为我们有身高和体重。一个问题是我们的身高是一个代表英尺和英寸的浮点数，即 6.4 == 6 英尺 4 英寸。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/683a46295e8cc136306045dba6da777c.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*sYu5E4lC7mYteEb_nfsB_w.png"/></div></figure><p id="328a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们有了函数，我们只需要通过调度调用它。这是我想到的:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="629d" class="oa ml it nw b gy ob oc l od oe">predict(m::Emmett) = calc_bmi(m)</span></pre><p id="8cbb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，当我们将构造函数插入到 Lathe.models.predict()中时，我们得到一个返回:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/0b9fc2b897eb1f66dcd8efc4b66f11e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FbUd3LUnPhtr0qesyyUSg.png"/></div></div></figure><blockquote class="lm"><p id="a4c9" class="ln lo it bd lp lq ok ol om on oo ll dk translated">不要去查那个身体质量指数</p></blockquote></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="9f12" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">证明文件</h1><p id="b2a8" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">有了这次更新，我想停止去维护者的网站搜索文档的传统方法。您可能需要了解的一切都应该可以在语言本身中找到，所以让我们来测试一下。</p><p id="6195" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，作为一个新用户，很难模仿我自己，这个项目的维护者…但我们现在会试着假装我根本不知道如何使用车床。我们可以完全用这个来操纵车床。()函数来自 Julia 的 base。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi op"><img src="../Images/11b31d8ce50ac1a6a79f9dd70ed60415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GF1cfSvahsPDZS51ds_uQ.png"/></div></div></figure><p id="2348" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们什么时候？(车床)，我们得到这样一个返回:一个树，里面有所有单独的模块，以及一些包信息，包括版本、依赖项和 UUID。关于这些的更多信息，可以查看任何 Julia 包的 Project.toml 文件(包括 Lathe。)</p><p id="be4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么接下来呢？就在树下，我们看到使用说明。(车床.包)获取信息。让我们在车床上试试。模型</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b41d8dcbcf256a8a81ade7233a05616e.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*eiR4soGw4KSOD-WAv7nlWw.png"/></div></figure><p id="2754" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们可以看到每个结构的每个参数，以及我们的附属函数。所以，举例来说，我们可以看看车床。模型。线性最小平方</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi or"><img src="../Images/f0e593935f64238a6e8818eba772b841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Td6BEwnn4QxgQWPnY7J4WQ.png"/></div></div></figure><p id="a7e8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这样，我们得到了一个全面的超参数列表、一个简短的描述和一个使用示例。理想情况下，这将是我们训练和验证模型所需的一切。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="4e35" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="9f31" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">车床是一个非常酷的包，0.0.9 的画布承诺了更多酷的特性，特别是在分类预测领域。如果你想更多地了解车床的新版本控制，有看板可以很好地记录到底发生了什么。</p><h2 id="3094" class="oa ml it bd mm os ot dn mq ou ov dp mu kz ow ox mw ld oy oz my lh pa pb na pc bi translated"><a class="ae lw" href="https://github.com/emmettgb/Lathe.jl/projects?query=is%3Aclosed" rel="noopener ugc nofollow" target="_blank">车床 0.0.8 板</a></h2><h2 id="119b" class="oa ml it bd mm os ot dn mq ou ov dp mu kz ow ox mw ld oy oz my lh pa pb na pc bi translated"><a class="ae lw" href="https://github.com/emmettgb/Lathe.jl/projects?query=is%3Aopen" rel="noopener ugc nofollow" target="_blank">车床 0.0.9 板</a></h2></div></div>    
</body>
</html>