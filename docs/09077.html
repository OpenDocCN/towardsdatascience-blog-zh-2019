<html>
<head>
<title>Faster A/B testing 🚀— in numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更快的 A/B 测试🚀—用数字表示</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/faster-a-b-testing-in-numbers-ee82e1af0885?source=collection_archive---------47-----------------------#2019-12-02">https://towardsdatascience.com/faster-a-b-testing-in-numbers-ee82e1af0885?source=collection_archive---------47-----------------------#2019-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8777" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">除了传统假设检验(也称为 frequentist)方法之外的其他方法正变得越来越普遍——我发现贝叶斯方法是一个有意义的改进。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b8f8292703f0ca7b698b8a403f808b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1w7RW-FJ4vMQ7u1xxckfg.png"/></div></div></figure><h1 id="d3af" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">传统的方法🎓</h1><p id="7f90" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">典型的 A/B 测试意味着假设测试——这意味着我们想要“证明 A &amp; B 是显著不同的”。我们可以将我们的测试结果插入到现有的 A/B 测试评估器中，例如来自 Evan Miller 的<a class="ae mf" href="https://www.evanmiller.org/ab-testing/chi-squared.html" rel="noopener ugc nofollow" target="_blank">评估器，并得到结果。</a></p><p id="fecc" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在大多数这些工具中，部分结果是“p”值。通常，如果小于 5%，结果被认为是显著的。有趣的是，许多人不知道“p”值的实际含义，并且经常被误解。这是问题的一部分，因为如果你不能解读测试结果，就很难得出合理的结论。</p><p id="da7f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="ml">“p”值代表 A 和 B 来自同一分布的可能性</em></p><h1 id="13be" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么要改变？😱</h1><p id="c267" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在我看来，常规方法有两个重大问题:</p><ol class=""><li id="932c" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">由于理解“p”值很难，人们经常得出错误的结论</li><li id="b2a1" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">传统的方法需要非常大的样本量:用典型的参数来显示 1%成功率的转换漏斗上 10%的提升，你必须让 320 000 个用户看到你的测试！</li></ol><h1 id="4be7" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">贝氏救援队。⛑</h1><p id="d959" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了评估其他工具，我构建了一个模拟环境来测试各种框架及其参数。下面我将分享我的高级发现，并推荐一些你可以使用的参数，我发现这些参数非常健壮。</p><p id="c401" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">场景:</strong>假设你计划在接下来的几周内一个接一个地运行 10 个 A/B 测试，如果一个测试被接受，你将为所有未来的用户推出这个特性。不是所有的 A/B 测试都是肯定的，有时你不知道用户在寻找什么——我假设你测试的是更好或更差的版本。</p><p id="8b2f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在每个模拟中，我综合了每个测试的改进——因此，如果 10 个测试中有 3 个测试获得了+3%、+7%、+2%的改进，我会计算:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="e50b" class="nf ks iq nb b gy ng nh l ni nj">(1.03 * 1.07 * 1.02)-1 = 0.124.. = 12.4%</span></pre><p id="ce5d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我重复了 1000 次以上的模拟，然后平均出复合结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/0ad3ddad4a1120e2c0289e41046dca57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MhVy3ycVTHYLrOBV2I1Kg.png"/></div></div></figure><p id="9423" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">正如你所看到的，所有的框架都接受积极的测试，并允许你向所有用户推出改进。但是你也可以看到,<strong class="ll ir"> Bayes(完整持续时间)</strong>版本产生了最大的提升(给定相同的精确 A/B 测试结果)。这怎么可能呢？<strong class="ll ir">贝叶斯</strong>伊恩方法接受小结果的负担也较低——因为来自多个测试的小结果可以合成大结果，所以<strong class="ll ir">贝叶斯</strong>伊恩方法胜出。您还可以看到，如果您运行 A/B 测试的时间较短，那么框架将无法做出如同拥有所有数据一样好的决策。</p><p id="ecc1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是贝叶斯方法有什么缺点吗？不幸的是，这一点经常被忽略，但是要回答这个问题，我们不应该看平均模拟结果，而应该看复合结果的分布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/370fa79fc647dfb0a88eb34fd0c45aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7y05bcS2MPoFTCv3vwkkUg.png"/></div></div></figure><p id="8581" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">百分位数显示，在一小部分模拟中(~1%)测试框架的错误决策会导致整体性能下降。虽然在我们的模拟中我们可以看到这一事实，但在现实世界中，您不会注意到您正在损害您的业务！相比之下，你可以看到非常保守的传统(Frequentist)方法没有这个问题。</p><h1 id="e7da" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">好吧，那么哪个更好呢？🤔</h1><p id="48da" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">总的来说，我更喜欢贝叶斯伊恩方法——只要你不是超级倒霉，你就可以期待用这种方法得到更好的结果，但在这种情况下，你也不会比传统方法失去太多。</p><p id="3fa3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">您还必须考虑时间方面——为您的决策框架提供更少的时间(和数据)将会导致更糟糕的决策……</p><p id="a817" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">除了:如果更短的测试持续时间可以让你运行更多的测试，这是一个值得的权衡。</p><p id="b3df" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">比方说，如果你在三分之一的时间内运行你的测试，它允许你在相同的时间内运行两倍的测试。这对结果有什么影响？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/5e00cd5888aebbe05a628cc2639ede1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6MGAc04Em5odqyr4ZKxCQ.png"/></div></div></figure><p id="91eb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">正如你所看到的，在 Frequentist 方法中用更短的测试持续时间运行更多的测试并没有太大的帮助，但是在<strong class="ll ir"> Bayes </strong> ian 的情况下，我们减少了可能的负面影响并显著提高了正面影响。</p><h1 id="4740" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">让我们在 0 时间内运行无限量的测试🦁</h1><p id="ecbb" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我的模拟显示，在<strong class="ll ir"> Bayes </strong> ian 框架中，只要运行同等数量的测试，就有可能将测试时间越来越短(例如，将时间减少 10 倍，运行 10 倍的测试)。实际上，这有几个问题:</p><ol class=""><li id="8a2a" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">如果您正在运行的测试的质量因为频率的增加而下降——所有的赌注都将被取消</li><li id="9fba" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">通常你不能运行尽可能多的测试，因为有人需要构建它们——在这种情况下，为测试分配尽可能多的时间以做出最好的决策是有意义的</li><li id="43bc" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">一般来说，你应该运行你的测试至少一个星期——用户在周末的行为可能与工作日有很大的不同，你的测试应该能够考虑这些情况！</li></ol><h1 id="1a76" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">让我们用贝叶斯分析一些测试🐳</h1><p id="f18d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我建议你使用以下参数来保护你的缺点:</p><ol class=""><li id="d17f" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">获胜的可能性应该大于 66%</li><li id="4895" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">利润应大于 1%</li></ol><p id="ba96" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我将在下面提供 python 代码，但是您也可以在大多数其他编程语言中这样做！该代码只是近似的，运行速度相当快。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="d864" class="nf ks iq nb b gy ng nh l ni nj"><em class="ml"># to install dependencies: pip install numpy scipy<br/></em><strong class="nb ir">import </strong>numpy <strong class="nb ir">as </strong>_numpy<br/><strong class="nb ir">from </strong>scipy.stats.distributions <strong class="nb ir">import </strong>beta <strong class="nb ir">as </strong>_beta<br/></span><span id="7540" class="nf ks iq nb b gy nn nh l ni nj"><strong class="nb ir">def </strong>get_likelihood_of_win(test_result, margin=0.01):<br/>    success = 0<br/>    total = 0</span><span id="c5ae" class="nf ks iq nb b gy nn nh l ni nj">    ref_pos = test_result[<strong class="nb ir">'A'</strong>][<strong class="nb ir">'success_cnt'</strong>]<br/>    ref_neg = test_result[<strong class="nb ir">'A'</strong>][<strong class="nb ir">'fail_cnt'</strong>]<br/>    test_pos = test_result[<strong class="nb ir">'B'</strong>][<strong class="nb ir">'success_cnt'</strong>]<br/>    test_neg = test_result[<strong class="nb ir">'B'</strong>][<strong class="nb ir">'fail_cnt'</strong>]</span><span id="2e4a" class="nf ks iq nb b gy nn nh l ni nj">    conv_rate_base = max(<br/>        (ref_pos/ ref_pos + ref_neg),<br/>        (test_pos/ test_pos + test_neg)<br/>    )</span><span id="7fd6" class="nf ks iq nb b gy nn nh l ni nj">    <strong class="nb ir">for </strong>x <strong class="nb ir">in </strong>_numpy.linspace(0, min(conv_rate_base * 2, 1), 100):<br/>        prob = _beta.pdf(x=x, a=ref_pos, b=ref_neg)<br/>        prob_test_wins = 1 - _beta.cdf(<br/>            x=x * (1 + margin), <br/>            a=test_pos, b=test_neg<br/>        )<br/>        success += prob_test_wins * prob<br/>        total += prob</span><span id="75b2" class="nf ks iq nb b gy nn nh l ni nj">    <strong class="nb ir">return </strong>success / total<br/></span><span id="e947" class="nf ks iq nb b gy nn nh l ni nj"><strong class="nb ir">if </strong>__name__ == <strong class="nb ir">'__main__'</strong>:<br/>    test_result = {<br/>        <strong class="nb ir">'A'</strong>: {<br/>            <strong class="nb ir">'success_cnt'</strong>: 10,<br/>            <strong class="nb ir">'fail_cnt'</strong>: 100,<br/>        },<br/>        <strong class="nb ir">'B'</strong>: {<br/>            <strong class="nb ir">'success_cnt'</strong>: 18,<br/>            <strong class="nb ir">'fail_cnt'</strong>: 100,<br/>        }<br/>    }<br/>    likelihood_of_win = get_likelihood_of_win(<br/>        test_result=test_result, margin=0.01<br/>    )<br/>    accepted = likelihood_of_win &gt; 0.66<br/>    print(accepted, round(likelihood_of_win, 2))</span></pre></div></div>    
</body>
</html>