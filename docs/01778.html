<html>
<head>
<title>Better Understanding Negative Log Loss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好地理解负对数损失</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-negative-log-loss-8c3e77fafb79?source=collection_archive---------6-----------------------#2019-03-24">https://towardsdatascience.com/understanding-negative-log-loss-8c3e77fafb79?source=collection_archive---------6-----------------------#2019-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在学习<a class="ae ko" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>的时候，我决定在一些数据集上测试“3 行代码”,而不是在课程中使用的数据集。<a class="ae ko" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>的<a class="ae ko" href="http://wiki.fast.ai/index.php/Image_Datasets" rel="noopener ugc nofollow" target="_blank">维基页面</a>有一些推荐，我决定尽可能多地尝试。</p><p id="34c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单类别下的第一个推荐数据集是<a class="ae ko" href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition" rel="noopener ugc nofollow" target="_blank">狗对猫 Redux: Kernels Edition </a>。虽然这个和课程里的很像，但我觉得不妨试试。</p><p id="84b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该数据集包含 25000 幅训练图像和 12500 幅测试图像。使用的评估指标是 LogLoss，描述如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/cac7b8da9c268d24afa6146b7ffd08a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WI_I5ecz7PQjeE4FebLfDQ@2x.png"/></div></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lb"><img src="../Images/f674bf73230de1c1b5297b13ba6f644f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzOmOTfAKwGUosZw_7VmRg@2x.png"/></div></div></figure><p id="99e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个实验的参考是 github 中的<a class="ae ko" href="https://github.com/fastai/fastai/blob/master/courses/dl1/lesson1.ipynb" rel="noopener ugc nofollow" target="_blank"> lesson-1 </a>笔记本</p><p id="1862" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下载文件，启动 Jupiter 笔记本，导入依赖项，设置路径，我们就可以开始了…嗯，不完全是。在我们开始我们的 3 行深度学习之前，我们还需要几行代码。这场比赛提供数据的方式与在<a class="ae ko" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>服务器上提供的<a class="ae ko" href="http://files.fast.ai/data/dogscats.zip" rel="noopener ugc nofollow" target="_blank">数据</a>略有不同。有多种方法可以处理这个问题，我发现最简单的方法是使用函数；</p><blockquote class="lc"><p id="e29e" class="ld le it bd lf lg lh li lj lk ll kn dk translated"><em class="lm">图像分类器数据。</em>来自 _ 名称 _ 和 _ 数组(…)</p></blockquote><p id="d4a8" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">而不是；</p><blockquote class="lc"><p id="e1c0" class="ld le it bd lf lg lh li lj lk ll kn dk translated"><em class="lm">image classifierdata . from _ paths(…)</em></p></blockquote><p id="2b70" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在我们这样做之前，我们需要 2 行额外的代码；</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ls"><img src="../Images/200e16822d83741c82b3021a06d48187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWbkw4QAZHybo48Yo5UxnA@2x.png"/></div></div></figure><p id="5ffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以开始我们的 3 行代码了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lt"><img src="../Images/677724147ca82a2719c6a2cdc5af8096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNmyoESthDMgZg2GCzrZTQ.png"/></div></div></figure><p id="cedb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这导致验证损失<em class="lu"> 0.029175 </em>。禁用预计算、解冻层、添加丢失并再训练 7 个历元会使损失降至<em class="lu"> 0.024749 </em>。</p><p id="2ba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在测试集上运行了预测，该模型给了我一个公共排行榜分数<em class="lu"> 0.06614 </em>。我的验证分数严重下降，但对(几乎)标准化代码来说还不算太坏。现在，我必须缩小我的分数与排名 1 的持有者的分数<em class="lu"> 0.03302 </em>之间的差距。</p><h2 id="601d" class="lv lw it bd lx ly lz dn ma mb mc dp md kb me mf mg kf mh mi mj kj mk ml mm mn bi translated">震惊</h2><p id="a800" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">在这一点上，我决定表现得厚脸皮一点。如果图像是猫，实际值为 0，如果图像是狗，实际值为 1。softmax 函数的输出只能是接近 0 或 1 的值，它永远不会是 0 或 1。我想，如果我把预测值推近 0 或 1，那么它可能会帮助我摆脱一些误差。我期待着第三位小数的变化，如果我真的很幸运，也许是第二位小数的变化。</p><p id="2984" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我编写了简单的代码来检查我的预测中的每个值。如果该值大于 0.9，则设为 1，如果该值小于 0.1，则设为 0，否则保持不变。生成并上传了一个新的提交文件，并急切地等待着看我的鬼把戏为我赢得了多少位置。令我惊讶的是，我的分数恶化到了<em class="lu"> 0.19683 </em>。</p><p id="7ac0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的第一个想法是，我一定是在代码中出错了。但是代码非常简单，只有两行，如下所示。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mt"><img src="../Images/c8c637b27cbefacaa0620896084b7723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzstkH8KtpLlqFS1edFDWQ@2x.png"/></div></div></figure><p id="0c4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lu"> pred_list_cor </em>包含原始预测值，即 12500 个测试图像中每一个的 softmax 的输出。嗯，卡格尔不可能错，所以我必须错。但是我相信我的逻辑是正确的。所以我试着在纸上算出来。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mu"><img src="../Images/ac114cb7bf4da163eb9a3e4ab7b853de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ote4MAtY2uvN4anjf2kLMQ.png"/></div></div></figure><p id="b540" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两项的结果都是 0。第一个是因为实际值，第二个是因为对数函数。这给出了 0 的理想损耗。当图像是狗的图像时，该逻辑也是有效的。</p><p id="5481" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我现在怀疑的是术语<strong class="js iu"> <em class="lu"> log(0) </em> </strong>，当然，它是未定义的。值不能为 0 或 1，因为这将导致两个术语中的一个变得不确定。对此，显而易见的解决方案是用'<em class="lu"> epsilon' </em>'替换' 0 '，用'<em class="lu"> 1- eplison' </em>'替换' 1 '。这将误差略微改善至<em class="lu"> 0.14109 </em>。进展，但我仍然不知道发生了什么解释。</p><p id="49ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你把预测值和实际值相匹配，损失应该会下降！但是我看到了相反的效果。我下一次试图理解观察到的行为是使用一个足够高和足够低的值，但不要像<em class="lu"> epsilon </em>那样剧烈。我选择了<em class="lu">0.99999</em>&amp;<em class="lu">0.00001</em>。使用这些，我的损失下降到 0.12065 。有所改善，但仍比我未改变的预测高很多。</p><h2 id="4372" class="lv lw it bd lx ly lz dn ma mb mc dp md kb me mf mg kf mh mi mj kj mk ml mm mn bi translated">敬畏</h2><p id="dc76" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">很明显，我的修改恶化了错误，而不是改善了错误，但我还不明白为什么。从数学上来说，它应该有所改善。</p><p id="e379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我觉得，获得更多清晰的唯一方法是检查我的预测到底发生了什么。因为我使用的是 Kaggle 数据集，所以我没有测试集的标签。我煞费苦心地手工标记了前 500 张图片。然后根据我的预测计算损失。损失为<em class="lu"> 0.00960 </em>，成绩优秀。然后我用我修改后的预测计算了损失，它是<em class="lu"> 0.01531 </em>。显著增加，但这一次，我有数据来确定问题的根源。</p><p id="880b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在仔细检查我的预测和实际标签后，我注意到我的模型在预测中有一个错误。它给一只狗贴上了猫的标签，通过对<em class="lu"> 0.03824 </em>的预测，它很有把握这张图片确实是一只猫。我的提升逻辑已经将这个值推至接近 0。这就是问题的根源。</p><blockquote class="lc"><p id="6248" class="ld le it bd lf lg lh li lj lk ll kn dk translated">测井损失误差会严重影响不正确的预测</p></blockquote><p id="f079" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我 1 次不正确的预测已经让我损失惨重，但我对预测的修改加剧了误差，导致误差增加了 0.0057。关于这一点的一个很好的解释在这个<a class="ae ko" href="https://www.r-bloggers.com/making-sense-of-logarithmic-loss/" rel="noopener ugc nofollow" target="_blank">博客</a>中，我在下面提到了其中的摘录。</p><blockquote class="mv mw mx"><p id="3b55" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">比方说，实际值是 1。</p><p id="6fee" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">如果你的模型是不确定的，预测值为 0.5，那么损失就是；</p><p id="7833" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">损失=-(1 * log(0.5)) = 0.69314</p><p id="7dab" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">如果你的模型被正确地置信和预测为 0.9，损失将是；</p><p id="336d" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">损失=-(1 * log(0.9)) = 0.10536</p><p id="1654" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">当预测值更接近实际值时，损耗下降</p><p id="c96b" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">如果你的模型是不正确的，但也有信心和预测 0.1，损失将是；</p><p id="1105" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">损失= -(1 * log(0.1)) =2.30258</p><p id="11da" class="jq jr lu js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">损失变得更加严重</p></blockquote><p id="a821" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在处理对数损失函数时，与其自信地错了，不如怀疑自己的预测。这是我对我的模型的疏忽。我假设当我的模型自信地预测时，它总是正确的。如果它得到了一些错误的图像，它必须预测在 0.5 左右。我完全忽略了我的模型自信地错误预测的情况。</p></div></div>    
</body>
</html>