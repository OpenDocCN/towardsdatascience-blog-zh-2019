<html>
<head>
<title>A simple and fast deterministic algorithm for the minimum k-way cut problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最小 k 路切割问题的简单快速确定性算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-and-fast-deterministic-algorithm-for-the-minimum-k-way-cut-74d7ee2a521a?source=collection_archive---------4-----------------------#2019-03-01">https://towardsdatascience.com/a-simple-and-fast-deterministic-algorithm-for-the-minimum-k-way-cut-74d7ee2a521a?source=collection_archive---------4-----------------------#2019-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="496d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用一个例子逐步解释 m .托鲁普的“通过确定性贪婪树包装的最小 k 路切割”中的算法。</p><h1 id="386a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">最小<em class="lm"> k 向切割</em></h1><p id="972e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">设<em class="ls"> G= </em> ( <em class="ls"> V，E，c: E →R+ </em> ) <em class="ls"> </em>是一个有容量限制的图，其中<em class="ls"> |V|=n </em>个节点，<em class="ls"> |E|=m </em>个边。一个<em class="ls"> k </em>路切割是将节点划分成<em class="ls"> k </em>组。切割边是连接不同组中的节点的边。最小<em class="ls"> k </em>路切割问题的目标是找到最小化切割边总容量的<em class="ls"> k </em>路切割。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/77fe03d2b8baaf98f01a33472ae95865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVurPzSebtPR-29sEwXokw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">In the left, a capacitated graph. In the right, a minimum 3<em class="lm">-way cut. The weight of the cut is the sum of the capacities of the edges that are not in the right subgraphs, which is 52.</em></figcaption></figure><p id="48b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最小路割问题在网络出现的不同领域都有应用，例如，在社交网络中划分兴趣组。它还用于查找电信网络甚至流量网络中最弱的连接。</p><h1 id="e393" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">解决问题</h1><p id="abb8" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">如果<em class="ls"> k </em>是输入的一部分，那么为有容量限制的图寻找最小<em class="ls"> k </em>路割的问题是 NP 难的，参见[1]。在<em class="ls"> k </em>固定的情况下，问题是多项式可解的。</p><p id="2a91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">M. Thorup 在[2]中提出的算法解决了<em class="ls">soft</em>-<em class="ls">o</em>(<em class="ls">n</em>^(2<em class="ls">k</em>)<em class="ls">，</em>参见<a class="ae mj" href="https://en.wikipedia.org/w/index.php?title=Big_O_notation&amp;section=22#Extensions_to_the_Bachmann.E2.80.93Landau_notations" rel="noopener ugc nofollow" target="_blank"> soft-O wikipedia </a>。</p><h2 id="20f5" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">算法:通过确定性贪婪树包装的最小 K 路切割，由 m .托鲁普提出</h2><p id="d5b2" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">该算法建立在 m .托鲁普在[2]中提出的以下定理的基础上:</p><p id="9633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于 0 &lt;<em class="ls"> a &lt; </em> 9/10，设<em class="ls"> T </em>是一个至少有 3 个<em class="ls">m</em>(<em class="ls">k</em>/<em class="ls">a</em>)ln(<em class="ls">nmk</em>/<em class="ls">a</em>)树的贪婪树包装。然后，平均起来，<em class="ls"> T </em>的树交叉每条最小<em class="ls">k</em>-路割不到 2( <em class="ls"> k- </em> 1+2 <em class="ls"> a </em>)次。特别地，对于<em class="ls"> a </em> =1/4，每个最小<em class="ls"> k </em>道切口被<em class="ls"> T </em>中的某棵树最多穿越 2 <em class="ls"> k </em> -2 次。</p><p id="994b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到<em class="ls"> a </em> =1/4 的特殊情况，寻找最小<em class="ls"> k </em>路径切口的过程如下:</p><ul class=""><li id="66a1" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">构建贪婪树包装。</li><li id="2a7f" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">对于至少一棵树的包装，收集每个<em class="ls"> k </em>道切口不超过 2<em class="ls">k</em>2 次。</li><li id="9d26" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">从集合中选择最小的<em class="ls"> k </em>向切削，也就是最小的<em class="ls"> k </em>向切削。</li></ul><h2 id="e854" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">逐步解释</h2><p id="0805" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这个解释中，目标是找到以下容量限制图的最小 3 路截</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5f0fff0a189b9376c4593167a3bc39c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*UqliKxo7hiyMKVIBJgN_8Q.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Capacitated graph.</figcaption></figure><p id="60b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第一步:生成贪婪树包装</strong></p><p id="a4ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ls">贪婪树打包</em>是图的生成树的集合，其通过将关于利用率的最小生成树添加到集合中来构建。</p><p id="8b51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一条边的<em class="ls">利用率</em>是该边在包装的当前树中的次数与其容量的商。因此，每次将一棵树添加到包装中，这些边的利用率都会随着其容量的倒数而增加。</p><p id="394a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">贪婪树打包获得的第一个生成树如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1ab7b24cad90b57ef39a330a5dc7abed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*YD-4Fdye2At2N0flJGmkRQ.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">First nine spanning trees (left-right by row) of the greedy tree packing. Edge labels are the capacities.</figcaption></figure><p id="df4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">步骤 2:建造每一个<em class="ls"> k </em>道切口，该切口被树</strong>穿过少于 2<em class="ls">k</em>2 次</p><p id="9c40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果对于每棵树，我们得到所有没有被该树交叉超过 2 次的 k 个方向切口，则最小的 k 个方向切口必须在最终集合中。那么，如何列出给定树木的采伐量呢？现在对包装的第一棵树进行解释，并且必须对它们中的每一个进行解释。有两个步骤:</p><ul class=""><li id="25c9" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">考虑从树上切割 2 条<em class="ls"> k 条</em> -2 条边所产生的所有可能的图形。这些切割中的每一个都有 2 个<em class="ls"> k </em> -1 块。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nm"><img src="../Images/166abb2723d015ae251a66c5c5a4cdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xjku0iY4y1mf0Cekyz9Kg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Sample of cuts generated by cutting 2<em class="lm">k-2 edges from the first tree of the packing. Pieces of the first cut would be 1:</em>[0, 1, 6, 7], 2:[2, 5], 3:[3], 4:[4], 5:[8]</figcaption></figure><ul class=""><li id="f0f4" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">对于每个切割，以各种可能的方式将 2 个<em class="ls"> k </em> -1 件分成<em class="ls"> k </em>组。在这样的分组中，被分成<em class="ls"> k </em>块的节点诱导出一个<em class="ls"> k </em>路割(在不同组的节点之间没有边的原始图)，该图满足被考虑的生成树交叉不超过 2 <em class="ls"> k </em> -2 次的条件。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nn"><img src="../Images/2533a3b175f619e62e2eb44ed1ff70aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hpTY4Y3eIwIkJy-W_Q3mw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">All 3-way cuts extracted from the first cut (previous figure’s first) of the first tree.</figcaption></figure><p id="61df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的关键是，对于给定的树，删除 2 条<em class="ls"> k </em> -2 条边相当于确保我们只允许这些边穿过<em class="ls"> k </em>路切割，因为剩余的边将节点保留在一个片段中，这些节点必须属于将片段分成<em class="ls"> k </em>组的每个可能分组中的同一组。</p><p id="ee49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这 25 个作为最小<em class="ls"> k </em>路切割的候选是从贪婪树包装的第一棵树的第一次切割中提取的。必须对包装中每棵树的 2 个<em class="ls"> k </em> -2 个边缘的所有可能切割进行收集。</p><p id="41ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第三步:选择最小<em class="ls">k</em>-路切</strong></p><p id="385b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最小<em class="ls"> k </em>路切削是生成的<em class="ls"> k </em>路切削集合的最小值。</p><h2 id="2eda" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">时间复杂度</h2><p id="cc08" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">算法的时间复杂度是找到定理所有可能的<em class="ls"> k </em>路割的时间。有关更多详细信息，请查看算法参考。因此，</p><ol class=""><li id="b12e" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn no nc nd ne bi translated">贪心树包装:3 棵<em class="ls">m</em>(<em class="ls">k</em>/<em class="ls">a</em>)ln(<em class="ls">nmk</em>/<em class="ls">a</em>)=<em class="ls">soft-O</em>(<em class="ls">MK</em>)树，每棵在<em class="ls"> O(n) </em>。对于每棵树:</li><li id="ed45" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn no nc nd ne bi translated">树的 2 <em class="ls"> k </em> -2 条边的所有可能切割:<em class="ls"> Binom </em> ( <em class="ls"> n- </em> 1，2<em class="ls">k</em>-2)=<em class="ls">soft-o</em>((<em class="ls">en</em>/(2<em class="ls">k-2</em>))^)2<em class="ls">k</em>-2)可能性。对于每次切割:</li><li id="d739" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn no nc nd ne bi translated">将 2 个<em class="ls"> k </em> -1 块分割成<em class="ls"> k </em>套:最多<em class="ls">k</em>^(2<em class="ls">k</em>-1)/<em class="ls">k</em>！= <em class="ls">软-o</em>((<em class="ls">ek</em>)^(<em class="ls">k</em>-1))不同的方式。</li></ol><p id="6ef3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个分区可以在固定的时间内生成分区，因此，时间复杂度变为<em class="ls">soft-o</em>(<em class="ls">n</em>^(2<em class="ls">k</em>)。</p><h1 id="6ce0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="9d4e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这篇文章中，解释了一个寻找有容量限制的图的最小<em class="ls"> k </em>路割的算法。接下来是一个例子，看看它是如何工作的，最后起草了一个简单的复杂性分析。</p><p id="66a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图形操作和数字是用 Python 的 NetworkX 包创建的，见[3]。</p><h1 id="b07e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><ol class=""><li id="268e" class="mw mx it js b jt ln jx lo kb np kf nq kj nr kn no nc nd ne bi translated">O.戈德施密特和 D. S .霍赫鲍姆。固定<em class="ls"> k </em>的<em class="ls"> k </em>割问题的多项式算法。<em class="ls">数学。操作。第 61 号决议，1994 年。</em></li><li id="ef20" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn no nc nd ne bi translated">米（meter 的缩写））托鲁普。经由确定性贪婪树包装的最小<em class="ls"> k </em>路切割。第四十届 ACM 计算理论年会会议录， 2008。</li><li id="e594" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn no nc nd ne bi translated">NetworkX，<a class="ae mj" href="https://networkx.github.io/" rel="noopener ugc nofollow" target="_blank">https://NetworkX . github . io</a>。</li></ol><h1 id="7d14" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">附录</h1><h2 id="b4f9" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">算法的 Python 代码</h2><p id="ccbe" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本附录中，有在 python 中运行算法的代码。该代码不是为最佳体验而优化的，它旨在阐明所描述的算法的定义和结构。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div></div>    
</body>
</html>