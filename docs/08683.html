<html>
<head>
<title>Beginner’s Guide to Creating the SVD Recommender System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建 SVD 推荐系统的初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beginners-guide-to-creating-an-svd-recommender-system-1fd7326d1f65?source=collection_archive---------5-----------------------#2019-11-22">https://towardsdatascience.com/beginners-guide-to-creating-an-svd-recommender-system-1fd7326d1f65?source=collection_archive---------5-----------------------#2019-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ef84f9f467fdfd4695e965bbecb95e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ztdcrkciHoT6CSYS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3483" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">序言</h1><p id="6021" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有没有登录网飞，看到他们建议你看<a class="ae kc" href="https://www.imdb.com/title/tt1454468/" rel="noopener ugc nofollow" target="_blank">重力</a>如果你昨晚看了<a class="ae kc" href="https://www.imdb.com/title/tt0816692/?ref_=nv_sr_srsg_0" rel="noopener ugc nofollow" target="_blank">星际</a>？或者在亚马逊上买了东西，看到他们向我们推荐我们可能感兴趣的产品？或者有没有想过在线广告公司是如何根据我们的浏览习惯向我们展示广告的？这一切都归结于一种叫做推荐系统的东西，它可以根据我们和其他人与产品的互动历史来预测我们可能感兴趣的东西。</p><p id="1044" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">正如我所承诺的，我们会做一个推荐系统。为了让你不要自我感觉不好，我们也会做一个很酷的。我们将使用 SVD(奇异向量分解)技术进行协同过滤；这比基本的基于内容的推荐系统高出一个档次。</p><p id="2f65" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">协同过滤捕捉志同道合的用户的潜在兴趣模式，并使用相似用户的选择和偏好来建议新项目。</em></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="04ef" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">要求</h1><p id="9998" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">所以让我们开始吧。所以我们需要的东西列在下面。如果你正在阅读这篇文章，你很可能知道并且已经拥有了这些。</p><p id="4c52" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">1.python &gt;= 2.7 <br/> 2。熊猫&gt; = 0.17 <br/> 3。numpy <br/> 4。scipy</p><p id="6a19" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于不了解的人来说，熊猫、numpy 和 scipy 是 python 包。这些将使我们的生活变得容易。您可以使用 pip 从终端或命令提示符安装它们。如果你不知道怎么做，谷歌一下。例如，下面的命令安装 pandas 包。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9d89" class="na ke iq mw b gy nb nc l nd ne">$ pip install pandas</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="ff59" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">资料组</h1><p id="fa0a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们肯定需要一个数据集来处理。我们将使用著名的 Movielens 数据集来制作我们的推荐系统。前往 http://grouplens.org/datasets/movielens/下载电影镜头 100k 数据集。</p><p id="25ba" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">该数据集包含不同用户对不同电影的大约 100，000 个评级。让我们来探索数据集。创建一个新脚本<strong class="ld ir"><em class="me">exploration . py</em></strong>并添加以下代码块。<strong class="ld ir">注意</strong>:这里我们将使用单独的脚本，但是你也可以使用一个单独的 iPython 笔记本，这要方便得多。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="25fe" class="na ke iq mw b gy nb nc l nd ne">import pandas as pd<br/>import numpy as np</span><span id="9875" class="na ke iq mw b gy nf nc l nd ne">data = pd.read_csv('movielens100k.csv')<br/>data['userId'] = data['userId'].astype('str')<br/>data['movieId'] = data['movieId'].astype('str')</span><span id="a47f" class="na ke iq mw b gy nf nc l nd ne">users = data['userId'].unique() #list of all users<br/>movies = data['movieId'].unique() #list of all movies</span><span id="0744" class="na ke iq mw b gy nf nc l nd ne">print("Number of users", len(users))<br/>print("Number of movies", len(movies))<br/>print(data.head())</span></pre><p id="0fe5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这就对了。您将看到数据集中有 718 个用户和 8915 部电影。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8173" class="na ke iq mw b gy nb nc l nd ne">Number of users 718<br/>Number of movies 8915<br/>+----+----------+-----------+----------+-------------+<br/>|    |   userId |   movieId |   rating |   timestamp |<br/>|----+----------+-----------+----------+-------------|<br/>|  0 |        1 |         1 |        5 |   847117005 |<br/>|  1 |        1 |         2 |        3 |   847642142 |<br/>|  2 |        1 |        10 |        3 |   847641896 |<br/>|  3 |        1 |        32 |        4 |   847642008 |<br/>|  4 |        1 |        34 |        4 |   847641956 |<br/>+----+----------+-----------+----------+-------------+</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="45e0" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">训练和测试分割</h1><p id="a5b2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以在数据集上使用正常的随机训练测试分割。但是既然我们有可用的时间戳，让我们做一些更好的事情。让我们创建一个新的脚本<strong class="ld ir"> <em class="me"> workspace.py </em> </strong>来完成我们所有的工作。在开头添加以下代码。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="03ac" class="na ke iq mw b gy nb nc l nd ne">import pandas as pd<br/>import numpy as np<br/>import scipy</span><span id="5242" class="na ke iq mw b gy nf nc l nd ne">data = pd.read_csv('movielens100k.csv')<br/>data['userId'] = data['userId'].astype('str')<br/>data['movieId'] = data['movieId'].astype('str')</span><span id="a5df" class="na ke iq mw b gy nf nc l nd ne">users = data['userId'].unique() #list of all users<br/>movies = data['movieId'].unique() #list of all movies</span><span id="8667" class="na ke iq mw b gy nf nc l nd ne">test = pd.DataFrame(columns=data.columns)<br/>train = pd.DataFrame(columns=data.columns)</span><span id="af8b" class="na ke iq mw b gy nf nc l nd ne">test_ratio = 0.2 #fraction of data to be used as test set.</span><span id="3dcd" class="na ke iq mw b gy nf nc l nd ne">for u in users:<br/>    temp = data[data['userId'] == u]<br/>    n = len(temp)<br/>    test_size = int(test_ratio*n)</span><span id="3496" class="na ke iq mw b gy nf nc l nd ne">temp = temp.sort_values('timestamp').reset_index()<br/>temp.drop('index', axis=1, inplace=True)<br/>    <br/>dummy_test = temp.ix[n-1-test_size :]<br/>dummy_train = temp.ix[: n-2-test_size]<br/>    <br/>test = pd.concat([test, dummy_test])<br/>train = pd.concat([train, dummy_train])</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="3f2b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这样做的目的是，根据给出这些评级时的时间戳，我们对数据进行排序，以将最近的评级保持在底部，并从底部开始从每个用户中抽取 20%的评级作为测试集。因此，我们没有随机选择，而是将最近的评分作为测试集。从推荐者的目标是基于类似产品的历史评级来对未来未遇到的产品进行评级的意义上来说，这更合乎逻辑。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="f8c7" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">效用矩阵</h1><p id="fa8a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当前形式的数据集对我们没有用。为了将数据用于推荐引擎，我们需要将数据集转换成一种叫做效用矩阵的形式。我们在新的脚本中创建一个函数<code class="fe ng nh ni mw b"><strong class="ld ir">create_utility_matrix</strong></code>。将其命名为<strong class="ld ir"> <em class="me"> recsys.py </em> </strong>。我们将使用这个脚本中的函数来处理我们的训练和测试集。</p><p id="8a3c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">作为一个参数，我们传递一个字典，该字典存储我们也传递的数据集“数据”的每一列的键值对。从数据集中，我们将看到每个对应字段的列号或列名，键'T12 用户'' T14]的列【T6]<em class="me">userId</em>或列<strong class="ld ir"> 0 </strong>，列<strong class="ld ir"> <em class="me"> movieId </em> </strong>或键<strong class="ld ir"> ' </strong> <em class="me">项'</em>和列<strong class="ld ir"> <em class="me"/></strong></p><p id="c158" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">效用矩阵只不过是一个 2D 矩阵，其中一个轴属于用户，另一个轴属于项目(在这种情况下是电影)。所以矩阵的<strong class="ld ir"> <em class="me"> (i，j) </em> </strong>位置的值将是用户<strong class="ld ir"> <em class="me"> i </em> </strong>给电影<strong class="ld ir"> <em class="me"> j </em> </strong>的评分。</p><p id="3ffd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们举一个例子来更清楚一点。假设我们有 5 个评级的数据集。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="82b5" class="na ke iq mw b gy nb nc l nd ne">+----+----------+-----------+----------+<br/>|    |   userId |   movieId |   rating |<br/>|----+----------+-----------+----------+<br/>|  0 |      mark|     movie1|        5 |<br/>|  1 |      lucy|     movie2|        2 |<br/>|  2 |      mark|     movie3|        3 |<br/>|  3 |     shane|     movie2|        1 |<br/>|  4 |      lisa|     movie3|        4 |<br/>+----+----------+-----------+----------+</span></pre><p id="c15e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果我们通过下面描述的<code class="fe ng nh ni mw b"><strong class="ld ir">create_utility_matrix</strong></code>函数传递这个数据集，它将返回一个这样的效用矩阵，以及 user_index 和 item_index 的辅助字典，如下所示。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2c38" class="na ke iq mw b gy nb nc l nd ne">+----+----+----+<br/>| 5  | nan| 3  |   # user_index = {mark: 0, lucy:1, shane:2, lisa:3}<br/>+----+----+----+   # item_index = {movie1:0, movie2: 1, movie3:2}<br/>| nan| 2  | nan|<br/>+----+----+----+<br/>| nan| 1  | nan|   # The nan values are for user-item combinations<br/>+----+----+----+   # where the ratings are unavailable.<br/>| nan| nan| 4  |<br/>+----+----+----+</span></pre><p id="34da" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在来看看功能。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="dda4" class="na ke iq mw b gy nb nc l nd ne">import numpy as np<br/>import pandas as pd<br/>from scipy.linalg import sqrtm</span><span id="dbf3" class="na ke iq mw b gy nf nc l nd ne">def <strong class="mw ir">create_utility_matrix</strong>(data, formatizer = {'user':0, 'item': 1, 'value': 2}):</span><span id="6f9c" class="na ke iq mw b gy nf nc l nd ne">    """<br/>        :param data:      Array-like, 2D, nx3<br/>        :param formatizer:pass the formatizer<br/>        :return:          utility matrix (n x m), n=users, m=items<br/>    """<br/>        <br/>    itemField = formatizer['item']<br/>    userField = formatizer['user']<br/>    valueField = formatizer['value']</span><span id="8212" class="na ke iq mw b gy nf nc l nd ne">    userList = data.ix[:,userField].tolist()<br/>    itemList = data.ix[:,itemField].tolist()<br/>    valueList = data.ix[:,valueField].tolist()</span><span id="95c2" class="na ke iq mw b gy nf nc l nd ne">    users = list(set(data.ix[:,userField]))<br/>    items = list(set(data.ix[:,itemField]))</span><span id="8853" class="na ke iq mw b gy nf nc l nd ne">    users_index = {users[i]: i for i in range(len(users))}</span><span id="d5fc" class="na ke iq mw b gy nf nc l nd ne">    pd_dict = {item: [np.nan for i in range(len(users))] for item in items}</span><span id="13a5" class="na ke iq mw b gy nf nc l nd ne">    for i in range(0,len(data)):<br/>        item = itemList[i]<br/>        user = userList[i]<br/>        value = valueList[i]</span><span id="3ebf" class="na ke iq mw b gy nf nc l nd ne">    pd_dict[item][users_index[user]] = value</span><span id="797b" class="na ke iq mw b gy nf nc l nd ne">    X = pd.DataFrame(pd_dict)<br/>    X.index = users<br/>        <br/>    itemcols = list(X.columns)<br/>    items_index = {itemcols[i]: i for i in range(len(itemcols))}<br/></span><span id="cc62" class="na ke iq mw b gy nf nc l nd ne">    # users_index gives us a mapping of user_id to index of user<br/>    # items_index provides the same for items</span><span id="1f61" class="na ke iq mw b gy nf nc l nd ne">    return X, users_index, items_index</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="bc5e" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">奇异值分解计算</h1><p id="0dd8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">SVD 是<em class="me">奇异向量分解。</em>它所做的是将一个矩阵分解成对应于每行和每列的特征向量的组成数组。我们再给<strong class="ld ir"> <em class="me"> recsys.py </em> </strong>添加一个函数。它将从“<em class="me"> create_utility_matrix </em>和参数“<em class="me"> k </em>”获取输出，该参数是每个用户和电影将被分解成的特征的数量。</p><p id="3ad3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">奇异值分解技术是由 Brandyn Webb 引入推荐系统领域的，在 Netflix 奖挑战赛期间，Brandyn Webb 以<strong class="ld ir"> <em class="me">【西蒙·芬克】</em> </strong>而闻名。这里我们不做 Funk 的 SVD 迭代版本，而是使用 numpy 的 SVD 实现所提供的任何东西。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e6bd" class="na ke iq mw b gy nb nc l nd ne">def <strong class="mw ir">svd</strong>(train, k):<br/>    utilMat = np.array(train)</span><span id="a149" class="na ke iq mw b gy nf nc l nd ne">    # the nan or unavailable entries are masked<br/>    mask = np.isnan(utilMat)<br/>    masked_arr = np.ma.masked_array(utilMat, mask)<br/>    item_means = np.mean(masked_arr, axis=0)</span><span id="21f5" class="na ke iq mw b gy nf nc l nd ne">    # nan entries will replaced by the average rating for each item<br/>    utilMat = masked_arr.filled(item_means)</span><span id="d2a8" class="na ke iq mw b gy nf nc l nd ne">    x = np.tile(item_means, (utilMat.shape[0],1))</span><span id="7185" class="na ke iq mw b gy nf nc l nd ne">    # we remove the per item average from all entries.<br/>    # the above mentioned nan entries will be essentially zero now<br/>    utilMat = utilMat - x</span><span id="5322" class="na ke iq mw b gy nf nc l nd ne">    # The magic happens here. U and V are user and item features<br/>    U, s, V=np.linalg.svd(utilMat, full_matrices=False)<br/>    s=np.diag(s)</span><span id="ddf9" class="na ke iq mw b gy nf nc l nd ne">    # we take only the k most significant features<br/>    s=s[0:k,0:k]<br/>    U=U[:,0:k]<br/>    V=V[0:k,:]</span><span id="56cb" class="na ke iq mw b gy nf nc l nd ne">    s_root=sqrtm(s)</span><span id="4eff" class="na ke iq mw b gy nf nc l nd ne">    Usk=np.dot(U,s_root)<br/>    skV=np.dot(s_root,V)<br/>    UsV = np.dot(Usk, skV)</span><span id="1308" class="na ke iq mw b gy nf nc l nd ne">    UsV = UsV + x</span><span id="3db3" class="na ke iq mw b gy nf nc l nd ne">    print("svd done")<br/>    return UsV</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="595f" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">将它们结合在一起</h1><p id="e66c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">回到<strong class="ld ir"> <em class="me"> workspace.py </em> </strong>我们将使用上面的函数。我们将找出使用真实评级的测试集的预测评级的均方根误差。除了创建一个函数，我们还将创建一个列表来保存不同数量的特性，这将有助于我们将来进行分析。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f807" class="na ke iq mw b gy nb nc l nd ne">from recsys import svd, create_utility_matrix</span><span id="2905" class="na ke iq mw b gy nf nc l nd ne">def <strong class="mw ir">rmse</strong>(true, pred):<br/>    # this will be used towards the end<br/>    x = true - pred<br/>    return sum([xi*xi for xi in x])/len(x)</span><span id="fc8c" class="na ke iq mw b gy nf nc l nd ne"># to test the performance over a different number of features<br/>no_of_features = [8,10,12,14,17]</span><span id="975b" class="na ke iq mw b gy nf nc l nd ne">utilMat, users_index, items_index = create_utility_matrix(train)</span><span id="381a" class="na ke iq mw b gy nf nc l nd ne">for f in no_of_features: <br/>    svdout = svd(utilMat, k=f)<br/>    pred = [] #to store the predicted ratings</span><span id="9be6" class="na ke iq mw b gy nf nc l nd ne">    for _,row in test.iterrows():<br/>        user = row['userId']<br/>        item = row['movieId']</span><span id="a8cd" class="na ke iq mw b gy nf nc l nd ne">        u_index = users_index[user]<br/>        if item in items_index:<br/>            i_index = items_index[item]<br/>            pred_rating = svdout[u_index, i_index]<br/>        else:<br/>            pred_rating = np.mean(svdout[u_index, :])<br/>        pred.append(pred_rating)</span><span id="fa03" class="na ke iq mw b gy nf nc l nd ne">print(rmse(test['rating'], pred))</span></pre><p id="e6d5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于<em class="me"> test_size = 0.2 </em>，RMSE 分数大约为 0.96</p><p id="3f8b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于 100k 的电影来说，这是一个适中的分数。稍微调整一下，你也许能超过 0.945。但这取决于你。</p><p id="8e79" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你喜欢这篇文章，请告诉我！这里有三个链接供你参考:</p><ol class=""><li id="0dc1" class="nj nk iq ld b le lz li ma lm nl lq nm lu nn ly no np nq nr bi translated"><a class="ae kc" href="https://github.com/mayukh18/reco" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="me"/></strong></a><em class="me">(SVD 的完整代码以及其他著名 RecSys 算法的实现)</em></li><li id="b238" class="nj nk iq ld b le ns li nt lm nu lq nv lu nw ly no np nq nr bi translated"><a class="ae kc" href="https://paperswithcode.com/sota/collaborative-filtering-on-movielens-100k" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="me">https://papers with code . com/sota/collaborative-filtering-on-movie lens-100k</em></strong></a><em class="me">(关于 Movielens100k 的最新成果。这些在官方测试集上得到验证)</em></li><li id="9269" class="nj nk iq ld b le ns li nt lm nu lq nv lu nw ly no np nq nr bi translated"><a class="ae kc" href="https://sifter.org/~simon/journal/20061211.html" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="me">https://sifter.org/~simon/journal/20061211.html</em></strong></a><em class="me">(西蒙·芬克最著名的博客详述了他的奇异值分解方法)</em></li></ol></div></div>    
</body>
</html>