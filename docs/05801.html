<html>
<head>
<title>A/B Testing Design &amp; Execution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">A/B 测试设计和执行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-b-testing-design-execution-6cf9e27c6559?source=collection_archive---------4-----------------------#2019-08-24">https://towardsdatascience.com/a-b-testing-design-execution-6cf9e27c6559?source=collection_archive---------4-----------------------#2019-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f4d3487a2011968d5000de079e56b123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8VSCoNbBoqQCF1Z2S48QQ.jpeg"/></div></div></figure><h2 id="d434" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/data-driven-growth" rel="noopener" target="_blank">使用 Python 实现数据驱动的增长</a></h2><div class=""/><div class=""><h2 id="8e20" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">如何以编程方式进行 A/B 测试</h2></div><p id="f2ff" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这一系列文章旨在解释如何以一种简单的方式使用 Python，通过将预测方法应用于您的所有行动来推动您公司的发展。它将是编程、数据分析和机器学习的结合。</p><p id="88d2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我将在以下九篇文章中讨论所有主题:</p><p id="fc17" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">1- <a class="ae ly" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-1-know-your-metrics-812781e66a5b">了解你的衡量标准</a></p><p id="6f26" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">2- <a class="ae ly" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-2-customer-segmentation-5c019d150444">客户细分</a></p><p id="4c47" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">3- <a class="ae ly" rel="noopener" target="_blank" href="/data-driven-growth-with-python-part-3-customer-lifetime-value-prediction-6017802f2e0f">客户终身价值预测</a></p><p id="34c7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">4- <a class="ae ly" rel="noopener" target="_blank" href="/churn-prediction-3a4a36c2129a">流失预测</a></p><p id="07f1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/predicting-next-purchase-day-15fae5548027"> 5-预测下一个购买日</a></p><p id="c028" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/predicting-sales-611cb5a252de"> 6-预测销售额</a></p><p id="57a8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/market-response-models-baf9f9913298"> 7-市场反应模型</a></p><p id="65de" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ae ly" rel="noopener" target="_blank" href="/uplift-modeling-e38f96b1ef60"> 8-隆起建模</a></p><p id="fddb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo"> 9- A/B 测试设计和执行</strong></p><p id="706e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">文章有自己的代码片段，使您可以轻松地应用它们。如果你是编程的超级新手，你可以在这里很好地介绍一下<a class="ae ly" href="https://www.kaggle.com/learn/python" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae ly" href="https://www.kaggle.com/learn/pandas" rel="noopener ugc nofollow" target="_blank"> Pandas </a>(一个我们将在任何事情上使用的著名库)。但是仍然没有编码介绍，您可以学习概念，如何使用您的数据并开始从中产生价值:</p><blockquote class="lz"><p id="6af7" class="ma mb je bd mc md me mf mg mh mi lx dk translated">有时候你必须先跑，然后才能走——托尼·斯塔克</p></blockquote><p id="045d" class="pw-post-body-paragraph lc ld je le b lf mj ko lh li mk kr lk ll ml ln lo lp mm lr ls lt mn lv lw lx im bi translated">作为先决条件，确保你的电脑上安装了 J <a class="ae ly" href="https://jupyter.readthedocs.io/en/latest/install.html" rel="noopener ugc nofollow" target="_blank"> upyter Notebook </a>和 P <a class="ae ly" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> ython </a>。代码片段只能在 Jupyter 笔记本上运行。</p><p id="e732" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好吧，我们开始吧。</p><h1 id="7297" class="mo mp je bd mq mr ms mt mu mv mw mx my kt mz ku na kw nb kx nc kz nd la ne nf bi translated">第 9 部分:A/B 测试设计和执行</h1><p id="6a12" class="pw-post-body-paragraph lc ld je le b lf ng ko lh li nh kr lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">作为一名(数据驱动的)增长黑客，主要职责之一是试验新的想法和维持持续的学习。实验是测试你的机器学习模型、新动作和改进现有动作的好方法。我们举个例子:</p><p id="604c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你有一个准确率高达 95%的客户流失模型。通过给可能流失的客户打电话，给他们一个有吸引力的报价，你假设他们中的 10%会留下来，每个人每月带来 20 美元。</p><p id="42a7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">假设太多了。分解一下:</p><ul class=""><li id="523e" class="nl nm je le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated">该模型的准确率为 95%。真的吗？您已经根据上个月的数据训练了您的模型。接下来的一个月，会有新用户，新产品功能，营销&amp;品牌活动，季节性等等。在这种情况下，历史准确性和实际准确性很难匹配。不经过测试是无法得出结论的。</li><li id="4846" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">通过查看之前活动的结果，您假设有 10%的转化率。并不能保证你的新动作会因为上述因素而有 10%的转化。此外，由于这是一个新的群体，他们的反应在一定程度上是不可预测的。</li><li id="ee12" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">最后，如果这些客户今天每月带来 20 美元，这并不意味着他们会在你采取新行动后带来同样的收入。</li></ul><p id="1fbf" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了了解将会发生什么，我们需要进行 A/B 测试。在本文中，我们将关注如何以编程方式执行测试，并报告测试背后的统计数据。在开始编码之前，有两个要点需要你在设计和 A/B 测试时考虑。</p><p id="cfa7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">1-你的假设是什么？</p><p id="25a6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">继续上面的例子，我们的假设是，测试组将有更多的保留:</p><p id="45d3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo">A 组→报价→更高留存</strong></p><p id="4298" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo">B 组→无报价→低留成</strong></p><p id="2a3e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这也有助于我们测试模型的准确性。如果 B 组的留存率是 50%，显然说明我们的模式不行了。这同样适用于衡量来自这些用户的收入。</p><p id="7534" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">2-你的成功标准是什么？</p><p id="12d6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在这种情况下，我们将检查两组的保留率。</p><h2 id="8915" class="nz mp je bd mq oa ob dn mu oc od dp my ll oe of na lp og oh nc lt oi oj ne jk bi translated">程序性 A/B 测试</h2><p id="f8ab" class="pw-post-body-paragraph lc ld je le b lf ng ko lh li nh kr lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">对于这个编码示例，我们将使用 numpy 库创建我们自己的数据集，并评估 A/B 测试的结果。</p><p id="3d41" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们从导入必要的库开始:</p><figure class="ok ol om on gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4e93" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在，我们将创建自己的数据集。数据集将包含以下各列:</p><ul class=""><li id="666a" class="nl nm je le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated"><strong class="le jo">客户标识:</strong><strong class="le jo"/>客户的唯一标识</li><li id="20cf" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><strong class="le jo">细分市场:</strong>客户的细分市场；高价值还是低价值</li><li id="c75d" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><strong class="le jo">组:</strong>表示<strong class="le jo"> </strong>客户是在测试组还是对照组</li><li id="a013" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><strong class="le jo"> purchase_count </strong>:客户完成购买的数量</li></ul><p id="67b5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">前三个很简单:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="57a3" class="nz mp je or b gy ov ow l ox oy">df_hv = pd.DataFrame()<br/>df_hv['customer_id'] = np.array([count for count in range(20000)])<br/>df_hv['segment'] = np.array(['high-value' for _ in range(20000)])<br/>df_hv['group'] = 'control'<br/>df_hv.loc[df_hv.index&lt;10000,'group'] = 'test'</span></pre><p id="06c1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">理想情况下，采购数量应该是泊松分布。将会有没有购买的客户，而购买次数高的客户将会减少。让我们使用<strong class="le jo"> numpy.random.poisson() </strong>来完成这项工作，并为测试组和对照组分配不同的分布:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="f9d0" class="nz mp je or b gy ov ow l ox oy">df_hv.loc[df_hv.group == 'test', 'purchase_count'] = np.random.poisson(0.6, 10000)<br/>df_hv.loc[df_hv.group == 'control', 'purchase_count'] = np.random.poisson(0.5, 10000)</span></pre><p id="cd0a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们来看看我们的数据集:</p><div class="ok ol om on gt ab cb"><figure class="oz iv pa pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/1908f239ed9257721a40ffedb572ac53.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*Yj53d1S_EAB87DatvPzyvg.png"/></div></figure><figure class="oz iv pf pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/43a728a739a7935f8f3750f62725218c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*kYtq-fQ4IOV8KFAJV8w1pA.png"/></div></figure></div><p id="26e5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">太棒了。我们有一切来评估我们的 A/B 测试。假设我们向 50%的高价值用户提供服务，并观察他们在给定时间内的购买行为。检查密度的最佳可视化方法是:</p><figure class="ok ol om on gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="08e9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">输出:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/da1378aedbd97fd53670cc64721c70b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RI_rCr-n8rk2rx22sYC7BQ.png"/></div></div></figure><p id="da75" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">结果看起来很不错。测试组的购买密度从 1 开始比较好。但是我们怎么能肯定地说这个实验是成功的并且这种差异不是由于其他因素而发生的呢？</p><p id="3a85" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">要回答这个问题，我们需要检查测试组的上升是否具有统计学意义。<strong class="le jo"> scipy </strong>库允许我们以编程方式检查这一点:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="3f05" class="nz mp je or b gy ov ow l ox oy">from scipy import stats <br/>test_result = stats.ttest_ind(test_results, control_results)<br/>print(test_result)</span></pre><p id="c72e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">输出:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/976696c65f81aa14b1684776d024aa50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvaFyoUX7-RmO-m3W-uRQw.png"/></div></div></figure><p id="727f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jo"> ttest_ind() </strong>方法返回两个输出:</p><ul class=""><li id="05e2" class="nl nm je le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated"><strong class="le jo">t-统计:</strong>代表测试组和对照组的平均值之间的差异，单位为标准误差。更高的 t 统计值意味着更大的差异，支持我们的假设。</li><li id="396e" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><strong class="le jo"> p 值:</strong>测量零假设为真的概率。</li></ul><p id="39f4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Ops，什么是<strong class="le jo">零假设？</strong></p><p id="fb52" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果零假设为真，这意味着测试组和对照组之间没有显著差异。所以 p 值越低意味着越好。作为行业标准，我们接受<strong class="le jo"> p 值&lt; 5% </strong>使得结果具有统计显著性(但这取决于你的商业逻辑，也有人们用 10%甚至 1%的情况)。</p><p id="3a83" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了了解我们的测试是否具有统计显著性，让我们构建一个函数并应用于我们的数据集:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="4fb4" class="nz mp je or b gy ov ow l ox oy">def eval_test(test_results,control_results):<br/>    test_result = stats.ttest_ind(test_results, control_results)<br/>    if test_result[1] &lt; 0.05:<br/>        print('result is significant')<br/>    else:<br/>        print('result is not significant')</span></pre><p id="f232" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果我们将此应用于数据集:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/453e711471c6c73068f3cbc731cdb9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iToV0Pr5YS1H9MvF8AQAGw.png"/></div></div></figure><p id="90be" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">看起来很棒，但不幸的是，事情没那么简单。如果您选择一个有偏见的测试组，默认情况下，您的结果将具有统计学意义。举个例子，如果我们把更多的高价值顾客分配到测试组，把更多的低价值顾客分配到控制组，那么我们的实验从一开始就是失败的。这就是为什么选择小组是健康 A/B 测试的关键。</p><h2 id="98ae" class="nz mp je bd mq oa ob dn mu oc od dp my ll oe of na lp og oh nc lt oi oj ne jk bi translated"><strong class="ak">选择试验&amp;对照组</strong></h2><p id="8b34" class="pw-post-body-paragraph lc ld je le b lf ng ko lh li nh kr lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">选择测试和控制组最常见的方法是<strong class="le jo">随机抽样</strong>。让我们看看如何通过编程来实现它。我们将首先从创建数据集开始。在这个版本中，它将拥有 2 万个高价值客户和 8 万个低价值客户:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="c119" class="nz mp je or b gy ov ow l ox oy">#create hv segment<br/>df_hv = pd.DataFrame()<br/>df_hv['customer_id'] = np.array([count for count in range(20000)])<br/>df_hv['segment'] = np.array(['high-value' for _ in range(20000)])<br/>df_hv['prev_purchase_count'] = np.random.poisson(0.9, 20000)</span><span id="7299" class="nz mp je or b gy pj ow l ox oy">df_lv = pd.DataFrame()<br/>df_lv['customer_id'] = np.array([count for count in range(20000,100000)])<br/>df_lv['segment'] = np.array(['low-value' for _ in range(80000)])<br/>df_lv['prev_purchase_count'] = np.random.poisson(0.3, 80000)</span><span id="48dc" class="nz mp je or b gy pj ow l ox oy">df_customers = pd.concat([df_hv,df_lv],axis=0)</span></pre><div class="ok ol om on gt ab cb"><figure class="oz iv pk pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/82c71aa1f84a2d2cbc6a14fb610ab80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*mCCy7vYQPNX1vtz25imqxw.png"/></div></figure><figure class="oz iv pl pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/8ab82983d1e203ee1b2b30262e5eac91.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*KZk8PKVH92Lm5z6Xz4oTmA.png"/></div></figure></div><p id="0a9f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过使用 pandas 的<strong class="le jo"> sample() </strong>函数，我们可以选择我们的测试组。假设我们有 90%的测试组和 10%的对照组:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="fce9" class="nz mp je or b gy ov ow l ox oy">df_test = df_customers.sample(frac=0.9)<br/>df_control = df_customers[~df_customers.customer_id.isin(df_test.customer_id)]</span></pre><p id="0965" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在这个例子中，我们提取了整个组的 90%，并将其标记为<em class="pm">测试</em>。但是有一个小问题会毁了我们的实验。如果数据集中有明显不同的多个组(在本例中，高值&amp;低值)，最好分别进行随机采样。否则，我们不能保证试验组和对照组的高值和低值的比率是相同的。</p><p id="a54d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了确保正确创建测试和控制组，我们需要应用以下代码:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="bc60" class="nz mp je or b gy ov ow l ox oy">df_test_hv = df_customers[df_customers.segment == 'high-value'].sample(frac=0.9)<br/>df_test_lv = df_customers[df_customers.segment == 'low-value'].sample(frac=0.9)</span><span id="01a8" class="nz mp je or b gy pj ow l ox oy">df_test = pd.concat([df_test_hv,df_test_lv],axis=0)<br/>df_control = df_customers[~df_customers.customer_id.isin(df_test.customer_id)]</span></pre><p id="c83d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这使得分配对两者都是正确的:</p><div class="ok ol om on gt ab cb"><figure class="oz iv pn pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/bb5b067071ab8c8e26c3f7a451b2472e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*tiXgGbc5CKkQ0xR7V1PjGA.png"/></div></figure><figure class="oz iv po pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/0fe88eb32a988dcf8e9de4d67c2d0c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*AvemcffbO3hLLKgyLfcFyA.png"/></div></figure></div><p id="00bc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们已经探讨了如何进行<strong class="le jo"> t 检验</strong>以及选择测试组和对照组。但是如果我们像上面一样在多组上做 A/B/C 测试或者 A/B 测试呢？是时候引入方差分析测试了。</p><h2 id="16f7" class="nz mp je bd mq oa ob dn mu oc od dp my ll oe of na lp og oh nc lt oi oj ne jk bi translated"><strong class="ak">单因素方差分析</strong></h2><p id="c36b" class="pw-post-body-paragraph lc ld je le b lf ng ko lh li nh kr lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">让我们假设我们在相同的组中测试 2 个以上的变体(例如，对低价值高价值客户的 2 个不同的报价和无报价)。然后我们需要应用单因素方差分析来评估我们的实验。让我们从创建数据集开始:</p><figure class="ok ol om on gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3b8a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">输出:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pp"><img src="../Images/e45c83d80b1280fd27e5e2de39793629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvD67C-f110DIUf8_Y7Stg.png"/></div></div></figure><p id="5ac7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了评估结果，我们将应用以下函数:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="f2cf" class="nz mp je or b gy ov ow l ox oy">def one_anova_test(a_stats,b_stats,c_stats):<br/>    test_result = stats.f_oneway(a_stats, b_stats, c_stats)<br/>    if test_result[1] &lt; 0.05:<br/>        print('result is significant')<br/>    else:<br/>        print('result is not significant')</span></pre><p id="16b5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">逻辑类似于 t_test。如果 p 值低于 5%，我们的测试变得有意义:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pq"><img src="../Images/faf202f30fb99518124d770b4877e25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8td8umFeO7a4u6XanBA0w.png"/></div></div></figure><p id="b0cd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们看看如果两组之间没有差异，谁会是这个样子:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="be64" class="nz mp je or b gy ov ow l ox oy">df_hv.loc[df_hv.group == 'A', 'purchase_count'] = np.random.poisson(0.5, 10000)<br/>df_hv.loc[df_hv.group == 'B', 'purchase_count'] = np.random.poisson(0.5, 10000)<br/>df_hv.loc[df_hv.group == 'C', 'purchase_count'] = np.random.poisson(0.5, 10000)</span><span id="2212" class="nz mp je or b gy pj ow l ox oy">a_stats = df_hv[df_hv.group=='A'].purchase_count<br/>b_stats = df_hv[df_hv.group=='B'].purchase_count<br/>c_stats = df_hv[df_hv.group=='C'].purchase_count</span><span id="aea5" class="nz mp je or b gy pj ow l ox oy">hist_data = [a_stats, b_stats, c_stats]</span><span id="eccc" class="nz mp je or b gy pj ow l ox oy">group_labels = ['A', 'B','C']</span><span id="5314" class="nz mp je or b gy pj ow l ox oy"># Create distplot with curve_type set to 'normal'<br/>fig = ff.create_distplot(hist_data, group_labels, bin_size=.5,<br/>                         curve_type='normal',show_rug=False)</span><span id="1dff" class="nz mp je or b gy pj ow l ox oy">fig.layout = go.Layout(<br/>        title='Test vs Control Stats',<br/>        plot_bgcolor  = 'rgb(243,243,243)',<br/>        paper_bgcolor  = 'rgb(243,243,243)',<br/>    )</span><span id="baca" class="nz mp je or b gy pj ow l ox oy"># Plot!<br/>pyoff.iplot(fig)</span></pre><p id="bce8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">输出和测试结果:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pr"><img src="../Images/87a58cf5547855cea63dfd3c7cf42cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1873Sls_CNCG4KFCtabFw.png"/></div></div></figure><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ps"><img src="../Images/bf17c353416c6108cd08fba013c4b4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llcGcHNr20a4o1IfGezoLA.png"/></div></div></figure><p id="434a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果我们想知道 A 和 B 或者 C 之间是否有区别，我们可以应用我上面解释的 t_test。</p><h2 id="7e20" class="nz mp je bd mq oa ob dn mu oc od dp my ll oe of na lp og oh nc lt oi oj ne jk bi translated">双向方差分析</h2><p id="6563" class="pw-post-body-paragraph lc ld je le b lf ng ko lh li nh kr lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">假设我们正在对高价值和低价值客户进行相同的测试。在这种情况下，我们需要应用双向方差分析。我们将再次创建数据集，并构建我们的评估方法:</p><figure class="ok ol om on gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="18d3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">双向方差分析需要建立如下模型:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="81b2" class="nz mp je or b gy ov ow l ox oy">import statsmodels.formula.api as smf <br/>from statsmodels.stats.anova import anova_lm<br/>model = smf.ols(formula='purchase_count ~ segment + group ', data=df_customers).fit()<br/>aov_table = anova_lm(model, typ=2)</span></pre><p id="17af" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过使用<strong class="le jo">段</strong> &amp; <strong class="le jo">组，</strong>模型试图达到<strong class="le jo">购买 _ 计数。上面的 aov_table </strong>帮助我们了解我们的实验是否成功:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pt"><img src="../Images/e4c5ef0953601e8104fa596a75ee4c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kMPJknUMPD09wL0TCjQ5w.png"/></div></div></figure><p id="078c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最后一列代表结果，向我们展示了显著的差异。如果不是，它将如下所示:</p><figure class="ok ol om on gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pu"><img src="../Images/937af94047383453ccd16874c7f23760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUUDLkztF7GhD4R_oJFb2A.png"/></div></div></figure><p id="6203" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">由此可见，<strong class="le jo">段</strong>(高价值或低价值)显著影响采购数量，但<strong class="le jo">组</strong>不影响，因为它几乎是 66%，远高于 5%。</p><p id="edae" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在我们知道如何选择我们的小组并评估结果。但是还有一个缺失的部分。为了达到统计显著性，我们的样本量应该足够了。让我们看看如何计算它。</p><h2 id="d669" class="nz mp je bd mq oa ob dn mu oc od dp my ll oe of na lp og oh nc lt oi oj ne jk bi translated">样本量计算</h2><p id="b4d9" class="pw-post-body-paragraph lc ld je le b lf ng ko lh li nh kr lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">为了计算所需的样本量，首先我们需要理解两个概念:</p><ul class=""><li id="fe22" class="nl nm je le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated"><strong class="le jo">效应大小</strong>:代表试验组和对照组平均值之间的差异大小。它是测试组和对照组之间平均值的方差除以对照组的标准偏差。</li><li id="9437" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><strong class="le jo">功效:</strong>这是指在你的测试中找到一个统计意义的概率。为了计算样本大小，0.8 是常用的值。</li></ul><p id="d833" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们构建数据集，并在一个示例中查看样本大小的计算:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="6408" class="nz mp je or b gy ov ow l ox oy">from statsmodels.stats import power<br/>ss_analysis = power.TTestIndPower()</span><span id="4a98" class="nz mp je or b gy pj ow l ox oy">#create hv segment<br/>df_hv = pd.DataFrame()<br/>df_hv['customer_id'] = np.array([count for count in range(20000)])<br/>df_hv['segment'] = np.array(['high-value' for _ in range(20000)])<br/>df_hv['prev_purchase_count'] = np.random.poisson(0.7, 20000)</span><span id="a75d" class="nz mp je or b gy pj ow l ox oy">purchase_mean = df_hv.prev_purchase_count.mean()<br/>purchase_std = df_hv.prev_purchase_count.std()</span></pre><p id="ebfd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在本例中，购买的平均值(purchase_mean)为 0.7，标准差(purchase_std)为 0.84。</p><p id="cb17" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">假设我们想在这个实验中将 purchase_mean 增加到 0.75。我们可以如下计算效果大小:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="c8ff" class="nz mp je or b gy ov ow l ox oy">effect_size = (0.75 - purchase_mean)/purchase_std</span></pre><p id="1a72" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">之后，样本量的计算就相当简单了:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="6fde" class="nz mp je or b gy ov ow l ox oy">alpha = 0.05<br/>power = 0.8<br/>ratio = 1</span><span id="7f52" class="nz mp je or b gy pj ow l ox oy">ss_result = ss_analysis.solve_power(effect_size=effect_size, power=power,alpha=alpha, ratio=ratio , nobs1=None) <br/>print(ss_result)</span></pre><p id="2c6e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">α是统计显著性的阈值(5%)，我们的测试和控制样本大小的比率是 1(相等)。因此，我们需要的样本大小是(ss_result 的输出)<strong class="le jo"> 4868。</strong></p><p id="5e66" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们构建一个函数，在任何我们想要的地方使用它:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="ce8f" class="nz mp je or b gy ov ow l ox oy">def calculate_sample_size(c_data, column_name, target,ratio):<br/>    value_mean = c_data[column_name].mean()<br/>    value_std = c_data[column_name].std()<br/>    <br/>    value_target = value_mean * target<br/>    <br/>    effect_size = (value_target - value_mean)/value_std<br/>    <br/>    power = 0.8<br/>    alpha = 0.05<br/>    ss_result = ss_analysis.solve_power(effect_size=effect_size, power=power,alpha=alpha, ratio=ratio , nobs1=None) <br/>    print(int(ss_result))</span></pre><p id="d7b7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于这个函数，我们需要提供我们的数据集、表示值的 column_name(在我们的例子中是 purchase_count)、我们的目标平均值(在前面的例子中 0.75 是我们的目标)和比率。</p><p id="add7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在上面的数据集中，假设我们希望将购买计数平均值提高 5%，并且我们将保持两组的规模相同:</p><pre class="ok ol om on gt oq or os ot aw ou bi"><span id="ead5" class="nz mp je or b gy ov ow l ox oy">calculate_sample_size(df_hv, 'prev_purchase_count', 1.05,1)</span></pre><p id="a124" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">那么结果就变成了<strong class="le jo"> 8961。</strong></p><p id="4117" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你可以在这里找到这篇文章<a class="ae ly" href="https://gist.github.com/karamanbk/b90315dfee3625e84a6cf10c70592d68" rel="noopener ugc nofollow" target="_blank">的 Jupyter 笔记本。</a></p><p id="5f72" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是<strong class="le jo">数据驱动增长</strong>系列的结束。希望你喜欢这些文章，并开始应用这里的实践。这些将被转换成电子书，并由一个全面的视频系列支持。敬请期待！</p><p id="85dc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">黑客快乐！</p></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><p id="9d2c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">需要帮助来发展你的公司吗？点击这里与我一起预订免费课程<a class="ae ly" href="https://app.growthmentor.com/mentors/baris-karaman" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>