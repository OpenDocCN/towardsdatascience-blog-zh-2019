<html>
<head>
<title>Building a Pseudorandom Number Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建伪随机数发生器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-pseudorandom-number-generator-9bc37d3a87d5?source=collection_archive---------8-----------------------#2019-11-11">https://towardsdatascience.com/building-a-pseudorandom-number-generator-9bc37d3a87d5?source=collection_archive---------8-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0519" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在不到 50 行的 Python 代码中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a438364f17dab99ce9b16c80158aab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLjJj85W-9DLNDJiLkcj3Q.png"/></div></div></figure><p id="3ee4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的文章“<a class="ae lq" rel="noopener" target="_blank" href="/how-to-get-an-unbiased-rng-from-an-unbalanced-one-dbb44850e5f7"> <em class="lr">如何从一个不平衡的 RNG 得到一个无偏的 T2</em></a><em class="lr">”</em>中，我展示了如何从任何来源提取随机性。现在的目标是从头开始构建一个伪随机数生成器！</p><h2 id="afb8" class="ls lt it bd lu lv lw dn lx ly lz dp ma ld mb mc md lh me mf mg ll mh mi mj mk bi translated">“为什么我需要一个随机数？”</h2><p id="bbfd" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">随机数的重要性不在于数字本身(如果单独来看，它们是普通的数字)，而在于它们产生的方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/afd7a36163b0e31ff54f5112444ffc68.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*kwVxwULlpFSCfMpkzQhVvg.png"/></div></figure><p id="7953" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现代技术是基于这些数字:通信协议，加密，游戏大量使用它们，它们的整体安全性和不可预测性依赖于它们。</p><p id="1104" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设你想创建一个游戏，系统抛出一枚硬币，玩家在结果上下赌注(用真钱)。如果玩家是正确的，那么他有奖励(金钱),否则他失去了放置的金钱。如果你的硬币真的是公平的(或不可预测的)，那么你就没什么好担心的。</p><p id="f6aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果玩家能够以很高的准确率预测下一次投掷的结果，会发生什么呢？或者他们是否能根据最后三投预测下一个结果？答案显而易见。</p><h1 id="07f2" class="mr lt it bd lu ms mt mu lx mv mw mx ma jz my ka md kc mz kd mg kf na kg mj nb bi translated">自然发电机</h1><p id="591f" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">大自然提供了一些随机性的来源，但是使用起来非常昂贵。</p><p id="8fab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在宏观环境中，来源很少，如气候变化或宇宙微波背景。这种发电机非常昂贵:我想买一个系统，把你和测量 CMB 变化的卫星连接起来，并在几毫秒内发回结果。成本在 4 ~ 5 亿美元左右。</p><p id="26f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，我举了一个极端的例子，但是总的来说，考虑到成本和性能，这一点都不方便。</p><p id="122f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在微观上，整个环境是由混沌驱动的:据我们所知，这是一个概率世界；但是，管理这种资源又是非常昂贵的。完美地平衡一个粒子的量子态这不是一个简单的任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/1764ed2017e95aa0fcaecbd9d7f122a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q95TImEffa_nxgmSauseJQ.jpeg"/></div></div></figure><h1 id="e9b0" class="mr lt it bd lu ms mt mu lx mv mw mx ma jz my ka md kc mz kd mg kf na kg mj nb bi translated">伪随机发生器</h1><p id="f337" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">由于这些原因，我们总是发现在我们的机器(电脑、智能手机、电视、<em class="lr">等……</em>)中内置发电机很方便。此外，有一个更简洁的方法来计算随机字符串总是好的:如果您的系统从以μK 为单位的本地温度中提取一个序列，任何人都可以通过在您的系统附近放置一个传感器来复制相同的序列；甚至任何人都可以操纵检测并控制你的序列。</p><p id="df6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计算机使用 CPU 来执行指令，而 CPU 是基于确定性机制的。我们如何从一个没有任何随机性来源的环境中创造随机性？</p><p id="faa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我回答这个问题之前，让我们定义一个伪随机数发生器(PRNG)。从这里开始，我将处理使用位(0 和 1)的 PRNGs，但对于其他情况，验证其属性是非常容易的，因为可以用一个数来编码一个二进制序列。</p><h1 id="7e6b" class="mr lt it bd lu ms mt mu lx mv mw mx ma jz my ka md kc mz kd mg kf na kg mj nb bi translated">背后的理论</h1><p id="8d66" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">给定一个初始种子，PRNG 产生一个比特序列，该序列与由真实随机源产生的序列无法区分。</p><p id="ca47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不可区分是指在一台<a class="ae lq" href="http://web.archive.org/web/20161115065946/http://en.wikipedia.org/wiki/Probabilistic_Turing_machine" rel="noopener ugc nofollow" target="_blank">概率图灵机</a>上没有可以在多项式时间内执行的算法可以决定给定的序列是随机的还是计算出来的。也就是说，没有随机算法能说 PRNG 产生的字符串是确定性计算的还是随机提取的。</p><p id="a291" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，这是 PRNG 的一个定义:它是一个在多项式时间内在确定性图灵机上可执行的算法，计算一个函数<strong class="kw iu"> <em class="lr"> G </em> </strong>使得</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c49c718be7ca5bcecae090ce2e3e310e.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*CTvAtO9QYDRu8Ws9jbmG3g.png"/></div></figure><p id="9afc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<strong class="kw iu"> <em class="lr"> l </em> </strong>作为单调递增函数。这意味着输出总是比输入(种子)长。</p><p id="fa26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，对于属于<a class="ae lq" href="https://en.wikipedia.org/wiki/BPP_(complexity)" rel="noopener ugc nofollow" target="_blank"> BPP 类</a>的<strong class="kw iu">D<em class="lr">D</em>T13】中的每个算法，对于每个多项式<strong class="kw iu">T17】pT19】和对于每个整数<strong class="kw iu">kT23】足够大:</strong></strong></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/6f0cfa1233ac09ab662436b95eb51fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKlzQrx--iqAQlWFMpDFLQ.png"/></div></div></figure><p id="c75f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个庞大的公式可以这样理解:</p><p id="cd2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"/><a class="ae lq" href="https://en.wikipedia.org/wiki/BPP_(complexity)" rel="noopener ugc nofollow" target="_blank"><em class="lr">概率多项式时间问题(BPP) </em> </a> <em class="lr">类中的算法能够区分真实随机源和 PRNG 之间的序列的概率随着种子长度的增加比任何多项式更快地趋向于零</em>。</p><p id="6e31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，PRNG 是一种算法，它将种子作为输入，并返回一个更长的字符串，因此没有人能够轻易说出它是否被计算过。算法计算出的函数称为<strong class="kw iu"> <em class="lr"> G </em> </strong>。</p><p id="bab3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lr"> G </em> </strong>的定义说，如果初始种子是一个<strong class="kw iu"> <em class="lr"> k </em> </strong>比特的序列，那么<strong class="kw iu"><em class="lr"/></strong>G<strong class="kw iu"><em class="lr">l(k)</em></strong>比特的更长序列。我们是否应该为每一个可能的函数<strong class="kw iu"> <em class="lr"> l </em> </strong>构建一个不同的函数<strong class="kw iu"> <em class="lr"> G </em> </strong>？</p><p id="14f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从简单的 PRNG <strong class="kw iu">号开始<em class="lr"> H </em>号</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7f8db8e4a2511c579f4a66be23ead773.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*bzxn0SH-hWLUwHQbTfFrQA.png"/></div></figure><p id="58a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有可能以<strong class="kw iu"> <em class="lr"> G </em> </strong> <em class="lr"> </em>的形式构建任何 PRNG，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/81fd5619a3af5d97a13a3cb7dbafe56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unGMeNAntfG7Kxa98Do3ng.png"/></div></div></figure><p id="3727" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中，xᵢ λᵢ是位串，是位串 xᵢ和单个位λᵢ.串联的结果<strong class="kw iu"> <em class="lr"> H </em> </strong>函数从初始种子生成一个比原来长一位的序列。通过调用<strong class="kw iu"> <em class="lr"> H </em> </strong>函数<strong class="kw iu"> <em class="lr"> l(k) </em> </strong>次并从每次迭代中取出最后一位，我们已经生成了一系列的<strong class="kw iu"><em class="lr">【l(k)</em></strong>位。显然这个功能就是<strong class="kw iu"> <em class="lr"> G </em> </strong>。</p><p id="9624" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在能够构建一个函数，该函数采用<strong class="kw iu"> <em class="lr"> k </em> </strong>位并返回<strong class="kw iu"> <em class="lr"> l(k) </em> </strong>位，使得没有算法能够决定<strong class="kw iu"> <em class="lr"> l(k) </em> </strong>位是否是从真实的随机源生成的。通过这个技巧，我们从构建输出<strong class="kw iu"><em class="lr">【k】</em></strong>位的函数(使用<strong class="kw iu"> <em class="lr"> l( ) </em> </strong>通用多项式函数)的问题转移到只返回<strong class="kw iu"> <em class="lr"> k+1 </em> </strong>位的函数。剩下的就是定义<strong class="kw iu"> <em class="lr"> H </em> </strong>函数。</p><h2 id="69d5" class="ls lt it bd lu lv lw dn lx ly lz dp ma ld mb mc md lh me mf mg ll mh mi mj mk bi translated">单向置换的 h 函数</h2><p id="3255" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">选择<strong class="kw iu"> <em class="lr"> H </em> </strong>作为单向置换是个好主意。</p><p id="f38c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lr"> H </em> </strong>如果很难求逆就是单向排列:给定<strong class="kw iu"><em class="lr"/></strong>y，很难计算出<strong class="kw iu"><em class="lr"/></strong>x 使得<strong class="kw iu"> <em class="lr"> H(x) = y </em> </strong>。</p><p id="bdf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">众所周知且广泛使用的单向置换是模幂运算。给定一个质数<strong class="kw iu"> <em class="lr"> p </em> </strong>和一个整数<strong class="kw iu"> <em class="lr"> x </em> </strong>使得<br/><strong class="kw iu"><em class="lr">0&lt;x&lt;p-1</em></strong>，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d5d4ad9734a7022cb6851a3230c80297.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*Nh1ys8NBPSTI5n4wnVLjTA.png"/></div></figure><p id="bc1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<strong class="kw iu"> <em class="lr"> g </em> </strong>是循环群的生成元</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fdfb2fb960b762a07088dd9fb56b6279.png" data-original-src="https://miro.medium.com/v2/resize:fit:70/format:webp/1*Lq-6tY49l8zgSW5CXnQBmA.png"/></div></figure><p id="394e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个循环群的生成元的个数是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/73bfd7a99aac091ebe1710cfaf792e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*OzJCoFlOGBmjKShsISR2hw.png"/></div></figure><p id="bd23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<strong class="kw iu"> <em class="lr"> p </em> </strong>为奇素数时，其中<strong class="kw iu"> <em class="lr"> ϕ </em> </strong>为<a class="ae lq" href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" rel="noopener ugc nofollow" target="_blank">欧拉全等函数</a>。现在求这样的<strong class="kw iu"> <em class="lr"> x </em> </strong>需要计算离散对数，这是一个著名的未解计算难题。也就是说，没有计算大整数的离散对数的有效方法是已知的。公钥密码学中的许多算法基于这样一种假设，即没有有效的方法来计算它的安全性。</p><h2 id="6adc" class="ls lt it bd lu lv lw dn lx ly lz dp ma ld mb mc md lh me mf mg ll mh mi mj mk bi translated">最后一点</h2><p id="c00a" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">我们发现一个函数从<strong class="kw iu"> <em class="lr"> k </em> </strong>位开始，返回<strong class="kw iu"> <em class="lr"> k </em> </strong>位，并且很难反转。我们需要额外的一位，根据<strong class="kw iu"> <em class="lr"> H </em> </strong>的定义。该位是功能<strong class="kw iu"> <em class="lr"> f </em> </strong>的<em class="lr">核心位</em>。如果已知<strong class="kw iu"><em class="lr"/></strong>x，则<strong class="kw iu"> <em class="lr"> f </em> </strong>的核心位有点容易计算，但如果只给定<strong class="kw iu"> <em class="lr"> f(x) </em> </strong>则很难计算。</p><p id="0659" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了找到它，让我们定义两个<strong class="kw iu"> <em class="lr"> k </em> </strong>位串<strong class="kw iu"> <em class="lr"> x </em> </strong>和<strong class="kw iu"> <em class="lr"> y </em> </strong>之间的新操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0540a67c605876326757c30e47a3a101.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*srpBAoskAPxFYR1ohKNkog.png"/></div></figure><p id="0724" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<strong class="kw iu"><em class="lr">【x】</em></strong>是一个单向排列(就像上面定义的那样)<strong class="kw iu"> <em class="lr"> g(x，y) = f(x) ‖ y </em> </strong>，那么<strong class="kw iu"> ⟨ <em class="lr"> x，y </em> ⟩ </strong>是<strong class="kw iu"> <em class="lr"> g </em> </strong>的硬核位，其中<strong class="kw iu"><em class="lr"/>这是由<a class="ae lq" href="https://en.wikipedia.org/wiki/Hard-core_predicate" rel="noopener ugc nofollow" target="_blank"> Goldreich-Levin 定理</a>陈述的。</strong></p><p id="783b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后我们找到了 PRNG <strong class="kw iu"> <em class="lr"> H </em> </strong>这是它的正式定义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e86e4c7e652bb1382c592955d244690b.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*e_nhPH63VzBbsBi1u4PDhA.png"/></div></figure><p id="27a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在哪里</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2f74d7492eb943893b65a71a98748d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*NUPOJ2449kNPIgGhYuj5Ag.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f2b418ab5235d40aaf879db44e0de373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_M-tFpVsDf5-Qv5XQMAVQ.jpeg"/></div></div></figure><h1 id="db6d" class="mr lt it bd lu ms mt mu lx mv mw mx ma jz my ka md kc mz kd mg kf na kg mj nb bi translated">PRNG</h1><p id="536c" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">现在我们可以根据我们给出的<strong class="kw iu"> <em class="lr"> H </em> </strong>和<strong class="kw iu"> <em class="lr"> G </em> </strong>的定义来构建一个好的 PRNG。对于那些错过的人，<strong class="kw iu"> <em class="lr"> G </em> </strong>是一个函数(实际上是 PRNG 本身),给定输入中的一个<strong class="kw iu"> <em class="lr"> k </em> </strong>位串，输出一个<strong class="kw iu"> <em class="lr"> l(k) </em> </strong>位串，并且没有随机算法可以判断产生的字符串是否是由真正的随机源生成的；<strong class="kw iu"> <em class="lr"> H </em> </strong>是一个帮助找到那些伪随机位的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/79ad04f371e05310f39c8f9a87b396fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XZd7VB4YY0xlvg7JZVcwg.png"/></div></div></figure><p id="dfd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我假设生成器<strong class="kw iu"> <em class="lr"> g = 2 </em> </strong>。你应该找到一个依赖于<strong class="kw iu"> <em class="lr"> p </em> </strong>的生成器，因为这只是一个例子(即使统计上<strong class="kw iu"> <em class="lr"> 2 </em> </strong>是一个频繁的生成器)。如果你想为你的<strong class="kw iu"> <em class="lr"> p </em> </strong>找到一个生成器，你可以使用<a class="ae lq" href="http://www.bluetulip.org/2014/programs/primitive.html" rel="noopener ugc nofollow" target="_blank">这个在线工具</a>来计算给定素数的根基元模。</p><p id="f87f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在主要功能<strong class="kw iu"> <em class="lr"> G </em> </strong>，【PRNG:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c4e48f97d34d1fb1e453c2196ed35b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAsQbDlb6Fn0PlyakK6wkQ.png"/></div></div></figure><p id="2138" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<strong class="kw iu"> <em class="lr"> l( ) </em> </strong>可以是任意多项式函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/baf2a0a6e6c861d32013771fcd3acc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPR1CbptO9g_gMUARH_hMw.png"/></div></div></figure><p id="2bb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<strong class="kw iu"> <em class="lr"> H </em> </strong>的输入是将被分成两半的位串，所以初始种子<strong class="kw iu"> <em class="lr"> x0 </em> </strong>的长度必须是偶数。</p><p id="a214" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，根据上一节的定义，更长的种子会产生更难区分的序列。这意味着更长的种子将产生更不可预测的比特序列。</p><h1 id="5814" class="mr lt it bd lu ms mt mu lx mv mw mx ma jz my ka md kc mz kd mg kf na kg mj nb bi translated">Python 实现</h1><p id="7bce" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">为了轻松管理位操作，算法的实现在字符串上工作，因此它可以更好地从上面显示的伪代码转换为 Python 代码。但是它可以通过直接处理位来增强，代价是可读性。</p><p id="75f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我用了模幂运算作为单向排列和<br/><strong class="kw iu"><em class="lr">l(k)= k-2k+1</em></strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk"><a class="ae lq" href="https://gist.github.com/firaja/f2eabc05db3fdd4cf60373f5971b4eb3" rel="noopener ugc nofollow" target="_blank">Link to the gist</a></figcaption></figure><p id="9b5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/8a2c329c16d71b740a147d7f73188af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrh4Or0TIaIRag1mi0qDtg.png"/></div></div></figure><p id="338a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一采用的参数是初始种子，它必须是一个二进制字符串，长度不能超过变量<code class="fe nv nw nx ny b">SEED_SIZE</code>的值。</p><p id="38b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想要生成一个数字序列，您可以使用输出的任何部分作为下一次迭代的种子。更大的种子会产生更好的输出，但在使用它之前，请记住重新定义一个合适的<strong class="kw iu"> <em class="lr"> l( ) </em> </strong>，如果您想保持模幂运算为单向变换，请选择一个新的<code class="fe nv nw nx ny b">GENERATOR</code>，它是<code class="fe nv nw nx ny b">MODULUS</code>的原始根。</p></div></div>    
</body>
</html>