<html>
<head>
<title>SequenceMatcher in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的序列匹配器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sequencematcher-in-python-6b1e6f3915fc?source=collection_archive---------2-----------------------#2019-04-15">https://towardsdatascience.com/sequencematcher-in-python-6b1e6f3915fc?source=collection_archive---------2-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="44ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个人性化的<strong class="ak"> <em class="ki">最长连续&amp;无垃圾</em> </strong>序列比较器</h2></div><p id="3dff" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">SequenceMatcher 是 python 模块中可用的类，名为<strong class="kl iu">“diff lib”。</strong>可用于比较成对的输入序列。本文的目的是通过一个示例来解释 SequenceMatcher 算法。由于可用的文档有限，我想通过一步一步的例子来分享这个概念，这可以帮助读者以清晰的方式理解整个过程。</p><blockquote class="lf lg lh"><p id="9fb1" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated">引用<a class="ae lm" href="https://github.com/python/cpython/blob/master/Lib/difflib.py" rel="noopener ugc nofollow" target="_blank">原始文件</a>:</p><p id="8e97" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated">基本思想是找到不包含<strong class="kl iu"> <em class="it">【垃圾】</em> </strong>元素的<em class="it"> </em> <strong class="kl iu"> <em class="it">最长连续匹配子序列</em></strong><em class="it"/><strong class="kl iu">【LCS】</strong>。这不会产生最小的编辑序列，但是会产生与人的<strong class="kl iu"> <em class="it">【向右看】</em> </strong>匹配的序列。</p></blockquote><p id="0df6" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">等一下。上一段描述了这么多专业术语。我们按顺序解码吧。我希望任何阅读这篇文章的人都知道算法<a class="ae lm" href="https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iu"> LCS </strong> </a>。基本上，LCS 的目标是:给定两个序列，找出两个序列中最长的子序列的长度。在这里，我们也试图在一对序列之间找到类似于 LCS 的东西，但它们在数学上不是 100%优雅的。换句话说，结果应该让用户更满意，这就是为什么它被称为对人们来说“看起来合适”的匹配。为了避免任何早期的混淆，让我们观察一个我在<a class="ae lm" href="https://stackoverflow.com/questions/35517353/how-does-pythons-sequencematcher-work" rel="noopener ugc nofollow" target="_blank"> <em class="li">堆栈溢出</em> </a> <em class="li"> </em>上找到的例子来理解这两者之间的区别。</p><p id="86d8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">输入字符串:</strong> <code class="fe ln lo lp lq b">my stackoverflow mysteries </code> <strong class="kl iu">和</strong> <code class="fe ln lo lp lq b">mystery</code></p><p id="d648" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">对任何人来说，自然的搭配是<code class="fe ln lo lp lq b">"myster"</code>如下:</p><blockquote class="lf lg lh"><p id="aad2" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated"><code class="fe ln lo lp lq b"><em class="it">my stackoverflow </em><strong class="kl iu"><em class="it">myster</em></strong><em class="it">ies<br/>.................</em><strong class="kl iu"><em class="it">myster</em></strong><em class="it">y..</em></code></p></blockquote><p id="900a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">事实上，这就是 SequenceMatcher 算法在处理上述字符串时返回的输出。</p><p id="2573" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然而，LCS 将输出<code class="fe ln lo lp lq b">"mystery"</code></p><blockquote class="lf lg lh"><p id="d2bb" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated"><code class="fe ln lo lp lq b"><strong class="kl iu"><em class="it">my</em></strong><em class="it"> </em><strong class="kl iu"><em class="it">st</em></strong><em class="it">ackov</em><strong class="kl iu"><em class="it">er</em></strong><em class="it">flow m</em><strong class="kl iu"><em class="it">y</em></strong><em class="it">steries<br/></em><strong class="kl iu"><em class="it">my</em></strong><em class="it">.</em><strong class="kl iu"><em class="it">st</em></strong><em class="it">.....</em><strong class="kl iu"><em class="it">er</em></strong><em class="it">......</em><strong class="kl iu"><em class="it">y</em></strong><em class="it">.......</em></code></p></blockquote><p id="2d0d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因为对于人类专家来说，较长的公共子序列可能比较短的公共子序列显得不那么自然。因此，我们认为 SequenceMatcher 试图找出对人类更友好的输出。</p><p id="ed09" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">继续向前，接下来是<strong class="kl iu"> <em class="li">【垃圾】</em> </strong>元素的概念。<em class="li">【垃圾】</em>是你不希望算法匹配的东西:比如普通文本文件中的空行，或者可能是 HTML 文件中的“&lt; P &gt;”行等。</p><blockquote class="lf lg lh"><p id="e6f7" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated">SequenceMatcher 对象初始化为:</p><p id="269d" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated">__init__(isjunk=None，a= ' '，b= ' ')</p></blockquote><p id="94d1" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu"> <em class="li"> isjunk </em> </strong>参数为您提供了定义您希望算法视为垃圾的任何元素的选项。</p><p id="e231" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">&gt;如果<em class="li">是垃圾</em>没有定义:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/63b9a58a3dcfdc2b0ccd517fa8b79e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*m5juGKHqh1gJoFuh-c0t2A.png"/></div></figure><p id="a92f" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">&gt;如果<em class="li">是垃圾</em>被定义为认为空白是垃圾:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/562bfe9fd87f81e86df99a20f1da326b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*a7eGhI5QxMMZHnyOpILuGw.png"/></div></figure><p id="ad58" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">将空白视为垃圾，可以防止“abcd”与第二个序列末尾的“abcd”直接匹配。相反，只有“abcd”可以匹配，并且匹配第二个序列中最左边的“abcd”。</p><h2 id="e621" class="ma mb it bd mc md me dn mf mg mh dp mi ks mj mk ml kw mm mn mo la mp mq mr ms bi translated">序列匹配器流程图</h2><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2105c4ec3618bdcc08f1a07a9bedfdd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*-o2CvfutjlWj7EA4oltPLA.png"/></div></figure><p id="0527" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">给定两个输入字符串 a 和 b，</p><ul class=""><li id="d9b6" class="mu mv it kl b km kn kp kq ks mw kw mx la my le mz na nb nc bi translated"><strong class="kl iu"> ratio( ) </strong>返回输入字符串之间的相似性得分(float in [0，1])。它对函数<em class="li"> get_matching_blocks </em>返回的所有匹配序列的大小求和，并计算比率为:<em class="li"/><strong class="kl iu">ratio = 2.0 * M/T</strong>，其中 M =匹配，T =两个序列中的元素总数</li><li id="a499" class="mu mv it kl b km nd kp ne ks nf kw ng la nh le mz na nb nc bi translated"><strong class="kl iu"> get_matching_blocks( ) </strong>返回描述匹配子序列的三元组列表。最后一个三元组是哑元，(len(a)，len(b)，0)。它通过重复应用 find_longest_match()来工作</li><li id="ba26" class="mu mv it kl b km nd kp ne ks nf kw ng la nh le mz na nb nc bi translated"><strong class="kl iu"> find_longest_match( ) </strong>返回包含 a[aLow:aHigh]和 b[bLow:bHigh]中最长匹配块的三元组</li></ul><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fc1be7f01ce708da484e651238447f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*EwboXmMfl2SdGAJO1PAq_A.png"/></div></figure><h2 id="422f" class="ma mb it bd mc md me dn mf mg mh dp mi ks mj mk ml kw mm mn mo la mp mq mr ms bi translated">再解释一下</h2><p id="77c4" class="pw-post-body-paragraph kj kk it kl b km nj ju ko kp nk jx kr ks nl ku kv kw nm ky kz la nn lc ld le im bi translated">在深入这个例子之前，让我们多了解一下上面两个重要的函数，这肯定会帮助我们完美地理解这些概念。我试图以一种简单的方式只解释重要的部分。关于完整的 python 代码，建议读者访问<a class="ae lm" href="https://github.com/python/cpython/blob/master/Lib/difflib.py" rel="noopener ugc nofollow" target="_blank"> <em class="li">官方网站</em> </a></p><blockquote class="lf lg lh"><p id="cd63" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated"><strong class="kl iu"> get_matching_blocks()解释</strong></p></blockquote><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/fec71aa24935ed7eb865f79b4a09f8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*26WekvNtg6lhx6M43Tl-xA.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Code Snippet of function get_matching_blocks( )</figcaption></figure><p id="e520" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">基本上，维护一个队列，该队列用包含两个输入字符串的上限和下限的索引的四元组来初始化。直到队列中有一个四元组可用，它被弹出并传递给<em class="li"> find_longest_match( ) </em>函数，该函数返回描述匹配子序列的三元组<em class="li"> </em>。三元组被添加到 matching_blocks 列表中。</p><p id="58ea" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">每个三元组的形式为(I，j，n)，表示 a[i:i+n] == b[j:j+n]</p><p id="8479" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">匹配子序列左边和右边的序列片段被进一步添加到队列中。重复该过程，直到队列为空。</p><p id="cec6" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后对 matching_blocks 列表进行排序，并作为输出返回。</p><blockquote class="lf lg lh"><p id="998c" class="kj kk li kl b km kn ju ko kp kq jx kr lj kt ku kv lk kx ky kz ll lb lc ld le im bi translated"><strong class="kl iu"> find_longest_match()解释</strong></p></blockquote><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0baf9965d435e91b1027155ec263de40.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*Mx5UiF2k_a6Qd_CRFBZcwg.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Code Snippet of find_longest_match( )</figcaption></figure><p id="4831" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这将包含字符串的上限和下限索引的三元组作为输入，并返回包含最长匹配块的三元组。</p><p id="dd54" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，定义一个字典<strong class="kl iu">b2j</strong><strong class="kl iu"/>其中对于字符串 b 中的 x，b2j[x]是 x 出现的索引(到 b 中)的列表。</p><p id="d1b8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在在外循环中逐字符扫描第一个字符串，我们使用 b2j 检查该字符在字符串 b 中的出现。如果有匹配，我们更新另一个字典 newj2len，它有助于记录到目前为止匹配的字符串的长度。并且相应地，变量<em class="li"> besti、bestj </em>和<em class="li"> bestsize </em>被更新，这考虑了迄今为止获得的最长匹配块数据。</p><p id="0cfb" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在所有最大匹配块中，该算法返回在 a 中最早开始的块，在所有最大匹配块中，它返回在 b 中最早开始的块。</p><p id="225c" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我想这些理论已经足够了，现在让我们深入一个例子，它将帮助我们详细地理解整个工作。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="1b1e" class="ma mb it bd mc md me dn mf mg mh dp mi ks mj mk ml kw mm mn mo la mp mq mr ms bi translated">一个有插图的例子</h2><p id="f530" class="pw-post-body-paragraph kj kk it kl b km nj ju ko kp nk jx kr ks nl ku kv kw nm ky kz la nn lc ld le im bi translated">让我们通过使用一对输入字符串实现算法来描述算法的一步一步的过程。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/89af4617ff290e2031c8a0ff8058cccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvhPjcvXHpb8Uh5RgJc_uA.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi og"><img src="../Images/cb6df02d577770dfc9a90ddb17ae196d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqq6zsgzzXRGjfvJ4BOaqw.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/d81584cb47db519bf88c85703842729a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkXhfbC3livW5kn8OA8BCA.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/966d92b87bd6bf6273f53bcef7160caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*ppTJEL85qFmJoOIE1QbAwA.png"/></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/44e2ee4da3f0d44cf61f04cbb518f4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBAI60w5jTsavbFsTxxNpA.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e288ac6dde93592efd50a05dead5fb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*6KHZakA1t9l1lrI2eIJGjg.png"/></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ok"><img src="../Images/19d8928c861fdb99d0c3a64a99061503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nzl_rPevxb3K8EgJXckxJg.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ol"><img src="../Images/5ab72af14eb4cf6fb78e486140bed757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAG3E-YzrgVKejjoQxTRYA.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8d280bb91e2d795a7245bf7a2f904629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*Uk6gVjhiler27KmFR4CvSQ.png"/></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/01b7b1ca01beaf3d5a8b441f975dd2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYdwUHNHmEa_HcmIXumQ6g.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/ef5833d8ad39252420724503dde4ea59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*N92QzVTBE6RpBksIhTmiTg.png"/></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/dc73b9a9aca9c98dcfb32c86a63ef48b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-S_vFf5sWhs0rZrlOfKavg.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/21a3c15921055446b8920aeca5a68896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlpmjAIzRT97-DZcIf6PNw.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/1b2d1732c6eaa1d9eeb38df90c438442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBwXrAGJSOIfBc_pqXvH8g.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/4ca13469c69a5b29ee6eb37ef8467e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_gVBRb5ohsjxa7cx3fNAg.png"/></div></div></figure><p id="82d4" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">根据经验，ratio()值超过 0.6 意味着序列非常匹配。这里，通过计算，我们已经获得了 0.8 的相似性得分比率，因此输入的序列对被视为相似的。</p><p id="fabd" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了交叉验证我们的计算结果，让我们用 python 运行 SequenceMatcher。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi on"><img src="../Images/552ca3e40d20ab2140c82c7ac49f54f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_n6yMWUSN8leVWZ-1-t8A.png"/></div></div></figure><p id="2498" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">万岁！！！我们已经达到了预期的产量。</p><p id="5d05" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我希望浏览上面的例子能够帮助读者了解序列相似性算法的工作原理。除了相似性，SequenceMatcher 类中还有许多其他功能。建议读者访问<a class="ae lm" href="https://github.com/python/cpython/blob/master/Lib/difflib.py" rel="noopener ugc nofollow" target="_blank"> <em class="li">官方代号</em> </a>。</p><p id="7e17" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">到那时，干杯！！</p><h1 id="70eb" class="oo mb it bd mc op oq or mf os ot ou mi jz ov ka ml kc ow kd mo kf ox kg mr oy bi translated"><strong class="ak">参考文献:</strong></h1><p id="4c55" class="pw-post-body-paragraph kj kk it kl b km nj ju ko kp nk jx kr ks nl ku kv kw nm ky kz la nn lc ld le im bi translated"><a class="ae lm" href="https://github.com/python/cpython/blob/master/Lib/difflib.py" rel="noopener ugc nofollow" target="_blank">https://github . com/python/cpython/blob/master/Lib/difflib . py</a></p></div></div>    
</body>
</html>