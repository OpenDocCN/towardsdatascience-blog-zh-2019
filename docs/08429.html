<html>
<head>
<title>Everything you need to know about Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于正则表达式你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-regular-expressions-8f622fe10b03?source=collection_archive---------0-----------------------#2019-11-16">https://towardsdatascience.com/everything-you-need-to-know-about-regular-expressions-8f622fe10b03?source=collection_archive---------0-----------------------#2019-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b1bdc4fe550e33e774c48162c8f7fd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvRLCts9a2k_8ptbolMgOg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@nesabymakers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NESA by Makers</a> on <a class="ae kf" href="https://unsplash.com/s/photos/learn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6bf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">读完这篇文章后，你会对什么是正则表达式，它们能做什么，它们不能做什么有一个坚实的理解。</p><p id="4f72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你将能够判断何时使用它们，更重要的是，何时不使用它们。</p><p id="d1fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从头开始。</p><h1 id="3c29" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是正则表达式？</h1><p id="fdfd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在抽象层次上，正则表达式，简称 regex，是集合的简写表示。一组弦。</p><p id="985f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个所有有效邮政编码的列表。与其保留那个又长又笨重的列表，不如用一个简短而精确的模式来完整地描述那个集合。每当您想要检查一个字符串是否是一个有效的邮政编码时，您可以将它与模式进行匹配。您将得到一个 true 或 false 结果，表明该字符串是否属于 regex 模式所代表的邮政编码集。</p><p id="d732" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们扩展一下邮政编码集。邮政编码列表是有限的，由相当短的字符串组成，在计算上并不特别具有挑战性。</p><p id="5c68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以<code class="fe mh mi mj mk b">.csv</code>结尾的那组字符串呢？在查找数据文件时非常有用。这个集合是无限的。你不能事先列个清单。测试成员资格的唯一方法是到字符串的末尾，比较最后四个字符。正则表达式是以一种标准化的方式编码这种模式的一种方式。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/5064118bbeacf119a73a1040fb1d80f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zyJfVFCraVQXD4IX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Regular expressions match sets of strings. Photo by <a class="ae kf" href="https://unsplash.com/@kristianstrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kristian Strand</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fa93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个正则表达式模式，代表我们的以<code class="fe mh mi mj mk b">.csv</code>结尾的字符串集</p><p id="ad40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">^.*\.csv$</code></p><p id="2746" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把这种特殊模式的机制放在一边，看看实际情况:正则表达式引擎可以根据输入字符串测试模式，看它是否匹配。以上图案匹配<code class="fe mh mi mj mk b">foo.csv</code>，但不匹配<code class="fe mh mi mj mk b">bar.txt</code>或<code class="fe mh mi mj mk b">my_csv_file</code>。</p><p id="4b6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在代码中使用正则表达式之前，可以使用在线正则表达式计算器测试它们，并尝试友好的用户界面。</p><p id="8fb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢<a class="ae kf" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">regex101.com</a>:你可以选择正则表达式引擎的风格，模式会被很好地分解，所以你可以很好地理解你的模式实际上做了什么。正则表达式模式可能是神秘的。</p><p id="657f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我建议你在另一个窗口或标签中打开<a class="ae kf" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">regex101.com</a>,以交互方式体验本文中的例子。我保证，这样您会对正则表达式模式有更好的感觉。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/60e4c2e6a83a62d96e725d54714eba59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkTZyxLEVU3cbezhae4FNg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">debugging regular expressions</figcaption></figure><h1 id="3478" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式是用来做什么的？</h1><p id="5f2b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正则表达式在任何受益于字符串的完全或部分模式匹配的场景中都很有用。以下是一些常见的使用案例:</p><ul class=""><li id="7f57" class="mr ms it ki b kj kk kn ko kr mt kv mu kz mv ld mw mx my mz bi translated">验证字符串的结构</li><li id="a488" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated">从结构化字符串中提取子字符串</li><li id="acfb" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated">搜索/替换/重新排列部分字符串</li><li id="9e2f" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated">将字符串拆分成标记</li></ul><p id="d078" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些在做数据准备工作时都会定期出现。</p><h1 id="68b1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式的构造块</h1><p id="541c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正则表达式模式是由不同的构建块构成的。它可以包含<a class="ae kf" href="#literals" rel="noopener ugc nofollow">文字</a>、<a class="ae kf" href="#character-classes" rel="noopener ugc nofollow">字符类</a>、<a class="ae kf" href="#boundary-matchers" rel="noopener ugc nofollow">边界匹配器</a>、<a class="ae kf" href="#quantifiers" rel="noopener ugc nofollow">量词</a>、<a class="ae kf" href="#groups" rel="noopener ugc nofollow">组</a>以及<a class="ae kf" href="#the-or-operator" rel="noopener ugc nofollow">或运算符</a>。</p><p id="8dbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们深入研究一下一些例子。</p><h2 id="52fb" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">文字</h2><p id="d867" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正则表达式中最基本的构件是字符，也称为文字。正则表达式模式中的大多数字符没有特殊的含义，它们只是匹配它们自己。考虑以下模式:</p><p id="ce7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">I am a harmless regex pattern</code></p><p id="d373" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个图案中没有一个字符有特殊含义。因此，模式中的每个字符都与其自身匹配。因此，只有一个字符串匹配这个模式，并且它与模式字符串本身相同。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/56f2f754fb7df9748ab862b68f287759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0A_R3Wp5t2wvTNAayAFXoQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching a simple pattern</figcaption></figure><h2 id="70e6" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">转义文字字符</h2><p id="ae0a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有哪些确实有特殊含义的字符？以下列表显示了在正则表达式中具有特殊含义的字符。如果要表示它们自己，就必须用反斜杠对它们进行转义。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">characters with special meaning in regular expressions</figcaption></figure><p id="0b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下模式:</p><p id="bf13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\+21\.5</code></p><p id="800c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该模式仅由文字组成——<code class="fe mh mi mj mk b">+</code>有特殊的含义并已被转义，同样的还有<code class="fe mh mi mj mk b">.</code>——因此该模式仅匹配一个字符串:<code class="fe mh mi mj mk b">+21.5</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/daf506bec68070d9171a1488553fcca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qMHOszaxexjjFSJfa7IkQ.png"/></div></div></figure><h2 id="de07" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">匹配不可打印字符</h2><p id="680e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有时需要引用一些不可打印的字符，如制表符⇥或换行符↩</p><p id="8d5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好对它们使用正确的转义序列:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您需要匹配换行符，它们通常有两种类型:</p><ul class=""><li id="aea7" class="mr ms it ki b kj kk kn ko kr mt kv mu kz mv ld mw mx my mz bi translated"><code class="fe mh mi mj mk b">\n</code>通常被称为 unix 风格的换行符</li><li id="4ed3" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated"><code class="fe mh mi mj mk b">\r\n</code>通常被称为 windows 风格的换行符</li></ul><p id="4bf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了抓住这两种可能性，你可以在<code class="fe mh mi mj mk b">\r?\n</code>上匹配，这意味着:可选的<code class="fe mh mi mj mk b">\r</code>后跟<code class="fe mh mi mj mk b">\n</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/f1340229434d41bcf54dfc5834c9f771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tjSaKkybq7omLHW0wHcLw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching a newline</figcaption></figure><h2 id="47d3" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">匹配任何 Unicode 字符</h2><p id="8aef" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有时，您必须使用 Unicode 索引来匹配最能表达的字符。有时候一个字符就是不能被输入——就像 ASCII <code class="fe mh mi mj mk b">NUL</code>、<code class="fe mh mi mj mk b">ESC</code>、<code class="fe mh mi mj mk b">VT</code>等控制字符。</p><p id="a8ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，您的编程语言不支持将某些字符放入模式中。在<a class="ae kf" href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" rel="noopener ugc nofollow" target="_blank"> BMP </a>之外的字符，如<a class="ae kf" href="https://charbase.com/1d11e-unicode-musical-symbol-g-clef" rel="noopener ugc nofollow" target="_blank"> 𝄞 </a>或表情符号通常不被逐字支持。</p><p id="35fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多 regex 引擎中——比如 Java、JavaScript、Python 和 Ruby——您可以使用<code class="fe mh mi mj mk b">\uHexIndex</code>转义语法通过 Unicode 索引匹配任何字符。假设我们想要匹配自然数的符号:<a class="ae kf" href="https://charbase.com/2115" rel="noopener ugc nofollow" target="_blank"> ℕ - U+2115 </a></p><p id="782e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">匹配这个字符的模式是:<code class="fe mh mi mj mk b">\u2115</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/b021734532c318226834d2ca3d0b0cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mbjHmnVrAJwiR0DlsDMSA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching a unicode symbol</figcaption></figure><p id="c638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他引擎通常提供等效的转义语法。在围棋中，你可以使用<code class="fe mh mi mj mk b">\x{2115}</code>来匹配ℕ</p><p id="ed8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Unicode 支持和转义语法因引擎而异。如果你计划匹配技术符号、音乐符号或表情符号——特别是在<a class="ae kf" href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" rel="noopener ugc nofollow" target="_blank"> BMP </a>之外——检查你使用的 regex 引擎的文档，以确保对你的用例有足够的支持。</p><h2 id="5a50" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">模式的转义部分</h2><p id="1e1a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有时模式要求连续字符作为文字进行转义。假设它匹配下面的字符串:<code class="fe mh mi mj mk b">+???+</code></p><p id="4b19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该模式如下所示:</p><p id="7c89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\+\?\?\?\+</code></p><p id="4cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将每个字符作为文字进行转义的需要使得阅读和理解变得更加困难。</p><p id="a39c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据您的正则表达式引擎，可能有一种方式在您的模式中开始和结束文字部分。检查你的文件。在 Java 和 Perl 中，应该逐字解释的字符序列可以用<code class="fe mh mi mj mk b">\Q</code>和<code class="fe mh mi mj mk b">\E</code>括起来。以下模式等同于上述模式:</p><p id="cfe2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\Q+???+\E</code></p><p id="699f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果模式是由部分构成的，对模式的部分进行转义也是有用的，其中一些部分是按字面意思解释的，比如用户提供的搜索词。</p><p id="123e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你的 regex 引擎没有这个特性，那么生态系统通常会提供一个函数来对模式字符串中所有具有特殊含义的字符进行转义，比如<a class="ae kf" href="https://lodash.com/docs/4.17.10#escapeRegExp" rel="noopener ugc nofollow" target="_blank"> lodash escapeRegExp </a>。</p><h1 id="7ec5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">OR 运算符</h1><p id="9f00" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">管道字符<code class="fe mh mi mj mk b">|</code>是选择操作符。它匹配备选方案。假设一个模式应该匹配字符串<code class="fe mh mi mj mk b">1</code>和<code class="fe mh mi mj mk b">2</code></p><p id="c27d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的模式可以达到这个目的:</p><p id="9b1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">1|2</code></p><p id="00d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运算符左侧和右侧的模式是允许的替代模式。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/3afc8defeb78a4c99e02a3c79179ae3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA91EZDCYNSo0bSL31hOkg.png"/></div></div></figure><p id="1be3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下模式匹配<code class="fe mh mi mj mk b">William Turner</code>和<code class="fe mh mi mj mk b">Bill Turner</code></p><p id="628a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">William Turner|Bill Turner</code></p><p id="22f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">备选方案的第二部分是一致的<code class="fe mh mi mj mk b">Turner</code>。将备选方案<code class="fe mh mi mj mk b">William</code>和<code class="fe mh mi mj mk b">Bill</code>放在前面，并且只提到<code class="fe mh mi mj mk b">Turner</code>一次会比较方便。以下模式可以做到这一点:</p><p id="0bb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">(William|Bill) Turner</code></p><p id="d9ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来可读性更强。它还引入了一个新概念:组。</p><h1 id="1ed3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">组</h1><p id="f2b7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以在圆括号中的部分中分组子模式。它们将包含的表达式组合成一个单元。对模式的各个部分进行分组有多种用途:</p><ul class=""><li id="a45f" class="mr ms it ki b kj kk kn ko kr mt kv mu kz mv ld mw mx my mz bi translated">简化正则表达式符号，使意图更清晰</li><li id="d0bf" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated">对子表达式应用量词<a class="ae kf" href="#quantifiers" rel="noopener ugc nofollow">和</a></li><li id="d49d" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated">提取匹配组的子字符串</li><li id="a0f2" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated">替换匹配组的子字符串</li></ul><p id="93bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来看一个带组的正则表达式:<code class="fe mh mi mj mk b">(William|Bill) Turner</code></p><p id="3fcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组有时被称为“捕获组”，因为在匹配的情况下，每个组的匹配子串被捕获，并且可用于提取。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/60d4e0a2ff691d8c729cbc816fa1ebe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Hjqa6luYuEleYEfz__6GA.png"/></div></div></figure><p id="f1e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何使捕获的组可用取决于您使用的 API。在 JavaScript 中，调用<code class="fe mh mi mj mk b">"my string".match(/pattern/)</code>会返回一个匹配的<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener ugc nofollow" target="_blank">数组。第一项是整个匹配的字符串，后续项是按照在模式中出现的顺序匹配模式组的子字符串。</a></p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Accessing sub-strings in captured in groups</figcaption></figure><h2 id="6730" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">示例:国际象棋符号</h2><p id="8c6d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">考虑识别<a class="ae kf" href="https://en.wikipedia.org/wiki/Algebraic_notation_(chess)" rel="noopener ugc nofollow" target="_blank">棋盘</a>区域的字符串。棋盘上的区域可以被标识为第一列的 A1-A8，第二列的 B1-B8，等等，直到最后一列的 H1-H8。假设应该验证包含此符号的字符串，并使用捕获组提取组成部分(字母和数字)。下面的正则表达式可以做到这一点。</p><p id="56ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">(A|B|C|D|E|F|G|H)(1|2|3|4|5|6|7|8)</code></p><p id="a0f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然上面的正则表达式是有效的，并完成了工作，但它有些笨拙。这个也可以，而且更简洁一点:</p><p id="f1cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">([A-H])([1-8])</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/46cfca14b43b1d9f71418fb37a7970de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9QA4dcYRYZI0BzjbUq7aA.png"/></div></div></figure><p id="ec3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这看起来更简洁。但是它引入了一个新概念:字符类。</p><h1 id="b8af" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字符类别</h1><p id="d6d0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">字符类用于定义一组允许的字符。允许的字符集放在方括号中，并且列出了每个允许的字符。角色类<code class="fe mh mi mj mk b">[abcdef]</code>相当于<code class="fe mh mi mj mk b">(a|b|c|d|e|f)</code>。因为该类包含替代项，所以它只匹配一个字符。</p><p id="c9a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图案<code class="fe mh mi mj mk b">[ab][cd]</code>正好匹配 4 串<code class="fe mh mi mj mk b">ac</code>、<code class="fe mh mi mj mk b">ad</code>、<code class="fe mh mi mj mk b">bc</code>和<code class="fe mh mi mj mk b">bd</code>。它确实<em class="oa">不</em>匹配<code class="fe mh mi mj mk b">ab</code>，第一个字符匹配，但第二个字符必须是<code class="fe mh mi mj mk b">c</code>或<code class="fe mh mi mj mk b">d</code>。</p><p id="7fcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设一个模式应该匹配一个两位数的代码。与之匹配的模式如下所示:</p><p id="35e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[0123456789][0123456789]</code></p><p id="aad0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该模式匹配从<code class="fe mh mi mj mk b">00</code>到<code class="fe mh mi mj mk b">99</code>范围内的所有 100 个两位字符串。</p><h2 id="07f6" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">范围</h2><p id="2f49" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在一个字符类中列出所有可能的字符通常是乏味且容易出错的。使用破折号运算符:<code class="fe mh mi mj mk b">[0-9][0-9]</code>可以将连续字符作为范围包含在字符类中</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/b3ad1286b802ae0515508dda20b112a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3X9AEtRz5M791nrOZNOCg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching two characters in range 0–9</figcaption></figure><p id="251c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符按数字索引排序——在 2019 年，数字索引几乎总是<a class="ae kf" href="https://en.wikipedia.org/wiki/List_of_Unicode_characters" rel="noopener ugc nofollow" target="_blank"> Unicode 索引</a>。如果您正在处理数字、拉丁字符和基本的标点符号，您可以查看 Unicode 的更小的历史子集:<a class="ae kf" href="http://www.asciitable.com/" rel="noopener ugc nofollow" target="_blank"> ASCII </a>。</p><p id="7a2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从 0 到 9 的数字通过码位顺序编码:<code class="fe mh mi mj mk b">0</code>的<code class="fe mh mi mj mk b">U+0030</code>到<code class="fe mh mi mj mk b">9</code>的码位<code class="fe mh mi mj mk b">U+0039</code>，所以<code class="fe mh mi mj mk b">[0–9]</code>的字符集是一个有效的范围。</p><p id="5374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拉丁字母的小写字母和大写字母也是连续编码的，所以字母字符的字符类也经常出现。以下字符集匹配任何小写拉丁字符:</p><p id="f23c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[a-z]</code></p><p id="7164" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在同一个字符类中定义多个范围。以下字符类匹配所有小写和大写拉丁字符:</p><p id="438a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[A-Za-z]</code></p><p id="c2f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会有这样的印象，上面的模式可以缩写为:</p><p id="4467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[A-z]</code></p><p id="5e62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个有效的字符类，但它不仅匹配 a-z 和 A-Z，还匹配 Z 和 A 之间定义的所有字符，如<code class="fe mh mi mj mk b">[</code>、<code class="fe mh mi mj mk b">\</code>和<code class="fe mh mi mj mk b">^</code>。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/1fddc643485e30ba9fb38dc45b5736f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-09HnIO6IoEN1z5PsRK2g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">the range A-z includes unexpected characters [ and ]</figcaption></figure><blockquote class="od oe of"><p id="c568" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">如果你正在气头上咒骂定义 ASCII 并引入这种令人难以置信的不连续性的人的愚蠢，请稍安勿躁。ASCII 是在计算能力比今天珍贵得多的时代定义的。</p><p id="e17c" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">看<code class="fe mh mi mj mk b">A hex: 0x41 bin: 0100 0001</code>和<em class="it"> </em> <code class="fe mh mi mj mk b"><em class="it">a hex: 0x61 bin: 0110 0001</em></code></p><p id="9537" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">你如何在大写和小写之间转换？你翻转<strong class="ki iu">一个</strong>位。整个字母表都是如此。ASCII 经过优化，可以简化大小写转换。定义 ASCII 的人考虑得非常周到。一些可取的品质不得不为其他品质而牺牲。不客气</p></blockquote><p id="e8dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能想知道如何将<code class="fe mh mi mj mk b">-</code>字符放入字符类。毕竟它是用来定义范围的。如果将<code class="fe mh mi mj mk b">-</code>字符放在类中的第一个或最后一个字符:<code class="fe mh mi mj mk b">[-+0–9]</code>或<code class="fe mh mi mj mk b">[+0–9-]</code>，大多数引擎会逐字解释该字符。一些引擎需要使用反斜杠<code class="fe mh mi mj mk b">[\-+0–9]</code>进行转义</p><h2 id="a1a7" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">否定</h2><p id="20b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有时定义一个匹配大多数字符的字符类是很有用的，除了一些定义的例外。如果字符类定义以<code class="fe mh mi mj mk b">^</code>开头，列出的字符集将被反转。例如，下面的类允许任何字符，只要它既不是数字也不是下划线。</p><p id="9374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[^0-9_]</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/8e82ede71a46945d44f874ec045d37cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tByYqkMhUCBXabiQsAuhwA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">looking for three consecutive non-digit and non-underscore characters</figcaption></figure><p id="86b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，如果<code class="fe mh mi mj mk b">^</code>字符不是类的第一个字符，它将被解释为文字，如在<code class="fe mh mi mj mk b">[f^o]</code>中，如果在字符类之外使用，它将是一个<a class="ae kf" href="#boundary-matchers" rel="noopener ugc nofollow">边界匹配器</a>。</p><h2 id="0eed" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">预定义的字符类</h2><p id="2d72" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有些字符类使用如此频繁，以至于为它们定义了速记符号。考虑角色类<code class="fe mh mi mj mk b">[0–9]</code>。它匹配任何数字字符，并且使用如此频繁，以至于有一个助记符号:<code class="fe mh mi mj mk b">\d</code>。</p><p id="3732" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的列表显示了具有最常见的速记符号的字符类，您使用的任何 regex 引擎都可能支持这些符号。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="75ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数引擎都提供了预定义字符类的完整列表，这些字符类与 Unicode 标准、标点符号、特定字母等的某些块或类别相匹配。这些额外的字符类通常特定于手边的引擎，并且不太容易移植。</p><h2 id="882d" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">点字符类</h2><p id="811e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最普遍的预定义字符类是点，它本身就值得拥有一小部分。它匹配任何字符，除了像<code class="fe mh mi mj mk b">\r</code>和<code class="fe mh mi mj mk b">\n</code>这样的行终止符。</p><p id="a876" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下模式匹配以小写 x 结尾的任意三个字符串:</p><p id="09fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">..x</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/b45522e7d6fbd82736c67b2358f6224f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mb-wKexWXT9Rzz-yQ9Lllg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">the dot matches anything except newline characters</figcaption></figure><p id="1738" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实践中，点通常用于创建模式中的“任何东西都可以放在这里”部分。它经常与一个量词<a class="ae kf" href="#quantifiers" rel="noopener ugc nofollow">结合使用</a>和<code class="fe mh mi mj mk b">.*</code>用于匹配“任何”或“无关”部分。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/0ba95b02503d609947bae478143dbeec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j24J--XlW4peIZCRkL-pdA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching anything between 1 and 2</figcaption></figure><p id="707b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，当在字符类中使用时，<code class="fe mh mi mj mk b">.</code>字符失去了它的特殊含义。字符类<code class="fe mh mi mj mk b">[.,]</code>只匹配两个字符，点和逗号。</p><p id="f6d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据您使用的正则表达式引擎，您可以设置<strong class="ki iu"> dotAll </strong> <a class="ae kf" href="#execution-flags" rel="noopener ugc nofollow">执行标志</a>，在这种情况下<code class="fe mh mi mj mk b">.</code>将匹配任何东西，包括行终止符。</p><h1 id="5762" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">边界匹配器</h1><p id="f9e1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">边界匹配器(也称为“锚点”)不匹配字符本身，而是匹配边界。如果你愿意，它们匹配字符之间的位置。最常见的主播有<code class="fe mh mi mj mk b">^</code>和<code class="fe mh mi mj mk b">$</code>。它们分别匹配一行的开始和结束。下表显示了最常支持的锚点。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="1510" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">锚定开始和结束</h2><p id="cea5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">考虑在多行文本中搜索数字的操作。模式<code class="fe mh mi mj mk b">[0–9]</code>查找文本中的每个数字，不管它位于哪里。模式<code class="fe mh mi mj mk b">^[0–9]</code>查找作为一行第一个字符的每个数字。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/021d61d1bd54461da749a8e5017349cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rY4q1UbMvW424zVjpwLQQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching digits at the beginning of a line</figcaption></figure><p id="8f81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的想法也适用于以<code class="fe mh mi mj mk b">$</code>结尾的行。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/9342e75f5b4528a0d3b4cea191314d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hP82WIRLQuav64jO8r_aPg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching digits at the end of a line</figcaption></figure><p id="86c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\A</code>和<code class="fe mh mi mj mk b">\Z</code> <em class="oa">或</em> <code class="fe mh mi mj mk b">\z</code>锚是匹配多行字符串的有用工具。它们锚定到整个输入的开头和结尾。大写的<code class="fe mh mi mj mk b">\Z</code>变体可以容忍尾随换行符，并且匹配之前的换行符，有效地丢弃匹配中的任何尾随换行符。</p><blockquote class="od oe of"><p id="9ecd" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">大多数主流 regex 引擎都支持\A 和\Z 锚，JavaScript 是个明显的例外。</p></blockquote><p id="3029" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设需求是检查一个文本是否是指定棋位的两行记录。输入字符串如下所示:</p><pre class="mm mn mo mp gt on mk oo op aw oq bi"><span id="b40c" class="nf lf it mk b gy or os l ot ou">Column: F<br/>Row: 7</span></pre><p id="6140" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下模式与上述结构相匹配:</p><p id="fb2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\AColumn: [A-H]\r?\nRow: [1-8]\Z</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/6eec83007f73cbd881df6f42d83de8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vh20E2SOawPrG1SaYOv6rg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Using /A and /Z to anchor to beginning and end of input</figcaption></figure><h2 id="77e6" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">全字匹配</h2><p id="bf47" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">\b</code>锚匹配任何字母数字序列的边缘。如果您想进行“全字”匹配，这是很有用的。下面的模式寻找一个独立的大写字母<code class="fe mh mi mj mk b">I</code>。</p><p id="d4c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\bI\b</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/9e88aadb662dacad12de368fca6e0582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqgO53z7bVI80trJ2dsgcg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">the \b anchor matches on transitions between “words”</figcaption></figure><p id="7b26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模式与<code class="fe mh mi mj mk b">Illinois</code>的第一个字母不匹配，因为右边没有单词边界。下一个字母是单词字母——由字符类<code class="fe mh mi mj mk b">\w</code>定义为<code class="fe mh mi mj mk b">[a-zA-Z0–9_]</code>——而不是非单词字母，这将构成一个边界。</p><p id="aee7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们把<code class="fe mh mi mj mk b">Illinois</code>换成<code class="fe mh mi mj mk b">I!linois</code>吧。感叹号不是单词字符，因此构成了边界。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/ea15af0968a410e8999d1f4e19614ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKXrH9Ujh8zQ7Jp4VGBV4w.png"/></div></div></figure><h2 id="f1f1" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">杂项锚</h2><p id="938b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有点深奥的非字界<code class="fe mh mi mj mk b">\B</code>是对<code class="fe mh mi mj mk b">\b</code>的否定。匹配任何<code class="fe mh mi mj mk b">\b</code>不匹配的位置。它匹配空格内字符<em class="oa">和字母数字序列之间的每个位置。</em></p><p id="ad28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些正则表达式引擎支持<code class="fe mh mi mj mk b">\G</code>边界匹配器。这在以编程方式使用正则表达式时很有用，一个模式被重复应用于一个字符串，试图在一个循环中找到所有匹配<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/anchors-in-regular-expressions#contiguous-matches-g" rel="noopener ugc nofollow" target="_blank">的模式。它锚定到找到的最后一个匹配的位置。</a></p><h1 id="daaf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">量词</h1><p id="8560" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">任何文字或字符组只匹配一个字符。模式<code class="fe mh mi mj mk b">[0–9][0–9]</code>正好匹配两位数字。量词有助于指定模式的预期匹配数。它们用花括号表示。以下等同于<code class="fe mh mi mj mk b">[0–9][0–9]</code></p><p id="a945" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[0-9]{2}</code></p><p id="f46c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本符号可以扩展到提供上限和下限。说是需要匹配二到六位数。确切的数字各不相同，但必须在 2 到 6 之间。下面的符号做到了这一点:</p><p id="7aed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[0-9]{2,6}</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/424c35e5f6df93b58a8d19e90df2a7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4umtRGpikeFJuSwX91NVg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">sequences of 2–6 digits are matched</figcaption></figure><p id="3861" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上限是可选的，如果省略，则等于或大于下限的任何出现次数都是可接受的。以下示例匹配两个或更多连续数字。</p><p id="0f6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">[0-9]{2,}</code></p><p id="1fea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于实践中经常使用的常用量词，有一些预定义的缩写。</p><h2 id="2672" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">那个？数量词</h2><p id="6775" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">?</code>量词相当于<code class="fe mh mi mj mk b">{0, 1}</code>，表示:可选单次出现。前面的模式可能不匹配，或者匹配一次。</p><p id="8ef5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们寻找整数，可选地以加号或减号为前缀:<code class="fe mh mi mj mk b">[-+]?\d{1,}</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/df4c39358a4358d05ea6dc574c544372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3DhaPFAxh3_efWbzKG0A9w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">finding integers with optional sign</figcaption></figure><h2 id="f8d7" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">+量词</h2><p id="9d7f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">量词<code class="fe mh mi mj mk b">+</code>相当于<code class="fe mh mi mj mk b">{1,}</code>，意思是:至少出现一次。</p><p id="0492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过用<code class="fe mh mi mj mk b">+</code>替换<code class="fe mh mi mj mk b">{1,}</code>来修改上面的整数匹配模式，使其更加符合习惯，我们得到:<code class="fe mh mi mj mk b">[-+]?\d+</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/27aa65c82376b00eeceaa1d2b81692e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sB4s8nLwGSjitT-qh0VHeA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">finding integers with optional sign again</figcaption></figure><h2 id="3605" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">量词*</h2><p id="01f7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">*</code>量词相当于<code class="fe mh mi mj mk b">{0,}</code>，意思是:零次或多次出现。你会经常看到它与点号连用为<code class="fe mh mi mj mk b">.*</code>，意思是:任何字符都不在乎多频繁。</p><p id="3194" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们匹配一个逗号分隔的整数列表。条目之间不允许有空格，并且必须至少有一个整数:<code class="fe mh mi mj mk b">\d+(,\d+)*</code></p><p id="5000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们匹配的是一个整数，后跟任意数量的包含一个逗号和一个整数的组。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/e9a22d3ca0c5a6951407f7a433837210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AAu-Pba_Ds6pSuFlhm6SQ.png"/></div></div></figure><h2 id="3a31" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">默认贪婪</h2><p id="4d74" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">假设需求是匹配捕获组中 http URL 的域部分。以下似乎是一个好主意:匹配协议，然后捕获域，然后是可选路径。这个想法大致可以解释为:</p><p id="c86c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/(.*)/?.*">http://(.*)/?</a></code></p><blockquote class="od oe of"><p id="17ce" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">如果你使用的引擎使用像 JavaScript 这样的<code class="fe mh mi mj mk b">/regex/</code>符号，你必须避开正斜杠:<code class="fe mh mi mj mk b"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/(.*)/?.*">http:\/\/(.*)\/?.*</a></code></p></blockquote><p id="7dae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它匹配协议，捕获协议之后的域，并允许一个可选的斜杠和其后的一些任意文本，这将是资源路径。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/b7cca792018b6065b804dbdb47279837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vn1LlR6P1_PkyJQXjVTEQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">greedy capture matches too much</figcaption></figure><p id="30b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">奇怪的是，给定一些输入字符串，该组捕获到以下内容:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">unexpected portion of url captured by group</figcaption></figure><p id="1c69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果有些令人惊讶，因为该模式被设计为仅捕获域部分，但它似乎捕获了 URL 末尾之前的所有内容。</p><p id="8412" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发生这种情况是因为模式中遇到的每个量词都试图匹配尽可能多的字符串。量词因此被称为<strong class="ki iu">贪心</strong>。</p><p id="80b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查一下:<code class="fe mh mi mj mk b"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/(.*)/?.*">http://(.*)/?.*</a></code>的匹配行为</p><p id="0810" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">捕获组中的贪心<code class="fe mh mi mj mk b">*</code>是第一个遇到的量词。它所应用的<code class="fe mh mi mj mk b">.</code>字符类匹配任何字符，所以量词扩展到字符串的末尾。因此捕获组捕获了一切。但是等等，你会说，结尾还有<code class="fe mh mi mj mk b">/?.*</code>的部分。嗯，是的，它和字符串的剩余部分完全匹配——什么也没有，也就是空字符串。斜杠是可选的，后跟零个或多个字符。空字符串符合。整个模式完全吻合。</p><h2 id="78dc" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">贪婪匹配的替代方案</h2><p id="c412" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">贪婪是量词的默认用法，但不是唯一的用法。每个量词都有一个<strong class="ki iu">不情愿的</strong>版本，它匹配<strong class="ki iu">最少</strong>可能数量的字符。量词的贪婪版本通过追加一个<strong class="ki iu">被转换成不情愿的版本？</strong>交给他们。</p><p id="32af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下表给出了所有量词的符号。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="483b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量化器<code class="fe mh mi mj mk b">{n}</code>在贪婪和勉强两种版本中是等价的。对于其他字符，匹配字符的数量可能会有所不同。让我们重新看看上面的例子，改变捕获组以尽可能少地匹配，希望能正确捕获域名。</p><p id="aa29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/(.*?)/?.*">http://(.*?)/?.*</a></code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/ee467b384b2c5e40f9f64ba43de8ed53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UF84hEao2eeSiOYVPeofEw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">capturing empty strings with reluctant quantifiers</figcaption></figure><p id="e2b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种模式，组不会捕获任何东西，更准确地说是空字符串。这是为什么呢？捕获组现在尽可能少地捕获:什么也不捕获。<code class="fe mh mi mj mk b">(.*?)</code>什么也没捕捉到，<code class="fe mh mi mj mk b">/?</code>什么也没匹配，而<code class="fe mh mi mj mk b">.*</code>匹配字符串剩余的全部内容。因此，这种模式并没有像预期的那样工作。</p><p id="1393" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，捕获组匹配太少或太多。让我们回到贪婪量词，但不允许在域名中使用斜杠字符，还要求域名至少有一个字符长。</p><p id="2435" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">http://([^/]+)/?.*</code></p><p id="f5c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式贪婪地捕捉协议后面的一个或多个非斜杠字符作为域，如果最后出现任何可选的斜杠，它后面可能会跟有路径中的任意数量的字符。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/de5b7ae9e0709b4829d512117be2ad85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ov25rq3Ge3CHeMKaoY6ePg.png"/></div></div></figure><h2 id="307d" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">量化器性能</h2><p id="66fd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">贪婪量词和勉强量词都意味着一些运行时开销。如果只有几个这样的量词，就没有问题。但是，如果多个嵌套组都被量化为贪婪或勉强，那么确定最长或最短的可能匹配是一个重要的操作，这意味着在输入字符串上来回运行，调整每个量词匹配的长度，以确定表达式作为一个整体是否匹配。</p><p id="eedf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能出现<a class="ae kf" href="https://www.regular-expressions.info/catastrophic.html" rel="noopener ugc nofollow" target="_blank">灾难性回溯</a>的病理情况。如果担心性能或恶意输入，最好选择不情愿的量词，并看看第三种量词:所有格量词。</p><h2 id="b5aa" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">所有格量词:永不回馈</h2><p id="a50e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果您的引擎支持，所有格量词的行为很像贪婪量词，区别在于它们不支持回溯。他们试图匹配尽可能多的字符，一旦他们这样做了，他们永远不会产生任何匹配的字符来适应模式的任何其他部分的可能匹配。</p><p id="9b25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们通过在基本贪婪量词后面追加一个<code class="fe mh mi mj mk b">+</code>来表示。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1a9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们是“类贪婪”量词的快速执行版本，这使它们成为对性能敏感的操作的良好选择。</p><p id="928a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在 PHP 引擎中看看它们。首先，我们来看看简单的贪婪匹配。让我们匹配一些数字，后面跟着一个九:<code class="fe mh mi mj mk b">([0–9]+)9</code></p><p id="0257" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">针对输入字符串进行匹配:<code class="fe mh mi mj mk b">123456789</code>贪婪量词会首先匹配整个输入，然后返回<code class="fe mh mi mj mk b">9</code>，这样剩下的模式就有机会匹配了。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/a9be1807ac7518ed60839c125c2c5995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqKph_QLcCXtz30-mCblcw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">greedy match</figcaption></figure><p id="68f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们用所有格量词替换贪婪时，它将匹配整个输入，然后拒绝返回<code class="fe mh mi mj mk b">9</code>以避免回溯，这将导致整个模式根本不匹配。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/6da75e614cf3c30a463aee0d7b4d314b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlS07_GkcaATDvtLt7Yp7w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">possessive quantifer causing a non-match</figcaption></figure><p id="459e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">什么时候你会想要占有欲行为？当你知道你总是想要尽可能长的比赛。</p><p id="34ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您想要提取文件系统路径的文件名部分。假设<code class="fe mh mi mj mk b">/</code>为路径分隔符。那么我们实际上想要的是最后一次出现<code class="fe mh mi mj mk b">/</code>之后的字符串的最后一位。</p><p id="f627" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有格模式在这里工作得很好，因为我们总是希望在获取文件名之前使用所有的文件夹名。使用文件夹名的模式部分不需要归还字符。相应的模式可能如下所示:</p><p id="e30f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\/?(?:[^\/]+\/)++(.*)</code></p><blockquote class="od oe of"><p id="3627" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">注意:这里使用 PHP <code class="fe mh mi mj mk b">/regex/</code>符号，所以正斜杠被转义。</p></blockquote><p id="b5ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望允许绝对路径，所以我们允许输入以可选的正斜杠开始。然后，我们使用由一系列非斜杠字符后跟一个斜杠组成的文件夹名。为此，我使用了一个<a class="ae kf" href="#non-capturing-group" rel="noopener ugc nofollow">非捕获组</a>——因此它被标记为<code class="fe mh mi mj mk b">(?:pattern)</code>，而不仅仅是<code class="fe mh mi mj mk b">(pattern)</code>。最后一个斜杠之后剩下的任何内容都是我们捕获到一个组中进行提取的内容。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/c63a4e76284c95812c01aa5dec0497c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iV4GKHeCnBhrNrkIjp-pog.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">example of posessive matching</figcaption></figure><h1 id="9b01" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">非捕获组</h1><p id="69aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">非捕获组与正常组完全匹配。但是，它们不提供匹配的内容。如果不需要捕获内容，它们可以用来提高匹配性能。非捕获组写为:<code class="fe mh mi mj mk b">(?:pattern)</code></p><p id="8624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想验证一个十六进制字符串是有效的。它需要由偶数个十六进制数字组成，每个数字在<code class="fe mh mi mj mk b">0–9</code>或<code class="fe mh mi mj mk b">a-f</code>之间。以下表达式使用组来完成这项工作:</p><p id="83a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">([0-9a-f][0-9a-f])+</code></p><p id="74cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于该组在模式中的作用是确保数字成对出现，并且实际匹配的数字没有任何相关性，因此该组也可以用更快执行的非捕获组来替换:</p><p id="a543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">(?:[0-9a-f][0-9a-f])+</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/4a5dccc17eddb6e2c35e16612057941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNFkMW-1Gb-X4CvShvXznw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching sequences of hex bytes</figcaption></figure><h2 id="9f8c" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">原子团</h2><p id="875a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">还有一个非捕获组的快速执行版本，它不支持回溯。它被称为“独立非捕获群”或“原子群”。</p><p id="34b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它被写成<code class="fe mh mi mj mk b">(?&gt;pattern)</code></p><p id="d6a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原子组是非捕获组，可用于优化模式匹配速度。通常，它由 regex 引擎支持，这些引擎也支持所有格量词。</p><p id="2aaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的行为也类似于所有格量词:一旦一个原子组匹配了字符串的一部分，第一个匹配就是永久的。这个群体永远不会试图以另一种方式重新匹配，以适应模式的其他部分。</p><p id="3837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">a(?&gt;bc|b)c</code>匹配<code class="fe mh mi mj mk b">abcc</code>但不匹配<code class="fe mh mi mj mk b">abc</code>。</p><p id="d091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原子组的第一场成功比赛在<code class="fe mh mi mj mk b">bc</code>进行，并且一直保持下去。正常组将在回溯期间重新匹配，以适应模式末尾的<code class="fe mh mi mj mk b">c</code>,从而成功匹配。但是原子组的第一场比赛是永久的，不会改变。</p><p id="2dd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您希望尽可能快地匹配，并且不希望发生任何回溯，这是非常有用的。</p><p id="d87f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们匹配路径的文件名部分。我们可以匹配任何字符的原子组，后跟一个斜杠。然后捕获其余部分:</p><p id="93b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">(?&gt;.*\/)(.*)</code></p><blockquote class="od oe of"><p id="ce48" class="kg kh oa ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">注意:这里使用 PHP <code class="fe mh mi mj mk b"><em class="it">/regex/</em></code>符号，所以正斜杠被转义。</p></blockquote><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/2eff23cb2bc37e86c3a68bc4134ecbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3sV5YpgWTbdIcdowdu4kA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">atomic group matching</figcaption></figure><p id="740d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个普通的团队同样可以完成这项工作，但是消除回溯的可能性可以提高性能。如果您将数百万个输入与非平凡的正则表达式模式进行匹配，您将开始注意到差异。</p><p id="7521" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还通过触发<a class="ae kf" href="https://www.regular-expressions.info/catastrophic.html" rel="noopener ugc nofollow" target="_blank">灾难性回溯</a>场景，提高了抵御旨在 DoS 攻击服务的恶意输入的弹性。</p><h1 id="039e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反向引用</h1><p id="3222" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有时引用字符串中较早匹配的内容很有用。假设一个字符串值只有以相同的字母开头和结尾才有效。单词“alpha”、“radar”、“kick”、“level”和“stars”就是例子。可以在一个组中捕获字符串的一部分，然后在模式 pattern 中引用该组:反向引用。</p><p id="1b01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">regex 模式中的反向引用使用<code class="fe mh mi mj mk b">\n</code>语法来表示，其中<code class="fe mh mi mj mk b">n</code>是捕获组的编号。编号从左到右，从 1 开始。如果组是嵌套的，它们按照遇到左括号的顺序编号。组 0 始终表示整个表达式。</p><p id="ce0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下模式匹配至少包含 3 个字符且以相同字母开头和结尾的输入:</p><p id="2540" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">([a-zA-Z]).+\1</code></p><p id="a0ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说:小写或大写字母——该字母被捕获到一个组中——后跟任何非空字符串，再跟我们在匹配开始时捕获的字母。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/a5afc44ab7b105b4f8698a6d2474c6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmq2km_LOf3gV3zevfl_6w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">on-letter back references</figcaption></figure><p id="8604" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们扩展一下。如果一个输入字符串不止一次地包含任何字母数字序列，那么它就是匹配的。单词边界用于确保匹配整个单词。</p><p id="fb50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\b(\w+)\b.*\b\1\b</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/b8bdba93efd744ca6ed544e9d9b276ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RSMpCCvNHI7Qbct7fCmxg.png"/></div></div></figure><h2 id="9772" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">搜索并替换为反向引用</h2><p id="065f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正则表达式在搜索和替换操作中很有用。典型的用例是寻找与模式匹配的子字符串，并用其他内容替换它。大多数使用正则表达式的 API 允许您在替换字符串中引用搜索模式中的捕获组。</p><p id="3de2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些反向引用有效地允许重新排列部分输入字符串。</p><p id="48e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下场景:输入字符串包含一个 A-Z 字符前缀，后跟一个可选空格，后跟一个 3–6 位数。像<code class="fe mh mi mj mk b">A321</code>、<code class="fe mh mi mj mk b">B86562</code>、<code class="fe mh mi mj mk b">F 8753</code>和<code class="fe mh mi mj mk b">L 287</code>这样的琴弦。</p><p id="eb00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任务是将其转换为另一个字符串，该字符串由数字、破折号和字符前缀组成。</p><pre class="mm mn mo mp gt on mk oo op aw oq bi"><span id="916e" class="nf lf it mk b gy or os l ot ou"><strong class="mk iu">Input</strong>   <strong class="mk iu">Output<br/></strong>A321    321-A<br/>B86562  86562-B<br/>F 8753  8753-F<br/>L 287   287-L</span></pre><p id="e690" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将一个字符串转换为另一个字符串的第一步是在捕获组中捕获字符串的每个部分。搜索模式如下所示:</p><p id="59f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">([A-Z])\s?([0-9]{3,6})</code></p><p id="bc51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将前缀捕获到一个组中，允许一个可选的空格字符，然后将数字捕获到第二个组中。替换字符串中的反向引用使用<code class="fe mh mi mj mk b">$n</code>语法表示，其中<code class="fe mh mi mj mk b">n</code>是捕获组的编号。此操作的替换字符串应该首先引用包含数字的组，然后引用文字破折号，然后引用包含字母前缀的第一个组。这将给出以下替换字符串:</p><p id="c269" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">$2-$1</code></p><p id="adcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此<code class="fe mh mi mj mk b">A321</code>与搜索模式匹配，将<code class="fe mh mi mj mk b">A</code>放入<code class="fe mh mi mj mk b">$1</code>并将<code class="fe mh mi mj mk b">312</code>放入<code class="fe mh mi mj mk b">$2</code>。替换字符串的排列产生了预期的结果:首先是数字，然后是破折号，最后是字母前缀。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/49e7c7a9c6171c9893f0da3801c33669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwioUb7Ip1wml7EZIj6L8w.png"/></div></div></figure><p id="1e9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，由于<code class="fe mh mi mj mk b">$</code>字符在替换字符串中具有特殊的含义，如果要作为字符插入，必须将其转义为<code class="fe mh mi mj mk b">$$</code>。</p><p id="9403" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种支持正则表达式的搜索和替换通常由文本编辑器提供。假设您在编辑器中有一个路径列表，手头的任务是在每个文件的文件名前面加一个下划线。路径<code class="fe mh mi mj mk b">/foo/bar/file.txt</code>应该变成<code class="fe mh mi mj mk b">/foo/bar/_file.txt</code></p><p id="fd5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我们目前所学，我们可以这样做:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/bc41f7740ed22332e05c470497396e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2HdN1eq9X6UcmnDKtNOjMg.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">example regex-enabled search and replace in VS Code</figcaption></figure><h1 id="57a6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">看，但不要碰:向前看和向后看</h1><p id="7666" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有时断言一个字符串具有某种结构是有用的，而不需要实际匹配它。这有什么用？</p><p id="0ff5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们编写一个模式，匹配后面跟有以<code class="fe mh mi mj mk b">a</code>开头的单词的所有单词</p><p id="dd03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试试<code class="fe mh mi mj mk b">\b(\w+)\s+a</code>它锚定到一个单词边界，并匹配单词字符，直到它看到一些空格后跟一个 a。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/2bbfa0202d03b55b6c4adacf634f9fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DIrV3NsjJ_9iJ153-57LQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">first attempt at matching words that are followed by words beginning with an a</figcaption></figure><p id="4f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们匹配了<code class="fe mh mi mj mk b">love</code>、<code class="fe mh mi mj mk b">swat</code>、<code class="fe mh mi mj mk b">fly</code>和<code class="fe mh mi mj mk b">to</code>，但是没有捕捉到<code class="fe mh mi mj mk b">ant</code>之前的<code class="fe mh mi mj mk b">an</code>。这是因为<code class="fe mh mi mj mk b">a</code>出发<code class="fe mh mi mj mk b">an</code>已经作为<code class="fe mh mi mj mk b">to</code>比赛的一部分被消耗掉了。我们已经扫描过那个<code class="fe mh mi mj mk b">a</code>，单词<code class="fe mh mi mj mk b">an</code>没有匹配的机会。</p><p id="d3d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有一种方法可以断言下一个单词的第一个字符的属性，而不实际消耗它，那将是非常好的。</p><p id="7fb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">断言存在但不消耗输入的构造称为“前视”和“后视”。</p><h2 id="56b2" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">向前看</h2><p id="bd82" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Lookaheads 用于断言模式在前面匹配。它们被写成<code class="fe mh mi mj mk b">(?=pattern)</code></p><p id="c625" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用它来修正我们的模式:</p><p id="c6f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\b(\w+)(?=\s+a)</code></p><p id="4acb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经将下一个单词的空格和首字母<code class="fe mh mi mj mk b">a</code>放入一个 lookahead 中，所以当扫描一个字符串进行匹配时，它们会被检查但不会被消耗。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/a67708e79fea508e32357bfe99c6c1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvEXd5B8oXb2G-pkzJEzvg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">look ahead asserts a pattern matches ahead, but does not consume it</figcaption></figure><p id="87f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">负的前瞻断言其模式不匹配前瞻。表示为<code class="fe mh mi mj mk b">(?!pattern)</code></p><p id="1fb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们找出后面没有以<code class="fe mh mi mj mk b">a</code>开头的单词的所有单词。</p><p id="cbcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">\b(\w+)\b(?!\s+a)</code></p><p id="d23f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们匹配后面没有空格和一个<code class="fe mh mi mj mk b">a</code>的整个单词。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/c44ef292b1b4259fa18b88cb3bf35ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ij35h4_6DhvDXMuP-_kuQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">negative look ahead asserts that its pattern does not match ahead</figcaption></figure><h2 id="7695" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">向后看</h2><p id="115f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">lookbehind 的作用与 lookahead 相同，但它适用于当前位置的左侧，而不是右侧。许多正则表达式引擎限制了可以在 look back 中使用的模式类型，因为向后应用模式不是它们所优化的。检查你的文件！</p><p id="d694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回顾被写成<code class="fe mh mi mj mk b">(?&lt;=pattern)</code></p><p id="167e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它断言在当前位置之前存在某个东西。让我们找出以<code class="fe mh mi mj mk b">r</code>或<code class="fe mh mi mj mk b">t</code>结尾的单词之后的所有单词。</p><p id="e932" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">(?&lt;=[rt]\s)(\w+)</code></p><p id="9836" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们断言有一个<code class="fe mh mi mj mk b">r</code>或<code class="fe mh mi mj mk b">t</code>后跟一个空格，然后我们捕获后面的单词字符序列。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/7b43ae91ed30cf135c6ea4db201f1d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-MiFHwOk5PLs0UsLo-A1A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">a lookbehind to capture certain words</figcaption></figure><p id="021d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一种消极的观点认为左边的模式不存在。它被写成<code class="fe mh mi mj mk b">(?&lt;!pattern)</code></p><p id="819d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们颠倒一下找到的单词:我们想要匹配不是以<code class="fe mh mi mj mk b">r</code>或<code class="fe mh mi mj mk b">t</code>结尾的单词之后的所有单词。</p><p id="cdf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">(?&lt;![rt]\s)\b(\w+)</code></p><p id="e883" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过<code class="fe mh mi mj mk b">\b(\w+)</code>匹配所有单词，并且通过在前面加上<code class="fe mh mi mj mk b">(?&lt;![rt]\s)</code>来确保我们匹配的任何单词前面没有以<code class="fe mh mi mj mk b">r</code>或<code class="fe mh mi mj mk b">t</code>结尾的单词。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/92bfab2d5761ef3920b2525f5cb4b592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1eRFcCOnZynsD7G041T4A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">matching with a negative lookbehind</figcaption></figure><h2 id="3555" class="nf lf it bd lg ng nh dn lk ni nj dp lo kr nk nl ls kv nm nn lw kz no np ma nq bi translated">分裂模式</h2><p id="8ac2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果您正在使用一个允许您按模式分割字符串的 API，记住前视和后视通常是有用的。</p><p id="dec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正则表达式拆分通常使用模式作为分隔符，并从部分中删除分隔符。将 lookahead 或 look ahead 部分放在一个定界符中可以使它匹配，而不会删除仅仅被查看过的部分。</p><p id="827b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你有一个由<code class="fe mh mi mj mk b">:</code>分隔的字符串，其中有些部分是由字母字符组成的标签，有些是格式为<code class="fe mh mi mj mk b">HH:mm</code>的时间戳。</p><p id="f444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看输入字符串<code class="fe mh mi mj mk b">time_a:9:23:time_b:10:11</code></p><p id="e914" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只是在<code class="fe mh mi mj mk b">:</code>分裂，我们得到部分:<code class="fe mh mi mj mk b"> [time_a, 9, 32, time_b, 10, 11]</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/7adbb55eb1c409f85ff900b91e5351ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*bpNK1PYlXbd0jkcRjGlCvQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">splitting on delimiter</figcaption></figure><p id="f0d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想通过分裂来提高，只要<code class="fe mh mi mj mk b">:</code>两边都有字母。分隔符现在是<code class="fe mh mi mj mk b">[a-z]:|:[a-z]</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/5bd22209281398a18e4127ca49c8b181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*tPGFpz2xqqkaC5KefRQMBw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">including adjacent letters in the match treats them as part of the delimiter</figcaption></figure><p id="c6bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到部分:<code class="fe mh mi mj mk b"> [time_, 9:32, ime_, 10:11]</code>我们丢失了相邻的字符，因为它们是分隔符的一部分。</p><p id="bf2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们细化分隔符，对相邻字符使用 lookahead 和 look ahead，它们的存在将被验证，但它们不会作为分隔符的一部分匹配:<code class="fe mh mi mj mk b">(?&lt;[a-z]):|:(?=[a-z])</code></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/36c833b1fc42a992d1bb1b8cfb0a4259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*pAorPhRzksREjpyPvaBBAQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">putting the characters into lookbehind and lookahead does not consume them</figcaption></figure><p id="b167" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后我们得到我们想要的零件:<code class="fe mh mi mj mk b">[time_a, 9:32, time_b, 10:11]</code></p><h1 id="416c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式修饰符</h1><p id="495b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">大多数正则表达式引擎允许设置标志或修饰符来调整模式匹配过程的各个方面。一定要熟悉你选择的引擎处理这种修饰语的方式。</p><p id="6743" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们经常在不切实际的复杂模式和繁琐的模式之间做出区别。</p><p id="4733" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会发现区分大小写的修饰符、锚定选项、完全匹配和部分匹配模式，以及一个 dotAll 模式，该模式允许<code class="fe mh mi mj mk b">.</code>字符类匹配任何内容，包括行终止符。</p><p id="3951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" rel="noopener ugc nofollow" target="_blank"> JavaScript，</a> <a class="ae kf" href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="noopener ugc nofollow" target="_blank"> Python </a>，<a class="ae kf" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html" rel="noopener ugc nofollow" target="_blank"> Java，</a> <a class="ae kf" href="https://ruby-doc.org/core-2.4.1/Regexp.html" rel="noopener ugc nofollow" target="_blank"> Ruby，</a> <a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference#regular-expression-options" rel="noopener ugc nofollow" target="_blank">。网</a></p><p id="7675" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，让我们看看 JavaScript。如果您想要不区分大小写的模式，并且只找到第一个匹配，您可以使用<code class="fe mh mi mj mk b">i</code>修饰符，并确保省略<code class="fe mh mi mj mk b">g</code>修饰符。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/f7c6ad0304bc4db18308894bd9b39514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffwA8QSYMZR1PBBZ07htQQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">case insensitive match, with only the first match found</figcaption></figure><h1 id="9e84" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式的限制</h1><p id="4adf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">阅读完本文后，您可能会觉得一旦掌握了正则表达式，所有可能的字符串解析问题都可以解决了。</p><p id="4d77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，没有。</p><p id="2e63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文介绍正则表达式作为字符串集合的速记符号。如果您恰好有邮政编码的精确正则表达式，那么您就有一个表示有效邮政编码的所有字符串集合的简写符号。您可以很容易地测试一个输入字符串，以检查它是否是该集合中的一个元素。然而有一个问题。</p><blockquote class="pi"><p id="36b2" class="pj pk it bd pl pm pn po pp pq pr ld dk translated">有许多有意义的字符串集合没有正则表达式！</p></blockquote><p id="39b4" class="pw-post-body-paragraph kg kh it ki b kj ps kl km kn pt kp kq kr pu kt ku kv pv kx ky kz pw lb lc ld im bi translated">例如，有效的 JavaScript 程序没有正则表达式。永远不会有正则表达式模式可以检查 JavaScript 源代码的语法是否正确。</p><p id="95b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这主要是因为 regex 天生无法处理任意深度的嵌套结构。正则表达式本质上是非递归的。XML 和 JSON 是嵌套结构，很多编程语言的源代码也是。回文是另一个例子——单词前后读起来一样，像<em class="oa">race car——</em>是嵌套结构的一种非常简单的形式。每个字符打开或关闭一个嵌套层次。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi px"><img src="../Images/a4c3dca215115af21961ba7beaa26a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5rXe_WZ9C4WDzr_a"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">If yor input can arbitrarily nest like JavaScript, you can’t validate it with Regular Expressions alone. Photo by <a class="ae kf" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Robin Ebbinghaus</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f781" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以构造匹配特定深度的嵌套结构的模式，但是您不能编写匹配任意深度嵌套的模式。</p><p id="e95e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嵌套结构经常被证明是不规则的 T4。如果你对计算理论和语言分类感兴趣——也就是说，对字符串集感兴趣——可以浏览一下<a class="ae kf" href="https://en.wikipedia.org/wiki/Chomsky_hierarchy" rel="noopener ugc nofollow" target="_blank">乔姆斯基的 Hiararchy </a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Formal_grammar" rel="noopener ugc nofollow" target="_blank">形式语法</a>和<a class="ae kf" href="https://en.wikipedia.org/wiki/Formal_language" rel="noopener ugc nofollow" target="_blank">形式语言</a>。</p><h1 id="74cd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">知道何时去拿不同的锤子</h1><p id="ba08" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最后，让我提出一点警告。我有时会看到有人试图将正则表达式不仅用于词法分析(从字符串中识别和提取标记)，还用于语义分析，试图解释和验证每个标记的含义。</p><p id="a57c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然词法分析是正则表达式的一个非常有效的用例，但是尝试语义验证往往会导致产生另一个问题。</p><blockquote class="pi"><p id="6d0c" class="pj pk it bd pl pm pn po pp pq pr ld dk translated">“regex”的复数形式是“后悔”</p></blockquote><p id="d20a" class="pw-post-body-paragraph kg kh it ki b kj ps kl km kn pt kp kq kr pu kt ku kv pv kx ky kz pw lb lc ld im bi translated">我举个例子说明一下。</p><p id="85c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设一个字符串应该是十进制记法中的 IPv4 地址，用点分隔数字。正则表达式应该验证输入字符串确实是 IPv4 地址。第一次尝试可能是这样的:</p><p id="705f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})</code></p><p id="cf80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它匹配由点分隔的四组一到三位数。一些读者可能会觉得这种模式有所欠缺。例如，它与<code class="fe mh mi mj mk b">111.222.333.444</code>匹配，这不是有效的 IP 地址。</p><p id="fdab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你现在迫切想改变模式，让它测试每组数字的编码数字在 0 到 255 之间——可能有前导零——那么你正在制造第二个问题，并后悔。</p><p id="874b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尝试这样做将从词法分析(识别四组数字)引向语义分析，验证数字组是否转化为可接受的数字。</p><p id="7ad9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这产生了一个更加复杂的正则表达式，这里的例子可以在<a class="ae kf" href="https://www.regular-expressions.info/ip.html" rel="noopener ugc nofollow" target="_blank">找到</a>。我建议通过使用 regex 模式捕获每组数字来解决这样的问题，然后将捕获的项目转换为整数，并在单独的逻辑步骤中验证它们的范围。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi py"><img src="../Images/70a68e8a9416397c8b9af05c938eb878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yQMbA_vzrxsdOYNB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Use regular expressions — like all your tools — wisely. Photo by <a class="ae kf" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Todd Quackenbush</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9d94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用正则表达式时，复杂性、可维护性、性能和正确性之间的权衡应该是一个有意识的决定。毕竟，正则表达式模式是计算语法所能达到的“只写”模式。正确读取正则表达式模式都很难，更不用说调试和扩展了。</p><p id="1871" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的建议是将它们作为一个强大的字符串处理工具，但不要高估它们的可能性，也不要高估人类处理它们的能力。</p><p id="d595" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有疑问，考虑去拿盒子里的另一把锤子。</p></div></div>    
</body>
</html>