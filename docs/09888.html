<html>
<head>
<title>Computer Vision — Auto grading Handwritten Mathematical Answersheets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉—手写数学答题卡的自动评分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computer-vision-auto-grading-handwritten-mathematical-answersheets-8974744f72dd?source=collection_archive---------12-----------------------#2019-12-27">https://towardsdatascience.com/computer-vision-auto-grading-handwritten-mathematical-answersheets-8974744f72dd?source=collection_archive---------12-----------------------#2019-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f080" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 python 自动校正和评分数学工作表的计算机视觉模型。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92c0a1d124fda53229360188a8e47b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jrITj0AOB6zaep8M"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@jeswinthomas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeswin Thomas</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">阅读是教育的一个重要部分。手动评估每份答卷，提供公平、公正和有效的分数在大多数情况下是困难的。这篇文章是关于我和我的导师<a class="me mf ep" href="https://medium.com/u/9adb8b8d7e98?source=post_page-----8974744f72dd--------------------------------" rel="noopener" target="_blank">比乔恩·古哈</a>的实习项目，建立一个计算机视觉模型，它将自动评估答案纸，从而确保分数完全基于学生的表现。</p><h1 id="fb79" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">概观</h1><p id="596c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">下面是我们将要检查和评分的样本工作表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ef371835db3a19cdf3640088d2d9f580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdJxmKN3v30yYhh8RuuJLA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Sample Worksheets</figcaption></figure><p id="859c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每张工作表都是由不同的人写的。线宽、同页字体、笔尖宽度、字符间距等都会有变化。</p><blockquote class="ne nf ng"><p id="a0cc" class="kz la nh lb b lc ld ju le lf lg jx lh ni lj lk ll nj ln lo lp nk lr ls lt lu im bi translated">这个想法是纠正工作表中的每一行，并用方框标记这些行。其中绿框表示线正确，红框表示线不正确。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/6acc38ffca307975115744906877c7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZPK8tO_iBcO4K-cd9AZUQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Sample Output</figcaption></figure><p id="2f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(注意:我没有在这里添加所有代码，如果你想检查你可以访问我的<a class="ae ky" href="https://github.com/divyaprabha123/Autograding-handwritten-mathematical-worksheets/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub </strong> </a>在那里我有一个 ipynb 笔记本的教程)</p><h1 id="f428" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">工作流程</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/ad3852d50d8700d9c046c3ff7e88be42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyj62oJ9xe5cChA2UeCmOw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Workflow diagram</figcaption></figure><p id="321e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作流程中有两个模块<strong class="lb iu">工作空间检测</strong>模块<strong class="lb iu">和</strong>分析模块。工作空间检测模块负责检测给定纸张中的多个工作空间。</p><p id="4f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析模块负责在任何给定的单个工作空间中检测和定位行中的字符，并对它们进行数学分析，然后根据它们的正确性绘制红、绿框。</p><h1 id="a5cb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">工作空间检测</h1><p id="5286" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">工作空间检测模块假设在给定的扫描工作表中存在有效的矩形框。下图显示了工作表设计。工作表中三个最大的矩形框是工作空间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5e3c05eace1f938c0e638f0f9932abc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*QUoudwRzsx48_1ssct1jZQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Worsheet design</figcaption></figure><p id="1ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作空间检测模块使用<a class="ae ky" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> openCV </a>完成。我们将首先找到矩形框，然后根据它们在工作表中的位置对它们进行排序。由于工作表中有许多矩形，我们必须从其他矩形中选择有效的工作空间。让我们看看每个步骤是如何完成的</p><h2 id="8bcf" class="no mh it bd mi np nq dn mm nr ns dp mq li nt nu ms lm nv nw mu lq nx ny mw nz bi translated">步骤 1:寻找矩形框</h2><p id="509f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">矩形由两条水平线和垂直线组成。所以第一步是找出所有的水平线和垂直线，忽略数字、符号或任何写在工作表上的东西。</p><p id="55b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码将首先创建一个名为<em class="nh"> "vertical_lines_img" </em>的二进制图像，它包含工作表中出现的所有垂直线，然后创建另一个名为" horizontal_lines_img" 的二进制图像<em class="nh">，它包含工作表中出现的所有水平线。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="29e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们要将图像<em class="nh">“垂直 _ 线条 _img”与“水平 _ 线条 _ img”</em>相加，得到最终的图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/5d8c47ce337af6f02348b1fb056e8348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Elm75MF-zUrbsbestYnzTA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Adding vertical and horizontal line</figcaption></figure><blockquote class="od"><p id="5924" class="oe of it bd og oh oi oj ok ol om lu dk translated"><strong class="ak">轮廓</strong>定义为沿着图像边界连接具有相同强度的所有点的线。</p></blockquote><p id="b9f1" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated"><strong class="lb iu"> OpenCV </strong>具有 findContour()函数，帮助从图像中提取<strong class="lb iu">轮廓</strong>。每个单独的轮廓是对象边界点的(x，y)坐标的 Numpy 数组。我们可以用它来找到最终图像中的所有对象(最终图像中只有对象是矩形)。</p><p id="2b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为最终图像只是原始图像的二进制版本，所以最终图像中矩形的坐标等于原始图像中矩形的坐标。</p><p id="c2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了坐标，让我们使用 openCV 的<em class="nh"/><a class="ae ky" href="https://docs.opencv.org/3.4/d4/d73/tutorial_py_contours_begin.html" rel="noopener ugc nofollow" target="_blank"><em class="nh">draw contours()</em></a>函数在原始图像上绘制它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Code to find and draw the contours</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/a636959825bd1adbea5cba43ef233f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKhH5m8rRMzppI24Mv4hoA.jpeg"/></div></div></figure><h2 id="898b" class="no mh it bd mi np nq dn mm nr ns dp mq li nt nu ms lm nv nw mu lq nx ny mw nz bi translated">步骤 2:对轮廓进行排序</h2><p id="668c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经找到了所有的矩形，是时候根据它们的坐标从上到下对它们进行排序了。下面的代码会帮我们做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Function to sort contours <a class="ae ky" href="https://www.pyimagesearch.com/2015/04/20/sorting-contours-using-python-and-opencv/" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Code Reference</strong></a></figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Sorted contours</figcaption></figure><p id="5f5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nh"> sort_contours </em>函数将返回按照我们给出的方法排序的轮廓和边界框(左上和右下坐标)。在这种情况下，方法是从上到下。</p><h2 id="7c02" class="no mh it bd mi np nq dn mm nr ns dp mq li nt nu ms lm nv nw mu lq nx ny mw nz bi translated">步骤 3:基于区域的选择</h2><p id="51d8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有许多矩形，但我们只需要三个最大的。如何选择三个最大的矩形？….一个答案是找出矩形的面积，然后选择面积最大的前 3 个矩形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/b411e2441d0964a02d5d0af0a99133da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uufO7dOlbvhbnWQTRABmpA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Overall solution</figcaption></figure><p id="9724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些选定的矩形是工作空间，然后从工作表中提取出来，并发送到分析模块。</p><h1 id="fbf9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">分析模块</h1><p id="919c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如上所述的分析模块将首先检测行，预测每行中的字符，最后用预测的字符形成方程，然后通过标记框来评估它们。</p><h2 id="d809" class="no mh it bd mi np nq dn mm nr ns dp mq li nt nu ms lm nv nw mu lq nx ny mw nz bi translated">线检测</h2><p id="ce95" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">检测这些线是棘手的部分，每个人都有自己解决方程的方法，有些人一步一步地解决，有些人只用一行就能解决，有些人可能写了好几页的步骤，有些人写了远离方程的指数，使模块混淆，将这些指数作为一个单独的行。</p><p id="132e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的线检测模块假设线之间有足够的间隙，并且在指数字符和线之间有一些交集。首先，检测到的工作空间被转换成二进制图像，然后压缩成一个单一的阵列，以采取向前的导数。哪里有线，哪里的导数就有变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/4f09f4b52c462a988eba0d7e159b294f.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*MpHM-fG-HdZ1bWZaEKTVqw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Change in derivatives of a binary image</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码只是线条提取工作原理的一瞥。要查看完整的代码，请点击<a class="ae ky" href="https://github.com/divyaprabha123/Autograding-handwritten-mathematical-worksheets/blob/d074738c2e1db6b4619e9930f576439b309d1f37/utils_functions.py#L426-L570" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a><strong class="lb iu">。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/0c50dfdb1fe73e892ad5059c8ef86803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVtJP3qAJsDVgozm9OZGbQ.png"/></div></div></figure><h2 id="0c0d" class="no mh it bd mi np nq dn mm nr ns dp mq li nt nu ms lm nv nw mu lq nx ny mw nz bi translated">字符分割和指数检测</h2><p id="70d9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">检测完所有线条后，我们必须将提取的线条图像发送到<a class="ae ky" href="https://github.com/divyaprabha123/Autograding-handwritten-mathematical-worksheets/blob/d074738c2e1db6b4619e9930f576439b309d1f37/utils_functions.py#L636-L725" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="nh">text _ segment</em></strong></a><em class="nh"/>函数<em class="nh"> </em>，该函数将使用 openCV 的 find contours 来分割字符，并使用上述函数<em class="nh"> sort_contours </em>对字符进行排序，其中方法现在设置为从左到右。</p><p id="4ac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们来说，判断给定的数是否是指数很容易，但对模型来说就没那么容易了。假设指数至少在直线的一半以上，我们可以在图像的中心画一条基线，基线以上的任何字符都被认为是指数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/1e268baa2ee5d8612b794339e4ba16de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*KWHzu15erOmkiUc1u3NcRA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Exponential detection</figcaption></figure><h2 id="7296" class="no mh it bd mi np nq dn mm nr ns dp mq li nt nu ms lm nv nw mu lq nx ny mw nz bi translated">光学字符识别</h2><p id="94a4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用<a class="ae ky" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据集用于数字(28*28 像素)和<a class="ae ky" href="https://www.kaggle.com/xainano/handwrittenmathsymbols" rel="noopener ugc nofollow" target="_blank"> Kaggle 的手写数学符号</a>数据集用于符号(45*45 像素)来训练模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/56ba09eb0c1f2ea08cf4fd2ab4f27743.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*3Q58Q1qNIcjYWmcAcotlpA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">MNIST IMAGES</figcaption></figure><p id="12d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MNIST 实际上是如何形成的？</p><ol class=""><li id="8fe6" class="oy oz it lb b lc ld lf lg li pa lm pb lq pc lu pd pe pf pg bi translated">从 500 个不同的作者那里收集的 128 * 128 像素的手写数字。</li><li id="46c5" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">高斯滤波器被应用于图像以柔化边缘</li><li id="e21e" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">然后，通过保持长宽比，将数字放置在正方形图像的中央。</li><li id="ad97" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">然后，使用双三次插值将图像下采样至 28 × 28 像素</li></ol><p id="274a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在训练之前，符号的图像以与 MNIST 数字相同的方式进行预处理。预处理的原因是我们选择的两个数据集具有不同的特征，如尺寸、厚度和线宽，这使得深度学习模型很难找到模式。预处理帮助我们减少数字和符号之间的差异。</p><p id="fc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://pdfs.semanticscholar.org/d80b/4375171d97a8c8b7daa8a1b9170429126f5d.pdf" rel="noopener ugc nofollow" target="_blank">深度柱状卷积神经网络(DCCNN) </a>上训练了近 60，000 幅数字和预处理符号的图像，这是一种单一的深度和广度神经网络架构，在各种图像分类挑战(如 MNIST、CIFAR-10 和 CIFAR-100 数据集)上提供接近最先进的性能，如集成模型。这个模型达到了 96 %的准确率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/1d7f72320848cd27a00ca1d848f18809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LVgE5TAM7XEwchsH"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Deep Columnar Convolutional Architecture (DCCNN)</figcaption></figure><p id="1663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<a class="ae ky" href="https://github.com/divyaprabha123/Autograding-handwritten-mathematical-worksheets/blob/d074738c2e1db6b4619e9930f576439b309d1f37/DCCNN%20-%20training.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="nh">查看训练代码 DCCNN_training.ipynb </em> </a></p><h1 id="b98b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">评估和绘图框</h1><p id="3e3f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">评估是最后也是最重要的部分。为了求解任何方程，我们可以使用 python 的<em class="nh"> eval </em>方法。</p><p id="5c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">eva 方法解析传递给它的表达式，并在程序中运行 python 表达式(代码)</p><p id="dbc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个关于<em class="nh"> eval </em>如何工作的例子</p><pre class="kj kk kl km gt pn po pp pq aw pr bi"><span id="3505" class="no mh it po b gy ps pt l pu pv">&gt;&gt;Enter the function y(in terms of x):</span><span id="8c32" class="no mh it po b gy pw pt l pu pv">‘x*(x+1)*(x+2)’</span><span id="98a3" class="no mh it po b gy pw pt l pu pv">&gt;&gt;Enter the value of x:</span><span id="e22d" class="no mh it po b gy pw pt l pu pv">3</span><span id="4a5b" class="no mh it po b gy pw pt l pu pv">&gt;&gt;print(y)</span><span id="9995" class="no mh it po b gy pw pt l pu pv">60</span></pre><p id="c106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/divyaprabha123/Autograding-handwritten-mathematical-worksheets/blob/d074738c2e1db6b4619e9930f576439b309d1f37/utils_functions.py#L573-L634" rel="noopener ugc nofollow" target="_blank"> <em class="nh">评估</em> </a>流程涉及的步骤有:</p><ol class=""><li id="4539" class="oy oz it lb b lc ld lf lg li pa lm pb lq pc lu pd pe pf pg bi translated">解决给定的数学问题并保存答案</li><li id="a40f" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">求解每一个手写行，并将其导出值与存储的答案进行比较。</li><li id="403c" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">如果线条正确，画一个绿色的边界框，如果线条错误，画一个红色的边界框。</li></ol><p id="9182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们举个例子，说问题是解方程 A*x + B*y</p><p id="e33a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中，A=56，B=7，x=3，y=13，这个等式的答案是 595 (56*3 +7*13 = 595)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/befd3ca71124d64bc409385bdbce14c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DyWTC-DxPSBEXZYl"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Sample workspace</figcaption></figure><p id="bd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绿色方框表示这条线是正确的，而红色方框表示这条线是错误的。</p><p id="9eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行和最后一行是正确的，通过求解这些行，我们得到 595，这与实际答案相符。</p><p id="241f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行(56*7 + 92)错了。3 是 9，但它被写成 7，在求解时我们得到 584，这不等于 595</p><p id="4ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三行(595 + 92)也是错误的，在求解这一行时，我们得到 684，它也不等于 595。</p><h1 id="b5c9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="5ef9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">总而言之，扫描的工作表被发送到工作空间检测模块，它将返回给定工作表中的所有矩形工作空间，然后检测到的工作空间被传递到线提取模块以提取所有的线。提取的线然后被发送到字符分割模块，它将分割字符，深度学习模型 DCCNN 将预测数字/符号。最后，评估模块将评估线，并绘制红/绿包围盒。</p><p id="fb35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动化评分过程不仅有助于教师，也为学生创造了舒适的学习体验。通过识别更复杂的数学方程，如微分积分方程、识别字符未分离的草书笔迹、检测剽窃和识别化学方程，该解决方案可以变得更酷。</p></div><div class="ab cl px py hx pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="im in io ip iq"><p id="dc21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读到最后！！...如果你喜欢这篇文章，请鼓掌让我知道，如果你能通过与你的朋友分享来帮助它传播，我将非常感激:)。✌️</p></div></div>    
</body>
</html>