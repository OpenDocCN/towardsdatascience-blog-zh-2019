<html>
<head>
<title>Practical Machine Learning with C++ and GRT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 C++和 GRT 实现实用的机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-machine-learning-with-c-and-grt-a54857972434?source=collection_archive---------14-----------------------#2019-11-01">https://towardsdatascience.com/practical-machine-learning-with-c-and-grt-a54857972434?source=collection_archive---------14-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd836ce1881c571023b73763462bbba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*487GL7h0LwHcodHS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Franck V.</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="82fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将是从程序员的角度解释机器学习基础知识的系列教程中的第一篇。在第 1 部分中，我将展示如何使用<a class="ae kf" href="https://github.com/nickgillian/grt" rel="noopener ugc nofollow" target="_blank"> GRT </a>库将基本的机器学习整合到 C++项目中。</p><h2 id="ab35" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">什么是机器学习？</h2><p id="140c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">机器学习是一种计算方法，它使程序能够基于给定的输入生成可预测的输出，而无需使用显式定义的逻辑。</p><p id="2de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，使用传统的基于逻辑的编程，我们可以编写一个对水果进行分类的函数，它以颜色和尺寸作为输入，输出水果的名称。大概是这样的:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0db6" class="le lf it mh b gy ml mm l mn mo">string classifyFruit(Colour c, Dimensions d)<br/>{<br/>    if (c.similar({255, 165, 0}))   // green<br/>    {<br/>        if (d.similar({10, 9, 11})) // round-ish<br/>        {<br/>             return "Apple";<br/>        }<br/>        else<br/>        {<br/>             return "Pear";<br/>        }<br/>    }<br/>    if (c.similar({255, 255, 0}))   // yellow<br/>    {<br/>         return "Banana";<br/>    }<br/>    if (c.similar({255, 165, 0}))   // orange<br/>    {<br/>         return "Orange";<br/>    }<br/>    <br/>    return "Unknown";<br/>}</span></pre><p id="3091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看出，这种方法存在各种各样的问题。我们的函数只知道四种水果，所以如果我们想扩展它来对 Clementines 进行分类，我们需要额外的语句来区分它们和橙子。根据水果的确切形状和我们的<code class="fe mp mq mr mh b">similar()</code>方法的定义，我们还会将梨和苹果混在一起。要创建一个函数来对各种各样的水果进行高精度分类，事情会变得非常复杂。</p><p id="2607" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">机器学习通过将输入和输出之间的关系表示为<a class="ae kf" href="https://en.wikipedia.org/wiki/State_(computer_science)#Program_state" rel="noopener ugc nofollow" target="_blank">状态</a>而不是通过逻辑规则来解决这个问题。这意味着我们可以使用<code class="fe mp mq mr mh b">given / then</code>例子来表达我们的意图，而不是使用<code class="fe mp mq mr mh b">if / then / else</code>语句来编写我们的分类器。所以决定我们函数行为的代码看起来更像这样:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f4fa" class="le lf it mh b gy ml mm l mn mo">ml.given({0,   255, 0, 10, 9,  11}) .then("Apple");<br/>ml.given({0,   255, 0, 15, 7,  8})  .then("Pear");<br/>ml.given({255, 255, 0, 20, 4,  4})  .then("Banana");<br/>ml.given({255, 165, 0, 10, 10, 10}) .then("Orange");</span></pre><p id="25bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，<code class="fe mp mq mr mh b">ml</code>表示我们的机器学习对象，<code class="fe mp mq mr mh b">given()</code>的列表参数表示不同类型水果的颜色和尺寸元组，<code class="fe mp mq mr mh b">then()</code>的字符串参数表示给定输入时我们期望从分类器得到的输出。</p><p id="3250" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们程序的下一步是类似于<code class="fe mp mq mr mh b">x = ml.classify({255, 165, 0, 10, 10, 10})</code>的东西，我们期望<code class="fe mp mq mr mh b">x</code>的值是“橙色”。</p><p id="b95d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法的优点是，由于我们已经将<em class="ms">状态</em>从<em class="ms">逻辑</em>中分离，指定输入/输出关系的过程可以自动化。</p><p id="b88a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7f50" class="le lf it mh b gy ml mm l mn mo">auto rows = csv.read();</span><span id="b0d1" class="le lf it mh b gy mt mm l mn mo">for (auto&amp; r : rows)<br/>{<br/>    ml.given(r.colour, r.dimension).then(r.name);<br/>}</span></pre><p id="d429" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以添加尽可能多的不同类型的水果，或者在不修改代码的情况下给出同一类型水果的许多不同示例！我们唯一需要改变的是输入数据的大小和内容，在本例中是来自一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="noopener ugc nofollow" target="_blank"> CSV </a>文件。</p><p id="9fb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">敏锐的读者现在会想:我们不是刚刚创建了一个大的查找表吗？答案是“否”,因为这只会对<em class="ms">与示例中的颜色和尺寸完全匹配的水果进行分类。相反，我们希望系统能够对新的水果项目进行分类，这些项目与我们的一个示例具有相同的名称，但是具有不同的尺寸和颜色。因此对于<code class="fe mp mq mr mh b">x = c.classify({245, 145, 0, 11, 9, 10})</code>,我们期望输出为“橙色”,即使颜色和尺寸与我们在<code class="fe mp mq mr mh b">given / then</code>语句中提供的任何示例都不完全匹配。</em></p><p id="178a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这一点，机器学习系统使用一组统计参数来定义基于现有输入的给定输出的<em class="ms">可能性</em>。每次提供新的示例时，这些参数都会更新，以使系统更加精确。这就是监督机器学习的本质。</p><p id="e57f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，让我们回顾并建立一些术语:</p><ul class=""><li id="6a1e" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">在<em class="ms">监督机器学习</em>中，我们有一组定义系统输入和输出之间预期关系的例子。这被称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Training,_validation,_and_test_sets" rel="noopener ugc nofollow" target="_blank">数据集</a>。</li><li id="5dda" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">数据集中的每一行都由确定输入的<em class="ms">类别</em>的<em class="ms">标签</em>和确定其属性的<em class="ms">特征向量</em>组成(例如<code class="fe mp mq mr mh b">{245, 145, 0, 11, 9, 10}</code>包含颜色和尺寸特征)。</li><li id="83f0" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">我们的目标是创建输入(特征向量)和输出(类别标签)之间的<em class="ms">统计</em> <em class="ms">关系</em>的表示。这叫做<a class="ae kf" href="https://en.wikipedia.org/wiki/Predictive_modelling" rel="noopener ugc nofollow" target="_blank">型号</a>。</li><li id="f476" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">为了实现这一点，我们使用一个系统来从<em class="ms">训练数据集</em>生成<em class="ms">模型</em>，并使用该模型执行<em class="ms">分类</em>。这叫做机器学习<a class="ae kf" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。</li></ul><p id="603d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，机器学习算法被称为从数据集“学习”，以便生成可用于对原始数据集中不存在的输入特征向量进行分类的模型。</p><h2 id="df97" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">有什么用？</h2><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/b61f43f8237c1835d54037ef9694ceef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRdXJAUOFdiyhkr85yOtOA.png"/></div></div></figure><p id="4be4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">机器学习有很多种。在这篇文章中，我主要关注监督分类。当我们想要建立一个可以自动分类许多不同类别的对象的系统时，监督分类是有用的。“独特的”这个词很重要，因为当物体的类别具有将它们彼此分开的独特特征(颜色、形状、大小、重量等)时，分类算法工作得最好。如果我们的对象非常相似，并且只能通过特征的微小变化来区分，那么分类的效果就不太好。因此，它可以很好地用于水果或人脸(不同的眼睛颜色、头发颜色、面部毛发、脸型等)，但会很难根据气温和天空颜色来识别某人的位置。这种区分不同物体的能力被称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Linear_separability" rel="noopener ugc nofollow" target="_blank">可分性</a>，是机器学习中的一个重要概念。一个很好的经验法则是，如果人类难以区分不同类别的物体，机器也会如此。</p><h2 id="d9e8" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">我如何将机器学习整合到我的 C++项目中？</h2><p id="9d3e" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在我们对机器学习有了基本的了解，我们如何将它融入到我们的 C++项目中呢？一个很好的库是<a class="ae kf" href="http://www.nickgillian.com/wiki/pmwiki.php/GRT/GestureRecognitionToolkit" rel="noopener ugc nofollow" target="_blank">手势识别工具包</a>或 GRT。GRT 是为实时手势识别而开发的，适用于一系列机器学习任务。在麻省理工学院的许可下，它可以在 Windows、Mac 和 Linux 上使用，因此可以用于封闭或开源项目。GRT 的完整类文档可以在<a class="ae kf" href="http://nickgillian.com/grt/api/0.2.0/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="cace" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GRT 由许多 C++类组成，每个类都实现一个特定的机器学习算法。几乎所有 GRT 类都使用以下约定:</p><ul class=""><li id="5378" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated"><code class="fe mp mq mr mh b">train(...)</code>使用输入数据<code class="fe mp mq mr mh b">(...)</code>来训练新的模型，该模型然后可以用于分类。</li><li id="4388" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe mp mq mr mh b">predict(...)</code>使用输入向量<code class="fe mp mq mr mh b">(...)</code>和<em class="ms">训练模型</em>进行分类。</li><li id="3d10" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe mp mq mr mh b">getPredictedClassLabel()</code>返回从输入向量预测的类别标签</li><li id="fb90" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe mp mq mr mh b">save(...)</code>将模型或数据集保存到文件中。</li><li id="2c23" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe mp mq mr mh b">load(...)</code>从文件中加载预训练模型或数据集。</li><li id="6a83" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe mp mq mr mh b">clear()</code>清除 ML 对象，删除所有预训练模型</li></ul><h2 id="8792" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">建筑 GRT</h2><p id="6ff4" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">以下说明是针对 Mac 和 Linux 平台的，Windows 用户应该参考官方的<a class="ae kf" href="https://github.com/jamiebullock/grt/tree/master/build#windows-build-instructions" rel="noopener ugc nofollow" target="_blank">构建指南</a>。</p><p id="8eb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要构建 GRT，需要 CMake。CMake 可以从<a class="ae kf" href="https://cmake.org" rel="noopener ugc nofollow" target="_blank">项目页面</a>安装。在 macOS 上，我推荐使用<a class="ae kf" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank">自制软件</a>来安装 CMake。</p><p id="bd8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装 CMake 后，从 git 存储库下载 GRT:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9603" class="le lf it mh b gy ml mm l mn mo">$ git clone <a class="ae kf" href="https://github.com/jamiebullock/grt" rel="noopener ugc nofollow" target="_blank">https://github.com/jamiebullock/grt</a></span></pre><p id="e28c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3991" class="le lf it mh b gy ml mm l mn mo">$ cd grt/build<br/>$ mkdir tmp &amp;&amp; cd tmp<br/>$ cmake .. -DBUILD_PYTHON_BINDING=OFF<br/>$ make</span></pre><p id="cf0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果发生构建错误，可以在项目<a class="ae kf" href="https://github.com/nickgillian/grt/issues" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>中报告。否则，可以按如下方式测试构建:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fc97" class="le lf it mh b gy ml mm l mn mo">$ ./KNNExample ../../data/IrisData.grt</span></pre><p id="8513" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该会输出类似如下的内容:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0f34" class="le lf it mh b gy ml mm l mn mo">[TRAINING KNN] Training set accuracy: 97.5</span><span id="45b3" class="le lf it mh b gy mt mm l mn mo">TestSample: 0 ClassLabel: 3 PredictedClassLabel: 3</span><span id="3fa9" class="le lf it mh b gy mt mm l mn mo">TestSample: 1 ClassLabel: 2 PredictedClassLabel: 2</span><span id="c778" class="le lf it mh b gy mt mm l mn mo">...</span><span id="3489" class="le lf it mh b gy mt mm l mn mo">TestSample: 29 ClassLabel: 2 PredictedClassLabel: 2</span><span id="89f3" class="le lf it mh b gy mt mm l mn mo">Test Accuracy: 93.3333%</span></pre><p id="9b7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将执行在<code class="fe mp mq mr mh b">examples/ClassificationModulesExamples/KNNExample/KNNExample.cpp</code>中找到的代码——基于来自<a class="ae kf" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>的数据的虹膜花分类器。更多解释见<a class="ae kf" href="http://www.nickgillian.com/wiki/pmwiki.php/GRT/MachineLearning101" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h2 id="b956" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">机器学习 Hello World！</h2><p id="c135" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们现在准备使用 GRT 构建一个简单的水果分类器！</p><p id="2e43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先我们需要创建一个新的源文件，(姑且称之为 fruit.cpp)并包含 GRT 头文件。这是使用 GRT 库中大部分功能所需的唯一头文件。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="68a9" class="le lf it mh b gy ml mm l mn mo">#include "GRT.h"<br/>using namespace GRT;</span><span id="5d29" class="le lf it mh b gy mt mm l mn mo">typedef std::vector&lt;double&gt; v_;</span><span id="a081" class="le lf it mh b gy mt mm l mn mo">int main (int argc, const char * argv[])<br/>{<br/>}</span></pre><p id="9379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将从训练数据集中添加一些数据。为了这个例子的目的，我们将使用同样的“水果数据”。为此，我们使用 GRT <a class="ae kf" href="http://nickgillian.com/grt/api/0.2.0/class_classification_data.html" rel="noopener ugc nofollow" target="_blank"> ClassificationData </a>类来创建一个简单的数据集。代替字符串，在机器学习中使用数字标签，这里我们假设一个映射:1 =苹果，2 =梨，3 =香蕉，4 =橘子。所以我们增加了我们的<code class="fe mp mq mr mh b">main()</code>函数:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b6ab" class="le lf it mh b gy ml mm l mn mo">ClassificationData dataset;<br/>dataset.setNumDimensions(6);</span><span id="9ac3" class="le lf it mh b gy mt mm l mn mo">// Add 3 examples for each item to give our classifier enough data<br/>for (int i = 0; i &lt; 3; ++i)<br/>{<br/>    dataset.addSample(1, v_{0,   255, 0, 10, 9,  11});   // Apple<br/>    dataset.addSample(2, v_{0,   255, 0, 15, 7,  8});    // Pear<br/>    dataset.addSample(3, v_{255, 255, 0, 20, 4,  4});    // Banana<br/>    dataset.addSample(4, v_{255, 165, 0, 10, 10, 10});   // Orange<br/>}</span></pre><p id="5ebe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实际代码中，我们将添加更多不同的训练示例，以便我们的分类器可以很好地推广到各种输入。我们还将使用<code class="fe mp mq mr mh b">loadDatasetFromCSVFile()</code>方法从文件中加载数据集，这样数据就可以从我们的代码中分离出来。这方面的文档可以在<a class="ae kf" href="http://nickgillian.com/grt/api/0.2.0/class_classification_data.html#ad082098a4f995a74c626fb151cfcf979" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="e816" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们加载数据集并训练分类器。这里我们使用一个<code class="fe mp mq mr mh b">KNN</code>分类器，它实现了<a class="ae kf" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"> k-NN 算法</a>，但是 GRT 中的任何其他分类器都可以工作。作为一个练习，鼓励读者尝试从 GRT 中替换出各种不同的分类器。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4b1a" class="le lf it mh b gy ml mm l mn mo">// The classification class. Try also SVM!<br/>KNN classifier;</span><span id="1c07" class="le lf it mh b gy mt mm l mn mo">// Train our classifier<br/>classifier.train(dataset);        </span></pre><p id="a458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！我们现在有了一个训练好的模型，使用基于我们提供的输入数据集的 k-NN 算法。现在测试分类器…</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ab84" class="le lf it mh b gy ml mm l mn mo">VectorFloat testVector = v_{0,   255, 0, 10, 9,  11};</span><span id="9f00" class="le lf it mh b gy mt mm l mn mo">// Predict the output based on testVector<br/>classifier.predict(testVector);</span><span id="e858" class="le lf it mh b gy mt mm l mn mo">// Get the label<br/>auto classLabel = classifier.<!-- -->getPredictedClassLabel();</span><span id="1b90" class="le lf it mh b gy mt mm l mn mo">std::cout &lt;&lt; "Class label: " &lt;&lt; classLabel &lt;&lt; std::endl;</span></pre><p id="c205" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，为了证明我们的分类器可以推广到原始数据集中不存在的输入，我们将要求它对与我们的训练示例之一相似但不相同的特征向量进行分类。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="dccd" class="le lf it mh b gy ml mm l mn mo">VectorFloat differentVector = v_{10, 240, 40, 8, 10, 9};</span><span id="4e21" class="le lf it mh b gy mt mm l mn mo">classifier.predict(differentVector);<br/>auto otherLabel = classifier.getPredictedClassLabel();</span><span id="7dac" class="le lf it mh b gy mt mm l mn mo">std::cout &lt;&lt; "Other label: " &lt;&lt; otherLabel &lt;&lt; std::endl;</span></pre><p id="e118" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们的<code class="fe mp mq mr mh b">differentVector</code>与苹果的<code class="fe mp mq mr mh b">dataset</code>向量最相似，所以我们希望程序输出<code class="fe mp mq mr mh b">Other label: 1</code>。让我们看看它是否有效！</p><h2 id="e850" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">完整的代码列表</h2><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e2ff" class="le lf it mh b gy ml mm l mn mo">#include "GRT.h"<br/>using namespace GRT;</span><span id="5424" class="le lf it mh b gy mt mm l mn mo">typedef std::vector&lt;double&gt; v_;</span><span id="33eb" class="le lf it mh b gy mt mm l mn mo">int main (int argc, const char * argv[])<br/>{<br/>    ClassificationData dataset;<br/>    dataset.setNumDimensions(6);</span><span id="7c68" class="le lf it mh b gy mt mm l mn mo">    // Add 3 examples each to give our classifier enough data<br/>    for (int i = 0; i &lt; 3; ++i)<br/>    {<br/>        // Apple<br/>        dataset.addSample(1, v_{0,   255, 0, 10, 9,  11});<br/>        // Pear<br/>        dataset.addSample(2, v_{0,   255, 0, 15, 7,  8});<br/>        // Banana<br/>        dataset.addSample(3, v_{255, 255, 0, 20, 4,  4});<br/>        // Orange<br/>        dataset.addSample(4, v_{255, 165, 0, 10, 10, 10});   <br/>    }</span><span id="5841" class="le lf it mh b gy mt mm l mn mo">    // The classification class. Try also SVM<br/>    KNN classifier;</span><span id="c19f" class="le lf it mh b gy mt mm l mn mo">    // Train our classifier<br/>    classifier.train(dataset);</span><span id="b929" class="le lf it mh b gy mt mm l mn mo">    // Create a test vector<br/>    VectorFloat testVector = v_{0,   255, 0, 10, 9,  11};</span><span id="49f4" class="le lf it mh b gy mt mm l mn mo">    // Predict the output based on testVector<br/>    classifier.predict(testVector);</span><span id="c2f0" class="le lf it mh b gy mt mm l mn mo">    // Get the label<br/>    <!-- -->auto classLabel = classifier.<!-- -->getPredictedClassLabel();</span><span id="e023" class="le lf it mh b gy mt mm l mn mo">    std::cout &lt;&lt; "Class label: " &lt;&lt; classLabel &lt;&lt; std::endl;</span><span id="2a03" class="le lf it mh b gy mt mm l mn mo">    // Try an input vector not in the original dataset<br/>    VectorFloat differentVector = v_{10, 240, 40, 8, 10, 9};</span><span id="68be" class="le lf it mh b gy mt mm l mn mo">    classifier.predict(differentVector);<br/>    auto otherLabel = classifier.getPredictedClassLabel();</span><span id="7901" class="le lf it mh b gy mt mm l mn mo">    std::cout &lt;&lt; "Other label: " &lt;&lt; otherLabel &lt;&lt; std::endl;</span><span id="d09b" class="le lf it mh b gy mt mm l mn mo">    return 0;</span><span id="4752" class="le lf it mh b gy mt mm l mn mo">}</span></pre><p id="2ca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在 macOS 或 Linux 上编译代码，键入以下内容(来自我们在本教程开始时创建的同一个<code class="fe mp mq mr mh b">tmp</code>目录)。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9613" class="le lf it mh b gy ml mm l mn mo">g++ -std=c++14 fruit.cpp -ofruit -lgrt -L. -I../../GRT</span></pre><p id="0857" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这告诉编译器链接到当前目录中的<code class="fe mp mq mr mh b">libgrt.so</code>，头文件在<code class="fe mp mq mr mh b">../../GRT</code>中，如果将 GRT 移动到其他地方，参数<code class="fe mp mq mr mh b">-L</code>和<code class="fe mp mq mr mh b">-I</code>将需要调整。</p><p id="8cb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们运行我们的程序:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ae4e" class="le lf it mh b gy ml mm l mn mo">./fruit</span></pre><p id="8459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出应该是:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5733" class="le lf it mh b gy ml mm l mn mo">Class label: 1<br/>Other label: 1</span></pre><p id="7c69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你！您刚刚用 26 行 C++代码编写了一个通用分类器🤩。如果我们从一个 CSV 文件加载数据集，它会少得多。</p><p id="b903" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这个教程是有用的。敬请关注未来更多内容！</p></div></div>    
</body>
</html>