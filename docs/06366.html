<html>
<head>
<title>Introduction to Web Scraping with Selenium and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Selenium 和 Python 网页抓取简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-web-scraping-with-selenium-and-python-85920d41722d?source=collection_archive---------28-----------------------#2019-09-12">https://towardsdatascience.com/introduction-to-web-scraping-with-selenium-and-python-85920d41722d?source=collection_archive---------28-----------------------#2019-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9e2d64aea1c9e1011fa84922ebcce092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnEQqNJTo1NAQ5UoYL6YQQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="1c72" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">关于如何开始使用 Selenium 的实用教程</h2></div><p id="0cfb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当你需要数据时，网络抓取是一种快速、经济、可靠的获取方式。更好的是，数据通常是最新的。现在，请记住，当抓取一个网站时，你可能会违反其使用政策，并可能被踢出网站。虽然抓取大部分是合法的，但根据您打算如何使用数据，可能会有一些例外。所以在开始之前，一定要做好调查。然而，对于一个简单的个人或开源项目，你应该没问题。</p><p id="de0c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">抓取数据的方法有很多，但我最喜欢的一种是使用<a class="ae lp" href="https://www.seleniumhq.org/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>。它主要用于测试，因为它主要做的是浏览器自动化。用简单的语言来说，它创建了一个机器人浏览器，为你做事情:它可以获得 HTML 数据，滚动，点击按钮等。最大的好处是我们可以明确地说出我们想要什么样的 HTML 数据，这样我们就可以适当地组织和存储它。</p><p id="59e1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Selenium 与许多编程语言兼容，但是本教程将重点介绍 Python。检查<a class="ae lp" href="https://selenium-python.readthedocs.io/index.html" rel="noopener ugc nofollow" target="_blank">此链接</a>以阅读 Selenium(使用 Python)文档。</p><h1 id="4e8c" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">第一步</h1><p id="9e84" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">要下载 Selenium，请在命令行中使用这个简单的命令:</p><p id="f9e6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">pip install selenium</code></p><p id="b8a9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你在 Jupyter 笔记本上工作，你可以直接在那里而不是命令行上完成。开头加个感叹号就行了:</p><p id="6f6a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">!pip install selenium</code></p><p id="6541" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">之后，您需要做的就是导入必要的模块:</p><p id="f2b3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">from selenium.webdriver import Chrome, Firefox</code></p><p id="b882" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也支持其他浏览器，但这两种是最常用的。</p><p id="b8be" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">开始时需要两个简单的命令:</p><p id="2093" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">browser = Firefox()</code> <br/>(或<code class="fe mn mo mp mq b">browser = Chrome()</code>取决于你的喜好)</p><p id="6b98" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这创建了一个 Firefox WebDriver 的实例，允许我们访问它所有有用的方法和属性。我们把它赋给了变量<code class="fe mn mo mp mq b">browser</code>，但是你可以自由选择你自己的名字。Firefox 浏览器将自动打开一个新的空白窗口。</p><p id="131d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来获取您想要抓取的 URL:</p><p id="43c2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">browser.get('https://en.wikipedia.org/wiki/Main_Page')</code></p><p id="c582" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">get()</code>方法将在浏览器中打开 URL，并等待它完全加载。</p><p id="29ff" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在你可以从这个 URL 获得所有你想要的 HTML 信息。</p><h1 id="8760" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">定位元件</h1><p id="71cc" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">用硒定位元素有不同的方法。哪一个是最好的，取决于你抓取的页面的 HTML 结构。找出访问您想要的元素的最有效的方法可能很棘手。所以请慢慢来，仔细检查 HTML。</p><p id="2d32" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以使用选择的搜索参数访问单个元素(您将获得与您的搜索参数对应的第一个元素)，也可以访问与搜索参数匹配的所有元素。要获得单个，请使用以下方法:</p><p id="48d7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">find_element_by_id()</code><br/><code class="fe mn mo mp mq b">find_element_by_name()</code><br/><code class="fe mn mo mp mq b">find_element_by_xpath()</code><br/><code class="fe mn mo mp mq b">find_element_by_link_text()</code><br/><code class="fe mn mo mp mq b">find_element_by_partial_link_text()</code><br/><code class="fe mn mo mp mq b">find_element_by_tag_name()</code><br/><code class="fe mn mo mp mq b">find_element_by_class_name()</code><br/>T7】</p><p id="fb38" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要定位多个元素，只需在上述方法中将<code class="fe mn mo mp mq b">element</code>替换为<code class="fe mn mo mp mq b">elements</code>。您将获得通过该方法定位的 WebDriver 对象的列表。</p><h1 id="a995" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">抓取维基百科</h1><p id="8ad9" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">所以让我们看看它是如何与已经提到的维基百科页面<a class="ae lp" href="https://en.wikipedia.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Main_Page</a>一起工作的</p><p id="8280" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们已经创建了包含 WebDriver 实例的<code class="fe mn mo mp mq b">browser</code>变量，并加载了 Wikipedia 主页面。</p><p id="1605" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">假设我们想要访问该页面可以翻译成的语言列表，并存储所有指向这些语言的链接。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mr"><img src="../Images/8a778708f18777f73a77d569c83248f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aEP5WNpkhmgjlGiF.png"/></div></div></figure><p id="3ab4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">经过一些检查，我们可以看到所有元素都有相似的结构:它们是类<code class="fe mn mo mp mq b">'interlanguage-link'</code>的<code class="fe mn mo mp mq b">&lt;li&gt;</code>元素，包含带有 URL 和文本的<code class="fe mn mo mp mq b">&lt;a&gt;</code>;</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="5eb5" class="na lr je mq b gy nb nc l nd ne">&lt;li class="interlanguage-link interwiki-bg"&gt; </span><span id="db95" class="na lr je mq b gy nf nc l nd ne">     &lt;a href="https://bg.wikipedia.org/wiki/" title="Bulgarian" <br/>     lang="bg" hreflang="bg" class="interlanguage-link-target"&gt;<br/>          <br/>            Български </span><span id="bef7" class="na lr je mq b gy nf nc l nd ne">     &lt;/a&gt; </span><span id="7a3c" class="na lr je mq b gy nf nc l nd ne">&lt;/li&gt;</span></pre><p id="6c13" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以让我们首先访问所有的<code class="fe mn mo mp mq b">&lt;li&gt;</code>元素。我们可以使用类名来隔离它们:</p><p id="b17d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">languages = browser.find_elements_by_class_name('interlanguage-link')</code></p><p id="2d37" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">languages</code>是 WebDriver 对象的列表。如果我们打印它的第一个元素:</p><p id="e2c3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">print(languages[0])</code></p><p id="966c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它会打印出这样的内容:</p><p id="6448" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="ng">&lt;selenium . web driver . Firefox . web element . Firefox web element(session = " 73e 70 f 48–851 a-764d-8533–66f 738 D2 BCF 6 "，element = " 2a 579 b 98–1a 03-b04f-AFE 3–5d 3 da 8 aa 9 EC 1 ")&gt;</em></p><p id="978d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以要真正看到里面有什么，我们需要写一个 for 循环来访问列表中的每个元素，然后访问它的<code class="fe mn mo mp mq b">&lt;a&gt;</code>子元素，并获得<code class="fe mn mo mp mq b">&lt;a&gt;</code>的文本和<code class="fe mn mo mp mq b">'href'</code>属性。</p><p id="203d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要获取文本，我们可以使用<code class="fe mn mo mp mq b">text</code>属性。使用<code class="fe mn mo mp mq b">get_attribute('attribute_name')</code>方法获得<code class="fe mn mo mp mq b">'href'</code>。因此，代码将如下所示:</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="81a7" class="na lr je mq b gy nb nc l nd ne">language_names = [language.find_element_by_css_selector('a').text   <br/>                  for language in languages] </span><span id="c836" class="na lr je mq b gy nf nc l nd ne">links =[language.find_element_by_css_selector('a') \<br/>                 .get_attribute('href') for language in languages]</span></pre><p id="e7dd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可以打印出<code class="fe mn mo mp mq b">language_names</code>和<code class="fe mn mo mp mq b">links</code>来看看它工作了。</p><h1 id="77c9" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">卷动</h1><p id="8530" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">有时并不是从一开始就加载整个页面。在这种情况下，我们可以让浏览器向下滚动，从页面的其余部分获取 HTML。使用将 JavaScript 代码作为参数的<code class="fe mn mo mp mq b">execute_script()</code>方法非常简单:</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="85b3" class="na lr je mq b gy nb nc l nd ne">scroll_down = "window.scrollTo(0, document.body.scrollHeight);" </span><span id="f418" class="na lr je mq b gy nf nc l nd ne">browser.execute_script(scroll_down)</span></pre><p id="2e0c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">scrollTo(x-coord, y-coord)</code>是一个滚动到给定坐标的 JavaScript 方法。在我们的例子中，我们使用返回元素高度的<code class="fe mn mo mp mq b">document.body.scrollHeight</code>(在这个例子中是<code class="fe mn mo mp mq b">body</code>)。</p><p id="f317" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如你可能已经猜到的，你可以用<code class="fe mn mo mp mq b">execute_script()</code>方法让浏览器执行所有类型的脚本。所以如果你有 JavaScript 的经验，你有很大的试验空间。</p><h1 id="6bbc" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">微小静电干扰声</h1><p id="f1f0" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">点击就像选择一个元素并对其应用<code class="fe mn mo mp mq b">click()</code>方法一样简单。在某些情况下，如果您知道需要访问的 URL，您可以让浏览器加载带有 URL 的页面。还是那句话，看什么效率更高。</p><p id="eb4e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了举例说明<code class="fe mn mo mp mq b">click()</code>方法，让我们点击左侧菜单中的“内容”链接。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/18743e921e0f4798a852c7326a32d1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PdXB7x2UTMACfbSM.png"/></div></div></figure><p id="04e7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该链接的 HTML 如下:</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="24e4" class="na lr je mq b gy nb nc l nd ne">&lt;li id="n-contents"&gt;<br/>   &lt;a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia"&gt;<br/><br/>        Contents<br/><br/>   &lt;/a&gt;<br/>&lt;/li&gt;</span></pre><p id="e4f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们必须首先找到具有唯一 id <code class="fe mn mo mp mq b">'n-contents'</code>的<code class="fe mn mo mp mq b">&lt;li&gt;</code>元素，然后访问它的<code class="fe mn mo mp mq b">&lt;a&gt;</code>子元素</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="cf78" class="na lr je mq b gy nb nc l nd ne">content_element = browser.find_element_by_id('n-contents') \    <br/>                         .find_element_by_css_selector('a')</span><span id="415f" class="na lr je mq b gy nf nc l nd ne">content_element.click()</span></pre><p id="1dcd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您现在可以看到浏览器加载了“目录”页面。</p><h1 id="e46e" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">下载图像</h1><p id="65a8" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">现在，如果我们决定从页面下载图片。为此，我们将使用<code class="fe mn mo mp mq b">urllib</code>库和一个 uuid 生成器。我们将首先用 CSS 选择器<code class="fe mn mo mp mq b">'img'</code>定位所有图像，然后访问它的<code class="fe mn mo mp mq b">'src'</code>属性，然后用<code class="fe mn mo mp mq b">urlretrieve('url', 'folder/name.jpg')</code>方法为每个图像创建一个唯一的 id 下载图像。这个方法有两个参数:一个图片的 URL 和一个我们想给它的名字，以及我们想下载到的文件夹(如果适用的话)。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="d6cf" class="na lr je mq b gy nb nc l nd ne">from urllib.request import urlretrieve <br/>from uuid import uuid4 </span><span id="e8b6" class="na lr je mq b gy nf nc l nd ne"># get the main page again browser.get('https://en.wikipedia.org/wiki/Main_Page') </span><span id="05f7" class="na lr je mq b gy nf nc l nd ne"># locate image elements <br/>images = browser.find_elements_by_css_selector('img') </span><span id="5b5f" class="na lr je mq b gy nf nc l nd ne"># access src attribute of the images <br/>src_list = [img.get_attribute('src') for img in images] </span><span id="231f" class="na lr je mq b gy nf nc l nd ne">for src in src_list: <br/>     # create a unique name for each image by using UUID generator    <br/>     uuid = uuid4() </span><span id="03eb" class="na lr je mq b gy nf nc l nd ne">     # retrieve umages using the URLs <br/>     urlretrieve(src, f"wiki_images/{uuid}.jpg")</span></pre><h1 id="f031" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">增加动作之间的等待时间</h1><p id="4f35" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">最后，有时有必要在浏览器中的操作之间引入一些等待时间。比如一个接一个加载很多页面的时候。可以用<code class="fe mn mo mp mq b">time</code>模块完成。</p><p id="067b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们从我们的<code class="fe mn mo mp mq b">links</code>列表中加载 3 个 URL，并让浏览器在使用<code class="fe mn mo mp mq b">time.sleep()</code>方法加载每个页面之前等待 3 秒钟。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="f011" class="na lr je mq b gy nb nc l nd ne">import time </span><span id="d732" class="na lr je mq b gy nf nc l nd ne">urls = links[0:3] </span><span id="90ac" class="na lr je mq b gy nf nc l nd ne">for url in urls: <br/>     browser.get(url) </span><span id="33f9" class="na lr je mq b gy nf nc l nd ne">     # stop for 3 seconds before going for the next page   <br/>     time.sleep(3)</span></pre><h1 id="9788" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">关闭 web 驱动程序</h1><p id="53ad" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">最后，我们可以关闭机器人浏览器的窗口</p><p id="f861" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">browser.close()</code></p><p id="ce18" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不要忘记<code class="fe mn mo mp mq b">browser</code>是一个包含<code class="fe mn mo mp mq b">Firefox()</code>方法实例的变量(见教程开头)。</p><h1 id="5098" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">GitHub 中的代码</h1><p id="3deb" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">这篇文章中的代码可以在 GitHub 中找到:<br/><a class="ae lp" href="https://github.com/AnnaLara/scraping_with_selenium_basics" rel="noopener ugc nofollow" target="_blank">https://github.com/AnnaLara/scraping_with_selenium_basics</a></p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="3157" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="ng">原发布于 2019 年 9 月 12 日</em><a class="ae lp" href="https://dev.to/annalara/introduction-to-web-scraping-with-selenium-and-python-4p7b" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://dev . to</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>