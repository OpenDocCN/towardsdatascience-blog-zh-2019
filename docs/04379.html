<html>
<head>
<title>Part 2: Hyperopt.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二部分:远视。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hyperparameter-optimization-in-python-part-2-hyperopt-5f661db91324?source=collection_archive---------4-----------------------#2019-07-08">https://towardsdatascience.com/hyperparameter-optimization-in-python-part-2-hyperopt-5f661db91324?source=collection_archive---------4-----------------------#2019-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="178b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hpo-in-python" rel="noopener" target="_blank">Python 中超参数优化。</a></h2><div class=""/><p id="8fa5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这个博客系列中，我将比较 python HPO 库。在阅读这篇文章之前，我强烈建议你阅读<a class="ae ku" rel="noopener" target="_blank" href="/hyperparameter-optimization-in-python-part-0-introduction-c4b66791614b"> <strong class="jy ja">第 0 部分:简介</strong> </a>其中我:</p><ul class=""><li id="f58e" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated">谈论 HPO 是什么，</li><li id="dc70" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">要比较的选定库，</li><li id="af3b" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">选择了评估标准，</li><li id="ddb5" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">为 HPO 定义了一个示例问题。</li></ul><p id="cac6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这篇博文和本系列其他部分的代码可以在<a class="ae ku" href="https://github.com/neptune-ml/blog-hyperparameter_optimization" rel="noopener ugc nofollow" target="_blank"> github </a>上获得，而所有关于脚本、超参数、图表和结果(可以下载)的实验都可以在 Neptune 上获得<a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/wiki/Skopt-forest-51912822-7a61-42ad-87d1-108998739c73?utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=explore-dashboard" rel="noopener ugc nofollow" target="_blank">。更多信息，请阅读这篇关于</a><a class="ae ku" href="https://neptune.ml/blog/experiment-management?utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=blog" rel="noopener ugc nofollow" target="_blank">组织实验过程的文章。</a></p><p id="e40e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">好，我们开始吧。</p><h1 id="988f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">远视</h1><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/0edf8b3a8774960f0cebbef70607022d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7OD02x99z7AkK9QIHzSnQ.png"/></div></div></figure><p id="8d28" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这是 HPO 空间中的经典。这个项目有超过 3300 星，600 叉和 40 个贡献者(2 个主要的)。甚至有基于它构建的项目，如:</p><ul class=""><li id="d8c4" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated"><a class="ae ku" href="https://github.com/maxpumperla/hyperas" rel="noopener ugc nofollow" target="_blank"> hyperas </a>:远视+角膜</li><li id="1410" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated"><a class="ae ku" href="https://github.com/hyperopt/hyperopt-sklearn" rel="noopener ugc nofollow" target="_blank">超视-sklearn </a>:超视+ sklearn</li></ul><h2 id="2283" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">易于设置和 API</h2><p id="2256" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated">这个 API 非常简单易用。我们需要定义一个搜索空间、目标并运行优化函数:</p><p id="79bb" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">首先，定义搜索空间。它可以是一个常规词典，也可以是本例中的 OrderedDict:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2988" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">有点尴尬的是，我必须定义这个名字两次，一次作为字典键，一次作为参数采样器中的<code class="fe nl nm nn no b">label</code>。</p><p id="9c68" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">然后，定义目标函数。记住<a class="ae ku" href="https://github.com/hyperopt/hyperopt/tree/master/hyperopt" rel="noopener ugc nofollow" target="_blank">远视</a>最小化功能，所以如果需要，改变符号:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cff2" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">最后，实例化<strong class="jy ja">试验</strong>对象，并运行优化:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bdd3" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">…完成了！</p><p id="ed2d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">所有的信息、超参数、损失和其他东西都保存在<code class="fe nl nm nn no b">trials</code>对象中。您可以毫无问题地访问它，也可以将其保存起来供以后使用。如果你想看完整的示例脚本，包括训练曲线、诊断图表等等，请看<a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/e/BLOG-165/source-code?path=.&amp;file=search_hyperopt.py&amp;utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=explore-script" rel="noopener ugc nofollow" target="_blank">这个版本化的 ml 实验。</a></p><p id="1a88" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我给它的分数是<strong class="jy ja"> 9/10 </strong>,因为在空间搜索定义中有重复的名称，而且对于简单的问题，我宁愿不实例化<code class="fe nl nm nn no b">trials</code>对象，而只是在默认情况下将它实例化为<code class="fe nl nm nn no b">Trials()</code>。</p><blockquote class="np nq nr"><p id="deb5" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">分数 9/10 </strong></p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="2b46" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">选项、方法和(超)超参数</h2><p id="4c04" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated"><strong class="jy ja">搜索空间</strong></p><p id="b7cc" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这就是<a class="ae ku" href="https://github.com/hyperopt/hyperopt/tree/master/hyperopt" rel="noopener ugc nofollow" target="_blank">远视</a>大放异彩的地方。有大量采样选项可供选择:</p><ul class=""><li id="1235" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated"><code class="fe nl nm nn no b">Categorical parameters-</code>使用<em class="ns"> hp.choice </em></li><li id="6e03" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated"><code class="fe nl nm nn no b">Integer parameters-</code>你可以使用<em class="ns"> hp.randit </em>、<em class="ns"> hp.quniform </em>、<em class="ns"> hp.qloguniform </em>或<em class="ns"> hp.qlognormal </em>，这给了你很多选择来为你的整数超参数空间建模</li><li id="fa77" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated"><code class="fe nl nm nn no b">Float parameters-</code>类似于整数参数，你真的可以选择用<em class="ns"> hp.normal </em>、<em class="ns"> hp.uniform </em>、<em class="ns"> hp.lognormal </em>和<em class="ns"> hp.loguniform </em>来解决你的问题</li></ul><p id="e6c0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">但事实并非如此。您可以轻松地定义嵌套空间，其中某些参数的值依赖于其他参数。以文档中的例子为例:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="33ce" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以看到，通过将<em class="ns"> hp.choice </em>与其他采样方法相结合，我们可以拥有条件搜索空间。</p><p id="58f9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这在从特征预处理、模型选择方法到模型超参数的复杂空间中搜索时非常有用。</p><p id="00d7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">优化方法</strong></p><p id="8437" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">有两种优化算法可以尝试。</p><p id="5359" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><code class="fe nl nm nn no b"><em class="ns">tpe.rand.suggest</em></code></p><p id="f9e1" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">你对参数的标准随机搜索。</p><p id="c887" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><code class="fe nl nm nn no b"><em class="ns">tpe.suggest</em></code></p><p id="3e3d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">类似于在<a class="ae ku" href="https://neptune.ml/blog/scikit-optimize?utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=blog" rel="noopener ugc nofollow" target="_blank">之前关于 Scikit-Optimize </a>的博文中所解释的，我们想要使用一个廉价的代理模型来估计昂贵的目标函数在一组参数上的性能。不同之处在于，我们想要估计尾部的密度，而不是估计实际性能(点估计)。</p><p id="2131" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我喜欢 AutoML.org 弗赖堡<a class="ae ku" href="https://www.automl.org/" rel="noopener ugc nofollow" target="_blank">的了不起的人们从</a><a class="ae ku" href="https://www.automl.org/wp-content/uploads/2019/05/AutoML_Book.pdf" rel="noopener ugc nofollow" target="_blank"> AutoML_Book </a>中摘录的以下解释。</p><blockquote class="np nq nr"><p id="36ea" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated">树 Parzen 估计器对给定运行的密度函数 p(λ|y &lt; α) and p(λ|y ≥ α). Given a percentile α (usually set to 15%), the observations are divided in good observations and bad observations and simple 1-d Parzen windows are used to model the two distributions.</p></blockquote><p id="837c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">By using p(λ|y &lt; α) and p(λ|y ≥ α) one can estimate the Expected Improvement (<strong class="jy ja"> EI </strong>)进行建模，而不是对给定配置λ的观测值 y 的概率 p(y|λ)进行建模。</p><p id="f037" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">有趣的是，在优化器中没有指定<strong class="jy ja"> λ </strong>参数的选项。</p><p id="056d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">回调</strong></p><p id="4fbf" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">本质上没有回调，但是您可以将回调函数放在<code class="fe nl nm nn no b">objective</code>中，每次调用<code class="fe nl nm nn no b">objective</code>时都会执行回调函数。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="197a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我不喜欢它，但我想我可以忍受。</p><p id="e4b7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">总而言之，这是嵌套搜索空间的一大优势，但我不喜欢没有干净回调的事实。<a class="ae ku" href="https://papers.nips.cc/paper/4443-algorithms-for-hyper-parameter-optimization.pdf" rel="noopener ugc nofollow" target="_blank"> TPE </a>没有任何(超)超参数，这一方面很好(工作量少，过拟合少),但另一方面，它不允许您调整不工作的东西。我给它 7/10。</p><blockquote class="np nq nr"><p id="2d72" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">分数 7/10 </strong></p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="5428" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">证明文件</h2><p id="9208" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated">说得好听点，它需要很多爱。</p><p id="59a5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">官方文档页面由维基上的<a class="ae ku" href="https://github.com/hyperopt/hyperopt/wiki" rel="noopener ugc nofollow" target="_blank">托管。如果你问我的话，我觉得这更像是一次图书馆之旅，而不是正式的文档。也就是说，读完之后，你应该能够有效地使用这个库。问题是，当你想找到一个特定的东西时，你需要浏览整个维基来寻找它。</a></p><p id="cd77" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">它缺少基本的例子。我找到的唯一一个(<code class="fe nl nm nn no b">hyperopt/recipes</code>)是 6 岁，有错误。</p><p id="e5e2" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">绝大多数函数和 main 类方法都缺少 docstrings。不幸的是，这使得导航和回答简单的问题变得很困难，比如这个函数实际上是做什么的？</p><p id="f13d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">好消息是，有很多关于它的博客帖子。其中一些我认为有用的是:</p><ul class=""><li id="3f0e" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated"><a class="ae ku" href="https://medium.com/district-data-labs/parameter-tuning-with-hyperopt-faa86acdfdce" rel="noopener"/><a class="od oe ep" href="https://medium.com/u/96c976e31f28?source=post_page-----5f661db91324--------------------------------" rel="noopener" target="_blank">区数据实验室</a>的【远视参数整定】</li><li id="bd84" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated"><a class="ae ku" href="https://medium.com/vooban-ai/hyperopt-tutorial-for-optimizing-neural-networks-hyperparameters-e3102814b919" rel="noopener"/>Vooban 撰写的《优化神经网络超参数的远视教程》</li><li id="7ee9" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated"><a class="ae ku" href="https://blog.goodaudience.com/on-using-hyperopt-advanced-machine-learning-a2dde2ccece7" rel="noopener ugc nofollow" target="_blank">Tanay agr awal</a><a class="od oe ep" href="https://medium.com/u/2e08a5e263c0?source=post_page-----5f661db91324--------------------------------" rel="noopener" target="_blank">的《关于使用 Hyperopt:高级机器学习》</a></li><li id="cdc7" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated"><a class="ae ku" rel="noopener" target="_blank" href="/an-introductory-example-of-bayesian-optimization-in-python-with-hyperopt-aae40fff4ff0"><a class="od oe ep" href="https://medium.com/u/e2f299e30cb9?source=post_page-----5f661db91324--------------------------------" rel="noopener" target="_blank">Will Koehrsen</a>撰写的“使用 Hyperopt 在 Python 中进行贝叶斯优化的介绍性示例”</a></li></ul><p id="458a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">文档肯定不是这个项目的强项，但因为它是一个经典，所以有很多外部资源。我给它 3/10。</p><blockquote class="np nq nr"><p id="df28" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">比分 3/10 </strong></p></blockquote><p id="3965" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">注</strong></p><p id="9aed" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果你正在考虑为社区做一些有益的事情，你可以继续，添加 docstrings，一堆例子，并为这个项目创建 read-the-docs 文档。就我而言，我会很感激的。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="2d75" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">形象化</h2><p id="1809" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated"><a class="ae ku" href="https://github.com/hyperopt/hyperopt" rel="noopener ugc nofollow" target="_blank">远视</a>有可视化模块<a class="ae ku" href="https://github.com/hyperopt/hyperopt/blob/master/hyperopt/plotting.py" rel="noopener ugc nofollow" target="_blank"> plotting.py </a>。它有三个功能:</p><ul class=""><li id="c960" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated">它向您显示每次迭代的结果，并突出显示最好的分数。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi of"><img src="../Images/30885863d77d24d0a82c536ceec077ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Wjl_xARf1PATLkpl5_baQ.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk">plot_history(trials) of the <a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/e/BLOG-165/details" rel="noopener ugc nofollow" target="_blank">best experiment</a></figcaption></figure><ul class=""><li id="0eae" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated"><code class="fe nl nm nn no b">main_plot_histogram</code>-显示所有迭代结果的直方图。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi of"><img src="../Images/6dacc25af7ff547eea02a7ec596a5237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCW7zZS-zOjtIgGYI6uxfQ.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk">plot_histogram(trials) of the <a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/e/BLOG-165/details" rel="noopener ugc nofollow" target="_blank">best experiment</a></figcaption></figure><ul class=""><li id="5069" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated">哪个…我真的不知道它是做什么的，因为我无法让它运行，也没有文档字符串或示例(同样，文档也远非完美)。</li></ul><p id="a27a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">有一些基本的可视化工具，但它们不是非常有用。感觉像<strong class="jy ja"> 3/10 </strong>。</p><blockquote class="np nq nr"><p id="0564" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">分数 3/10 </strong></p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="8974" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">注</strong></p><p id="ba06" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">正如我在上一篇帖子中提到的，我喜欢 Scikit-Optimize 提供的图形，并且我实现了一组函数来帮助在不同的 HPO 库之间进行转换，以便您可以对每个库使用这些可视化。我已经把它们放在<code class="fe nl nm nn no b">neptune-contrib</code>包里，你可以在这里<a class="ae ku" href="https://neptune-contrib.readthedocs.io/user_guide/hpo/utils.html" rel="noopener ugc nofollow" target="_blank">查看如何使用</a>。</p><h2 id="89e7" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">持续/重启</h2><p id="de21" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated">你可以先处理一下<code class="fe nl nm nn no b">trials</code>对象，以后再用。例如，保存部分可以读作:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3133" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">pickle 会再次加载，而重新启动就像传递<code class="fe nl nm nn no b">trials</code>对象(现在不为空)并将<strong class="jy ja"> max_evals </strong>从 100 更改为 200 一样简单。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8869" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">简单且工作没有问题:<strong class="jy ja"> 10/10。</strong></p><blockquote class="np nq nr"><p id="da6c" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">分数 10/10 </strong></p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="8415" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">速度和并行化</h2><p id="49ad" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated">使用 hyperopt，您可以将计算分布在一组机器上。Tanay Agrawal 撰写的这篇<a class="ae ku" href="https://blog.goodaudience.com/on-using-hyperopt-advanced-machine-learning-a2dde2ccece7" rel="noopener ugc nofollow" target="_blank">博客文章</a>中可以找到很好的分步指导，但简而言之，你需要:</p><ul class=""><li id="4509" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated">启动一个装有 MongoDB 的服务器，它将使用您的工人培训脚本的结果，并发送下一个参数集进行尝试，</li><li id="13eb" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">在您的训练脚本中，创建一个指向您在上一步中启动的数据库服务器的<code class="fe nl nm nn no b">MongoTrials</code>对象，而不是<code class="fe nl nm nn no b">Trials()</code>,</li><li id="52cc" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">将您的<em class="ns">目标</em>函数移动到一个单独的 objective.py 脚本中，并将其重命名为<em class="ns">函数，</em></li><li id="b0ca" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">编译您的 Python 训练脚本，</li><li id="c7d1" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">运行<em class="ns">远视-蒙哥-工人</em></li></ul><p id="9e33" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">虽然它完成了任务，但感觉并不完美。您需要围绕<em class="ns">目标</em>函数做一些杂耍，在 CLI 中启动 MongoDB 会使事情变得更容易。</p><p id="527c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">因为上面的<strong class="jy ja"> 8/10 </strong>对我感觉很公平。</p><blockquote class="np nq nr"><p id="b13c" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">得分 8/10 </strong></p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="81ef" class="mt lk iq bd ll mu mv dn lp mw mx dp lt kh my mz lx kl na nb mb kp nc nd mf iw bi translated">实验结果</h2><p id="5fb2" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated">你可以在海王星探索所有<a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/experiments?tag=%5B%22hyperopt%22%5D&amp;viewId=95618c17-ba92-4e89-aca5-27288a6b6286&amp;utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=explore-dashboard" rel="noopener ugc nofollow" target="_blank">版本化的 ml 实验</a>。每个实验都有一个脚本。例如，你可以在这里看到<a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/e/BLOG-194/source-code?path=.&amp;file=source&amp;utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=explore-script" rel="noopener ugc nofollow" target="_blank">最佳的代码。</a></p><p id="8591" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">还可以下载实验元数据给<em class="ns">熊猫。数据帧</em>通过运行:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="af2e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们来看看<a class="ae ku" href="https://ui.neptune.ml/jakub-czakon/blog-hpo/experiments?tag=%5B%22hyperopt%22%5D&amp;viewId=95618c17-ba92-4e89-aca5-27288a6b6286&amp;utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=explore-dashboard" rel="noopener ugc nofollow" target="_blank">的实验结果:</a></p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ok"><img src="../Images/d0bf0f2ccb880ab86ebd3f7675d6821e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAI4IlX8ftIgrsA5qPU0bg.png"/></div></div></figure><p id="ec2e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">只有当我们运行更多的迭代时,<code class="fe nl nm nn no b">tpe</code>方法才略微胜出。在 100 次迭代的预定义预算中，<code class="fe nl nm nn no b">random</code>搜索略胜<code class="fe nl nm nn no b">tpe</code>。</p><p id="5b35" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">查看 Scikit 的<em class="ns"> plot_evaluations </em>图表——优化最佳 100 次迭代实验:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ol"><img src="../Images/1e6a025ba570ac5abedbcd4531ee1119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwX2FbL2PK9QnFuJ1Zgwsg.png"/></div></div></figure><p id="f459" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以看到，只有对于<strong class="jy ja"> feature_fraction </strong>参数，搜索实际上已经转向某个方向。否则，它基本上是随机的(这解释了为什么结果如此接近随机搜索)。</p><p id="fe35" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">总的来说，我在 100 次迭代中得到的最高分仅仅是 0.84509，实际上比随机搜索(来自 Scikit-Optimize)的 0.8464 差了 0.001。我将把它转换成<strong class="jy ja"> -1 </strong>点(-0.001*100)。</p><blockquote class="np nq nr"><p id="fd08" class="jw jx ns jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ij bi translated"><strong class="jy ja">分数–1</strong></p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="2367" class="lj lk iq bd ll lm om lo lp lq on ls lt lu oo lw lx ly op ma mb mc oq me mf mg bi translated">结论</h1><p id="408d" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated"><a class="ae ku" href="https://github.com/hyperopt/hyperopt" rel="noopener ugc nofollow" target="_blank">hyperpt</a>是一款经典产品，已经为社区服务多年。它有一个易于使用的 API，可以在一个机器集群上并行计算，并且对嵌套搜索空间有很好的支持。</p><p id="d83e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">然而，它的文档有限，只有很少的例子和文档字符串，这使得它很难使用，尤其是在黄金路径之外。Visualization suite 也非常有限，并没有带来很多价值。有点麻烦的是，对于我们的示例问题，它无法打败随机搜索。</p><p id="3499" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">让我们来看看所有标准的结果:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi or"><img src="../Images/af71a5322ff353abd25b31a77df1fff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*9tGLpn-PZ33k0UGyACNuGQ.png"/></div></figure><p id="6e11" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> 39 </strong>的分数远低于 Scikit-Optimize 的分数。最大的因素是文档、可视化和实验结果。</p><h1 id="88d9" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">下一步是什么？</h1><p id="02e9" class="pw-post-body-paragraph jw jx iq jy b jz ne kb kc kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt ij bi translated">下次我们将仔细看看另一个用于超参数优化 Optuna 的 Tree-Parzen 估计器库。</p><p id="1d48" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">你可以在这里查看这个系列的第三部分</strong> <a class="ae ku" href="https://neptune.ml/blog/optuna-vs-hyperopt?utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=blog" rel="noopener ugc nofollow" target="_blank"> <strong class="jy ja"> Optuna vs 远视。</strong> </a></p><p id="3c6b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">你也可以在我的 Python  专栏的<a class="ae ku" href="https://towardsdatascience.com/tagged/hpo-in-python" rel="noopener" target="_blank"> <strong class="jy ja"> HPO 中阅读这个系列的其他帖子。</strong></a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="1177" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><em class="ns">如果你喜欢这个，你可以在我们的</em> <a class="ae ku" href="https://neptune.ml/blog?utm_source=medium&amp;utm_medium=crosspost&amp;utm_campaign=blog-hyperopt-medium&amp;utm_content=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ns"> Neptune 博客上找到更多类似的帖子。</em> </a></p><p id="a17b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><em class="ns">你也可以找我</em> <a class="ae ku" href="https://twitter.com/neptune_ai" rel="noopener ugc nofollow" target="_blank"> <em class="ns">发微博@Neptune_a </em> </a> <em class="ns">我或者</em> <a class="ae ku" href="https://www.linkedin.com/in/jakub-czakon-2b797b69/" rel="noopener ugc nofollow" target="_blank"> <em class="ns">在 LinkedIn 上发帖</em> </a> <em class="ns">关于 ML 和数据科学的东西。</em></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="bffb" class="lj lk iq bd ll lm om lo lp lq on ls lt lu oo lw lx ly op ma mb mc oq me mf mg bi translated">参考</h1><pre class="mi mj mk ml gt os no ot ou aw ov bi"><span id="a30b" class="mt lk iq no b gy ow ox l oy oz">@book{automl_book,<br/>    editor = {Hutter, Frank and Kotthoff, Lars and Vanschoren, Joaquin},<br/>    note = {In press, available at http://automl.org/book.},<br/>    publisher = {Springer},<br/>    title = {Automated Machine Learning: Methods, Systems, Challenges},<br/>    year = {2018}<br/>}</span></pre></div></div>    
</body>
</html>