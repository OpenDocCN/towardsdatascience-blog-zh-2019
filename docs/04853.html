<html>
<head>
<title>Understanding RNNs by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解 RNNs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-rnns-by-example-c8cd52b13059?source=collection_archive---------28-----------------------#2019-07-22">https://towardsdatascience.com/understanding-rnns-by-example-c8cd52b13059?source=collection_archive---------28-----------------------#2019-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d3aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">训练你的 PyTorch 模型计数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c30d8b559ccec7906dad3829c02e1734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ceR17DLdGnsrLHxhHrrHA.jpeg"/></div></div></figure><p id="4d45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">成为机器学习实践者最艰难的任务之一是直观地理解模型背后的<em class="ln">魔力</em>。人们普遍认为你需要成为一名数学专家才能完全掌握底层的机制，但你真正需要的只是浏览几个基本的例子。掌握简单的模型会给你在复杂性增加时所需要的基础。</p><p id="e3fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有很多精彩的文章从较高的层面讲述了 RNN 是如何工作的，所以我将本课的内容提供给那些对自己实现一个具体示例感兴趣的人。</p><p id="cf4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章中的很多想法和插图都来源于<a class="ae lo" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> fast.ai </em> </a> <em class="ln"> </em>以及他们在 NLP 中的课程。</p><h1 id="686c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">RNNs 入门:</h1><p id="0e98" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">传统的前馈网络接收固定大小的输入，并产生固定大小的输出。当您的表格数据具有恒定的列数时，这非常有用，但是当您具有可变长度的序列(如音频、时间序列或我们示例中的文本)时，这就没什么用了。</p><p id="7341" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RNN 的<em class="ln">魔力</em>在于它将当前输入与先前或隐藏状态相结合的方式。这种隐藏状态可以简单地认为是模型的<strong class="kt ir">内存</strong>或<strong class="kt ir">上下文</strong>。如果我让你预测一个句子中的下一个单词，如果当前单词是“hot ”,那就不可能做出准确的猜测。如果你有一些比当前输入更多的记忆，比如“我吃了一个热的”，你可以更好地猜测下一个单词是“狗”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/1df0a8ad62678d641a979ab0c8718510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lJTnlinXJIKvHPvGtfc5Q.png"/></div></div></figure><p id="77ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于其简单性，rnn 的能力令人惊叹。rnn 只是一个循环，将它们的内存与当前输入相加，并通过线性层发送该组合值，以计算下一步的内存。在为每一步输入计算隐藏状态后，隐藏状态通过输出层发送，以进行最终预测。下面是这个循环的伪代码:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="28aa" class="ms lq iq mo b gy mt mu l mv mw">h = hidden_state_init()<br/>for word in words:<br/>   h += embedding(h)<br/>   h = linear(h)<br/>out = linear_output(h)<br/>return out</span></pre><p id="270c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将用英语教我们的 RNN 数数。例如，如果我们的输入是:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="68b0" class="ms lq iq mo b gy mt mu l mv mw">['one', 'thousand', 'three', 'hundred', 'tweleve', ',' , 'one']</span></pre><p id="26aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么序列中的下一个单词将是<em class="ln">‘千’</em>。</p><h1 id="8995" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">设置数据管道:</h1><h2 id="ce2d" class="ms lq iq bd lr mx my dn lv mz na dp lz la nb nc mb le nd ne md li nf ng mf nh bi translated">加载数据和构建词汇表:</h2><p id="f7f5" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">首先，我们需要加载<a class="ae lo" href="https://drive.google.com/file/d/1kTJc-73djl6mmGdNZjQxFJqJjXvBlGQC/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> train.txt </a>和<a class="ae lo" href="https://drive.google.com/file/d/1bdwi4_tSiuXmC0qpDpr3t5-q6O_B3sBr/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> valid.txt </a>文件，它们的数字分别从 1 到 8000 和 8000 到 9999。我们将把这些文件加载到一个字符串列表中，通过制作一组字符串来构建我们的词汇表，然后构造一个从每个字符串到一个整数的映射。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="7b5a" class="ms lq iq bd lr mx my dn lv mz na dp lz la nb nc mb le nd ne md li nf ng mf nh bi translated">创建批处理迭代器:</h2><p id="2896" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">当训练我们的模型时，我们希望输出比输入快一步。例如，如果当前输入是“二”，那么输出应该是“，”。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="eeab" class="ms lq iq mo b gy mt mu l mv mw">x = ['one', ',', 'two', ',', 'three', ',', 'four', ',', 'five', ','] <br/>y = [',', 'two', ',', 'three', ',', 'four', ',', 'five', ',', 'six']</span></pre><p id="3778" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个迭代器将首先生成形状的 2d 列表(bs，bptt ),其中 bs 代表批量大小，bptt 代表时间上的反向传播，或者基本上是序列中的字数。一旦我们生成了这些列表，我们就使用我们在上一步中构建的字典将令牌映射到它对应的整数。最后，我们将 2d 列表转换为 torch 张量，以便我们的模型可以处理它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="1fbc" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">训练第一个模型:</h1><p id="90fb" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">虽然 PyTorch 有一个专用的 RNN 层，但我们实际上将使用我们的循环来重新创建该层，这样我们可以更直观地掌握我们的层的顺序。我们的模型将由 4 个独特的层构成:</p><ul class=""><li id="5d4f" class="nk nl iq kt b ku kv kx ky la nm le nn li no lm np nq nr ns bi translated"><strong class="kt ir"> i_h(隐藏的输入):</strong>将输入(表示特定令牌的数字)映射到一个嵌入，其大小是我们定义的隐藏状态的 64</li><li id="4667" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated"><strong class="kt ir"> h_h (hidden to hidden): </strong>线性层将先前的隐藏状态+当前输入作为输入，并向前传播这些组合值以生成当前隐藏状态</li><li id="5b0f" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated"><strong class="kt ir"> h_o(隐藏到输出):</strong>线性层，正向传播当前隐藏状态，生成预测输出</li><li id="87e4" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated"><strong class="kt ir"> bn(批量标准化):</strong>移动和缩放激活以使<a class="ae lo" href="https://arxiv.org/pdf/1805.11604.pdf" rel="noopener ugc nofollow" target="_blank">优化场景明显更平滑</a>(不要担心这个！).</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2f30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们建立了模型，训练模型就相当于样板代码。然而，我将讨论一些关于我们的训练循环的细节。</p><ul class=""><li id="c446" class="nk nl iq kt b ku kv kx ky la nm le nn li no lm np nq nr ns bi translated">我们使用 Adam 作为我们的优化器，它和学习率一起决定在随机梯度下降(SGD)过程中减去梯度时的步长。</li><li id="3d85" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">我们使用交叉熵损失，这是任何分类任务中最常见的损失函数，并且通过对不正确答案的高概率猜测(假阳性)和正确答案的低概率猜测(假阴性)进行惩罚来工作。</li><li id="de0e" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">我们迭代 10 个时期，这意味着我们将暴露所有的输入 10 次。在每个时期内，我们使用 DataLM 迭代器通过迭代整个输入来构建批处理。</li><li id="393c" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">我们记录每一步的损失和准确性。注意，损失是为每个标记计算的，而准确度只是模型正确获得第 71 个标记的能力的度量。我会让你想想，如果我们为每个记号计算，精度会有什么变化。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="6393" class="ms lq iq mo b gy mt mu l mv mw">plt.plot(pd.Series(losses).rolling(4).mean())<br/>plt.plot(pd.Series(accuracy).rolling(4).mean())</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/2e26cd54f629bf616cf7380649b16a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iz2rPVSub2eULADcwvMa2w.png"/></div></div></figure><h1 id="d1b9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">改进模型:</h1><p id="5206" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们可以使用 PyTorch 的原生 RNN 层重构上面的模型，以获得与上面相同的结果。在实践中，您应该使用本机层，因为它更容易使用，并且由于一些 GPU 优化，运行速度更快。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ecf6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我们上面的演示表明，RNNs 可以有效地处理序列数据，但它们与长期依赖性作斗争。gru(门控循环单元)的功能与 rnn 非常相似，但在决定当前输入对当前状态的影响程度方面更智能。我很快会写一篇关于 GRUs 的文章，但与此同时，我会推荐这个由<a class="ae lo" href="https://www.youtube.com/watch?v=Bl6WVj6wQaE&amp;list=PLtmWHNX-gukKocXQOkQjuVxglSDYWsSh9&amp;index=15" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>做的讲座。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5cbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用 GRU 而不是 RNN，我们可以将准确率从略高于 50%提高到 95%。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/429adbc677bc7d94c716e1a730a380be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjPSGilAkkxRi1wnB6aTjQ.png"/></div></div></figure><h1 id="edc9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">测试模型:</h1><p id="6143" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们使用由数字 8001–9999 组成的验证列表，随机选择 20 个令牌。当我运行代码时，我对以下输入序列进行了采样:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="a635" class="ms lq iq mo b gy mt mu l mv mw">seven , nine thousand three hundred eight , nine thousand three hundred nine , nine thousand three hundred ten ,</span></pre><p id="b104" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将此输入运行到我们的模型中，以预测下一个令牌。在预测了那个记号之后，我们把它附加到输入中来预测另一个记号。我们重复这个输入→预测→连接→输入序列 20 步。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d716" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用与上面相同的输入字符串，我们得到以下输出:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="1666" class="ms lq iq mo b gy mt mu l mv mw">nine thousand three hundred eight , nine thousand three hundred nine , nine thousand three hundred ten , nine thousand nine hundred eleven , nine thousand nine hundred twelve , nine thousand nine hundred thirteen , nine thousand</span></pre><p id="66df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，当以 95%的准确率预测 20 个令牌时，我们只会在 36%的时间内得到正确的输出。根据经验，使用训练集，我在 80%的情况下得到正确的输出，在 45%的情况下使用验证得到正确的输出</p><h1 id="a077" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">总结:</h1><p id="4cd8" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">希望现在你对 RNN 的工作原理有了更好的理解，但是我不期望你完全掌握所有的细节。说到这里，我对如何加强你的理解有很多建议:</p><ul class=""><li id="1112" class="nk nl iq kt b ku kv kx ky la nm le nn li no lm np nq nr ns bi translated">如果你喜欢自上而下的结账方式<a class="ae lo" href="https://www.fast.ai/2019/07/08/fastai-nlp/" rel="noopener ugc nofollow" target="_blank"/></li><li id="3b45" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">如果你想深入了解数学，请访问关于序列模型的<a class="ae lo" href="https://www.coursera.org/learn/nlp-sequence-models" rel="noopener ugc nofollow" target="_blank"> deeplearning.ai </a>课程。</li><li id="bad9" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">如果你是动手型的，那么把 RNN 应用到另一个应用程序中。</li></ul><p id="de1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">参考文献:</strong></p><p id="619c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">J.霍华德，r .托马斯，<a class="ae lo" href="https://www.fast.ai/2019/07/08/fastai-nlp/" rel="noopener ugc nofollow" target="_blank">自然语言处理的代码优先介绍</a> (2019)，<a class="ae lo" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai </a></p></div></div>    
</body>
</html>