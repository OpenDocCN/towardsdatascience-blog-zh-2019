<html>
<head>
<title>How to use data version control (dvc) in a machine learning project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在机器学习项目中使用数据版本控制(dvc)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-data-version-control-dvc-in-a-machine-learning-project-a78245c0185?source=collection_archive---------9-----------------------#2019-07-27">https://towardsdatascience.com/how-to-use-data-version-control-dvc-in-a-machine-learning-project-a78245c0185?source=collection_archive---------9-----------------------#2019-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/909e7dbb5dda2b6df4bf43a014151da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxzCZ_x7oeKlq_NRTw6GeA.jpeg"/></div></div></figure><p id="6fe0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当在一个多产的机器学习项目中工作时，你可能会处理一些数据和几个模型。为了跟踪哪些模型是用哪些数据训练的，您应该使用一个系统来对数据进行版本化，类似于对代码进行版本化和跟踪。解决这个问题的一种方法是 dvc(数据版本控制，<a class="ae kz" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank">https://dvc.org/</a>)，它以类似于 Git 的方式处理数据版本控制。</p><p id="99ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了说明 dvc 在机器学习环境中的使用，我们假设默认情况下我们的数据分为训练、测试和验证文件夹，数据量随着时间的推移通过主动学习周期或通过手动添加新数据而增加。下面的结构就是一个例子，为了简化起见，这里省略了标签:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="19f6" class="lj lk it lf b gy ll lm l ln lo">├── train<br/>│    ├── image1.jpg<br/>│    ├── image2.jpg<br/>│    └── image3.jpg<br/>├── val<br/>│    └── image4.jpg<br/>└──test<br/>     └── image5.jpg</span></pre><p id="a025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，最低版本系统应该具有以下两种功能:</p><ul class=""><li id="deb2" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated">用新版本标记一组新数据，例如 vx.y.z</li><li id="df5a" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">返回旧数据版本或在不同数据版本之间切换非常容易</li></ul><p id="ff62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在其他功能中，dvc 能够完成这些任务。为此，它与 Git 紧密合作。首先，您需要安装 dvc，这可以使用 pip 来完成</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ca78" class="lj lk it lf b gy ll lm l ln lo">pip install dvc </span></pre><p id="598c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要开始版本化过程，您必须在数据的基本文件夹中创建一个 git 存储库，然后通过</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="82d8" class="lj lk it lf b gy ll lm l ln lo">git init<br/>dvc init</span></pre><p id="201a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过 init 命令，dvc 现在已经创建了一个包含其缓存的. dvc 文件夹，以便保存不同数据版本和存储元信息的配置文件之间的差异。</p><p id="1078" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，你想知道 git 如何适应这个概念:在这种情况下，git 的任务不是对数据本身进行版本化，而是对 dvc 文件进行版本化，DVC 文件保存了版本的元信息，如对应于特定版本的文件的位置，或者数据的哪个文件属于当前数据版本的信息。</p><p id="083c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让 git 忽略数据本身，dvc 还会自动写入。gitignore 文件。提交 dvc 的配置文件和。gitignore 文件我们需要做一个初始提交</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ce96" class="lj lk it lf b gy ll lm l ln lo">git commit -m “Initial commit”</span></pre><p id="3f10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个数据版本都与其自己的相关联。dvc 文件，同样与一个提交或一个 Git 头相关联。dvc 文件定义并跟踪给定版本的数据，由此 dvc 文件本身被 Git 跟踪。对我来说，将新数据版本与 Git 头相关联的一个好方法是为新数据版本创建一个新分支。为此，在定义我们的第一个版本之前，我们用版本的名称创建一个新的分支，并签出到这个分支:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="9119" class="lj lk it lf b gy ll lm l ln lo">git checkout -b v0.0.1</span></pre><p id="411b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以通过告诉 dvc 应该跟踪哪些数据来定义我们的第一个版本，在我们的例子中是 train、val 和 test 文件夹。这可以通过 dvc add 命令来完成:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c9b6" class="lj lk it lf b gy ll lm l ln lo">dvc add train test val</span></pre><p id="ccf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，我们现在看到新的。每个文件夹的 dvc 文件，如基本文件夹中的 train.dvc。文件夹本身已被添加到。gitignore，这样 git 就不会跟踪数据本身，在我们的例子中，这是 dvc 的任务。为了追踪新的。我们用 Git 创建了标准的 Git 提交过程</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="219b" class="lj lk it lf b gy ll lm l ln lo">git add .<br/>git commit -m "Data versioning files added to Git"</span></pre><p id="c57d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经创建了数据的第一个版本，将哪些数据属于我们的。dvc 文件并参考了。dvc 自己被当前提交。请注意，您还可以将 git 连接到远程 git 来保存和版本化。远程 dvc 文件。在这种情况下，数据保留在当前文件夹中，而不是远程存储(这也可以使用 dvc 推拉进行更改)。</p><p id="7d5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在已经将数据的一种状态与一个版本相关联，但是当然，您不需要为一个 fix 数据集进行数据版本化。因此，我们现在假设两个新图像(image6.jpg 和 image7.jpg)被添加到 train 和 test 文件夹中，因此结构现在看起来像这样:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="2628" class="lj lk it lf b gy ll lm l ln lo">├── train<br/>│    ├── image1.jpg<br/>│    ├── image2.jpg<br/>│    ├── image3.jpg<br/>│    └── image6.jpg<br/>├── val<br/>│    └── image5.jpg<br/>└── test<br/>     ├── image4.jpg  <br/>     └── image7.jpg</span></pre><p id="a0a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建新的数据版本，我们重复前面的步骤。因此，我们创建一个对应于新数据版本的新分支</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e3e9" class="lj lk it lf b gy ll lm l ln lo">git checkout -b v0.0.2</span></pre><p id="73fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们已经知道的，一个新的数据版本总是与它们自己相关联的。存储版本元信息的 dvc 文件。为了更新。dvc 文件我们需要告诉 dvc，它应该再次跟踪 train 和 test 文件夹，因为这些文件夹中有新数据:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="980e" class="lj lk it lf b gy ll lm l ln lo">dvc add train test</span></pre><p id="879b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">train.dvc 和 test.dvc 文件已更改，dvc 现在可以跟踪哪些文件属于当前版本。为了追踪新的。git 分支中的 dvc 文件，我们必须提交:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b34a" class="lj lk it lf b gy ll lm l ln lo">git add .<br/>git commit -m "Data versioning files added to Git"</span></pre><p id="49a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在爽的部分来了。当检查您的 git 分支时，您会看到两个不同的分支(主分支除外),其中每个分支对应一个数据版本:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="22c8" class="lj lk it lf b gy ll lm l ln lo">master<br/>v0.0.1<br/>* v0.0.2</span></pre><p id="418f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以返回到旧的数据版本，并直接更新您的数据目录，以便重新创建旧的数据版本。为了回到之前的版本，我们需要做两件事。首先，我们需要签出到数据版本的相应标题，在本例中是 branch v0.0.1:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="02b3" class="lj lk it lf b gy ll lm l ln lo">git checkout v0.0.1</span></pre><p id="4dd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个脑袋里。与 v0.0.2 相比，dvc 文件有所不同，但我们当前的数据目录看起来仍然相同，目录中的数据仍然对应于 v0.0.2。这是因为 dvc 尚未将数据目录与其对齐。dvc 文件。将您的数据目录与正确的数据版本对齐，这同样在。dvc 文件，需要执行 dvc checkout 命令:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4662" class="lj lk it lf b gy ll lm l ln lo">dvc checkout</span></pre><p id="09b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令使用其缓存恢复旧的数据版本(在本例中为 v0.0.1)。现在，当您查看您的数据存储库时，您会再次看到以下结构:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="db6b" class="lj lk it lf b gy ll lm l ln lo">├── train<br/>│    ├── image1.jpg<br/>│    ├── image2.jpg<br/>│    └── image3.jpg<br/>├── val<br/>│    └── image4.jpg<br/>└──test<br/>     └── image5.jpg</span></pre><p id="9ea9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文件 image6.jpg 和 image7.jpg 被从数据目录中删除并存储到 dvc 的缓存中。现在，您可以像往常一样使用三个文件夹来处理旧数据版本。</p><p id="78b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此过程还适用于包含比当前持久存储在数据文件夹中的数据多得多的数据版本，因为 dvc 在其缓存中存储不同版本之间任意大小的差异，因此可以通过其 checkout 命令重新创建数据目录的较旧或较新状态。当然，结账也可以是另一个方向。您可以将 git 签出到 branch v0.0.2 并执行 dvc 签出，以便将数据目录设置为 v0.0.2 版本的状态。</p><p id="14f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了 init、add 和 checkout 命令之外，dvc 还有更多功能，以便使机器学习/大数据工作流程更加简单。例如，可以在多台机器之间共享数据版本吗？使用像亚马逊的 S3 存储桶这样的远程存储桶，并使用 dvc 推拉与存储桶进行交互(有关详细信息，请参见。<a class="ae kz" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank">https://dvc.org/</a>。</p><p id="e39d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章可以帮助更好地组织机器学习项目中的数据，并保持更好的概览。</p><p id="31cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更多关于机器学习、数据科学和统计学的博文，请查看<a class="ae kz" href="http://www.matthias-bitzer.de" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>