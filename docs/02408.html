<html>
<head>
<title>Top 10 Coding Mistakes Made by Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家犯的 10 大编码错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-10-coding-mistakes-made-by-data-scientists-bb5bc82faaee?source=collection_archive---------4-----------------------#2019-04-20">https://towardsdatascience.com/top-10-coding-mistakes-made-by-data-scientists-bb5bc82faaee?source=collection_archive---------4-----------------------#2019-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8acf53aa6b0888aef17ec9f47d9081be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgHLTpv2-qNpPgNe7iuofQ.png"/></div></div></figure><p id="af41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据科学家是“比任何软件工程师更擅长统计，比任何统计学家更擅长软件工程的人”。许多数据科学家有统计学背景，但对软件工程几乎没有经验。我是一名高级数据科学家，在 python 编码的 Stackoverflow 上排名前 1%，与许多(初级)数据科学家一起工作。以下是我经常看到的 10 个常见错误。</p><h1 id="6e98" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1.不要共享代码中引用的数据</h1><p id="cab3" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">数据科学需要代码和数据。因此，为了让其他人能够复制你的结果，他们需要能够访问这些数据。看起来很简单，但是很多人忘记了与他们的代码共享数据。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a046" class="ml la it mh b gy mm mn l mo mp">import pandas as pd<br/>df1 = pd.read_csv('file-i-dont-have.csv') # fails<br/>do_stuff(df)</span></pre><p id="f014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:使用<a class="ae mq" href="https://github.com/d6t/d6tpipe" rel="noopener ugc nofollow" target="_blank"> d6tpipe </a>与您的代码共享数据文件，或者上传到 S3/web/google drive 等，或者保存到一个数据库中，以便接收方可以检索文件(但不要将它们添加到 git 中，见下文)。</p><h1 id="8d38" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">2.硬编码不可访问的路径</h1><p id="5487" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">类似于错误 1，如果你硬编码了其他人不能访问的路径，他们就不能运行你的代码，并且不得不寻找很多地方来手动改变路径。Booo！</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4ab8" class="ml la it mh b gy mm mn l mo mp">import pandas as pd<br/>df = pd.read_csv('/path/i-dont/have/data.csv') # fails<br/>do_stuff(df)</span><span id="7136" class="ml la it mh b gy mr mn l mo mp"># or <br/>impor os<br/>os.chdir('c:\\Users\\yourname\\desktop\\python') # fails</span></pre><p id="c201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:使用相对路径、全局路径配置变量或<a class="ae mq" href="https://github.com/d6t/d6tpipe" rel="noopener ugc nofollow" target="_blank"> d6tpipe </a>来使你的数据易于访问。</p><h1 id="d68b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">3.将数据与代码混合</h1><p id="9982" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">既然数据科学代码需要数据，为什么不把它转储到同一个目录中呢？当你这么做的时候，把图片、报告和其他垃圾也保存在那里。呀，真是一团糟！</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6f8e" class="ml la it mh b gy mm mn l mo mp">├── data.csv<br/>├── ingest.py<br/>├── other-data.csv<br/>├── output.png<br/>├── report.html<br/>└── run.py</span></pre><p id="7023" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:将你的目录分类，比如数据、报告、代码等等。参见<a class="ae mq" href="https://drivendata.github.io/cookiecutter-data-science/#directory-structure" rel="noopener ugc nofollow" target="_blank"> Cookiecutter Data Science </a>或<a class="ae mq" href="https://github.com/d6t/d6tflow-template" rel="noopener ugc nofollow" target="_blank"> d6tflow 项目模板</a>并使用#1 中提到的工具来存储和共享数据。</p><h1 id="3142" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">4.Git 用源代码提交数据</h1><p id="1566" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">大多数人现在控制他们代码的版本(如果你不这样做，那是另一个错误！！参见<a class="ae mq" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>。为了共享数据，将数据文件添加到版本控制中可能很有诱惑力。这对于非常小的文件来说是可以的，但是 git 并不适合数据，尤其是大文件。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6032" class="ml la it mh b gy mm mn l mo mp">git add data.csv</span></pre><p id="ec81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:使用#1 中提到的工具来存储和共享数据。如果你真的想要版本控制数据，参见<a class="ae mq" href="https://github.com/d6t/d6tpipe" rel="noopener ugc nofollow" target="_blank"> d6tpipe </a>、<a class="ae mq" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank"> DVC </a>和<a class="ae mq" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"> Git 大文件存储</a>。</p><h1 id="fd12" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">5.编写函数而不是 Dag</h1><p id="72cc" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">数据说够了，让我们来谈谈实际的代码！由于学习编码时首先要学习的是函数，因此数据科学代码通常被组织成一系列线性运行的函数。这导致了几个问题，参见<a class="ae mq" rel="noopener" target="_blank" href="/4-reasons-why-your-machine-learning-code-is-probably-bad-c291752e4953">你的机器学习代码可能不好的 4 个原因</a>。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="acab" class="ml la it mh b gy mm mn l mo mp">def process_data(data, parameter):<br/>    data = do_stuff(data)<br/>    data.to_pickle('data.pkl')</span><span id="f6fb" class="ml la it mh b gy mr mn l mo mp">data = pd.read_csv('data.csv')<br/>process_data(data)<br/>df_train = pd.read_pickle(df_train)<br/>model = sklearn.svm.SVC()<br/>model.fit(df_train.iloc[:,:-1], df_train['y'])</span></pre><p id="6581" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:与其线性链接函数，不如将数据科学代码编写为一组任务，这些任务之间存在依赖关系。使用<a class="ae mq" href="https://github.com/d6t/d6tflow" rel="noopener ugc nofollow" target="_blank">d6t 气流</a>或<a class="ae mq" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">气流</a>。</p><h1 id="9450" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">6.编写循环</h1><p id="3dda" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">像函数一样，for 循环是你学习编码的第一件事。容易理解，但是它们速度慢且过于冗长，通常表明您不知道矢量化的替代方法。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c5b0" class="ml la it mh b gy mm mn l mo mp">x = range(10)<br/>avg = sum(x)/len(x); std = math.sqrt(sum((i-avg)**2 for i in x)/len(x));<br/>zscore = [(i-avg)/std for x]<br/># should be: scipy.stats.zscore(x)</span><span id="42e3" class="ml la it mh b gy mr mn l mo mp"># or<br/>groupavg = []<br/>for i in df['g'].unique():<br/>	dfg = df[df[g']==i]<br/>	groupavg.append(dfg['g'].mean())<br/># should be: df.groupby('g').mean()</span></pre><p id="1ef8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:<a class="ae mq" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>、<a class="ae mq" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> scipy </a>和<a class="ae mq" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>对大多数你认为循环可能需要的东西都有向量化函数。</p><h1 id="9d5b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">7.不要写单元测试</h1><p id="2d91" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">随着数据、参数或用户输入的变化，您的代码可能会中断，有时您并没有注意到。这会导致糟糕的结果，如果有人根据你的结果做决定，糟糕的数据会导致糟糕的决定！</p><p id="e7fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:使用<code class="fe ms mt mu mh b">assert</code>语句检查数据质量。<a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/general_utility_functions.html#testing-functions" rel="noopener ugc nofollow" target="_blank"> pandas </a>有相等测试，<a class="ae mq" href="https://github.com/d6t/d6tstack" rel="noopener ugc nofollow" target="_blank"> d6tstack </a>有数据接收检查，<a class="ae mq" href="https://github.com/d6t/d6tjoin/blob/master/examples-prejoin.ipynb" rel="noopener ugc nofollow" target="_blank"> d6tjoin </a>有数据连接检查。数据检查示例代码:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1f10" class="ml la it mh b gy mm mn l mo mp">assert df['id'].unique().shape[0] == len(ids) # have data for all ids?<br/>assert df.isna().sum()&lt;0.9 # catch missing values<br/>assert df.groupby(['g','date']).size().max() ==1 # no duplicate values/date?<br/>assert d6tjoin.utils.PreJoin([df1,df2],['id','date']).is_all_matched() # all ids matched?</span></pre><h1 id="8e3c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">8.不要记录代码</h1><p id="fca7" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我明白了，你急着做分析。你把事情拼凑起来，把结果交给你的客户或老板。然后一周后他们回来说“你能改变 xyz 吗”或者“你能更新这个吗”。你看着你的代码，却不记得你为什么要这么做。现在想象其他人必须运行它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ca61" class="ml la it mh b gy mm mn l mo mp">def some_complicated_function(data):<br/>	data = data[data['column']!='wrong']<br/>	data = data.groupby('date').apply(lambda x: complicated_stuff(x))<br/>	data = data[data['value']&lt;0.9]<br/>	return data</span></pre><p id="8729" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:花额外的时间，即使是在你完成分析之后，来记录你做了什么。你会感谢你自己，别人会更感谢你！你会看起来像个专业人士！</p><h1 id="fd31" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">9.将数据保存为 csv 或 pickle</h1><p id="bdc4" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">背数据，毕竟是数据科学。就像函数和 for 循环一样，CSV 和 pickle 文件是常用的，但它们实际上并不是很好。CSV 不包含模式，所以每个人都必须再次解析数字和日期。Pickles 解决了这个问题，但是只能在 python 中工作，并且没有被压缩。这两种格式都不适合存储大型数据集。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e294" class="ml la it mh b gy mm mn l mo mp">def process_data(data, parameter):<br/>    data = do_stuff(data)<br/>    data.to_pickle('data.pkl')</span><span id="379e" class="ml la it mh b gy mr mn l mo mp">data = pd.read_csv('data.csv')<br/>process_data(data)<br/>df_train = pd.read_pickle(df_train)</span></pre><p id="f3fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:使用带有数据模式的 parquet 或其他二进制数据格式，最好是压缩数据的格式。<a class="ae mq" href="https://github.com/d6t/d6tflow" rel="noopener ugc nofollow" target="_blank"> d6tflow </a>自动将任务的数据输出保存为 parquet，这样你就不用处理了。</p><h1 id="fec2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">10.使用 jupyter 笔记本</h1><p id="f69d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们以一个有争议的问题来结束:jupyter 笔记本和 CSV 一样普遍。很多人都在用。这并不意味着他们是好人。Jupyter 笔记本助长了上面提到的许多坏的软件工程习惯，特别是:</p><ol class=""><li id="6dc5" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">您很想将所有文件都转储到一个目录中</li><li id="3939" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">您编写自顶向下运行的代码，而不是 Dag</li><li id="3511" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">你没有模块化你的代码</li><li id="c5b7" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">难以调试</li><li id="47a5" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">代码和输出混合在一个文件中</li><li id="fd2b" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">他们没有很好的版本控制</li></ol><p id="bf7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感觉很容易上手，但是扩展性很差。</p><p id="9e2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方法:使用<a class="ae mq" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> pycharm </a>和/或<a class="ae mq" href="https://www.spyder-ide.org/" rel="noopener ugc nofollow" target="_blank"> spyder </a>。</p></div></div>    
</body>
</html>