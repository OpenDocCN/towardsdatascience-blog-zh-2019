<html>
<head>
<title>Step-by-Step Guide to Creating R and Python Libraries (in JupyterLab)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建 R 和 Python 库的分步指南(在 JupyterLab 中)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911?source=collection_archive---------3-----------------------#2019-03-30">https://towardsdatascience.com/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911?source=collection_archive---------3-----------------------#2019-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2af2b09fe3ddbff724782f2f103fdcc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PKhe_Cklu8uDIHhg5-WlQ.png"/></div></div></figure><p id="533b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">r 和 Python 是当今机器学习语言的面包和黄油。r 提供了强大的统计和快速的可视化，而 Python 提供了直观的语法和丰富的支持，是当今主流 AI 框架的首选接口。</p><p id="b77b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将看看用 R 和 Python 创建库的步骤。这是每个机器学习从业者都应该拥有的技能。库帮助我们组织代码并与他人共享，为数据社区提供打包的功能。</p><blockquote class="kx ky kz"><p id="851a" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:在本文中，我交替使用了术语“<em class="iq">库”</em>和“<em class="iq">包”</em>。虽然有些人区分这些词，但我不认为这种区分有用，而且很少在实践中看到这样做。我们可以把一个<strong class="ka ir">库</strong>(或者<strong class="ka ir">包</strong>)想象成一个包含函数的脚本目录。这些功能组合在一起，帮助工程师和科学家解决挑战。</p></blockquote><h2 id="a957" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">创建图书馆的重要性</h2><p id="08f9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如果不广泛使用库，构建今天的软件是不可能的。库极大地减少了团队将工作投入生产所需的时间和精力。通过利用开源社区，工程师和科学家可以将他们独特的贡献推向更多的受众，并有效地提高他们代码的质量。各种规模的公司都使用这些库来将他们的工作置于现有功能之上，从而使产品开发更加高效和集中。</p><p id="3828" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是创建库不仅仅是为了生产软件。库对于快速原型化想法至关重要，可以帮助团队快速验证假设和制作实验软件。虽然流行的图书馆享有大量的社区支持和一套最佳实践，但较小的项目可以在一夜之间转化为图书馆。</p><p id="ce1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过学习创建轻量级的库，我们养成了维护代码和共享工作的习惯。我们自己的开发速度大大加快，我们将编码工作锚定在一个有形的工作单元上，我们可以随着时间的推移而改进。</p><h2 id="6158" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">文章范围</h2><p id="7316" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本文中，我们将重点关注用 R 和 Python 创建库，以及在 GitHub 上托管和安装它们。这意味着我们不会关注流行的托管站点，比如 R 的<strong class="ka ir"> CRAN </strong>和 Python 的<strong class="ka ir"> PyPI </strong>。这些额外的步骤超出了本文的范围。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2af2b09fe3ddbff724782f2f103fdcc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PKhe_Cklu8uDIHhg5-WlQ.png"/></div></div></figure><p id="dedb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只关注 GitHub 有助于鼓励从业者更频繁地开发和共享库。CRAN 和 PyPI 有许多必须满足的标准(它们经常变化)，这会减慢我们发布工作的过程。请放心，其他人从 GitHub 安装我们的库也一样容易。此外，CRAN 和 PyPI 的步骤可以在以后添加，如果你觉得你的库可以从托管站点中受益的话。</p><p id="6cf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用相同的环境(JupyterLab)构建 R 和 Python 库，对这两种语言使用相同的高级步骤。这应该有助于您建立将代码打包成库所需的核心步骤的工作知识。</p><p id="8633" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始吧。</p><h1 id="ef35" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">设置</h1><p id="bbbb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们将用 R 和 Python 创建一个名为<strong class="ka ir"> datapeek </strong>的库。datapeek 库是一个简单的包，提供了一些处理原始数据的有用函数。这些功能是:</p><p id="8a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">encode_and_bind</code></p><p id="3594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">remove_features</code></p><p id="5bcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">apply_function_to_column</code></p><p id="4cc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">get_closest_string</code></p><p id="8721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在后面研究这些函数。现在，我们需要设置一个 R 和 Python 环境来创建 datapeek，以及一些支持打包代码的库。我们将在一个<strong class="ka ir"> Docker </strong>容器中使用<strong class="ka ir"> JupyterLab </strong>，以及一个我们需要的“Docker 栈”。</p><h2 id="85e5" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">安装并运行 Docker</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/26d3817339901f81c30fd44a68064a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8ko91wVC74zI-4KEbWt1g.png"/></div></div></figure><p id="dd3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用的<a class="ae nb" href="https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks" rel="noopener ugc nofollow" target="_blank"> Docker 栈</a>被称为<a class="ae nb" href="https://hub.docker.com/r/jupyter/datascience-notebook/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">jupyter/data science-notebook</strong></a>。该图包含 R 和 Python 环境，以及许多通常在机器学习中使用的包。</p><p id="9a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这些都是在 Docker 里面运行的，所以你必须在你的机器上安装 Docker。所以<a class="ae nb" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">安装 Docker </strong> </a>如果你还没有的话，一旦安装好，在<strong class="ka ir">终端</strong>中运行以下命令<em class="kw">拉</em>data science-notebook:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="11ab" class="ld le iq mz b gy ng nh l ni nj">docker pull jupyter/datascience-notebook</span></pre><p id="4461" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将提取 Docker Hub 上托管的最新图像。</p><blockquote class="kx ky kz"><p id="1e99" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> : </strong>任何时候你从 Docker Hub 拉一个项目，你都会得到最新的版本。如果距离上次拉动已经过了一段时间，请再次拉动以更新您的图像。</p></blockquote><p id="1c99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行上述命令后，您应该立即看到以下内容:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/68ec062bd8bd050467826ff4d424c0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8cET57hA_rBgT5Se9r5DCw.gif"/></div></figure><p id="e487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦所有东西都被取出，我们就可以通过运行以下命令来确认我们的新映像存在:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="4629" class="ld le iq mz b gy ng nh l ni nj">docker images</span></pre><p id="bf50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…显示类似如下的内容:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/a1c0c4972c43f5cbc44e2c273429676b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDqVs2M0xHXxG7xe-F2dEQ.png"/></div></div></figure><p id="7559" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了 Docker 堆栈，让我们来设置 JupyterLab。</p><h2 id="d289" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">JupyterLab</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/c9ee9d987a4e89c51426dc9c280535ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvChjy5ca-tQSpIgIO3Fug.png"/></div></div></figure><p id="c711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在一个<strong class="ka ir"> JupyterLab </strong>环境中创建我们的库。JupyterLab 是一个基于 web 的编程用户界面。有了 JupyterLab，我们在浏览器中有了一个轻量级的 IDE，方便了构建快速应用程序。JupyterLab 提供了用 R 和 Python 创建库所需的一切，包括:</p><ul class=""><li id="0798" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated">一个<strong class="ka ir">终端</strong>环境，用于运行 shell 命令和下载/安装库；</li><li id="8beb" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">一个 R 和 Python <strong class="ka ir">控制台</strong>，用于与这些语言交互工作；</li><li id="dcd4" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">一个简单的<strong class="ka ir">文本编辑器</strong>，用于创建各种扩展名的文件；</li><li id="6948" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">Jupyter <strong class="ka ir">笔记本</strong>用于 ML 工作的原型制作。</li></ul><p id="2875" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚获取的 datascience-notebook 包含 JupyterLab 的安装，因此我们不需要单独安装它。在运行我们的 Docker 映像之前，我们需要<strong class="ka ir">挂载一个卷</strong>来确保我们的工作<strong class="ka ir">保存在容器</strong>之外。</p><p id="65ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，<strong class="ka ir">在你的桌面上创建一个名为 datapeek </strong>的文件夹(或者任何你想创建的地方),然后进入这个目录。我们需要<strong class="ka ir">用 JupyterLab </strong>，<strong class="ka ir"> </strong>运行 Docker 容器，因此我们的完整命令应该如下所示:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="2d84" class="ld le iq mz b gy ng nh l ni nj">docker run -it -v `pwd`:/home/jovyan/work -p 8888:8888 jupyter/datascience-notebook start.sh jupyter lab</span></pre><p id="d979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里了解更多关于 Docker 命令的信息。重要的是，上面的命令公开了我们在端口 8888 上的环境，这意味着我们可以通过浏览器访问我们的容器。</p><p id="05f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行以上命令后，您应该会在最后看到以下输出:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/3e1ed25a095f81ab3989f0285d3ae1e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uXyc3ciq7rm4sAAOeSljQ.png"/></div></div></figure><p id="ea0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这告诉我们将提供的 URL 复制并粘贴到浏览器中。打开浏览器，在地址栏中添加链接，然后按 enter 键(您的令牌会有所不同):</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="cbb9" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">localhost</strong>:8888/?token=11e5027e9f7cacebac465d79c9548978b03aaf53131ce5fd</span></pre><p id="2cb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在您的浏览器中自动打开 JupyterLab 作为一个新标签:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fe98de288fb4e5d67cdebee8d39d1138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_ZZOf24TPopHmYSWcxet0g.gif"/></div></figure><p id="a76c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在准备开始建造图书馆。</p><p id="96ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从<strong class="ka ir"> R </strong>开始这篇文章，然后看看<strong class="ka ir"> Python </strong>。</p><h1 id="39fe" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">在 R 中创建库</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/0bbee666b48c0eec6237cb024c392346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skPE8Bpx6n9eVWUiqzYc3g.png"/></div></div></figure><p id="fa76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">r 是机器学习的“两大”语言之一。在撰写本文时，它已经拥有超过 10，000 个图书馆。转到<em class="kw"> </em> <a class="ae nb" href="https://cran.r-project.org/web/packages/available_packages_by_date.html" rel="noopener ugc nofollow" target="_blank"> <em class="kw">按发布日期</em> </a>和运行日期列出的可用起重机包…</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="2137" class="ld le iq mz b gy ng nh l ni nj">document.getElementsByTagName('tr').length</span></pre><p id="47b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…在浏览器控制台中显示 13858。减去标题和最后一行，得到<strong class="ka ir"> 13856 </strong>个包装。不用说，R 不需要变化。凭借强大的社区支持和简洁(如果不是直观的话)的语言，R 轻松地位居值得学习的统计语言之首。</p><p id="c0e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于创建 R 包最著名的论文是哈德利·威卡姆的书<a class="ae nb" href="http://r-pkgs.had.co.nz" rel="noopener ugc nofollow" target="_blank"> R 包</a>。它的内容可以在网上免费获得。如果想更深入地了解这个话题，我建议去那里看看。</p><p id="340b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用 Hadley 的<strong class="ka ir"> devtools </strong>包来抽象出创建包所涉及的繁琐任务。dev tools<em class="kw">已经安装</em>在我们的 Docker Stacks 环境中。我们还需要<strong class="ka ir"> roxygen2 </strong>包，它帮助我们记录我们的函数。因为它没有预装我们的映像，所以让我们现在安装它。</p><blockquote class="kx ky kz"><p id="f7a3" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:从现在开始我们将<strong class="ka ir">使用 JupyterLab </strong>中的终端，以便于在浏览器中保存我们的工作。</p></blockquote><p id="58fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开 JupyterLab 发射器内的终端:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/31e4ae9e6118bb5bbb53b4bb41c3d952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzTRuvR7xCOFz7CMlT683Q.png"/></div></div></figure><blockquote class="kx ky kz"><p id="9152" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:如果您想将 JupyterLab 更改为<strong class="ka ir">黑暗主题</strong>，点击顶部的<em class="iq">设置</em>，点击<em class="iq"> JupyterLab 主题</em>，然后点击<em class="iq"> JupyterLab 黑暗</em>:</p></blockquote><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/eccf48f0e70692b7244a4990733734f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3v7vHBmv0ZnkFDNef3hQQ.png"/></div></div></figure><p id="d16f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在控制台内键入 R，然后…</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="2973" class="ld le iq mz b gy ng nh l ni nj">install.packages("roxygen2")<br/>library(roxygen2)</span></pre><p id="de53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装好必要的软件包后，我们就可以开始每一步了。</p><h1 id="428b" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 1:创建包框架</h1><p id="32a9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们需要为我们的包创建一个目录。我们可以使用 devtools <strong class="ka ir"> create </strong>函数，在一行代码中做到这一点。在终端运行中:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="8bd4" class="ld le iq mz b gy ng nh l ni nj">devtools::create("datapeek")</span></pre><p id="18f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将自动创建定义我们的 R 包所需的基本文件和目录。在 JupyterLab 中，你会在左侧看到一组新创建的文件夹和文件。</p><blockquote class="kx ky kz"><p id="0099" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:你还会看到你的新目录结构在你的桌面上(或者你选择创建它的任何地方)被创建，因为我们<strong class="ka ir">在设置期间挂载了一个卷</strong>到我们的容器中。</p></blockquote><p id="50d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们在 JupyterLab 检查我们的包装，我们现在看到:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="f245" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">R</strong><br/>├── datapeek.Rproj<br/>├── DESCRIPTION<br/>├── NAMESPACE</span></pre><p id="4fae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> R </strong>文件夹最终会包含我们的<em class="kw"> R 代码</em>。<strong class="ka ir">我的包。Rproj </strong>文件是特定于<em class="kw"> RStudio </em> IDE 的，所以我们可以忽略它。<strong class="ka ir">描述</strong>文件夹存放我们包的<em class="kw">元数据</em>(关于<em class="kw"> </em>的详细讨论可以在<a class="ae nb" href="http://r-pkgs.had.co.nz/description.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。最后，<strong class="ka ir"> NAMSPACE </strong>是一个确保我们的库<a class="ae nb" href="http://r-pkgs.had.co.nz/namespace.html" rel="noopener ugc nofollow" target="_blank">与其他库</a>很好地配合的文件，并且更多的是一个 CRAN 需求。</p><h2 id="7c1a" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">命名规格</h2><p id="eee1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">命名 R 包时，我们必须遵循这些<strong class="ka ir">规则</strong>:</p><ul class=""><li id="f465" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated">在<strong class="ka ir">曲柄</strong>上必须是唯一的(你可以在这里查看所有当前的 R 库<a class="ae nb" href="https://cran.r-project.org/web/packages/available_packages_by_name.html" rel="noopener ugc nofollow" target="_blank">)；</a></li><li id="e3e8" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><em class="kw">是否只能由<strong class="ka ir">字母</strong>、<strong class="ka ir">数字</strong>和<strong class="ka ir">句点</strong>组成</em>；</li><li id="f6c1" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><em class="kw">不能包含</em><em class="kw"/>下划线<strong class="ka ir">或<strong class="ka ir">连字符</strong>；</strong></li><li id="30f7" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><em class="kw">必须以<strong class="ka ir">字母</strong>开始</em>；</li><li id="a7bc" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">不能在<strong class="ka ir">周期</strong>内<em class="kw">结束</em>；</li></ul><p id="bc43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里阅读更多关于命名包<a class="ae nb" href="http://r-pkgs.had.co.nz/package.html" rel="noopener ugc nofollow" target="_blank">的内容。我们的包名“datapeek”通过了上述标准。让我们转向</a><a class="ae nb" href="https://cran.r-project.org/web/packages/available_packages_by_date.html" rel="noopener ugc nofollow" target="_blank">曲柄</a>并执行<em class="kw">命令+F </em>搜索“数据检查”以确保它没有被占用:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/f9e3c7a6a1a91fb27f1e8698740f099c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6DGXoNOenrFmkU1NkkuBsg.gif"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk">Command + F search on CRAN to check for <strong class="bd oj">package name uniqueness</strong>.</figcaption></figure><p id="c56d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…看起来我们很好。</p><h1 id="d396" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 2:填写描述细节</h1><p id="4195" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">文件的工作是存储关于我们包的重要元数据。这些数据包括运行我们的库所需的<strong class="ka ir">其他包</strong>，我们的<strong class="ka ir">许可证</strong>，以及我们的<strong class="ka ir">联系人</strong>信息。从技术上来说，R 中的包的定义是包含一个<code class="fe mw mx my mz b">DESCRIPTION</code>文件的任何目录，所以总是要确保它存在。</p><p id="f627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C <strong class="ka ir">点击 JupyterLab 目录列表中描述文件</strong>上的 <strong class="ka ir">。您将看到我们运行<code class="fe mw mx my mz b">devtools::create(“datapeek”)</code>时自动创建的基本细节:</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/f354783dcccca8b15c37f1310590bb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8m_8d37u-bn1qir0jzY_dg.png"/></div></div></figure><p id="3a1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加我们的具体细节，以便我们的包包含必要的元数据。只需在 JupyterLab 中编辑这个文件。以下是我补充的细节:</p><ul class=""><li id="45cd" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><strong class="ka ir">包装</strong> : <code class="fe mw mx my mz b">datapeek</code></li><li id="5fcd" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">标题</strong> : <code class="fe mw mx my mz b">Provides useful functions for working with raw data.</code></li><li id="c252" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">版本</strong> : <code class="fe mw mx my mz b">0.0.0.1</code></li><li id="1ee3" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">作者@R </strong> : <code class="fe mw mx my mz b">person(“Sean”, “McClure”, email=”sean.mcclure@example.com”, role=c('aut','cre'))</code></li><li id="c78f" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">描述</strong>:data peek 包帮助用户转换用于机器学习开发的原始数据。</li><li id="70d4" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">取决于</strong> : <code class="fe mw mx my mz b">R (≥ 3.5.1)</code></li><li id="dad4" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">执照</strong> : <code class="fe mw mx my mz b">MIT</code></li><li id="39d8" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">编码</strong> : <code class="fe mw mx my mz b">UTF-8</code></li><li id="6224" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir"> LazyData </strong> : <code class="fe mw mx my mz b">true</code></li></ul><p id="dc29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然你应该用你自己的细节填写这些部分。你可以在哈德利关于元数据的章节中读到更多关于这些的定义。作为一个简单的概述…这些<code class="fe mw mx my mz b">package</code>、<code class="fe mw mx my mz b">title</code>和<code class="fe mw mx my mz b">version</code>部分是不言自明的，只要确保<em class="kw">将</em> <code class="fe mw mx my mz b">title</code> <em class="kw">保持在一行</em>。<code class="fe mw mx my mz b">Authors@R</code>必须遵循你上面看到的格式，因为它包含可执行的 R 代码。注意<strong class="ka ir">角色</strong>参数，它允许我们列出本库的主要贡献者。常见的有:</p><p id="c06c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">aut</code> : <em class="kw">作者</em></p><p id="3e4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">cre</code> : <em class="kw">创建者或维护者</em></p><p id="7847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">ctb</code> : <em class="kw">投稿人</em></p><p id="5353" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">cph</code> : <em class="kw">版权所有者</em></p><p id="16ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有更多的选项，完整列表见<a class="ae nb" href="http://www.loc.gov/marc/relators/relaterm.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="a491" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过将多个作者列为一个向量来添加他们:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="da07" class="ld le iq mz b gy ng nh l ni nj">Authors@R: as.person(c(<br/>    "Sean McClure &lt;sean.mcclure@example.com&gt; [aut, cre]", <br/>    "Rick Deckard &lt;rick.deckard@example.com&gt; [aut]",<br/>    "<!-- -->Rachael<strong class="mz ir"> </strong>Tyrell<!-- --> &lt;rachel.tyrell@example.com&gt; [ctb]"<br/>))</span></pre><blockquote class="kx ky kz"><p id="6f61" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:如果你计划在 CRAN 上托管你的图书馆，确保你的电子邮件地址是正确的，因为 CRAN 会用这个联系你。</p></blockquote><p id="af80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">description</code>可以是多行，限 1 段。我们使用<code class="fe mw mx my mz b">depends</code>来指定我们的包所依赖的 R 的最低版本。您应该使用与您用来构建库的版本相同或更高的 R 版本。今天大多数人把他们的<code class="fe mw mx my mz b">License</code>设置为 MIT，它允许任何人“使用、复制、修改、合并、出版、分发、再许可和/或出售软件的拷贝”,只要你的版权包括在内。你可以在这里了解更多关于麻省理工学院许可证<a class="ae nb" href="https://opensource.org/licenses/MIT" rel="noopener ugc nofollow" target="_blank">的信息。<code class="fe mw mx my mz b">Encoding</code>确保我们的库可以使用现代解析器打开、读取和保存，而<code class="fe mw mx my mz b">LazyData</code>指的是如何加载我们包中的数据。因为我们将我们的设置为 true，这意味着我们的数据在被使用之前不会占用内存。</a></p><h1 id="dde9" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 3:添加函数</h1><h2 id="5265" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">3A:向 R 文件夹添加功能</h2><p id="b04c" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的图书馆没有功能就没什么用。让我们添加本文开头提到的 4 个函数。下面的<a class="ae nb" href="https://help.github.com/en/articles/about-gists" rel="noopener ugc nofollow" target="_blank">要点</a>显示了我们在 R 中的 datapeek 函数:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2978" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须将我们的函数添加到<strong class="ka ir"> R 文件夹</strong>，因为这是 R 在库中查找函数的地方。</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="3423" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">R</strong><br/>├── datapeek.Rproj<br/>├── DESCRIPTION<br/>├── NAMESPACE</span></pre><p id="c42f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的库只包含 4 个函数，我们将把它们放入一个名为<strong class="ka ir"> utilities 的文件中。R </strong>，这个文件位于 R 文件夹中。</p><p id="ee43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入 JupyterLab 中的<strong class="ka ir">目录</strong>，打开 R 文件夹。<strong class="ka ir">点击启动器中的<em class="kw">文本文件</em> </strong>并粘贴到我们的<a class="ae nb" href="https://gist.github.com/sean-mcclure/34c87f68c2bfdccdec27799a946c4445" rel="noopener ugc nofollow" target="_blank"> 4 R 函数</a>中。右击该文件并<strong class="ka ir">重命名</strong>为 utilities.R。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/16d2f810dad8acef5a5d5081159785a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*OV4FjXsnPE9iwR45EQCWGw.gif"/></div></figure><h2 id="5c00" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">3B:导出我们的函数</h2><p id="f55a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">仅仅将 R 函数放在我们的文件中是不够的。每个函数都必须<em class="kw">导出</em>才能向我们库的用户公开。这是通过在每个函数上方添加<strong class="ka ir"> @export 标签</strong>来实现的。</p><p id="33d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导出语法来自<a class="ae nb" href="https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> Roxygen </em> </a>，并确保我们的函数被添加到名称空间中。让我们将@export 标签添加到我们的第一个函数中:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="38fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对其余的函数也这样做。</p><blockquote class="kx ky kz"><p id="d3fe" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> </strong>:在更大的库中，我们只导出需要在我们的包之外可用的函数。这有助于减少与另一个库冲突的机会。</p></blockquote><h2 id="0f99" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">3C:记录我们的功能</h2><p id="91d3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">记录我们的功能很重要。文档功能为用户提供信息，这样当他们输入<code class="fe mw mx my mz b">?datapeek</code>时，他们就可以获得关于我们的包的细节。文档还支持使用<a class="ae nb" href="http://r-pkgs.had.co.nz/vignettes.html" rel="noopener ugc nofollow" target="_blank">小插图</a>，这是一种长格式的文档。你可以在这里阅读更多关于记录函数<a class="ae nb" href="http://r-pkgs.had.co.nz/man.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="bfcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将采取<strong class="ka ir"> 2 个子步骤</strong>:</p><ul class=""><li id="4c88" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><strong class="ka ir">添加</strong>文档注释</li><li id="b1b8" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">运行</strong>T1】</li></ul><p id="a202" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> —添加文档注释</strong></p><p id="3555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文档被添加到我们的功能之上<strong class="ka ir">，直接在我们的<code class="fe mw mx my mz b">#’ @export </code>行之上。下面是我们第一个函数的例子:</strong></p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="94cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了可读性，我们将这些行隔开，添加了标题、描述和函数使用的任何参数。让我们为我们的<a class="ae nb" href="https://gist.github.com/sean-mcclure/f4955b10dbe582d02460a7a74c20ea4a" rel="noopener ugc nofollow" target="_blank">剩余功能</a>这样做:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4c78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> —运行</strong> <code class="fe mw mx my mz b">devtools::document()</code></p><p id="3785" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将文档添加到我们的函数中，然后<strong class="ka ir">在根目录外的终端</strong>、<strong class="ka ir"> </strong>中运行以下内容:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="e518" class="ld le iq mz b gy ng nh l ni nj">devtools::document()</span></pre><blockquote class="kx ky kz"><p id="2fe1" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:确保你在 datapeek 目录之外的一级。</p></blockquote><p id="4779" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会得到<strong class="ka ir">错误</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="92f2" class="ld le iq mz b gy ng nh l ni nj">Error: ‘roxygen2’ &gt;= 5.0.0 must be installed for this functionality.</span></pre><p id="8db8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下<strong class="ka ir">打开 JupyterLab </strong>中的 <strong class="ka ir">端子并<strong class="ka ir">安装 roxygen2 </strong>。您还应该安装 data.table 和 mltools，因为我们的第一个函数使用这些工具:</strong></p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="5935" class="ld le iq mz b gy ng nh l ni nj">install.packages('roxygen2')<br/>install.packages('data.table')<br/>install.packages('mltools')</span></pre><p id="e91e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次运行<code class="fe mw mx my mz b">devtools::document()</code>。您应该看到以下内容:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/89a924bdd4daefba1854608e273c97f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXogolrIlfO713HMz326fA.png"/></div></div></figure><p id="5d95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会生成<strong class="ka ir">。Rd 文件</strong>里面有一个新的<strong class="ka ir">人文件夹</strong>。你会注意到。Rd 文件是为我们包中的每个函数<em class="kw">创建的。</em></p><p id="e7b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您查看您的描述文件，它现在会在底部显示一个新行:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/524f8ef08f37dfa81317a2669b0ca6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF506HHEhRheWnL4bDAcRg.png"/></div></div></figure><p id="710d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也将生成一个名称空间文件:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/24b9b2404970a973c2578ab2a1e2b6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RkcToBI1gB0qbZjWrJhjw.png"/></div></div></figure><p id="e86f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到我们的 4 个功能已经暴露。现在让我们继续确保在我们的库中指定依赖关系。</p><h1 id="2cc7" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 4:列出外部依赖关系</h1><p id="e111" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的函数经常需要其他库中的函数。我们必须做两件事来确保外部功能对我们库的功能可用:</p><ol class=""><li id="b468" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv oq nt nu nv bi translated"><strong class="ka ir">在我们的函数中使用</strong> <strong class="ka ir">双冒号</strong>来指定我们所依赖的库；</li><li id="8ffb" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv oq nt nu nv bi translated"><strong class="ka ir">将</strong> <strong class="ka ir">导入</strong>添加到我们的描述文件中。</li></ol><p id="1b57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到，在上面的要点中，我们只是将我们的库列在了顶部。虽然这在独立的 R 脚本中工作得很好，但这不是在 R 包中使用依赖关系的方式。当创建 R 包时，我们必须使用"<strong class="ka ir"> <em class="kw">双冒号方法</em> </strong>"来确保正确的函数被读取。这与 R 包中的“顶层代码”(不像函数那样是对象的代码)如何只在编译包时执行，而不是在加载包时执行有关。</p><p id="d1df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="d7de" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">library(mltools)</strong></span><span id="d341" class="ld le iq mz b gy or nh l ni nj">do_something_cool_with_mltools &lt;- function() {<br/>    auc_roc(preds, actuals)<br/>}</span></pre><p id="d194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…不起作用，因为<code class="fe mw mx my mz b">auc_roc</code>将不可用(运行库(datapeek)不重新执行库(mltools))。这个<em class="kw">将</em>工作:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="4ebc" class="ld le iq mz b gy ng nh l ni nj">do_something_cool_with_mltools &lt;- function() {<br/>    <strong class="mz ir">mltools::</strong>auc_roc(preds, actuals)<br/>}</span></pre><p id="41e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的 datapeek 包中唯一需要额外包的函数是我们的第一个函数:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk">Using the <strong class="ak">double-colon approach</strong> to specify dependent packages in R.</figcaption></figure><p id="d9c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<strong class="ka ir">每次</strong>我们调用一个外部函数时，我们都会在它前面加上外部库和双冒号。</p><p id="3826" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还必须在我们的<code class="fe mw mx my mz b">DESCRIPTION</code>文件中列出外部依赖项，这样它们才能被正确处理。让我们<strong class="ka ir">将</strong> <strong class="ka ir">我们的导入添加到描述文件</strong>:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/d566ec220ad818de715c7ec7bdfa3aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssqvCp6QLyPkF83NGlZzuQ.png"/></div></div></figure><p id="04f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保导入的库用逗号分隔。注意，我们没有为外部依赖项指定任何<strong class="ka ir">版本</strong>。如果我们需要指定版本，我们可以在包名后面使用括号:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="ff28" class="ld le iq mz b gy ng nh l ni nj">Imports:<br/>    data.table (&gt;= 1.12.0)</span></pre><p id="ded9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的<code class="fe mw mx my mz b">encode_and_bind</code>函数没有利用任何最新的更新，我们将不对它指定任何版本。</p><h1 id="9ce6" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 5:添加数据</h1><p id="c521" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">有时在我们的库中包含数据是有意义的。包数据可以让我们的用户练习我们的库的功能，也有助于<em class="kw">测试</em>，因为机器学习包总是包含摄取和转换数据的功能。将<em class="kw">外部数据</em>添加到 R 包的 4 个选项是:</p><ol class=""><li id="2709" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv oq nt nu nv bi translated"><strong class="ka ir">二进制</strong>数据</li><li id="5489" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv oq nt nu nv bi translated"><strong class="ka ir">解析的</strong>数据</li><li id="fcea" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv oq nt nu nv bi translated"><strong class="ka ir">原始</strong>数据</li><li id="9a0f" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv oq nt nu nv bi translated"><strong class="ka ir">序列化</strong>数据</li></ol><p id="1541" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里了解更多关于这些不同方法的信息<a class="ae nb" href="http://r-pkgs.had.co.nz/data.html" rel="noopener ugc nofollow" target="_blank">。对于本文，我们将坚持使用最常见的方法，即<strong class="ka ir">将外部数据添加到 R 文件夹</strong>。</a></p><p id="9857" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将<a class="ae nb" href="https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>添加到我们的库中，以便为用户提供一种快速测试我们功能的方法。数据必须在<strong class="ka ir">中。rda 格式</strong>，使用 R 的<code class="fe mw mx my mz b"><strong class="ka ir">save()</strong></code>函数创建，并具有与文件<strong class="ka ir">相同的名称</strong>。我们可以通过使用 devtools 的<code class="fe mw mx my mz b">use_data</code>函数来确保满足这些标准:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="5460" class="ld le iq mz b gy ng nh l ni nj">x &lt;- read.csv("<a class="ae nb" href="http://bit.ly/2HuTS0Z'" rel="noopener ugc nofollow" target="_blank">http://bit.ly/2HuTS0Z</a>")<br/>devtools::use_data(x, iris)</span></pre><p id="ee60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面，我从 Iris 数据集的 URL 中读取它，并将数据帧传递给<code class="fe mw mx my mz b">devtools::use_data()</code>。</p><p id="2a95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 JupyterLab 中，我们看到创建了一个新的数据文件夹，以及我们的 iris.rda 数据集:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="b46e" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">data<br/>    </strong>└── <!-- -->iris.rda<br/>├── <strong class="mz ir">man</strong><br/>├── <strong class="mz ir">R<br/></strong>├── datapeek.Rproj<br/>├── DESCRIPTION<br/>├── NAMESPACE</span></pre><p id="fded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在接下来的部分中，我们将使用我们添加的数据集来运行测试。</p><h1 id="e8b5" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 6:添加测试</h1><p id="b7d6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">测试是软件开发的一个重要部分。测试有助于确保我们的代码按预期工作，并使调试代码成为一个更快、更有效的过程。点击了解更多关于测试 R 包<a class="ae nb" href="http://r-pkgs.had.co.nz/tests.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="d9d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试中的一个常见挑战是知道我们应该测试什么。测试大型库中的每一个功能都很麻烦，而且并不总是需要，而测试不足会使发现和纠正出现的错误变得更加困难。</p><p id="7653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢马丁·福勒关于何时测试的下面这段话:</p><blockquote class="ot"><p id="c6cc" class="ou ov iq bd ow ox oy oz pa pb pc kv dk translated">每当您想在 print 语句或调试器表达式中键入某些内容时，请将其编写为测试—马丁·福勒</p></blockquote><p id="4c35" class="pw-post-body-paragraph jy jz iq ka b kb pd kd ke kf pe kh ki kj pf kl km kn pg kp kq kr ph kt ku kv ij bi translated">如果您定期构建应用程序原型，您会发现自己经常向控制台写东西，看看一段代码是否返回您所期望的结果。在数据科学中，编写交互式代码甚至更常见，因为机器学习工作是高度实验性的。一方面，这提供了充分的机会来思考编写哪些测试。另一方面，机器学习代码的不确定性意味着测试 ML 的某些方面可能不那么简单。作为一般规则，寻找每次都应该返回相同输出的明显确定性代码段。</p><p id="7746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在数据科学中做的交互测试是<em class="kw">手动</em>，但是我们在我们的包中寻找的是<strong class="ka ir">自动测试</strong>。自动化测试意味着我们运行一套预定义的测试，以确保我们的包端到端地工作。</p><p id="ea66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然在软件中有很多种测试，但这里我们主要讨论“<strong class="ka ir">单元测试</strong>”从单元测试的角度思考迫使我们将代码分解成更多的模块化组件，这是软件设计中的良好实践。</p><blockquote class="kx ky kz"><p id="d6cf" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> </strong>:如果你习惯用 Python 这样的语言测试，注意 R 本质上更<strong class="ka ir"> functional </strong>(即方法属于函数而不是类)，所以会有一些区别。</p></blockquote><p id="a0bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将采取 2 个子步骤<strong class="ka ir">来测试我们的 R 库:</strong></p><p id="7c81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 6A </strong>:创建<code class="fe mw mx my mz b">tests/testthat</code>文件夹；</p><p id="0d49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 6B </strong>:写作测试。</p><p id="2d15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> — 6A: </strong> <strong class="ka ir">创建</strong> <code class="fe mw mx my mz b"><strong class="ka ir">tests/testthat</strong></code> <strong class="ka ir">文件夹</strong></p><p id="23b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如 R 希望我们的 R 脚本和数据放在特定的文件夹中一样，它也希望我们的测试也是如此。为了创建 tests 文件夹，我们在 JupyterLab 的 R 控制台中运行以下命令:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="3c50" class="ld le iq mz b gy ng nh l ni nj">devtools::use_testthat()</span></pre><p id="4032" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会得到以下错误:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="53a3" class="ld le iq mz b gy ng nh l ni nj">Error: ‘testthat’ &gt;= 1.0.2 must be installed for this functionality.</span></pre><p id="7b8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果是这样的话，使用上面相同的方法在 Jupyter 的终端中安装 roxygen2。</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="8e02" class="ld le iq mz b gy ng nh l ni nj">install.packages('testthat')</span></pre><p id="f6d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe mw mx my mz b">devtools::use_testthat()</code>将产生以下输出:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="6571" class="ld le iq mz b gy ng nh l ni nj">* Adding testthat to Suggests<br/>* Creating `tests/testthat`.<br/>* Creating `tests/testthat.R` from template.</span></pre><p id="8c2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的主目录中会有一个新的<strong class="ka ir">测试文件夹</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="7946" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">data<br/></strong>├── <strong class="mz ir">man</strong><br/>├── <strong class="mz ir">R<br/></strong>├── <strong class="mz ir">tests<br/>    </strong>└── testthat.R<strong class="mz ir"><br/></strong>├── datapeek.Rproj<br/>├── DESCRIPTION<br/>├── NAMESPACE</span></pre><p id="5d65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的命令还在 tests 文件夹中创建了一个名为<code class="fe mw mx my mz b">testthat.R</code>的文件。当<code class="fe mw mx my mz b">R CMD check</code>运行时，它会运行所有的测试(我们很快就会看到)。您还会注意到<strong class="ka ir"/><em class="kw">test 在我们的<code class="fe mw mx my mz b">DESCRIPTION</code>文件中的<strong class="ka ir">建议</strong>下添加了</em>:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pi"><img src="../Images/1b335dd61daaf2db16a83fc6d10d2ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N24_J5Dg9ZhuepxwYcy-vQ.png"/></div></div></figure><p id="a1b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> — 6B:写作测试</strong></p><p id="cb27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">test 这是 R 最流行的单元测试包，至少有 2600 个 CRAN 包使用，更不用说 Github 上的库了。你可以在 Tidyverse 页面<a class="ae nb" href="https://www.tidyverse.org/articles/2017/12/testthat-2-0-0/" rel="noopener ugc nofollow" target="_blank">这里</a>查看关于 testthat 的最新消息。也可以查看它的<a class="ae nb" href="https://cran.r-project.org/web/packages/testthat/testthat.pdf" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="2408" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要考虑 3 个级别的测试:</p><ul class=""><li id="1373" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><strong class="ka ir">期望(断言):</strong>一次计算的预期结果；</li><li id="34d0" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">测试:</strong>将单个功能的多个期望，或者跨多个功能的相关功能组合在一起；</li><li id="bb33" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">文件:</strong>将多个相关测试组合在一起。文件被赋予一个人类可读的名称<code class="fe mw mx my mz b">context().</code></li></ul><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pi"><img src="../Images/8c6dbb53f9ee153fc374f5a71899d072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BiYtnFbj5vsgf_zphz4K4Q.png"/></div></div></figure><h2 id="9e85" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">断言</h2><p id="2548" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><em class="kw">断言</em>是我们选择的测试库中包含的函数。我们使用断言来检查我们自己的函数是否返回预期的输出。断言有多种风格，这取决于被检查的内容。在接下来的部分，我将介绍 R 编程中使用的主要测试，展示每一个失败的测试，这样你就可以理解它是如何工作的。</p><p id="9c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">相等</strong>断言<strong class="ka ir">断言</strong></p><ul class=""><li id="4232" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_equal()</code></li><li id="4590" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_identical()</code></li><li id="90c5" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_equivalent</code></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="c850" class="ld le iq mz b gy ng nh l ni nj"># <strong class="mz ir">test for</strong> <strong class="mz ir">equality</strong><br/>a &lt;- 10<br/>expect_equal(a, 14)</span><span id="f793" class="ld le iq mz b gy or nh l ni nj">&gt; Error: `a` not equal to 14.</span><span id="b656" class="ld le iq mz b gy or nh l ni nj"># <strong class="mz ir">test for identical</strong> <br/>expect_identical(42, 2)</span><span id="0d7a" class="ld le iq mz b gy or nh l ni nj">&gt; Error: 42 not identical to 2.</span><span id="082a" class="ld le iq mz b gy or nh l ni nj"># <strong class="mz ir">test for equivalence</strong> <br/>expect_equivalent(10, 12)</span><span id="35a0" class="ld le iq mz b gy or nh l ni nj">&gt; Error: 10 not equivalent to 12.</span></pre><p id="ec5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子之间有细微的差别。例如，<code class="fe mw mx my mz b">expect_equal</code>用于检查<em class="kw">在数值公差</em>内是否相等，而<code class="fe mw mx my mz b">expect_identical</code>用于测试<em class="kw">是否完全相等。以下是一些例子:</em></p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="fe7c" class="ld le iq mz b gy ng nh l ni nj">expect_equal(10, 10 + 1e-7) # true<br/>expect_identical(10, 10 + 1e-7) # false</span></pre><p id="e1ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着你写更多的测试，你会明白什么时候使用每一个。当然，如有疑问，请参考上述文件。</p><p id="cc71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试<strong class="ka ir">字符串</strong>和<strong class="ka ir">是否匹配</strong></p><ul class=""><li id="db50" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_match()</code></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="7051" class="ld le iq mz b gy ng nh l ni nj"># <strong class="mz ir">test for string matching</strong><br/>expect_match("Machine Learning is Fun", "But also rewarding.")</span><span id="feb5" class="ld le iq mz b gy or nh l ni nj">&gt; Error: "Machine Learning is Fun" does not match "But also rewarding.".</span></pre><p id="3524" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试<strong class="ka ir">长度</strong></p><ul class=""><li id="6457" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_length</code></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="1e79" class="ld le iq mz b gy ng nh l ni nj"># <strong class="mz ir">test for length </strong><br/>vec &lt;- 1:10<br/>expect_length(vec, 12)</span><span id="423d" class="ld le iq mz b gy or nh l ni nj">&gt; Error: `vec` has length 10, not length 12.</span></pre><p id="d972" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">比较测试</strong></p><ul class=""><li id="d89f" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_lt</code></li><li id="5e4d" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_gt</code></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="b8a5" class="ld le iq mz b gy ng nh l ni nj"># <strong class="mz ir">test for less than</strong><br/>a &lt;- 11<br/>expect_lt(a, 10)</span><span id="5b73" class="ld le iq mz b gy or nh l ni nj">&gt; Error: `a` is not strictly less than 10. Difference: 1</span><span id="78e6" class="ld le iq mz b gy or nh l ni nj"># <strong class="mz ir">test for greater than</strong><br/>a &lt;- 11<br/>expect_gt(a, 12)</span><span id="ccf8" class="ld le iq mz b gy or nh l ni nj">&gt; Error: `a` is not strictly more than 12. Difference: -1</span></pre><p id="db2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试<strong class="ka ir">逻辑</strong></p><ul class=""><li id="b3f4" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_true</code></li><li id="3468" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_false</code></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="7def" class="ld le iq mz b gy ng nh l ni nj"># <strong class="mz ir">test for</strong> <strong class="mz ir">truth</strong> <br/>expect_true(5 == 2)</span><span id="25df" class="ld le iq mz b gy or nh l ni nj">&gt; Error: 5 == 2 isn't true.</span><span id="b679" class="ld le iq mz b gy or nh l ni nj"># <strong class="mz ir">test for</strong> <strong class="mz ir">false</strong> <br/>expect_false(2 == 2)</span><span id="c104" class="ld le iq mz b gy or nh l ni nj">&gt; Error: 2 == 2 isn't false.</span></pre><p id="c2c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试<strong class="ka ir">输出</strong></p><ul class=""><li id="be61" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_output</code></li><li id="2529" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><code class="fe mw mx my mz b">expect_message</code></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="1c1b" class="ld le iq mz b gy ng nh l ni nj"># <strong class="mz ir">testing for outputs </strong><br/>expect_output(str(mtcars), "31 obs")</span><span id="0af5" class="ld le iq mz b gy or nh l ni nj">&gt; Error: `str\(mtcars\)` does not match "31 obs".</span><span id="e95e" class="ld le iq mz b gy or nh l ni nj"># <strong class="mz ir">test for warning</strong> <br/>f &lt;-function(x) {<br/>  if(x &lt; 0) {<br/>    message("*x* is already negative")<br/>  }<br/>}</span><span id="4e1c" class="ld le iq mz b gy or nh l ni nj">expect_message(f(1))</span><span id="a085" class="ld le iq mz b gy or nh l ni nj">&gt; Error: `f(1)` did not produce any messages.</span></pre><p id="a220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">testthat 库中包含了更多。如果你是测试新手，开始写一些简单的来适应这个过程。随着时间的推移，你会对测试什么和何时测试有一个直觉。</p><h2 id="cc15" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">写作测试</h2><p id="1d38" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">一个<strong class="ka ir">测试</strong>是一组<em class="kw">断言</em>。我们在 tests 中编写如下测试:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="9ad6" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">test_that</strong>("this functionality does what it should", {<br/>    // group of assertions here<br/>})</span></pre><p id="c3d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到我们既有<strong class="ka ir">描述</strong>(<em class="kw">测试名称</em>)又有<strong class="ka ir">代码</strong>(包含断言)。描述完成了句子，“测试那个…”</p><p id="c630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们说“<em class="kw">测试</em>这个功能做了它应该做的事情。”</p><p id="a815" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">断言是我们想要测试的输出。例如:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="5216" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">test_that</strong>("trigonometric functions match identities", {<br/>      expect_equal(sin(pi / 4), 1 / sqrt(2))<br/>      expect_equal(cos(pi / 4), 1 / sqrt(10))<br/>      expect_equal(tan(pi / 4), 1)<br/>    })</span><span id="75f2" class="ld le iq mz b gy or nh l ni nj">&gt; Error: Test failed: 'trigonometric functions match identities'</span></pre><blockquote class="kx ky kz"><p id="8364" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注</em> </strong>:结合我们的测试文件，需要考虑<a class="ae nb" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">内聚</a>和<a class="ae nb" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">耦合</a>之间的平衡。正如 Hadley 在书中所说，“这两个极端显然是不好的(所有测试在一个文件中，每个测试一个文件)。你需要找到一个适合你的快乐的媒介。一个好的起点是为每个复杂的功能准备一个测试文件。”</p></blockquote><h2 id="23a3" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">创建文件</h2><p id="d564" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们在测试中做的最后一件事是创建文件。如上所述，测试中的“文件”是一组覆盖相关功能集的测试。我们的测试文件必须位于<code class="fe mw mx my mz b">tests/testthat/</code>目录中。下面是<a class="ae nb" href="https://github.com/tidyverse/stringr/blob/master/tests/testthat/test-case.R" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的<em class="kw"> stringr </em>包的测试文件示例:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pj"><img src="../Images/23850e4ed8dd364d2086a3cba28cd6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk7Fl1p7J7q5heitapFr0w.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk"><strong class="bd oj">Example Test File</strong> from the stringr package on GitHub.</figcaption></figure><p id="f448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件叫做测试用例。r(以“test”开头)位于<code class="fe mw mx my mz b">tests/testthat/</code>目录中。顶部的<em class="kw">上下文</em>只允许我们提供文件内容的简单描述。当我们运行测试时，它会出现在控制台中。</p><p id="a38d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们<strong class="ka ir">创建我们的测试文件</strong>，它将包含与我们的 4 个函数相关的测试和断言。像往常一样，我们在 Launcher 中使用 JupyterLab 的文本文件来创建和重命名一个新文件:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a20736dab0aac8d0dbb4002ac71c3242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*VqCI4yW8KtpCLQzXnsCvPw.gif"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk">Creating a Test File in R</figcaption></figure><p id="25f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们添加我们的测试:</p><p id="a6ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于第一个函数，我将<strong class="ka ir">确保返回具有正确特征数量的数据帧</strong>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="62d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意我们如何调用我们的<code class="fe mw mx my mz b">encode_and_bind</code>函数，然后简单地检查维度和预期输出之间的相等性。我们在任何时候运行我们的自动化测试，以确保我们的测试文件运行，并且我们得到预期的输出。在控制台中运行<code class="fe mw mx my mz b">devtools::test()</code>运行我们的测试:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pk"><img src="../Images/686911a5778e1d5d659c1587cf251c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZKgP8cHJlJs9SL9idUgbA.png"/></div></div></figure><p id="1329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也得到了一个笑脸！</p><p id="1ca2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的<strong class="ka ir">第二个函数</strong>删除了一个指定的特征，我将使用与上面相同的测试，检查返回的框架的尺寸。我们的<strong class="ka ir">第三个函数</strong>将指定的函数应用到选择的列，所以我将编写一个测试来检查给定指定函数的结果。最后，我们的<strong class="ka ir">第四个函数</strong>返回最接近的匹配字符串，所以我将简单地检查返回的字符串以获得预期的结果。</p><p id="c0a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我们的完整测试文件:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="kx ky kz"><p id="7626" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> </strong>:注意测试文件中数据的相对路径。</p></blockquote><h2 id="8daf" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">测试我们的包</h2><p id="e71f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如上所述，我们使用以下命令运行测试:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="2b79" class="ld le iq mz b gy ng nh l ni nj">devtools::test()</span></pre><p id="7980" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将运行我们放在 testthat 目录中的任何测试文件中的所有测试。让我们来看看结果:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pl"><img src="../Images/fe1448cc9201bca4c3b4ec14e2bfcc3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGcqkMztKgkco3o7xPsLfg.png"/></div></div></figure><p id="4d3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在 4 个单元测试中有 5 个断言，放在一个测试文件中。看来我们没事了。如果我们的任何测试失败，我们将在上面的打印输出中看到这一点，在这一点上，我们将寻求纠正问题。</p><h1 id="e4c9" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 7:创建文档</h1><p id="2fc0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这通常是通过在 R 中使用“Vignettes”来完成的。你可以在这里了解如何为你的 R 包<a class="ae nb" href="http://r-pkgs.had.co.nz/vignettes.html" rel="noopener ugc nofollow" target="_blank">创建 R vignettes。就我个人而言，我认为这是一种过时的文档方法。我更喜欢用类似于狮身人面像或者 T21 的东西。文档应该很容易<strong class="ka ir">共享</strong>、<strong class="ka ir">搜索</strong>和<strong class="ka ir">托管</strong>。</a></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/dd9cb75c79722172eb86003142279f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1OmKtcF9Q9Mmw9FRWFVDg.png"/></div></div></figure><p id="eebc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击 julepcode.com 大学的问号，了解如何使用 Julep。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pn"><img src="../Images/0356200bc21b4de9d4fe3d6c19621e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9tsK99BoBoyMSBJIIZADg.png"/></div></div></figure><p id="f9ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我为我们的 R datapeek 库创建并托管了一些简单的文档，你可以在这里找到<a class="ae nb" href="http://julepcode.live/57u3yt" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e588817c234a4673041a8d827407cb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*zx5RJ2cg3rToA_WjYXrL0g.gif"/></div></figure><p id="a9c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然我们也会在 GitHub 上有这个库，我会在下面介绍。</p><h1 id="0ea5" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">第八步:共享你的 R 库</h1><p id="56c8" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">正如我在引言中提到的，我们应该定期创建库，这样其他人就可以受益于并扩展我们的工作。最好的方法是通过<strong class="ka ir"> GitHub </strong>，这是开源软件项目分发和协作的标准方式。</p><p id="43b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您是 GitHub 的新手，这里有一个快速教程可以帮助您入门，这样我们就可以将我们的 datapeek 项目推到远程 repo。</p><p id="3cd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注册/登录 GitHub 并<a class="ae nb" href="https://github.com/new" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">创建一个新的库</strong> </a>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a1ba6efc1d2a4f22415ee18525f695f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Kxiso5ne6d3ZFqnyPVy0vA.gif"/></div></figure><p id="3020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…这将为我们提供通常的屏幕:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi po"><img src="../Images/2e56761c6034be735020802ce5956529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Potig3fv6vTBUIQkwjsZdQ.png"/></div></div></figure><p id="788c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用我们的远程回购设置，我们可以在我们的机器上初始化我们的<strong class="ka ir">本地回购</strong>，并发送我们的第一个提交。</p><p id="ba01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">打开 JupyterLab 中的终端</strong>，进入 datapeek 目录:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/3a2eddc9cf779843bbb210489f396154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwrbbrmiE1zYKIB3xkyoUg.png"/></div></div></figure><p id="4cd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">初始化本地 repo </strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="3706" class="ld le iq mz b gy ng nh l ni nj">git init</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pq"><img src="../Images/0c103c75ae058172551ac4c563493cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zft44wygE513LDq4C8zvrg.png"/></div></div></figure><p id="7f58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">添加远程原点</strong>(您的链接会有所不同):</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="87b7" class="ld le iq mz b gy ng nh l ni nj">git remote add origin <a class="ae nb" href="https://github.com/sean-mcclure/datapeek.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sean-mcclure/datapeek.git</a></span></pre><p id="ce36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在运行<code class="fe mw mx my mz b">git add .</code>将当前目录和所有子目录下所有修改的和新的(未跟踪的)文件添加到<strong class="ka ir"> staging </strong>区域:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="058f" class="ld le iq mz b gy ng nh l ni nj">git add .</span></pre><p id="79ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记上面命令中的“点”。现在我们可以<strong class="ka ir">提交</strong>我们的更改，这将任何新代码添加到我们的本地回购中。</p><p id="6a76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">但是</strong>，由于我们在 Docker 容器中工作，与我们的本地回购相关联的<strong class="ka ir">用户名</strong>和<strong class="ka ir">电子邮件</strong>不能被自动检测。我们可以通过在终端中运行以下命令来<strong class="ka ir">设置</strong><strong class="ka ir"/>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="2063" class="ld le iq mz b gy ng nh l ni nj">git config --global user.email {emailaddress}<br/>git config --global user.name {name}</span></pre><p id="bb42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用您用来登录 GitHub 的电子邮件地址和用户名。</p><p id="e2f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以承诺:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="b051" class="ld le iq mz b gy ng nh l ni nj">git commit -m 'initial commit'</span></pre><p id="b288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提交新代码后，我们可以进行推送，将最后一次提交转移到我们的<em class="kw"> remote </em> repo:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="1949" class="ld le iq mz b gy ng nh l ni nj">git push origin master</span></pre><blockquote class="kx ky kz"><p id="a899" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> </strong>:因为我们在 Docker 中，你可能会再次被要求<strong class="ka ir">认证</strong>。出现提示时，只需添加您的 GitHub 用户名和密码。然后再次运行上面的命令。</p></blockquote><p id="d79e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些读者会注意到我们没有在目录中放置一个<code class="fe mw mx my mz b">.gitignore</code>文件。将所有文件放入较小的 R 库中通常没问题。对于更大的库，或者包含大型数据集的库，你可以使用站点<strong class="ka ir"> gitignore.io </strong>来看看常见的 gitignore 文件是什么样子的。这里是一个用于 R 的通用 R .gitignore 文件:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk"><strong class="ak">Example .gitignore file</strong> for an R package</figcaption></figure><p id="441e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">概括地说，git <strong class="ka ir"> add </strong>将当前目录中所有修改过的和新的(未跟踪的)文件添加到<strong class="ka ir"> staging </strong>区域。<strong class="ka ir">提交</strong>将任何更改添加到我们的<em class="kw">本地</em>回购，而<strong class="ka ir">推送</strong>将最后的提交转移到我们的<em class="kw">远程</em>回购。虽然<code class="fe mw mx my mz b">git add</code>可能看起来是多余的，但它存在的原因是因为有时我们只想提交某些文件，这样我们可以有选择地存放文件。上面，我们通过在<code class="fe mw mx my mz b">git add</code>后使用“点”来暂存<em class="kw">所有的</em>文件。</p><p id="7e0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能还注意到我们没有包括一个<strong class="ka ir">自述文件</strong>。您确实应该包括这一点，但是为了简洁起见，我省略了这一步。</p><p id="408d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，<strong class="ka ir">任何人都可以使用我们的库</strong>。👍让我们看看怎么做。</p><h1 id="5c8e" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 9:安装你的 R 库</h1><p id="f8bd" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">正如在引言中提到的，我不会在本文中讨论 CRAN。坚持使用 GitHub 使得频繁共享我们的代码变得更加容易，并且我们总是可以在以后添加 CRAN 标准。</p><p id="2602" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从 GitHub 安装一个库，用户只需在本地机器上运行以下命令:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="8005" class="ld le iq mz b gy ng nh l ni nj">devtools::install_github("yourusername/mypackage")</span></pre><p id="dbc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们可以简单地指示希望使用 datapeek 的其他人在他们的本地机器上运行以下命令:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="450c" class="ld le iq mz b gy ng nh l ni nj">devtools::install_github("sean-mcclure/datapeek")</span></pre><p id="71bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们将包含在自述文件和/或我们创建的任何其他文档中的内容。这将像我们从 CRAN 获得的任何其他软件包一样安装我们的软件包:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/cf8ad08ccce905fff910e44d30fa0545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*iBejKHJF8u_lXvD1cSwAfQ.gif"/></div></figure><p id="84f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，用户像往常一样加载库，一切就绪:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="da8a" class="ld le iq mz b gy ng nh l ni nj">library(datapeek)</span></pre><p id="8f2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我建议在一个新的 R 环境中尝试上述命令，以确认新库的安装和加载符合预期。</p><h1 id="a176" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">用 PYTHON 创建库</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/ee5efb02abf9b77e8cecae7908e07e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neF0DKqRQdS7QYvn8XeIMQ.png"/></div></div></figure><p id="4127" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建 Python 库遵循与我们之前看到的 r 相同的高级步骤。我们需要一个基本的<strong class="ka ir">目录结构</strong>和适当的<strong class="ka ir">命名</strong>约定，<strong class="ka ir">函数</strong>和<strong class="ka ir">描述</strong>，<strong class="ka ir">导入</strong>，指定<strong class="ka ir">依赖关系</strong>，添加<strong class="ka ir">数据集</strong>，<strong class="ka ir">文档</strong>，以及能够<strong class="ka ir">共享</strong>并允许其他人<strong class="ka ir">安装</strong>我们的库</p><p id="b29e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<strong class="ka ir"> JupyterLab </strong>来构建我们的 Python 库，就像我们对 r。</p><h2 id="77e5" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">库 vs 包 vs 模块</h2><p id="9c00" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本文的开始，我讨论了“<strong class="ka ir">库”</strong>和“<strong class="ka ir">包”</strong>之间的区别，以及我是如何喜欢交替使用这些术语的。这同样适用于 Python 库。"<strong class="ka ir">模块"</strong>是另一个术语，在 Python 中简单地指任何包含 Python 代码的文件。Python 库显然包含作为脚本的模块。</p><h2 id="ee71" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">在我们开始之前:</h2><p id="5d41" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我在介绍中说过，我们将在 GitHub 上托管和安装我们的库。这鼓励了库的快速创建和共享，而不会因为在流行的 R 和 Python 包托管站点上发布标准而陷入困境。</p><p id="cade" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python 最流行的托管站点是 Python 包索引(<a class="ae nb" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>)。这里是<strong class="ka ir">寻找</strong>、<strong class="ka ir">安装</strong>和<strong class="ka ir">发布</strong> python 库的地方。每当您运行<code class="fe mw mx my mz b">pip install &lt;package_name&gt;</code>(或<code class="fe mw mx my mz b">easy_intall</code>)时，您都会从 PyPI 获取一个包。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pr"><img src="../Images/6311fa318813c2bc1d3535489206916a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDk221YEbB0_UrCrBcfs5Q.png"/></div></div></figure><p id="5820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我们不会讨论在 PyPI 上托管我们的包，但是看看我们的库名是否是唯一的还是一个好主意。这将最大限度地减少与其他流行 Python 库的混淆，并提高我们的库名与众不同的可能性，如果有一天我们决定在 PyPI 上托管它的话。</p><p id="c7f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们应该遵循一些 Python 库的命名约定。</p><h2 id="a9e1" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">Python 库命名约定</h2><ul class=""><li id="6193" class="nn no iq ka b kb lw kf lx kj ps kn pt kr pu kv ns nt nu nv bi translated"><strong class="ka ir">全部用小写</strong>；</li><li id="ee82" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">让名字<strong class="ka ir">在 PyPI 上唯一</strong>(在<a class="ae nb" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>上搜索名字)</li><li id="0089" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">没有<strong class="ka ir">连字符</strong>(可以用下划线分隔单词)</li></ul><p id="347f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的库名是<strong class="ka ir"> datapeek </strong>，所以满足第一个和第三个标准；让我们检查 PyPI 的<em class="kw">唯一性</em>:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bcc0740e4b5184b6c087302596865576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*VlSWkHqFq59uaPLe4dX3Rg.gif"/></div></figure><p id="0a3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都好。👍</p><p id="95ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在已经准备好完成创建 Python 库所需的每个步骤。</p><h1 id="aada" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 1:创建包框架</h1><p id="aa3f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><strong class="ka ir"> JupyterLab </strong>应按照本文<strong class="ka ir">设置部分</strong>中的说明启动并运行。</p><p id="9506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用 JupyterLab 的<strong class="ka ir">新文件夹</strong>和<strong class="ka ir">文本文件</strong>选项创建以下<strong class="ka ir">目录结构</strong>和<strong class="ka ir">文件</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="e22a" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">datapeek</strong><br/>    └── <!-- -->__init__.py<br/>    <!-- -->└── <!-- -->utilities.py<br/>├── <!-- -->setup.py</span></pre><blockquote class="kx ky kz"><p id="8920" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注</em> </strong> : <strong class="ka ir">粗体</strong>名称为<strong class="ka ir">文件夹</strong>和<strong class="ka ir">浅色</strong>名称为<strong class="ka ir">文件</strong>。我们将把<strong class="ka ir">内部</strong> datapeek 文件夹称为“模块目录”，把<strong class="ka ir">外部</strong> datapeek 目录称为“根目录”。</p></blockquote><p id="3a94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的视频展示了我在 JupyterLab 中创建 datapeek 目录的过程:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="pv om l"/></div></figure><p id="b739" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些文件我们不想提交给源代码管理。这些文件是由 Python 构建系统创建的。照此，我们也把<strong class="ka ir"> </strong>加上下面的<strong class="ka ir">。gitignore 文件</strong>到我们的包框架:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="kx ky kz"><p id="7398" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注</em> </strong>:在撰写本文时，JupyterLab 缺少在浏览器中切换隐藏文件的前端设置。因此，我们将简单地把我们的文件命名为 gitignore(前面没有点)；在推送到 GitHub 之前，我们会把它改成一个隐藏文件。</p></blockquote><p id="900f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">将你的 gitignore 文件</strong>作为一个简单的文本文件添加到<strong class="ka ir">根目录:</strong></p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="3eba" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">datapeek</strong><br/>    └── <!-- -->__init__.py<br/>    <!-- -->└── <!-- -->utilities.py<br/>├── <!-- -->setup.py<br/>├── <!-- -->gitignore</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/4168d2309b4bcd2c0059cfb65d965384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ntCLIqmfrmF2kfnYSk6ZRA.gif"/></div></div></figure><h1 id="c8d0" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 2:填写描述细节</h1><p id="394a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">正如我们对 R 所做的一样，我们应该添加关于我们新库的元数据。我们使用<strong class="ka ir">设置工具</strong>来完成这项工作。Setuptools 是一个 Python 库，旨在方便打包 Python 项目。</p><p id="ba49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">打开 setup.py </strong>并为我们的库添加以下详细信息:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="fa3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，您应该将创作更改为您自己的创作。稍后我们将向该文件添加更多的细节。这些关键字是不言自明的。<code class="fe mw mx my mz b">url</code>是我们项目在 GitHub 上的 URL，后面会添加；除非您已经创建了 python repo，在这种情况下，现在添加 URL。我们在 R 部分讨论了许可。<code class="fe mw mx my mz b">zip_safe</code>简单地说，我们的包可以作为一个 zip 文件安全地运行，这是通常的情况。你可以在这里了解更多关于可以添加到 setup.py 文件<a class="ae nb" href="https://packaging.python.org/tutorials/packaging-projects/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h1 id="58ac" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 3:添加函数</h1><p id="e78a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的库显然需要<em class="kw">函数</em>有用。对于更大的库，我们将组织我们的模块以平衡内聚/耦合，但是因为我们的库很小，我们将简单地把所有的函数放在一个文件中。</p><p id="cbf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将添加与 R 相同的函数，这次是用 Python 编写的:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="048b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">将</strong>这些函数添加到<code class="fe mw mx my mz b">utilities.py</code>模块，在 datapeek 的模块目录中。</p><h1 id="b2a7" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 4:列出外部依赖关系</h1><p id="8333" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的库经常需要其他包作为依赖关系。当安装我们的库时，我们用户的 Python 环境需要知道这些(所以也可以安装这些其他的包)。<strong class="ka ir"> Setuptools </strong>提供了<code class="fe mw mx my mz b">install_requires</code>关键字来列出我们的库所依赖的任何包。</p><p id="f063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的 datapeek 库依赖于用于模糊字符串匹配的<strong class="ka ir"> fuzzywuzzy </strong>包和用于数据结构高性能操作的<strong class="ka ir"> pandas </strong>包。要指定我们的依赖关系<strong class="ka ir">、</strong>、<strong class="ka ir">，请将以下内容添加到您的 setup.py 文件中:</strong></p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="3c4c" class="ld le iq mz b gy ng nh l ni nj">install_requires=[<br/>    'fuzzywuzzy',<br/>    'pandas'<br/>]</span></pre><p id="a0af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的 setup.py 文件当前应该如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7fbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过在 JupyterLab 终端会话中运行以下命令来确认一切正常:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="bde6" class="ld le iq mz b gy ng nh l ni nj">python setup.py develop</span></pre><blockquote class="kx ky kz"><p id="4bdb" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> </strong>:在 datapeek 的根目录下运行这个。</p></blockquote><p id="1f18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行该命令后，您应该会看到类似这样的内容:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pw"><img src="../Images/a6b89b79f59ef2aca0c39f5d9dd089a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQpUpTxJgYkv88djZS9Pqw.png"/></div></div></figure><p id="8571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…结尾写道:</p><p id="5aa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mz b">Finished processing dependencies for datapeek==0.1</code></p><p id="2af4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们的一个或多个依赖项在 PyPI 上不可用，但在 Github 上可用(例如，<em class="kw">一个尖端的机器学习包只在 GitHub 上可用…或者它是我们团队的另一个库，只托管在 GitHub 上</em>)，我们可以在设置调用中使用<code class="fe mw mx my mz b">dependency_links</code>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="d62b" class="ld le iq mz b gy ng nh l ni nj">setup(<br/>    ...<br/>    dependency_links=['http://github.com/user/repo/tarball/master#egg=package-1.0'],<br/>    ...<br/>)</span></pre><p id="d67b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要添加额外的元数据，比如<strong class="ka ir">状态</strong>、<strong class="ka ir">许可</strong>、<strong class="ka ir">语言</strong>、<strong class="ka ir">版本</strong>等。我们可以这样使用<code class="fe mw mx my mz b">classifiers</code>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="f16e" class="ld le iq mz b gy ng nh l ni nj">setup(<br/>    ...<br/>    classifiers=[<br/>        'Development Status :: 3 - Alpha',<br/>        'License :: OSI Approved :: MIT License',<br/>        'Programming Language :: Python :: 2.7',<br/>        'Topic :: Text Processing :: Linguistic',<br/>      ],<br/>    ...<br/>)</span></pre><p id="2562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要了解更多关于可以添加到 setup.py 文件中的不同分类器的信息，请参见<a class="ae nb" href="https://pypi.org/pypi?%3Aaction=list_classifiers" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="2395" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 5:添加数据</h1><p id="bd59" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">正如我们在 R 中所做的一样，我们可以将数据添加到我们的 Python 库中。在 Python 中，这些文件被称为<strong class="ka ir">非代码文件</strong>，可以包括<strong class="ka ir">图像</strong>、<strong class="ka ir">数据</strong>、<strong class="ka ir">文档</strong>等。</p><p id="83db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们<strong class="ka ir">将数据</strong>添加到我们库的模块目录中，这样任何需要这些数据的代码都可以使用来自消费模块的<code class="fe mw mx my mz b">__file__</code>变量的<em class="kw">相对路径</em>。</p><p id="e04f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将<a class="ae nb" href="https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>添加到我们的库中，以便为用户提供一种快速测试我们功能的方法。首先，使用 JupyterLab 中的<strong class="ka ir">新建文件夹</strong>按钮<strong class="ka ir">在模块目录下新建一个名为 data </strong>的文件夹:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="b84d" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">datapeek</strong><br/>    └── <!-- -->__init__.py<br/>    <!-- -->└── <!-- -->utilities.py<br/>    <!-- -->└── <strong class="mz ir">data</strong><br/>├── <!-- -->setup.py<br/>├── <!-- -->gitignore</span></pre><p id="8ce0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…然后<strong class="ka ir">在名为 iris.csv 的数据文件夹中创建一个新的文本文件</strong>，并且<strong class="ka ir">将<a class="ae nb" href="https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv" rel="noopener ugc nofollow" target="_blank">中的数据</a>粘贴到新文件中。</strong></p><p id="4a04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您关闭并打开新的 csv 文件，它将在 JupyterLab 中以适当的表格形式呈现:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/59f6444300c9f4eb3cd0bd4d1ae187a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8uF8rHonFfak0q8SZ6_nFg.gif"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk"><strong class="bd oj">CSV file</strong> rendered in JupyterLab as formatted table.</figcaption></figure><p id="037d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用一个<code class="fe mw mx my mz b">MANIFEST.in</code>文件来指定非代码文件。<strong class="ka ir">创建另一个名为<code class="fe mw mx my mz b">MANIFEST.in</code>的文本文件</strong>，将其放入根文件夹:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="c7e2" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">datapeek</strong><br/>    └── <!-- -->__init__.py<br/>    <!-- -->└── <!-- -->utilities.py<br/>    <!-- -->└── <strong class="mz ir">data</strong><br/>├── <!-- -->MANIFEST.in<br/>├── <!-- -->setup.py<br/>├── <!-- -->gitignore</span></pre><p id="5713" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…然后<strong class="ka ir">将这一行</strong>添加到文件中:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="05a9" class="ld le iq mz b gy ng nh l ni nj">include <!-- -->datapeek<!-- -->/data/iris.csv</span></pre><blockquote class="kx ky kz"><p id="64d8" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注</em></strong>:manifest . in 通常不需要，但为了完整起见包含在本教程中。更多讨论见<a class="ae nb" href="https://stackoverflow.com/questions/24727709/do-python-projects-need-a-manifest-in-and-what-should-be-in-it" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></blockquote><p id="f654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要<strong class="ka ir">在 setup.py 中包含下面一行</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="93f1" class="ld le iq mz b gy ng nh l ni nj">include_package_data=True</span></pre><p id="82b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的 setup.py 文件现在应该如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><h1 id="5361" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 6:添加测试</h1><p id="79f3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">与我们的 R 库一样，我们应该添加测试，以便其他人可以扩展我们的库，并确保他们自己的函数不会与现有代码冲突。<strong class="ka ir">添加一个测试文件夹</strong>到我们库的模块目录:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="7fb6" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">datapeek</strong><br/>    └── <!-- -->__init__.py<br/>    <!-- -->└── <!-- -->utilities.py<br/>    <!-- -->└── <strong class="mz ir">data<br/>    </strong>└── <strong class="mz ir">tests</strong><strong class="mz ir"><br/></strong>├── <!-- -->MANIFEST.in<br/>├── <!-- -->setup.py<br/>├── <!-- -->gitignore</span></pre><p id="4f2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的测试文件夹应该有自己的<code class="fe mw mx my mz b">__init__.py</code>文件以及测试文件本身。<strong class="ka ir">创建</strong>那些现在使用 JupyterLab 的文本文件选项:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="6729" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">datapeek</strong><br/>├── <strong class="mz ir">datapeek</strong><br/>    └── <!-- -->__init__.py<br/>    <!-- -->└── <!-- -->utilities.py<br/>    <!-- -->└── <strong class="mz ir">data<br/>    </strong>└── <strong class="mz ir">tests<br/>        </strong>└──<!-- -->__init__.py<br/>        <!-- -->└──<!-- -->datapeek_tests.py<br/>├── <!-- -->MANIFEST.in<br/>├── <!-- -->setup.py<br/>├── <!-- -->gitignore</span></pre><p id="241f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的 datapeek 目录结构现在被设置为存放测试函数，我们现在将编写这些函数。</p><h2 id="ae64" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">写作测试</h2><p id="923f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">用 Python 编写测试类似于用 r 编写测试。断言用于检查本库函数产生的预期输出。我们可以使用这些“<a class="ae nb" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>来检查各种期望的输出，这取决于什么可能会失败。例如，我们可能希望确保返回一个数据帧，或者在某种已知的转换后返回正确的列数。</p><p id="28dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将为我们的 4 个函数添加一个简单的测试。请随意添加您自己的测试。思考应该检查什么，并记住马丁·福勒在本文 R 部分引用的话。</p><p id="686c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用 Python 中流行的单元测试框架<a class="ae nb" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a>。</p><p id="bd91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">将</strong> <strong class="ka ir">单元测试</strong>添加到 datapeek_tests.py 文件中，确保单元测试和 datapeek 库被导入:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ff01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了运行这些测试，我们可以使用<a class="ae nb" href="https://nose.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Nose </strong> </a>，它扩展了 unittest，使测试更加容易。<strong class="ka ir">使用 JupyterLab 中的<strong class="ka ir">终端</strong>会话安装</strong> <strong class="ka ir">机头</strong>；</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="46fc" class="ld le iq mz b gy ng nh l ni nj">$ pip install nose</span></pre><p id="e8f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要<strong class="ka ir">向 setup.py 添加</strong>以下几行:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="46bd" class="ld le iq mz b gy ng nh l ni nj">setup(<br/>    ...<br/>    <strong class="mz ir">test_suite='nose.collector',<br/>    tests_require=['nose'],</strong><br/>)</span></pre><p id="9b49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的 setup.py 现在应该是这样的:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2f64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从根目录运行以下命令来运行我们的测试:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="6e68" class="ld le iq mz b gy ng nh l ni nj">python setup.py test</span></pre><p id="c1f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果需要，Setuptools 将负责安装 nose 并运行测试套件。运行上述程序后，您应该会看到以下内容:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/0bc8182d8b8a0af7f4b8a58e54efc0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4JQ-0NfM5JosUIEn0al9A.png"/></div></div></figure><p id="7760" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们所有的测试都通过了！</p><p id="41d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果任何测试失败，unittest 框架将显示哪些函数没有通过。此时，检查以确保您正确地调用了函数，并且输出确实是您所期望的。故意先写测试失败的代码，然后写你的函数直到它们通过，这也是一个很好的实践。</p><h1 id="2ace" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 7:创建文档</h1><p id="039e" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">正如我在 R 部分提到的，我使用<a class="ae nb" href="http://julepcode.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Julep </strong> </a>来快速创建可共享和可搜索的文档。这避免了编写晦涩的注释，并提供了立即托管我们的文档的能力。当然，这并不像其他文档那样附带 IDE 挂钩，但是对于快速交流来说，它是有效的。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi px"><img src="../Images/097a761445d3bcb9af22aa48a8ca3993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXsc1sQ1K-tek4UKE9WKaA.png"/></div></div></figure><p id="16cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里找到我为这个库<a class="ae nb" href="http://julepcode.live/jnt4fl" rel="noopener ugc nofollow" target="_blank">创建的文档。</a></p><h1 id="0384" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 8:共享你的 Python 库</h1><p id="5ede" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">共享 python 库的标准方法是通过 PyPI。正如我们没有介绍 R 中的 CRAN 一样，我们也不会介绍在 PyPI 上托管我们的库。虽然要求比 CRAN 少，但要在 PyPI 上成功托管，仍然需要采取许多步骤。在 GitHub 之外的站点上托管所需的步骤可以在以后添加。</p><h2 id="cf86" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">开源代码库</h2><p id="d5ba" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们在 R 小节中介绍了向 GitHub 添加项目的步骤。同样的步骤也适用于此。</p><p id="fa2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在上面提到需要<strong class="ka ir">重命名我们的 gitignore 文件</strong>使其成为一个隐藏文件。<strong class="ka ir"> </strong>您可以在<strong class="ka ir">终端</strong>中运行以下命令:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="4735" class="ld le iq mz b gy ng nh l ni nj">mv gitignore .gitignore</span></pre><p id="a170" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到这个文件在我们的 JupyterLab 目录中不再可见(它最终会消失)。由于 JupyterLab 仍然缺乏切换隐藏文件的前端设置，因此只需随时在终端中运行以下命令即可查看隐藏文件:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="b7f1" class="ld le iq mz b gy ng nh l ni nj">ls -a </span></pre><p id="8da1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们需要在 JupyterLab 中查看/编辑该文件，我们可以通过运行以下命令使其再次可见:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="4cef" class="ld le iq mz b gy ng nh l ni nj">mv .gitignore gitignore</span></pre><p id="6e67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个关于将我们的库推送到 GitHub 的快速回顾(将 git URL 改为你自己的):</p><ul class=""><li id="195f" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated">在 GitHub 上创建一个名为 datapeek_py 的新 repo</li><li id="bd4d" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">使用<code class="fe mw mx my mz b">git init</code>初始化</strong>你的库的目录</li><li id="d626" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">使用您的 GitGub 电子邮件和用户名(如果使用 Docker)配置您的本地回购:</strong></li></ul><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="d8c7" class="ld le iq mz b gy ng nh l ni nj">git config --global user.email {emailaddress}<br/>git config --global user.name {name}</span></pre><ul class=""><li id="fc3e" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><strong class="ka ir">使用<code class="fe mw mx my mz b"> git remote add origin <a class="ae nb" href="https://github.com/sean-mcclure/datapeek_py.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sean-mcclure/datapeek_py.git</a></code>添加</strong>您的新远程原点</li><li id="9fdb" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">阶段</strong>你的图书馆使用<code class="fe mw mx my mz b">git add .</code></li><li id="1eb7" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">使用<code class="fe mw mx my mz b">git commit -m ‘initial commit’</code>提交</strong>所有文件</li><li id="ab04" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><strong class="ka ir">使用<code class="fe mw mx my mz b">git push origin master</code>将</strong>您的库推送到远程 repo(出现提示时进行身份验证)</li></ul><p id="d653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，<strong class="ka ir">任何人都可以使用我们的 python 库</strong>。👍让我们看看怎么做。</p><h1 id="2065" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">步骤 9:安装 Python 库</h1><p id="d7d3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">虽然我们通常使用以下命令安装 Python 库:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="c6d3" class="ld le iq mz b gy ng nh l ni nj">pip install &lt;package_name&gt;</span></pre><p id="6197" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…这需要在 PyPI 上托管我们的库，正如上面解释的，这超出了本文的范围。相反，我们将学习如何从 GitHub 安装我们的 Python 库，就像我们对 r 所做的那样。这种方法仍然需要<code class="fe mw mx my mz b">pip install</code>命令，但是使用 GitHub URL 而不是包名。</p><h2 id="6496" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">从 GitHub 安装我们的 Python 库</h2><p id="93b5" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的库托管在 GitHub 上，我们只需使用<code class="fe mw mx my mz b">pip install git+</code>，后跟 GitHub repo 上提供的 URL(可通过点击 GitHub 网站上的<em class="kw">克隆或下载</em>按钮获得):</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="ecd1" class="ld le iq mz b gy ng nh l ni nj">pip install git+https://github.com/sean-mcclure/datapeek_py</span></pre><p id="f991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以<strong class="ka ir">将我们的库</strong>导入到 Python 环境中。对于单一功能:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="ca12" class="ld le iq mz b gy ng nh l ni nj">from datapeek.utilities import encode_and_bind</span></pre><p id="3b55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…对于<strong class="ka ir">所有功能</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="cdd3" class="ld le iq mz b gy ng nh l ni nj">from datapeek.utilities import *</span></pre><p id="799c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在新的 Python 环境中做一个快速检查，以确保我们的函数可用。创建一个新的 Docker 容器，我运行以下代码:</p><p id="c34e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">获取数据集</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="edac" class="ld le iq mz b gy ng nh l ni nj">iris = pd.read_csv('<a class="ae nb" href="https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv'</a>)</span></pre><p id="e3f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">检查功能</strong>:</p><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="7541" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">encode_and_bind</strong>(iris, 'species')</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi py"><img src="../Images/61c7af31fa8b9605cb80d4ce130048fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cB-1NTEjiLYHLub-LP_fg.png"/></div></div></figure><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="39ef" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">remove_features</strong>(iris, ['petal_length', 'petal_width'])</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pz"><img src="../Images/4cbb4a7c31f8cb96ab06db32b6657385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoOaRRJS6mFfgf4gISLJxA.png"/></div></div></figure><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="6dde" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">apply_function_to_column</strong>(iris, ['sepal_length'], 'times_4', 'x*4')</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qa"><img src="../Images/2926a56a936b0758f794bc8f95e85698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YInyLtj6rKlA15CD23jYcA.png"/></div></div></figure><pre class="mb mc md me gt nc mz nd ne aw nf bi"><span id="280f" class="ld le iq mz b gy ng nh l ni nj"><strong class="mz ir">get_closest_string</strong>(['hey there','we we are','howdy doody'], 'doody')</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qb"><img src="../Images/b9465bb23fc0ac679ed579006057c6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gj5RhqcRZTNpsd1pLsOMlg.png"/></div></div></figure><p id="e3cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功！</p><h1 id="c004" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">摘要</h1><p id="24e1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本文中，我们研究了如何使用运行在 Docker 容器中的 JupyterLab 来创建 R 和 Python 库。Docker 允许我们利用 Docker 栈，这样我们的环境很容易控制，并且可以使用公共包。这也使得使用相同的高级接口通过浏览器为 2 种不同的语言创建库变得容易。因为我们在 Docker 中装入了一个卷，所以所有的文件都被写到我们的本地机器上。</p><p id="4663" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建库对于任何机器学习从业者来说都是一项关键技能，我也鼓励其他人经常这么做。库有助于将我们的工作隔离在有用的抽象中，提高可再现性，使我们的工作可共享，并且是设计更好软件的第一步。使用轻量级的方法确保我们可以快速地构建原型和共享，并根据需要选择添加更详细的实践和发布标准。</p><p id="f2ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往，如果你遇到问题，请在评论区提出<strong class="ka ir">问题</strong>。快乐编码。</p><p id="35e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如果你喜欢这篇文章，你可能也会喜欢:</strong></p><div class="qc qd gp gr qe qf"><a rel="noopener follow" target="_blank" href="/learn-to-build-machine-learning-services-prototype-real-applications-and-deploy-your-work-to-aa97b2b09e0c"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd ir gy z fp qk fr fs ql fu fw ip bi translated">学习建立机器学习服务，原型真实的应用程序，并部署您的工作…</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">在这篇文章中，我将向读者展示如何将他们的机器学习模型公开为 RESTful web 服务，原型真实…</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="qp l qq qr qs qo qt jw qf"/></div></div></a></div><div class="qc qd gp gr qe qf"><a rel="noopener follow" target="_blank" href="/combining-d3-with-kedion-graduating-from-toy-visuals-to-real-applications-92bf7c3cc713"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd ir gy z fp qk fr fs ql fu fw ip bi translated">用 D3.js 从玩具视觉过渡到真实应用</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">我们经常孤立地学习技术和方法，与数据科学的真正目标脱节；至…</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="qu l qq qr qs qo qt jw qf"/></div></div></a></div><div class="qc qd gp gr qe qf"><a rel="noopener follow" target="_blank" href="/gui-fying-the-machine-learning-workflow-towards-rapid-discovery-of-viable-pipelines-cab2552c909f"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd ir gy z fp qk fr fs ql fu fw ip bi translated">机器学习工作流的 GUI 化:快速发现可行的流水线</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">前言</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="qv l qq qr qs qo qt jw qf"/></div></div></a></div><h1 id="055a" class="mf le iq bd lf mg mh mi li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv bi translated">进一步阅读和资源</h1><ul class=""><li id="20bb" class="nn no iq ka b kb lw kf lx kj ps kn pt kr pu kv ns nt nu nv bi translated">哈雷·威克姆的 R 包</li><li id="3591" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">哈德利·韦翰的测试</li><li id="312c" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">Scott Torborg 的 Python 打包</li><li id="d2db" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://hub.docker.com/r/jupyter/datascience-notebook/" rel="noopener ugc nofollow" target="_blank"> Jupyter 数据科学笔记本</a></li><li id="334c" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker —定位和设置</a></li><li id="cbd6" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://jupyterlab.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> JupyterLab 文档</a></li><li id="72c9" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://cran.r-project.org/web/packages/available_packages_by_date.html" rel="noopener ugc nofollow" target="_blank">按发布日期列出的可用起重机包</a></li><li id="631d" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="http://r-pkgs.had.co.nz/man.html" rel="noopener ugc nofollow" target="_blank">记录 R 中的功能</a></li><li id="12a9" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://julepcode.com/" rel="noopener ugc nofollow" target="_blank">七月</a></li><li id="a284" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://www.gitignore.io/" rel="noopener ugc nofollow" target="_blank"> gitignore.io </a></li><li id="b4b7" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank">Python 包索引</a></li><li id="155c" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://setuptools.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">设置工具文档</a></li><li id="4ff0" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv" rel="noopener ugc nofollow" target="_blank">GitHub 上的虹膜数据集</a></li><li id="bb78" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试—维基百科文章</a></li><li id="129c" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">unitest——一个单元测试框架</a></li><li id="2fb2" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://nose.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">Nose——Python 更好的测试</a></li><li id="e707" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发—维基百科上的文章</a></li><li id="bb40" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nb" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank">对接器运行参考</a></li></ul></div></div>    
</body>
</html>