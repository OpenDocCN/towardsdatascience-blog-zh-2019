<html>
<head>
<title>Python &amp; Vectorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 和矢量化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-vectorization-5b882eeef658?source=collection_archive---------11-----------------------#2019-05-03">https://towardsdatascience.com/python-vectorization-5b882eeef658?source=collection_archive---------11-----------------------#2019-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8649725041bf639541c10c1d6d37920b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUivF7hNxWsWEsE7xcZHqQ.png"/></div></div></figure><div class=""/><p id="04fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当今世界的计算机硬件通过利用 SIMD(单指令、多数据)架构，利用并行计算来实现更快的计算。SIMD 是一类并行计算，其中逻辑处理器同时对多个数据点执行单个指令。我们需要向量化我们的深度学习代码，以便我们可以利用我们的系统提供的所有计算能力。计算越快，我们的神经网络训练得越快，我们得到结果的速度就越快。因此，对一段代码进行矢量化的能力已经成为深度学习实践者的一项关键技能。在这个故事中，我将解释使用 python 进行矢量化的基础知识。</p><h1 id="ecd4" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">到底什么是矢量化？</h1><p id="b916" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在逻辑回归的背景下，让我们借助下面的等式来理解矢量化的确切含义:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/22a43885670df85c76d08726da7a4d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*2ZdcTupgZzVps_NOiyzpdg.png"/></div></figure><p id="8201" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">存储输入和权重的约定并不标准，但我更喜欢用以下方式存储。设<strong class="kd jf"> <em class="mh"> X </em> </strong>为输入矩阵的维数(<strong class="kd jf"> <em class="mh"> n，m) </em> </strong>其中<strong class="kd jf"> <em class="mh"> n </em> </strong>是出现在<strong class="kd jf"><em class="mh"/></strong>中的特征数，而<strong class="kd jf"> <em class="mh"> m </em> </strong>是出现在我们的训练数据集中的训练样本数，即我们在 1 列中存储一个数据点。对于每个特征，都会有一个与之相关联的权重，因此设<strong class="kd jf"> <em class="mh"> W </em> </strong>为维度的权重矩阵(<strong class="kd jf"> <em class="mh"> n，1) </em> </strong>)。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/2d6acd23752a5ecf3de9cae73fb869bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*aR_wREi4O5hVmZuUbd2fAQ.png"/></div></figure><p id="ba6a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们使用<strong class="kd jf"> <em class="mh">为</em> </strong>循环编写示例方程，我们会得到如下结果:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/0009e6393ea79c24763bb62989f067a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*w7287t9cuFOCOCeVEWiicQ.png"/></div></figure><p id="b190" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述代码片段由针对 循环的显式<strong class="kd jf"> <em class="mh">组成，不会利用并行化。因此，我们需要将其转换为矢量化版本。这可以通过以下方式利用内置的<strong class="kd jf"> <em class="mh"> Numpy </em> </strong>函数轻松完成:</em></strong></p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b7d290bd41a94f9bc54d2011b68bae0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*HLibRk_T8QPDrwItSiqvsg.png"/></div></figure><p id="7473" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> <em class="mh"> Z </em> </strong>将是一个<strong class="kd jf"> <em class="mh"> (1，m) </em> </strong>矩阵，按照矩阵乘法规则。<strong class="kd jf"> <em class="mh"> np.dot() </em> </strong>函数执行给定输入矩阵的矩阵乘法。它不仅使代码更具可读性和可理解性，而且还利用并行化来提高计算速度。下面的代码片段显示了与非矢量化实现相比，矢量化实现的速度有多快。</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="1524" class="mq la je mm b gy mr ms l mt mu"><strong class="mm jf">import </strong>numpy <strong class="mm jf">as </strong>np<br/><strong class="mm jf">import </strong>time</span><span id="d3a8" class="mq la je mm b gy mv ms l mt mu"><em class="mh"># Number of features<br/></em>n = 1000<br/><em class="mh"># Number of training examples<br/></em>m = 10000<br/><em class="mh"># Initialize X and W<br/></em>X = np.random.rand(n,m)<br/>W = np.random.rand(n,1)</span><span id="1829" class="mq la je mm b gy mv ms l mt mu"><em class="mh"># Vectorized code<br/></em>t1=time.time()<br/>Z = np.dot(W.T,X)<br/>print(<strong class="mm jf">"Time taken for vectorized code is : "</strong>,(time.time()-t1)*1000,<strong class="mm jf">"ms"</strong>)</span><span id="ace9" class="mq la je mm b gy mv ms l mt mu"><em class="mh"># Non Vectorized code<br/></em>Z1 = np.zeros((1,m))<br/>t2 = time.time()<br/><strong class="mm jf">for </strong>i <strong class="mm jf">in </strong>range(X.shape[1]):<br/>    <strong class="mm jf">for </strong>j <strong class="mm jf">in </strong>range(X.shape[0]):<br/>        Z[0][i] += W[j]*X[j][i]</span><span id="14e8" class="mq la je mm b gy mv ms l mt mu">print(<strong class="mm jf">"Time taken for non vectorized code is : "</strong>,(time.time()-t2)*1000,<strong class="mm jf">"ms"</strong>)</span><span id="8139" class="mq la je mm b gy mv ms l mt mu"><strong class="mm jf">''' Output<br/>Time taken for vectorized code is :  5.964040756225586 ms<br/>Time taken for non vectorized code is :  40915.54665565491 ms<br/>'''</strong></span></pre><p id="a552" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述实现仅考虑 10k 训练示例和 1k 特征。尽管有代码优化策略，但显然矢量化实现比非矢量化实现快得多。<strong class="kd jf"> <em class="mh"> Numpy </em> </strong>是一个用于科学计算的 python 库。它<strong class="kd jf"> <em class="mh"> </em> </strong>提供了各种内置函数，让我们可以轻松地编写矢量化代码。</p><blockquote class="mw mx my"><p id="03ec" class="kb kc mh kd b ke kf kg kh ki kj kk kl mz kn ko kp na kr ks kt nb kv kw kx ky im bi translated">根据经验，我们应该使用内置的<strong class="kd jf"> numpy </strong>函数为任何未来的实现编写矢量化代码。</p></blockquote><h1 id="dfb3" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">向量化逻辑回归</h1><p id="4d39" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">既然我们已经看到了编写矢量化代码的好处，那么让我们更深入地研究，为逻辑回归编写矢量化代码。不可能为每种情况编写一个矢量化代码，但是我们应该尽可能地遵循经验法则。让我们看一个非矢量化版本的逻辑回归，并尝试找出可以矢量化的部分。这样我们就能理解如何将一段给定的代码转换成它的矢量化版本。为简单起见，我们将只考虑<strong class="kd jf"> <em class="mh"> X </em> </strong>中的 2 个特征，因此只有 2 个权重。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/37f7a138b64da3e351370887f940cf3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*mArhc9TkCjkZYvJAwCcsmQ.png"/></div></figure><p id="f1b1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们只考虑了 2 个权重，即<strong class="kd jf"> <em class="mh"> w1 </em> </strong>和<strong class="kd jf"> <em class="mh"> w2 </em> </strong>，但是在实际生活场景中会有更多的权重，处理它们将成为一项复杂的任务。因此，我们将通过以下方式对权重导数<strong class="kd jf"> <em class="mh"> dw1 </em> </strong>和<strong class="kd jf"> <em class="mh"> dw2 </em> </strong>的计算和更新进行矢量化:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="f112" class="mq la je mm b gy mr ms l mt mu">dW = X[i].dZ[i]<br/>dW /= m</span></pre><p id="ae9a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上述更改的帮助下，我们已经设法对代码的一小部分进行了矢量化。大部分仍然依赖于<strong class="kd jf"> <em class="mh"> for </em> </strong>循环，该循环用于迭代所有的训练示例。让我们看看如何移除 循环的<strong class="kd jf"> <em class="mh">并对其进行矢量化:</em></strong></p><p id="ee00" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有训练示例的值<strong class="kd jf"> <em class="mh"> A </em> </strong>可以很容易地通过下式找到:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="315b" class="mq la je mm b gy mr ms l mt mu">A = sigmoid(np.dot(W.T,X)+b)</span></pre><p id="279f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">成本<strong class="kd jf"> <em class="mh"> J </em> </strong>可由下式查出:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="7512" class="mq la je mm b gy mr ms l mt mu">J = -(np.dot(Y,np.log(A).T)+np.dot((1-Y),np.log(1-A).T))</span></pre><p id="0066" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有训练示例的导数<strong class="kd jf"> <em class="mh"> dZ </em> </strong>，<strong class="kd jf"> <em class="mh"> dW </em> </strong>和<strong class="kd jf"> <em class="mh"> dB </em> </strong>可以通过以下方式找到:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="951e" class="mq la je mm b gy mr ms l mt mu">dZ = A - Y <br/>dW = np.dot(X*(dZ.T))/m<br/>dB = (np.sum(dZ))/m</span></pre><p id="d308" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">权重矩阵<strong class="kd jf"> <em class="mh"> W </em> </strong>和偏差<strong class="kd jf"> <em class="mh"> B </em> </strong>可以通过以下方式更新:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="2b44" class="mq la je mm b gy mr ms l mt mu">W = W - alpha*dW<br/>b = b - alpha*dB</span></pre><p id="e3e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些转变起初看起来令人困惑。因此，我敦促读者看看每次计算后每个矩阵的维数是如何变化的。这将有助于更好地理解事物。让我们应用这些变化，看看当所有东西都被编译在一起时，矢量化的代码是什么样子。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c53334ad5e5a41aa2f29a8a988b56fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*xudZy4erEuAlVoDSsrxooQ.png"/></div></figure><p id="7dd1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码更加清晰、易读、简短，计算速度也更快。</p><h1 id="6987" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">广播</h1><p id="1696" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在代码中，你可能已经发现两个维数不相容的矩阵被相加、相减、相乘和相除。<strong class="kd jf"> <em class="mh"> Numpy </em> </strong>有一大特色叫<strong class="kd jf"> <em class="mh">播</em> </strong>。在某些约束条件下，较小的矩阵被<strong class="kd jf"> <em class="mh">广播</em> </strong>到较大的矩阵，以便它们具有兼容的维数来执行各种数学运算。让我们借助一些例子来看看广播是如何工作的。设<strong class="kd jf"> <em class="mh"> A </em> </strong>和<strong class="kd jf"> <em class="mh"> B </em> </strong>为输入矩阵，<strong class="kd jf"> <em class="mh"> C </em> </strong>为输出矩阵，作为对<strong class="kd jf"> <em class="mh"> A </em> </strong>和<strong class="kd jf"> <em class="mh"> B </em> </strong>的任何数学运算的结果。</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="5d22" class="mq la je mm b gy mr ms l mt mu">Shape of A : 5 x 4<br/>Shape of B :     4<br/>Shape of C : 5 x 4</span><span id="1f82" class="mq la je mm b gy mv ms l mt mu">Shape of A : 15 x 3 x 5<br/>Shape of B : 15 x 1 x 5<br/>Shape of C : 15 x 3 x 5</span><span id="b07e" class="mq la je mm b gy mv ms l mt mu">Shape of A : 8 x 1 x 6 x 1<br/>Shape of B :     7 x 1 x 5<br/>Shape of C : 8 x 7 x 6 x 5</span><span id="98fd" class="mq la je mm b gy mv ms l mt mu">Shape of A : 2 x 3 x 3<br/>Shape of B :     1 x 5<br/>Shape of C : Error</span></pre><p id="e52a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由此可见，广播工作基于两个原则:</p><ol class=""><li id="e322" class="ne nf je kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><strong class="kd jf"> <em class="mh"> A </em> </strong>和<strong class="kd jf"> <em class="mh"> B </em> </strong>的尾部尺寸应等于<strong class="kd jf"> <em class="mh">或</em> </strong></li><li id="23f2" class="ne nf je kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd jf"> <em class="mh"> A </em> </strong>或<strong class="kd jf"> <em class="mh"> B </em> </strong>的拖尾尺寸应为 1。</li></ol><blockquote class="mw mx my"><p id="bbb4" class="kb kc mh kd b ke kf kg kh ki kj kk kl mz kn ko kp na kr ks kt nb kv kw kx ky im bi translated">理解矢量化并将给定代码转换为矢量化格式的最佳方式是跟踪表中各种矩阵的维数。</p></blockquote><p id="6842" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">起初，编写代码的矢量化版本可能会令人望而生畏，但是，在 Numpy 的内置函数和广播的帮助下，通过练习，它变得非常容易。这将使代码可读性更强，速度更快。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="7615" class="kz la je bd lb lc nz le lf lg oa li lj lk ob lm ln lo oc lq lr ls od lu lv lw bi translated">参考</h1><ol class=""><li id="2b3e" class="ne nf je kd b ke lx ki ly km oe kq of ku og ky nj nk nl nm bi translated"><a class="ae oh" href="https://stackoverflow.com/questions/1422149/what-is-vectorization" rel="noopener ugc nofollow" target="_blank"> StackOverflow —什么是矢量化？</a></li><li id="cda9" class="ne nf je kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><a class="ae oh" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">科学文件—广播</a></li><li id="d8d9" class="ne nf je kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><a class="ae oh" href="https://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a></li><li id="0792" class="ne nf je kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><a class="ae oh" href="https://www.coursera.org/learn/neural-networks-deep-learning?specialization=deep-learning" rel="noopener ugc nofollow" target="_blank"> Coursera —深度学习课程 1 </a></li></ol></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="494e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我要感谢读者阅读这个故事。如果你有任何问题或疑问，请在下面的评论区提问。我将非常乐意回答这些问题并帮助你。如果你喜欢这个故事，请关注我，以便在我发布新故事时获得定期更新。我欢迎任何能改进我的故事的建议。</p></div></div>    
</body>
</html>