<html>
<head>
<title>Graph Networks for Champion Recommendation (League of Legends)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冠军推荐的图形网络(英雄联盟)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-networks-for-champion-recommendation-league-of-legends-189c8d55f2b?source=collection_archive---------23-----------------------#2019-06-11">https://towardsdatascience.com/graph-networks-for-champion-recommendation-league-of-legends-189c8d55f2b?source=collection_archive---------23-----------------------#2019-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a9068ea3ccaba1d90028a51975c17385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uJMLUUZPaznwMzIntuEZQ.png"/></div></div></figure><p id="8537" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们想象你为暴乱游戏公司工作。你的第一个任务是设计一种在他们的游戏《英雄联盟》中产生冠军(可玩角色)推荐的方法。你会如何处理这个问题？</p><p id="c07c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标准的方法是给每个冠军贴上关键属性的标签，然后根据这些共同属性将他们联系起来。我们可以用这个来假设享有冠军 A 的参与人 1 也会享有相似的冠军 b。</p><p id="9cb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例子:泽德是一名中路刺客，使用近战攻击，并拥有高机动性装备。塔龙也有这些属性，因此如果一号玩家喜欢泽德，我们可以假设他们也会喜欢塔龙。</p><p id="9429" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，通过使用图网络，我们可以反过来解决这个问题:如果我们已经知道平均来说享受冠军 A 的玩家享受冠军 B，那么那些目前只玩冠军 A 的玩家将可能享受冠军 B——不管他们共享什么属性。</p><p id="4579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">例子:经常玩 Zed 的玩家也经常玩 Talon。如果一号玩家只玩泽德，他们可能也会喜欢塔龙。我们可以假设这两个冠军有相似之处——我们只是不需要定义他们是什么。</em></p><p id="7fe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里找到最终产品:【www.lolnets.com T4】</p><h1 id="e759" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">语境</h1><p id="86d9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">你可以在这里观看游戏介绍。</p><p id="e375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里阅读更多关于图表的信息。</p><p id="355e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“节点”=图中的特定点，在此上下文中，“节点”是冠军</p><p id="f4c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“边”=两个节点(冠军)之间的连接。如果没有边缘，两个冠军是不相连的。有时与权重(也称为节点间距离)一起使用。</p><h1 id="7295" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">数据采集</strong></h1><p id="f518" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">对于任何数据科学问题，第一步都是收集数据。首先，我们需要随机选择一个召唤师的名字。幸运的是，这些都可以通过 Riot API 工具轻松实现。</p><p id="177a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先创建一个区域和部门列表。为此，我使用了 3 个地区(EUW、北美和韩国)和以下分类:钻石、铂金、黄金、白银和青铜(比例为 1:2:4:4:2)。然后可以使用下面的循环随机创建一个大约 8000 个召唤师 id 的列表。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/524735c526833c6c6e469e93bc5e1426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ay-953_2FTnRvzzxZYuXQg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Loop code used to create a randomised list of Summoner IDs</figcaption></figure><p id="fa92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们有了这些 id，我们可以再次使用 Riot API 来循环每个召唤师，找到他们的前 5 名冠军。代码下方的表格显示了 5 名随机玩家，他们最常玩的 5 个冠军(显示为冠军 ID)。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/36b3c0c1d0e2bb26e59a5089cc990cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQQPoEWTTVoovSYv1Ednzg.png"/></div></div></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/383e0711d8e2ff7523837cef498ef60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*kA4956GxykhltIzNbZiLDg.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Each players Top 5 Champions (using Champion ID)</figcaption></figure><p id="70d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过聚集这个数据集，我们可以回答每个冠军的以下问题:当他们出现在玩家的前 5 名名单中时，哪些冠军也最常出现在同一名单中？</p><p id="ff53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建下表:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f6e00daba72678ea27280ab5a7ae1ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*mPOc_ZvzzsmzN_pppZMkoA.png"/></div></figure><p id="0b29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，对于冠军 1(安妮)，最常见的连接是冠军 103 (Ahri)。用最简单的话来说:对于所有 8000 名选手来说，那些经常打安妮的选手也将比其他任何冠军更经常打 Ahri。</p><p id="badf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过另一个简单的循环，我们可以将这个表转换为一个矩阵，其中冠军 ID 1(在 Y 轴上)将连接到 X 轴上的冠军 103、142 和 55。然后再一次，以同样的方式从 X 转置到 y。这将在所有冠军中重复。代码下方是最终矩阵的<strong class="ka ir">说明性示例(非真实数据)</strong>。冠军 id 出现在 X 和 Y 轴上，其中 1 表示两个冠军之间有联系，0 表示没有联系。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/75b0148d4582ba8c3a1926e94f452893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJUknU9E4CeoVwIiI_IBoA.png"/></div></div></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/8aa7abc92645431573649ad28cf5772a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*WBg-De123PIJ9NTUYGriAg.png"/></div></div></figure><p id="29c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据收集现已完成。</p><h1 id="8cb2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">图形网络</h1><p id="dfae" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">下一步是创建图形网络，为此，我将使用 NetworkX 根据我们之前保存的矩阵创建图形。然后我们用散景来更详细地观察它。完整代码如下:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/4265b342eb3fe4f97cd9860b0e13e01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XN9_ugiB9I1v9B6GDI-uug.png"/></div></div></figure><p id="df27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建下图:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a9068ea3ccaba1d90028a51975c17385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uJMLUUZPaznwMzIntuEZQ.png"/></div></div></figure><p id="d616" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里看到这张图的互动版本<a class="ae kx" href="https://www.lolnets.com/graph" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cd3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点按泳道着色(黄色:支持，橙色:ADC，蓝色:中间，绿色:丛林，红色:顶部)。由此我们可以得出一些有趣的发现，例如 Thresh/Blitzcrank 往往是由非支援玩家扮演的支援(因为它最接近其他车道组)，而 Soraka 往往是支援主线的首选冠军(因为它最深入支援组)。这个逻辑可以贯穿始终，查看交互图，得出自己的结论！</p><p id="9197" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是对推荐有帮助吗？答案是依赖。是的，如果你正在寻找你最喜欢的泳道的冠军，不，否则。这是为什么呢？</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/57a38a0fac8d1a257539e5f7eb426987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkP0D-PMbYypSycOzOID_A.png"/></div></div></figure><p id="c1e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你是一名 ADC main，你可以假设你的前 3 名冠军将围绕以黑色突出显示的橙色部分分组。如果我们使用此图来推荐冠军，可以肯定的是，它只会推荐一小部分最接近 ADC 分组的中间 laners(用蓝色标记)。这不是一个量身定制的建议。它不会从您独特的 ADC 冠军那里获取您的特定玩法，而是简单地将您默认为一个通用 ADC 播放器，并假设您与所有其他 ADC 完全一样。</p><p id="a2e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了改善这一点，我们需要回到数据收集上来。</p><h1 id="b9ab" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数据收集 2</h1><p id="99fd" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这一次，我们正在以不同的方式完成任务。我们不会给每个玩家找前 5 名冠军，我们会给每个玩家找前 3 名冠军<em class="kw"/>。这意味着，对于每一个冠军，我们也将有共同的连接到每一个车道。</p><p id="bd78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">循环代码相当长，所以我不会在这里包括它。最后，我们留下了一个矩阵，它包含每个冠军，并将其连接到每个通道中的前 3 名冠军(总共 15 个连接)。除此之外，这些优势现在也将根据他们的平均冠军掌握程度作为该车道的百分比进行加权。</p><p id="a5dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">举例:如果你是一个打 Thresh (80k 精通)、Blitzcrank (10k 精通)、Pyke (10k 精通)做支援的 ADC 主。然后 Thresh 会给 80%，Blitz 给 10%，Pyke 给 10%。</em></p><p id="4909" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是反过来计算的:边 A 到 B 权重= 1 —(冠军 B 精通点数/总冠军精通点数)。这样，<strong class="ka ir">越高的</strong>玩家在一条道上掌握的百分比就在冠军身上，<strong class="ka ir">越低的</strong>边权重(也称为节点间距离)。</p><h1 id="d41f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">图形网络 2</h1><p id="95ec" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在我们有了一个新的方法来处理图网络，我们可以使用相同的代码重新创建图。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/d2b31800cc9b25ade3c6c5f948ee7983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCn1lJS1gKS48AtJ53LuLg.png"/></div></div></figure><p id="c0ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这比之前的要复杂得多。节点之间有大量的连接，权重决定了它们之间的距离。虽然看起来不太舒服，但它现在应该会提供更强的推荐。</p><h1 id="d3a4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">推荐引擎</h1><p id="b58f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">最后一部分是制造引擎。为此，我们回到 Riot API。通过插入我们自己的召唤师名字和地区，我们可以调用我们最常玩的冠军列表。我们用我们的干线，用<a class="ae kx" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Dijkstra 的算法</a>来确定从我们的冠军到其他冠军的距离。我们删除任何我们已经经常玩的冠军，按球道分组，瞧——我们会找到最接近我们已经玩过的冠军。</p><p id="dd34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">举例:我是 AP Mid main，大部分时间玩战斗法师，比如 Vel'Koz 和 Lux。我的首选是 Teemo，我的中间是仙后座，我的支持者是莫甘娜。这是有道理的，我们可能会使用本文开头概述的简单方法到达这里。然而，对于 ADC，我被推荐为 Jhin——这一点我无法解释。我没玩过 Jhin，但是和我一样热爱战斗法师的人玩 ADC 的时候似乎也很享受 Jhin。引用大师自己的话，我的观众在等待！</em></p><p id="b81a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://www.lolnets.com/recommend" rel="noopener ugc nofollow" target="_blank">如需自己的推荐，请点击此处。</a></p><h1 id="e35a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="29f4" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">谢谢你读到文章最后。我希望这为如何在推荐引擎中使用图网络提供了一些启示。我可能最终会将完整的代码发布到 GitHub 上，但直到我对它的编写方式感到更加自豪。我计划很快将此贴在 Reddit 上，当我这样做时，我会包含链接，请随时在这里或那里留下您的反馈和评论。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="782e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你已经看到文章的结尾了！我叫 Jack J，是一名将人工智能应用于竞技游戏和电子竞技的专业数据科学家。我是<a class="ae kx" href="https://itero.gg/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> iTero 的创始人。GG</strong>T3</a><a class="ae kx" href="https://www.jung.gg/" rel="noopener ugc nofollow" target="_blank">和<strong class="ka ir">jung . GG</strong>T7】。你可以在</a><a class="ae kx" href="https://twitter.com/JackJGaming" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Twitter </strong> </a>上关注我，加入<a class="ae kx" href="https://discord.gg/hZmk3z6adP" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> iTero Discord </strong> </a>或者给我发邮件<strong class="ka ir"> jack@itero.gg </strong>。下一场见。</p><p id="02e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">最初发表于:</em><a class="ae kx" href="https://itero.gg/blog" rel="noopener ugc nofollow" target="_blank">【https://itero.gg/blog】T21</a></p></div></div>    
</body>
</html>