<html>
<head>
<title>Building a Minimal Blockchain in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 构建一个最小的区块链</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-minimal-blockchain-in-python-4f2e9934101d?source=collection_archive---------4-----------------------#2019-07-13">https://towardsdatascience.com/building-a-minimal-blockchain-in-python-4f2e9934101d?source=collection_archive---------4-----------------------#2019-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d28e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过编码了解区块链</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f367da870da2cf1ae6953d1d20df08a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aoyqbjj9CGk9IqD5"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@neural_notworks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shaojie</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区块链不仅仅是比特币或其他加密货币。它也用于数据库，如健康记录。</p><p id="027c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与某种流行的观念相反，区块链与数据加密无关。事实上，区块链中的所有数据都是透明的。它的特别之处在于它(在一定程度上)防止了回溯和数据篡改。让我们使用 Python 实现一个最小的区块链。下面是我如何构建一个最小的区块链，代码可以在 GitHub 上找到。</p><p id="98a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这是区块链的最小实现，所以在任何分布式网络上都没有算法或工作证明。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="75b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">散列法</h1><p id="7d56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们想要一个可以代表一个数据块的“键”。我们想要一个很难伪造或暴力破解的密钥，但是很容易验证。这就是哈希的用武之地。散列是满足以下性质的函数 H(x ):</p><ul class=""><li id="e12c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">相同的输入<code class="fe ni nj nk nl b">x</code>总是产生相同的输出<code class="fe ni nj nk nl b">H(x)</code>。</li><li id="941f" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">不同(甚至相似)的输入<code class="fe ni nj nk nl b">x</code>应该产生<strong class="lb iu"> <em class="nr">完全</em> </strong>不同的输出<code class="fe ni nj nk nl b">H(x)</code>。</li><li id="6c2d" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">从输入<code class="fe ni nj nk nl b">x</code>中获得<code class="fe ni nj nk nl b">H(x)</code>在计算上很容易，但要逆转这个过程却很难，即从已知散列<code class="fe ni nj nk nl b">H</code>中获得输入<code class="fe ni nj nk nl b">x</code>。</li></ul><p id="3794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是谷歌如何存储你的“密码”，而不是实际存储你的密码。他们存储你的密码散列<code class="fe ni nj nk nl b">H(password)</code>，这样他们可以通过散列你的输入和比较来验证你的密码。没有进入太多的细节，我们将使用 SHA-256 算法散列我们的块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/0b7939f30ac14e624004dc0a67ca2bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4IHXhBPRlW0P_FJm"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@cmdrshane?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">CMDR Shane</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="93ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最小块</h1><p id="44a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们来做一个名为<code class="fe ni nj nk nl b">MinimalBlock()</code>的对象类。它是通过提供一个<code class="fe ni nj nk nl b">index</code>、一个<code class="fe ni nj nk nl b">timestamp</code>、一些你想要存储的<code class="fe ni nj nk nl b">data</code>和一个叫做<code class="fe ni nj nk nl b">previous_hash</code>的东西来初始化的。前一个哈希是前一个块的哈希(键)，它充当指针，这样我们就知道哪个块是前一个块，从而知道块是如何连接的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a31b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，<code class="fe ni nj nk nl b">Block[x]</code>包含索引<code class="fe ni nj nk nl b">x</code>、时间戳、一些数据和前一个块 x-1 <code class="fe ni nj nk nl b">H(Block[x-1])</code>的散列。现在这个块已经完成了，它可以被散列以生成<code class="fe ni nj nk nl b">H(Block[x])</code>作为下一个块中的指针。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/77e4e3d0430d88d10e9a6494bd42b21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cxxC3ar56CFF_fm5"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@mraidenmarples?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aiden Marples</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a7ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最小链</h1><p id="3b27" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">区块链本质上是一个区块链，通过存储前一个区块的哈希来建立连接。因此，可以使用 Python 列表实现一个链，而<code class="fe ni nj nk nl b">blocks[i]</code>表示第{ i }个块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们初始化一个链时，我们用函数<code class="fe ni nj nk nl b">get_genesis_block()</code>自动分配一个第 0 块(也称为 Genesis 块)给这个链。这一块标志着你的链的开始。注意<code class="fe ni nj nk nl b">previous_hash</code>在创世纪块中是任意的。添加块可以通过调用<code class="fe ni nj nk nl b">add_block()</code>来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2f4106c458a96a1d202bc442acc8bd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xJGcR83qhDg_28KN"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@rusticvegan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rustic Vegan</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b1cd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据验证</h1><p id="b547" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据完整性对数据库非常重要，区块链提供了一种验证所有数据的简单方法。在函数<code class="fe ni nj nk nl b">verify()</code>中，我们检查以下内容:</p><ul class=""><li id="df11" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">blocks[i]</code>中的索引是<code class="fe ni nj nk nl b">i</code>，因此没有丢失或额外的块。</li><li id="05d4" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">计算块哈希<code class="fe ni nj nk nl b">H(blocks[i])</code>，并与记录的哈希进行交叉检查。即使块中的单个位被改变，计算出的块散列也会完全不同。</li><li id="ee20" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">验证<code class="fe ni nj nk nl b">H(blocks[i])</code>是否正确存储在下一个程序块的<code class="fe ni nj nk nl b">previous_hash</code>中。</li><li id="f3ee" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">通过查看时间戳来检查是否有回溯。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4771" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分支</h1><p id="123e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在某些情况下，您可能想从一个链中分支出来。这被称为分叉，如代码中的<code class="fe ni nj nk nl b">fork()</code>所示。你可以复制一个链(或者链的根),然后分道扬镳。在 Python 中使用<code class="fe ni nj nk nl b">deepcopy()</code>至关重要，因为 Python 列表是可变的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/69e173bc7b87e69c5fe9421b16742ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hn46EX9Mf0FrfdK3"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@elcarito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">elCarito</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe51" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外卖</h1><p id="afee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对一个块进行哈希运算会创建一个块的唯一标识符，并且一个块的哈希构成下一个块的一部分，以在块之间建立链接。只有相同的数据才会创建相同的哈希。</p><p id="28e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想修改第三个块中的数据，第三个块的散列值会改变，第四个块中的<code class="fe ni nj nk nl b">previous_hash</code>也需要改变。<code class="fe ni nj nk nl b">previous_hash</code>是第 4 个块的一部分，因此它的散列也会改变，依此类推。</p><h2 id="d176" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">相关文章</h2><p id="13cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您的阅读！如果您对 Python 感兴趣，请查看以下文章:</p><div class="ok ol gp gr om on"><a rel="noopener follow" target="_blank" href="/5-python-features-i-wish-i-had-known-earlier-bc16e4a13bf4"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">我希望我能早点知道的 5 个 Python 特性</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">超越 lambda、map 和 filter 的 Python 技巧</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener follow" target="_blank" href="/visualizing-bike-mobility-in-london-using-interactive-maps-for-absolute-beginners-3b9f55ccb59"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">使用交互式地图和动画可视化伦敦的自行车移动性</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">探索 Python 中的数据可视化工具</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div><p id="e5d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">最初发布于</em><a class="ae ky" href="https://edenau.github.io" rel="noopener ugc nofollow" target="_blank"><em class="nr">edenau . github . io</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>