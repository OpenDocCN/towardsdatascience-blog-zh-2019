<html>
<head>
<title>More Uncommon Data Cleaners for your Machine or Deep Learning Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的机器或深度学习项目提供更多不常见的数据清理器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-2-more-uncommon-data-cleaners-for-your-machine-or-deep-learning-project-b30f862b2d81?source=collection_archive---------17-----------------------#2019-12-14">https://towardsdatascience.com/part-2-more-uncommon-data-cleaners-for-your-machine-or-deep-learning-project-b30f862b2d81?source=collection_archive---------17-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d9c2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">帕索项目</h2><div class=""/><div class=""><h2 id="b7a4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我将介绍类型和格式转换数据清理器。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b9eabffb8593a21734addf72fb384370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xt3zZ-SBGTGlVU0PJT5RwQ.jpeg"/></div></div></figure><p id="4d01" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">几乎所有的<strong class="lf jd"> paso </strong>，包括这里讨论的所有函数，都要求<strong class="lf jd"> paso </strong>数据清理步骤(如删除空值和 NA 值)已经完成。</p><p id="1e48" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些数据清理器在以下文章中有详细介绍:</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/uncommon-data-cleaners-for-your-real-world-machine-or-deep-learning-project-f926d8ecb258"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd jd gy z fp mh fr fs mi fu fw jc bi translated">用于真实世界机器或深度学习项目的不寻常的数据清理器</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">介绍</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq lb mc"/></div></div></a></div><h1 id="b8f8" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">背景故事</h1><p id="8a5e" class="pw-post-body-paragraph ld le it lf b lg nj kd li lj nk kg ll lm nl lo lp lq nm ls lt lu nn lw lx ly im bi translated">在我们以前的项目中，我们发现自己大部分时间都在用非常相似或略有不同的数据清理器清理数据。</p><p id="2a0e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在第一个项目中，我们在数据清理开发上花费了大量时间。以至于在第二个项目开始时，项目管理将数据清理分为三类:相同、差异小于 33%和差异大于 33%。</p><p id="79d3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些类别定义了两个重要原因:</p><ul class=""><li id="ba8f" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated">作为一个团队，随着数据清理器需求的确定，我们能够消除大量的“<em class="nx">重新编码车轮”</em>，并向我们的数据清理器包添加超过 33%的不同类别。</li><li id="ccfa" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">我们的开发时间估计变得更加精确。</li></ul><p id="a717" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">两年半之后，我们开始了第八个项目，并且发现，到目前为止，不到十分之一的数据清理器属于第三类，即花费开发人员更多时间的类别。更重要的是，我们从开发到生产的时间是前两个项目的一半。我们现在可以将大部分时间花在寻找足够好的机器学习(有时是深度学习)解决方案上。</p><p id="4c59" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您的体验可能会有所不同，因为我目前的领域是用于资产配置、平衡和风险的固定收益金融数据。(好吧，是的，一些我在这里不会提到或使用的其他晦涩的东西。)</p><p id="9068" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在你可能会问我为什么要讲这个故事。因为随着我们沿着这条路走下去，我从一个机器学习科学家进化成了一个软件架构师和软件工程师。</p><p id="484d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我现在负责修复一个生产服务，并完成最初的架构设计工作和代码开发。我喜欢从开发到生产。有时我会写下并分享我们的一些成就。</p><p id="f91e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我真诚地希望你能使用我们的一些工作。这里使用的函数的所有代码都可以在<a class="ae od" href="https://github.com/bcottman/paso/toutil.py" rel="noopener ugc nofollow" target="_blank">https://github.com/bcottman/paso/toutil.py</a>找到。</p><h1 id="e70d" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">故事已经够多了。你能做什么？给我看看！</h1><p id="bdf3" class="pw-post-body-paragraph ld le it lf b lg nj kd li lj nk kg ll lm nl lo lp lq nm ls lt lu nn lw lx ly im bi translated">使用不同组合的清洗策略(管道)是<strong class="lf jd"> paso </strong>的一个重要目标。</p><p id="aec6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">讨论将分为以下几个主要部分:</p><ul class=""><li id="bc01" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated">首先，我们创建可以改变的数据集。</li><li id="4adf" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">接下来，通过对创建的数据集进行操作来演示每个清理器。</li><li id="158a" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">然后我们展示了一个与管道很好地混合的调用功能:链接掉<strong class="lf jd"> pandas </strong> DataFrame 实例。这是我们熟悉的<strong class="lf jd"> R </strong>开发模式。我们发现编码 paso 链比编码 sklearn 管道要容易得多。我们甚至认为链式管道比传统管道更容易检查和理解。</li><li id="ec76" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">最后，我们总结一下<strong class="lf jd"> paso 的</strong>数据清理器，以及我们对未来文章和<strong class="lf jd"> paso </strong>版本的计划。</li></ul><p id="0654" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本课的代码在<a class="ae od" href="https://github.com/bcottman/paso/blob/master/lessons/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae od" href="https://github.com/bcottman/paso/blob/master/paso/pre/toutil.py" rel="noopener ugc nofollow" target="_blank">这里</a>文件中给出。获得整个<strong class="lf jd"> paso </strong>包的最好方法是<em class="nx"> git 克隆</em>base。<code class="fe oe of og oh b">pip</code>将不起作用，因为此包中有您需要的基于文本的文件(描述)。</p><h1 id="d1eb" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">目标实用程序:目标数据框架</h1><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="a425" class="om ms it oh b gy on oo l op oq">paso.pre.toutil.toDataFrame(X: pd.DataFrame,<br/>    columns: List = None, <br/>    inplace: bool = True, <br/>    verbose: bool = True) <br/>    -&gt; pd.DataFrame:<br/><br/>Parameters:<br/>    X: DataFrame<br/>        Attempt to convert python datatype argument into <br/>        pandas dataframe.<br/><br/>    columns:     <br/>        The column names to  be used for new DataFrame. <br/>        If a number of column names given is less than a number <br/>        of column names needed, then they will be generared <br/>        as c_0...c_(n-1), where n is the number of missing<br/>        column names.<br/><br/>    verbose: default: True) Logging is on.<br/><br/>    Returns: DataFrame</span></pre><p id="ba61" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该功能基于<code class="fe oe of og oh b">willmcginnis's convert_input()</code>。</p><p id="4863" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">paso 是一个包，其中所有的功能和方法都需要一个数据框架。</p><p id="03ac" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">由于<strong class="lf jd"> paso </strong>函数和方法只消耗<strong class="lf jd"> pandas </strong>数据帧，我们需要一个函数来转换各种 python 数据类型，同时还提供<strong class="lf jd"> paso 的</strong>基本服务。这个功能就是<code class="fe oe of og oh b">paso.to_util.toDataFrame</code>。</p><p id="9ed4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此函数是"<strong class="lf jd"> paso </strong> <em class="nx">规则的例外。第一个参数是 DataFrame </em>"规则，因为它将一维或二维列表、元组、csr_matrix、numpy 数组或 1d <strong class="lf jd"> pandas </strong>系列转换为<strong class="lf jd"> pandas </strong> DataFrame。</p><p id="94be" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你也有<code class="fe oe of og oh b">paso.to_util.isDataFrame(X) -&gt; bool</code>来检查对象是否是一个<code class="fe oe of og oh b">pandas.DataFrame</code>。</p><p id="0f3d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果不需要<strong class="lf jd"> paso 的</strong>服务，比如日志记录和缓存，可以使用方法<code class="fe oe of og oh b">pandas.DataFrame</code>。我建议你<em class="nx">不要这样做</em>，但是你可以选择这样做。</p><p id="3b8d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一个好的做法是在管道的开始制作类型为<code class="fe oe of og oh b">DataFrame</code>的数据集。由<strong class="lf jd"> paso </strong>函数所做的更改将被保存在 DataFrame 实例的状态中(<code class="fe oe of og oh b">inplace=True</code>)。在您的实验运行的整个管道中，就地将会发生，以最大化完成速度和最小化内存使用。</p><p id="88e2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您需要引用原始数据帧，那么您可以执行类似以下操作:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="4e06" class="om ms it oh b gy on oo l op oq">&lt;dataset_name&gt;_original = &lt;dataset_name&gt;.copy()</span></pre><p id="ef58" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是，系统会警告您，保留原件会消耗一些电脑内存。</p><p id="63dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">由您决定是否保留原始数据集的副本。</p><p id="56c2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">几乎总是从本地文件或通过 URL 寻址的非本地文件输入原件，因此，您可能不需要在计算机内存中保留副本。</p><p id="cd75" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以通过以下方式查看任何对象的大小(以字节为单位):</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="8244" class="om ms it oh b gy on oo l op oq">from sys import getsizeof<br/>getsizeof(pd.DataFrame())</span><span id="c915" class="om ms it oh b gy or oo l op oq">=&gt; 24</span></pre><p id="862d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这表明空数据帧的大小为 24 字节。</p><h1 id="d387" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">创建一个我们可以使用的数据集</h1><p id="cef0" class="pw-post-body-paragraph ld le it lf b lg nj kd li lj nk kg ll lm nl lo lp lq nm ls lt lu nn lw lx ly im bi translated">现在，我们创建一个人工数据集<code class="fe oe of og oh b">df_of_ints</code>，一个由<code class="fe oe of og oh b">int</code>组成的数组</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="c1cf" class="om ms it oh b gy on oo l op oq">from paso.base import raise_PasoError  <br/>from paso.pre.toutil import toDataFrame<br/>arr = np.ndarray(shape=(1000000,6), dtype=int, order='F')<br/>df_of_ints = toDataFrame(arr)</span></pre><p id="01a3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="8338" class="om ms it oh b gy on oo l op oq">2019-12-12 13:29:08.164 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with <br/>column names: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre><p id="d093" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe oe of og oh b">toDataFrame(arr, columns=['a','b']) </code>可以为新的 DataFrame 指定前两个列名。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="33dd" class="om ms it oh b gy on oo l op oq">df_of_ints = toDataFrame(arr, columns=['a','b'])<br/>df_of_ints.shape</span></pre><p id="27e2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="a512" class="om ms it oh b gy on oo l op oq">2019-12-12 13:29:22.981 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with <br/>column names: Index(['a', 'b', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre><p id="e900" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="2725" class="om ms it oh b gy on oo l op oq">(1000000, 6)</span></pre><p id="eaad" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，前两个列名是如何给出的，<code class="fe oe of og oh b">toDataFrame</code>检测到这一点，并创建了所需的接下来的四个列名。</p><p id="3870" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这次我们调用<code class="fe oe of og oh b">toDataFrame</code>，同时保持<strong class="lf jd"> paso </strong>注销。只有在调用的函数范围内，日志记录才会被关闭。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="3e0f" class="om ms it oh b gy on oo l op oq">df_of_ints = toDataFrame(arr, columns=['X','yyyyyy'],verbose=False)<br/>df_of_ints.columns</span></pre><p id="ef16" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="280a" class="om ms it oh b gy on oo l op oq">Index(['X', 'yyyyyy', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre><h1 id="2881" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">to _ util:to 类别</h1><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="b178" class="om ms it oh b gy on oo l op oq">paso.pre.toutil.toCategory(<br/>    X: pd.DataFrame,<br/>    bool_: bool = True,<br/>    int_: bool = True,<br/>    object_: str = True,<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:<br/><br/>Parameters:<br/>    X: dataFrame<br/><br/>    bool_: default: True - convert to category type.<br/><br/>    int_: default: True - convert to category type.<br/><br/>    object_: default: True - convert to category type.<br/><br/>    inplace: default:<br/>        True - change DataFrame arg "in-place"<br/>        False:  return new resulting DataFrame<br/><br/>    verbose: default: True - Logging is on.<br/><br/>Returns: resulting DataFrame</span></pre><p id="d1a3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该函数将一个<strong class="lf jd"> pandas </strong> DataFrame 实例的任何布尔值、对象值或整数值转换为类别类型值。</p><p id="f3d8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例外情况是连续(浮点或日期时间)值，它返回未转换的值。</p><p id="af1e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果要将连续或日期时间类型转换为类别，则在<strong class="lf jd"> paso </strong> toCategory 之前使用 ContinuoustoCategory 或 DatetimetoComponents。</p><p id="1c5a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注:<strong class="lf jd"> paso </strong>数据清理步骤(如删除空值和 NA 值)已在此步骤之前完成。</p><p id="d408" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe oe of og oh b">datetime</code>特征应在此步骤之前调用<code class="fe oe of og oh b">toDatetimeComponents()</code>，以便<code class="fe oe of og oh b">datetime</code>组件(类型为<code class="fe oe of og oh b">int</code>)转换为<code class="fe oe of og oh b">category</code>。</p><p id="2a2a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该步骤的行为不是将<code class="fe oe of og oh b">datetime</code>转换为<code class="fe oe of og oh b">category</code>。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="4113" class="om ms it oh b gy on oo l op oq">from paso.base import raise_PasoError  <br/>from paso.pre.toutil import toCategory<br/>df_cat = toCategory(df_of_ints,inplace=False)</span></pre><p id="fd75" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="ac2b" class="om ms it oh b gy on oo l op oq">2019-12-12 13:36:58.748 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : X<br/>2019-12-12 13:36:58.768 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : yyyyyy<br/>2019-12-12 13:36:58.786 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_2<br/>2019-12-12 13:36:58.802 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_3<br/>2019-12-12 13:36:58.814 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_4<br/>2019-12-12 13:36:58.824 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_5</span></pre><p id="6258" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">看起来<code class="fe oe of og oh b">df_of_ints</code>没变，这就是我们在本例中想要的，<code class="fe oe of og oh b">inplace=False</code>。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="ae9b" class="om ms it oh b gy on oo l op oq">df_of_ints.dtypes</span></pre><p id="6926" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="3368" class="om ms it oh b gy on oo l op oq">X         int64<br/>yyyyyy    int64<br/>c_2       int64<br/>c_3       int64<br/>c_4       int64<br/>c_5       int64<br/>dtype: object</span></pre><p id="83d5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在看来，<code class="fe oe of og oh b">df_of_ints</code>的所有值都是从类型<code class="fe oe of og oh b">int</code>转换为类型<code class="fe oe of og oh b">category</code>并带有<code class="fe oe of og oh b"> inplace=True</code>。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="c00f" class="om ms it oh b gy on oo l op oq">df_of_ints.toCategory(inplace=True)<br/>df_of_ints.dtypes</span></pre><p id="debe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="84fb" class="om ms it oh b gy on oo l op oq">2019-12-12 09:39:37.193 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : X<br/>2019-12-12 09:39:37.214 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : yyyyyy<br/>2019-12-12 09:39:37.233 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_2<br/>2019-12-12 09:39:37.251 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_3<br/>2019-12-12 09:39:37.269 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_4<br/>2019-12-12 09:39:37.282 | INFO     | paso.pre.toutil:toCategory:197 - toCategory integer feature converted : c_5</span></pre><p id="84d4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="cf5c" class="om ms it oh b gy on oo l op oq">X         category<br/>yyyyyy    category<br/>c_2       category<br/>c_3       category<br/>c_4       category<br/>c_5       category<br/>dtype: object</span></pre><h1 id="f1a5" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">链接</h1><p id="01de" class="pw-post-body-paragraph ld le it lf b lg nj kd li lj nk kg ll lm nl lo lp lq nm ls lt lu nn lw lx ly im bi translated">我猜有些读者(不是你)对<code class="fe oe of og oh b">df_of_ints.toCategory(inplace=True)</code>有点困扰。如果是这样的话，你会更加为此烦恼:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="fb3b" class="om ms it oh b gy on oo l op oq">toDataFrame(arr, columns=['a','b']).toCategory(verbose=False).dtypes</span></pre><p id="3606" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="b0a9" class="om ms it oh b gy on oo l op oq">2019-12-12 09:39:37.359 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with column names: Index(['a', 'b', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre><p id="dea2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="8a32" class="om ms it oh b gy on oo l op oq">a      category<br/>b      category<br/>c_2    category<br/>c_3    category<br/>c_4    category<br/>c_5    category<br/>dtype: object</span></pre><p id="f301" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您对这种大惊小怪不感到困扰甚至困惑，那是因为您知道 DataFrame 可以是一个<code class="fe oe of og oh b">python</code>类实例，并且您在一个类实例上调用方法。你甚至可以<em class="nx">链</em>方法。也就是说，你可以一个接一个地调用方法。</p><p id="0166" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这种情况下，我<em class="nx">链接了<code class="fe oe of og oh b">toDataFrame</code>输出的 DataFame 实例的两个方法<code class="fe oe of og oh b">.toCategory().dtypes</code>。</em></p><p id="c55d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> paso </strong>的<code class="fe oe of og oh b">Cleaners</code>类和<code class="fe oe of og oh b">toutils</code>函数的所有方法都要求第一个参数是 DataFrame 实例。Dataframe 作为第一个参数，通过使用基于包<strong class="lf jd"> pandas-flavor </strong>的重构装饰器，使它们成为 DataFrame 的方法。</p><p id="a884" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">链接可以使它非常容易理解，因为操作是从左到右调用的。这和你阅读(英语和许多其他语言)的方式是一样的。</p><p id="c7a0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有些人更喜欢链而不是使用<strong class="lf jd"> sklearn 的管道</strong>。你会注意到我们的链接在语法上与 sklearn 的管道链接略有不同。</p><p id="34e2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的链接非常接近<code class="fe oe of og oh b">R</code>的外观。从现在开始，我们将使用这两种调用方法。</p><h1 id="f09a" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">to_util: toContinuousCategory</h1><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="16d0" class="om ms it oh b gy on oo l op oq">def toContinuousCategory(<br/>        X: pd.DataFrame,<br/>        features:List=[],<br/>        drop: bool = True,<br/>        inplace: bool = True,<br/>        verbose: bool = True,<br/>        integer: bool = True,<br/>        floaty: bool = True,<br/>        quantile: bool = True,<br/>        nbin: int = 10,<br/>    ) -&gt; pd.DataFrame:<br/>    <br/>    Parameters:<br/>        X:pd.DataFrame</span><span id="d299" class="om ms it oh b gy or oo l op oq">drop: default:True<br/>            do not keep original features.</span><span id="2033" class="om ms it oh b gy or oo l op oq">integer: default:True<br/>            set integer=False if not continuous and not to <br/>            transform into category.</span><span id="0e81" class="om ms it oh b gy or oo l op oq">floaty: default:True<br/>            set floaty=False if not continuous and not to <br/>            transform into category.</span><span id="289b" class="om ms it oh b gy or oo l op oq">quantile: default: True<br/>            use quantile bin.<br/>            Quantile is similar to v/(maxy-miny), works on any scale.<br/>            False, use fixed-width bin. miny,maxy arguments are ignored.</span><span id="75aa" class="om ms it oh b gy or oo l op oq">nbin:int (default: 10)</span><span id="f6a2" class="om ms it oh b gy or oo l op oq">Returns: DataFrame</span><span id="32f4" class="om ms it oh b gy or oo l op oq">Raises:<br/>        TypeError('"ContinuoustoCategory:inplace: requires boolean type.")</span></pre><h1 id="773e" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">util:today time components</h1><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="df82" class="om ms it oh b gy on oo l op oq">paso.pre.toutil.toDatetimeComponents(<br/>    X: pd.DataFrame,<br/>    drop: bool = True,<br/>    components: list = [],<br/>    prefix: bool = True,<br/>    inplace: bool = True,<br/>    verbose: bool = True) -&gt; pd.DataFrame:<br/><br/>Parameters:<br/><br/>    X: DataFrame<br/><br/>    drop: default: True<br/>        If True then the datetime feature/column will be removed.<br/><br/>    components:: default: []<br/>        list of column(feature) names for which datetime components<br/>        are created.<br/><br/>    prefix: default: True<br/>        If True then the feature will be the prefix of the <br/>        created datetime component features. The postfix will be<br/>       _&lt;component&gt; to create the new feature column<br/>        &lt;feature&gt;_&lt;component&gt;.<br/><br/>        if False only first _PREFIX_LENGTH_ characters of feature<br/>        string will be used to create the new feature<br/>        name/column&lt;featurename[0:_PREFIX_LENGTH_]&gt;_&lt;component&gt;.<br/><br/>    components:list default:<br/>        ['Year', 'Month', 'Week', 'Day','Dayofweek'<br/>        , 'Dayofyear','Elapsed','Is_month_end'<br/>        , 'Is_month_start', 'Is_quarter_end'<br/>        , 'Is_quarter_start', 'Is_year_end', 'Is_year_start']<br/><br/>        or set components to one or component names in a list<br/>        Must be components names from default list.<br/><br/>    inplace: default: True<br/>        True: change DataFrame arg in-place"<br/><br/>        False: return new resulting dataframe<br/><br/>    verbose: default: True Logging is on.<br/><br/><br/>Returns:DataFrame<br/>        toDatetimeComponents transformed into datetime<br/>        feature components.</span></pre><p id="7e28" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为什么要将一个日期时间分解成单位成分？这导致了一种高级的编码策略，在论文<a class="ae od" href="https://`arxiv.org/pdf/1604.06737.pdf" rel="noopener ugc nofollow" target="_blank">分类变量的实体嵌入</a>中有详细的讨论</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/understanding-entity-embeddings-and-its-application-69e37ae1501d"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd jd gy z fp mh fr fs mi fu fw jc bi translated">理解实体嵌入及其应用</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">最近，在被指派研究一个预测问题后，我读了很多关于实体嵌入的文章。</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="os l mn mo mp ml mq lb mc"/></div></div></a></div><p id="aaf4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">以下条款指出:</p><blockquote class="ot"><p id="4439" class="ou ov it bd ow ox oy oz pa pb pc ly dk translated"><code class="fe oe of og oh b">"Categorical variables are known to hide and mask lots of interesting information in a data set and many times they might even be the most important variables in a model. A good data scientist should be capable of handling such variables effectively and efficiently. If you are a smart data scientist, you’d hunt down the categorical variables in the data set, and dig out as much information as you can."</code></p></blockquote><p id="d330" class="pw-post-body-paragraph ld le it lf b lg pd kd li lj pe kg ll lm pf lo lp lq pg ls lt lu ph lw lx ly im bi translated">出于多种原因，所有这些都会产生更好的预测能力，您可以将一个<code class="fe oe of og oh b">datetime</code>分解成<code class="fe oe of og oh b">int</code>个组件。您可以更进一步，将<code class="fe oe of og oh b">datetime</code> <code class="fe oe of og oh b">int</code>组件转换成分类类型的组件。</p><p id="cce5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可能已经明白这是怎么回事了。如果我有一些非分类特征，比如一列<code class="fe oe of og oh b">datetimes</code>，我将需要一个函数把日期时间转换成分类特征。</p><p id="e770" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我将在下一篇文章中介绍如何使用分类特征作为嵌入向量。</p><p id="a7d1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以通过<code class="fe oe of og oh b">datetimeComponents</code>查看哪些日期时间组件可用。我们的版本基于<strong class="lf jd"> fast.ai </strong>包中的一个函数。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="c1c7" class="om ms it oh b gy on oo l op oq">from paso.pre.toutil import datetimeComponents<br/>datetimeComponents()</span></pre><p id="b1c4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="3a65" class="om ms it oh b gy on oo l op oq">['Year',<br/> 'Month',<br/> 'Week',<br/> 'Day',<br/> 'Dayofweek',<br/> 'Dayofyear',<br/> 'Elapsed',<br/> 'Is_month_end',<br/> 'Is_month_start',<br/> 'Is_quarter_end',<br/> 'Is_quarter_start',<br/> 'Is_year_end',<br/> 'Is_year_start']</span></pre><p id="ad82" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我首先创建一个 DataFrame 实例来展示<code class="fe oe of og oh b">toDatetimeComponents</code>的功能。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="c303" class="om ms it oh b gy on oo l op oq">from datetime import datetime, timedelta</span><span id="6455" class="om ms it oh b gy or oo l op oq">rc = 94598; cc = 1; acc =13<br/>darr = np.arange(datetime(1751,7,1),<br/>                 datetime(2010,7,1),<br/>                 timedelta(days=1)).reshape(rc,cc)<br/>from paso.pre.toutil import toDatetimeComponents<br/>toDataFrame(darr,columns = []).toDatetimeComponents(inplace=False).head(2)</span></pre><p id="3677" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="5dc7" class="om ms it oh b gy on oo l op oq">2019-12-12 09:39:37.601 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with column names: Index(['c_0'], dtype='object')<br/>2019-12-12 09:39:37.609 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Year<br/>2019-12-12 09:39:37.614 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Month<br/>2019-12-12 09:39:37.621 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Week<br/>2019-12-12 09:39:37.627 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Day<br/>2019-12-12 09:39:37.633 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Dayofweek<br/>2019-12-12 09:39:37.640 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Dayofyear<br/>2019-12-12 09:39:37.794 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Elapsed<br/>2019-12-12 09:39:37.800 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Is_month_end<br/>2019-12-12 09:39:37.805 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Is_month_start<br/>2019-12-12 09:39:37.812 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Is_quarter_end<br/>2019-12-12 09:39:37.816 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Is_quarter_start<br/>2019-12-12 09:39:37.822 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Is_year_end<br/>2019-12-12 09:39:37.828 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: c_0_Is_year_start<br/>2019-12-12 09:39:37.837 | INFO     | paso.pre.toutil:toDatetimeComponents:351 - datetime feature dropped: c_0</span></pre><p id="ec05" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/fb430e05cab27c6819cbc1256c041715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCZmjR8D6H2aeCfpvCS5Uw.png"/></div></div><figcaption class="pj pk gj gh gi pl pm bd b be z dk">Resulting DataFrame from toDatetimeComponents</figcaption></figure><p id="08a7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这种情况下，<code class="fe oe of og oh b">datetimeComponents</code>将每个日期时间值转换成十三个<code class="fe oe of og oh b">int</code>组件。然后它将这些<code class="fe oe of og oh b">int</code>类型转换成<code class="fe oe of og oh b">category</code>类型。</p><p id="70e6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果 X[[dt_features]]不是日期时间类型(如<code class="fe oe of og oh b">object</code>类型)，那么<strong class="lf jd">不会试图将 X[[dt_features]]强制转换为<code class="fe oe of og oh b">datetime</code>类型。</strong></p><p id="359f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最好将原始数据字段作为<code class="fe oe of og oh b">datetime</code>而不是<code class="fe oe of og oh b">object</code>读取/输入。您可以使用以下方法将 dataframe 列转换为 datetime:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="21c2" class="om ms it oh b gy on oo l op oq">X[feature] = pd.datetime(X[feature])</span></pre><p id="10bc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以进行自动转换，但是我们发现对于一些较大的数据集(&gt; 1 亿行)，转换速度太慢。使用数据帧列作为<code class="fe oe of og oh b">datetime</code>而不是<code class="fe oe of og oh b">object</code>来启动管道要快得多。</p><h1 id="8ac2" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">toutil: toContinuousCategory</h1><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="b206" class="om ms it oh b gy on oo l op oq">paso.pre.toutil.<!-- -->toContinuousCategory(<br/>    oX: pd.DataFrame,<br/>    features: list = [],<br/>    drop: bool = True,<br/>    int_: bool = True,<br/>    float_: bool = True,<br/>    quantile: bool = True,<br/>    nbin: int = 10,<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:</span><span id="e96f" class="om ms it oh b gy or oo l op oq"><em class="nx">Parameters:<br/>    X: dataset<br/><br/>Keywords:<br/><br/>    features:  default: []<br/>        The column  names to  be transform from continuous<br/>        to category.<br/><br/>    drop: default: True)<br/>        If True then the datetime feature/column will be removed.<br/><br/>    int_: Default: True<br/>        set integer=False if not continuous and not to <br/>        transform into category.<br/><br/>    float_: Default: True<br/>        set floaty=False if not continuous and not to transform<br/>        into category.</em></span><span id="c94e" class="om ms it oh b gy or oo l op oq"><em class="nx"><br/>    quantile: Default: True use quantile bin.<br/>        quantile is simular to v/(maxy-miny), works on any scale.<br/>        False, use fixed-width bin. miny,maxy arguments are ignored.<br/><br/>    nbin: default: 10<br/>        Alternately ``nbins`` can be integer for number of bins.<br/>        Or it can be array of quantiles, e.g. [0, .25, .5, .75, 1.]<br/>        or array of fixed-width bin boundaries i.e. [0., 4., 10., 100].<br/><br/>    verbose: Default True<br/>        True: output<br/>        False: silent<br/><br/>    inplace: Default: True<br/>        True: replace 1st argument with resulting dataframe<br/>        False:  (boolean)change unplace the dataframe X<br/><br/>Returns: pd.DataFrame<br/><br/>Raises:<br/>        TypeError('" requires boolean type.")</em></span></pre><p id="a335" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe oe of og oh b">toContinuousCategory</code>将任何连续的浮点数，或<strong class="lf jd"> pandas </strong> DataFrame 的整数值分组到 bin 中，转换为类别值。</p><p id="0ba5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">宁滨，也称为量化，用于将连续的数字特征(<code class="fe oe of og oh b">np.number</code>类型)转换为<code class="fe oe of og oh b">category</code>类型。</p><p id="b4d8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个容器代表一系列连续的数值。</p><p id="6730" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">宁滨数据的具体策略有固定宽度(<code class="fe oe of og oh b">quantile=False</code>)和自适应宁滨(<code class="fe oe of og oh b">quantile = True</code>)。</p><p id="ba7d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">无论输入数据集的类型如何，它都将作为<code class="fe oe of og oh b">DataFrame</code>返回。如果要设置功能名称，在此功能之前调用<code class="fe oe of og oh b">toDataFrame</code>。</p><p id="6d4e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">固定宽度的宁滨只对基于树的模型的数据集有效，<em class="nx">没有缩放</em>，例如<strong class="lf jd"> random forest、xgboost、lightgbm、catboost </strong>等。非树基模型，如线性、对数、<strong class="lf jd"/>、神经网络等。，不会正确工作，因为它们依赖于值的大小。</p><p id="492d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">线性宁滨的统计问题。</strong></p><p id="2974" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">宁滨增加 I 型和 II 型误差；(简单的证明是，随着箱数趋近于无穷大，那么信息损失趋近于零)。此外，改变容器数量将改变容器分布形状，除非分布均匀<em class="nx">平坦</em>。</p><p id="ff57" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">分位数宁滨与单一数据集一起使用。</strong></p><p id="df6f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你有一个训练和测试数据集，基于百分位数(<em class="nx">分位数</em>)将连续特征转换成类别特征是<em class="nx">错误的</em>。分位数基于数据集，除非每个数据集的分布形状相同，否则分位数会有所不同。在极限中，只有两个箱，然后几乎没有关系可以建模。我们主要是在做 t 检验。</p><p id="6a99" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">如果特征之间存在非线性甚至非单调关系</strong></p><p id="d325" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你需要线性宁滨，而不是分位数，使用<code class="fe oe of og oh b">quantile=False</code>。</p><p id="b5a0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">如果你想要分位数——宁滨。</strong></p><p id="e10f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尽管有上述警告，您的用例可能需要分位数宁滨。<br/>在这种情况下，将分位数宁滨应用于合并的训练和测试数据集，然后再将它们分开。</p><p id="167b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">基于分位数的宁滨是用于自适应宁滨的一个相当好的策略。分位数是将要素的连续值分布划分为离散的连续箱或区间的特定值或分界点。因此，q-分位数将数值属性划分为 q 个相等(百分比-宽度)的分区。</p><p id="ae4e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些箱变成分类特征。你可能想这样做的年龄，体重，温度，工资，价格等特征..</p><p id="83b8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">分位数的众所周知的例子包括 2 分位数，中位数，将数据分布分为两个相等(百分比宽度)的二进制数，4 分位数，标准四分位数，四个相等的二进制数(百分比宽度)和 10 分位数，十分位数，十个相等宽度(百分比宽度)的二进制数。</p><p id="b373" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您应该注意到，新要素是由分位数宁滨附加 q 产生的，而新要素是由固定宽度宁滨附加 w 产生的</p><p id="bcec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">将连续浮动功能转换为类别并删除原始列:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="0eb4" class="om ms it oh b gy on oo l op oq">from paso.pre.toutil import toContinuousCategory<br/>nc = 6<br/>nr = 1000000<br/>delta = 0.1<br/>farr = np.arange(0,(nr*delta*nc),delta, dtype=float).reshape(nr,nc)<br/>toDataFrame(farr).toContinuousCategory(drop=True).head(n=2)</span></pre><p id="2dd7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="7cf2" class="om ms it oh b gy on oo l op oq">2019-12-12 15:27:27.638 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with <br/>column names: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')<br/>2019-12-12 15:27:28.204 | INFO     | paso.pre.toutil:toContinuousCategory:533 - toContinuousCategory features:: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre><p id="d840" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/5886cd53425deb446162b5142be57ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGWyL3MhULeSyUjwT0syJw.png"/></div></div></figure><p id="12da" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">将连续浮动要素转换为固定宽度的类别箱，并保留原始列。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="3b4a" class="om ms it oh b gy on oo l op oq">toDataFrame(farr).toContinuousCategory(quantile=False,nbin=3,drop=False)\<br/>.head(n=2)</span></pre><p id="895a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="41d1" class="om ms it oh b gy on oo l op oq">2019-12-12 09:39:38.578 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with column names: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')<br/>2019-12-12 09:39:38.896 | INFO     | paso.pre.toutil:toContinuousCategory:533 - toContinuousCategory features:: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre><p id="2b97" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/a034f5def87854f7b3088f64b6ae333e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5kapOM2KH813-pM1ERlSA.png"/></div></div><figcaption class="pj pk gj gh gi pl pm bd b be z dk">DataFrame resulting in quantile binning</figcaption></figure><h1 id="4641" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">toutil: toColumnNamesFixedLen</h1><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="a218" class="om ms it oh b gy on oo l op oq">def toColumnNamesFixedLen(<br/>    oX: pd.DataFrame,<br/>    column_length: int = 1,<br/>    col_separator: str = "_",<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:<br/><br/>    Parameters:<br/>    X: dataset<br/><br/>Keywords:<br/><br/>    column_length:  Default: 3<br/>        Character length for which to truncate all columns.<br/>        The column separator value and number for duplicate<br/>        column name does not contribute. Therefore, if all<br/>        columns are truncated to 10 characters, the first<br/>        distinct column will be 10 characters and the<br/>        remaining will be 12 characters (assuming a column<br/>        separator of one character).<br/><br/>    col_separator: Default: "_"<br/>        The separator to append plus incremental Int <br/>        to create unique column names. Care should be <br/>        taken in choosing non-default col_separator <br/>        so as to create legal pandas column name.<br/><br/>    verbose: Default: True<br/>        True: output<br/>        False: silent<br/><br/>    inplace: Default: True<br/>        True: replace 1st argument with resulting dataframe<br/>        False:  (boolean)change unplace the dataframe X<br/><br/>Returns: A pandas DataFrame with truncated column lengths.</span></pre><p id="ca59" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">将列名截断到特定长度。如果列长度较短，则列长度保持不变。</p><p id="5a64" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe oe of og oh b">toColumnNamesFixedLen</code>会将所有列截断到给定的长度，并附加给定的分隔符和重复列的索引，第一个不同的列名除外。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="5e3b" class="om ms it oh b gy on oo l op oq">toDataFrame([[1,2,3,4]],columns=[<br/> “long_name”,<br/> “another_long_name”,<br/> “another_longer_name”,<br/> “data”,<br/>]).toColumnNamesFixedLen(column_length=5)</span></pre><p id="454f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="f344" class="om ms it oh b gy on oo l op oq">2019-12-12 09:39:39.051 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with column names: Index(['long_name', 'another_long_name', 'another_longer_name', 'data'], dtype='object')<br/>2019-12-12 09:39:39.052 | INFO     | paso.pre.toutil:toColumnNamesFixedLen:669 - toColumnNamesFixedLen features:: ['lo', 'an', 'an=1', 'da']</span></pre><p id="2717" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/42bea6affbedf66f953b3d65348391b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*uW8Zx5z-xl9Zl8ANUGKfLQ.png"/></div><figcaption class="pj pk gj gh gi pl pm bd b be z dk">Resulting DataFrame from toColumnNamesFixedLen</figcaption></figure><h1 id="a2b4" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">函数式编程——用链接创建可读管道</h1><p id="3f0c" class="pw-post-body-paragraph ld le it lf b lg nj kd li lj nk kg ll lm nl lo lp lq nm ls lt lu nn lw lx ly im bi translated">在这一节。我将展示 python 中的函数式编程风格。这种风格也被称为<em class="nx">链式</em>，使用<strong class="lf jd"> R </strong>的人应该非常熟悉。</p><p id="bc13" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我将创建一个数据框架，这样我们就可以显示我们的一些清洁链(管道)。</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="de53" class="om ms it oh b gy on oo l op oq">arr = np.ndarray(shape=(1000000,6), dtype=int, order='F')<br/>dataset = toDataFrame(arr)<br/>dataset['date'] = pd.to_datetime('11/30/1956')</span></pre><p id="d664" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="1cbe" class="om ms it oh b gy on oo l op oq">2019-12-12 09:46:58.614 | INFO     | paso.pre.toutil:toDataFrame:112 - toDataFrame  with column names: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5'], dtype='object')</span></pre></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><pre class="oi oh oj ok aw ol bi"><span id="02f4" class="om ms it oh b gy pw px py pz qa oo l op oq">dataset.toDatetimeComponents(inplace=False)\<br/>.toColumnNamesFixedLen(column_length=12)\<br/>.toContinuousCategory(quantile=False,nbin=10,drop=False)\<br/>.head(n=3)</span></pre><p id="4579" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">日志输出[=&gt;]</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="ff48" class="om ms it oh b gy on oo l op oq">2019-12-12 10:18:49.817 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Year<br/>2019-12-12 10:18:49.861 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Month<br/>2019-12-12 10:18:49.920 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Week<br/>2019-12-12 10:18:49.962 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Day<br/>2019-12-12 10:18:50.013 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Dayofweek<br/>2019-12-12 10:18:50.060 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Dayofyear<br/>2019-12-12 10:18:50.092 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Elapsed<br/>2019-12-12 10:18:50.139 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Is_month_end<br/>2019-12-12 10:18:50.182 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Is_month_start<br/>2019-12-12 10:18:50.236 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Is_quarter_end<br/>2019-12-12 10:18:50.280 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Is_quarter_start<br/>2019-12-12 10:18:50.327 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Is_year_end<br/>2019-12-12 10:18:50.368 | INFO     | paso.pre.toutil:toDatetimeComponents:346 - datetime feature component added: date_Is_year_start<br/>2019-12-12 10:18:50.477 | INFO     | paso.pre.toutil:toDatetimeComponents:351 - datetime feature dropped: date<br/>2019-12-12 10:18:50.478 | INFO     | paso.pre.toutil:toColumnNamesFixedLen:669 - toColumnNamesFixedLen features:: ['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5', 'date_Year', 'date_Month', 'date_Week', 'date_Day', 'date_Dayofwe', 'date_Dayofye', 'date_Elapsed', 'date_Is_mont', 'date_Is_mont_1', 'date_Is_quar', 'date_Is_quar_1', 'date_Is_year', 'date_Is_year_1']<br/>2019-12-12 10:18:51.112 | INFO     | paso.pre.toutil:toContinuousCategory:533 - toContinuousCategory features:: Index(['c_0', 'c_1', 'c_2', 'c_3', 'c_4', 'c_5', 'date_Year', 'date_Month',<br/>       'date_Week', 'date_Day', 'date_Dayofwe', 'date_Dayofye', 'date_Elapsed',<br/>       'date_Is_mont', 'date_Is_mont_1', 'date_Is_quar', 'date_Is_quar_1',<br/>       'date_Is_year', 'date_Is_year_1'],<br/>      dtype='object')</span></pre><p id="f392" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出[=&gt;]</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/f721d309725b6bf0e4c7c0b712288724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3ssPzvd17LAE0CxsrgqOQ.png"/></div></div><figcaption class="pj pk gj gh gi pl pm bd b be z dk">Resulting DataFrame from chaining</figcaption></figure><h1 id="9d7e" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">摘要</h1><p id="0e38" class="pw-post-body-paragraph ld le it lf b lg nj kd li lj nk kg ll lm nl lo lp lq nm ls lt lu nn lw lx ly im bi translated">从 Python 3.6 (PEP 484)开始，引入了类型提示。类型提示(注意:不是强类型检查)使得用下游工具对 Python 代码进行静态类型检查成为可能。</p><p id="8dcc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用类型提示，<code class="fe oe of og oh b">toutil</code>函数调用签名被总结如下:</p><pre class="ks kt ku kv gt oi oh oj ok aw ol bi"><span id="52d3" class="om ms it oh b gy on oo l op oq"># 1<br/>paso.pre.toutil.toDataFrame(<br/>        X: pd.DataFrame,<br/>        columns: List = None, <br/>        inplace: bool = True, <br/>        verbose: bool = True) -&gt; pd.DataFrame:<br/>#2<br/>paso.pre.toutil.toCategory(<br/>    X: pd.DataFrame,<br/>    bool_: bool = True,<br/>    int_: bool = True,<br/>    object_: str = True,<br/>    inplace: bool = True,<br/>    verbose: bool = True) -&gt; pd.DataFrame:<br/>#3<br/>paso.pre.toutil.<!-- -->toContinuousCategory(<br/>    oX: pd.DataFrame,<br/>    features: list = [],<br/>    drop: bool = True,<br/>    int_: bool = True,<br/>    float_: bool = True,<br/>    quantile: bool = True,<br/>    nbin: int = 10,<br/>    inplace: bool = True,<br/>    verbose: bool = True,<br/>) -&gt; pd.DataFrame:<br/><br/>#4<br/> paso.pre.toutil.toDatetimeComponents(<br/>    oX: pd.DataFrame,<br/>    drop: bool = True,<br/>    components: list = [],<br/>    prefix: bool = True,<br/>    inplace: bool = True,<br/>    verbose: bool = True) -&gt; pd.DataFrame:<br/><br/>#5<br/>paso.pre.toutil.def toColumnNamesFixedLen(<br/>    X: pd.DataFrame,<br/>    column_length: int = 1,<br/>    col_separator: str = "_",<br/>    inplace: bool = True,<br/>    verbose: bool = True) -&gt; pd.DataFrame:</span></pre><p id="c26d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本文的代码在这里给出<a class="ae od" href="https://github.com/bcottman/paso/blob/master/lessons" rel="noopener ugc nofollow" target="_blank">在这里给出</a>和<a class="ae od" href="https://github.com/bcottman/paso/blob/master/paso/pre/toutil.py" rel="noopener ugc nofollow" target="_blank">在这里给出</a>。</p><p id="3101" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">关于<strong class="lf jd">帕索</strong>的其他文章有:</p><div class="lz ma gp gr mb mc"><a href="https://medium.com/@dr.bruce.cottman/pasos-offering-of-logging-and-parameter-services-for-your-python-project-c3ae2fd6869a" rel="noopener follow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd jd gy z fp mh fr fs mi fu fw jc bi translated">paso 为您的 Python 项目提供日志记录和参数服务</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">paso 为您的 Python 项目提供日志记录和参数服务</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">paso 为您的 Python Projectmedium.com 提供日志记录和参数服务</p></div></div><div class="ml l"><div class="qc l mn mo mp ml mq lb mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a href="https://medium.com/@dr.bruce.cottman/part-1-balancing-and-augmenting-structured-data-4ade0df38662" rel="noopener follow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd jd gy z fp mh fr fs mi fu fw jc bi translated">第 1 部分:平衡和扩充结构化数据</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">数据扩充很重要，因为它从我们当前现有的数据集生成(准确地)人工数据。的…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">medium.com</p></div></div><div class="ml l"><div class="qd l mn mo mp ml mq lb mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/uncommon-data-cleaners-for-your-real-world-machine-or-deep-learning-project-f926d8ecb258"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd jd gy z fp mh fr fs mi fu fw jc bi translated">用于真实世界机器或深度学习项目的不寻常的数据清理器</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">介绍</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq lb mc"/></div></div></a></div><p id="ff01" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">未来，我们将通过以下文章更深入地介绍<strong class="lf jd"> paso </strong>:</p><ul class=""><li id="04bc" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated">链接整个机器学习管道。</li><li id="fac5" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">第 2 部分:平衡和扩充结构化数据的更多(更好)方法。</li><li id="15fb" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">第 1 部分:分类特征的不同编码方法。</li><li id="f43b" class="no np it lf b lg ny lj nz lm oa lq ob lu oc ly nt nu nv nw bi translated">第 2 部分:分类特征的深度学习编码。</li></ul><p id="d3dd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你有一个服务或功能，或者看到一个 bug，那么就把这个<strong class="lf jd"> paso </strong>项目留给一个<a class="ae od" href="https://github.com/bcottman/paso/issues" rel="noopener ugc nofollow" target="_blank">注释</a>。</p></div></div>    
</body>
</html>