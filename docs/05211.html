<html>
<head>
<title>Gaining a solid understanding of Pandas series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解熊猫系列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gaining-a-solid-understanding-of-pandas-series-893fb8f785aa?source=collection_archive---------15-----------------------#2019-08-04">https://towardsdatascience.com/gaining-a-solid-understanding-of-pandas-series-893fb8f785aa?source=collection_archive---------15-----------------------#2019-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/97c8622cac520d9978f724470709f67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7yGVLAzhwInOcAXG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@stonewyq?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stone Wang</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3210" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">议程</h1><p id="48ef" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Pandas 的两个主要数据结构是序列和数据帧。这篇文章试图对熊猫系列有一个正确的理解。</p><p id="5b84" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">数据帧的基础是一个系列。DataFrame 的 docstring 将 DataFrame 定义为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2f40" class="mn ke iq mj b gy mo mp l mq mr">Can be thought of as a dict-like<br/>container for Series objects</span></pre><p id="a32b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">dataframe 上的许多操作返回系列实例。因此，我们必须对级数有一个扎实的了解。</p><h1 id="3c33" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是系列</h1><p id="6bb3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">熊猫有两种概念。可以把它想象成一列表格数据。它也可以被想象成一行表格数据。</p><p id="d2d9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们假设有一个名为<code class="fe ms mt mu mj b">accounting</code>的数据库表，它存储不同年份的<code class="fe ms mt mu mj b">revenue</code>和<code class="fe ms mt mu mj b">expenses</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0e87" class="mn ke iq mj b gy mo mp l mq mr"> year   revenue   expense<br/> 2017   1000      800<br/> 2018   1200      900<br/> 2019   1500      1100</span></pre><p id="ea79" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">所有收入的集合是一个<code class="fe ms mt mu mj b">Series</code>，即<code class="fe ms mt mu mj b">[1000, 1200, 1500]</code>是一个数列。系列是不同对象/行/实例的相同属性的集合。</p><p id="25e5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">Series</code>也可以被认为是表格中的一行，也就是说<code class="fe ms mt mu mj b">[2017, 1000, 800]</code>也是一个系列。在这种情况下，系列是单个对象的不同属性的集合。</p><h1 id="4f16" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">创建系列</h1><p id="c12f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在现实世界中，您很少会创建一个系列。您可能会获得一个 csv 或其他数据源，您可以从中读取数据。pandas 有从这些数据源读取数据的工具。</p><p id="e56e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">读取的数据将是熊猫数据帧。您将从数据帧中提取一些序列，并对这些序列进行操作。</p><p id="446f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这是一个简单的任务。现在，让我们明确地创建一个系列</p><p id="7a11" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">可以使用<code class="fe ms mt mu mj b">pandas.Series</code>创建一个<code class="fe ms mt mu mj b">Series</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d2347c514868095b2750ee16ea3ac9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYdYWdXYvNgvhxeI7YaCcA.png"/></div></div></figure><p id="ba73" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们在 ipython shell 上试试吧。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="653c" class="mn ke iq mj b gy mo mp l mq mr">In [2]: revenue = pd.Series([1000, 1200, 1500, 800, 900], index=['2014', '2015', '2016', '2017', '2018'])</span></pre><p id="d87f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">index</code>关键字参数将标签分配给系列的不同值。这些标签在从系列中检索数据时很方便。</p><h1 id="50ee" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">索引系列</h1><p id="f6ba" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们从这个系列中获取信息。让我们检索 2016 年的收入。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="59ed" class="mn ke iq mj b gy mo mp l mq mr">In [8]: revenue['2016']<br/>Out[8]: 1500</span></pre><p id="695a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">系列也有两种索引方法，分别是<code class="fe ms mt mu mj b">.loc</code>和<code class="fe ms mt mu mj b">.iloc</code>。</p><p id="57fb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">.loc</code>执行基于标签的索引。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d88" class="mn ke iq mj b gy mo mp l mq mr">In [9]: revenue.loc['2016']<br/>Out[9]: 1500</span></pre><p id="df7d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">.iloc</code>执行基于整数的索引。2016 是第三个条目，即索引 2。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e1f4" class="mn ke iq mj b gy mo mp l mq mr">In [10]: revenue.iloc[2]<br/>Out[10]: 1500</span></pre><p id="5763" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">revenue.iloc['2016']</code>将失败，并出现<code class="fe ms mt mu mj b">KeyError</code>。<code class="fe ms mt mu mj b">revenue.loc[2]</code>将失败，并出现<code class="fe ms mt mu mj b">IndexError</code>。</p><h1 id="1039" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">切片系列</h1><p id="9a6e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以使用与列表切片相同的语法对序列进行切片。我们想从 2014 年到 2016 年分一杯羹。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="80d0" class="mn ke iq mj b gy mo mp l mq mr">In [17]: revenue['2014': '2016']<br/>Out[17]:<br/>2014    1000<br/>2015    1200<br/>2016    1500<br/>dtype: int64</span></pre><p id="ab93" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">注意，返回的数据结构也是一个<code class="fe ms mt mu mj b">pandas.Series</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2b93" class="mn ke iq mj b gy mo mp l mq mr">In [18]: type(revenue['2014': '2016'])<br/>Out[18]: pandas.core.series.Series</span></pre><p id="d58d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果要使用整数位置进行切片，就必须使用<code class="fe ms mt mu mj b">.iloc</code>。整数位置只能与<code class="fe ms mt mu mj b">iloc</code>一起使用。它不能与<code class="fe ms mt mu mj b">loc</code>一起使用。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5119" class="mn ke iq mj b gy mo mp l mq mr">In [20]: revenue.iloc[0:3]<br/>Out[20]:<br/>2014    1000<br/>2015    1200<br/>2016    1500<br/>dtype: int64</span></pre><p id="8ae8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">返回的对象又是一个序列。</p><p id="53b6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果我们需要多年的信息，我们必须将一个列表传递给索引语法。让我们看看 2014 年和 2017 年的收入。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7931" class="mn ke iq mj b gy mo mp l mq mr">In [23]: revenue[['2014', '2017']]<br/>Out[23]:<br/>2014    1000<br/>2017     800<br/>dtype: int64</span></pre><p id="2c62" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们也可以使用<code class="fe ms mt mu mj b">revenue.loc[['2014', '2017']]</code>。</p><p id="d7c9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">2014 年是该系列的第一个条目，2017 年是第四个条目。我们也可以使用<code class="fe ms mt mu mj b">revenue.iloc[[0, 3]]</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c94f" class="mn ke iq mj b gy mo mp l mq mr">In [25]: revenue.iloc[[0, 3]]<br/>Out[25]:<br/>2014    1000<br/>2017     800<br/>dtype: int64</span></pre><p id="b495" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">您应该已经注意到，对一个系列进行切片总是会返回另一个系列。</p><h1 id="3e65" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">获取系列的标签</h1><p id="6ff3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们想要一份我们有收入的所有年份的清单。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a73" class="mn ke iq mj b gy mo mp l mq mr">In [93]: revenue.index<br/>Out[93]: Index(['2014', '2015', '2016', '2017', '2018'], dtype='object')</span><span id="7cb1" class="mn ke iq mj b gy mw mp l mq mr">In [94]: list(revenue.index)<br/>Out[94]: ['2014', '2015', '2016', '2017', '2018']</span></pre><p id="974a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">正如我们所见，<code class="fe ms mt mu mj b">Series</code>对象有一个名为<code class="fe ms mt mu mj b">index</code>的属性，它返回标签。</p><h1 id="ce01" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">过滤系列</h1><p id="ca61" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们希望获得收入大于 1000 的所有年份。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="09c1" class="mn ke iq mj b gy mo mp l mq mr">In [50]: revenue[revenue &gt; 1000]<br/>Out[50]:<br/>2015    1200<br/>2016    1500<br/>dtype: int64</span></pre><p id="7236" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们将在下一节了解它是如何工作的。</p><h1 id="1276" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用布尔列表进行过滤</h1><p id="56f3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">布尔列表是支持对序列进行过滤的底层机制。</p><p id="0cf1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们希望获得 2014 年和 2017 年的收入。2014 定位 0，2017 定位 3。</p><p id="a7ac" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们必须创建一个与收入相同长度的列表，并将第 0 和第 3 个元素设置为真。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="92ec" class="mn ke iq mj b gy mo mp l mq mr">In [75]: l = [True, False, False, True, False] # Set 0th and 3rd element True</span><span id="29f7" class="mn ke iq mj b gy mw mp l mq mr">In [76]: revenue[l]<br/>Out[76]:<br/>2014    1000<br/>2017     800<br/>dtype: int64</span></pre><p id="c44b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们向索引语法传递了一个布尔值列表，它过滤了这个系列，返回另一个系列。返回的序列只包含布尔列表中相应元素为真的值。</p><p id="b691" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">代替列表，我们可以用布尔值创建一个长度为 5 的序列，并使用带有<code class="fe ms mt mu mj b">revenue</code>的布尔序列。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="92ce" class="mn ke iq mj b gy mo mp l mq mr">In [78]: boolean_series = pd.Series([True, False, False, True, False], index=['2014', '2015', '2016', '2017', '2018'])</span><span id="164a" class="mn ke iq mj b gy mw mp l mq mr">In [79]: revenue[boolean_series]<br/>Out[79]:<br/>2014    1000<br/>2017     800<br/>dtype: int64</span></pre><p id="421d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因为我们想对收入使用布尔序列，所以我们必须确保两个序列的索引匹配。</p><p id="2daa" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们看看<code class="fe ms mt mu mj b">revenue &gt; 1000</code>给了我们什么:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8bfe" class="mn ke iq mj b gy mo mp l mq mr">In [80]: revenue &gt; 1000<br/>Out[80]:<br/>2014    False<br/>2015     True<br/>2016     True<br/>2017    False<br/>2018    False<br/>dtype: bool</span></pre><p id="2a2b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">它返回给我们一个序列，类似于我们显式创建的 boolean_series。</p><p id="26a0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">既然是一个系列，我们可以直接用这个和<code class="fe ms mt mu mj b">revenue</code>做<code class="fe ms mt mu mj b">revenue[revenue &gt; 1000]</code>。这正是我们在上一节过滤中所做的。</p><h1 id="e2d6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">更多过滤</h1><p id="d7ec" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们希望获得收入大于 1000 但小于 1300 的所有年份。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1379" class="mn ke iq mj b gy mo mp l mq mr">In [68]: revenue[(revenue &gt; 1000) &amp; (revenue &lt; 1300)]<br/>Out[68]:<br/>2015    1200<br/>dtype: int64</span></pre><h1 id="845c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">级数的算术运算</h1><p id="b214" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">假设我们意识到每年的收入减少了 100 英镑。我们想每年增加 100 的收入来弥补。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c8a7" class="mn ke iq mj b gy mo mp l mq mr">In [81]: revenue + 100<br/>Out[81]:<br/>2014    1100<br/>2015    1300<br/>2016    1600<br/>2017     900<br/>2018    1000<br/>dtype: int64</span></pre><p id="9083" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">请注意序列的每个值是如何增加 100 的。</p><p id="4c52" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对序列的任何算术运算都应用于序列的所有值。</p><h1 id="411a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">按系列订购</h1><p id="6ee5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们希望按升序对收入进行排序。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="80a3" class="mn ke iq mj b gy mo mp l mq mr">In [87]: revenue.sort_values()<br/>Out[87]:<br/>2017     800<br/>2018     900<br/>2014    1000<br/>2015    1200<br/>2016    1500<br/>dtype: int64</span></pre><p id="491e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们想按降序排列收入。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="618d" class="mn ke iq mj b gy mo mp l mq mr">In [88]: revenue.sort_values(ascending=False)<br/>Out[88]:<br/>2016    1500<br/>2015    1200<br/>2014    1000<br/>2018     900<br/>2017     800<br/>dtype: int64</span></pre><p id="1bcb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们想知道哪一年的收入最高。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9359" class="mn ke iq mj b gy mo mp l mq mr">In [92]: revenue.sort_values(ascending=False).index[0]<br/>Out[92]: '2016'</span></pre><p id="afa0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">revenue.sort(ascending=False)</code>返回一个有序序列。由于一个系列有属性<code class="fe ms mt mu mj b">index</code>，我们可以使用它并获得年度最大收入的标签。</p><p id="1f2a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">不过，有一种更好的方法可以实现这一点。我们将在下一节看到<code class="fe ms mt mu mj b">idxmax()</code>。</p><h1 id="b718" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">序列上的聚合</h1><p id="8ba8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们找出这些年的总收入。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="04a6" class="mn ke iq mj b gy mo mp l mq mr">In [96]: revenue.sum()<br/>Out[96]: 5400</span></pre><p id="e503" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">系列有工具可以很容易地找到平均值，最大值和最小值。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0da7" class="mn ke iq mj b gy mo mp l mq mr">In [102]: revenue.mean()<br/>Out[102]: 1080.0</span><span id="6051" class="mn ke iq mj b gy mw mp l mq mr">In [103]: revenue.max()<br/>Out[103]: 1500</span><span id="e884" class="mn ke iq mj b gy mw mp l mq mr">In [104]: revenue.min()<br/>Out[104]: 800</span></pre><p id="0c36" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们想知道哪一年的收入最高。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dc7b" class="mn ke iq mj b gy mo mp l mq mr">In [106]: revenue.idxmax()<br/>Out[106]: '2016'</span></pre><h1 id="f1d5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">序列的分组和聚合</h1><p id="780c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们假设某一年的收入可能有多行。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a1f" class="mn ke iq mj b gy mo mp l mq mr">In [2]: revenue_with_multiple_entries = pd.Series([1000, 1200, 1500, 800, 900, 500], index=['2014', '2015', '2016', '2017', '2018', '2017'])</span><span id="00c1" class="mn ke iq mj b gy mw mp l mq mr">In [3]: print(revenue_with_multiple_entries)<br/>2014    1000<br/>2015    1200<br/>2016    1500<br/>2017     800<br/>2018     900<br/>2017     500<br/>dtype: int64</span></pre><p id="5316" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们有多行 2017 年收入。我们想知道不同年份的总收入。</p><p id="a5b6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以通过做一个<code class="fe ms mt mu mj b">groupby</code>然后做一个<code class="fe ms mt mu mj b">sum</code>来实现它。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3af4" class="mn ke iq mj b gy mo mp l mq mr">In [4]: revenue_with_multiple_entries.groupby(revenue_with_multiple_entries.index).sum()<br/>Out[4]:<br/>2014    1000<br/>2015    1200<br/>2016    1500<br/>2017    1300<br/>2018     900<br/>dtype: int64</span></pre><h1 id="34ef" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">数列的最常见值</h1><p id="03bf" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们创建一系列班级学生的名字。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6733" class="mn ke iq mj b gy mo mp l mq mr">In [6]: names = pd.Series(['steve jobs', 'bill gates', 'mark twain', 'charles darwin', 'charles dickens', 'mark zuckerberg', 'charles darwin'])</span><span id="0a40" class="mn ke iq mj b gy mw mp l mq mr">In [7]: print(names)<br/>0         steve jobs<br/>1         bill gates<br/>2         mark twain<br/>3     charles darwin<br/>4    charles dickens<br/>5    mark zuckerberg<br/>6     charles darwin</span></pre><p id="32b0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">你应该已经注意到了，我们没有给这个系列提供明确的<code class="fe ms mt mu mj b">index</code>。所以会自动分配一个整数标签。</p><p id="e4a9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们来找一个最常见的名字。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bed0" class="mn ke iq mj b gy mo mp l mq mr">In [10]: names.value_counts()<br/>Out[10]:<br/>charles darwin     2<br/>bill gates         1<br/>mark zuckerberg    1<br/>mark twain         1<br/>steve jobs         1<br/>charles dickens    1</span></pre><h1 id="35ea" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">系列上的字符串操作</h1><p id="af71" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们找出所有以<code class="fe ms mt mu mj b">mark</code>开头的名字。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e44d" class="mn ke iq mj b gy mo mp l mq mr">In [16]: names[names.str.startswith('mark')]<br/>Out[16]:<br/>2         mark twain<br/>5    mark zuckerberg<br/>dtype: object</span></pre><p id="4910" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">names.str.startswith('mark')</code>返回一个布尔数组，我们将该数组传递给索引语法以过滤序列。</p><p id="c4e3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">熊猫系列有<code class="fe ms mt mu mj b">str</code>属性，允许执行字符串操作。</p><h1 id="f299" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">运用方法</h1><p id="3e1c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Series 有一个叫做<code class="fe ms mt mu mj b">apply</code>的方法，允许进行高级过滤。</p><p id="57b6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们想找到所有姓氏为<code class="fe ms mt mu mj b">darwin</code>的名字。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aba8" class="mn ke iq mj b gy mo mp l mq mr">In [27]: names[names.apply(lambda x: x.split(' ')[-1] == 'darwin')]<br/>Out[27]:<br/>3    charles darwin<br/>6    charles darwin<br/>dtype: object</span></pre><p id="d429" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe ms mt mu mj b">apply</code>方法需要一个函数传递给它。这就是为什么我们给它传递了一个 lambda 函数。</p><p id="a423" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">调用 names.apply()将 lambda 函数应用于序列的所有值。<code class="fe ms mt mu mj b">.apply()</code>的返回值是布尔值的一个<code class="fe ms mt mu mj b">series</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="113d" class="mn ke iq mj b gy mo mp l mq mr">In [26]: names.apply(lambda x: x.split(' ')[-1] == 'darwin')<br/>Out[26]:<br/>0    False<br/>1    False<br/>2    False<br/>3     True<br/>4    False<br/>5    False<br/>6     True<br/>dtype: bool</span></pre><p id="c29d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们使用布尔型<code class="fe ms mt mu mj b">series</code>来过滤原始系列。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="2ce7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在<a class="ae kc" href="https://twitter.com/_akshar" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，我<a class="ae kc" href="https://twitter.com/_akshar" rel="noopener ugc nofollow" target="_blank">在 Twitter 上发布</a>关于信息丰富且有价值的编程文章和建议。</p></div></div>    
</body>
</html>