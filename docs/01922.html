<html>
<head>
<title>Predictive Maintenance: detect Faults from Sensors with CNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测性维护:使用 CNN 检测传感器故障</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predictive-maintenance-detect-faults-from-sensors-with-cnn-6c6172613371?source=collection_archive---------5-----------------------#2019-03-30">https://towardsdatascience.com/predictive-maintenance-detect-faults-from-sensors-with-cnn-6c6172613371?source=collection_archive---------5-----------------------#2019-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a81a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 python 代码和图形表示的有趣方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9a22cdcf91f116b7eb3d9402e9d5d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZXfZOP5RwOljusHT"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@brucebmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bruce Warrington</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在机器学习中，随着时间的推移，预测性维护的主题变得越来越流行。这些挑战并不容易，而且非常多样化:对该领域有很好的了解或者与了解底层系统如何工作的人接触是很有用的。由于这些原因，当数据科学家投身于这个新的战场时，必须遵循线性和理性的方法，记住最简单的解决方案总是更好的。</p><p id="6e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究一个分类问题。我们将在 Keras 应用一个由 CNN 制作的简单但非常强大的模型，并尝试对我们的结果给出一个直观的解释。</p><h1 id="e944" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据集</h1><p id="c784" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我决定从常青 UCI 仓库(<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/Condition+monitoring+of+hydraulic+systems#" rel="noopener ugc nofollow" target="_blank">液压系统的状态监控</a>)获取一个数据集。</p><blockquote class="ms mt mu"><p id="e5ac" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">该数据集是用液压试验台通过实验获得的。该试验台由通过油箱连接的一次工作回路和二次冷却过滤回路组成。当四个液压部件(冷却器、阀门、泵和蓄能器)的状态定量变化时，系统周期性地重复恒定负载循环(持续时间 60 秒)并测量过程值，如压力、体积流量和温度。</p></blockquote><p id="34ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以设想有一个液压管道系统，该系统周期性地接收由于例如管道中特定类型液体的转移而产生的脉冲。这种现象持续 60 秒，由不同的传感器(<em class="mv">传感器物理量单位采样率、PS1 压力棒、PS2 压力棒、PS3 压力棒、PS4 压力棒、PS5 压力棒、PS6 压力棒、EPS1 电机功率、FS1 体积流量、FS2 体积流量、TS1 温度、TS2 温度、TS3 温度、TS4 温度、VS1 振动、CE 冷却效率、CP 冷却功率、SE 效率因子</em>)以不同的 Hz 频率测量。</p><p id="6360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目的是预测组成管道的四个液压元件的状态。这些目标条件值以整数值的形式进行注释(易于编码)，如果某个特定组件在每个周期都接近失效，则称之为 us <strong class="lb iu">。</strong></p><h1 id="4c15" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">读取数据</h1><p id="b92f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个传感器测量的值可在特定的<em class="mv"> txt </em>文件中获得，其中每一行以时间序列的形式表示一个周期。</p><p id="c993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定考虑来自温度传感器(TS1、TS2、TS3、TS4)的数据，这些传感器以 1 Hz 的频率测量(每个周期 60 次观察)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c385" class="ne lw it na b gy nf ng l nh ni">label = pd.read_csv(path+'profile.txt', sep='\t', header=None)<br/>label.columns = ['Cooler','Valve','Pump','Accumulator','Flag']</span><span id="98ba" class="ne lw it na b gy nj ng l nh ni">data = ['TS1.txt','TS2.txt','TS3.txt','TS4.txt']<br/>df = pd.DataFrame()</span><span id="4de9" class="ne lw it na b gy nj ng l nh ni">for txt in data:<br/>    read_df = pd.read_csv(path+txt, sep='\t', header=None)<br/>    df = df.append(read_df)</span></pre><p id="f171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一个周期，我们从温度传感器获得这些时间序列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/414f342e39178253f316fe18a044609f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*EoYyvuoGqZ1I2fyqZ0Fwiw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Temperature Series for cycle 1 from TS1 TS2 TS3 TS4</figcaption></figure><h1 id="df73" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型</h1><p id="3a9f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了捕捉有趣的特征和不明显的相关性，我们决定采用 1D CNN。这种模型非常适合于传感器时间序列的分析，并且要求在短的固定长度段中对数据进行整形。</p><p id="d2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发这个工作流程时，我从<a class="ae ky" href="https://blog.goodaudience.com/introduction-to-1d-convolutional-neural-networks-in-keras-for-time-sequences-3a7ff801a2cf" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中获得了灵感，这篇文章采用了一种非常有用的方法。我选择了在<a class="ae ky" href="https://keras.io/getting-started/sequential-model-guide/" rel="noopener ugc nofollow" target="_blank"> Keras 网站</a>上描述的 CNN，并刷新了参数。建立该模型是为了对冷却器组件的状态进行分类，只给定数组格式的温度时间序列作为输入(每个周期的 t_periods x n_sensor)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="22c1" class="ne lw it na b gy nf ng l nh ni">num_sensors = 4<br/>TIME_PERIODS = 60<br/>BATCH_SIZE = 16<br/>EPOCHS = 10</span><span id="1cec" class="ne lw it na b gy nj ng l nh ni">model_m = Sequential()<br/>model_m.add(Conv1D(100, 6, activation='relu', input_shape=(TIME_PERIODS, num_sensors)))<br/>model_m.add(Conv1D(100, 6, activation='relu'))<br/>model_m.add(MaxPooling1D(3))<br/>model_m.add(Conv1D(160, 6, activation='relu'))<br/>model_m.add(Conv1D(160, 6, activation='relu'))<br/>model_m.add(GlobalAveragePooling1D(name='G_A_P_1D'))<br/>model_m.add(Dropout(0.5))<br/>model_m.add(Dense(3, activation='softmax'))<br/>print(model_m.summary())</span><span id="b23e" class="ne lw it na b gy nj ng l nh ni">model_m.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])</span><span id="6217" class="ne lw it na b gy nj ng l nh ni">history = model_m.fit(X_train, y_train, batch_size=BATCH_SIZE, epochs=EPOCHS, validation_split=0.2, verbose=2)</span></pre><p id="7370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，仅用 10 个纪元，我们就能取得令人难以置信的结果！</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="419c" class="ne lw it na b gy nf ng l nh ni">Train on 1411 samples, validate on 353 samples<br/>Epoch 1/10<br/>1411/1411 [==============================] - 2s 2ms/step - loss: 0.2581 - acc: 0.9391 - val_loss: 0.0867 - val_acc: 0.9830<br/>Epoch 2/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.1111 - acc: 0.9731 - val_loss: 0.0686 - val_acc: 0.9830<br/>Epoch 3/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.0925 - acc: 0.9759 - val_loss: 0.0674 - val_acc: 0.9802<br/>Epoch 4/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.1093 - acc: 0.9731 - val_loss: 0.0769 - val_acc: 0.9830<br/>Epoch 5/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.1022 - acc: 0.9731 - val_loss: 0.0666 - val_acc: 0.9802<br/>Epoch 6/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.0947 - acc: 0.9773 - val_loss: 0.0792 - val_acc: 0.9830<br/>Epoch 7/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.0984 - acc: 0.9794 - val_loss: 0.0935 - val_acc: 0.9830<br/>Epoch 8/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.0976 - acc: 0.9738 - val_loss: 0.0756 - val_acc: 0.9802<br/>Epoch 9/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.0957 - acc: 0.9780 - val_loss: 0.0752 - val_acc: 0.9830<br/>Epoch 10/10<br/>1411/1411 [==============================] - 2s 1ms/step - loss: 0.1114 - acc: 0.9738 - val_loss: 0.0673 - val_acc: 0.9802</span></pre><p id="2503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对试验数据进行预测，模型的准确率达到 0.9909%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/fa27638057ac4a45b89b5d988303ff3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCXvGIBytsmriBeB7i9cCA.png"/></div></div></figure><p id="f81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个班的 KPI 都很牛逼！这一结果对于 3 级(部件冷却器“接近完全失效”)尤为重要，因为通过这种方式，我们能够检测并防止系统中可能出现的故障。</p><h1 id="c949" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将结果可视化</h1><p id="b2b4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们想对系统状态有一个总体的了解，并看到我们的模型的不可思议的优点，看一个图形表示可能是有用的。为了达到这个目标，我们重新利用我们在上面建立的 CNN 来制作解码器，并从每个周期的时间序列中提取巧妙的特征。使用 Keras，这在一行代码中就可以实现:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e30a" class="ne lw it na b gy nf ng l nh ni">emb_model = Model(inputs=model_m.input, outputs=model_m.get_layer('G_A_P_1D').output)</span></pre><p id="23da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新模型是一个解码器，它以与我们用于分类任务的 NN 相同的格式接收输入数据(每个周期的 t_periods x n_sensor ),并以嵌入的形式返回“预测”,该嵌入来自具有相对维度的 GlobalAveragePooling1D 层(每个周期的一行 160 个嵌入变量)。</p><p id="1a38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用我们的编码器对测试数据进行预测计算，采用一种降维技术(如 PCA 或 T-SNE ),并绘制结果，我们可以看到这种魔力:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2601" class="ne lw it na b gy nf ng l nh ni">serie_features = emb_model.predict(X_test)<br/>tsne = TSNE(n_components=2, random_state=42, n_iter=300, perplexity=5)<br/>T = tsne.fit_transform(serie_features)</span><span id="1c57" class="ne lw it na b gy nj ng l nh ni">plt.figure(figsize=(16,9))<br/>colors = {0:'red', 1:'blue', 2:'yellow'}<br/>plt.scatter(T.T[0], T.T[1], c=[colors[i] for i in np.argmax(y_test, axis=1)]) <br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/d02dd75e4565557054bf6fffb7bb2159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJAJec4niDI6_6VC4860zw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">TSNE on cycle embeddings for test data</figcaption></figure><p id="0fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇哦！！！这个图讲的是事实！每个点代表测试集中的一个循环，相对颜色是较冷条件的目标类别。可以看出冷却器组件的目标值之间的区别是如何定义的。这种方法是我们模型性能的关键指标。</p><h1 id="5b44" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="6655" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇文章中，我们试图解决一个预测性维护的问题，用 CNN 对时间序列进行分类。开发了一个具有令人印象深刻的性能的强大模型。我们还试图给出结果的可视化表示。重要的是要强调 CNN 的力量，不仅是在预测方面，而且是作为一种工具来检测数据之间的无形关系。</p><p id="a78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果你对题目感兴趣，我建议:</strong></p><ul class=""><li id="4075" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/predictive-maintenance-with-lstm-siamese-network-51ee7df29767"> <strong class="lb iu">预见性维护同 LSTM</strong></a></li><li id="c396" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/predictive-maintenance-detect-faults-from-sensors-with-crnn-and-spectrograms-e1e4f8c2385d"> <strong class="lb iu">预测维护:用 CRNN 和光谱图检测传感器故障</strong> </a></li><li id="e3af" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/predictive-maintenance-with-resnet-ebb4f4a0be3d" rel="noopener"> <strong class="lb iu">用 ResNet 进行预测性维护</strong> </a></li></ul></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="21bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/cerlymarco/MEDIUM_NoteBook" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">查看我的 GITHUB 回购</strong> </a></p><p id="7e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持联系:<a class="ae ky" href="https://www.linkedin.com/in/marco-cerliani-b0bba714b/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></p></div></div>    
</body>
</html>