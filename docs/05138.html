<html>
<head>
<title>XLNET explained in simple terms !!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XLNET 深入浅出的解释！！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xlnet-explained-in-simple-terms-255b9fb2c97c?source=collection_archive---------7-----------------------#2019-08-01">https://towardsdatascience.com/xlnet-explained-in-simple-terms-255b9fb2c97c?source=collection_archive---------7-----------------------#2019-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/86ee82d0091faa1457159a9470bbd319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AipKZ4b5nA1LA_ov3mzAag.png"/></div></div></figure><p id="d2d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我很高兴带你了解谷歌大脑和 CMU 最近发表的自然语言理解算法——XLNET。该算法是 NLP 中的一个突破，因为它在 20 个不同的任务中超过了最先进的<a class="ae kz" rel="noopener" target="_blank" href="/bert-explained-state-of-the-art-language-model-for-nlp-f8b21a9b6270"> BERT 算法</a>。来吧，让我们探索这种新算法能为世界带来什么！！</p><p id="646c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章的结构如下-</p><ul class=""><li id="3d55" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">通过伯特简介，</li><li id="939c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">理解伯特的缺点</li><li id="f799" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">了解变压器架构</li><li id="f048" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">深入 XLNET</li></ul><h1 id="986e" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">伯特建筑</h1><p id="f150" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">BERT 代表“来自变压器的双向编码器表示”。它是一种神经网络架构，可以使用<a class="ae kz" href="https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html" rel="noopener ugc nofollow" target="_blank">转换器</a>对文本数据中的双向上下文进行建模。</p><p id="c232" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">什么是双向的？</strong></p><ul class=""><li id="1cf3" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">传统方法在给定前“n”个记号的情况下预测当前记号，或者在给定当前记号之后的所有记号的情况下预测当前记号。</li><li id="9ef1" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">在预测当前标记时，没有一种方法一次获取前一个和下一个标记。</li><li id="84be" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">BERT 克服了这个缺点，因为它考虑了前一个和下一个标记来预测当前标记。这个属性被称为“双向的”。</li></ul><p id="0d81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">双向性是通过一种叫做“屏蔽语言建模”的现象实现的。该模型是预先训练的，可以用于一套令牌和句子级别的任务。</p><p id="dd82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">什么是蒙面语言建模(MLM)？</strong></p><p id="d51b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现双向表示，输入句子中 15%的标记被随机屏蔽。变压器被训练来预测屏蔽字。例如，考虑句子——“猫坐在墙上”。伯特的输入将是“面具上的猫”。</p><p id="9964" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">BERT 也适用于下一个句子预测任务，因为它是用成对的句子预先训练的，其中句子 B 有 50%的时间跟随 A，而其他时间不跟随。一旦该模型被预先训练，它就被微调用于特定的应用，例如问题回答、句子完成、检查两个句子的语义等价等。</p><p id="e565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">伯特的缺点</strong></p><p id="4b09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">BERT 算法有两个主要的局限性。他们是</p><ol class=""><li id="a24e" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky mr lg lh li bi translated">BERT 用掩码破坏输入，并且遭受预训练-微调差异。在实际应用中，我们没有被屏蔽的输入。伯特在现实中是如何处理的还不清楚。</li><li id="bf91" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky mr lg lh li bi translated">BERT 忽略了屏蔽位置之间的相关性。例如，考虑句子“纽约是一座城市”，输入给 BERT 的是“[MASK] [MASK]是一座城市”。伯特的目标是</li></ol><blockquote class="ms mt mu"><p id="6d27" class="kb kc mv kd b ke kf kg kh ki kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ky im bi translated"><em class="it"> log p(New |是城市)+ log p(York |是城市)</em></p></blockquote><p id="85b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的函数可以看出，学习“New”和“York”之间没有依赖关系。因此，BERT 可以得出类似“新旧金山是一座城市”的预测。</p><h1 id="c286" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">变压器架构</h1><p id="c3df" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">XLNET 将最先进的自回归模型 Transformer-XL 的思想整合到预训练中。Transformer 是 google 用于语言翻译的模型。基本都是围绕着“注意力”展开的。这是一个编码器-解码器模型，其中你将一个序列映射到另一个序列——英语到法语。要将英语中的句子翻译成法语，解码器需要查看<strong class="kd iu">整个句子</strong>以在任意时间点选择性地从中提取信息(因为英语中的标记顺序不需要与法语中的相同)。因此，<strong class="kd iu">编码器的所有隐藏状态</strong>对于解码器都是可用的。</p><p id="a925" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解码器如何知道在任何一点应该查找哪个隐藏状态？</p><p id="9b07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它通过<strong class="kd iu">加权</strong>编码器的每个隐藏状态。权重由简单的前馈神经网络确定。在本文的术语中，这些被称为注意力权重，或<em class="mv">值</em>。这里有一个<a class="ae kz" href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/" rel="noopener ugc nofollow" target="_blank">链接</a>到注意力权重的精彩解释。本文中使用的一些术语是</p><ul class=""><li id="968c" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">Query (Q) —解码器的隐藏状态。</li><li id="22c0" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">Keys (K) —编码器的隐藏状态。</li><li id="f383" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">值(V) —处理查询时的注意力权重。</li></ul><p id="6b94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个重要的东西从 Transformer-XL 集成到 XLNET 中。</p><ul class=""><li id="159f" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">位置编码——跟踪每个标记在序列中的位置(在后面的章节中将会知道为什么我们要这样做)</li><li id="3d16" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">段重现(segment recurrence )-缓存每层内存中第一个段的隐藏状态，并相应地更新注意力。它允许每个段重用内存。</li></ul><p id="f183" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们好钻研 XLNET:)</p><h1 id="8a2d" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">XL net——NLU 的广义自回归模型</h1><p id="6cca" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">XLNET 是一个广义的自回归模型，其中下一个令牌依赖于所有先前的令牌。XLNET 是“通用的”，因为它通过一种称为“置换语言建模”的机制来捕获双向上下文。它集成了自回归模型和双向上下文建模的思想，同时克服了 BERT 的缺点。它在 20 个任务上超过了 BERT，通常在问题回答、自然语言推理、情感分析和文档排序等任务上超过 BERT 很多。</p><p id="d22b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">置换语言建模(PLM) </strong></p><p id="612c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">PLM 是通过对句子中所有可能的单词排列训练一个自回归模型来捕捉双向上下文的思想。XLNET 不是固定的左右或左右建模，而是在序列的所有可能排列上最大化期望对数似然。在期望中，每个位置学习利用来自所有位置的上下文信息，从而捕获双向上下文。不需要[屏蔽]，输入数据也不会被破坏。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/72e12b9597188568b76540cd3835e83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMgzP_YboxpR8VXuGeAg_Q.png"/></div></div></figure><p id="14b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上图展示了 PLM。假设我们正在学习 x3(句子中第三个位置的标记)。PLM 训练了一个自回归模型，其中包含句子中标记的各种排列，因此在所有这些排列结束时，我们将学习 x3，给定句子中的所有其他单词。在上图中，我们可以看到下一层仅将置换序列中 x3 之前的标记作为输入。这样也实现了自回归。</p><p id="376b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">【XLNET 和 BERT 的比较</p><p id="b1b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，考虑“纽约是一个城市”这一行，我们需要预测“纽约”。让我们假设当前的排列是</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d21f54c96adb2e5f9f24edd46a45bf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*dDlZyhXmIVxKdIRy2Z-ykw.png"/></div></figure><p id="4d0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">伯特将彼此独立地预测记号 4 和 5。而 XLNET 作为一个自回归模型，按照序列的顺序进行预测。即首先预测令牌 4，然后预测令牌 5。</p><p id="7020" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，XLNET 将计算</p><p id="358a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">log P(New | <strong class="kd iu">是座城市</strong> ) + log P(York | <strong class="kd iu"> New，是座城市</strong>)</p><p id="099d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而伯特会减少到</p><p id="012a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">log P(New | <strong class="kd iu">是城市</strong> ) + log P(York | <strong class="kd iu">是城市</strong>)</p><h1 id="8c93" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">XLNET 是如何用变压器实现的？</h1><p id="914e" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们看到 transformer 查看整个句子的隐藏表示来进行预测。为了实现 XLNET，转换器被调整为只看<strong class="kd iu">要预测的</strong>之前的<strong class="kd iu">标记的隐藏表示。回想一下，当输入模型时，我们嵌入了每个标记的位置信息。假设如果要预测令牌 3，则后续层</strong></p><ul class=""><li id="032e" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">无法</strong>从输入层访问令牌 3 的内容。</li><li id="9dae" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">能不能</strong>只访问它之前的令牌的内容，只访问令牌 3 的位置信息。</li></ul><p id="a828" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当计算关注度时，根据上述原理更新 Q、K 和 V。</p><h1 id="c32d" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用 XLNET 进行的实验</h1><p id="0821" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">以下是本文作者测试 XLNET 的数据集。</p><ul class=""><li id="bc1d" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">RACE 数据集—来自英语考试的 100K 个问题，XLNET 在准确性上超过最佳模型 7.6 个点。</li><li id="88b5" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">SQuAD —阅读理解任务— XLNET 比 BERT 高出 7 分。</li><li id="aabc" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">文本分类——在各种数据集上明显优于 BERT(更多详细信息，请参见论文)。</li><li id="05bc" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">GLUE 数据集—包含 9 个 NLU 任务—纸上报告的数字，XLNET 优于 BERT。</li><li id="3bed" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">ClueWeb09-B 数据集——用于评估文档排序的性能，XLNET 优于 BERT。</li></ul><h1 id="6b37" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="68d4" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我希望你喜欢阅读这篇博客。如果你有任何问题，请在下面发表。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="facf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mv">原载于 2019 年 8 月 1 日</em><a class="ae kz" href="https://medium.com/@av2845/xlnet-at-a-quick-glance-to-begin-with-f97b1834baaf" rel="noopener"><em class="mv">【https://medium.com】</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>