<html>
<head>
<title>Computer Vision for Beginners: Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的计算机视觉:第 4 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computer-vision-for-beginners-part-4-64a8d9856208?source=collection_archive---------7-----------------------#2019-04-23">https://towardsdatascience.com/computer-vision-for-beginners-part-4-64a8d9856208?source=collection_archive---------7-----------------------#2019-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轮廓检测和一点点乐趣</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc50edce52955af3bce6e706ba8e2f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-Gxkq3Uj804Nc6Wu1DBdA.png"/></div></div></figure><p id="cee7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有很多方法可以让你有效地学习进步。对我来说，把学习和一点点乐趣结合起来是最好的策略。在这一系列教程中，许多图像被用来演示图像处理概念。你可能会感兴趣地注意到，人们喜欢我以一种有趣的方式将这个概念应用到图像中的部分。我建议你把娱乐和学习结合起来。</p><p id="d9b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是 OpenCV 初学者教程的最后一部分，完整系列如下:</p><ol class=""><li id="42f8" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener" target="_blank" href="/computer-vision-for-beginners-part-1-7cca775f58ef">理解颜色模型并在图像上绘制图形</a></li><li id="3972" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener" target="_blank" href="/computer-vision-for-beginners-part-2-29b3f9151874">使用过滤和渐变进行图像处理的基础知识</a></li><li id="c30b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener" target="_blank" href="/computer-vision-for-beginners-part-3-79de62dbeef7">从特征检测到人脸检测</a></li><li id="507b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir"><em class="mc"/></strong>轮廓检测又有了一点乐趣</li></ol><p id="4d44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从第一个系列中，我们看到了如何在图像上绘制图形。我们还讨论了如何使用各种选项应用模糊和阈值处理。在第三部分，我们讨论了几种检测算法，包括边缘检测。还有另一种检测技术叫做轮廓检测，它在物体检测中是必不可少的。在那之后，我们会用一点玩蒙版的乐趣来结束这个系列。</p><p id="4e3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文假设您已经遵循了前面的步骤，或者您已经知道这些概念。但如果不是这样，请查看本系列前面的部分。本教程的完整代码一如既往地在<a class="ae lw" href="https://github.com/jjone36/vision_4_beginners/blob/master/part4_contour_mapping.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">Github</strong></a><strong class="kt ir"/>上提供。</p><h1 id="aa9d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">轮廓检测</h1><p id="5fe3" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">你可能已经熟悉了“轮廓”这个词。在以前的帖子中，我已经多次使用这个术语。<a class="ae lw" href="https://en.wikipedia.org/wiki/Contour_line" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">轮廓线</strong> </a>表示代表相同值或相同强度的边界的曲线。等高线图是我们能想到的最简单的例子。</p><p id="ccce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是你可能会问。边缘和轮廓有什么区别？这两个术语经常互换使用，所以可能会有点混淆。简单地说，边缘的概念是在局部范围内，而轮廓的概念是在图形的整体边界上。边是其值与其相邻点相比发生显著变化的点。另一方面，轮廓是从边缘获得的封闭曲线，描绘了图形的边界。这里 可以找到进一步的解释<a class="ae lw" href="https://stackoverflow.com/questions/17103735/difference-between-edge-detection-and-image-contours" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">。</strong></a></p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="d857" class="nf me iq nb b gy ng nh l ni nj"># Load the image<br/>img = cv2.imread('images/pine_apple.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br/>plt.imshow(img)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5dc8700a24d2b1349c6a78afbe542806.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*F2dznG-AJRkklpQcRQm25g.png"/></div></figure><p id="9311" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我们要做的是检测这个菠萝的轮廓。在应用检测算法之前，我们需要将图像转换成灰度并应用如下的阈值处理。所有这些步骤都是我们在上一系列文章中讨论过的。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="ed5b" class="nf me iq nb b gy ng nh l ni nj"># Blurring for removing the noise <br/>img_blur = cv2.bilateralFilter(img, d = 7, <br/>                               sigmaSpace = 75, sigmaColor =75)</span><span id="2e7b" class="nf me iq nb b gy nl nh l ni nj"># Convert to grayscale <br/>img_gray = cv2.cvtColor(img_blur, cv2.COLOR_RGB2GRAY)</span><span id="6dbc" class="nf me iq nb b gy nl nh l ni nj"># Apply the thresholding<br/>a = img_gray.max()  <br/>_, thresh = cv2.threshold(img_gray, a/2+60, a,cv2.THRESH_BINARY_INV)<br/>plt.imshow(thresh, cmap = 'gray')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9c4e4615021ca0bdb913be801738cafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*9p5ZlGFJz0_HFKHthyEvRw.png"/></div></figure><p id="26dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">轮廓检测可以通过 OpenCV 中的函数<code class="fe nn no np nb b">cv2.findContours()</code>来实现，这里有两个重要的参数。<code class="fe nn no np nb b">mode</code>是寻找轮廓的方法，<code class="fe nn no np nb b">method</code>是检测的近似方法。我要求你从<a class="ae lw" href="https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#findcontours" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">文档</strong> </a>中找到其他信息。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="ea66" class="nf me iq nb b gy ng nh l ni nj"># Find the contour of the figure <br/>image, contours, hierarchy = cv2.findContours(<strong class="nb ir"><br/>                                   </strong>image = thresh, <br/>                                   <strong class="nb ir">mode = cv2.RETR_TREE, <br/>                                   method = cv2.CHAIN_APPROX_SIMPLE</strong>)</span></pre><p id="eb3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模式<code class="fe nn no np nb b">cv2.RETR_TREE</code>找到所有有希望的轮廓线，并重建嵌套轮廓的完整层次。方法<code class="fe nn no np nb b">cv2.CHAIN_APPROX_SIMPLE</code>只返回绘制等高线所需的端点。正如你在上面看到的，这个函数给出了图像，检测到的轮廓和它们的层次作为输出。</p><p id="b63b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">返回的等高线是由等高线组成的点的列表。为了画出图形的外部线条，我们将按面积对轮廓进行排序。选中轮廓线后，<code class="fe nn no np nb b">cv2.drawContours()</code>将描绘出边界线和如下所示的点。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b970" class="nf me iq nb b gy ng nh l ni nj"># Sort the contours <br/>contours = sorted(contours, key = cv2.contourArea, reverse = True)</span><span id="f19f" class="nf me iq nb b gy nl nh l ni nj"># Draw the contour <br/>img_copy = img.copy()<br/>final = <strong class="nb ir">cv2.drawContours(</strong>img_copy, contours, contourIdx = -1, <br/>                         color = (255, 0, 0), thickness = 2<strong class="nb ir">)</strong><br/>plt.imshow(img_copy)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/16295535909082ec48d5af7473c8b11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*ulXyqlK5LAVhgHe3i4HsKA.png"/></div></figure><p id="7df3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单吧？虽然底部也加了阴影，但是结局还是蛮满意的。</p><h1 id="ab42" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">关于轮廓的更多信息</h1><p id="0dfb" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我们可以对轮廓做更多的事情。借助于图像矩的概念，我们可以找到图像的质心或计算边界场的面积。一瞬间在这里意味着什么？单词<em class="mc">‘moment’</em>在通常用法中是一小段时间。但在物理学术语中，一个<a class="ae lw" href="https://en.wikipedia.org/wiki/Moment_(physics)" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">矩</strong> </a>是距离和另一个物理量的乘积，意味着一个物理量是如何分布或定位的。所以在计算机视觉中，<a class="ae lw" href="https://en.wikipedia.org/wiki/Image_moment" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">图像矩</strong> </a>就是图像像素强度是如何根据位置分布的。它是图像像素强度的加权平均值，我们可以从图像矩中获得质心或空间信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4a3bcb093ad76c6f4caf223dcb2269b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMU_8F-NDbeLbIy8sFj9UA.png"/></div></div></figure><p id="465e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有三种类型的矩-空间矩、中心矩和中心归一化矩。我们可以用 OpenCV 中的函数<code class="fe nn no np nb b">cv2.moments()</code>得到图像的矩，它返回 24 个不同的矩。如果您打印如下所示的输出<code class="fe nn no np nb b">M</code>，它将以字典格式返回 24 个时刻。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="38fe" class="nf me iq nb b gy ng nh l ni nj"># The first order of the contours<br/>c_0 = contours[0]</span><span id="d3da" class="nf me iq nb b gy nl nh l ni nj"># image moment<br/>M = cv2.moments(c_0)<br/>print(M.keys())</span></pre><p id="5e71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想在这里把重点放在图像时刻的实现上。如果你有兴趣，可以在本文末尾找到额外的阅读资源。</p><p id="8d96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了得到轮廓的面积，我们可以实现函数<code class="fe nn no np nb b">cv2.contourArea()</code>。为什么我们不在这里尝试几种轮廓？如果您输入第一个、第二个和第三个轮廓，您将得到如下所示的递减值。这表明轮廓检测算法形成了检测到的边界的层次。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="24e6" class="nf me iq nb b gy ng nh l ni nj"># The area of contours <br/>print("1st Contour Area : ", cv2.contourArea(contours[0])) # 37544.5<br/>print("2nd Contour Area : ", cv2.contourArea(contours[1])) # 75.0<br/>print("3rd Contour Area : ", cv2.contourArea(contours[2])) # 54.0</span></pre><p id="a5a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">轮廓的弧长可以通过函数<code class="fe nn no np nb b">cv2.arcLength()</code>得到。参数<code class="fe nn no np nb b">closed</code>指示曲线是否应该闭合。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="514c" class="nf me iq nb b gy ng nh l ni nj"># The arc length of contours <br/>print(cv2.arcLength(contours[0], closed = True))      # 2473.3190<br/>print(cv2.arcLength(contours[0], closed = False))  <strong class="nb ir">  </strong> # 2472.3190</span></pre><p id="b357" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们试着画出菠萝的质心和极值点。我们可以用下面的公式得到质心点。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="79b2" class="nf me iq nb b gy ng nh l ni nj"># The centroid point<br/>cx = int(M['m10'] / M['m00'])<br/>cy = int(M['m01'] / M['m00'])</span></pre><p id="d382" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">极值是左边和右边、顶部和底部的端点。并且我们可以把 x 和 y 坐标分别排列如下。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="dd70" class="nf me iq nb b gy ng nh l ni nj"># The extreme points<br/>l_m = tuple(<strong class="nb ir">c_0[c_0[:, :, 0]</strong>.argmin()][0])<br/>r_m = tuple(<strong class="nb ir">c_0[c_0[:, :, 0]</strong>.argmax()][0])<br/>t_m = tuple(<strong class="nb ir">c_0[c_0[:, :, 1]</strong>.argmin()][0])<br/>b_m = tuple(<strong class="nb ir">c_0[c_0[:, :, 1]</strong>.argmax()][0])</span><span id="525f" class="nf me iq nb b gy nl nh l ni nj">pst = [l_m, r_m, t_m, b_m]<br/>xcor = [p[0] for p in pst]<br/>ycor = [p[1] for p in pst]</span></pre><p id="4f6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们在图像上绘制所有这些点。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="395c" class="nf me iq nb b gy ng nh l ni nj"># Plot the points<br/>plt.figure(figsize = (10, 16))<br/>plt.subplot(1, 2, 1)<br/>plt.imshow(image, cmap = 'gray')<br/>plt.scatter([cx], [cy], c = 'b', s = 50)</span><span id="fae1" class="nf me iq nb b gy nl nh l ni nj">plt.subplot(1, 2, 2)<br/>plt.imshow(image, cmap = 'gray')<br/>plt.scatter(xcor, ycor, c = 'b', s = 50)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/7718843ba2c16eaa83b2d5d1ac8015cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zh_AX-nV5T-1DqlM2j2mnw.png"/></div></div></figure><h1 id="e48a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">其他轮廓形状</h1><p id="418d" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">除了紧致轮廓，我们还可以画出一个图形的凸轮廓或矩形轮廓线。让我们先尝试一个直的矩形。有了外部轮廓线，我们将围绕对象绘制矩形。函数<code class="fe nn no np nb b">cv2.boundingRect()</code>返回边界框的 4 个点，如下所示。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="018e" class="nf me iq nb b gy ng nh l ni nj"># The first order of the contours<br/>c_0 = contours[0]</span><span id="b842" class="nf me iq nb b gy nl nh l ni nj"># Get the 4 points of the bounding rectangle<br/>x, y, w, h = cv2.boundingRect(c_0)</span><span id="896d" class="nf me iq nb b gy nl nh l ni nj"># Draw a straight rectangle with the points<br/>img_copy = img.copy()<br/>img_box = cv2.rectangle(img_copy, (x, y), (x+w, y+h), color = (255, 0, 0), thickness = 2)</span></pre><p id="1aa1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，这个直矩形不是其他可能边界中的最小值。我们可以用函数<code class="fe nn no np nb b">cv2.minAreaRect()</code>提取面积最小的矩形，该函数找到一个包含输入 2D 点集的旋转矩形。之后，我们得到这个矩形的四个角，并把它们放在<code class="fe nn no np nb b">contour</code>参数中，如下所示。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="c1ff" class="nf me iq nb b gy ng nh l ni nj"># Get the 4 points of the bounding rectangle with the minimum area<br/>rect = cv2.minAreaRect(c_0)<br/>box = cv2.boxPoints(rect)<br/>box = box.astype('int')</span><span id="c16d" class="nf me iq nb b gy nl nh l ni nj"># Draw a contour with the points <br/>img_copy = img.copy()<br/>img_box_2 = cv2.drawContours(img_copy, <strong class="nb ir">contours = [box]</strong>, <br/>                             contourIdx = -1, <br/>                             color = (255, 0, 0), thickness = 2)</span></pre><p id="552d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们检查结果并比较两个不同的轮廓框。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="6278" class="nf me iq nb b gy ng nh l ni nj">plt.figure(figsize = (10, 16))<br/>plt.subplot(1, 2, 1); plt.imshow(img_box)<br/>plt.subplot(1, 2, 2); plt.imshow(img_box_2)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/1eb3179c9df4a7c1a1d12f849d53772b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2veTSIBJBQCw9DmRFrDqg.png"/></div></div></figure><p id="06cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以使用<code class="fe nn no np nb b">cv2.convexHull()</code>功能绘制一个凸形轮廓。这需要一组点，并从给定的集合中返回凸包。在<code class="fe nn no np nb b">cv2.drawContours()</code>中输入这个返回的点为<code class="fe nn no np nb b">contours</code>，我们可以得到如下的凸轮廓。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="cb33" class="nf me iq nb b gy ng nh l ni nj"># Detect the convex contour<br/>hull = cv2.convexHull(c_0)</span><span id="3e53" class="nf me iq nb b gy nl nh l ni nj">img_copy = img.copy()<br/>img_hull = cv2.drawContours(img_copy, <strong class="nb ir">contours = [hull]</strong>, <br/>                            contourIdx = 0, <br/>                            color = (255, 0, 0), thickness = 2)<br/>plt.imshow(img_hull)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f32978faf7e9a32d1a8c9153a59dd255.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*wtJWfEVQUKyJ-7YullGDbw.png"/></div></figure><p id="d69a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在轮廓检测中有太多的事情要涉及。我鼓励你查看文档<a class="ae lw" href="https://docs.opencv.org/3.4.6/d3/d05/tutorial_py_table_of_contents_contours.html" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"/></a>并自己探索更多选项。</p><h1 id="9e24" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">掩蔽带来的一点乐趣</h1><p id="22d0" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">作为这个系列的最后一个练习，我想做一些有趣的图像遮罩。我们可以通过图像加法或位运算等算术运算将两幅不同的图像相加。所以我们最后的任务是把我们的菠萝先生系在一个男人的左肩上。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="7c13" class="nf me iq nb b gy ng nh l ni nj"># Import the large image<br/>backpacker = cv2.imread('images/backpacker.jpg')<br/>backpacker = cv2.cvtColor(backpacker, cv2.COLOR_BGR2RGB)<br/>plt.imshow(backpacker)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/cde113c815829d68a27d3c03ba962fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*GvVB4WgAgRc5WO5NqYZtrw.png"/></div></figure><p id="a611" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将从大图和小图中剪切出感兴趣的区域(肩部),如下所示。注意，这里两个图像的大小(图像的高度和宽度)应该是相同的。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="728c" class="nf me iq nb b gy ng nh l ni nj"># Crop the small image and the roi<br/>roi = backpacker[750:1150, 300:500]<br/>img_2 = img[40:440, 80:280]</span><span id="ef01" class="nf me iq nb b gy nl nh l ni nj">plt.figure(figsize = (6, 6))<br/>plt.subplot(1, 3, 1); plt.imshow(roi)<br/>plt.subplot(1, 3, 3); plt.imshow(img_2)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/5559ecf55ef243c01cff82da56638df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhEkPyj_3_e8HgMV05dSqQ.png"/></div></div></figure><p id="c494" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是为每张图片制作蒙版。我们要用掩码实现位运算，掩码应该是一个二进制图像。通过对小图像<code class="fe nn no np nb b">img_2</code>进行阈值处理，我们创建了蒙版。然后用<code class="fe nn no np nb b">cv2.bitwise_not()</code>，我们制作另一个和第一个完全相反的面具。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="7e35" class="nf me iq nb b gy ng nh l ni nj"># Creating the mask for the roi and small image<br/>img_gray = cv2.cvtColor(img_2, cv2.COLOR_RGB2GRAY)<br/>_, mask = cv2.threshold(img_gray, 254/2+100, 255, cv2.THRESH_BINARY)<br/>mask_inv = cv2.bitwise_not(mask)</span><span id="6fcc" class="nf me iq nb b gy nl nh l ni nj">plt.figure(figsize = (6, 6))<br/>plt.subplot(1, 3, 1); plt.imshow(mask, cmap = 'gray')<br/>plt.subplot(1, 3, 3); plt.imshow(mask_inv, cmap = 'gray')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/abef8c38f9169660ce5d68cd25de7bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVSrcLV0sK_WJJN8n7ErTA.png"/></div></div></figure><p id="edec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们实现函数<code class="fe nn no np nb b">cv2.bitwise_and()</code>和遮罩，它们将只通过图像的白色区域。因此，如果我们将第一个蒙版应用于<code class="fe nn no np nb b">roi</code>图像，我们可以从它设置背景图像。同样的，如果我们将第二个应用到<code class="fe nn no np nb b">img_2</code>图像，我们可以用水果制作前景图像。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="d9b2" class="nf me iq nb b gy ng nh l ni nj"># Masking <br/>img_bg = cv2.bitwise_and(roi, roi, mask = mask)<br/>img_fg = cv2.bitwise_and(img_2, img_2, mask = mask_inv)<br/>dst = cv2.add(img_fg, img_bg)</span><span id="b859" class="nf me iq nb b gy nl nh l ni nj">plt.figure(figsize = (10, 6))<br/>plt.subplot(1, 3, 1); plt.imshow(img_bg)<br/>plt.subplot(1, 3, 2); plt.imshow(img_fg)<br/>plt.subplot(1, 3, 3); plt.imshow(dst)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/eda3880407ec9dbd5d4565247ebe7f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLMJBoiVt_MkQlrTdpBw4w.png"/></div></div></figure><p id="21c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到底部的阴影，结果有点混乱，但让我们保持它。如果你想了解位运算是如何工作的，详细的解释可以在<a class="ae lw" href="https://stackoverflow.com/questions/44333605/what-does-bitwise-and-operator-exactly-do-in-opencv" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">这里</strong> </a>找到。现在，我们准备将这个组合图像附加到原始图像上。因此，我们可以简单地这样做，将<code class="fe nn no np nb b">dst</code>图像放在<code class="fe nn no np nb b">roi</code>位置，如下所示。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="f40e" class="nf me iq nb b gy ng nh l ni nj"># Final output<br/>backpacker[750:1150, 300:500] = dst<br/>display(backpacker)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/04f7e7ea23db6bc85752314f35a33b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*eBQDrL6BaspKXXfV1mxBgQ.png"/></div></figure><p id="51da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">😄👋祝你和背包客过得愉快！</p><h1 id="c223" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">摘要</h1><p id="1824" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">从第 1 部分到第 4 部分，我们已经学习了很多关于图像处理和计算机视觉的基础知识。到目前为止，你喜欢这些教程吗？我希望在阅读本系列文章的同时，您对这些技巧有了信心。</p><p id="a614" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您完全是图像处理的初学者，最初不熟悉 OpenCV 函数的术语和用法是正常的。最好的练习方法是自己实现所有这些。选择你喜欢的任何类型的图片，并从中获得乐趣。改变颜色模式，旋转和调整图像大小，遮罩并粘贴到不同的图像上。或者你也可以应用边缘、拐角和轮廓的检测技术。虽然通过组合几个预处理和尝试不同的参数来获得乐趣，但您可以在没有意识到的情况下更快地习惯 OpenCV 库。</p><h1 id="cf6c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">资源</h1><ul class=""><li id="2c2d" class="ln lo iq kt b ku mv kx mw la oa le ob li oc lm od lt lu lv bi translated"><a class="ae lw" href="https://en.wikipedia.org/wiki/Image_moment" rel="noopener ugc nofollow" target="_blank">维基百科上的图片瞬间</a></li><li id="fc30" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm od lt lu lv bi translated"><a class="ae lw" href="https://www.youtube.com/watch?v=AAbUfZD_09s&amp;t=71s" rel="noopener ugc nofollow" target="_blank">uda city 上的影像时刻课程</a></li><li id="b562" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm od lt lu lv bi translated"><a class="ae lw" href="https://www.learnopencv.com/shape-matching-using-hu-moments-c-python/" rel="noopener ugc nofollow" target="_blank">使用 Hu 矩的形状匹配(C++/Python) </a></li><li id="2db9" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm od lt lu lv bi translated"><a class="ae lw" href="https://www.learnopencv.com/find-center-of-blob-centroid-using-opencv-cpp-python/" rel="noopener ugc nofollow" target="_blank">使用 OpenCV (C++/Python)找到斑点的中心(质心)</a></li></ul><p id="4993" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有你想改正的错误吗？请与我们分享您的见解。我总是乐于交谈，所以请在下面留下评论，分享你的想法。我还在<a class="ae lw" href="https://www.linkedin.com/in/jiwon-jeong/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> LinkedIn </strong> </a>上分享有趣和有用的资源，欢迎随时关注并联系我。下次我会带来另一个有趣的故事。一如既往，敬请关注！😎</p></div></div>    
</body>
</html>