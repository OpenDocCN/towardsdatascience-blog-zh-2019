<html>
<head>
<title>Object-Oriented Programming and the magic of Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程和测试驱动开发的魔力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-oriented-programming-and-the-magic-of-test-driven-development-d377acae85fa?source=collection_archive---------14-----------------------#2019-08-26">https://towardsdatascience.com/object-oriented-programming-and-the-magic-of-test-driven-development-d377acae85fa?source=collection_archive---------14-----------------------#2019-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/37f480a0174d2b543cb02505664eaa9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*zxHd49fnNF3wxCDLFaYzeQ.jpeg"/></div></figure><p id="ccb7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kv kw kx ky b"><a class="ae kz" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">Python</a></code>是数据科学中最常用的编程语言之一。对于一些人来说，这是关于语言的灵活性和可读性，对于其他人来说，这是关于它相对较低的复杂性，对于大多数人来说，这是关于它的多面性。</p><p id="43f8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们称<code class="fe kv kw kx ky b"><a class="ae kz" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">Python</a></code>为<strong class="jz iu">多面语言</strong>，因为它允许你以四种不同的风格编码:<em class="la">功能性</em>、<em class="la">命令性</em>、<em class="la">面向对象</em>和<em class="la">过程性</em>。这些编码风格在形式上被称为<a class="ae kz" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener ugc nofollow" target="_blank">编程范例</a>，代表了一种基于语言特性对语言进行分类的方法。</p><p id="5b07" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">自从我开始了我的数据科学之旅，我就一直想更深入地研究<a class="ae kz" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> <em class="la">【面向对象编程(OOP) </em> </a>，所以我利用本周的博客帖子全力以赴。</p><h1 id="c2ba" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是面向对象编程(OOP)？</h1><p id="c083" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">正如我前面说过的，OOP 是一种建立在对象概念之上的编程范式。在计算机科学中，object 这个词可以指代不同的概念，但在最基本的层面上，它是由标识符引用的内存中的<a class="ae kz" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank">值。</a></p><p id="15d4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在面向对象的上下文中，对象是状态(变量)和行为(方法)的组合。面向对象方法的目标是通过<a class="ae kz" href="https://www.freecodecamp.org/news/object-oriented-programming-concepts-21bb035f7260/" rel="noopener ugc nofollow" target="_blank">四原则</a> : <em class="la">封装</em>、<em class="la">抽象</em>、<em class="la">继承</em>和<em class="la">多态</em>来创建更易于维护的可重用软件。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi me"><img src="../Images/d00e45fab4c2da1dcaa265df8f2c92c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dF7xdJ8zEOx4z1jPkr52-Q.png"/></div></div></figure><p id="9a1b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们还可以在面向对象语言内部进一步区分，比如<em class="la">基于类的</em>和<em class="la">基于原型的</em>。</p><p id="f883" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在基于类的 OOP 中，对象是一个类的实例。类是应该如何定义的蓝图，但它并不激活内容本身——它只是提供结构。</p><h1 id="2213" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">学习策略</h1><p id="2bce" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">学习和练习 OOP 的方法比我能想到的多得多，但我必须选择一种，所以我决定使用莎士比亚的《罗密欧与朱丽叶》的故事情节创建一个简单的基于文本的游戏。我的过程如下:</p><ol class=""><li id="c050" class="mn mo it jz b ka kb ke kf ki mp km mq kq mr ku ms mt mu mv bi translated">写这个故事</li><li id="0dba" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">画出问题</li><li id="3460" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">识别问题的实体——这些将是你的类</li><li id="109c" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">创建实体层次结构</li><li id="2c20" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">确定实体的责任</li><li id="3f1b" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">编写您的测试</li><li id="aa33" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">检查测试是否失败——最初会失败，因为您没有编写任何代码！</li><li id="059b" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">写代码</li><li id="8ac3" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">重复！重构！精炼！</li></ol><p id="ac94" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个过程不是一成不变的，我们也不应该成为它的奴隶。只是帮助我起步的一系列步骤。<strong class="jz iu">面向对象不仅仅是一种编程范式，它还是一种解决问题的方法</strong>，尽管它并非没有批评，但在构建复杂系统时，它是一个很好的选择。</p><h1 id="73b9" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">兔子洞</h1><p id="33db" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">请注意步骤 6:编写您的测试。现在，这不是我最初计划的一部分。我计划编码我的类，就是这样！但是在我研究 OOP 的时候，我遇到了测试驱动<a class="ae kz" href="https://www.guru99.com/test-driven-development.html" rel="noopener ugc nofollow" target="_blank"> <em class="la">开发</em> </a> <em class="la"> (TDD) </em>的概念。</p><p id="41e3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">TDD 是一种编程实践，它始于为程序的每个功能设计和开发测试。这种方式迫使你在开始写代码之前考虑规范、需求或设计。<strong class="jz iu">换句话说，你写代码是为了在你写任何代码之前测试你的代码。</strong></p><p id="aa5c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">迷茫？我也是。但是做这个练习 100%值得。</strong></p><h1 id="354f" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试驱动的开发和单元测试</h1><p id="e41b" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">TDD 的过程非常简单:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nb"><img src="../Images/39dd049ea45f147d7927f77727844694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gi4NPFboHsUXnXid25hTvg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk"><a class="ae kz" href="https://www.guru99.com/test-driven-development.html" rel="noopener ugc nofollow" target="_blank">Image from Kanchan Kulkarni’s TDD Tutorial.</a></figcaption></figure><ol class=""><li id="04b5" class="mn mo it jz b ka kb ke kf ki mp km mq kq mr ku ms mt mu mv bi translated">写一个测试</li><li id="02f8" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">运行测试</li><li id="0a9a" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">写一些代码</li><li id="cda6" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">运行测试</li><li id="e346" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">重构代码</li><li id="51df" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ms mt mu mv bi translated">重复</li></ol><p id="8761" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我的例子中，我使用<a class="ae kz" href="http://softwaretestingfundamentals.com/unit-testing/" rel="noopener ugc nofollow" target="_blank"> <em class="la">单元测试</em> </a>进行 TDD。单元测试是软件测试的第一级，目的是验证程序中的每个单元都按照设计执行。有不同的框架来执行单元测试，我用的是<code class="fe kv kw kx ky b"><a class="ae kz" href="https://docs.python.org/3/library/unittest.html#module-unittest" rel="noopener ugc nofollow" target="_blank">unittest</a></code>。</p><p id="360c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当谈到 TDD 时，你会发现人们站在两边。我亲身经历的一些好处如下:</p><ul class=""><li id="7268" class="mn mo it jz b ka kb ke kf ki mp km mq kq mr ku ng mt mu mv bi translated">强迫你在开始毫无目的地输入代码之前思考你试图解决的问题。</li><li id="7a5f" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ng mt mu mv bi translated">在基于类的 OOP 的特殊情况下，它帮助你理解每个类的契约。他们的职责是什么？他们需要知道什么？—当您的目标是低耦合和高内聚时，这变得更加重要。</li><li id="1a58" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ng mt mu mv bi translated">尽管一开始它可能会降低您的速度，但从长远来看，它通过最大限度地减少调试时间来节省您的时间。</li><li id="7be4" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ng mt mu mv bi translated">它鼓励更好的设计，使代码更容易维护，更少冗余(保持干燥！)，并且在需要时可以安全地重构。</li><li id="7b4a" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ng mt mu mv bi translated">它可以作为活的文档——仅仅通过查看测试，您就可以理解每个单元应该做什么，使代码不言自明。</li></ul><h1 id="f69b" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">罗密欧与朱丽叶——代码和测试</h1><p id="a743" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">在思考了游戏的故事之后，我决定有两条不同的故事线<strong class="jz iu">经典</strong>和<strong class="jz iu">另类</strong>。第一个是我们所知道的罗密欧与朱丽叶的故事，第二个，嗯，不是。</p><p id="1bc3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">故事中的实体(我将用它作为创建不同类的参考)如下:</p><ul class=""><li id="1748" class="mn mo it jz b ka kb ke kf ki mp km mq kq mr ku ng mt mu mv bi translated"><strong class="jz iu">场景:</strong>假面舞会，阳台，决斗，编曲，药剂师，凯普莱特墓，另类结局。场景有两个主要的职责，为玩家描述场景，然后提示玩家一个是或否的问题，以获得他们的输入。</li><li id="e681" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ng mt mu mv bi translated"><strong class="jz iu">Map:</strong>Map 作为<a class="ae kz" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton" rel="noopener ugc nofollow" target="_blank"> <em class="la">有限状态机</em> </a>工作。它有有限数量的状态(场景)，一个转换函数(从一个场景移动到另一个场景)，和一个开始状态(第一个场景)。</li><li id="58b8" class="mn mo it jz b ka mw ke mx ki my km mz kq na ku ng mt mu mv bi translated"><strong class="jz iu">故事情节:</strong>为故事情节定义两个唯一的常量值。</li></ul><p id="9744" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从场景的定义可以看出，所有场景的职责都是一样的，只有它们的内容发生了变化(场景的描述和提示)。这就是为什么我们将使用<code class="fe kv kw kx ky b"><a class="ae kz" href="https://docs.python.org/3/tutorial/classes.html" rel="noopener ugc nofollow" target="_blank">inheritance</a></code>的概念。这个概念允许我们<strong class="jz iu">定义一个从另一个类</strong>继承所有方法和属性的类；在这种情况下，最重要的是<strong class="jz iu">保持代码干燥</strong>。</p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5873" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于故事情节类，我用了<code class="fe kv kw kx ky b"><a class="ae kz" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">Python’s </a><a class="ae kz" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">enumeration type</a></code>或者<code class="fe kv kw kx ky b"><a class="ae kz" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">enum</a></code>。在文档中，它们被定义为“<em class="la">”一组绑定到唯一的常量值的符号名(成员)。在枚举中，成员可以通过标识进行比较，并且枚举本身可以被迭代。</em>”</p><p id="5ce4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们有了<code class="fe kv kw kx ky b">Scene class</code>和<code class="fe kv kw kx ky b">TestScene class</code>。测试代码中两个值得注意的特征:1 .一个<code class="fe kv kw kx ky b">MockMap class</code>的使用；2.创造一个<code class="fe kv kw kx ky b">TestScene class</code>来测试这个<code class="fe kv kw kx ky b">Scene class</code>。在单元测试级别，您将创建一个<code class="fe kv kw kx ky b">Test class</code>来为您的每个类编写测试。</p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ded8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，但同样重要的是，让我们看看<code class="fe kv kw kx ky b">Map class</code>和<code class="fe kv kw kx ky b">TestMap class</code>。就像之前一样，我们为<code class="fe kv kw kx ky b">Scene class</code>创建了一个 mock，但在本例中是用<code class="fe kv kw kx ky b">MockScene class</code>创建的。</p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="32c0" class="lb lc it bd ld le nq lg lh li nr lk ll lm ns lo lp lq nt ls lt lu nu lw lx ly bi translated">结论</h1><p id="17bb" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">首先编写测试，然后编写程序代码的练习并不是没有困难的。</p><p id="d60b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我不否认我曾经想过放弃整个测试的想法，但是当我在这个过程中坚持下来的时候，我发现自己更像一个程序员，花更多的时间思考设计，并且在某种程度上，<strong class="jz iu">从脚本升级到编码</strong>。</p><p id="694b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我邀请你来测试一下(<strong class="jz iu">双关语！</strong>)。并且<strong class="jz iu">请</strong>，如果你在学习 TDD 的时候有不同的感受或者有其他的经历，请一定要伸出手来谈论它。</p></div></div>    
</body>
</html>