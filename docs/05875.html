<html>
<head>
<title>Image Object detection with Tensorflow-js 🤔</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Tensorflow-js 的图像目标检测🤔</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-object-detection-with-tensorflow-js-b8861119ed46?source=collection_archive---------7-----------------------#2019-08-27">https://towardsdatascience.com/image-object-detection-with-tensorflow-js-b8861119ed46?source=collection_archive---------7-----------------------#2019-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/5c94c9f029bcb55e7e77e37b9d6d1bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_goV6BV1jk2gdkPf9MlAXg.png"/></div></figure><p id="8173" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是图像处理系列从零到一的第四篇帖子。</p><p id="b82d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是其他帖子的列表</p><ol class=""><li id="fbcb" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated"><a class="ae le" href="https://overflowjs.com/posts/Image-Processing-OpenCV-and-Nodejs-Part-3.html" rel="noopener ugc nofollow" target="_blank">图像处理— OpenCV 和 Node.js(第三部分)</a></li><li id="5e1e" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated"><a class="ae le" href="https://overflowjs.com/posts/Image-Processing-Making-Custom-Filters-Reactjs-Part-2.html" rel="noopener ugc nofollow" target="_blank">图像处理—制作自定义滤镜— React.js —第二部分</a></li><li id="17e0" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated"><a class="ae le" href="https://overflowjs.com/posts/Image-Processing-In-Reactjs-Part-1.html" rel="noopener ugc nofollow" target="_blank">使用 Cloundinary 的图像处理(第一部分)</a></li></ol><p id="e5b5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我们将使用 Tensorflow-js 和预训练的模型构建一个图像对象检测系统。</p><p id="3892" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，在网页中部署 TensorFlow 有很多方法，其中一种方法是包含 ml5js。参观 https://ml5js.org/。它是 tf.js 的包装器，一个张量流和 p5.js 库，用于在 Html 元素中进行操作。</p><p id="0271" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是，我们希望保持后端部分的电源，以便我可以尝试使用 API 的后端进程等在后端运行这些模型。</p><p id="7d5f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，在本文的前半部分，我们将使用 React.js 和 Material-UI 创建一个 UI，在后半部分，我们将在 Node.js 中创建一个 API 来支持这个 UI。</p><p id="1f83" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们从构建一个示例 React 项目开始。🚀</p><h1 id="157f" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">前端部分:-</h1><p id="958a" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">如果您遵循了我的前一篇文章，那么 react 项目似乎很容易构建。</p><ol class=""><li id="9647" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">打开终端，做</li></ol><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e3d0" class="mw ll it ms b gy mx my l mz na">create-react-app image_classification_react_ui</span></pre><p id="54c6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将创建一个 react 项目来使用。</p><p id="f3c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.让我们安装所需的依赖项</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0c29" class="mw ll it ms b gy mx my l mz na">npm install @material-ui/core<br/>npm install — save isomorphic-fetch es6-promise</span></pre><blockquote class="nb nc nd"><p id="47af" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">注意:从 React 代码调用对象检测 API 端点需要同构提取。</p></blockquote><p id="a050" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">3.在你最喜欢的编辑器中打开项目，让我们创建两个文件夹</p><ol class=""><li id="7c82" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated"><strong class="jz iu">容器</strong> —这将包含一个文件— <code class="fe ni nj nk ms b">ImageOps.jsx</code>，其中包含所有的前端 UI 代码。</li><li id="93b5" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated"><strong class="jz iu"> utils </strong> —这将包含一个文件<code class="fe ni nj nk ms b">Api.js</code>，用于调用对象检测端点。</li></ol><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9bb9" class="mw ll it ms b gy mx my l mz na">└── src<br/>    ├── containers<br/>        ├── ImageOps.jsx<br/>    ├── utils<br/>        ├── Api.js</span></pre><p id="7bb1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们研究一下<code class="fe ni nj nk ms b">ImageOps.jsx</code>代码并理解它。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8df2" class="mw ll it ms b gy mx my l mz na">import React from 'react';<br/> <br/>import Container from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Container';<br/>import Grid from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Grid';<br/> <br/>import Card from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Card';<br/>import CardContent from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/CardContent';<br/>import Typography from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Typography';<br/>import Button from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Button';<br/>import { red } from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/colors';<br/> <br/>import {api} from '../utils/Api';<br/> <br/>import Table from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Table';<br/>import TableBody from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/TableBody';<br/>import TableCell from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/TableCell';<br/>import TableHead from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/TableHead';<br/>import TableRow from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/TableRow';<br/>import Paper from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Paper';<br/>import CircularProgress from '<a class="ae le" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/CircularProgress';<br/> <br/> <br/>export default class ImageOps extends React.Component {<br/>  <br/>   constructor(props) {<br/>       super(props);<br/> <br/>       this.state = {<br/>           image_object: null,<br/>           image_object_details: {},<br/>           active_type: null<br/>       }<br/>   }<br/> <br/>   updateImageObject(e) {<br/>       const file  = e.target.files[0];<br/>       const reader = new FileReader();<br/>      <br/>       reader.readAsDataURL(file);<br/>       reader.onload = () =&gt; {<br/>           this.setState({image_object: reader.result, image_object_details: {}, active_type: null});<br/>       };<br/> <br/>   }<br/> <br/>   processImageObject(type) {<br/> <br/>       this.setState({active_type: type}, () =&gt; {<br/> <br/>           if(!this.state.image_object_details[this.state.active_type]) {<br/>               api("detect_image_objects", {<br/>                   type,<br/>                   data: this.state.image_object<br/>               }).then((response) =&gt; {<br/>                  <br/>                   const filtered_data = response;<br/>                   const image_details = this.state.image_object_details;<br/>      <br/>                   image_details[filtered_data.type] = filtered_data.data;<br/>      <br/>                   this.setState({image_object_details: image_details });<br/>               });<br/>           }<br/>       });<br/>   }<br/> <br/>   render() {<br/>       return (<br/>           &lt;Container maxWidth="md"&gt;<br/>               &lt;Grid container spacing={2}&gt;<br/>                   &lt;Grid item xs={12}&gt;<br/>                       &lt;CardContent&gt;<br/>                           &lt;Typography variant="h4" color="textPrimary" component="h4"&gt;<br/>                               Object Detection Tensorflow<br/>                           &lt;/Typography&gt;<br/>                       &lt;/CardContent&gt;<br/>                   &lt;/Grid&gt;<br/>                   &lt;Grid item xs={12}&gt;<br/>                       {this.state.image_object &amp;&amp;<br/>                           &lt;img src={this.state.image_object} alt="" height="500px"/&gt;<br/>                       }<br/>                   &lt;/Grid&gt;<br/>                   &lt;Grid item xs={12}&gt;<br/>                       &lt;Card&gt;<br/>                           &lt;CardContent&gt;<br/>                               &lt;Button variant="contained"<br/>                                   component='label' // &lt;-- Just add me!<br/>                                   &gt;<br/>                                   Upload Image<br/>                                   &lt;input accept="image/jpeg" onChange={(e) =&gt;  this.updateImageObject(e)} type="file" style={{ display: 'none' }} /&gt;<br/>                               &lt;/Button&gt;<br/>                           &lt;/CardContent&gt;<br/>                       &lt;/Card&gt;<br/>                   &lt;/Grid&gt;<br/>                   &lt;Grid item xs={3}&gt;<br/>                       &lt;Grid container justify="center" spacing={3}&gt;<br/>                           &lt;Grid item &gt;<br/>                               {this.state.image_object &amp;&amp; &lt;Button onClick={() =&gt; this.processImageObject("imagenet")}variant="contained" color="primary"&gt;<br/>                                   Get objects with ImageNet<br/>                               &lt;/Button&gt;}<br/>                           &lt;/Grid&gt;<br/>                           &lt;Grid item&gt;<br/>                               {this.state.image_object &amp;&amp; &lt;Button onClick={() =&gt; this.processImageObject("coco-ssd")}variant="contained" color="secondary"&gt;<br/>                                   Get objects with Coco SSD<br/>                               &lt;/Button&gt;}<br/>                           &lt;/Grid&gt;<br/>                       &lt;/Grid&gt;<br/>                   &lt;/Grid&gt;<br/>                   &lt;Grid item xs={9}&gt;<br/>                       &lt;Grid container justify="center"&gt;<br/>                           {this.state.active_type &amp;&amp; this.state.image_object_details[this.state.active_type] &amp;&amp;<br/>                               &lt;Grid item xs={12}&gt;<br/>                                   &lt;Card&gt;<br/>                                       &lt;CardContent&gt;<br/>                                           &lt;Typography variant="h4" color="textPrimary" component="h4"&gt;<br/>                                               {this.state.active_type.toUpperCase()}<br/>                                           &lt;/Typography&gt;<br/>                                           &lt;ImageDetails type={this.state.active_type} data = {this.state.image_object_details[this.state.active_type]}&gt;&lt;/ImageDetails&gt;<br/>                                       &lt;/CardContent&gt;<br/>                                   &lt;/Card&gt;<br/>                               &lt;/Grid&gt;<br/>                           }<br/>                           {this.state.active_type &amp;&amp; !this.state.image_object_details[this.state.active_type] &amp;&amp;<br/>                               &lt;Grid item xs={12}&gt;<br/>                                   &lt;CircularProgress<br/>                                       color="secondary"<br/>                                   /&gt;<br/>                               &lt;/Grid&gt;<br/>                           }<br/>                       &lt;/Grid&gt;<br/>                   &lt;/Grid&gt;<br/>               &lt;/Grid&gt;<br/>           &lt;/Container&gt;<br/>       )<br/>   }<br/>}<br/> <br/>class ImageDetails extends React.Component {<br/>  <br/>   render() {<br/> <br/>       console.log(this.props.data);<br/> <br/>       return (<br/>           &lt;Grid item xs={12}&gt;<br/>               &lt;Paper&gt;<br/>                   &lt;Table&gt;<br/>                   &lt;TableHead&gt;<br/>                       &lt;TableRow&gt;<br/>                       &lt;TableCell&gt;Objects&lt;/TableCell&gt;<br/>                       &lt;TableCell align="right"&gt;Probability&lt;/TableCell&gt;<br/>                       &lt;/TableRow&gt;<br/>                   &lt;/TableHead&gt;<br/>                   &lt;TableBody&gt;<br/>                       {this.props.data.map((row) =&gt; {<br/>                           if (this.props.type === "imagenet") {<br/>                               return (<br/>                                   &lt;TableRow key={row.className}&gt;<br/>                                       &lt;TableCell component="th" scope="row"&gt;<br/>                                       {row.className}<br/>                                       &lt;/TableCell&gt;<br/>                                       &lt;TableCell align="right"&gt;{row.probability.toFixed(2)}&lt;/TableCell&gt;<br/>                                   &lt;/TableRow&gt;<br/>                               )<br/>                           } else if(this.props.type === "coco-ssd") {<br/>                               return (<br/>                                   &lt;TableRow key={row.className}&gt;<br/>                                       &lt;TableCell component="th" scope="row"&gt;<br/>                                       {row.class}<br/>                                       &lt;/TableCell&gt;<br/>                                       &lt;TableCell align="right"&gt;{row.score.toFixed(2)}&lt;/TableCell&gt;<br/>                                   &lt;/TableRow&gt;<br/>                               )<br/>                           }<br/>                           })<br/>                       }<br/>                   &lt;/TableBody&gt;<br/>                   &lt;/Table&gt;<br/>               &lt;/Paper&gt;<br/>            <br/>           &lt;/Grid&gt;<br/>       )<br/>   }<br/>}<br/> <br/>}</span></pre><blockquote class="nb nc nd"><p id="18f4" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">注:这里是上面的 Github repo 链接—<a class="ae le" href="https://github.com/overflowjs-com/image_object_detction_react_ui" rel="noopener ugc nofollow" target="_blank">https://Github . com/overflow js-com/image _ object _ det ction _ react _ ui</a>。如果你觉得理解很难，那么我强烈推荐你阅读我们的第 2 部分和第 1 部分。</p></blockquote><p id="2366" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在渲染中，我们创建了一个三行的网格，其中一行包含标题</p><p id="a366" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">第二，包含要显示的图像</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3c4f" class="mw ll it ms b gy mx my l mz na">&lt;Grid item xs={12}&gt;<br/>  {this.state.image_object &amp;&amp;<br/>    &lt;img src={this.state.image_object} alt="" height="500px"/&gt;}                <br/>&lt;/Grid&gt;</span></pre><p id="c413" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果图像已经上传或图像对象处于可用状态，我们将在此显示图像</p><p id="2d18" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下一个网格包含一个按钮，用于上传文件并将上传的文件更新到当前状态。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ca7f" class="mw ll it ms b gy mx my l mz na">&lt;Grid item xs={12}&gt;<br/>    &lt;Card&gt;<br/>        &lt;CardContent&gt;<br/>            &lt;Button variant="contained"<br/>                component='label' // &lt;-- Just add me!<br/>                &gt;<br/>                Upload Image<br/>                &lt;input accept="image/jpeg" onChange={(e) =&gt;  this.updateImageObject(e)} type="file" style={{ display: 'none' }} /&gt;<br/>            &lt;/Button&gt;<br/>        &lt;/CardContent&gt;<br/>    &lt;/Card&gt;<br/>&lt;/Grid&gt;</span></pre><p id="c79b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们调用了一个函数<code class="fe ni nj nk ms b">updateImage</code>来更新状态下当前选中的图像。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="fcf2" class="mw ll it ms b gy mx my l mz na">updateImageObject(e) {<br/>       const file  = e.target.files[0];<br/>       const reader = new FileReader();<br/>      <br/>       reader.readAsDataURL(file);<br/>       reader.onload = () =&gt; {<br/>           this.setState({image_object: reader.result, image_object_details: {}, active_type: null<br/>           });<br/>       };<br/>}</span></pre><p id="5570" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在上面的代码中，我们从文件输入上传器中读取当前文件对象，并在当前状态下加载它的数据。随着新图像的上传，我们正在重置 image_object_details 和 active_type，以便可以对上传的图像应用新的操作</p><p id="8cb3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是下一个网格，包含每个模型的两个按钮的代码。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bea1" class="mw ll it ms b gy mx my l mz na">&lt;Grid item xs={3}&gt;<br/>        &lt;Grid container justify="center" spacing={3}&gt;<br/>            &lt;Grid item &gt;<br/>                {this.state.image_object &amp;&amp; &lt;Button onClick={() =&gt; this.processImageObject("imagenet")}variant="contained" color="primary"&gt;<br/>                    Get objects with ImageNet<br/>                &lt;/Button&gt;}<br/>            &lt;/Grid&gt;<br/>            &lt;Grid item&gt; <br/>                {this.state.image_object &amp;&amp; &lt;Button onClick={() =&gt; this.processImageObject("coco-ssd")}variant="contained" color="secondary"&gt;<br/>                    Get objects with Coco SSD<br/>                &lt;/Button&gt;}<br/>            &lt;/Grid&gt;<br/>        &lt;/Grid&gt;<br/>    &lt;/Grid&gt;<br/>    &lt;Grid item xs={9}&gt;<br/>        &lt;Grid container justify="center"&gt;<br/>            {this.state.active_type &amp;&amp; this.state.image_object_details[this.state.active_type] &amp;&amp;<br/>                &lt;Grid item xs={12}&gt;<br/>                    &lt;Card&gt;<br/>                        &lt;CardContent&gt;<br/>                            &lt;Typography variant="h4" color="textPrimary" component="h4"&gt;<br/>                                {this.state.active_type.toUpperCase()}<br/>                            &lt;/Typography&gt;<br/>                            &lt;ImageDetails data = {this.state.image_object_details[this.state.active_type]}&gt;&lt;/ImageDetails&gt;<br/>                        &lt;/CardContent&gt;<br/>                    &lt;/Card&gt;<br/>                &lt;/Grid&gt;<br/>            }<br/>            {this.state.active_type &amp;&amp; !this.state.image_object_details[this.state.active_type] &amp;&amp; <br/>                &lt;Grid item xs={12}&gt;<br/>                    &lt;CircularProgress<br/>                        color="secondary"<br/>                    /&gt;<br/>                &lt;/Grid&gt;<br/>            }<br/>     &lt;/Grid&gt;<br/>&lt;/Grid&gt;</span></pre><p id="c468" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这里，我们将网格从 12 列父网格分为 3 列和 9 列两部分。</p><p id="67d8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">第一个有 3 列的网格包含两个有两个按钮的网格</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="39b3" class="mw ll it ms b gy mx my l mz na">&lt;Grid container justify="center" spacing={3}&gt;<br/>    &lt;Grid item &gt;<br/>        {this.state.image_object &amp;&amp; &lt;Button onClick={() =&gt; this.processImageObject("imagenet")}variant="contained" color="primary"&gt;<br/>            Get objects with ImageNet<br/>        &lt;/Button&gt;}<br/>    &lt;/Grid&gt;<br/>    &lt;Grid item&gt; <br/>        {this.state.image_object &amp;&amp; &lt;Button onClick={() =&gt; this.processImageObject("coco-ssd")}variant="contained" color="secondary"&gt;<br/>            Get objects with Coco SSD<br/>        &lt;/Button&gt;}<br/>    &lt;/Grid&gt;<br/>&lt;/Grid&gt;</span></pre><blockquote class="nb nc nd"><p id="fde4" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">我们正在使用<strong class="jz iu"> ImageNet 和 Coco SSD 型号</strong>分析图像检测，并比较输出。</p></blockquote><p id="f0ff" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每个按钮都有一个动作事件 onClick，它调用一个函数<code class="fe ni nj nk ms b">processImageObject()</code>,该函数将模型的名称作为参数。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="fe31" class="mw ll it ms b gy mx my l mz na">processImageObject(type) {</span><span id="a29d" class="mw ll it ms b gy nl my l mz na">this.setState({active_type: type}, () =&gt; {<br/>        api("detect_image_objects", {<br/>            type,<br/>            data: this.state.image_object<br/>        }).then((response) =&gt; {<br/>            <br/>            const filtered_data = response;<br/>            const image_details = this.state.image_object_details;</span><span id="dcda" class="mw ll it ms b gy nl my l mz na">image_details[filtered_data.type] = filtered_data.data;</span><span id="4d7d" class="mw ll it ms b gy nl my l mz na">this.setState({image_object_details: image_details });<br/>        });<br/>    });<br/>}</span></pre><p id="bc9d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们正在用当前选择的模态设置状态对象<code class="fe ni nj nk ms b">action_type</code>。</p><p id="431f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Process image 对象函数将从 state 中获取当前图像，并将其发送给 API 函数，我接下来将向您展示该函数，API 将被调用<code class="fe ni nj nk ms b">detect_image_objects</code>，作为响应，我们将在 UI 中进行处理和显示。</p><p id="4ea0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">将从 API 获取响应，并在阶段<code class="fe ni nj nk ms b">image_object_details</code>中设置。</p><p id="bc98" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们根据型号类型<strong class="jz iu"> (imagenet/coco-ssd) </strong>设置每个 API 响应</p><p id="38d4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该按钮仅在<code class="fe ni nj nk ms b">image_object</code>处于该状态时可见。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7d75" class="mw ll it ms b gy mx my l mz na">{<br/> this.state.image_object &amp;&amp; <br/> &lt;Button onClick={() =&gt; this.processImageObject()} variant="contained" color="primary"&gt;Process Image <br/> &lt;/Button&gt;<br/>}</span></pre><p id="713e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是我们创建的另一个网格:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1e42" class="mw ll it ms b gy mx my l mz na">&lt;Grid item xs={9}&gt;<br/>    &lt;Grid container justify="center"&gt;<br/>        {this.state.active_type &amp;&amp; this.state.image_object_details[this.state.active_type] &amp;&amp;<br/>            &lt;Grid item xs={12}&gt;<br/>                &lt;Card&gt;<br/>                    &lt;CardContent&gt;<br/>                        &lt;Typography variant="h4" color="textPrimary" component="h4"&gt;<br/>                            {this.state.active_type.toUpperCase()}<br/>                        &lt;/Typography&gt;<br/>                        &lt;ImageDetails  type={this.state.active_type} data = {this.state.image_object_details[this.state.active_type]}&gt;&lt;/ImageDetails&gt;<br/>                    &lt;/CardContent&gt;<br/>                &lt;/Card&gt;<br/>            &lt;/Grid&gt;<br/>        }<br/>        {this.state.active_type &amp;&amp; !this.state.image_object_details[this.state.active_type] &amp;&amp; <br/>            &lt;Grid item xs={12}&gt;<br/>                &lt;CircularProgress<br/>                    color="secondary"<br/>                /&gt;<br/>            &lt;/Grid&gt;<br/>        }<br/>    &lt;/Grid&gt;<br/>&lt;/Grid&gt;</span></pre><p id="24a8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们已经检查了当前的<code class="fe ni nj nk ms b">action_type</code>模式是否被选中，如果 API 已经处理了细节，它将显示对象细节。为此，我们创建了一个组件<code class="fe ni nj nk ms b">ImageDetails</code>。</p><p id="22bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看<code class="fe ni nj nk ms b">ImageDetails</code>组件代码，它很容易理解。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e8d1" class="mw ll it ms b gy mx my l mz na">class ImageDetails extends React.Component {<br/>  <br/>   render() {<br/> <br/>       console.log(this.props.data);<br/> <br/>       return (<br/>           &lt;Grid item xs={12}&gt;<br/>               &lt;Paper&gt;<br/>                   &lt;Table&gt;<br/>                   &lt;TableHead&gt;<br/>                       &lt;TableRow&gt;<br/>                       &lt;TableCell&gt;Objects&lt;/TableCell&gt;<br/>                       &lt;TableCell align="right"&gt;Probability&lt;/TableCell&gt;<br/>                       &lt;/TableRow&gt;<br/>                   &lt;/TableHead&gt;<br/>                   &lt;TableBody&gt;<br/>                       {this.props.data.map((row) =&gt; {<br/>                           if (this.props.type === "imagenet") {<br/>                               return (<br/>                                   &lt;TableRow key={row.className}&gt;<br/>                                       &lt;TableCell component="th" scope="row"&gt;<br/>                                       {row.className}<br/>                                       &lt;/TableCell&gt;<br/>                                       &lt;TableCell align="right"&gt;{row.probability.toFixed(2)}&lt;/TableCell&gt;<br/>                                   &lt;/TableRow&gt;<br/>                               )<br/>                           } else if(this.props.type === "coco-ssd") {<br/>                               return (<br/>                                   &lt;TableRow key={row.className}&gt;<br/>                                       &lt;TableCell component="th" scope="row"&gt;<br/>                                       {row.class}<br/>                                       &lt;/TableCell&gt;<br/>                                       &lt;TableCell align="right"&gt;{row.score.toFixed(2)}&lt;/TableCell&gt;<br/>                                   &lt;/TableRow&gt;<br/>                               )<br/>                           }<br/>                           })<br/>                       }<br/>                   &lt;/TableBody&gt;<br/>                   &lt;/Table&gt;<br/>               &lt;/Paper&gt;<br/>            <br/>           &lt;/Grid&gt;<br/>       )<br/>   }<br/>}</span></pre><p id="8821" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该组件将显示从对象的模态名称接收的详细信息及其概率。基于我们正在处理的模态的类型，我们可以显示在这个类中处理的两个不同的输出。</p><p id="b5ac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">4.最后一步是编写 API.js 包装器进行服务器端调用。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6779" class="mw ll it ms b gy mx my l mz na">import fetch from  'isomorphic-fetch';<br/><br/>const BASE_API_URL = "<a class="ae le" href="http://localhost:4000/api/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/api/</a>"<br/> <br/>export function api(api_end_point, data) {<br/> <br/>   return fetch(BASE_API_URL+api_end_point,<br/>       {<br/>           method: 'POST',<br/>           headers: {<br/>               'Content-Type': 'application/json'<br/>           },<br/>           body:JSON.stringify(data)<br/>       }).then((response) =&gt; {<br/>           return response.json();<br/>       });<br/>}</span></pre><p id="cea5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个示例代码中，我们提供了一个通过获取 API 函数的包装器，它将获取 API 端点和数据，并将构造完整的 URL 和从 API 发送的返回响应。</p><p id="5984" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最终的用户界面将如下所示</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/5d4ad53a7023afb39e96b19441b19aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYxMAew-o32Uda1ja6_Inw.png"/></div></div></figure><h1 id="09c8" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">后端部分:-</h1><p id="8c0e" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">现在，既然我们已经有了自己的 UI，让我们开始使用 tensorflow.js 创建一个 API 端点，看起来像这样</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1b46" class="mw ll it ms b gy mx my l mz na"><a class="ae le" href="http://localhost:4000/api/detect_image_objects" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/api/detect_image_objects</a></span></pre><ol class=""><li id="3382" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">第一步是选择一个样板文件，它使用 express.js 并提供只编写路由和对象检测逻辑的能力。在本教程中，我们使用<a class="ae le" href="https://github.com/developit/express-es6-rest-api" rel="noopener ugc nofollow" target="_blank">https://github.com/developit/express-es6-rest-api</a>。让我们克隆它</li></ol><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0022" class="mw ll it ms b gy mx my l mz na">git clone <a class="ae le" href="https://github.com/developit/express-es6-rest-api" rel="noopener ugc nofollow" target="_blank">https://github.com/developit/express-es6-rest-api</a> image_detection_tensorflow_api</span></pre><p id="2536" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.现在，通过运行以下命令安装所有依赖项</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="838b" class="mw ll it ms b gy mx my l mz na">cd image_detection_tensorflow_api<br/>npm install</span></pre><p id="254a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">3.转到项目根目录下的<code class="fe ni nj nk ms b">config.json</code>，将<code class="fe ni nj nk ms b">port</code>编辑为 4000，将<code class="fe ni nj nk ms b">bodylimit</code>编辑为 10000kb。</p><blockquote class="nb nc nd"><p id="839b" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">注意:我们将使用预先训练的模型<code class="fe ni nj nk ms b">imagenet and coco-ssd.</code>从图像中寻找多个对象是一项繁琐的工作，尽管 image net 以从图像中检测单个对象(动物/其他对象)而闻名，但这两种模型都基于非常广泛的不同数据集。所以，如果你没有得到你的目标，不要担心😅。</p></blockquote><p id="fdf5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">4.从 TensorFlow 开始，如果您使用的是旧版本，我们需要更新节点版本。在你熟悉了节点版本之后，让我们运行下面的命令来安装<a class="ae le" href="https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd/demo" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/tfjs-models</a></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c642" class="mw ll it ms b gy mx my l mz na">npm install @tensorflow/tfjs-node</span></pre><blockquote class="nb nc nd"><p id="85b1" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">注意:您可以根据您的系统 Linux/Windows/Mac 使用—<a class="ae le" href="https://www.npmjs.com/package/@tensorflow/tfjs-node" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/@tensorflow/tfjs-node</a>安装<a class="ae le" href="https://www.npmjs.com/package/@tensorflow/tfjs-node" rel="noopener ugc nofollow" target="_blank"> tfjs-node </a></p></blockquote><p id="48d1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">5.现在让我们安装我们将要使用的两个模型，所以运行</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0527" class="mw ll it ms b gy mx my l mz na">npm install @tensorflow-models/mobilenet — save<br/>npm install @tensorflow-models/coco-ssd — save</span></pre><p id="b870" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">6.我们需要安装下面的模块，因为需要依赖</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e10c" class="mw ll it ms b gy mx my l mz na">npm install base64-to-uint8array — save</span></pre><p id="2b09" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">7.现在转到<code class="fe ni nj nk ms b">src &gt; api</code>文件夹下的<code class="fe ni nj nk ms b">index.js</code>，创建一个新的端点</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8e60" class="mw ll it ms b gy mx my l mz na">api.post('/detect_image_objects', async (req, res) =&gt; {<br/>  const data = req.body.data;<br/>  const type = req.body.type;</span><span id="ee95" class="mw ll it ms b gy nl my l mz na">  const objectDetect = new ObjectDetectors(data, type);<br/>  const results = await objectDetect.process();</span><span id="c1d2" class="mw ll it ms b gy nl my l mz na">  res.json(results);<br/>});</span></pre><p id="804a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们调用<code class="fe ni nj nk ms b">ObjectDetectors</code>类并传递从 UI 接收的两个参数，一个是 base64 编码的图像，另一个是模型的类型。</p><p id="cb22" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">8.现在让我们创建<code class="fe ni nj nk ms b">ObjectDetectors</code>类。转到<code class="fe ni nj nk ms b">src &gt; api</code>文件夹并创建<code class="fe ni nj nk ms b">object_detector</code>文件夹。在<code class="fe ni nj nk ms b">object_detector</code>中，我们将创建一个新文件<code class="fe ni nj nk ms b">ObjectDetectors.js</code></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f71d" class="mw ll it ms b gy mx my l mz na">const tf = require('<a class="ae le" href="http://twitter.com/tensorflow/tfjs-node" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-node</a>');<br/> <br/>const cocossd = require('<a class="ae le" href="http://twitter.com/tensorflow" rel="noopener ugc nofollow" target="_blank">@tensorflow</a>-models/coco-ssd');<br/>const mobilenet = require('<a class="ae le" href="http://twitter.com/tensorflow" rel="noopener ugc nofollow" target="_blank">@tensorflow</a>-models/mobilenet');<br/> <br/>import toUint8Array from 'base64-to-uint8array';<br/> <br/> <br/>export default class ObjectDetectors {<br/> <br/>   constructor(image, type) {<br/> <br/>       this.inputImage = image;<br/>       this.type = type;<br/>   }<br/>  <br/>   async loadCocoSsdModal() {<br/>       const modal = await cocossd.load({<br/>           base: 'mobilenet_v2'<br/>       })<br/>       return modal;<br/>   }<br/> <br/>   async loadMobileNetModal() {<br/>       const modal = await mobilenet.load({<br/>           version: 1,<br/>           alpha: 0.25 | .50 | .75 | 1.0,<br/>       })<br/>       return modal;<br/>   }<br/> <br/>   getTensor3dObject(numOfChannels) {<br/> <br/>       const imageData = this.inputImage.replace('data:image/jpeg;base64','')<br/>                           .replace('data:image/png;base64','');<br/>      <br/>       const imageArray = toUint8Array(imageData);<br/>      <br/>       const tensor3d = tf.node.decodeJpeg( imageArray, numOfChannels );<br/> <br/>       return tensor3d;<br/>   }<br/> <br/>   async process() {<br/>        <br/>       let predictions = null;<br/>       const tensor3D = this.getTensor3dObject(3);<br/> <br/>       if(this.type === "imagenet") {<br/> <br/>           const model =  await this.loadMobileNetModal();<br/>           predictions = await model.classify(tensor3D);<br/> <br/>       } else {<br/> <br/>           const model =  await this.loadCocoSsdModal();<br/>           predictions = await model.detect(tensor3D);<br/>       }<br/> <br/>       tensor3D.dispose();<br/> <br/>      return {data: predictions, type: this.type};<br/>   }<br/>}</span></pre><p id="0547" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们有一个构造函数，它有两个参数，一个是图像 base64 编码，另一个是图像类型。</p><p id="ec07" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">调用一个调用<code class="fe ni nj nk ms b">getTensor3dObject(3).</code>的<code class="fe ni nj nk ms b">process</code>函数</p><blockquote class="nb nc nd"><p id="ca71" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">注意:这里 3 是通道的数量，因为在 UI 中，我们将图像类型限制为 jpeg，现在是 3 通道图像。我们不处理 png 的 4 通道图像，你可以很容易地建立这个，因为你可以在 API 中发送图像类型，并根据需要改变给定的函数。</p></blockquote><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6e17" class="mw ll it ms b gy mx my l mz na">getTensor3dObject(numOfChannels) {<br/> const imageData = this.inputImage.replace('data:image/jpeg;base64','')<br/>           .replace('data:image/png;base64','');</span><span id="1888" class="mw ll it ms b gy nl my l mz na">const imageArray = toUint8Array(imageData);</span><span id="f7f2" class="mw ll it ms b gy nl my l mz na">const tensor3d = tf.node.decodeJpeg( imageArray, numOfChannels );</span><span id="6440" class="mw ll it ms b gy nl my l mz na">return tensor3d;<br/>}</span></pre><p id="e0fc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个函数中，我们从 base64 图像中移除标签，将其转换为图像数组，并构建 tensor3d。</p><p id="ce8f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的预训练模型使用 tensor3d 对象或<code class="fe ni nj nk ms b">&lt;img&gt;</code> HTML 标记或 HTML 视频标记，但当我们从 Node.js API 执行此操作时，我们有一个 base64 图像，它被转换为 tensor3d 对象。</p><p id="346e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">欣然 tensorflow.js 为它提供了一个函数<code class="fe ni nj nk ms b">decodeJpeg</code>。</p><blockquote class="nb nc nd"><p id="5f0c" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">TensorFlow 还提供了其他功能，您可以查看更多详细信息—<a class="ae le" href="https://js.tensorflow.org/api_node/1.2.7/#node.decodeJpeg" rel="noopener ugc nofollow" target="_blank">https://js.tensorflow.org/api_node/1.2.7/#node.decodeJpeg</a></p></blockquote><p id="a6a3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在<code class="fe ni nj nk ms b">decodeJpeg</code>将把我们的 3 通道图像的<code class="fe ni nj nk ms b">ArrayBuffer</code>转换成 tesnor3d 对象。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5531" class="mw ll it ms b gy mx my l mz na">if(this.type === "imagenet") {<br/> const model =  await this.loadMobileNetModal();<br/> predictions = await model.classify(tensor3D);</span><span id="365d" class="mw ll it ms b gy nl my l mz na">} else {<br/> const model =  await this.loadCocoSsdModal();<br/> predictions = await model.detect(tensor3D);<br/>}</span></pre><p id="ae5e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">基于选择的模型类型，我们在 API 调用中加载模型。你可以在 API 开始加载的时候加载模型，但是对于这个博客，我只是在 API 得到一个调用的时候加载它们，所以 API 可能需要时间来响应。</p><p id="9df4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是我目前为止得到的结果</p><h2 id="51a3" class="mw ll it bd lm nr ns dn lq nt nu dp lu ki nv nw ly km nx ny mc kq nz oa mg ob bi translated">IMAGENET 模型输出</h2><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oc"><img src="../Images/024044dd5c6bac281b38fdfce732e288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKAQRbbTJ61Vx0lywCkS9Q.png"/></div></div></figure><p id="bffc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk ms b">imagenet</code>的输出它提供了物体的名称及其概率有三个物体用<code class="fe ni nj nk ms b">imagenet.</code>标识</p><h2 id="b6e4" class="mw ll it bd lm nr ns dn lq nt nu dp lu ki nv nw ly km nx ny mc kq nz oa mg ob bi translated">COCO-SSD 模型输出-</h2><p id="df76" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">如果您了解更多关于 coco-ssd 的信息，它可以识别多个对象，即使它们是相似的。以及它们的对象所依赖的矩形坐标。</p><blockquote class="nb nc nd"><p id="912f" class="jx jy ne jz b ka kb kc kd ke kf kg kh nf kj kk kl ng kn ko kp nh kr ks kt ku im bi translated">在这里阅读更多—<a class="ae le" href="https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd" rel="noopener ugc nofollow" target="_blank">https://github . com/tensor flow/tfjs-models/tree/master/coco-SSD</a></p></blockquote><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi od"><img src="../Images/06eaec6355b1cdb2bedf21ce4dc1043b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZytCo52sK-RJ7rzw1vgy7A.png"/></div></div></figure><p id="6b89" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这里你可以看到它已经确定了 6 个人，他们的位置是一个矩形。现在，您可以将这些坐标用于任何目的，因为它们会告诉您对象名称和对象位置。</p><p id="43d4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以使用任何图像库来绘制这些矩形，围绕这些细节构建一些很酷的图像效果应用程序。</p><p id="8a81" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以试试我在 React.js 上的关于 Cloudniary 和 OpenCV 的教程，以前文章中的 Nodejs 试图使用这些知识来构建很酷的东西。</p><p id="80ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">快乐编码❤️</p><p id="b98c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您想被添加到我的电子邮件列表中，请考虑在这里输入您的电子邮件地址 和<strong class="jz iu">关注我的</strong> <a class="ae le" href="https://medium.com/@ideepak.jsd" rel="noopener"> <strong class="jz iu"> medium </strong> </a> <strong class="jz iu">阅读更多关于 javascript 的文章，并关注</strong><a class="ae le" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="jz iu">github</strong></a><strong class="jz iu">查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="1581" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="44be" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated"><a class="ae le" href="https://levelup.gitconnected.com/image-object-detection-with-tensorflow-js-b8861119ed46" rel="noopener ugc nofollow" target="_blank">用 Tensorflow-js 进行图像目标检测🤔</a></li><li id="c793" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">Nodejs 应用程序结构——构建高度可扩展的架构。</li><li id="f5f1" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated"><a class="ae le" href="https://levelup.gitconnected.com/image-processing-making-custom-image-filters-react-js-part-2-ee2787f56b0d" rel="noopener ugc nofollow" target="_blank">图像处理——在 React.js 中制作自定义图像滤镜</a></li></ol></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="595d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你喜欢这篇文章，请随意分享并帮助他人找到它！</p><p id="0cb6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">谢谢你！</p></div></div>    
</body>
</html>