<html>
<head>
<title>No Need to Know the End: Recursive Algorithm and Mathematical Induction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无需知道结局:递归算法和数学归纳法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/no-need-to-know-the-end-recursion-algorithm-and-mathematical-induction-5a9e4c747c3c?source=collection_archive---------16-----------------------#2019-10-31">https://towardsdatascience.com/no-need-to-know-the-end-recursion-algorithm-and-mathematical-induction-5a9e4c747c3c?source=collection_archive---------16-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5443" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">当我第一次学习数学归纳法和用线性代数解线性系统时，它们对我来说是如此神奇，我觉得自己就像电影《黑客帝国》中最终看到矩阵的尼奥。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/432f776ee717eb0d4c6d1117b3ece675.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/0*JQVaBia87wvMnuhu.gif"/></div></figure><p id="c433" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经多年没有学习它们了(不要问我有多少年了，我不想让你猜我的年龄)，但我清楚地记得，我认为我理解计算机的思维和世界是如何在很短的时间内工作的——我可以一次解多个线性方程，我可以证明系统中模式的存在。我很快会告诉你数学归纳法是如何工作的(希望你能有一秒钟像 Neo 一样的感觉)，但让我先告诉你这个。当我最近了解到一个递归算法时，它让我想起了我学习数学归纳法的时候。好神奇好聪明！每当我得到这些让我震惊的神奇技术时，我一定要仔细分析它们，直到我知道它们是如何工作的。在这篇文章中，我想与你分享我在递归算法和数学归纳法之间发现的相似之处，以及它们如何帮助我实现该算法。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="d970" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数学归纳法是一种证明数学性质或公式的技术，适用于每个自然数(0 和正整数)或每个整数(正整数)。</p><p id="d91d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，让我们证明从 0(或 1)到 n 的正整数相加的等式:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/408bf6accb3e55b9e90e270c0d076792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*3IkODc0NiDsoR_7tdwTOPg.png"/></div></figure><p id="d8c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先证明当 n = 0 时:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/2253852190e8313f4155e5ad4176d5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*-tXqj1hIeAPr5QbmUJg3rA.png"/></div></figure><p id="b21f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，<strong class="js iu">假设</strong>从 0 到 n-1 的加法等式成立:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/cd4957b95ca5c8193258d24eb9c29114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxHlREjnvYfotm4PsmmdMQ.png"/></div></div></figure><p id="f1c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三，使用上一步中的假设，证明该等式适用于从 0 到 n 的加法:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lt"><img src="../Images/b8a1214f3a839aa0cada7a4c5675a108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHB0MQFMGu20REZr8pEmIQ.png"/></div></div></figure><p id="9421" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这证明了该方程适用于每个自然数，因为:</p><ol class=""><li id="f5cd" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated">它适用于最小的数字 0(或者有时是 1)；</li><li id="5c92" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">如果等式对一个自然数成立，那么对下一个连续的数也成立；</li><li id="2355" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">对 0 为真所以对 1 为真，然后对 2 为真，对 3 为真以此类推……(这是我脑子被炸飞的点！)</li></ol></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="d91b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归算法是一种调用自身的算法。例如，我有一个自然数，<strong class="js iu"> m，</strong>，我想检查一下<strong class="js iu"> m </strong>是否是从 0 到某个数字<strong class="js iu"> n </strong>的连续自然数之和，并找出数字<strong class="js iu"> n </strong>。这意味着:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/6dbd78154097f72e6e36ba05c1965dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*lV1_3aK1oH4n2SSMeWLwlA.png"/></div></figure><p id="ecda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们之前证明的方程的倒退。如果我选择 m 为 6，那么 n 就是 3，因为 6 = 1+2+3。然而，如果我选择 m 为 7，那么 n 不存在。要在 Python 中构建一个算法来查找 n，让我们像下面这样计划:</p><ol class=""><li id="e38c" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated">如果 m 是 0，那么 n=0</li><li id="685b" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">如果 m&gt;0，更新 n = n+1，然后检查 m-n 是否=0</li><li id="5c97" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">如果 m-n =0，我们找到 n。如果 m-n&gt;0，则更新 m =m-n，并返回步骤 2。如果 m-n&lt;0，则 n 不存在</li></ol><p id="1974" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们重复第 2 步和第 3 步，直到相减后的数字变成 0 或负数。我们不知道要重复多少次，所以我们不应该使用 for 循环。当我们需要在不知道终点的情况下重复这个过程时，递归算法非常有用。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="980f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现数学归纳法和递归算法在三点上非常相似:</p><ol class=""><li id="7669" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated">基本案情应当成立；在第一个例子中，n=0，在第二个例子中，m = 0</li><li id="7f87" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">换人是用来过箱子的；在第一个例子中，数列中的最后一个数用于等式中，而在第二个例子中，m 和 n 被更新，直到 m 变为 0 或小于 0</li></ol><p id="6f2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.没有固定的终点:数学归纳法用于无限数量的序列，递归算法用于没有固定索引范围的迭代。</p><p id="310b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我意识到这些相似性时，似乎更容易知道何时使用递归算法以及如何构建它。使用这三样东西，递归算法被分解成两个部分，这两个部分也是何时使用该算法的指示符:</p><ol class=""><li id="1326" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated">找到一个代表基本情况的参数值，看看它能否结束您将要构建的循环</li><li id="a38a" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">找到一个重复的模式，看看是否可以简单地通过更新变量值来表达</li></ol></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="fa2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了查看这些部件的运行情况，让我们使用欧几里德算法，创建一个函数来计算两个整数 a 和 b 的最大公约数(gcd ),其中 a &gt;b。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ml"><img src="../Images/c6ab35f3bbf16448ea9d6096c0441b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ac0YcP7cDBaqF8a6QyiPKg.png"/></div></div></figure><p id="55eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从步骤 1 和步骤 4 中，我们看到基本情况是一个数可以被另一个数整除。此外，当余数为正时，对于下一步，我们更新除数和被除数:r₀ = b，r₁，…，rₖ，前一步的余数成为下一步的除数。因此，我们看到递归算法将是一个很好的函数。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mm"><img src="../Images/a4e241c0b5f744a95a3e40e59a0c3385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzyfS2yGVQxxBGNuYoP3lQ.png"/></div></div></figure></div></div>    
</body>
</html>