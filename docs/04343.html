<html>
<head>
<title>Hash Tables Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希表解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hash-tables-explained-5dc457db50da?source=collection_archive---------10-----------------------#2019-07-06">https://towardsdatascience.com/hash-tables-explained-5dc457db50da?source=collection_archive---------10-----------------------#2019-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="442d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">哈希表及其冲突的内幕</strong></h2></div><h2 id="b59a" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><span class="l le lf lg bm lh li lj lk ll di"> I </span>简介</h2><p id="dd35" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kr lv lw lx kv ly lz ma kz mb mc md me im bi translated">当给定由与其他信息片段相关的信息片段定义的大型数据集时，我们有哪些方法可以有效地存储和检索信息？为了管理大量的关系数据，我们需要有能够快速操作它(即插入、删除和搜索)的数据结构。假设我们有与“值”数据相对应的“键”数据，那么，关联两条信息的一种方法是使用由键/值关系组成的字典。实现字典有几种不同的方法，包括使用平衡二分搜索法树和双向链表。在本文中，我们将讨论使用哈希表，这是目前为止三种字典实现中最快的方法，并且可以比其他两种字典实现更有效地执行插入、删除和搜索操作。</p><h2 id="8da0" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">哈希函数的动机是什么？</strong></h2><p id="1b83" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kr lv lw lx kv ly lz ma kz mb mc md me im bi translated">首先，我将解释为什么我们需要一种不同于最简单的关联信息的解决方案，即直接地址表。这个幼稚的解决方案基本上是一个大小为<em class="mf"> m </em>的数组，其中键的数量小于<em class="mf"> m </em>，每个数组索引的地址都对应于这个键，这个键要么保存值，要么保存指向值的指针。示例:我们可以将与键<em class="mf"> k </em>相关联的值存储在第<em class="mf">个</em>槽中。没有相应关键字的地址简单地称为:nil。参见下面由直接地址表(T)定义的键和值之间的关系。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/97575d34d48a91d196dd9d735647ec19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6gPozcklj4dtkF5mz6kTg.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">How a Direct Address Table works</figcaption></figure><p id="bdf3" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">在这种情况下，插入、删除和搜索都是 O(1 ),因为您可以通过地址直接找到键，并访问值。然而，限制这种数据结构用于存储关系信息的两个假设是:</p><ol class=""><li id="5357" class="nb nc it lo b lp mw ls mx kr nd kv ne kz nf me ng nh ni nj bi translated">数组的大小，<em class="mf"> m </em>，不算太大。</li><li id="4d97" class="nb nc it lo b lp nk ls nl kr nm kv nn kz no me ng nh ni nj bi translated">没有两个元素具有相同的键。</li></ol><p id="20b7" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">第一个是一个问题，因为我们不希望数组因为没有元素而占用太多空间。第二个也是一个问题，因为它限制了我们可以使用的键的类型。</p><p id="d94b" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">因此，我们使用散列函数。</p><h2 id="99ce" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">什么是哈希函数？</strong></h2><p id="d03e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kr lv lw lx kv ly lz ma kz mb mc md me im bi translated">散列函数<em class="mf"> h(k) </em>是将所有键映射到数组的槽的函数。另一种思考方式是:给定一个键和一个数组，哈希函数可以建议键的索引应该存储在数组中的什么位置。</p><h2 id="0f70" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">散列函数是如何工作的？</h2><p id="80da" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kr lv lw lx kv ly lz ma kz mb mc md me im bi translated">可以为哈希表实现几种哈希函数，但最流行的是除法，其中对于 m 的某个值，<em class="mf">h(k)</em>=<em class="mf">k</em>mod<em class="mf">m</em>。其他哈希函数包括:乘法和折叠方法。</p><h2 id="8a42" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">什么是哈希冲突，如何解决哈希冲突？</strong></h2><p id="675a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kr lv lw lx kv ly lz ma kz mb mc md me im bi translated">所以这一切都很好。但是当一个键被散列到与另一个键相同的数组槽中时会发生什么呢？啊哈！这就是所谓的哈希冲突。处理哈希冲突有几种不同的方法，最流行的两种方法是开放式寻址和封闭式寻址。</p><p id="dee2" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">开放式寻址是指您将一个项目放置在某个位置，而不是其计算的位置。我们通过计算的方式来实现这一点，例如线性探测，其中使用线性搜索来查找可用的位置，并且查找项目也涉及线性搜索。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi np"><img src="../Images/da5bd37df6e94f179ea2417a2e2e276a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlHo-VO48Pph65B7tGwjOQ.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">How the Linear Probe works as an example of open addressing</figcaption></figure><p id="ba7a" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">下面是哈希表中线性探测的代码片段:</p><pre class="mh mi mj mk gt nq nr ns nt aw nu bi"><span id="d70f" class="ki kj it nr b gy nv nw l nx ny"><strong class="nr iu">class</strong> <strong class="nr iu">HashEntry</strong>:<br/>    <strong class="nr iu">def</strong> <strong class="nr iu">__init__</strong>(self, key, value):<br/>        self<strong class="nr iu">.</strong>key <strong class="nr iu">=</strong> key<br/>        self<strong class="nr iu">.</strong>value <strong class="nr iu">=</strong> value<br/>        self<strong class="nr iu">.</strong>next <strong class="nr iu">=</strong> None</span><span id="f234" class="ki kj it nr b gy nz nw l nx ny"><strong class="nr iu">class</strong> <strong class="nr iu">HashTable</strong>:<br/>    <strong class="nr iu">def</strong> <strong class="nr iu">__init__</strong>(self, size):<br/>        self<strong class="nr iu">.</strong>size <strong class="nr iu">=</strong> size<br/>        self<strong class="nr iu">.</strong>keys <strong class="nr iu">=</strong> [None] <strong class="nr iu">*</strong> self<strong class="nr iu">.</strong>size<br/>        self<strong class="nr iu">.</strong>values <strong class="nr iu">=</strong> [None] <strong class="nr iu">*</strong> self<strong class="nr iu">.</strong>size<br/>      <br/>    <strong class="nr iu">def</strong> <strong class="nr iu">hash_function</strong>(self, key):<br/>        <strong class="nr iu">return</strong> hash(key) <strong class="nr iu">%</strong> self<strong class="nr iu">.</strong>size<br/>    <br/>    <strong class="nr iu">def</strong> <strong class="nr iu">get_slot</strong>(self, key):<br/>        slot <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>hash_function(key)<br/>        <strong class="nr iu">while</strong> self<strong class="nr iu">.</strong>keys[slot] <strong class="nr iu">and</strong> self<strong class="nr iu">.</strong>keys[slot] <strong class="nr iu">!=</strong> key:<br/>            slot <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>hash_function(slot <strong class="nr iu">+</strong> 1)<br/>        <strong class="nr iu">return</strong> slot<br/>    <br/>    <strong class="nr iu">def</strong> <strong class="nr iu">set</strong>(self, key, value):<br/>        slot <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>get_slot(key)<br/>        self<strong class="nr iu">.</strong>keys[slot] <strong class="nr iu">=</strong> key<br/>        self<strong class="nr iu">.</strong>values[slot] <strong class="nr iu">=</strong> value<br/>        <br/>    <strong class="nr iu">def</strong> <strong class="nr iu">get</strong>(self, key):<br/>        <strong class="nr iu">return</strong> self<strong class="nr iu">.</strong>values[self<strong class="nr iu">.</strong>get_slot(key)]</span></pre><p id="a625" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">另一种开放式寻址的方式是使用二次探测，当决定下一步离最初的碰撞点有多远时，我们将挫败的尝试次数平方。每当另一个挫败的尝试被做，距离最初的碰撞点的距离迅速增长。</p><p id="a957" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">封闭寻址本质上是使用链表将具有相同哈希值的键链接在一起。该方法的查找与在链表中搜索是一样的。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/f1fd13bd14a4cc4bc7b73f0a0159edf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0BMygKKJdhZAeCdSZapkQ.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Chaining uses Linked Lists to resolve hash collisions</figcaption></figure><p id="ee97" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">下面是哈希表中链接的代码片段:</p><pre class="mh mi mj mk gt nq nr ns nt aw nu bi"><span id="a0f8" class="ki kj it nr b gy nv nw l nx ny"><strong class="nr iu">class</strong> <strong class="nr iu">HashEntry</strong>:<br/>    <strong class="nr iu">def</strong> <strong class="nr iu">__init__</strong>(self, key, value):<br/>        self<strong class="nr iu">.</strong>key <strong class="nr iu">=</strong> key<br/>        self<strong class="nr iu">.</strong>value <strong class="nr iu">=</strong> value<br/>        self<strong class="nr iu">.</strong>next <strong class="nr iu">=</strong> None</span><span id="62a0" class="ki kj it nr b gy nz nw l nx ny"><strong class="nr iu">class</strong> <strong class="nr iu">HashTable</strong>:<br/>    <strong class="nr iu">def</strong> <strong class="nr iu">__init__</strong>(self, size):<br/>        self<strong class="nr iu">.</strong>size <strong class="nr iu">=</strong> size<br/>        self<strong class="nr iu">.</strong>table <strong class="nr iu">=</strong> [None] <strong class="nr iu">*</strong> self<strong class="nr iu">.</strong>size</span><span id="fe41" class="ki kj it nr b gy nz nw l nx ny">    <strong class="nr iu">def</strong> <strong class="nr iu">hashing_function</strong>(self, key):<br/>        <strong class="nr iu">return</strong> hash(key) <strong class="nr iu">%</strong> self<strong class="nr iu">.</strong>size</span><span id="0a86" class="ki kj it nr b gy nz nw l nx ny">    <strong class="nr iu">def</strong> <strong class="nr iu">rehash</strong>(self, entry, key, value):<br/>        <strong class="nr iu">while</strong> entry <strong class="nr iu">and</strong> entry<strong class="nr iu">.</strong>key <strong class="nr iu">!=</strong> key:<br/>            prev, entry <strong class="nr iu">=</strong> entry, entry<strong class="nr iu">.</strong>next<br/>        <strong class="nr iu">if</strong> entry:<br/>            entry<strong class="nr iu">.</strong>value <strong class="nr iu">=</strong> value<br/>        <strong class="nr iu">else</strong>:<br/>            prev<strong class="nr iu">.</strong>next <strong class="nr iu">=</strong> HashEntry(key, value)</span><span id="eb37" class="ki kj it nr b gy nz nw l nx ny">    <strong class="nr iu">def</strong> <strong class="nr iu">set</strong>(self, key, value):<br/>        slot <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>hashing_function(key)<br/>        entry <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>table[slot]<br/>        <strong class="nr iu">if</strong> <strong class="nr iu">not</strong> entry:<br/>            self<strong class="nr iu">.</strong>table[slot] <strong class="nr iu">=</strong> HashEntry(key, value)<br/>        <strong class="nr iu">else</strong>:<br/>            self<strong class="nr iu">.</strong>rehash(entry, key, value)<br/>    <br/>    <strong class="nr iu">def</strong> <strong class="nr iu">get</strong>(self, key):<br/>        hash <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>hashing_function(key)<br/>        <strong class="nr iu">if</strong> <strong class="nr iu">not</strong> self<strong class="nr iu">.</strong>table[hash]: <strong class="nr iu">raise</strong> KeyError<br/>        <strong class="nr iu">else</strong>:<br/>            entry <strong class="nr iu">=</strong> self<strong class="nr iu">.</strong>table[hash]<br/>            <strong class="nr iu">while</strong> entry <strong class="nr iu">and</strong> entry<strong class="nr iu">.</strong>key <strong class="nr iu">!=</strong> key: entry <strong class="nr iu">=</strong> entry<strong class="nr iu">.</strong>next<br/>            <strong class="nr iu">return</strong> entry<strong class="nr iu">.</strong>value</span></pre><p id="55cb" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">暂时就这样吧！我希望这个关于散列表和它们的冲突的信息已经启发了你去学习更多关于它们的知识。</p><h2 id="9555" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">资源和引用</h2><p id="d332" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kr lv lw lx kv ly lz ma kz mb mc md me im bi translated">哈希表和哈希函数:<a class="ae oa" href="https://www.youtube.com/watch?v=KyUTuwz_b7Q" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=KyUTuwz_b7Q</a></p><p id="0465" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">麻省理工学院开放式课程:<a class="ae oa" href="https://www.youtube.com/watch?v=0M_kIqhwbFo" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=0M_kIqhwbFo</a></p><p id="af0d" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">斯坦福 CS 161 哈希注意事项:<a class="ae oa" href="https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture9.pdf" rel="noopener ugc nofollow" target="_blank">https://web . Stanford . edu/class/archive/CS/CS 161/CS 161.1168/lecture 9 . pdf</a></p><p id="31df" class="pw-post-body-paragraph lm ln it lo b lp mw ju lr ls mx jx lu kr my lw lx kv mz lz ma kz na mc md me im bi translated">编码备忘单:<a class="ae oa" href="https://www.alispit.tel/coding-cheat-sheets/data_structures/hash_tables.html" rel="noopener ugc nofollow" target="_blank">https://www . alispit . tel/coding-Cheat-Sheets/data _ structures/hash _ tables . html</a></p></div></div>    
</body>
</html>