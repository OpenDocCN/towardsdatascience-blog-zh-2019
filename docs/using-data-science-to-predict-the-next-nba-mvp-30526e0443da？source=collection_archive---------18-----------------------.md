# 用数据科学预测下一个 NBA MVP

> 原文：<https://towardsdatascience.com/using-data-science-to-predict-the-next-nba-mvp-30526e0443da?source=collection_archive---------18----------------------->

## 统计模型能自信地告诉我们谁将获得每个赛季的 MVP 吗？

![](img/5d3b371e25bf5c39acc183d22db6666c.png)

*Michael Kovac/Getty Images*

每年，都会有一名杰出的 NBA 球员被一百多家体育媒体评选为年度最有价值球员(MVP)。正如体育运动中的其他事情一样，围绕谁应该或不应该获奖的讨论可能会非常激烈。把范围缩小到少数几个球员并不难，但是球迷和媒体很难完全同意谁应该是获奖者。除了那次斯蒂芬.库里。

有些人认为 MVP 应该是拥有最令人印象深刻的数据的球员。其他人认为，一个真正的 MVP 没有最好的个人表现，而是提高周围其他人的水平(见勒布朗詹姆斯)。

但是谁是对的呢？我们可以无休止地辩论这个问题，但毫无结果。或者，我们可以看看数字是怎么说的。为了解决这场辩论，我决定使用各种篮球统计数据来模拟谁将成为 2019 年 NBA MVP。

# 数据收集

*用硒网刮篮球参考*

任何数据科学项目的第一步都是获取完整的数据集进行分析。幸运的是，我们面对的是篮球，一项充满数据的运动。

NBA 的数据主要有两个来源:NBA 自己的统计网站或球迷喜爱的第三方篮球参考网站。这里的主要区别是数据格式化的方式:虽然 NBA 网站包括一个 JSON API，但 BBallRef 允许您直接下载 CSV 文件。第一个需要 JSON 请求，第二个需要一点聪明的 web 抓取。因为我希望从后者中获得一些经验，所以我选择了 BBallRef。

在 Python 中使用 Selenium——一个自动化浏览器的工具——我构建了一个简单的 scraper，它按照年份列表加载每个页面，切换内置的“下载为 CSV”按钮，并将 CSV 输出保存到磁盘。幸运的是，BBalRef 页面遵循一个模板，允许使用相同的 scraper，而不管年份或数据类型。完整的注释函数如下所示。这似乎也是一个很好的时机来提及我的完整代码库是在 GitHub 上完全可用的[。](https://github.com/CaioBrighenti/nba-models)

一旦 scraper 完成，我所要做的就是让它发挥它的魔力，收集从 1976 年到 2018 年的赛季排名，高级，总，每场比赛的个人球员统计数据和奖励数据。下一步是处理数据。

# 数据处理

*使用 R 来加载、清理和合并数据*

虽然简单的球员统计数据以及姓名、球队和赛季的数据集并不是特别难处理，但我的数据确实有一些被证明具有挑战性的特点。首先，让我们只看总玩家统计。下面是单个条目可能的样子。

![](img/243857d6077cf5c2fce5ed10dc0cb392.png)

Example row from 2018 total statistics

好吧，这看起来很简单，但是有一个问题:玩家名字的格式。它采用“詹姆斯·哈登\ \哈德贾 01”的格式，而实际上我们只需要“詹姆斯·哈登”这成为在 r 中练习简单文本清理的绝佳机会。

这就是我们需要做的。当然有一种更有效的方法来完成这项任务，但有时最好接受多几行代码，以使代码更易读。

从这里开始，我们需要遍历数据集中的每一年，加载那一年的 CSV，清除球员姓名，进行一些更简单的数据类型管理(为了方便读者，我省略了这些内容)，并将结果合并到一个电子表格中。该电子表格保存了自 1976 年以来每个赛季每个球员的总数据，格式如上所示。我也为每场比赛统计，以及高级统计，奖项统计和赛季排名做了同样的事情。

接下来，我想在个人统计中添加一个`Team.Wins`栏，因为团队获胜经常会成为讨论个人奖项的因素。因此，我将每个球员的赛季与我的赛季排名数据中适当的球队和赛季进行了匹配。让我们看看积分榜数据是如何格式化的。

![](img/abd0150528dfacce54dff4fd71c12847.png)

Example row from complete standings data

虽然这在技术上只是匹配团队名称和获取`Wins`列的问题，但我们在团队名称格式上有问题。球员数据将休斯顿火箭队编码为`HOU`，而积分榜数据使用全名`Houston Rockets`。这对任何 NBA 球迷来说都不是问题，但我的电脑没有足够的信息来将球队名称与其缩写匹配起来。

解决方案简单而繁琐:手动将每个缩写映射到每个完整的团队名称。考虑到这些年来团队频繁更换名称，这尤其具有挑战性。谁知道有堪萨斯城国王队(KCK)？创建这个映射后，向球员数据添加一个`Team.Wins`列只需要遍历每个球员/赛季对并找到合适的值。

如果你想看看这段代码是什么样子，完整的数据处理代码可以在这里[找到](https://github.com/CaioBrighenti/nba-models/blob/master/loadData.R)以及代码库的其余部分。处理完我们的数据后，是时候进行汇总分析了。

# 数据分析

*汇总统计和初步分析*

在建模之前，对数据集进行一些汇总分析始终是一种很好的做法。在本文的其余部分，我们将只查看 2000 年以后的数据。首先，让我们用我们的总数据做一个简单的`summary()`,具体看看上场时间，投篮得分，3 分，篮板，助攻，抢断，盖帽和得分。我使用 dplyr `tibble`格式来轻松选择相关的列。

![](img/2f6243817f9789e66f79c423d54c4682.png)

Summary of individual player season totals

正如所料，我们看到任何给定的统计值都有很大的范围。让我们快速地看看我们使用`dim`函数处理了多少个观察值。

![](img/5b7f3c7ba2d11d558c8c0d0dbf142497.png)

Dataset dimensions for individual player season totals

我们看到我们有将近 6500 个 36 列的观察值。因为我们着眼于 18 年的范围，这给了我们每年大约 360 次观察。接下来，为了了解哪些栏目可能是有用的预测指标，我创建了一个关联图，来看看哪些篮球统计数据与 MVP 投票最相关。

![](img/7d080339c4da47306705c301d63c0095.png)

Plot of correlation between player season totals and number of first place MVP votes received

第一次尝试的信息并不丰富。上图显示了第一名票数和得分、投篮命中率和罚球命中率之间微弱的正相关关系。这些统计数据本身也是内在相关的(更多的领域目标=更多的点)。这表明得分多会增加你成为 MVP 的几率，但这是一个相当明显的结论。让我们用更高级的数据再试一次。

![](img/14a56fb8f88a649677d807f08ae866a0.png)

Plot of correlation between player season advanced stats and number of first place MVP votes received

我们的结果在这里更有趣，表明玩家效率等级(PER)、获胜份额、正负以及对替代玩家(VORP)的价值与收到的投票更密切相关。让我们通过观察过去的 MVP 获得者在这些统计中的排名来进一步形象化这一点。

![](img/adc3ca786dfd70269e1faab6d8053e1e.png)

Plots of VORP vs. PER and BPM vs. WS with MVP recipients shown in red (players with less than 41 games played omitted)

这两幅图用红色显示了 MVP 获得者，清楚地展示了高级统计在捕捉 MVP 级别球员的品质方面的有效性。然而，他们似乎不足以判断获胜者，在这两张图中有几个 MVP 落在了中间位置。

在这个阶段，我在建模之前采取的最后一步是通过将每个统计数据除以该季节的最大值来按季节归一化每个统计数据。也就是说，现在每个统计值都位于(0，1)之间，stat leader 将标杆设置为 1。这主要是为了避免异常低或高的统计数据伤害模型。现在我们终于可以开始建模了。

# 建模

*建立并调整一个模型来预测 NBA MVP*

我们从一个简单的逻辑回归模型开始，这个模型使用了球员赛季总数数据集中的一些相关变量和 r。

```
tot.log <- glm(MVP~G+X3P+DRB+AST+BLK+PF+PTS+Team.Wins,
data=dat_totals,family = binomial(link = "logit"))
```

为了澄清这里发生了什么，`MVP~`告诉 R 使用以下所有变量来预测 MVP 得主。`family=binomial`部分告诉 R 我们打算执行一个简单的(0，1)分类。当我们这样做的时候，让我们也用高级统计数据来拟合一个模型。

```
adv.log <- glm(MVP~PER+TS.+X3PAr+FTr+TRB.+AST.+STL.+BLK.+
                 TOV.+USG.+WS+BPM+VORP+Team.Wins,
                data=adv.shortlist,family = binomial(link="logit"))
```

和以前一样，我们传递我们想要预测的变量，后面跟着预测值。现在让我们看看我们的模型有多好。为了衡量模型的性能，我们首先必须使用这些模型进行预测，然后看看这些预测有多准确。为了简化这一点，我在 R 中创建了函数来完成这两项任务，如下所示。

第一个函数对每个球员进行预测，然后找出每个赛季预测赔率最高的球员，授予他 MVP。第二个函数将选择的 MVP 与正确的选择进行比较，并返回精确度。现在让我们测试我们的两个模型的准确性。

![](img/7fbc0a1268b8d9126badff758138cde7.png)

Accuracy and error count for total stats and advanced stats models

我们的 total stats 模型报告了 84%的准确率，而 advanced stats 模型只能在大约三分之二的时间里正确预测 MVP 冠军。我很惊讶地看到高级统计模型表现更差，因为在我们的初步分析中，高级统计显示与 MVP 投票有更高的相关性。为了更好地判断这里发生了什么，让我们看看高级统计模型的模型系数。

![](img/feb9d4faecaca987a38ed2599ca75392.png)

Model coefficients for advanced stats logistic regression classifier

奇怪的是，模型系数表明更高的 PER 和 BPM 实际上*会降低*一个球员成为 MVP 的几率。这显然是错误的，所以一定是哪里出错了。让我们通过查看每个赛季的 PER leader 来进行调查。

![](img/4bba093ace34982c0bba35939145031a.png)

PER leaders by season

虽然这份名单中肯定有一些像沙奎尔·奥尼尔和勒布朗·詹姆斯这样的名字，但其他人像大卫·温盖特和贾内尔·斯托克斯似乎很突出。幸运的是，这里的问题是显而易见的:游戏和上场时间异常低的玩家放弃了高级的统计计算。

这里简单的解决方法是简单地忽略未能满足最低游戏数的观察结果。这绝对是值得的一步，但我们可以走得更远。为什么要考虑那些根本没有机会获奖的球员呢？通过训练我们的模型让每个球员每个赛季都踏上球场，我们淡化了模型突出精英球员的能力，而是让轮换球员充斥其中。

此时，我决定实现一个两阶段的模型管道。首先，我们确定哪些球员甚至在争夺这个奖项，然后我们预测候选名单中的哪个球员最有可能获得 MVP。由于我们的数据集包含每个玩家获得的投票份额，我们可以很容易地编码一个二进制的`Shortlist`变量如下。

```
dat_totals$Shortlist<-dat_totals$Share!=0
```

然后，我们拟合一个简单的逻辑回归模型，并预测入围的球员。

```
tot.short.mod <- glm(Shortlist~G+MP+X3P+DRB+AST+
    BLK+TOV+PF+PTS+Team.Wins,
    data=dat_totals,family = binomial(link = "logit"))
## grab shortlist
tot.shortlist<-dat_totals[which(predict(tot.short.mod,type="response")>.75),]
```

在对高级统计数据集进行了同样的操作后，我们就可以像之前一样进行建模了。让我们看看我们的准确度是否提高了。

![](img/9f8352e68552daab0668efce6caf9187.png)

Accuracy and error count for total and advanced stats models

我们的两阶段管道似乎是成功的，因为我们的 total stats 模型保持了相同的准确性，而高级模型显著提高了。在这两种情况下，我们每个赛季在近 400 名球员中有 84%的几率正确预测出 NBA MVP。

当然，我们正在犯一个重大的数据科学错误:仅仅根据训练数据来衡量模型性能。我们的模特完全有可能过于合身，对未来几季毫无用处。为了测试这一点，我们必须采用交叉验证。

# 交叉验证

*按季节留一交叉验证(有很多连字符)*

虽然通常您可能只是将数据分成训练集和测试集，但在这种情况下会有点棘手，因为我们每个季度只有一个积极的观察结果。删除季节的子集会创建一个太小而无用的测试集。相反，我采用了留一法交叉验证。

为了做到这一点，我必须将每个模型*训练 n* 次，其中 *n* 是季节数。每次，从训练集中选出一个季节，并且仅针对该季节进行预测，结果是模型从未看到过其预测数据的每个季节的预测。为了简化这个过程，我编写了一个 R 函数来快速运行这个过程。

有了这个方便的助手功能，我们现在可以交叉验证以前模型的准确性。

![](img/4073633a90e92e28bf2e176bc9fc41b2.png)

Leave-one-out cross-validation error for each model

不出所料，在应用交叉验证后，我们看到了模型准确性的下降。也就是说，我们仍然有一个相当准确的模型，特别是先进的统计数据。但是为什么要在那里定居呢？

在这一阶段，我们拥有适合和测试各种不同模型所需的所有工具。在我寻找理想模型的过程中，我对总统计数据、每场比赛统计数据和高级统计数据以及由总统计数据和高级统计数据组成的合并数据集进行了线性、逻辑和多项式回归。每个模型的结果如下所示。

![](img/4ae5956e2404064443aa9e1507b6a697.png)

Accuracy and leave-one-out cross-validation accuracy for each model fit

我们可以看到，在交叉验证后，许多模型的表现非常相似，我们的最高 CV 准确率为 73%，这是由两个不同的模型共享的，两个模型都使用高级统计数据。我们还可以在其他情况下看到过度拟合，例如三次多项式模型，它具有最高的未验证准确性，但一些验证得分最低。

我们值得信赖的逻辑高级统计模型是与最高准确性相关的模型之一，所以让我们坚持使用它。现在是关键时刻了:预测 2019 年 NBA MVP。

# 预言；预测；预告

*预测 2019 NBA MVP*

为了预测 2019 年 NBA MVP，我们必须首先加载该年的高级数据。幸运的是，我们已经在[数据加载和处理文件](https://github.com/CaioBrighenti/nba-models/blob/master/loadData.R)中为此准备了一个函数。

一旦数据被加载，我们只需通过我们的两阶段管道运行数据。首先选出前 10 名候选人组成入围名单，预测每个选手的赔率。下面的代码完成所有这些工作，然后将最终预测转换成百分比。

现在剩下要做的就是焦急地看着我们的结果。

![](img/b3418141083ebed007e460840fd11a0c.png)

MVP prediction results for 2019

最终，我们的模型几乎未能正确预测 2019 年的 MVP 得主:扬尼斯·阿德托昆博，但哈登和詹尼斯之间的预测得分接近，反映了 MVP 比赛实际上有多接近。事实上，詹尼斯获得了大约 35%的投票份额，而哈登达到了近 30%。

我们的候选名单模型也表现得相当好，几乎完美地预测了前 10 名得票数。候选名单中唯一的错误是将凯里·欧文排除在科怀·伦纳德之外。因此，虽然我们没有准确地做出正确的最终预测，但我们的两阶段流水线仍然表现得相当好。

# 未来的工作

*模型改进和数据可视化*

虽然我们已经在本文中介绍了大量不同的技术和方法，但是我仍然想探索许多途径来改进这个项目。最明显的一个是使用更复杂的模型。支持向量机或随机森林可能会大大超过我的简单逻辑回归分类器。

我想做的更有雄心的改进是加入社交媒体数据。围绕 MVP 的争论经常围绕着一个拥有优越数据的球员可能会输给一个更强大的媒体叙事(见 2015 年的詹姆斯·哈登或 2011 年的勒布朗)。找到一种量化社交媒体言论的方法可能是探索这个问题的一个有趣途径，也可能改善我们的结果。

最后，这个项目的最终目的是创建一个网站，通过在每场比赛后更新预测来跟踪整个赛季的 MVP 赔率。虽然我已经部分构建了 HTML 界面，但我仍然需要对系统进行编码，以便在每场比赛后使用 NBA API 更新预测。

感谢阅读！请告诉我您是否喜欢这篇文章，以及我是否应该在将来撰写第 2 部分。如果你感兴趣，我的整个代码库都可以在这里[找到](https://github.com/CaioBrighenti/nba-models)。