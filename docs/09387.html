<html>
<head>
<title>Is that a warbler? Bird classification with Keras CNN in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那是只莺吗？Python 中 Keras CNN 的鸟类分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-that-a-warbler-bird-classification-with-keras-cnn-in-python-db4606555a33?source=collection_archive---------11-----------------------#2019-12-11">https://towardsdatascience.com/is-that-a-warbler-bird-classification-with-keras-cnn-in-python-db4606555a33?source=collection_archive---------11-----------------------#2019-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="54e0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有没有想过“那是什么鸟？”</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b8580dcf04062173119c5c1b0848dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psVzoLfr1VsZgVfSn9sNbg.png"/></div></div></figure><p id="91b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我一直想知道“那是什么鸟？”当我带着我的狗在波士顿的一个公园散步时，那里一年四季都充满了鸟类:夏天是小鸭子，秋天/春天是迁徙的鸣鸟，冬天是水鸟。我的爷爷(一个长期观察鸟类的人)给了我 Sibley 鸟类野外指南，这激发了我的爱好。在你认为这是老年人的爱好之前，我强烈建议你去观鸟，尤其是如果你有相机的话。</p><p id="7eac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于大多数小鸟不会安静地坐足够长的时间，让你翻阅 400 页野外指南并比较 20 多个标记，我开始拍摄鸟类的照片，希望我能有足够清晰的照片供以后识别。然后我发现了一个名为<a class="ae ln" href="https://ebird.org/home" rel="noopener ugc nofollow" target="_blank"> eBird </a>的网站，它可以让你追踪你在哪里见过哪种鸟。你甚至可以上传一张照片作为证明。对于那些喜欢口袋妖怪的书呆子来说，就像那样，但有真正的活鸟！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/3d7b6917ab1294907ce9903ae21c0b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/0*52Dd0KXVj17_WDJf.jpg"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Source: <a class="ae ln" href="https://www.trollandtoad.com/pokemon/pokemon-miscellaneous-supplies/pokemon-1999-pikachu-meowth-pokedex-2-pocket-folder/1167040" rel="noopener ugc nofollow" target="_blank">https://www.trollandtoad.com/pokemon/pokemon-miscellaneous-supplies/pokemon-1999-pikachu-meowth-pokedex-2-pocket-folder/1167040</a></figcaption></figure><p id="17fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">偶尔，我会上传一张错误的鸟的照片，但幸运的是，有 eBird 志愿者监控这些鸟的照片，并给你发电子邮件(友好地)说你标记了错误的物种。但是不要经常这样做，因为那样他们会锁定你的帐户(哎呀！).通常，这些志愿者也会告诉你正确的物种。这对那些志愿者来说是一项繁重的工作！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/b8dcc0a016ba3f033ba2d59b6a4245b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdILNKCbrUlKjVwoKOpWkA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Not a Savannah Sparrow</figcaption></figure><p id="0d9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名数据科学家，我在想:如果我们可以自动检查每一张用深度学习上传的鸟类照片，会怎么样？作为一个周末项目的原理证明，我创建了这个预测模型来检测鸟类图像是否是一只莺(我爷爷最喜欢的鸟类类别)。</p><h1 id="42d0" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">项目定义</h1><p id="79a8" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">给定一只鸟的图像，预测它是否是一只林莺(见下面的林莺物种标签)</p><h1 id="3924" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">数据集</h1><p id="8b49" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">本项目数据集来自加州理工学院-加州大学圣迭戈分校 Birds-200–2011(【http://www.vision.caltech.edu/visipedia/CUB-200-2011.html】T2)。该数据集包含 200 种鸟类的 11，788 张图片。由于任何一个物种的图像数量都很少，作为原则的证明，我决定将所有的莺图像进行分组。</p><h1 id="884d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">设置:加载元数据</h1><p id="3794" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">让我们从聚集加州理工学院-加州大学圣地亚哥分校提供的所有元数据开始:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7687" class="mw lv iq ms b gy mx my l mz na">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="e605" class="mw lv iq ms b gy nb my l mz na">#path to dataset<br/>data_path = '../CUB_200_2011/CUB_200_2011/'</span><span id="10a7" class="mw lv iq ms b gy nb my l mz na"># aggregate datasets<br/>df_images = pd.read_csv(data_path+'images.txt', <br/>                        sep = ' ',header = None, <br/>                        names = ['img_num','img'])<br/>df_labels = pd.read_csv(data_path+'image_class_labels.txt', <br/>                        sep = ' ',header = None, <br/>                        names = ['img_num','class_id'])<br/>df_classes = pd.read_csv(data_path+'classes.txt', <br/>                         sep = ' ', header = None, <br/>                         names = ['class_id','bird_class'])<br/>df_split = pd.read_csv(data_path +'train_test_split.txt', <br/>                       sep = ' ', header = None, <br/>                       names = ['img_num','dataset'])</span><span id="98d6" class="mw lv iq ms b gy nb my l mz na">df = pd.merge(df_images, df_labels, on = 'img_num', how = 'inner')<br/>df = pd.merge(df, df_classes, on = 'class_id',how = 'inner')<br/>df = pd.merge(df, df_split, on = 'img_num',how = 'inner')</span></pre><p id="052a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数据包含图像编号、img 名称(带路径)、物种 id 以及物种文本，如下所示。由于我们将进行自己的培训/测试分割，因此我们将忽略该团队提供的分割，即最后一列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5940fe433d927aaef964bf91f31c128d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Qwy3v1wwkchn2Ixv3vEb0Q.png"/></div></figure><h1 id="8aee" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">制作莺输出标签</h1><p id="b77f" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我浏览了物种列表，提取了列表中的所有鸣鸟:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="363f" class="mw lv iq ms b gy mx my l mz na">warbler_class = ['020.Yellow_breasted_Chat','158.Bay_breasted_Warbler',<br/>       '159.Black_and_white_Warbler', '160.Black_throated_Blue_Warbler',<br/>       '161.Blue_winged_Warbler', '162.Canada_Warbler',<br/>       '163.Cape_May_Warbler', '164.Cerulean_Warbler',<br/>       '165.Chestnut_sided_Warbler', '166.Golden_winged_Warbler',<br/>       '167.Hooded_Warbler', '168.Kentucky_Warbler',<br/>       '169.Magnolia_Warbler', '170.Mourning_Warbler',<br/>       '171.Myrtle_Warbler', '172.Nashville_Warbler',<br/>       '173.Orange_crowned_Warbler', '174.Palm_Warbler',<br/>       '175.Pine_Warbler', '176.Prairie_Warbler',<br/>       '177.Prothonotary_Warbler', '178.Swainson_Warbler',<br/>       '179.Tennessee_Warbler', '180.Wilson_Warbler',<br/>       '181.Worm_eating_Warbler', '182.Yellow_Warbler',<br/>       '183.Northern_Waterthrush', '184.Louisiana_Waterthrush', '200.Common_Yellowthroat']</span></pre><p id="4da9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这允许我们制作一个二进制输出标签:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="5e1e" class="mw lv iq ms b gy mx my l mz na">df['OUTPUT_LABEL'] = (df.bird_class.isin(warbler_class)).astype('int')</span></pre><h1 id="3c38" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">将数据分为训练和验证</h1><p id="d9d2" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们可以将数据分为 70%训练数据和 30%验证数据。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="df44" class="mw lv iq ms b gy mx my l mz na">df = df.sample(n = len(df), random_state = 42)<br/>df_train_all = df.sample(frac = 0.7, random_state = 42)<br/>df_valid = df.drop(df_train_all.index)</span></pre><p id="abaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并检查两组的患病率是否相同:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1170" class="mw lv iq ms b gy mx my l mz na">def calc_prevalence(y):<br/>    return sum(y)/ len(y)</span><span id="3c5c" class="mw lv iq ms b gy nb my l mz na">print('train all %.3f'%calc_prevalence(df_train_all.OUTPUT_LABEL))<br/>print('valid %.3f'%calc_prevalence(df_valid.OUTPUT_LABEL))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0b44edc33743d9216e56f4161414fd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*ltaUdvzRtg1qYyrf8GdC5Q.png"/></div></figure><p id="2f5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大约各占 15%</p><h1 id="0d3e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">图像增强</h1><p id="4dfe" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在这一点上，我们可以只是训练一个深度学习模型，但由于不平衡，该模型可能最终只会默默预测不是一只林莺。我试过了，发生在我身上。</p><p id="b506" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了抵消这种不平衡，我们需要获取或制作更多的林莺图像，或者对非林莺图像进行二次采样。对于这个项目，我将使用数据增强(旋转，缩放，裁剪，翻转等)来增加林莺图像的数量。为了更好的回顾数据增强，请看这个<a class="ae ln" rel="noopener" target="_blank" href="/classify-butterfly-images-with-deep-learning-in-keras-b3101fe0f98">蝴蝶探测器项目</a>。</p><p id="68a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从数据帧中抓取所有的林莺图像:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="826b" class="mw lv iq ms b gy mx my l mz na">warbler_imgs = df_train_all.loc[df_train_all.OUTPUT_LABEL == 1,’img’].values</span></pre><p id="2764" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以使用 Keras ' T0 '来制作新的增强图像。为了简单起见，我将把这些新图像保存在一个增强的林莺文件夹中。此外，给非林莺图像添加增强可能是个好主意，这样 DL 模型就不会知道‘增强’是林莺图像，但我现在跳过这一步。我也看过其他文章在训练中做这种增强，但是我现在也跳过这个。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/62641209de725b998f059cbc6f3d3c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*JnB3K3vtYDmAIOHsvqPjtQ.png"/></div></figure><p id="1127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以聚集增强的图像:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a89f" class="mw lv iq ms b gy mx my l mz na"><br/>from os import listdir</span><span id="5fe9" class="mw lv iq ms b gy nb my l mz na">warbler_aug_files = ['aug_warblers/'+ a for a in listdir(data_path+'images/aug_warblers/') if a.endswith('.jpg')]</span><span id="2f17" class="mw lv iq ms b gy nb my l mz na">df_aug = pd.DataFrame({'img':warbler_aug_files, 'OUTPUT_LABEL': [1]*len(warbler_aug_files) })</span></pre><p id="52a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并与我们现有的培训相结合</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="05c7" class="mw lv iq ms b gy mx my l mz na">df_c = pd.concat([df_train_all[['img','OUTPUT_LABEL']],df_aug],<br/>                 axis = 0, ignore_index = True, sort = False)</span></pre><p id="bce2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了安全起见，让我们以 1:1 的比率在莺和非莺之间平衡数据:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="36ca" class="mw lv iq ms b gy mx my l mz na">rows_pos = df_c.OUTPUT_LABEL == 1<br/>df_pos = df_c.loc[rows_pos]<br/>df_neg = df_c.loc[~rows_pos]<br/>n= min([len(df_pos), len(df_neg)])<br/>df_train = pd.concat([df_pos.sample(n = n,random_state = 42), <br/>                      df_neg.sample(n = n, random_state = 42)], <br/>                     axis = 0)<br/>df_train = df_train.sample(frac = 1, random_state = 42)</span></pre><h1 id="de0e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">构建 X 和 Y</h1><p id="ba88" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们现在可以为机器学习建立我们的 X 和 Y。为了做到这一点，让我们创建一个函数来加载给定数据帧的所有图像，该数据帧</p><ul class=""><li id="09f3" class="ni nj iq kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated">将每个图像的大小调整为 224x224</li><li id="9ed4" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">转换为 RGB (3 通道)</li><li id="369c" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">从 0 到 1 归一化(即除以 255)</li></ul><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c75d" class="mw lv iq ms b gy mx my l mz na">IMG_SIZE = 224<br/>def load_imgs(df):<br/>    imgs = np.ndarray(shape = (len(df), IMG_SIZE, IMG_SIZE,3), dtype = np.float32)<br/>    for ii in range(len(df)):<br/>        file = df.img.values[ii]<br/>        img = load_img(data_path+'images/'+file, target_size=(IMG_SIZE, IMG_SIZE),color_mode='rgb')<br/>        img = img_to_array(img)/255<br/>        imgs[ii] = img<br/>    return imgs</span></pre><p id="0cef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="630b" class="mw lv iq ms b gy mx my l mz na">X_train = load_imgs(df_train)<br/>X_valid = load_imgs(df_valid)</span><span id="da1e" class="mw lv iq ms b gy nb my l mz na">y_train = df_train.OUTPUT_LABEL.values<br/>y_valid = df_valid.OUTPUT_LABEL.values</span></pre><p id="1b53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的 X 矩阵并不是我们想要的 Keras，所以让我们用</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="bcae" class="mw lv iq ms b gy mx my l mz na"># reshape<br/>X_train = X_train.reshape(X_train.shape[0], IMG_SIZE,IMG_SIZE, 3)<br/>X_valid = X_valid.reshape(X_valid.shape[0], IMG_SIZE,IMG_SIZE, 3)</span></pre><p id="2f36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最后的 X_train 有一个形状(14104，224，224，3 ),这意味着我们有 14104 个 224 x 224 的图像，有 3 种颜色。</p><p id="2e3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用以下方式绘制其中一幅图像:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="d267" class="mw lv iq ms b gy mx my l mz na">ii = 3<br/>plt.imshow(X_train[ii])<br/>plt.title(df_train.img.iloc[ii])<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4acec5687a70c7a42fcca226fd35b94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*cGIUYNaSYKsDQ9BJppKGhw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Image of augmented yellow-rumped warbler</figcaption></figure><h1 id="dc1a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">CNN 机器学习模型</h1><p id="55c6" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">为简单起见，让我们创建一个架构，该架构具有两个带 dropout 的 CNN 层、一个密集层和用于该二进制分类器的最终 sigmoid。稍后可以尝试其他更复杂的架构。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3fae" class="mw lv iq ms b gy mx my l mz na">from keras.models import Sequential<br/>from keras.layers import Conv2D, MaxPool2D, Dense, Flatten, Dropout</span><span id="61d8" class="mw lv iq ms b gy nb my l mz na">model = Sequential()<br/>model.add(Conv2D(filters = 64, kernel_size = (5,5), <br/>                 activation = 'relu', <br/>                 input_shape = X_train.shape[1:]))<br/>model.add(MaxPool2D(pool_size = (3,3)))<br/>model.add(Dropout(rate = 0.25))<br/>model.add(Conv2D(filters = 64, kernel_size = (3,3), <br/>                 activation = 'relu'))<br/>model.add(MaxPool2D(pool_size = (3,3)))<br/>model.add(Dropout(rate = 0.25))<br/>model.add(Flatten())<br/>model.add(Dense(64, activation = 'relu'))<br/>model.add(Dropout(rate = 0.25))<br/>model.add(Dense(1, activation = 'sigmoid'))</span></pre><p id="58af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将用 Adam 和二元交叉熵损失(即 2 类的对数损失)来编译我们的模型。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b4ed" class="mw lv iq ms b gy mx my l mz na">model.compile(<br/>                loss = 'binary_crossentropy',<br/>                optimizer = 'adam',<br/>                metrics = ['accuracy'])</span></pre><p id="deea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以用以下方法训练您的分类器(为了加快速度，我刚才用 64 的批量做了 2 个时期):</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="07c9" class="mw lv iq ms b gy mx my l mz na">model.fit(X_train, y_train, batch_size = 64, epochs= 2, verbose = 1)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/85acc79fc7d086e2b1e9792c9d3f0a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKUWw0UaiGQQUkFQTVJyQw.png"/></div></div></figure><h1 id="90f6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">预测和模型性能</h1><p id="3144" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们可以计算训练和验证的预测值，如下所示:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1a20" class="mw lv iq ms b gy mx my l mz na">y_train_preds = model.predict_proba(X_train,verbose = 1)<br/>y_valid_preds = model.predict_proba(X_valid,verbose = 1)</span></pre><p id="107b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将把验证预测保存在 df_valid 中，以便进一步分析</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7a62" class="mw lv iq ms b gy mx my l mz na">df_valid['pred'] = y_valid_preds</span></pre><p id="8f2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看看我们做得最好(最高平均分)的林莺种类</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8589" class="mw lv iq ms b gy mx my l mz na">df_valid.loc[(df_valid.OUTPUT_LABEL == 1) ].groupby('bird_class').pred.mean().sort_values(ascending = False)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/746eef8df333305b3d80bd4cacfc8d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*TIydef-jMiYuulmxIxiRRQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/6529282c545dd79337bce92425afa882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEBJ7XssPqLC5yXbFsHE3w.png"/></div></div></figure><p id="2398" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从一些图片来看，似乎这个模型对黄色的莺比对没有黄色的莺做得更好。</p><p id="e891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以看看模型倾向于认为是鸣鸟但不是的物种:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b94fe4b50bdb8325c2ad639c5d97a780.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*Br-dOoXgEjSBasWseziYEw.png"/></div></figure><p id="1171" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是有道理的，因为金翅雀非常黄！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/56dc39ca847e1c9fbf7ebb56649b7500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0I1ttppmradqdOF9hVuaQ.png"/></div></div></figure><p id="3d1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以计算一系列指标的性能(关于分类指标的教程，请参见我的帖子<a class="ae ln" rel="noopener" target="_blank" href="/understanding-data-science-classification-metrics-in-scikit-learn-in-python-3bc336865019">这里</a></p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9fe0" class="mw lv iq ms b gy mx my l mz na">from sklearn.metrics import roc_auc_score, accuracy_score, \<br/>                            precision_score, recall_score<br/>def calc_specificity(y_actual, y_pred, thresh):<br/>    # calculates specificity<br/>    return sum((y_pred &lt; thresh) &amp; (y_actual == 0)) /sum(y_actual ==0)</span><span id="1d6f" class="mw lv iq ms b gy nb my l mz na">def print_report(y_actual, y_pred, thresh):<br/>    <br/>    auc = roc_auc_score(y_actual, y_pred)<br/>    accuracy = accuracy_score(y_actual, (y_pred &gt; thresh))<br/>    recall = recall_score(y_actual, (y_pred &gt; thresh))<br/>    precision = precision_score(y_actual, (y_pred &gt; thresh))<br/>    specificity = calc_specificity(y_actual, y_pred, thresh)<br/>    print('AUC:%.3f'%auc)<br/>    print('accuracy:%.3f'%accuracy)<br/>    print('recall:%.3f'%recall)<br/>    print('precision:%.3f'%precision)<br/>    print('specificity:%.3f'%specificity)<br/>    print('prevalence:%.3f'%calc_prevalence(y_actual))<br/>    print('pred pos:%.3f'%(sum(y_pred &gt; thresh)/len(y_actual)))<br/>    print(' ')<br/>    return auc, accuracy, recall, precision, specificity</span></pre><p id="e4f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们平衡了数据，所以让我们设置一个阈值 0.50 来标记预测的莺:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="5c8a" class="mw lv iq ms b gy mx my l mz na">thresh = 0.5<br/>print('train')<br/>print_report(y_train, y_train_preds[:,0], thresh);<br/>print('valid')<br/>print_report(y_valid, y_valid_preds[:,0], thresh);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9037462953ee61894dd17676f86bce2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*hHrHBCXQIK-BrmUlAx9mBA.png"/></div></figure><p id="d3b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用以下公式绘制 ROC 曲线:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4f7c" class="mw lv iq ms b gy mx my l mz na">from sklearn.metrics import roc_curve, roc_auc_score</span><span id="457a" class="mw lv iq ms b gy nb my l mz na">fpr_train, tpr_train, t_train = roc_curve(y_train, y_train_preds[:,0])<br/>auc_train = roc_auc_score(y_train, y_train_preds[:,0])</span><span id="90f2" class="mw lv iq ms b gy nb my l mz na">fpr_valid, tpr_valid, t_valid = roc_curve(y_valid, y_valid_preds[:,0])<br/>auc_valid = roc_auc_score(y_valid, y_valid_preds[:,0])</span><span id="9d1e" class="mw lv iq ms b gy nb my l mz na">plt.plot(fpr_train, tpr_train, 'r-', label = 'Train AUC:%.3f'%auc_train)<br/>plt.plot(fpr_valid, tpr_valid, 'b-', label = 'Valid AUC:%.3f'%auc_valid)</span><span id="5d10" class="mw lv iq ms b gy nb my l mz na">plt.plot([0,1],[0,1], 'k--')<br/>plt.xlabel('FPR')<br/>plt.ylabel('TPR')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/667de6239f7cbcbe7a09ca97541edadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*nlwaZNBxx7zElha3iLERRg.png"/></div></figure><p id="9965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们可以看到的，这个简单模型的 AUC 在验证上相当高。这给了我建立一个分类器来帮助我标记鸟类图像的巨大希望。</p><p id="8b24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用我自己的一些图片来测试一下:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="d5ce" class="mw lv iq ms b gy mx my l mz na">file = 'magnolia2.png'<br/>print(file)<br/>x = load_img(file, target_size=(IMG_SIZE, IMG_SIZE),color_mode='rgb')<br/>x= img_to_array(x)/255<br/>x=x.reshape(1,IMG_SIZE,IMG_SIZE, 3)<br/>print('prob it is warbler:%.3f'%model.predict_proba(x,verbose = 1)[0][0])<br/>plt.imshow(load_img(file))<br/>plt.show()</span></pre><p id="608f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我可以正确地把玉兰花莺归类为莺</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/250b749a8f4d64e5c6f09197421a7a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*9jV-PjNu3t63upzrzI6rvw.png"/></div></figure><p id="51cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并把这种冲浪苏格兰人归类为非林莺</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/276912cdfdd51d1293e5992779f9f8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*oBLIqXaixDRwkt2IG-lhaQ.png"/></div></figure><h1 id="f1b9" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="5843" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在这篇文章中，我们建立了一个简单的 CNN 模型来预测一张鸟的照片是不是一只莺！</p></div></div>    
</body>
</html>