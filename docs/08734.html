<html>
<head>
<title>Particle Filter on Localisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定位粒子滤波</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/particle-filter-on-localisation-9e0802282aaf?source=collection_archive---------16-----------------------#2019-11-23">https://towardsdatascience.com/particle-filter-on-localisation-9e0802282aaf?source=collection_archive---------16-----------------------#2019-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">粒子滤波器在自动驾驶汽车上的应用概述</h2></div><p id="427e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在之前的<a class="ae le" rel="noopener" target="_blank" href="/kalman-filter-3-localisation-in-continuous-state-space-1c979f6bde5b">帖子</a>中，我们谈到了卡尔曼滤波器在帮助自动驾驶汽车定位方面的作用。课程<a class="ae le" href="https://classroom.udacity.com/courses/cs373/lessons/48704330/concepts/484805920923" rel="noopener ugc nofollow" target="_blank">在这里</a>介绍了另一种叫做粒子过滤器的定位方法，这很有趣，我认为它可以以某种方式被塞进一篇文章中，所以我将简要介绍粒子过滤器的概念并实现它。</p><h1 id="e550" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">直觉</h1><p id="dd1d" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">顾名思义，粒子过滤器构建了许多粒子来代表我们对汽车位置的猜测。考虑一个场景，一辆自动驾驶汽车在一个有 4 个主要地标的世界中行驶:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/546ea203b4d7c5ecd4b0cfcc24527afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1g2rGZO2Y_95kp-toKkTSQ.png"/></div></div></figure><p id="c657" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">汽车上的传感器能够粗略计算汽车和四个地标之间的距离，同时我们初始化大量粒子，每个粒子代表汽车潜在位置的猜测。<strong class="kk iu">基于来自实际汽车的测量和来自虚拟汽车(粒子)的测量，我们应该能够生成每个粒子是实际汽车的后验概率</strong>，并且随着汽车继续移动，不相关的粒子将被逐渐过滤掉。</p><p id="f3a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以一般来说，粒子过滤器包括 4 个步骤:</p><ol class=""><li id="f42c" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">生成一组粒子</li><li id="7ddb" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">测量每个粒子成为实际汽车(机器人)的概率</li><li id="e11d" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">基于概率权重的重采样</li><li id="dd0b" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">重复移动到接近方向</li></ol><p id="077d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们一步一步来。</p><h1 id="b6bc" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">产生粒子</h1><p id="48fb" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">除了粒子是我们对汽车实际位置的猜测，它应该具有实际汽车的所有功能。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a9c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的代码指的是课程<a class="ae le" href="https://classroom.udacity.com/courses/cs373" rel="noopener ugc nofollow" target="_blank">。首先在这个 2D 世界中，一辆汽车被定义为 3 个基本元素<code class="fe ne nf ng nh b">(x, y, orientation)</code>，所以在 init 函数中，它随机初始化这 3 个元素，这里的噪声是每个动作的不确定性。其次在<code class="fe ne nf ng nh b">set</code>和<code class="fe ne nf ng nh b">set_noise</code>功能中我们可以直接设置位置、方向和噪声。第三，汽车应该能够<code class="fe ne nf ng nh b">sense</code>和<code class="fe ne nf ng nh b">move</code>，而<code class="fe ne nf ng nh b">sense</code>测量与每个地标的距离，<code class="fe ne nf ng nh b">move</code>在汽车采取行动后返回新的状态。</a></p><p id="af32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们首先生成一辆真实的汽车:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="md me mf mg gt ni nh nj nk aw nl bi"><span id="7910" class="nm lg it nh b gy nn no l np nq">[x=27.984 y=67.990 orient=4.0437]  # the real location of the car</span></pre><p id="e6a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后生成随机猜测的粒子:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a9a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码生成了 1000 个粒子，每个粒子都有随机初始化，但噪声固定<code class="fe ne nf ng nh b">(0.05, 0.05, 5.0)</code>。</p><pre class="md me mf mg gt ni nh nj nk aw nl bi"><span id="945f" class="nm lg it nh b gy nn no l np nq">[[x=89.958 y=44.058 orient=0.5153],<br/> [x=67.425 y=71.905 orient=3.0930],<br/> [x=11.044 y=60.100 orient=2.3018],<br/> [x=21.359 y=43.892 orient=4.0847],<br/> [x=6.6223 y=41.454 orient=0.8310]]</span></pre><p id="8099" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过打印出初始化，我们可以看到每个粒子可以有非常不同的位置和方向。</p><h1 id="8652" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">测量概率</h1><p id="fa1c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在让我们让汽车行驶，获得每个粒子概率的想法是，通过使用来自实际汽车的测量值，并给出每个粒子的测量值，我们应该能够计算每个粒子成为实际汽车的可能性。让我们看下面的例子:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nr"><img src="../Images/83c37891d011c46eb14b4e5c8d4293a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APSjEiB4nSkXQsZ_dXDQGg.png"/></div></div></figure><p id="c113" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们将仅基于地标 2 的距离测量来测量图中粒子的概率。粒子的距离为 3，噪声为 1，也就是说<strong class="kk iu">测量服从高斯分布</strong> <code class="fe ne nf ng nh b">N(3, 1)</code>，<strong class="kk iu">表示粒子可以用距离 4.2、3.2、5.1、1.2、…，以不同的概率测量自身。</strong>现在问题来了，给定我们的汽车测量值<code class="fe ne nf ng nh b">dist = 5</code>，这个粒子也测量距离 5 的自身的概率是多少？<strong class="kk iu">答案是计算 5 给定分布的概率</strong> <code class="fe ne nf ng nh b">N(3, 1)</code>。</p><p id="912d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以在<code class="fe ne nf ng nh b">robot</code>类中，我们需要增加两个函数:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0c4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过以下方式来衡量每个概率:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a8b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的 1000 个粒子每个都将采取与实际汽车相同的移动，之后，每个粒子将通过<code class="fe ne nf ng nh b">rob.measurement_prob(Z)</code>计算其概率给定测量<code class="fe ne nf ng nh b">Z</code>。</p><p id="cb92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">经过概率计算，靠近实际位置的粒子概率较高，远离实际位置的粒子概率较低。</strong>所以下一步要明确，对粒子进行采样，保留大概率的粒子。</p><h1 id="1310" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">重采样</h1><p id="d866" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在每个粒子都被标注了不同的概率，我们希望保留高概率的粒子，在我们的下一轮迭代中使用它们。这样做的方法是基于概率权重进行重新采样。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0d32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一种相当原始的基于权重的采样方式，我并不完全理解。我猜<code class="fe ne nf ng nh b">np.random.choice</code>也可以做到同样的效果，但是请记住，我们需要基于当前的概率权重重新采样一个相同大小的粒子列表。</p><h1 id="e8d6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">找到方向</h1><p id="83af" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们已经谈了很多关于距离和位置的问题。但是，即使我们能够得到最接近我们的汽车的位置的粒子，我们如何能够确定它的方向呢？</p><p id="4176" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">事实上，我们可以通过汽车行驶到地标的距离来暗示方向。</strong>考虑以下场景:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ns"><img src="../Images/6f427f9e75ddde8e25ca495e17e971b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-FecfbposgVhx1fZ15HEA.png"/></div></div></figure><p id="a7f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有两个粒子，粒子 1 和粒子 2，它们同样接近真实的汽车。然而，粒子 2 朝着我们汽车的同一个方向运动，而粒子 1 则相反。显然，随着时间的推移(更多轮次的迭代)，粒子 1 的概率将显著降低并最终被过滤掉，而粒子 2 更有可能存活下来。</p><p id="23d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以定位方位的方法就是让车多做动作，走的更远。最后，我们需要将代码放入一个循环中:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6c66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终，只有位置和方向最接近的粒子才能存活下来(完整实现<a class="ae le" href="https://github.com/MJeremy2017/Machine-Learning-Models/blob/master/Localisation/particle-filters.ipynb" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p><p id="15bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考</strong>:</p><ol class=""><li id="b7c1" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">【https://classroom.udacity.com/courses/cs373 T4】</li></ol></div></div>    
</body>
</html>