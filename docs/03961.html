<html>
<head>
<title>A beginner’s guide to Kaggle’s Titanic problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡格尔泰坦尼克号问题初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-beginners-guide-to-kaggle-s-titanic-problem-3193cb56f6ca?source=collection_archive---------1-----------------------#2019-06-22">https://towardsdatascience.com/a-beginners-guide-to-kaggle-s-titanic-problem-3193cb56f6ca?source=collection_archive---------1-----------------------#2019-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e3318d052bdf43ffa819da449e277e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OToy8W6uEveeRM0IOO4aVw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image source: Flickr</figcaption></figure><p id="7431" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为这是我的第一篇文章，这里简单介绍一下我一直在做的事情:</p><p id="fcba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我是一名软件开发人员，后来变成了数据爱好者。我最近开始了解数据科学的本质。当我开始通过 Udemy、Coursera 等网站上的视频和课程学习时，最突出的挑战之一就是。这让我变得被动，我听得更多，做得更少。我没有实践经验，尽管我能理解大部分理论。</p><p id="a81e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就在那时，我遇到了 Kaggle，这是一个由多家大型科技公司(如谷歌)主办的网站，提供一系列数据科学问题和竞赛。在世界范围内，Kaggle 以其有趣、具有挑战性和非常非常令人上瘾的问题而闻名。其中一个问题是泰坦尼克号数据集。</p><p id="3e7c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总而言之，泰坦尼克号问题是基于 1912 年初“不沉之船”泰坦尼克号的沉没。它给你提供关于多人的信息，比如他们的年龄、性别、兄弟姐妹数量、登机点以及他们是否在灾难中幸存。基于这些特征，你必须预测泰坦尼克号上的任意一名乘客是否能在沉没中幸存。</p><p id="00a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">听起来很简单，对吧？</p><p id="83c6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">没有。</p><p id="8850" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">问题陈述仅仅是<em class="la"/><em class="la">的冰山一角。</em></p><h1 id="fbca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用的库</h1><ol class=""><li id="9bee" class="lz ma iq ke b kf mb kj mc kn md kr me kv mf kz mg mh mi mj bi translated">熊猫</li><li id="7212" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">海生的</li><li id="96e2" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">Sklearn</li><li id="0fea" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">WordCloud</li></ol><h1 id="b97e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">铺设土地</h1><p id="a8cc" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">初始阶段处理完整数据集的特征。在这里，我没有试图塑造或收集这些特征，只是观察它们的品质。</p><h2 id="1b38" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">1.聚合</h2><p id="ef8c" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">我最初聚集了来自训练和测试数据集的数据。得到的数据集有 1309 行和 12 列。每一行代表了 RMS 泰坦尼克号上的一个独特的乘客，每一列描述了每个乘客不同的有价值的属性。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1202" class="ms lc iq nj b gy nn no l np nq">trd = pd.read_csv('train.csv')<br/>tsd = pd.read_csv('test.csv')</span><span id="1f27" class="ms lc iq nj b gy nr no l np nq">td = pd.concat([trd, tsd], ignore_index=True, sort  = False)</span></pre><h2 id="2462" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">2.缺少值</h2><p id="4704" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">数据集有几列缺少值。“Cabin”属性缺少 1014 个值。描述通勤者登机点的列“已登机”总共有 2 个缺失值。属性“Age”有 263 个缺失值，列“Fare”有一个缺失值。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3063" class="ms lc iq nj b gy nn no l np nq">td.isnull().sum()</span><span id="eea9" class="ms lc iq nj b gy nr no l np nq">sns.heatmap(td.isnull(), cbar = False).set_title("Missing values heatmap")</span></pre><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/f5ee4873f4cb5c56bf522cea112752e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5Gs-sMpdAyEHtZZZcsvYw.png"/></div></div></figure><h2 id="b230" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">3.种类</h2><p id="2167" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">此外，为了理解分类和非分类特性，我查看了每一列中唯一值的数量。属性“性别”和“幸存”有两个可能的值，属性“上船”和“Pclass”有三个可能的值。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="665d" class="ms lc iq nj b gy nn no l np nq">td.nunique()</span><span id="b772" class="ms lc iq nj b gy nr no l np nq">PassengerId    1309<br/>Survived          2<br/>Pclass            3<br/>Name           1307<br/>Sex               2<br/>Age              98<br/>SibSp             7<br/>Parch             8<br/>Ticket          929<br/>Fare            281<br/>Cabin           186<br/>Embarked          3<br/>dtype: int64</span></pre><h1 id="32d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">特征</h1><p id="b4fa" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在对数据集的不同方面有了更好的理解后，我开始探索这些特征以及它们在旅行者的生存或死亡中所起的作用。</p><h2 id="1496" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">1.幸存</h2><p id="652b" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">第一个特写报道了一个旅行者的生死。一项比较显示超过 60%的乘客已经死亡。</p><h2 id="ad22" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">2.Pclass</h2><p id="d0b7" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">此功能呈现乘客分区。游客可以选择三个不同的区域，即一级、二级和三级。第三类的通勤人数最多，其次是第二类和第一类。三等舱的游客人数比一等舱和二等舱的乘客人数加起来还多。一级旅行者的生存机会高于二级和三级旅行者。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/f750f3233e288833c89109cc38e9b4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJEvUpZv46tzakfJPy9UiQ.png"/></div></div></figure><h2 id="fa98" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">3.性</h2><p id="2893" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">大约 65%的游客是男性，其余 35%是女性。然而，女性幸存者的比例高于男性幸存者。超过 80%的男性通勤者死亡，相比之下，约 70%的女性通勤者死亡。</p><h2 id="c559" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">4.年龄</h2><p id="9230" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">船上最小的旅行者大约两个月大，最大的旅行者 80 岁。船上游客的平均年龄不到 30 岁。显然，<strong class="ke ir">10 岁以下儿童存活的比例比死亡的比例大。或其他年龄组，伤亡人数高于幸存者人数。20 至 30 岁年龄组中有超过 140 人死亡，而同年龄组中只有大约 80 人幸存。</strong></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/748be6bdac7885802c1fc44df19f3a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJFghpSagFeXRFosbAyv2g.png"/></div></div></figure><h2 id="0ead" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">5.SibSp</h2><p id="b73c" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">SibSp 是船上一个人的兄弟姐妹或配偶的数量。最多有 8 名兄弟姐妹和配偶与其中一名旅行者同行。<strong class="ke ir">超过 90%的人独自或与他们的兄弟姐妹或配偶之一一起旅行。如果一个人和两个以上的兄弟姐妹或配偶一起旅行，生存机会会急剧下降。</strong></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/8f2e02c0c759edca827f989e99f01839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Nomsldts0q4vAHNPCr1yg.png"/></div></div></figure><h2 id="5d03" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">6.烤</h2><p id="ca4e" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">与 SibSp 类似，该功能包含每位乘客同行的父母或孩子的数量。最多有 9 名父母/子女与其中一名旅行者同行。</p><p id="4d7b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我添加了“Parch”和“SibSp”值的数量，以存储在名为“Family”的新列中</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="b8df" class="ms lc iq nj b gy nn no l np nq">td['Family'] = td.Parch + td.SibSp</span></pre><p id="9e74" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，当一个旅行者独自旅行时，生存的机会会直线上升。创建了另一列，Is_Alone，如果“Family”列中的值为 0，则赋值为 True。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="becc" class="ms lc iq nj b gy nn no l np nq">td['Is_Alone'] = td.Family == 0</span></pre><h2 id="6c46" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">7.票价</h2><p id="7050" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">通过把车费分成四类，很明显，费用和生存之间有很强的联系。游客支付的费用越高，生存的机会就越大。</p><p id="009e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我将分离的费用存储到一个新的列 Fare_Category 中</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1a95" class="ms lc iq nj b gy nn no l np nq">td['Fare_Category'] = pd.cut(td['Fare'], bins=[0,7.90,14.45,31.28,120], labels=['Low','Mid',                                                                                   'High_Mid','High'])</span></pre><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/d50f1eb4cf57bc03115ad2a2b6352052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OYSiUvP57QMoIYO0S0G7A.png"/></div></div></figure><h2 id="8c33" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">8.从事</h2><p id="ad6b" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">apollowed 暗示旅行者从哪里出发。Embark 有三个可能的值— <strong class="ke ir">南安普敦、瑟堡和皇后镇</strong>。超过 70%的人是从南安普敦上船的。不到 20%的乘客从瑟堡登机，其余的从皇后镇登机。从瑟堡登船的人比从南安普敦或皇后镇登船的人有更高的生还机会。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/df592a77784ef62177c545aeccab65e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPOI3nhGpudAJgaOy8OalQ.png"/></div></div></figure><p id="3621" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">值得注意的是，我们没有使用“Ticket”列。</p><h1 id="171f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据插补</h1><p id="77ce" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">数据插补是用一些替代值替换缺失数据的做法。可以使用多种替代方法。我用它们中的一些来弥补缺失的值。</p><h2 id="0111" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">1.从事</h2><p id="f8a1" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">由于“登船”只有两个缺失值，并且从南安普敦登船的通勤者人数最多，因此从南安普敦登船的概率更高。所以，我们用南安普敦来填充缺失的值。然而，我们不是手动输入 Southampton，而是找到 apollowed 列的模式并用它替换丢失的值。众数是一个序列中出现频率最高的元素。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="6611" class="ms lc iq nj b gy nn no l np nq">td.Embarked.fillna(td.Embarked.mode()[0], inplace = True)</span></pre><h2 id="a25b" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">2.小木屋</h2><p id="5960" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">因为“小屋”一栏有很多缺失的数据。我决定将所有缺失的数据归为不同的类别。我把它命名为 NA。我用这个值给所有缺失的值赋值。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="342d" class="ms lc iq nj b gy nn no l np nq">td.Cabin = td.Cabin.fillna('NA')</span></pre><h2 id="ded1" class="ms lc iq bd ld mt mu dn lh mv mw dp ll kn mx my lp kr mz na lt kv nb nc lx nd bi translated">3.年龄</h2><p id="4c87" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">年龄是最难填写的一栏。年龄有 263 个缺失值。我最初是根据人们的称呼来给他们分类的。一个基本的 Python 字符串分割足以从每个名字中提取标题。有 18 个不同的标题。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ba39" class="ms lc iq nj b gy nn no l np nq">td['Salutation'] = td.Name.apply(lambda name: name.split(',')[1].split('.')[0].strip())</span></pre><p id="42f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我将这些标题按照性别和类别进行了分类。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1245" class="ms lc iq nj b gy nn no l np nq">grp = td.groupby(['Sex', 'Pclass'])</span></pre><p id="4ef5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后在缺失的行中替换该组的中间值。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="8bc8" class="ms lc iq nj b gy nn no l np nq">grp.Age.apply(lambda x: x.fillna(x.median()))<br/>td.Age.fillna(td.Age.median, inplace = True)</span></pre><h1 id="790d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编码</h1><p id="a3f8" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">由于字符串数据不适合机器学习算法，我需要将非数字数据转换成数字数据。我用 LabelEncoder 对“性别”一栏进行了编码。标签编码器会用某个数字代替“男性”值，用某个不同的数字代替“女性”值。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3d1b" class="ms lc iq nj b gy nn no l np nq">td['Sex'] = LabelEncoder().fit_transform(td['Sex'])</span></pre><p id="4e21" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于其他分类数据，我使用熊猫的假人。它添加对应于所有可能值的列。因此，如果有三个装载值——Q、C、S，get_dummies 方法将创建三个不同的列，并根据装载点分配值 0 或 1。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="646b" class="ms lc iq nj b gy nn no l np nq">pd.get_dummies(td.Embarked, prefix="Emb", drop_first = True)</span></pre><h1 id="3d61" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">删除列</h1><p id="a19c" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">此外，我删除了预测中不需要的列以及通过创建虚拟列而编码的列。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="bd2b" class="ms lc iq nj b gy nn no l np nq">td.drop(['Pclass', 'Fare','Cabin', 'Fare_Category','Name','Salutation', 'Deck', 'Ticket','Embarked', 'Age_Range', 'SibSp', 'Parch', 'Age'], axis=1, inplace=True)</span></pre><h1 id="770d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">预言；预测；预告</h1><p id="3ab5" class="pw-post-body-paragraph kc kd iq ke b kf mb kh ki kj mc kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">这是一个分类问题的例子，我试着用两种算法预测—</p><ol class=""><li id="612d" class="lz ma iq ke b kf kg kj kk kn ny kr nz kv oa kz mg mh mi mj bi translated">随机森林</li><li id="ac95" class="lz ma iq ke b kf mk kj ml kn mm kr mn kv mo kz mg mh mi mj bi translated">高斯朴素贝叶斯</li></ol><p id="0982" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我对结果感到惊讶。高斯朴素算法表现不佳，而另一方面，随机森林的预测准确率始终在 80%以上。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="523f" class="ms lc iq nj b gy nn no l np nq"># Data to be predicted<br/>X_to_be_predicted = td[td.Survived.isnull()]<br/>X_to_be_predicted = X_to_be_predicted.drop(['Survived'], axis = 1)<br/># X_to_be_predicted[X_to_be_predicted.Age.isnull()]<br/># X_to_be_predicted.dropna(inplace = True) # 417 x 27</span><span id="5266" class="ms lc iq nj b gy nr no l np nq">#Training data<br/>train_data = td<br/>train_data = train_data.dropna()<br/>feature_train = train_data['Survived']<br/>label_train  = train_data.drop(['Survived'], axis = 1)</span><span id="c951" class="ms lc iq nj b gy nr no l np nq">##Gaussian<br/>clf = GaussianNB()<br/>x_train, x_test, y_train, y_test = train_test_split(label_train, feature_train, test_size=0.2)<br/>clf.fit(x_train,  np.ravel(y_train))<br/>print("NB Accuracy: "+repr(round(clf.score(x_test, y_test) * 100, 2)) + "%")<br/>result_rf=cross_val_score(clf,x_train,y_train,cv=10,scoring='accuracy')<br/>print('The cross validated score for Random forest is:',round(result_rf.mean()*100,2))<br/>y_pred = cross_val_predict(clf,x_train,y_train,cv=10)<br/>sns.heatmap(confusion_matrix(y_train,y_pred),annot=True,fmt='3.0f',cmap="summer")<br/>plt.title('Confusion_matrix for NB', y=1.05, size=15)</span></pre><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/d702623bb59b2698d38c8c634243533e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEITuEXsRI-yGhq3CLOdqA.png"/></div></div></figure><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="703a" class="ms lc iq nj b gy nn no l np nq">##Random forest<br/>clf = RandomForestClassifier(criterion='entropy', <br/>                             n_estimators=700,<br/>                             min_samples_split=10,<br/>                             min_samples_leaf=1,<br/>                             max_features='auto',<br/>                             oob_score=True,<br/>                             random_state=1,<br/>                             n_jobs=-1)<br/>x_train, x_test, y_train, y_test = train_test_split(label_train, feature_train, test_size=0.2)<br/>clf.fit(x_train,  np.ravel(y_train))<br/>print("RF Accuracy: "+repr(round(clf.score(x_test, y_test) * 100, 2)) + "%")</span><span id="f2ec" class="ms lc iq nj b gy nr no l np nq">result_rf=cross_val_score(clf,x_train,y_train,cv=10,scoring='accuracy')<br/>print('The cross validated score for Random forest is:',round(result_rf.mean()*100,2))<br/>y_pred = cross_val_predict(clf,x_train,y_train,cv=10)<br/>sns.heatmap(confusion_matrix(y_train,y_pred),annot=True,fmt='3.0f',cmap="summer")<br/>plt.title('Confusion_matrix for RF', y=1.05, size=15)</span></pre><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/3a08dc219b125a7c550e23f190e8e4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNQbtavqmmaN5idWNLVqsg.png"/></div></div></figure><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2e38" class="ms lc iq nj b gy nn no l np nq">RF Accuracy: 78.77%<br/>The cross validated score for Random forest is: 84.56</span></pre><p id="f29d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我创建了一个提交文件来存储预测的结果。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="53d8" class="ms lc iq nj b gy nn no l np nq">result = clf.predict(X_to_be_predicted)<br/>submission = pd.DataFrame({'PassengerId':X_to_be_predicted.PassengerId,'Survived':result})<br/>submission.Survived = submission.Survived.astype(int)<br/>print(submission.shape)<br/>filename = 'Titanic Predictions.csv'<br/>submission.to_csv(filename,index=False)<br/>print('Saved file: ' + filename)</span></pre><p id="4dca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的代码行特别重要，因为如果幸存值不是 int 数据类型，Kaggle 会认为预测是错误的</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="b8a0" class="ms lc iq nj b gy nn no l np nq">submission.Survived = submission.Survived.astype(int)</span></pre><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/ebc04b8c4fb848a70a38d628db93adfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdkNZGBlttsBnAb5nmK1EQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Submission result</figcaption></figure><p id="7bee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完整的实现 Jupyter 笔记本可以在我的<a class="ae oe" href="https://github.com/sumitmukhija/Titanic" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或者<a class="ae oe" href="https://www.kaggle.com/sumukhija/top-8-tip-of-the-iceberg-eda-prediction" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到。提交的作品让我进入了前 8%的参赛者。这并不容易，我尝试了 20 多次才到达那里。我会说关键是要善于分析，玩转分析，凭直觉去尝试一切，不管这听起来有多荒谬。</p></div></div>    
</body>
</html>