<html>
<head>
<title>10 Python Pandas tricks that make your work more efficient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的工作更有效率的 10 个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-python-pandas-tricks-that-make-your-work-more-efficient-2e8e483808ba?source=collection_archive---------0-----------------------#2019-03-13">https://towardsdatascience.com/10-python-pandas-tricks-that-make-your-work-more-efficient-2e8e483808ba?source=collection_archive---------0-----------------------#2019-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有些命令您可能已经知道，但可能不知道它们可以这样使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/055d47294ac89aec8311021f9e61dbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zC8lx7tciV1hM6nKrMS2A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo from <a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a></figcaption></figure><p id="7915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是一个广泛用于结构化数据的 Python 包。有很多很好的教程，但在这里我还是想介绍一些读者以前可能不知道的很酷的技巧，我相信它们是有用的。</p><h1 id="893e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">阅读 _csv</h1><p id="6600" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个人都知道这个命令。但是您试图读取的数据很大，尝试添加这个参数:<strong class="lb iu"> nrows = 5 </strong>以便在实际加载整个表之前只读取表的一小部分。那么你可以通过选择错误的分隔符来避免这个错误(它可能不总是用逗号分隔)。</p><p id="6108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(或者，您可以使用 linux 中的' head '命令检查任何文本文件中的前 5 行:<strong class="lb iu"> head -n 5 data.txt </strong>(感谢<strong class="lb iu"> Ilya Levinson </strong>在这里指出了一个拼写错误))</p><p id="5e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，可以通过使用<code class="fe ms mt mu mv b">df.columns.tolist()</code>提取所有列来提取列列表，然后添加<strong class="lb iu"> usecols = ['c1 '，' c2 '，…]【T10]参数来加载需要的列。此外，如果您知道一些特定列的数据类型，您可以添加参数<strong class="lb iu"> dtype = {'c1': str，' c2': int，…} </strong>，这样它会加载得更快。这个参数的另一个优点是，如果您有一个既包含字符串又包含数字的列，那么将它的类型声明为 string 是一个很好的做法，这样当您试图使用这个列作为键来合并表时就不会出现错误。</strong></p><h1 id="51fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">select_dtypes</h1><p id="fe3b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果数据预处理必须在 Python 中完成，那么这个命令会节省您一些时间。读入表后，每列的默认数据类型可以是 bool、int64、float64、object、category、timedelta64 或 datetime64。您可以首先通过以下方式检查分布</p><p id="ee59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">df.dtypes.value_counts()</code></p><p id="e108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解数据帧的所有可能的数据类型，那么</p><p id="77c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">df.select_dtypes(include=['float64', 'int64'])</code></p><p id="10fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择只有数字特征的子数据帧。</p><h1 id="ee83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">复制</h1><p id="df2a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您还没有听说过，这是一个重要的命令。如果您执行以下命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5d7a" class="na lw it mv b gy nb nc l nd ne">import pandas as pd<br/>df1 = pd.DataFrame({ 'a':[0,0,0], 'b': [1,1,1]})<br/>df2 = df1<br/>df2['a'] = df2['a'] + 1<br/>df1.head()</span></pre><p id="e7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会发现 df1 变了。这是因为 df2 = df1 不是制作 df1 的副本并将其分配给 df2，而是建立一个指向 df1 的指针。所以 df2 的任何变化都会导致 df1 的变化。要解决这个问题，您可以</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2510" class="na lw it mv b gy nb nc l nd ne">df2 = df1.copy()</span></pre><p id="eafe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2e6e" class="na lw it mv b gy nb nc l nd ne">from copy import deepcopy<br/>df2 = deepcopy(df1)</span></pre><h1 id="be19" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">地图</h1><p id="0a1f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个很酷的命令，可以进行简单的数据转换。首先定义一个字典，其中“键”是旧值，“值”是新值。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="102c" class="na lw it mv b gy nb nc l nd ne">level_map = {1: 'high', 2: 'medium', 3: 'low'}<br/>df['c_level'] = df['c'].map(level_map)</span></pre><p id="1b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举几个例子:真，假到 1，0(用于建模)；定义级别；用户定义的词汇编码。</p><h1 id="0efe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">申请还是不申请？</h1><p id="1a4c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们想创建一个新列，并以其他几列作为输入，apply 函数有时会非常有用。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="223e" class="na lw it mv b gy nb nc l nd ne">def rule(x, y):<br/>    if x == 'high' and y &gt; 10:<br/>         return 1<br/>    else:<br/>         return 0</span><span id="6f8f" class="na lw it mv b gy nf nc l nd ne">df = pd.DataFrame({ 'c1':[ 'high' ,'high', 'low', 'low'], 'c2': [0, 23, 17, 4]})<br/>df['new'] = df.apply(lambda x: rule(x['c1'], x['c2']), axis =  1)<br/>df.head()</span></pre><p id="1a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们定义了一个具有两个输入变量的函数，并使用 apply 函数将其应用于列“c1”和“c2”。</p><p id="8ae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是“应用”的问题是它有时太慢了。比方说，如果你想计算两列“c1”和“c2”的最大值，你当然可以这样做</p><p id="7c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">df['maximum'] = df.apply(lambda x: max(x['c1'], x['c2']), axis = 1)</code></p><p id="b73b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您会发现它比这个命令慢得多:</p><p id="31ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">df['maximum'] = df[['c1','c2']].max(axis =1)</code></p><p id="98d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">要点</strong>:如果你可以用其他内置函数完成同样的工作，就不要使用 apply(它们通常更快)。例如，如果要将列' c '舍入为整数，请执行<strong class="lb iu"> round(df['c']，0) </strong>或<strong class="lb iu"> df['c']。round(0) </strong>而不是使用应用函数:<code class="fe ms mt mu mv b">df.apply(lambda x: round(x['c'], 0), axis = 1)</code>。</p><h1 id="380f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">值计数</h1><p id="0012" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个检查值分布的命令。例如，如果您想检查“c”列中每个单独值的可能值和频率，您可以</p><p id="e145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">df['c'].value_counts()</code></p><p id="92e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些有用的技巧/论据:<br/> A. <strong class="lb iu"> normalize = True </strong>:如果你想检查频率而不是计数。dropna = False :如果你也想在统计数据中包含丢失的值。<br/> C. <code class="fe ms mt mu mv b">df['c'].value_counts().reset_index()</code>:如果您想将统计表转换成熊猫数据帧并对其进行操作<br/> D. <code class="fe ms mt mu mv b">df['c'].value_counts().reset_index().sort_values(by='index')</code>:在‘c’列中显示按不同值排序的统计数据，而不是计数。</p><p id="7ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(更新 2019.4.18 —针对上面的 d，<strong class="lb iu">郝洋</strong>指出了一个更简单的办法，没有。reset_index(): <code class="fe ms mt mu mv b">df['c'].value_counts().sort_index()</code></p><h1 id="9d7c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">缺失值的数量</h1><p id="74b7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">构建模型时，您可能希望排除缺少太多值的行/缺少所有值的行。你可以用。isnull()和。sum()计算指定列中缺失值的数量。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f050" class="na lw it mv b gy nb nc l nd ne">import pandas as pd<br/>import numpy as np</span><span id="5191" class="na lw it mv b gy nf nc l nd ne">df = pd.DataFrame({ 'id': [1,2,3], 'c1':[0,0,np.nan], 'c2': [np.nan,1,1]})<br/>df = df[['id', 'c1', 'c2']]<br/>df['num_nulls'] = df[['c1', 'c2']].isnull().sum(axis=1)<br/>df.head()</span></pre><h1 id="b2a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">选择具有特定 id 的行</h1><p id="a7d2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在 SQL 中，我们可以使用 SELECT * FROM … WHERE ID in ('A001 '，' C022 '，…)来获得具有特定 ID 的记录。如果你想对熊猫做同样的事情，你可以做</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4920" class="na lw it mv b gy nb nc l nd ne">df_filter = df['ID'].isin(['A001','C022',...])<br/>df[df_filter]</span></pre><h1 id="261c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">百分位组</h1><p id="c90c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您有一个数字列，并且想要将该列中的值分组，比如前 5%归入第 1 组，5–20%归入第 2 组，20%-50%归入第 3 组，后 50%归入第 4 组。当然，你可以用熊猫来做。切，但我想在这里提供另一种选择:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2743" class="na lw it mv b gy nb nc l nd ne">import numpy as np<br/>cut_points = [np.percentile(df['c'], i) for i in [50, 80, 95]]<br/>df['group'] = 1<br/>for i in range(3):<br/>    df['group'] = df['group'] + (df['c'] &lt; cut_points[i])<br/># or &lt;= cut_points[i]</span></pre><p id="d775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行速度更快(不使用应用函数)。</p><h1 id="5535" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">to_csv</h1><p id="9bd9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">同样，这是每个人都会使用的命令。这里我想指出两个窍门。第一个是</p><p id="5f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">print(df[:5].to_csv())</code></p><p id="0413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用这个命令准确地打印出将要写入文件的前五行。</p><p id="e0c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个技巧是处理混合在一起的整数和缺失值。如果一个列同时包含缺失值和整数，数据类型仍然是 float 而不是 int。导出表格时，可以添加<strong class="lb iu"> float_format='%.0f' </strong>将所有浮点数四舍五入为整数。如果您只想要所有列的整数输出，就使用这个技巧——您将去掉所有烦人的“. 0”</p></div></div>    
</body>
</html>