<html>
<head>
<title>Stacking made easy with Sklearn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sklearn 让堆叠变得简单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stacking-made-easy-with-sklearn-e27a0793c92b?source=collection_archive---------7-----------------------#2019-12-10">https://towardsdatascience.com/stacking-made-easy-with-sklearn-e27a0793c92b?source=collection_archive---------7-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4375036ac1673abf954a4825109fbbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6V4BCpQUhKTt5u63YQsEkg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@jeremythomasphoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jeremy Thomas</a> on <a class="ae jg" href="https://unsplash.com/s/photos/balance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="ec9f" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">sci kit-学习</h2><div class=""/><div class=""><h2 id="3cc0" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">用几行代码创建一个 StackingClassifier</h2></div><h1 id="30d8" class="lh li jj bd lj lk ll lm ln lo lp lq lr ky ls kz lt lb lu lc lv le lw lf lx ly bi translated">介绍</h1><p id="4d41" class="pw-post-body-paragraph lz ma jj mb b mc md kt me mf mg kw mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">整体方法的基本原则是在统一中发现力量。通过组合多种方法，每种方法都有自己的优缺点，可以创建更强大的模型。</p><blockquote class="mv mw mx"><p id="5e15" class="lz ma my mb b mc mz kt me mf na kw mh nb nc mk ml nd ne mo mp nf ng ms mt mu im bi translated">整体大于部分之和——亚里士多德</p></blockquote><p id="4a61" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">这句话尤其适用于堆叠，这是一种将许多不同的学习者组合成一个更强大的模型的方法。</p><p id="02aa" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">写这篇文章的主要原因不是解释堆栈是如何工作的，而是演示如何使用<strong class="mb jt"> Scikit-Learn V0.22 </strong>来简化堆栈管道并创建有趣的模型。</p><h1 id="1512" class="lh li jj bd lj lk ll lm ln lo lp lq lr ky ls kz lt lb lu lc lv le lw lf lx ly bi translated">1.堆垛</h1><p id="6351" class="pw-post-body-paragraph lz ma jj mb b mc md kt me mf mg kw mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">尽管有许多很棒的资料来源介绍了堆栈(这里的<a class="ae jg" href="https://www.kaggle.com/arthurtok/introduction-to-ensembling-stacking-in-python" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae jg" rel="noopener" target="_blank" href="/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205"/>和这里的<a class="ae jg" href="https://blog.statsbot.co/ensemble-learning-d1dcd548e936" rel="noopener ugc nofollow" target="_blank"/>)，但是让我快速地让您了解一下。</p><p id="9140" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">堆叠是一种技术，它采用几个回归或分类模型，并使用它们的输出作为元分类器/回归器的输入。</p><p id="256c" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">本质上，堆叠是一种集成学习技术，很像随机森林，通过组合典型的弱模型来提高预测的质量。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/220665e44730c6d8325629921cd11bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsTcX5N6FXQW1bGhS9hxJQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Overview of a single level Stacking model</figcaption></figure><p id="ad47" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">上图给出了堆叠原理的基本概述。它通常由许多弱基础学习或几个强基础学习组成。然后，元学习器基于每个基础学习器的预测输出进行学习。</p><h1 id="7318" class="lh li jj bd lj lk ll lm ln lo lp lq lr ky ls kz lt lb lu lc lv le lw lf lx ly bi translated">2.Sklearn 堆叠</h1><p id="f1b6" class="pw-post-body-paragraph lz ma jj mb b mc md kt me mf mg kw mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">虽然有许多包可以用于堆叠，如<a class="ae jg" href="http://rasbt.github.io/mlxtend/user_guide/classifier/StackingClassifier/" rel="noopener ugc nofollow" target="_blank"> mlxtend </a>和<a class="ae jg" href="https://github.com/vecxoz/vecstack" rel="noopener ugc nofollow" target="_blank"> vecstack </a>，但本文将深入探讨 scikit-learn 新版本中新添加的堆叠回归器和分类器。</p><p id="811c" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">首先，我们需要确保将 Scikit-learn 升级到版本 0.22:</p><p id="ee9a" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated"><code class="fe nm nn no np b">pip install --upgrade scikit-learn</code></p><p id="0ead" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">我们要做的第一个模型是一个分类器，可以预测花的规格。该模型相对简单，我们使用随机森林和 k 近邻作为我们的基本学习器，使用逻辑回归作为我们的元学习器。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/fe42bb2a8330cdccb468ce67195879c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XxziIgU0I7mpN50uh19jg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">One-layer Stacking Model</figcaption></figure><p id="5d2a" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">编码堆叠模型可能相当棘手，因为您将不得不考虑您想要在不同步骤生成的折叠和交叉验证。幸运的是，新的 scikit-learn 版本只需几行代码就可以创建如上所示的模型:</p><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8772" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">基本上就是这样！只有几行代码的堆叠分类器。</p><h1 id="51f3" class="lh li jj bd lj lk ll lm ln lo lp lq lr ky ls kz lt lb lu lc lv le lw lf lx ly bi translated">3.交叉验证</h1><p id="3714" class="pw-post-body-paragraph lz ma jj mb b mc md kt me mf mg kw mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">堆叠的一个困难是您选择在哪里应用交叉验证。我们可以只在元学习者级别应用它，但是这可能会导致我们的模型过拟合，因为基础学习者的输出可能已经过拟合了。</p><p id="6358" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">尽管有许多解决这个问题的策略，但在 scikit-learn 中，堆栈的实现如下:</p><blockquote class="mv mw mx"><p id="5588" class="lz ma my mb b mc mz kt me mf na kw mh nb nc mk ml nd ne mo mp nf ng ms mt mu im bi translated">基础学习者适合于完整的<code class="fe nm nn no np b">X</code>，而最终估计者则通过使用<code class="fe nm nn no np b">cross_val_predict</code>的基础学习者的交叉验证预测来训练。</p></blockquote><p id="de38" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">这意味着每个单独的基础学习者的预测被堆叠在一起，并被用作元学习者的输入来计算预测。然后通过交叉验证来训练这个元学习者。</p><p id="3f68" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">交叉验证自动设置为 5 倍 CV，但可以手动调整:</p><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aa90" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">但这还不是全部，您还可以加入任何您想要的交叉验证策略:</p><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="57fe" class="lh li jj bd lj lk ll lm ln lo lp lq lr ky ls kz lt lb lu lc lv le lw lf lx ly bi translated">4.多层堆叠</h1><p id="1d6f" class="pw-post-body-paragraph lz ma jj mb b mc md kt me mf mg kw mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在第 2 步中，我们已经创建了一个具有单层基本学习者的 StackingClassifier。但是如果你想用另一组基础学习者代替元学习者呢？你如何添加层来增加模型的复杂性？</p><p id="8b1e" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">这里，我们将在步骤 2 中向模型添加另一层学习者，以便了解如何编写解决方案。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/619988c57fa8d19eb62f19e4b86b082f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q98mnJbUPR6M7DkztDQXGA.png"/></div></div></figure><p id="8ba3" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">在上图中，我们可以看到我们想要添加一个包含两个额外分类器的层，即一个决策树和一个随机森林。</p><p id="326d" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">为了做到这一点，我们创建了两个估计列表，每层一个。我们使用最终模型的第二层估计量，即逻辑回归，创建一个 StackingClassifier。然后，我们用第一层估计器创建一个新的 StackingClassifier 来创建完整的模型管道。</p><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f992" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">正如你所看到的，模型的复杂性随着每一层的增加而迅速增加。此外，如果没有适当的交叉验证，您很容易使用这么多的层来填充数据。</p><h1 id="c74c" class="lh li jj bd lj lk ll lm ln lo lp lq lr ky ls kz lt lb lu lc lv le lw lf lx ly bi translated">结论</h1><p id="0ae9" class="pw-post-body-paragraph lz ma jj mb b mc md kt me mf mg kw mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">堆叠可能是一个棘手的问题，因为它需要对数据泄漏有深刻的理解，以便选择正确的程序。确保总是对你的模型进行广泛的验证，以便理解它的普遍性。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="c201" class="pw-post-body-paragraph lz ma jj mb b mc mz kt me mf na kw mh mi nc mk ml mm ne mo mp mq ng ms mt mu im bi translated">如果你像我一样，对人工智能、数据科学或心理学充满热情，请随时在<a class="ae jg" href="https://www.linkedin.com/in/mgrootendorst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上添加我。</p></div></div>    
</body>
</html>