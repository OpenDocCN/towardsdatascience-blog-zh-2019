<html>
<head>
<title>Time Series Machine Learning Analysis and Demand Forecasting with H2O &amp; TSstudio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列机器学习分析和需求预测与 H2O 和 TSstudio</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-machine-learning-analysis-and-demand-forecasting-with-h2o-tsstudio-b21cd58749b1?source=collection_archive---------22-----------------------#2019-12-11">https://towardsdatascience.com/time-series-machine-learning-analysis-and-demand-forecasting-with-h2o-tsstudio-b21cd58749b1?source=collection_archive---------22-----------------------#2019-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="996f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我如何使用机器学习来实现每周收入的时间序列预测</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ad89c6742773235fdee97eda6b707f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*340zfmgpTCZKY-ch"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@benelwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ben Elwood</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统的时间序列分析和预测方法，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Linear_regression" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Exponential_smoothing" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">霍尔特-温特斯指数平滑</strong> </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Autoregressive%E2%80%93moving-average_model" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">ARMA/ARIMA/萨里玛</strong> </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Autoregressive_conditional_heteroskedasticity" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> ARCH/GARCH </strong> </a>，已经建立了几十年，并在<strong class="lb iu">商业和金融</strong>(例如预测股票价格和分析金融市场的趋势)<strong class="lb iu"/></p><p id="1349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，开源框架的普及和更广泛的可用性，如<a class="ae ky" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Keras </strong> </a>、<a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> TensorFlow </strong> </a>和<a class="ae ky" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> scikit-learn </strong> </a>帮助机器学习方法，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">【随机森林】</strong> </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/XGBoost" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">极端梯度提升</strong>、</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Time_delay_neural_network" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">时间延迟神经网络</strong> </a>这些技术允许通过一组时间延迟将历史信息作为输入引入模型。</p><p id="87f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与更传统的方法相比，使用机器学习模型的优势在于，它们可以有<code class="fe lv lw lx ly b">higher predictive power</code>，尤其是当预测器与响应有明确的因果联系时。此外，它们可以处理大量输入的复杂计算。</p><p id="9188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，它们往往有<code class="fe lv lw lx ly b">wider array of tuning parameters</code>，一般都是<code class="fe lv lw lx ly b">more complex</code>比【经典】型号多，而且可以<code class="fe lv lw lx ly b">expensive</code>来上手，无论是计算能力还是时间。更重要的是，他们的<code class="fe lv lw lx ly b">black box</code>本性使得他们的输出更难解释，并催生了不断增长的<a class="ae ky" href="https://www.h2o.ai/wp-content/uploads/2019/08/An-Introduction-to-Machine-Learning-Interpretability-Second-Edition.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">机器学习可解释性</strong> </a>(我不打算触及这一点，因为这超出了项目的范围)</p><h1 id="c99d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">项目结构</h1><p id="9db1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这个项目中，我将详细解释用机器学习模型对时间序列数据建模所需的各个步骤。</p><p id="8413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中包括:</p><ul class=""><li id="8938" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">探索性时间序列分析</strong></li><li id="bf55" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">特征工程</strong></li><li id="83dc" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">模型训练和验证</strong></li><li id="ea87" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">模型性能对比及预测</strong></li></ul><p id="3985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，我使用<code class="fe lv lw lx ly b">TSstudio</code>来执行“传统的”时间序列<strong class="lb iu">探索性分析</strong>来描述时间序列及其组成部分，并展示如何使用我收集的洞察力来<strong class="lb iu">为机器学习管道创建特征</strong>以最终生成每周收入预测。</p><p id="e95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于建模和预测，我选择了高性能、开源的机器学习库。我正在安装各种机器学习模型，例如<strong class="lb iu">广义线性模型</strong>、<strong class="lb iu">梯度推进机器</strong>和<strong class="lb iu">随机森林</strong>，并且还使用<strong class="lb iu"> AutoML </strong>进行<em class="nk">自动机器学习</em>，这是<code class="fe lv lw lx ly b">H2O</code>库最令人兴奋的特性之一。</p><h1 id="57e9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">数据</h1><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="9617" class="np ma it ly b gy nq nr l ns nt">library(tidyverse) <br/>library(lubridate) <br/>library(readr) <br/>library(TSstudio) <br/>library(scales) <br/>library(plotly) <br/>library(h2o) <br/>library(vip) <br/>library(gridExtra) </span></pre><p id="18b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里使用的数据集附带了一个红皮书出版物，可以在附加资料部分免费下载。这些数据涵盖了<strong class="lb iu">样本户外公司</strong>的销售额<code class="fe lv lw lx ly b">orders</code>，这是一家虚构的 B2B 户外设备零售企业，并提供了他们销售的<code class="fe lv lw lx ly b">products</code>以及他们的客户(在他们的案例中是<code class="fe lv lw lx ly b">retailers</code>)的详细信息。由于它的<strong class="lb iu">人工性质</strong>，这个系列呈现了一些古怪和怪癖，我将在整个项目中指出这些。</p><p id="35db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我只是加载已编译的数据集，但如果你想继续，我也写了一篇名为<a class="ae ky" href="https://diegousai.io/2019/09/loading-merging-and-joining-datasets/" rel="noopener ugc nofollow" target="_blank">加载、合并和连接数据集</a>的文章，其中我展示了我如何组装各种数据馈送，并整理出变量命名、新功能创建和一些常规内务任务等内容。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="f421" class="np ma it ly b gy nq nr l ns nt"># Import orders <br/>orders_tmp &lt;- <br/>read_rds("orders_tbl.rds")</span></pre><p id="541b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的 Github 库上找到完整的代码。</p><h1 id="8ff8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">初步探索</h1><p id="8182" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">时间序列数据有一组独特的特征，如<em class="nk">时间戳</em>、<em class="nk">频率</em>和<em class="nk">周期/时期</em>，它们在描述性和预测性分析中都有应用。r 提供了几个类来表示时间序列对象(<code class="fe lv lw lx ly b">xts</code>和<code class="fe lv lw lx ly b">zoo</code>仅举几个主要的例子)，但是为了涵盖这个项目的<strong class="lb iu">描述性分析</strong>，我选择了使用<code class="fe lv lw lx ly b">ts</code>类，它由<code class="fe lv lw lx ly b">TSstudio</code>库支持。</p><p id="24b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">TSstudio</code>附带了一些非常有用的功能，用于时间序列对象的交互式可视化。我真的很喜欢这个库使用<em class="nk">作为它的可视化引擎！</em></p><p id="ccde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我选择我的分析所需的数据(在本例中是<code class="fe lv lw lx ly b">order_date</code>和<code class="fe lv lw lx ly b">revenue</code>，并将其聚合为一个<strong class="lb iu">周频率</strong>。我用一个<code class="fe lv lw lx ly b">_tmp</code>后缀来标记这个数据集，表示它是一个<em class="nk">临时</em>版本，在它可以使用之前还需要一些步骤。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="b755" class="np ma it ly b gy nq nr l ns nt">revenue_tmp &lt;- orders_tmp %&gt;% <br/># filter out final month of the series, which is incomplete filter(order_date &lt;= "2007-06-25") %&gt;% <br/>select(order_date, revenue) %&gt;% <br/>mutate(order_date = <br/>         floor_date(order_date, <br/>                    unit = 'week', <br/>                    # setting up week commencing Monday <br/>                    week_start = getOption("lubridate.week.start", 1))<br/>                    ) %&gt;% <br/>group_by(order_date) %&gt;% <br/>summarise(revenue = sum(revenue)) %&gt;% <br/>ungroup()</span><span id="43ba" class="np ma it ly b gy nu nr l ns nt">revenue_tmp %&gt;% str() </span><span id="f807" class="np ma it ly b gy nu nr l ns nt">## Classes 'tbl_df', 'tbl' and 'data.frame': 89 obs. of 2 variables: <br/>## $ order_date: Date, format: "2004-01-12" "2004-01-19" ... <br/>## $ revenue : num 58814754 13926869 55440318 17802526 52553592 ...</span></pre><p id="0be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个系列跨越了<strong class="lb iu">3&amp;1/2 年</strong>的销售额<code class="fe lv lw lx ly b">orders</code>，所以我应该期望<strong class="lb iu">至少有 182 个数据点</strong>，但是<strong class="lb iu">只有 89 个观察值</strong>！</p><p id="9fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看发生了什么:</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="e355" class="np ma it ly b gy nq nr l ns nt">revenue_tmp %&gt;% head(10) </span><span id="2cb7" class="np ma it ly b gy nu nr l ns nt">## # A tibble: 10 x 2 <br/>## order_date revenue <br/>## &lt;date&gt; &lt;dbl&gt; <br/>## 1 2004-01-12 58814754. <br/>## 2 2004-01-19 13926869. <br/>## 3 2004-02-09 55440318. <br/>## 4 2004-02-16 17802526. <br/>## 5 2004-03-08 52553592. <br/>## 6 2004-03-15 23166647. <br/>## 7 2004-04-12 39550528. <br/>## 8 2004-04-19 25727831. <br/>## 9 2004-05-10 41272154. <br/>## 10 2004-05-17 33423065.</span></pre><p id="2448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这里需要注意一些事情:</strong>这个系列呈现出一种不同寻常的每周模式，平均每月记录两次销售。此外，2004 年的第一周没有任何销售记录。</p><p id="fb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe lv lw lx ly b">ts</code>对象进行时间序列分析，我需要确保我每年有整整 52 周的时间，这也应该包括没有销售额的几周。</p><p id="b546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在将我的数据转换成一个<code class="fe lv lw lx ly b">ts</code>对象之前，我需要:</p><ul class=""><li id="d122" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">在系列开始处增加 1 次观察</strong>以确保第一年包括 52 次每周观察</li><li id="6bdb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">一切都是按时间顺序排列的。</strong>这一点尤其重要，因为输出可能无法正确映射到序列的实际索引，从而导致不准确的结果。</li><li id="eadb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">填补不完整日期时间变量的空白。</strong><code class="fe lv lw lx ly b">padr</code>库中的<code class="fe lv lw lx ly b">pad</code>函数为每个缺失的时间点插入一条记录(默认填充值为 NA)</li><li id="ea93" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">用零替换缺失值</strong>，因为空周没有销售记录。来自<code class="fe lv lw lx ly b">padr</code>库的<code class="fe lv lw lx ly b">fill_by_value</code>函数对此有所帮助。</li></ul><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="c9a5" class="np ma it ly b gy nq nr l ns nt">revenue_tbl &lt;- <br/>  revenue_tmp %&gt;% <br/>    rbind(list('2004-01-05', NA, NA)) %&gt;% <br/>    arrange(order_date) %&gt;% <br/>    padr::pad() %&gt;% <br/>    padr::fill_by_value(value = 0)</span><span id="5874" class="np ma it ly b gy nu nr l ns nt">revenue_tbl %&gt;% summary() </span><span id="bfda" class="np ma it ly b gy nu nr l ns nt">## order_date revenue <br/>## Min. :2004-01-05 Min. : 0 <br/>## 1st Qu.:2004-11-15 1st Qu.: 0 <br/>## Median :2005-09-26 Median : 0 <br/>## Mean :2005-09-26 Mean :24974220 <br/>## 3rd Qu.:2006-08-07 3rd Qu.:52521082 <br/>## Max. :2007-06-18 Max. :93727081</span></pre><p id="f7bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我可以看看<strong class="lb iu">周收入</strong>，我的反应变量</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="e59c" class="np ma it ly b gy nq nr l ns nt">revenue_tbl %&gt;% <br/>  ggplot(aes(x = order_date, y = revenue)) + <br/>  geom_line(colour = 'darkblue') + <br/>  theme_light() + <br/>  scale_y_continuous(labels = scales::dollar_format(scale = 1e-6, <br/>                                                    suffix = "m")) +<br/>  labs(title = 'Weekly Revenue - 2004 to June 2007', <br/>       x = "", <br/>       y = 'Revenue ($m)')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/3640889d1260abcc92d8845688661a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M1nK6UFBf8-NVyga.png"/></div></div></figure><p id="dc58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，该系列是人为生成的，并不一定反映现实生活中会发生什么。如果这是一个实际的分析咨询项目，我肯定会质疑我的客户每周的销售频率。</p><p id="5562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但假设这是真实的交易，<strong class="lb iu">这里的挑战</strong>是构建一个经过深思熟虑选择的<strong class="lb iu">有意义的特征</strong>，并在<strong class="lb iu">几个机器学习模型</strong>上测试它们，以找到一个能够<strong class="lb iu">产生良好预测的模型</strong>。</p><p id="1656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">挑战除外！</p><h1 id="869e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">探索性分析</h1><p id="173f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这一部分，我将探索时间序列，检查其组成部分和季节性结构，并进行相关性分析，以确定该序列的主要特征。</p><p id="1cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将我的系列转换成一个<code class="fe lv lw lx ly b">ts</code>对象之前，我需要定义系列的<code class="fe lv lw lx ly b">start</code>(或<code class="fe lv lw lx ly b">end</code>)参数。我希望从一年的第一周开始计算周数，这样可以确保所有事情都符合<code class="fe lv lw lx ly b">ts</code>框架。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="9447" class="np ma it ly b gy nq nr l ns nt">start_point_wk &lt;- c(1,1) </span><span id="f002" class="np ma it ly b gy nu nr l ns nt">start_point_wk <br/>## [1] 1 1</span></pre><p id="5911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通过选择响应变量(<code class="fe lv lw lx ly b">revenue</code>)作为数据参数并指定 52 周的频率来创建<code class="fe lv lw lx ly b">ts</code>对象。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="ecc0" class="np ma it ly b gy nq nr l ns nt">ts_weekly &lt;- <br/>  revenue_tbl %&gt;% <br/>    select(revenue) %&gt;% <br/>    ts(start = start_point_wk, frequency = 52)</span><span id="789c" class="np ma it ly b gy nu nr l ns nt">ts_info(ts_weekly) </span><span id="7c27" class="np ma it ly b gy nu nr l ns nt">## The ts_weekly series is a ts object with 1 variable and 181 observations <br/>## Frequency: 52 <br/>## Start time: 1 1 <br/>## End time: 4 25</span></pre><p id="6c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">ts_info()</code>函数检查系列属性显示，该系列是一个包含 1 个变量和 181 个观察值的每周<code class="fe lv lw lx ly b">ts</code>对象。</p><h1 id="0bc3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">时间序列组件</h1><p id="f8fa" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在让我们借助<code class="fe lv lw lx ly b">TSstudio</code>的图形功能来绘制我们的时间序列。</p><p id="bf3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ts_decompose</code>将序列分解为其元素:<strong class="lb iu">趋势</strong>、<strong class="lb iu">季节性</strong>和<strong class="lb iu">随机</strong>成分。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="ae80" class="np ma it ly b gy nq nr l ns nt">ts_decompose(ts_weekly, type = 'additive')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/e8babf7c0226ff28f4a65433ab20f969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IOqSvXWi9WIQN9Ck.png"/></div></div></figure><ul class=""><li id="5b25" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">趋势</strong>:该系列似乎没有<em class="nk">周期性成分</em>，但显示出明显的<em class="nk">上升趋势</em>。趋势可能不是线性的，我将通过在特性中包含一个平方趋势元素来捕捉这一点。</li><li id="c941" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">季节性</strong>:这个情节显示了一个明显的<em class="nk">季节性模式</em>，我将在接下来探究。</li><li id="8450" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">随机</strong>:随机成分<em class="nk">看起来是随机分布的。</em></li></ul><h1 id="a351" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">季节性成分</h1><p id="d57d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在让我们放大这个系列的<strong class="lb iu">季节性部分</strong></p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="1189" class="np ma it ly b gy nq nr l ns nt">ts_seasonal(ts_weekly, type = 'normal')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/589b0cc51b147690f8d9e72ef237e409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yRgMY5MupEjbk0eG.png"/></div></div></figure><p id="c56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有 12 个不同的“峰值”(一年中的每个月一个)，但该图并不表明存在典型的季节性。然而，除了极少数例外，销售记录在每年的同一周，我将尝试用一个特征变量来捕捉这种规律性。</p><h1 id="060a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">相关分析</h1><p id="ec49" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><strong class="lb iu">自相关函数(ACF) </strong>描述了序列与其滞后之间的相关程度。</p><p id="c16f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于手头的系列的奇怪性质，AC 图不是很容易阅读和解释:它表明存在滞后结构，但由于系列中的噪声，很难拾取有意义的模式。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="a107" class="np ma it ly b gy nq nr l ns nt">ts_acf(ts_weekly, lag.max = 52)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5b9b0cfc65b42d8758c61de13d8a066e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BsOvYXZbhNVu8v1f.png"/></div></div></figure><p id="407c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我可以利用<strong class="lb iu">滞后可视化</strong>和玩滞后数字，以确定序列和它的滞后之间的潜在相关性。</p><p id="052c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，将周数与<strong class="lb iu">季度频率</strong>对齐显示了与季度滞后的明显的<strong class="lb iu">线性关系</strong>。为简单起见，我将只在模型中包括<strong class="lb iu">滞后 13 </strong>，以控制上一季度销售水平的影响。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="f42a" class="np ma it ly b gy nq nr l ns nt">ts_lags(ts_weekly, lags = c(13, 26, 39, 52))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/0e492bdf4c0de88e2b25e9a5b0fd61ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z5GCHIJu8PGuX8g3.png"/></div></div></figure><p id="23b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用相同的技巧揭示了<strong class="lb iu">与<strong class="lb iu">第一年滞后</strong>的强线性关系</strong>。同样，我将在模型中只包括一个<strong class="lb iu">滞后 52 </strong>。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="db6f" class="np ma it ly b gy nq nr l ns nt">ts_lags(ts_weekly, lags = c(52, 104, 156))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/13a74e33fda538ac628575a3a2312f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1aE1cVAMHdSin9YD.png"/></div></div></figure><h1 id="9d42" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">探索性分析总结</h1><ul class=""><li id="cc83" class="mw mx it lb b lc mr lf ms li nx lm ny lq nz lu nb nc nd ne bi translated">该系列的购买频率为两周一次，两周一次，没有典型的季节性<strong class="lb iu"/>。然而，除了极少数的例外情况，每年的销售额都大致记录在同一个星期。</li><li id="9bc1" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">该系列似乎没有<strong class="lb iu">周期性成分</strong>，但显示出明显的<strong class="lb iu">上升趋势</strong>以及潜在的<strong class="lb iu">非线性趋势</strong>。</li><li id="2ac9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">由于数据嘈杂，ACF 很难解释，但滞后图暗示了年度<strong class="lb iu">和季度<strong class="lb iu">滞后结构</strong>。</strong></li></ul><h1 id="dffc" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">系统模型化</h1><p id="5b6f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><strong class="lb iu">建模和预测</strong>策略是:</p><ul class=""><li id="eec3" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">使用<strong class="lb iu"> Q1 2007 </strong>训练并交叉验证<strong class="lb iu"> Q1 2007 </strong>之前的所有车型，并比较其样本内<strong class="lb iu">预测性能</strong>。</li><li id="4290" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">假设我没有<strong class="lb iu"> Q2 2007 </strong>的数据，使用所有合适的模型生成该期间的预测，并将它们的<strong class="lb iu">预测性能</strong>与<strong class="lb iu"> Q2 2007 实际值</strong>进行比较</li></ul><p id="06a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是该策略的可视化表示。我从经验中发现，用一个好的形象化来支持解释是一个让你的观点变得生动的好方法，尤其是在进行时间序列分析的时候。</p><p id="ea61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有<strong class="lb iu">模型精度</strong>将与<strong class="lb iu">性能指标</strong>和<strong class="lb iu">实际与预测</strong>图进行比较。</p><p id="ba75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用的<strong class="lb iu">绩效指标</strong>是:</p><ul class=""><li id="e935" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu"> R </strong>是一个<em class="nk">拟合优度指标</em>，它以百分比的形式解释了由于特征变量的变化而导致的响应变量的变化量。</li><li id="df24" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> RMSE </strong>(或<em class="nk">均方根误差</em>)是残差的标准差，衡量预测误差的平均大小。基本上，它告诉你残差是如何分布的。</li></ul><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="2e90" class="np ma it ly b gy nq nr l ns nt">revenue_tbl %&gt;% <br/>  filter(order_date &gt;= "2005-01-03") %&gt;% <br/>  ggplot(aes(order_date, revenue)) + <br/>  geom_line(colour = 'black', size = 0.7) + <br/>  geom_point(colour = 'black', size = 0.7) + <br/>  geom_smooth(se = FALSE, <br/>              colour = 'red', <br/>              size = 1,  <br/>              linetype = "dashed") + <br/>  theme_light() + <br/>  scale_y_continuous(limits = c(0, 11.5e7), <br/>                     labels = scales::dollar_format(scale = 1e-6, <br/>                     suffix = "m")) + <br/>  labs(title = 'Weekly Revenue - 2005 to June 2007', <br/>       subtitle = 'Train, Test and Forecast Data Portions', <br/>       x = "", y = 'Revenue ($m)') + </span><span id="a07d" class="np ma it ly b gy nu nr l ns nt"># Train Portion <br/>  annotate(x = ymd('2005-12-01'), y = (10.5e7), fill = 'black', <br/>           'text', label = 'Train\nPortion', size = 2.8) + </span><span id="47a0" class="np ma it ly b gy nu nr l ns nt"># Test Portion <br/>  annotate(x = ymd('2007-02-05'), y = (10.5e7), <br/>           'text', label = 'Test\nPortion', size = 2.8) + <br/>  geom_rect(xmin = as.numeric(ymd('2006-12-18')), <br/>            xmax = as.numeric(ymd('2007-03-25')), <br/>            ymin = -Inf, ymax = Inf, alpha = 0.005, <br/>            fill = 'darkturquoise') + </span><span id="5437" class="np ma it ly b gy nu nr l ns nt"># Forecast Portion <br/>  annotate(x = ymd('2007-05-13'), y = (10.5e7), <br/>           'text', label = 'Forecast\nPortion', size = 2.8) +<br/>  geom_rect(xmin = as.numeric(ymd('2007-03-26')), <br/>            xmax = as.numeric(ymd('2007-07-01')), <br/>            ymin = -Inf, ymax = Inf, alpha = 0.01, <br/>            fill = 'cornflowerblue')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b1b6be87a58f551d3793cd2559f1398f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B3kTEKD0daqza6IF.png"/></div></div></figure><p id="95bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">非常重要的一点:</strong>如你所见，我没有在图中显示 2004 年的数据。这是因为，每当您在模型中包含滞后变量时，用于计算滞后的第一个周期<strong class="lb iu">【drop off】</strong>数据集，将无法用于建模。在<strong class="lb iu">有年度滞后</strong>的情况下，所有观察值<strong class="lb iu">都提前</strong>一年，并且由于没有 2003 年的销售记录，这导致前 52 周被从分析中删除。</p><h1 id="de87" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">特征创建</h1><p id="0729" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在，我可以开始将时间序列探索的结果整合到我的特征变量中。为此，我创造了:</p><p id="7e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">趋势</strong>特征:(一个<em class="nk">趋势</em>和<em class="nk">趋势平方</em>)。这是通过一个简单的数字指数来控制上升趋势和潜在的非线性趋势。</p><p id="0e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Lag </strong>特性:(a _lag <em class="nk"> 13 </em>和 _lag <em class="nk"> 52 </em>)捕捉观察到的收入与其季度和年度季节性滞后的相关性。</p><p id="455e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">季节性</strong>特性，用于处理<em class="nk">两周工作、两周休息</em>的采购频率</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="5752" class="np ma it ly b gy nq nr l ns nt">model_data_tbl &lt;- <br/>  revenue_tbl %&gt;% <br/>  mutate(trend      = 1:nrow(revenue_tbl), <br/>         trend_sqr  = trend^2, <br/>         rev_lag_13 = lag(revenue, n = 13), <br/>         rev_lag_52 = lag(revenue, n = 52), <br/>         season     = case_when(revenue == 0 ~ 0, <br/>                            TRUE ~ 1)<br/>         ) %&gt;% <br/>filter(!is.na(rev_lag_52))</span></pre><p id="e060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建<strong class="lb iu">训练</strong>、<strong class="lb iu">测试</strong>和<strong class="lb iu">预测</strong>数据帧。</p><p id="4fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，<strong class="lb iu">测试数据</strong>集合是<strong class="lb iu">不是严格要求的</strong>，因为<code class="fe lv lw lx ly b">H2O</code>允许<strong class="lb iu">多重交叉验证</strong>自动执行。</p><p id="412c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，正如上一段所暗示的，为了评估和比较装配模型的<strong class="lb iu">样品内性能</strong>，我正在从列车数据中“切割”一个<strong class="lb iu">测试集</strong>。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="9451" class="np ma it ly b gy nq nr l ns nt">train_tbl &lt;- <br/>  model_data_tbl %&gt;% <br/>  filter(order_date &lt;= "2007-03-19") </span><span id="494c" class="np ma it ly b gy nu nr l ns nt">test_tbl &lt;- <br/>  model_data_tbl %&gt;% <br/>  filter(order_date &gt;= "2006-10-02" &amp; <br/>          order_date &lt;= "2007-03-19")</span><span id="7f0d" class="np ma it ly b gy nu nr l ns nt">train_tbl %&gt;% head()<br/><br/>## # A tibble: 6 x 7<br/>##   order_date   revenue trend trend_sqr rev_lag_13 rev_lag_52 season<br/>##   &lt;date&gt;         &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;<br/>## 1 2005-01-03        0     53      2809         0          0       0<br/>## 2 2005-01-10 54013487.    54      2916  45011429.  58814754.      1<br/>## 3 2005-01-17 40984715.    55      3025  30075259.  13926869.      1<br/>## 4 2005-01-24        0     56      3136         0          0       0<br/>## 5 2005-01-31        0     57      3249         0          0       0<br/>## 6 2005-02-07 51927116.    58      3364  51049952.  55440318.      1</span></pre><p id="d015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<strong class="lb iu">预测数据集</strong>时的主要考虑围绕着对预测变量的可能值和水平进行计算<strong class="lb iu">假设</strong></p><ul class=""><li id="bd11" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">说到<code class="fe lv lw lx ly b">trend</code>特性，我只是从 _model_data <em class="nk"> tbl </em>数据集中选择它们。它们是基于数字索引的，这样就很好了</li><li id="23fb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">假设有订单的周数几乎都是年复一年一致的(还记得探索性分析吗？)我将<code class="fe lv lw lx ly b">season</code>和<code class="fe lv lw lx ly b">rev_lag_52</code>设置为一年前(52 周前)的值</li><li id="5535" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">rev_lag_13</code>的值被设置为等于其上一季度的值(即 Q1 2007)</li></ul><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="ba4c" class="np ma it ly b gy nq nr l ns nt">forecast_tbl &lt;- <br/>  model_data_tbl %&gt;% <br/>  filter(order_date &gt; "2007-03-19") %&gt;%<br/>  select(order_date:trend_sqr) %&gt;%<br/>  cbind(season     = model_data_tbl %&gt;%<br/>               filter(between(order_date,<br/>                              as.Date("2006-03-27"),<br/>                              as.Date("2006-06-19"))) %&gt;% <br/>                        select(season),<br/>        rev_lag_52 = model_data_tbl %&gt;%<br/>               filter(between(order_date,<br/>                              as.Date("2006-03-27"),<br/>                              as.Date("2006-06-19"))) %&gt;% <br/>                        select(rev_lag_52),<br/>        rev_lag_13 = model_data_tbl %&gt;%<br/>               filter(between(order_date,<br/>                              as.Date("2006-12-25"),<br/>                              as.Date("2007-03-19"))) %&gt;% <br/>                        select(rev_lag_13)<br/>         )<br/></span><span id="de10" class="np ma it ly b gy nu nr l ns nt">forecast_tbl %&gt;% head()<br/><br/>##   order_date  revenue trend trend_sqr season rev_lag_52 rev_lag_13<br/>## 1 2007-03-26   449709   169     28561      0        0.0          0<br/>## 2 2007-04-02        0   170     28900      0        0.0          0<br/>## 3 2007-04-09 89020602   171     29241      1 45948859.7   63603122<br/>## 4 2007-04-16 70869888   172     29584      1 41664162.8   63305793<br/>## 5 2007-04-23        0   173     29929      0   480138.8          0<br/>## 6 2007-04-30        0   174     30276      0        0.0          0</span></pre><h1 id="36aa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">和 H2O 一起做模特</h1><p id="c56c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">终于准备好开始做模特了！</p><p id="2b39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">H2O</code>是一个面向机器学习应用的高性能开源库，致力于分布式处理，这使得它适合于较小的内存项目，并且可以通过外部处理能力快速扩展以实现更大的目标。</p><p id="dd9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它基于 Java，具有与<em class="nk"> R </em>和<em class="nk"> Python </em>的专用接口，并整合了许多监督和非监督的机器学习模型。在这个项目中，我特别关注 4 种算法:</p><ul class=""><li id="bb50" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">广义线性模型(GLM) </strong></li><li id="8c85" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">梯度推进机(GBM) </strong></li><li id="3e49" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我还使用了<strong class="lb iu"> AutoML </strong>工具，并使用 leader 模型来比较性能</li></ul><p id="57ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先:启动一个<code class="fe lv lw lx ly b">H2O</code>实例！</p><p id="d19e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当 R 通过<code class="fe lv lw lx ly b">h2o.init</code>命令启动 H2O 时，我可以指定内存分配池集群的大小。为了加快速度，我把它设置为“16G”。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="00a3" class="np ma it ly b gy nq nr l ns nt">h2o.init(max_mem_size = "16G")<br/><br/>## H2O is not running yet, starting it now...<br/>## <br/>## Note:  In case of errors look at the following log files:<br/>##     C:\Users\LENOVO\AppData\Local\Temp\RtmpSWW88g/h2o_LENOVO_started_from_r.out<br/>##     C:\Users\LENOVO\AppData\Local\Temp\RtmpSWW88g/h2o_LENOVO_started_from_r.err<br/>## <br/>## <br/>## Starting H2O JVM and connecting: . Connection successful!<br/>## <br/>## R is connected to the H2O cluster: <br/>##     H2O cluster uptime:         4 seconds 712 milliseconds <br/>##     H2O cluster timezone:       Europe/Berlin <br/>##     H2O data parsing timezone:  UTC <br/>##     H2O cluster version:        3.26.0.10 <br/>##     H2O cluster version age:    2 months and 4 days  <br/>##     H2O cluster name:           H2O_started_from_R_LENOVO_xwx278 <br/>##     H2O cluster total nodes:    1 <br/>##     H2O cluster total memory:   14.22 GB <br/>##     H2O cluster total cores:    4 <br/>##     H2O cluster allowed cores:  4 <br/>##     H2O cluster healthy:        TRUE <br/>##     H2O Connection ip:          localhost <br/>##     H2O Connection port:        54321 <br/>##     H2O Connection proxy:       NA <br/>##     H2O Internal Security:      FALSE <br/>##     H2O API Extensions:         Amazon S3, Algos, AutoML, Core V3, TargetEncoder, Core V4 <br/>##     R Version:                  R version 3.6.1 (2019-07-05)</span></pre><p id="b30e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也喜欢关闭进度条，因为在某些情况下，输出消息可能会非常冗长。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="9fe5" class="np ma it ly b gy nq nr l ns nt">h2o.no_progress()</span></pre><p id="527b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是安排<strong class="lb iu">响应</strong>和<strong class="lb iu">预测</strong>变量集。为了进行回归，您需要确保响应变量不是一个因子(否则<code class="fe lv lw lx ly b">H2O</code>将进行分类)。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="5c0c" class="np ma it ly b gy nq nr l ns nt"># response variable<br/>y &lt;- "revenue"<br/><br/># predictors set: remove response variable and order_date from the set<br/>x &lt;- setdiff(names(train_tbl %&gt;% as.h2o()), c(y, "order_date"))</span></pre><h1 id="4192" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">随机森林</h1><p id="8fe0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我将从安装一个<code class="fe lv lw lx ly b">random forest</code>开始。</p><p id="3e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我包括了<code class="fe lv lw lx ly b">nfolds</code>参数。无论何时指定，该参数使交叉验证能够在不需要<code class="fe lv lw lx ly b">validation_frame</code>的情况下执行——例如，如果设置为 5，它将执行 5 重交叉验证。</p><p id="d50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还使用了一些控制参数来处理模型的运行时间:</p><ul class=""><li id="52b6" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">我将<code class="fe lv lw lx ly b">stopping_metric</code>设置为<code class="fe lv lw lx ly b">RMSE</code>作为提前停止的误差度量(当度量停止改善时，模型将停止构建新的树)</li><li id="0458" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">通过<code class="fe lv lw lx ly b">stopping_rounds</code>，我指定了考虑提前停止前的训练轮数</li><li id="6758" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我使用<code class="fe lv lw lx ly b">stopping_tolerance</code>来设置训练过程继续所需的最小改进</li></ul><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="505b" class="np ma it ly b gy nq nr l ns nt"># random forest model<br/>rft_model &lt;- <br/>  h2o.randomForest(<br/>    x = x, <br/>    y = y, <br/>    training_frame = train_tbl %&gt;% as.h2o(),<br/>    nfolds = 10,<br/>    ntrees = 500,<br/>    stopping_metric = "RMSE",<br/>    stopping_rounds = 10,<br/>    stopping_tolerance = 0.005,<br/>    seed = 1975<br/>  )</span></pre><p id="2a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在用<code class="fe lv lw lx ly b">h2o.varimp_plot</code>可视化变量重要性，它返回一个每个变量的排名贡献图，标准化为 0 到 1 之间的范围。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="51a0" class="np ma it ly b gy nq nr l ns nt">rft_model %&gt;% h2o.varimp_plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/945d28b8c67f6230b65c7671f91ebfb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ab_fafWt4xWMdXyr.png"/></div></div></figure><p id="1baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">model_summary</code>功能允许访问关于模型参数的信息。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="b3a7" class="np ma it ly b gy nq nr l ns nt">rft_model@model$model_summary<br/><br/>## Model Summary: <br/>## number_of_trees number_of_internal_trees model_size_in_bytes min_depth<br/>## 1            27                       27               12560         7<br/>## max_depth mean_depth min_leaves max_leaves mean_leaves<br/>## 1      14   10.29630         12         45    32.37037</span></pre><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到，随机森林只使用了允许估计的最多 500 棵树中的 26 棵树(我用<code class="fe lv lw lx ly b">ntrees</code>参数设置了这一点)。我们还可以估算出树的深度范围从 7 到 14(不是特别深的森林),每棵树的叶子数量范围从 12 到 45。</p><p id="6479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，我可以用<code class="fe lv lw lx ly b">h2o.performance</code>查看模型的性能</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="4e8d" class="np ma it ly b gy nq nr l ns nt">h2o.performance(rft_model, newdata = test_tbl %&gt;% as.h2o())<br/><br/>## H2ORegressionMetrics: drf<br/>## <br/>## MSE:  3.434687e+13<br/>## RMSE:  5860620<br/>## MAE:  3635468<br/>## RMSLE:  9.903415<br/>## Mean Residual Deviance :  3.434687e+13<br/>## R^2 :  0.9737282</span></pre><p id="20b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型实现了<em class="nk"> 97.4% </em>的高<code class="fe lv lw lx ly b">R^2</code>，这意味着特征变量的变化解释了响应变量的几乎所有可变性。</p><p id="ecb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe lv lw lx ly b">RMSE</code>显得相当大！RMSE 的高值可能是由于少量高误差预测的存在(如异常值的情况)，考虑到响应变量的波动性，这并不奇怪。</p><p id="3e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈到基于误差的指标，如 RMSE、平均误差、均方误差等。没有好坏的绝对值，因为它们是用响应变量的单位表示的<em class="nk">。通常，你想要实现一个更小的<code class="fe lv lw lx ly b">RMSE</code>，因为这意味着更高的预测能力，但是对于这个项目，我将简单地使用这个指标来比较不同模型的相对性能。</em></p><h1 id="1d2b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">扩展到许多型号</h1><p id="d5c2" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们以编程的方式概括性能评估，一次性计算、评估和比较多个模型。</p><p id="d603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我安装了几个型号，并确保我为所有型号启用了<code class="fe lv lw lx ly b">cross-validation</code>。注意，对于<em class="nk"> GBM </em>，我指定了与用于<em class="nk">随机森林</em>相同的参数，但是有大量的参数可以用来控制模型估计的几个方面(我不会涉及这些，因为这超出了本项目的范围)</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="bdb0" class="np ma it ly b gy nq nr l ns nt"># gradient boosting machine model<br/>gbm_model &lt;-  <br/>  h2o.gbm(<br/>    x = x, <br/>    y = y, <br/>    training_frame = as.h2o(train_tbl),<br/>    nfolds = 10,<br/>    ntrees = 500,<br/>    stopping_metric = "RMSE",<br/>    stopping_rounds = 10,         <br/>    stopping_tolerance = 0.005,<br/>    seed = 1975<br/>  )<br/><br/># generalised linear model (a.k.a. elastic net model)<br/>glm_model &lt;- <br/>  h2o.glm(<br/>    x = x, <br/>    y = y, <br/>    training_frame = as.h2o(train_tbl),<br/>    nfolds = 10,<br/>    family = "gaussian",<br/>    seed = 1975<br/>  )</span></pre><p id="f886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还运行了非常方便的<code class="fe lv lw lx ly b">automl</code>功能，可以安装多个模型并优化网格搜索。就像我对其他模型所做的那样，我可以指定一系列参数来指导这个函数，比如几个<code class="fe lv lw lx ly b">stopping</code>度量和<code class="fe lv lw lx ly b">max_runtime_secs</code>来节省计算时间。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="235e" class="np ma it ly b gy nq nr l ns nt">automl_model &lt;-<br/>  h2o.automl(<br/>    x = x,<br/>    y = y,<br/>    training_frame     = as.h2o(train_tbl),<br/>    nfolds             = 5,<br/>    stopping_metric    = "RMSE",<br/>    stopping_rounds    = 10,<br/>    stopping_tolerance = 0.005,<br/>    max_runtime_secs   = 60,<br/>    seed               = 1975<br/> )</span></pre><p id="16d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查引导板将显示适合的模型</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="9429" class="np ma it ly b gy nq nr l ns nt">automl_model@leaderboard<br/><br/>##                                              model_id <br/>## 1                        GBM_2_AutoML_20200112_111324 <br/>## 2                        GBM_4_AutoML_20200112_111324  <br/>## 3 StackedEnsemble_BestOfFamily_AutoML_20200112_111324  <br/>## 4                        GBM_1_AutoML_20200112_111324 <br/>## 5  DeepLearning_grid_1_AutoML_20200112_111324_model_1 <br/>## 6  DeepLearning_grid_1_AutoML_20200112_111324_model_5  <!-- --> <br/>##<br/>##   mean_residual_deviance      rmse          mse     mae rmsle<br/>## 1           1.047135e+14  10232963 1.047135e+14 5895463   NaN<br/>## 2           1.070608e+14  10347021 1.070608e+14 5965855   NaN<br/>## 3           1.080933e+14  10396794 1.080933e+14 5827000   NaN<br/>## 4           1.102083e+14  10498016 1.102083e+14 5113982   NaN<br/>## 5           1.104058e+14  10507419 1.104058e+14 6201525   NaN<br/>## 6           1.146914e+14  10709407 1.146914e+14 6580217   NaN<br/>## <br/>## [22 rows x 6 columns]</span></pre><p id="1b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，顶部的模型是一个<strong class="lb iu">梯度推进机</strong>模型。还有几个<strong class="lb iu">深度学习</strong>模型和一个<strong class="lb iu">堆叠合奏</strong>，<code class="fe lv lw lx ly b">H2O</code>迎战<strong class="lb iu">超级学习者</strong>。</p><h1 id="f475" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">性能评价</h1><p id="1bfb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">首先，我将所有模型保存在一个文件夹中，这样我就可以访问它们，并通过一系列函数以编程方式处理性能指标</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="a0f7" class="np ma it ly b gy nq nr l ns nt"># set path to get around model path being different from project path<br/>path = "/02_models/final/"<br/><br/># Save GLM model<br/>h2o.saveModel(glm_model, path)<br/><br/># Save RF model<br/>h2o.saveModel(rft_model, path)<br/><br/># Save GBM model<br/>h2o.saveModel(gbm_model, path)<br/><br/># Extracs and save the leader autoML model<br/>aml_model &lt;- automl_model@leader<br/><br/>h2o.saveModel(aml_model, path)</span></pre><h1 id="c448" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">可变重要性图</h1><p id="6fe3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们从可变重要性图开始。之前我在<code class="fe lv lw lx ly b">random forest</code>模型中使用了绘图功能，但是现在我想一次将它们全部绘制出来，这样我就可以比较和对比结果了。</p><p id="1708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多库(如<em class="nk"> IML </em>、<em class="nk"> PDP </em>、<em class="nk"> VIP </em>、<em class="nk"> DALEX </em>等更受欢迎的库)有助于<strong class="lb iu">机器学习模型可解释性</strong>、<strong class="lb iu">特征解释</strong>和<strong class="lb iu">一般性能评估</strong>。在这个项目中，我使用的是<code class="fe lv lw lx ly b">vip</code>包。</p><p id="b393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些库的主要优势之一是它们与其他 R 包如<code class="fe lv lw lx ly b">gridExtra</code>的兼容性。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="92c0" class="np ma it ly b gy nq nr l ns nt">p_glm &lt;- vip(glm_model) + ggtitle("GLM")<br/>p_rft &lt;- vip(rft_model) + ggtitle("RF")<br/>p_gbm &lt;- vip(gbm_model) + ggtitle("GBM")<br/>p_aml &lt;- vip(aml_model) + ggtitle("AML")<br/><br/>grid.arrange(p_glm, p_rft, p_gbm, p_aml, nrow = 2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9ca2a3faf13d7d35fc46db8a703ee983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B0ZKjo9ZICcRkV6B.png"/></div></div></figure><p id="2e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Seasonality</code>和以前的收入水平(<code class="fe lv lw lx ly b">lags</code>)在几乎所有车型中都排在前 3 位(唯一的例外是<em class="nk"> GBM </em>)。相反，没有一个模型发现<code class="fe lv lw lx ly b">trend</code>及其对应的<code class="fe lv lw lx ly b">squared</code>是反应变量变化的有力解释者。</p><h1 id="10e3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">性能指标</h1><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="47ba" class="np ma it ly b gy nq nr l ns nt">perf_gbm_model &lt;- <br/>  h2o.performance(gbm_model, newdata = as.h2o(test_tbl))<br/><br/>perf_gbm_model<br/><br/>## H2ORegressionMetrics: gbm<br/>## <br/>## MSE:  1.629507e+13<br/>## RMSE:  4036716<br/>## MAE:  2150460<br/>## RMSLE:  9.469847<br/>## Mean Residual Deviance :  1.629507e+13<br/>## R^2 :  0.9875359</span></pre><p id="b82a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，为了评估和比较模型的性能，我将重点关注<code class="fe lv lw lx ly b">RMSE</code>和<code class="fe lv lw lx ly b">R^2^</code>。</p><p id="af55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">h20.metric</code>函数可以一次提取所有性能指标，由于某种原因，这似乎不适用于<code class="fe lv lw lx ly b">H2ORegressionMetrics</code>对象。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="c526" class="np ma it ly b gy nq nr l ns nt">perf_gbm_model %&gt;% <br/>  h2o.metric()<br/><br/>## Error in paste0("No ", metric, " for ",<br/>## class(object)) : argument "metric" is missing, with<br/>##  no default</span></pre><p id="2928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在这种情况下，错误消息不是特别有用，因为“metric”参数是可选的，默认情况下应该返回所有指标。这个问题似乎与执行回归有关，因为它实际上可以很好地处理<code class="fe lv lw lx ly b">H2OClassificationMetrics</code>对象。</p><p id="1923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，提供了一些有用的助手函数来单独提取单个指标，它们工作正常！</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="92ab" class="np ma it ly b gy nq nr l ns nt">perf_gbm_model %&gt;% h2o.r2()<br/>## [1] 0.9875359<br/><br/>perf_gbm_model %&gt;% h2o.rmse()<br/>## [1] 4036716</span></pre><p id="9608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我将使用这些单独的助手来编写一个小函数，该函数对测试数据上的所有模型运行<strong class="lb iu">预测，并返回一个包含所有性能指标的简便 tibble。</strong></p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="88d1" class="np ma it ly b gy nq nr l ns nt">performance_metrics_fct &lt;- function(path, data_tbl) {<br/>    <br/>    model_h2o &lt;- h2o.loadModel(path)<br/>    perf_h2o  &lt;- h2o.performance(model_h2o, newdata = as.h2o(data_tbl)) <br/>    <br/>    R2   &lt;- perf_h2o %&gt;% h2o.r2()  <br/>    RMSE &lt;- perf_h2o %&gt;% h2o.rmse()<br/>    <br/>    tibble(R2, RMSE)<br/>}</span></pre><p id="201d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我可以将这个公式传递给<code class="fe lv lw lx ly b">purrr</code>包中的<code class="fe lv lw lx ly b">map</code>函数，以迭代计算并编译所有模型中的<code class="fe lv lw lx ly b">RMSE</code>和<code class="fe lv lw lx ly b">R^2^</code>。为了正确地识别每个模型，我还确保从路径中提取模型的名称。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="11d3" class="np ma it ly b gy nq nr l ns nt">perf_metrics_test_tbl &lt;- fs::dir_info(path = "/02_models/final_models/") %&gt;%<br/>    select(path) %&gt;%<br/>    mutate(metrics = map(path, performance_metrics_fct, data_tbl = test_tbl),<br/>           path = str_split(path, pattern = "/", simplify = T)[,2] <br/>                            %&gt;% substr(1,3)) %&gt;%<br/>    rename(model = path) %&gt;% <br/>    unnest(cols = c(metrics))</span><span id="3096" class="np ma it ly b gy nu nr l ns nt">perf_metrics_test_tbl %&gt;% <br/>  arrange(desc(R2)) <br/><br/>model 	          R2 	      RMSE<br/>AML 	   0.9933358 	   2951704<br/>GBM 	   0.9881890 	   3929538<br/>DRF 	   0.9751434 	   5700579<br/>GLM 	  -0.0391253 	  36858064</span></pre><p id="cbb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">所有基于树的模型</strong>都达到非常高的<code class="fe lv lw lx ly b">R^2</code>，其中有 autoML 模型(这是一个 GBM，记得吗？)达到惊人的<em class="nk"> 99.3% </em>并达到最低<code class="fe lv lw lx ly b">RMSE</code>。另一方面，<em class="nk"> GLM </em>得到一个<strong class="lb iu">负 R^2 </strong>。</p><p id="33b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负 R 并非闻所未闻:R 将模型的拟合与水平直线的拟合进行比较，并计算模型解释的方差与直线(零假设)解释的方差的比例。如果拟合实际上比仅仅拟合一条水平线差，那么 R 平方可以是负的。</p><h1 id="e9be" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">实际与预测图</h1><p id="e3cb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后但同样重要的是，为了提供模型性能的额外和更直观的显示，我将绘制所有模型的<strong class="lb iu">实际与预测</strong>。</p><p id="35a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在使用一个类似于我用来计算性能指标的函数，因为基本原理是相同的。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="594f" class="np ma it ly b gy nq nr l ns nt">predict_fct &lt;- function(path, data_tbl) {<br/>    <br/>    model_h2o &lt;- h2o.loadModel(path)<br/>    pred_h2o  &lt;- h2o.predict(model_h2o, newdata = as.h2o(data_tbl)) <br/>    <br/>    pred_h2o %&gt;% <br/>      as_tibble() %&gt;% <br/>      cbind(data_tbl %&gt;% select(order_date))<br/>    <br/>}</span></pre><p id="9b72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前所做的，我将公式传递给一个<code class="fe lv lw lx ly b">map</code>函数来迭代计算，并使用所有模型的<code class="fe lv lw lx ly b">test</code>数据子集来编译<code class="fe lv lw lx ly b">prediction</code>。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="fe56" class="np ma it ly b gy nq nr l ns nt">validation_tmp &lt;- fs::dir_info(path = "/02_models/final_models/") %&gt;%<br/>    select(path) %&gt;%<br/>    mutate(pred = map(path, predict_fct, data_tbl = test_tbl),<br/>           path = str_split(path, pattern = "/", simplify = T)[,2] %&gt;% <br/>             substr(1,3)) %&gt;%<br/>    rename(model = path)</span></pre><p id="c80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，得到的<code class="fe lv lw lx ly b">validation_tmp</code>是一个嵌套的 tibble，每个单元格中的预测都存储为列表。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="5b2d" class="np ma it ly b gy nq nr l ns nt">validation_tmp<br/><br/>## # A tibble: 4 x 2<br/>##   model pred             <br/>##   &lt;chr&gt; &lt;list&gt;           <br/>## 1 AML   &lt;df[,2] [25 × 2]&gt;<br/>## 2 DRF   &lt;df[,2] [25 × 2]&gt;<br/>## 3 GBM   &lt;df[,2] [25 × 2]&gt;<br/>## 4 GLM   &lt;df[,2] [25 × 2]&gt;</span></pre><p id="d288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要几个额外的操作来获得一个可用于绘图的形状:取消列表嵌套，围绕<code class="fe lv lw lx ly b">order_date</code>旋转预测，并将收入添加为<code class="fe lv lw lx ly b">actual</code>。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="af48" class="np ma it ly b gy nq nr l ns nt">validation_tbl &lt;- <br/>    validation_tmp %&gt;% <br/>    unnest(cols = c(pred)) %&gt;% <br/>    pivot_wider(names_from = model, <br/>                values_from = predict) %&gt;%<br/>    cbind(test_tbl %&gt;% <br/>            select(actual = revenue)) %&gt;% <br/>    rename(date = order_date)</span></pre><p id="300b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我要把这个绘图函数直接写在<em class="nk">里 plotly </em></p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="7bb3" class="np ma it ly b gy nq nr l ns nt">validation_tbl %&gt;% <br/>  plot_ly() %&gt;% <br/>    add_lines(x = ~ date, y = ~ actual, name = 'Actual') %&gt;% <br/>    add_lines(x = ~ date, y = ~ DRF, name = 'Random Forest', <br/>              line = list(dash = 'dot')) %&gt;% <br/>    add_lines(x = ~ date, y = ~ GBM, name = 'Gradient Boosting Machine', <br/>              line = list(dash = 'dash')) %&gt;% <br/>    add_lines(x = ~ date, y = ~ AML, name = 'Auto ML', <br/>              line = list(dash = 'dot')) %&gt;% <br/>    add_lines(x = ~ date, y = ~ GLM, name = 'Generalised Linear Model', <br/>              line = list(dash = 'dash')) %&gt;% <br/>    layout(title = 'Total Weekly Sales - Actual versus Predicted (various models)',<br/>           yaxis = list(title = 'Millions of Dollars'),<br/>           xaxis = list(title = ''),<br/>           legend = list(orientation = 'h')<br/>           )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/bf18cd6819a0c64d6f017f72b38c0c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gU1lYkVr8c9N0OP0.png"/></div></div></figure><p id="b5c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了 GLM 模型，它产生了一条看似平坦的预测线(还记得负面的<em class="nk"> R </em>？)，所有模型都很好地捕捉到了系列中的波峰和波谷。预测仅开始错过最后 2 个尖峰周围的响应变化的全部范围。</p><h1 id="2425" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">预测</h1><p id="7d01" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">无需编写任何新函数，因为<code class="fe lv lw lx ly b">performance_metrics_fct</code>和<code class="fe lv lw lx ly b">predict_fct</code>也可用于预测。</p><p id="f6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我看一下性能指标</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="cd16" class="np ma it ly b gy nq nr l ns nt">perf_metrics_cast_tbl &lt;- fs::dir_info(path = "/02_models/final_models/") %&gt;%<br/>    select(path) %&gt;%<br/>    mutate(metrics = map(path, performance_metrics_fct, <br/>           data_tbl = forecast_tbl),<br/>           path = str_split(path, pattern = "/", simplify = T)[,2] <br/>                            %&gt;% substr(1,3)) %&gt;%<br/>    rename(model = path) %&gt;% <br/>    unnest(cols = c(metrics))<br/></span><span id="1fb8" class="np ma it ly b gy nu nr l ns nt">perf_metrics_cast_tbl %&gt;% <br/>  arrange(desc(R2)) <br/><br/>model 	      R2 	      RMSE<br/>GBM 	    0.8678649 	  14544327<br/>AML 	    0.8363565 	  16185792<br/>DRF 	    0.8042526 	  17702414<br/>GLM 	   -0.0617160 	  41227664</span></pre><p id="a560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，在顶部位置有一点互换，与 autoML 模型相比,“手动”GBM 在预测中表现更好。与验证指标相比，所有模型的性能指标都恶化了。</p><p id="7758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我计算预测…</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="333b" class="np ma it ly b gy nq nr l ns nt">cast_tbl &lt;- fs::dir_info(path = "/02_models/final_models/") %&gt;%<br/>    select(path) %&gt;%<br/>    mutate(pred = map(path, predict_fct, data_tbl = forecast_tbl),<br/>           path = str_split(path, pattern = "/", simplify = T)[,2] %&gt;% <br/>             substr(1,3)) %&gt;%<br/>    rename(model = path) %&gt;% <br/>    unnest(cols = c(pred)) %&gt;% <br/>    pivot_wider(names_from = model, values_from = predict) %&gt;%<br/>    cbind(forecast_tbl %&gt;% select(actual = revenue)) %&gt;% <br/>    rename(date = order_date)</span></pre><p id="814c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…并想象它</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="2901" class="np ma it ly b gy nq nr l ns nt">cast_tbl %&gt;% <br/>  plot_ly() %&gt;% <br/>    add_lines(x = ~ date, y = ~ actual, name = 'Actual') %&gt;% <br/>    add_lines(x = ~ date, y = ~ DRF, name = 'Random Forest', <br/>              line = list(dash = 'dot')) %&gt;% <br/>    add_lines(x = ~ date, y = ~ GBM, name = 'Gradient Boosting Machine', <br/>              line = list(dash = 'dash')) %&gt;% <br/>    add_lines(x = ~ date, y = ~ AML, name = 'Auto ML', <br/>              line = list(dash = 'dot')) %&gt;% <br/>    add_lines(x = ~ date, y = ~ GLM, name = 'Generalised Linear Model', <br/>              line = list(dash = 'dash')) %&gt;% <br/>    layout(title = 'Total Weekly Sales - Actual versus Forecast (various models)',<br/>           yaxis = list(title = 'Millions of Dollars'),<br/>           xaxis = list(title = ''),<br/>           legend = list(orientation = 'h')<br/>           )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/a086994a6e4b3d52101d57eaf51d02bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wBdCHbGyP154d8VD.png"/></div></div></figure><p id="9eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了不出所料产生持平预测的<strong class="lb iu"> GLM </strong>之外，所有车型都继续很好地捕捉 2 周开工、2 周停工的购买模式。此外，所有模型预测都未能捕捉到所有 3 个峰值的反应变量运动的全部范围，这表明在 2007 年可能有另一种动态在起作用，而当前的预测者无法控制这种动态。</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="be9d" class="np ma it ly b gy nq nr l ns nt">forecast_tbl %&gt;% <br/>  select(-trend, -trend_sqr) %&gt;% <br/>  tail(10) <br/><br/>    order_date 	 revenue 	season 	rev_lag_52 	rev_lag_13<br/>4   2007-04-16 	70869888 	    1 	41664162.8 	  63305793<br/>5   2007-04-23 	       0 	    0 	  480138.8 	         0<br/>6   2007-04-30 	       0 	    0 	       0.0 	         0<br/>7   2007-05-07 	78585882 	    1 	41617508.0 	  64787291<br/>8   2007-05-14 	78797822 	    1 	48403283.4 	  59552955<br/>9   2007-05-21 	       0 	    1 	       0.0 	         0<br/>10  2007-05-28 	       0 	    0 	       0.0 	        0<br/>11  2007-06-04 	       0 	    0 	45696327.2 	         0<br/>12  2007-06-11 	75486199 	    1 	53596289.9 	  70430702<br/>13  2007-06-18 	86509530 	    1 	  774190.1 	  60094495</span></pre><p id="f448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一件事:完成后不要忘记关闭<code class="fe lv lw lx ly b">H2O</code>实例！</p><pre class="kj kk kl km gt nl ly nm nn aw no bi"><span id="bfac" class="np ma it ly b gy nq nr l ns nt">h2o.shutdown(prompt = FALSE)</span></pre><h1 id="4bf5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束语</h1><p id="62d0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这个项目中，我经历了建立时间序列机器学习管道和生成每周收入预测所需的各个步骤。</p><p id="0ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，我用<code class="fe lv lw lx ly b">TSstudio</code>和<strong class="lb iu">进行了一个更“传统”<strong class="lb iu">的探索性时间序列分析</strong>，并利用我收集的洞察力创建了许多预测器</strong>。然后<strong class="lb iu">我用开源库<code class="fe lv lw lx ly b">H2O</code>训练并验证了</strong>一系列机器学习模型，并且<strong class="lb iu">使用<strong class="lb iu">性能指标</strong>和<strong class="lb iu">实际与预测</strong>图比较了模型的准确性</strong>。</p><h1 id="7e06" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="306e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这只是制作每周收入预测的第一次尝试，显然还有很大的改进空间。尽管如此，一旦你有了这样的建模和预测管道，创建和测试几个模型和不同的预测集就会变得更加容易和快速。</p><p id="6253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据序列是人工生成的这一事实并不理想，因为它不一定包含您在现实生活数据集中会遇到的动态。尽管如此，这促使我发挥创造力，让整个练习变得更加愉快。</p><p id="16cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测总收入可能不是最好的策略，例如，通过<code class="fe lv lw lx ly b">product line</code>或<code class="fe lv lw lx ly b">country</code>分解响应变量可能会带来更好、更准确的预测。这超出了本项目的范围，但也可能是未来项目的主题！</p><p id="90aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从这个练习中学到的一件事是<code class="fe lv lw lx ly b">H2O</code>是<strong class="lb iu">绝对聪明的</strong>！它的设置快速、直观，并具有广泛的定制选项。<strong class="lb iu"> AutoML </strong>非常棒，支持<strong class="lb iu"> R </strong>、<strong class="lb iu"> Python </strong>和<strong class="lb iu"> Java </strong>并且任何人都可以免费使用它的事实给了像<strong class="lb iu"> Google AutoML </strong>和<strong class="lb iu"> AWS SageMaker AutoML </strong>这样的平台一个机会！</p><h1 id="0cb4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">代码库</h1><p id="3704" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">完整的 R 代码可以在<a class="ae ky" href="https://github.com/DiegoUsaiUK/Customer_Analytics/tree/master/time_series_machine_learning" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">我的 GitHub 简介</strong> </a>中找到</p><h1 id="4612" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">参考</h1><ul class=""><li id="0b4b" class="mw mx it lb b lc mr lf ms li nx lm ny lq nz lu nb nc nd ne bi translated">对于 H2O 网站<a class="ae ky" href="https://www.h2o.ai/" rel="noopener ugc nofollow" target="_blank">T5 H2O 网站 T7】</a></li><li id="469a" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">对于 H2O 文档<a class="ae ky" href="http://docs.h2o.ai/h2o/latest-stable/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> H2O 文档</strong> </a></li><li id="a8af" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">有关在 R <a class="ae ky" href="https://www.packtpub.com/big-data-and-business-intelligence/hands-time-series-analysis-r" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">中使用 R </strong> </a>进行时间序列分析和预测的详细讨论</li><li id="3725" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">关于 TSstudio 的介绍<a class="ae ky" href="https://diegousai.io/2019/12/time-series-machine-learning-analysis-and-demand-forecasting/Introduction for the TSstudio Package" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">关于 TSstudio 包的介绍</strong> </a></li><li id="29ee" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.h2o.ai/wp-content/uploads/2019/08/An-Introduction-to-Machine-Learning-Interpretability-Second-Edition.pdf" rel="noopener ugc nofollow" target="_blank">T21 简介机器学习可解释性</a></li></ul></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="c036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nk">原载于 2019 年 12 月 11 日</em><a class="ae ky" href="https://diegousai.io/2019/12/time-series-machine-learning-analysis-and-demand-forecasting/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://diegousei . io</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>