<html>
<head>
<title>A Brief Introduction to Supervised Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监督学习简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-brief-introduction-to-supervised-learning-54a3e3932590?source=collection_archive---------2-----------------------#2019-09-29">https://towardsdatascience.com/a-brief-introduction-to-supervised-learning-54a3e3932590?source=collection_archive---------2-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0a71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">监督学习是当今机器学习最常见的分支。通常，新的机器学习实践者将从监督学习算法开始他们的旅程。因此，这三篇文章系列的第一篇将是关于监督学习的。</p><p id="37ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">监督机器学习算法被设计成通过例子来学习。“受监督的”学习这个名称源于这样一种想法，即训练这种类型的算法就像让一个老师监督整个过程。</p><p id="a32d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当训练监督学习算法时，训练数据将由与正确输出配对的输入组成。在训练期间，算法将在数据中搜索与期望输出相关的模式。训练后，监督学习算法将接受新的未知输入，并根据之前的训练数据确定新输入将被分类为哪个标签。监督学习模型的目标是为新出现的输入数据预测正确的标签。在其最基本的形式下，监督学习算法可以简单地写成:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/47409c304c75136eb00d443f36c1438c.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/0*jBtf04r_NW3UKkj6"/></div></figure><p id="585f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<em class="kw"> Y </em>是由映射函数确定的预测输出，该映射函数将类别分配给输入值<em class="kw"> x </em>。用于将输入特征连接到预测输出的函数是由机器学习模型在训练期间创建的。</p><p id="53b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">监督学习可以分为两个子类别:<strong class="js iu">分类</strong>和<strong class="js iu">回归</strong>。</p><h1 id="e89f" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">分类</strong></h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/520897b8f4da7a178581c6d218c6e59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQOmuWjgevfagaHqGh6HXA.png"/></div></div></figure><p id="18be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在训练过程中，将为分类算法提供具有指定类别的数据点。分类算法的工作是获取一个输入值，并根据提供的训练数据为其指定一个类别或种类。</p><p id="850b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最常见的分类示例是确定电子邮件是否是垃圾邮件。有两个类别可供选择(垃圾邮件或非垃圾邮件)，这个问题被称为二元分类问题。该算法将获得带有垃圾邮件和非垃圾邮件的训练数据。该模型将在数据中找到与任一类相关的特征，并创建前面提到的映射函数:<em class="kw"> Y=f(x) </em>。然后，当收到一封看不见的电子邮件时，该模型将使用该函数来确定该电子邮件是否是垃圾邮件。</p><p id="8a01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分类问题可以用大量的算法来解决。选择使用哪种算法取决于数据和情况。以下是一些流行的分类算法:</p><ul class=""><li id="2b59" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">线性分类器</li><li id="5b9a" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">支持向量机</li><li id="6dd2" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">决策树</li><li id="00ee" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">k-最近邻</li><li id="cabe" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">随机森林</li></ul><h1 id="8bd3" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">回归</h1><p id="5caa" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">回归是一个预测性的统计过程，其中模型试图找到因变量和自变量之间的重要关系。回归算法的目标是预测连续的数字，如销售额、收入和考试分数。基本线性回归方程可以写成这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/73f5c549d2530d176b936ffe62b5946a.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/0*BGeIUZiUrf2TFZfN"/></div></figure><p id="4ef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<em class="kw"> x[i] </em>是数据的特征，其中<em class="kw"> w[i] </em>和<em class="kw"> b </em>是在训练期间开发的参数。对于数据中只有一个要素的简单线性回归模型，公式如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/dbacbf66c39e0b2ebb0ab09150fdc64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:190/0*95-XUCGcO0_s_BxJ"/></div></figure><p id="85f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<em class="kw"> w </em>是斜率，<em class="kw"> x </em>是单一特征，<em class="kw"> b </em>是 y 轴截距。熟悉吗？对于像这样的简单回归问题，模型预测由最佳拟合线表示。对于使用两个特征的模型，将使用平面。最后，对于使用两个以上特征的模型，将使用超平面。</p><p id="de21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想根据学生在考试的那一周学习了多少小时来确定他们的考试成绩。假设用最佳拟合线绘制的数据如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/be487f9d7c9bece652f238623e5200b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R82ZV3VNYTQxW3YiDo9E8A.png"/></div></div></figure><p id="7422" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习时间(自变量)和学生的最终考试成绩(因变量)之间有明显的正相关关系。当给定新的输入时，可以通过数据点绘制最佳拟合线来显示模型预测。比方说，我们想知道一个学生学习五个小时会有多好。我们可以根据其他学生的表现，使用最佳拟合线来预测考试分数。</p><p id="26e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多不同类型的回归算法。下面列出了三种最常见的方法:</p><ul class=""><li id="25ae" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">线性回归</li><li id="9a61" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">逻辑回归</li><li id="6a08" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">多项式回归</li></ul><h1 id="b583" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">简单回归示例</h1><p id="c182" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">首先，我们将导入所需的库，然后创建一个输出不断增加的随机数据集。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mx"><img src="../Images/587c9c40957201ac210e9f2fd39dcb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*q5qAAZe43vepLVNKjFthag.png"/></div></div></figure><p id="6cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以将最佳拟合线与所有数据点一起放在图上。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mx"><img src="../Images/a499085eb307c9931474b217bd2c301f.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*OU_rKVon2hP885rSIc7jkA.png"/></div></div></figure><p id="7da5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们将打印出回归模型的斜率和截距。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="2d20" class="nd ky it mz b gy ne nf l ng nh"><strong class="mz iu">print</strong>("Slope:    ", reg<strong class="mz iu">.</strong>coef_[0])<br/><strong class="mz iu">print</strong>("Intercept:", reg<strong class="mz iu">.</strong>intercept_)</span></pre><p id="1c15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="8760" class="nd ky it mz b gy ne nf l ng nh">Slope:     65.54726684409927<br/>Intercept: -1.8464500230055103</span></pre><p id="e281" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">中学的时候我们都学过一条直线的方程是<em class="kw"> y = mx + b </em>。我们现在可以创建一个名为“predict”的函数，它将把斜率(<em class="kw"> w </em>)乘以新的输入(<em class="kw"> x </em>)。该函数也将使用截距(<em class="kw"> b </em>)返回一个输出值。创建函数后，我们可以预测当<em class="kw"> x = 3 </em>和<em class="kw"> x = -1.5 </em>时的输出值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div></figure><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="e134" class="nd ky it mz b gy ne nf l ng nh">Predict y For 3:      194.7953505092923<br/>Predict y For -1.5:  -100.16735028915441</span></pre><p id="5d3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们用最佳拟合线来绘制原始数据点。然后，我们可以添加我们预测的新点(红色)。不出所料，它们落在最佳拟合线上。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mx"><img src="../Images/b4502f58f1d46ffaa184cd1485ec1ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*WUncqO3fCdzEMK8CzR5N3A.png"/></div></div></figure><h1 id="a103" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="c16d" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">监督学习是机器学习的最简单的子类别，是许多机器学习从业者对机器学习的介绍。监督学习是最常用的机器学习形式，并已被证明是许多领域的优秀工具。这篇文章是三部分系列文章的第一部分。第二部分将涵盖<strong class="js iu">无监督学习</strong>。</p></div></div>    
</body>
</html>