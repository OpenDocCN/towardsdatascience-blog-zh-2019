<html>
<head>
<title>Introduction to Convolutional Neural Networks (CNN) with TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流卷积神经网络简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-convolutional-neural-networks-cnn-with-tensorflow-57e2f4837e18?source=collection_archive---------3-----------------------#2019-04-03">https://towardsdatascience.com/introduction-to-convolutional-neural-networks-cnn-with-tensorflow-57e2f4837e18?source=collection_archive---------3-----------------------#2019-04-03</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="ea1b" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">学习计算机视觉卷积神经网络的基础，并使用 TensorFlow 构建 CNN</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/74fe3d60c05fec35f9cfb9674df076b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fGzfv2ZASyPSCHj7"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo by <a class="ae la" href="https://unsplash.com/@stephtcook?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephanie Cook</a> on <a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fa7d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">深度学习的最新进展使计算机视觉应用向前迈进了一大步:从用我们的脸解锁手机，到更安全的自动驾驶汽车。</p><p id="050f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">卷积神经网络</strong> (CNN)是计算机视觉应用背后的架构。在这篇文章中，你将学习细胞神经网络和计算机视觉的基础，如卷积运算，填充，步长卷积和池层。然后，我们将使用 TensorFlow 构建一个用于图像识别的 CNN。</p><blockquote class="lx"><p id="fb5b" class="ly lz iv bd ma mb mc md me mf mg lw dk translated">对于机器学习、深度学习和人工智能的实践视频教程，请查看我的<a class="ae la" href="https://www.youtube.com/channel/UC-0lpiwlftqwC7znCcF83qg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> YouTube 频道</a>。</p></blockquote><figure class="mh mi mj mk ml kp"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Spiderman recognizing Spiderman…</figcaption></figure><h1 id="36f9" class="mo mp iv bd mq mr ms mt mu mv mw mx my kb mz kc na ke nb kf nc kh nd ki ne nf bi translated">理解卷积</h1><p id="4fd2" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">顾名思义，<strong class="ld iw">卷积</strong>运算是卷积神经网络的构建模块。</p><p id="7012" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，在计算机视觉领域，图像可以表示为 RGB 值的矩阵。这个概念实际上是在之前的一篇<a class="ae la" rel="noopener" target="_blank" href="/step-by-step-guide-to-building-your-own-neural-network-from-scratch-df64b1c5ab6e">文章中介绍的。</a></p><p id="c6c7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了完成卷积运算，我们需要一个图像和一个过滤器。</p><p id="33fc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，让我们将下面的 6x6 矩阵视为图像的一部分:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/489218fd23b28ae57bc480d39b79159d.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*aGSthcPASa2OT1UBm7paOA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">6x6 matrix. <a class="ae la" href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/4Trod/edge-detection-example" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="b6b9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">并且过滤器将是下面的矩阵:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0b1068efab86d7d063565229bc5aa574.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*591OPcvDKUN9liZ_VQ1M5g.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">3x3 filter. <a class="ae la" href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/4Trod/edge-detection-example" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="b0b8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，卷积包括将过滤器叠加到图像矩阵上，将来自过滤器的值和来自图像矩阵的值的乘积相加，这将生成 4x4 卷积层。</p><p id="1933" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这很难用语言表达，但这里有一个很好的动画来解释这个卷积:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nn"><img src="../Images/cd7a5df8874d57367eb90465c50f3a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VJCoCYjnjBBtWDLrugCBYQ.gif"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Convolution operation</figcaption></figure><p id="fbce" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">对上面的图像矩阵执行此操作，并使用上面定义的过滤器，您应该得到下面的结果矩阵:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi no"><img src="../Images/441429db4d3759dd7ddfa1dee7f24fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*FkUz4rejmKag4x6j5QC39w.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">4x4 output layer. <a class="ae la" href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/4Trod/edge-detection-example" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="200e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如何解读输出层？</p><p id="8cc2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">考虑到每个值都表示颜色，或者像素有多暗(正值表示亮，负值表示暗)，您可以将输出图层解释为:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi np"><img src="../Images/22ba310422aed6acff0d3f4c9a70d0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*UHl8cCPMN2GfuR9JRtOfCg.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Output layer interpretation. <a class="ae la" href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/4Trod/edge-detection-example" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="742a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，似乎这个特殊的过滤器负责检测图像中的垂直边缘！</p><h2 id="14e3" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">如何选择合适的滤镜？</h2><p id="e1b1" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">这是一个很自然的问题，因为你可能会意识到有无数种可能的滤镜可以应用于一幅图像。</p><p id="bb43" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">事实证明，您的过滤器矩阵中的精确值可以是基于模型目标的可训练参数。因此，您可以选择适合特定应用的滤波器，也可以使用<a class="ae la" rel="noopener" target="_blank" href="/step-by-step-guide-to-building-your-own-neural-network-from-scratch-df64b1c5ab6e">反向传播</a>来确定能够产生最佳结果的滤波器的最佳值。</p><h1 id="444b" class="mo mp iv bd mq mr ms mt mu mv mw mx my kb mz kc na ke nb kf nc kh nd ki ne nf bi translated">计算机视觉中的填充</h1><p id="dbc8" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">之前，我们已经看到，3x3 滤波器与 6x6 图像卷积将产生 4x4 矩阵。这是因为在 6×6 的图像中，有 4×4 的可能位置适合滤波器。</p><p id="5a50" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，在每个卷积步骤之后，图像会缩小，这意味着只能执行有限次数的卷积，直到图像无法再缩小为止。此外，位于图像角落的像素仅被使用一次，这导致神经网络的信息丢失。</p><p id="8f1e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了解决上述两个问题，使用了<strong class="ld iw">填充</strong>。填充包括在输入图像周围添加边框，如下所示:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/aac512e2a8f7f8017c05ee317433c34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*gwEFlk20bWiXGyZkO5r_Xg.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Input image with padding of 1</figcaption></figure><p id="39b1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如你所见，添加的边框通常用零填充。现在，图像的角像素将被多次使用来计算输出，有效地防止信息丢失。此外，它允许我们在输出中保持输入矩阵的形状。</p><p id="a431" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">考虑我们的 6x6 输入图像，如果我们添加 1 的填充，我们得到一个 8x8 的矩阵。应用 3×3 滤波器，这将产生 6×6 输出。</p><p id="871f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">一个简单的等式可以帮助我们计算出输出的形状:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi od"><img src="../Images/b992c23f981069380dd083ce63f4f105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvp7Rv0F5RVvEizfZGTI4A.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Where n is the input shape, p is the padding size, and f is the filter shape</figcaption></figure><p id="0983" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">重申一下，我们有:</p><ul class=""><li id="9bec" class="oe of iv ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">6x6 输入</li><li id="a2ca" class="oe of iv ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">填充 1</li><li id="c18f" class="oe of iv ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">3x3 过滤器</li></ul><p id="eb34" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，输出形状将是:6+2(1)-3+1 = 6。因此，输出将是一个 6x6 的矩阵，就像输入图像一样！</p><p id="6c88" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">填充并不总是必需的。但是，当使用填充时，通常是为了使输出与输入图像具有相同的大小。这产生了两种类型的卷积。</p><p id="8238" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当没有应用填充时，这被称为“<strong class="ld iw">有效卷积”</strong>。否则称为“<strong class="ld iw">同卷积”</strong>。要确定保持输入图像尺寸所需的填充大小，只需将上面的公式等同于<em class="os"> n </em>。求解完<em class="os"> p </em>后，你应该得到:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ot"><img src="../Images/112be5c77ea3d50f6932ee8627d03110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWzcwdB9ZJTk_CYtIK6gTw.png"/></div></div></figure><p id="e77e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您可能已经注意到，为了使填充为整数，<em class="os"> f </em>应该是奇数。因此，在计算机视觉领域，使用奇数滤镜是一种惯例。</p><h1 id="3a7a" class="mo mp iv bd mq mr ms mt mu mv mw mx my kb mz kc na ke nb kf nc kh nd ki ne nf bi translated">步进卷积</h1><p id="61e5" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">之前，我们已经看到了步长为 1 的卷积。这意味着过滤器水平和垂直移动了 1 个像素。</p><p id="de81" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">跨距卷积是指跨距大于 1 的卷积。在下面的动画中，步幅是 2:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/37a16c39550f39bf9554a42c79893d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*GkmFFtArfzTN62uy8Lsf2g.gif"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Convolution with a stride of 2</figcaption></figure><p id="2ea2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，考虑步幅，计算输出矩阵形状的公式为:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ov"><img src="../Images/29ca37eae5922755bc23427149790ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aizYpl5FG3nE3wybDHcvQg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Where s is the stride</figcaption></figure><p id="62dc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">按照惯例，如果上面的公式不能得出一个整数，那么我们就向下舍入到最接近的整数。</p><h1 id="b68a" class="mo mp iv bd mq mr ms mt mu mv mw mx my kb mz kc na ke nb kf nc kh nd ki ne nf bi translated">池层</h1><p id="3420" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">合并图层是另一种减少图像解释大小以加快计算速度的方法，它使检测到的特征更加稳健。</p><p id="b05a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">用一个图像来解释池是最好的。下面是<strong class="ld iw">最大池</strong>的一个例子:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ow"><img src="../Images/3154d5a602a8da716d3dc6b6c4267261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ziqq69FhwOAbBi9-FNruAA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Max pooling with a 2x2 filter</figcaption></figure><p id="db9f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如您所见，我们选择了步幅为 2 的 2x2 滤波器。这相当于将输入分成 4 个相同的正方形，然后我们取每个正方形的最大值，并将其用于输出。</p><p id="c9a2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">也可以执行平均池化，但是它不如最大池化流行。</p><p id="f4bf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您可以将池化视为防止过度拟合的一种方式，因为我们正在从输入图像中移除一些特征。</p><h1 id="74b1" class="mo mp iv bd mq mr ms mt mu mv mw mx my kb mz kc na ke nb kf nc kh nd ki ne nf bi translated">为什么要使用卷积神经网络？</h1><p id="ef92" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">我们现在有一个强大的卷积神经网络的基础知识。但是，深度学习从业者为什么要用呢？</p><p id="1ee8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">与全连接层不同，卷积层需要学习的参数要少得多。这是因为:</p><ul class=""><li id="a1c7" class="oe of iv ld b le lf lh li lk og lo oh ls oi lw oj ok ol om bi translated">参数共享</li><li id="47c3" class="oe of iv ld b le on lh oo lk op lo oq ls or lw oj ok ol om bi translated">联系的稀疏性</li></ul><p id="c7dd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">参数共享是指一个特征检测器，例如垂直边缘检测器，将在图像的许多部分有用。那么，连接的稀疏性是指只有少数特征与某个输出值相关。</p><p id="a551" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">考虑上面的最大池示例，输出的左上值仅取决于输入图像的左上 2x2 正方形。</p><p id="5c38" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，我们可以在更小的数据集上进行训练，并大大减少要学习的参数数量，使 CNN 成为计算机视觉任务的一个伟大工具。</p><h1 id="4c3d" class="mo mp iv bd mq mr ms mt mu mv mw mx my kb mz kc na ke nb kf nc kh nd ki ne nf bi translated">用 TensorFlow 构建 CNN</h1><p id="28fa" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">理论讲够了，让我们为手势识别编写一个 CNN。我们重温一个<a class="ae la" rel="noopener" target="_blank" href="/the-complete-tensorflow-tutorial-for-newbies-dc3acc1310f8">以前的项目</a>，看看 CNN 是否会表现得更好。</p><p id="a6a9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">一如既往，完整的笔记本可在<a class="ae la" href="https://github.com/marcopeix/Deep_Learning_AI/blob/master/4.Convolutional%20Neural%20Networks/1.Foundations%20of%20Convolutional%20Neural%20Networks/ConvNet%20in%20TensorFlow.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h2 id="002a" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">步骤 1:预处理图像</h2><p id="506b" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">导入所需的库和资产后，我们加载数据并预处理图像:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ox"><img src="../Images/ec73bf29b58cf4f70325bc26b60d1e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LYCHqOt1nCsWnRAkKMCEA.png"/></div></div></figure><h2 id="7d39" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">步骤 2:创建占位符</h2><p id="5a3c" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">然后，我们为特征和目标创建占位符:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oy"><img src="../Images/945e190306179ea87f5b6353708b35fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBsRg_fAqc936Bc-Yhyaqw.png"/></div></div></figure><h2 id="9e42" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">步骤 3:初始化参数</h2><p id="b6b1" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">然后，我们使用 Xavier 初始化来初始化参数:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oz"><img src="../Images/09c622cdef8798f4376a5cf19a50e3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaJYUdsTfrUlKYiDS2C3VA.png"/></div></div></figure><h2 id="dac1" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">步骤 4:定义正向传播</h2><p id="a9a6" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">现在，我们定义正向传播步骤，这实际上是我们 CNN 的架构。我们将使用一个简单的三层网络，包括两个卷积层和一个全连接层:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pa"><img src="../Images/03c7c0cd50584fb6783706cbb51c2343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Hi9oFvpQacKu2e7X5yIyQ.png"/></div></div></figure><h2 id="9905" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">第五步:计算成本</h2><p id="c1a6" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">最后，我们定义一个函数来计算成本:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pb"><img src="../Images/b48c15046f9ee35cb1be29077ccc970a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmvD8TNeRF19ZeTDHTkHFQ.png"/></div></div></figure><h2 id="b8c9" class="nq mp iv bd mq nr ns dn mu nt nu dp my lk nv nw na lo nx ny nc ls nz oa ne ob bi translated">步骤 6:将所有功能组合成一个模型</h2><p id="250c" class="pw-post-body-paragraph lb lc iv ld b le ng jw lg lh nh jz lj lk ni lm ln lo nj lq lr ls nk lu lv lw io bi translated">现在，我们将上述所有功能合并到一个 CNN 网络中。我们将使用小批量梯度下降进行训练:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="pc mn l"/></div></figure><p id="e5ab" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">太好了！现在，我们可以运行我们的模型，看看它的表现如何:</p><pre class="kl km kn ko gt pd pe pf pg aw ph bi"><span id="b30f" class="nq mp iv pe b gy pi pj l pk pl">_, _, parameters = model(X_train, Y_train, X_test, Y_test)</span></pre><p id="ba66" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在我的例子中，我在只使用 CPU 的笔记本电脑上训练 CNN，我得到了一个相当糟糕的结果。如果你在有更好的 CPU 和 GPU 的台式机上训练 CNN，你肯定会得到比我更好的结果。</p></div><div class="ab cl pm pn hz po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="io ip iq ir is"><p id="b586" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">恭喜你！你现在对 CNN 和计算机视觉领域有了很好的了解。尽管还有更多的东西需要学习，但是更高级的技术使用这里介绍的概念作为构建模块。</p><p id="8b96" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在下一篇文章中，我将介绍 Keras 的剩余网络！</p><p id="b1b8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">干杯！</p><p id="7700" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">参考:<a class="ae la" href="https://www.deeplearning.ai/" rel="noopener ugc nofollow" target="_blank"> deeplearning.ai </a></p></div></div>    
</body>
</html>