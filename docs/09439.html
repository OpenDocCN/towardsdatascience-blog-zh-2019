<html>
<head>
<title>Visualising the Mercator graph layout/embeddings using a real-world complex network.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用真实世界的复杂网络可视化墨卡托图布局/嵌入。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualising-the-mercator-graph-layout-embeddings-using-a-real-world-complex-network-bf065c316b7a?source=collection_archive---------29-----------------------#2019-12-12">https://towardsdatascience.com/visualising-the-mercator-graph-layout-embeddings-using-a-real-world-complex-network-bf065c316b7a?source=collection_archive---------29-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aa7687166ab40c70dbd711151bb932ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-2Dl0taarjDM2CVqUPu1w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">A network of the <a class="ae kf" href="http://mcm.york.ac.uk" rel="noopener ugc nofollow" target="_blank">Master Chemical Mechanism</a></figcaption></figure><p id="1f05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">制图领域长期以来一直使用投影将高维数据(即地球，扁球体)转换成平面表示。</p><p id="86f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最近的一篇论文“<a class="ae kf" href="https://arxiv.org/abs/1904.10814https://arxiv.org/abs/1904.10814" rel="noopener ugc nofollow" target="_blank"> <em class="le">墨卡托:揭示复杂网络的忠实双曲线嵌入(2019) </em> </a> <em class="le">”中，</em>采用了将球形地球转换为圆柱形表示的相同数学方法，能够将恒定方位角映射为线性段，并应用它来产生无向和未加权网络内的节点嵌入。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="f75a" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">我们的数据</h2><p id="2d15" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我感兴趣的复杂网络是 2019 年北京空气质量活动中对流层(低层空气)化学的近显式表示。当使用传统的力定向或静电图形算法作图时，我们看到高度连接的物质形成了“毛团”。许多真实世界的图表就是这种情况。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/09ab444047cabba072b65c2dca0b6d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mpja--M9u8NMZxGG5izBA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Plotting the network using the Force Atlas algorithm.</figcaption></figure><h2 id="262a" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">应用墨卡托图布局</h2><p id="d621" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">为了应用图表布局，我们使用<a class="ae kf" href="https://github.com/networkgeometry/mercator" rel="noopener ugc nofollow" target="_blank">https://github.com/networkgeometry/mercator</a>提供的代码。这读入我们网络的边列表，并返回我们计算嵌入的极坐标。在绘制这些图时，我们得到了下图。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/6601c6014962e1114b0d674d6f2b4f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNuS_rWSSHvutXzQLLcwWw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Plotted output of the Mercator embedding.</figcaption></figure><h2 id="32f1" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">将输出转换成 JSON 文件</h2><p id="54e7" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">因为我们的绘图将在 Javascript 中完成，所以我们将嵌入输出转换成 JSON 格式，可以由可视化软件读取。</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="324d" class="lm ln it mr b gy mv mw l mx my">'''<br/>To plot run python plot.py &lt;filename&gt;<br/>This reads &lt;filename&gt;.edges and &lt;filename&gt;.inf_coord<br/>'''</span><span id="02fb" class="lm ln it mr b gy mz mw l mx my">import sys,json<br/>import pandas as pd<br/>name = sys.argv[1]</span><span id="f10c" class="lm ln it mr b gy mz mw l mx my">edge= pd.read_csv(name+'.edge',comment='#',header=None,sep='\s+',index_col= None)[[0,1]]<br/>edge.columns = 'source target'.split()</span><span id="4080" class="lm ln it mr b gy mz mw l mx my">df = pd.read_csv(name+'.inf_coord',comment='#',header=None,sep='\s+',index_col=0)<br/>df.columns = 'k theta r'.split()</span><span id="b84e" class="lm ln it mr b gy mz mw l mx my">save = {}<br/>save['nodes'] = df.T.to_dict()<br/>save['edges'] = edge.T.to_dict()</span><span id="1a57" class="lm ln it mr b gy mz mw l mx my">json.dump(save,open(name+'.json','w'))</span></pre><h2 id="e1b3" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">使用 D3.js 绘图</h2><p id="6a24" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">如果你对 Javascript 或 D3 不熟悉，我推荐你看看<a class="ae kf" href="http://observablehq.com" rel="noopener ugc nofollow" target="_blank">www.observablehq.com</a>。这有许多关于如何制作图像和在图像中放置元素的例子。</p><p id="1281" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些能够分配点数的人，我们首先用<code class="fe na nb nc mr b">d3.json('../data.json', data =&gt; {...})</code>读入我们的数据，然后设置一个横跨半个页面的径向标尺:</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="b2fb" class="lm ln it mr b gy mv mw l mx my">size = Math.min(width,height)</span><span id="d34d" class="lm ln it mr b gy mz mw l mx my">var r = d3.scaleLinear().domain(d3.extent(d3.values(data.nodes).map(d=&gt;d.r))).range([0,size/2])</span></pre><p id="5d52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用<code class="fe na nb nc mr b">sine</code>和<code class="fe na nb nc mr b">cosine</code>函数将极坐标从墨卡托输出转换成笛卡尔坐标。</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="5885" class="lm ln it mr b gy mv mw l mx my">node_data = {};<br/>    d3.entries(data.nodes).forEach(d =&gt; {</span><span id="6081" class="lm ln it mr b gy mz mw l mx my">node_data[d.key] = {'x': r(d.value.r) * Math.cos(d.value.theta),<br/>        'y':r(d.value.r) * Math.sin(d.value.theta)<br/>      }</span><span id="ab5c" class="lm ln it mr b gy mz mw l mx my">});</span></pre><p id="b821" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，编写我们希望用来绘制节点的脚本</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="bd4b" class="lm ln it mr b gy mv mw l mx my">svg.selectAll(".node")<br/>      .data(d3.values(data.nodes))<br/>      .enter()<br/>      .append("circle")<br/>      .attr("r", 2)<br/>      .attr('cx', d=&gt; d.y)<br/>      .attr('cy', d=&gt; d.x)<br/>      .style("fill", "steelblue")<br/>      .style("opacity", 0.6)<br/>      .attr('transform',`translate(${size/2},${size/2})`)</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="8342" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">边缘捆绑</h2><p id="380a" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">边捆绑是一种用于简化图中的边的技术。这里，边缘被模拟为柔性弹簧，如果满足一定的几何兼容性标准，它们会相互吸引。这通常用于减少可视化中链接的混乱。欲了解更多信息，请阅读<a class="ae kf" href="https://aviz.fr/wiki/uploads/Teaching2014/bundles_infovis.pdf" rel="noopener ugc nofollow" target="_blank">和</a>。</p><p id="84a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先从<a class="ae kf" href="https://github.com/upphiminn/d3.ForceBundle/blob/master/d3-ForceEdgeBundling.js" rel="noopener ugc nofollow" target="_blank">D3-forcegebundling . js</a>下载相关的库文件，并将其放入当前目录。从这里，我们可以使用脚本标签将它导入到我们的程序中:</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="b8bf" class="lm ln it mr b gy mv mw l mx my">&lt;script type="text/javascript" src="d3-ForceEdgeBundling.js"&gt;&lt;/script&gt;</span></pre><p id="d2d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以引入边缘捆绑功能:</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="9d53" class="lm ln it mr b gy mv mw l mx my">var fbundling = d3<br/>      .ForceEdgeBundling()<br/>      .step_size(.2)<br/>      .compatibility_threshold(.70)<br/>      .nodes(node_data)<br/>      .edges(data.edges);</span><span id="c1a4" class="lm ln it mr b gy mz mw l mx my">const results = fbundling();</span></pre><p id="dcb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们遍历每个返回的边，并将其添加到我们的图像中:</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="3307" class="lm ln it mr b gy mv mw l mx my">var d3line = d3<br/>      .line()<br/>      .x(function(d) {<br/>        return d['x'] ;<br/>      })<br/>      .y(function(d) {<br/>        return d['y'];<br/>      })<br/>      .curve(d3.curveLinear);</span><span id="f6d6" class="lm ln it mr b gy mz mw l mx my">results.forEach(function(edge_subpoint_data,i) {</span><span id="1d83" class="lm ln it mr b gy mz mw l mx my">      svg<br/>        .append("path")<br/>        .attr("d", d3line(edge_subpoint_data,i))<br/>        .style("stroke", "#222")<br/>        .style("fill", "none")<br/>        .style("stroke-width",0.25)<br/>        .style("stroke-opacity", .39)<br/>        .attr('transform',`translate(${size/2},${size/2})`)</span><span id="e479" class="lm ln it mr b gy mz mw l mx my">});</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="6174" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">调整兼容性阈值</h2><p id="c2d4" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">最后，我们可以调整兼容性阈值来改变不同边相互吸引的程度。这将把上面的线性图转换成下列之一。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aa7687166ab40c70dbd711151bb932ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-2Dl0taarjDM2CVqUPu1w.png"/></div></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="7c9e" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">钦佩结果</h2><p id="1978" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">这就是我们的数据集的墨卡托图嵌入的边捆绑表示。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/1dbac89e34e8352c14b75caff98389ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2NFYDpyJxwCxFXMYhlsZw.png"/></div></div></figure><blockquote class="nd ne nf"><p id="084d" class="kg kh le ki b kj kk kl km kn ko kp kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">注意:所有图像都受版权保护。如果在任何地方使用，请引用“丹尼尔·埃利斯 2019”。</p></blockquote></div></div>    
</body>
</html>