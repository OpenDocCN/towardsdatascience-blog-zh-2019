<html>
<head>
<title>Create a Python map from categorical data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据分类数据创建 Python 地图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-categorical-choropleth-with-python-122da5ae6764?source=collection_archive---------15-----------------------#2019-05-22">https://towardsdatascience.com/create-categorical-choropleth-with-python-122da5ae6764?source=collection_archive---------15-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="54ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多关于使用 Python 构建地理地图的好帖子，比如<a class="ae ko" rel="noopener" target="_blank" href="/lets-make-a-map-using-geopandas-pandas-and-matplotlib-to-make-a-chloropleth-map-dddc31c1983d">这个</a>。然而，所有这些帖子都使用 choropleths 作为连续数据，这意味着使用带有颜色条的渐变来填充地图。由于我找不到很多关于如何使用分类信息构建地图的信息，所以我决定尝试自己构建一些东西，结果是这样的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/9e204af407535508214d4a2d94f26366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R12TcrgrWnrKPGTBbdbnBw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Map from categorical data, built with Python.</figcaption></figure><h2 id="2da4" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">要求</h2><p id="f774" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为了构建此地图，您需要以下库:</p><ul class=""><li id="f556" class="md me it js b jt ju jx jy kb mf kf mg kj mh kn mi mj mk ml bi translated">Pandas 和 NumPy(使用数据框)</li><li id="57f3" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn mi mj mk ml bi translated">Geopandas(使用 shapefiles)</li><li id="e146" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn mi mj mk ml bi translated">Matplotlib(绘制图表)</li></ul><h1 id="2146" class="mr lg it bd lh ms mt mu lk mv mw mx ln my mz na lq nb nc nd lt ne nf ng lw nh bi translated">准备数据</h1><h2 id="c432" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">获取数据</h2><p id="0178" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">创建 geopandas 地图时，您总是需要两个文件。</p><p id="982c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个文件是 shapefile，它包含多边形以构建一个带有边界的空地图。你可以在网上找到无数不同地区和边界的 shapefiles。对于这个项目，我使用了一个以行政区为边界的纽约市形状文件。</p><p id="6594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">fp = ‘geo_export_58b25928–032c-45c8-a41f-8345f112f4d4.shp’<br/>map_df = gpd.read_file(fp)</code></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nm"><img src="../Images/d163498feb60f260e088f1f3e7e8a807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBXq__E_MJogI6WQT-tXzg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">The shapefile data.</figcaption></figure><p id="92af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据导入后，您就可以预览地图的外观，而无需用数据填充地图。</p><p id="5370" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">map_df.plot()</code></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nn"><img src="../Images/92659394db753ce4f0ef550454ab1aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oC9_OR2TozY28jdOEZpjQg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">A plot of the NYC shapefile.</figcaption></figure><p id="a71c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们用我们的数据对不同的行政区进行颜色编码。</p><p id="fe30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个文件是实际数据，即包含用于填充地图的值。在这种情况下，我在纽约市使用了包含 364.558 <strong class="js iu"> 311 服务请求</strong>的<a class="ae ko" href="https://www.kaggle.com/sherinclaudia/nyc311-2010" rel="noopener ugc nofollow" target="_blank">文件。</a></p><p id="fb9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">df = pd.read_csv(‘NY_311_requests.csv’)</code></p><p id="11fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个文件中，每行代表一个请求(或投诉)。然而，我想看看各区最受欢迎的投诉类型。通过使用<strong class="js iu"> groupby </strong>我可以创建这个概览:</p><p id="eef8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">df_top_compl = df.groupby(‘Borough’)[‘Complaint Type’].apply(lambda x: x.value_counts().head(1)).reset_index()</code></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b8fef49c345b91cc9b0a0fff440ead5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*BlRi1P5XABZpCPst2LAJOA.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Most frequent complaint by borough</figcaption></figure><h2 id="b2b2" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">合并数据</h2><p id="cb2d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">现在我们有了两个文件，我们可以将它们合并在一起，这样我们就有了地理数据和填充数据(投诉)的组合。由于两个数据框架都包含行政区，我们可以基于该列进行合并。然而，在数据文件中，行政区是用大写的<strong class="js iu">写成的</strong>，所以我们也需要将它应用到 shapefile。</p><p id="0779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">map_df[‘Borough’] = map_df[‘boro_name’].apply(lambda x: x.upper())</code></p><p id="5212" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，两个文件都有一列具有相似的值，我们可以在该列上合并它们。(为了防止 shapefile 中的行政区没有匹配的填充数据，我还添加了一个 fillna()值。)</p><p id="c146" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">data_df = pd.merge(map_df, df_top_compl, how=’left’, on=’Borough’)<br/>data_df[‘level_1’].fillna(value=’No data’, inplace=True)</code></p><p id="43f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在所有的数据都准备好了，我们可以创建地图了！</p><h1 id="29e0" class="mr lg it bd lh ms mt mu lk mv mw mx ln my mz na lq nb nc nd lt ne nf ng lw nh bi translated">创建地图</h1><h2 id="4a37" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">准备颜色</h2><p id="88a4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在我们创建实际的地图之前，我们将为图例做一些准备。鉴于代码应该是动态的，以防数据发生变化，我们不能使用固定数量的图例颜色。所以我们要做的是用调色板中相应的颜色创建一个填充值的字典(在这个例子中是<strong class="js iu"> matplotlib tab20b </strong>)，除了'<em class="np"> No data </em>'值，按照惯例它应该总是灰色的。</p><p id="2d94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">keys = list(data_df[‘level_1’].unique())<br/>color_range = list(np.linspace(0, 1, len(keys), endpoint=False))<br/>colors = [cm.tab20b(x) for x in color_range]<br/>color_dict = dict(zip(keys, colors))<br/>color_dict[‘No data’] = ‘lightgray’</code></p><h2 id="4e4d" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">准备网格</h2><p id="c611" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">由于我们需要绘制图例和地图，我们将把图形分成两列；<strong class="js iu">左为图例</strong>，<strong class="js iu">右为地图</strong>。图例的左列必须再次按行拆分:每个值和相应的颜色一行。但是，由于项目应该是动态的，我们不能使用固定的行数，它应该适应填充值的数量。使用下面的代码，我们可以根据唯一填充值的数量创建一个轴列表<strong class="js iu">。</strong></p><p id="0cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">row_count = data_df[‘level_1’].nunique()<br/>ax_list = []<br/>for i in range(row_count+1):<br/> ax_list.append(‘ax’ + str(i+1))<br/>ax_string = ‘, ‘.join(ax_list)</code></p><p id="a71a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于该字符串和轴名称列表，我们可以创建具有 4 列和 N 行的<strong class="js iu">plot grid</strong>。</p><p id="7f93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">fig, (ax_string) = plt.subplots(row_count, 4)</code></p><p id="b55c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这 4 列中，我们将第一列用于图例，另外 3 列用于实际绘图(使用 colspan)。</p><p id="3d54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们有 5 行(要绘制的唯一值)，网格将如下所示:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nq"><img src="../Images/e410b1c54c450e4058de92e0ebf3aa68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTf8rNGhPt3XNJ6QTcaJqw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Subplotgrid mockup.</figcaption></figure><h2 id="5234" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">绘制地图</h2><p id="30b7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这就是“传统”的连续数据图谱的不同之处。我们将使用一个循环来堆叠不同的地图，而不是绘制一个地图，以创建最终的结果。每个图层由一个区组成，每个区的颜色对应于它的值，使用我们之前构建的颜色字典。</p><p id="7958" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">ax1 = plt.subplot2grid((row_count,4),(0,1), rowspan=row_count, colspan=3)<br/>for index, row in data_df.iterrows():<br/> plot = data_df[data_df[‘boro_code’] == row[‘boro_code’]].plot(color=color_dict[row[‘level_1’]], ax=ax1)<br/> ax1.axis(‘off’)</code></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nr"><img src="../Images/3049cc78933a03a292e9288d4c873687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cr1UjHHsQ59B3vvPtUyOww.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Map without legend.</figcaption></figure><p id="a769" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">地图看起来很棒，但是没有相应的图例显然是没用的。所以让我们把那部分也加上。</p><h2 id="6881" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">绘制图例</h2><p id="bb0d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">现在让我们在左栏添加一个图例。由于我们使用图层构建了地图，因此我们还需要以一种不太传统的方式构建图例。网格已经完成，包含了我们将要绘制的每个图例值的一行。现在在每一行将放一个彩色圆圈(使用一个小饼图)和一个字符串与相应的值。</p><p id="92e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ni nj nk nl b">row_counter = 0<br/>for i in data_df[‘level_1’].unique(): <br/> plt.subplot2grid((row_count,4),(row_counter,0))<br/> plt.pie([1],labels=[i],radius=0.4, colors=[color_dict[i]])<br/> plt.axis(‘off’)<br/> row_counter += 1</code></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/b530eb6c754b26506b562909b8c1a4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbdoFoOHPQSdKsBddE11Rg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Final result.</figcaption></figure><p id="cd4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那里！带有分类数据和相应图例的精美地图。如果数据发生了变化，您可以简单地重新运行脚本，图例中的颜色和值的数量都会很好地适应。</p><p id="d716" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，你可以把它应用到你能找到的任何 shapefile 和数据上，只要你能合并这两个文件。</p><p id="7e5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在我的<a class="ae ko" href="https://github.com/ZhongTr0n/categorical_choropleth" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看并下载我的 Jupyter 笔记本。如果有不清楚的地方，请随时提问。</p><p id="9927" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我要感谢<a class="ns nt ep" href="https://medium.com/u/37240f6b6698?source=post_page-----122da5ae6764--------------------------------" rel="noopener" target="_blank">本杰明·库利</a>，他的<a class="ae ko" rel="noopener" target="_blank" href="/lets-make-a-map-using-geopandas-pandas-and-matplotlib-to-make-a-chloropleth-map-dddc31c1983d">帖子</a>给了我创作这个附加内容的灵感。</p><p id="8062" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这是我在 Medium 上的第一篇帖子，任何评论或反馈都将受到极大的感谢。</p><p id="bfbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="np">关于我:我叫布鲁诺，是总部位于荷兰的人工智能技术纵向扩展公司</em><a class="ae ko" href="http://www.dashmote.com" rel="noopener ugc nofollow" target="_blank"><em class="np">dash mote</em></a><em class="np">的数据科学家。我们的目标是借助基于人工智能的解决方案，弥合图像和数据之间的鸿沟。<br/>查看我在</em> <a class="ae ko" href="https://www.zhongtron.me" rel="noopener ugc nofollow" target="_blank">上的其他作品 https://www.zhongtron.me </a>。</p></div></div>    
</body>
</html>