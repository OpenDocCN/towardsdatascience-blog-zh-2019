<html>
<head>
<title>Javascript Generator Yield/Next vs Async-Await Overview and Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 生成器 Yield/Next 与 Async-Await 概述和比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/javascript-generator-yield-next-async-await-8442d2c77185?source=collection_archive---------4-----------------------#2019-09-03">https://towardsdatascience.com/javascript-generator-yield-next-async-await-8442d2c77185?source=collection_archive---------4-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/85ac86fb7c76e3be87aa94b7e00c3769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yONeU8vuaq8eIyTD"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="9aaf" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">发电机(ES6)</h2><blockquote class="le lf lg"><p id="1988" class="lh li lj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">可以根据用户需求在不同的时间间隔返回多个值并可以管理其内部状态的函数是生成器函数。如果一个函数使用了<code class="fe mg mh mi mj b"><a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank"><em class="it">function*</em></a></code>语法，它就变成了 GeneratorFunction。</p></blockquote><p id="777e" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">它们不同于普通函数，普通函数在一次执行中运行完成，而<em class="lj">生成器函数可以暂停并恢复</em>，因此它们确实运行完成，但触发器仍在开发人员手中。它们允许对异步功能进行更好的执行控制，但这并不意味着它们不能用作同步功能。</p><blockquote class="le lf lg"><p id="d000" class="lh li lj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">注意:当执行生成器函数时，它返回一个新的生成器对象。</p></blockquote><p id="3895" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">暂停和恢复是使用<code class="fe mg mh mi mj b">yield</code> &amp; <code class="fe mg mh mi mj b">next</code>完成的。所以让我们看看它们是什么，它们是做什么的。</p><h2 id="8a2f" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">产量/下一个</h2><p id="531a" class="pw-post-body-paragraph lh li it lk b ll ml ln lo lp mm lr ls kr mn lv lw kv mo lz ma kz mp md me mf im bi translated">关键字<code class="fe mg mh mi mj b">yield</code>暂停生成器函数的执行，关键字<code class="fe mg mh mi mj b">yield</code>后面的表达式的值被返回给生成器的调用者。它可以被认为是基于生成器的<code class="fe mg mh mi mj b">return</code>关键字版本。</p><p id="015b" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><code class="fe mg mh mi mj b">yield</code>关键字实际上返回一个具有两个属性<code class="fe mg mh mi mj b">value</code>和<code class="fe mg mh mi mj b">done</code>的<code class="fe mg mh mi mj b">IteratorResult</code>对象。(如果你<a class="ae mk" href="https://codeburst.io/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener" target="_blank">不知道什么是迭代器和可迭代对象，那么请阅读这里的</a>)。</p><p id="dc8a" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">一旦在<code class="fe mg mh mi mj b">yield</code>表达式上暂停，生成器的代码执行就会保持暂停，直到调用生成器的<code class="fe mg mh mi mj b">next()</code>方法。每次调用生成器的<code class="fe mg mh mi mj b">next()</code>方法时，生成器恢复执行并返回<a class="ae mk" href="https://codeburst.io/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener" target="_blank">迭代器</a>的结果。</p><p id="8048" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">咳…理论讲够了，让我们来看一个例子</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="c22b" class="ki kj it mj b gy my mz l na nb">function* UUIDGenerator() {<br/>    let d, r;<br/>    while(true) {<br/>        yield 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {<br/>            r = (new Date().getTime() + Math.random()*16)%16 | 0;<br/>            d = Math.floor(d/16);<br/>            return (c=='x' ? r : (r&amp;0x3|0x8)).toString(16);<br/>        });<br/>    }<br/>};</span></pre><p id="a577" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">这里，<code class="fe mg mh mi mj b">UUIDGenerator</code>是一个生成器函数，它使用随机数的当前时间计算 UUID，并在每次执行时返回一个新的 UUID。</p><p id="4d12" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">要运行上面的函数，我们需要创建一个生成器对象，我们可以在其上调用<code class="fe mg mh mi mj b">next()</code></p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="fe6b" class="ki kj it mj b gy my mz l na nb">const UUID = UUIDGenerator();<br/>// UUID is our generator object</span><span id="21e6" class="ki kj it mj b gy nc mz l na nb">UUID.next() <br/>// return {value: 'e35834ae-8694-4e16-8352-6d2368b3ccbf', done: false}</span></pre><p id="f42c" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><code class="fe mg mh mi mj b">UUID.next()</code>将在<code class="fe mg mh mi mj b">value</code>键下的每个<code class="fe mg mh mi mj b">UUID.next()</code>上返回新的 UUID，而<code class="fe mg mh mi mj b">done</code>将始终为假，因为我们处于一个无限循环中。</p><blockquote class="le lf lg"><p id="bc13" class="lh li lj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">注意:我们暂停在无限循环之上，这有点酷，在一个生成器函数中的任何“停止点”，它们不仅可以向一个外部函数产生值，还可以从外部接收值。</p></blockquote><p id="1b6e" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">上面有很多生成器的实际实现，也有很多大量使用它的库，<a class="ae mk" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank"> co </a>、<a class="ae mk" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> koa </a>和<a class="ae mk" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>就是一些例子。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="2ee0" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">异步/等待(ES7)</h2><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/d378ca65594459b9e9857629afa5fdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LAkE4GiZATgtseM5"/></div></div></figure><p id="708b" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">传统上，当异步操作返回使用<code class="fe mg mh mi mj b">Promise</code>处理的数据时，回调被传递和调用。</p><p id="1afd" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">Async/Await 是一种特殊的语法，以更舒适的方式处理承诺，非常容易理解和使用。</p><p id="324f" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><code class="fe mg mh mi mj b">async</code> <em class="lj"> </em>关键字用于定义一个<em class="lj">异步函数</em>，返回一个<code class="fe mg mh mi mj b"><a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">AsyncFunction</a></code>对象。</p><p id="c387" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><code class="fe mg mh mi mj b">await</code>关键字用于暂停异步函数的执行，直到<code class="fe mg mh mi mj b">Promise</code>完成，即解决或拒绝，并在完成后继续执行<code class="fe mg mh mi mj b">async</code>函数。当恢复时，<code class="fe mg mh mi mj b">await</code>表达式的值就是已完成的<code class="fe mg mh mi mj b">Promise</code>的值。</p><p id="53da" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><strong class="lk iu">要点:</strong></p><p id="2844" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">1.<code class="fe mg mh mi mj b">await</code>只能在<code class="fe mg mh mi mj b">async</code>函数中使用。</p><p id="0762" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">2.带有<code class="fe mg mh mi mj b">async</code>关键字的函数将总是返回一个承诺。</p><p id="5ed7" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">3.在同一个函数下，多个等待将总是按顺序运行。</p><p id="0a28" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">4.如果承诺正常解决，那么<code class="fe mg mh mi mj b">await promise</code>返回结果。但是在拒绝的情况下，它抛出错误，就好像在那一行有一个<code class="fe mg mh mi mj b">throw</code>语句一样。</p><p id="86a2" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">5.一个<code class="fe mg mh mi mj b">async</code>函数不能同时等待多个承诺。</p><p id="40ff" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">6.如果将许多<code class="fe mg mh mi mj b">await</code>作为一条语句使用而不依赖于前一条语句，可能会出现性能问题。</p><p id="cd85" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">到目前为止一切顺利，现在让我们看一个简单的例子:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="ce9e" class="ki kj it mj b gy my mz l na nb">async function asyncFunction() {</span><span id="473b" class="ki kj it mj b gy nc mz l na nb">  const promise = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; resolve("i am resolved!"), 1000)<br/>  });</span><span id="9aaa" class="ki kj it mj b gy nc mz l na nb">  const result = await promise; <br/>  // wait till the promise resolves (*)</span><span id="1315" class="ki kj it mj b gy nc mz l na nb">  console.log(result); // "i am resolved!"<br/>}</span><span id="3374" class="ki kj it mj b gy nc mz l na nb">asyncFunction();</span></pre><p id="0f35" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><code class="fe mg mh mi mj b">asyncFunction</code>执行在第<code class="fe mg mh mi mj b">await promise</code>行“暂停”,并在承诺完成时恢复，结果是<code class="fe mg mh mi mj b">result</code>。所以上面的代码一秒钟显示了“<code class="fe mg mh mi mj b">i am resolved!</code>”。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="46b8" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">生成器和异步等待—比较</h2><ol class=""><li id="9bae" class="ne nf it lk b ll ml lp mm kr ng kv nh kz ni mf nj nk nl nm bi translated"><em class="lj"> Generator functions/yield </em>和<em class="lj"> Async functions/await </em>都可以用来编写“等待”的异步代码，这意味着代码看起来好像是同步的，尽管它实际上是异步的。</li><li id="3f84" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><em class="lj">一个生成器函数</em>一个产出<strong class="lk iu">一个产出</strong>地执行，即通过其迭代器(T4 方法)一次执行一个产出表达式，而<em class="lj">同步等待</em>，它们被依次执行<strong class="lk iu">等待</strong>。</li><li id="8cc1" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><em class="lj"> Async/await </em>使得实现<em class="lj">生成器</em>的特定用例更加容易。</li><li id="50ec" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated">g <em class="lj">生成器</em>的返回值始终是<code class="fe mg mh mi mj b"><strong class="lk iu">{value: X, done: Boolean}</strong></code>，而对于<em class="lj">同步函数来说，</em>将始终是一个<strong class="lk iu">承诺</strong>，要么解析为值 X，要么抛出一个错误。</li><li id="8139" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated">一个<code class="fe mg mh mi mj b">async</code>函数可以被分解成一个生成器和 promise 实现，这是一个很好的工具。</li></ol></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="bc76" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">如果您想被添加到我的电子邮件列表中，请考虑在这里输入您的电子邮件地址<a class="ae mk" href="https://goo.gl/forms/MOPINWoY7q1f1APu2" rel="noopener ugc nofollow" target="_blank"><strong class="lk iu"/></a>和<strong class="lk iu">关注我的</strong> <a class="ae mk" href="https://medium.com/@ideepak.jsd" rel="noopener"> <strong class="lk iu">中的</strong> </a> <strong class="lk iu">阅读更多关于 javascript 和</strong><a class="ae mk" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="lk iu">github</strong></a><strong class="lk iu">的文章，看看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="18d4" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="9c7f" class="ne nf it lk b ll lm lp lq kr ns kv nt kz nu mf nj nk nl nm bi translated"><a class="ae mk" href="https://levelup.gitconnected.com/javascript-execution-context-and-hoisting-c2cc4993e37d" rel="noopener ugc nofollow" target="_blank"> Javascript 执行上下文和提升</a></li><li id="cee8" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><a class="ae mk" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解 Javascript‘this’关键字(上下文)</a>。</li><li id="0a58" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><a class="ae mk" href="https://levelup.gitconnected.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener ugc nofollow" target="_blank"> Javascript 数据结构与映射、归约、过滤</a></li><li id="d00c" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><a class="ae mk" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="88d0" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><a class="ae mk" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="60e2" class="ne nf it lk b ll nn lp no kr np kv nq kz nr mf nj nk nl nm bi translated"><a class="ae mk" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a>，<a class="ae mk" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li></ol></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="a6c8" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><strong class="lk iu">如果您喜欢这篇文章，请随意分享并帮助他人找到它！</strong></p><p id="fa0d" class="pw-post-body-paragraph lh li it lk b ll lm ln lo lp lq lr ls kr lu lv lw kv ly lz ma kz mc md me mf im bi translated"><strong class="lk iu">谢谢！</strong></p></div></div>    
</body>
</html>