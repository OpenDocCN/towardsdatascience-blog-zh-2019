<html>
<head>
<title>How and why I got 75Gb of free foreign exchange “Tick” data.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何以及为什么获得 75Gb 的免费外汇“滴答”数据。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-and-why-i-got-75gb-of-free-foreign-exchange-tick-data-9ca78f5fa26c?source=collection_archive---------4-----------------------#2019-07-30">https://towardsdatascience.com/how-and-why-i-got-75gb-of-free-foreign-exchange-tick-data-9ca78f5fa26c?source=collection_archive---------4-----------------------#2019-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1210" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过完整的 Python 代码来抓取、提取、转换并加载到 HDF5 数据存储中，以满足未来的自己。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68c22062b14b53bc62eba491d8ffe681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BcuR4nd0lEJyRG8K"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@robsonhmorgan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robson Hatsukami Morgan</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在完成数据科学硕士课程的最后，我开始想象自己用机器学习和自动化交易做聪明的事情。如果你和我一样，碰到过<em class="lv"> </em> <strong class="lb iu"> <em class="lv">【我如何获得历史自由分笔成交点数据】</em></strong>connudrum，那么这篇帖子就是为你准备的。</p><p id="aa0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把我的文章分为三个部分:</p><ol class=""><li id="8daf" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">一些背景知识。</li><li id="05d6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">故事时间——如何失败然后成功。</li><li id="1080" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将所有这些放在一起—完整的代码</li></ol><p id="7061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意跳到你最感兴趣的部分。</p><h1 id="8303" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1.一些背景知识</h1><p id="f8d7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">正如我之前提到的，这一切都始于我对应用一些机器学习(ML)来预测市场价格或者更简单的市场方向的问题感兴趣。也就是说，我想使用 ML 来分析给定货币对的一些历史数据，然后告诉我未来某个特定点的价格。然后我会用这个预测价格来决定如何投资我的钱。因为我只需要知道目标货币的价值是增加还是减少，我可以简化我的算法来简单地预测市场方向(正或负)。当然，这是对交易盈利所需条件的过分简化，但是准确预测市场的未来状态(准确率高于 50%)是关键的第一步。</p><p id="7862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用 ML 建立市场模型之前，我首先需要一些关于市场的数据。这些数据有多种形式。通常情况下，数据可以在所谓的“蜡烛数据”或基于时间的“棒线”中自由传播。蜡烛数据以基于时间的增量(频率)出现。这可以是 1 分钟、5 分钟、1 天、每月等等。以下是来自 FXCM 的日蜡烛线数据示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Example using FXCM RestAPI to download daily candle data.</figcaption></figure><p id="769e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ea6bb439622fb9dd9f5f2a9faccbac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*O1wglKKSGVOT-RNN-J_Qpw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">FXCM daily candle data.</figcaption></figure><p id="6a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于给定的货币对(本例中为 USD/JPY ),每一行代表单日数据的一根<em class="lv">蜡烛线</em>。它告诉你的是蜡烛线开始时的价格，蜡烛线结束时的价格，蜡烛线窗口期间的最高价格和最低价格。它为市场的两个方面做这件事，出价和要价。</p><p id="adc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值共同代表时间和价格值的边界，在此边界内所有价格变化(称为分笔成交点)都会发生。除了蜡烛线边界之外，数据还包括刻度数量值。该值表示在蜡烛线边界内发生的价格变化的数量。但是，它不会告诉您何时发生了变化，或者变化有多大或多小。</p><p id="be03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图直观地展示了蜡烛的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7cbd8fc8616af2f91d8990b008801c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*8QbYEBKnaZWsrxGiimm3tQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Diagram showing the structure of a single data candle.</figcaption></figure><p id="a237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过查看上图，打开和关闭边界之间的空间是由蜡烛大小指定的。在 USD/JPY 示例中，这个空格代表一整天。然而，它可能是 1 分钟，1 小时或任何蜡烛数据供应商可以为您提供。</p><p id="b48a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，蜡烛线是原始基础分笔成交点数据的一个样本，结合了关于样本本身的一些描述性统计信息(分笔成交点计数)。事实上，人们可以认为蜡烛数据实际上是关于发生了什么的有限的元数据，而不是事件的实际记录。</p><h2 id="d5ac" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">为什么使用蜡烛数据作为 ML 的主要数据源是不好的。</h2><p id="8e55" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">那么蜡烛数据有什么问题呢？显然每个人都喜欢它..首先，蜡烛数据是低分辨率的，不能描述产生蜡烛“盒子”的潜在价格变化。第二，标准蜡烛使用基于时间的采样，这进一步模糊了潜在的事件。Marcos Lopez De Prado 在他的书<a class="ae ky" href="https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089" rel="noopener ugc nofollow" target="_blank">“金融机器学习的进步”</a>中详细解释了这些问题。</p><p id="aa73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反对基于时间的蜡烛线的一个简单论点是，市场活动不会在一天中均匀发生。这样，大量产生交易机会的价格变化，当它们存在于蜡烛内部时，就变得模糊不清了。这反过来使得 ML 算法不可能学习关于这些自主时间的任何东西，因此不能识别交易机会，因为所需的指标在时间蜡烛数据中不存在。</p><p id="c872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">De Prado 确实提出了替代类型的蜡烛线采样，但是要创建这些类型的蜡烛线数据集，您需要有基础的分笔成交点数据。替代采样的一个示例是基于规则的分笔成交点数量对分笔成交点数据进行采样。换句话说，不管市场有多活跃，都要根据固定的交易量来制作蜡烛线。</p><p id="feff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，轻松访问原始数据使我能够通过使用各种数据集构建概念来进行自己的特征工程，这些概念专门旨在获得更好的机器学习结果。此外，我热衷于在这种需要大量训练数据的问题上尝试一些深度学习技术。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="3a9f" class="mk ml it bd mm mn oe mp mq mr of mt mu jz og ka mw kc oh kd my kf oi kg na nb bi translated">2.故事时间——如何失败然后成功</h1><p id="9fff" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">足够的背景..这里的要点是告诉您如何获得大量免费分笔成交点数据的技术故事。我将向您介绍我是如何做到这一点的，以及我遇到的挑战和如何克服它们。</p><p id="e6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示我如何为 21 个货币对收集 2 年(2017 年和 2018 年)的分笔成交点数据，并将其加载到一个<a class="ae ky" href="https://www.hdfgroup.org/solutions/hdf5/" rel="noopener ugc nofollow" target="_blank">分层数据文件(HDF5) </a>。数据来自<a class="ae ky" href="https://www.fxcm.com/" rel="noopener ugc nofollow" target="_blank"> FXCM </a>，最初使用它们的<a class="ae ky" href="https://github.com/fxcm/RestAPI" rel="noopener ugc nofollow" target="_blank"> RestAPI </a>。我最终放弃了他们的 api，采用了不同的方法。</p><h2 id="7afe" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">版本 1 -&gt; API 失败:</h2><p id="ff80" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，这里是我第一次尝试使用的库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FXCM 提供了一个名为<code class="fe oj ok ol om b">fxcmpy_tick_data_reader</code>(这里也称为<code class="fe oj ok ol om b">tdr</code>)的函数，它将返回关于哪些货币对可用的信息，但也允许您下载一个目标货币。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">How to use FXCM RestAPI to get available tick data currency pairs (symbols).</figcaption></figure><p id="71cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/246c8118a5685500fa6390f281eb1caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zvo0YFsPCSjUE7cLVl-WLg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">FXCM available symbols with some duplicates.</figcaption></figure><p id="038e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算符号的数量显示有 24 个，但是这里有一些重复，所以让我们创建一个没有任何重复的新列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">script that creates a list of symbols without duplicates.</figcaption></figure><p id="5260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们现在只有 21 种货币对:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/cd4c8a7f6d561fb6a1d244cb21f5c891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*6qKTTS_y1mcApksVBvujCg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">FXCM available symbols without duplication.</figcaption></figure><p id="8473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获取一些数据，您需要指定该范围的开始和结束日期，然后调用函数来要求目标货币对，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9626148c465da6a6214ae353b96188aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*5YEVHQakP0K4RySuOIGsbQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">FXCM tick_data_reader() output when request 5 weeks of data.</figcaption></figure><p id="4a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，无论您是否只需要 1 天，数据都是以 1 周为单位提供的。所以当你看 URL 的时候，我们可以看到上面的代码已经返回了一个 2017 年第 1 周的 gzip 文件。如果您更改日期并自己运行代码，您将看到 URL 遵循相同的模式，只需根据您请求的日期范围更改年份或周数。如果您请求超过一周的数据，它只是返回更多的 gzip 文件。</p><p id="4475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看数据，您需要对下载的数据调用一些方法，这些方法将提取文件并将包含的 csv 转换为 pandas 数据帧。根据您使用的方法，它还会将索引从类型<code class="fe oj ok ol om b">object</code>更新为类型<code class="fe oj ok ol om b">DataTimeIndex</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下图所示，<code class="fe oj ok ol om b">get_data()</code>方法将索引从<code class="fe oj ok ol om b">object</code>(又名<code class="fe oj ok ol om b">str</code>)转换为<code class="fe oj ok ol om b">DatetimeIndex:</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/aa98a8b9b6a6ecfa27b228813fe6ad2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*9LpFSQIaCwt3LL-r57F5ZA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Output showing index has been converted to type = DatetimeIndex.</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oj ok ol om b">get_raw_data()</code>的情况下，索引保持为<code class="fe oj ok ol om b">object`</code>类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9338a45fbfe25fd92e31bd4cdf9cc676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*oMBH1NsLQbBtPDLJg5ULsw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Output showing the index type has not been changed.</figcaption></figure><h2 id="94f8" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">慢速索引转换:</h2><p id="8fd3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当调用<code class="fe oj ok ol om b">get_data()</code>时，您会注意到它比<code class="fe oj ok ol om b">get_raw_data()</code>要长得多。这是由于从<code class="fe oj ok ol om b">object</code>到<code class="fe oj ok ol om b">DatetimeIndex</code>的指数转换。<code class="fe oj ok ol om b">get_data()</code>和<code class="fe oj ok ol om b">get_raw_data()</code>都产生一个熊猫数据帧，但是<code class="fe oj ok ol om b">get_data()</code>更新索引以使用日期时间列作为索引，并将其转换为类型<code class="fe oj ok ol om b">DatetimeIndex</code>。我后来发现，在没有<a class="ae ky" href="http://strftime.org/" rel="noopener ugc nofollow" target="_blank"> srftime 格式指令</a>的情况下，包含微秒字段的<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>在转换为<code class="fe oj ok ol om b">DatetimeIndex</code>时表现不佳。参见 stackoverflow 上的<a class="ae ky" href="https://stackoverflow.com/questions/32034689/why-is-pandas-to-datetime-slow-for-non-standard-time-format-such-as-2014-12-31/32034914#32034914" rel="noopener ugc nofollow" target="_blank">“为什么 pandas.to_datetime 对于‘2014/12/31’等非标准时间格式较慢”</a>了解更多信息。</p><p id="bb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的底线是需要一个 srftime 指令来加速(索引转换)。我稍后将回到这一点。</p><p id="a6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问为什么拥有一个<code class="fe oj ok ol om b">DatetimeIndex</code>很重要？..这很重要，因为我们希望以后能够根据时间对数据进行切片。为此，应该从一开始就将数据正确加载到 HDF5 数据存储中。我们不希望以后不得不转换索引。</p><h2 id="515a" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">继续前进…</h2><p id="4aeb" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了自动下载，我们需要提供触发下载每周文件的日期范围。为了防止下载超时，我决定一次下载一个月的文件。为了做到这一点，我创建了一个短列表，我称之为<code class="fe oj ok ol om b">periods</code>，它包含了这段时间内每个星期一的日期。</p><p id="6bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的脚本计算出一年中每个星期一的正确日期，并将它们组织成 4 个一组的列表(一个周期),并将所有列表放在一个大列表中。稍后，我使用这个列表来自动下载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Script that creates a list of shorter lists that contain the sequential dates of four Mondays each.</figcaption></figure><p id="690b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我的描述看起来令人困惑，下面的示例输出显示了 2 个短列表，每个短列表包含 4 个按顺序排列的星期一日期，并从前面的列表开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/7345c70c3cbd6cca4146434c2e00db30.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*EvhJmliF9osCYCMvQQ9mJQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">List of lists containing 4 Mondays each.</figcaption></figure><p id="3e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我创建了一个函数，它执行以下操作:</p><ul class=""><li id="25da" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu os mc md me bi translated">下载文件。</li><li id="c601" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">提取数据。</li><li id="f848" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">将索引更新为<code class="fe oj ok ol om b">DatetimeIndex</code>。</li><li id="855f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">将数据追加到正确的表中。</li><li id="d2ff" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">刷新 HDF5 文件中的表格。</li></ul><p id="0732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还附上了一些打印声明，以帮助我跟踪下载、提取和上传的内容。</p><p id="f800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我在一个小程序中使用该函数，打开 HDF5 文件，使用 ETL 函数，最后关闭 HDF5 文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Small program that uses the FXCM RestAPI to fetch FX data and then loads it into a HDF5 database</figcaption></figure><h2 id="d932" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">为什么上面的代码不够好:</h2><p id="b40a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">所以在运行脚本之后，很快就清楚这将需要一段时间。当我说一会儿..我是说几天！！..真的是几天！！</p><p id="a460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然这还不够好，因为我不知道为什么它会这么慢，我只是假设这是互联网问题引起的太空猴子。这个过程的缓慢给我带来了各种各样令人沮丧的问题。</p><ol class=""><li id="29f0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">由于下载时间太长，我会离开我的电脑，最终导致睡眠模式，并中断了下载过程。这导致脚本失败。</li><li id="1752" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">最恼人的是，由于数据的大小，我决定将数据写入外部硬盘。即使我取消了所有的节电盒，我的笔记本电脑仍然会偶尔断开和重新连接硬盘。如果这发生在 HDF5 文件关闭之前，整个数据存储将会损坏！</li></ol><p id="a6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在做了一番调查后，我意识到太空猴子不应该受到指责。相反，前面提到的指数转换是整个过程花费这么长时间的原因。我还发现我下载的文件是 gzip 文件，每个大约 5Mb。一旦提取出来，它们会膨胀到 80Mb 左右。</p><p id="1ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为加速整个过程提供了一些机会..</p><h2 id="4e88" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">版本 2 -&gt;成功</h2><p id="f0d1" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在多次尝试下载所有可用的分笔成交点数据后，由于超时、文件损坏和必须重启而失败..我决定采取不同的方法。</p><p id="64e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，每个 gzip 文件只有几兆字节。我决定首先抓取所有文件，并将它们存储在一个目录中，稍后我将提取这些文件。这样我就可以避免每次出错时都要重新下载文件。</p><p id="709e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">版本 2 需要的库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="5e47" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">刮刀</h2><p id="e856" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果在代码中不清楚，我正在做的是构造遵循 FXCM 格式的 url，然后我使用<code class="fe oj ok ol om b">requests</code>库在构造的 URL 下载每个文件。为了确保每个文件正确下载，我决定流式下载文件，并在<code class="fe oj ok ol om b">chunks</code>中将数据写入磁盘。以下是抓取脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python script that downloads FXCM gzip files that contain FX data.</figcaption></figure><p id="3a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管每个文件只有 5-10mb 大小，但值得注意的是，它们有 2000 多个，下载它们确实需要一些时间。你可能会发现自己走开去吃烤面包或看网飞的一个节目。</p><h2 id="1d59" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">检查点</h2><p id="3836" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当你回到你的电脑，你可能要检查你下载了每种货币的所有文件。您可以费力地手动检查这些文件，或者…您可以使用下面的代码来检查它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python script that counts files by matching the first 6 characters.</figcaption></figure><p id="b50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您成功下载了所有内容，上面的脚本输出应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/0e0ab4c03a6ce1daf809429594d19cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*Zcx6JobQbMydqK5qkmNoXg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Output from file counting script.</figcaption></figure><p id="7b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经下载了所有文件，下一步是提取并加载到我们的数据库中(HDF5 文件)。此时，我还没有解决索引更新缓慢的问题。因此，我按货币对创建了批处理文件夹，这样我就可以监控数据到数据库的提取、转换和加载(ETL ),而不用一次呆在电脑前好几天。每批大约需要 3-4 个小时完成。</p><h2 id="bc08" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">定量</h2><p id="3236" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本文结束时，您不需要创建批处理，但是如果出于某种原因您想创建批处理，您可以使用下面的脚本。</p><p id="31ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它为每种货币创建一个文件夹，然后通过将前 6 个字符与其所属的文件夹名称进行匹配来查找属于该文件夹的文件，然后将文件复制到目标文件夹中。最后，您将拥有 21 个文件夹，每个文件夹包含 104 个文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python script that copies gzip files to folders by matching files to folders.</figcaption></figure><h2 id="ca98" class="nl ml it bd mm nm nn dn mq no np dp mu li nq nr mw lm ns nt my lq nu nv na nw bi translated">ETL 脚本解释</h2><p id="75cc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在的目标是解压缩 gzip 文件，将数据转换为正确的格式，然后将其加载到 HDF5 数据库中。如果你喜欢阅读代码，可以直接跳到最后，但是如果你对代码是如何组合在一起的故事感兴趣，请继续阅读..</p><p id="c8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我决定放弃 FXCM api 来解包这些文件，我需要手动提取它们。我不能再使用<code class="fe oj ok ol om b">tick_data_reader()</code>函数了，因为它调用 web 服务器寻找与我请求的日期相关的文件。所有的文件现在都在我的硬盘上，所以我需要写我自己的提取代码。</p><p id="545c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于编解码器的问题，提取数据比我预期的更具挑战性。最后，我查阅了 FXCM api 源代码，找到了执行提取的<a class="ae ky" href="https://github.com/fxcm/RestAPI/blob/master/fxcmpy/fxcmpy/fxcmpy_data_reader.py" rel="noopener ugc nofollow" target="_blank">函数(见第 181 行)</a>。我稍微修改了一下代码，然后就去参加比赛了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python snippet that extracts FXCM gzip files.</figcaption></figure><p id="8e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我遇到了一个更模糊的问题。我的脚本将运行良好，直到它遇到日期时间毫秒字段不包含所需的 6 个小数位的数据。</p><p id="9d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">四舍五入到六位以下的数字不包括零，这在其他任何情况下都是完全合理的。例如，<code class="fe oj ok ol om b">.123000</code>会显示为<code class="fe oj ok ol om b">.123</code>。不幸的是，当您指定<code class="fe oj ok ol om b">srftime</code>指令(<code class="fe oj ok ol om b">format="%m/%d/%Y %H:%M:%S.%f"</code>)时，这会破坏您的代码。</p><p id="410f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，有一种奇妙的方法<code class="fe oj ok ol om b">dataframe.DateTime.str.pad()</code>可以让你用任何你想要的字符或数字填充字符串。所以我需要做的就是在字符串长度与要求的 26 个字符不匹配的地方用零填充<em class="lv">“DateTime”</em>列。更棒的是，它只用了一行代码就实现了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python snippet that pads the microsecond field with zeroes to ensure consistent formatting.</figcaption></figure><p id="521c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是将索引从类型<code class="fe oj ok ol om b">object</code>转换为类型<code class="fe oj ok ol om b">DatetimeIndex</code>的问题，这个过程相当缓慢。</p><p id="6c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在向一些老同学提出这个问题后，他们中的一个(谢谢 Alex)建议这可能与我让<code class="fe oj ok ol om b">pd.to_datetime()</code>推断格式有关。在 Pandas 文档中，它特别提到推断 datetime 格式可能会将转换速度提高 10 倍。因为我要处理大约 20 亿行数据，所以我很感激我能获得的任何加速。</p><p id="3287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，事实证明，当包含微秒时，推断 datetime 格式实际上并不好用。参见 stackoverflow 上的<a class="ae ky" href="https://stackoverflow.com/questions/32034689/why-is-pandas-to-datetime-slow-for-non-standard-time-format-such-as-2014-12-31/32034914#32034914" rel="noopener ugc nofollow" target="_blank">“为什么 pandas.to_datetime 对于‘2014/12/31’等非标准时间格式很慢”</a>了解更多信息(感谢分享链接 Davide)。</p><p id="7814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个技巧，我尝试用一个<a class="ae ky" href="http://strftime.org/" rel="noopener ugc nofollow" target="_blank"> srftime 格式指令</a>指定格式，例如:<code class="fe oj ok ol om b">format="%m/%d/%Y %H:%M:%S.%f"</code>。这大大缩短了执行时间。使用<code class="fe oj ok ol om b">"infer"</code>规范只需要几分钟就可以转换一个文件。通过指定格式，转换实际上只需要几秒钟！！。</p><p id="6baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我的麻烦还没有结束。在转换和加载“EURCHF”文件的中途，我的代码再次中断。事实证明，并非所有文件都遵循相同的日期时间格式。也就是说，有些文件将日期格式化为月/日/年，而其他文件可能是日/月/年甚至年/月/日。</p><p id="d851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理这个问题，我决定对数据集中的第一个和最后一个记录进行采样，因为每个文件包含 5 个工作日的数据。然后，在使用正确的 srftime 指令转换索引之前，我使用了一个 for 循环和一些嵌套的 if 语句来判断给定文件中每一行的格式。脚本的这一部分允许我在不到 2 个小时的时间内提取并加载所有文件(2184)，而在此之前，仅加载 104 个文件就需要 3-5 个小时。</p><p id="38b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是将索引转换为<code class="fe oj ok ol om b">Dtaetimeindex</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fbe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是将数据加载到数据库中。幸运的是，这其实很容易。<a class="ae ky" href="https://www.pytables.org/" rel="noopener ugc nofollow" target="_blank"> PyTables </a>让这一步超级简单。所需要的是:</p><ul class=""><li id="1617" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu os mc md me bi translated">打开文件。</li><li id="96bf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">将数据追加到正确的表中(如果不存在，则创建一个)</li><li id="2f4f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">将更新写入磁盘(通过“刷新”文件)</li><li id="b420" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">关闭文件</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然没有我的脚本，但你会注意到我正在打印一些摘要信息。你不需要这样做。我用这种方法来跟踪脚本运行到了哪里，并了解数据在哪里出了问题。</p><p id="80f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但并非最不重要的一点是，因为我是成批进行 ETL 的。一旦一批完成，我想要某种声音通知，所以我从<a class="ae ky" href="https://realpython.com/playing-and-recording-sound-python/" rel="noopener ugc nofollow" target="_blank">realpython.com</a>那里借了一些代码，从头开始构建一个 440 赫兹的正弦波并播放 2 秒钟。我只是在我的剧本结尾照原样使用了它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python script that generates and plays a tone at 440Hz.</figcaption></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="b923" class="mk ml it bd mm mn oe mp mq mr of mt mu jz og ka mw kc oh kd my kf oi kg na nb bi translated">3.把所有的放在一起</h1><p id="f754" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">正如所承诺的，这里是您需要的所有代码:</p><ul class=""><li id="219a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu os mc md me bi translated">收集 21 种货币对两年的分笔成交点数据</li><li id="249d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">提取数据</li><li id="f76f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">将索引转换为 DatetimeIndex</li><li id="50dc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu os mc md me bi translated">将其加载到 HDF5 数据库中</li></ul><p id="b534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重要提示:</strong>记得在运行代码之前更新您的环境的目录位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">List of libraries required for the final script.</figcaption></figure><p id="02f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第 1 部分—收集数据并检查下载</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python script that downloads all the gzip files from FXCM and then counts them.</figcaption></figure><p id="8d40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第 2 部分—提取、转换文件并将其加载到 HDF5 数据存储中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Python script that extracts, transforms and loads FXCM gzip tick data files into a HDF5 file.</figcaption></figure><p id="b891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。下一次，我将讲述/演示使用这么多分笔成交点数据可以带来的一些乐趣。</p><p id="7d9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>