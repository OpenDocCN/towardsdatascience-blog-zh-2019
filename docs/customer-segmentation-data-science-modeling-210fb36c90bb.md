# 客户细分数据科学

> 原文：<https://towardsdatascience.com/customer-segmentation-data-science-modeling-210fb36c90bb?source=collection_archive---------11----------------------->

## 问题公式化、数据建模和聚类分析

在市场营销中，*客户细分*是将客户按共同特质分组的过程。根据客户类型辨别购买习惯有助于恰当地营销。例如，它揭示了各部分的大小，我们从中赚了多少，等等。这有助于决定如何分配营销预算。

在数据科学中，*聚类*是根据一些共同特征对对象进行分组的过程。

看到联系了吗？聚类——一种数据科学方法——非常适合客户细分——一种用例。也就是说，正如经常发生的那样，当我们开始挖掘时，还有更多的东西。我们称之为建模。

让我们先来看看我们想要细分的具体特征。我们将区分 B2B 营销和 B2C 营销，因为它们的特点各不相同。

**B2B 营销**

客户是企业，即公司。一组有用的特征是所谓的*公司分类*:行业、地点、公司规模(小、中、大等)。

**B2C 营销**

在这里，顾客是消费者，即人。用于细分的有用特征是所谓的人口统计特征:年龄、性别、地点、种族、收入水平等等。

**建模**

现在，我们从 B2B 和 B2C 的细节中抽象出来，看看建模本身。虽然我们将使用 B2B 示例进行说明，但是建模更加通用。

**单一结构化因素**

先考虑单一特质，说*行业*。我们希望通过这一特点来细分客户。首先，让我们假设*行业*有少量的干净值。(“干净”是指来自受控的词汇表，例如下拉列表中的词汇表。)

这种分割很容易做到。它只是涉及到分组和聚合。

**单一非结构化因素**

现在假设*行业*价值观不干净。它们以自由格式存储在文本字段中。在数据输入时，任何有意义的值都会被输入。

假设我们的数据库中有 100，000 条客户记录，其中大多数都填写了*行业*字段值。

我们的细分问题立刻变得更加困难。同一个行业在不同的记录中往往会有不同的表达方式。词序可能有所不同；缩略语可能会被使用；连接词可能存在，也可能不存在；可能会用到同义词。

**字符串相似性度量** : 解决这个问题的第一个合理尝试是这样的。首先，我们在成对的*行业*字符串上定义一个*相似性度量*。我们首先定义一个*行业*字符串的词集。这只是字符串中的一组不同的标记。熟悉术语*单词袋*的人可能会认为这是去掉了词频的袋子。接下来，给定两个词集，我们需要一个合理的方法来量化它们的相似性。这里有一个:叫做 *Jaccard 相似度*。

两个集合的 *Jaccard 相似度*是它们共有的元素数除以它们的并集中的元素数。

下面是一个例子。

```
**Jaccard-coefficient({predictive analytics platform},{predictive analytics}) = ⅔**
```

**将记录分组**:接下来，我们需要使用这个相似性度量将记录分组。同一聚类中的记录对应该彼此相似；不同簇中的对不匹配。

这说起来容易做起来难。还不清楚我们是否已经完全考虑了我们的问题表述。我会详细说明。“组”这个词似乎意味着一个记录应该恰好属于一个簇。这真的是我们想要的吗？不一定。想象一个行业价值*医学信息学*。我们可能希望将它放在多个集群中——一些与医疗相关，一些与 IT 相关。

**多级行业**:行业字段的值可以跨越行业分类的多个级别。例如，一条记录可能将行业字段值设置为一个宽泛的类别，比如说*软件*。另一个记录可以在更精细的层次上指定行业，比如说数据库软件。所以也许我们要做的是层次聚类，而不是平面聚类。因此，行业为*数据库软件*的记录可以被分配给一个集群，该集群是行业为*软件*的集群的后代。

**聚类算法**:使用哪种算法取决于我们想要哪种类型的聚类——平面的还是层次的？即使在扁平类别中，算法也取决于我们希望聚类是硬的还是软的。(*硬*表示一个项目恰好属于一个集群。)

**平面聚类**:适合硬聚类的算法有 *k* -means 聚类、dbscan、连通分量聚类等。软聚类算法通常是硬聚类算法的软化版本。其中一个是软的，也称为概率的，即聚类的 *k* 。这是基于一个强大的算法，称为 EM 算法，其中(硬)k 均值聚类是一个特例。

**层次聚类**:流行的层次聚类算法有凝聚(自下而上)聚类或分裂(自上而下)聚类。在前者中，首先将项目聚集成紧密的簇，然后将簇聚集成较粗糙的簇。重复这个过程，直到我们得到一个聚类树。它的叶子就是物品。树的根是代表整个数据集的单个聚类。

分裂聚类的作用方向相反。它从代表整个数据集的聚类开始；然后，一个集群被一分为二。由此产生的集群成为前者的子集群。因此聚类树是自上而下生长的。

*自底向上 vs 自顶向下*:有人可能会想，自底向上或者自顶向下，它们是镜像过程，所以为什么要在意使用哪一个呢。选择很重要。合并两个合适的小集群通常比将一个大集群分成两个好的集群更容易。这个事实很大程度上解释了为什么自底向上的聚类比自顶向下的聚类更受欢迎。

另一个重要的考虑是，自底向上和自顶向下的聚类会产生不同的结果。自下而上的建立不同于自上而下的分裂。由于这个原因，当自底向上的结果不够好时，或者我们只想知道在任何特定情况下从自底向上到自顶向下的切换对树的改变有多大时，有时会考虑自顶向下的聚类。

**行业名称中的语言结构**:回到我们的行业，以非结构化价值为例，我们可能会采取第三种策略。利用行业名称中隐含的语言结构。这可能会更好。下面我们用一个玩具例子来说明这一点。出现的算法可以容易地被增强以适应更现实的场景。

*举例*:假设只有六个不同的行业价值:*软件*、*数据库软件*、*分析软件、制造业、汽车制造业、药品制造业*。(有些名字是人为的，不要当真。)所寻求的层次结构是

```
**Software ← Database Software, Software ← Analytics Software
Manufacturing ← Auto Manufacturing, Manufacturing ← Drug Manufacturing**
```

其中 *p* ← *c* 表示父子实例。

*利用语言结构的算法*:下面是算法。在这个例子中，它将产生我们想要的层次结构。

```
**Order the set of distinct industry values by the number of words in them. Least number of words first. Denote this ordering as I1, I2, …, Ik.****For each i in 1..k
   If Ii does not have a parent, set Ii as a root of the hierarchy.
   For each j in (i+1)..k
      If Ij’s parent is not set and is_child(Ij,Ii)
          parent(Ij) = Ii**
```

让我们在例子中说明这个算法。首先，我们根据行业名称中的字数对其进行排序。这产生了有序列表

```
**Software, Manufacturing, Database Software, Analytics Software, Auto Manufacturing, Drug Manufacturing**
```

接下来，我们将*软件*作为一个根，扫描到它的右边，找到它的所有子节点。我们发现

```
**Software ← Database Software, Software ← Analytics Software**
```

接下来，我们将 *Manufacturing* 作为这个层次结构的根，并扫描到它的右边，找到它的所有子代，跳过已经有父代的行业名称。我们发现

```
**Manufacturing ← Auto Manufacturing, Manufacturing ← Drug Manufacturing**
```

接下来，我们尝试查找每个两个单词的行业名称的子代。我们什么也没找到。所以我们结束了。

**多重因素，混合结构**

现在考虑结合多种因素对公司进行细分。具体来说，是根据关键的公司分类:行业、地点和公司规模。这些因素中有些可能是结构化的，有些可能是非结构化的。例如，和以前一样，工业是无组织的。公司规模可以是结构化的:用固定数量的值表示，如*小*、*中*、*大*。这使问题变得非常复杂。

**多因子相似性度量**:首先，让我们定义一个合适的度量，量化一对因子元组的相似程度。这一定义需要仔细考虑，因为这一指标将极大地影响哪些公司被归入哪些细分市场。

*序言 1 —因子描述*:首先，让我们细化我们的因子描述。我们将像以前一样保持*行业*的非结构化。我们将使*公司规模*有序。这只是意味着公司规模将有一套固定的有序值。举个例子，*小型*，*中型，大型*。我们以后可以给*公司规模*添加更多的值，比如*非常小*和*非常大*。我们甚至可以通过数据驱动的公司规模宁滨过程来自动确定一组值。结果值可能因数据集而异。只要价值观是有序的，我们就是好的。(顺便说一下，并不是每组值都可以排序。考虑性别=女，男。没有自然的顺序。我们可以强加一些人为的秩序，但这可能不太好。)

对于*位置*，首先让我们保持简单，只选择 5 位数字的邮政编码。(这确实将我们的公司局限在美国。)

*序言 2 —关于指标的一些注释*:接下来，我们在这些因素定义下定义一个合适的指标。值得注意的是，如果我们修改我们的因素定义，该指标可能需要大规模的修订。例如，假设我们将*位置*定义为*邮政编码*、*城市*、*州*、*国家*的组合。量化两个地点的相似程度现在要复杂得多。

**单个因素的相似性度量**

我们将采用为每个因素单独定义相似性度量的方法，并在此基础上构建我们的多因素相似性度量。

**公共部分— Sigmoid 函数**:在我们深入研究各个指标之前，我们想提一下贯穿其设计的一个关键点。在所有这些方法中，我们使用 sigmoid 函数作为阶梯函数的软近似。我们这样做是因为当被比较的值不够相似时，我们希望相似性迅速下降到 0。这使我们能够控制相似性检测和假阳性率。

正因为如此，我们先来定义一下 sigmoid 函数。

```
**sigmoid_{a,b}(x) = 1/(1+exp(-a*(x-b)))**
```

`a`控制 sigmoid 的陡度，即它逼近阶跃函数的程度。`b`控制软阈值。就像一个阶跃函数，sigmoid 识别`b`两侧的值。

**公司名称相似度指标**:让我们从比较两家公司规模的指标开始。让我们将公司规模值按顺序排列为 *1* 、 *2* 、 *3* 、…、 *k* 。也就是说， *1* 表示最小公司尺寸仓位， *k* 表示最大公司尺寸仓位。我们的相似性度量是

```
**S(i,j) = sigmoid_{a,b}(-|i-j|)**
```

这里`a>0`和`b>0`让我们控制 s 形的陡度和阈值。我们使用了`-|i-j|`而不是`|i-j|`作为参数，因为我们寻求一个反 s 形行为。相反，我们可以将这个负号吸收到`a`中，但是让它显式更直观。

S(i，j)有一个简单的直觉，即箱 *i* 和 *j* 在它们的等级顺序中越接近，即在它们所代表的公司的规模中，相似性值越高。

我们将选择合理的默认值，这样如果你不喜欢自由参数，你可以忘记它们。具体来说，我们将`a`设置为 1，这是最常用的 sigmoid 陡度。为了更好地揭示什么值`b`有意义，让我们将 sigmoid 重写为`sigmoid(b-|i-j|)`。我们将把`b`设置为 1.5。这将使我们得到当`|i-j|<=1.5`s 形值从下方越过 0.5 时的行为。当然，我们可以随心所欲地微调这种行为。

**zip 相似性度量**:接下来，让我们研究 zip 值的度量。我们将利用 5 位数的邮政编码是数字的事实，一般来说，数字越近，邮政编码位置就越近。我们使用

```
**S(z1,z2) =sigmoid_{a,b}(-|z1-z2|)**
```

这次我们会选择`a>0`远小于 1、`b`到~ 20。直觉是，我们希望 S(z1，z2)大于 0.5，即使|z1-z2|大约为 20，粗略地说。此外，我们希望交叉点有低陡度。当然，我们可以按照自己认为合适的方式微调这些值。

*替换和转置错误*:虽然这种度量对邻近性建模得足够好，但它没有考虑替换或转置错误。让我们先来看一个例子。(我们有意省略了插入和删除错误，因为它们改变了位数。)

```
**Substitution error: 21**0**34, 21**8**34, Transposition error: 2**10**34, 2**01**34**
```

和上面的例子一样，我们将只考虑*单个*数字替换错误和*相邻*数字换位错误。下面是一个简单的度量标准，可以容纳一位数的替换错误:

```
**S2(z1,z2) = sigmoid_{a,b}(-sum_i NE(z1[i],z2[i]))**
```

这里`x`等于`y`时`NE(x,y)`等于 0，不等于时为 1。我们将`a`设置为 1，将`b`设置为 1.5，因为我们寻求的行为(根据 sigmoid 的论证)正是我们寻求的公司规模相似性。

类似地，我们可以定义一个最多容纳一个相邻数字换位的度量。

```
**T(z1,z2) = sigmoid_{a,b}(-#adjacent-digit-transpositions(z1,z2))**
```

我们使用与替代计分相同的`a`和`b`。

现在，我们可以将所有这些指标合并成一个指标。

```
**Sim(z1,z2) = Max(S(z1,z2),S2(z1,z2),T(z1,z2) )**
```

**行业相似性度量**:最后，对于*行业*，我们将使用其词集上的 Jaccard 系数作为相似性度量，并通过 sigmoid 进一步转换。即

```
**S_industry(I1,I2) = sigmoid_{a,b}(Jaccard-coefficient(I1,I2))**
```

如何选择`a`和`b`的默认值我们就不详细描述了。相反，我们将注意到`a`应该是大于 1 的正数，并且`b`应该被选择为我们认为处于相似性边缘的 Jaccard 系数的值。请注意，Jaccard-coefficient 返回一个介于 0 和 1 之间的值，其中 0 表示最不相似，1 表示最相似。

**多因素指标**

我们现在准备在这些指标的基础上构建我们的多因素指标。首先，让我们简单讨论一下这种方法的利弊。这种模块化设计使得添加新的因素或删除现有的因素变得容易。它还使得调整单个因子值的相似性对整体度量的相对影响变得容易。也就是说，它不能自然地模拟因素之间的相互作用。为了对这些进行建模，需要明确地添加特定的交互术语。

我们的多因素指标是

```
**S(C1,C2) = w_zip*S_zip(C1.zip,C2.zip) + w_industry*S_industry(C1.industry,C2.industry) + w_company_size*S(C1.company_size_bin_rank,C2.company_size_bin_rank)**
```

因素权重让我们可以控制整体指标中单个因素相似性的相对影响。

**专门化**:现在我们有了这个指标，我们可以通过简单地将某些因素权重设置为 0 来构建它的各种专门化。因此，我们可以实现所有的单因素版本——基于 zip 的相似性、基于行业的相似性、基于公司规模的相似性——以及所有的双因素版本。有了这些专业化，我们可以更加灵活地构建细分市场。实际上，我们可以根据一个因素、两个因素或所有三个因素进行分组。请注意，“分组依据”实际上意味着“模糊分组依据”。

**聚类相似性矩阵**:我们想要提出的关键点是，利用我们定义的成对相似性度量的自然方法是计算所有成对公司之间的成对相似性，并在相似性矩阵中捕捉这些相似性。(除非公司的数量太多，以至于计算两两相似度会太慢。我们将假设情况并非如此。)

然后，聚类算法可以直接在这个矩阵上工作。这就分开了顾虑。聚类算法只对相似矩阵进行操作，而不关心它是如何产生的。相似性度量关注量化实际的相似性，而不关心对象将如何在下游聚集。

**一个具体的算法——图划分**:我们来看一个相似矩阵上的具体聚类算法。我们将把矩阵表示成图形。图中的节点是对象，在我们的例子中是公司。如果对应的对象足够相似，则两个节点由一条边连接。边上的权重捕获实际的相似性值。

该算法的高级思想是将图划分成由稀疏交叉区域连接的稠密子图。密集的子图将表示紧密的聚类。稀疏的交叉区域将确保这些簇被很好地分开。

我们来提炼一下这个描述。我们首先需要一些关键概念。

*子图密度*:我们将一个子图在 *k* 个节点上的密度定义为连接这组节点对的边上的权重之和除以 *k* ( *k* -1)/2。这假设边上的权重介于 0 和 1 之间。非边可以被视为权重为 0 的边。在这种表示下，子图的密度是其中一条边的平均权重。

*节点权重*:我们将节点的权重定义为接触该节点的边的权重之和。我们将节点集上的节点*的权重定义为接触该节点的边的权重之和，该节点的另一个端点在该集中。例如，节点 *b* 、 *c* 和 *d* 上的节点 *a* 的权重是边 *a* - *b* 、 *a* - *c* 和 *a* - *d* 的权重之和。*

*实际算法*:接下来，我们描述一个简单的启发式算法，它可以找到一个好的聚类。

```
**find_one_good_cluster(G)
   C = {v}, where v is a highest-weight node in G
   Repeat
     Find a node v in G-C whose weight on C is
     sufficiently high.
     If no such v exists 
       Close C.
       remaining_clusters = find_one_good_cluster(G-C)
       Return remaining_clusters + {C}
     Else
       Add v to C
   forever**
```

“足够高”测试使算法偏向于寻找紧密的聚类。(不保证紧密性，因为紧密性检查仅在节点添加到集群时进行。)该算法并不明确倾向于跨簇稀疏。这是隐性的。只要一个集群之外的节点对其中的节点具有足够高的累积权重，该集群就会保持增长。因此，当集群停止增长时，其外部的所有节点相对于其中的节点具有较低的累积权重。这有利于稀疏的跨簇区域。

**总结**

在这篇文章中，我们看到了聚类作为一种数据科学方法是如何作为一个用例很好地适合市场细分的。我们已经研究了 B2B 和 B2C 细分的因素。我们已经研究了当一个因子有干净的值时出现的问题；当一个因子具有非结构化值的长尾时；当一个因子有一小组序数值时。

我们已经讨论了平面聚类、软聚类和层次聚类。我们已经看到了领域知识如何指导我们使用什么算法，甚至让我们远离标准算法。(我指的是利用行业名称中隐含的语言结构，将行业名称聚集成一个行业层次结构。)

我们已经提出了具体的衡量标准，用于量化我们在 B2B 环境中遇到的某些因素的相似性。然后，我们提出了一个多因素相似性度量，并描述了如何在多因素聚类中使用它(考虑通过多个因素的组合来细分市场)。