<html>
<head>
<title>Combinatorics: permutations, combinations and dispositions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合学:排列、组合和处置</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/combinatorics-permutations-combinations-and-dispositions-46604da34882?source=collection_archive---------15-----------------------#2019-09-07">https://towardsdatascience.com/combinatorics-permutations-combinations-and-dispositions-46604da34882?source=collection_archive---------15-----------------------#2019-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/8b92b919d3371317b7d8a3115152eda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/0*bo2IpxNTU1Wrx6zv.jpg"/></div></figure><div class=""/><p id="7be9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">组合学是数学的一个领域，主要研究对一个或多个集合中的元素进行计数。它可以帮助我们统计可能发生的<em class="kv">订单</em>的数量。</p><p id="e933" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本文中，我将详细介绍三种不同类型的技术:</p><ul class=""><li id="39a0" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">排列</li><li id="44ac" class="kw kx ja jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">性情</li><li id="0b04" class="kw kx ja jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">组合</li></ul><h1 id="0174" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">排列</h1><p id="1ad1" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">这些是最容易计算的。想象我们有 n 个物体，彼此不同。排列是这些物体的任何可能的排列。</p><p id="7939" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">考虑下面的例子。我们有一个盒子，里面有一些球(每个球有不同的颜色)，我们想计算排列这些球的方式。我们可以用两种不同的方法做到这一点:重复(每个球在被捡起后都被放回盒子里)或者不重复。</p><ul class=""><li id="38a0" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz jb">重复</strong>:这个想法是，在每一个球被提取后，我们可以根据自己的需要任意多次再次选择它。让我们简单地开始，考虑盒子={g，b}，其中 g= '绿色球'，b= '蓝色球':嗯，在这种情况下，我们可以排列那些球的可能方式是' gg '，' bg '，' gb '，' bb '。我们也可以用 Python 来计算:</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6c4b" class="mw ll ja ms b gy mx my l mz na">box_1=['g','b']<br/>perm=[]<br/>for p in itertools.product(listA, repeat=2):<br/>     perm.append(p)<br/><br/>perm<br/><br/>Output:<br/>[('g', 'g'), ('g', 'b'), ('b', 'g'), ('b', 'b')]</span></pre><p id="338f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们用 3 个球来代替:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6f8a" class="mw ll ja ms b gy mx my l mz na">box_2 = ['g','b','y']<br/>perm=[]<br/>for p in itertools.product(box_2, repeat=3):<br/>     perm.append(p)<br/><br/>perm<br/>Output:<br/>[('g', 'g', 'g'),<br/> ('g', 'g', 'b'),<br/> ('g', 'g', 'y'),<br/> ('g', 'b', 'g'),<br/> ('g', 'b', 'b'),<br/> ('g', 'b', 'y'),<br/> ('g', 'y', 'g'),<br/> ('g', 'y', 'b'),<br/> ('g', 'y', 'y'),<br/> ('b', 'g', 'g'),<br/> ('b', 'g', 'b'),<br/> ('b', 'g', 'y'),<br/> ('b', 'b', 'g'),<br/> ('b', 'b', 'b'),<br/> ('b', 'b', 'y'),<br/> ('b', 'y', 'g'),<br/> ('b', 'y', 'b'),<br/> ('b', 'y', 'y'),<br/> ('y', 'g', 'g'),<br/> ('y', 'g', 'b'),<br/> ('y', 'g', 'y'),<br/> ('y', 'b', 'g'),<br/> ('y', 'b', 'b'),<br/> ('y', 'b', 'y'),<br/> ('y', 'y', 'g'),<br/> ('y', 'y', 'b'),<br/> ('y', 'y', 'y')]</span></pre><p id="ecb3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们的实验有 27 种可能的结果。如果我们想概括，当我们有 n 个对象，我们想看看我们可以用多少种方式排列它们，我们有:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/29ad35d5e2a77a0247a196d4ff7e1de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/0*5n2qYc8tt5UhIdEK"/></div></figure><ul class=""><li id="c9a6" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz jb">没有重复:</strong>在这种情况下，一旦你选择了一个球，它就不能再使用了。所以球的每种排列都有独特的值。在这种情况下，回到我们的 box={g，b}，两种可能的排列是“gb”和“bg”:</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="83ef" class="mw ll ja ms b gy mx my l mz na">import itertools <br/>  <br/>box_1 = ['g','b']<br/>perm = itertools.permutations(box_1) <br/>  <br/>for i in list(perm): <br/>    print(i)<br/><br/>Output:<br/>('g', 'b')<br/>('b', 'g')</span></pre><p id="cf44" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样，让我们考虑一个更大的盒子={g，b，y}，其中 y= '黄色球':</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0b68" class="mw ll ja ms b gy mx my l mz na">box_2 = ['g','b','y']<br/>perm = itertools.permutations(box_2) <br/><br/>for i in list(perm): <br/>    print(i)<br/><br/>Output:<br/><br/>('g', 'b', 'y')<br/>('g', 'y', 'b')<br/>('b', 'g', 'y')<br/>('b', 'y', 'g')<br/>('y', 'g', 'b')<br/>('y', 'b', 'g')</span></pre><p id="24d9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种情况下，我们必须考虑，在每次提取之后，可用元素的数量都要少一个。因此，如果我们的集合中有 n 个元素，排列将是:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/567355981acc9ddd7e1c7dfa24d97630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7G1_ts2lyvfLgKf2"/></div></div></figure><p id="cba6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了让您判断有重复和无重复排列之间的差异，让我们想象一下上面的例子。我们有一个盒子，里面有 4 个不同颜色的球:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b82656cd4f997ea5a8b4f89208c33107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/0*-E8SsG5DHBS16aMM"/></div></figure><p id="a182" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们想计算这些球可能排列的数量，这意味着:我可以用多少种方式排列这些球，每次从盒子里挑选一个球？</p><p id="c623" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果每次提取后都没有替换，那么在第一阶段，有 4 种方法可以设置第一个元素(黄色、绿色、橙色和蓝色):</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4d4a232be771f8d154f148e4a291d732.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/0*8T639vylvbJ9UufN"/></div></figure><p id="aa60" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们一个接一个地挑选其他的球，在每个阶段，我们排列剩余球的方式都在减少:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/be1d5aac6002d83029cf4558490d495c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BtCCu_uNe6Q521Tk"/></div></div></figure><p id="6509" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，最终，我们有 24 种可能的方法来排列这些对象，因为:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/15bab44d049075a4b35f6dcbad248f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FN852HR2y70fMmBR"/></div></div></figure><p id="181c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另一方面，如果在第二阶段(以及接下来的阶段),我们重新插入取出的球:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/d61096800ef5e2d93e981a4155f3374b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dDrEkuVYIE4I78fF"/></div></div></figure><p id="e9a4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">等于 256。</p><h1 id="cf7e" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">性情</h1><p id="e5be" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">部署只不过是排列，其中我们要挑选的对象的数量小于对象的总数 n。让我们简单地检索上面的示例，假设在三个球中，我们只想排列第一和第二个位置。让我们使用 box={g，b，y}并且让我们从重复的情况开始:</p><ul class=""><li id="bdaf" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz jb">重复</strong>:我们要从三个球(n=3)中选择两个球(k=2)，并计算可能排列的数量:</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="cdb7" class="mw ll ja ms b gy mx my l mz na">box_2 = ['g','b','y']<br/>perm=[]<br/>for p in itertools.product(box_2, repeat=2):<br/>     perm.append(p)<br/><br/>perm<br/><br/>Output:<br/>[('g', 'g'),<br/> ('g', 'b'),<br/> ('g', 'y'),<br/> ('b', 'g'),<br/> ('b', 'b'),<br/> ('b', 'y'),<br/> ('y', 'g'),<br/> ('y', 'b'),<br/> ('y', 'y')]</span></pre><p id="e03f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种情况下有 9 种可能的排列，而不是 27 种。与前一种情况一样，第一种选择有 n 种可能性，然后第二种选择又有 n 种可能性，以此类推，每次都相乘。但是这一次，这些将不是针对对象的总数(n)而是针对我们感兴趣的对象的数量(k)而被相乘。所以我们有:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f616d0ecd3a54a0770651b44cb540483.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*a_RlBC-tvyrHjniW"/></div></figure><ul class=""><li id="75f0" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz jb">没有重复</strong>:如果没有重复，同样的推理成立。事实上:</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="65f7" class="mw ll ja ms b gy mx my l mz na">box_2 = ['g','b','y']<br/>perm = itertools.permutations(box_2,2) <br/>  <br/>for i in list(perm): <br/>    print(i)<br/><br/>Output:<br/>('g', 'b')<br/>('g', 'y')<br/>('b', 'g')<br/>('b', 'y')<br/>('y', 'g')<br/>('y', 'b')</span></pre><p id="8f99" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种情况下，我们有:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nl"><img src="../Images/a464224b38d0369d6ca354d73a85ade9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dHLBNP9HoM4CCxCM"/></div></div></figure><p id="210c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">再一次，让我们想象一下，考虑一个有 4 个球的盒子，我们只需要安排其中的两个。对于重复的倾向，我们有:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/53a16cdb02514dd1da5210217effaf1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UTXjS5wqMQudahvP"/></div></div></figure><p id="bec8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">而对于没有重复的处置，我们有:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/aa2abbfbab93fa87bec03beeef98f0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3pkGw4K_4dhTmzL9"/></div></div></figure><h1 id="10f8" class="lk ll ja bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">组合</h1><p id="ec30" class="pw-post-body-paragraph jx jy ja jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">组合是排列(或置换，如果 k=n ),其中顺序无关紧要。基本上，每当我们想计算有多少种方法时，我们就使用组合，从 n 个对象中，我们可以提取其中的 k 个，<em class="kv">，不管这些对象被挑选的顺序如何</em>。</p><p id="1cbf" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">也就是说，如果你回忆起我们在最开始检查的没有重复的排列，其输出是“gb”和“bg”，等效的组合将只有“gb”(或只有“bg”)，因为顺序无关紧要，因此它们代表相同的对象。</p><p id="37c6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看 python，总是分别检查重复和不重复的两种情况:</p><ul class=""><li id="909a" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz jb">有重复:</strong></li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4f5f" class="mw ll ja ms b gy mx my l mz na">from itertools import combinations_with_replacement <br/><br/>box_1=['g','b']<br/>comb = combinations_with_replacement(box_1, 2) <br/>  <br/><br/>for i in list(comb): <br/>    print(i)<br/><br/>Output:<br/><br/>('g', 'g')<br/>('g', 'b')<br/>('b', 'b')</span></pre><p id="89a0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，第四种排列“bg”不在这些组合中，因为它等同于“gb”。</p><p id="6319" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这同样适用于 3 个球(让我们只组合其中的两个):</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8794" class="mw ll ja ms b gy mx my l mz na">from itertools import combinations_with_replacement <br/><br/>box_2=['g','b','y']<br/>comb = combinations_with_replacement(box_2, 2) <br/>  <br/><br/>for i in list(comb): <br/>    print(i)<br/><br/>Output:<br/><br/>('g', 'g')<br/>('g', 'b')<br/>('g', 'y')<br/>('b', 'b')<br/>('b', 'y')<br/>('y', 'y')</span></pre><ul class=""><li id="5b7c" class="kw kx ja jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated"><strong class="jz jb">无重复:</strong></li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ca08" class="mw ll ja ms b gy mx my l mz na">from itertools import combinations <br/><br/>comb = combinations(box_1, 2) <br/>   <br/>for i in list(comb): <br/>    print(i) <br/><br/>Output:<br/><br/>('g', 'b')</span></pre><p id="7d6d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有三个球:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ff56" class="mw ll ja ms b gy mx my l mz na">from itertools import combinations <br/><br/>comb = combinations(box_2, 2) <br/>   <br/>for i in list(comb): <br/>    print(i) <br/><br/>Output:<br/>('g', 'b')<br/>('g', 'y')<br/>('b', 'y')</span></pre><p id="a417" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">可能组合的数量(无重复)由下式给出:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nm"><img src="../Images/c2e1a690b17d3de73a2e2a2894f0984f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7O5QOf6ZO_hsg6W_"/></div></div></figure><p id="226b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是所谓的二项式系数，它被用在<a class="ae nn" rel="noopener" target="_blank" href="/understanding-bernoulli-and-binomial-distributions-a1eef4e0da8f">二项式概率分布</a>中，用来计算在 n 次试验中有多少种方法可以获得 k 次成功。另一方面，如果我们允许重复，二项式系数变成:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e000b84179e2ed3b64b2d252e0c39f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/0*xYpaT3dOTGtlZbTn"/></div></figure><p id="a0ed" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">再一次，让我们用我们的球盒想象它，重复:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/5fed2481b4188c4fa223a39e386fa8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e524fomUGMgzVRrn"/></div></div></figure><p id="5be7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">没有重复:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi np"><img src="../Images/1114879860879082f12020c38d27cc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*viOqFENAwLVfC9y9"/></div></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="5678" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">原载于 2019 年 9 月 7 日</em><a class="ae nn" href="https://datasciencechalktalk.com/2019/09/07/combinatorics-permutations-combinations-and-dispositions/" rel="noopener ugc nofollow" target="_blank"><em class="kv">http://datasciencechalktalk.com</em></a><em class="kv">。</em></p></div></div>    
</body>
</html>