<html>
<head>
<title>Introduction to Matrix Profiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">矩阵轮廓简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-matrix-profiles-5568f3375d90?source=collection_archive---------3-----------------------#2019-10-11">https://towardsdatascience.com/introduction-to-matrix-profiles-5568f3375d90?source=collection_archive---------3-----------------------#2019-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dfc6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种新的时间序列挖掘数据结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ea3a549a160bbf396f586074c38c1e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqSughjd85a6_x7-xg0_Yg.png"/></div></div></figure><p id="43fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在时间序列分析中，人们通常对两件事感兴趣；异常和趋势。例如，医生检查 EKG(心电图——心跳读数),看是否有异常事件表明患者存在风险。在零售业工作的个人需要了解销售什么商品以及何时销售(季节性)以增加利润。发现时间序列中异常和趋势的一种方法是执行<strong class="kt ir">相似性连接</strong>。本质上，您可以通过计算每对片段之间的距离来比较时间序列的片段。虽然使用嵌套循环实现一个简单的算法只需很少的努力，但使用这种方法可能需要几个月或几年的时间才能得到中等大小的时间序列的答案。利用矩阵轮廓算法大大减少了计算时间。</p><p id="a5a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Matrix Profile 是一种相对较新的数据结构，于 2016 年推出，由加州大学河滨分校的<a class="ae ln" href="https://www.cs.ucr.edu/~eamonn/" rel="noopener ugc nofollow" target="_blank">埃蒙·基奥</a>和新墨西哥大学的<a class="ae ln" href="https://www.cs.unm.edu/~mueen/" rel="noopener ugc nofollow" target="_blank">阿卜杜拉·穆恩</a>开发。使用矩阵轮廓的一些优点是它是领域不可知的、快速的、提供精确的解决方案(当需要时是近似的)并且只需要单个参数。</p><p id="55f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文的主要目标是让您熟悉这些好处，以便您可以利用它们。由于矩阵轮廓主要是可视化的，所以我们在本文中利用这一点，尽可能避开数学符号，而将重点放在可视化上。如果你想要学术描述，请阅读基奥博士网页上的研究出版物。</p><p id="86e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇介绍性文章将涵盖以下内容:</p><ul class=""><li id="6211" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">矩阵轮廓由什么组成？</li><li id="f32f" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">什么是不和？</li><li id="8a69" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">什么是主题？</li><li id="1513" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">哪些算法用于计算矩阵轮廓？</li><li id="8e0b" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">这些算法有什么区别？</li><li id="1fcf" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">从哪里可以得到这些算法？</li><li id="117c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">一个简短但实用的不和谐发现的例子。</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="b002" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">矩阵简介概述</h1><p id="d890" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">矩阵轮廓有两个主要组成部分；一个<strong class="kt ir">距离轮廓</strong>和<strong class="kt ir">轮廓索引</strong>。距离轮廓是最小 Z 归一化欧几里德距离<strong class="kt ir">的矢量</strong>。轮廓索引包含其第一个最近邻<strong class="kt ir">的索引。换句话说，它是其最相似的子序列的位置。</strong></p><p id="c681" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">计算矩阵轮廓的算法使用<strong class="kt ir">滑动窗口</strong>方法。窗口大小为<strong class="kt ir"> m </strong>，算法:</p><ol class=""><li id="2a14" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm ng lu lv lw bi translated">计算加窗子序列相对于整个时间序列的距离</li><li id="8766" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">设置一个排除区域以忽略无关紧要的匹配</li><li id="95e1" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">用最小值更新距离轮廓</li><li id="2cc5" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">设置第一个最近邻索引</li></ol><p id="fba5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面概述的距离计算发生<strong class="kt ir"> n-m + 1 </strong>次；其中<strong class="kt ir"> n </strong>是时间序列的长度，而<strong class="kt ir"> m </strong>是窗口大小。由于子序列是从时间序列本身中提取的，因此需要一个<strong class="kt ir">排除区</strong>来防止<strong class="kt ir">的琐碎匹配</strong>。例如，匹配自身的代码片段或非常接近自身的代码片段被认为是微不足道的匹配。在当前窗口索引之前和之后，禁止区仅仅是窗口大小的一半(<strong class="kt ir"> m </strong>)。计算最小距离和最近邻索引时，这些索引处的值将被忽略。显示从第二个窗口开始的距离轮廓计算的可视化如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ef914c0148915722dafdf2296a2606ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/1*E1jkPS6DbqgoR-1tpr3lyA.gif"/></div></figure><p id="70e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个值窗口，从 X2 到 X5，在时间序列上滑动，计算每个子序列的点积。计算完所有的点积后，将排除区域应用于距离，最小距离存储在矩阵配置文件中。扔掉多余的距离，只保留最小距离，将空间复杂度降低到 0(n)。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="3d0e" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">主题和主题</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/47cef07cf4851c1251bbde587a701ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yctMOFsiE5tYfgr_owkgDw.png"/></div></div></figure><p id="3a6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单地说，<strong class="kt ir">母题是时间序列中的重复模式</strong>，而<strong class="kt ir">不一致是异常</strong>。计算出矩阵的轮廓后，很容易找到前 K 个基序或不一致。矩阵轮廓在欧几里德空间中存储距离，这意味着接近 0 的距离最类似于时间序列中的另一个子序列，而远离 0 的距离，比如 100，不像任何其他子序列。提取最小的距离给出了主题，最大的距离给出了主题。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="8b33" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">矩阵轮廓算法</h1><p id="a4fe" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">有一些算法可以计算矩阵轮廓。下表提供了算法的非穷举列表和关于它们的简短描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4b3fa5ef5e0f6f650a28059ad4cb7903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*nhN2_ATxEgWke2z89gElHA.png"/></div></figure><p id="f7d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的图说明了使用 STAMP、STOMP 或 SCRIMP++比简单的方法有明显的优势。时间序列长度为 1，024，窗口大小为 32，naive 算法需要 50 多秒才能完成！另一方面，其他算法只需几分之一秒就能完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d64de27c4fa7d2b5311aed161ab1a254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*AFTX0t5fozW-0jwftXUzfw.png"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c279" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">矩阵轮廓挖掘算法</h1><p id="850d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">一旦计算出矩阵轮廓，就必须使用额外的算法来从中提取信息。在讨论主题和不一致时，我简单地提到了这一点。以下是在矩阵配置文件上运行的算法的非详尽列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7f11be7ee6c4eeb5ce6e22c779fc3f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*pDpWQG3zm5mJoOFKrcE7dg.png"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="5b29" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">例子</h1><p id="848b" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">对于我们的实际示例，我们将检查 2018 年的“纽约市黄色出租车乘客数量”。纽约市公开了许多数据集，以便每个人都可以探索它们。原始数据集带有许多其他属性，并且每分钟都提供详细信息。我汇总并整理了数据，以获得每小时的乘客数量。为了使这个例子简短，我就不详细介绍数据是如何聚合的了。我也避免在整个例子中展示代码。对于那些感兴趣的人，本文有一个<a class="ae ln" href="https://github.com/matrix-profile-foundation/article-matrix-profile-intro" rel="noopener ugc nofollow" target="_blank">公共代码库。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/dac2cfc2782335a613023d1221f9358e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PocJc7uz0aSJ8_YlUCFyyg.png"/></div></div></figure><p id="0f91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面显示的原始数据为我们正在处理的问题提供了一些背景信息。您可能已经在数据中直观地看到了一些模式，但是想象一下，如果这是一年多的数据，或者我们查看每分钟的乘客数。如果没有某种类型的转换，很难直观地看到发生了什么。我们将计算不同窗口大小的矩阵轮廓，看看是否有什么有趣的东西突出出来。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/c14f61934fe9c24cf4d961fc3c370daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSoYhdstQi5nsH3rS40lBA.png"/></div></div></figure><p id="1a28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面使用的不同窗口大小说明了选择适当值的重要性。我不明白纽约出租车系统在 4、8 甚至 12 小时周期内的复杂细节。然而，我能够使用搜索引擎研究每天甚至每周的事件。由于在 24 小时和 7 天的窗口内有一些明显的不一致(图中的峰值),我们将把重点放在那些矩阵曲线上。为了提取不一致，我们使用“前 K 个不一致”算法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/d026272ee7cfd35f590ac5859b8b4ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaMCIOianRp2VlhQDIZgRg.png"/></div></div></figure><p id="9175" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的图用红色显示了前 5 个不一致。我花了一些时间研究这些可能与什么有关，并在情节中对它们进行了注释。对于每日矩阵配置文件，夏令时似乎对乘客数量有巨大影响。在夏令时，我们在凌晨 2 点左右各慢一个小时。乘客计数受到重复计数的影响，或者计数的乘客非常少。例如，在夏令时开始，我们失去了凌晨 2 点，但一些系统仍然设法在这个时候计数乘客。在这个特定的数据集中，仍然计算了 3 名乘客。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e5d5eb6a9e43d049fe5c36d9ca8d3001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWvv2W19VEyaX4HWLQT0Bg.png"/></div></div></figure><p id="380f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用 7 天矩阵图来观察时间序列，我们会得到稍微不同的结果。独立日和圣诞节在 7 天内有不同的波动。这并不罕见，因为大多数人在独立日会花时间在户外，在圣诞节会和家人在一起。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c0ce" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">收尾工作</h1><p id="7ed4" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">在本文中，向您介绍了 Matrix Profile 以及如何使用它来分析时间序列数据。这是一种鲜为人知的方法，因为它仍然是新的，但它是一种快速和领域不可知的方法。一旦你有了矩阵的轮廓，提取共同的模式(图案)和异常(不一致)是很容易的。在我们简短的纽约出租车例子中，我通过可视化说明了异常提取。</p><p id="0f8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住，我只介绍了矩阵概要文件和一些概念。它提供了更多的功能。流数据分析的增量模式、语义分段和片段发现是更多的功能。我强烈建议任何对 Matrix Profile 或时间序列分析感兴趣的人查看补充部分。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="90b0" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">承认</h1><p id="e60d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">感谢 Tawni Marrs、Andrew Van Benschoten、Francisco Bischoff 和 Jackson Green 花时间阅读本文。最重要的是，我要感谢埃蒙·基奥、阿卜杜拉·穆恩和他们的合作者。没有他们的研究努力，这篇文章就不会存在。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="20c2" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">补充的</h1><ol class=""><li id="4801" class="lo lp iq kt b ku nb kx nc la nq le nr li ns lm ng lu lv lw bi translated">本文的源代码:</li></ol><p id="eb13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/matrix-profile-foundation/article-matrix-profile-intro" rel="noopener ugc nofollow" target="_blank">https://github . com/matrix-profile-foundation/article-matrix-profile-intro</a></p><p id="3461" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.关于矩阵简介的研究论文在埃蒙·基奥的网页上:</p><p id="3b49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【https://www.cs.ucr.edu/~eamonn/MatrixProfile.html T2】号</p><p id="97bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.一个志愿者组织，矩阵档案基金会，链接可以在这里找到:</p><p id="4f00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【https://matrixprofile.org/ T4】</p><p id="c739" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.矩阵轮廓算法的 Python 实现可在此处找到:</p><p id="bba7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/matrix-profile-foundation/matrixprofile" rel="noopener ugc nofollow" target="_blank">https://github.com/matrix-profile-foundation/matrixprofile</a></p><p id="ad07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.矩阵分析算法其余实现可在此处找到:</p><p id="9184" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/franzbischoff/tsmp" rel="noopener ugc nofollow" target="_blank">https://github.com/franzbischoff/tsmp</a></p><p id="0108" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6.矩阵轮廓算法的 Golang 实现可在此处找到:</p><p id="eed2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/matrix-profile-foundation/go-matrixprofile" rel="noopener ugc nofollow" target="_blank">https://github . com/matrix-profile-foundation/go-matrix profile</a></p></div></div>    
</body>
</html>