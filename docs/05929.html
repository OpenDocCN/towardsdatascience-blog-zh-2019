<html>
<head>
<title>Deep Learning using Transfer Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用迁移学习的深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-using-transfer-learning-cfbce1578659?source=collection_archive---------11-----------------------#2019-08-29">https://towardsdatascience.com/deep-learning-using-transfer-learning-cfbce1578659?source=collection_archive---------11-----------------------#2019-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2068" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">在本系列文章中，我们将探讨什么是迁移学习，迁移学习的目的是什么。了解实施迁移学习的不同策略。在下一篇文章中，我们将使用 ResNet50 编写代码来应用迁移学习。</em>T3】</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c1176349fa8944dd4cc43aaf583c933f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3co-5_R_zHek1Us9OTeCA.png"/></div></div></figure><p id="bc59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你知道如何划船，如何游泳，那么我们可以学习水上漂流吗？</p><p id="b9e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你已经学会了基础知识，那么你只需要学习水上漂流的具体知识，划船和游泳的基本概念是你知识基础的一部分。</p><p id="e06a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">我们能否将这种技术应用于机器学习和深度学习？</em> </strong></p><p id="b5f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi lb translated">但是我们每次都会创建一个新的卷积神经网络(CNN)来识别不同类别的对象。我们有一个 CNN 来识别像狗和猫这样的动物。我们将有一个不同的 CNN 用于识别数字，另一个用于识别服装对象。</p><p id="79b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">关于机器学习和深度学习的常见假设</em> </strong></p><p id="57e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果训练和测试数据来自相同的特征空间和相同的分布，我们可以重用已经建立的模型，但是当分布改变时，我们需要从头开始重建模型。这就需要我们收集新的训练数据。</p><p id="0c45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重新收集所需的训练数据和重建模型是昂贵的。如果我们减少重新收集训练数据的需要和努力，并且可以使用知识转移或任务域之间的转移学习，会怎么样？</p><p id="e9d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">如果我们有一个 CNN，可以用来学习图像的基本知识，如角、形状、光照，然后稍微调整一下，学习其他类别图像的细节，会怎么样？</em> </strong></p><blockquote class="lk"><p id="eda1" class="ll lm it bd ln lo lp lq lr ls lt kn dk translated">欢迎转学习！</p></blockquote><p id="0e40" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated"><strong class="js iu"> <em class="ko">迁移学习的目的是什么？</em> </strong></p><blockquote class="lk"><p id="5c70" class="ll lm it bd ln lo lp lq lr ls lt kn dk translated">迁移学习的目的是利用第一个设置中的数据，提取在第二个设置中学习甚至直接进行预测时可能有用的信息</p></blockquote><p id="c285" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">- <strong class="js iu"> <em class="ko">深度学习作者伊恩·古德菲勒、约舒阿·本吉奥和亚伦·库维尔</em> </strong></p><h1 id="6b39" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak"> <em class="mx">迁移学习的动机</em> </strong></h1><p id="8718" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">机器学习模型传统上是在这样的假设下开发的，即如果训练和测试数据来自相同的特征空间和相同的分布，则模型将工作良好。</p><p id="abec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果特征空间或数据分布发生变化，那么我们就需要建立一个新的模型。每次从头开始开发一个新模型以及每次收集一组新的训练数据都是非常昂贵的。迁移学习减少了回忆大量训练数据的需要和努力。</p><p id="de22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于机器学习和深度学习的迁移学习的动机是基于这样一个事实，即人们可以智能地将以前学到的知识应用于不同的任务或领域，这些任务或领域可以用来更快地解决新问题或提供更好的解决方案。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nd"><img src="../Images/10ad4f247d5a4b9a1764d911ee2a6a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejesu5Rg6yvOQ3ldV1HiBw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk">Source:<a class="ae ni" href="https://www.cse.ust.hk/~qyang/Docs/2009/tkde_transfer_learning.pdf" rel="noopener ugc nofollow" target="_blank"> A Survey on Transfer Learning</a></figcaption></figure><p id="f23e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">迁移学习有哪些重点考虑？</em> </strong></p><p id="df79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了有效地应用迁移学习，我们需要回答三个主要问题</p><ol class=""><li id="01bd" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn no np nq nr bi translated">转什么</li><li id="878a" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">什么时候转移</li><li id="cfc3" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">怎么转</li></ol><ul class=""><li id="806b" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn nx np nq nr bi translated"><strong class="js iu">转移什么</strong> —我们需要了解源任务和目标任务之间有哪些知识是共同的。哪些知识可以从源任务转移到目标任务，从而有助于提高目标任务的绩效</li><li id="20bd" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><strong class="js iu">何时迁移或何时不迁移- </strong>当源域和目标域完全不相关时，我们不应该尝试应用迁移学习。在这种情况下，性能会受到影响。这种迁移称为<strong class="js iu">负迁移。只有当源域和目标域/任务相关时，我们才应该应用迁移学习</strong></li><li id="b92e" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><strong class="js iu">如何迁移:</strong>当源和目标领域/任务相关时，识别不同的技术来应用迁移学习。我们可以使用归纳迁移学习、直推迁移学习或无监督迁移学习。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ny"><img src="../Images/694ecfa01d0244b789232e845ac87db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxnkmfsyD26SrW2gEYpWlw.png"/></div></div></figure><p id="2cba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">这些不同类型的迁移学习是什么？</em> </strong></p><h1 id="ae55" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">不同类型的迁移学习</h1><blockquote class="nz oa ob"><p id="112e" class="jq jr ko js b jt ju jv jw jx jy jz ka oc kc kd ke od kg kh ki oe kk kl km kn im bi translated"><strong class="js iu">归纳迁移学习- </strong> S <strong class="js iu">源域和目标域相同但任务不同</strong></p></blockquote><p id="3192" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想让孩子识别水果，那么我们就开始展示不同颜色的苹果，像红苹果、绿苹果、淡黄色苹果等等。我们给孩子看不同种类的苹果，如嘎拉、澳洲青苹、富士苹果等。我们在不同的环境中展示这些苹果，这样孩子在大多数情况下都能识别苹果。同样的逻辑也用于识别不同的水果，如葡萄、橘子、芒果等。这里我们把在学习苹果中获得的知识应用到学习识别其他水果中。我们的源域和目标域与水果的识别相关，但是一个任务涉及识别苹果，一个任务涉及识别芒果。</p><ul class=""><li id="91c3" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn nx np nq nr bi translated"><strong class="js iu">归纳迁移学习的目标是提高目标预测函数的性能。</strong></li><li id="e6a6" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><strong class="js iu">归纳迁移学习需要目标域中的少量标记数据作为训练数据来归纳目标预测函数</strong></li><li id="8f4c" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><strong class="js iu">如果源域和目标域都有标记数据，那么我们可以执行多任务迁移学习</strong></li><li id="fc64" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><strong class="js iu">如果源有标记数据，而目标任务没有标记数据，那么我们可以进行自学习迁移学习</strong></li></ul><blockquote class="nz oa ob"><p id="fb90" class="jq jr ko js b jt ju jv jw jx jy jz ka oc kc kd ke od kg kh ki oe kk kl km kn im bi translated"><strong class="js iu">直推式迁移学习——不同领域但相似任务的迁移学习</strong></p></blockquote><p id="68dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们推断这一学习，现在我们想让孩子学习像椅子、桌子、床等家用物品。孩子将利用所学的水果识别知识来识别家用物品。</p><p id="5aa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">孩子可能没有看到足够多的家庭用品，但会使用形状、颜色等知识。学会鉴别水果来鉴别家居物品。</p><p id="7508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">直推式迁移学习，目标域没有标记数据，而源域有大量标记数据</strong></p><p id="d164" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">直推式迁移学习适用于以下情况</p><ul class=""><li id="cad5" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn nx np nq nr bi translated">源域和目标域之间的特征空间可以不同</li><li id="82da" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">域之间的特征空间相同，但输入数据的边际概率分布不同。这也被称为域适应。</li></ul><blockquote class="nz oa ob"><p id="266a" class="jq jr ko js b jt ju jv jw jx jy jz ka oc kc kd ke od kg kh ki oe kk kl km kn im bi translated"><strong class="js iu">无监督迁移学习</strong></p></blockquote><p id="f766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无监督迁移学习类似于归纳迁移学习，其中目标任务不同于但与源任务相关。源任务和目标任务的域是相同的。我们没有源-目标任务的标记数据</p><p id="8ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它侧重于解决目标领域中的无监督学习任务，如聚类或维度缩减</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi of"><img src="../Images/dfdce1af427f2101e130ea8097e97348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jd5C3tpx12mMGFI-9YsnRg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk">Source :<a class="ae ni" href="https://www.cse.ust.hk/~qyang/Docs/2009/tkde_transfer_learning.pdf" rel="noopener ugc nofollow" target="_blank"> A Survey on Transfer Learning</a></figcaption></figure><p id="0b11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">我能把这些迁移学习策略应用到深度学习中吗？</em>T11】</strong></p><p id="0bd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与计算机视觉或顺序文本处理或音频处理等机器学习相比，深度学习需要大量的训练数据和训练时间。我们可以保存我们训练好的模型的权重，并分享给其他人使用。我们现在也有预训练模型，广泛用于迁移学习，称为<strong class="js iu">深度迁移学习。</strong></p><p id="baa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">深度迁移学习的常用策略</strong></p><ul class=""><li id="ed39" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn nx np nq nr bi translated"><strong class="js iu">使用预训练的模型作为特征提取器</strong></li><li id="8bfc" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><strong class="js iu">微调预训练模型</strong></li></ul><p id="9749" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于计算机视觉的预训练深度神经网络</p><ul class=""><li id="c5c2" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn nx np nq nr bi translated">VGG-16 号</li><li id="842b" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><a class="ae ni" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank"> VGG-19 </a></li><li id="f9a2" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><a class="ae ni" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank">盗梦空间 V3 </a></li><li id="a783" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><a class="ae ni" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank"> ResNet-50 </a></li><li id="2355" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><a class="ae ni" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank">异常</a></li></ul><p id="2881" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于自然语言处理任务的预训练深度神经网络</p><ul class=""><li id="58f0" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn nx np nq nr bi translated"><a class="ae ni" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">手套</a></li><li id="8ed6" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><a class="ae ni" href="https://www.tensorflow.org/tutorials/representation/word2vec" rel="noopener ugc nofollow" target="_blank"> Word2Vec </a>，</li><li id="f7e4" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated"><a class="ae ni" href="https://fasttext.cc/" rel="noopener ugc nofollow" target="_blank">快速正文</a></li><li id="41b8" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">伯特</li></ul><p id="d9b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">预训练模型可用于预测、特征提取和微调</p><p id="2750" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来了解一下这些策略的细节</p><h2 id="b00d" class="og ma it bd mb oh oi dn mf oj ok dp mj kb ol om mn kf on oo mr kj op oq mv or bi translated"><strong class="ak">使用预训练的模型作为特征提取器</strong></h2><ul class=""><li id="f1ee" class="nj nk it js b jt my jx mz kb os kf ot kj ou kn nx np nq nr bi translated">为了实现迁移学习，我们删除了预训练模型的最后一个预测层，并用我们自己的预测层替换它们。FC-T1 和 FC_T2 如下所示</li><li id="4d03" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">这些预训练模型的权重被用作特征提取器</li><li id="f72c" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">预训练模型的权重被冻结，并且在训练期间不被更新</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/00056c7e7d83b77d37d70f6fb31b998e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*1rUm4OpT_HXl6-HFCW9fUw.png"/></div></figure><h2 id="7b23" class="og ma it bd mb oh oi dn mf oj ok dp mj kb ol om mn kf on oo mr kj op oq mv or bi translated"><strong class="ak">微调预训练模型</strong></h2><ul class=""><li id="f01b" class="nj nk it js b jt my jx mz kb os kf ot kj ou kn nx np nq nr bi translated">我们可以使用像 VGG-16，VGG-19，Inception V3，ResNet-50，Xception 这样的深度神经网络作为预训练模型</li><li id="dd6f" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">为了实现带有微调的迁移学习，我们删除了预训练模型的最后一个预测层，并用我们自己的预测层来替换它们。FC-T1 和 FC_T2 如下所示。</li><li id="eb8e" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">网络的初始较低层从预先训练的模型中学习非常一般的特征。为了实现这一点，预训练模型的初始层权重被冻结，并且在训练期间不被更新</li><li id="d250" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">较高层用于学习特定任务的特征。预训练模型的更高层是可训练的或可微调的</li><li id="3f5d" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn nx np nq nr bi translated">用更少的培训时间提高绩效</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ow"><img src="../Images/08cd10a4e275683a16f39035500a62da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*furTQNGfh9pDeW97_WBOHA.png"/></div></div></figure><p id="5119" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在下一篇文章中看到使用<a class="ae ni" href="https://github.com/keras-team/keras-applications/blob/master/keras_applications/resnet50.py" rel="noopener ugc nofollow" target="_blank"> ResNet50 </a>的代码实现。ResNet 是<a class="ae ni" href="https://arxiv.org/pdf/1512.03385.pdf" rel="noopener ugc nofollow" target="_blank">残网</a>的简称。这是一个 50 层的残余网络。</p><h2 id="9d61" class="og ma it bd mb oh oi dn mf oj ok dp mj kb ol om mn kf on oo mr kj op oq mv or bi translated">参考资料:</h2><p id="cca9" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">关于迁移学习的调查</p><p id="3dc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ni" rel="noopener" target="_blank" href="/a-comprehensive-hands-on-guide-to-transfer-learning-with-real-world-applications-in-deep-learning-212bf3b2f27a">全面的实践指南，帮助您将学习转化为深度学习中的实际应用</a></p><p id="4a11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ni" href="https://github.com/dipanjanS/hands-on-transfer-learning-with-python/blob/master/notebooks/Ch05%20-%20Unleash%20the%20Power%20of%20Transfer%20Learning/CNN%20with%20Transfer%20Learning.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub 用 Python 进行迁移学习</a></p></div></div>    
</body>
</html>