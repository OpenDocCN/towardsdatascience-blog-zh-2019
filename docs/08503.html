<html>
<head>
<title>Using Spark to Predict Churn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Spark 预测客户流失</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-spark-to-predict-churn-c69e675272bf?source=collection_archive---------30-----------------------#2019-11-17">https://towardsdatascience.com/using-spark-to-predict-churn-c69e675272bf?source=collection_archive---------30-----------------------#2019-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6b1d0cec16ebac37a3bbdbabea12c909.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*2p4Uv2j3ecmV3RBT1ryUUw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Image by author</figcaption></figure><p id="59e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在面向客户的业务中，预测客户流失是一个具有挑战性且常见的问题。由于预测通常是根据大量的用户活动日志做出的，我们需要一种分布式的方法来有效地处理大型数据集，而不必一次将它放入我们的内存中。</p><p id="5717" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该项目将探索如何使用 Spark 建立客户流失预测模型，包括以下步骤:</p><ul class=""><li id="3bf9" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">探索和操作我们的数据集</li><li id="548d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">为我们的问题设计相关功能</li><li id="01a6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">通过抽样流失将数据分为训练集和测试集</li><li id="d196" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使用<a class="ae lk" href="https://spark.apache.org/docs/latest/ml-guide.html" rel="noopener ugc nofollow" target="_blank"> Spark 的基于数据帧的 MLlib </a>构建二进制分类器模型</li><li id="69ce" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使用<a class="ae lk" href="https://spark.apache.org/docs/latest/ml-pipeline.html" rel="noopener ugc nofollow" target="_blank"> Spark 的 ML 管道</a>和<a class="ae lk" href="https://github.com/interviewstreet/spark-stratifier" rel="noopener ugc nofollow" target="_blank">stratifiedcrossfvalidator</a>选择并微调最终模型</li></ul><h1 id="78e1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">关于数据集</h1><p id="8236" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们将使用名为 Sparkify 的音乐流媒体服务的用户事件日志(持续时间约为 2 个月)作为我们的数据集。通过这些日志，我们可以预测该用户是更有可能留下来还是更有可能流失。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mo"><img src="../Images/93e8c71a0b9c22cfb4649c339ac6c656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7taTKS3aC0ENv0cyFuds0Q.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">A log(row) will be appended whenever a user interacts with the service: play the next song, add a song to playlist, thumb up/down a song, etc.</figcaption></figure><p id="e385" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们仅使用一个数据子集(128MB)来训练我们的带有本地 Spark 的流失预测模型。为了使用完整数据集(12GB)进行模型训练，您可能需要在云服务上部署一个集群。</p><h1 id="06ca" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">加载和清理数据</h1><h2 id="f08b" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">加载数据</h2><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="1046" class="mx lm iq nk b gy no np l nq nr">user_log = spark.read.json('mini_sparkify_event_data.json')<br/>user_log.count()<br/># 286500<br/>user_log.printSchema()<br/># root<br/> |-- artist: string (nullable = true)<br/> |-- auth: string (nullable = true)<br/> |-- firstName: string (nullable = true)<br/> |-- gender: string (nullable = true)<br/> |-- itemInSession: long (nullable = true)<br/> |-- lastName: string (nullable = true)<br/> |-- length: double (nullable = true)<br/> |-- level: string (nullable = true)<br/> |-- location: string (nullable = true)<br/> |-- method: string (nullable = true)<br/> |-- page: string (nullable = true)<br/> |-- registration: long (nullable = true)<br/> |-- sessionId: long (nullable = true)<br/> |-- song: string (nullable = true)<br/> |-- status: long (nullable = true)<br/> |-- ts: long (nullable = true)<br/> |-- userAgent: string (nullable = true)<br/> |-- userId: string (nullable = true)</span></pre><h2 id="b54a" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">干净的数据</h2><p id="cd27" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在我们的数据集中检查缺失/null/空值之后，我们发现了一些事实:</p><ul class=""><li id="6a66" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">所有列中没有缺失(NaN)值。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ns"><img src="../Images/399d740e0e5d29ffeb4e9902d985351d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdEzuXmzMjL0tJd-yuQIEQ.png"/></div></div></figure><ul class=""><li id="b2f8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在与用户信息和歌曲信息相关的列中发现空值。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nt"><img src="../Images/860918ca30bd940a3d640534cb14e378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeORi97nnr6aaj_TrTfJNA.png"/></div></div></figure><ul class=""><li id="5943" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">不是<code class="fe nu nv nw nk b">NextSong</code>的页面的<code class="fe nu nv nw nk b">artist</code>、<code class="fe nu nv nw nk b">length</code>和<code class="fe nu nv nw nk b">song</code>将为空值。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/a29557f53ee4c0dfac8ee1f53fb7889b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMfcld02bVU6ypfMS_LI7g.png"/></div></div></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/0017ad2825f83f5f6ca49d6e7c400eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k53rqrgQkLrqqDlk1xOg3g.png"/></div></div></figure><ul class=""><li id="3662" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">仅在列<code class="fe nu nv nw nk b">userId</code>中发现空值。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nz"><img src="../Images/61639025047350bf2ac01b3518bda21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyKZyuhwEdcB7eVSLtJ1XQ.png"/></div></div></figure><ul class=""><li id="11e4" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">空<code class="fe nu nv nw nk b">userId</code>的用户是没有注册登录的用户。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/70c882e1872b191e97a7f969bffb114c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiWFuOR0x59lCGKiwsChSQ.png"/></div></div></figure><p id="de41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于空<code class="fe nu nv nw nk b">userId</code>的日志无法帮助我们识别后面的用户，所以我们无法对他们进行预测。所以我们把它们从分析中去掉了。</p><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="3ff6" class="mx lm iq nk b gy no np l nq nr"># drop rows with empty userId<br/>df = user_log.filter(F.col('userId')!='')<br/>df.count()<br/># 278154</span></pre><h1 id="8fab" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">探索性数据分析</h1><h2 id="e7b0" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">定义流失</h2><p id="5b22" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们将使用<code class="fe nu nv nw nk b">Cancellation Confirmation</code>事件来定义客户流失。搅动的用户将在列<code class="fe nu nv nw nk b">churn</code>中有一个<code class="fe nu nv nw nk b">1</code>，这是我们模型的标签列。</p><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="2df0" class="mx lm iq nk b gy no np l nq nr">flag_churn = F.udf(lambda x: 1 if x == 'Cancellation Confirmation' else 0, T.IntegerType())<br/>df = df.withColumn('churn', flag_churn('page'))</span></pre><h2 id="85fa" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">转换数据</h2><p id="6d33" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在这一步中，我们将把原始数据集(每个日志一行)转换成具有用户级信息或统计数据的数据集(每个用户一行)。在进行聚合之前，我们将首先执行以下步骤:</p><ol class=""><li id="f7d4" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv oa lc ld le bi translated">将时间戳(毫秒)转换为日期时间<br/><code class="fe nu nv nw nk b">ts</code>和<code class="fe nu nv nw nk b">registration</code>列是使用以毫秒为单位的时间戳记录的，非常难以读取，因此我们将它们转换为日期时间对象，并保存为两个新列:<code class="fe nu nv nw nk b">dt</code>和<code class="fe nu nv nw nk b">reg_dt</code>。</li><li id="724e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">推断每个用户的观察开始日期<br/> a .对于<code class="fe nu nv nw nk b">reg_dt</code> <em class="ob">比<code class="fe nu nv nw nk b">min_dt</code>(整个分析的开始日期)早</em>的用户:使用<code class="fe nu nv nw nk b">min_dt</code>作为<code class="fe nu nv nw nk b">obs_start</code>(观察开始日期)列的值；b*。对于<code class="fe nu nv nw nk b">reg_dt</code><code class="fe nu nv nw nk b">min_dt</code><em class="ob"/><code class="fe nu nv nw nk b">first_dt</code>(用户第一个日志的<code class="fe nu nv nw nk b">dt</code>)之间有<em class="ob">的用户:使用<code class="fe nu nv nw nk b">reg_dt</code>作为<code class="fe nu nv nw nk b">obs_start</code>列的值；<br/> c .对于<code class="fe nu nv nw nk b">reg_dt</code> <em class="ob">晚于<code class="fe nu nv nw nk b">first_dt</code></em>的用户:使用<code class="fe nu nv nw nk b">first_dt</code>作为<code class="fe nu nv nw nk b">obs_start</code>列的值。<br/>*奇怪的是注册日期在第一次登录日期之后，但有些用户(如 userId=154)会发生这种情况。</em></li><li id="5eb5" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">推断每个用户的观察结束日期<br/> a .对于流失用户，使用他们最后的日志<code class="fe nu nv nw nk b">dt</code>(他们流失的日期)作为列<code class="fe nu nv nw nk b">obs_end</code>(观察结束日期)的值；对于非流失用户，使用<code class="fe nu nv nw nk b">max_dt</code>(整个分析的结束日期)作为<code class="fe nu nv nw nk b">obs_end</code>栏的值。</li><li id="e431" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">获取每个用户的最后订阅级别<br/>将用户的最后订阅级别保存到新列<code class="fe nu nv nw nk b">last_level</code>。</li></ol><p id="9b3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们按用户聚合所有必需的列:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/349b9646f7705a51c72dd23d7e3f35a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ph7jzsc7q23ouHhxuO3JjA.png"/></div></div></figure><p id="cee9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在聚合之后，我们还提取了一些与事件相关的基于时长的特征。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi od"><img src="../Images/c1c5be7370aeb7d601facf02db276eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfG3QoVUTlOk_63gxwx7Yg.png"/></div></div></figure><p id="db8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加一些会话级特性。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/670154fe4ee843ca86e63d86e74f08d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXRawFQRE1jw23x5qn0Y7w.png"/></div></div></figure><p id="9208" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们只选择这些对于以后的探索和分析是必要的列。</p><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="dfdc" class="mx lm iq nk b gy no np l nq nr">root<br/> |-- userId: string (nullable = true)<br/> |-- churn: integer (nullable = true)<br/> |-- gender: string (nullable = true)<br/> |-- last_level: string (nullable = true)<br/> |-- sum_length: double (nullable = true)<br/> |-- n_session: long (nullable = false)<br/> |-- reg_days: integer (nullable = true)<br/> |-- obs_hours: double (nullable = true)<br/> |-- n_act_per_hour: double (nullable = true)<br/> |-- n_about_per_hour: double (nullable = true)<br/> |-- n_addFriend_per_hour: double (nullable = true)<br/> |-- n_addToPlaylist_per_hour: double (nullable = true)<br/> |-- n_cancel: long (nullable = true)<br/> |-- n_downgrade_per_hour: double (nullable = true)<br/> |-- n_error_per_hour: double (nullable = true)<br/> |-- n_help_per_hour: double (nullable = true)<br/> |-- n_home_per_hour: double (nullable = true)<br/> |-- n_logout_per_hour: double (nullable = true)<br/> |-- n_song_per_hour: double (nullable = true)<br/> |-- n_rollAdvert_per_hour: double (nullable = true)<br/> |-- n_saveSettings_per_hour: double (nullable = true)<br/> |-- n_settings_per_hour: double (nullable = true)<br/> |-- n_submitDowngrade_per_hour: double (nullable = true)<br/> |-- n_submitUpgrade_per_hour: double (nullable = true)<br/> |-- n_thumbsDown_per_hour: double (nullable = true)<br/> |-- n_thumbsUp_per_hour: double (nullable = true)<br/> |-- n_upgrade_per_hour: double (nullable = true)<br/> |-- avg_session_items: double (nullable = true)<br/> |-- avg_session_mins: double (nullable = true)<br/> |-- avg_session_songs: double (nullable = true)</span></pre><h2 id="398d" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">浏览数据</h2><p id="88ff" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在这里，我们将重点比较留下来的用户和离开的用户之间的行为。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/515e5db152069caa1cf5f762530c84ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0NTQ9Rpxh_i3exttvV5u-w.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Distribution of Churn</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi og"><img src="../Images/d1cdadc1c3b2e5413ed660568a51a447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3NPFqi8W5169PB2S4lGE0g.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Distributions of Categorical Features</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oh"><img src="../Images/de492b7ec5fc45b09a5981af8e51f28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZB4ouerVa1iPLeh2K_x0GQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Correlations among Numerical Features</figcaption></figure><p id="53e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据上述相关性，我们发现这些高度相关(&gt; 0.8)的变量对(组):</p><ul class=""><li id="dbe2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">流失，obs_hours，n_cancel</li><li id="df92" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">总和 _ 长度，n _ 会话</li><li id="d697" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">平均会话项目数，平均会话分钟数，平均会话歌曲数</li><li id="2fb6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">n_act_per_hour，n_addFriend_per_hour，n_addToPlaylist_per_hour，n_downgrade_per_hour，<br/> n_help_per_hour，n_home_per_hour，n_song_per_hour，n_thumbsUp_per_hour</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oi"><img src="../Images/9724d432bdd400e0ac404d528f8c132b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQINrEVnKCNxhabDVoI4qA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Correlations among ‘n_help_per_hour’ Numerical Features</figcaption></figure><p id="ae0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">删除高度相关的列后，相关性看起来好得多。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oh"><img src="../Images/3b73ca003a74f2f2392019c0b75ebb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3VNR6CVmvVhthbc2JIQEA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Correlations between Numerical Features (after removing highly correlated columns)</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi og"><img src="../Images/848d04ace1485ed323ede599c0d3041c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HltFD_3sSEuXApZwOjmPWw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Distributions of Numerical Features</figcaption></figure><h1 id="b2b2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">特征工程</h1><p id="5de4" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在我们总共有 16 个特性(不包括<code class="fe nu nv nw nk b">userId</code>和<code class="fe nu nv nw nk b">label(churn)</code>列)。</p><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="77ae" class="mx lm iq nk b gy no np l nq nr">root<br/> |-- userId: string (nullable = true)<br/> |-- label: integer (nullable = true)<br/> |-- gender: string (nullable = true)<br/> |-- last_level: string (nullable = true)<br/> |-- n_session: long (nullable = false)<br/> |-- reg_days: integer (nullable = true)<br/> |-- n_about_per_hour: double (nullable = true)<br/> |-- n_error_per_hour: double (nullable = true)<br/> |-- n_logout_per_hour: double (nullable = true)<br/> |-- n_song_per_hour: double (nullable = true)<br/> |-- n_rollAdvert_per_hour: double (nullable = true)<br/> |-- n_saveSettings_per_hour: double (nullable = true)<br/> |-- n_settings_per_hour: double (nullable = true)<br/> |-- n_submitDowngrade_per_hour: double (nullable = true)<br/> |-- n_submitUpgrade_per_hour: double (nullable = true)<br/> |-- n_thumbsDown_per_hour: double (nullable = true)<br/> |-- n_upgrade_per_hour: double (nullable = true)<br/> |-- avg_session_items: double (nullable = true)</span></pre><p id="c1c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在特征工程的正常情况下，在将它们输入到我们的模型之前，我们必须将它们编码、缩放和组合成一个特征向量。但是由于我们这次使用 pipeline 来构建模型，而不是现在就处理它们，我们只是将它们准备为一些数据处理阶段。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oj"><img src="../Images/b4f4a5c5ffcb11160249a051f0f15b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9HmIFESv0O7f4v5CtTaSA.png"/></div></div></figure><h1 id="629e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">建模</h1><h2 id="9071" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">将数据分成训练集和测试集</h2><p id="08b0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">从上一节展示的流失分布来看，我们知道这是一个不平衡的数据集，只有 1/4 的用户被标记为流失。为了避免随机分裂中的不平衡结果，我们首先用标签抽样建立一个训练集，然后从整个数据集中减去它们得到测试集。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ok"><img src="../Images/10108e2e6137d736fefabb8dd582b643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*875nf1kymLAlvBVFQvO40g.png"/></div></div></figure><h2 id="57f7" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">型号选择</h2><p id="e023" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了选择一个好的模型进行最终调整，我们在<a class="ae lk" href="https://spark.apache.org/docs/latest/ml-guide.html" rel="noopener ugc nofollow" target="_blank"> Spark 的 MLlib </a>中比较了三个不同的分类器模型。</p><ul class=""><li id="47dd" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">因为 Spark 提供的评估器不太适合我们的使用，所以我们定制了一个评估方法，以便在测试原型时查看分数。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ol"><img src="../Images/c63746606d820648d3491e89386af425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8foFt5ngIlqDFqpW40jgA.png"/></div></div></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi om"><img src="../Images/00a736e48731e247c9077a02bd1f7c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8_0jqiJ1KSWOl0hE26LwQ.png"/></div></div></figure><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="f539" class="mx lm iq nk b gy no np l nq nr">&lt;class 'pyspark.ml.classification.LogisticRegression'&gt;<br/>train time: 30s<br/>----------pred_train----------<br/>f1-score:0.88<br/>precision:0.91<br/>recall:0.84<br/>accuracy:0.94<br/>confusion matrix:<br/>TP:32.0	 | FP:3.0<br/>FN:6.0	 | TN:122.0<br/>----------pred_test----------<br/>f1-score:0.75<br/>precision:0.90<br/>recall:0.64<br/>accuracy:0.90<br/>confusion matrix:<br/>TP:9.0	 | FP:1.0<br/>FN:5.0	 | TN:47.0<br/><br/> &lt;class 'pyspark.ml.classification.DecisionTreeClassifier'&gt;<br/>train time: 23s<br/>----------pred_train----------<br/>f1-score:0.93<br/>precision:1.00<br/>recall:0.87<br/>accuracy:0.97<br/>confusion matrix:<br/>TP:33.0	 | FP:0.0<br/>FN:5.0	 | TN:125.0<br/>----------pred_test----------<br/>f1-score:0.62<br/>precision:0.60<br/>recall:0.64<br/>accuracy:0.82<br/>confusion matrix:<br/>TP:9.0	 | FP:6.0<br/>FN:5.0	 | TN:42.0<br/><br/> &lt;class 'pyspark.ml.classification.RandomForestClassifier'&gt;<br/>train time: 27s<br/>----------pred_train----------<br/>f1-score:0.88<br/>precision:1.00<br/>recall:0.79<br/>accuracy:0.95<br/>confusion matrix:<br/>TP:30.0	 | FP:0.0<br/>FN:8.0	 | TN:125.0<br/>----------pred_test----------<br/>f1-score:0.64<br/>precision:0.64<br/>recall:0.64<br/>accuracy:0.84<br/>confusion matrix:<br/>TP:9.0	 | FP:5.0<br/>FN:5.0	 | TN:43.0</span></pre><p id="7090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于测试集的 f1 分数，我们决定使用<code class="fe nu nv nw nk b">LogisticRegression</code>进行最终调整。</p><h2 id="f342" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">分层交叉验证的模型调整</h2><p id="aba8" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">由于被搅动的用户是一个相当小的子集，我们将使用 f1 分数作为优化的主要指标。如上所述，Spark 的评估器不太适合我们的使用，所以我们需要构建一个<code class="fe nu nv nw nk b">FbetaScore</code>评估器类来使用交叉验证器。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi on"><img src="../Images/17181936bee2cf988a8d86e33dfc5ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzKTWahhwUszRlnw6GVpgg.png"/></div></div></figure><p id="9b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为 PySpark 的<code class="fe nu nv nw nk b"><a class="ae lk" href="https://spark.apache.org/docs/latest/api/python/pyspark.ml.html#pyspark.ml.tuning.CrossValidator" rel="noopener ugc nofollow" target="_blank">CrossValidator</a></code>目前只支持简单的 K-fold CV，我们将使用 pip 库<code class="fe nu nv nw nk b"><a class="ae lk" href="https://github.com/interviewstreet/spark-stratifier" rel="noopener ugc nofollow" target="_blank">spark-stratifier</a></code>为不平衡数据集执行分层 K-fold CV。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oo"><img src="../Images/03aebab5561f68d118b1f29c1f1aeb72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3NQ2TbJNT3trV0pGSk7DA.png"/></div></div></figure><p id="c640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nu nv nw nk b">explainParams()</code>中<code class="fe nu nv nw nk b">maxIter</code>参数的解释:</p><ul class=""><li id="d786" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">maxIter:最大迭代次数(&gt; = 0)。(默认值:100)</li></ul><p id="519b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们发动引擎！我们的目标是超过原型的 0.75 分。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi op"><img src="../Images/89494b4c1e14ba75e848a137c1872f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdPyY2BQWZ5ejbVudakyhg.png"/></div></div></figure><pre class="mp mq mr ms gt nj nk nl nm aw nn bi"><span id="c3b8" class="mx lm iq nk b gy no np l nq nr">train time: 3113s<br/>----------pred_train----------<br/>f1-score:0.88<br/>precision:0.91<br/>recall:0.84<br/>accuracy:0.94<br/>confusion matrix:<br/>TP:32.0	 | FP:3.0<br/>FN:6.0	 | TN:122.0<br/>----------pred_test----------<br/>f1-score:0.75<br/>precision:0.90<br/>recall:0.64<br/>accuracy:0.90<br/>confusion matrix:<br/>TP:9.0	 | FP:1.0<br/>FN:5.0	 | TN:47.0</span></pre><p id="de28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与原型相比没有观察到改进…也许原型<code class="fe nu nv nw nk b">LogisticRegression</code>已经是最好的了；)</p><h2 id="602a" class="mx lm iq bd ln my mz dn lr na nb dp lv kj nc nd lz kn ne nf md kr ng nh mh ni bi translated">特征重要性</h2><p id="3267" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">让我们检查一下最重要的特性是否有意义。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oq"><img src="../Images/610805dd774e05e3faf261b04513f680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFRUUivRl4ZS6wF_VKfsdQ.png"/></div></div></figure><ol class=""><li id="8230" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv oa lc ld le bi translated">reg_days(注册后天数)<br/>注册天数越短的用户越容易流失。<br/><em class="ob">*从数据探索会话中数字特征的分布可以得出相同的结论。</em></li><li id="4112" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">设置-每小时检查事件<br/>用户检查设置越频繁，他们就越有可能流失！</li><li id="a07f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">每小时升级相关的事件</li><li id="141c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">每小时观看的广告</li><li id="5dcf" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv oa lc ld le bi translated">每小时播放的歌曲</li></ol><p id="6fb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，这一切似乎都是合理的…尽管我期望在查看数字特征的分布时，否定事件具有更高的重要性:(</p><h1 id="f087" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="a1cd" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">到目前为止，我们已经完成了这些步骤:</p><ul class=""><li id="ef92" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">探索和操作我们的数据集</li><li id="01d8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">为我们的问题设计相关功能</li><li id="59ae" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">通过抽样流失将数据分为训练集和测试集</li><li id="70b0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">用<a class="ae lk" href="https://spark.apache.org/docs/latest/ml-guide.html" rel="noopener ugc nofollow" target="_blank"> Spark 的基于数据帧的 MLlib </a>构建二进制分类器模型</li><li id="ee3a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">用<a class="ae lk" href="https://spark.apache.org/docs/latest/ml-pipeline.html" rel="noopener ugc nofollow" target="_blank"> Spark 的 ML 管道</a>和<a class="ae lk" href="https://github.com/interviewstreet/spark-stratifier" rel="noopener ugc nofollow" target="_blank">stratifiedcrossfvalidator</a>选择并微调最终模型</li></ul><p id="501a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这个项目有趣或困难的方面:</p><ul class=""><li id="2085" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">如何使用 Spark 的数据框架进行聚合</li><li id="b99a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如何处理不平衡数据集</li></ul><p id="5013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">改进:</p><ul class=""><li id="f4b9" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">给定一些日志作为输入，实际预测哪些用户更有可能流失</li><li id="5b6e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在模型优化会话中探索更多参数</li><li id="7837" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">一种更加自动化的方法来过滤掉高度相关的特征</li></ul><p id="0ea0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！完整的代码可以在这个<a class="ae lk" href="https://github.com/silviaclaire/sparkify" rel="noopener ugc nofollow" target="_blank">报告</a>中找到。</p></div></div>    
</body>
</html>