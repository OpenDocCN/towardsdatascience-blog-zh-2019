<html>
<head>
<title>Find thy hyper-parameters for scikit-learn pipelines using Microsoft NNI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用微软 NNI 查找 scikit-learn 管道的超参数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-thy-hyper-parameters-for-scikit-learn-pipelines-using-microsoft-nni-f1015b1224c1?source=collection_archive---------29-----------------------#2019-11-06">https://towardsdatascience.com/find-thy-hyper-parameters-for-scikit-learn-pipelines-using-microsoft-nni-f1015b1224c1?source=collection_archive---------29-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6e1cf80c8f06d3f59626bf49814d7565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gK0FY4v05ghDbZyZVDxJCA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Source: <a class="ae kf" href="https://www.pexels.com/photo/person-woman-eyes-face-4636/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com</a></figcaption></figure><h1 id="5d42" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是超参数搜索？</h1><p id="2cf2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">任何机器学习算法的目标都是<strong class="lg iu">在样本数据中找到模式</strong>，然后使用这些模式来预测给定的未知样本(测试)数据的结果。</p><p id="5f14" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">机器学习算法学习的模式被编码在模型的权重(也称为参数)中。然而，机器学习算法可以应用于不同类型的数据，即使对于数据“类型”相同的情况，数据的分布也可能不同。</p><p id="4975" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一个具体的例子，让我们看看 scikit-learn 的支持向量分类器(SVC)的 API。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/b509b10fe1002c48229631c3b94e1d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MquB3xHa8gfzazMwp1mHw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Source : Screenshot of <a class="ae kf" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html</a></figcaption></figure><p id="c213" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">根据上图，您可以理解为不同类型和分布的输入数据集找到 C、核、度、Gamma 和 Coef0 的适当组合并不是一项简单的任务。</p><p id="4e69" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这些类型的参数(机器学习算法的输入，即上述示例中的 C、内核等)被称为超参数，找到它们的任务被称为超参数搜索或调整。</p><h1 id="146a" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是微软 NNI？</h1><p id="dc48" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">微软 NNI(神经网络智能)是一个开源的神经架构搜索和超参数调整的 AutoML 工具包。</p><blockquote class="mm mn mo"><p id="46ac" class="le lf mp lg b lh mc lj lk ll md ln lo mq me lr ls mr mf lv lw ms mg lz ma mb im bi translated"><strong class="lg iu">我了解超参数调优，但什么是 AutoML？</strong></p></blockquote><p id="4317" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">实际上，在许多方面，超参数搜索/调整是一个叫做 AutoML 的大领域的一个子领域。也就是说，根据你在哪里阅读 AutoML，你可能会得到不同的印象。在这里，我提供了通常与 AutoML 相关的三个主要特性</p><p id="d88f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">超参数搜索。</strong>我的神经网络有多少层、神经元、宽度和深度？我的 SVM 的 C &amp; gamma 值应该是多少？</p><p id="4531" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">网络架构搜索(NAS) </strong>。神经网络中的哪种层组合可以产生最佳性能。例如，使用 NAS 发现了名为<strong class="lg iu"> EfficientNet </strong>的最新领先 ImageNet 网络。我把这个定义过于简化了，但是希望你能明白其中的要点！</p><p id="3e13" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">基于云的 AutoML </strong>。云提供商公开了一项服务，并告诉我提供您的训练数据集并指定任务(分类或回归)，我将为您构建模型。回家睡觉吧！。这个定义意味着一个典型的机器学习管道的大部分(如果不是全部的话)方面(数据规范化、标准化、找到合适的算法、优化等)都是为你考虑的。这是一个自动化的机器学习。</p><p id="b8e0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">还可以看到，上述特征很容易相互重叠。例如，有人可能认为网络架构搜索将/应该主要包括超参数搜索。</p><p id="4f0b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要进行超参数和架构搜索，一个简单的方法是尝试大量的组合，看看哪一个胜出！….但这不会有成效，不是吗？。这就是为什么有算法和技术的研究，为其他机器学习算法找到超参数。</p><p id="b4ae" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这些超参数和架构搜索算法通常被称为<strong class="lg iu"> <em class="mp">调谐器</em> </strong>，因为大多数时候它们从一组参数开始，然后根据看到的结果选择下一组参数。简而言之，他们<em class="mp">反复调整</em>它们。</p><p id="be0b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">微软 NNI 被称为工具包，因为</p><ul class=""><li id="1e46" class="mt mu it lg b lh mc ll md lp mv lt mw lx mx mb my mz na nb bi translated">它已经实现了许多已知的艺术调谐器，并为您编写自己的框架。</li><li id="9da2" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">它为您的实验提供编写、运行、记录和可视化支持。</li><li id="ce6f" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">您不仅可以在本地机器上运行您的实验，而且它还可以与各种编排系统(如 Kubeflow、OpenPAI 等)很好地集成。还有足够的扩展点来集成新的或专有的机器学习平台。</li><li id="9ad7" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">它支持大多数机器学习框架(Tensorflow、PyTorch、MXNET、Chainer 等)以及库(scikit-learn、xgboost、lightgbm 等)。</li></ul><p id="60b9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，它不仅提供了运行和可视化的工具，而且还可以扩展(因此是框架的概念)进行定制。</p><h1 id="b414" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">编写和运行一个简单的 NNI 实验(试用版)</h1><p id="2f76" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">尽管 GitHub repo 列出了支持的框架(Tensorflow、scikit-learn 等)，但对于大多数用例，微软 NNI 并不知道您正在使用的框架，甚至是您的培训模型。</p><p id="64ca" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">下图显示了撰写典型试验所涉及的 3 种类型的文件:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/d11d08aae890963aa4286a4f71a007bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78Y2vjp5zpa7MO6t1Hux7A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Source : Screenshot of a trial example from <a class="ae kf" href="https://github.com/microsoft/nni" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/nni</a></figcaption></figure><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c76bb5f58e470d9f299ff36bf8fcbe6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*M76eA5K2DcC9WrUfApOdAA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Source: Screenshot of search-space.json</figcaption></figure><p id="5ac4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nj nk nl nm b">search-space.json</code>该文件用于指定您正在搜索的超参数的范围！</p><p id="63dc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这是您最终要编写的一种示例代码。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/b9fa74c0ce77756bd7482666da4fb523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKsQLKwiw4H6TO_v9ESRGw.png"/></div></div></figure><p id="200a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在这个例子中，您有一个 SVC 模型。进行试验包括 4 个步骤:</p><p id="6b93" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">1)你加载你的数据。</p><p id="52fe" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">2)你请求 NNI 给你试验参数。</p><p id="ce2d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">3)将参数应用到正在训练的模型</p><p id="f6de" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">4)你回分数。</p><p id="1f8a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">基于<code class="fe nj nk nl nm b">config.yml</code>文件中的<code class="fe nj nk nl nm b">optimize_mode</code>(见下文)，调谐器将通过建议下一组模型的超参数来帮助最大化或最小化分数。</p><p id="fa3b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这里是一个例子<code class="fe nj nk nl nm b">config.yml</code>的文件，它被用来指定这个试验的配置选项。即在哪里运行、应该运行多长时间以及使用哪个调谐器。所以让我们看看 config.yml 文件。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/67fa6d090511e26b0495034b0f40658e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*4qPkkEWAZnzqVQZzKZTRVA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Source: Screenshot of example config.yml</figcaption></figure><p id="a507" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在配置文件中，您还可以指定到<code class="fe nj nk nl nm b">search_space.json</code>和<code class="fe nj nk nl nm b">main.py.</code>的路径</p><p id="d152" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">运行实验的时间:</p><pre class="mi mj mk ml gt np nm nq nr aw ns bi"><span id="f26b" class="nt kh it nm b gy nu nv l nw nx">nnictl create --config &lt;path_to&gt;/config.yml</span></pre><p id="de9d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在执行上述命令后，您将在终端上看到如下所示的响应:</p><pre class="mi mj mk ml gt np nm nq nr aw ns bi"><span id="4d52" class="nt kh it nm b gy nu nv l nw nx">INFO: Starting restful server...<br/>INFO: Successfully started Restful server!<br/>INFO: Setting local config...<br/>INFO: Successfully set local config!<br/>INFO: Starting experiment...<br/>INFO: Successfully started experiment!<br/>--------------------------------------------------------------------<br/>The experiment id is egchD4qy<br/>The Web UI urls are: http://223.255.255.1:8080   http://127.0.0.1:8080<br/>--------------------------------------------------------------------</span><span id="3721" class="nt kh it nm b gy ny nv l nw nx">You can use these commands to get more information about the experiment<br/>--------------------------------------------------------------------<br/>         commands                       description<br/>1. nnictl experiment show        show the information of experiments<br/>2. nnictl trial ls               list all of trial jobs<br/>3. nnictl top                    monitor the status of running experiments<br/>4. nnictl log stderr             show stderr log content<br/>5. nnictl log stdout             show stdout log content<br/>6. nnictl stop                   stop an experiment<br/>7. nnictl trial kill             kill a trial job by id<br/>8. nnictl --help                 get help information about nnictl<br/>--------------------------------------------------------------------</span></pre><p id="27ea" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">你现在可以用你的浏览器来查看 NNI 进行的各种实验。每个试验本质上对应于炒作参数的一个组合。</p><p id="66b4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">还可以选择使用命令(如上所示)来获取终端本身的实验和试验状态。命令应该是不言自明的。</p><h1 id="1a8c" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">sci kit-学习管道</h1><p id="4854" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">scikit-learn 是任何机器学习工程师最重要的库之一。它与许多优秀算法的实现捆绑在一起。scikit-learn 的一个我非常喜欢的特性是管道的概念。</p><p id="080b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">管道旨在反映典型的机器学习实验，该实验由对输入特征的各种变换步骤组成，并最终以估计器(分类器或回归器)终止。转换器和估算器被称为流水线的组件。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/169d909c08af8b4f288b5e9cdaaaa2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*n6CHRAuypD7Qw5cWFBpwsg.png"/></div></figure><p id="86a6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在上图中，组件是缩放、降维、学习算法和预测模型。看看这些组件如何实现<code class="fe nj nk nl nm b">fit, transform and predict</code>方法。</p><p id="5651" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您与接口兼容，您还可以实现一个定制的转换器或估计器。</p><p id="c928" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">以下是如何使用 python 编写管道的示例:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/0f2ec1575574f5be349293d278094da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTDTH9kASbx3VH7OZEaQdQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Source: Author</figcaption></figure><p id="7284" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">上图中显示了两条管道-</p><p id="a016" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">a)make _ svc _ pipeline-标准化数据，然后应用 SVC</p><p id="2601" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">b) make_pca_svc_pipeline —规格化 pca(用于 dim 减少)和最终 svc</p><p id="4640" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">请注意，在这两个管道中，我是如何将所有的超参数(<code class="fe nj nk nl nm b">pca_components &amp; svc_hparams) </code>作为函数的输入参数传递的。这样，我现在可以从 NNI 调谐器获得这些，并把它们传递给函数。</p><p id="3bc8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">下面是 NNI 网络用户界面的一个标签的截图，显示了一个调谐器最后尝试的各种组合。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/e93bdb001e708929a7a78325cb667f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3v5BbKwiiS8PNlrwjNvRQ.png"/></div></div></figure><p id="69f2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">非常酷的可视化！我现在想编写由其他分类器组成的管道，例如，不使用 SVC，我想尝试 xgboost、lightgbm 等，但是我开始发现对于我的任务来说，这个过程是相当重复的，即对于每个实验编写<code class="fe nj nk nl nm b">config.yml, search-space.json and pipelines + entrypoint script to get the parameters from NNI Tuner, return the score and invoke the pipelines.</code></p><blockquote class="mm mn mo"><p id="9d72" class="le lf mp lg b lh mc lj lk ll md ln lo mq me lr ls mr mf lv lw ms mg lz ma mb im bi translated">使用微软 NNI 进一步简化寻找<strong class="lg iu"> scikit-learn 管道</strong>的超级参数的任务不是很棒吗？</p></blockquote><p id="8ddf" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这就是我最终构建的东西，一个使用自省和配置文件来自动化上述步骤的小包。目前，我支持分类(很快也会支持回归)算法。</p><p id="6b7c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您对如何使用该软件包感兴趣，请继续阅读本文的其余部分。</p><h1 id="3c66" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">scikit-nni:一个小 python 包，用于自动搜索 scikit-learn 管道的超参数</h1><pre class="mi mj mk ml gt np nm nq nr aw ns bi"><span id="8aec" class="nt kh it nm b gy nu nv l nw nx">pip install scikit-nni</span></pre><p id="becc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">sci kit-nni(【https://github.com/ksachdeva/scikit-nni】T2)是一个辅助工具(和一个软件包)，它:</p><ul class=""><li id="8d08" class="mt mu it lg b lh mc ll md lp mv lt mw lx mx mb my mz na nb bi translated">生成 NNI 所需的配置(config.yml &amp; search-space.json)</li><li id="93b8" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">根据您的规范自动构建 scikit-learn 管道，并成为微软 NNI 运行的实验/试用代码</li></ul><h2 id="eff4" class="nt kh it bd ki oc od dn km oe of dp kq lp og oh ku lt oi oj ky lx ok ol lc om bi translated">scikit-nni 的特点</h2><ul class=""><li id="31c9" class="mt mu it lg b lh li ll lm lp on lt oo lx op mb my mz na nb bi translated">使用微软 NNI 搜索 scikit-learn 管道的超参数</li><li id="1ca6" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">定义管道不需要代码</li><li id="0904" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">内置数据源读取器，用于读取 npz 文件进行分类</li><li id="563c" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">支持使用自定义数据源读取器</li><li id="abd3" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">定义 NNI 配置和搜索空间的单一配置文件</li></ul><p id="efd0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该软件包及其使用方法在 https://github.com/ksachdeva/scikit-nni<a class="ae kf" href="https://github.com/ksachdeva/scikit-nni" rel="noopener ugc nofollow" target="_blank">有很好的文档记录，所以请查看完整的文档和示例。</a></p><p id="103f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">简而言之，这是你最终会做的事-</p><p id="db89" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在使用微软 NNI 时，你不用写 3 个(或更多)文件，你只需写一个配置文件。一个例子是-</p><p id="a608" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">看看<code class="fe nj nk nl nm b">search-space.json </code>和<code class="fe nj nk nl nm b">config.yaml</code>是如何嵌入到这个配置文件中的。他们遵循与微软 NNI 相同的语法和惯例，所以我没有发明任何新的语法。最大的区别在于，您不是编写 python 代码，而是在配置文件本身中指定 scikit-learn 管道。阅读上述 YAML 文件中的注释。</p><p id="8dff" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">你会意识到，这种自动化不仅有助于找到超参数，而且现在很容易尝试各种管道，而不必经历用代码编写它们、从 NNI 检索参数、发回分数和编写入口点脚本的麻烦。</p><p id="bd7e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一旦您编写了这个配置文件，然后发出以下命令:</p><pre class="mi mj mk ml gt np nm nq nr aw ns bi"><span id="ff0f" class="nt kh it nm b gy nu nv l nw nx">sknni generate-experiment --spec example/pca_svc.nni.yml --output-dir experiments</span></pre><p id="6980" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">像往常一样运行您的 NNI 实验，即现在发出以下命令</p><pre class="mi mj mk ml gt np nm nq nr aw ns bi"><span id="0268" class="nt kh it nm b gy nu nv l nw nx">nnictl create --config experiments/pca-svc-classification/config.yml</span></pre><p id="7429" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然而，您需要做的是编写一个返回训练和测试数据的 callable。在存储库的文档中，我展示了如何根据项目的需求编写这样一个数据源。在不久的将来，我将为分类和回归需求捆绑一些常见的数据源。</p><p id="1aff" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">将来会添加更多的数据源，但是您可以根据您的项目需求编写一个数据源。定制数据源的一个简单例子是</p><h1 id="1ec5" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结束语</h1><ul class=""><li id="41d8" class="mt mu it lg b lh li ll lm lp on lt oo lx op mb my mz na nb bi translated">微软 AutoML 是一个真正设计良好的，可扩展的和文档化的解决方案</li><li id="4237" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">感谢 NNI，使用最先进的调谐器现在只是一个简单的配置问题，你不必狩猎和学习如何使用各种调谐器算法。</li><li id="9fb5" class="mt mu it lg b lh nc ll nd lp ne lt nf lx ng mb my mz na nb bi translated">scikit-nni 利用微软 nni 来自动执行超参数搜索任务，而不需要在 python 代码中定义管道和实验。它还通过使用一致的语法将文件数量减少到 1 个来简化配置文件。</li></ul><p id="534f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">scikit-nni 非常新，请随时提交您可能遇到的任何问题(<a class="ae kf" href="https://github.com/ksachdeva/scikit-nni" rel="noopener ugc nofollow" target="_blank">https://github.com/ksachdeva/scikit-nni</a>)以及进一步改进它的想法。贡献总是被感激的！。</p></div></div>    
</body>
</html>