<html>
<head>
<title>R you sure you’re using this package?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你确定你在用这个包吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/r-you-sure-youre-using-this-package-8ce265a990b0?source=collection_archive---------15-----------------------#2019-05-23">https://towardsdatascience.com/r-you-sure-youre-using-this-package-8ce265a990b0?source=collection_archive---------15-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何识别一个 R 文件实际上正在使用哪些包(和哪些函数)</h2></div><p id="8fbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在继承别人的 R 代码时，我总喜欢检查它用了哪些包和函数。不仅仅是那些它装载的库函数调用，还有那些它<em class="le">实际上</em>使用的。为此，我最近发现了<a class="ae lf" href="https://www.rdocumentation.org/packages/NCmisc/versions/1.1.6/topics/list.functions.in.file" rel="noopener ugc nofollow" target="_blank">这个有用的小工具</a>，它将为你提供一个列表，列出所有的包以及在给定的 R 文件中引用的那些包中的所有函数。</p><p id="bae2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要安装的包是<strong class="kk iu"> NCmisc </strong>，我们将在其中使用的函数是名副其实的<strong class="kk iu"> list.functions.in.file </strong>。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/faafdc3dc3b8dc74dcf824c48df63628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R41eer1vdXzIpC9YKWTCow.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Example use of NCmisc::list.functions.in.file()</figcaption></figure><p id="d448" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的工作原理是识别给定文件中的所有函数调用，并将这些调用与内存中当前加载的函数进行比较。</p><p id="7544" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着<em class="le">在</em>运行<strong class="kk iu"> list.functions.in.file </strong>之前，你需要将所有你认为被引用的包加载到内存中，并且<em class="le">只需要</em>那些包。最简单的方法是打开一个 RStudio 的新实例，只执行文件中的代码。(在上面的例子中,“全局。r”文件是一个闪亮应用程序的一部分，我第一次运行它，然后就停止了。)</p><p id="5822" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是一个命名列表。每个项目都以包的名称命名，如果一个特定的函数名称为多个包所共有，则以包的名称命名。每个列表条目都是一个函数名列表。文件本身定义的任何自定义功能将出现在<strong class="kk iu">下。全球环境</strong>。</p><blockquote class="lw"><p id="b323" class="lx ly it bd lz ma mb mc md me mf ld dk translated">如果您的 R 脚本文件加载了一个包，但是这个包是<strong class="ak">而不是</strong>在这个输出中列出的，那么它就是多余的，您可以删除它。清理是好的。</p></blockquote><p id="15ec" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在我们的例子中，这个文件中引用了五个来自<strong class="kk iu"> plotly </strong>包的函数。但是还有一个——布局功能的<strong class="kk iu">——在<strong class="kk iu">图形</strong>和<strong class="kk iu">图形</strong>中都有定义。</strong></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ml"><img src="../Images/c0e1a2b77988e5b650be182de4ebbb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ic5QRDg9n_cjY7giQFBJw.png"/></div></div></figure><h2 id="d3f7" class="mm mn it bd mo mp mq dn mr ms mt dp mu kr mv mw mx kv my mz na kz nb nc nd ne bi translated">查找潜在的函数名冲突</h2><p id="4480" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">因此，这可以成为发现潜在名称空间冲突的工具。我碰巧知道我们不需要担心这种特定的冲突，但情况不会总是如此。在同一个例子中，在<strong class="kk iu"> config </strong>包中有一个名为<strong class="kk iu"> get </strong>的函数，它与一个完全不同的同名基本函数冲突。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nk"><img src="../Images/c1ac5d7b0a2b8cc114d58fdbce0d4442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVD4Hf6DRrxqdgH8mqLr3g.png"/></div></div></figure><p id="c2aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使加载了<strong class="kk iu"> config </strong>包，我们也应该总是使用显式引用来调用它的<strong class="kk iu"> get </strong>函数——使用双冒号符号——以避免意想不到的后果。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nl"><img src="../Images/a021c409c796b9341bf1a2389775354f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHDypOJBOy_4_Dj5JlNg4w.png"/></div></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="90a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。当然，如果你想让它解析多个文件，寻找特定的包/函数，输出结果到一个文本文件等等，你可以把它包装在你自己的代码里。</p><p id="cb4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这能对你有所帮助，即使阅读这篇文章的唯一“你”是未来的我。</p></div></div>    
</body>
</html>