<html>
<head>
<title>Stop Waiting! Start using Async and Await!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">别等了！开始使用异步并等待！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stop-waiting-start-using-async-and-await-18fcd1c28fd0?source=collection_archive---------2-----------------------#2019-10-22">https://towardsdatascience.com/stop-waiting-start-using-async-and-await-18fcd1c28fd0?source=collection_archive---------2-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ab479260246940396e1d87d349e8cb43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmfaVAY-PadlMgs09ZeB8Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@harryknight?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Harry Knight</a> on <a class="ae kf" href="https://unsplash.com/s/photos/wait?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ac6e" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="43c5" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对我们数据科学家来说，最重要的因素是数据。我们如何把我们需要的数据输入到我们的程序中？我们通过一些 I/O 操作来做到这一点，如查询数据库、从磁盘加载文件或通过 HTTP 请求从 web 下载数据。这些 I/O 操作可能需要相当长的时间，我们只是在等待数据被访问。当我们必须加载多个文件、执行多个数据库查询或执行多个 HTTP 请求时，情况会变得更糟。大多数情况下，我们按顺序执行这些操作，这导致执行 100 个 I/O 操作总共要比执行单个操作多花 100 倍的时间。现在等待不仅令人讨厌，而且成为一种真正的痛苦。但是等待，不要太久:)，在我们启动另一个完全独立的请求之前等待请求的响应有意义吗？或者举一个日常生活中的例子，当你给两个人发邮件时，你会等到收到第一个人的回复后再给第二个人发邮件吗？我想不会。在本文中，我想向您展示如何使用 Python 中的异步 IO(简称 AsyncIO)编程范例来显著减少 IO 绑定问题的等待时间。我不会过多地探究技术细节，而是让它保持相当基本，并向您展示一个小的代码示例，希望这有助于您的理解。</p><h1 id="daad" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">问题是</h1><p id="69cc" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">假设我们想从一个服务器下载三个不同的文件。如果我们按顺序执行，大部分时间我们的 CPU 是空闲的，等待服务器响应。如果响应时间占主导地位，那么总执行时间就是各个响应时间的总和。示意性地，这看起来像图 1 所示。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/a89d16c0ffe4203e0f3d066580c0e349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTBbjzvwof0r3RzTBTABSA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Picture 1 showing the sequential execution flow and time.</figcaption></figure><p id="03d4" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">我认为空闲的 CPU 听起来不太理想。按顺序发送请求，等待所有请求完成，然后组合所有响应，这样不是更好吗？在这种情况下，再次假设响应时间占主导地位，总的执行时间大致是所有请求中最大的响应时间。这示意性地显示在图 2 中。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/bf0577b06a933823385c1d4f9f92b5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*HxgQA-wrWJtWZEHmZL1h0Q.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Picture 2 showing the idealized concurrently send non-blocking request execution time.</figcaption></figure><p id="5ac7" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">请注意，蓝色条只是显示了发送请求和响应可用之间的时间。在这段时间内，我们不应该只是有一个空闲的 CPU，而是应该利用它来执行一些工作。这正是我们在这里所做的。当一个请求的响应到达时，我们已经处理了它，同时还在等待其他响应的到达。听起来很棒，不是吗？那么我们如何编写利用这一点的代码呢？正如在介绍中已经说过的，我们可以使用 AsyncIO 来达到这个目的。</p><h1 id="3e3b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">解决方案</h1><p id="4a51" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">异步是一种更高级的编程范式，在这种情况下，您开始一项任务，虽然您没有该任务的结果，但您做了一些其他工作。这样，尽管在单个进程中使用单个线程，AsyncIO 还是给人一种并发的感觉。实现这一点的神奇要素是事件循环、协程和属于协程的可应用对象——对象、任务和未来。非常简单</p><ul class=""><li id="6428" class="mo mp it lg b lh mi ll mj lp mq lt mr lx ms mb mt mu mv mw bi translated">一个<strong class="lg iu">事件循环</strong>协调一个可应用对象的执行和通信。没有事件循环，我们就不能使用 awaitables，因此，每个 AsyncIO 程序至少有一个事件循环。</li><li id="6c76" class="mo mp it lg b lh mx ll my lp mz lt na lx nb mb mt mu mv mw bi translated">本地<strong class="lg iu">协程</strong>是用<strong class="lg iu">异步定义</strong>定义的 python 函数。你可以把它想象成一个可暂停的函数，它可以保持状态并从暂停状态恢复执行。你可以通过调用<strong class="lg iu">wait</strong>来暂停一个协同程序。通过暂停，它将控制流释放回事件循环，从而使其他工作得以完成。当 awaitable 的结果就绪时，事件循环将控制流交还给协程。调用协程会返回一个协程对象，必须等待它才能得到实际结果。最后，重要的是要记住<strong class="lg iu">你只能在一个协程内调用 await<em class="mc"/>。</strong>您的根协程需要通过阻塞调用被调度到事件循环上。</li></ul><p id="db05" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">下面是一些非常基本的代码，希望有助于您的理解</p><pre class="me mf mg mh gt nc nd ne nf aw ng bi"><span id="81b5" class="nh kh it nd b gy ni nj l nk nl"><strong class="nd iu">import </strong>asyncio</span><span id="b785" class="nh kh it nd b gy nm nj l nk nl"><strong class="nd iu">async def</strong> sample_coroutine():<br/>    <strong class="nd iu">return</strong> 1212</span><span id="9437" class="nh kh it nd b gy nm nj l nk nl"><strong class="nd iu">async def</strong> main_coroutine():<br/>    coroutine_object = sample_coroutine()<br/><strong class="nd iu">    # With await, we stop execution, give control back to the <br/>    # eventloop, and come back when the result of the <br/>    # coroutine_object is available.<br/></strong>    result = <strong class="nd iu">await</strong> coroutine_object<br/>    <strong class="nd iu">assert</strong> result == 1212</span><span id="e3b8" class="nh kh it nd b gy nm nj l nk nl"><strong class="nd iu"># Blocking call to get the event loop, schedule a task, and close<br/># the event loop</strong><br/>asyncio.run(main_coroutine())</span></pre><p id="79bd" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">如果你对更全面的介绍感兴趣，我向你推荐<a class="ae kf" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae kf" href="https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae kf" href="https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c" rel="noopener ugc nofollow" target="_blank">那个</a>。</p><h1 id="5022" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">这个例子</h1><p id="b960" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">理论够了，来试试吧。使用原生协程的先决条件是 Python 3.5+，但是 asyncio 发展很快，所以我建议使用最新的 Python 版本，在撰写本文时是 3.7+。举个例子，我下载了几张<a class="ae kf" href="https://dog.ceo/api/breed/hound/images" rel="noopener ugc nofollow" target="_blank">狗的图片</a>。为了进行比较，我以同步和异步方式进行了相同的操作。为了执行 HTTP 请求，我将<a class="ae kf" href="https://requests.kennethreitz.org/en/master/" rel="noopener ugc nofollow" target="_blank">请求</a>用于同步部分，将<a class="ae kf" href="https://aiohttp.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> AIOHTTP </a>用于异步部分。我有意省略了任何类型的错误检查，以避免重复代码。</p><h2 id="3201" class="nh kh it bd ki nn no dn km np nq dp kq lp nr ns ku lt nt nu ky lx nv nw lc nx bi translated">代码</h2><p id="2e39" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以让我们首先安装必要的模块</p><pre class="me mf mg mh gt nc nd ne nf aw ng bi"><span id="1892" class="nh kh it nd b gy ni nj l nk nl">pip install aiohttp requests</span></pre><p id="7517" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">接下来，我导入模块并添加一个小的助手函数</p><pre class="me mf mg mh gt nc nd ne nf aw ng bi"><span id="eb4f" class="nh kh it nd b gy ni nj l nk nl"><strong class="nd iu">import </strong>asyncio<br/><strong class="nd iu">import </strong>time<br/><strong class="nd iu">from </strong>typing <strong class="nd iu">import </strong>Any, Iterable, List, Tuple, Callable<br/><strong class="nd iu">import </strong>os<br/><strong class="nd iu">import </strong>aiohttp<br/><strong class="nd iu">import </strong>requests</span><span id="b324" class="nh kh it nd b gy nm nj l nk nl"><strong class="nd iu">def </strong>image_name_from_url(url: str) -&gt; str:<br/>    <strong class="nd iu">return </strong>url.split(<strong class="nd iu">"/"</strong>)[-1]</span></pre><p id="0581" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">现在，给定一组图像 URL，我们可以通过以下方式将它们顺序下载并存储为一个图像对列表(图像名，字节数组)</p><pre class="me mf mg mh gt nc nd ne nf aw ng bi"><span id="ae58" class="nh kh it nd b gy ni nj l nk nl"><strong class="nd iu">def </strong>download_all(urls: Iterable[str]) -&gt; List[Tuple[str, bytes]]:<br/>    <strong class="nd iu">def </strong>download(url: str) -&gt; Tuple[str, bytes]:<br/>        print(<strong class="nd iu">f"Start downloading </strong>{url}<strong class="nd iu">"</strong>)<br/>        <strong class="nd iu">with </strong>requests.Session() <strong class="nd iu">as </strong>s:<br/>            resp = s.get(url)<br/>            out= image_name_from_url(url), resp.content<br/>        print(<strong class="nd iu">f"Done downloading </strong>{url}<strong class="nd iu">"</strong>)<br/>        <strong class="nd iu">return </strong>out</span><span id="a0a8" class="nh kh it nd b gy nm nj l nk nl"><strong class="nd iu">return </strong>[download(url) for url in urls]</span></pre><p id="289e" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">我添加了一些打印语句，这样您就可以看到执行该函数时会发生什么。到目前为止还不错，到目前为止没有什么新的，但现在来了异步版本</p><pre class="me mf mg mh gt nc nd ne nf aw ng bi"><span id="3e0f" class="nh kh it nd b gy ni nj l nk nl"><strong class="nd iu">async def</strong> donwload_aio(urls:Iterable[str])-&gt;List[Tuple[str, bytes]]:<br/>    <strong class="nd iu">async def</strong> download(url: str) -&gt; Tuple[str, bytes]:<br/>        print(<strong class="nd iu">f"Start downloading </strong>{url}<strong class="nd iu">"</strong>)<br/>        <strong class="nd iu">async with</strong> aiohttp.ClientSession() as s:<br/>            resp = <strong class="nd iu">await </strong>s.get(url)<br/>            out = image_name_from_url(url), <strong class="nd iu">await </strong>resp.read()<br/>        print(<strong class="nd iu">f"Done downloading </strong>{url}<strong class="nd iu">"</strong>)<br/>        <strong class="nd iu">return </strong>out<br/>        <br/>    <strong class="nd iu">return await </strong>asyncio.gather(*[download(url) for url in urls])</span></pre><p id="4420" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">啊哈，这看起来几乎是一样的，除了所有那些异步和等待关键字。让我给你解释一下这里发生了什么。</p><ul class=""><li id="0978" class="mo mp it lg b lh mi ll mj lp mq lt mr lx ms mb mt mu mv mw bi translated">download_aio 是一个协同例程，因为它是用<em class="mc">异步定义定义的。它必须是一个协程，因为我们在其中调用其他协程。</em></li><li id="3631" class="mo mp it lg b lh mx ll my lp mz lt na lx nb mb mt mu mv mw bi translated">在<em class="mc">下载</em>协程中，我们使用异步上下文管理器(async with)创建一个会话对象，并等待 get 请求的结果。此时，我们执行潜在的持久 HTTP 请求。通过等待，我们暂停执行，给其他任务工作的机会。</li><li id="1538" class="mo mp it lg b lh mx ll my lp mz lt na lx nb mb mt mu mv mw bi translated">asyncio.gather 可能是这里最重要的部分。它执行一系列合适的对象，并返回收集结果的列表。有了这个功能，你可以达到一种并发的感觉，如图 2 所示。使用 gather 不能调度太多的协程，它的数量级是几百个。当您遇到这种问题时，您仍然可以将调用划分为较小的块，然后逐个收集。像调用协程返回一个变量一样，调用 gather 也返回一个变量，您必须等待它才能得到结果。</li></ul><p id="599c" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">让我们把它们放在一起，运行它，然后比较下载狗狗需要多长时间。</p><h2 id="35a8" class="nh kh it bd ki nn no dn km np nq dp kq lp nr ns ku lt nt nu ky lx nv nw lc nx bi translated">结果呢</h2><p id="da4c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下面是执行同步和异步 Http 调用的代码。</p><pre class="me mf mg mh gt nc nd ne nf aw ng bi"><span id="ed49" class="nh kh it nd b gy ni nj l nk nl"><strong class="nd iu">if</strong> __name__ == <strong class="nd iu">"__main__"</strong>:<br/>    <strong class="nd iu"># Get list of images from dogs API</strong><br/>    URL = <strong class="nd iu">"https://dog.ceo/api/breed/hound/images"<br/></strong>    images = requests.get(URL).json()[<strong class="nd iu">"message"</strong>]</span><span id="a4fa" class="nh kh it nd b gy nm nj l nk nl"><strong class="nd iu"># Take only 200 images to not run into issues with gather</strong>     <br/>    reduced = images[:200]<br/>    st = time.time()<br/>    images_s = download_all(reduced)<br/>    print(f"Synchronous exec took {time.time() - st} seconds")</span><span id="0faf" class="nh kh it nd b gy nm nj l nk nl">st = time.time()<br/>    images_a = asyncio.run(donwload_aio(reduced))<br/>    print(f"Asynchronous exec took {time.time() - st} seconds")</span></pre><p id="3be1" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">在稍微简化的版本中，同步版本打印出</p><blockquote class="ny nz oa"><p id="6d77" class="le lf mc lg b lh mi lj lk ll mj ln lo ob mk lr ls oc ml lv lw od mm lz ma mb im bi translated">开始 1，结束 1，开始 2，结束 2，…，开始 200，结束 200</p></blockquote><p id="7019" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">这反映了图 1 所示的流程。异步副本打印出如下内容</p><blockquote class="ny nz oa"><p id="2c97" class="le lf mc lg b lh mi lj lk ll mj ln lo ob mk lr ls oc ml lv lw od mm lz ma mb im bi translated">开始 1，开始 2，…，开始 200，结束 3，结束 1，…，结束 199</p></blockquote><p id="c569" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">这反映了图 2 中所示的内容。太棒了，这就是我答应你的。但我认为单凭这一点并不太有说服力。所以，把最好的留到最后，让我们看看执行时间。在我的机器上下载 200 张图片，同步调用需要 52.7 秒，而异步调用需要 6.5 秒，大约比<strong class="lg iu">快 8 倍</strong>。竟有人会说出这种话来！亏你（他）说得出口加速会因单个项目的最大下载时间而异，这取决于项目的大小和服务器在不减速的情况下可以处理的负载。</p><h1 id="25ee" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">外卖</h1><ul class=""><li id="a26c" class="mo mp it lg b lh li ll lm lp oe lt of lx og mb mt mu mv mw bi translated">对于您希望加速的 IO 相关问题，请使用 AsnycIO。有许多 IO 绑定操作模块，比如<a class="ae kf" href="https://aioredis.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> Aioredis </a>、<a class="ae kf" href="https://aiokafka.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> Aiokafka </a>或<a class="ae kf" href="https://aiomysql.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Aiomysql </a>等等。要获得更高级别的异步 API 的完整列表，请访问<a class="ae kf" href="https://github.com/timofurrer/awesome-asyncio" rel="noopener ugc nofollow" target="_blank"> awesome-asyncio </a>。</li><li id="8502" class="mo mp it lg b lh mx ll my lp mz lt na lx nb mb mt mu mv mw bi translated">您只能等待协程中的协程。</li><li id="ecc3" class="mo mp it lg b lh mx ll my lp mz lt na lx nb mb mt mu mv mw bi translated">您需要通过调用 python 3.7+中的<em class="mc"> asyncio.run </em>或 asyncio.get_event_loop()来调度您的异步程序或“根”协程。python 3.5–3.6 中的 run_until_complete。</li><li id="29e9" class="mo mp it lg b lh mx ll my lp mz lt na lx nb mb mt mu mv mw bi translated">最后也是最重要的:<strong class="lg iu">不要等待，等待！</strong></li></ul><p id="3b7c" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">希望你已经学到了一些新东西，可以减少等待时间。感谢您的关注，如果有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>