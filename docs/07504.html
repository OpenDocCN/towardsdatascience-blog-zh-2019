<html>
<head>
<title>8 Different Ways to Join Tables in SQL and its Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 中连接表的 8 种不同方式及其时间复杂度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-complexity-and-8-different-ways-to-join-tables-22ed7ae0060c?source=collection_archive---------4-----------------------#2019-10-20">https://towardsdatascience.com/sql-complexity-and-8-different-ways-to-join-tables-22ed7ae0060c?source=collection_archive---------4-----------------------#2019-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近在 Salesforce 营销云平台上工作时，我和一位同事遇到了一个由外部供应商编写的 SQL 查询，其形式我们相当不熟悉。事情是这样的:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Inefficient SQL query</figcaption></figure><p id="0130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个查询在 Salesforce Marketing Cloud 上表现很差，运行时间很长，超时频繁，让我们很沮丧。与我们熟悉的 Google Bigquery 不同，它是一个完全托管的 Pb 级数据平台，Salesforce Marketing Cloud 的计算能力低得多，无法处理复杂的查询负载。</p><p id="7c66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在这个低效的查询中，它的两个子查询引用了 where 表中的主表。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kx"><img src="../Images/1aa883bf4e2cb5ae865fd7c3eb520aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F98MaRX2aoIk_ILMXHI9mg.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Sub-queries referencing main query in the where function</figcaption></figure><p id="a7ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这激发了团队内部的求知欲；<em class="le">`我们可以用多少种方式编写一个 SQL 查询，每个查询的时间复杂度是多少？`.</em></p><p id="b85d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们决定基于 Fabian Pascal 1988 年的一篇文章<a class="ae kw" href="http://www.dbdebunk.com/2013/02/language-redundancy-and-dbms.html" rel="noopener ugc nofollow" target="_blank">重放一个实验，以比较在 SQL 查询中编写连接的不同方式的性能。这将有助于在排除故障、编辑某人的查询以及理解 SQL 的时间复杂性时建立我们的直觉，并允许我们编写更好的 SQL。</a></p><p id="b714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">展示了从 Google Bigquery 获得的增加了时间复杂度的 SQL 中连接表的 8 种方法，希望你喜欢这篇文章！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="85fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLDR:最有效的连接也是最简单的连接，“关系代数”。如果你想找到更多关于所有连接方法的信息，请继续阅读。</p><p id="dc5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 1:关系代数</strong></p><p id="6b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关系代数是编写查询最常见的方式，也是最自然的方式。代码很干净，很容易排除故障，不出所料，这也是连接两个表的最有效的方法。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Relational Algebra</figcaption></figure><p id="e3e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 2:不相关的子查询</strong></p><p id="e7a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不相关子查询方法通过首先创建 account_number 的子查询列表，然后使用 IN 函数来筛选子查询中的帐号，从而执行筛选函数。虽然效率不如关系代数，但由于易于编写，它是更常用的连接方法之一。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Uncorrelated Subquery</figcaption></figure><p id="5ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 3:相关子查询</strong></p><p id="0fc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在相关子查询中，EXISTS 函数用于在未筛选的子查询' SELECT * '中进行搜索。子查询中的筛选操作需要一个“where MP . account _ number = t . account _ number”。这是<code class="fe lm ln lo lp b">inefficient query</code>中使用的 join 函数之一。这种连接的性能令人苦恼。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Correlated Subquery</figcaption></figure><p id="3ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 WHERE 子句中的标量子查询</strong></p><p id="9cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用子查询作为 WHERE 函数的筛选器，该查询能够筛选 f_online = 1。这是一种很酷的思维方式，但不幸的是，它的表现并不好。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Scalar Subquery in the WHERE clause</figcaption></figure><p id="6bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 SELECT 子句中的标量子查询</strong></p><p id="37ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写查询的另一种非常有趣的方式是，该方法在 SELECT 函数中使用子查询从另一个表中提取 account_number，但是由于这两个表有多对多的关系，我们必须添加一个过滤器来删除空值。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Scalar Subquery in the SELECT clause</figcaption></figure><p id="a653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 6:聚合函数检查存在性</strong></p><p id="e8cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与标量子查询类似，此方法在 WHERE 函数中使用子查询。不同之处在于，该方法使用了一个子查询 COUNT(*)，其过滤器大于 1。​</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Aggregate function to check existence</figcaption></figure><p id="8c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 7:相关子查询(双重否定)</strong></p><p id="c93d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于相关子查询，但使用双重否定。这也是<code class="fe lm ln lo lp b">inefficient query</code>中使用的连接之一。但有趣的是，它的表现并没有我预期的那么差。这可能仅仅是由于数据结构中异常多于包含。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Correlated subquery (double negative)</figcaption></figure><p id="75d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法 8:不相关子查询(双重否定)</strong></p><p id="1536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于不相关子查询，但使用双重否定。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Uncorrelated subquery (double negative)</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="3d1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，我们编写 SQL 查询的方式对查询的效率有很大的影响。效率最高的查询运行时间为 13.8 秒，而效率最低的查询运行时间为 52.6 秒。我们在 Salesforce Marketing Cloud 上重新编写了外部供应商的低效查询，我们能够将运行时间从 45 分钟(外加频繁超时)减少到 4 分钟。之后，我们去喝了一杯冰啤酒，庆祝我们的胜利。</p><p id="a0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考<br/> </strong> *1988 年 Fabian Pascal 的文章《SQL 冗余和 DBMS 性能》发表在《数据库编程》&amp;Design—<a class="ae kw" href="http://www.dbdebunk.com/2013/02/language-redundancy-and-dbms.html" rel="noopener ugc nofollow" target="_blank">http://www . db deedged . com/2013/02/language-Redundancy-and-DBMS . html</a><br/>* Day 4:SQL 的十二天:您编写查询的方式至关重要—<a class="ae kw" href="https://iggyfernandez.wordpress.com/2011/12/04/day-4-the-twelve-days-of-sql-there-way-you-write-your-query-matters/" rel="noopener ugc nofollow" target="_blank">https://iggyfernandez . WordPress . com/2011/11</a></p><p id="7f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<a class="ae kw" href="https://www.linkedin.com/in/daniel-lim-305b1a106/" rel="noopener ugc nofollow" target="_blank"> Daniel </a>提供这篇文章背后的灵感，感谢<a class="ae kw" href="https://www.linkedin.com/in/shawn-phua-kc/" rel="noopener ugc nofollow" target="_blank"> Shawn </a>提供关于 SQL sequence 的额外材料。我很幸运有像你们这样酷的同事。</p><p id="a77e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢乔治分享费边·帕斯卡 1988 年的实验；)</p><p id="aadf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯，</p><p id="3477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kw" href="https://www.linkedin.com/in/mylee1/" rel="noopener ugc nofollow" target="_blank">孟勇</a></p></div></div>    
</body>
</html>