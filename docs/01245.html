<html>
<head>
<title>ML Data Pipelines with Custom Transformers in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中使用自定义转换器的 ML 数据管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65?source=collection_archive---------1-----------------------#2019-02-26">https://towardsdatascience.com/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65?source=collection_archive---------1-----------------------#2019-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f87b7637fe15157e95a8f961126aaf71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lw2NOHs4Zx62vlEwBSVmZg.jpeg"/></div></div></figure><div class=""/><p id="161d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如何使用继承和 sklearn 为机器学习预处理编写自己的定制转换器和管道</p><p id="ef8b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数数据科学项目花费的总时间的 80%花费在清理和预处理数据上。我们都听说过，对吧？因此，我们必须找到尽可能自动化预处理和清理的方法。</p><p id="4d94" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Scikit-Learn 管道由多个步骤组成，每个步骤都必须是某种转换器，除了最后一个步骤，它可以是转换器或估计器，如机器学习模型。当我说变压器时，我指的是变压器，例如<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html" rel="noopener ugc nofollow" target="_blank">规格化器</a>、<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">标准定标器</a>或<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">单热编码器</a>等等。但是，假设在我使用其中任何一个之前，我想编写 Scikit-Learn 没有提供的我自己的自定义转换器，它将使用我提供的权重向量作为参数，获取我的数据集中第 3、第 7 和第 11 列的加权平均值，用结果创建一个新列并删除原始列，该怎么办？除此之外，最重要的是，如果我还想让我的定制转换器与我现有的 Scikit-Learn 管道及其其他转换器无缝集成，该怎么办？听起来很棒，对我们来说很幸运，Scikit-Learn 允许我们这样做。</p><h1 id="0159" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Python 中的继承</h1><p id="21fd" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了理解我们如何用 scikit-learn 编写我们自己的定制转换器，我们首先必须稍微熟悉一下 Python 中的继承概念。scikit-learn 中的所有转换器和估算器都是作为 Python 类实现的，每个类都有自己的属性和方法。所以每次你写像这样的 Python 语句-</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e789" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您实际上是在使用类“OneHotEncoder”的类构造函数创建一个名为“one_hot_enc”的实例，并为其参数“sparse”传递参数“False”。OneHotEncoder 类具有诸如“fit”、“transform”和“fit_transform”等方法，现在可以在我们的实例上使用适当的参数调用这些方法，如下所示。</p><p id="09b0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让我们的自定义转换器与 scikit-learn 管道兼容，它必须作为具有 fit、transform、fit_transform、get_params、set_params 等方法的类来实现，因此我们要编写所有这些方法……或者我们可以简单地编写我们希望我们的转换器应用的转换类型，然后<strong class="kd jf">从某个其他类继承</strong>所有其他内容！</p><p id="a113" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要理解 Python 中继承的概念，请看下面这个波巴·费特的乐高进化。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/73e09e9606b9c122899a7ea2ce8bcf04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMhBkEJQQZs6Ur3fv0Dplg.png"/></div></div></figure><p id="9c71" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比如我想写一个看起来像右边乐高积木的类。我完全可以从最左边开始，通过写我自己的方法来建立自己的路。然而，如果我能从我正在努力做的那个后面的那个开始呢？我不需要从头开始，我已经有了我需要的大部分方法，而不需要自己编写它们。我可以对它进行添加或修改，直到完成我需要它做的事情。那不是很好吗？这正是遗传允许我们做的。</p><p id="5ad8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们在下面写出自己的变形金刚时，这个概念会变得更加清晰。如果您想在继续学习之前对 Python 中的类和继承有更多的了解，请查看下面的链接。</p><div class="is it gp gr iu mk"><a href="https://www.programiz.com/python-programming/class" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd jf gy z fp mp fr fs mq fu fw jd bi translated">Python 类和对象[带示例]</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">Python 是一种面向对象的编程语言。与面向过程的编程不同，面向过程的编程主要强调…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.programiz.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ja mk"/></div></div></a></div><div class="is it gp gr iu mk"><a href="https://www.programiz.com/python-programming/inheritance" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd jf gy z fp mp fr fs mq fu fw jd bi translated">Python 继承</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">继承是面向对象编程中的一个强大特性。它指的是定义一个新的类，很少或没有…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.programiz.com</p></div></div></div></a></div><p id="e864" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以现在你可能在想，那太好了！但是我在哪里可以找到这些基类呢？这些基类包含了我需要用来编写 transformer 类的大多数方法。不要担心。Scikit-Learn 为我们提供了两个很棒的基类，<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html" rel="noopener ugc nofollow" target="_blank"> TransformerMixin </a>和<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html" rel="noopener ugc nofollow" target="_blank"> BaseEstimator </a>。从 TransformerMixin 继承确保了我们所需要做的就是编写我们的 fit 和 transform 方法，并且我们可以免费获得 fit_transform。从 BaseEstimator 继承确保我们免费获得 get_params 和 set_params。由于 fit 方法除了返回对象本身之外不需要做任何事情，所以在从这些类继承之后，我们真正需要做的是为我们的自定义转换器定义转换方法，这样我们就获得了一个功能完整的自定义转换器，它可以与 scikit-learn 管道无缝集成！简单。</p><h1 id="ba4e" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">说明</h1><p id="3a70" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我将在这个插图中使用的数据集可以通过这个链接在 Kaggle 上找到。</p><div class="is it gp gr iu mk"><a href="https://www.kaggle.com/harlfoxem/housesalesprediction" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd jf gy z fp mp fr fs mq fu fw jd bi translated">美国金县的房屋销售</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">用回归法预测房价</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.kaggle.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my ja mk"/></div></div></a></div><p id="e6a2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此图的目标是通过编写我们自己的自定义转换器和管道所涉及的步骤，对数据进行预处理，直到数据被输入到机器学习算法中，以训练模型或进行预测。对于这个特殊的问题，可能有比在这个例子中描述的更好的方法来设计特性，因为我不关注这些特殊特性的有效性。此图的目的是让读者熟悉可用于创建转换器和管线的工具，以便尽可能高效地针对任何数据集以任何方式设计和预处理要素。</p><p id="f929" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那我们开始吧。</p><p id="301e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该数据集包含分类和数字独立变量的混合，我们知道这些变量需要以不同的方式分别进行预处理。这意味着最初它们必须通过单独的管道进行适当的预处理，然后我们将它们组合在一起。因此，两个管道的第一步都必须提取需要下推进行预处理的适当列。</p><p id="4bab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编写一个类并让 Python 知道它继承自一个或多个类的语法如下图所示，因为对于我们编写的任何类，我们都可以从 TransformerMixin 和 BaseEstimator 基类继承大部分内容。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/21c6c94fc404bdb875052574c1825a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*eroPf-aNxt7fJ_oOpOC-AQ.png"/></div></figure><p id="fbd5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们第一个名为 FeatureSelector 的自定义转换器的代码。这个构造函数的 transform 方法只是提取并返回 pandas 数据集，其中只包含那些在初始化过程中作为参数传递给它的列名。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2ccc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们在声明类时将 BaseEstimator 和 TransformerMixin 放在括号中，让 Python 知道我们的类将从它们继承。像我们要写的所有构造函数一样，fit 方法只需要返回 self。transform 方法是我们真正要写的，让转换器做我们需要它做的事情。在这种情况下，它仅仅意味着返回一个只包含所选列的 pandas 数据框。</p><p id="fbd0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然已经编写了将在两个管道中处理第一步的构造函数，我们就可以编写将在相应管道中处理其他步骤的转换器，从处理分类特性的管道开始。</p><h2 id="7e0d" class="nb lb je bd lc nc nd dn lg ne nf dp lk km ng nh lo kq ni nj ls ku nk nl lw nm bi translated">分类管道</h2><p id="7480" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是我们的定制转换器将处理的功能列表，以及在我们的分类管道中如何处理。</p><ul class=""><li id="7a7f" class="nn no je kd b ke kf ki kj km np kq nq ku nr ky ns nt nu nv bi translated"><strong class="kd jf"> date </strong>:此列中的日期格式为‘yyyymmddt 000000’，必须进行清理和处理才能以任何有意义的方式使用。这个转换器的构造函数将允许我们为参数“use_dates”指定一个值列表，这取决于我们是想为年、月、日或这些值的某种组合创建一个单独的列，还是简单地通过传入一个空列表来完全忽略该列。通过不对该特性的规范进行硬编码，我们可以随时尝试不同的值组合，而不必重写代码。</li><li id="1b51" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">滨水</strong>:房屋是否为滨水物业。转换为二进制—是或否</li><li id="6f1c" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">查看</strong>:房子被查看了多少次。大部分值都是 0。其余的非常稀疏地分布在 1 到 4 之间。转换为二进制—是或否</li><li id="8eb9" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">yr _ recruited</strong>:房子装修的年份。大多数值都是 0，可能永远不会，而其余的值在几年之间分布得很稀疏。转换为二进制—是或否</li></ul><p id="9bf4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们的定制转换器以上述方式处理了所有这些特性，它们将被转换成一个 Numpy 数组，并被推送到分类管道中的下一个也是最后一个转换器。一个简单的 sci kit-了解一个热编码器，它返回我们预处理数据的密集表示。下面是我们定制的转换器的代码。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h2 id="6d72" class="nb lb je bd lc nc nd dn lg ne nf dp lk km ng nh lo kq ni nj ls ku nk nl lw nm bi translated">数字流水线</h2><p id="0e49" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是我们的自定义数值转换器将处理的特性列表，以及如何在我们的数值管道中处理。</p><ul class=""><li id="25f3" class="nn no je kd b ke kf ki kj km np kq nq ku nr ky ns nt nu nv bi translated"><strong class="kd jf">卧室</strong>:房子里卧室的数量。照原样通过。</li><li id="d10e" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">卫生间</strong>:房屋内卫生间数量。这个转换器的构造函数将有一个参数“bath_per_bead ”,它接受一个布尔值。如果为真，那么构造函数将通过计算浴室/卧室来创建一个新列，以计算每个卧室的浴室数量，并删除原始的浴室列。如果为 False，那么它将原样通过浴室列。</li><li id="0b7e" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf"> sqft_living </strong>:房屋居住面积大小，平方英尺。照原样通过。</li><li id="20dc" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf"> sqft_lot </strong>:以平方英尺为单位的总批量。照原样通过。</li><li id="5de0" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">楼层</strong>:房屋的层数。照原样通过。</li><li id="27d9" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">条件</strong>:描述房屋条件的离散变量，取值范围为 1-5。照原样通过。</li><li id="157f" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf"/>等级:根据 King County 等级系统给出的住房单元的总体等级，值为 1-13。照原样通过。</li><li id="f5f3" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf"> sqft_basement </strong>:房屋内的地下室面积，以平方英尺为单位(如有)。没有地下室的房屋为 0。照原样通过。</li><li id="b6b8" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated"><strong class="kd jf">yr _ build</strong>:房子建造的年份。这个转换器的构造函数将有另一个参数‘years _ old ’,它也接受一个布尔值。如果为真，则构造函数将通过从 2019 年减去房屋建造年份来计算 2019 年的房屋年龄，从而创建一个新列，并将删除原始的 yr _ built 列。如果为 False，那么它将直接传递 yr _ built 列。</li></ul><p id="37cf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦所有这些特性都由我们的自定义数值转换器在上述数值管道中处理，数据将被转换为 Numpy 数组，并传递到数值管道的下一步，即另一种 scikit-learn 转换器。估算器将计算列中值，并用适当的中值填充任何 Nan 值。从那里，数据将被推送到数字管道中的最终转换器，一个简单的 scikit-learn 标准定标器。下面是自定义数值转换器的代码。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h2 id="6594" class="nb lb je bd lc nc nd dn lg ne nf dp lk km ng nh lo kq ni nj ls ku nk nl lw nm bi translated"><strong class="ak">将管道组合在一起</strong></h2><p id="5512" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，我们已经编写了数字和分类转换器，并定义了我们的管道，我们需要一种方法来横向组合它们。我们可以使用 scikit-learn 中的<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.FeatureUnion.html" rel="noopener ugc nofollow" target="_blank"> FeatureUnion </a>类来实现。我们可以在 Python 中创建一个特征联合类对象，方法是给它两个或更多由转换器组成的管道对象。为要素联合对象调用 fit_transform 方法会将数据分别推入管道，然后将结果合并并返回。在我们的例子中，因为我们的两个管道的第一步是为每个管道提取适当的列，所以使用特征联合将它们组合起来，并在整个数据集上拟合特征联合对象，这意味着适当的列集将被下推到适当的管道集，并在它们被转换后组合在一起！是不是很牛逼？</p><p id="ff28" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还没告诉你最精彩的部分呢。它将为我们并行计算！没错，它会并行转换数据，并将其重新组合在一起！因此，它很可能比任何处理这种线性预处理的脚本都要快，因为它很可能需要更多的并行工作。我们再也不用担心手动操作了。我们的 FeatureUnion 对象将尽可能多次地处理这个问题。我们所要做的就是在我们的完整特性联合对象上调用 fit_transform。下面是使用我们的自定义转换器和其他工具创建两个管道，然后将它们组合在一起的代码。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e987" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你可能已经注意到，我没有在完整的管道中包括任何机器学习模型。原因是我不能。FeatureUnion 对象接受仅包含转换器的管道对象。机器学习模型是一个估计器。解决方法是，我可以创建另一个管道对象，第一步传递完整的管道对象，最后一步添加一个机器学习模型。完整的预处理数据集将是第一步的输出，它将简单地传递到我的模型中，使它像您可能编写的任何其他 scikit-learn 管道一样工作！这是代码。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="be28" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只需在未处理的数据集上拟合管道，它会使用我们构建的工具自动进行所有预处理和拟合。适当的柱子被分开，然后它们被推下适当的管道，在那里它们各自通过 3 或 4 个不同的变压器(总共 7 个！)使用我们决定的参数，将预处理的数据放回一起，并向下推至模型进行训练！调用 predict 对未处理的测试数据帧做同样的事情，并返回预测！这是我做的一个简单的图表，展示了我们机器学习管道的流程。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/4a6c6be3ce7fc9cd96502f75fd482ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*b0rUb-3fH6bpvwVpHrcFUQ.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Simple flow diagram for our pipeline</figcaption></figure><p id="369d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了因为我们的 transformer 类继承了 TransformerMixin 类而免费获得的 fit_transform 之外，我们还为我们的 transformer 提供了 get_params 和 set_params 方法，而无需编写它们，因为我们的 transformer 类也继承了 BaseEstimator 类。</p><p id="d25a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些方法会派上用场，因为我们编写转换器的方式允许我们通过为参数(如 use_dates、bath_per_bed 和 years_old)提供不同的参数来操纵数据的预处理方式。仅仅使用简单的乘积规则，我就可以为预处理部分的数据尝试大约 108 个参数组合！我可以使用 set_params 来设置它，而无需重新编写一行代码。由于这个管道的功能类似于任何其他管道，所以我也可以使用 GridSearch 来调优我打算与之一起使用的任何模型的超参数！</p><p id="37eb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是了。现在，您知道了如何在自己的机器上编写自己的全功能定制转换器和管道来自动处理任何类型的数据，使用一点 Python 魔法和 Scikit-Learn 就可以实现这一点。显然还有改进的空间，比如验证数据是否是您期望的形式，在数据到达管道之前来自数据源，并让转换器能够处理和报告意外错误。然而，仅仅使用本文中的工具应该会使您的下一个数据科学项目更有效率，并允许您自动化和并行化一些繁琐的计算。</p><p id="f5d0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我遗漏了什么，或者有什么不准确的地方，或者如果你有任何反馈，请在评论中告诉我。我将非常感激。谢谢你。</p></div></div>    
</body>
</html>