<html>
<head>
<title>All the Steps to Build your first Image Classifier (with code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建第一个图像分类器的所有步骤(带代码)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-steps-to-build-your-first-image-classifier-with-code-cf244b015799?source=collection_archive---------1-----------------------#2019-03-01">https://towardsdatascience.com/all-the-steps-to-build-your-first-image-classifier-with-code-cf244b015799?source=collection_archive---------1-----------------------#2019-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从创建数据集到测试您的程序准确性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/663524e49badabacd827b2f4c1f0c96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lHGdTjx0RMGJjZ16"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@templecerulean?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Temple Cerulean</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="71e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想创建一个图像分类器，但不知道从哪里开始，按照这个快速指南来理解概念，并能够训练一个卷积神经网络来识别任何你想要的图像！</p><p id="9509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，提供的代码是用 Python (3.x)编写的，我们将主要使用 Keras 库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，如果你对什么是神经网络毫无概念，我只能用快速指南鼓励你去发现这个概念。例如，这是我写的最后一篇:</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/first-neural-network-for-beginners-explained-with-code-4cfd37e06eaf"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">第一个为初学者讲解的神经网络(带代码)</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">理解并创造一个感知机</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div><p id="5d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将重点关注卷积神经网络，它保持了关于列和神经元、输入和输出的相同想法，同时简单地添加了一种提取图像中信息的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a98b" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">什么是卷积神经网络？</h2><p id="6133" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这种类型的神经网络由一些操作之前的深度神经网络组成。</p><blockquote class="ns nt nu"><p id="ce4a" class="kz la nv lb b lc ld ju le lf lg jx lh nw lj lk ll nx ln lo lp ny lr ls lt lu im bi translated">O <!-- -->总之，请记住，图像只是一个数字矩阵，如果图像只有灰度级，则为 2 维，如果图像包含颜色，则为 3 维(第三维适用于所有 RGB 级别)。</p></blockquote><p id="229c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，当一个图像被提供给算法时，它首先在初始图像上应用一个小的过滤器，并在图像上的任何地方使用它。这一步称为卷积。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0e7de8a67e0c197106c87d417e45b499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/1*ZCjPUFrB6eHPRi4eyP6aaA.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 1 — Convolution of a 5x5 image by a 3x3 filter</figcaption></figure><p id="d6b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图 1 中，初始图像是绿色的，滤镜是黄色的，并将初始图像的每个数字乘以相应滤镜的数字。</p><p id="4e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个操作之后，一个新的矩阵(红色)被获得。通过将红色矩阵的像素与模型进行比较，程序可以确定在第一图像上是否存在对应于模型的物体。</p><p id="a6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，仅在一行像素上获得大数字意味着初始图像在那里包含一行。</p><p id="7bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步叫做汇集。它是关于取每个区域的最高值，并仅使用那些值形成新的矩阵。它降低了矩阵的空间维数，从而有助于神经网络更快地运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/c33fc788f8846061e57f24bf284aabcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gaD6SJ6kQNVOclE_WkwLNQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 2 — Example of Pooling operation</figcaption></figure><p id="096a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图 2 中，您可以看到图像的维度被分为 4 个部分，每个部分都有其最高值。新形成的图像更小。</p><p id="53b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在该过程中使用激活函数来归一化所有获得的值。在下面的例子中，我们将使用 ReLU。</p><p id="73c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，可以使用最后一个步骤来提高精度，该步骤被称为下降。它迫使神经网络在学习阶段随机禁用一些神经元。我们也将在我们的例子中实现这个函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经知道了卷积的基础，我们可以开始构建一个了！</p><h2 id="b9cd" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">准备数据</h2><p id="6c1e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">只有当你想使用你自己的数据，或者在网上找不到的数据，来建立一个可能更适合你需要的卷积神经网络时，这一部分才是有用的。否则，下面是直接使用来自 Keras 的数据集的代码:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="be63" class="mu mv it oc b gy og oh l oi oj"><strong class="oc iu">from</strong> keras.datasets <strong class="oc iu">import </strong>mnist #replace mnist with any dataset</span><span id="236b" class="mu mv it oc b gy ok oh l oi oj">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span></pre><p id="011a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们简单地调用函数 load_data 来为训练和测试阶段设置数据集。您可以用任何想要使用的数据集替换“mnist”(在两行中都进行更改)。</p><p id="9239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想创建自己的数据集，以下是步骤:</p><p id="8ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你需要收集大量的图像。越多越好。请记住为每个班级保留大约相同数量的图像。例如，对于我的 2D 象棋分类器，每个可能的棋子(和空棋子)有 160 张图像，所以总共大约有<strong class="lb iu">2000 张图像</strong>(这并不多)，但是数据集的大小取决于项目(我的 2D 棋子总是有相同的方面，而猫有许多品种、不同的大小、不同的姿势……)。</p><p id="77fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个强大的工具可以帮助你创建更多的数据，叫做<strong class="lb iu">数据增强</strong>。它只是简单地修改一张图片，然后通过翻转、旋转或裁剪，返回大量新的独特的图片，所有这些都基于第一张图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/8ec2a0ad396bfd6beab07b631659c6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*BV93AI91HhavLQHLSi_NNw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 3 — Example of a folder tree</figcaption></figure><p id="1d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，确保你所有的数据都被分类到一个专门的文件夹中，每个类都有自己的子文件夹。</p><p id="2455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在主文件夹中，我们将创建一个 python 程序来设置所有数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Preparing the data</figcaption></figure><p id="fd4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第 14 行，您可以将列表更改为您需要的任何类，但是保持您之前用于子文件夹的相同名称。</p><p id="3ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在运行程序后，数据被设置在文件中，并准备使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b3e8" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">构建卷积神经网络</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The convolutional neural network</figcaption></figure><p id="88f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您决定使用导入的数据集，将第 9 &amp; 10 行替换为我们之前看到的内容，将第 44 行替换为:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="9585" class="mu mv it oc b gy og oh l oi oj">model.fit(x_train, y_train, batch_size=32, epochs=40, verbose=1, validation_data=(x_test, y_test))</span></pre><p id="7107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在第 37 行</strong>，将<strong class="lb iu"> Dense() </strong>的参数修改为你所拥有的班级数。这是神经网络可能输出的数量。</p><p id="8972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个卷积层，你可以看到我们总是首先加上它的神经元数量和滤波器大小。然后，我们涉及到激活函数，最后使用池化方法。我们还在第 30 行添加了一个 Dropout 来看看如何做。</p><p id="2767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在第一个“正常”隐藏层之前，我们添加了函数<strong class="lb iu"> Flatten() </strong>，该函数将之前卷积的所有信息转换为神经元的输入。在这一点上，剩下的只是包含来自基本神经网络的层和神经元。</p><p id="bbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，你建立了自己的分类器！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a0c2" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">预测图像类别</h2><p id="d46d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">现在，你可以使用你的神经网络来预测任何你想要的图像。简单地写一个包含这几行的小脚本:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="7839" class="mu mv it oc b gy og oh l oi oj"><strong class="oc iu">import </strong>cv2<br/><strong class="oc iu">import </strong>tensorflow <strong class="oc iu">as</strong> tf</span><span id="abf8" class="mu mv it oc b gy ok oh l oi oj">CATEGORIES = ["bishopB", "bishopW", "empty", "kingB", "kingW",<br/>			"knightB", "knightW", "pawnB", "pawnW",<br/>			"queenB", "queenW", "rookB", "rookW"]</span><span id="331d" class="mu mv it oc b gy ok oh l oi oj"><strong class="oc iu">def </strong>prepare(file):<br/>    IMG_SIZE = 50<br/>    img_array = cv2.imread(file, cv2.IMREAD_GRAYSCALE)<br/>    new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))<br/>    return new_array.reshape(-1, IMG_SIZE, IMG_SIZE, 1)</span><span id="f012" class="mu mv it oc b gy ok oh l oi oj">model = tf.keras.models.load_model("CNN.model")<br/>image = "test.jpg" #your image path<br/>prediction = model.predict([image])<br/>prediction = list(prediction[0])<br/>print(CATEGORIES[prediction.index(max(prediction))])</span></pre><p id="0f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数 prepare(file)允许我们使用任何大小的图像，因为它会自动将图像调整到我们在第一个程序中定义的大小。</p><p id="77b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在数据程序中修改了图像尺寸，也请在此处修改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="06ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！您只是构建了适合您自己图像的图像分类器。当然，不要犹豫修改你看到的任何一行代码，因为你的神经网络的准确性可能会根据这些参数而有很大的不同。以下是其中的一部分:</p><ul class=""><li id="849b" class="oo op it lb b lc ld lf lg li oq lm or lq os lu ot ou ov ow bi translated">模型:你可以很容易地在你的神经网络中添加或删除一些层，改变神经元的数量，甚至是激活函数。你有你想要添加的任何东西的模型。</li><li id="a6bf" class="oo op it lb b lc ox lf oy li oz lm pa lq pb lu ot ou ov ow bi translated">数据:获得的精度不是你所期望的？也许你可以添加更多的数据，主要是验证你所有的图像都存储在他们的好文件夹。</li><li id="984f" class="oo op it lb b lc ox lf oy li oz lm pa lq pb lu ot ou ov ow bi translated">IMG 大小:在程序中为数据集定义，它表征了网络将要处理的图像的大小。不要尝试太大的数字，因为高质量的图像会导致更长的训练阶段。此外，即使是著名的数据库，如 MNIST，包含的图像也非常少(MNIST 为 28x28)。不要忘记在最后一个程序中修改整形函数的 IMG 大小。</li><li id="fb0d" class="oo op it lb b lc ox lf oy li oz lm pa lq pb lu ot ou ov ow bi translated">Keras 使用的新参数，如回调。一个叫做“早期停止”的方法可以帮助你提高训练阶段的长度，主要是避免过度适应。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="78ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个指南，我们刚刚够你创建和理解你的第一个卷积神经网络。如果你愿意，还有许多其他参数或方面可以发现，所以不要犹豫，继续前进。</p><blockquote class="pc"><p id="0e9f" class="pd pe it bd pf pg ph pi pj pk pl lu dk translated">感谢阅读！</p><p id="737e" class="pd pe it bd pf pg ph pi pj pk pl lu dk translated">我希望这个小指南有用，如果你有任何问题和/或建议，请在评论中告诉我。</p></blockquote></div></div>    
</body>
</html>