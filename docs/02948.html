<html>
<head>
<title>How To Make Pi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">圆周率怎么做</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-pi-part-1-d0b41a03111f?source=collection_archive---------11-----------------------#2019-05-13">https://towardsdatascience.com/how-to-make-pi-part-1-d0b41a03111f?source=collection_archive---------11-----------------------#2019-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b1ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在今年的圆周率日，艾玛·相户爱·Iwao<a class="ae ko" href="https://www.theverge.com/2019/3/14/18265358/pi-calculation-record-31-trillion-google" rel="noopener ugc nofollow" target="_blank">计算出圆周率</a>为 31 万亿位，使之前 22 万亿位的记录相形见绌。从六年级开始，我就知道圆周率是 3.14 和一些变化。但是我开始想我们是怎么知道的？我们如何制作<em class="kp">圆周率</em>？</p><p id="f1d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算<em class="kp"> pi </em>的位数有很多种方法——可以用随机抽样、几何、微积分等。但是我们为什么要在乎呢？如果你给我<em class="kp"> pi </em>的前 39 位，我可以告诉你一个氢原子内已知宇宙的宽度(具体方法见<a class="ae ko" href="https://www.youtube.com/watch?v=FpyrF_Ci2TQ" rel="noopener ugc nofollow" target="_blank"> Numberphile 的视频</a>)。我们真的需要 31 万亿吗？</p><p id="273e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，不，可能不会。但这并不意味着这没有价值！为了生成这些近似值，我们使用了数学、计算机科学和计算机工程中的许多重要工具。我们需要处理关于浮点运算的准确性的问题，估计和误差界限的问题，以及关于优化的问题。所有这些都是有价值的，即使其他 30，999，999，999，961 个数字没有价值。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="9e07" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">蒙特卡洛方法</h1><p id="2635" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我们将从蒙特卡罗方法开始。这些方法依靠随机抽样来生成数字结果。出于我们的目的，我们将对<em class="kp"> X-Y </em>平面中的点进行采样。我们来看看下图。有一个半径为 1 <a class="ae ko" href="https://en.wikipedia.org/wiki/Inscribed_figure" rel="noopener ugc nofollow" target="_blank">的圆内接在正方形</a>上。这个正方形的边长正好是圆的直径，也就是 2。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/784875ac25923c35c848104777a9a892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-GFdC5OM0ZtYfbfkjjB2w.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">A circle with radius 1 and center (1, 1) inscribed in a square with side length 2</figcaption></figure><p id="b962" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，假设你和我在玩一个游戏。我们随机选取一个<em class="kp"> 0 ≤ x ≤ 2 </em>和<em class="kp"> 0 ≤ y ≤ 2 </em>的点<em class="kp"> (x，y) </em>。如果点在圆圈里，你就赢一美元。否则，我赢一美元。橙色是你赢的地方，蓝色是我赢的地方。你赢得一美元的几率有多大？它是橙色圆圈的面积与总面积的比率。圆的面积是<em class="kp">A = pi</em><em class="kp">r = pi</em><em class="kp">1 = pi</em>总面积是正方形的面积<em class="kp"> A = s = 2 = 4。</em>所以，赔率是(<em class="kp"> pi / 4) </em> ≈ 78.5%。胜算大！</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="0429" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，如果我们取一堆点，看看落在圆内的点的百分比，我们可以估计出<em class="kp"> pi </em>(这里是<a class="ae ko" href="https://www.khanacademy.org/math/statistics-probability/random-variables-stats-library/expected-value-lib/v/law-of-large-numbers" rel="noopener ugc nofollow" target="_blank">为什么</a>)。这种随机抽样正是我们的蒙特卡罗方法。下面的代码采样一千万、一亿和十亿个点来计算<em class="kp">圆周率。</em></p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/ae87e25752fb8a3943d476def2c355ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AU25LmMYHdxbSIVxa1OVYg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">An implementation of the Monte Carlo method using Python. Source code <a class="ae ko" href="https://github.com/andrewjoliver/estimating-pi/blob/master/monte-carlo.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="273f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果如下。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mr"><img src="../Images/99ff3a5c6d01135f477d446cb5c362d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2jNRkuxsnWL-ibXmPdH-g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Monte Carlo method results</figcaption></figure><p id="6efe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那还不算太糟！在我的电脑上，十亿次迭代大约需要半个小时。它给出了对π的估计，只差 0 . 00007<em class="kp">。但是我们远没有产生 31 万亿位的圆周率。幸运的是，我们有很多其他方法可以尝试。</em></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="b070" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">微积分方法</h1><p id="8f46" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我们知道半径为 1 的圆的面积是<em class="kp">A = pi</em><em class="kp">(1)= pi</em>。太好了！让我们计算半径为 1 的圆的面积。但是我们到底如何计算面积呢？我们可以用积分来解决这个问题。看一下下图。它是以<em class="kp"> (0，0) </em>为圆心，半径为 1 的圆的右上部分。这个圆的方程式是<em class="kp"> x + y = 1。</em>然而，<em class="kp"> </em>我们只关心<em class="kp"> x </em>轴上方的部分，因此我们可以将公式重新排列为下方的公式。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/59e290215c4f897e0473c258e39292c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*XhIfGm5vj0rlieg3iSrZpw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">The top right of a circle with radius 1 and center at (0, 0)</figcaption></figure><p id="7ddc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于整个圆的面积是<em class="kp"> pi </em>，那么上面的面积就是<em class="kp"> pi / 4 </em>。我们可以从 0 到 1 积分，结果将是<em class="kp"> pi / 4 </em>。但是，再一次，整合一个函数到底意味着什么？积分源于波恩哈德·黎曼(1826 年)提出的黎曼和。黎曼求和允许我们通过对曲线下的矩形求和来近似积分，如下所示。我们使用的矩形越多，近似值就越好。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mt"><img src="../Images/6102854cccf3934690e1de0ad71a59d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccdjOYNjkup35YhIanV-4Q.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Riemann Sums (Images from <a class="ae ko" href="https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/left-and-right-riemann-sums" rel="noopener ugc nofollow" target="_blank">Khan Academy</a>)</figcaption></figure><p id="9c2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码使用黎曼和的方法来近似我们的圆下面的面积。这个近似值等于<em class="kp"> (pi / 4)。</em>更多关于黎曼和的内容，请看<a class="ae ko" href="https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/v/midpoint-sums" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mu"><img src="../Images/eec89ed562699c9255d27a5ff9a5ab35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AepzO24Mk8LBLaQI-kUkVg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Implementation of the Riemann Sum Method with Python. Source code <a class="ae ko" href="https://github.com/andrewjoliver/estimating-pi/blob/master/riemann-sums.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="5b87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果如下。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mv"><img src="../Images/5b752c493cd74432a5c394cc7038376b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4-dIQCrVt7iqdkjC2yVPg.png"/></div></div></figure><p id="59e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这无疑是对我们以前方法的改进！在相同的迭代次数下，我们为自己多买了几个正确的数字。但是我们可以做得更好。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="4aff" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">无穷级数方法</h1><p id="d041" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">这个无穷和的想法似乎是可行的，所以我们将继续沿着这条路走下去。从三角学我们知道<em class="kp">tan(π/4)= 1</em>。我们现在可以使用反正切函数<em class="kp"> arctan(x) </em>来计算<em class="kp"> arctan(1) = pi / 4 </em>。幸运的是，我们有一个简单易行的公式来计算 arctan(x) 。这种方法也被称为格雷戈里-莱布尼茨系列或马达瓦-格雷戈里系列，以戈特弗里德·莱布尼茨(1646)、詹姆斯·格雷戈里(1638)和桑加玛格拉玛的马达瓦(1340)命名。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mw"><img src="../Images/69202ba3b88995afb91d2b77fd6f1087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpcheXuz0GYmllpfL16o-g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Summation Formula for arctan(x)</figcaption></figure><p id="6024" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以设置<em class="kp"> x = 1 </em>，让下面的代码运行。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mx"><img src="../Images/a23241fc8401433f998520559feb0495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tc8UmU7CPYD0OA4HKoo2Qg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Implementation of the arctan(x) method with Python. Source code <a class="ae ko" href="https://github.com/andrewjoliver/estimating-pi/blob/master/geometry.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="67c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果是朝着正确的方向迈出了一步！对于十亿次迭代，我们得到的数字比积分法多一位。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mv"><img src="../Images/b1158788e3c923b65a9818fea0e125e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7531UefES9ed9u6YhV-GA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Results of arctan(x) method</figcaption></figure><p id="f3ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以继续这种方法，做一些改进，并得到明显更好的结果。一个改进来自约翰·麦金(1706)，他发展了下面的公式。Machin 对这个公式的推导超出了本文的范围，但是可以在这里找到<a class="ae ko" href="https://en.wikipedia.org/wiki/Machin-like_formula" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi my"><img src="../Images/940d6278b5c78228d315ccd1e7b8ee6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*87rcrjV5f0pZF-TYX8XCWQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Machin’s formula for estimating pi</figcaption></figure><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mz"><img src="../Images/bb234a16a98722bfbc6a01beafaf0cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAK19Evrhh5wxH7SRK1nuw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Implementation of Machin’s Formula with Python. Source code <a class="ae ko" href="https://github.com/andrewjoliver/estimating-pi/blob/master/geometry.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="d24f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果如下。确保记下迭代的次数。经过 10 次迭代，我们的估计和上面一样好。我们在第 1 部分中的<a class="ae ko" href="https://medium.com/@andrewjoliver3/how-to-make-pi-part-1-d0b41a03111f" rel="noopener">蒙特卡罗方法花了 10 亿次迭代去做 Machin 公式在第 3 部分所做的事情。</a></p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi na"><img src="../Images/65db094a831a00d5a22a9d666b6f8ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DWdRsWRMQf0UjTJqGOTyw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Results of estimation using Machin’s Formula</figcaption></figure><p id="7b83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，正如你可能猜到的，我们仍然可以做得更好。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="4c4b" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一种改进的无穷级数方法</h1><p id="7089" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我们看到的最后一个无穷级数来自杰出的数学家斯里尼瓦瑟·拉马努金(1887)。Ramanujan 写了两个计算<em class="kp"> pi </em>的公式。Chudnovsky 兄弟，Gregory (1952)和 David (1947)也改进了 Ramanujan 的初始公式。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nb"><img src="../Images/b34f17674d808d0bdbf7e2aa0fc67573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UaXogI7GtGxz-3Q-dvsH_g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Ramanujan’s and Chudnovsky Brothers’ formulae for estimating pi</figcaption></figure><p id="a71e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码是 Chudonovksy 公式的一个实现。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nc"><img src="../Images/37d5cca7afac94742daff344ff08d5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUASqBjcAyKRvtLAxFgU4g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Implementation of Chudnovsky formula with Python. Source code <a class="ae ko" href="https://github.com/andrewjoliver/estimating-pi/blob/master/series.py" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="7378" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">一次</strong>迭代后，该公式将<em class="kp"> pi </em>精确到<strong class="js iu">第 14 位</strong>数字。随着每一次连续的迭代，该公式会生成 14 个以上的正确数字<em class="kp"> pi </em>。经过三次迭代后，我们就可以计算出一个氢原子内宇宙的宽度了。</p><p id="1dcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个公式是每一个现代圆周率计算记录的基础。常见的实现使用的是<a class="ae ko" href="http://www.numberworld.org/y-cruncher/" rel="noopener ugc nofollow" target="_blank"> y-cruncher </a>，这是一个设计用来高效计算<em class="kp"> pi </em>的软件。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="7ce0" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结束语</h1><p id="6987" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我们已经研究了 4 种不同的策略来生成<em class="kp">pi</em>——随机模拟、积分、三角函数和无穷级数。估计问题现在看起来可能微不足道，但那只是因为我们可以在现代笔记本电脑上运行十亿次迭代。在历史上的大部分时间里，找到准确的估计值需要巧妙的公式，而这些公式在计算上并不昂贵。现在只需要 Python 一个半小时。</p><p id="ed00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些只是制作<em class="kp">圆周率</em>的几种方法。如果你想做派，皮尔斯伯里有一篇很棒的文章<a class="ae ko" href="https://www.pillsbury.com/everyday-eats/desserts/pies-tarts/how-to-make-pie" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p></div></div>    
</body>
</html>