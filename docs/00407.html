<html>
<head>
<title>Improve your workflow by managing your machine learning experiments using Sacred</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用 Sacred 管理您的机器学习实验来改进您的工作流程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improve-your-workflow-by-managing-your-machine-learning-experiments-using-sacred-d51dd2b0047e?source=collection_archive---------6-----------------------#2019-01-18">https://towardsdatascience.com/improve-your-workflow-by-managing-your-machine-learning-experiments-using-sacred-d51dd2b0047e?source=collection_archive---------6-----------------------#2019-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cae568bb476cf773dc1384786d0cd05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RAONZCLWlhVb98iG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Me building experiments before using Sacred (Thanks <a class="ae kc" href="https://unsplash.com/@nicolasthomas" rel="noopener ugc nofollow" target="_blank">Nicolas</a> for the pick)</figcaption></figure><p id="f0c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名数据科学家，模型调优是我最不喜欢的任务。我<strong class="kf ir"> <em class="lb">讨厌</em> </strong>它。我想这是因为管理实验总是会变得非常混乱。在寻找帮助我的工具时，我看到很多人提到<a class="ae kc" href="https://github.com/IDSIA/sacred" rel="noopener ugc nofollow" target="_blank">神圣的</a>，所以我决定试一试。</p><p id="ad32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看到<strong class="kf ir">如何使用神圣和全面的</strong>来管理我们的实验。剧透警告:这个工具很棒，现在做实验真的很有趣。</p><h1 id="532f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">神圣是如何工作的？</h1><p id="6af1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们在模型训练脚本中使用神圣的装饰者。就是这样！该工具会自动存储每次运行的实验信息。今天，我们将使用 MongoDB 存储信息，并使用 Omniboard 工具将其可视化。好了，我们开始吧。</p><h1 id="945f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用神圣的</h1><p id="0bd4" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这里有一个逐步指南:</p><ol class=""><li id="f9f4" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">创造一个实验</li><li id="7228" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">定义实验的主要功能</li><li id="7741" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">添加配置参数</li><li id="6d38" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">添加其他指标</li><li id="db67" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">进行实验</li></ol><h2 id="34c6" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">1 —创建一个实验</h2><p id="5a63" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">首先我们需要创建一个实验。很简单:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="3696" class="mt ld iq nk b gy no np l nq nr">from <strong class="nk ir">sacred</strong> import <strong class="nk ir">Experiment</strong></span><span id="362b" class="mt ld iq nk b gy ns np l nq nr"><strong class="nk ir">ex = Experiment("our_experiment")</strong></span></pre><p id="12ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">搞定了。</p><h2 id="35fb" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">2 —定义实验的主要功能</h2><p id="c2fe" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated"><code class="fe nt nu nv nk b">run</code>方法运行实验的主要功能。当我们运行 Python 脚本时，<code class="fe nt nu nv nk b">@ex.automain</code>装饰器定义<em class="lb">并且</em>运行实验的主要功能。它相当于:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="aae0" class="mt ld iq nk b gy no np l nq nr">from sacred import Experiment</span><span id="b771" class="mt ld iq nk b gy ns np l nq nr">ex = Experiment("our_experiment")</span><span id="2dc4" class="mt ld iq nk b gy ns np l nq nr"><strong class="nk ir">@ex.main<br/>def run():<br/>    pass</strong><br/><br/><strong class="nk ir">if __name__ == '__main__':<br/>    ex.run_commandline()</strong></span></pre><p id="13f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用<code class="fe nt nu nv nk b">@ex.automain</code>来代替:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="2a3d" class="mt ld iq nk b gy no np l nq nr">from sacred import Experiment</span><span id="2805" class="mt ld iq nk b gy ns np l nq nr">ex = Experiment("our_experiment")</span><span id="6dde" class="mt ld iq nk b gy ns np l nq nr"><strong class="nk ir">@ex.automain<br/>def run():<br/>    pass</strong></span></pre><h2 id="bd06" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">3-添加配置参数</h2><p id="430b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">每次运行时，配置参数也会存储在数据库中。设置的方式有很多:通过<a class="ae kc" href="https://sacred.readthedocs.io/en/latest/configuration.html#config-scopes" rel="noopener ugc nofollow" target="_blank">配置范围</a>、<a class="ae kc" href="https://sacred.readthedocs.io/en/latest/configuration.html#config-dictionaries" rel="noopener ugc nofollow" target="_blank">字典</a>、<a class="ae kc" href="https://sacred.readthedocs.io/en/latest/configuration.html#config-files" rel="noopener ugc nofollow" target="_blank">配置文件</a>。让我们坚持这里的配置范围。</p><p id="325f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用这个<a class="ae kc" href="https://archive.ics.uci.edu/ml/datasets/online+retail" rel="noopener ugc nofollow" target="_blank">在线零售数据集</a>并使用 scikit-learn 的<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.TimeSeriesSplit.html" rel="noopener ugc nofollow" target="_blank">时间序列交叉验证器</a>来拆分数据。该模型将预测订单是否会被取消。让我们定义<code class="fe nt nu nv nk b">criterion</code>参数:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="2061" class="mt ld iq nk b gy no np l nq nr">from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.model_selection import TimeSeriesSplit<br/>import pandas as pd<br/>from sacred import Experiment </span><span id="5d01" class="mt ld iq nk b gy ns np l nq nr">ex = Experiment('online_retail_tree') </span><span id="3af4" class="mt ld iq nk b gy ns np l nq nr"><strong class="nk ir">@ex.config<br/>def cfg():    <br/>    criterion = "entropy"</strong> </span><span id="72b8" class="mt ld iq nk b gy ns np l nq nr">@ex.automain<br/>def run(<strong class="nk ir">criterion</strong>):    <br/>    dateparse = lambda x: pd.datetime.strptime(x, '%d/%m/%Y %H:%M')</span><span id="f9bb" class="mt ld iq nk b gy ns np l nq nr">    df = pd.read_csv("Online Retail.csv", parse_dates["InvoiceDate"], date_parser=dateparse, decimal=",")</span><span id="621c" class="mt ld iq nk b gy ns np l nq nr">    df = df.sort_values(by="InvoiceDate")    </span><span id="d941" class="mt ld iq nk b gy ns np l nq nr">    df["canceled"] = df["InvoiceNo"].apply(lambda x: x[0] == "C")     </span><span id="27bf" class="mt ld iq nk b gy ns np l nq nr">    X = df.loc[:,["Quantity","UnitPrice"]]    <br/>    y = df.loc[:, ["canceled"]]     </span><span id="fd4f" class="mt ld iq nk b gy ns np l nq nr">    ts_split = TimeSeriesSplit(n_splits=10)     <br/>    <br/>    clf = DecisionTreeClassifier(criterion=criterion)  <br/>   <br/>    for train_index, test_index in ts_split.split(X):        <br/>        X_train = X.iloc[train_index]        <br/>        y_train = y.iloc[train_index]         </span><span id="e383" class="mt ld iq nk b gy ns np l nq nr">        X_test = X.iloc[test_index]        <br/>        y_test = y.iloc[test_index]         </span><span id="8080" class="mt ld iq nk b gy ns np l nq nr">        clf.fit(X_train, y_train.values.ravel())         <br/>        y_pred = clf.predict(X_test)</span></pre><h2 id="5f35" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">4 —添加其他指标</h2><p id="7b5f" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">神圣收集关于实验的信息，但我们通常也想测量其他东西。在我们的例子中，我想知道<strong class="kf ir">每次分割中取消订单的数量</strong>。我们可以为此使用 Metrics API。</p><blockquote class="nw nx ny"><p id="91e6" class="kd ke lb kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">神圣支持使用 Metrics API 跟踪数字序列(例如 int、float)。<code class="fe nt nu nv nk b">_run.log_scalar(metric_name, value, step)</code>方法采用一个度量名称(例如“training.loss”)、测量值和获取该值的迭代步骤。如果未指定步长，则会为每个度量设置一个自动递增 1 的计数器。— <a class="ae kc" href="https://sacred.readthedocs.io/en/latest/collected_information.html#metrics-api" rel="noopener ugc nofollow" target="_blank">指标 API </a></p></blockquote><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="8a37" class="mt ld iq nk b gy no np l nq nr">from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.model_selection import TimeSeriesSplit<br/>import pandas as pd<br/>from sacred import Experiment</span><span id="d0c1" class="mt ld iq nk b gy ns np l nq nr">ex = Experiment('online_retail_tree')</span><span id="3a99" class="mt ld iq nk b gy ns np l nq nr">@ex.config<br/>def cfg():    <br/>    criterion = "entropy"</span><span id="4325" class="mt ld iq nk b gy ns np l nq nr">@ex.automain<br/>def run(criterion):    <br/>    dateparse = lambda x: pd.datetime.strptime(x, '%d/%m/%Y %H:%M')</span><span id="37e0" class="mt ld iq nk b gy ns np l nq nr">    df = pd.read_csv("Online Retail.csv", parse_dates["InvoiceDate"], date_parser=dateparse, decimal=",")</span><span id="874d" class="mt ld iq nk b gy ns np l nq nr">    df = df.sort_values(by="InvoiceDate")</span><span id="97fc" class="mt ld iq nk b gy ns np l nq nr">    df["canceled"] = df["InvoiceNo"].apply(lambda x: x[0] == "C")</span><span id="24fc" class="mt ld iq nk b gy ns np l nq nr">    X = df.loc[:,["Quantity","UnitPrice"]]    <br/>    y = df.loc[:, ["canceled"]]</span><span id="90c2" class="mt ld iq nk b gy ns np l nq nr">    ts_split = TimeSeriesSplit(n_splits=10)     <br/>    <br/>    clf = DecisionTreeClassifier(criterion=criterion)  <br/>   <br/>    for train_index, test_index in ts_split.split(X):        <br/>        X_train = X.iloc[train_index]        <br/>        y_train = y.iloc[train_index]</span><span id="9aba" class="mt ld iq nk b gy ns np l nq nr">        X_test = X.iloc[test_index]        <br/>        y_test = y.iloc[test_index]</span><span id="7f3a" class="mt ld iq nk b gy ns np l nq nr">        clf.fit(X_train, y_train.values.ravel())         <br/>        y_pred = clf.predict(X_test)5 — Running the experiment</span><span id="720d" class="mt ld iq nk b gy ns np l nq nr">        true_cancel_count = y_test["canceled"].value_counts().tolist()[1]  <br/>           <br/>       pred_cancel_count = y_pred.tolist().count(True)  <br/>      <br/>       train_cancel_count = y_train["canceled"].value_counts().tolist()[1]<strong class="nk ir">     </strong></span><span id="8c21" class="mt ld iq nk b gy ns np l nq nr"><strong class="nk ir">       ex.log_scalar("true_cancel_count", true_cancel_count)        <br/>       ex.log_scalar("pred_cancel_count", pred_cancel_count)        <br/>       ex.log_scalar("train_cancel_orders", train_cancel_count)</strong></span></pre><h2 id="0fc5" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">5 —运行实验</h2><p id="d50f" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们将使用 MongoDB Observer 来存储关于实验的信息:</p><blockquote class="nw nx ny"><p id="d3ec" class="kd ke lb kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">神圣通过为你的实验提供一个<em class="iq">观察者界面</em>来帮助你。通过附加一个观察器，您可以收集关于运行的所有信息，即使它还在运行。— <a class="ae kc" href="https://sacred.readthedocs.io/en/latest/observers.html#observing-an-experiment" rel="noopener ugc nofollow" target="_blank">观察实验</a></p></blockquote><p id="5864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将数据保存到名为 my_database 的 mongo 数据库中，我们只需运行<code class="fe nt nu nv nk b">python3 my_experiment.py -m my_database</code>。</p><p id="7893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有了关于实验的数据，但我们需要将它可视化。为此，我们将使用<a class="ae kc" href="https://github.com/vivekratnavel/omniboard" rel="noopener ugc nofollow" target="_blank">综合</a>。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="c39e" class="lc ld iq bd le lf oj lh li lj ok ll lm ln ol lp lq lr om lt lu lv on lx ly lz bi translated">使用 OMNIBOARD</h1><p id="4e16" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Omniboard 是用 React，Node.js，Express 和 Bootstrap 写的一个神圣的仪表盘。</p><p id="e7e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，运行<code class="fe nt nu nv nk b">npm install -g omniboard</code>，并开始我们运行<code class="fe nt nu nv nk b">omniboard -m hostname:port:database</code>，在我们的例子中:<code class="fe nt nu nv nk b">omniboard -m localhost:27017:my_database</code>。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/ed1c6a004643cb30f4e74bc6456da600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJxf-V19pLUuy0wl-ynKMg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Omniboard listing our experiments</figcaption></figure><p id="24e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到一个实验是否失败，实验持续时间，添加注释等等。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/5dac6654c5eed8f59a5bad644824f505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaEpH7aIEURuz4Iw8WU9UA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Detailed view of an experiment</figcaption></figure><p id="306c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">detail 视图显示了我们跟踪的指标的图表，我们还可以查看命令行输出、源代码(awesome)和其他实验细节。</p><h1 id="2677" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">那又怎样？</h1><p id="84d4" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">神圣是一个伟大的工具，因为<strong class="kf ir">现在我们不必担心保存我们的实验结果</strong>。一切都被自动存储，我们可以回去分析任何实验。</p><p id="e04c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个工具被设计成<strong class="kf ir">只引入最小的开销</strong>，在我看来这就是它的伟大之处。</p><p id="a05a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的主要信息是:<strong class="kf ir">给神圣一个尝试</strong>！我可以说我现在的工作流程因为它好了很多。🙂</p><p id="2075" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了同样的目的，你使用另一个工具吗？我也想听听其他替代方案。感谢您的阅读！</p></div></div>    
</body>
</html>