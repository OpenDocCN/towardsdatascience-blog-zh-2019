<html>
<head>
<title>Improve data quality by using the pandas library and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用 pandas 库和 Python 提高数据质量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improve-data-quality-by-using-the-pandas-library-and-python-34fda752a6b5?source=collection_archive---------15-----------------------#2019-07-15">https://towardsdatascience.com/improve-data-quality-by-using-the-pandas-library-and-python-34fda752a6b5?source=collection_archive---------15-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/999f5cbc5395b1dd1204d5c3a86968c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkSj3_rxsi-4T0q7cPr4VA.jpeg"/></div></div></figure><div class=""/><p id="1a8d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">数据质量</em>是一个具有多个维度的宽泛概念。我在<a class="ae la" rel="noopener" target="_blank" href="/data-demystified-data-quality-d8c699b678a2">的另一篇介绍性文章</a>中详细介绍了这一信息。本教程探索了一个真实的例子。我们确定我们想要改进什么，创建代码来实现我们的目标，并以一些关于现实生活中可能发生的事情的评论结束。要继续学习，您需要对<a class="ae la" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>有一个基本的了解。</p><h1 id="969b" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">熊猫图书馆</h1><p id="00f4" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">Python 数据分析库(<a class="ae la" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>)是一个开源的、BSD 许可的库，它为 Python 编程语言提供了高性能、易于使用的数据结构和数据分析工具。</p><p id="5519" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以通过在命令行中输入以下代码来安装 pandas:python 3-m pip install—upgrade pandas。</p><p id="ae63" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">pandas 中有两种主要的数据结构:</p><ul class=""><li id="a414" class="me mf je kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><strong class="kd jf">系列。</strong>可以包含任何类型数据的单个列。</li><li id="74a8" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf">数据帧。</strong>具有行和命名列的关系数据表。</li></ul><p id="8213" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据帧包含一个或多个系列以及每个系列的名称。数据帧是通常用于数据操作的抽象或复杂性管理器。</p><h1 id="d8fb" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">系列结构</h1><p id="92b9" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">系列就像是字典和列表的混合体。物品按顺序存放，并贴上标签，以便您可以检索。序列列表中的第一项是特殊索引，它很像一个字典键。第二项是你的实际数据。需要注意的是，每个数据列都有自己的索引标签。您可以通过使用。名称属性。这部分结构不同于字典，它对于合并多列数据很有用。</p><p id="ade7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个简单的例子向您展示了一个系列是什么样子的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1ccb" class="nb lc je mx b gy nc nd l ne nf">import pandas as pd<strong class="mx jf"><br/>carbs = [‘pizza’, ‘hamburger‘, ‘rice’]<br/>pd.Series(carbs)</strong></span><span id="4b02" class="nb lc je mx b gy ng nd l ne nf">0     ‘pizza’<br/>1     ‘hamburger’<br/>2     ‘rice’</span><span id="7e04" class="nb lc je mx b gy ng nd l ne nf">dType: object</span></pre><p id="6966" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以创建带有标签属性的系列:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="45a4" class="nb lc je mx b gy nc nd l ne nf"><strong class="mx jf">foods = pd.Series( [‘pizza’, ‘hamburger’, ‘rice’], index=[‘Italy’, ‘USA’, ‘Japan’]</strong></span><span id="cff9" class="nb lc je mx b gy ng nd l ne nf">Italy     ‘pizza’<br/>USA       ‘hamburger’<br/>Japan     ‘rice’</span><span id="f277" class="nb lc je mx b gy ng nd l ne nf">dType: object</span></pre><h1 id="8a1b" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查询系列</h1><p id="0bfd" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">您可以通过索引位置或索引标签来查询序列。如果不为系列指定索引，则位置和标签具有相同的值。要按数字位置进行查询，请使用 iloc 属性。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9a07" class="nb lc je mx b gy nc nd l ne nf"><strong class="mx jf">foods.iloc[2]</strong><br/>‘rice’</span></pre><p id="e002" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要通过索引标签进行查询，请使用 loc 属性。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4016" class="nb lc je mx b gy nc nd l ne nf"><strong class="mx jf">foods.loc[‘USA’]</strong><br/>‘hamburger’</span></pre><p id="3edc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请记住，一个键可以返回多个结果。这个例子展示了基础知识。还有许多其他系列主题，如矢量化、内存管理等。但我们不会在本文中深入探讨。</p><h1 id="dc64" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据帧结构</h1><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/3592d2a1a17978734fa3619368cec9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WB6lJ0Fe-K-xDXT_Yo0RaA.jpeg"/></div></div></figure><p id="be84" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据框架是熊猫图书馆的主要结构。它是您在数据分析和清理任务中工作的主要对象。</p><p id="cbe3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从概念上讲，DataFrame 是一个二维序列对象。它有一个索引和多列内容，每一列都有标签。但是列和行之间的区别只是概念上的。将 DataFrame 想象成一个双轴标签数组。</p><p id="a12d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用<strong class="kd jf">系列</strong>创建如下数据帧表:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="50ba" class="nb lc je mx b gy nc nd l ne nf">purchase_1  = pd.Series({ ‘Name’: ‘John’, ‘Ordered’:’Pizza’, ‘Cost’: 11 })<br/>purchase_2  = pd.Series({ ‘Name’: ‘Mary’, ‘Ordered’:’Brioche’, ‘Cost’: 21.20 })<br/>purchase_3  = pd.Series({ ‘Name’: ‘Timothy’, ‘Ordered’:’Steak’, ‘Cost’: 30.00 })</span><span id="6a86" class="nb lc je mx b gy ng nd l ne nf"><strong class="mx jf">df = pd.DataFrame([purchase_1, purchase_2, purchase_3], index=[‘Restaurant 1’, ‘Restaurant 1’, ‘Restaurant 2’])</strong></span><span id="97af" class="nb lc je mx b gy ng nd l ne nf">+--------------+-------+---------+---------+<br/>|              | Cost  | Ordered |  Name   |<br/>+--------------+-------+---------+---------+<br/>| Restaurant 1 |    11 | Pizza   | John    |<br/>| Restaurant 1 | 21.20 | Brioche | Mary    |<br/>| Restaurant 2 | 30.00 | Steak   | Timothy |<br/>+--------------+-------+---------+---------+</span></pre><p id="b249" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和 Series 一样，我们可以通过使用<strong class="kd jf"> iloc </strong>和<strong class="kd jf"> loc </strong>属性来提取数据。数据帧是二维的。因此，当我们向 loc 传递单个值时，如果只有一行要返回，那么索引操作符将返回一个序列。</p><p id="2b40" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们查询这个数据帧。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cc9c" class="nb lc je mx b gy nc nd l ne nf"><strong class="mx jf">df.loc[‘Restaurant 2’]</strong></span><span id="d727" class="nb lc je mx b gy ng nd l ne nf">Cost         30.00<br/>Ordered   ‘Steak’<br/>Name       ‘Timothy’</span></pre><p id="df2a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数返回一个 Series 类型的对象。</p><p id="d654" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">pandas DataFrame 的一个强大特性是，您可以基于多个轴快速选择数据。因为 iloc 和 loc 用于行选择，pandas 开发人员直接在数据帧上为列选择保留了索引操作符。在数据帧中，列总是有一个名称。所以这个选择总是基于标签的。</p><p id="f069" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们可以用以下代码重写所有餐馆 1 成本的查询:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d5cb" class="nb lc je mx b gy nc nd l ne nf"><strong class="mx jf">df.loc[‘Restaurant 1’][‘Cost’]</strong></span><span id="1732" class="nb lc je mx b gy ng nd l ne nf">Restaurant 1    11<br/>Restaurant 1    21.20</span><span id="b1e5" class="nb lc je mx b gy ng nd l ne nf">Name: Cost, dType: float64</span></pre><h1 id="4dce" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">表演时间到了。</h1><p id="c92d" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">现在我们处理一个简单但常见的数据问题:缺少值。在<a class="ae la" rel="noopener" target="_blank" href="/data-demystified-data-quality-d8c699b678a2">数据去神秘化——数据质量</a>，<strong class="kd jf"> </strong>中，我解释了为什么完整性是评估数据质量时要考虑的因素之一。缺失数据还可能与另外两个方面有关:缺乏准确性或一致性。还有很多东西需要学习，但是我想直接跳到一个例子，并随着我们的进行引入新的概念。</p><p id="9947" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以从任何来源读取大型数据集。一些例子是关系数据库、文件和 NoSQL 数据库。这个库示例展示了一组与关系数据库交互的方法:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="401d" class="nb lc je mx b gy nc nd l ne nf">import pandas.io.sql as psql</span></pre><p id="98e2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<strong class="kd jf"> connect </strong>和<strong class="kd jf"> read_sql </strong>是关键方法。</p><p id="603c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了简单起见，我们将使用 CSV 文件。假设我们有一个存储在 logs.csv 中的日志文件，该日志每隔 100 毫秒存储一次鼠标指针的位置。如果鼠标没有变化，算法会存储一个空值，但会向该行添加一个新条目。为什么？因为如果信息没有改变，通过网络发送这些信息是没有效率的。</p><p id="ebe5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的目标是用正确的坐标存储 CSV 文件中的所有行。如下表所示，我们可以用以下代码存储这些行:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e769" class="nb lc je mx b gy nc nd l ne nf">df = pd.read_csv(‘logs.csv’)<br/>df</span><span id="8d95" class="nb lc je mx b gy ng nd l ne nf">+----+-----------+---------+---------+-----+-----+<br/>|    | timestamp |  page   |  user   |  x  |  y  |<br/>+----+-----------+---------+---------+-----+-----+<br/>|  0 | 169971476 | landing | admin   | 744 | 220 |<br/>|  1 | 169971576 | landing | admin   | NaN | NaN |<br/>|  2 | 169971591 | profile | maryb   | 321 | 774 |<br/>|  3 | 169971691 | profile | maryb   | NaN | NaN |<br/>|  4 | 169972003 | landing | joshf   | 432 | 553 |<br/>|  5 | 169971776 | landing | admin   | 722 | 459 |<br/>|  6 | 169971876 | landing | admin   | NaN | NaN |<br/>|  7 | 169971891 | profile | maryb   | 221 | 333 |<br/>|  8 | 169971976 | landing | admin   | NaN | NaN |<br/>|  9 | 169971991 | profile | maryb   | NaN | NaN |<br/>| 10 | 169972003 | landing | johnive | 312 | 3   |<br/>| 11 | 169971791 | profile | maryb   | NaN | NaN |<br/>| 12 | 169971676 | landing | admin   | NaN | NaN |<br/>+----+-----------+---------+---------+-----+-----+</span></pre><p id="304c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们检查数据时，我们发现了多个问题。有许多空值，并且文件不是按时间戳排序的。这个问题在高度并行的系统中很常见。</p><p id="08f4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以处理空数据的一个函数是 fillna。更多信息请输入 df.fillna？在命令行中。使用这种方法有许多选项:</p><ul class=""><li id="fefc" class="me mf je kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">一种选择是传入单个<em class="kz">标量</em>值，将所有丢失的数据都变成一个值。但是这种改变不是我们想要的。</li><li id="d74c" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">另一个选择是传递一个<em class="kz">方法</em>参数。两个常见的值是 ffill 和 bfill。ffill 向前填充单元格。它使用前一行中的值更新单元格中的 NaN 值。为了使此更新有意义，您的数据需要按顺序排序。但是传统的数据库管理系统通常不能保证你从中提取的数据的顺序。</li></ul><p id="9e71" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，我们先把数据整理一下。我们可以按索引或值排序。在这个例子中，时间戳是索引，我们对<em class="kz">索引</em>字段进行排序:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8a6c" class="nb lc je mx b gy nc nd l ne nf">df = df.set_index(‘timestamp’)<br/>df = df.sort_index()</span></pre><p id="651c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了下表:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7cef" class="nb lc je mx b gy nc nd l ne nf">+-----------+---------+---------+-----+-----+<br/>|           |  page   |  user   |  x  |  y  |<br/>+-----------+---------+---------+-----+-----+<br/>| time      |         |         |     |     |<br/>| 169971476 | landing | admin   | 744 | 220 |<br/>| 169971576 | landing | admin   | NaN | NaN |<br/>| 169971591 | profile | maryb   | 321 | 774 |<br/>| 169971676 | landing | admin   | NaN | NaN |<br/>| 169971691 | profile | maryb   | NaN | NaN |<br/>| 169971776 | landing | admin   | 722 | 459 |<br/>| 169971791 | profile | maryb   | NaN | NaN |<br/>| 169971876 | landing | admin   | NaN | NaN |<br/>| 169971891 | profile | maryb   | 221 | 333 |<br/>| 169971976 | landing | admin   | NaN | NaN |<br/>| 169971991 | profile | maryb   | NaN | NaN |<br/>| 169972003 | landing | johnive | 312 | 3   |<br/>| 169972003 | landing | joshf   | 432 | 553 |<br/>+-----------+---------+---------+-----+-----+</span></pre><p id="6123" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，还有一个问题。我们的时间戳不是唯一的。两个用户可能同时与平台交互。</p><p id="c2bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重置索引，并使用时间戳和用户名创建一个复合索引:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8803" class="nb lc je mx b gy nc nd l ne nf">df = df.reset_index()<br/>df = df.set_index([‘timestamp’, ‘user’])<br/>df</span></pre><p id="8727" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了下表:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5a6b" class="nb lc je mx b gy nc nd l ne nf">+-----------+---------+---------+-----+-----+<br/>|           |         |  page   |  x  |  y  |<br/>+-----------+---------+---------+-----+-----+<br/>| time      | user    |         |     |     |<br/>| 169971476 | admin   | landing | 744 | 220 |<br/>| 169971576 | admin   | landing | NaN | NaN |<br/>| 169971676 | admin   | landing | NaN | NaN |<br/>| 169971776 | admin   | landing | 722 | 459 |<br/>| 169971876 | admin   | landing | NaN | NaN |<br/>| 169971976 | admin   | landing | NaN | NaN |<br/>| 169971591 | maryb   | profile | 321 | 774 |<br/>| 169971691 | maryb   | profile | NaN | NaN |<br/>| 169971791 | maryb   | profile | NaN | NaN |<br/>| 169971891 | maryb   | profile | 221 | 333 |<br/>| 169971991 | maryb   | profile | NaN | NaN |<br/>| 169972003 | johnive | landing | 312 | 3   |<br/>|           | joshf   | landing | 432 | 553 |<br/>+-----------+---------+---------+-----+-----+</span></pre><p id="db08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以用<strong class="kd jf"> ffill </strong>来填充缺失的数据:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1fd9" class="nb lc je mx b gy nc nd l ne nf"><strong class="mx jf">df = df.fillna(method='ffill')</strong></span></pre><p id="8b89" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下表显示了结果:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c935" class="nb lc je mx b gy nc nd l ne nf">+-----------+---------+---------+-----+-----+<br/>|           |         |  page   |  x  |  y  |<br/>+-----------+---------+---------+-----+-----+<br/>| time      | user    |         |     |     |<br/>| 169971476 | admin   | landing | 744 | 220 |<br/>| 169971576 | admin   | landing | 744 | 220 |<br/>| 169971676 | admin   | landing | 744 | 220 |<br/>| 169971776 | admin   | landing | 722 | 459 |<br/>| 169971876 | admin   | landing | 722 | 459 |<br/>| 169971976 | admin   | landing | 722 | 459 |<br/>| 169971591 | maryb   | profile | 321 | 774 |<br/>| 169971691 | maryb   | profile | 321 | 774 |<br/>| 169971791 | maryb   | profile | 321 | 774 |<br/>| 169971891 | maryb   | profile | 221 | 333 |<br/>| 169971991 | maryb   | profile | 221 | 333 |<br/>| 169972003 | johnive | landing | 312 |   3 |<br/>|           | joshf   | landing | 432 | 553 |<br/>+-----------+---------+---------+-----+-----+</span></pre><h1 id="80ab" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">熊猫大战 PostgreSQL</h1><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8d8dc98d0bd99f0b87fb20b91567adbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OysYAX2YA0VBzhWA3Magtg.jpeg"/></div></div></figure><p id="cff7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">熊猫胜过 PostgreSQL。对于大型数据集，它的运行速度要快 5 到 10 倍。PostgreSQL 唯一表现更好的时候是在小数据集上，通常少于一千行。在 pandas 中选择列是高效的，时间为 O(1)。这是因为数据帧存储在内存中。</p><p id="9221" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于同样的原因，pandas 也有局限性，仍然需要 SQL。熊猫的数据存储在内存中。所以很难加载大于系统内存一半的 CSV 文件。数据集通常包含数百列，这为超过一百万行的数据集创建了大约 10 GB 的文件大小。</p><p id="0cb3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">PostgreSQL 和 pandas 是两种不同的工具，具有重叠的功能。创建 PostgreSQL 和其他基于 SQL 的语言是为了管理数据库。它们使用户能够轻松地访问和检索数据，尤其是跨多个表的数据。</p><ul class=""><li id="a066" class="me mf je kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">运行 PostgreSQL 的服务器将所有数据集存储为系统中的表。对于用户来说，将所需的表传输到他们的系统，然后使用 pandas 在客户端执行像 join 和 group 这样的任务是不现实的。</li><li id="c088" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">熊猫的专长是数据处理和复杂的数据分析操作。</li></ul><p id="8a70" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种工具在技术市场上并不竞争。相反，它们增加了数据科学计算堆栈中可用的工具范围。</p><h1 id="7940" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">额外小费</h1><p id="e3a6" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">pandas 团队最近引入了一种方法，用与数据帧长度相同的序列来填充缺失值。使用这种新方法，如果需要的话，很容易得到缺失的值。</p><h1 id="b117" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><p id="fcc8" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">Fox，D. (2018)，<a class="ae la" href="https://blog.thedataincubator.com/2018/01/pandas-vs-postgresql/" rel="noopener ugc nofollow" target="_blank">用 pandas 和 PostgreSQL 操纵数据:哪个更好？</a>、<em class="kz">数据孵化器</em>。</p><p id="bd60" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">熊猫(2019)，<a class="ae la" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Python 数据分析库</a>。</p></div></div>    
</body>
</html>