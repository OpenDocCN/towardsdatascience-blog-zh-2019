<html>
<head>
<title>Creating Web Applications with D3 Observable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 D3 Observable 创建 Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-web-applications-with-d3-observable-d5c53467ff12?source=collection_archive---------11-----------------------#2019-07-16">https://towardsdatascience.com/creating-web-applications-with-d3-observable-d5c53467ff12?source=collection_archive---------11-----------------------#2019-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cf4c140aadc86ba5e7d42949f3a299a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyp5sKQbJOLECunrOO7JaA.png"/></div></div></figure><h1 id="1f05" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是 D3 可观测？</h1><p id="620a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我以前写过关于将 D3 引入 web 应用程序的文章<a class="ae lu" rel="noopener" target="_blank" href="/combining-d3-with-kedion-graduating-from-toy-visuals-to-real-applications-92bf7c3cc713">这里</a>，看看如何将 D3 视觉效果绑定到 UI 元素。目的是鼓励超越独立的视觉效果，让人们原型化更完整的应用程序。真正的应用程序会征求反馈，因为它们使用了<em class="lv"/>，帮助我们验证超出常规统计方法的分析。在我看来，如果你没有在构建一个真正的产品，你就没有真正在学习/做数据科学。</p><p id="f77d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">前一篇文章仍然有效，但是 D3 正朝着它所谓的<strong class="ky ir">可观察</strong>(正式名称为 d3.express)的方向转变。Observable 提供了一个各种各样的游乐场，允许用户在一个<em class="lv">笔记本</em>中在线修改 D3 代码。对于那些使用 Jupyter 笔记本的人来说，你会发现体验是相似的。它本质上是一个做 D3 的 REPL。</p><p id="1105" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Observable 向真正的开发开放了 D3，因为它现在提供了<em class="lv">下载您定制的 D3 visual 作为一个独立的“包”</em>(一个 tarball 文件)，您可以将它嵌入到您的应用程序中。Observable 自带<a class="ae lu" href="https://github.com/observablehq/runtime" rel="noopener ugc nofollow" target="_blank">运行时</a>和<a class="ae lu" href="https://github.com/observablehq/stdlib" rel="noopener ugc nofollow" target="_blank">标准库</a>，为使用<strong class="ky ir"> HTML </strong>、<strong class="ky ir"> SVG </strong>、<strong class="ky ir">生成器</strong>、<strong class="ky ir">文件</strong>和<strong class="ky ir">承诺</strong>提供了有用的功能。</p><p id="6712" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">以下是可观察到的<strong class="ky ir">文档</strong>:</p><div class="mb mc gp gr md me"><a href="https://observablehq.com/@observablehq/user-manual" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">可观察:用户手册</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">可观察:用户手册👋欢迎来到 Observable -网络神奇笔记本之家！有很多东西要学…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">observablehq.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms jw me"/></div></div></a></div><p id="a4b9" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">…以及一篇关于他们方法的自以为是的文章:</p><div class="mb mc gp gr md me"><a href="https://medium.com/@mbostock/a-better-way-to-code-2b1d2876a3a0" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">更好的编码方式</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">介绍 d3.express:集成发现环境。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="mt l mp mq mr mn ms jw me"/></div></div></a></div><p id="86ba" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">你可以在这里找到<strong class="ky ir">视觉效果</strong> <a class="ae lu" href="https://observablehq.com/" rel="noopener ugc nofollow" target="_blank">的例子，你可以立即在你的浏览器中开始玩。当您希望创建新的可视化效果时，请访问以下网站，选择一个项目，根据需要编辑可视化效果，并嵌入到您的应用程序中。</a></p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/4fe96f08766c45f2c1b2dee5c1dcf3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fwlCeQz9e750yqS_aB-Fw.png"/></div></div></figure><h1 id="0e14" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概观</h1><p id="93c5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我们将探讨以下主题:</p><ul class=""><li id="c696" class="mz na iq ky b kz lw ld lx lh nb ll nc lp nd lt ne nf ng nh bi translated">创建一个快速的应用程序<strong class="ky ir">布局</strong>基于 2 个简单的样机；</li><li id="3913" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">为我们的应用程序的 UI 元素制作组件；</li><li id="abcd" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated"><strong class="ky ir">在我们的 app 内嵌入</strong> <strong class="ky ir">可观察</strong>；</li><li id="6ac1" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated"><strong class="ky ir">在我们的 app 和 Observable 之间发送</strong> <strong class="ky ir">数据</strong>；</li><li id="a5c6" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">使用<strong class="ky ir">谷歌的图书 API </strong>。</li></ul><p id="546d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">你可以在这里查看简单应用<a class="ae lu" href="https://collaboratescience.com/stack/medium/d3_obs_medium/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/54a92abd382ad941530202c1a828b2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*kuXqBXK3sy0n8Pxz3M7lwA.gif"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 1</figcaption></figure><p id="6db4" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们开始吧。</p><h1 id="6248" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">应用程序</h1><p id="c680" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们制作一个简单的应用程序，它使用 Kaggle 上托管的<a class="ae lu" href="https://www.kaggle.com/jealousleopard/goodreadsbooks" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Goodreads 数据集</strong> </a>来允许人们探索书名。数据集列出了书名、作者、ISBNs 和一些简单的特性，比如评级。</p><h2 id="36d6" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">模型</h2><p id="427c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将允许用户查看原始数据的表格，并提供过滤功能，以便用户可以通过<strong class="ky ir">作者</strong>、<strong class="ky ir"> ISBN </strong>号和<strong class="ky ir">语言</strong>来搜索表格。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/11dff7a86cb002196bf5180b6d67f36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HD6_4fJB5K2BOV5ylzX8Cw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 2</figcaption></figure><p id="af84" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们还将从<a class="ae lu" href="https://developers.google.com/books/" rel="noopener ugc nofollow" target="_blank">谷歌的图书 API </a>中获取图书属性，并在条形图中展示它们。该 API 还提供了所选图书的图片 URL，因此当用户通过 ISBN 搜索时，我们将显示图书封面:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/6aff88684d25d816c19124816f165e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAVF6_M2SVBUa4P36tlbuA.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 3</figcaption></figure><p id="ea6a" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们将使用<a class="ae lu" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> Azle </a>把 Observable 和 Google 的 Book API 缝合成一个真正的应用程序。</p><h2 id="c991" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">目录结构</h2><p id="89b9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们首先为我们的应用程序创建下面的<strong class="ky ir">目录结构</strong>:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="b213" class="ns jz iq oh b gy ol om l on oo"><strong class="oh ir">app</strong><br/>├── <strong class="oh ir">data<br/></strong>├── <strong class="oh ir">scripts<br/></strong>├── <strong class="oh ir">d3_visuals<br/>  </strong>── <strong class="oh ir">table<br/>  </strong>── <strong class="oh ir">bar_chart<br/></strong>├── <!-- -->index.html</span></pre><p id="aa5c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">粗体名称是空文件夹，index.html 文件是通常的 Azle 起点:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 1</figcaption></figure><p id="b3ff" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们将在本文中添加所需的文件。现在<strong class="ky ir">通过在终端会话中运行以下命令，在<strong class="ky ir"> app </strong>文件夹中启动一个简单的 web 服务器</strong>:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="5352" class="ns jz iq oh b gy ol om l on oo">python3 -m http.server</span></pre><p id="2005" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">…然后将您的浏览器指向<strong class="ky ir">本地主机</strong>:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="ab33" class="ns jz iq oh b gy ol om l on oo"><a class="ae lu" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></span></pre><h1 id="0c79" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤 1:创建应用程序布局</h1><p id="a9ef" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我将使用 Azle 来创建我的应用程序的框架。我创建 Azle 是因为它使用快速、易于理解、轻量级、灵活且免费，并且使得将库和框架缝合在一起变得容易。但是你可以使用任何你喜欢的 JS 工具。</p><h2 id="ed11" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">1.1 创建应用程序布局</h2><p id="c390" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们使用 Azle 的<strong class="ky ir"> az.add_layout </strong>函数创建布局。这就是我们如何在页面上创建网格。我将把我的布局代码放在 Azle 的 index.html 文件中:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 2</figcaption></figure><p id="e6a3" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">通读上面的代码，你可以很容易地知道页面是如何构建的。每个 Azle 函数都带一个“<strong class="ky ir"> target_class </strong>和<strong class="ky ir"> target_instance </strong>来向 DOM 添加元素。它还接受一个具有<em class="lv">属性</em>的对象。如果我们添加一个元素，它是一个<strong class="ky ir">内容对象</strong>，如果我们设计一个元素，它是一个<strong class="ky ir">样式对象</strong>(通常的 CSS 样式)。</p><p id="b145" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">上述代码产生以下内容:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/8f56566fb4f51d635b932bb7cb1558ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps2Y_YGRSRU6YseUXV91Xw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 4</figcaption></figure><p id="d5a1" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们可以看到布局如何允许我们通过在屏幕上划分区域来定位元素。让我们给我们的主体部分涂上颜色，这样它就能和身体的颜色融为一体了。我们将通常的 CSS 样式作为属性传递给样式对象:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="3226" class="ns jz iq oh b gy ol om l on oo"><strong class="oh ir">az</strong>.<strong class="oh ir">style_sections</strong>('my_sections', 1, {<br/>  "background": "rgb(51, 47, 47)",<br/>  "height": "auto"<br/> })</span></pre><p id="d185" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们也添加一个深色的背景，我们的视觉 _ 布局:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="9254" class="ns jz iq oh b gy ol om l on oo"><strong class="oh ir">az.style_layout</strong>('visual_layout', 1, {<br/>  "align": "center",<br/>  <strong class="oh ir">"background": "rgb(39, 36, 36)"</strong>,<br/>  "border-radius": "4px",<br/>  "height": "460px",<br/>  "margin-top": "10px",<br/>  "column_widths": ['65%', '35%'],<br/>  "border": 3<br/> })</span></pre><p id="c280" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在我们的应用程序看起来像这样:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/aaac5a3e2b54c538ffedad43add0c1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c_9VJZ00tcZvPafsoR33A.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 5</figcaption></figure><p id="2e6b" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们所有的布局单元格都在等待它们的内容。这就是组件出现的地方。</p><h2 id="fb96" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">1.2 创建应用程序组件</h2><p id="543c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">组件由 UI <strong class="ky ir">元素</strong>、<strong class="ky ir">样式</strong>和<strong class="ky ir">事件</strong>组合而成。这就像将创建应用程序特定部分所需的所有代码打包在一起。例如，如果我们想在我们的应用程序中有一个日历，我们将创建一个日历组件，并将其放置在我们的布局单元格之一。</p><p id="a5af" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">创建组件使我们的代码模块化，易于重用，易于维护，并使我们能够在想法改变时更容易地调整应用程序。虽然我们将在 Azle 中创建我们的组件，但这些也可能是添加到 Azle 布局中的<a class="ae lu" href="https://reactjs.org/docs/add-react-to-a-website.html" rel="noopener ugc nofollow" target="_blank"> React </a>组件。</p><p id="0132" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">从上面的模型中，我们知道我们需要搜索栏、图标、下拉菜单、图像和 D3 视觉效果。展示我们如何为这个应用程序创建每个组件超出了本文的范围。你可以在这里查看<strong class="ky ir">完整应用代码</strong> <a class="ae lu" href="https://github.com/sean-mcclure/book_searcher" rel="noopener ugc nofollow" target="_blank">。我们将在本文中创建几个主要的。</a></p><p id="d404" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们将所有组件代码放在<strong class="ky ir"> az.components </strong>对象中:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="248c" class="ns jz iq oh b gy ol om l on oo">az.components = {</span><span id="9535" class="ns jz iq oh b gy ot om l on oo">}</span></pre><p id="02f1" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">创建一个名为<strong class="ky ir"> component.js </strong>的文件，并添加以下代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 3</figcaption></figure><p id="ec1d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">看起来很多，但读起来很容易。注意我们如何首先添加和样式化一个<strong class="ky ir">布局</strong>，就像我们上面做的一样，这一次是为了保存我们的输入框和搜索图标。然后，我们将一个<strong class="ky ir">输入</strong>元素添加到第一个布局单元格中，并将搜索<strong class="ky ir">图标</strong>添加到第二个布局单元格中。最后，我们将一个<strong class="ky ir">事件</strong>添加到我们的搜索图标中，这样当用户点击它时，就会发生一些事情。</p><p id="0904" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">不要担心在我们的点击事件中发生的所有事情，我们会在嵌入 D3 视觉效果后解决这些问题。现在让我们创建组件，为我们的应用程序添加 D3 视觉效果。下面是<strong class="ky ir">表</strong>的例子:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 4</figcaption></figure><p id="351f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">它看起来有点<em class="lv">回调地狱</em>，但它是可读的。我们添加并样式化一个 iframe，等待 iframe 完成加载，确保完整的数据集可用，然后将我们的消息发送到 iframe。消息发布是我们与 D3 交流的方式。我们将在下一节讨论这一点。</p><p id="d207" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">添加组件的方式与 Azle 向应用程序添加元素的方式相同:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="c971" class="ns jz iq oh b gy ol om l on oo"><strong class="oh ir">az.components.d3_table</strong>(target_class, target_instance)</span></pre><p id="cb62" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">因此，上面的代码行将我们的 iframe 添加到我们的应用程序框架的一个单元中。这些框架中还没有任何视觉效果可以显示，所以让我们去抓取我们可观察到的视觉效果，然后我们将它们定位到它们适当的单元格中。</p><h1 id="b671" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤 2:在应用程序中嵌入 D3</h1><p id="e0d4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">嵌入 Observable 非常简单，只需下载所需视觉对象的 tarball，然后在 iframe 中托管其 index.html 文件。这并不是将 Observable 引入应用程序的唯一方法，但是它很快，并且对于快速原型开发很有效。</p><h2 id="80aa" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">2.1 从可观察的事物中获得视觉效果</h2><p id="1425" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要一张<strong class="ky ir">表</strong>和<strong class="ky ir">条形图</strong>。这些都可以在网上搜索到:</p><div class="mb mc gp gr md me"><a href="https://observablehq.com/@pstuffa/tables-with-nested-data" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">带 D3 的基本表</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">普斯塔法的可观察的笔记本。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">observablehq.com</p></div></div><div class="mn l"><div class="ou l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a href="https://observablehq.com/@d3/bar-chart" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">条形图</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">条形图这个图表显示了英语中字母的相对频率。这是一个垂直条形图…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">observablehq.com</p></div></div><div class="mn l"><div class="ov l mp mq mr mn ms jw me"/></div></div></a></div><p id="371c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们<strong class="ky ir">通过点击右上角的 3 个点下载</strong> <strong class="ky ir">他们的</strong> <strong class="ky ir"> tarballs </strong>:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/bd2f89b99b4fec1e61bb7e79641c783e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*h-wl55Nc1QrT78JNNQjBwQ.gif"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 6</figcaption></figure><p id="9aae" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">下载完成后，解压压缩包并<strong class="ky ir">放入各自的文件夹:</strong></p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/15ebeb95a0a7c2bf23f617e2c78fa7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNsvqyCJigmv3QvcpKfcIA.png"/></div></div></figure><h2 id="21ce" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">2.2 在 App 和 D3 之间建立通信</h2><p id="03bc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要我们的应用程序与我们可观察到的视觉效果进行交流。在上一节中，我们提到了使用<strong class="ky ir">az . post _ message _ to _ frame</strong>来做这件事。下面是函数:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 5</figcaption></figure><p id="f0ad" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Azle 的 post_message_to_frame 允许我们的应用程序在 iframe 内部发送数据和函数(只要所有东西都在同一个服务器上，就不会有 CORS 问题)。</p><p id="261e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir"> main.redefine </strong>来自可观察本身，也是我们如何<em class="lv">在 D3 可视化</em>中重新定义变量和数据。D3 表以名为“fakeData”的数据对象开始，因此我们需要用 Kaggle 数据集中的图书数据替换它。你会注意到我们传入了一个名为<em class="lv"> filter_by_author </em>的父函数，而不是数据本身。我们稍后会讨论这个问题。</p><p id="05fe" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这个等式的另一半是 D3 如何接受发布的消息。为了让托管的可观察对象接受来自应用程序的传入消息，我们必须<strong class="ky ir">向可观察对象的 index.html 文件</strong>中添加一个事件监听器:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 6</figcaption></figure><p id="ab7d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Azle 图书馆在最上面:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="c391" class="ns jz iq oh b gy ol om l on oo">&lt;script src='<a class="ae lu" href="https://azlejs.com/v2/azle.min.js'" rel="noopener ugc nofollow" target="_blank">https://azlejs.com/v2/azle.min.js'</a>&gt;&lt;/script&gt;</span></pre><p id="0868" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">所以我们的 D3 表 index.html 文件应该是这样的:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 7</figcaption></figure><p id="7c1b" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">为了清楚起见，我们将向该文件添加:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/51bf0ad7bfdcc0180ef9c6b315c4f685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAuDPLXcQXObiX7lQiZ6Qw.png"/></div></div></figure><p id="d3a6" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这种通信是可行的，因为我们使用 Azle 的<strong class="ky ir"> post_message_to_frame </strong>在我们的框架内发送 Observable 的<strong class="ky ir"> main.redefine </strong>，此时我们的框架接受该消息并执行<strong class="ky ir"> parent.filter_by_author </strong>函数(如代码块 5 所示)。下图描述了这个概念:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/6b63767e9f425d6e9d77b9a298b20261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDVOUt5gDkUn8f7LVvryfA.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure 7</figcaption></figure><p id="2646" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在我们讨论父函数之前，让我们来设计一下 D3 的视觉效果。</p><h2 id="079a" class="ns jz iq bd ka nt nu dn ke nv nw dp ki lh nx ny km ll nz oa kq lp ob oc ku od bi translated">2.3 向 D3 Observable 添加样式</h2><p id="4025" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因为我们下载了整个笔记本，所以会有我们不希望在应用程序中出现的笔记本单元格(它们用于将视觉效果调整为 REPL)。我们应该移除那些细胞。</p><p id="8a6c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们可以通过<strong class="ky ir">删除【Observable 的<strong class="ky ir">index.html 文件中的下面一行:</strong></strong></p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="5130" class="ns jz iq oh b gy ol om l on oo">const main = runtime.module(define, Inspector.into(document.body));</span></pre><p id="ef71" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">包含以下内容:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="ddfe" class="ns jz iq oh b gy ol om l on oo">const main = runtime.module(define, name =&gt; {<br/>  if (name == 'chart') {<br/>    return new Inspector(document.body)<br/>  }<br/>});</span></pre><p id="3ed2" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这样只会画出图表。</p><p id="9369" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们也可以<strong class="ky ir">设计 D3 视觉效果</strong>让它看起来更现代。检查表文件夹中的<strong class="ky ir">table-with-nested-data . js</strong>文件。比较原始文件和我在这里准备的文件，看看我添加的样式。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 8</figcaption></figure><p id="6478" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">区别在于:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/fa7dfe5042cf104d5a050bafadaf523c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koJYZQ44jwMGKTsrIE_xJQ.png"/></div></div></figure><p id="347b" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果您检查 bar_chart 文件夹中的<strong class="ky ir"> bar-chart.js </strong>文件，您会看到类似的变化。</p><h1 id="1d28" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤 3:创建父函数</h1><p id="1392" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们上面提到了父函数的使用。在图 7 中，我们看到了我们的应用程序和 Observable 之间的双向通信。父函数是我们在应用程序中从可观察对象调用函数<em class="lv">的方式。</em></p><p id="a2e3" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们希望 Observable 使用新的、经过过滤的数据重新绘制它的 D3 视图。因此，我们将使用从 iframes 内部调用的函数来过滤原始数据集(我们之前读到的)。</p><p id="6341" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir">创建一个名为<strong class="ky ir"> parent_functions.js </strong>的文件</strong>，放在 scripts 文件夹中:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="e3a3" class="ns jz iq oh b gy ol om l on oo"><strong class="oh ir">app</strong><br/>├── <strong class="oh ir">data<br/></strong>├── <strong class="oh ir">scripts<br/>  </strong>── <!-- -->parent_functions.js<br/>├── <strong class="oh ir">img<br/></strong>├── <strong class="oh ir">d3_visuals<br/>  </strong>── <strong class="oh ir">table<br/>  </strong>── <strong class="oh ir">bar_chart<br/></strong>├── <!-- -->index.html</span></pre><p id="b1be" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">下面是前 3 个父函数，它们返回完整的数据集、按语言过滤的数据或按作者过滤的数据。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 9</figcaption></figure><p id="2198" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们的框架将通过代码块 6 调用这些函数，并用新返回的数据替换默认的可视化数据集。</p><h1 id="7868" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤 4:定位我们的组件</h1><p id="5ee9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">至此，我们已经基于实体模型构建了一个简单的应用程序布局，精心制作了组件，在包含 main.redefine 的组件中设置了单击事件，向 D3 索引文件添加了事件处理程序，并创建了用于返回完整和过滤数据的父函数。此外，我们有我们的 D3 可视图像在他们的文件夹中等待。</p><p id="055a" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">D3 部分剩下的就是<strong class="ky ir">将我们的组件放入它们的目标单元</strong>。我们像任何其他 Azle 函数一样，使用目标布局单元格的<em class="lv"> target_class </em>和<em class="lv"> target_instance </em>来定位我们的组件。</p><p id="c09f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">首先，我们需要将数据集加载到应用程序中。</p><p id="dcb6" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我下载了 CSV 格式的 Kaggle Goodreads 数据集，然后使用在线转换器将其转换成 JSON。然后我下载了新的 JSON 文件，并保存到我们的 app 目录的 data 文件夹中，命名为<strong class="ky ir"> books.json </strong>。</p><p id="0a8f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在我们可以使用 Azle 的<strong class="ky ir"> read_local_file </strong>函数来读取我们的数据集。将它放在 index.html 文件的顶部:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 10</figcaption></figure><p id="74c0" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我将数据保存为一个名为 az.hold_value.full_dataset 的新对象。可以使用 az.hold_value。[变量名称]使任何变量或对象在 Azle 名称空间内全局可用。请注意，我还对数据进行了“切片”，以限制应用程序中显示的行数。您可以删除它以显示所有数据(或者更好的是，创建一个允许用户控制加载多少行的组件:)</p><p id="bd9f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在，我将使用 Azle 的<strong class="ky ir"> call_once_satisfied </strong>函数来确保在调用我们的组件之前已经加载了完整的数据集:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">codeblock 11</figcaption></figure><p id="798c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">一旦定义了现有数据对象的条件，这将把所有组件添加到我们的应用程序布局中。</p><p id="aaed" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们的<strong class="ky ir">表</strong>看起来是这样的:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/83e66bcbaf10d5e5648e0b836f0d185c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H31R8IYwZDxrm0rcPsfMFA.png"/></div></div></figure><p id="668e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果你玩<a class="ae lu" href="https://collaboratescience.com/stack/medium/d3_obs_medium/" rel="noopener ugc nofollow" target="_blank">应用</a>，你会看到用户可以通过作者姓名和语言过滤 D3 表格。许多 B2B 应用程序受益于这种功能。</p><p id="344b" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">当用户通过 ISBN 搜索时，我们仍然需要实现我们的原型承诺，显示信息的条形图和书的封面。让我们现在做那件事。</p><h1 id="382d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤 5:调用 Google 的图书 API</h1><p id="ff43" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，我们可以使用免费的谷歌图书 API 从 ISBNs 获取图书封面。快速的谷歌搜索会让我们看到显示如何使用它的堆栈溢出答案(通常比通常的文档更快):</p><div class="mb mc gp gr md me"><a href="https://stackoverflow.com/questions/7908954/google-books-api-searching-by-isbn" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">通过 ISBN 搜索谷歌图书 API</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">我试图弄清楚如何使用谷歌图书 API 通过 ISBN 搜索一本书。我需要写一个程序…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">stackoverflow.com</p></div></div><div class="mn l"><div class="pb l mp mq mr mn ms jw me"/></div></div></a></div><p id="b06d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们希望条形图和图书封面出现在用户通过 ISBN 搜索后。如果您查看 components.js 中的<strong class="ky ir"> search_by_isbn </strong>函数并检查它的 click 事件，您将会看到这是如何处理的。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="cd4e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">当用户粘贴 ISBN #并点击搜索图标时，会发生 4 种情况:</p><ul class=""><li id="44b0" class="mz na iq ky b kz lw ld lx lh nb ll nc lp nd lt ne nf ng nh bi translated">调用<strong class="ky ir"> fetch_book_cover </strong>组件；</li><li id="7fc5" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">使用<strong class="ky ir"> az.style_iframe </strong>中的 CSS display 属性切换 iframe 的显示；</li><li id="b6de" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">一条<strong class="ky ir">消息被发送</strong>到保存条形图的 iframe，数据由 ISBN 过滤；</li><li id="f0c1" class="mz na iq ky b kz ni ld nj lh nk ll nl lp nm lt ne nf ng nh bi translated">伴随条形图调用<strong class="ky ir"> add_chart_buttons </strong>组件。</li></ul><p id="564d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir"> fetch_book_cover </strong>组件解析从 Google 的 Book API 返回的数据，并检索所需的图片 URL:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="b324" class="ns jz iq oh b gy ol om l on oo">data.items[0].volumeInfo.imageLinks.thumbnail</span></pre><p id="c596" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">…在我们将图书封面添加到应用程序时，我们可以将它用作图片 URL:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="4b7c" class="ns jz iq oh b gy ol om l on oo"><strong class="oh ir">az.add_image</strong>('visual_layout_cells', 2, {<br/>     "this_class": "cover_img",<br/>     "image_path": data.items[0].volumeInfo.imageLinks.thumbnail<br/>})</span></pre><p id="7e06" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果你查看应用程序代码的<strong class="ky ir"> component.js </strong>，你会看到一个调用谷歌图书 API 的函数。它使用 Azle 的<strong class="ky ir"> call_api </strong>函数以及以下 URL:</p><pre class="mv mw mx my gt og oh oi oj aw ok bi"><span id="5d68" class="ns jz iq oh b gy ol om l on oo">"https://www.googleapis.com/books/v1/volumes?q=isbn:" + <strong class="oh ir">az.grab_value</strong>('search_isbn_bar', 1)</span></pre><p id="82e3" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这只是将 API url 和用户添加的 ISBN 连接到类名为“search_isbn_bar”的输入字段。</p><p id="0315" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">用户因此可以从表格中复制一个 ISBN 号，并将其粘贴到<em class="lv">通过 isbn </em>输入字段进行搜索，这将绘制<strong class="ky ir">条形图</strong>并显示该书的<strong class="ky ir">封面</strong>:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0f2eaa3067f80c1fb24f9cf45bb54bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnjDdZ_zK4pTNMXqtGVFKQ.png"/></div></div></figure><p id="eaaa" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">用户还可以使用条形图下方的细按钮来更改条形图视图。这里又是 app gif:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1494ba4bad1453fe7b3f62f26590475b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gDxTUPopZ-FPUMeWOUpU_g.gif"/></div></figure><p id="9506" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如前所述，您可以通读完整的代码库，看看完整的应用程序是如何构建的。如果你看到一个看起来不熟悉的函数，参考 Azle 的<a class="ae lu" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank">文档</a>。本文想要展示将 D3 Observable 引入一个真正的 web 应用程序所需的核心部分。</p><h1 id="4c43" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="84e7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我们研究了在 web 应用程序中嵌入 D3 Observable。我们使用 Azle 将 Observable 和 Google 的 Book API 结合在一起，创建了一个真正的应用程序，允许用户搜索和浏览书名。</p><p id="85b5" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们的任务包括基于 2 个简单的<strong class="ky ir">实体模型</strong>创建一个快速布局，制作并定位<strong class="ky ir">组件</strong>，在框架中嵌入一个可观察的<strong class="ky ir">表格</strong>和<strong class="ky ir">条</strong>T30】图表，使用<strong class="ky ir">消息</strong> <strong class="ky ir">发布</strong>和<strong class="ky ir">事件</strong> <strong class="ky ir">处理程序</strong>在应用程序和可观察对象之间进行通信，最后使用 Google 的 Book <strong class="ky ir"> API </strong></p><p id="4989" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们只讨论了将 D3 连接到应用程序所需的主要部分。您可以在 GitHub 项目上探索更多代码。我鼓励你创建自己的应用程序，并通过真实的产品将你的分析带给用户。</p><p id="e5c4" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir">如果你喜欢这篇文章，你可能也会喜欢</strong>:</p><div class="mb mc gp gr md me"><a rel="noopener follow" target="_blank" href="/learn-to-build-machine-learning-services-prototype-real-applications-and-deploy-your-work-to-aa97b2b09e0c"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">学习建立机器学习服务，原型真实的应用程序，并部署您的工作…</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">在这篇文章中，我将向读者展示如何将他们的机器学习模型公开为 RESTful web 服务，原型真实…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">towardsdatascience.com</p></div></div><div class="mn l"><div class="pc l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a rel="noopener follow" target="_blank" href="/gui-fying-the-machine-learning-workflow-towards-rapid-discovery-of-viable-pipelines-cab2552c909f"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">机器学习工作流的 GUI 化:快速发现可行的流水线</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">前言</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">towardsdatascience.com</p></div></div><div class="mn l"><div class="pd l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">创建 R 和 Python 库的分步指南(在 JupyterLab 中)</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">r 和 Python 是当今机器学习语言的支柱。r 提供了强大的统计数据和快速…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">towardsdatascience.com</p></div></div><div class="mn l"><div class="pe l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a rel="noopener follow" target="_blank" href="/combining-d3-with-kedion-graduating-from-toy-visuals-to-real-applications-92bf7c3cc713"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">用 D3.js 从玩具视觉过渡到真实应用</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">我们经常孤立地学习技术和方法，与数据科学的真正目标脱节；至…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">towardsdatascience.com</p></div></div><div class="mn l"><div class="pf l mp mq mr mn ms jw me"/></div></div></a></div></div></div>    
</body>
</html>