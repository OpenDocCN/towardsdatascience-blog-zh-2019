<html>
<head>
<title>Multiprotocol Label Switching(MPLS) Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释多协议标签交换(MPLS)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multiprotocol-label-switching-mpls-explained-aac04f3c6e94?source=collection_archive---------6-----------------------#2019-08-10">https://towardsdatascience.com/multiprotocol-label-switching-mpls-explained-aac04f3c6e94?source=collection_archive---------6-----------------------#2019-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="aa06" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">这个博客分为两个部分，第一部分我们将了解 MPLS 到底是什么，第二部分我们将看到如何使用 Golang 制作 MPLS 数据包。</p></blockquote><p id="b107" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">多协议标签交换(MPLS)并不是一项新技术。已经好几年了。你们中的许多人一定熟悉数据是如何以网络数据包的形式在网络中从一个地方传输到另一个地方的。这些数据包包含源 IP 地址和目的 IP 地址。一个包要通过中间的几个路由器，这些路由器包含路由表，它为包提供下一跳信息，并跟随它最终到达目的地。这就是<strong class="jw iu"> IP 转发</strong>的工作方式。这是第 3 层协议。</p><p id="5840" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">MPLS 转发不同于 IP 转发，因为转发不是基于 IP 地址，而是基于数据包上的标签，因此得名标签交换。它是多协议的，因为它支持多种协议，如互联网协议(IP)、异步传输模式(ATM)和帧中继网络协议。我们将在后面看到 MPLS 转发到底是如何完成的。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/0f6505d592941311c85d6e4b36952a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*pyWBenYHenpyhAEJg8GWyQ.png"/></div></figure><p id="3498" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">如果你熟悉计算机网络，你一定知道 TCP/IP 模型有 5 层。MPLS 层位于模型的第 2 层和第 3 层之间，即数据链路层和网络层。这就是为什么它也被称为 2.5 层协议或“垫片”协议。</p><p id="7fec" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">MPLS 报头是 32 位的。它包含以下信息:-</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/7fb8dd4b873b08c4723c27c3643a0d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*Umdp5m0NBwWmMx8TbcaJfw.png"/></div></figure><ol class=""><li id="edd5" class="le lf it jw b jx jy kb kc ks lg kt lh ku li kr lj lk ll lm bi translated"><strong class="jw iu">标签</strong>:标签字段为 20 位，因此标签可以取从 0 到 2^20–1 的值，或 1048575。但是，前 16 个标签值(即从 0 到 15)由于具有特殊含义，因此可免于正常使用。</li><li id="7450" class="le lf it jw b jx ln kb lo ks lp kt lq ku lr kr lj lk ll lm bi translated"><strong class="jw iu">实验(Exp): </strong>这三个比特被保留作为实验比特。它们用于服务质量(QoS)。</li><li id="10bb" class="le lf it jw b jx ln kb lo ks lp kt lq ku lr kr lj lk ll lm bi translated"><strong class="jw iu">栈底(BoS): </strong>一个网络数据包可以有一个以上的 MPLS 标签，这些标签相互堆叠。为了确保哪个 MPLS 标签在栈底，我们有一个 1 比特的 BoS 字段。只有当特定标签位于堆栈底部时，该位才为高(即值 1)，否则其值保持为 0。</li><li id="56f3" class="le lf it jw b jx ln kb lo ks lp kt lq ku lr kr lj lk ll lm bi translated"><strong class="jw iu">生存时间(TTL): </strong>后 8 位用于生存时间(TTL)。该 TTL 与 IP 报头中的 TTL 具有相同的功能。它的值只是在每一跳减 1。TTL 的作用是当数据包的值变为零时，通过丢弃数据包来避免数据包滞留在网络中。</li></ol><h1 id="6384" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">现在我们将看到典型的 MPLS 网络是什么样子的</h1><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/9bbf767969cd493459b43122befe936b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPm4jhgWMQ0vuoSB7TSYKA.png"/></div></div></figure><p id="0ca2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">MPLS 网络包含标签交换路由器(LSR)。这些路由器能够理解 MPLS 标签，并能够接收和发送带标签的数据包。</p><p id="7ab0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">MPLS 网络中存在三种标签交换路由器</p><ol class=""><li id="4a31" class="le lf it jw b jx jy kb kc ks lg kt lh ku li kr lj lk ll lm bi translated"><strong class="jw iu">入口 LSR: </strong>这些路由器出现在 MPLS 网络的起点。他们的工作是接收未标记的 IP 数据包，并将标签放在上面。</li><li id="9b06" class="le lf it jw b jx ln kb lo ks lp kt lq ku lr kr lj lk ll lm bi translated"><strong class="jw iu">出口 LSR: </strong>这些路由器位于 MPLS 网络的末端。他们的工作是从传入的数据包中弹出标签，并将数据包作为 IP 数据包转发。</li><li id="d254" class="le lf it jw b jx ln kb lo ks lp kt lq ku lr kr lj lk ll lm bi translated"><strong class="jw iu">中间 LSR: </strong>这些路由器存在于上述两个路由器之间。他们的工作是接收带标签的数据包，交换数据包的标签，并将其转发到下一跳。它们负责数据包的 MPLS 转发。</li></ol><blockquote class="jq jr js"><p id="9c5d" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">入口和出口也称为边缘路由器</p></blockquote><p id="3ea8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">因此，在任何特定的路由器上，标签的推送、弹出或交换这三个步骤中的任何一个都会发生。</p><h1 id="8e63" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">标签交换路径(LSP)</h1><p id="8c6f" class="pw-post-body-paragraph jt ju it jw b jx mv jz ka kb mw kd ke ks mx kh ki kt my kl km ku mz kp kq kr im bi translated">标签交换路径(LSP)可以定义为在 MPLS 网络中传输数据包的标签交换路由器(LSR)序列。基本上，LSP 是数据包在传输过程中采用的预定义路径。LSP 中的第一个 LSR 是入口 LSR，类似地，LSP 中的最后一个 LSR 是出口路由器，后面是中间的 LSR。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi na"><img src="../Images/a1ea657f56792f5722cdc8f9594ade10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLTNnZipf-1Smv3aprvdaw.png"/></div></div></figure><p id="205a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">这里的主要收获是，在 IP 转发中，没有数据包必须遵循的固定路径，而在 MPLS 转发中，我们预定义了路径，即在数据包传输过程中必须遵循的 LSP。</p><h1 id="5ae6" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">MPLS 转发</h1><p id="72f6" class="pw-post-body-paragraph jt ju it jw b jx mv jz ka kb mw kd ke ks mx kh ki kt my kl km ku mz kp kq kr im bi translated">因此，结合我们所学的上述概念，现在我们可以很容易地看到 MPLS 数据包是如何在网络中转发的。</p><p id="833d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">当网络数据包进入 MPLS 网络时，入口路由器会在其顶部放置一个标签。该标签对应于分组需要遵循的特定路径，即 LSP。不同的 LSP 对应不同的标签栈。使用不同的协议来分发标签，例如标签分发协议(TDP)、标签分发协议(LDP)和资源预留协议(RSVP)。</p><p id="408b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">与 IP 转发一样，每个路由器都包含一个路由表。类似地，在 MPLS 网络中，每个 LSR 都包含标签转发信息库(LFIB)。这个信息库引导 LSR 用其相应的输出标签交换标签，从而允许分组通过网络传输。这里的主要要点是，路由器只需要看到传入数据包顶部的标签，它不关心数据包内部的 IP 地址(源和目的地),从而允许通过网络进行更快的路由。</p><p id="6920" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">以下是 LFIB 中的信息示例</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1981f8dc27778be28d563b0c432bda30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*i_Ayqpq7OfOM2RSTPCHvZw.png"/></div></figure><p id="8e43" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">在 LSP 结束时，出口 LSR 弹出信息包的标签，信息包作为普通的 IP 信息包被路由。</p><blockquote class="jq jr js"><p id="7420" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">这是 MPLS 转发如何发生的高级视图。要深入了解，您可以参考<a class="ae nc" href="https://doc.lagout.org/network/Cisco/CCIE/CCIE%20SP/CiscoPress%20-%20MPLS%20Fundamentals.pdf" rel="noopener ugc nofollow" target="_blank">思科 MPLS 基础书籍</a></p></blockquote><h1 id="8b39" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">制作 MPLS 数据包</h1><p id="dc61" class="pw-post-body-paragraph jt ju it jw b jx mv jz ka kb mw kd ke ks mx kh ki kt my kl km ku mz kp kq kr im bi translated">继续下一部分，在这里我们将看到如何使用 Golang 制作 MPLS 数据包。为什么是 Golang？因为它是高度可伸缩的，具有内置的并发性和对服务器端编程的强大支持，并且还有一组令人敬畏的库。我们将使用<a class="ae nc" href="https://github.com/google/gopacket" rel="noopener ugc nofollow" target="_blank"> GoPacket </a>库来制作这个包。</p><p id="35ab" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">代码来了</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8f85" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">代码是不言自明的，我们为 IP、UDP、有效负载、MPLS 和以太网创建了单独的层，并按照以下顺序将这些层堆叠在一起，然后返回创建的字节对象。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/575ebd272e70aca1dabe016ccc37f6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*EhR6JyrlqXtwwhhEoyCyug.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">MPLS packet layer stack</figcaption></figure><p id="102b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">如果我们执行上述代码，我们将获得以下输出</p><pre class="kw kx ky kz gt nk nl nm nn aw no bi"><span id="3204" class="np lt it nl b gy nq nr l ns nt">c8b302c0b91bc8b302c0b91b88470001114045000023000000000011b6c7010101010101010107d00bb8000f2b157061796c6f616400000000000000</span></pre><p id="eac1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">这是数据包形成的输出，我们可以使用在线工具，如 https://hpd.gasmi.net/的<a class="ae nc" href="https://hpd.gasmi.net/" rel="noopener ugc nofollow" target="_blank">或 Wireshark 来解码数据包。</a></p><p id="18ef" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">解码上面的包给出了如下预期的结果。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nu"><img src="../Images/dbb09a995bfd5066a1345709fda35959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHJaOXzmuTU-2QEYy41LtA.png"/></div></div></figure><p id="7885" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">全部代码也可以在我的 Github <a class="ae nc" href="https://github.com/mayank408/MPLS-packet" rel="noopener ugc nofollow" target="_blank">库</a>中找到</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="8364" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">感谢阅读这篇文章。</p><p id="e7b7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">更多这样的博客，你可以关注我，这样每当我有新的帖子时，你都会得到通知。</p><p id="8593" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">干杯！</p><p id="8dd0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">还有，我们来连线一下<a class="ae nc" href="https://twitter.com/mayank_408" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu"> Twitter </strong> </a>，<a class="ae nc" href="https://www.linkedin.com/in/mayank-tripathi-a49563126/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu"> Linkedin </strong> </a>，<a class="ae nc" href="https://github.com/mayank408" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu"> Github </strong> </a>。</p></div></div>    
</body>
</html>