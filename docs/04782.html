<html>
<head>
<title>Comprehending the ‘Comprehensions’ in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Python 中的“理解”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comprehending-the-concept-of-comprehensions-in-python-c9dafce5111?source=collection_archive---------4-----------------------#2019-07-20">https://towardsdatascience.com/comprehending-the-concept-of-comprehensions-in-python-c9dafce5111?source=collection_archive---------4-----------------------#2019-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97a6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解和实现 python 中的列表、字典、集合和生成器。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ba4a260d7bdee834a1f6336bc870ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59ckTVTqFW0N_CRFL4AbTA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by <a class="ae ky" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2470549" rel="noopener ugc nofollow" target="_blank">Gerd Altmann</a> from <a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2470549" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><blockquote class="kz"><p id="9557" class="la lb it bd lc ld le lf lg lh li lj dk translated">“好的代码是它自己最好的文档”——史蒂夫·麦康奈尔</p></blockquote><p id="7b7a" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">在我的<a class="ae ky" rel="noopener" target="_blank" href="/elements-of-functional-programming-in-python-1b295ea5bbe0">上一篇文章</a>中，我解释了 Python 中 Lambda、Map、Filter 和 Reduce 函数的概念，它们基于函数式编程范式。我还提到了列表理解的概念，它被认为是 lambda 函数的替代品。整篇文章详细地涵盖了理解的本质及其各种形式。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="97ad" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Python 中的理解</h1><p id="9546" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">理解是允许从其他序列构建序列的结构。Python 2.0 向我们介绍了列表理解的概念，而 Python 3.0 通过包含字典和集合理解更进一步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4af999b8a241a0be08142e93f01b89b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*HvPCNNaUJgG0KVm_8Sg4LQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Types of Comprehensions in Python</figcaption></figure><p id="06ec" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">为什么理解力如此强大？我们将通过一个例子来理解这一点。我们都知道 Python 提供了多种表示列表的方式。例如:</p><ul class=""><li id="0d28" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated">人们可以明确地把整个事情写成:</li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="227c" class="od mn it nz b gy oe of l og oh">squares = [0, 1, 4, 9,16,25]</span></pre><ul class=""><li id="e9f6" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated">或者，编写一个 for 循环来创建一个列表:</li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="9f66" class="od mn it nz b gy oe of l og oh">squares = []<br/>for num in range(6):<br/>    squares.append(num*num)</span></pre><ul class=""><li id="8bf7" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated">创建列表的另一种方法是使用单行代码。</li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="dddf" class="od mn it nz b gy oe of l og oh">squares = [num*num for num in range(6)]</span></pre><p id="3145" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">上面这个一行程序叫做<strong class="lm iu">列表理解</strong>，是创建列表的一种便捷方式。它消除了对循环的依赖，使代码紧凑。下一节将进一步深入 Python 3 中提供的列表和其他类型的概念。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="11c4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">列表理解[ ]</h1><p id="f01b" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated"><a class="ae ky" href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank">列表理解</a>是一种用 Python 以简洁的方式定义和创建列表的方法。在大多数情况下，列表理解让我们在一行代码中创建列表，而不用担心初始化列表或设置循环。</p><p id="6ba7" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">列表理解由以下部分组成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9cf15f9d76f7abe4a82532b7838e2323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*QlyEL6xtD4NW3mw08n6a6Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Various parts of a List Comprehension</figcaption></figure><p id="1dca" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">比方说，我们需要找到前五个偶数的平方。如前一节所述，有两种方法可以做到这一点:显式 for 循环或列表理解。让我们两个都试试。</p><ul class=""><li id="311d" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated"><strong class="lm iu">使用 For 循环</strong></li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="ce01" class="od mn it nz b gy oe of l og oh">even_squares = []<br/>&gt;&gt;&gt; for num in range(11):<br/>...    if num%2 == 0:<br/>...        even_squares.append(num * num)</span><span id="f64e" class="od mn it nz b gy oj of l og oh">&gt;&gt;&gt; even_squares<br/>[0, 4, 16, 36, 64, 100]</span></pre><ul class=""><li id="8b38" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated"><strong class="lm iu">使用列表理解</strong></li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="346e" class="od mn it nz b gy oe of l og oh">even_squares = [num * num for num in range(11) if num%2 == 0]<br/>even_squares<br/>[0, 4, 16, 36, 64, 100]</span></pre><p id="df54" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果我们仔细观察，可以发现仅仅通过重新排列 For 循环就可以创建列表理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b9fe0f02c0995be77739128760cd6743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUhlknsL6rR-s_DcVQK7kQ.png"/></div></div></figure><blockquote class="kz"><p id="d392" class="la lb it bd lc ld le lf lg lh li lj dk translated">列表理解是 Python 实现数学中使用的集合符号的方式。</p></blockquote><figure class="om on oo op oq kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/1be75c6c44b867f57211d4631a46524b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__QkfytLlRx_x3El0C3U7A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://courses.cs.washington.edu/courses/cse140/14wi/lectures/22-list-comprehensions.pdf" rel="noopener ugc nofollow" target="_blank">similarily to sets in Maths</a></figcaption></figure><p id="e06e" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">让我们试着看看更多借助列表理解创建列表的例子。</p><h2 id="da68" class="od mn it bd mo or os dn ms ot ou dp mw lt ov ow my lx ox oy na mb oz pa nc pb bi translated">创造毕达哥拉斯三胞胎</h2><p id="7078" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">一个毕达哥拉斯三元组由三个正整数 a，b，c 组成，这样<br/> a + b = c .我们通常把这样的三元组写成(a，b，c)，比如(3，4，5)。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="48e8" class="od mn it nz b gy oe of l og oh">[(a,b,c) for a in range(1,30) for b in range(1,30) for c in range(1,30)if a**2 + b**2 == c**2]</span><span id="c993" class="od mn it nz b gy oj of l og oh">[(3, 4, 5), (4, 3, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25), (8, 6, 10), (8, 15, 17), (9, 12, 15), (10, 24, 26), (12, 5, 13), (12, 9, 15), (12, 16, 20), (15, 8, 17), (15, 20, 25),(16, 12, 20), (20, 15, 25),(20, 21, 29), (21, 20, 29), (24, 7, 25), (24, 10, 26)]</span></pre><h2 id="68e4" class="od mn it bd mo or os dn ms ot ou dp mw lt ov ow my lx ox oy na mb oz pa nc pb bi translated">用字符串列出理解</h2><ul class=""><li id="0ec5" class="np nq it lm b ln ne lq nf lt pc lx pd mb pe lj nu nv nw nx bi translated">将字符串中的小写字母转换成大写字母。</li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b2a7" class="od mn it nz b gy oe of l og oh">colors = ["pink", "white", "blue", "black", purple"]<br/>[color.upper() for color in colors]<br/>['RED', 'GREEN', 'BLUE', 'PURPLE']</span></pre><ul class=""><li id="4656" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated">交换给定列表中的名字和姓氏。</li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b48d" class="od mn it nz b gy oe of l og oh"><strong class="nz iu">presidents_usa</strong> = ["George Washington", "John Adams","Thomas Jefferson","James Madison","James Monroe","John Adams","Andrew Jackson"]</span><span id="2436" class="od mn it nz b gy oj of l og oh"><strong class="nz iu">split_names</strong> = [name.split(" ") for name in presidents_usa]<br/><strong class="nz iu">swapped_list</strong> = [split_name[1] + " " + split_name[0] for split_name in split_names]</span><span id="5fb0" class="od mn it nz b gy oj of l og oh"><strong class="nz iu">swapped_list</strong></span><span id="8656" class="od mn it nz b gy oj of l og oh">['Washington George', 'Adams John', 'Jefferson Thomas', 'Madison James', 'Monroe James', 'Adams John', 'Jackson Andrew']</span></pre><h2 id="e9de" class="od mn it bd mo or os dn ms ot ou dp mw lt ov ow my lx ox oy na mb oz pa nc pb bi translated">用元组列出理解</h2><p id="16a1" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">如果表达式包含一个元组(如<code class="fe pf pg ph nz b">(x, y)</code>)，必须用括号括起来。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="402e" class="od mn it nz b gy oe of l og oh"># Convert height from cms to feet using List Comprehension : 1 cm = 0.0328 feet</span><span id="4d3a" class="od mn it nz b gy oj of l og oh"><strong class="nz iu">height_in_cms</strong> = [('Tom',183),('Daisy',171),('Margaret',179),('Michael',190),('Nick',165)]</span><span id="86d4" class="od mn it nz b gy oj of l og oh"><strong class="nz iu">height_in_feet</strong> = [(height[0],round(height[1]*0.0328,1)) for height in height_in_cms]</span><span id="addd" class="od mn it nz b gy oj of l og oh"><strong class="nz iu">height_in_feet</strong></span><span id="dc50" class="od mn it nz b gy oj of l og oh">[('Tom', 6.0), ('Daisy', 5.6), ('Margaret', 5.9), ('Michael', 6.2), ('Nick', 5.4)]</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="002c" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">嵌套列表理解[[ ]]</h1><p id="8a18" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">列表理解也可以嵌套来创建复杂的列表。例如，我们可以只使用列表理解来创建一个矩阵。</p><ul class=""><li id="eef9" class="np nq it lm b ln nk lq nl lt nr lx ns mb nt lj nu nv nw nx bi translated">创建 3X3 矩阵</li></ul><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="dd21" class="od mn it nz b gy oe of l og oh">matrix = [[j * j+i for j in range(3)] for i in range(3)]<br/>matrix</span><span id="8612" class="od mn it nz b gy oj of l og oh">[[0, 1, 4], [1, 2, 5], [2, 3, 6]]</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7b89" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">集合理解{ }</h1><p id="8a7e" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">集合理解类似于列表理解，但是返回集合而不是列表。语法略有不同，因为我们使用花括号而不是方括号来创建集合。</p><p id="ee0f" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">考虑以下由人名组成的列表:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="14e9" class="od mn it nz b gy oe of l og oh">names = [ 'Arnold', 'BILL', 'alice', 'arnold', 'MARY', 'J', 'BIll' ,'maRy']</span></pre><p id="462c" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">名单上有很多重复的名字，而且有些名字只有一个字母。我们想要的是一个由长度超过一个字母并且只有首字母大写的名字组成的列表。为了完成这样的任务，我们求助于集合理解。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="645f" class="od mn it nz b gy oe of l og oh">{name.capitalize() for name in names if len(name) &gt; 1}</span><span id="3d62" class="od mn it nz b gy oj of l og oh">{'Alice', 'Arnold', 'Bill', 'Mary'}</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d611" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">字典理解{ }</h1><p id="fb7d" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">当输入是字典或<code class="fe pf pg ph nz b">key: value</code>对的形式时，使用字典理解。例如，考虑一个字典，其中的键表示字符，值表示这些字符在语料库中出现的次数。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="1a26" class="od mn it nz b gy oe of l og oh">char_dict = {'A' : 4,'z': 2, 'D' : 8, 'a': 5, 'Z' : 10 }</span></pre><p id="3ae7" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">字典<code class="fe pf pg ph nz b">char_dict</code>由大写字母和小写字母混合组成。我们要计算字母出现的总次数，而不考虑它们的大小写。让我们用字典的理解来实现这一点:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="15c6" class="od mn it nz b gy oe of l og oh">{ k.lower() : char_dict.get(k.lower(), 0) + char_dict.get(k.upper(), 0) for k in char_dict.keys()}</span><span id="a38d" class="od mn it nz b gy oj of l og oh">{'a': 9, 'z': 12, 'd': 8}</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c4ea" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">生成器表达式( )</h1><p id="7018" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">列表理解之于列表，正如生成器表达式之于<a class="ae ky" href="https://www.programiz.com/python-programming/generator" rel="noopener ugc nofollow" target="_blank">生成器</a>。发生器函数从给定序列中一次输出一个值<strong class="lm iu">而不是一次给出所有值</strong>。这里有一篇<a class="ae ky" href="https://www.dataquest.io/blog/python-generators-tutorial/" rel="noopener ugc nofollow" target="_blank">不错的文章</a>，它解释了 Python 中生成器的本质。</p><div class="pi pj gp gr pk pl"><a href="https://www.dataquest.io/blog/python-generators-tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">Python 生成器— Dataquest</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">Python 生成器是强大但被误解的工具。他们经常被认为是太难的概念…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">www.dataquest.io</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><p id="dbd0" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">生成器表达式的语法和工作方式与列表理解非常相似，只是它们使用圆括号而不是方括号。假设我们要计算前十个自然数的平方和。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="f5bc" class="od mn it nz b gy oe of l og oh"># Sum of first ten natural numbers using List Comprehensions</span><span id="a230" class="od mn it nz b gy oj of l og oh">sum(<strong class="nz iu">[</strong>num**2 for num in range(11)<strong class="nz iu">]</strong>)<br/>385</span></pre><p id="b7f1" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果我们使用任何其他的 iterable，而不一定是 list，结果会是一样的。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="778e" class="od mn it nz b gy oe of l og oh">sum(<strong class="nz iu">{</strong>num**2 for num in range(11)<strong class="nz iu">}</strong>)<br/>385</span></pre><p id="f1ce" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">现在，如果我们使用一个生成器表达式来计算前十个自然数的平方，它会是这样的:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b1d3" class="od mn it nz b gy oe of l og oh">squares = (num**2 for num in range(11))<br/>squares</span><span id="cef7" class="od mn it nz b gy oj of l og oh">squares<br/>&lt;generator object &lt;genexpr&gt; at 0x1159536d8&gt;</span></pre><p id="800a" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">与列表理解不同，生成器表达式不返回列表，而是返回生成器对象。为了得到结果，我们可以使用上面的表达式和<code class="fe pf pg ph nz b">sum</code>函数。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="5eec" class="od mn it nz b gy oe of l og oh">sum(n <strong class="nz iu">**</strong> 2 <strong class="nz iu">for</strong> n <strong class="nz iu">in</strong> numbers)<br/>385</span></pre><p id="7853" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">看看我们如何去掉上面表达式中多余的括号，使代码更加高效。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="ee82" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">最后，不要过度使用理解</h1><p id="9217" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">列表理解是减少代码长度的有效方法。它们还使代码更具可读性。但是有些情况下，没有它们我们也能过得很舒服。</p><p id="dcc8" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">当你的程序逻辑太长时，使用理解是不明智的。使用理解的主要思想是缩短代码。然而，当我们开始将太多的代码打包到一条语句中时，我们往往会损害代码的可读性。在这种情况下，for 循环是一个更好的主意。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="432b" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">参考资料和进一步阅读</h1><ul class=""><li id="5846" class="np nq it lm b ln ne lq nf lt pc lx pd mb pe lj nu nv nw nx bi translated"><a class="ae ky" href="https://realpython.com/lessons/list-comprehensions-overview/" rel="noopener ugc nofollow" target="_blank">列表理解概述</a></li><li id="3fc8" class="np nq it lm b ln qa lq qb lt qc lx qd mb qe lj nu nv nw nx bi translated"><a class="ae ky" href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" rel="noopener ugc nofollow" target="_blank">https://trey hunner . com/2015/12/python-list-comprehensions-now-in-color/</a></li></ul></div></div>    
</body>
</html>