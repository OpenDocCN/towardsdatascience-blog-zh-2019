<html>
<head>
<title>Private AI — Federated Learning with PySyft and PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">私有人工智能——使用 PySyft 和 PyTorch 的联合学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/private-ai-federated-learning-with-pysyft-and-pytorch-954a9e4a4d4e?source=collection_archive---------11-----------------------#2019-06-05">https://towardsdatascience.com/private-ai-federated-learning-with-pysyft-and-pytorch-954a9e4a4d4e?source=collection_archive---------11-----------------------#2019-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f096" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">GRU 模型在垃圾短信检测中的应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/dad24be15244fa4931baff3e7500e296.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*UA9OOcTeuX3vrW5XkB3M6w.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">OpenMined</figcaption></figure><h1 id="dcf6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">简介</strong></h1><p id="da9f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在过去的几年里，我们都见证了人工智能和机器学习领域的一个重要而快速的发展。这种快速发展得益于计算能力的提高(通过上一代 GPU 和 TPU 实现)以及多年来积累的每秒钟都在创建的大量数据。</p><p id="621f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">从对话助手到肺癌检测，我们可以清楚地看到 AI 发展对我们社会的几种应用和各种好处。然而，在过去的几年里，这种进步是有代价的:在某种程度上失去了隐私。<a class="ae mn" href="https://en.wikipedia.org/wiki/Facebook%E2%80%93Cambridge_Analytica_data_scandal" rel="noopener ugc nofollow" target="_blank">剑桥分析公司丑闻</a>敲响了保密和数据隐私的警钟。此外，无论大小，科技公司对数据的使用越来越多，导致多个司法管辖区的当局致力于制定有关数据保护和隐私的法规和法律。欧洲的<a class="ae mn" href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation" rel="noopener ugc nofollow" target="_blank"> GDPR </a>是这种行为最著名的例子。</p><p id="ac34" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些担忧和法规与人工智能和机器学习的发展并不直接兼容，因为模型和算法总是依赖于数据的可用性和将其集中在大型服务器中的可能性。为了解决这个问题，一个新的研究领域引起了 ML 研究者和实践者的兴趣:私有和安全的 AI。</p><h1 id="a717" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">什么是私有安全 AI？</strong></h1><p id="9e0b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个新领域由一系列技术组成，这些技术允许 ML 工程师在不直接访问用于训练的数据的情况下训练模型，并避免他们通过使用密码术获得关于数据的任何信息。</p><p id="7699" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这看起来像是黑魔法，不是吗？</p><p id="338a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">不要担心…在一系列文章中，我将展示它是如何工作的，以及我们如何通过开源库<a class="ae mn" href="https://github.com/OpenMined/PySyft" rel="noopener ugc nofollow" target="_blank"> PySyft </a>将它应用于我们自己的 Python 深度学习模型。</p><p id="f5c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该框架依赖于三种主要技术:</p><ul class=""><li id="25a7" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">联合学习</li><li id="f487" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">差异隐私</li><li id="2064" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">安全多方计算</li></ul><p id="0274" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本文中，我将介绍联合学习及其在垃圾短信检测中的应用。</p><h1 id="aac3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">联合学习</h1><p id="cf48" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">也许是私人人工智能中最容易理解的概念，联合学习是一种训练人工智能模型的技术，而不必将数据移动到中央服务器。谷歌在 2016 年发表的一篇论文<a class="ae mn" href="https://arxiv.org/pdf/1602.05629.pdf" rel="noopener ugc nofollow" target="_blank">中首次使用了这个术语。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/48c1c21164e22f1ac3f12c6ce1c10602.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*PqDfah26HPR6CyTJIXWnMA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Schema of a Federated Learning task</figcaption></figure><p id="660e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">主要思想是，我们不是将数据带到模型中，而是将模型发送到数据所在的位置。</p><p id="3392" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于数据位于几个设备中(在这里我称之为 workers ),模型被发送给每个 worker，然后再发送回中央服务器。</p><p id="5687" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现实世界中联合学习的一个简单例子发生在苹果设备上。应用程序 QuickType(苹果的文本预测工具)实际上使用的模型通过 WiFi 不时发送到 iOS 设备，用用户的数据在本地进行训练，然后发送回苹果的中央服务器，并更新其权重。</p><h1 id="0798" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">PySyft</h1><p id="6436" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">PySyft 是一个为联邦学习和隐私保护而构建的开源库。它允许其用户执行私人和安全的深度学习。它是作为一些 DL 库的扩展而构建的，如 PyTorch、Keras 和 Tensorflow。</p><div class="nd ne gp gr nf ng"><a href="https://github.com/OpenMined/PySyft" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">露天开采/PySyft</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">一个加密的、保护隐私的深度学习库</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ko ng"/></div></div></a></div><p id="554d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你更感兴趣，你也可以看看 OpenMined 发表的关于这个框架的<a class="ae mn" href="https://arxiv.org/pdf/1811.04017.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>。</p><p id="107d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本文中，我将展示一个使用 PyTorch 的 PySyft 扩展的教程。</p><h2 id="9315" class="nv kv it bd kw nw nx dn la ny nz dp le lv oa ob lg lz oc od li md oe of lk og bi translated">入门-设置库</h2><p id="1d40" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了安装 PySyft，建议您首先设置一个 conda 环境:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="be40" class="nv kv it oi b gy om on l oo op">conda create -n pysyft python=3<br/>conda activate pysyft # or source activate pysyft<br/>conda install jupyter notebook</span></pre><p id="545c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后安装软件包:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="bcef" class="nv kv it oi b gy om on l oo op">pip install syft</span></pre><p id="9da9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请确保您的环境中也安装了 PyTorch 1.0.1 或更高版本。</p><p id="8e80" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="oq">如果你有一个关于 zstd 的安装错误，尝试卸载 zstd 并重新安装。</em></p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="7a19" class="nv kv it oi b gy om on l oo op">pip uninstall zstd<br/>pip install --upgrade zstd</span></pre><p id="8cb6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="oq">如果您在设置时仍然遇到错误，您也可以使用</em> <a class="ae mn" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> <em class="oq"> Colab </em> </a> <em class="oq">笔记本并运行以下代码行:</em></p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f421" class="nv kv it oi b gy om on l oo op">!pip install syft</span></pre><h1 id="38b7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用 PySyft 和 PyTorch 检测垃圾短信</h1><p id="4768" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">包含以下代码的 jupyter 笔记本可以在我的 GitHub 页面上找到。</p><div class="nd ne gp gr nf ng"><a href="https://github.com/andrelmfarias/Private-AI" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">andrelmfarias/私人-AI</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">包含教程和应用程序的库，带有 PySyft-andrelmfarias/Private-AI 的 Private-AI 算法</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="or l nr ns nt np nu ko ng"/></div></div></a></div><p id="fad7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本教程中，我将模拟两个工人，Bob 和 Anne 的设备，在那里存储 SMS 消息。使用 PySyft，我们可以通过使用<em class="oq"> VirtualWorker </em>对象的抽象来模拟这些远程机器。</p><p id="1e04" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们钩住 PyTorch:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="88bf" class="nv kv it oi b gy om on l oo op">import torch<br/>import syft as sy<br/>hook = sy.TorchHook(torch)</span></pre><p id="0a55" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我们创建<em class="oq">虚拟工人:</em></p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="e507" class="nv kv it oi b gy om on l oo op">bob = sy.VirtualWorker(hook, id="bob")<br/>anne = sy.VirtualWorker(hook, id="anne")</span></pre><p id="7430" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们现在可以用方法<em class="oq">向工人发送张量。</em>送(工)。例如:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="cca5" class="nv kv it oi b gy om on l oo op">x = torch.Tensor([2,2,2]).send(bob)<br/>print(x)</span></pre><p id="20d2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您可能会得到类似这样的输出:</p><blockquote class="os ot ou"><p id="aff8" class="lm ln oq lo b lp mi ju lr ls mj jx lu ov mk lx ly ow ml mb mc ox mm mf mg mh im bi translated">(Wrapper)&gt;[pointer tensor | me:79601866508-&gt; bob:62597613886]</p></blockquote><p id="2f45" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您还可以检查指针所指张量的位置:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="07f7" class="nv kv it oi b gy om on l oo op">print(x.location)</span></pre><blockquote class="os ot ou"><p id="9bbd" class="lm ln oq lo b lp mi ju lr ls mj jx lu ov mk lx ly ow ml mb mc ox mm mf mg mh im bi translated"><virtualworker id:bob=""/></p></blockquote><p id="eac5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以看到张量位于一个叫做“鲍勃”的<em class="oq">虚拟工作者</em>处，这个工作者有一个张量。</p><p id="18ea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，您可以使用这些指针进行远程操作:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="d839" class="nv kv it oi b gy om on l oo op">y = torch.Tensor([1,2,3]).send(bob)<br/>sum = x + y<br/>print(sum)</span></pre><blockquote class="os ot ou"><p id="e7b6" class="lm ln oq lo b lp mi ju lr ls mj jx lu ov mk lx ly ow ml mb mc ox mm mf mg mh im bi translated">(Wrapper)&gt;[pointer tensor | me:40216858934-&gt; bob:448194605]</p></blockquote><p id="bafd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以看到在操作之后我们得到了一个指针作为返回。要取回张量，你需要使用方法<em class="oq">。get() </em></p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="973d" class="nv kv it oi b gy om on l oo op">sum = sum.get()<br/>print(sum)</span></pre><blockquote class="os ot ou"><p id="ae55" class="lm ln oq lo b lp mi ju lr ls mj jx lu ov mk lx ly ow ml mb mc ox mm mf mg mh im bi translated">张量([3。, 4., 5.])</p></blockquote><p id="4b5a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最令人惊奇的是，我们可以在这些指针上实现 PyTorch API 提供的所有操作，例如计算损失、将梯度归零、执行反向传播等。</p><p id="ff4e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在你已经理解了<em class="oq">虚拟工人</em>和<em class="oq">指针</em>的基础，我们可以使用联合学习来训练我们的模型。</p><h2 id="d973" class="nv kv it bd kw nw nx dn la ny nz dp le lv oa ob lg lz oc od li md oe of lk og bi translated">准备数据并将其发送给远程工作人员</h2><p id="5ee7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了模拟远程数据，我们将使用<a class="ae mn" href="https://archive.ics.uci.edu/ml/index.php" rel="noopener ugc nofollow" target="_blank"> UCI 机器学习库</a>上的<a class="ae mn" href="https://archive.ics.uci.edu/ml/datasets/sms+spam+collection" rel="noopener ugc nofollow" target="_blank">垃圾短信收集数据集</a>。它由大约 5500 条短信组成，其中大约 13%是垃圾短信。我们将大约一半的消息发送到 Bob 的设备，另一半发送到 Anne 的设备。</p><p id="af7c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于这个项目，我执行了一些文本和数据预处理，我不会在这里展示，但如果你感兴趣，你可以看看我在我的<a class="ae mn" href="https://github.com/andrelmfarias/Private-AI" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> GitHub </strong> </a>页面上使用的<a class="ae mn" href="https://github.com/andrelmfarias/Private-AI/blob/master/Federated_Learning/preprocess.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">脚本</strong> </a>。还请注意，在现实生活中，这种预处理将在每个用户的设备中完成。</p><p id="92ac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们加载处理过的数据:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="0ca1" class="nv kv it oi b gy om on l oo op"># Loading data<br/>inputs = np.load('./data/inputs.npy')<br/>inputs = torch.tensor(inputs)<br/>labels = np.load('./data/labels.npy')<br/>labels = torch.tensor(labels)</span><span id="2719" class="nv kv it oi b gy oy on l oo op"># splitting training and test data<br/>pct_test = 0.2<br/>train_labels = labels[:-int(len(labels)*pct_test)]<br/>train_inputs = inputs[:-int(len(labels)*pct_test)]<br/>test_labels = labels[-int(len(labels)*pct_test):]<br/>test_inputs = inputs[-int(len(labels)*pct_test):]</span></pre><p id="0ab2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我们将数据集一分为二，发送给带有 sy 类的工人。基础数据集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="4efb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在 PyTorch 中训练时，我们使用数据加载器来迭代批处理。使用 PySyft，我们可以使用 FederatedDataLoaders 进行类似的迭代，其中批处理以联合的方式来自几个设备。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h2 id="f586" class="nv kv it bd kw nw nx dn la ny nz dp le lv oa ob lg lz oc od li md oe of lk og bi translated">训练 GRU 模型</h2><p id="8cd4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于这个任务，我决定使用一个基于一层 GRU 网络的分类器。不幸的是，PySyft 的当前版本还不支持 PyTorch 的 RNNs 模块。然而，我能够手工制作一个简单的线性图层的 GRU 网络，这是 PySyft 支持的。</p><p id="f0d6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因为我们这里的重点是 PySyft 框架的使用，所以我将跳过模型的构建。如果你对我是如何构建的感兴趣，你可以在我的<a class="ae mn" href="https://github.com/andrelmfarias/Private-AI" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> GitHub </strong> </a> <strong class="lo iu"> </strong>页面查看一下这个<a class="ae mn" href="https://github.com/andrelmfarias/Private-AI/blob/master/Federated_Learning/handcrafted_GRU.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">脚本</strong> </a>。</p><p id="34c3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们启动模型！</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f7c8" class="nv kv it oi b gy om on l oo op">from handcrafted_GRU import GRU</span><span id="8ed4" class="nv kv it oi b gy oy on l oo op"># Training params<br/>EPOCHS = 15<br/>CLIP = 5 # gradient clipping - to avoid gradient explosion <br/>lr = 0.1<br/>BATCH_SIZE = 32</span><span id="c750" class="nv kv it oi b gy oy on l oo op"># Model params<br/>EMBEDDING_DIM = 50<br/>HIDDEN_DIM = 10<br/>DROPOUT = 0.2</span><span id="b649" class="nv kv it oi b gy oy on l oo op"># Initiating the model<br/>model = GRU(vocab_size=VOCAB_SIZE, hidden_dim=HIDDEN_DIM, embedding_dim=EMBEDDING_DIM, dropout=DROPOUT)</span></pre><p id="f6d1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在训练它！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="d4e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请注意第 8、12、13 和 27 行。这些步骤将 PyTorch 的集中培训与 PySyft 的联合培训区分开来。</p><p id="dc9e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在训练循环结束时取回模型后，我们可以使用它在本地或远程测试集上用类似的方法评估它的性能。在这种情况下，我能够获得超过 97.5%的<a class="ae mn" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html" rel="noopener ugc nofollow" target="_blank"> AUC 得分</a>，表明以联合方式训练模型不会损害性能。然而，我们可以注意到整体时间计算的增加。</p></div><div class="ab cl pb pc hx pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="im in io ip iq"><h1 id="fc47" class="ku kv it bd kw kx pi kz la lb pj ld le jz pk ka lg kc pl kd li kf pm kg lk ll bi translated">结论</h1><p id="9fc3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以看到，使用 PySyft 库及其 PyTorch 扩展，我们可以使用张量指针执行操作，就像我们可以使用 PyTorch API 一样(但仍有一些限制需要解决)。</p><p id="dbb6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于这一点，我们能够在不访问远程和私有数据的情况下训练垃圾邮件检测器模型:对于每一批，我们将模型发送给当前的远程工作器，并在将其发送给下一批的工作器之前将其返回到本地机器。</p><p id="78b3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，这种方法有一个限制:通过取回模型，我们仍然可以访问一些私人信息。假设 Bob 的机器上只有一条短信。当我们取回模型时，我们只需检查模型的哪些嵌入发生了变化，就可以知道哪些是 SMS 的标记(单词)。</p><p id="5666" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了解决这个问题，有两种解决方案:差分隐私和安全多方计算(SMPC)。差分隐私将用于确保该模型不会提供对某些隐私信息的访问。SMPC 是一种加密计算，作为回报，它允许您私下发送模型，这样拥有数据的远程工作人员就看不到您使用的重量。</p><p id="8159" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我将在下一篇文章中展示我们如何用 PySyft 执行这些技术。</p><p id="9216" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">欢迎随时给我反馈和提问！</p><p id="d3ff" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你有兴趣学习更多关于安全和私人人工智能以及如何使用 PySyft 的知识，你也可以在 Udacity  上查看这个免费课程<a class="ae mn" href="https://eu.udacity.com/course/secure-and-private-ai--ud185" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">。这是一门很棒的初学者课程，由 Andrew Trask 教授，他是 OpenMined Initiative 的创始人。</strong></a></p><h1 id="0527" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">来源:</h1><ul class=""><li id="003b" class="mo mp it lo b lp lq ls lt lv pn lz po md pp mh mt mu mv mw bi translated">OpenMined 关于 PySyft 在 arXiv 上的文章:【https://arxiv.org/pdf/1811.04017.pdf T4】</li><li id="1f29" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">谷歌关于联邦学习的文章:<a class="ae mn" href="https://arxiv.org/pdf/1602.05629.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1602.05629.pdf</a></li><li id="8cbc" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">PySyft 初学者教程:<a class="ae mn" href="https://github.com/OpenMined/PySyft/tree/dev/examples/tutorials" rel="noopener ugc nofollow" target="_blank">https://github . com/open mined/PySyft/tree/dev/examples/tutorials</a></li><li id="9b72" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">联邦学习概述:<a class="ae mn" href="https://medium.com/datadriveninvestor/an-overview-of-federated-learning-8a1a62b0600d" rel="noopener">https://medium . com/@ ODSC/an-open-framework-for-secure-and-private-ai-96c 1891 a4b</a></li><li id="cc54" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">一个安全私有 AI 的开放框架:<a class="ae mn" href="https://medium.com/@ODSC/an-open-framework-for-secure-and-private-ai-96c1891a4b" rel="noopener">https://medium . com/@ ODSC/an-Open-Framework-for-Secure-and-Private-AI-96c 1891 a 4b</a></li><li id="2bc2" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">PyTorch + PySyft 的 10 行联合学习:<a class="ae mn" href="https://blog.openmined.org/upgrade-to-federated-learning-in-10-lines/" rel="noopener ugc nofollow" target="_blank">https://blog . open mined . org/upgrade-to-federated-Learning-in-10-lines/</a></li></ul></div></div>    
</body>
</html>