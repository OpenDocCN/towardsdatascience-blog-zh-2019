<html>
<head>
<title>Angular and Bokeh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度和散景</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/angular-and-bokeh-e8acd86e7ab1?source=collection_archive---------12-----------------------#2019-03-09">https://towardsdatascience.com/angular-and-bokeh-e8acd86e7ab1?source=collection_archive---------12-----------------------#2019-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们最近遇到了在应用程序或网站中显示质量图表的问题。但是除此之外，您还希望能够从 python 后端发送更新事件，并拥有所有漂亮的交互，比如按钮按压和文本输入事件，对吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/472c4179d21299e3263712d7f6ca15d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*Uc5KW7hV3kPvueSuKKqVnA.png"/></div></figure><p id="a31a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">散景图组件可能并不总是最佳的解决方案，但是尽管如此，我们希望在 GitHub 知识库中与您分享我们认为是一个很好的、最小的例子，演示了如何将 python 后端集成到 angular 应用程序中。</p><h2 id="d71e" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">起点</h2><p id="a712" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">是我们集成到 Angular 项目中的 BokehJS 库。绘图数据由 websocket 服务提供，在我们的示例中，我们使用 aiohttp，但是您可以设置任何其他 websocket 连接。角度组件可以通过它的标签名集成到 html 中的任何地方，下面的代码片段显示了散景图组件</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="029f" class="ku kv iq lt b gy lx ly l lz ma">&lt;bokeh-chart&gt;&lt;/bokeh-chart&gt;</span></pre><p id="dec7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">散景图组件是一个规则的角度组件，有一个 html 部分</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="5a36" class="ku kv iq lt b gy lx ly l lz ma">&lt;div [id]="id"&gt;&lt;/div&gt;</span></pre><p id="2d76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和打字稿部分。图表组件只需要向它自己的 html 部件提供 id。图表的数据由一个服务提供，这个服务在<strong class="jp ir"> ngOnInit </strong>中的组件初始化时被调用。散景图组件的相关 typescript 部分如下所示</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="438b" class="ku kv iq lt b gy lx ly l lz ma">...<br/>export class BokehChartComponent implements OnInit {<br/>  public id: string;<br/><br/>  constructor(<br/>    private bokehService: BokehService) { }<br/><br/><br/> ngOnInit() {<br/>     this.id = "chart";<br/>     this.bokehService.getChart(this.id);<br/> }<br/>}</span></pre><p id="ed2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于 BokehJS 库没有可用的类型，angular 中的集成并不像它应该的那样简单。人们只能通过库的全局暴露对象来访问库，在这种情况下，它也被命名为<strong class="jp ir"> Bokeh </strong>，并且它是嵌入图表所必需的唯一挂钩。</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="84ab" class="ku kv iq lt b gy lx ly l lz ma">// this is the global hook to the bokehjs lib (without types)<br/>declare var Bokeh: any;</span></pre><p id="7279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当你将普通的 java 脚本插入 angular 应用程序<strong class="jp ir">index.html</strong>最顶层的 html 文件时，这种魔力才会如预期的那样发挥作用</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="5b43" class="ku kv iq lt b gy lx ly l lz ma">&lt;head&gt;<br/> ...<br/>  &lt;link<br/>    href="<a class="ae kt" href="https://cdn.pydata.org/bokeh/release/bokeh-1.0.4.min.css" rel="noopener ugc nofollow" target="_blank">https://cdn.pydata.org/bokeh/release/bokeh-1.0.4.min.css</a>"<br/>    rel="stylesheet" type="text/css"&gt;<br/>  &lt;script src="<a class="ae kt" href="https://cdn.pydata.org/bokeh/release/bokeh-1.0.4.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.pydata.org/bokeh/release/bokeh-1.0.4.min.js</a>"&gt;&lt;/script&gt;<br/> &lt;/head&gt;</span></pre><h2 id="1ef0" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">博客服务</h2><p id="2322" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">通过<strong class="jp ir"> MessageService </strong>为图表提供数据，MessageService 封装了与后端的连接，因此只需通过公开的方法 sendMsg(msg)发送适当格式的消息。</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="2a5a" class="ku kv iq lt b gy lx ly l lz ma">export class BokehService extends Connector {</span><span id="6d08" class="ku kv iq lt b gy mb ly l lz ma">constructor(private msgService: MessageService) {<br/> super(‘BokehService’);<br/> this.msgService.register(this);<br/> }</span><span id="ef57" class="ku kv iq lt b gy mb ly l lz ma">…</span><span id="30ca" class="ku kv iq lt b gy mb ly l lz ma">public getChart(id: string) {<br/> const msg = {<br/> name: ‘addChart’,<br/> args: [id],<br/> action: ‘default’<br/> };<br/> this.msgService.sendMsg(msg);<br/> }</span></pre><p id="8fcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该服务还向后端公开了一个方法，该方法实际上将图表绘制到原生 DOM 元素中，我们首先必须删除之前的绘图。</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="cc9e" class="ku kv iq lt b gy lx ly l lz ma">public plot(msg: Message) {<br/>      const id = msg.args.id;<br/>      const el = document.getElementById(id);<br/>      // first remove the previous charts as child<br/>      // like this, bokeh does not let us update a chart<br/>      while (el.hasChildNodes()) {<br/>            el.removeChild(el.lastChild);<br/>      }<br/>      // be sure to include the correct dom-id as second argument<br/>      Bokeh.embed.embed_item(msg.args.item, id);<br/>    }</span></pre><h2 id="2f32" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">后端服务</h2><p id="ea3a" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在我们的例子中是用 python 写的。我们使用 aiohttp 作为 web 服务器的异步解决方案。在浏览器中启动 angular 应用程序后，angular WebsocketService 立即连接到服务器端的 python 后端。请记住，在生产中，您将在这一点上实现更多的安全性，比如身份验证。后端准备接收来自 angular 的事件，例如给我散景图的数据。</p><p id="41f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自 angular 的消息调用的<strong class="jp ir"> addChart </strong>将 chartItem 作为连接到 websocket 服务的 json 项发送</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="0770" class="ku kv iq lt b gy lx ly l lz ma">    async def addChart(self, id_, user):<br/>        """<br/>        Example for adding a bokeh chart from backend<br/><br/>        """<br/>        chartItem = self.chartProvider.chartExample()<br/>        print("try to add chart for dom-id %s" % id_)<br/>        context = {"name": "BokehService",<br/>                   "args": {"item": chartItem, "id": id_},<br/>                   "action": "plot"}<br/>        await self.send_event(json.dumps(context), user=user)</span></pre><p id="bcb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有趣的部分是 send_event 方法，它实际上是基于我们的 websocket 服务器的实现。如前所述，在您的具体实现中，该部分可能会有所不同。</p><p id="62ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图表的最小示例也是作为<strong class="jp ir"> ChartProvider </strong>类的成员函数编写的，它看起来非常简单，只为散景中的普通正弦图生成数据</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="8e67" class="ku kv iq lt b gy lx ly l lz ma">import time<br/>import numpy as np<br/>from bokeh.plotting import figure<br/>from bokeh.embed import json_item</span><span id="c2bd" class="ku kv iq lt b gy mb ly l lz ma">class ChartProvider():</span><span id="df77" class="ku kv iq lt b gy mb ly l lz ma">    def chartExample(self):<br/>        t0 = time.time()<br/>        # prepare some data<br/>        self.phi += 0.02<br/>        x = np.arange(0., 10., 0.1)<br/>        y = np.sin(x + self.phi)<br/>        # create a new plot<br/>        p = figure()<br/>        p.line(x, y, legend="SIN")<br/>        chart_item = json_item(p)<br/>        print(time.time()-t0)<br/>        return chart_item</span></pre></div></div>    
</body>
</html>