<html>
<head>
<title>Extracting regions of interest from images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从图像中提取感兴趣区域</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extracting-regions-of-interest-from-images-dacfd05a41ba?source=collection_archive---------3-----------------------#2019-08-31">https://towardsdatascience.com/extracting-regions-of-interest-from-images-dacfd05a41ba?source=collection_archive---------3-----------------------#2019-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2eb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用 OpenCV 从图像中高效提取感兴趣区域</h2></div><p id="21df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">欢迎来到本系列的第二篇文章，我们将讨论使用 OpenCV 和 Python 从图像中提取感兴趣区域(ROI)。</p><p id="feb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回顾一下，在本系列的第一篇文章中，我们介绍了从台球桌的图像中提取球和球台边缘的步骤。我们使用简单的 OpenCV 函数，如<strong class="kk iu"> inRange，findContours，boundingRect，minAreaRect，</strong><strong class="kk iu">mineclosing Circle，circle，HoughLines，line 等</strong>来实现我们的目标。</p><p id="a9f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于 OpenCV 的初学者，我建议浏览一下<a class="ae le" href="https://debalb.wordpress.com/2019/08/19/feature-extraction-using-opencv-and-python-part1/" rel="noopener ugc nofollow" target="_blank">的帖子</a>，以便熟悉上述函数的用法。</p><p id="6255" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将着眼于一个更复杂的问题，并探索一些我们可以用来获得预期结果的方法。</p><p id="a170" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们今天的任务是从包含患者大脑活动图快照的图像中提取所需的片段。然后，所提取的片段可以用于许多应用中，例如可以诊断任何健康异常的机器学习模型中。</p><p id="4ab7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从输入图像本身开始。这是神经科学领域中使用的医疗仪器生成的典型报告，这些仪器使用传感器来检测来自患者大脑的信号，并将它们显示为彩色图。通常有四幅地图，每幅地图都描绘了某个特征，并一起进行分析以进行诊断(进一步的细节不在当前范围内)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/d64073786bcd0e717cfd94fb761d7c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*n0mjCiLlxtm6WBxehDeUWA.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Our target image for this exercise containing the four brain maps (image source author)</figcaption></figure><p id="c231" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的图像中，我们只想提取对应于四个地图(头部扫描)的区域，其他的都不提取。所以我们走吧。</p><p id="971c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步是检测我们想要提取的片段的边缘。这是一个多步骤的过程，如下所述:</p><ol class=""><li id="7d2c" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld lw lx ly lz bi translated">使用<strong class="kk iu">“CVT color()”</strong>将 RGB 图像转换为灰度</li><li id="52df" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated">通过应用模糊函数<strong class="kk iu">“Gaussian blur()”</strong>去除灰度图像中的噪声</li><li id="dac1" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated">最后对模糊图像应用<strong class="kk iu">“Canny()”</strong>函数以获得边缘</li></ol><p id="48a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">边缘检测过程的输出如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/fef4979c997d8619539cd59b86e821e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*2BOwQE3QomqRaN9NP7a0FQ.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Edge detection output using Canny algorithm (image source author)</figcaption></figure><p id="ccd0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，虽然识别了脑图片段，但是有许多不需要的边缘需要消除，并且一些边缘之间有间隙需要闭合。</p><p id="2090" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用于此目的的一种常用方法是<strong class="kk iu">形态变换</strong>，它涉及到在图像上使用一系列的膨胀和腐蚀来移除不需要的边缘和闭合间隙。</p><p id="184d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在多次迭代中使用 OpenCV 函数“explain()”和“erode()”来获得如下输出。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/5f49ad11b5d591130d8a0c14b6711472.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*-El8HXND7I3ES17vOwrOwQ.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Some enhancements in the edges using OpenCV (image source author)</figcaption></figure><p id="70ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，边缘现在是完整的，比以前平滑多了。</p><p id="016a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以使用 OpenCV 函数<strong class="kk iu">“find contours()”</strong>提取该图像中的轮廓，并仅选择具有以下属性的轮廓:</p><ol class=""><li id="1ff3" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld lw lx ly lz bi translated">几何形状是圆形或椭圆形</li><li id="14a9" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated">面积高于某个阈值(在本例中，值 7000 很好)。</li></ol><p id="dc49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一部分，我们将使用 OpenCV“bounding rect()”检测每个轮廓的外接矩形，并检查纵横比(高度与宽度之比)是否接近 1。</p><p id="63a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来我们的任务已经完成，但是还需要一点微调。</p><p id="acb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常情况下，在一个片段上检测到多个重叠的轮廓，而我们只对一个感兴趣。</p><p id="6113" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu">非最大值抑制</strong>解决了这个问题，即我们查看所有重叠的轮廓，并选择具有最大面积的轮廓作为最终候选轮廓。逻辑非常简单，因此我们不需要任何内置的 OpenCV 或 Python 函数。</p><p id="8d84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个重要的逻辑是分别识别四个部分，即左上、右上、左下和右下。</p><p id="c874" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也非常简单，包括识别图像中心坐标以及我们检测到的每个片段的质心。分段轮廓的质心检测需要在轮廓上应用 OpenCV <strong class="kk iu"> "moments()" </strong>函数，然后使用下面的公式计算中心 X，Y 坐标:<br/> <strong class="kk iu"> center_x，center _ Y =(int(M[" M10 "]/M[" m00 "])，int(M[" m01 "]/M[" m00 "])</strong></p><p id="1a5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将分段质心坐标与图像中心坐标进行比较，可以让我们将四个分段放置在它们各自的位置。</p><p id="ad72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经确定了四个部分，我们需要建立图像蒙版，它将允许我们从原始图像中提取出想要的特征。</p><p id="1051" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用 OpenCV 函数<strong class="kk iu"> "drawContours()" </strong>，使用白色(R，G，B=255，2555，255)和填充厚度(-1)在黑色背景上绘制所有四个分段轮廓。结果如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e911111e4aea32163352eb6e53902644.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*rb0YbV5oDY-K9um_A2V7ag.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Mask for extracting our ROIs (image source author)</figcaption></figure><p id="fcd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在原始图像上应用这个蒙版可以在我们选择的背景(例如黑色或白色)上得到我们想要的片段。</p><p id="d675" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于黑色背景，我们创建一个黑色画布，然后使用 OpenCV 函数<strong class="kk iu">“bitwise _ and()”</strong>使用之前获得的蒙版在其上绘制。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/d6c7ce1e4ee03f06148253c906bb0d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*u--HszQa0s_BSHp1r1NVpg.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Extracted ROIs over a black background (image source author)</figcaption></figure><p id="0e5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于白色背景，我们首先创建一个白色画布，然后创建一个彩色反转遮罩，如下图所示，使用 OpenCV 函数<strong class="kk iu"> "drawContours()" </strong>以黑色(R，G，B = 0，0，0)绘制轮廓，填充厚度为(-1)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/26c6a996a182b0356ffb7f9f13ce851a.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*UR19iZpD95-e_bJozXAL_w.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">An alternative Inverted mask for ROI extraction (image source author)</figcaption></figure><p id="4c4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们使用 OpenCV<strong class="kk iu">“add()”</strong>函数将这个反转的蒙版与之前获得的黑色背景相加，得到相同的结果，但背景为白色。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c063ff3f85d1677885cf7dfc0aa2f1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*wf0yfMSV-QG05FUg535jLw.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Extracted ROIs over a white background (image source author)</figcaption></figure><p id="5eb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章到此结束，在这篇文章中，我们研究了几种方法，使用这些方法可以很容易地从图像中提取感兴趣的区域。</p><p id="7eb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应当注意，在具有不同复杂度的其他图像的情况下，上面使用的方法可以进行修改。然而，上面讨论的基础知识将为解决此类问题所需的任何高级技术奠定基础。</p><div class="ml mm gp gr mn mo"><a href="https://www.toptal.com/opencv" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">2019 年 10 月 11 位最佳自由职业 OpenCV 开发者——Toptal</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">自 2013 年 10 月 28 日起成为会员 Ivan 是一名算法开发人员和研究科学家(博士),具有很强的数学…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">www.toptal.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ll mo"/></div></div></a></div></div></div>    
</body>
</html>