<html>
<head>
<title>Introduction to Kotlin-Statistics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林统计学简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-kotlin-statistics-cdad3be88b5?source=collection_archive---------8-----------------------#2019-01-30">https://towardsdatascience.com/introduction-to-kotlin-statistics-cdad3be88b5?source=collection_archive---------8-----------------------#2019-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b79f6c371e3db13f22f36929412fe642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tDdP4E23idqu1nME.jpg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Kotlin Island outside of Saint Petersburg, Russia (SOURCE: <a class="ae jd" href="https://commons.wikimedia.org/wiki/File:Kotlin_Island_west_side.jpg#filelinks" rel="noopener ugc nofollow" target="_blank">Wikimedia</a>)</figcaption></figure><div class=""/><div class=""><h2 id="0e4d" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用 Kotlin 的流畅数据科学运算符</h2></div><p id="a417" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在过去的几年里，我一直是 Kotlin 的狂热用户。但是我对 Kotlin 的癖好不仅仅是因为对语言的厌倦或者对<a class="ae jd" href="https://www.jetbrains.com/" rel="noopener ugc nofollow" target="_blank"> JetBrains 产品</a>(包括<a class="ae jd" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm，伟大的 Python IDE </a>)的热情。Kotlin 是一个更加实用的 Scala，或者我听到有人这样描述它:“傻瓜的 Scala”。它的独特之处在于，它试图不这样做，专注于实用性和工业，而不是学术实验。它吸收了迄今为止编程语言(包括 Java、Groovy、Scala、C#和 Python)的许多最有用的特性，并将它们集成到一种语言中。</p><p id="6db3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我对 Kotlin 的使用是出于需要，这是我在 2017 年 KotlinConf 演讲中谈到的事情:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d036" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能会说“Python 是实用的”，当然，我仍然使用 Python，尤其是当我需要某些库的时候。但是，在快速发展的生产应用程序中管理 10，000 行 Python 代码可能会很困难。虽然有些人能够成功地做到这一点，并在 Python 上运行整个公司，但像 Khan Academy 这样的一些公司正在发现 Kotlin 及其静态类型的现代方法的好处。Khan Academy 写了他们从 Python 生态系统转换到 Python/Kotlin 生态系统的经历:</p><div class="ip iq gp gr ir lx"><a href="https://engineering.khanacademy.org/posts/kotlin-adoption.htm" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd jh gy z fp mc fr fs md fu fw jf bi translated">可汗学院服务器上的科特林</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">在 Khan Academy，我们使用 Python 2.7 在 Google 的应用引擎标准上运行我们的 web 应用程序。我们非常喜欢 Python</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">engineering.khanacademy.org</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ix lx"/></div></div></a></div><p id="5413" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Khan 还为希望学习 Kotlin 的 Python 开发人员写了一个文档:</p><div class="ip iq gp gr ir lx"><a href="https://khan.github.io/kotlin-for-python-developers/" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd jh gy z fp mc fr fs md fu fw jf bi translated">面向 Python 开发者的 Kotlin</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">对 Kotlin 的全面介绍，面向具有 Python 或其他动态语言背景的开发人员。</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">khan.github.io</p></div></div></div></a></div><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/869b3ed7f8de1aec5074e88519dd0e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/0*CISqOnzbb-qHa39m.png"/></div></div></figure><p id="a2a5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我跑题了。在这篇文章中我想介绍的是一个我已经工作了一段时间的库，叫做<a class="ae jd" href="https://github.com/thomasnield/kotlin-statistics" rel="noopener ugc nofollow" target="_blank"> Kotlin-Statistics </a>。它最初是一个实验，用函数式和面向对象的编程来表达有意义的统计和数据分析，同时使代码清晰直观。换句话说，我想证明在不求助于数据框架和其他数据科学结构的情况下分析 OOP/功能数据是可能的。</p><div class="ip iq gp gr ir lx"><a href="https://github.com/thomasnield/kotlin-statistics" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd jh gy z fp mc fr fs md fu fw jf bi translated">托马斯尼尔德/科特林-统计</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">科特林惯用的统计运算符。为托马斯尼尔德/科特林统计发展作出贡献</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="mn l mi mj mk mg ml ix lx"/></div></div></a></div><p id="1938" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下面这段 Kotlin 代码为例，我声明了一个<code class="fe mo mp mq mr b">Patient</code>类型，并包含了名字、姓氏、生日和白细胞计数。我还有一个名为<code class="fe mo mp mq mr b">Gender</code>的<code class="fe mo mp mq mr b">enum</code>来反映男性/女性类别。当然，我可以从文本文件、数据库或其他来源导入这些数据，但是现在我打算用 Kotlin 代码来声明它们:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="290e" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">import </strong>java.time.LocalDate<br/><br/><strong class="mr jh">data class </strong>Patient(<strong class="mr jh">val firstName</strong>: String,<br/>                   <strong class="mr jh">val lastName</strong>: String,<br/>                   <strong class="mr jh">val gender</strong>: Gender,<br/>                   <strong class="mr jh">val birthday</strong>: LocalDate,<br/>                   <strong class="mr jh">val whiteBloodCellCount</strong>: Int) { <br/>    <br/>    <strong class="mr jh">val age get</strong>() = <br/>         ChronoUnit.<strong class="mr jh">YEARS</strong>.between(<strong class="mr jh">birthday</strong>, LocalDate.now())<br/>}</span><span id="f7ad" class="mw mx jg mr b gy nc mz l na nb"><strong class="mr jh">val </strong><em class="nd">patients </em>= <em class="nd">listOf</em>(<br/>        Patient(<br/>                <strong class="mr jh">"John"</strong>,<br/>                <strong class="mr jh">"Simone"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1989, 1, 7),<br/>                4500<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Sarah"</strong>,<br/>                <strong class="mr jh">"Marley"</strong>,<br/>                Gender.<strong class="mr jh">FEMALE</strong>,<br/>                LocalDate.of(1970, 2, 5),<br/>                6700<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Jessica"</strong>,<br/>                <strong class="mr jh">"Arnold"</strong>,<br/>                Gender.<strong class="mr jh">FEMALE</strong>,<br/>                LocalDate.of(1980, 3, 9),<br/>                3400<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Sam"</strong>,<br/>                <strong class="mr jh">"Beasley"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1981, 4, 17),<br/>                8800<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Dan"</strong>,<br/>                <strong class="mr jh">"Forney"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1985, 9, 13),<br/>                5400<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Lauren"</strong>,<br/>                <strong class="mr jh">"Michaels"</strong>,<br/>                Gender.<strong class="mr jh">FEMALE</strong>,<br/>                LocalDate.of(1975, 8, 21),<br/>                5000<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Michael"</strong>,<br/>                <strong class="mr jh">"Erlich"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1985, 12, 17),<br/>                4100<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Jason"</strong>,<br/>                <strong class="mr jh">"Miles"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1991, 11, 1),<br/>                3900<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Rebekah"</strong>,<br/>                <strong class="mr jh">"Earley"</strong>,<br/>                Gender.<strong class="mr jh">FEMALE</strong>,<br/>                LocalDate.of(1985, 2, 18),<br/>                4600<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"James"</strong>,<br/>                <strong class="mr jh">"Larson"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1974, 4, 10),<br/>                5100<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Dan"</strong>,<br/>                <strong class="mr jh">"Ulrech"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1991, 7, 11),<br/>                6000<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Heather"</strong>,<br/>                <strong class="mr jh">"Eisner"</strong>,<br/>                Gender.<strong class="mr jh">FEMALE</strong>,<br/>                LocalDate.of(1994, 3, 6),<br/>                6000<br/>        ),<br/>        Patient(<br/>                <strong class="mr jh">"Jasper"</strong>,<br/>                <strong class="mr jh">"Martin"</strong>,<br/>                Gender.<strong class="mr jh">MALE</strong>,<br/>                LocalDate.of(1971, 7, 1),<br/>                6000<br/>        )<br/>)<br/><br/><strong class="mr jh">enum class </strong>Gender {<br/>    <strong class="mr jh">MALE</strong>,<br/>    <strong class="mr jh">FEMALE<br/></strong>}</span></pre><p id="aaa6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">先说一些基本的分析:所有患者的<code class="fe mo mp mq mr b">whiteBloodCellCount</code>的平均值和标准差是多少？我们可以利用 Kotlin 统计数据中的一些扩展函数来快速找到这一点:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="173b" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>averageWbcc =<br/>            <em class="nd">patients</em>.<em class="nd">map </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">whiteBloodCellCount }</strong>.<em class="nd">average</em>()<br/><br/>    <strong class="mr jh">val </strong>standardDevWbcc = <em class="nd">patients</em>.<em class="nd">map </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">whiteBloodCellCount }<br/>                </strong>.<em class="nd">standardDeviation</em>()<br/><br/>    <em class="nd">println</em>(<strong class="mr jh">"Average WBCC: $</strong>averageWbcc<strong class="mr jh">, <br/>               Std Dev WBCC: $</strong>standardDevWbcc<strong class="mr jh">"</strong>)<br/>    <br/>    <em class="nd">// PRINTS: <br/>    // Average WBCC: 5346.153846153846, <br/>         Std Dev WBCC: 1412.2177503341948<br/></em>}</span></pre><p id="3dec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还可以从一组项目中创建一个<code class="fe mo mp mq mr b">DescriptiveStatistics</code>对象:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="8ddb" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>descriptives = <em class="nd">patients<br/>            </em>.<em class="nd">map </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">whiteBloodCellCount }<br/>            </strong>.<em class="nd">descriptiveStatistics<br/><br/>    println</em>(<strong class="mr jh">"Average: ${</strong>descriptives.<strong class="mr jh">mean} <br/>         STD DEV: ${</strong>descriptives.<strong class="mr jh">standardDeviation}"</strong>)<br/>    <br/>    <em class="nd">/* PRINTS<br/>      Average: 5346.153846153846   STD DEV: 1412.2177503341948<br/>     */<br/></em>}</span></pre><p id="b4f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我们有时需要对数据进行切片，不仅是为了更详细的了解，也是为了判断我们的样本。例如，我们是否获得了男性和女性患者的代表性样本？我们可以使用 Kotlin Statistics 中的<code class="fe mo mp mq mr b">countBy()</code>操作符，通过一个<code class="fe mo mp mq mr b">keySelector</code>来计数一个<code class="fe mo mp mq mr b">Collection</code>或<code class="fe mo mp mq mr b">Sequence</code>项目，如下所示:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="59eb" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>genderCounts = <em class="nd">patients</em>.<em class="nd">countBy </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">gender }<br/><br/>    </strong><em class="nd">println</em>(genderCounts)<br/>    <br/>    <em class="nd">// PRINTS<br/>    // {MALE=8, FEMALE=5}<br/></em>}</span></pre><p id="ca1e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将返回一个<code class="fe mo mp mq mr b">Map&lt;Gender,Int&gt;</code>，反映打印时显示<code class="fe mo mp mq mr b">{MALE=8, FEMALE=5}</code> <em class="nd"> </em>的按性别分类的患者计数。</p><p id="902f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，我们的样本有点男性化，但让我们继续。我们还可以使用<code class="fe mo mp mq mr b">averageBy()</code>通过<code class="fe mo mp mq mr b">gender</code>找到平均白细胞数。这不仅接受一个<code class="fe mo mp mq mr b">keySelector</code> lambda，还接受一个<code class="fe mo mp mq mr b">intSelector</code>来从每个<code class="fe mo mp mq mr b">Patient</code>中选择一个整数(我们也可以使用<code class="fe mo mp mq mr b">doubleSelector</code>、<code class="fe mo mp mq mr b">bigDecimalSelector</code>等)。在这种情况下，我们从每个<code class="fe mo mp mq mr b">Patient</code>中选择<code class="fe mo mp mq mr b">whiteBloodCellCount</code>并通过<code class="fe mo mp mq mr b">Gender</code>进行平均，如下所示。有两种方法可以做到这一点:</p><p id="f89e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="nd">方法 1: </em> </strong></p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="78db" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>averageWbccByGender = <em class="nd">patients<br/>            </em>.<em class="nd">groupBy </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">gender }<br/>            </strong>.<em class="nd">averageByInt </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">whiteBloodCellCount }<br/><br/>    </strong><em class="nd">println</em>(averageWbccByGender)<br/>    <br/>    <em class="nd">// PRINTS<br/>    // {MALE=5475.0, FEMALE=5140.0}<br/></em>}</span></pre><p id="bce4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="nd">方法二:</em> </strong></p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="9f40" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>averageWbccByGender = <em class="nd">patients</em>.<em class="nd">averageBy</em>(<br/>            keySelector = <strong class="mr jh">{ it</strong>.<strong class="mr jh">gender }</strong>,<br/>            intSelector = <strong class="mr jh">{ it</strong>.<strong class="mr jh">whiteBloodCellCount }<br/>    </strong>)<br/>    <br/>    <em class="nd">println</em>(averageWbccByGender)<br/><br/>    <em class="nd">// PRINTS<br/>    // {MALE=5475.0, FEMALE=5140.0}<br/></em>}</span></pre><p id="e9a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以男性的平均 WBCC 是 5475，女性是 5140。</p><p id="c269" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">年龄呢？我们对年轻和年长的患者进行了很好的取样吗？如果你看看我们的<code class="fe mo mp mq mr b">Patient</code>类，我们只有一个<code class="fe mo mp mq mr b">birthday</code>可以使用，那就是 Java 8 <code class="fe mo mp mq mr b">LocalDate</code>。但是使用 Java 8 的日期和时间工具，我们可以像这样导出<code class="fe mo mp mq mr b">keySelector</code>中的年龄:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="2e34" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>patientCountByAge = <em class="nd">patients</em>.<em class="nd">countBy</em>(<br/>        keySelector = <strong class="mr jh">{ it.age }<br/>    </strong>)<br/><br/>    patientCountByAge.forEach <strong class="mr jh">{ </strong>age, count <strong class="mr jh">-&gt;<br/>        </strong><em class="nd">println</em>(<strong class="mr jh">"AGE: $</strong>age<strong class="mr jh"> COUNT: $</strong>count<strong class="mr jh">"</strong>)<br/>    <strong class="mr jh">}<br/>    <br/>    </strong><em class="nd">/* PRINTS: <br/>    AGE: 30 COUNT: 1<br/>    AGE: 48 COUNT: 1<br/>    AGE: 38 COUNT: 1<br/>    AGE: 37 COUNT: 1<br/>    AGE: 33 COUNT: 3<br/>    AGE: 43 COUNT: 1<br/>    AGE: 27 COUNT: 2<br/>    AGE: 44 COUNT: 1<br/>    AGE: 24 COUNT: 1<br/>    AGE: 47 COUNT: 1<br/>    */<br/></em>}</span></pre><p id="f77f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您查看我们的代码输出，按年龄计数并没有太大的意义。如果我们能够按照年龄范围来计算，比如 20-29 岁、30-39 岁和 40-49 岁，那就更好了。我们可以使用<code class="fe mo mp mq mr b">binByXXX()</code>操作符来做到这一点。如果我们想要通过一个<code class="fe mo mp mq mr b">Int</code>值(比如年龄)来进行分类，我们可以定义一个从 20 开始的<code class="fe mo mp mq mr b">BinModel</code>，并且将每个<code class="fe mo mp mq mr b">binSize</code>递增 10。我们还使用<code class="fe mo mp mq mr b">valueSelector</code>提供了我们是宁滨的值，即患者的年龄，如下所示:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="b680" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>binnedPatients = <em class="nd">patients</em>.<em class="nd">binByInt</em>(<br/>            valueSelector = <strong class="mr jh">{ it.age }</strong>,<br/>            binSize = 10,<br/>            rangeStart = 20<br/>    )<br/><br/>    binnedPatients.<em class="nd">forEach </em><strong class="mr jh">{ </strong>bin <strong class="mr jh">-&gt;<br/>        </strong><em class="nd">println</em>(bin.<strong class="mr jh">range</strong>)<br/>        bin.<strong class="mr jh">value</strong>.<em class="nd">forEach </em><strong class="mr jh">{ </strong>patient <strong class="mr jh">-&gt;<br/>            </strong><em class="nd">println</em>(<strong class="mr jh">"    $</strong>patient<strong class="mr jh">"</strong>)<br/>        <strong class="mr jh">}<br/>    }<br/></strong>}</span><span id="3adb" class="mw mx jg mr b gy nc mz l na nb">/* PRINTS:</span><span id="8f2b" class="mw mx jg mr b gy nc mz l na nb">[20..29]<br/>    Patient(firstName=Jason, lastName=Miles, gender=MALE... <br/>    Patient(firstName=Dan, lastName=Ulrech, gender=MALE...<br/>    Patient(firstName=Heather, lastName=Eisner, gender=FEMALE...<br/>[30..39]<br/>    Patient(firstName=John, lastName=Simone, gender=MALE...<br/>    Patient(firstName=Jessica, lastName=Arnold, gender=FEMALE...<br/>    Patient(firstName=Sam, lastName=Beasley, gender=MALE...<br/>    Patient(firstName=Dan, lastName=Forney, gender=MALE...<br/>    Patient(firstName=Michael, lastName=Erlich, gender=MALE...<br/>    Patient(firstName=Rebekah, lastName=Earley, gender=FEMALE...<br/>[40..49]<br/>    Patient(firstName=Sarah, lastName=Marley, gender=FEMALE...<br/>    Patient(firstName=Lauren, lastName=Michaels, gender=FEMALE...<br/>    Patient(firstName=James, lastName=Larson, gender=MALE...<br/>    Patient(firstName=Jasper, lastName=Martin, gender=MALE...</span><span id="a0ac" class="mw mx jg mr b gy nc mz l na nb">*/</span></pre><p id="4af8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用 getter 语法查找给定年龄的 bin。例如，我们可以像这样检索年龄为 25 的<code class="fe mo mp mq mr b">Bin</code>，它将返回 20-29 的 bin:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="8e3b" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>    <strong class="mr jh">val </strong>binnedPatients = <em class="nd">patients</em>.<em class="nd">binByInt</em>(<br/>            valueSelector = <strong class="mr jh">{ it.age }</strong>,<br/>            binSize = 10,<br/>            rangeStart = 20<br/>    )<br/><br/>    <em class="nd">println</em>(binnedPatients[25])<br/>}</span></pre><p id="ba3e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们不想将项目收集到 bin 中，而是对每个项目执行聚合，我们也可以通过提供一个<code class="fe mo mp mq mr b">groupOp</code>参数来实现。这允许您使用 lambda 来指定如何为每个<code class="fe mo mp mq mr b">Bin</code>减少每个<code class="fe mo mp mq mr b">List&lt;Patient&gt;</code>。以下是按年龄范围划分的平均白细胞数:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="d37d" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">val </strong>avgWbccByAgeRange = <em class="nd">patients</em>.<em class="nd">binByInt</em>(<br/>        valueSelector = <strong class="mr jh">{ it.age }</strong>,<br/>        binSize = 10,<br/>        rangeStart = 20,<br/>        groupOp = <strong class="mr jh">{ it</strong>.<em class="nd">map </em><strong class="mr jh">{ it</strong>.<strong class="mr jh">whiteBloodCellCount }</strong>.<em class="nd">average</em>() <strong class="mr jh">}<br/></strong>)<br/><br/><em class="nd">println</em>(avgWbccByAgeRange)</span><span id="46ee" class="mw mx jg mr b gy nc mz l na nb">/* PRINTS:<br/>BinModel(bins=[Bin(range=[20..29], value=5300.0), <br/>    Bin(range=[30..39], value=5133.333333333333), <br/>    Bin(range=[40..49], value=5700.0)]<br/>)<br/>*/</span></pre><p id="6e82" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有时，您可能希望执行多个聚合来创建各种指标的报告。这通常可以使用 Kotlin 的 let()操作符来实现。假设您想按性别找出第 1、25、50、75 和 100 个百分点。我们可以有策略地使用一个名为<code class="fe mo mp mq mr b">wbccPercentileByGender()</code>的 Kotlin 扩展函数，它将选取一组患者，并按性别进行百分位数计算。然后我们可以为五个期望的百分点调用它，并将它们打包在一个<code class="fe mo mp mq mr b">Map&lt;Double,Map&lt;Gender,Double&gt;&gt;</code>中，如下所示:</p><pre class="lr ls lt lu gt ms mr mt mu aw mv bi"><span id="3ecf" class="mw mx jg mr b gy my mz l na nb"><strong class="mr jh">fun </strong>main() {<br/><br/>  <strong class="mr jh">fun </strong>Collection&lt;Patient&gt;.wbccPercentileByGender(<br/>        percentile: Double) =<br/>            <em class="nd">percentileBy</em>(<br/>                percentile = percentile,<br/>                keySelector = <strong class="mr jh">{ it</strong>.<strong class="mr jh">gender }</strong>,<br/>                valueSelector = <strong class="mr jh">{ <br/>                    it</strong>.<strong class="mr jh">whiteBloodCellCount</strong>.toDouble() <br/>                <strong class="mr jh">}<br/>            </strong>)<br/><br/>    <strong class="mr jh">val </strong>percentileQuadrantsByGender = <em class="nd">patients</em>.<em class="nd">let </em><strong class="mr jh">{<br/>        </strong><em class="nd">mapOf</em>(1.0 <em class="nd">to </em><strong class="mr jh">it</strong>.<em class="nd">wbccPercentileByGender</em>(1.0),<br/>                25.0 <em class="nd">to </em><strong class="mr jh">it</strong>.<em class="nd">wbccPercentileByGender</em>(25.0),<br/>                50.0 <em class="nd">to </em><strong class="mr jh">it</strong>.<em class="nd">wbccPercentileByGender</em>(50.0),<br/>                75.0 <em class="nd">to </em><strong class="mr jh">it</strong>.<em class="nd">wbccPercentileByGender</em>(75.0),<br/>                100.0 <em class="nd">to </em><strong class="mr jh">it</strong>.<em class="nd">wbccPercentileByGender</em>(100.0)<br/>        )<br/>    <strong class="mr jh">}<br/><br/>    </strong>percentileQuadrantsByGender.<em class="nd">forEach</em>(::println)<br/>}</span><span id="7f8e" class="mw mx jg mr b gy nc mz l na nb">/* PRINTS:<br/>1.0={MALE=3900.0, FEMALE=3400.0}<br/>25.0={MALE=4200.0, FEMALE=4000.0}<br/>50.0={MALE=5250.0, FEMALE=5000.0}<br/>75.0={MALE=6000.0, FEMALE=6350.0}<br/>100.0={MALE=8800.0, FEMALE=6700.0}<br/>*/</span></pre><p id="12e9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是对科特林统计学的简单介绍。请务必阅读该项目的<a class="ae jd" href="https://github.com/thomasnield/kotlin-statistics/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>以查看库中更全面的可用操作符集合(它也有一些不同的工具，如<a class="ae jd" href="https://github.com/thomasnield/kotlin-statistics#naive-bayes-classifier" rel="noopener ugc nofollow" target="_blank">朴素贝叶斯分类器</a>和<a class="ae jd" href="https://github.com/thomasnield/kotlin-statistics#random-selection" rel="noopener ugc nofollow" target="_blank">随机操作符</a>)。</p><p id="da9c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这能证明 Kotlin 在战术上的有效性，但也很强大。Kotlin 能够快速周转以进行快速的特别分析，但是您可以使用静态类型的代码，并通过许多编译时检查对其进行改进。虽然您可能认为 Kotlin 没有 Python 或 R 所拥有的生态系统，但它实际上在 JVM 上已经有了很多库和功能。随着<a class="ae jd" href="https://kotlinlang.org/docs/reference/native-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin/Native </a>获得牵引力，看看什么样的<a class="ae jd" href="https://github.com/altavir/kmath" rel="noopener ugc nofollow" target="_blank">数字库</a>会从 Kotlin 生态系统中崛起将会很有趣。</p><p id="0d89" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了获得一些关于将 Kotlin 用于数据科学目的的资源，我在这里整理了一个列表:</p><div class="ip iq gp gr ir lx"><a href="https://github.com/thomasnield/kotlin-data-science-resources/blob/master/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd jh gy z fp mc fr fs md fu fw jf bi translated">托马斯尼尔德/科特林-数据-科学-资源</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">管理图书馆、媒体、链接和其他资源，将 Kotlin 用于数据科学…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="ne l mi mj mk mg ml ix lx"/></div></div></a></div><p id="f893" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是我为演示 Kotlin 进行数学建模而撰写的一些其他文章:</p><div class="ip iq gp gr ir lx"><a rel="noopener follow" target="_blank" href="/animating-the-traveling-salesman-problem-56da20b95b2f"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd jh gy z fp mc fr fs md fu fw jf bi translated">制作旅行推销员问题的动画</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">关于制作模型动画的经验教训</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mg l"><div class="nf l mi mj mk mg ml ix lx"/></div></div></a></div><div class="ip iq gp gr ir lx"><a rel="noopener follow" target="_blank" href="/sudokus-and-schedules-60f3de5dfe0d"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd jh gy z fp mc fr fs md fu fw jf bi translated">数独和时间表</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">用树搜索解决调度问题</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mg l"><div class="ng l mi mj mk mg ml ix lx"/></div></div></a></div></div></div>    
</body>
</html>