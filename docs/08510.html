<html>
<head>
<title>How to create a CLI in golang with cobra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 cobra 在 golang 中创建 CLI</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-cli-in-golang-with-cobra-d729641c7177?source=collection_archive---------1-----------------------#2019-11-18">https://towardsdatascience.com/how-to-create-a-cli-in-golang-with-cobra-d729641c7177?source=collection_archive---------1-----------------------#2019-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/76adec7a9bd03ad54f85cddf39dca53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaUmBti42n0FMMffyjTtBg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by Marvin Meyer on Unsplash</figcaption></figure><p id="8da0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你有没有想过为什么在 GUI 的世界里，CLI 依然存在？当你自己造一个的时候你会更好的理解它。</p><p id="94ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你学习 golang 的时候，你经常会碰到“golang 是构建 cli 工具的好工具”。这也让我着迷。所以，我试着动手做，找到了一些创建 cli 的教程，但大多数都不是基础的。在本教程中，我将尝试平滑学习曲线。</p><p id="4cfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是基本的 CLI 应用程序，我们将在其中介绍基本的 CLI 操作。我计划写另一篇关于高级 CLI 操作的文章，但那是以后的事了。</p><p id="9be7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们正在创建一个简单的数学 cli，它将能够完成以下两项工作:</p><ul class=""><li id="ba90" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">数字相加</li><li id="ff1a" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">仅偶数或奇数的加法</li></ul><p id="f4bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我知道这些工作不符合你的期望，但相信我，在这之后，你会觉得建立一个 cli 很舒服。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="94bd" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">什么是 CLI？(命令行界面)</h1><p id="80f8" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">CLI 根据软件工程的基本原理工作，接受输入，对其进行处理，然后给出输出。在 CLI 工具中，它不是一个闪烁的前端，而是从<strong class="ke ir"> <em class="my">黑色窗口</em> </strong>获取输入。记住，黑客帝国三部曲。</p><p id="429d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你使用的是<strong class="ke ir"> <em class="my">窗口</em> </strong> <em class="my"> </em>只需在<code class="fe mz na nb nc b">start</code>中键入<em class="my"> </em> <code class="fe mz na nb nc b">cmd</code>或<code class="fe mz na nb nc b">powershell</code>并回车，黑色窗口或蓝色窗口就是 cli。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/e2c8b370f20fe3a284a02b5012d33d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd7_QQz6YXwnVKewPX98Gg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">cmd</figcaption></figure><p id="92ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在 Mac 或 Linux 中，它被称为<code class="fe mz na nb nc b">terminal</code>。</p><blockquote class="ni"><p id="1fb2" class="nj nk iq bd nl nm nn no np nq nr kz dk translated"><a class="ae ns" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">命令行界面</strong> ( <strong class="ak"> CLI </strong> ) </a>是一种与<a class="ae ns" href="https://en.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">计算机程序</a>交互的手段，其中<a class="ae ns" href="https://en.wikipedia.org/wiki/User_(computing)" rel="noopener ugc nofollow" target="_blank">用户</a>(或<a class="ae ns" href="https://en.wikipedia.org/wiki/Client_(computing)" rel="noopener ugc nofollow" target="_blank">客户端</a>)以连续文本行(命令行)的形式向程序发出<a class="ae ns" href="https://en.wikipedia.org/wiki/Command_(computing)" rel="noopener ugc nofollow" target="_blank">命令</a>。处理接口的程序被称为<strong class="ak">命令行解释器</strong>或<strong class="ak">命令行处理器</strong>。— <a class="ae ns" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="534f" class="pw-post-body-paragraph kc kd iq ke b kf nt kh ki kj nu kl km kn nv kp kq kr nw kt ku kv nx kx ky kz ij bi translated">你可以使用很多 CLIs，比如 npm、node、go、python、docker、Kubernetes 等等。所有这些都是与软件交互的理想界面。</p><h2 id="1701" class="ny lw iq bd lx nz oa dn mb ob oc dp mf kn od oe mj kr of og mn kv oh oi mr oj bi translated">为什么他们还在使用 CLI？</h2><ul class=""><li id="3ea7" class="la lb iq ke b kf mt kj mu kn ok kr ol kv om kz lf lg lh li bi translated">它重量轻，速度快。</li><li id="1096" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">最少或没有依赖性。</li><li id="b9c5" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">最适合系统管理和基于任务的自动化等。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="15c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">理论讲够了，让我们从需求开始:</p><ul class=""><li id="0f97" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">golang 已安装(我使用的是 go1.11.5 windows/amd64)</li><li id="1fa5" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">眼镜蛇库(<code class="fe mz na nb nc b">go get -u github.com/spf13/cobra/cobra</code>)</li><li id="0c72" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">您选择的任何代码编辑器。(我用的是 VS 代码)</li></ul><blockquote class="on oo op"><p id="4930" class="kc kd my ke b kf kg kh ki kj kk kl km oq ko kp kq or ks kt ku os kw kx ky kz ij bi translated">我推荐使用 VS 代码，安装微软的<code class="fe mz na nb nc b">go</code>扩展。这将根据代码更新导入语句。如果您使用新包，它将在保存时导入该包。如果某个包已导入但未被使用，它会将该包从导入中移除。</p></blockquote><p id="7cac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">Cobra</code>图书馆简介。我们将使用 cobra cli 来使用 cobra 库。我们将使用命令行界面来构建命令行界面😃</p><blockquote class="ni"><p id="743f" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">Cobra 既是一个用于创建强大的现代 CLI 应用程序的库，也是一个用于生成应用程序和命令文件的程序。</p><p id="8cef" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">很多应用最广泛的 Go 项目都是用 Cobra 搭建的，比如:<a class="ae ns" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>、<a class="ae ns" href="http://gohugo.io/" rel="noopener ugc nofollow" target="_blank"> Hugo </a>、<a class="ae ns" href="https://github.com/docker/distribution" rel="noopener ugc nofollow" target="_blank"> Docker (distribution) </a>等。— <a class="ae ns" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> Github </a></p></blockquote></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="886a" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">Cobra 概念</h1><p id="a833" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">Cobra 建立在命令、参数和标志的结构上。</p><ul class=""><li id="f419" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">命令</strong>代表动作</li><li id="8d13" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><strong class="ke ir"> Args </strong>是事物</li><li id="5372" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><strong class="ke ir">标志</strong>是那些动作的修饰符</li></ul><p id="270d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本结构就像一个简单的句子</p><p id="5a10" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">APPNAME Command Args --Flags</code>或<code class="fe mz na nb nc b">APPNAME Command --Flags Args</code></p><p id="3260" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">为 Ex。</strong></p><ul class=""><li id="560d" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><code class="fe mz na nb nc b">git clone URL -bare</code></li><li id="b962" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe mz na nb nc b">go get -u URL</code></li><li id="1354" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe mz na nb nc b">npm install package --save</code></li><li id="a743" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe mz na nb nc b">docker run image -d</code></li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="eadb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> GOPATH </strong>的之外创建一个新的项目目录<strong class="ke ir">。我已经为本教程创建了<code class="fe mz na nb nc b"><strong class="ke ir">my-calc</strong></code>项目目录。你可以说出你的任何选择。</strong></p><p id="c422" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> GOPATH </strong>之外创建项目简化了本地文件的导入。初始化项目中的模块。该模块将保留该项目中需要和使用的所有库和依赖项。它类似于 nodejs 中的<code class="fe mz na nb nc b">package.json</code>。要了解关于这些模块的更多信息，请阅读这篇伟大的<a class="ae ns" href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16" rel="noopener">文章</a>。</p><blockquote class="ni"><p id="be02" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">一个<em class="ot">模块</em>是一个相关 Go 包的集合，这些包作为一个单元一起被版本化。</p><p id="0717" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">模块记录精确的依赖需求，并创建可重复的构建。— <a class="ae ns" href="http://A module is a collection of related Go packages that are versioned together as a single unit.  Modules record precise dependency requirements and create reproducible builds." rel="noopener ugc nofollow" target="_blank">维基</a></p></blockquote><p id="9071" class="pw-post-body-paragraph kc kd iq ke b kf nt kh ki kj nu kl km kn nv kp kq kr nw kt ku kv nx kx ky kz ij bi translated">在您选择的命令行中打开项目目录。我用的是<code class="fe mz na nb nc b"><strong class="ke ir">bash</strong></code> <strong class="ke ir"> </strong>。进入项目目录后，运行下面的命令来初始化模块。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="05d9" class="ny lw iq nc b gy oy oz l pa pb"><strong class="nc ir">go mod init my-calc</strong></span></pre><p id="a015" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以注意到它在项目中创建了一个<strong class="ke ir"> </strong> <code class="fe mz na nb nc b"><strong class="ke ir">go.mod</strong></code>文件。</p><blockquote class="on oo op"><p id="728c" class="kc kd my ke b kf kg kh ki kj kk kl km oq ko kp kq or ks kt ku os kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>默认情况下，在<code class="fe mz na nb nc b"><strong class="ke ir"><em class="iq">$GOPATH</em></strong></code>内创建模块是禁用的。如果你运行上面的命令— <code class="fe mz na nb nc b"><strong class="ke ir"><em class="iq">go: modules disabled inside GOPATH/src by GO111MODULE=auto; see ‘go help modules’</em></strong></code>，你会得到这个错误。如果您仍然想在<code class="fe mz na nb nc b"><strong class="ke ir">$GOPATH</strong></code>中创建 go 模块，那么首先将<code class="fe mz na nb nc b"><strong class="ke ir"><em class="iq">GO111MODULE</em></strong></code>环境变量设置为<code class="fe mz na nb nc b"><strong class="ke ir"><em class="iq">on</em></strong></code> <strong class="ke ir">。</strong> <code class="fe mz na nb nc b"><strong class="ke ir">export GO111MODULE=on</strong></code></p></blockquote><p id="7607" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，无论何时你在项目中使用任何第三方包，它都将把它保存为与他们版本的依赖关系。这样，即使库的新版本中引入了重大更改，您的项目也会按预期工作。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="2af5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你还没有安装<code class="fe mz na nb nc b"><strong class="ke ir">cobra</strong></code> <strong class="ke ir"> </strong>库，你可以使用下面的命令来安装。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="6c12" class="ny lw iq nc b gy oy oz l pa pb">go get -u github.com/spf13/cobra/cobra</span></pre><p id="0670" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe mz na nb nc b">cobra init</code>命令初始化项目的 cli 脚手架。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="0db0" class="ny lw iq nc b gy oy oz l pa pb">cobra init --pkg-name my-calc</span></pre><p id="7e66" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">编辑:</strong>感谢<a class="pc pd ep" href="https://medium.com/u/9d89a5180aaf?source=post_page-----d729641c7177--------------------------------" rel="noopener" target="_blank">布兰登卡顿，</a>对 init 命令的更新。</p><p id="7a1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它将用<code class="fe mz na nb nc b">cobra</code>库初始化<code class="fe mz na nb nc b">my-calc</code>项目。您可以观察到它在项目中创建了几个文件。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="709a" class="ny lw iq nc b gy oy oz l pa pb">▾ my-calc/<br/>  ▾ cmd/<br/>     root.go<br/>   main.go</span></pre><p id="7f05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">main.go</code>是<code class="fe mz na nb nc b">cli</code>的切入点。在<code class="fe mz na nb nc b">main.go</code>内部，它正在调用<code class="fe mz na nb nc b">cmd/root.go</code>的<code class="fe mz na nb nc b">Execute</code>函数。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="a5a5" class="ny lw iq nc b gy oy oz l pa pb">// main.go<br/>package main</span><span id="2995" class="ny lw iq nc b gy pe oz l pa pb"><strong class="nc ir">import "my-calc/cmd"</strong></span><span id="cdfc" class="ny lw iq nc b gy pe oz l pa pb">func main() {<br/>  <strong class="nc ir"> cmd.Execute()<br/></strong>}</span></pre><p id="12b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们来考察一下<code class="fe mz na nb nc b">root.go</code>。</p><h1 id="8538" class="lv lw iq bd lx ly pf ma mb mc pg me mf mg ph mi mj mk pi mm mn mo pj mq mr ms bi translated">rootCmd</h1><p id="ffd9" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">Root 命令是任何 cli 的基本命令。为了前任。<code class="fe mz na nb nc b">go get URL</code> — <code class="fe mz na nb nc b"><strong class="ke ir">go</strong></code> <strong class="ke ir"> </strong>是这里的根命令，<code class="fe mz na nb nc b"><strong class="ke ir">get</strong></code> <strong class="ke ir"> </strong>是<code class="fe mz na nb nc b"><strong class="ke ir">go</strong></code> <strong class="ke ir"> </strong>的子命令。在<code class="fe mz na nb nc b"><strong class="ke ir">root.go</strong></code>中，用<code class="fe mz na nb nc b">cobra</code>命令初始化<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code> <strong class="ke ir"> </strong>结构<strong class="ke ir"> </strong>变量。cli 中的所有其他命令都将是<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>和<strong class="ke ir">的子命令。</strong></p><p id="1cf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在编辑器中打开<code class="fe mz na nb nc b">root.go</code>并在<code class="fe mz na nb nc b">rootCmd</code>中取消注释</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="6e70" class="ny lw iq nc b gy oy oz l pa pb"><strong class="nc ir">Run: func(cmd *cobra.Command, args []string) {},</strong></span></pre><p id="e6cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并将<code class="fe mz na nb nc b">fmt.Println("Hello CLI")</code>粘贴在花括号内。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="a4ca" class="ny lw iq nc b gy oy oz l pa pb"><strong class="nc ir">Run: func(cmd *cobra.Command, args []string) {fmt.Println("Hello CLI"},</strong></span></pre><blockquote class="ni"><p id="23b8" class="nj nk iq bd nl nm pk pl pm pn po kz dk translated">⚠️不要去掉右花括号后面的逗号。它将抛出语法错误。</p></blockquote><p id="a536" class="pw-post-body-paragraph kc kd iq ke b kf nt kh ki kj nu kl km kn nv kp kq kr nw kt ku kv nx kx ky kz ij bi translated">打开<code class="fe mz na nb nc b">my-calc</code>项目内的终端并运行</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="0db4" class="ny lw iq nc b gy oy oz l pa pb">go install my-calc</span></pre><p id="74fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该命令将在<code class="fe mz na nb nc b"><strong class="ke ir">$GOPATH/bin</strong></code> <strong class="ke ir"> </strong>文件夹中生成项目的二进制或可执行文件。</p><p id="29db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在在终端中运行<code class="fe mz na nb nc b"><strong class="ke ir">my-calc</strong></code> <strong class="ke ir"> </strong>。因为它保存在 bin 文件夹中，所以您不必为此设置环境变量。</p><blockquote class="ni"><p id="6cc9" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">cli 的名称是<strong class="ak"> rootCmd </strong>。<strong class="ak"> my-calc </strong>是 rootCmd。</p></blockquote><p id="78bd" class="pw-post-body-paragraph kc kd iq ke b kf nt kh ki kj nu kl km kn nv kp kq kr nw kt ku kv nx kx ky kz ij bi translated">您将看到类似如下的输出。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/337e38efd4adf5c6a1161d03b7ba725f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mT8xfNAKDvSds-_AwRDrYA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">hello-cli</figcaption></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="19f1" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">初始化</h1><p id="c221" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">每当一个包在 golang 中初始化时，这是第一个被调用的函数。<code class="fe mz na nb nc b"><strong class="ke ir">cobra.OnInitialize(funcDeclarations)</strong></code> <strong class="ke ir"> </strong>在命令的初始化中追加用户自定义函数。<strong class="ke ir"> <em class="my">每当运行或调用命令时，它将首先执行命令初始化中的所有函数，然后运行 execute 方法。</em> </strong> <em class="my"> </em>这种初始化可以用于加载配置文件或者可以用作构造函数。这完全取决于你的用例以及你的创造力。</p><p id="9d64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我想我在这里失去了你。我们用一个例子来理解这个。</p><p id="c8aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mz na nb nc b">root.go</code>中，命令是<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>。</p><p id="c9e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b"><strong class="ke ir">cobra.OnInitialize(initConfig)</strong></code> <strong class="ke ir"> </strong>在<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>的初始化中追加了<code class="fe mz na nb nc b"><strong class="ke ir">initConfig</strong></code>函数声明。所以，每当<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code> <strong class="ke ir"> </strong>的 execute 方法(<code class="fe mz na nb nc b"><strong class="ke ir">RUN: func</strong></code>)运行时，<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code> <strong class="ke ir"> </strong>将首先运行<code class="fe mz na nb nc b"><strong class="ke ir">initConfig</strong></code>函数。一旦所有初始化函数的执行结束，它将运行<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>的<code class="fe mz na nb nc b"><strong class="ke ir">RUN: func</strong></code>执行方法。</p><p id="1b2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了可视化，在<code class="fe mz na nb nc b"><strong class="ke ir">initConfig</strong></code> <strong class="ke ir"> </strong>功能中添加一条打印消息。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="b9fa" class="ny lw iq nc b gy oy oz l pa pb">func initConfig() {</span><span id="18e7" class="ny lw iq nc b gy pe oz l pa pb"><strong class="nc ir">   fmt.Println("inside initConfig")<br/>...</strong></span></pre><p id="0e0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存更改。打开<code class="fe mz na nb nc b">my-calc</code>项目内的终端。</p><p id="c55e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重建二进制<code class="fe mz na nb nc b"><strong class="ke ir">go install my-calc</strong></code> <strong class="ke ir">。</strong></p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="f544" class="ny lw iq nc b gy oy oz l pa pb">go install my-calc</span></pre><p id="0164" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行<code class="fe mz na nb nc b"><strong class="ke ir">my-calc</strong></code>。无论何时在 cli 中进行任何更改，都必须重新构建二进制文件。运行<code class="fe mz na nb nc b"><strong class="ke ir">go install my-calc</strong></code>以在 cli 命令中反映它。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pq"><img src="../Images/164dfb53ac37451882cf3bf249b431db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjnoric819SKTAB0bsazlQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">initConfig</figcaption></figure><p id="a70e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以看到<code class="fe mz na nb nc b">initConfig</code>先运行，后<code class="fe mz na nb nc b">Hello CLI</code>运行。</p><p id="75b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了理解 cli 的完整流程，在<code class="fe mz na nb nc b"><strong class="ke ir">main.go</strong></code>中的<code class="fe mz na nb nc b"><strong class="ke ir">init</strong></code>函数内添加一条消息，在<code class="fe mz na nb nc b"><strong class="ke ir">main</strong></code> <strong class="ke ir"> </strong>函数内添加一条消息。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="c04f" class="ny lw iq nc b gy oy oz l pa pb">// root.go</span><span id="b992" class="ny lw iq nc b gy pe oz l pa pb">func init() {<br/>     <strong class="nc ir">fmt.Println("inside init")<br/>     </strong>cobra.OnInitialize(initConfig)<br/>...</span><span id="336d" class="ny lw iq nc b gy pe oz l pa pb">// main.go</span><span id="01ce" class="ny lw iq nc b gy pe oz l pa pb">func main() {<br/>     <strong class="nc ir">fmt.Println("inside main")</strong><br/>     cmd.Execute()<br/>}</span></pre><p id="2703" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存更改。重建二进制<code class="fe mz na nb nc b"><strong class="ke ir">go install my-calc</strong></code>并运行<code class="fe mz na nb nc b"><strong class="ke ir">my-calc</strong></code> <strong class="ke ir">。</strong></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pq"><img src="../Images/e54e3fe36aba7b1357dc0df7c8838030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YdtY9ZLB8xaetsq5jQ0yw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">cli flow</figcaption></figure><p id="3697" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您已经了解了 cli 命令流。</p><p id="7a2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">init</code>函数中最后一个是<code class="fe mz na nb nc b">flags</code>。</p><p id="dc96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">标志就像命令的修饰符。你可以把它们看作是条件动作。我们将在教程的后面了解更多。</p><p id="ba95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有两种类型的旗帜<code class="fe mz na nb nc b"><strong class="ke ir">Persistent Flags</strong></code> <strong class="ke ir"> </strong>和<code class="fe mz na nb nc b"><strong class="ke ir">Local Flags</strong></code> <strong class="ke ir"> </strong>。</p><ul class=""><li id="b637" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">持久标志:</strong>该标志可用于分配给它的命令以及该命令的所有子命令。</li><li id="da1f" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><strong class="ke ir">本地标志:</strong>该标志仅适用于其被分配到的命令。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="424b" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">初始化配置</h1><p id="939e" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">该功能设置主目录中的配置路径，配置文件名为<code class="fe mz na nb nc b">.my-calc</code>。如果配置文件存在，它将使用该文件。</p><p id="d782" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b"><strong class="ke ir">viper</strong></code> <strong class="ke ir"> </strong>库以 go 应用的配置解决方案而闻名。它读取 JSON、TOML、YAML、HCL、envfile 和 Java 属性配置文件。它不仅仅是读取配置。要了解更多信息，请点击此<a class="ae ns" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="a834" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过该功能，我们完成了<code class="fe mz na nb nc b">root.go</code>检查。它有点长，但是理解我们正在使用的东西是有好处的。</p><blockquote class="on oo op"><p id="7e31" class="kc kd my ke b kf kg kh ki kj kk kl km oq ko kp kq or ks kt ku os kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>现在如果你愿意，你可以从<code class="fe mz na nb nc b"><em class="iq">root.go</em></code>和<code class="fe mz na nb nc b"><em class="iq">main.go</em></code>中删除所有的打印语句。为了保持代码的整洁，我已经删除了所有的打印语句。</p></blockquote></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="00fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是时候在我们的 cli 中添加一些命令了。我们已经创建了一个命令<code class="fe mz na nb nc b"><strong class="ke ir">my-calc</strong></code>作为<code class="fe mz na nb nc b">rootCmd</code>，它返回<strong class="ke ir"> Hello CLI。</strong></p><h1 id="1dff" class="lv lw iq bd lx ly pf ma mb mc pg me mf mg ph mi mj mk pi mm mn mo pj mq mr ms bi translated">添加数字</h1><p id="5515" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">在项目目录中打开终端并创建一个名为<code class="fe mz na nb nc b"><strong class="ke ir">add</strong></code>的命令。添加新命令的 cobra 命令是</p><p id="8037" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b"><strong class="ke ir">cobra add &lt;commandName&gt;</strong></code></p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="f491" class="ny lw iq nc b gy oy oz l pa pb"><strong class="nc ir">cobra add add</strong></span><span id="8720" class="ny lw iq nc b gy pe oz l pa pb"><strong class="nc ir">// output</strong><br/>add created at C:\Work\golang\my-calc</span></pre><p id="85d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">查看<code class="fe mz na nb nc b">cmd</code>文件夹，里面添加了一个<code class="fe mz na nb nc b">add.go</code>文件。</p><p id="6c42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">打开<code class="fe mz na nb nc b">add.go</code>。它类似于<code class="fe mz na nb nc b">root.go</code>。</p><p id="3aa5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，一个<code class="fe mz na nb nc b">addCmd</code>结构变量被声明为<code class="fe mz na nb nc b">*cobra.Command</code>类型。</p><p id="be07" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">*cobra.Command</code>有<code class="fe mz na nb nc b">RUN</code>，它是一个 func，带<code class="fe mz na nb nc b"><strong class="ke ir">*cobra.Command</strong></code>的指针和一段字符串<code class="fe mz na nb nc b"><strong class="ke ir">[]string</strong></code>。</p><p id="8eb9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后在<code class="fe mz na nb nc b">init</code>函数中初始化。在<code class="fe mz na nb nc b">init</code>中，添加到<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>T34 中。我们可以理解为<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>的子命令或子命令<code class="fe mz na nb nc b"><strong class="ke ir">addCmd</strong></code>。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="068a" class="ny lw iq nc b gy oy oz l pa pb">func init() {<br/>   <strong class="nc ir">rootCmd.AddCommand(addCmd)</strong></span></pre><p id="4d8d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在终端中，使用<code class="fe mz na nb nc b"><strong class="ke ir">go install my-calc</strong></code>命令重建二进制文件，并运行<code class="fe mz na nb nc b"><strong class="ke ir">my-calc add</strong></code> <strong class="ke ir">。</strong></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pq"><img src="../Images/79c468f8ca86bf6e72940416d80563a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe_F6Aj9Di5yExrb2WCiDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">add called</figcaption></figure><p id="39fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">add</code>命令工作正常。是时候修改一下加一串数字了。</p><p id="a3a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些命令只接受一部分字符串作为参数。为了将数字相加，我们首先必须将<code class="fe mz na nb nc b">string</code>转换成<code class="fe mz na nb nc b">int</code>，然后返回结果。我们将使用<code class="fe mz na nb nc b">strconv</code>库将<code class="fe mz na nb nc b">string</code>转换成<code class="fe mz na nb nc b">int</code>。</p><p id="cb58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导入<code class="fe mz na nb nc b">strconv</code>包。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="f545" class="ny lw iq nc b gy oy oz l pa pb">import (<br/>   "fmt"<br/>   <strong class="nc ir">"strconv"</strong></span><span id="2a6b" class="ny lw iq nc b gy pe oz l pa pb">   "github.com/spf13/cobra"<br/>)</span></pre><p id="3125" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mz na nb nc b">add.go</code>内部，创建一个新的<code class="fe mz na nb nc b"><strong class="ke ir">addInt</strong></code> <strong class="ke ir"> </strong>函数。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="17c3" class="ny lw iq nc b gy oy oz l pa pb">// add.go</span><span id="fd6c" class="ny lw iq nc b gy pe oz l pa pb"><strong class="nc ir">func addInt(args []string) {</strong></span><span id="a0c7" class="ny lw iq nc b gy pe oz l pa pb">   var sum int</span><span id="a0e3" class="ny lw iq nc b gy pe oz l pa pb">  // iterate over the arguments<br/>  // the first return value is index of args, we can omit it using _<br/>  <br/>   for _, ival := range args {</span><span id="8d85" class="ny lw iq nc b gy pe oz l pa pb"> // strconv is the library used for type conversion. for string<br/> // to int conversion Atio method is used.<br/>      <strong class="nc ir"> itemp, err := strconv.Atoi(ival)</strong><br/>       <br/>       if err != nil {<br/>           fmt.Println(err)<br/>       }<br/>       sum = sum + itemp<br/>    }</span><span id="bdf3" class="ny lw iq nc b gy pe oz l pa pb">   fmt.Printf("Addition of numbers %s is %d", args, sum)<br/>}</span></pre><p id="0bc9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存更改。</p><p id="f09a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mz na nb nc b">addCmd</code>变量中，更新<code class="fe mz na nb nc b">RUN</code>功能。删除打印信息，用<code class="fe mz na nb nc b">args</code>调用<code class="fe mz na nb nc b">addInt</code>功能。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="4eca" class="ny lw iq nc b gy oy oz l pa pb">// addCmd<br/>Run: func(cmd *cobra.Command, args []string) {<br/>  addInt(args)<br/>},</span></pre><p id="dd79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe mz na nb nc b">go install my-calc</code>重建二进制文件。</p><p id="8f44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行<code class="fe mz na nb nc b">my-calc add 2 3</code>。</p><blockquote class="ni"><p id="d292" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">⚠️Don't 忘记了争论之间的空隙。</p></blockquote><figure class="ps pt pu pv pw jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pr"><img src="../Images/532577e12867fe34bd101b84e270554f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxK46mbo2T-qwTsms2fHrw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">add int</figcaption></figure><p id="2a4d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以传递任意多个参数。如果你记得 args 是一段字符串。但是这个功能是有限制的。它只能将整数相加，不能将小数相加。在<code class="fe mz na nb nc b">addInt</code>函数中，我们将字符串转换成<code class="fe mz na nb nc b">int</code>而不是<code class="fe mz na nb nc b">float32/64</code>。</p><p id="a3bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是时候在<code class="fe mz na nb nc b">addCmd</code>中引入一只<code class="fe mz na nb nc b">flag</code>了。该标志将帮助 cli 决定是<code class="fe mz na nb nc b">int </code>操作还是<code class="fe mz na nb nc b">float</code>操作。</p><p id="732e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mz na nb nc b">add.go</code>中，在<code class="fe mz na nb nc b">init</code> func 内，创建一个 bool 类型的本地标志<code class="fe mz na nb nc b"><strong class="ke ir">Flags().BoolP</strong></code>。其名称为<code class="fe mz na nb nc b">float</code>，简称<code class="fe mz na nb nc b">f</code>，默认值<code class="fe mz na nb nc b">false</code>和描述。默认值非常重要。意味着即使命令中没有调用标志，标志值也会是<code class="fe mz na nb nc b">false</code>。对于 bool 类型，如果调用一个标志，它将切换默认值。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="e711" class="ny lw iq nc b gy oy oz l pa pb">// add.go</span><span id="4eba" class="ny lw iq nc b gy pe oz l pa pb">func init() {<br/> rootCmd.AddCommand(addCmd)<br/> <strong class="nc ir">addCmd.Flags().BoolP("float", "f", false, "Add Floating Numbers")</strong><br/>}</span></pre><p id="bc51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mz na nb nc b">add.go</code>中创建新的<code class="fe mz na nb nc b">addFloat</code>功能</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="b524" class="ny lw iq nc b gy oy oz l pa pb">// add.go</span><span id="a0ad" class="ny lw iq nc b gy pe oz l pa pb">func addFloat(args []string) {</span><span id="5db8" class="ny lw iq nc b gy pe oz l pa pb">    var sum float64</span><span id="e8a4" class="ny lw iq nc b gy pe oz l pa pb">    for _, fval := range args {<br/>    // convert string to float64 <br/>       <strong class="nc ir">ftemp, err := strconv.ParseFloat(fval, 64)</strong></span><span id="de2e" class="ny lw iq nc b gy pe oz l pa pb">       if err != nil {<br/>          fmt.Println(err)<br/>       }<br/>       sum = sum + ftemp<br/>    }</span><span id="482c" class="ny lw iq nc b gy pe oz l pa pb">    fmt.Printf("Sum of floating numbers %s is %f", args, sum)<br/>}</span></pre><p id="27c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该功能与<code class="fe mz na nb nc b">addInt</code>相同，只是将<code class="fe mz na nb nc b"><strong class="ke ir">string </strong></code>转换为<code class="fe mz na nb nc b"><strong class="ke ir">float64</strong></code>。</p><p id="ea11" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mz na nb nc b">addCmd</code> <code class="fe mz na nb nc b">RUN</code>函数中，会根据标志调用<code class="fe mz na nb nc b">addInt</code>或<code class="fe mz na nb nc b">addFloat</code>。如果标志<code class="fe mz na nb nc b">--float or -f</code>通过，那么它将调用<code class="fe mz na nb nc b">addFloat</code>。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="c458" class="ny lw iq nc b gy oy oz l pa pb">// add.go <br/>// addCmd</span><span id="7eba" class="ny lw iq nc b gy pe oz l pa pb">Run: func(cmd *cobra.Command, args []string) {<br/> <strong class="nc ir">// get the flag value, its default value is false</strong><br/> <strong class="nc ir">fstatus, _ := cmd.Flags().GetBool("float")</strong></span><span id="3e93" class="ny lw iq nc b gy pe oz l pa pb"> if fstatus { // if status is true, call addFloat<br/>   <strong class="nc ir"> addFloat(args)</strong><br/>  } else {<br/>    <strong class="nc ir">addInt(args)</strong><br/>  }<br/>},</span></pre><p id="88b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存所有更改。使用<code class="fe mz na nb nc b">go install my-calc</code>重建二进制文件。</p><p id="67ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行<code class="fe mz na nb nc b">my-calc add 1.2 2.5 -f</code>或<code class="fe mz na nb nc b">my-calc add 1.2 2.5 --float</code></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/e5be55a3eb2f13ae8a678fe79d64111d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgHCe30Lxd1kz8tf1_gnRw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">add float flag</figcaption></figure><p id="574c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以用旗子做很多事情。您甚至可以将值传递给标志，如一片 int、float、string 等。</p><p id="11a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">操作实现的基本添加完成。</p><p id="09e2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们通过向<code class="fe mz na nb nc b">addCmd</code>添加子命令来扩展它。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="4a2c" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">添加偶数</h1><p id="e5a5" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">在项目目录中打开终端，创建一个新的<code class="fe mz na nb nc b"><strong class="ke ir">even</strong></code>命令。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="5e9c" class="ny lw iq nc b gy oy oz l pa pb">cobra add even</span></pre><p id="c32c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">even</code>命令作为<code class="fe mz na nb nc b">even.go</code>添加到<code class="fe mz na nb nc b">cmd</code>文件夹中。</p><p id="7926" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在编辑器中打开<code class="fe mz na nb nc b">even.go</code>。将<code class="fe mz na nb nc b">init</code>中的<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>改为<code class="fe mz na nb nc b"><strong class="ke ir">addCmd</strong></code>。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="8be2" class="ny lw iq nc b gy oy oz l pa pb">// even.go<br/>func init() {<br/>    <strong class="nc ir">addCmd.AddCommand(evenCmd)<br/></strong>...<br/>}</span></pre><p id="e073" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">addCmd.AddCommand(evenCmd)</code>将添加<code class="fe mz na nb nc b">evenCmd</code>作为<code class="fe mz na nb nc b">addCmd</code>的子命令或子命令。</p><p id="440e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更新<code class="fe mz na nb nc b">evenCmd</code>结构变量的<code class="fe mz na nb nc b">RUN</code>方法。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="d498" class="ny lw iq nc b gy oy oz l pa pb">// even.go<br/>Run: func(cmd *cobra.Command, args []string) {</span><span id="81b7" class="ny lw iq nc b gy pe oz l pa pb">   var evenSum int<br/>   for _, ival := range args {<br/>     <strong class="nc ir"> itemp, _ := strconv.Atoi(ival)</strong><br/>      <strong class="nc ir">if itemp%2 == 0 {</strong><br/>         evenSum = evenSum + itemp<br/>      }<br/>   }</span><span id="df6e" class="ny lw iq nc b gy pe oz l pa pb">   fmt.Printf("The even addition of %s is %d", args, evenSum)<br/>},</span></pre><p id="37ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它将首先使用<code class="fe mz na nb nc b">strconv</code>包将<code class="fe mz na nb nc b">string</code>转换为<code class="fe mz na nb nc b">int</code>，然后只添加偶数。</p><p id="0f55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存所有更改。使用<code class="fe mz na nb nc b">go install my-calc</code>重建二进制文件。</p><p id="d0b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行<code class="fe mz na nb nc b"><strong class="ke ir">my-calc add even 1 2 3 4 5 6</strong></code></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi px"><img src="../Images/07b765fd6027385339ecab416b199992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3j9_wtCrg9UAqGP1K4dd2Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">add even</figcaption></figure><p id="4a09" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">my-calc</code>是根命令，<code class="fe mz na nb nc b">add</code>是<code class="fe mz na nb nc b">rootCmd</code>的命令，<code class="fe mz na nb nc b">even</code>是<code class="fe mz na nb nc b">addCmd</code>的命令(子命令)。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="cea1" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">添加奇数</h1><p id="0e72" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">这个和<code class="fe mz na nb nc b">evenCmd</code>一样。它不加偶数，反而会加奇数。</p><p id="9981" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在项目目录中打开终端并创建一个新的 odd 命令。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="7beb" class="ny lw iq nc b gy oy oz l pa pb">cobra add odd</span></pre><p id="cdea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">odd</code>命令作为<code class="fe mz na nb nc b">odd.go</code>添加到<code class="fe mz na nb nc b">cmd</code>文件夹中。</p><p id="3707" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在编辑器中打开<code class="fe mz na nb nc b">odd.go</code>。将<code class="fe mz na nb nc b">init</code>中的<code class="fe mz na nb nc b"><strong class="ke ir">rootCmd</strong></code>改为<code class="fe mz na nb nc b"><strong class="ke ir">addCmd</strong></code>。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="c3f9" class="ny lw iq nc b gy oy oz l pa pb">// odd.go<br/>func init() {<br/>    <strong class="nc ir">addCmd.AddCommand(oddCmd)<br/></strong>...<br/>}</span></pre><p id="011b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">addCmd.AddCommand(oddCmd)</code>将添加<code class="fe mz na nb nc b">oddCmd</code>作为<code class="fe mz na nb nc b">addCmd</code>的子命令或子命令。</p><p id="de3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更新<code class="fe mz na nb nc b">oddCmd</code>结构变量的<code class="fe mz na nb nc b">RUN</code>方法。</p><pre class="ne nf ng nh gt ou nc ov ow aw ox bi"><span id="2920" class="ny lw iq nc b gy oy oz l pa pb">// odd.go</span><span id="2933" class="ny lw iq nc b gy pe oz l pa pb">Run: func(cmd *cobra.Command, args []string) {<br/>    var oddSum int<br/>    for _, ival := range args {<br/>      <strong class="nc ir">itemp, _ := strconv.Atoi(ival)</strong><br/>     <strong class="nc ir"> if itemp%2 != 0 {</strong><br/>         oddSum = oddSum + itemp<br/>      }<br/>    }</span><span id="17b2" class="ny lw iq nc b gy pe oz l pa pb">    fmt.Printf("The odd addition of %s is %d", args, oddSum)<br/>},</span></pre><p id="310f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它将首先使用<code class="fe mz na nb nc b">strconv</code>包将<code class="fe mz na nb nc b">string</code>转换为<code class="fe mz na nb nc b">int</code>，然后只添加偶数。</p><p id="da41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存所有更改。使用<code class="fe mz na nb nc b">go install my-calc</code>重建二进制文件。</p><p id="87b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行<code class="fe mz na nb nc b"><strong class="ke ir">my-calc add odd 1 2 3 4 5 6</strong></code></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/474875bbaaae05232d2f41458c96650b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SndQDhFXKCKz_H9a-NPQ7w.png"/></div></div></figure><p id="3b0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">my-calc</code>是根命令，<code class="fe mz na nb nc b">add</code>是<code class="fe mz na nb nc b">rootCmd</code>的命令，<code class="fe mz na nb nc b">odd</code>是<code class="fe mz na nb nc b">addCmd</code>的命令(子命令)。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="782c" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">恭喜🎉</h1><p id="3d58" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">恭喜你！您使用 cobra 在 golang 中创建了自己的 cli。</p><blockquote class="ni"><p id="8d77" class="nj nk iq bd nl nm nn no np nq nr kz dk translated">完整的代码保存在<a class="ae ns" href="https://github.com/schadokar/my-calc.git" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p></blockquote><p id="c36d" class="pw-post-body-paragraph kc kd iq ke b kf nt kh ki kj nu kl km kn nv kp kq kr nw kt ku kv nx kx ky kz ij bi translated">cli 项目已经完成。本教程的主要目的是理解 cobra 库的基础知识。本教程涵盖了创建 cli 所需的大多数基本操作。如果需要，我会不断更新更多的基本操作。我希望我平滑了创建 cli 的学习曲线。感谢您花时间阅读教程。我希望你学到了一些东西，这是值得你花时间。</p><p id="57d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请对本教程提出宝贵的反馈意见。我会做出相应的改变。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><blockquote class="on oo op"><p id="0421" class="kc kd my ke b kf kg kh ki kj kk kl km oq ko kp kq or ks kt ku os kw kx ky kz ij bi translated">如果你喜欢这个教程，你可以在我的博客上阅读我的最新教程。 <em class="iq">📑</em></p></blockquote></div></div>    
</body>
</html>