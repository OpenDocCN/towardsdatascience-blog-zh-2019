<html>
<head>
<title>Markov Chain for music generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">音乐生成的马尔可夫链</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/markov-chain-for-music-generation-932ea8a88305?source=collection_archive---------15-----------------------#2019-07-08">https://towardsdatascience.com/markov-chain-for-music-generation-932ea8a88305?source=collection_archive---------15-----------------------#2019-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a4aebbc7fac89daca6a3753901e4c5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xafxl_YG8qH3UTv99Ilg6g.jpeg"/></div></div></figure><p id="4049" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从本文中，您将了解马尔可夫链模型，以及如何将它应用于音乐生成。</p><h1 id="32ab" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是马尔可夫链？</h1><p id="dfff" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">马尔可夫链是描述一系列可能事件的模型。这个序列需要满足马尔可夫假设——下一个状态的概率取决于前一个状态，而不是序列中的所有前一个状态。</p><p id="dd73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这听起来像是对真实案例的简化。例如，为了应用马尔可夫链进行天气预测，我们需要假设明天的天气只取决于当前的天气，并假设没有其他因素，如一年中的时间等</p><p id="bd2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管在许多情况下这种简化，我们将能够生成有用的预测，但同时，我们将能够通过降低计算成本来更快地解决我们的任务。</p><p id="e833" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">马尔可夫链模型在金融、自然语言处理和任何有时间序列数据的地方都有很多应用。</p><h1 id="3ab0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用马尔可夫链生成音乐</h1><p id="d447" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有很多优秀的论文和博客文章解释了马尔可夫链。所以不深究理论细节，让我们把这个模型应用到实践上！马尔可夫链最普遍的应用是语言和语音，例如，预测句子中的下一个单词。但是如果我们尝试创造音乐呢？</p><p id="ed5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和自然语言一样，我们可以把音乐想象成一系列音符。但是因为我弹吉他，所以我会用<a class="ae lz" href="https://en.wikipedia.org/wiki/Chord_(music)" rel="noopener ugc nofollow" target="_blank">和弦</a>来操作。如果我们研究和弦序列并学习它的模式，我们会发现某些和弦可能更多地跟随特定和弦，而其他和弦很少跟随那个和弦。我们将构建我们的模型来发现和理解这种模式。</p><h2 id="0d22" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">好吧，计划是这样的:</h2><ol class=""><li id="2f1f" class="mm mn iq ka b kb lu kf lv kj mo kn mp kr mq kv mr ms mt mu bi translated">取和弦集</li><li id="a391" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">计算和弦跟随特定和弦的概率分布</li><li id="54a3" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">定义第一个和弦或随机选择</li><li id="39d0" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">考虑概率分布，随机选择下一个和弦</li><li id="24ea" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">对生成的和弦重复步骤 4</li><li id="9055" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi">…</li><li id="7da0" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">随机音乐太棒了！</li></ol><h1 id="90b4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">分步指南:</h1><p id="4750" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于数据源，我准备了一个带有和弦序列的 CSV 文件，这些和弦序列来自利物浦的一个著名乐队。你可以在<a class="ae lz" href="https://github.com/subpath/Markov_chain_for_music_generation/tree/master/data" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个文件。</p><p id="73e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">序列示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="da27" class="ma kx iq nf b gy nj nk l nl nm">['F', 'Em7', 'A7', 'Dm', 'Dm7', 'Bb', 'C7', 'F', 'C', 'Dm7',...]</span></pre><p id="59ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们制造二元模型:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3683" class="ma kx iq nf b gy nj nk l nl nm">['F Em7', 'Em7 A7', 'A7 Dm', 'Dm Dm7', 'Dm7 Bb', 'Bb C7', ...]</span></pre><p id="a0f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我把和弦 F 作为一个序列中的初始和弦，其他和弦跟随它的概率是多少？</p><p id="1662" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有 18 个以和弦 F 开头的二元组:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e100" class="ma kx iq nf b gy nj nk l nl nm">['F Em7', 'F C', 'F F', 'F Em7', 'F C', 'F A7sus4', 'F A7sus4', ...]</span></pre><p id="0001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将计算每个独特的二元模型在序列中出现的频率:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="528b" class="ma kx iq nf b gy nj nk l nl nm">{'F Em7': 4, 'F C': 4, 'F F': 3, 'F A7sus4': 4, 'F Fsus4': 2, 'F G7': 1}</span></pre><p id="2eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们归一化，我们会得到概率:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c351" class="ma kx iq nf b gy nj nk l nl nm">{'F Em7': 0.222,<br/> 'F C': 0.222,<br/> 'F F': 0.167,<br/> 'F A7sus4': 0.222,<br/> 'F Fsus4': 0.111,<br/> 'F G7': 0.056}</span></pre><p id="00b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这通常可以用图表的形式来解释:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8c45dafd2411eb33dc25b1c7bc212e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*YJ_hnlTVaRZVhUq6G_VUhA.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Weighted graph of possible next chord</figcaption></figure><p id="c945" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个图的每个节点，除了中间的初始节点 F，代表了我们的序列可以达到的可能状态，在我们的例子中，它们是可能跟随 F 的弦，一些弦比其他弦有更高的概率，一些弦根本不能跟随 F 弦，例如 Am，因为没有二元模型可以将这个弦与 F 组合。</p><p id="b6d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，马尔可夫链是一个随机过程，或者你更喜欢随机过程。为了进入下一个状态，我们将随机选择和弦，但是根据概率分布，在我们的例子中，这意味着我们更有可能选择和弦 C 而不是 G7。</p><p id="096c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于给定的和弦 F，下一个和弦有 6 个候选和弦:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6d30" class="ma kx iq nf b gy nj nk l nl nm">options<br/>&gt;&gt;&gt; ['Em7', 'C', 'F', 'A7sus4', 'Fsus4', 'G7']</span></pre><p id="c63e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个和弦都有相应的概率:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="85d9" class="ma kx iq nf b gy nj nk l nl nm">probabilities<br/>&gt;&gt;&gt; [0.222, 0.222, 0.167, 0.222, 0.111, 0.056]</span></pre><p id="8016" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://pypi.org/project/numpy/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>由于 1.7.0 版本可以根据给定的概率分布执行随机采样，所以我们使用:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="0982" class="ma kx iq nf b gy nj nk l nl nm">import numpy as np</span><span id="3e76" class="ma kx iq nf b gy ns nk l nl nm">choise = np.random.choice(options, p=probabilities)</span></pre><p id="6d15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们随机选择的结果是 Em7。现在我们有了一个新的状态，可以再次重复整个过程。</p><p id="25ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个工作流程如下所示:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="15e6" class="ma kx iq nf b gy nj nk l nl nm"># Our current state<br/>chord = 'F'</span><span id="40b8" class="ma kx iq nf b gy ns nk l nl nm"># create list of bigrams which stats with current chord<br/>bigrams_with_current_chord = [bigram for bigram in bigrams if bigram.split(' ')[0]==chord]</span><span id="b2cc" class="ma kx iq nf b gy ns nk l nl nm"># count appearance of each bigram<br/>count_appearance = dict(Counter(bigrams_with_current_chord))</span><span id="d31b" class="ma kx iq nf b gy ns nk l nl nm"># convert apperance into probabilities<br/>for ngram in count_appearance.keys():<br/>  count_appearance[ngram] = count_appearance[ngram]/len(bigrams_with_current_chord)</span><span id="31bd" class="ma kx iq nf b gy ns nk l nl nm"># create list of possible options for the next chord<br/>options = [key.split(' ')[1] for key in count_appearance.keys()]<br/># create  list of probability distribution<br/>probabilities = list(count_appearance.values())</span><span id="519c" class="ma kx iq nf b gy ns nk l nl nm"># Make random prediction<br/>np.random.choice(options, p=probabilities)</span></pre><p id="ff54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这是一个随机过程，每次你运行这个模型，都会得到不同的结果。为了实现可重复性，您可以像这样设置种子:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b13c" class="ma kx iq nf b gy nj nk l nl nm">np.random.seed(42)</span></pre><p id="322b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将整个过程概括为两个功能:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f9b6" class="ma kx iq nf b gy nj nk l nl nm">def predict_next_state(chord:str, data:list=bigrams):<br/>    """Predict next chord based on current state."""<br/>    # create list of bigrams which stats with current chord<br/>    bigrams_with_current_chord = [bigram for bigram in bigrams if bigram.split(' ')[0]==chord]<br/>    # count appearance of each bigram<br/>    count_appearance = dict(Counter(bigrams_with_current_chord))<br/>    # convert apperance into probabilities<br/>    for ngram in count_appearance.keys():<br/>        count_appearance[ngram] = count_appearance[ngram]/len(bigrams_with_current_chord)<br/>    # create list of possible options for the next chord<br/>    options = [key.split(' ')[1] for key in count_appearance.keys()]<br/>    # create  list of probability distribution<br/>    probabilities = list(count_appearance.values())<br/>    # return random prediction<br/>    return np.random.choice(options, p=probabilities)</span><span id="a4f1" class="ma kx iq nf b gy ns nk l nl nm">def generate_sequence(chord:str=None, data:list=bigrams, length:int=30):<br/>    """Generate sequence of defined length."""<br/>    # create list to store future chords<br/>    chords = []<br/>    for n in range(length):<br/>        # append next chord for the list<br/>        chords.append(predict_next_state(chord, bigrams))<br/>        # use last chord in sequence to predict next chord<br/>        chord = chords[-1]<br/>    return chords</span></pre><p id="30e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以生成一个我们想要的长度的序列:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ce57" class="ma kx iq nf b gy nj nk l nl nm">generate_sequence('C')</span></pre><p id="119c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">序列示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="d530" class="ma kx iq nf b gy nj nk l nl nm">['Bb',<br/> 'Dm',<br/> 'C',<br/> 'Bb',<br/> 'C7',<br/> 'F',<br/> 'Em7',<br/> 'A7',<br/> 'Dm',<br/> 'Dm7',<br/> 'Bb',<br/> 'Dm',<br/> 'Gm6'<br/> ...<br/> ]</span></pre><p id="b9f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我试着用吉他弹奏它，它听起来确实像一首来自利物浦的乐队可能写的歌。唯一缺少的是文本，但我们可以使用在文本语料库上训练的相同模型来为歌曲生成文本:)。</p><h1 id="fee7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="51f7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们仅仅用简单的马尔可夫链触及了冰山一角，随机模型的世界是如此之大，包括隐马尔可夫链、马尔可夫链蒙特卡罗、哈密顿蒙特卡罗等等。但是在每个模型的本质上都有相同的马尔可夫假设——下一个状态依赖于当前状态，而不依赖于先前的状态序列。</p><p id="c15b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这个简单而强大的规则，马尔可夫链模型在许多领域得到了应用，也可以成功地应用于音乐的产生。</p><p id="3aae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里最酷的事情之一是，我们将根据我们训练模型的语料库得到不同的结果。在来自电台司令和模型的语料库上训练将生成电台司令风格的和弦序列。</p><h2 id="f00d" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated"><strong class="ak">代码和数据集可以在我的</strong> <a class="ae lz" href="https://github.com/subpath/Markov_chain_for_music_generation" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> GitHub 资源库中找到。</strong> </a></h2><h1 id="739a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考资料:</h1><ol class=""><li id="c0bf" class="mm mn iq ka b kb lu kf lv kj mo kn mp kr mq kv mr ms mt mu bi translated">尤金·塞内塔。《马尔可夫和马尔可夫链的创建》(2006) <a class="ae lz" href="https://www.csc2.ncsu.edu/conferences/nsmc/MAM2006/seneta.pdf" rel="noopener ugc nofollow" target="_blank">原始论文 PDF </a></li><li id="1e7a" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">海因斯布莱恩。"马尔可夫链中的第一个环节."美国科学家 101.2 (2013): 252。<a class="ae lz" href="http://www.americanscientist.org/libraries/documents/201321152149545-2013-03Hayes.pdf" rel="noopener ugc nofollow" target="_blank">原稿 PDF </a></li></ol></div></div>    
</body>
</html>