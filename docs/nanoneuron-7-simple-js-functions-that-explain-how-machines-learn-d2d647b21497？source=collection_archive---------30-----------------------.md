# çº³ç±³ç¥ç»å…ƒâ€”â€”è§£é‡Šæœºå™¨å¦‚ä½•å­¦ä¹ çš„ 7 ä¸ªç®€å• JS å‡½æ•°

> åŸæ–‡ï¼š<https://towardsdatascience.com/nanoneuron-7-simple-js-functions-that-explain-how-machines-learn-d2d647b21497?source=collection_archive---------30----------------------->

> *7 ä¸ªç®€å•çš„ JavaScript å‡½æ•°ï¼Œè®©ä½ æ„Ÿå—ä¸€ä¸‹æœºå™¨æ˜¯å¦‚ä½•â€œå­¦ä¹ â€çš„ã€‚*

![](img/789123c8248b49abb38d110066d1456e.png)

Image by [mohamed_hassan](https://pixabay.com/users/mohamed_hassan-5229782/) on [pixabay](https://pixabay.com/vectors/nerve-cell-neuron-brain-neurons-3759541/)

# TLï¼›é€Ÿåº¦ä¸‰è§’å½¢å®šä½æ³•(dead reckoning)

[çº³ç±³ç¥ç»å…ƒ](https://github.com/trekhleb/nano-neuron)æ˜¯ç¥ç»ç½‘ç»œä¸­ç¥ç»å…ƒæ¦‚å¿µçš„*è¿‡åº¦ç®€åŒ–*ç‰ˆæœ¬ã€‚çº³ç±³ç¥ç»å…ƒè¢«è®­ç»ƒæˆå°†æ¸©åº¦å€¼ä»æ‘„æ°æ¸©åº¦è½¬æ¢æˆåæ°æ¸©åº¦ã€‚

[NanoNeuron.js](https://github.com/trekhleb/nano-neuron/blob/master/NanoNeuron.js) ä»£ç ç¤ºä¾‹åŒ…å« 7 ä¸ªç®€å•çš„ JavaScript å‡½æ•°(æ¨¡å‹é¢„æµ‹ã€æˆæœ¬è®¡ç®—ã€å‘å‰å’Œå‘åä¼ æ’­ã€è®­ç»ƒ)ï¼Œè¿™äº›å‡½æ•°å°†è®©æ‚¨æ„Ÿå—åˆ°æœºå™¨å®é™…ä¸Šæ˜¯å¦‚ä½•â€œå­¦ä¹ â€çš„ã€‚æ²¡æœ‰ç¬¬ä¸‰æ–¹åº“ï¼Œæ²¡æœ‰å¤–éƒ¨æ•°æ®é›†å’Œä¾èµ–ï¼Œåªæœ‰çº¯ç²¹ç®€å•çš„ JavaScript å‡½æ•°ã€‚

â˜ğŸ»è¿™äº›å‡½æ•°æ— è®ºå¦‚ä½•éƒ½ä¸æ˜¯æœºå™¨å­¦ä¹ çš„å®Œæ•´æŒ‡å—ã€‚å¾ˆå¤šæœºå™¨å­¦ä¹ çš„æ¦‚å¿µåœ¨é‚£é‡Œè¢«è·³è¿‡ï¼Œè¢«è¿‡åº¦ç®€åŒ–ï¼è¿™ç§ç®€åŒ–çš„ç›®çš„æ˜¯è®©è¯»è€…å¯¹æœºå™¨å¦‚ä½•å­¦ä¹ æœ‰ä¸€ä¸ªçœŸæ­£åŸºæœ¬çš„ç†è§£å’Œæ„Ÿå—ï¼Œå¹¶æœ€ç»ˆä½¿è¯»è€…æœ‰å¯èƒ½ç§°ä¹‹ä¸ºâ€œæœºå™¨å­¦ä¹ é­”æ³•â€è€Œä¸æ˜¯â€œæœºå™¨å­¦ä¹ æ•°å­¦â€ğŸ¤“ã€‚

> å¯¹äºæ›´é«˜çº§çš„æœºå™¨å­¦ä¹ ç¤ºä¾‹(åœ¨ TensorFlow å’Œ Python ä¸Šå®ç°é€’å½’å’Œå·ç§¯ç¥ç»ç½‘ç»œ),æ‚¨å¯ä»¥ç»§ç»­ğŸ¤– [**äº¤äº’å¼æœºå™¨å­¦ä¹ å®éªŒ**](https://github.com/trekhleb/machine-learning-experiments) s çŸ¥è¯†åº“ã€‚

# çº³ç±³ç¥ç»å…ƒä¼šå­¦ä¹ ä»€ä¹ˆ

ä½ å¯èƒ½åœ¨[ç¥ç»ç½‘ç»œ](https://en.wikipedia.org/wiki/Neural_network)ä¸­å¬è¯´è¿‡ç¥ç»å…ƒã€‚æˆ‘ä»¬ä¸‹é¢è¦å®ç°çš„çº³ç±³ç¥ç»å…ƒæœ‰ç‚¹åƒå®ƒï¼Œä½†ç®€å•å¾—å¤šã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ç”šè‡³ä¸æ‰“ç®—åœ¨çº³ç±³ç¥ç»å…ƒä¸Šå»ºç«‹ç½‘ç»œã€‚æˆ‘ä»¬å°†ç‹¬è‡ªæ‹¥æœ‰å®ƒï¼Œä¸ºæˆ‘ä»¬åšä¸€äº›ç¥å¥‡çš„é¢„æµ‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†æ•™ä¼šè¿™ä¸ªç®€å•çš„çº³ç±³ç¥ç»å…ƒå°†æ¸©åº¦ä»æ‘„æ°æ¸©åº¦è½¬æ¢(é¢„æµ‹)ä¸ºåæ°æ¸©åº¦ã€‚

é¡ºä¾¿è¯´ä¸€ä¸‹ï¼ŒæŠŠæ‘„æ°æ¸©åº¦è½¬æ¢æˆåæ°æ¸©åº¦çš„å…¬å¼æ˜¯è¿™æ ·çš„:

![](img/b63b2725e3a2bf690fcbd72ba20de2a9.png)

ä½†æ˜¯ç°åœ¨æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒè¿˜ä¸çŸ¥é“å®ƒâ€¦

# çº³ç±³ç¥ç»å…ƒæ¨¡å‹

è®©æˆ‘ä»¬å®ç°æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒæ¨¡å‹å‡½æ•°ã€‚å®ƒå®ç°äº†`x`å’Œ`y`ä¹‹é—´çš„åŸºæœ¬çº¿æ€§ä¾èµ–ï¼Œçœ‹èµ·æ¥åƒ`y = w * x + b`ã€‚ç®€å•çš„è¯´æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒå°±æ˜¯ä¸€ä¸ªå¯ä»¥åœ¨`XY`åæ ‡ä¸­ç”»ç›´çº¿çš„â€œå°å­©â€ã€‚

å˜é‡`w`ã€`b`æ˜¯æ¨¡å‹çš„å‚æ•°ã€‚çº³ç±³ç¥ç»å…ƒåªçŸ¥é“çº¿æ€§å‡½æ•°çš„è¿™ä¸¤ä¸ªå‚æ•°ã€‚
è¿™äº›å‚æ•°æ˜¯çº³ç±³ç¥ç»å…ƒåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­å°†è¦â€œå­¦ä¹ â€çš„ä¸œè¥¿ã€‚

çº³ç±³ç¥ç»å…ƒå”¯ä¸€èƒ½åšçš„å°±æ˜¯æ¨¡ä»¿çº¿æ€§ä¾èµ–ã€‚åœ¨å…¶`predict()`æ–¹æ³•ä¸­ï¼Œå®ƒæ¥å—ä¸€äº›è¾“å…¥`x`å¹¶é¢„æµ‹è¾“å‡º`y`ã€‚è¿™é‡Œæ²¡æœ‰é­”æ³•ã€‚

```
function **NanoNeuron**(w, b) {
  this.w = w;
  this.b = b;
  this.predict = (x) => {
    return x * this.w + this.b;
  }
}
```

*(â€¦ç­‰ç­‰â€¦* [*çº¿æ€§å›å½’*](https://en.wikipedia.org/wiki/Linear_regression#:~:targetText=In%20statistics%2C%20linear%20regression%20is,is%20called%20simple%20linear%20regression.) *æ˜¯ä½ å—ï¼Ÿ)* ğŸ§

# æ‘„æ°åˆ°åæ°çš„è½¬æ¢

ä»¥æ‘„æ°åº¦ä¸ºå•ä½çš„æ¸©åº¦å€¼å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å…¬å¼è½¬æ¢ä¸ºåæ°æ¸©åº¦:`f = 1.8 * c + 32`ï¼Œå…¶ä¸­`c`æ˜¯ä»¥æ‘„æ°åº¦ä¸ºå•ä½çš„æ¸©åº¦ï¼Œ`f`æ˜¯ä»¥åæ°æ¸©åº¦ä¸ºå•ä½çš„è®¡ç®—æ¸©åº¦ã€‚

```
function **celsiusToFahrenheit**(c) {
  const w = 1.8;
  const b = 32;
  const f = c * w + b;
  return f;
};
```

æœ€ç»ˆï¼Œæˆ‘ä»¬å¸Œæœ›æ•™ä¼šæˆ‘ä»¬çº³ç±³ç¥ç»å…ƒæ¨¡ä»¿è¿™ä¸€åŠŸèƒ½(å­¦ä¹ `w = 1.8`å’Œ`b = 32`)ï¼Œè€Œæ— éœ€äº‹å…ˆçŸ¥é“è¿™äº›å‚æ•°ã€‚

è¿™æ˜¯æ‘„æ°åˆ°åæ°è½¬æ¢å‡½æ•°çš„æ ·å­:

![](img/5274e251f842da3d419b00a01e1549d0.png)

Celsius to Fahrenheit conversion function

# ç”Ÿæˆæ•°æ®é›†

åœ¨è®­ç»ƒä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦åŸºäº`celsiusToFahrenheit()`å‡½æ•°ç”Ÿæˆ**è®­ç»ƒ**å’Œ**æµ‹è¯•æ•°æ®é›†**ã€‚æ•°æ®é›†ç”±æˆå¯¹çš„è¾“å…¥å€¼å’Œæ­£ç¡®æ ‡è®°çš„è¾“å‡ºå€¼ç»„æˆã€‚

> åœ¨ç°å®ç”Ÿæ´»ä¸­ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™äº›æ•°æ®æ˜¯æ”¶é›†çš„ï¼Œè€Œä¸æ˜¯ç”Ÿæˆçš„ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ç»„æ‰‹ç»˜æ•°å­—å›¾åƒå’Œä¸€ç»„ç›¸åº”çš„æ•°å­—ï¼Œè¿™äº›æ•°å­—è§£é‡Šäº†æ¯å¼ å›¾ç‰‡ä¸Šå†™çš„æ˜¯ä»€ä¹ˆæ•°å­—ã€‚

æˆ‘ä»¬å°†ä½¿ç”¨è®­ç»ƒæ ·æœ¬æ•°æ®æ¥è®­ç»ƒæˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒã€‚åœ¨æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒæˆé•¿å¹¶èƒ½å¤Ÿè‡ªå·±åšå‡ºå†³å®šä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç”¨è®­ç»ƒæ ·æœ¬æ•™ä¼šå®ƒä»€ä¹ˆæ˜¯å¯¹çš„ï¼Œä»€ä¹ˆæ˜¯é”™çš„ã€‚

æˆ‘ä»¬å°†ä½¿ç”¨æµ‹è¯•ç¤ºä¾‹æ¥è¯„ä¼°æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒåœ¨è®­ç»ƒæœŸé—´æ²¡æœ‰çœ‹åˆ°çš„æ•°æ®ä¸Šçš„è¡¨ç°ã€‚åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„â€œå­©å­â€å·²ç»é•¿å¤§ï¼Œå¯ä»¥è‡ªå·±åšå†³å®šäº†ã€‚

```
function **generateDataSets**() {
  // xTrain -> [0, 1, 2, ...],
  // yTrain -> [32, 33.8, 35.6, ...]
  const xTrain = [];
  const yTrain = [];
  for (let x = 0; x < 100; x += 1) {
    const y = celsiusToFahrenheit(x);
    xTrain.push(x);
    yTrain.push(y);
  } // xTest -> [0.5, 1.5, 2.5, ...]
  // yTest -> [32.9, 34.7, 36.5, ...]
  const xTest = [];
  const yTest = [];
  // By starting from 0.5 and using the same step of 1 as we have used for training set
  // we make sure that test set has different data comparing to training set.
  for (let x = 0.5; x < 100; x += 1) {
    const y = celsiusToFahrenheit(x);
    xTest.push(x);
    yTest.push(y);
  } return [xTrain, yTrain, xTest, yTest];
}
```

# é¢„æµ‹çš„æˆæœ¬(è¯¯å·®)

æˆ‘ä»¬éœ€è¦ä¸€äº›æŒ‡æ ‡æ¥æ˜¾ç¤ºæˆ‘ä»¬çš„æ¨¡å‹é¢„æµ‹ä¸æ­£ç¡®å€¼çš„æ¥è¿‘ç¨‹åº¦ã€‚çº³ç±³ç¥ç»å…ƒäº§ç”Ÿçš„æ­£ç¡®è¾“å‡ºå€¼`y`å’Œ`prediction`ä¹‹é—´çš„æˆæœ¬(è¯¯å·®)çš„è®¡ç®—å°†ä½¿ç”¨ä»¥ä¸‹å…¬å¼:

![](img/5777cd3ac314e2dc32ad0b084e00e342.png)

è¿™æ˜¯ä¸¤ä¸ªå€¼çš„ç®€å•åŒºåˆ«ã€‚æ•°å€¼è¶Šæ¥è¿‘ï¼Œå·®å¼‚è¶Šå°ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨`2`çš„èƒ½åŠ›åªæ˜¯ä¸ºäº†å»æ‰è´Ÿæ•°ï¼Œè¿™æ ·`(1 - 2) ^ 2`å°±å’Œ`(2 - 1) ^ 2`ä¸€æ ·äº†ã€‚é™¤ä»¥`2`åªæ˜¯ä¸ºäº†è¿›ä¸€æ­¥ç®€åŒ–åå‘ä¼ æ’­å…¬å¼(è§ä¸‹æ–‡)ã€‚

è¿™ç§æƒ…å†µä¸‹çš„æˆæœ¬å‡½æ•°éå¸¸ç®€å•:

```
function **predictionCost**(y, prediction) {
  return (y - prediction) ** 2 / 2; // i.e. -> 235.6
}
```

# æ­£å‘ä¼ æ’­

è¿›è¡Œå‰å‘ä¼ æ’­æ„å‘³ç€å¯¹æ¥è‡ª`xTrain`å’Œ`yTrain`æ•°æ®é›†çš„æ‰€æœ‰è®­ç»ƒæ ·æœ¬è¿›è¡Œé¢„æµ‹ï¼Œå¹¶è®¡ç®—è¿™äº›é¢„æµ‹çš„å¹³å‡æˆæœ¬ã€‚

æˆ‘ä»¬åªæ˜¯è®©æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒè¯´å‡ºå®ƒåœ¨è¿™ä¸€ç‚¹ä¸Šçš„æ„è§ï¼Œåªæ˜¯è®©ä»–çŒœä¸€çŒœå¦‚ä½•æ¢ç®—æ¸©åº¦ã€‚è¿™å¯èƒ½æ˜¯æ„šè ¢çš„é”™è¯¯ã€‚å¹³å‡æˆæœ¬å°†æ˜¾ç¤ºæˆ‘ä»¬çš„æ¨¡å‹ç°åœ¨æ˜¯å¤šä¹ˆçš„é”™è¯¯ã€‚è¿™ä¸ªæˆæœ¬å€¼éå¸¸æœ‰ä»·å€¼ï¼Œå› ä¸ºé€šè¿‡æ”¹å˜çº³ç±³ç¥ç»å…ƒå‚æ•°`w`å’Œ`b`å¹¶å†æ¬¡è¿›è¡Œæ­£å‘ä¼ æ’­ï¼Œæˆ‘ä»¬å°†èƒ½å¤Ÿè¯„ä¼°çº³ç±³ç¥ç»å…ƒåœ¨å‚æ•°æ”¹å˜åæ˜¯å¦å˜å¾—æ›´èªæ˜ã€‚

å°†ä½¿ç”¨ä»¥ä¸‹å…¬å¼è®¡ç®—å¹³å‡æˆæœ¬:

![](img/50a9728f93452c18be8c75ae2f5099ac.png)

å…¶ä¸­`m`æ˜¯è®­ç»ƒç¤ºä¾‹çš„æ•°é‡(åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯`100`)ã€‚

ä¸‹é¢æ˜¯æˆ‘ä»¬å¦‚ä½•ç”¨ä»£ç å®ç°å®ƒ:

```
function **forwardPropagation**(model, xTrain, yTrain) {
  const m = xTrain.length;
  const predictions = [];
  let cost = 0;
  for (let i = 0; i < m; i += 1) {
    const prediction = nanoNeuron.predict(xTrain[i]);
    cost += predictionCost(yTrain[i], prediction);
    predictions.push(prediction);
  }
  // We are interested in average cost.
  cost /= m;
  return [predictions, cost];
}
```

# åå‘ä¼ æ’­

ç°åœ¨ï¼Œå½“æˆ‘ä»¬çŸ¥é“çº³ç±³ç¥ç»å…ƒçš„é¢„æµ‹æœ‰å¤šæ­£ç¡®æˆ–é”™è¯¯(åŸºäºæ­¤æ—¶çš„å¹³å‡æˆæœ¬)æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥åšäº›ä»€ä¹ˆæ¥ä½¿é¢„æµ‹æ›´ç²¾ç¡®å‘¢ï¼Ÿ

åå‘ä¼ æ’­æ˜¯è¿™ä¸ªé—®é¢˜çš„ç­”æ¡ˆã€‚åå‘ä¼ æ’­æ˜¯è¯„ä¼°é¢„æµ‹æˆæœ¬å’Œè°ƒæ•´çº³ç±³ç¥ç»å…ƒå‚æ•°`w`å’Œ`b`çš„è¿‡ç¨‹ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡é¢„æµ‹æ›´åŠ ç²¾ç¡®ã€‚

è¿™å°±æ˜¯æœºå™¨å­¦ä¹ çœ‹èµ·æ¥åƒé­”æ³•ğŸ§â€â™‚ï¸.çš„åœ°æ–¹è¿™é‡Œçš„å…³é”®æ¦‚å¿µæ˜¯**å¯¼æ•°**ï¼Œå®ƒæ˜¾ç¤ºäº†é‡‡å–ä»€ä¹ˆæ­¥éª¤æ¥æ¥è¿‘æˆæœ¬å‡½æ•°æœ€å°å€¼ã€‚

è®°ä½ï¼Œæ‰¾åˆ°ä¸€ä¸ªæˆæœ¬å‡½æ•°çš„æœ€å°å€¼æ˜¯è®­ç»ƒè¿‡ç¨‹çš„æœ€ç»ˆç›®æ ‡ã€‚å¦‚æœæˆ‘ä»¬ä¼šå‘ç°`w`å’Œ`b`çš„å€¼ä½¿å¾—æˆ‘ä»¬çš„å¹³å‡æˆæœ¬å‡½æ•°å¾ˆå°ï¼Œè¿™å°†æ„å‘³ç€çº³ç±³ç¥ç»å…ƒæ¨¡å‹åšäº†éå¸¸å¥½å’Œç²¾ç¡®çš„é¢„æµ‹ã€‚

è¡ç”Ÿå“æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å¤§è¯é¢˜ï¼Œæˆ‘ä»¬ä¸ä¼šåœ¨æœ¬æ–‡ä¸­è®¨è®ºã€‚MathIsFun æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„èµ„æºï¼Œå¯ä»¥è®©ä½ å¯¹å®ƒæœ‰ä¸€ä¸ªåŸºæœ¬çš„äº†è§£ã€‚

å…³äºå¯¼æ•°ï¼Œæœ‰ä¸€ç‚¹å¯ä»¥å¸®åŠ©ä½ ç†è§£åå‘ä¼ æ’­æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œé‚£å°±æ˜¯å¯¼æ•°çš„å«ä¹‰æ˜¯å‡½æ•°æ›²çº¿çš„åˆ‡çº¿ï¼Œå®ƒæŒ‡å‡ºäº†å‡½æ•°æœ€å°å€¼çš„æ–¹å‘ã€‚

*å›¾ç‰‡æ¥æº:* [*é©¬è’‚æ–¯èŠ¬*](https://www.mathsisfun.com/calculus/derivatives-introduction.html)

ä¾‹å¦‚ï¼Œåœ¨ä¸Šé¢çš„å›¾ä¸­ï¼Œä½ å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæˆ‘ä»¬åœ¨`(x=2, y=4)`ç‚¹ï¼Œé‚£ä¹ˆæ–œç‡å‘Šè¯‰æˆ‘ä»¬èµ°`left`å’Œ`down`åˆ°è¾¾å‡½æ•°æœ€å°å€¼ã€‚è¿˜è¦æ³¨æ„ï¼Œæ–œç‡è¶Šå¤§ï¼Œæˆ‘ä»¬å‘æœ€å°å€¼ç§»åŠ¨çš„é€Ÿåº¦è¶Šå¿«ã€‚

æˆ‘ä»¬çš„`averageCost`å‡½æ•°å¯¹å‚æ•°`w`å’Œ`b`çš„å¯¼æ•°å¦‚ä¸‹æ‰€ç¤º:

![](img/a0b5328959a167234b7cef92e4efd22a.png)![](img/b2fbfccfcec2e60be7baad02de061a3a.png)

å…¶ä¸­`m`æ˜¯ä¸€äº›è®­ç»ƒä¾‹å­(åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯`100`)ã€‚

*ä½ å¯ä»¥åœ¨è¿™é‡Œ* *é˜…è¯»æ›´å¤šå…³äºå¯¼æ•°è§„åˆ™ä»¥åŠå¦‚ä½•å¾—åˆ°å¤æ‚å‡½æ•°çš„å¯¼æ•°* [*ã€‚*](https://www.mathsisfun.com/calculus/derivatives-rules.html)

```
function **backwardPropagation**(predictions, xTrain, yTrain) {
  const m = xTrain.length;
  // At the beginning we don't know in which way our parameters 'w' and 'b' need to be changed.
  // Therefore we're setting up the changing steps for each parameters to 0.
  let dW = 0;
  let dB = 0;
  for (let i = 0; i < m; i += 1) {
    dW += (yTrain[i] - predictions[i]) * xTrain[i];
    dB += yTrain[i] - predictions[i];
  }
  // We're interested in average deltas for each params.
  dW /= m;
  dB /= m;
  return [dW, dB];
}
```

# è®­ç»ƒæ¨¡å‹

ç°åœ¨ï¼Œæˆ‘ä»¬çŸ¥é“å¦‚ä½•è¯„ä¼°æˆ‘ä»¬çš„æ¨¡å‹å¯¹äºæ‰€æœ‰è®­ç»ƒé›†ç¤ºä¾‹çš„æ­£ç¡®æ€§(*æ­£å‘ä¼ æ’­*)ï¼Œæˆ‘ä»¬ä¹ŸçŸ¥é“å¦‚ä½•å¯¹çº³ç±³ç¥ç»å…ƒæ¨¡å‹çš„å‚æ•°`w`å’Œ`b`(*åå‘ä¼ æ’­*)è¿›è¡Œå°çš„è°ƒæ•´ã€‚ä½†é—®é¢˜æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬åªè¿è¡Œä¸€æ¬¡å‰å‘ä¼ æ’­å’Œåå‘ä¼ æ’­ï¼Œæˆ‘ä»¬çš„æ¨¡å‹ä»è®­ç»ƒæ•°æ®ä¸­å­¦ä¹ ä»»ä½•è§„å¾‹/è¶‹åŠ¿æ˜¯ä¸å¤Ÿçš„ã€‚ä½ å¯ä»¥æŠŠå®ƒå’Œç»™å­©å­ä¸Šä¸€å¤©å°å­¦ç›¸æ¯”è¾ƒã€‚ä»–/å¥¹åº”è¯¥å»å­¦æ ¡ä¸æ˜¯ä¸€æ¬¡ï¼Œè€Œæ˜¯æ—¥å¤ä¸€æ—¥ï¼Œå¹´å¤ä¸€å¹´åœ°å­¦ä¹ ä¸€äº›ä¸œè¥¿ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºæˆ‘ä»¬çš„æ¨¡å‹å¤šæ¬¡é‡å¤å‘å‰å’Œå‘åä¼ æ’­ã€‚è¿™æ­£æ˜¯`trainModel()`åŠŸèƒ½çš„ä½œç”¨ã€‚å®ƒå°±åƒæ˜¯æˆ‘ä»¬çº³ç±³ç¥ç»å…ƒæ¨¡å‹çš„â€œè€å¸ˆâ€:

*   å®ƒå°†èŠ±ä¸€äº›æ—¶é—´(`epochs`)åœ¨æˆ‘ä»¬è¿˜æœ‰ç‚¹æ„šè ¢çš„çº³ç±³ç¥ç»å…ƒæ¨¡å‹ä¸Šï¼Œå¹¶å°è¯•è®­ç»ƒ/æ•™æˆå®ƒï¼Œ
*   å®ƒå°†ä½¿ç”¨ç‰¹å®šçš„â€œä¹¦ç±â€(`xTrain`å’Œ`yTrain`æ•°æ®é›†)è¿›è¡Œè®­ç»ƒï¼Œ
*   å®ƒå°†é€šè¿‡ä½¿ç”¨å­¦ä¹ ç‡å‚æ•°`alpha`æ¥æ¨åŠ¨æˆ‘ä»¬çš„å­©å­æ›´åŠªåŠ›(æ›´å¿«)åœ°å­¦ä¹ 

è¯´å‡ å¥å­¦ä¹ ç‡`alpha`ã€‚è¿™åªæ˜¯æˆ‘ä»¬åœ¨åå‘ä¼ æ’­æœŸé—´è®¡ç®—çš„`dW`å’Œ`dB`å€¼çš„ä¹˜æ•°ã€‚å› æ­¤ï¼Œå¯¼æ•°ä¸ºæˆ‘ä»¬æŒ‡å‡ºäº†æ‰¾åˆ°æˆæœ¬å‡½æ•°çš„æœ€å°å€¼éœ€è¦é‡‡å–çš„æ–¹å‘(`dW`å’Œ`dB`ç¬¦å·)ï¼Œå®ƒè¿˜ä¸ºæˆ‘ä»¬æŒ‡å‡ºäº†éœ€è¦å¤šå¿«åˆ°è¾¾é‚£ä¸ªæ–¹å‘(`dW`å’Œ`dB`ç»å¯¹å€¼)ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦å°†è¿™äº›æ­¥é•¿ä¹˜ä»¥`alpha`ï¼Œä»¥ä½¿æˆ‘ä»¬çš„ç§»åŠ¨æ›´å¿«æˆ–æ›´æ…¢ã€‚æœ‰æ—¶ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå¤§å€¼`alpha`ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè·³è¿‡æœ€å°å€¼ï¼Œæ°¸è¿œæ‰¾ä¸åˆ°å®ƒã€‚

ä¸è€å¸ˆçš„ç±»æ¯”æ˜¯ï¼Œä»–è¶Šæ˜¯é€¼è¿«æˆ‘ä»¬çš„â€œçº³ç±³å­©å­â€ï¼Œæˆ‘ä»¬çš„â€œçº³ç±³å­©å­â€å°±ä¼šå­¦å¾—è¶Šå¿«ï¼Œä½†æ˜¯å¦‚æœè€å¸ˆé€¼å¾—å¤ªç´§ï¼Œâ€œå­©å­â€å°±ä¼šç²¾ç¥å´©æºƒï¼Œä»€ä¹ˆä¹Ÿå­¦ä¸åˆ°ğŸ¤¯ã€‚

ä¸‹é¢æ˜¯æˆ‘ä»¬å¦‚ä½•æ›´æ–°æ¨¡å‹çš„`w`å’Œ`b`å‚æ•°:

![](img/2a97d15ba479c9b19344477cfd048463.png)![](img/85f89e6549ab8dfbf19b1056e0ed1874.png)

è¿™æ˜¯æˆ‘ä»¬çš„åŸ¹è®­å¸ˆèŒèƒ½:

```
function **trainModel**({model, epochs, alpha, xTrain, yTrain}) {
  // The is the history array of how NanoNeuron learns.
  const costHistory = []; // Let's start counting epochs.
  for (let epoch = 0; epoch < epochs; epoch += 1) {
    // Forward propagation.
    const [predictions, cost] = forwardPropagation(model, xTrain, yTrain);
    costHistory.push(cost); // Backward propagation.
    const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain);
    nanoNeuron.w += alpha * dW;
    nanoNeuron.b += alpha * dB;
  } return costHistory;
}
```

# æŠŠæ‰€æœ‰çš„ç¢ç‰‡æ”¾åœ¨ä¸€èµ·

ç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨ä¸Šé¢åˆ›å»ºçš„å‡½æ•°ã€‚

è®©æˆ‘ä»¬åˆ›å»ºæˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒæ¨¡å‹å®ä¾‹ã€‚æ­¤æ—¶ï¼Œçº³ç±³ç¥ç»å…ƒä¸çŸ¥é“å‚æ•°`w`å’Œ`b`åº”è¯¥è®¾ç½®ä»€ä¹ˆå€¼ã€‚æ‰€ä»¥æˆ‘ä»¬éšæœºè®¾ç½®`w`å’Œ`b`ã€‚

```
const w = Math.random(); // i.e. -> 0.9492
const b = Math.random(); // i.e. -> 0.4570
const nanoNeuron = new NanoNeuron(w, b);
```

ç”Ÿæˆè®­ç»ƒå’Œæµ‹è¯•æ•°æ®é›†ã€‚

```
const [xTrain, yTrain, xTest, yTest] = generateDataSets();
```

è®©æˆ‘ä»¬åœ¨`70000`æ—¶æœŸç”¨å°çš„(`0.0005`)æ­¥éª¤æ¥è®­ç»ƒæ¨¡å‹ã€‚ä½ å¯ä»¥æ‘†å¼„è¿™äº›å‚æ•°ï¼Œå®ƒä»¬æ˜¯æ ¹æ®ç»éªŒå®šä¹‰çš„ã€‚

```
const epochs = 70000;
const alpha = 0.0005;
const trainingCostHistory = trainModel({model: nanoNeuron, epochs, alpha, xTrain, yTrain});
```

è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹æˆæœ¬å‡½æ•°åœ¨åŸ¹è®­æœŸé—´æ˜¯å¦‚ä½•å˜åŒ–çš„ã€‚æˆ‘ä»¬æœŸæœ›åŸ¹è®­åçš„è´¹ç”¨ä¼šæ¯”ä»¥å‰ä½å¾—å¤šã€‚è¿™æ„å‘³ç€çº³ç±³ç¥ç»å…ƒå˜å¾—æ›´åŠ èªæ˜ã€‚ç›¸åçš„æƒ…å†µä¹Ÿæ˜¯å¯èƒ½çš„ã€‚

```
console.log('Cost before the training:', trainingCostHistory[0]); // i.e. -> 4694.3335043
console.log('Cost after the training:', trainingCostHistory[epochs - 1]); // i.e. -> 0.0000024
```

è¿™å°±æ˜¯åŸ¹è®­æˆæœ¬åœ¨ä¸åŒæ—¶æœŸçš„å˜åŒ–ã€‚åœ¨`x`è½´ä¸Šæ˜¯çºªå…ƒç¼–å· x1000ã€‚

![](img/2dbb701bb2fb76c110c9157fe121a374.png)

Training cost change over the epochs

è®©æˆ‘ä»¬æ¥çœ‹çœ‹çº³ç±³ç¥ç»å…ƒçš„å‚æ•°ï¼Œçœ‹çœ‹å®ƒå­¦åˆ°äº†ä»€ä¹ˆã€‚æˆ‘ä»¬æœŸæœ›çº³ç±³ç¥ç»å…ƒå‚æ•°`w`å’Œ`b`ä¸æˆ‘ä»¬åœ¨`celsiusToFahrenheit()`å‡½æ•°ä¸­çš„å‚æ•°`w = 1.8`å’Œ`b = 32`ç›¸ä¼¼ï¼Œå› ä¸ºæˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒè¯•å›¾æ¨¡ä»¿å®ƒã€‚

```
console.log('NanoNeuron parameters:', {w: nanoNeuron.w, b: nanoNeuron.b}); // i.e. -> {w: 1.8, b: 31.99}
```

è¯„ä¼°æˆ‘ä»¬çš„æ¨¡å‹å¯¹æµ‹è¯•æ•°æ®é›†çš„å‡†ç¡®æ€§ï¼Œçœ‹çœ‹æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒå¦‚ä½•å¤„ç†æ–°çš„æœªçŸ¥æ•°æ®é¢„æµ‹ã€‚å¯¹æµ‹è¯•é›†è¿›è¡Œé¢„æµ‹çš„æˆæœ¬é¢„è®¡å°†æ¥è¿‘è®­ç»ƒæˆæœ¬ã€‚è¿™å°†æ„å‘³ç€çº³ç±³ç¥ç»å…ƒåœ¨å·²çŸ¥å’ŒæœªçŸ¥æ•°æ®ä¸Šè¡¨ç°è‰¯å¥½ã€‚

```
[testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest);
console.log('Cost on new testing data:', testCost); // i.e. -> 0.0000023
```

ç°åœ¨ï¼Œç”±äºæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒâ€œå­©å­â€åœ¨è®­ç»ƒæœŸé—´åœ¨â€œå­¦æ ¡â€è¡¨ç°è‰¯å¥½ï¼Œå³ä½¿å¯¹äºå®ƒæ²¡æœ‰çœ‹åˆ°çš„æ•°æ®ï¼Œä»–ä¹Ÿå¯ä»¥æ­£ç¡®åœ°å°†æ‘„æ°æ¸©åº¦è½¬æ¢ä¸ºåæ°æ¸©åº¦ï¼Œæˆ‘ä»¬å¯ä»¥ç§°ä¹‹ä¸ºâ€œæ™ºèƒ½â€ï¼Œå¹¶é—®ä»–ä¸€äº›é—®é¢˜ã€‚è¿™æ˜¯æ•´ä¸ªåŸ¹è®­è¿‡ç¨‹çš„æœ€ç»ˆç›®æ ‡ã€‚

```
const tempInCelsius = 70;
const customPrediction = nanoNeuron.predict(tempInCelsius);
console.log(`NanoNeuron "thinks" that ${tempInCelsius}Â°C in Fahrenheit is:`, customPrediction); // -> 158.0002
console.log('Correct answer is:', celsiusToFahrenheit(tempInCelsius)); // -> 158
```

å¦‚æ­¤æ¥è¿‘ï¼å’Œæ‰€æœ‰äººä¸€æ ·ï¼Œæˆ‘ä»¬çš„çº³ç±³ç¥ç»å…ƒæ˜¯å¥½çš„ï¼Œä½†å¹¶ä¸ç†æƒ³:)

ç¥ä½ å­¦ä¹ æ„‰å¿«ï¼

# å¦‚ä½•å‘å°„çº³ç±³ç¥ç»å…ƒ

æ‚¨å¯ä»¥å…‹éš†å­˜å‚¨åº“å¹¶åœ¨æœ¬åœ°è¿è¡Œå®ƒ:

```
git clone https://github.com/trekhleb/nano-neuron.git
cd nano-neuronnode ./NanoNeuron.js
```

# è·³è¿‡æœºå™¨å­¦ä¹ æ¦‚å¿µ

ä¸ºäº†è§£é‡Šç®€å•ï¼Œè·³è¿‡å¹¶ç®€åŒ–äº†ä»¥ä¸‹æœºå™¨å­¦ä¹ æ¦‚å¿µã€‚

**åˆ—è½¦/æµ‹è¯•è£…ç½®æ‹†åˆ†**

é€šå¸¸ä½ æœ‰ä¸€å¤§ç»„æ•°æ®ã€‚æ ¹æ®è¯¥é›†åˆä¸­ç¤ºä¾‹çš„æ•°é‡ï¼Œæ‚¨å¯èƒ½å¸Œæœ›å¯¹è®­ç»ƒ/æµ‹è¯•é›†æŒ‰ 70/30 çš„æ¯”ä¾‹è¿›è¡Œæ‹†åˆ†ã€‚åœ¨åˆ†å‰²ä¹‹å‰ï¼Œåº”è¯¥éšæœºæ‰“ä¹±æ•°æ®é›†ä¸­çš„æ•°æ®ã€‚å¦‚æœç¤ºä¾‹çš„æ•°é‡å¾ˆå¤§(å³æ•°ç™¾ä¸‡)ï¼Œé‚£ä¹ˆå¯¹äºè®­ç»ƒ/æµ‹è¯•æ•°æ®é›†ï¼Œæ‹†åˆ†å¯èƒ½ä»¥æ›´æ¥è¿‘ 90/10 æˆ– 95/5 çš„æ¯”ä¾‹å‘ç”Ÿã€‚

**ç½‘ç»œå¸¦æ¥åŠ›é‡**

é€šå¸¸ä½ ä¸ä¼šæ³¨æ„åˆ°ä»…ä»…ä¸€ä¸ªç‹¬ç«‹ç¥ç»å…ƒçš„ä½¿ç”¨ã€‚åŠ›é‡å°±åœ¨è¿™ç±»ç¥ç»å…ƒçš„[ç½‘ç»œ](https://en.wikipedia.org/wiki/Neural_network)ä¸­ã€‚ç½‘ç»œå¯ä»¥å­¦ä¹ æ›´å¤æ‚çš„ç‰¹æ€§ã€‚çº³ç±³ç¥ç»å…ƒæœ¬èº«çœ‹èµ·æ¥æ›´åƒç®€å•çš„çº¿æ€§å›å½’ï¼Œè€Œä¸æ˜¯ç¥ç»ç½‘ç»œã€‚

**è¾“å…¥å½’ä¸€åŒ–**

åœ¨è®­ç»ƒä¹‹å‰ï¼Œæœ€å¥½å°†è¾“å…¥å€¼[æ ‡å‡†åŒ–](https://www.jeremyjordan.me/batch-normalization/)ã€‚

**çŸ¢é‡åŒ–å®ç°**

å¯¹äºç½‘ç»œæ¥è¯´ï¼ŒçŸ¢é‡åŒ–(çŸ©é˜µ)è®¡ç®—æ¯”`for`å¾ªç¯è¦å¿«å¾—å¤šã€‚é€šå¸¸ï¼Œå¦‚æœä»¥çŸ¢é‡åŒ–å½¢å¼å®ç°å¹¶ä½¿ç”¨ [Numpy](https://numpy.org/) Python åº“è¿›è¡Œè®¡ç®—ï¼Œå‰å‘/åå‘ä¼ æ’­ä¼šå·¥ä½œå¾—æ›´å¿«ã€‚

**æˆæœ¬å‡½æ•°çš„æœ€å°å€¼**

æˆ‘ä»¬åœ¨è¿™ä¸ªä¾‹å­ä¸­ä½¿ç”¨çš„æˆæœ¬å‡½æ•°è¿‡äºç®€åŒ–ã€‚å®ƒåº”è¯¥æœ‰[å¯¹æ•°åˆ†é‡](https://stackoverflow.com/questions/32986123/why-the-cost-function-of-logistic-regression-has-a-logarithmic-expression/32998675)ã€‚æ”¹å˜æˆæœ¬å‡½æ•°ä¹Ÿå°†æ”¹å˜å…¶å¯¼æ•°ï¼Œå› æ­¤åå‘ä¼ æ’­æ­¥éª¤ä¹Ÿå°†ä½¿ç”¨ä¸åŒçš„å…¬å¼ã€‚

**æ¿€æ´»åŠŸèƒ½**

æ­£å¸¸æƒ…å†µä¸‹ï¼Œç¥ç»å…ƒçš„è¾“å‡ºåº”è¯¥é€šè¿‡æ¿€æ´»å‡½æ•°ï¼Œå¦‚ [Sigmoid](https://en.wikipedia.org/wiki/Sigmoid_function) æˆ– [ReLU](https://en.wikipedia.org/wiki/Rectifier_(neural_networks)) æˆ–å…¶ä»–ã€‚

> *æ›´å¤šæ›´æ–°å’Œæ–°æ–‡ç« * [*åœ¨ Twitter ä¸Šå…³æ³¨æˆ‘*](https://twitter.com/Trekhleb)