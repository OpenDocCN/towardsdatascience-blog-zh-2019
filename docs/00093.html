<html>
<head>
<title>6 Different Ways to Compensate for Missing Values In a Dataset (Data Imputation with examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">补偿数据集中缺失值的 6 种不同方法(数据插补，附示例)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779?source=collection_archive---------0-----------------------#2019-01-05">https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779?source=collection_archive---------0-----------------------#2019-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c7508e69677ed94f46960f329f59f5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7OPSeSl-x2UVG1fJ"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@vilmosheim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vilmos Heim</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="6e65" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">统计估算数据集中缺失值的常用策略。</h2></div><p id="a932" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于各种原因，许多现实世界的数据集可能包含缺失值。它们通常被编码为名词、空格或任何其他占位符。使用具有大量缺失值的数据集来训练模型会极大地影响机器学习模型的质量。一些算法如<em class="lu"> scikit-learn 估计器</em>假设所有的值都是数字的，并且拥有有意义的值。</p><p id="c730" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">处理这个问题的一个方法是去掉有缺失数据的观测值。但是，您可能会丢失包含有价值信息的数据点。更好的策略是估算缺失值。换句话说，我们需要从数据的现有部分推断出那些缺失的值。缺失数据主要有三种类型:</p><ul class=""><li id="ee7c" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">完全随机失踪(MCAR)</li><li id="5e5b" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">随机失踪(三月)</li><li id="2c9b" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">不是随意失踪(NMAR)</li></ul><p id="2f60" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在这篇文章中，我将重点介绍 6 种流行的横截面数据集的数据插补方法(时间序列数据集是一个不同的故事)。</p><h1 id="9345" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">1-什么都不做:</h1><p id="79e4" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这很简单。你只是让算法处理丢失的数据。一些算法可以考虑缺失值，并基于训练损失减少(即 XGBoost)。有些人可以选择忽略它们(即。light GBM—<em class="lu">use _ missing = false</em>。然而，其他算法会惊慌失措，并抛出一个报错值(即。Scikit learn —线性回归)。在这种情况下，您需要处理丢失的数据，并在将它提供给算法之前对其进行清理。</p><p id="e40b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看在训练前估算缺失值的其他方法:</p><blockquote class="ng nh ni"><p id="68ea" class="ky kz lu la b lb lc kk ld le lf kn lg nj li lj lk nk lm ln lo nl lq lr ls lt im bi translated"><strong class="la jk">注意:下面所有的例子都使用了 Scikit-learn 的</strong> <a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.fetch_california_housing.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">加州住房数据集</strong> </a> <strong class="la jk">。</strong></p></blockquote><h1 id="0b8e" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">2-使用(平均值/中值)的插补:</h1><p id="add1" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">其工作原理是计算一列中非缺失值的平均值/中值，然后独立地替换每列中缺失的值。它只能用于数值数据。</p><figure class="nn no np nq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/d6b2ba8fee005e4be85ac3e66b9b6142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiJ_HpTbZECYjjF1qepNNQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Mean Imputation</figcaption></figure><p id="2a95" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">优点:</strong></p><ul class=""><li id="d6c2" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">简单快捷。</li><li id="f3c7" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">适用于小型数值数据集。</li></ul><p id="cb5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">缺点</strong>:</p><ul class=""><li id="a2b7" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">不考虑特征之间的相关性。它只在列级别有效。</li><li id="978e" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">将对编码的分类特征给出较差的结果(不要对分类特征使用它)。</li><li id="83fc" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">不太准确。</li><li id="eb1f" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">没有考虑插补的不确定性。</li></ul><figure class="nn no np nq gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Mean/Median Imputation</figcaption></figure><h1 id="05c7" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">3-使用(最频繁)或(零/常数)值的插补:</h1><p id="3ab3" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><strong class="la jk">最常见的</strong>是<strong class="la jk"> </strong>另一种估算缺失值的统计策略，没错！！它通过用每列中最频繁的值替换缺失数据来处理分类特征(字符串或数字表示)。</p><p id="3ff9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">优点:</strong></p><ul class=""><li id="b98b" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">适用于分类特征。</li></ul><p id="5b9e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">缺点:</strong></p><ul class=""><li id="81b8" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">它也没有考虑特征之间的相关性。</li><li id="a945" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它会在数据中引入偏差。</li></ul><figure class="nn no np nq gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Most Frequent Imputation</figcaption></figure><p id="49d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">零或常数</strong>插补——顾名思义——用零或您指定的任何常数值替换缺失值</p><figure class="nn no np nq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/e7f08dc8b268a3bd7eeb178d0fe3bbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2L2lSHCYCYQTDoHTy2o9Kw.png"/></div></div></figure><h1 id="0d20" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">4-使用 k-NN 的插补:</h1><p id="f35a" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><em class="lu"> k </em>最近邻是一种用于简单分类的算法。该算法使用“<strong class="la jk">特征相似度</strong>来预测任何新数据点的值。这意味着根据新点与训练集中的点的相似程度为其赋值。这对于预测缺失值非常有用，方法是找到与缺失数据的观测值最接近的<em class="lu"> k 的</em>邻域，然后基于邻域中的非缺失值对其进行输入。让我们看一些使用<code class="fe nu nv nw nx b"><a class="ae jg" href="https://impyute.readthedocs.io/en/master/#" rel="noopener ugc nofollow" target="_blank">Impyute</a></code>库的示例代码，该库提供了一种使用 KNN 进行插补的简单易行的方法:</p><figure class="nn no np nq gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">KNN Imputation for California Housing Dataset</figcaption></figure><h2 id="29c0" class="ny mk jj bd ml nz oa dn mp ob oc dp mt lh od oe mv ll of og mx lp oh oi mz oj bi translated">它是如何工作的？</h2><p id="5bd1" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">它创建一个基本的均值估算，然后使用生成的完整列表来构建一个 KDTree。然后，它使用生成的 KDTree 来计算最近邻(NN)。在找到 k-nn 之后，它对它们进行加权平均。</p><figure class="nn no np nq gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8d6e3675c9164dff18bf25615763ccf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*b9BXv0uAkbSAn8MJIa4-_Q.gif"/></div></figure><p id="c034" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">优点:</strong></p><ul class=""><li id="bd12" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">可能比平均值、中间值或最常见的插补方法更准确(取决于数据集)。</li></ul><p id="ee7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">缺点:</strong></p><ul class=""><li id="f084" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">计算开销很大。KNN 的工作原理是将整个训练数据集存储在内存中。</li><li id="e6a1" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">K-NN 对数据中的异常值非常敏感(<strong class="la jk">不同于 SVM </strong>)</li></ul><h1 id="993a" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">5-使用链式方程多元插补的插补(小鼠)</h1><figure class="nn no np nq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/6c10685b90f288999c40a514f5b1b3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmZFWypJUrFL2QL3KyzXEQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Main steps used in multiple imputations [1]</figcaption></figure><p id="1e6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种类型的插补通过多次填充缺失数据来实现。多重插补(MIs)比单一插补好得多，因为它以更好的方式衡量缺失值的不确定性。链式方程方法也非常灵活，可以处理不同数据类型的不同变量(即连续或二进制)以及诸如边界或勘测跳跃模式的复杂性。关于算法机制的更多信息，你可以参考 R <a class="ae jg" href="https://www.jstatsoft.org/article/view/v045i03/v45i03.pdf" rel="noopener ugc nofollow" target="_blank">研究论文</a></p><figure class="nn no np nq gt iv"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="nn no np nq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/ecea09ddf751ee3ae400a58a1f6ae100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylbDaIbxkvc-Zzj5ngci-g.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">MICE imputation using impyute</figcaption></figure><h1 id="3402" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">6-使用深度学习的插补(<a class="ae jg" href="https://github.com/awslabs/datawig" rel="noopener ugc nofollow" target="_blank">数据偏移</a>):</h1><p id="ac27" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这种方法非常适用于分类和非数字特征。它是一个库，使用深度神经网络学习机器学习模型，以估算数据帧中的缺失值。它还支持 CPU 和 GPU 进行训练。</p><figure class="nn no np nq gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Imputation using Datawig</figcaption></figure><p id="23de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">优点</strong>:</p><ul class=""><li id="d778" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">与其他方法相比相当准确。</li><li id="34f3" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它有一些可以处理分类数据的函数(特征编码器)。</li><li id="37f9" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它支持 CPU 和 GPU。</li></ul><p id="57a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">缺点:</strong></p><ul class=""><li id="31ab" class="lv lw jj la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">单列插补。</li><li id="074d" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">对于大型数据集可能会非常慢。</li><li id="cd8e" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">您必须指定包含要估算的目标列信息的列。</li></ul><h1 id="4d18" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">其他插补方法:</h1><h2 id="a0ca" class="ny mk jj bd ml nz oa dn mp ob oc dp mt lh od oe mv ll of og mx lp oh oi mz oj bi translated">随机回归插补:</h2><p id="bd52" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">它与回归插补法非常相似，回归插补法试图通过从同一数据集中的其他相关变量加上一些随机残差值进行回归来预测缺失值。</p><h2 id="1f23" class="ny mk jj bd ml nz oa dn mp ob oc dp mt lh od oe mv ll of og mx lp oh oi mz oj bi translated">外推和内插法:</h2><p id="a56b" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">它试图从一组离散的已知数据点范围内的其他观察值中估计值。</p><h2 id="57d6" class="ny mk jj bd ml nz oa dn mp ob oc dp mt lh od oe mv ll of og mx lp oh oi mz oj bi translated">热卡插补:</h2><p id="0776" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">工作原理是从一组相关和相似的变量中随机选择缺失值。</p><p id="9941" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，没有完美的方法来补偿数据集中缺失的值。对于某些数据集和缺失数据类型，每种策略的性能都较好，但对于其他类型的数据集，性能可能会差得多。有一些固定的规则来决定对特定类型的缺失值使用哪种策略，但除此之外，您应该试验并检查哪种模型最适合您的数据集。</p><h2 id="ae4a" class="ny mk jj bd ml nz oa dn mp ob oc dp mt lh od oe mv ll of og mx lp oh oi mz oj bi translated"><strong class="ak">参考文献:</strong></h2><ul class=""><li id="6c8c" class="lv lw jj la b lb nb le nc lh on ll oo lp op lt ma mb mc md bi translated">[1] Buuren，S. V .，&amp; Groothuis-oudshorn，K. (2011 年)。Mice:用链式方程进行多变量插补</li><li id="88b0" class="lv lw jj la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae jg" href="https://impyute.readthedocs.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank">https://impyute.readthedocs.io/en/master/index.html</a></li></ul></div></div>    
</body>
</html>