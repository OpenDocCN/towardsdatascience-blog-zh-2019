<html>
<head>
<title>Getting started with Bitcoin data on Kaggle with Python and BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 和 BigQuery 在 Kaggle 上开始使用比特币数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/https-medium-com-nocibambi-getting-started-with-bitcoin-data-on-kaggle-with-python-and-bigquery-d5266aa9f52b?source=collection_archive---------21-----------------------#2019-11-01">https://towardsdatascience.com/https-medium-com-nocibambi-getting-started-with-bitcoin-data-on-kaggle-with-python-and-bigquery-d5266aa9f52b?source=collection_archive---------21-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="afd1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">什么是区块链</h2><div class=""/><div class=""><h2 id="06d3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">逐步概述</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6a2b152bd13ea241d547ddeb40bc3d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rN1m_hVBeBWeW5wG"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@silverhousehd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">André François McKenzie</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我的<a class="ae lh" href="https://medium.com/@nocibambi/how-to-get-into-bigquery-analysis-on-kaggle-with-python-b75ee5e0a79d" rel="noopener">上一篇文章</a>中，我研究了 Python 在 Kaggle 上研究 BigQuery 数据的可用性。在那里，我得出结论，就目前而言，我们无法避免比我最初设想的更广泛地使用 BigQuery。</p><p id="039e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(本文是用 Python 分析 BigQuery 区块链数据系列文章的一部分。关于项目和帖子的概述，见<a class="ae lh" href="https://medium.com/@nocibambi/blockchain-data-analysis-on-kaggle-with-bigquery-and-python-c7ab2f46ace" rel="noopener">此链接</a>。)</p><p id="fce2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我展示了一种简单直接的方法，在<code class="fe me mf mg mh b">pandas</code>和谷歌的<code class="fe me mf mg mh b">bigquery</code> Python 模块的帮助下，在<a class="ae lh" href="https://www.kaggle.com/bigquery/bitcoin-blockchain" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上运行 BigQuery 比特币数据集的查询。你可以<a class="ae lh" href="https://www.kaggle.com/nocibambi/getting-started-with-bitcoin-data/" rel="noopener ugc nofollow" target="_blank">看到并分支我写这篇文章所基于的笔记本</a>，你可以在它的<a class="ae lh" href="https://console.cloud.google.com/marketplace/details/bitcoin/crypto-bitcoin?filter=solution-type:dataset&amp;id=7fd60425-cb95-4a58-b59f-ab3789642844" rel="noopener ugc nofollow" target="_blank"> BigQuery 页面</a>上阅读更多关于数据集的信息。</p><p id="1725" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然有其他方法可以访问比特币数据，但<a class="ae lh" href="https://cloud.google.com/blog/products/data-analytics/introducing-six-new-cryptocurrencies-in-bigquery-public-datasets-and-how-to-analyze-them" rel="noopener ugc nofollow" target="_blank">谷歌的 BigQuery 数据集</a>集合是关于比特币的最详尽和最新的数据源，它还包含了更多加密货币的数据。另一方面，通过 Google 云平台使用 BigQuery 是一套完全独立的技能，您需要掌握这些技能才能开始分析。相比之下，使用 Kaggle 可以给你一个快速的开端，尽管——正如我在上一篇文章中指出的——你确实需要了解一些 BigQuery SQL。此外，通过 Google Cloud，在免费计划中，你一个月只能处理 1TB 的数据，而使用 Kaggle 的许可证可以为你提供 5tb 的处理能力。</p><h2 id="52c5" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">概述</h2><ol class=""><li id="edc2" class="na nb it lk b ll nc lo nd lr ne lv nf lz ng md nh ni nj nk bi translated">BigQuery <code class="fe me mf mg mh b">Client</code>对象</li><li id="dbb4" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">BigQuery 数据集和表的一般结构</li><li id="1fd4" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">一个示例查询</li><li id="0185" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">运行查询并生成数据帧</li><li id="a229" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">情节</li></ol><p id="628b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我将介绍 BigQuery <code class="fe me mf mg mh b">Client</code>对象，我们将使用它来访问数据。在这个对象的帮助下，我们将对 BigQuery 数据集的高层结构有所了解。接下来，我们将编写一个简单的查询来访问比特币数据。</p><p id="5595" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于比特币数据集非常庞大，并且使用 BigQuery 的成本非常高(无论是在内存使用还是时间方面)，我们还将评估查询的大小以及产生的数据帧。虽然这不是我们在这里的主要焦点，但最后，我们将生成一些关于熊猫的情节。</p><h1 id="8593" class="nq mj it bd mk nr ns nt mn nu nv nw mq ki nx kj mt kl ny km mw ko nz kp mz oa bi translated">🔧BigQuery“客户端”对象</h1><p id="6b5a" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">这里我们使用 Google 的官方 Python 库，特别是它的<code class="fe me mf mg mh b">bigquery</code>模块。导入库之后，我们初始化一个<code class="fe me mf mg mh b">Client</code>对象，这将是我们访问和处理数据的主要工具。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4a32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们会经常检查我们创建和使用的对象，所以我们创建一个助手函数来简化这个过程。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4f44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在我们的<code class="fe me mf mg mh b">client</code>物体上进行试验。这让我们知道它处理的是什么类型的其他对象(例如，'表'，'数据库'，'模式'，'模型'，'行'，'作业')，以及它应该执行什么操作(例如，'列表'，'获取'，'更新'，'删除')。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/2d7531177327186411288c036feffd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yp8MaLPUgs09QtrMIbnjhA.png"/></div></div></figure><p id="d513" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(如果您对<code class="fe me mf mg mh b">client</code>对象的细节感兴趣，您可以在它的<a class="ae lh" href="https://cloud.google.com/apis/docs/client-libraries-explained" rel="noopener ugc nofollow" target="_blank">文档</a>或它的<a class="ae lh" href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html" rel="noopener ugc nofollow" target="_blank"> API 描述</a>中了解更多信息)</p><h1 id="766b" class="nq mj it bd mk nr ns nt mn nu nv nw mq ki nx kj mt kl ny km mw ko nz kp mz oa bi translated">📩访问 BigQuery 数据集和表</h1><p id="5eb8" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">为了理解下面的步骤，如果我们从概览图像开始会有所帮助。</p><p id="0ee7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(图片来自<a class="ae lh" href="https://www.kaggle.com/dansbecker/getting-started-with-sql-and-bigquery" rel="noopener ugc nofollow" target="_blank"> Kaggle 的教程</a>。它使用了 Hackernews 数据集的例子，但是它的逻辑也适用于这里)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/6f840cc6c5cf5e5b26a475f84a4aeebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dgHJCG5K2HIUwDRTm1prg.png"/></div></div></figure><p id="1ebd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结构相对简单。一个客户可以有多个项目，这些项目的数据集由不同的表组成。我们已经创建了一个客户端对象，因此，在本节中，我们继续执行以下步骤:</p><ol class=""><li id="6be2" class="na nb it lk b ll lm lo lp lr oi lv oj lz ok md nh ni nj nk bi translated">定义项目和数据集</li><li id="8de2" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">获取表名</li><li id="210c" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">定义表引用</li><li id="f83c" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">获取表模式</li><li id="5df4" class="na nb it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">检查前几行</li></ol><p id="1518" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在演示这些步骤时，我们将经常检查我们创建的对象的属性。希望这能让这个过程更好理解，更有可复制性。</p><p id="264b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了仅仅访问数据之外，每当我们想要做其他事情，或者每当我们事先需要一些信息时，我们需要能够在数据集和表之间导航。以下步骤向我们展示了实现这一点的基本方法。</p><h2 id="28e6" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">获取有关数据的信息</h2><p id="20a1" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated"><code class="fe me mf mg mh b">client</code>对象的主要用途之一是获取我们试图访问的数据对象的信息。例如，查找术语“列表”，我们的函数返回以下属性。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/5738ecab837c5e66c89ec361ae57f350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mkm1hX--DqoyPG6Ja4NRQ.png"/></div></div></figure><p id="c12b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了符合我们的意图，我们将使用<code class="fe me mf mg mh b">list_tables</code>和<code class="fe me mf mg mh b">list_rows</code>。</p><p id="b8ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(我们也可以尝试列出数据集，但 Kaggle 许可证不允许这样做)。我们可以在<a class="ae lh" href="https://www.kaggle.com/bigquery/bitcoin-blockchain" rel="noopener ugc nofollow" target="_blank">页面</a>上找到数据集名称</p><p id="b959" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们要列出表格。然而，在此之前，我们需要定义一个项目，通过它我们可以访问一个 BigQuery 数据集。因为我们通过 Kaggle 的许可工作，所以我们使用‘big query-public-data’项目。数据集的名称是“crypto_bitcoin”。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="19c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将这些参数传递给<code class="fe me mf mg mh b">list_tables</code>方法，该方法又返回一个迭代器。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8443" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了看得更清楚，我们列出了它返回的第一个项目的属性。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/d83175c0cc259b1df8666aa33b75d266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xhl26rBxTQxd0kf8ikBU3A.png"/></div></div></figure><p id="d343" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该列表显示数据集中表对象的属性。基于它，我们将使用<code class="fe me mf mg mh b">table_id</code>属性，该属性将返回数据集中的表的名称。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/5fd9b2f483662a5f360ee398bd20752c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzWAH-NjHlJr-OLBao3s8Q.png"/></div></div></figure><p id="b3c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们检查一下<code class="fe me mf mg mh b">transactions</code>表。我们可以通过<code class="fe me mf mg mh b">Client</code>对象再次做到这一点。这里我们列出了与表相关的客户机属性和方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f2ca3ee8aeb7068bf5cbcf458b6ec85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*SbRcJetL3LM9fbMSZxLT6Q.png"/></div></figure><p id="8275" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中，我们使用了<code class="fe me mf mg mh b">get_table</code>方法。这样做将创建一个对表的引用，我们可以访问它来检查它的内部。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/c62981f9c4f2f5ad2cf5c996496c325c.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*l5F8CQLZcTb_HBtU-MaEug.png"/></div></div></figure><p id="6152" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们检查表的模式。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/480c5186c88a5e422b98fcb297c6bea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzsWqnXprZSA-h_mzADtRg.png"/></div></div></figure><p id="e124" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个列表显示了关于表的列的信息，比如它的名称和数据类型。我们还可以看到,<code class="fe me mf mg mh b">inputs</code>和<code class="fe me mf mg mh b">outputs</code>表本身包含更多的<code class="fe me mf mg mh b">SchmeaField</code>对象，这表明在列中嵌套了更多的表。</p><p id="ee83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地理解，我们列出了表的前五行，并将其转换成 pandas 数据帧。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/423d9a9e57039b9489dad5e94adfe82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neKl-wbcLJLHnI_LS0e_dg.png"/></div></div></figure><p id="d9fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们看一下第一个的<code class="fe me mf mg mh b">outputs</code>值。因为——正如我们注意到的——它是一个嵌套表，该“单元格”的内容是第一个事务的相应输出相关信息。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/504d18543678cf7f8c4342df8a34eb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XGVg_Ie6HDHLDG-fL2_Dw.png"/></div></div></figure><p id="54d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">至此，我们达到了 BigQuery <code class="fe me mf mg mh b">client</code>对象操作的极限。这对于了解被检查的数据集和表很有用，但是要做任何更实质性的事情，我们需要运行实际的 SQL 查询。</p><h1 id="010d" class="nq mj it bd mk nr ns nt mn nu nv nw mq ki nx kj mt kl ny km mw ko nz kp mz oa bi translated">🔍该查询</h1><p id="4934" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">假设我们对 2017 年 9 月期间比特币交易的频率和价值感兴趣。我们希望有一个事务的标识符，它们的时间(至少大约)，以及输入和输出的计数和值。</p><p id="52ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的 SQL 查询就是这样做的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6263" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个简单的查询，但是让我们做一些解释:</p><p id="4b93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">FROM</code>:从<code class="fe me mf mg mh b">crypto_bitcoin</code>数据集中通过<code class="fe me mf mg mh b">bigquery-public-data</code>项目访问<code class="fe me mf mg mh b">transactons</code>表。</p><p id="edce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">SELECT</code>:选择以下栏目:</p><ul class=""><li id="56be" class="na nb it lk b ll lm lo lp lr oi lv oj lz ok md os ni nj nk bi translated"><code class="fe me mf mg mh b">hash</code>(因为<code class="fe me mf mg mh b">hash</code>是 BigQuery 中的一个<a class="ae lh" href="https://cloud.google.com/bigquery/docs/reference/legacy-sql#hash" rel="noopener ugc nofollow" target="_blank">遗留 SQL 关键字，我们需要将这个列名放在反斜杠中)，</a></li><li id="9f18" class="na nb it lk b ll nl lo nm lr nn lv no lz np md os ni nj nk bi translated"><code class="fe me mf mg mh b">block_timestamp</code>，</li><li id="e5ae" class="na nb it lk b ll nl lo nm lr nn lv no lz np md os ni nj nk bi translated"><code class="fe me mf mg mh b">binput_count</code>，</li><li id="7b87" class="na nb it lk b ll nl lo nm lr nn lv no lz np md os ni nj nk bi translated"><code class="fe me mf mg mh b">binput_value</code>，</li><li id="5990" class="na nb it lk b ll nl lo nm lr nn lv no lz np md os ni nj nk bi translated"><code class="fe me mf mg mh b">boutput_count</code>，</li><li id="6260" class="na nb it lk b ll nl lo nm lr nn lv no lz np md os ni nj nk bi translated"><code class="fe me mf mg mh b">boutput_value</code></li></ul><p id="8f4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">WHERE</code>:过滤数据，只显示数据块时间戳在 2017 年 9 月的记录。(正如<a class="ae lh" href="https://hackernoon.com/a-clarification-on-the-perpetual-discussion-of-bitcoins-timestamp-5597859a9193" rel="noopener ugc nofollow" target="_blank">这篇文章解释的</a>，比特币交易没有时间戳，因为它们被捆绑在一起，所以这是我们可以用来作为时间指示器的最接近的东西)</p><p id="12eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于我们需要处理的资源有限，所以在运行查询之前估计它的大小是一个很好的做法。我们可以通过打开<code class="fe me mf mg mh b">dry run</code>作业配置参数来实现。为此，我们编写了一个助手函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/7e36ade13934d11d74011a1c20565263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*KfLiFhMDC0a751Wd5Zx47w.png"/></div></figure><p id="c065" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该查询将需要处理大约 53gb 的数据。当我们通过 Kaggle 的许可工作时，我们有 5TB 的每月预算，所以我们会很好。然而，这是一个有限的查询，例如，在<code class="fe me mf mg mh b">transactions</code>表上运行一个<code class="fe me mf mg mh b">SELECT *</code>将需要处理 1TB 的数据。</p><h1 id="9509" class="nq mj it bd mk nr ns nt mn nu nv nw mq ki nx kj mt kl ny km mw ko nz kp mz oa bi translated">🕒运行查询</h1><p id="0e39" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">现在，是时候运行查询了。因为默认情况下，一个作业被限制为 1gb，以防止意外处理太多数据，所以我们需要手动设置一个新的限制。我们通过在初始化 BigQuery <code class="fe me mf mg mh b">QueryJobConfig</code>对象时传递一个<code class="fe me mf mg mh b">maximum_bytes_billed</code>作业配置参数来实现这一点。</p><p id="ac84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，我们将这个对象传递给<code class="fe me mf mg mh b">client</code>对象的<code class="fe me mf mg mh b">query</code>方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3c41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下一步是得到工作的结果。我们还将其转换为 pandas 数据框架，因为在这一步之后，我们希望以这种形式继续处理数据。</p><p id="ad98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(对于那些考虑运行这段代码的人，请注意:这一步大约需要 15 分钟来运行。)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1323" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">拥有数据帧格式的数据是一个很好的里程碑。尽管如此，我们也想评估结果的大小。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/92591030696bc2ac0e5ef2df5934d402.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*hZWW3_aoo0tyTDJfPCOZVA.png"/></div></figure><p id="34a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">产生的数据帧非常大，超过 700 万行，占用将近 2.5，这取决于预期的工作，会影响处理时间。</p><p id="f3de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，正如详细视图所示，大部分大小来自三列:<code class="fe me mf mg mh b">hash</code>、<code class="fe me mf mg mh b">input_value</code>和<code class="fe me mf mg mh b">output_value</code>。虽然我们在这里不会这样做，但如果需要，并且不影响我们的分析目标，我们可以通过对数值进行脱壳并将散列信息转换为分类信息来减小对象的大小。</p><p id="76f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，为了以后的使用，我们可以将数据帧保存到 csv 中，这样我们下次就可以避免从云中查询数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="2417" class="nq mj it bd mk nr ns nt mn nu nv nw mq ki nx kj mt kl ny km mw ko nz kp mz oa bi translated">📈情节</h1><p id="a94b" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">最后，让我们做一些基本的数据可视化。因为我们有事务的输入和输出值和计数以及块时间戳，所以我们可以很容易地检查它们是如何随时间变化的，以及它们的值是否有明显的时间模式。(以下是精选，可以在笔记本里找到所有情节)</p><p id="702d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，要做到这一点，我们需要将时间戳转换成 pandas <code class="fe me mf mg mh b">datetime</code>格式。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="ec7d" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">总交易产值</h2><p id="6b05" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">这里，我们将实际事务输出值的值绘制在它们的块的时间戳上。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bef3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于这是一个过于精细的图，很难看到整体模式，但它确实显示了一些异常值事件。例如，从 9 月 12 日左右开始，产值开始上升，随后几天逐渐下降。在这一个月里，比特币价格经历了大幅下跌，例如<a class="ae lh" href="https://www.coindesk.com/bitcoins-price-fallen-500-today" rel="noopener ugc nofollow" target="_blank">14 日</a>，其价值下跌了 500 多美元。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/91854ba043936fee7b38847f4e729a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vWfmfBi2RNuIUcTQojbVA.png"/></div></div></figure><h2 id="ba02" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">按工作日划分的总产值</h2><p id="263e" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">下一幅图向我们展示了总产量是如何在一周中的每一天分布的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="387d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据该图，周二和周四的交易量较多，周日的交易量最少。尤其是周日价值似乎遵循一个不令人惊讶的模式(即，人们在周末交易较少)。但是，为了使其他值有意义，我们可能希望删除异常值(例如，9 月 14 日是星期四)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/badc75a60518bc4fea1483774b08c6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZUxp9o8n8ztIfLs7WGx0Q.png"/></div></div></figure><h2 id="bf7c" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">一天中每小时的输出值</h2><p id="2c65" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">最后一个情节与前一个情节相似；只是它显示了一天中各小时之间的分布。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e218" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">分布似乎告诉我们，比特币交易在 1800–0100 期间的产值最小，在 0800–1000 和 1300–1400 左右的产值最高。然而，该图使用原始时间戳数据，没有对时区进行任何处理，因此，为了更好地理解，我们还应该考虑地理差异。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/a69cf69cafa68d444da304df702492f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTkAa3h9SeRcAG3FKHrRaQ.png"/></div></div></figure><p id="7b6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们所看到的，在我们成功地提取数据之后，用 python 生成图是很容易的。然而，为了使这些图有意义，我们确实需要更深入地研究数据维度规范并进行预处理。</p><h1 id="104d" class="nq mj it bd mk nr ns nt mn nu nv nw mq ki nx kj mt kl ny km mw ko nz kp mz oa bi translated">🌔结论</h1><p id="7243" class="pw-post-body-paragraph li lj it lk b ll nc kd ln lo nd kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">综上所述，在本帖中，我们回顾了一个借助 Python 和 BigQuery 在 Kaggle 上分析比特币数据的简单入门方法。特别是，我们从 Google 的<code class="fe me mf mg mh b">bigquery</code> Python 模块中引入了<code class="fe me mf mg mh b">Client</code>对象，并展示了如何使用它来处理数据集和表。我们还编写了一个简单的 SQL 查询并估计了它的大小。我们提取数据，将其转换成数据帧，保存，并从中生成一些图表。</p><p id="a548" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章的一个目的是帮助其他人进入区块链分析，所以如果有任何不清楚的地方，或者如果你错过了什么，请在评论中告诉我。同样，你可以随意地将<a class="ae lh" href="https://www.kaggle.com/nocibambi/getting-started-with-bitcoin-data/" rel="noopener ugc nofollow" target="_blank">的内核放在 Kaggle </a>上，并将其用于你的研究。</p></div></div>    
</body>
</html>