<html>
<head>
<title>Python Tutorial: A Name Lookup Table for Fuzzy Name Data Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 教程:模糊名称数据集的名称查找表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tutorial-a-name-lookup-table-for-fuzzy-name-data-sets-2580e4eca6e7?source=collection_archive---------17-----------------------#2019-03-27">https://towardsdatascience.com/python-tutorial-a-name-lookup-table-for-fuzzy-name-data-sets-2580e4eca6e7?source=collection_archive---------17-----------------------#2019-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8a0c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/python-stat-tutorial" rel="noopener" target="_blank"> Python 统计教程系列</a></h2><div class=""/><div class=""><h2 id="33c5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过使用姓名成分组合提高人名匹配的准确性</h2></div><p id="62ae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是我们探索 Python 数据世界之旅的第六篇文章。点击标题上方的链接，获得所有文章的列表。</p><h1 id="2971" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">本教程的目标是</h1><p id="2d4c" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">让我们回顾一下我们在<a class="ae mk" rel="noopener" target="_blank" href="/python-tutorial-fuzzy-name-matching-algorithms-7a6f43322cc5">的最后一课</a>中所取得的成绩。我们建立了一个人的名字“模糊”的名字匹配算法，通过使用一个标准化的步骤以及双变音算法的力量。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/7a2e6b571aac51eb8870e1c8bb0110a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkLMDxO8COu1afSmACNVDw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">All Name Components available</figcaption></figure><p id="e771" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该算法可以处理姓名属性<strong class="kt jd">中的错别字、特殊字符和其他差异，但如果 twitter 账户名称中缺少任何姓名成分，该算法就会失败。</strong></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/2b0ab636ec2b7b7e8b02564c07a35948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKbCmR4jbHI2LNCgFog4Og.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Two Name Components Available, one only available as an abbreviation</figcaption></figure><p id="f553" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">问题是 Twitter 帐户名称是由用户连接的，因此不具有确定性(我们假设他没有使用假名，并且有可能匹配)。正如我们在上一个教程中看到的，我们试图修复某些异常，但解决方案似乎不够健壮。因此，我们必须投入额外的时间来建立一个更健壮的解决方案，通过使用组合学来解决“缺少名称组件”的问题。</p><h2 id="b608" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">获取 Jupyter 笔记本以获得额外的教程解释</h2><p id="b8a7" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">作为我自己进入 Python 数据科学世界的一部分，我最近开始玩 Python 的<a class="ae mk" href="https://jupyter.org/index.html" rel="noopener ugc nofollow" target="_blank"> Jupyter Notebook </a>。</p><blockquote class="nm nn no"><p id="2ae5" class="kr ks np kt b ku kv kd kw kx ky kg kz nq lb lc ld nr lf lg lh ns lj lk ll lm im bi translated">Jupyter Notebook 是一个开源的 web 应用程序，允许您创建和共享包含实时代码、等式、可视化和叙述性文本的文档。用途包括:数据清理和转换、数值模拟、统计建模、数据可视化、机器学习等等。</p></blockquote><p id="991c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这简直太棒了，而且通过<a class="ae mk" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Ancaconda </a>发行版几分钟就安装好了(你的机器上需要一些备用磁盘空间)。</p><p id="8831" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我把它整合到了我的训练过程中，从现在开始，我将在 Jupyter 的专用笔记本中更详细地描述算法和编码的构建。</p><p id="950e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可以在<a class="ae mk" href="https://github.com/talfco/clb-sentiment/blob/master/jupyter/lesson6/tutorial6.ipynb" rel="noopener ugc nofollow" target="_blank">我的 Github 项目</a>中找到本教程的 Jupyter 笔记本。使用 Jupyter 笔记本(与本教程并排)，允许您在笔记本中随意摆弄和实时修改代码序列。令人惊讶的是，Github 以其原始的、易于阅读的 Web 视图格式呈现了一个 Jupyter 笔记本文件。以防你想看只读格式的！</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nt"><img src="../Images/ae87d2a3bc7cd035927b6c196ff9e2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWO9ddlpY-K3gv1-_Tow-w.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Jupyter Notebook rendered in Github</figcaption></figure><h1 id="7f11" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">在名称匹配过程中处理缺少的名称组件</h1><p id="0a08" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">我们想要实现的是，我们的算法能够管理丢失的名称组件。在下面的示例中，我们可以通过省略两边的第二个名称组件来实现匹配。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/ecb83bf20f43ad2b578e7f2d5cc29df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1hxHoB2rC0FUFXmo5qBQg.png"/></div></div></figure><p id="2d3c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">显然，我们想要一个通用算法，它可以处理 twitter 帐户名称中的任何复杂性，也就是说，在命名结构中也应该有可能进行匹配，如:</p><ul class=""><li id="06f9" class="nu nv it kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">“梅德医生。彼得·埃舍尔(苏黎世)"或</li><li id="65ea" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">“梅德医生。彼得·埃舍尔(苏黎世)”，用户打错了一个字。</li></ul><p id="f3f7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们用组合学解决的第一个问题，第二个问题，我们已经通过应用著名的双变音算法解决了。</p><h1 id="6144" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">组合和排列的简明介绍</h1><p id="1d81" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">为了在缺少元素的情况下导出任何种类的名称成分星座，我们必须理解组合学中的基本概念。</p><h2 id="e244" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">我们应该使用组合还是排列</h2><p id="4837" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">先来回答这个问题。离开学校太久？看看这个有帮助的六分钟视频(来自 betterExplained.com<a class="ae mk" href="https://betterexplained.com/articles/easy-permutations-and-combinations/" rel="noopener ugc nofollow" target="_blank"/>),它更新了各种概念。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Permutations/Combinations explained</figcaption></figure><p id="5ad2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Python 在其标准库<em class="np"> itertools </em>中已经提供了函数<em class="np">置换</em>和<em class="np">组合</em>，我们想进一步研究一下。</p><p id="184e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们将它应用于我们的名称示例，以了解其机制。首先是<em class="np">组合</em>功能</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b27b65ecfc961d49c34a14bb89993fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*OCXiPSlDDkjE4lMnsFKNMA.png"/></div></figure><p id="3f2d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">以及<em class="np">排列</em>功能:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/09da2c9293c42f7d002db63ab7626637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*FgejbXtPa0sV9gDnukvdMA.png"/></div></figure><p id="3453" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如您所见，在排列中，名称组件的<strong class="kt jd">顺序起着作用</strong>。有一个用于<code class="fe om on oo op b">('peter','alfred')</code>的元组和一个用于<code class="fe om on oo op b">('alfred','peter')</code>的元组。在组合中，名称组件的<strong class="kt jd">顺序与</strong>无关。</p><p id="b542" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对我们来说，顺序不起作用，<code class="fe om on oo op b">'peter escher'</code>被视为<code class="fe om on oo op b">'escher peter'</code>在应用双音素算法之前，我们无论如何都要对姓名成分进行排序。因此我们使用组合函数。</p><p id="244d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请始终将“个人识别码”视为“排列”的摇篮。任何 pin 码锁定机制都是基于 10 个元素中给定的一组“数字”的排列数:“1234”不能解锁被“4321”锁定的屏幕。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oq"><img src="../Images/6f064159710ba8748fb14bc0235bbdaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vf4hXjloVkRYNpmm6rQig.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">ATM — Photo by <a class="ae mk" href="https://unsplash.com/photos/eYZpTMc7hno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mirza Babic</a> on <a class="ae mk" href="https://unsplash.com/search/photos/atm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5cc9" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">为名称组合建立一个查找目录</h1><p id="4ed8" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">我们现在构建一个查找目录类，它允许我们存储姓名组件组合，并将它们与我们从 Twitter API 获得的人名进行比较。</p><h2 id="f197" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">将人员添加到查找目录</h2><p id="6e98" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">方法<code class="fe om on oo op b">add_person_to_lookup_table</code> <em class="np"> </em>计算所提供的姓名元组的所有组合，为每个组合生成相关联的双变音键，并将该键与唯一的个人 id 一起存储在查找目录中。</p><p id="821d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该方法的序列图如下所示，让我们看看所需的各种帮助方法。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi or"><img src="../Images/92e823ff60654d746523da23d64f21be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RVjPKYR7sIBQx8aZjXskg.png"/></div></div></figure><h2 id="f30b" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">方法:生成组合</h2><p id="a480" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">作为第一步，我们生成名称元组的所有组合。下面的方法计算名称元组的所有组合。例如，对于 3 个元素的元组，构建的数组包括</p><ul class=""><li id="716f" class="nu nv it kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">三元素元组本身</li><li id="0e1b" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">具有 3 个元素中的 2 个元素的组合的所有元组</li><li id="bfff" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">具有 3 个元素中的 1 个的组合的所有元组</li></ul><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="5337" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，下面的 3 个名称元组导致下面的组合列表。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ot"><img src="../Images/aa75460ba697dcdbb739122d2d0906c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFmfIA01U21zTNVzfTA78w.png"/></div></div></figure><h2 id="9f30" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">方法:将组合添加到目录</h2><p id="c576" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">在这种方法中，我们通过将每个元组添加到我们的查找目录来构建目录。</p><p id="20f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的查找目录由两个字典的元组组成，这两个字典用于存储键、值对。我们的键是从名称创建的双变音元组，值是唯一的个人标识符。</p><pre class="mm mn mo mp gt ou op ov ow aw ox bi"><span id="e132" class="nb lo it op b gy oy oz l pa pb">__lookup_dict = ({}, {})</span></pre><p id="05ca" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该方法如下所示</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="ff70" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在第 3 行代码中，我们用名称组件元组创建了一个规范化的名称字符串。该方法如下所示</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="19d3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">结果是排序后的串联元组名称元素的小写字符串:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pc"><img src="../Images/33bd1045d4823f16140f372f8ac467ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mv37CqXo8CgTiwpTDx-Sng.png"/></div></div></figure><p id="ac1e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该字符串用于生成双变音元组，这是我们的字典的键。</p><p id="94f4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在代码行 5 和 10 中，我们检查字典中是否已经有一个具有相同键的条目。</p><ul class=""><li id="f102" class="nu nv it kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">如果没有，我们添加新的键，值对。</li><li id="ee5c" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">如果已经有一个条目，我们首先检查是否已经存储了<code class="fe om on oo op b">person_id</code>。如果不是，我们将<code class="fe om on oo op b">person_id</code>添加到值数组中。</li></ul><h2 id="773f" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">方法:将人员添加到查找目录</h2><p id="2f44" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">最后，我们准备好了方法，它允许我们将名称元组添加到查找目录中。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="fbf3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，我们将以下三个人添加到查找表中。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pd"><img src="../Images/99b449a05a703087697bb8beddcf32f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1FAKXIFAl6hb1AYGv7png.png"/></div></div></figure><p id="d25a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如我们在输出中所看到的，我们的带有关键字<code class="fe om on oo op b">'PTR'</code>的 Peter 条目有一个三人标识符数组。</p><h1 id="c052" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">在我们的查找目录中匹配一个名字</h1><p id="06ee" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">我们的查找目录现在已经准备好了，可能会填充人名数据，这些数据是通过我们的政府 API 检索的。</p><p id="2716" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">缺少的是<code class="fe om on oo op b">match_name</code>方法，该方法允许我们查找通过 Twitter API 检索到的名称。我们现在要解决这个问题。</p><p id="d615" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的第一步是将所有查找目录条目——与我们搜索的名称元组匹配——收集到一个结果列表中。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><ul class=""><li id="1fcb" class="nu nv it kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">在代码行 3 中，我们通过现有的方法生成了所有名称组件组合，并对所有组合进行了迭代</li><li id="007a" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">在代码行 5 和 6 中，我们为查找准备了组合元组的键元组。</li><li id="78f0" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">在代码行 7 中，我们检查我们的密钥是否存在。如您所见，我们只对双变音元组的第一个条目进行检查，它存储在查找目录的第一个条目中。我们将基于双变音元组的排序特性的完整实现作为练习。</li></ul><pre class="mm mn mo mp gt ou op ov ow aw ox bi"><span id="090e" class="nb lo it op b gy oy oz l pa pb">if metaphone_tuple[0] in self.__lookup_dict[0]:</span></pre><p id="0759" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们的样本加载查找目录上运行<code class="fe om on oo op b">match_name</code> <em class="np"> </em>方法会产生以下输出:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pe"><img src="../Images/c32d83cb1fc2974174802cd6afdee247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYbZ7C2JL8NZMfhChhXsVA.png"/></div></div></figure><p id="1945" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如我们所看到的，我们有两个指向一个<code class="fe om on oo op b">person_id</code>的元组和一个指向三个人的元组<code class="fe om on oo op b">peter</code>(显然姓氏被多人重复使用)。指向一个人的二元组有<strong class="kt jd">相同的</strong> id <code class="fe om on oo op b">'A123'</code>。这意味着我们的匹配只确认了一个人。如果我们的结果中有指向不同人的单人元组，这意味着我们的匹配不是唯一的。</p><p id="a51c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，我们增强了我们的方法来进行这种唯一性检查(代码行 12–20):</p><ul class=""><li id="caf6" class="nu nv it kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">我们的匹配列表中有一个或多个元组总是指向一个人吗？</li><li id="6403" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">如果是，我们发现了一个唯一的记录，否则我们返回<em class="np"> None </em></li></ul><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="5eb4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们在测试样本上验证该算法(如上所述，所有内容也可以作为交互式 Jupyter 笔记本使用)</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a5f3361a233e478dec9022f0bf08bf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*0DUiG2wn_ahaSpE8_BmSkA.png"/></div></figure><p id="82c7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以我们准备将新的查找策略应用到我们的程序中。</p><h1 id="c924" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">重构我们现有的类</h1><h2 id="c9ef" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">GovAPI 类扩展</h2><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pg"><img src="../Images/123069747a27db3ad01d20937a7b2843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ToXNiLMbDL3Wxq5Jskf_5w.png"/></div></div></figure><p id="eeff" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们通过集成一个<code class="fe om on oo op b">NameLookupDirectory</code>类实例来增强我们的抽象<code class="fe om on oo op b">GovAPI</code>类。</p><pre class="mm mn mo mp gt ou op ov ow aw ox bi"><span id="73d0" class="nb lo it op b gy oy oz l pa pb">class GovAPI(ABC):<br/>  def __init__(self):<br/>    self._members = []<br/>    self._nameLookupDirectory =  NameLookupDirectory()</span></pre><p id="b3c6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们用代码序列增强了<code class="fe om on oo op b">add_person_record</code>,以构建我们的查找目录(代码行 22–29)</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="e41e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们还为<code class="fe om on oo op b">match_name</code>检查添加了一个新方法，当我们试图合并表记录时会调用这个方法。</p><pre class="mm mn mo mp gt ou op ov ow aw ox bi"><span id="a84c" class="nb lo it op b gy oy oz l pa pb">def match_name(self, name_tuple):<br/>    return self._nameLookupDirectory.match_name(name_tuple)</span></pre><p id="1c30" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不再需要下面的<code class="fe om on oo op b">calculate_name_matching</code>方法。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><h2 id="d9bd" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">SocialMediaAnalyzer 类重构</h2><p id="7eff" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">在这个类中，我们还必须重构<code class="fe om on oo op b">calculate_name_matching</code>方法，我们现在调用匹配的<code class="fe om on oo op b">govAPI</code>类实例的<code class="fe om on oo op b">match_name</code>方法(第 5 行)。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="b5aa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们有一个匹配(7–14)，我们从 govAPI 类中检索完整的 person 记录。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="0245" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">记住,<code class="fe om on oo op b">calculate_name_matching</code>方法是通过 Panda <code class="fe om on oo op b">apply</code>方法在每个行记录上调用的，因此，该行将由附加的新列补充:</p><pre class="mm mn mo mp gt ou op ov ow aw ox bi"><span id="d490" class="nb lo it op b gy oy oz l pa pb">panda_data = { 'ScreenName' : self.__col_screen_name,<br/>               'Name': self.__col_name,<br/>               'Description': self.__col_description,<br/>               "FollowersCount": self.__col_followers_count,<br/>               "FriendsCount": self.__col_friends_count,<br/>               "Party": self.__col_party<br/>               }<br/>df = DataFrame(panda_data, index=self.__labels)<br/>df = df.apply(self.__calculate_name_matching, axis=1)</span></pre><p id="c407" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当我们再次执行程序时，Twitter 检索到的表如下所示:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ph"><img src="../Images/c8305c2e11cf10e8a22a7f1ff89ec5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qg3gtXmuV2YInAgR_t3BrQ.png"/></div></div></figure><p id="0d98" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<code class="fe om on oo op b">col_match1</code>中，我们列出了 govAPI 惟一 id，在<code class="fe om on oo op b">col_match2</code>中，我们列出了结果元组列表，并对其进行了分析。例如</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/ea0f4da644aa17d6683bf7aea4506628.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*s4dVo8Xz4WXUrEgXmZJ6JA.png"/></div></figure><p id="18f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于 Twitter 名称“Christian Levrat ”,我们在查找表中找到了三个条目:</p><ul class=""><li id="0862" class="nu nv it kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">“christian leverat”映射到 1 个人 id (1150)</li><li id="6a57" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">“christian”映射到 5 个人 id</li><li id="7a4c" class="nu nv it kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">“leverat”映射到 1 个人 id (11509</li></ul><p id="c7ee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的匹配算法有一个肯定的匹配，因为两个条目都指向同一个人 id。</p><h1 id="bda0" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">评估我们算法的假阳性</h1><p id="a73f" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">让我们检查一下误报的算法。</p><p id="c1b6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">什么是误报？</p><blockquote class="nm nn no"><p id="0955" class="kr ks np kt b ku kv kd kw kx ky kg kz nq lb lc ld nr lf lg lh ns lj lk ll lm im bi translated">假阳性是指当你应该得到阴性结果时，却得到了阳性结果。它有时被称为“<a class="ae mk" href="https://www.statisticshowto.datasciencecentral.com/false-alarm-ratio-definition/" rel="noopener ugc nofollow" target="_blank">假警报</a>或“假阳性错误”它通常用于医学领域，但也可以应用于其他领域(如软件测试)。(<a class="ae mk" href="https://www.statisticshowto.datasciencecentral.com/false-positive-definition-and-examples/" rel="noopener ugc nofollow" target="_blank"> Ref </a></p></blockquote><p id="fcc3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">假阳性意味着我们算法的准确性有问题。</p><h2 id="6262" class="nb lo it bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md iz bi translated">假阳性 1</h2><p id="6bb9" class="pw-post-body-paragraph kr ks it kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">当我们浏览 Twitter 表时，会遇到下面的记录。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pj"><img src="../Images/f1e59aa7cc07ce2b2a1c3af60b0606dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrUjTcqNsgyNWqukumiUQA.png"/></div></div></figure><p id="5dee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">它们都指向同一个人员 id。在检查 govAPI 表中的记录时，我们得到以下记录“74 Christoph Eymann”，它没有 Twitter 帐户，因此在 Twitter 表中找不到。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pk"><img src="../Images/ca447f538c2c03161c6349fb80c641ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrgfEfqsek-_SPjjMNGa1w.png"/></div></div></figure><p id="652e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">哪里出了问题:</strong></p><p id="a93f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">“Christophe Darbellay”和“Christoph mrgeli”曾是瑞士委员会的政治家，因此不在 govAPI 名单中，我们只对活跃成员进行了筛选。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/a833c745ac5367dd1ca8e6b4ca100f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*T7dzsXQ4ZEMnFG8iKj7F9w.png"/></div></figure><p id="779c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">“Christophe”和“Christoph”被转换成相同的双变音字符串，并且与“Christoph Leymann”的 govAPI 记录 74 相匹配。由于 govAPI 列表中只有一个姓“Christoph”的人，因此我们的算法会为任何姓“Christoph(e)”的人返回一个误报，并将其与“Christoph Leymann”进行匹配。govAPI 会列出两个姓“Christoph”的人吗？匹配记录会指向两个人的 id，不再是唯一的。我们的算法在这种情况下不会导致假阳性。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/9a912fd94af443aa7cbd0dfdce5c0451.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*rwgYESPCJXCaJMxSFkVz1w.png"/></div></figure><p id="0be4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">解决方案</strong>:</p><p id="75b2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">嗯，我们必须重新调整我们的算法，使它更加严格。这意味着我们改变了名称元组生成器的条件</p><blockquote class="nm nn no"><p id="384f" class="kr ks np kt b ku kv kd kw kx ky kg kz nq lb lc ld nr lf lg lh ns lj lk ll lm im bi translated">仅允许至少将姓氏作为元素的名称组件元组。</p></blockquote><p id="39dc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，当调用者向目录中添加一个人时，我们重新调整我们的方法，要求调用者提供姓氏在元组中的位置。</p><pre class="mm mn mo mp gt ou op ov ow aw ox bi"><span id="118f" class="nb lo it op b gy oy oz l pa pb">def add_person_to_lookup_directory(self, person_id, name_tuple, last_name_pos):<br/>    tuples = self.generate_combinations(name_tuple)<br/>    self.add_combinations_to_directory(tuples, person_id, name_tuple[last_name_pos])</span></pre><p id="b797" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<code class="fe om on oo op b">add_combinations_to_directory</code>方法中，我们现在只添加包含姓氏的元组(第 3 行)。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="os oj l"/></div></figure><p id="776f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">重新运行我们的程序会产生以下匹配的统计数据。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/e18743dece48f8ca1d0592cea1a22fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*niQC1oAtHZPlTrwsSP1d5w.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Matching via Lookup Directory</figcaption></figure><p id="7c21" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这实际上并不比我们的第一次尝试更好(参考下面的<a class="ae mk" rel="noopener" target="_blank" href="/python-tutorial-fuzzy-name-matching-algorithms-7a6f43322cc5">教程</a>)，但是我们得到了一个更健壮的匹配算法。看起来使用的 Twitter 政治家列表在联邦议会的活跃成员中并不是真正最新的。但是，这是下一课要讲的内容，我们想在下一课结束数据匹配的话题，然后继续。</p><p id="e48d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">源代码你可以在相应的<a class="ae mk" href="https://github.com/talfco/clb-sentiment" rel="noopener ugc nofollow" target="_blank"> Github 项目</a>中找到，所有其他文章的列表<a class="ae mk" href="https://twitter.com/i/moments/1092507080307720193" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="639a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">编码愉快。</p></div></div>    
</body>
</html>