<html>
<head>
<title>How to Enhance your Matplotlib Plots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何增强 Matplotlib 图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/annotating-bar-charts-and-other-matplolib-techniques-cecb54315015?source=collection_archive---------12-----------------------#2019-11-28">https://towardsdatascience.com/annotating-bar-charts-and-other-matplolib-techniques-cecb54315015?source=collection_archive---------12-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f5ee688e5a6acc27c0f38de4eec1d280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g0_gwqBdZnxHm-JS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@adeolueletu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adeolu Eletu</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="be00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">眼睛是我们最重要的器官，因为我们通过视觉感知大约 80%的印象。毫不奇怪，可视化是我们收集和分析信息的最简单的方法。当谈到数据科学时，各种各样的图表帮助我们理解不同复杂性的问题。它们允许我们识别数据中的模式、关系和异常值。因此，无论我们想要分析什么数据，数据可视化都是至关重要的第一步。当使用 Python 时，M <a class="ae kf" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> atplotlib </a>和相应的插件如<a class="ae kf" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>是快速实现这一点的首选工具。</p><p id="ba60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我想向您展示一些技巧来增强和丰富您的 matplolib 数字。最重要的是，我为您提供了一种注释各种条形图的好方法。</p><p id="465e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感兴趣吗？所以让我们开始吧！</p><h1 id="0098" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">先决条件</h1><p id="55b0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">按照这个例子，你需要 Python 3.7+和 M <a class="ae kf" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> atplotlib </a>、<a class="ae kf" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>和<a class="ae kf" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>。一如既往，我推荐使用<a class="ae kf" href="https://poetry.eustace.io/" rel="noopener ugc nofollow" target="_blank">poem</a>来管理您的 Python 包和环境。你可以查看<a class="ae kf" rel="noopener" target="_blank" href="/how-to-setup-an-awesome-python-environment-for-data-science-or-anything-else-35d358cc95d5">这篇文章</a>了解如何设置它。作为一种快捷方式，我建议使用 pip 或 pipx 将其安装在您的机器上。</p><p id="465b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为提醒，我们首先要从样本数据中创建<strong class="ki iu">条形图</strong> <strong class="ki iu">图表</strong>而不需要进一步的样式化。<em class="mh">本文的目标是增强和丰富这些图表。</em>你可以在我的<a class="ae kf" href="https://github.com/Shawe82/nice-plots" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> <em class="mh"> GitHub 资源库</em> </strong> </a>上找到所有的示例代码。</p><h2 id="7b0a" class="mi lf it bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">设置</h2><p id="ef5a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们创建一个名为<em class="mh"> nice-plots </em>的诗歌项目，在这里我们实现了示例并添加了必要的包</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="7881" class="mi lf it mz b gy nd ne l nf ng">poetry new nice-plots<br/>cd nice-plots<br/>poetry add pandas matplotlib seaborn<br/>touch nice_plots/bar_charts.py</span></pre><p id="bf3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个独立的 Python 环境，安装了我们需要的所有东西。太好了，我们可以开始工作了！</p><h2 id="cb53" class="mi lf it bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">数据</h2><p id="8e94" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">作为数据，我们使用著名的<a class="ae kf" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank">鸢尾花数据集</a>。幸运的是，这是 seaborn 直接提供的。为了创建“有意义的”条形图，我首先使用<strong class="ki iu"> <em class="mh">平均值</em> </strong>作为聚合函数，按照<strong class="ki iu"><em class="mh"/></strong>对数据集进行分组。根据这些数据，我创建了四个不同的条形图，分别是<strong class="ki iu"> <em class="mh">垂直条形图</em> </strong>和<strong class="ki iu"> <em class="mh">水平条形图</em> </strong>两个版本的<strong class="ki iu"> <em class="mh">正常- </em> </strong>和<strong class="ki iu"> <em class="mh">堆叠版本</em> </strong>。在代码中，这看起来像</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="8288" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu">import</strong> seaborn <strong class="mz iu">as</strong> sns<br/><strong class="mz iu">import</strong> os<strong class="mz iu"><br/>from</strong> dataclasses <strong class="mz iu">import</strong> dataclass<br/><strong class="mz iu">import</strong> pandas <strong class="mz iu">as</strong> pd<br/><strong class="mz iu">import</strong> matplotlib.pyplot as plt<br/><strong class="mz iu">import</strong> matplotlib<br/><strong class="mz iu">from</strong> typing <strong class="mz iu">import</strong> *</span><span id="3bbf" class="mi lf it mz b gy nh ne l nf ng">sns.set()<br/><strong class="mz iu"># BLOCK 1<br/># BLOCK 2<br/># BLOCK 4<br/># BLOCK 6</strong></span><span id="a8a4" class="mi lf it mz b gy nh ne l nf ng">data = sns.load_dataset(<strong class="mz iu">"iris"</strong>).groupby(<strong class="mz iu">'species'</strong>).mean()<br/>fig, axes = plt.subplots(2,2)<br/>data.plot.bar(ax=axes[0][0]) <br/>data.plot.bar(stacked=True, ax=ax[0][1])<br/>data.plot.barh(ax=axes[1][0])<br/>data.plot.barh(stacked=True, ax=ax[1][1])<br/><strong class="mz iu"># BLOCK 3<br/># BLOCK 5<br/># BLOCK 7</strong></span><span id="1404" class="mi lf it mz b gy nh ne l nf ng">plt.show()</span></pre><p id="4ce0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我添加了注释<strong class="ki iu"> # BLOCK N </strong>，其中我<strong class="ki iu"> </strong>向前引用了下面的增强功能。我希望这不会太令人困惑。我还添加了稍后需要的所有导入。</p><p id="14e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于您可能不会坐在电脑前，下面是最终的条形图</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4aed3ea8afbd5a06026c6e30ed87ecbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Z2Wrs2gpeahavdpoAcZ9QQ.png"/></div></figure><p id="22ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，不太好，对吧？我想努力让它们变得更好是值得的。</p><h1 id="3598" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">提高</h1><h2 id="a07c" class="mi lf it bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">图形和字体大小</h2><p id="ae07" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">看这些图表时，第一件显而易见的事情是，与图中的其他部分相比，它们太小了。有几种方法可以改变这种情况。我更喜欢<strong class="ki iu"> <em class="mh">从 pyplot </em> </strong>设置全局 rcParams。<em class="mh">全局</em>意味着它们适用于你创建的所有人物，而不仅仅是某个特定人物。要更改图形大小和某些字体大小，您只需</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b67b" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu"># BLOCK 1<br/>def</strong> set_sizes(fig_size:<em class="mh">Tuple[int,int]</em>=(9, 6), <em class="mh">font_size:int</em>=10):<br/>    plt.rcParams["figure.figsize"] = fig_size<br/>    plt.rcParams["font.size"] = font_size<br/>    plt.rcParams["xtick.labelsize"] = font_size<br/>    plt.rcParams["ytick.labelsize"] = font_size<br/>    plt.rcParams["axes.labelsize"] = font_size<br/>    plt.rcParams["axes.titlesize"] = font_size<br/>    plt.rcParams["legend.fontsize"] = font_size</span><span id="2431" class="mi lf it mz b gy nh ne l nf ng">set_sizes((12,8), 10)</span></pre><p id="6958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行这个会产生</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/bdc6a4abdcbe599ee5e37097894aa30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7h2thNSLMDZ4wxOwW325qQ.png"/></div></div></figure><p id="5608" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这已经比以前好多了。但仍有改进的余地。</p><h2 id="9059" class="mi lf it bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">旋转刻度标签</h2><p id="6e80" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">垂直文本，就像水平条形图的 x 刻度标签，对我来说没有吸引力。除此之外，这种竖排文字还浪费了大量的图形空间。为了解决这个问题，Matplotlib 提供了一种简单的方法来通过</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="bc1f" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu"># BLOCK 2</strong><br/><strong class="mz iu">def</strong> rotate_xticks(ax: matplotlib.axes, degrees : <em class="mh">float</em> = 45):<br/>    ax.set_xticklabels(ax.get_xticklabels(), rotation=degrees)</span><span id="aaec" class="mi lf it mz b gy nh ne l nf ng"><strong class="mz iu"># BLOCK 3</strong><br/>rotate_xticks(ax=axes[0][0],0)<br/>rotate_xticks(ax=axes[1][0],0)</span></pre><p id="93b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于将 x 轴旋转 45 度是很常见的，所以我将其设为默认值。然而，在这个例子中，水平打印标签最有意义。可以通过将<em class="mh">度</em>设置为 0 来实现。</p><p id="2944" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的机器上产生的输出看起来像</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/71dd45494d9168003ab01e6f6cba01d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VkSQqz2pZmgM0OmKE3jJg.png"/></div></div></figure><h2 id="ee7c" class="mi lf it bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">注释条形图</h2><p id="3382" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">条形图非常适合快速直观地了解不同组之间的比较情况。然而，我们可能不仅对相对比较感兴趣，还想知道相应的绝对值。我们可以通过用各自的值注释每个条来实现这两个目标。</p><p id="8b3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我创建了一个类<em class="mh"> AnnotateBars </em>，这个类<em class="mh"> </em>允许您在堆叠和非堆叠版本中注释垂直和水平条形图</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="e958" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu"># BLOCK 4<br/>#Alias types to reduce typing, no pun intended </strong><br/>Patch = matplotlib.patches.Patch<br/>PosVal = Tuple[float, Tuple[float, float]] <br/>Axis = <em class="mh">matplotlib.axes.Axes<br/>PosValFunc = Callable[[Patch], PosVal]</em></span><span id="53d1" class="mi lf it mz b gy nh ne l nf ng">@dataclass<br/><strong class="mz iu">class</strong> AnnotateBars:<br/>    font_size: <em class="mh">int</em> = 10<br/>    color: <em class="mh">str</em> = "black"<strong class="mz iu"><br/>    </strong>n_dec: <em class="mh">int</em> = 2</span><span id="8094" class="mi lf it mz b gy nh ne l nf ng">    <strong class="mz iu">def</strong> horizontal(<strong class="mz iu">self</strong>, ax: <em class="mh">Axis, </em>centered=False):<br/>        <strong class="mz iu">def</strong> get_vals(p: Patch) -&gt; PosVal:<br/>            value = p.get_width()<br/>            div = 2 <strong class="mz iu">if</strong> centered <strong class="mz iu">else</strong> 1<br/>            pos = (<br/>                p.get_x() + p.get_width() / div,<br/>                p.get_y() + p.get_height() / 2,<br/>            )<br/>            <strong class="mz iu">return</strong> value, pos<br/>        ha = "center" <strong class="mz iu">if</strong> centered <strong class="mz iu">else</strong>  "left"<br/>        <strong class="mz iu">self</strong>._annotate(ax, get_vals, ha=ha, va="center")</span><span id="c9d0" class="mi lf it mz b gy nh ne l nf ng">    <strong class="mz iu">def</strong> vertical(<strong class="mz iu">self</strong>, ax: <em class="mh">Axis, </em>centered:<em class="mh">bool</em>=False):<br/>        <strong class="mz iu">def</strong> get_vals(p: Patch) -&gt; PosVal:<br/>            value = p.get_height()<br/>            div = 2 <strong class="mz iu">if</strong> centered <strong class="mz iu">else</strong> 1<br/>            pos = (p.get_x() + p.get_width() / 2,<br/>                   p.get_y() + p.get_height() / div<br/>            )<br/>            <strong class="mz iu">return</strong> value, pos<br/>        va = "center" <strong class="mz iu">if</strong> centered <strong class="mz iu">else</strong> "bottom"<br/>        self._annotate(ax, get_vals, ha="center", va=va)</span><span id="a826" class="mi lf it mz b gy nh ne l nf ng">    <strong class="mz iu">def</strong> _annotate(<strong class="mz iu">self</strong>, ax, func: <em class="mh">PosValFunc</em>, **kwargs):<br/>        cfg = {"color": <strong class="mz iu">self</strong>.color, <br/>               "fontsize": <strong class="mz iu">self</strong>.font_size, **kwargs}<br/>        <strong class="mz iu">for</strong> p <strong class="mz iu">in</strong> ax.patches:<br/>            value, pos = func(p)<br/>            ax.annotate(f"{value:.{<strong class="mz iu">self</strong>.n_dec}f}", pos, **cfg)</span></pre><p id="8c63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Puh，代码很多但是不用担心，我指导你怎么用。</p><p id="038b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，您需要创建一个<em class="mh"> AnnotateBars </em>的实例。您可以指定字体大小、文本颜色以及应该打印的小数位数。所有这些参数都有合理的默认值。</p><p id="c1a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，您需要调用<em class="mh">垂直</em>或<em class="mh">水平</em>，这取决于您想要注释的条形图的类型。对于这些函数，您需要传递包含相应条形图的轴对象。此外，它们接受一个名为<em class="mh">的附加参数，以</em>为中心。这样，您就可以确定注释是打印在工具栏的中心还是顶部/右侧。当您使用堆积条形图时，这尤其有用。</p><p id="db6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说得够多了，让我们利用这个类，用不同的配置来注释我们的四个条形图</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="abf4" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu"># BLOCK 5</strong><br/>AnnotateBars().vertical(axes[0][0])<br/>AnnotateBars(color="blue").vertical(axes[1][0], True)<br/>AnnotateBars().horizontal(axes[0][1])<br/>AnnotateBars(font_size=8, n_dec=1).horizontal(axes[1][1], True)</span></pre><p id="e047" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是结果输出图表</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/c0dcd55b74e4418d22eb1ad1fb95c1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nBxjYybM3PTKGxYbarAEQ.png"/></div></div></figure><p id="daf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们更聪明了，不仅知道关系，还知道绝对值。厉害！</p><p id="5b76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便提一下，当我们在堆积条形图中有非常小的条形时，叠加值就成了一个问题。你可以从堆叠的 Setosa 图表中看到这一点。在这种情况下，你必须选择是接受还是要求不同的东西。</p><h2 id="917a" class="mi lf it bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">保存绘图</h2><p id="c9dc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最后，当你创作出令人自豪的精彩情节时，你可能想与你的同事分享。为此，您必须以 PNG 这样的格式存储您的绘图，以便于分发。尽管将数字转储到图像的语法相当简单，但我很容易忘记它。这就是我使用这个助手函数的原因</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="ef6c" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu"># BLOCK 6<br/>def</strong> save_figure(fig : <em class="mh">matplotlib.figure.Figure</em>, path : <em class="mh">str</em>):<br/>    folder = os.path.dirname(path)<br/>    <strong class="mz iu">if</strong> folder:<br/>        os.makedirs(folder, exist_ok=True)<br/>    fig.savefig(path, bbox_inches="tight")</span></pre><p id="366e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你只需要把它的一个<strong class="ki iu"> <em class="mh">图对象</em> </strong>和<strong class="ki iu"> <em class="mh">路径</em> </strong>传递到输出的图像文件中。如果您想要存储图像的文件夹不存在，该功能会自动为您创建一个。对我来说，这是非常方便的。让我们添加这最后一块代码，我们就完成了</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0f41" class="mi lf it mz b gy nd ne l nf ng"><strong class="mz iu"># BLOCK 7</strong><br/>save_figure(fig, "./plots/medium/bar-charts.png")</span></pre><p id="7562" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我如何创造了你们之前看到的所有情节。我肯定是自己吃狗粮的:)！</p><h1 id="2a50" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包裹</h1><p id="fa92" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在本文中，我向您展示了几个 Matplotlib 函数来增强您的绘图。最重要的是，我向您展示了一种注释各种条形图的好方法。</p><p id="b376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您关注这篇文章。一如既往，如有任何问题、意见或建议，请随时联系我。密谋愉快！</p></div></div>    
</body>
</html>