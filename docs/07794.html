<html>
<head>
<title>An Intuitive Explanation of NeoDTI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NeoDTI 的直观解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-intuitive-explanation-of-neodti-e1859d178031?source=collection_archive---------25-----------------------#2019-10-28">https://towardsdatascience.com/an-intuitive-explanation-of-neodti-e1859d178031?source=collection_archive---------25-----------------------#2019-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NeoDTI 是一种用于异构网络上链路预测的特定任务节点嵌入学习算法。</h2></div><h1 id="638b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="bb8a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本系列之前的故事中，我们已经讨论了 DeepWalk 和 GraphSAGE。他们两个都被提出来学习具有单个实体和单个链路类型的网络中的节点表示，即同质网络。如果你不知道这些方法，你可以查看以前的故事。</p><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/an-intuitive-explanation-of-graphsage-6df9437ee64f"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">GraphSAGE 的直观解释</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">归纳学习在动态数据集中很有用。这里我们讨论一个关于图的归纳学习算法。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn mo lz"/></div></div></a></div><p id="2422" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">在这个故事中，我们将解释 NeoDTI [1]，它有一个不同的视角。NeoDTI 在两个方面不同于 DeepWalk 和 GraphSAGE。首先，NeoDTI 能够在异构网络上操作，即具有多个链路和实体类型的网络。其次，与 DeepWalk 和 GraphSAGE 不同，NeoDTI 学习特定于任务的节点嵌入，而不是通用的节点嵌入。以这种方式，NeoDTI 嵌入专用于一项任务，即链路预测。</p><p id="7ee0" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">NeoDTI 被提议利用异构数据进行药物-靶标相互作用(DTI)预测任务。在 DTI 任务中，每种药物和靶标用一个节点表示，如果已知两个节点相互作用，则这两个节点是相邻的。因此，关联预测对应于预测药物和蛋白质是否相互作用。下面我们可以看到一个玩具异构网络，由三种药物和四个目标组成。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7dd2d0200b270e24f58f746bf867fea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*7MqueWD99mC5LcsGwiVBTw.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">A drug-target network with three drugs and four targets.</figcaption></figure><p id="b893" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">虽然 NeoDTI 是针对 DTI 提出的，但是异构网络上的链路预测是一个跨域问题。例如，考虑用户和故事被表示为节点的中型网络。在这个网络中，用户之间的边表示跟随者关系，而用户和故事之间的边表示鼓掌。在这种情况下，链接预测任务可以用于向用户推荐朋友或故事。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/7fb610f3d36978d33fdf4e2715b8cd19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymb7kqIUKu6kV2mhI4bqpA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Medium network with users and stories.</figcaption></figure><p id="f922" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">媒体网络的例子突出强调了 NeoDTI 的可推广性。然而，在故事的其余部分，我们将坚持 DTI 预测任务，以符合原始论文。我们将分三步描述 NeoDTI，即邻域整合、节点嵌入更新和边重构学习。</p><h1 id="ba5e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">邻里整合</h1><p id="8b9d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">NeoDTI 在一个有四个实体和十二个关系的网络上工作。实体是药物、目标、疾病和副作用，而关系包含这些实体的相互作用、关联和相似性。每个关系都用二元边来表示。邻域整合旨在整合节点邻域内的多方面信息，并将其反映在节点的嵌入中。</p><p id="7c4b" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">尽管这个想法与 DeepWalk 和 GraphSAGE 非常相似，但 NeoDTI 遵循了不同的策略。与以前的方法不同，NeoDTI 不通过图遍历来探索节点的邻域，而是将所有相邻节点视为邻域。对于邻域中的每个实体类型，NeoDTI 通过非线性神经网络层传递每个相邻节点，并对它们的和应用规格化器，以获得实体类型特定的邻域嵌入。为了组合来自不同实体类型的信息，NeoDTI 应用求和并获得结果邻域嵌入。下面我们可以看到节点<em class="nk">对</em>的邻域积分方程</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nl"><img src="../Images/78b7b62bca6a5bb90fe609c7e2a81b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7DI8XXdd9cN3IKCRuA1YQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Information aggregation from the neighborhood in NeoDTI [1].</figcaption></figure><p id="9b51" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">在这个等式中，<em class="nk"> u </em>是具有边类型<em class="nk"> r </em>的<em class="nk"> v </em>的相邻节点，并且<em class="nk"> f ⁰(u) </em>是检索<em class="nk"> u </em>的初始嵌入向量的函数。<em class="nk"> Wᵣ </em>和<em class="nk"> bᵣ </em>是边缘类型特定的神经网络权重，<em class="nk"> σ </em>是非线性激活函数。神经网络前的系数是基于节点度的归一化器。最后，<em class="nk"> aᵥ </em>是得到的邻域嵌入。</p><h1 id="71f7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">节点嵌入更新</h1><p id="daaf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">已经为节点<em class="nk"> v </em>构造了邻域嵌入，是时候将它与<em class="nk">v’</em>s<em class="nk"/>自身嵌入结合起来了。为此，NeoDTI 将<em class="nk"> v </em> ( <em class="nk"> f ⁰ (v) </em>)的初始嵌入与邻域嵌入(<em class="nk"> aᵥ </em>)连接起来。与上一步类似，连接的向量通过另一个非线性神经网络层，然后归一化为单位长度，以获得更新的节点嵌入(<em class="nk"> f (v) </em>)。在下面的等式中，<em class="nk"> W </em>和<em class="nk"> b </em>表示该步骤中神经网络的权重。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/b2f4beadc77e17c626996489a2fa9ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*1VF2-Y3A0J0qOZSD04hFyA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Node embedding update rule in NeoDTI [1].</figcaption></figure><p id="ae8c" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">理论上，更新步骤可以重复几次，以创建更多的嵌入。然而，在实践中，使用单个更新步骤就足以获得相当好的预测。</p><h1 id="309f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">边缘重构学习</h1><p id="45de" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在前面的步骤中，我们定义了使用异构邻域信息创建节点嵌入的必要过程。现在是时候定义一个损失函数来实现学习了。NeoDTI 使用损失函数来促进边缘重建。换句话说，NeoDTI 旨在从节点嵌入中重建初始网络的边。</p><p id="ef12" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">下面我们看到损失公式，其中<em class="nk"> Gᵣ </em>和<em class="nk"> Hᵣ </em>是边缘类型特定的投影矩阵和<em class="nk"> s(e) </em>在<em class="nk"> u </em>和<em class="nk"> v </em>之间的边缘的权重。为了创建负样本，NeoDTI 对不相邻的节点进行采样，并在训练期间将它们作为输入提供。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/193e140f2a95a61598a0ecd016d69484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AK9Te2eATOxVJ_C053HXuQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">The loss function used for edge reconstruction in NeoDTI [1].</figcaption></figure><p id="9fec" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">现在让我们解释损失函数。为了将损耗降至最低，求和中的项应尽可能接近 0。因此，<em class="nk"> s(e) </em>必定等于<em class="nk"> f (u)ᵀ Gᵣ Hᵣᵀ f (v) </em>。由于<em class="nk">f(u)ᵀgᵣhᵣᵀf(v)】</em>是基于节点嵌入和投影矩阵的重构项，因此嵌入被学习，使得边被重构。</p><blockquote class="no"><p id="90dd" class="np nq it bd nr ns nt nu nv nw nx lv dk translated">与旨在最大化相似节点之间的嵌入相似性的 DeepWalk 和 GraphSAGE 相反，NeoDTI 嵌入被学习用于边缘重建。这就是它们具有特定任务的原因。</p></blockquote><p id="5907" class="pw-post-body-paragraph la lb it lc b ld ny ju lf lg nz jx li lj oa ll lm ln ob lp lq lr oc lt lu lv im bi translated">有了这个公式，重建项可以用来对 NeoDTI 的预测进行采样。为了预测药物<em class="nk"> u </em>和目标<em class="nk"> v </em>是否相互作用，我们使用学习的药物和目标投影矩阵<em class="nk">f(u)</em>和<em class="nk"> f (v)来计算重建项。</em>结果是对<em class="nk"> u </em>和<em class="nk"> v </em>之间的边权重的 NeoDTI 预测。</p><h1 id="2192" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">讨论</h1><p id="1f37" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">NeoDTI 是一种端到端的学习方法，用于学习特定于任务的节点嵌入。嵌入创建和损失函数步骤都是完全可微的，并且所有权重和嵌入都可以通过梯度下降来学习。这个端到端过程的结果嵌入被优化用于边缘重建，即链路预测。因此，面对链路预测精度的提高，学习嵌入的可推广性被牺牲了。下面我们可以在一张图中看到 NeoDTI 的工作流程。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi od"><img src="../Images/d0da97b3257dc7eefb24af8a8a1128df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrjFO4O9WYNQaqZAu61hyg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">The workflow of NeoDTI [1].</figcaption></figure><p id="8a8e" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">此外，尽管 NeoDTI 在二值边上运行，但它也适用于加权边。在这个问题中，<em class="nk"> s(e) </em>被当作一个二进制项，但可以用实值权重来代替。在这种情况下，权重应该表示节点之间的连接强度，并且训练目标将是恢复连接强度。</p><h1 id="cf09" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="c391" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">NeoDTI 是用于异构网络上的链路预测任务的有价值的方法。论文表明，集成异构信息提高了模型性能。因此，网络可以很容易地用新的实体和关系类型来扩展，以包含更多的信息。这就是使用异构网络的力量。</p><p id="cbb9" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">此外，与首先学习节点嵌入并将其用于链路预测的多步骤方法相比，使用端到端方法导致了准确性的提高。通过异构数据和端到端学习，NeoDTI 在 DTI 任务中产生了 SOTA 结果。然而，应该注意的是，NeoDTI 也可以应用于不同的领域。</p><h2 id="39b0" class="oe kj it bd kk of og dn ko oh oi dp ks lj oj ok ku ln ol om kw lr on oo ky op bi translated">参考</h2><p id="b380" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">[1] <a class="ae oq" href="https://www.biorxiv.org/content/10.1101/261396v1" rel="noopener ugc nofollow" target="_blank"> NeoDTI 论文</a></p><p id="8bce" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">[2] <a class="ae oq" href="https://github.com/FangpingWan/NeoDTI" rel="noopener ugc nofollow" target="_blank"> NeoDTI Github </a></p></div></div>    
</body>
</html>