<html>
<head>
<title>Exploring SG’s Rentals with an Interactive Webapp built using Dash, Flask and Heroku — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Dash、Flask 和 Heroku 构建的交互式 Webapp 探索 SG 的租赁——第 2 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-sgs-rentals-with-an-interactive-webapp-built-using-dash-flask-and-heroku-part-2-24656906ccbb?source=collection_archive---------18-----------------------#2019-03-19">https://towardsdatascience.com/exploring-sgs-rentals-with-an-interactive-webapp-built-using-dash-flask-and-heroku-part-2-24656906ccbb?source=collection_archive---------18-----------------------#2019-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4855" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过构建 DS/ML Webapp 并将其部署到世界各地来升级</h2></div><p id="e0c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">** <em class="le">这是 2 篇系列文章的第 2 部分。查看</em> <a class="ae lf" href="https://medium.com/p/cccd9e8dd1b8/edit" rel="noopener"> <em class="le">第一部</em> </a> <em class="le">这里！</em></p><p id="975d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一篇文章中，我们讨论了如何构建不同的组件来形成 Flaskapp。现在是时候将它们集成在一起了</p><h2 id="8e52" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">4.把所有东西放在主程序中</h2><p id="a343" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">这是万物融为一体的地方。主程序配置后端 Flaskapp，并定义它如何响应来自前端的请求。所有子模块都在这里调用</p><p id="3679" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> *** </em> </strong> <em class="le">主程序的</em> <strong class="kk iu"> <em class="le">骨架</em> </strong> <em class="le">如下图</em></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6638" class="lg lh it mj b gy mn mo l mp mq">***import ___                       //whatever packages you need<br/>***import ___                       //whatever helper funcs needed<br/>from flask import Flask, request, render_template<br/>from dash import Dash<br/>from dash_core_components import ____<br/>from dash_html_components import ____<br/>from wtforms import Form<br/>from wtforms.fields import _____    //choose necessary fields</span><span id="1729" class="lg lh it mj b gy mr mo l mp mq"><strong class="mj iu">app</strong> = Flask(__name__)<br/><strong class="mj iu">app_dash</strong> = Dash(__name__, server=app, url_base_pathname = '/dash/')<br/>app_dash.layout = ____              //set up your dash layout</span><span id="c1ea" class="lg lh it mj b gy mr mo l mp mq">form1 = Form(request.form)<br/>form2 = Form(request.form)<br/>//Form can be customized using extented class and wtforms.fields</span><span id="f5a5" class="lg lh it mj b gy mr mo l mp mq"><strong class="mj iu">@app.route</strong>('/', methods=___)        //main view, choose methods<br/>def some_function():<br/>    if request.form = form1<br/>        //Do something<br/>        <strong class="mj iu">return</strong> ___ <br/>    elif request.form = form2<br/>        //Do something<br/>        <strong class="mj iu">return</strong> ___<br/>//something to the server OR render_template('somepage.html')</span><span id="28a8" class="lg lh it mj b gy mr mo l mp mq"><strong class="mj iu">@app.route</strong>('/route1', methods=___)  //new view, choose methods  <br/>def some_function():<br/>    //Do something<br/>    <strong class="mj iu">return</strong> ___ <br/>//something to the server OR render_template('somepage.html')</span><span id="7821" class="lg lh it mj b gy mr mo l mp mq"><strong class="mj iu">@app.route</strong>('/route2', methods=___)  //new view, choose methods   <br/>def some_function():<br/>    global app_dash<br/>    //Do something<br/>    app_dash.layout = ___           //change your dash layout<em class="le"> </em>  <br/>    <strong class="mj iu">return</strong> flask.redicrect('/dash/')<br/>//direct the flask app to display the Dash dashboard</span><span id="80d9" class="lg lh it mj b gy mr mo l mp mq">if __name__ == '__main__':<br/> <strong class="mj iu">app</strong>.run(port=8000, debug=True)</span></pre><p id="ff1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主程序由<strong class="kk iu">一个或多个视图</strong>组成。每个路线/视图都有一个代码部分。每个路线/视图<strong class="kk iu">最终都必须返回</strong>一些东西</p><p id="a075" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你理解了上面的框架，你就可以开始阅读我的复杂得多的主程序，而不会被它包含的代码行数所淹没。此程序的更多解释如下</p><p id="44c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">* * *我的主程序的一些说明</em></p><ul class=""><li id="c348" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">应用</strong> = Flask app 的名称。每个<strong class="kk iu"> @application.route() </strong>代码块定义一个路径/视图</li><li id="4f43" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">主程序有<strong class="kk iu"> 3 个视图</strong> : A)主视图'/'，B)第二视图'/哈哈哈'和 C)第三视图'/seaborn '</li><li id="b6e0" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">类<strong class="kk iu"> ReusableForm(Form) </strong>是一个将基本表单类扩展为具有可定制输入字段的新表单类的例子</li><li id="0036" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">如果没有来自前端网络浏览器的请求，<strong class="kk iu">主视图</strong>提供由<strong class="kk iu"> 5 个表格</strong>组成的<strong class="kk iu">index.html</strong>页面。<strong class="kk iu">第一节</strong></li><li id="b423" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">如果有来自<strong class="kk iu">表单 1 </strong>的<strong class="kk iu">发布</strong>请求，应用程序修改数据集，重新显示带有一些通知文本的<strong class="kk iu">index.html</strong>页面</li><li id="2f44" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">如果有一个来自<strong class="kk iu"> form2 </strong>的<strong class="kk iu"> POST </strong>请求，app 会创建并训练一个<strong class="kk iu"> ML 模型</strong>，然后用它来预测所提议房产的<strong class="kk iu">租金</strong>，并返回<strong class="kk iu"> prediction_result.html </strong>页面<strong class="kk iu"> </strong>显示预测<strong class="kk iu">。</strong></li><li id="8a48" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">如果有一个来自<strong class="kk iu"> form3、</strong>的<strong class="kk iu"> POST </strong>请求，应用程序会搜索一些<strong class="kk iu">的与提议的酒店相似的房源</strong>，并返回<strong class="kk iu"> filtering_result.html </strong>显示这些房源的详细信息</li><li id="0d22" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">如果有一个来自<strong class="kk iu"> form4 的<strong class="kk iu"> POST </strong>请求，</strong>应用程序触发第二个视图<strong class="kk iu">@ application . route('/哈哈哈')</strong>，这将改变<strong class="kk iu"> Dash 应用程序的布局</strong>，然后将用户重定向到其<strong class="kk iu">仪表板</strong></li><li id="e9ec" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">如果有一个来自<strong class="kk iu"> form5、</strong>的<strong class="kk iu"> POST </strong>请求，应用程序会触发第三个视图<strong class="kk iu">@ application . route('/seaborn ')</strong>，返回一个显示图表的页面</li><li id="ee31" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu">方法</strong>:指定路由/视图可以处理来自前端网页的哪种<strong class="kk iu"> HTTP 请求(' POST '或' GET') </strong></li><li id="120f" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu"> request.form </strong>用于定义一个表单。此外，它还用于接收<strong class="kk iu">后端程序所需的</strong> <strong class="kk iu">用户输入</strong>。</li><li id="56b5" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu"> request.method </strong>用于在每个视图中构造<strong class="kk iu"> if 子句</strong>，分别处理不同类型的 HTTP 请求。</li><li id="144c" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu"> render_template </strong>:该函数用于在触发路线/视图时返回一个 Html 页面。模板内部调用的表单和变量需要作为参数解析到 render_template()函数中</li><li id="be4d" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu">全局</strong>用于每个视图内的变量，因此每个视图内的动作导致变量的永久变化，这些变化可以在整个程序中共享</li><li id="bc1f" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu"> port=8080 </strong>将允许您通过浏览器中的 localhost:8080 在本地部署应用程序</li></ul><p id="da19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><h2 id="5450" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">5.在 HEROKU 上部署完成的应用程序</h2><p id="8329" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">在你完成主程序并确保程序中不再有 bug 之后(重要！—在本地运行，直到你对此非常有信心)，然后你就可以把它部署到 Heroku 上，这是一个面向业余开发者的流行的免费应用托管网站</p><figure class="me mf mg mh gt nh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9d43fe2630395dcdc41e868c6171f9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*TV_J9qE_cu_ZW_TrRVSryQ.png"/></div></figure><h2 id="3283" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">创建帐户</h2><p id="6196" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">但是，在您做任何事情之前，您需要首先通过访问该网站创建一个帐户，除非您已经有了一个帐户。</p><p id="766d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建您的帐户并登录后，您将看到一个可以管理您的应用程序的仪表板。您可以选择从那里配置您的应用程序，或者下载适用于您的操作系统的<a class="ae lf" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> Heroku Cli </a>并使用客户端配置您的应用程序。我将在这里展示第二种方法</p><p id="2363" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装 CLI 客户端后，在您的终端中运行以下命令，登录到您的 Heroku 帐户</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d58e" class="lg lh it mj b gy mn mo l mp mq">$ heroku login</span></pre><p id="ed08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出现提示时，输入您的凭据(电子邮件和密码)。</p><h2 id="9360" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">创建 Heroku 应用程序</h2><p id="f264" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">部署过程的下一步是您需要创建一个 Heroku 应用程序。为此，请在您的终端中运行以下命令；</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4e67" class="lg lh it mj b gy mn mo l mp mq">$ <!-- -->heroku apps:create<!-- --> unique-name-of-your-app</span></pre><p id="8c47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此操作将在 Heroku 上创建一个应用程序，并为您上传文件创建一个存储库</p><h2 id="b114" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">准备 Git 存储库</h2><p id="2132" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">在这个阶段，我假设您应该已经建立了一个本地 git 存储库。您需要通过运行命令向现有的本地目录添加一个新的远程上游</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8891" class="lg lh it mj b gy mn mo l mp mq">$ git remote add <!-- -->heroku YOUR_HEROKU_REPO_ADDRESS</span></pre><p id="8460" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果您还没有设置存储库，请将创建的 Heroku 存储库克隆到您的本地目录中，并将您的工作文件复制到该文件夹中。</p><h2 id="c8b3" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">选择合适的 web 服务器</h2><p id="e1a6" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">Flask 对于开发阶段来说是一个很好的 web 服务器，但对于生产环境来说不是最佳选择。建议使用更好的 web 服务器。最受欢迎的两个是 Gunicorn 和 waste。你可以在这里查看这些服务器的列表<a class="ae lf" href="https://quintagroup.com/cms/python/web-server" rel="noopener ugc nofollow" target="_blank"/>。我在我的应用程序中使用 waste，因为我发现它有助于应用程序更好地运行，因为它能够缓冲请求和响应。另一方面，Gunicorn 导致我的应用程序给出不一致的响应，可能是因为它没有缓冲能力，无法处理我的应用程序的缓慢进程。此外，这里的一篇文章<a class="ae lf" href="https://blog.etianen.com/blog/2014/01/19/gunicorn-heroku-django/" rel="noopener ugc nofollow" target="_blank">解释了 Gunicorn 不是 Heroku 应用程序最佳选择的一些原因</a></p><p id="2900" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以用这个命令下载这两个文件</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9257" class="lg lh it mj b gy mn mo l mp mq">$ pip install waitress<br/>OR<br/>$ pip install gunicorn</span></pre><h2 id="e949" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">创建 Procfile</h2><p id="402c" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">procfile 告诉 Heroku 如何运行你的应用程序。该文件没有文件类型扩展名。用简单的命令在存储库中创建一个</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="abd3" class="lg lh it mj b gy mn mo l mp mq">$ touch Procfile</span></pre><p id="cd4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将下面一行添加到配置文件中。我为 Guniconr 和 waste 都举了例子。此外，“文件名”是您的主程序文件的名称，而“应用程序名”是您的程序中配置的 Flask 应用程序的名称。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d1b2" class="lg lh it mj b gy mn mo l mp mq">$ web:gunicorn -w:? file_name:app_name<br/>OR<br/>$ web:waitres-serve --port=$PORT -w:? file_name:app_name<br/>\\? is the number of threads/workers to be started by the server.</span></pre><h2 id="f83c" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">准备 Requirements.txt 文件</h2><p id="a5e5" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">这个文件告诉 Heroku 哪些库/包要和你的应用一起安装来运行它。它包含包的名称和每个包的版本号。如果您不确定您当前使用的是什么版本，您可以使用“$ pip list”命令进行检查。记得把新下载的网络服务器放在其中</p><p id="e697" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我自己的 requirements.txt 文件的一个例子</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="80e2" class="lg lh it mj b gy mn mo l mp mq">gunicorn==19.9.0<br/>waitress==1.2.1<br/>numpy==1.16.2<br/>pandas==0.23.0<br/>matplotlib==2.2.2<br/>seaborn==0.9.0<br/>pyspark==2.3.0<br/>scikit-learn==0.20.3<br/>plotly==3.3.0<br/>flask==1.0.2<br/>flask_sqlalchemy==2.3.2<br/>wtforms==2.2.1<br/>psycopg2==2.7.7<br/>dash==0.38.0<br/>dash_core_components==0.43.1<br/>dash_html_components==0.13.5</span></pre><p id="4ddd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您一直在使用虚拟环境开发您的应用程序，那么您只需运行一个简单的命令，就可以帮助您在一瞬间创建这个文件</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6726" class="lg lh it mj b gy mn mo l mp mq">$ pip freeze &gt; requirements.txt</span></pre><h2 id="b58d" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">指定合适的构建包</h2><p id="39b8" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">在部署到 Heroku 之前，您需要指定您的应用程序将使用哪个(哪些)构建包。您可以通过运行以下程序来添加它们(根据您的应用程序的语言来更改构建包)</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="37b3" class="lg lh it mj b gy mn mo l mp mq">$ heroku <!-- -->buildpacks:set heroku/python</span></pre><h2 id="dc2a" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">* *添加数据库(可选)</h2><p id="bef3" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">如果您的应用程序需要数据库服务器，Heroku 提供免费或付费的 Postgresql。自由层版本最多只允许 10，000 行和 20 个并发连接。</p><p id="9761" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，为应用程序设置数据库并配置它与数据库进行交互需要几个步骤。</p><p id="1999" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">步骤 1 </strong>:要创建一个数据库，运行以下命令</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f87b" class="lg lh it mj b gy mn mo l mp mq">$ heroku addons: add heroku-postgresql:hobby-dev<br/>\\hobby-dev is the free tier mentioned</span></pre><p id="1819" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以从应用仪表板查看数据库的连接详细信息。只需转到新创建的数据库部分&gt;点击设置&gt;查看凭证。在这里你可以看到数据库的 URI 被配置为一个名为<code class="fe nk nl nm mj b">$DATABASE_URL </code>的环境变量。数据导入过程和程序设置都需要这个变量。</p><p id="0de7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">步骤 2 </strong>:通过添加下面的代码片段来修改您的 flask 应用程序，以便它可以连接到数据库。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3993" class="lg lh it mj b gy mn mo l mp mq">import os<br/>app.config['SQLALCHEMY_DATABASE_URI'] = os.environ['DATABASE_URL']<br/>\\app is your Flask app's name</span></pre><p id="f848" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第三步</strong>:将您的数据导入 Heroku</p><p id="91c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将假设您的数据以 CSV 文件的形式出现。如果您已经有了本地 PostgreSQL 数据库中的数据，或者 SQL 文件形式的数据，那么您实际上可以跳过下面的一些步骤</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="521d" class="lg lh it mj b gy mn mo l mp mq"><strong class="mj iu">STEP 0. </strong>Download and install PostgreSQL on your computer<strong class="mj iu"><br/>STEP 1</strong>. Create a local Postgres Database &amp; Table (with name=Tablename) with PGAdmin</span><span id="90c8" class="lg lh it mj b gy mr mo l mp mq"><strong class="mj iu">STEP 2</strong>. Run the following command<br/>$ psql -U user_name -d database_name -c "\copy Tablename FROM '\file directory\file.csv' WITH CSV;"<br/>\\ Transfer the csv file to local database</span><span id="e699" class="lg lh it mj b gy mr mo l mp mq">\\If you have many columns, table creation can be a headache. For such case, you can use a tool called pgfutter to automate table creation with some datatype identification. Check out this <a class="ae lf" href="https://stackoverflow.com/questions/21018256/can-i-automatically-create-a-table-in-postgresql-from-a-csv-file-with-headers" rel="noopener ugc nofollow" target="_blank">answer</a> on stackoverflow</span><span id="0252" class="lg lh it mj b gy mr mo l mp mq"><strong class="mj iu">STEP 3</strong>. Push from local database to remote Heroku database<br/>Method1:<br/>A. pg_dump -U user_name -d database_name --no-owner --no-acl -f backup.sql<br/>B. heroku pg:psql -app app_name &lt; backup.sql</span><span id="7685" class="lg lh it mj b gy mr mo l mp mq">Method2:<br/>A. heroku pg:reset //make sure remote database is empty<br/>B. heroku pg:push local_database_name --app app_name</span></pre><p id="7e5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">步骤 4 </strong>:创建 SQLAlchemy ORM 对象，以便从 Flask 应用程序内部与数据库进行通信。您首先需要安装软件包</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e74" class="lg lh it mj b gy mn mo l mp mq">$ pip install flask_sqlalchemy</span></pre><p id="27e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后你把这些代码添加到你的程序中</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8edd" class="lg lh it mj b gy mn mo l mp mq">from flask_sqlalchemy import SQLAlchemy<br/>db = SQLAlchemy(app)<br/>\\app is your Flask app's name</span></pre><p id="87c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是代码要点，展示了我如何使用我的 ORM 与数据库通信，查询它，用一些用户的输入条件过滤查询，并返回一个结果数据帧。我在这里使用反射从步骤 3 中上传的现有数据库中加载信息</p><p id="82f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，您可以通过用<strong class="kk iu"> db 声明 table 类来创建一个全新的表。在 Flask 应用程序中建模</strong>，并使用<strong class="kk iu"> db.session.add() </strong>和<strong class="kk iu"> db.session.commit() </strong>将数据添加到表中。当你的应用有一些允许用户操作/更新数据库的特性时，这是很有用的。你可以看看这篇文章了解更多关于如何做的细节</p><h2 id="c8d9" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">* *为 Heroku 定制</h2><p id="9261" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">在将应用程序部署到 Heroku 时，有两件事需要注意</p><ol class=""><li id="7ebe" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld nn my mz na bi translated">Heroku 自由层(和一些低级计划)只有<strong class="kk iu">低内存分配</strong> (512MB)。确保您的进程/应用程序在此限制内使用资源。如有必要，自定义您的应用程序</li><li id="3156" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nn my mz na bi translated">Heroku 有一个<strong class="kk iu"> 30 秒超时策略</strong>。这意味着对于 web 客户端请求，您的后端服务器有 30 秒的“期限”来返回响应。如果你的服务器需要更长的时间，应用程序将崩溃</li></ol><p id="81c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我用来绕过第二条规则的一个技巧(我的一些过程，比如模型训练或交互式情节准备需要超过 30 秒)是让应用程序<strong class="kk iu">以某种形式的状态</strong>返回给服务器，关于正在运行的过程，在<strong class="kk iu">指定的间隔</strong>小于 30 秒</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="70ed" class="lg lh it mj b gy mn mo l mp mq">&lt;h3 class=”heading-3-impt-red”&gt;Click &lt;button style=”font-size:20px” <strong class="mj iu">onclick=”myfunc()</strong>”&gt;Here&lt;/button&gt; to Start Preparing Interactive Scatter Plot<br/>&lt;/h3&gt;</span><span id="80f6" class="lg lh it mj b gy mr mo l mp mq">&lt;script src="<a class="ae lf" href="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" rel="noopener ugc nofollow" target="_blank"><strong class="mj iu">https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.j</strong>s</a>"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>  <br/>  <strong class="mj iu">function myfunc(){<br/>  </strong>alert("Preparing Plot Now...");<br/>  count = 0;<br/>  var interval = setInterval(function(){<strong class="mj iu">wowwah()</strong>; count++; if (count&gt;=4)clearInterval(interval);},8000); // call every 8 seconds<br/>  };<br/>  <br/>  <strong class="mj iu">function wowwah(){<br/>  </strong>$.ajax({<br/>  url:"/hehehe", //the page containing python script<br/>  method:"GET",<br/>  dataType:"json",<br/>  success:function(result){ alert(result); }<br/>  });}<br/>&lt;/script&gt;</span></pre><p id="f385" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在我的 HTML 模板中使用了这个脚本。每当调用 wowwah()函数时(每 8 秒一次)，视图“/hehehe”以 jsonify()对象的形式向浏览器返回一个状态文本。</p><h2 id="b023" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">部署到 Heroku</h2><p id="caab" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">最后，当所有工作完成后，你可以将应用程序部署到 Heroku，就像你将你的东西部署到 Github 一样。确保您准备好所有内容，并更新您的。git 如果需要，忽略文件</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5792" class="lg lh it mj b gy mn mo l mp mq">$ git add *<br/>$ git commit<br/>$ git push heroku master<br/>// change heroku to origin if you previously clone the heroku repo</span></pre><p id="672c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="kk iu"><em class="le">your _ app _ name . heroku . com</em></strong>访问您的应用程序，看看它是否有效。如果它不像预期的那样工作，您可以在控制台中键入“$ heroku logs-tails”来找出错误是什么。如果是的话，那么恭喜你成功了！您已经构建了您的第一个 DS webapp</p><h2 id="7e10" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">6.结论</h2><p id="2b17" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">通过 Flask 应用程序将您的 DS/ML 项目部署到 Heroku，使您能够将您的想法和发现转化为工作产品，并向全世界展示。对于那些新手来说，这应该让你体会到当公司聘请数据科学家/软件工程师团队来交付数据科学项目时，他们真正关心的是什么:一个成品生产级模型/软件，可以在需要时为他们提供可操作的见解，而不仅仅是一份报告或一个代码笔记本。</p><p id="b225" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我自己在这方面还是个新手，但我希望我的文章能够对您的学习之旅有所帮助，并成为数据科学艺术的更好实践者。如果是的话，我很乐意看到你的一两条评论来解释这是怎么回事。如果您能给我一些反馈，告诉我如何更好地改进我的帖子/文章，我将不胜感激</p><p id="1ce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢大家一直关注到这个阶段！不要忘记关注我的下一篇文章。</p><p id="fa5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Huy，</p></div></div>    
</body>
</html>