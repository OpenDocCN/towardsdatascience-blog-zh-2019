<html>
<head>
<title>Immutable vs Mutable Data Types in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的不可变数据类型与可变数据类型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/immutable-vs-mutable-data-types-in-python-e8a9a6fcfbdc?source=collection_archive---------0-----------------------#2019-10-17">https://towardsdatascience.com/immutable-vs-mutable-data-types-in-python-e8a9a6fcfbdc?source=collection_archive---------0-----------------------#2019-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/88e9408e35557eac7423b1a7e277f53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLNMeKAxC4dPjZwbbT303w.png"/></div></div></figure><div class=""/><div class=""><h2 id="d04b" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">了解可变数据类型和不可变数据类型之间的区别，以及如何找出哪个是哪个！</h2></div><p id="56dc" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到现在为止，你可能听说过“Python 中的一切都是对象”这句话。<strong class="kw jf">对象</strong>是数据的抽象，Python 有多种多样的数据结构，你可以用它们来表示数据，或者组合它们来创建你自己的定制数据。</p><p id="f4d8" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python 对数据的第一个基本区别是对象的值是否会改变。如果值可以改变，对象称为<strong class="kw jf">可变</strong>，如果值不能改变，对象称为<strong class="kw jf">不可变</strong>。</p><p id="58b6" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个速成课程中，我们将探索:</p><ul class=""><li id="2fe8" class="lq lr je kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">可变类型和不可变类型的区别</li><li id="4f2c" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">不同的数据类型以及如何确定它们是可变的还是不可变的</li></ul><p id="b290" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解可变和不可变之间的区别非常重要，因为它会影响您编写的代码。</p><p id="8c8a" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧！</p><blockquote class="me mf mg"><p id="9ab0" class="ku kv mh kw b kx ky kf kz la lb ki lc mi le lf lg mj li lj lk mk lm ln lo lp im bi translated">这个速成课程改编自 Next Tech 的<strong class="kw jf">学习 Python 编程</strong>课程，该课程使用理论和实践的混合来探索 Python 及其特性，并从 Python 初学者进步到熟练。它包括一个浏览器内沙盒环境，预装了所有必要的软件和库。这里可以免费上手<a class="ae ml" href="https://c.next.tech/2OYvckb" rel="noopener ugc nofollow" target="_blank">！</a></p></blockquote></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="35f1" class="mt mu je bd mv mw mx my mz na nb nc nd kk ne kl nf kn ng ko nh kq ni kr nj nk bi translated">可变与不可变</h1><p id="12cb" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">首先，理解 Python 中的每个对象都有一个 ID(或标识)、一个类型和值是很重要的，如下面的代码片段所示:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="0efa" class="nz mu je nv b gy oa ob l oc od">age = 42<br/>print(id(age))    # id<br/>print(type(age))  # type<br/>print(age)        # value<br/></span><span id="a227" class="nz mu je nv b gy oe ob l oc od">[Out:]<br/>10966208<br/>&lt;class ‘int’&gt;<br/>42</span></pre><p id="46a6" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦创建，对象的 ID 永远不会改变。这是它的唯一标识符，当我们想要使用它时，Python 在幕后使用它来检索对象。</p><p id="b819" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类型也永远不会改变。类型告诉对象支持哪些操作，以及可以分配给它的可能值。</p><p id="e5b2" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该值可以更改，也可以不更改。如果可以，则称该对象是可变的，如果不能，则称该对象是不可变的。</p><p id="0773" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个例子:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="9311" class="nz mu je nv b gy oa ob l oc od">age = 42<br/>print(id(age))<br/>print(type(age))<br/>print(age)</span><span id="50ef" class="nz mu je nv b gy oe ob l oc od">age = 43<br/>print(age)<br/>print(id(age))<br/></span><span id="b9e6" class="nz mu je nv b gy oe ob l oc od">[Out:]<br/>10966208<br/>&lt;class ‘int’&gt;<br/>42<br/>43<br/>10966240</span></pre><p id="2d28" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe of og oh nv b">age</code>的值变了吗？嗯，【T1 号】是一个整数，类型为<code class="fe of og oh nv b">int</code>，是不可变的。所以，实际上在第一行，<code class="fe of og oh nv b">age</code>是一个名字，它指向一个<code class="fe of og oh nv b">int</code>对象，它的值是<code class="fe of og oh nv b">42</code>。</p><p id="56cc" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们键入<code class="fe of og oh nv b">age = 43</code>时，所发生的是另一个对象被创建，类型为<code class="fe of og oh nv b">int</code>，值为<code class="fe of og oh nv b">43</code>(同样，<code class="fe of og oh nv b">id</code>也会不同)，名字<code class="fe of og oh nv b">age</code>被设置为指向它。所以，我们没有把那个<code class="fe of og oh nv b">42</code>改成<code class="fe of og oh nv b">43</code>。我们实际上只是将<code class="fe of og oh nv b">age</code>指向了一个不同的位置。</p><p id="2ec5" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从第二个名为<code class="fe of og oh nv b">age</code>的对象创建前后的打印<code class="fe of og oh nv b">id(age)</code>可以看出，它们是不同的。</p><p id="a3cb" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看使用可变对象的同一个例子。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="00c6" class="nz mu je nv b gy oa ob l oc od">x = [1, 2, 3]<br/>print(x)<br/>print(id(x))</span><span id="5e27" class="nz mu je nv b gy oe ob l oc od">x.pop()<br/>print(x)<br/>print(id(x))<br/></span><span id="a1c9" class="nz mu je nv b gy oe ob l oc od">[Out:]<br/>[1, 2, 3]<br/>139912816421064<br/>[1, 2]<br/>139912816421064</span></pre><p id="af0c" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个例子，我们创建了一个名为<code class="fe of og oh nv b">m</code>的列表，其中包含 3 个整数<code class="fe of og oh nv b">1</code>、<code class="fe of og oh nv b">2</code>和<code class="fe of og oh nv b">3</code>。在我们通过“弹出”最后一个值<code class="fe of og oh nv b">3</code>来改变<code class="fe of og oh nv b">m</code>之后，<code class="fe of og oh nv b">m</code>的 ID 保持不变！</p><p id="b1bd" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，<code class="fe of og oh nv b">int</code>类型的对象是不可变的，而<code class="fe of og oh nv b">list</code>类型的对象是可变的。现在让我们讨论其他不可变和可变的数据类型！</p><h1 id="a618" class="mt mu je bd mv mw oi my mz na oj nc nd kk ok kl nf kn ol ko nh kq om kr nj nk bi translated">可变数据类型</h1><p id="fe55" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">可变序列在创建后可以改变。Python 的一些可变数据类型有:<strong class="kw jf">列表</strong>、<strong class="kw jf">字节数组</strong>、<strong class="kw jf">集合</strong>和<strong class="kw jf">字典</strong>。</p><h2 id="fb4f" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">列表</h2><p id="291e" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">如前所述，列表是可变的。这里是另一个使用<code class="fe of og oh nv b">append()</code>方法的例子:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="2e28" class="nz mu je nv b gy oa ob l oc od">a = list(('apple', 'banana', 'clementine'))<br/>print(id(a))</span><span id="c297" class="nz mu je nv b gy oe ob l oc od">a.append('dates')<br/>print(id(a))</span><span id="ee2a" class="nz mu je nv b gy oe ob l oc od"><br/>[Out:]<br/>140372445629448<br/>140372445629448</span></pre><h2 id="576f" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">字节数组</h2><p id="ebed" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">字节数组代表了<code class="fe of og oh nv b">bytes</code>对象的可变版本。它们公开了大多数可变序列的常用方法以及大多数<code class="fe of og oh nv b">bytes</code>类型的方法。项目是范围[0，256]内的整数。</p><p id="031a" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个简单的例子，用<code class="fe of og oh nv b">bytearray</code>类型来说明它是可变的:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="bf08" class="nz mu je nv b gy oa ob l oc od">b = bytearray(b'python')<br/>print(id(b))</span><span id="8b2b" class="nz mu je nv b gy oe ob l oc od">b.replace(b'p', b'P')<br/>print(id(b))</span><span id="3588" class="nz mu je nv b gy oe ob l oc od"><br/>[Out:]<br/>139963525979808<br/>139963525979808</span></pre><h2 id="43ae" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">设置</h2><p id="47e7" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">Python 提供了两种集合类型，<code class="fe of og oh nv b">set</code>和<code class="fe of og oh nv b">frozenset</code>。它们是不可变对象的无序集合。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="6671" class="nz mu je nv b gy oa ob l oc od">c = set((‘San Francisco’, ‘Sydney’, ‘Sapporo’))<br/>print(id(c))<br/>c.pop()<br/>print(id(c))<br/></span><span id="5624" class="nz mu je nv b gy oe ob l oc od">[Out:]<br/>140494031990344<br/>140494031990344</span></pre><p id="980d" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，<code class="fe of og oh nv b">set</code> s 确实是可变的。稍后，在<strong class="kw jf">不可变数据类型</strong>部分，我们将看到<code class="fe of og oh nv b">frozenset</code>是不可变的。</p><h2 id="de69" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">字典</h2><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="1085" class="nz mu je nv b gy oa ob l oc od">d = {<br/>    'a': 'alpha',<br/>    'b': 'bravo',<br/>    'c': 'charlie',<br/>    'd': 'delta',<br/>    'e': 'echo'<br/>}<br/>print(id(d))</span><span id="dc39" class="nz mu je nv b gy oe ob l oc od">d.update({<br/>    'f': 'foxtrot'<br/>})<br/>print(id(d))</span><span id="3dfe" class="nz mu je nv b gy oe ob l oc od"><br/>[Out:]<br/>14007111431940<br/>14007111431940</span></pre><h1 id="4352" class="mt mu je bd mv mw oi my mz na oj nc nd kk ok kl nf kn ol ko nh kq om kr nj nk bi translated">不可变数据类型</h1><p id="b406" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">不可变数据类型与可变数据类型的不同之处在于，它们在创建后不能更改。一些不可变类型包括<strong class="kw jf">数字数据类型</strong>、<strong class="kw jf">字符串</strong>、<strong class="kw jf">字节</strong>、<strong class="kw jf">冻结集</strong>和<strong class="kw jf">元组</strong>。</p><h2 id="12d3" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">数字数据类型</h2><p id="57ca" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">你已经看到整数是不可变的；同样，Python 的其他内置数值数据类型如布尔、浮点、复数、分数和小数也是不可变的！</p><h2 id="8f41" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">字符串和字节</h2><p id="9fe4" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">Python 中的文本数据是用<code class="fe of og oh nv b">str</code>对象处理的，通常称为<strong class="kw jf">字符串</strong>。它们是不可变的<strong class="kw jf"> Unicode 码位序列</strong>。Unicode 码位可以表示一个字符。</p><p id="a9e9" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当涉及到存储文本数据或在网络上发送文本数据时，您可能希望对其进行编码，使用适合您所使用的介质的编码。编码的结果产生一个<code class="fe of og oh nv b">bytes</code>对象，其语法和行为类似于字符串。</p><p id="34bc" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符串和字节都是不可变的，如下面的代码片段所示:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="b6cc" class="nz mu je nv b gy oa ob l oc od"># string<br/>e = 'Hello, World!'<br/>print(id(e))</span><span id="1a6c" class="nz mu je nv b gy oe ob l oc od">e = 'Hello, Mars!'<br/>print(id(e))</span><span id="10ba" class="nz mu je nv b gy oe ob l oc od"><br/>[Out:]<br/>140595675113648<br/>140595675113776</span><span id="fd8b" class="nz mu je nv b gy oe ob l oc od"># bytes<br/>unicode = 'This is üŋíc0de'  # unicode string: code points<br/>print(type(unicode))<br/>f = unicode.encode('utf-8')  # utf-8 encoded version<br/>print(type(f))<br/>print(id(f))</span><span id="c30c" class="nz mu je nv b gy oe ob l oc od">f = b'A bytes object'        # a bytes object<br/>print(id(f))</span><span id="032a" class="nz mu je nv b gy oe ob l oc od"><br/>[Out:]<br/>&lt;class 'str'&gt;<br/>&lt;class 'bytes'&gt;<br/>140595675068152<br/>140595675461360</span></pre><p id="7e1e" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在字节部分，我们首先将<code class="fe of og oh nv b">f</code>定义为我们的<code class="fe of og oh nv b">unicode</code>字符串的编码版本。正如你从<code class="fe of og oh nv b">print(type(f))</code>中看到的，这是一款<code class="fe of og oh nv b">bytes</code>型。然后我们创建另一个名为<code class="fe of og oh nv b">f</code>的<code class="fe of og oh nv b">bytes</code>对象，其值为<code class="fe of og oh nv b">b'A bytes object'</code>。两个<code class="fe of og oh nv b">f</code>对象有不同的 id，这表明字节是不可变的。</p><h2 id="0d7e" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">冻结集</h2><p id="ac50" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">正如上一节所讨论的，<code class="fe of og oh nv b">frozenset</code>与<code class="fe of og oh nv b">set</code>相似。但是，<code class="fe of og oh nv b">frozenset</code>对象在可变对应物方面非常有限，因为它们不能被改变。尽管如此，对于成员测试、并集、交集和差运算以及性能原因，它们仍然被证明是非常有效的。</p><h2 id="61a7" class="nz mu je bd mv on oo dn mz op oq dp nd ld or os nf lh ot ou nh ll ov ow nj ox bi translated">元组</h2><p id="9d84" class="pw-post-body-paragraph ku kv je kw b kx nl kf kz la nm ki lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">我们将要看到的最后一个不可变序列类型是元组。元组是任意 Python 对象的序列。在元组中，项目由逗号分隔。这些也是不可变的，如下例所示:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="ad00" class="nz mu je nv b gy oa ob l oc od">g = (1, 3, 5)<br/>print(id(g))</span><span id="1763" class="nz mu je nv b gy oe ob l oc od">g = (42, )<br/>print(id(g))</span><span id="f7e0" class="nz mu je nv b gy oe ob l oc od"><br/>[Out:]<br/>139952252343784<br/>139952253457184</span></pre></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="730d" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢这个速成班，它讲述了不可变对象和可变对象之间的区别，以及如何找出哪一个是对象！既然您已经理解了 Python 编程的这个基本概念，那么现在您可以探索可以用于每种数据类型的方法。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="3818" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mh">如果你想学习这方面的知识并继续提高你的 Python 技能，Next Tech 有一个完整的</em> <strong class="kw jf"> <em class="mh">学习 Python 编程</em> </strong> <em class="mh">课程，该课程涵盖:</em></p><ul class=""><li id="adac" class="lq lr je kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><em class="mh">功能</em></li><li id="dc56" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">条件编程</em></li><li id="ffb5" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">理解和生成器</em></li><li id="9e50" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">装饰器、面向对象编程和迭代器</em></li><li id="bd86" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">文件数据持久化</em></li><li id="2159" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">测试，包括对测试驱动开发的简要介绍</em></li><li id="167b" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">异常处理</em></li><li id="fdcd" class="lq lr je kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="mh">剖析和性能</em></li></ul><p id="0924" class="pw-post-body-paragraph ku kv je kw b kx ky kf kz la lb ki lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mh">这里</em>  <em class="mh">可以免费上手</em> <a class="ae ml" href="https://c.next.tech/2OYvckb" rel="noopener ugc nofollow" target="_blank"> <em class="mh">！</em></a></p></div></div>    
</body>
</html>