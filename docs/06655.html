<html>
<head>
<title>Classifying Flowers With Transfer Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于迁移学习的花卉分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/classifying-flowers-with-transfer-learning-5e17925a1f59?source=collection_archive---------17-----------------------#2019-09-23">https://towardsdatascience.com/classifying-flowers-with-transfer-learning-5e17925a1f59?source=collection_archive---------17-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8b4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">人工智能在英国花卉分类中的应用</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7e4f5213c19a26219191a0ab50db99cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InZlavJysRZGEq3k-Dgbuw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://unsplash.com/@dlanor_s" rel="noopener ugc nofollow" target="_blank">Dlanor S</a> (<a class="ae le" href="https://unsplash.com/photos/vjDbHCjHlEY" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/vjDbHCjHlEY</a>)</figcaption></figure><p id="d609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://machinelearningmastery.com/transfer-learning-for-deep-learning/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">迁移学习</strong> </a>是一种机器学习技术，旨在使用来自先前训练的模型的知识来帮助改善目标值的预测。有趣的是，之前的分类器可能是用不同的集合训练的，最初是试图解决不同的任务。</p><p id="a4b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将探索一些关于<strong class="js iu">深度学习</strong>和<strong class="js iu">迁移学习</strong>的概念，以便预测英国的花卉种类。这篇文章是基于我为毕业于 Udacity 的数据科学家 Nanodegree 而开发的一个项目而创建的，可以通过我的<a class="ae le" href="https://github.com/GiulioCMSanto/classifying_flowers_with_transfer_learning" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">GitHub</strong></a><strong class="js iu"/>资源库访问该项目。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="2222" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">关于数据的一点点</h2><p id="6bc9" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">本项目中使用的数据是从牛津大学的视觉几何小组中提取的，可以在此处 访问<a class="ae le" href="http://www.robots.ox.ac.uk/~vgg/data/flowers/102/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">。</strong></a></p><p id="4b89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该数据包含一个关于英国常见花卉类别的<strong class="js iu"> 102 类别</strong>数据集。正如原始资料中所解释的，每一种花的种类由 40 到 258 张图片组成。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="f89a" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">深度学习框架</h2><p id="7161" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">深度学习被构建成所谓的神经网络。一个简单的网络基本上由经过加权并通过激活函数的输入组成。这个简单的模式通常被称为<strong class="js iu">单元</strong>，可以如下图所示显示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/1e02aaaa212d70bc4af43bd1426a32b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NE9DQpCoAG0jZjJAlocp4Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Neural Network Unit</figcaption></figure><p id="f88d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当单元被连接起来创建<strong class="js iu">层</strong>时，这个模式变得非常强大。</p><p id="f441" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">激活函数允许网络呈现非线性特性。一些最常见的激活功能是<strong class="js iu">s 形</strong>、<strong class="js iu">、</strong>、<strong class="js iu">整流器(ReLu) </strong>和<strong class="js iu">双曲正切。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ml"><img src="../Images/d351baef0d00871c8b5fedc7c1204727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACHo09NFhKvYCsOFHxWVbA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Activation Functions (<a class="ae le" rel="noopener" target="_blank" href="/complete-guide-of-activation-functions-34076e95d044">source</a>)</figcaption></figure><p id="ffa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单地说，像图中这样的<strong class="js iu">单元</strong>的输出可以计算为ŷ=σ( <strong class="js iu"> W </strong> ⋅ <strong class="js iu"> x </strong> +b)。这就是所谓的<strong class="js iu">前馈</strong>传递。该输出是一个预测，可以通过<strong class="js iu">误差(损失)函数</strong>与真实目标 y 进行比较。向后运行前馈操作<strong class="js iu">以将计算的误差传播到每个权重的过程被称为<strong class="js iu">反向传播</strong>。</strong></p><h2 id="5b30" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">迁移学习</h2><p id="b3f2" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">迁移学习是使用为特定任务开发的模型作为不同任务中模型的起点的能力。粗略地说，我们可以使用预训练神经网络的输出作为我们自己网络的特征，我们需要做的就是训练我们自己的层。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/02318b4eb97d6604c7d5fda70fddbe19.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*FD6e9gjWY5VPQhLhsKjtwQ.png"/></div></figure><p id="4a12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> PyTorch </strong>是基于 Torch 库的开源机器学习库，广泛用于计算机视觉和 NLP(自然语言处理)。</p><p id="db13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PyTorch 附带了<strong class="js iu"> torchvision </strong>包，其中包含流行的数据集、模型架构和计算机视觉的常见图像转换。此外，如<a class="ae le" href="https://pytorch.org/docs/stable/torchvision/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>中所解释的，<strong class="js iu">模型子包</strong>包含用于处理不同任务的模型定义，包括:图像分类、逐像素语义分割、对象检测、实例分割、人物关键点检测和视频分类。</p><p id="6477" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个项目中，我将使用<strong class="js iu"> vgg11、vgg13 </strong>和<strong class="js iu"> vgg16 </strong>网络，它们都由<a class="ae le" href="https://arxiv.org/abs/1409.1556" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">非常深的卷积网络组成，用于大规模图像识别。</strong>T29】</a></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="3ef1" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">该项目</h2><p id="1d88" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">该项目包括训练一个图像分类器来识别不同种类的花。此外，分类器将以应用方式进行转换，这意味着可以在终端中运行代码，用训练模型对给定图像进行预测。你可以关注我的<a class="ae le" href="https://github.com/GiulioCMSanto/classifying_flowers_with_transfer_learning" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> GitHub </strong> </a>资源库中的项目。</p><p id="e632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一些我们想要预测的花的例子:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mn"><img src="../Images/cb7eb5bd5096f793105d8c0544163853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6c7DLkKiWvolgzJdhigAw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Example of Flowers to be Predicted</figcaption></figure><p id="424a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据集分为三部分:<strong class="js iu">训练</strong>、<strong class="js iu">验证</strong>和<strong class="js iu">测试</strong>。在这些图像中应用了一些变换，例如<strong class="js iu">随机缩放</strong>、<strong class="js iu">裁剪</strong>和<strong class="js iu">翻转</strong>。这有助于网络泛化，从而提高性能。此外，根据预训练网络的要求，图像被调整为<strong class="js iu"> 224x224 </strong>像素<strong class="js iu">。你可以在下面看到一个转换的例子。</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2d74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们加载一个预先训练好的<a class="ae le" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank"> vgg16 </a>,我们会看到类似这样的内容:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/b3e587941bd6e9dc52244b0f81a768e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQd7zT3Yvla0fCsBsHLMLA.png"/></div></div></figure><p id="b014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，预训练网络被视为<strong class="js iu">功能</strong>。我们需要做的就是建立我们自己的神经网络，取代预训练模型的<em class="mr">(分类器)</em>部分。因此，利用我们自己的网络，利用<strong class="js iu"> vgg16 </strong>提供的<em class="mr">(特征)</em>部分，利用我们自己的花朵图像，我们可以训练网络的<em class="mr">(分类器)</em>部分来构建我们的模型。</p><h2 id="816b" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">构建网络</h2><p id="6b37" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">将取代预训练网络的<em class="mr">(分类器)</em>部分的神经网络可以通过一个简单的类轻松完成，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/a5118f1202a6f8111ee02d4e8e119e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MupBuDRDf38EH1RvETmzA.png"/></div></div></figure><p id="1704" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，在这个类中使用了所谓的<strong class="js iu">辍学</strong>。dropout 的概念非常简单:在神经网络的每次迭代中，我们将随机删除一定比例的节点，这对我们减少过度拟合有很大帮助！</p><h2 id="d5b8" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">训练网络</h2><p id="f76e" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">网络培训将包括以下步骤:</p><ul class=""><li id="7c51" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">在网络中执行<strong class="js iu">前馈通道</strong>并计算 y 的预测值</li><li id="96f4" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">预测和真实标签必须插入损失函数中(为此，我将使用 NLLLoss 负对数似然损失)。</li><li id="c1d2" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">基于损失函数，执行反向传播传递以将误差传播到其他节点。</li><li id="0497" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">通过优化器重新计算权重(为此我将使用 Adam 优化器)。</li><li id="011c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">计算交叉验证结果(损失和准确度)以监控结果。</li><li id="07e4" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">重复整个过程 N 个周期！</li></ul><p id="3e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面我展示了一个 4 代执行的例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nh"><img src="../Images/6bd75de4dff201d4781c80ddcbe0a75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Agml6qnzTOR_xmj3uqaE-Q.png"/></div></div></figure><p id="35f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，损失函数降低，而验证数据的准确性显著提高！</p><h2 id="980d" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">保存模型</h2><p id="45f5" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">一旦模型被训练，我们需要保存它来进行预测。在此步骤中，必须完成以下步骤:</p><ul class=""><li id="d039" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">保存类到索引的映射，以及类别名称，这样我们可以跟踪预测的花的名称；</li><li id="4fc1" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">使用关于模型的信息(如网络输入大小)创建模型检查点。网络输出大小(在这种情况下是 102，这是不同花的数量)；隐藏的层；辍学率等等。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/56df92722b170810c798625d23de0837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_uiQKpAcl4e_mxmm1tTig.png"/></div></div></figure><h2 id="c796" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">做预测</h2><p id="168f" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">做预测仍然需要一些编码！</p><p id="69cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先需要以与处理训练数据相同的方式转换每个输入图像，这可以通过特定于该任务的函数来完成:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/99cd63835da3fd642ed0ac3eef3bfba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mYU8gJqkAZeO5EzLBh9M0w.png"/></div></div></figure><p id="9322" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，这个过程非常简单:一旦我们处理了输入图像，我们就可以加载我们训练过的模型并进行一次<strong class="js iu">向前传递</strong>。然后，我们从 102 个类中选择最有可能的结果类，并将其索引映射到相应的花。就这些了！预测的示例显示在下面的 top 5 预测中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/98ef0cc1d05b623c1ae17b3fc11abf4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzFjqOXaYWESIw6XVT-pZg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Prediction Example</figcaption></figure><p id="60fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，最有可能的类是<strong class="js iu">无茎龙胆</strong>！</p><h2 id="401b" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">创建应用程序</h2><p id="3cc0" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">上述概念在类和函数中被模块化，允许人们通过终端调用模型进行预测。下面显示了如何使用该应用程序的一些示例。</p><p id="3cd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">训练模型:</strong></p><p id="f75d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了训练模型，应该给出图像的输入路径以及可选参数，例如要使用的预训练模型(vgg11、vgg13 或 vgg16)、是否使用 GPU、期望的学习速率以及隐藏层的大小。</p><ul class=""><li id="cc1c" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">python train.py '。/花</li><li id="5e4e" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python train.py '。/flowers' — save_dir '。/'</li><li id="5dd3" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python train.py '。/flowers—arch ' vgg 11 '</li><li id="5913" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python train.py '。/flowers' -l 0.005 -e 2 -a 'vgg13 '</li><li id="f8c1" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python train.py '。/flowers '-l 0.005-e 2-a ' vgg 16 '—GPU</li><li id="0ad1" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python train.py '。'/flowers '—learning _ rate 0.01—hidden _ units 2048 1024—epochs 20—GPU</li></ul><p id="220b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">预测花朵</strong></p><p id="ed85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了进行预测，应该给出要预测的图像的输入路径和训练模型的路径(检查点)。而且，一个<em class="mr">。json </em>文件与每个类(category)对应的花名可以作为参数传递。</p><ul class=""><li id="f521" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">python predict.py。/flowers/test/15/image _ 06351 . jpg ' ' check point . PTH '</li><li id="e5b4" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python predict.py。/flowers/test/15/image _ 06351 . jpg ' ' check point . PTH '—category _ names cat _ to _ name . JSON</li><li id="1fa6" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python predict.py。/flowers/test/15/image _ 06351 . jpg ' ' check point . PTH '—category _ names cat _ to _ name . JSON—top _ k 3</li><li id="957c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">python predict.py。/flowers/test/15/image _ 06351 . jpg ' ' check point . PTH '—category _ names cat _ to _ name . JSON—top _ k 5—GPU</li></ul><h2 id="9a9f" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">结论</h2><p id="31e4" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们首先描述了什么是迁移学习，以及它与深度学习的关系。然后我们明白，可以使用一个预先训练好的网络，它是为一个特定的目的而制作的，因为<strong class="js iu">的特点是</strong>用于训练一个不同的神经网络，具有不同的目的。</p><p id="d184" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些概念然后被用来预测在英国发现的不同种类的花。所获得的函数和类被模块化，以便创建能够训练神经网络并对给定输入图像进行预测的完整应用。</p></div></div>    
</body>
</html>