<html>
<head>
<title>New York Taxi data set analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纽约出租车数据集分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/new-york-taxi-data-set-analysis-7f3a9ad84850?source=collection_archive---------14-----------------------#2019-05-22">https://towardsdatascience.com/new-york-taxi-data-set-analysis-7f3a9ad84850?source=collection_archive---------14-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da23" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用回归模型预测出租车费用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/142f87ce0349db022af91ce34cdba645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2UAM77u9_dRS0P5V"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@andersjilden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anders Jildén</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近我有机会玩了一下谷歌云的大查询平台托管的纽约出租车公共数据集。我决定对数据集应用机器学习技术，尝试使用 Python 建立一些预测模型。在这篇文章中，我将尝试预测出租车费用。让我们直接开始吧！本文的所有代码都可以在 Github 的<a class="ae ky" href="https://gist.github.com/stephenleo/731550f10522835467b7079de3384932" rel="noopener ugc nofollow" target="_blank">链接</a>中找到</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/7a06d9e16f675044598bc29116001d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*MlqiBhgCWh5Rw8UEiLJO9g.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Google Big Query Tables</figcaption></figure><p id="7094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，在检查 Google 大查询表时，我们注意到每年有一个表。这给了我一个想法。我可以使用 2015 年的数据来训练我的机器学习模型，然后使用 2016 年的数据来测试模型的预测能力。</p><p id="7a2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用 Google 的 data lab 平台查询 2015 年的随机 100K 行和 2016 年的随机 100K 行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们开始预测出租车费用的过程。首先，让我们导入必要的包并将数据加载到 pandas 数据框中。我使用%matplotlib 内联，因为我使用 jupyter 笔记本进行分析。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="be2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据框中，我们看到每一行都是一次旅行，而每一列都是与旅行相关的属性。</p><h1 id="c654" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">直觉:</h1><p id="dbd6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我喜欢首先纯粹凭直觉建立一个预测模型来开始我的项目。这个简单直观的模型将给出我们的基线精度，我们将尝试使用更先进的技术来打破这个基线精度。</p><p id="5873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何预测模型，我们需要考虑我们试图预测的响应变量是什么，以及可能对所述响应产生影响的特征变量是什么。在本练习中，我们想要预测的响应是<em class="mv"> fare_amount </em>。纯粹从直觉的角度来看，我们知道出租车一般按固定的初始费用+每公里 a(总距离)+每分钟 a(总时长)收费。回头看看我们的数据框列，我们已经有了一个<em class="mv"> trip_distance </em>列，但是我们缺少一个<em class="mv"> trip_duration </em>列。但是，我们提供了接送日期时间，因此我们可以使用下面的这些列轻松计算出<em class="mv"> trip_duration </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="307b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们为简单直观的模型(<em class="mv"> fare_amount </em>、<em class="mv"> trip_distance、</em>和<em class="mv"> trip_duration </em>)可视化感兴趣的列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ed2935554ed89e4dc08ef9e4d34496fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*lWJs2JtGe6KkvskV8AeTkQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Visualizing the columns of interest for simple intuitive model</figcaption></figure><p id="28b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图表中可以看出，所有三列都有显著的异常值。让我们执行一个离群点删除，并再次绘图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d07afc2fd693eb15f1e57079a40412f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*rbnzwQ6IjSyJblUVJlmwPw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Visualizing the columns of interest after outlier removal for simple intuitive model</figcaption></figure><p id="5e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了！此外，我们可以清楚地看到<em class="mv">票价 _ 金额</em>与<em class="mv">行程 _ 距离</em>和<em class="mv">行程 _ 持续时间</em>之间有很强的相关性，因此我们是在正确的轨道上。</p><p id="d294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们创建一些助手函数。第一个功能是拆分数据，以便训练数据集只包含 2015 年的数据，测试数据集只包含 2016 年的数据，如前所述。第二个功能是计算一些可用于评估模型预测能力的统计数据。在本练习中，我选择的统计数据是均方根误差(RMSE)，它给出了实际<em class="mv">费用 _ 金额</em>和预测<em class="mv">费用 _ 金额</em>之间的差异的标准偏差，单位为美元，可以计算为 sklearn 的<em class="mv">均方误差()</em>的平方根。R-square 给出了模型预测的实际<em class="mv"> fare_amount </em>的变化量的百分比，可以直接从 sklearn 的<em class="mv"> r2_score() </em>中获得。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="473e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在，我们已经准备好完全凭直觉构建我们的第一个模型。让我们首先将数据分为响应(y)和特征(X)，然后使用上述帮助函数创建训练集和测试集，然后在训练数据集上拟合简单的线性回归模型，最后使用上述帮助函数检查模型结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="48dd" class="nd lz it mz b gy ne nf l ng nh">----Training Data results (2015 data set)----<br/>RMSE: $5.6<br/>R2: 0.79<br/><br/>----Test Data results (2016 data set)----<br/>RMSE: $5.5<br/>R2: 0.81</span></pre><p id="06b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们的第一次尝试来说还不错！测试数据集的 RMSE 为 5.5 美元，我们将使用它作为基线得分。现在，让我们努力提高这个分数。</p><h1 id="ca5c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">特征工程:</h1><p id="603f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我在这里采用的方法是通过特征工程的过程给模型增加更多的特征。对问题进行更深入的思考。</p><ul class=""><li id="e5a1" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">一周中的取件日和一天中的时间可能在需求和交通状况中发挥重要作用，从而对票价产生影响</li><li id="fb5d" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">纬度差和经度差可以是增加行程距离对费用影响的附加数据</li><li id="d442" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">由于特定位置的额外费用，上下客社区可能会对票价产生影响？</li></ul><p id="0433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们添加一些额外的功能如下。Geohashing 是一种基于绝对纬度和经度创建离散地理位置的方法。您可以将它视为为属于同一邻域的位置创建一个通用名称。我使用 pygeohash python 包，可以使用<code class="fe nw nx ny mz b">pip install pygeohash</code>安装。由于纬度和经度列中有许多缺失的数据，让我们也删除它们。新增功能包括:</p><ol class=""><li id="8225" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nz no np nq bi translated">提货月份</li><li id="aef2" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">一周中的提货日</li><li id="e454" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">一天中的取件时间</li><li id="d9f3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">纬度差</li><li id="78ba" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">经度差</li><li id="be2e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">地理哈希拾取位置</li><li id="173e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">地理哈希删除位置</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d27774f7afb731b7fac6f806977a7668.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*Q8e5XQywIYkOK3Nw8rPJVA.png"/></div></figure><p id="e978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来在<em class="mv"> lat_dif </em>和<em class="mv"> lon_dif </em>中有一些异常值，我们把它们去掉吧。此外，由于像<em class="mv"> month、day_of_week、hour_of_day、pickup_geohash 和 dropoff_geohash </em>这样的列是分类的，所以让我们使用 pandas get_dummies 方法对它们进行编码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a037860bb2c80bf0705a377c4d809074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*qQyI8zGfsIPK9Irt3tKRJw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Visualizing the features</figcaption></figure><p id="9932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们拆分训练和测试数据集，并拟合一个简单的线性回归模型</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="6e0b" class="nd lz it mz b gy ne nf l ng nh">----Training Data results (2015 data set)----<br/>RMSE: $3.5<br/>R2: 0.92<br/><br/>----Test Data results (2016 data set)----<br/>RMSE: $7139352.0<br/>R2: -338832003532.88</span></pre><p id="cc4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呀！该模型在训练数据集上具有更好的 RMSE，但在测试数据集上具有更差的 RMSE，这表明该模型过度拟合。这就需要使用正则化技术。我们可以用 sklearn 的 Lasso 回归进行正则化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="a2f2" class="nd lz it mz b gy ne nf l ng nh">----Training Data results (2015 data set)----<br/>RMSE: $5.6<br/>R2: 0.79<br/><br/>----Test Data results (2016 data set)----<br/>RMSE: $5.3<br/>R2: 0.82</span></pre><p id="8f2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，从过度拟合的角度来看，这更好，但 RMSE 模型并没有改善太多。让我们现在尝试超参数调整，以改善模型 RMSE。我们可以为 Lasso 回归调整的参数称为 alpha，它是一个乘以 L1 罚项的常数。alpha 的默认值是 1。较小的 alpha 将通过减少惩罚项使 Lasso 回归类似于线性回归。</p><p id="70d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用套索回归，有两种方法来执行阿尔法超参数调整。第一种方法是使用 sklearn 的通用 GridSearchCV，它可以用于调整任何机器学习模型。第二种方法是使用 sklearn 自己的 LassoCV，它专门用于 Lasso 回归。让我们两个都试试，比较他们的运行时间，以及每个人能找到的最好的阿尔法。</p><p id="633a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们运行 GridSearchCV 方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c2ef" class="nd lz it mz b gy ne nf l ng nh">GridSearchCV execution time: 3124.58699989</span><span id="9774" class="nd lz it mz b gy oc nf l ng nh">Lasso best params: {'alpha': 0.0004012807031942776}<br/><br/>----Training Data results (2015 data set)----<br/>RMSE: $3.7<br/>R2: 0.91<br/><br/>----Test Data results (2016 data set)----<br/>RMSE: $3.8<br/>R2: 0.90</span></pre><p id="6f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇！当 alpha 值为 0.0004 时，我们能够获得仅 3.8 美元的测试 RMSE！然而，GridSearchCV 方法的运行时间长达 3124 秒。差不多一个小时了！让我们看看 LassoCV 是否能跑得更快，但为我们提供可比较的结果。请注意，我们将对 LassoCV 使用相同的 alpha 搜索空间，以实现真正的面对面比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="3e95" class="nd lz it mz b gy ne nf l ng nh">LassoCV execution time: 42.0979998112</span><span id="bf91" class="nd lz it mz b gy oc nf l ng nh">LassoCV best params: 0.000401280703194<br/><br/>----Training Data results (2015 data set)----<br/>RMSE: $3.7<br/>R2: 0.91<br/><br/>----Test Data results (2016 data set)----<br/>RMSE: $3.8<br/>R2: 0.90</span></pre><p id="6c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。LassoCV 不仅为我们提供了相同的最佳 alpha 值 0.0004，以获得仅 3.8 美元的测试 RMSE，而且它的运行速度更快，可以在 42 秒内完成！我必须承认，我自己也对结果感到惊讶，并且必须深入研究才能理解为什么 LassoCV 比 GridSearchCV 跑得快得多。目前，看起来我们使用线性模型可以达到的 RMSE 的最佳测试分数是 3.8 美元。这比我们简单直观模型的 RMSE 低 1.7 美元！最后，让我们绘制实际票价与 LassoCV 模型预测票价的对比图，以直观地检查相关性</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3cf9241c8e6133e061303d44f6f03934.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*Uw8UTJP_JZF9Mc3X5HF2IA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Actual vs Predicted Fare using LassoCV tuned model</figcaption></figure><p id="9125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！那表情很有希望。</p><p id="6e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过尝试更复杂的模型，如梯度增强，甚至是神经网络，来进一步改善模型的 RMSE。我们还可以通过查询 100 万行而不是 10 万行来将更多的数据添加到训练集中。你怎么想呢?请就我们如何进一步改进该模型发表评论。</p><p id="65f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！希望你觉得有趣。干杯！</p></div></div>    
</body>
</html>