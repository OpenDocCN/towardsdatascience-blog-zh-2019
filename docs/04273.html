<html>
<head>
<title>Serving Prophet Model with Flask — Predicting Future</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用烧瓶服务先知模型——预测未来</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serving-prophet-model-with-flask-predicting-future-1896986da05f?source=collection_archive---------12-----------------------#2019-07-03">https://towardsdatascience.com/serving-prophet-model-with-flask-predicting-future-1896986da05f?source=collection_archive---------12-----------------------#2019-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc52" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">演示如何使用 Flask 在 Web 上提供 Prophet 模型 API 的解决方案。prophet——由脸书开发的用于预测时间序列数据的开源 Python 库。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d554b9191741b207bd22f0c3cea92367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHDqCfhyZdlo4rnQqKKtDA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Source: Pixabay</figcaption></figure><p id="b403" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几乎对任何企业来说，准确的预测和未来的预测都是至关重要的。这是显而易见的事情，不需要解释。有一个时间序列数据的概念，这个数据是按日期排序的，通常每个日期都被赋予一个或多个特定于该日期的值。机器学习驱动的模型可以基于时间序列数据生成预测。这种预测可能是商业决策的重要信息来源。</p><p id="ae86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在研究时间序列<a class="ae lu" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">预测</a>的 LSTM 模型。LSTM 神经网络擅长预测序列数据，时间序列也是序列数据，这就是为什么 LSTM 网络被用来预测时间序列的原因。LSTM 的实施很复杂，很难为 LSTM 的培训准备输入数据。可能所有 LSTM 的例子都是基于当前数据集的数据进行预测，而不是真实的未来数据-这使得在实践中很难应用 LSTM。</p><p id="a8f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我在 GitHub 上找到并评估了<a class="ae lu" href="https://github.com/facebook/prophet" rel="noopener ugc nofollow" target="_blank"> Prophet </a> Python 库用于未来预测时，我对它的简单性和实用性印象深刻。prophet——由脸书开发的开源预测库。</p><p id="3b44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将与 Prophet forecast 实现共享一个示例 Python 笔记本，并展示如何通过 Flask API 保存/加载 Prophet 模型并提供服务。</p><p id="880a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">源代码和数据可在我的 GitHub <a class="ae lu" href="https://github.com/abaranovskis-redsamurai/automation-repo/tree/master/forecast" rel="noopener ugc nofollow" target="_blank"> repo </a>中获得。</p><p id="a90d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您需要导入 Prophet 库:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b43e" class="ma mb it lw b gy mc md l me mf">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from fbprophet import Prophet<br/>%matplotlib inline</span></pre><p id="7227" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的环境中没有安装 Prophet，您需要安装它。我把它安装在 Docker 容器中运行的 Ubuntu 中。用<em class="mg"> pip </em>安装没有效果。但是我可以用康达安装:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0b16" class="ma mb it lw b gy mc md l me mf">conda install gcc<br/>conda install -c conda-forge fbprophet</span></pre><p id="7f15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常下一步是加载数据。对于这个例子，我使用铁/钢价格数据集(从<a class="ae lu" href="https://www.investing.com/indices/dj-iron---steel-historical-data" rel="noopener ugc nofollow" target="_blank">这里</a>下载)。数据被加载到带有熊猫库的框架中。熊猫数据框架允许操纵和争论数据。我们正在删除未使用的列，设置索引并重新排序时间序列数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="204a" class="ma mb it lw b gy mc md l me mf">df = pd.read_csv('Dow Jones Iron &amp; Steel Historical Data.csv')<br/>df = df[['Date', 'Price']].dropna()</span><span id="33d5" class="ma mb it lw b gy mh md l me mf">df['Date'] = pd.to_datetime(df['Date'])<br/>df = df.set_index('Date')</span><span id="a41b" class="ma mb it lw b gy mh md l me mf">daily_df = df.resample('D').mean()<br/>d_df = daily_df.reset_index().dropna()</span></pre><p id="e050" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Prophet 操作 ds/y 列，我们应该重命名数据框中的列:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d441" class="ma mb it lw b gy mc md l me mf">d_df.columns = ['ds', 'y']</span><span id="766a" class="ma mb it lw b gy mh md l me mf">fig = plt.figure(facecolor='w', figsize=(20, 6))<br/>plt.plot(d_df.ds, d_df.y)</span></pre><p id="c7a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将用于 Prophet 模型培训的钢铁价格数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/7ee5185886606a825896ba39595e1458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1etbjvgHSWpOWFZE1ZTpfA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Iron/steel price data</figcaption></figure><p id="84f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键部分来了——先知模型训练:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f2bc" class="ma mb it lw b gy mc md l me mf">m = Prophet()<br/>m.fit(d_df)</span><span id="59bb" class="ma mb it lw b gy mh md l me mf">future = m.make_future_dataframe(periods=90)<br/>forecast = m.predict(future)<br/>forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()</span></pre><p id="dfe4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过调用<em class="mg"> fit </em>函数并传递 Pandas 数据帧来执行模型训练。未来预测由<em class="mg"> predict </em>函数执行，并传递描述未来多少天要预测的参数(上例中为 90 天)。Prophet 返回一个包含各种参数的数据框来描述预测。其中最重要的是:</p><ol class=""><li id="1850" class="mj mk it la b lb lc le lf lh ml ll mm lp mn lt mo mp mq mr bi translated">ds —预测日期</li><li id="5795" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">yhat —给定日期的预测值</li><li id="8a33" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">yhat _ lower 给定日期的预测下限</li><li id="2670" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">yhat _ uppet 给定日期的预测上限</li></ol><p id="e044" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用 Prophet 模型的<em class="mg"> plot </em>函数，显示模型是如何根据训练数据(黑点—训练数据，蓝线—预测值，浅蓝色区域—预测边界)进行训练的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/7564def0b16c0947e2cc8741d19e3fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgP27k239Gv8CVz66RY4Nw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Prophet model</figcaption></figure><p id="b5a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此图表显示未来 90 天的模型预测。但是很难看出来，图表显示了所有的数据。我们可以放大数据，并使用从训练数据中分离预测的垂直线来绘制图表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c14c" class="ma mb it lw b gy mc md l me mf">from datetime import datetime, timedelta</span><span id="6462" class="ma mb it lw b gy mh md l me mf">fig1 = m.plot(forecast)</span><span id="f404" class="ma mb it lw b gy mh md l me mf">#datenow = datetime.now()<br/>datenow = datetime(2019, 7, 2)<br/>dateend = datenow + timedelta(days=90)<br/>datestart = dateend - timedelta(days=450)</span><span id="ac1f" class="ma mb it lw b gy mh md l me mf">plt.xlim([datestart, dateend])<br/>plt.title("Iron/steel forecast", fontsize=20)<br/>plt.xlabel("Day", fontsize=20)<br/>plt.ylabel("Iron/steel price", fontsize=20)<br/>plt.axvline(datenow, color="k", linestyle=":")<br/>plt.show()</span></pre><p id="860a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这有助于更清楚地看到 90 天的预测。我们可以看到价格预测的下降趋势:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/d2cb019eb18a7d6f2f8031778d7ba795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voKXLrLfY_nyD84QCx_2Iw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Forecast trend</figcaption></figure><p id="8446" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打印预测值有一种简单的方法，即从预测数据框中访问最近 90 天的预测值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ab2f" class="ma mb it lw b gy mc md l me mf">forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']][-90:]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/2dabd865289ada63febcdc12636aaf5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoPOOx8gUTxIyE-Pw2pujQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">First 6 entries from 90 days forecast</figcaption></figure><p id="6f37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了评估模型，显示学习到的趋势是有用的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a8ab" class="ma mb it lw b gy mc md l me mf">fig2 = m.plot_components(forecast)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/181821a4f5ed1e41dd9910ada5d21f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYzzMftq8FLalJG42lkuuA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Trends</figcaption></figure><p id="49b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Prophet 了解到从三月到十月价格通常会下降。</p><p id="1fc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当预测一定天数时，您应该检查预期误差是多少。这被称为模型交叉验证:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7cb5" class="ma mb it lw b gy mc md l me mf">from fbprophet.diagnostics import cross_validation, performance_metrics<br/>df_cv = cross_validation(m, horizon='90 days')<br/>df_p = performance_metrics(df_cv)<br/>df_p.head(5)</span></pre><p id="3127" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/e263bf572dc6746fdbab9fb829c40ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEdGpSalPS-1ryzUwtLozA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Cross-validation results</figcaption></figure><p id="3a20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以绘制这些指标来直观地观察模型的表现。百分比误差(MAPE)更容易理解，我们可以这样绘制:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aef3" class="ma mb it lw b gy mc md l me mf">from fbprophet.plot import plot_cross_validation_metric<br/>fig3 = plot_cross_validation_metric(df_cv, metric='mape')</span></pre><p id="0d5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它表明 10 天的预测导致大约 10%的误差，然后误差增长到大约 18%:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/500d84024af1ec690fdf258f5286f6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OV0jx7XRaOgZerpM3qwkRg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Forecast percentage error</figcaption></figure><p id="58fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当新数据可用时，应该重新训练该模型。如果数据没有改变，就没有必要重新训练模型。当用户想要调用<em class="mg">预测</em>功能时，保存模型并再次使用。将 pickle 功能用于:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="db03" class="ma mb it lw b gy mc md l me mf">import pickle<br/>with open('forecast_model.pckl', 'wb') as fout:<br/>    pickle.dump(m, fout)</span><span id="fcfd" class="ma mb it lw b gy mh md l me mf">with open('forecast_model.pckl', 'rb') as fin:<br/>    m2 = pickle.load(fin)</span></pre><p id="3ed6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将把模型保存到磁盘上的一个物理文件中。在本例中，我展示了如何保存和加载模型，为您提供方便。在实际实施中，load 函数将在不同的位置调用(在负责处理用户预测请求的函数中)。</p><p id="3ee3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Flask 完美地通过 REST API 将 Prophet 模型暴露给外部世界。导入烧瓶库:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8452" class="ma mb it lw b gy mc md l me mf">from flask import Flask, jsonify, request<br/>from flask_cors import CORS, cross_origin</span></pre><p id="cf2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在带有 Flask 注释的函数内调用<em class="mg">预测</em>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bca0" class="ma mb it lw b gy mc md l me mf">app = Flask(__name__)<br/>CORS(app)</span><span id="2d3d" class="ma mb it lw b gy mh md l me mf"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/katana-ml/api/v1.0/forecast/ironsteel", methods=['POST'])<br/>def predict():<br/>    horizon = int(request.json['horizon'])<br/>    <br/>    future2 = m2.make_future_dataframe(periods=horizon)<br/>    forecast2 = m2.predict(future2)<br/>    <br/>    data = forecast2[['ds', 'yhat', 'yhat_lower', 'yhat_upper']][-horizon:]<br/>    <br/>    ret = data.to_json(orient='records', date_format='iso')<br/>    <br/>    return ret</span><span id="48a0" class="ma mb it lw b gy mh md l me mf"># running REST interface, port=3000 for direct test<br/>if __name__ == "__main__":<br/>    app.run(debug=False, host='0.0.0.0', port=3000)</span></pre><p id="5786" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过 Postman 调用 REST API 的例子。预测范围参数被传递给 API，我们得到带有预测数据的 JSON 响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ba50ece4ecc6710a84c029c2a9aab6e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGdkaIGQYf79mJ6cuYE-3Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Prophet forecast REST API response example</figcaption></figure><p id="f2fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">源代码和示例数据可以在我的<a class="ae lu" href="https://github.com/abaranovskis-redsamurai/automation-repo/tree/master/forecast" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo 中获得。</p></div></div>    
</body>
</html>