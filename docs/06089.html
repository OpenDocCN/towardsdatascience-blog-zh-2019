<html>
<head>
<title>Speeding up Matrix Multiplication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速矩阵乘法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matrix-multiplication-the-pytorch-way-c0ad724402ed?source=collection_archive---------12-----------------------#2019-09-04">https://towardsdatascience.com/matrix-multiplication-the-pytorch-way-c0ad724402ed?source=collection_archive---------12-----------------------#2019-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c8c832fe01f8f2a28d381639117d476a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOpFRrZrtnXWuyHSIZUTIw.jpeg"/></div></div></figure><p id="c116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用 Python 写一个矩阵乘法的函数。</p><p id="e147" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先找到两个矩阵的形状，并检查它们是否可以相乘。(matrix_1 的列数应该等于 matrix_2 的行数)。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/e1ff431316b2490345156829df7f3e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0-CZeEuvINKL-VJCo33Dg.png"/></div></div></figure><p id="3a01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们写 3 个循环来逐元素地乘矩阵。最终矩阵的形状将是(矩阵 _1 的行数)乘以(矩阵 _2 的列数)。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/c842ff62a5d5771f4005a4dd15b2be63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOkcVxleORtHF_f1nFkhQg.png"/></div></div></figure><p id="42e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个基本的神经网络，我们将使用这个函数。</p><p id="4742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将使用 MNIST 数据集进行演示。它包含 50，000 个手写数字样本。这些数字本来就是 28*28 的矩阵(或者拆包后一个线性向量中的 784 个值)。</p><p id="e368" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的神经网络将 784 个值作为输入，并将 10 个类作为输出。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/1d4a574c84ab4843b83d585da7cbc6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpmAjwZs1R2RY4TrNDnmEw.png"/></div></div></figure><p id="0d07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们从 MNIST 验证集中提取 5 个元素，并在这个模型中运行它们。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/bc8e9e9ae368db9171fc3328e1bdea71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCckvN47Uf8BK2xGWnIsTA.png"/></div></div></figure><p id="fcc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到，对于仅仅 5 个元素，我们花费了<code class="fe ld le lf lg b">650 milliseconds</code>来执行矩阵乘法。这个比较慢。让我们试着加快速度。</p><h2 id="7b7a" class="lh li iq bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">为什么速度很重要？</h2><p id="d0c9" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">矩阵乘法构成了神经网络的基础。训练神经网络时，大多数操作都需要某种形式的矩阵乘法。因此，做得好、做得快真的很重要。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/d2ee17df001ee4e0b988492d4ff19742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9In1Doyo_C2P5dsg0GFhrQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">source: fast.ai course: Deep learning from the foundations</figcaption></figure><p id="6aff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过消除循环并用 PyTorch 函数代替它们来加速矩阵乘法。这将给我们 C 速度(PyTorch 之下)而不是 Python 速度。让我们看看它是如何工作的。</p><h2 id="cdb0" class="lh li iq bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">消除最里面的循环</h2><p id="ddc6" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们从消除最里面的循环开始。消除这种循环背后的想法是，我们可以一次对一行(或一列)进行操作，而不是一次对一个元素进行操作。看看下面的图片。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/d8ab11df2559be2a3ad90eaae0ab839b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5fK5l0SthU8D3zb6H3GFA.png"/></div></div></figure><p id="1c7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个张量，我们想把它们的元素加在一起。我们可以写一个循环来实现，或者我们可以使用 PyTorch 的<strong class="ka ir"> <em class="ml"> elementwise 操作</em> </strong>(直接 a + b)来实现。</p><p id="e8ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用同样的想法，我们将消除最里面的循环</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/7c77d9597034b48a45874294f31e55c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*YFib3jf3Dzefr4GMvrqw0w.png"/></div></figure><p id="a673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们直接做</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/31e0e0dacc45a33aa96bbe4410d175b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*UOMGbSf4IE0juxqbhdtotg.png"/></div></figure><p id="b127" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的函数现在看起来如下:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/afa2f9cbcfd71d15d145fc85830bf6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LyYsQdlI6N7ikzE-nT5qw.png"/></div></div></figure><p id="3f92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行大约需要<code class="fe ld le lf lg b">1.55 milliseconds</code>，这是一个巨大的改进！</p><p id="452a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不熟悉索引语法，<code class="fe ld le lf lg b">a[i,:]</code>意味着选择<code class="fe ld le lf lg b">ith</code>行和所有列，而<code class="fe ld le lf lg b">b[:,j]</code>意味着选择所有行和<code class="fe ld le lf lg b">jth</code>列。</p><p id="f7a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以编写一个小测试来确认我们更新后的函数给出的输出与原始函数相同。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/eacc7c4a5b266d0f5488506614cd6f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYG1S9Y65J3cWu0vJuuJnA.png"/></div></div></figure><p id="7065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确实如此。</p><h2 id="4c2e" class="lh li iq bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">消除第二个循环</h2><p id="cf04" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们现在可以继续消除第二个循环。这是最激动人心的部分，因为这一次，我们将从这里开始</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/31e0e0dacc45a33aa96bbe4410d175b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*UOMGbSf4IE0juxqbhdtotg.png"/></div></figure><p id="c6d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去做</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a1b599c284bd689d0f37453adff5f50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*xQBtqL6IhuyXehRoE2q3rw.png"/></div></figure><p id="4207" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要了解一些被称为<strong class="ka ir"> <em class="ml">的广播</em> </strong>。</p><h2 id="3e73" class="lh li iq bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">广播</h2><p id="f630" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">假设您想要从数据集中的每个数据点减去平均值。同样，你可以写一个循环来这样做，或者你可以利用广播。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/c497db8be26be32b3df4abd8241d9228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCCjiUQxkMmnIo1GBirpGA.png"/></div></div></figure><p id="5b8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在广播中，我们取较小的张量，并通过较大的张量进行广播，使它们具有可比较的形状。一旦它们有了可比较的形状，我们就可以对它们执行<strong class="ka ir"> <em class="ml">元素运算</em> </strong>。让我们看另一个例子。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/5ced5904a47704ac3320cc40a123655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkvxnJK64dTHiUIK6Pw3Tw.png"/></div></div></figure><p id="f45f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看到那里发生了什么吗？张量<strong class="ka ir"> c </strong>被广播，因此它的行数与<strong class="ka ir"> m 的行数相同。</strong>我们可以通过<code class="fe ld le lf lg b">expand_as()</code>函数找到广播后张量的样子。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/b8216a20f742b3025f9b4bd122fb140a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p923aL59Ti6HtkH9HOlU0w.png"/></div></div></figure><p id="f2e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是最精彩的部分。PyTorch 实际上并不复制值。它只是假装这样做。我们来看看<code class="fe ld le lf lg b">t</code>的收纳和造型</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/b10de408c5594a37f5120adc48c865ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVoibeZA2r23pr0flGieMQ.png"/></div></div></figure><p id="9e6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">张量<strong class="ka ir"> t </strong>仍然只存储为[10，20，30],但是它知道它的形状应该是 3*3。这使得广播内存高效。</p><p id="33be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用广播，我们将广播 matrix_1 的第一行，并用 matrix_2 的整体进行操作。我们的函数现在看起来如下:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/560ac733aee10cab27edfb0b6fda192d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9rLr6Ks5CocaytjRpw6FA.png"/></div></div></figure><p id="d2dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且只需要<code class="fe ld le lf lg b">402 micro seconds</code>跑！</p><p id="94e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们能以灵活的方式做的最好的事情。如果你想做得更好，你可以用<strong class="ka ir"> <em class="ml">爱因斯坦求和</em> </strong>来做。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/599d8ede34aa0a4320f165cba8792fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coQ5IykeifO1lRTurzqRaQ.png"/></div></div></figure><p id="1d33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是最快的方法是使用 PyTorch 的<code class="fe ld le lf lg b">matmul</code>功能。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/29ac540d0f3cca993858c5d27540abbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpXDMBzTVq5ZRcURtWDEtg.png"/></div></div></figure><p id="4983" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它之所以这么快是因为它在底层也使用汇编语言代码。</p><p id="7f7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是本文的全部内容。</p><p id="e07f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于深度学习的知识，你可以看看我下面的深度学习系列。</p><div class="my mz gp gr na nb"><a href="https://medium.com/@dipam44/deep-learning-series-30ad108fbe2b" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">深度学习系列</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">我所有关于深度学习的文章的系统列表</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jw nb"/></div></div></a></div><h2 id="ae56" class="lh li iq bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated"><strong class="ak">参考</strong>:</h2><p id="97f5" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">从基础开始深度学习:fastai 。</p></div></div>    
</body>
</html>