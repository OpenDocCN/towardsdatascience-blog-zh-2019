<html>
<head>
<title>Image Data Analysis Using Python:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 进行影像数据分析:</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-data-analysis-using-python-edddfdf128f4?source=collection_archive---------1-----------------------#2019-12-08">https://towardsdatascience.com/image-data-analysis-using-python-edddfdf128f4?source=collection_archive---------1-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/2f1803d5e03a8f1f4d66a56c071bfd80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*OAC28Vt6J9AsF-EdGYokmA.png"/></div></figure><div class=""/><div class=""><h2 id="bda5" class="pw-subtitle-paragraph jx iz ja bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">本教程着眼于如何导入图像和观察它的属性，分裂层，还着眼于灰度。</h2></div><h1 id="aa16" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">内容:</h1><ul class=""><li id="c9b6" class="lh li ja lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简介:关于像素的一点点</li><li id="2242" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">观察图像的基本属性</li><li id="63da" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">灰度</li><li id="9a32" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">使用逻辑运算符处理像素值</li><li id="c81a" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">掩饰</li><li id="7f57" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">图像处理</li></ul><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi me"><img src="../Images/a4cbca7d897b7a588cdb57b308c2492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0eYKJMRKfX4VV0KHiyBOQ.jpeg"/></div></div></figure><h1 id="a263" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">简介:关于像素的一点点</h1><p id="589c" class="pw-post-body-paragraph mn mo ja lj b lk ll kb mp lm ln ke mq lo mr ms mt lq mu mv mw ls mx my mz lu im bi translated">计算机将图像存储为微小方块的马赛克。这就像古代艺术形式的瓷砖马赛克，或者今天孩子们玩的熔珠工具。现在，如果这些方形瓷砖太大，就很难做出光滑的边缘和曲线。我们使用越多越小的瓷砖，图像就越平滑，或者说像素化程度越低。这些有时被称为图像的分辨率。</p><p id="97b5" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">矢量图形是一种有点不同的存储图像的方法，旨在避免像素相关的问题。但即使是矢量图像，最终也显示为像素的马赛克。像素这个词的意思是一个图像元素。描述每个像素的简单方法是使用三种颜色的组合，即红、绿、蓝。这就是我们所说的 RGB 图像。</p><p id="d704" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">每张数码形式的照片都是由像素组成的。它们是组成图片的最小信息单位。通常为圆形或方形，它们通常排列成二维网格。</p><p id="e43b" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">现在，如果这三个值都是最大强度，那就意味着它们是 255。然后它显示为白色，如果三种颜色都被静音，或者值为 0，则颜色显示为黑色。这三者的结合将依次给我们一个特定的像素颜色的阴影。因为每个数字都是 8 位数字，所以值的范围是从 0 到 255。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7cd6066e00a807aa8a3fdb7c0e304db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*y0nV4cWk3KbzXSe9dIWL5g.jpeg"/></div></figure><p id="dc9c" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">这三种颜色的组合趋于其中的最高值。因为每个值可以有 256 个不同强度或亮度值，所以总共有 1680 万种色调。</p><p id="87ae" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">现在让我们加载一个图像，观察它的各种属性。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="ae2e" class="nl kq ja nh b gy nm nn l no np"><br/> import imageio<br/> import matplotlib.pyplot as plt<br/> %matplotlib inline<br/> pic = imageio.imread(‘images/me.jpg’)<br/> plt.figure(figsize = (5,5))<br/> plt.imshow(pic)</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f8e3e71daf0aaeb1b77b72683dac2320.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*EjrDCqtAZW8LXzHvVfwbxQ.png"/></div></figure><h1 id="c02a" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">观察图像的基本属性</h1><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="a536" class="nl kq ja nh b gy nm nn l no np"><br/>print('Type of the image : ' , type(pic)) <br/>print('Shape of the image : {}'.format(pic.shape)) <br/>print('Image Hight {}'.format(pic.shape[0])) <br/>print('Image Width {}'.format(pic.shape[1])) <br/>print('Dimension of Image {}'.format(pic.ndim))<br/></span></pre><p id="9ead" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">输出:</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="53bd" class="nl kq ja nh b gy nm nn l no np"><br/>Type of the image :  &lt;class 'imageio.core.util.Array'&gt; <br/>Shape of the image : (728, 720, 3) <br/>Image Hight 728 <br/>Image Width 720 <br/>Dimension of Image 3<br/></span></pre><p id="2bf5" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">阵列的形状表明它是一个三层矩阵。这里的前两个数字是长度和宽度，第三个数字(即 3)用于三层:红色、绿色、蓝色。因此，如果我们计算一个 RGB 图像的大小，总的大小将被计算为高 x 宽 x 3</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="1333" class="nl kq ja nh b gy nm nn l no np"><br/>print('Image size {}'.format(pic.size)) <br/>print('Maximum RGB value in this image {}'.format(pic.max())) print('Minimum RGB value in this image {}'.format(pic.min()))<br/></span></pre><p id="ac5d" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">输出:</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="ecb7" class="nl kq ja nh b gy nm nn l no np"><br/>Image size 1572480 <br/>Maximum RGB value in this image 255 <br/>Minimum RGB value in this image 0<br/></span><span id="3479" class="nl kq ja nh b gy nr nn l no np"># A specific pixel located at Row : 100 ; Column : 50  <br/># Each channel's value of it, gradually R , G , B  <br/>print('Value of only R channel {}'.format(pic[ 100, 50, 0])) print('Value of only G channel {}'.format(pic[ 100, 50, 1])) print('Value of only B channel {}'.format(pic[ 100, 50, 2]))<br/></span></pre><p id="69f0" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">输出:</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="b7b2" class="nl kq ja nh b gy nm nn l no np">Value of only R channel 168<br/>Value of only G channel 189<br/>Value of only B channel 182</span></pre><p id="458e" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">好了，现在让我们快速浏览一下整个图像中的每个通道。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="5ec6" class="nl kq ja nh b gy nm nn l no np">plt.title('R channel') <br/>plt.ylabel('Height {}'.format(pic.shape[0])) <br/>plt.xlabel('Width {}'.format(pic.shape[1])) <br/>plt.imshow(pic[ : , : , 0])<br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5a677c97abd3b1b32a93cce109d37acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*9D8sAvE-7bRjhbns3d8KNw.png"/></div></figure><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="6716" class="nl kq ja nh b gy nm nn l no np">plt.title('G channel')<br/>plt.ylabel('Height {}'.format(pic.shape[0])) <br/>plt.xlabel('Width {}'.format(pic.shape[1])) <br/>plt.imshow(pic[ : , : , 1]) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2b45a84165bfcf45efaf3563f8a6f96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*Q7KTKYGe3xQaLZ-66oEEfw.png"/></div></figure><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="4bf8" class="nl kq ja nh b gy nm nn l no np">plt.title('B channel') <br/>plt.ylabel('Height {}'.format(pic.shape[0])) <br/>plt.xlabel('Width {}'.format(pic.shape[1])) <br/>plt.imshow(pic[ : , : , 2]) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c7827389bbbe01814a5865c57b3cebad.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*7gsktlS2gihX_t3JR9e_Aw.png"/></div></figure><p id="744f" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">现在，我们还可以改变 RGB 值的数量。作为一个例子，让我们设置红色，绿色，蓝色层的后续行值为全强度。</p><ul class=""><li id="22da" class="lh li ja lj b lk na lm nb lo nt lq nu ls nv lu lv lw lx ly bi translated">r 通道:第 100 至 110 行</li><li id="d441" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">g 通道:第 200 至 210 行</li><li id="2ac8" class="lh li ja lj b lk lz lm ma lo mb lq mc ls md lu lv lw lx ly bi translated">b 通道:行— 300 至 310</li></ul><p id="7de7" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">我们将加载图像一次，这样我们可以同时看到每个变化。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="f068" class="nl kq ja nh b gy nm nn l no np">pic[50:150 , : , 0] = 255 # full intensity to those pixel's R channel <br/>plt.figure( figsize = (5,5)) <br/>plt.imshow(pic) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dd2c5ee6fe88fb4abe4141fedd08c721.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*qnLihR-TqzxdduJEDs6j6A.png"/></div></figure><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="810a" class="nl kq ja nh b gy nm nn l no np">pic[200:300 , : , 1] = 255 # full intensity to those pixel's G channel <br/>plt.figure( figsize = (5,5)) <br/>plt.imshow(pic) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8bc2e803a7f6baf0f1a85fdf71ba23ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*7oOoOQaPndp15sUnF8RcgQ.png"/></div></figure><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="1c10" class="nl kq ja nh b gy nm nn l no np">pic[350:450 , : , 2] = 255 # full intensity to those pixel's B channel <br/>plt.figure( figsize = (5,5)) <br/>plt.imshow(pic) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/74bef634e75749b0ef60f980c263e807.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*lmscyM3Ydrapp_OkCIYIsw.png"/></div></figure><p id="775e" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">为了使它更清楚，让我们改变列部分，这一次我们将同时改变 RGB 通道。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="d4cc" class="nl kq ja nh b gy nm nn l no np"># set value 200 of all channels to those pixels which turns them to white <br/>pic[ 50:450 , 400:600 , [0,1,2] ] = 200  <br/>plt.figure( figsize = (5,5)) <br/>plt.imshow(pic) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/75431ffc648036bf5ebf208fcd6caf24.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*5UXzW3oD7lJ7Gk62ylSl6g.png"/></div></figure><h1 id="4c48" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">拆分层</h1><p id="e148" class="pw-post-body-paragraph mn mo ja lj b lk ll kb mp lm ln ke mq lo mr ms mt lq mu mv mw ls mx my mz lu im bi translated">现在，我们知道图像的每个像素由三个整数表示。将图像分割成单独的颜色分量仅仅是取出图像阵列的正确切片的问题。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="a9d1" class="nl kq ja nh b gy nm nn l no np">import numpy as np <br/>pic = imageio.imread('images/me.jpg') <br/>fig, ax = plt.subplots(nrows = 1, ncols=3, figsize=(15,5))  <br/>for c, ax in zip(range(3), ax):     <br/>     # create zero matrix        <br/>     split_img = np.zeros(pic.shape, dtype="uint8") <br/>     # 'dtype' by default: 'numpy.float64'  # assing each channel      <br/>     split_img[ :, :, c] = pic[ :, :, c] # display each channel     <br/>     ax.imshow(split_img)</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/31184f98b6757177c0c0ea7f1cd4c97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py8R_SQXCwCZyuljdR-VOg.png"/></div></div></figure><h1 id="ebf4" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">灰度</h1><p id="6bab" class="pw-post-body-paragraph mn mo ja lj b lk ll kb mp lm ln ke mq lo mr ms mt lq mu mv mw ls mx my mz lu im bi translated">黑白图像存储在二维数组中。有两种类型的黑白图像:</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="2c6f" class="nl kq ja nh b gy nm nn l no np">- Binary: Pixel is either black or white:0 or 255<br/>- Greyscale: Ranges of shades of grey:0 ~ 255</span></pre><p id="1bea" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">现在，灰度化是一个将图像从全色转换为灰色阴影的过程。例如，在图像处理工具中:在 OpenCV 中，许多函数在处理之前使用灰度图像，这样做是因为它简化了图像，几乎起到了降噪的作用，并增加了处理时间，因为图像中的信息较少。</p><p id="81ea" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">在 python 中有几种方法可以将图像转换为灰度，但使用 matplotlib 的一种直接方法是使用此公式对原始图像的 RGB 值进行加权平均。</p><h1 id="60e0" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">Y' = 0.299 R + 0.587 G + 0.114 B</h1><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="915f" class="nl kq ja nh b gy nm nn l no np">pic = imageio.imread('images/me.jpg') <br/>gray = lambda rgb : np.dot(rgb[... , :3] , [0.299 , 0.587, 0.114])   gray = gray(pic) plt.figure( figsize = (5,5))  <br/>plt.imshow(gray, cmap = plt.get_cmap(name = 'gray')) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fcd6d33297c2b2a5c490e18163457f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*iKLD77pWiuI_Hq-zYdU54g.png"/></div></figure><h1 id="e5b2" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">使用逻辑运算符处理像素值</h1><p id="d473" class="pw-post-body-paragraph mn mo ja lj b lk ll kb mp lm ln ke mq lo mr ms mt lq mu mv mw ls mx my mz lu im bi translated">我们可以使用逻辑运算符创建一个相同大小的金块数组。然而，这不会创建任何新的数组，只是将 True 返回给它的主机变量。例如，假设我们想要过滤掉 RGB 图像中的一些低值像素或高值像素或(任何条件),是的，将 RGB 转换为灰度是很好的，但目前，我们不会这样做，而是处理彩色图像。</p><p id="b5b3" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">让我们首先加载一个图像并在屏幕上显示它。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="984e" class="nl kq ja nh b gy nm nn l no np">pic = imageio.imread('images/logic_op_pic.JPG') <br/>plt.figure(figsize=(5,5)) <br/>plt.imshow(pic) <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2705627e6604de3785964d2e648d5fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*yKCa7rtILar4lbxqUFeksQ.png"/></div></figure><p id="ccbb" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">让我们考虑这个转储图像。现在，在任何情况下，我们都要过滤掉所有的像素值，假设低于 20。为此，我们将使用一个逻辑操作符来完成这项任务，我们将为所有索引返回 True 值。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="a9b5" class="nl kq ja nh b gy nm nn l no np">low_pixel = pic &lt; 20  <br/># to ensure of it let's check if all values in low_pixel are True or not <br/>if low_pixel.any() == True:     <br/>    print(low_pixel.shape)</span></pre><p id="63c6" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">输出:</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="f8be" class="nl kq ja nh b gy nm nn l no np">(743, 911, 3)</span></pre><p id="3700" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">正如我们所说的，主机变量传统上不被使用，但是我引用它是因为它的行为。它只包含真正的值，没有其他内容。所以，如果我们同时看到 low_pixel 和 pic 的形状，我们会发现两者的形状是一样的。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="4c7d" class="nl kq ja nh b gy nm nn l no np">print(pic.shape)<br/>print(low_pixel.shape)</span></pre><p id="9ba3" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">输出:</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="84b9" class="nl kq ja nh b gy nm nn l no np">(743, 911, 3)<br/>(743, 911, 3)</span></pre><p id="3f2f" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">我们使用全局比较运算符为所有小于 200 的值生成了低值过滤器。但是，我们可以使用这个 low_pixel 数组作为索引，将那些低值设置为一些特定的值，这些值可能高于或低于前面的像素值。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="8535" class="nl kq ja nh b gy nm nn l no np"># randomly choose a value <br/>import random<br/><br/># load the orginal image<br/><br/>pic = imageio.imread('images/logic_op_pic.JPG')<br/><br/># set value randomly range from 25 to 225 - these value also randomly choosen<br/>pic[low_pixel] = random.randint(25,225)<br/># display the image<br/>plt.figure( figsize = (5,5))<br/>plt.imshow(pic)<br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/59fc63c2a6dba2d714e99bd3dbe1a47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*COB85YOegUT8P_TVcokGoQ.png"/></div></figure><h1 id="0fd7" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">掩饰</h1><p id="cfeb" class="pw-post-body-paragraph mn mo ja lj b lk ll kb mp lm ln ke mq lo mr ms mt lq mu mv mw ls mx my mz lu im bi translated">图像遮罩是一种图像处理技术，用于从具有模糊边缘、透明或毛发部分的照片中移除背景。</p><p id="a12a" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">现在，我们将创建一个圆盘形状的遮罩。首先，我们将测量从图像中心到每个边界像素值的距离。我们取一个方便的半径值，然后使用逻辑运算符，我们将创建一个圆盘。挺简单的，看看代码吧。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="49c0" class="nl kq ja nh b gy nm nn l no np"># Load the image <br/>pic = imageio.imread('images/logic_op_pic.JPG')  <br/># seperate the row and column values  <br/>total_row , total_col , layers = pic.shape  <br/>'''     Create vector.     Ogrid is a compact method of creating a multidimensional     ndarray operations in single lines.     <br/>for ex:     <br/>&gt;&gt;&gt; ogrid[0:5,0:5]     <br/>output: [array([[0],<br/>                [1],<br/>                [2],<br/>                [3],<br/>                [4]]),<br/>         array([[0, 1, 2, 3, 4]])]  <br/>''' <br/>x , y = np.ogrid[:total_row , :total_col]  <br/># get the center values of the image <br/>cen_x , cen_y = total_row/2 , total_col/2  </span><span id="5c9f" class="nl kq ja nh b gy nr nn l no np">'''    <br/> Measure distance value from center to each border pixel.     To make it easy, we can think it's like, we draw a line from center-     to each edge pixel value --&gt; s**2 = (Y-y)**2 + (X-x)**2  <br/>''' <br/>distance_from_the_center = np.sqrt((x-cen_x)**2 + (y-cen_y)**2)  <br/># Select convenient radius value <br/>radius = (total_row/2)  <br/># Using logical operator '&gt;'  <br/>''' <br/>logical operator to do this task which will return as a value  of True for all the index according to the given condition <br/>''' <br/>circular_pic = distance_from_the_center &gt; radius  </span><span id="6a95" class="nl kq ja nh b gy nr nn l no np">''' <br/>let assign value zero for all pixel value that outside the cirular disc. All the pixel value outside the circular disc, will be black now. <br/>''' </span><span id="54c1" class="nl kq ja nh b gy nr nn l no np">pic[circular_pic] = 0 <br/>plt.figure(figsize = (5,5)) <br/>plt.imshow(pic)  <br/>plt.show()</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/08f4076dd4156814ae494f38923bc05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*ldoULt4LXvmRem_kPJhbzw.png"/></div></figure><h1 id="dfe7" class="kp kq ja bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">图像处理</h1><p id="4356" class="pw-post-body-paragraph mn mo ja lj b lk ll kb mp lm ln ke mq lo mr ms mt lq mu mv mw ls mx my mz lu im bi translated">关于 edX 的 MOOC 课程之一，我们已经介绍了一些卫星图像及其处理系统。这当然是非常有益的。但是，让我们对它进行一些分析</p><p id="e7a6" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">这幅图像有一些有趣的地方。像许多其他可视化一样，每个 RGB 层中的颜色都有一定的含义。例如，红色的强度将指示像素中地理数据点的高度。蓝色的强度表示坡向的度量，绿色表示坡度。这些颜色将有助于以更快、更有效的方式传达这些信息，而不是显示数字。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="c3c5" class="nl kq ja nh b gy nm nn l no np">Red pixel indicates: Altitude<br/>Blue pixel indicates: Aspect<br/>Green pixel indicates: Slope</span></pre><p id="e8b4" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">仅仅通过看这张彩色的图像，一只训练有素的眼睛就能分辨出高度、坡度和方位。所以，这就是给这些颜色赋予更多意义的想法，以表明一些更科学的东西。</p><pre class="mf mg mh mi gt ng nh ni nj aw nk bi"><span id="2189" class="nl kq ja nh b gy nm nn l no np"># Only Red Pixel value , higher than 180<br/>pic = imageio.imread('images/sat_img.JPG')<br/>red_mask = pic[:, :, 0] &lt; 180<br/>pic[red_mask] = 0<br/>plt.figure(figsize=(5,5))<br/>plt.imshow(pic)<br/><br/># Only Green Pixel value , higher than 180<br/>pic = imageio.imread('images/sat_img.JPG')<br/>green_mask = pic[:, :, 1] &lt; 180<br/>pic[green_mask] = 0<br/>plt.figure(figsize=(5,5))<br/>plt.imshow(pic)<br/># Only Blue Pixel value , higher than 180<br/>pic = imageio.imread('images/sat_img.JPG')<br/>blue_mask = pic[:, :, 2] &lt; 180<br/>pic[blue_mask] = 0<br/>plt.figure(figsize=(5,5))<br/>plt.imshow(pic)<br/># Composite mask using logical_and<br/>pic = imageio.imread('images/sat_img.JPG')<br/>final_mask = np.logical_and(red_mask, green_mask, blue_mask)<br/>pic[final_mask] = 40<br/>plt.figure(figsize=(5,5))<br/>plt.imshow(pic)</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0ce1fca1de1fa83199bc96ef0a379836.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*0CetvdfHZ_vUWq2WOTQRxQ.png"/></div></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3f67c8a3e5b26ef2ab0d1c7df6217826.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*UiyZ5x3qKAt4PZ1EBxrbgQ.png"/></div></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8410400757a06fb46422487cbed9ddc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*urQd67sc4ag49bpGdS4nog.png"/></div></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/60a512a89a64326ac3ebfa2702819a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*aTmtDGzGOopbhZ29ScWXWg.png"/></div></figure><p id="c255" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated">记住你可以在我的 github 库<a class="ae ny" href="https://github.com/Yassine-Hamdaoui/Image-Data-Analysis" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的工作代码。</p><p id="7097" class="pw-post-body-paragraph mn mo ja lj b lk na kb mp lm nb ke mq lo nc ms mt lq nd mv mw ls ne my mz lu im bi translated"><strong class="lj jb">感谢</strong>的阅读，我很高兴讨论你可能有的任何问题或纠正:)如果你想讨论机器学习或其他任何问题，请在<a class="ae ny" href="https://www.linkedin.com/in/yassine-hamdaoui/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p></div></div>    
</body>
</html>