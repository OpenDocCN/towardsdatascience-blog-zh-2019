<html>
<head>
<title>React Best Practices ⚛</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践⚛</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/react-best-practices-804def6d5215?source=collection_archive---------3-----------------------#2019-11-25">https://towardsdatascience.com/react-best-practices-804def6d5215?source=collection_archive---------3-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e4df" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">前端</h2><div class=""/><div class=""><h2 id="db8c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">您应该在 React 项目中遵循的 React 最佳实践</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1d29ffcd23cb5690ee09b87437ca91c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zle8LiIMKwV2LUV8s4ksBQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@mimithian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mimi Thian</a> on <a class="ae lh" href="https://unsplash.com/s/photos/coding-practice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="145e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Sysco 实验室实习期间，我大量接触了 React Js。对于我们的项目，我们使用 React Js，并遵循 React 最佳实践。因此，我的团队领导和我的导师<a class="me mf ep" href="https://medium.com/u/a66a40c6b858?source=post_page-----804def6d5215--------------------------------" rel="noopener" target="_blank"> Nadun Indunil </a>建议我写一写 React 最佳实践。这是我在 Medium 的第 25 篇文章。</p><h1 id="debe" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">反应⚛️</h1><p id="8d11" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">React 是一个用于开发用户界面的 JavaScript 库。<a class="ae lh" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> React </a>图书馆是脸书创建的。React 允许集成许多令人兴奋的<a class="ae lh" href="https://hackernoon.com/23-best-react-ui-component-libraries-and-frameworks-250a81b2ac42" rel="noopener ugc nofollow" target="_blank">组件、库和框架</a>。诚然，开发者可以自己制作组件。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/2983d7d7bbbaecb5f2c92c11c3848c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXa8csNqRugQTile_zCfYQ.png"/></div></div></figure><p id="8fc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在最佳实践之前，我建议在开发 react 应用程序时使用测试驱动开发。测试驱动开发意味着先写一个测试，然后根据测试开发你的代码。更容易识别缺陷。如果当你发现一个 bug 时，你遵循另一个软件开发过程，首先写一个测试。</p><h1 id="6538" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">最佳实践</h1><h2 id="5a25" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">目录</h2><ol class=""><li id="77a3" class="np nq it lk b ll my lo mz lr nr lv ns lz nt md nu nv nw nx bi translated"><a class="ae lh" href="#49ac" rel="noopener ugc nofollow">文件组织</a></li><li id="add8" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#bbb6" rel="noopener ugc nofollow">微小功能部件</a></li><li id="7368" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#2de0" rel="noopener ugc nofollow">复用组件</a></li><li id="adb1" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#3a85" rel="noopener ugc nofollow">删除冗余代码</a></li><li id="1f4a" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#d96b" rel="noopener ugc nofollow">索引为键</a></li><li id="f7e7" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#1912" rel="noopener ugc nofollow">不必要的&lt;部门&gt; s </a></li><li id="5aeb" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#d915" rel="noopener ugc nofollow">仅必要的注释</a></li><li id="2262" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#249a" rel="noopener ugc nofollow">理解为处理‘这个’</a></li><li id="1189" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#b021" rel="noopener ugc nofollow">道具—状态—构造器</a></li><li id="e1d0" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#c966" rel="noopener ugc nofollow">最终命名</a></li><li id="3b67" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#b850" rel="noopener ugc nofollow">感知状态和渲染</a></li><li id="9ebd" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#cb4d" rel="noopener ugc nofollow">避免“设置状态”内的对象</a></li><li id="641d" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#1211" rel="noopener ugc nofollow">使用上部骆驼案例名称</a></li><li id="8440" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#bc4d" rel="noopener ugc nofollow">利用道具类型</a></li><li id="b6dd" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#f00a" rel="noopener ugc nofollow">JavaScript 中的 CSS</a></li><li id="993c" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#08d7" rel="noopener ugc nofollow">测试</a></li><li id="4fb0" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#8cc9" rel="noopener ugc nofollow">使用 ESLint、Prettier 和 snippet 库</a></li><li id="6956" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated"><a class="ae lh" href="#7745" rel="noopener ugc nofollow">使用 React 开发者工具</a></li></ol><h2 id="49ac" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">1.文件组织📂</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6d7da3765cb51fd6a4059642dc0b6aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*6JESZ9W-qgMPWjqyHQanDA.png"/></div></figure><p id="a93d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">文件组织不仅是 react 应用程序的最佳实践，也是其他应用程序的最佳实践。<a class="ae lh" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>的文件结构是组织 react 文件的一种可能方式。虽然不一定有一种文件结构比另一种更好，但保持文件有条理是很重要的。在 React 中，考虑到每个组件至少有一个与之相关联的文件，您的文件结构将快速增长。保存一个包含顶级 CSS、图像和字体文件的<strong class="lk jd"> <em class="oe">资产</em> </strong>文件夹。维护一个<strong class="lk jd"> <em class="oe"> helpers </em> </strong>文件夹来存放其他文件的任何种类的文件功能。将与组件相关的所有文件保存在一个文件夹中。通常情况下，<strong class="lk jd"> <em class="oe">组件</em> </strong>文件夹包含不止一个组件文件，比如测试文件 CSS 和一个或多个组件文件。如果有某个特定组件只使用的小组件，最好将这些小组件保存在<strong class="lk jd"> <em class="oe">组件</em> </strong>文件夹中。当您将大型组件放在它们自己的文件夹中，而将组件使用的小型组件放在子文件夹中时，就更容易理解文件的层次结构。开发人员主要将文件中的主要组件文件命名为 index.js。如果有几个文件都命名为 index.js，这可能会变得很麻烦。解决方法是在每个组件文件夹中添加一个<strong class="lk jd"> <em class="oe"> package.json </em> </strong>文件，并为相应的文件夹设置主入口点。例如，对于 button 组件，主要入口点是 Button.js。将 package.json 添加到每个文件夹并不是一个好的做法，但它有助于轻松处理您的文件。所以我们可以在按钮组件文件夹中添加下面的 package.json 文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4077" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你在 React 项目中使用 Redux 时，你可以根据你的项目使用<strong class="lk jd"> <em class="oe"> Rails 风格</em> </strong>或<strong class="lk jd"> <em class="oe"> Domain 风格</em> </strong>或<strong class="lk jd"> <em class="oe">【鸭子】</em> </strong>模式文件夹结构。在<strong class="lk jd"> <em class="oe"> Rails 风格的</em> </strong>模式中，单独的文件夹用于“动作”、“常量”、“缩减器”、“容器”和“组件”。在<strong class="lk jd"> <em class="oe">域风格</em> </strong>模式中，每个特征或域使用单独的文件夹，每个文件类型可能有子文件夹。<strong class="lk jd"><em class="oe">【Ducks】</em></strong>模式类似于领域风格，但是它明确地将动作和 reducers 联系在一起，通常是通过在同一个文件中定义它们。然而，文件夹结构可能是开发人员所希望的，但是应该有一种简单的方法来处理组件。React 说，它对你如何将文件放入文件夹没有意见。新队伍使用鸭式反应。当他们变得成熟时，他们开始使用 rails。Rails 具有易于理解项目的优势。</p><p id="d4dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">丹·阿布拉莫夫在推特上发布了一个解决方案👉</p><blockquote class="oh oi oj"><p id="1d20" class="li lj oe lk b ll lm kd ln lo lp kg lq ok ls lt lu ol lw lx ly om ma mb mc md im bi translated">移动文件，直到感觉合适为止。</p></blockquote><p id="22fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这正是你应该做的。你应该移动文件，直到他们觉得合适。</p><h2 id="bbb6" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">2.微小功能元件🤏</h2><p id="de62" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">众所周知，React 可以处理大型组件。但是如果我们把它们分成小块，我们可以重复使用它们。小组件更容易阅读、测试、维护和重用。大多数 React 初学者创建类组件，即使他们没有使用组件状态或生命周期方法。功能组件对于简单组件来说效率更高。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="bf70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的类组件可以编写如下。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3819" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用功能组件的优势。</p><ul class=""><li id="a5f2" class="np nq it lk b ll lm lo lp lr on lv oo lz op md oq nv nw nx bi translated">较少代码</li><li id="0df0" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md oq nv nw nx bi translated">更容易理解</li><li id="9285" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md oq nv nw nx bi translated">无国籍的</li><li id="af41" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md oq nv nw nx bi translated">更容易测试</li><li id="19db" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md oq nv nw nx bi translated">没有<code class="fe or os ot ou b">this</code>绑定。</li><li id="1be1" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md oq nv nw nx bi translated">更容易提取更小的成分。</li></ul><p id="c91b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您使用功能组件时，您无法控制重新渲染过程。当某些东西改变甚至组件自身改变时，React 会重新渲染功能组件。在以前的 react 版本中有一个解决方案可以使用<code class="fe or os ot ou b">React.PureComponent</code>。PureComponent 允许浅层 props 和状态比较。当组件的道具或内容或组件本身发生变化时，组件会重新呈现。否则，PureComponent 跳过重新渲染，而是重用最后一次渲染的结果。</p><p id="df75" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">React v16.6.0 之后 React 引入了一个新特性，那就是<a class="ae lh" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">备忘录</a>。Memo 浅比道具。当组件的道具或内容或组件本身发生变化时，组件会重新呈现。根据比较结果，react 将重用上次渲染的结果或重新渲染。Memo 允许你创建一个纯粹的功能组件。Memo 抹杀了有状态组件和<code class="fe or os ot ou b">PureComponent</code>的使用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/61950060ca4b2b000b577b1b1a3847ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3nDP0U_P9yF1Ulk-BNsCw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Components, Picture credit: <a class="ae lh" href="https://www.kirupa.com/react/images/c_app_144.png" rel="noopener ugc nofollow" target="_blank">https://www.kirupa.com/react/images/c_app_144.png</a></figcaption></figure><h2 id="2de0" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">3.可重用组件♻️</h2><p id="fd8f" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">每个功能组件应该有一个功能，这意味着一个功能组件等于一个功能。当你创建一个具有一个功能的功能组件时，你可以提高组件的可重用性。</p><h2 id="3a85" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">4.删除冗余代码🗑️</h2><p id="97f4" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">不仅在 React 中，而且在所有应用程序开发中，通用规则是尽可能保持代码简洁。反应最佳实践指示保持无错代码和精确代码。不要重复你自己(DRY)是软件开发的一个原则，专注于最大限度地减少软件模式的重复，用抽象来代替它，或者使用数据规范化来避免冗余。在代码设计中，你可以使用你自己的风格指南，或者使用一个流行的成熟的风格指南(<a class="ae lh" href="https://github.com/airbnb/javascript/tree/master/react" rel="noopener ugc nofollow" target="_blank"> Airbnb React/JSX 风格指南</a>、<a class="ae lh" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">脸书风格指南</a>等等)。如果你开始追随任何一种风格的人，不要和其他人混淆。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/6fa473570bcca4c76661e21c3d7a02b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcHGlChZigW9UTdyLtzOQQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://quotefancy.com/quote/46568/Lemony-Snicket-Don-t-repeat-yourself-It-s-not-only-repetitive-it-s-redundant-and-people" rel="noopener ugc nofollow" target="_blank">https://quotefancy.com/quote/46568/Lemony-Snicket-Don-t-repeat-yourself-It-s-not-only-repetitive-it-s-redundant-and-people</a></figcaption></figure><h2 id="d96b" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">5.作为关键字的索引🔑</h2><p id="9efb" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">当创建一个 JSX 元素的数组时，react 要求你给你的元素添加一个关键道具。这通常是通过使用映射函数来完成的，而映射函数又会导致人们使用索引来设置键属性。这太糟糕了！React 使用 key 属性来跟踪数组中的每个元素，并且由于数组的折叠性质。这很容易导致错误的信息出现在错误的地方。这在用状态循环遍历类组件时尤其明显。</p><h2 id="1912" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">6.不必要的🚫</h2><p id="e5ae" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">当创建 React 组件时，记住您仍然在构建 HTML 文档是很重要的。人们倾向于在 React 中使用<code class="fe or os ot ou b">divitis</code>,最终导致不正确的 HTML。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d747" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe or os ot ou b">div</code>是<code class="fe or os ot ou b">ul</code>的直接子节点，这是不正确的 HTML，而在下面的例子中，<code class="fe or os ot ou b">li</code>是<code class="fe or os ot ou b">ul</code>的直接子节点，这是正确的 HTML。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d2c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用另一种使用<code class="fe or os ot ou b">&lt;React.Fragment&gt;</code>标签的方法。<code class="fe or os ot ou b">&lt;React.Fragment&gt;</code>是在 React v16.2 中引入的，我们可以用它们来代替无关的<code class="fe or os ot ou b">&lt;div&gt;</code>标签。</p><h2 id="d915" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">7.仅必要的注释📝</h2><p id="6856" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">必要时在应用程序中添加注释。从应用程序中移除注释的能力意味着我必须编写有文化的代码，没有例外。它给出了混乱的自由代码段。一般来说，注释是糟糕设计的一个标志，尤其是冗长的注释，很明显开发者不知道他们在做什么，试图通过写注释来弥补。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/875bf82654cf64e4315c67887187cbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-RsjpvPIlQ8fcoB-X1BfQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://www.toptal.com/sql/guide-to-data-synchronization-in-microsoft-sql-server" rel="noopener ugc nofollow" target="_blank">https://www.toptal.com/sql/guide-to-data-synchronization-in-microsoft-sql-server</a></figcaption></figure><h2 id="249a" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">8.理解处理“这个”👆</h2><p id="ddf8" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">因为功能组件不需要<code class="fe or os ot ou b">this</code>绑定，所以只要有可能，你就会想要使用它们。但是如果你使用的是 ES6 类，你需要手动绑定它，因为 React 不会自动绑定组件中的函数。这里有一些这样做的例子。</p><p id="41c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="oe">例 1:绑定渲染</em> </strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5d51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将以下代码片段添加到名为 bind in render 的渲染中</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="6e6c" class="ne mh it ou b gy pc pd l pe pf">onClick={this.logMessage.bind(this)}</span></pre><p id="dd7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方式清晰、简洁且可行，但可能会导致轻微的性能问题，因为每次组件重新渲染时都会调用新的函数，这可能会很频繁。</p><p id="2946" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="oe">例 2:渲染中的箭头功能。</em>T11】</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9346" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将以下代码片段添加到 render 中名为 arrow function 的渲染中。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="680b" class="ne mh it ou b gy pc pd l pe pf">onClick={() <strong class="ou jd">=&gt;</strong> this.logMessage()}</span></pre><p id="5372" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方式清晰、简洁，就像示例 1 一样，但是像示例 1 一样，它也会在每次组件呈现时创建一个新函数。</p><p id="52f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="oe">例 3:绑定构造函数</em> </strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f2ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将以下代码片段添加到名为 bind in constructor 的构造函数中。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="0828" class="ne mh it ou b gy pc pd l pe pf">this.logMessage = this.logMessage.bind(this);</span></pre><p id="7f56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法将解决示例 1 和示例 2 的潜在性能问题。不要忘记在构造函数中调用 super。</p><p id="6fcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="oe">例 4:类属性</em> </strong>中的箭头函数</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="32de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将以下代码片段添加到类属性中名为 arrow function 的类中。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="a9d4" class="ne mh it ou b gy pc pd l pe pf">logMessage = () <strong class="ou jd">=&gt;</strong> {<br/><strong class="ou jd">const</strong> { message } = this.state;<br/>console.log(message);<br/>}</span></pre><p id="47ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方式非常简洁、易读，它将避免例 1 和例 2 中的性能问题，并避免例 3 中的重复。但是要注意，这种方法依赖于实验特性，它不是 ECMA 脚本规范的正式部分。您可以通过安装和配置 babel 包来试验语言功能，create react 应用程序创建的应用程序启用了许多功能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/a6da26136dbf2da211c03e4756bceefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6cJeEek1dapE90sVllvYw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://codeburst.io/javascript-arrow-functions-for-beginners-926947fc0cdc" rel="noopener" target="_blank">https://codeburst.io/javascript-arrow-functions-for-beginners-926947fc0cdc</a></figcaption></figure><h2 id="b021" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">9.道具-状态-构造器🏁</h2><p id="4f57" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们可以把标题分成两个子标题，如。</p><ul class=""><li id="d0bb" class="np nq it lk b ll lm lo lp lr on lv oo lz op md oq nv nw nx bi translated">初始状态的时候不要用道具。</li><li id="181d" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md oq nv nw nx bi translated">不要在类构造函数内部初始化组件状态。</li></ul><p id="f0f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你在初始状态使用 props 时，问题是当组件被创建时构造函数被调用。所以构造函数只被调用一次。如果您下次对 props 进行更改，组件状态将不会更新，它将保持与以前的值相同。您可以使用 react 生命周期方法<code class="fe or os ot ou b">componentDidUpdate</code>来解决这个问题。当属性改变时,<code class="fe or os ot ou b">componentDidUpdate</code>方法更新组件。<code class="fe or os ot ou b">componentDidUpdate</code>在初始渲染时不会被调用。但是，在初始状态下使用道具并不是最好的做法。</p><p id="0eaa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将状态初始化为类字段是最佳实践。用构造函数初始化组件状态并没有那么糟糕，但是它增加了代码中的冗余，并产生了一些性能问题。当你初始化类构造函数内部的状态时，它会不必要地调用 super 并记住 props，这会造成性能问题。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8ff6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个问题是，当你要在构造函数中初始化状态时，想想你需要多少行，你需要<code class="fe or os ot ou b">constructor()</code>，<code class="fe or os ot ou b">super()</code>？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/73ef1622a09db361098ca014c5d5ecd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMcEZHVPkiL2vysGeDxJ7g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://indepth.dev/in-depth-explanation-of-state-and-props-update-in-react/" rel="noopener ugc nofollow" target="_blank">https://indepth.dev/in-depth-explanation-of-state-and-props-update-in-react/</a></figcaption></figure><h2 id="c966" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">10.最终命名🔚</h2><p id="b297" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">键入脚本后命名一个函数或组件，因为它们应该易于识别。比如你因为组件代码，瞬间选择了<code class="fe or os ot ou b">FacebookButton</code>这样的组件名称。但是将来你可能会用那个组件作为<code class="fe or os ot ou b">TwitterButton</code>、<code class="fe or os ot ou b">YoutubeButton</code>。因此，最佳实践是将该组件命名为<code class="fe or os ot ou b">Button</code>。通常，当您完成函数时，您应该能够为组件和函数选择通用名称。最后命名增加了可重用性。</p><h2 id="b850" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">11.意识到状态和渲染🎭</h2><p id="3ba6" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">在 React 中，我们可以根据状态对组件进行分类。有<strong class="lk jd"> <em class="oe">有状态</em> </strong>和<strong class="lk jd"> <em class="oe">无状态</em> </strong>。有状态组件存储组件的状态信息，并提供必要的上下文。反过来，无状态组件没有内存，也不能给用户界面部分提供上下文。无状态组件是可伸缩的、可重用的，就像纯 JavaScript 函数一样。将有状态提取逻辑与呈现无状态逻辑分开。一个更好的方法是使用有状态组件获取数据，使用另一个无状态组件显示获取的数据。</p><p id="9fc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 React v16.08 之后有一个新特性叫做“React Hooks”。React 钩子编写有状态的功能组件。React 钩子取消了类组件的使用。</p><p id="ed60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果数据没有在 render 方法中直接呈现，它就不应该处于组件状态。未直接呈现的数据可能会导致不必要的重新呈现。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/bdca868d7eff818739049049a4e401c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Bb04OITwnidkntzFR045g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://www.barrymichaeldoyle.com/sub-rendering/" rel="noopener ugc nofollow" target="_blank">https://www.barrymichaeldoyle.com/sub-rendering/</a></figcaption></figure><h2 id="cb4d" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">12.避免“setstate”🛑内的对象</h2><p id="4ea8" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">根据<a class="ae lh" href="https://reactjs.org/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank"> React 文档</a> React 不保证立即应用阶段更改。因此，在调用<code class="fe or os ot ou b">setState</code>之后立即读取<code class="fe or os ot ou b">this.state</code>是一个潜在的陷阱，因为<code class="fe or os ot ou b">this.state</code>实际上可能不是你所想的那样。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="b5ad" class="ne mh it ou b gy pc pd l pe pf"><strong class="ou jd">const</strong> { ischecked } = this.state;<br/>this.setState({ischecked: !ischecked});</span></pre><p id="79c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用下面的函数，而不是像上面的代码片段那样更新对象的状态。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="e2e9" class="ne mh it ou b gy pc pd l pe pf">this .setState((prevState, props) =&gt; {<br/>return {ischecked: !prevState.ischecked}<br/>})</span></pre><p id="d184" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的函数将接收先前的状态作为它的第一个参数，并将应用更新时的<code class="fe or os ot ou b">props</code>作为它的第二个参数。状态更新是异步操作，所以要更新状态对象，我们需要使用带有<code class="fe or os ot ou b">setState</code>的 updater 函数。</p><h2 id="1211" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">13.使用大写骆驼名称🐪</h2><p id="bf82" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">当你在 React 中工作时，记住你使用的是 JSX (JavaScript 扩展)而不是 HTML。你创建的组件应该用上驼格命名，又名<strong class="lk jd"> <em class="oe">帕斯卡格</em> </strong>。大写骆驼字母表示单词书写时没有空格，每个单词的第一个字母大写。例如，如果有一个名为<code class="fe or os ot ou b">selectbutton</code>的组件，那么你应该将其命名为<code class="fe or os ot ou b">SelectButton</code>而不是<code class="fe or os ot ou b">selectbutton</code>。使用大写骆驼有助于 JSX 区分默认的 JSX 元素标签和创建的元素。但是，您可以使用小写字母来命名组件，但这不是最佳做法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/db94b1d42dca80a53360fa2d057d1497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyY3KjAgxFXCbmc-_X1qCg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae lh" href="https://unsplash.com/s/photos/reactjs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="bc4d" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">14.利用支柱型🧪</h2><p id="47f3" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">“prop-types”是一个用于类型检查道具的库，它可以通过确保你为你的道具使用正确的数据类型来帮助防止错误。<code class="fe or os ot ou b">React.PropTypes</code>从 React v15.5 开始，已经转移到一个不同的包中。<code class="fe or os ot ou b">React.PropTypes</code>包让我们能够对组件的属性进行类型检查，并赋予它默认值。因此，npm install 将使用一个外部库。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="b2c2" class="ne mh it ou b gy pc pd l pe pf">npm i prop-types</span></pre><p id="07e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">导入库，添加<code class="fe or os ot ou b">PropTypes</code>到组件，相应地设置数据类型，如果需要道具，添加<code class="fe or os ot ou b">isRequired</code>，如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6ee5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以使用<code class="fe or os ot ou b">defaultProps</code>将默认值分配给属性。当一个组件没有收到它的道具时，它指的是已经赋值的<code class="fe or os ot ou b">defaultProps</code> <em class="oe"> </em>。如果你已经按要求标记了你的道具，就不需要分配<code class="fe or os ot ou b">defaultProps</code>。在下面的代码片段中，您可以看到所有已经分配给<em class="oe"> ModalButton </em>的属性的默认值。对于这个例子，我使用了<em class="oe"> React Bootstrap </em>框架。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><blockquote class="oh oi oj"><p id="8389" class="li lj oe lk b ll lm kd ln lo lp kg lq ok ls lt lu ol lw lx ly om ma mb mc md im bi translated">始终为所有可选属性定义显式 defaultProps</p></blockquote><p id="340b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的是，做类型检查时使用<code class="fe or os ot ou b">PropsTypes</code> <em class="oe"> </em>后赋值<code class="fe or os ot ou b">defaultProps</code> <em class="oe">。</em>因此，它也对分配给属性的默认值进行类型检查。</p><h2 id="f00a" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">15.JavaScript 中的 CSS💅</h2><p id="f085" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">在我的实习工作中，我们面临一个造型问题，尤其是主题。CSS 已在开发环境中加载，但没有在生产环境中加载。我的队友<a class="me mf ep" href="https://medium.com/u/87c8f67602eb?source=post_page-----804def6d5215--------------------------------" rel="noopener" target="_blank">哈里斯·桑卡帕</a>写了那个<a class="ae lh" href="https://medium.com/@harith.sankalpa/how-to-load-css-or-sass-styles-into-single-spa-framework-using-style-loader-7d5937fc1c53" rel="noopener">问题</a>。但是现在我根据不同的应用找到了这么多最好的方法。</p><p id="73d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你有一个大的 CSS (SCSS)文件时，你可以使用全局前缀，后跟块-元素-修饰符约定来避免名字冲突。当您的应用程序变得更大时，这种方法是不可伸缩的。所以你必须评估你的 CSS(SCSS)文件。还有另一种通过 webpack 的<a class="ae lh" href="https://github.com/webpack-contrib/mini-css-extract-plugin" rel="noopener ugc nofollow" target="_blank">迷你 CSS 提取文本插件</a>提取 CSS 的方法(它需要 webpack 4 才能工作)，但它对 webpack 产生了严重的依赖性。如果你使用这种方法，测试你的组件是困难的。最佳实践是拥有一个易于测试的应用程序，因此，遵循这种方法并不是最佳实践。</p><p id="e10b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/emotion-js/emotion" rel="noopener ugc nofollow" target="_blank"> EmotionJS </a>、<a class="ae lh" href="https://glamorous.rocks/" rel="noopener ugc nofollow" target="_blank">laminate</a>和<a class="ae lh" href="https://github.com/styled-components/styled-components" rel="noopener ugc nofollow" target="_blank"> Styled Components </a>是 JS 库中的一些新 CSS。您可以根据您的用例来使用它们。当你需要生成一个编译好的 CSS 时，你可以使用 EmotionJS 库。当你有一个复杂的主题问题时，你可以使用迷人的和风格化的组件库。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/01f6a27b27e6bae949b11b80a2d46983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujZiNHOT2BJLUHKcbGt9HQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://wordpress.org/plugins/custom-css-js/" rel="noopener ugc nofollow" target="_blank">https://wordpress.org/plugins/custom-css-js/</a></figcaption></figure><h2 id="08d7" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">16.测试🚀</h2><p id="68a1" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">不仅在 React 中，在其他编程语言中也应该进行测试。测试是很重要的，因为它确保代码如预期的那样运行，并且可以简单快速地测试。在最佳实践中，在组件文件夹中创建一个<code class="fe or os ot ou b">__Test__</code>文件夹。用组件名加上一个<code class="fe or os ot ou b">.test.js</code>后缀来创建测试文件。您可以将 Jest 用作测试程序，将 Enzyme 用作 React 的测试工具。我的队友<a class="me mf ep" href="https://medium.com/u/9be478c2735f?source=post_page-----804def6d5215--------------------------------" rel="noopener" target="_blank">卡温杜文迪卡</a>写了关于<a class="ae lh" href="https://medium.com/@kavinduvsomadasa/unit-test-in-react-with-jest-enzyme-bde3840ade8" rel="noopener">的笑话和酶测试</a>，如果你想你可以看看。</p><p id="b875" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对组件进行崩溃测试是一种简单快速的方法，可以确保所有组件都正常工作而不会崩溃。组件崩溃测试很容易应用到你制作的每个组件中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c760" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你应该做明显比碰撞测试更广泛的测试。如果你写更多的测试用例，它会给你的代码更多的测试覆盖率。但是，至少你应该做一些碰撞测试。在崩溃测试中，我们所做的是创建一个元素，然后它使用 ReactDom 并装载您导入到刚刚创建的 div 中的任何组件，然后它卸载 div。</p><blockquote class="oh oi oj"><p id="15f8" class="li lj oe lk b ll lm kd ln lo lp kg lq ok ls lt lu ol lw lx ly om ma mb mc md im bi translated">一个真正的 react 开发人员会对整个 React 应用程序进行适当的测试。</p></blockquote><h2 id="8cc9" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">17.使用 ESLint、Prettier 和 snippet 库📚</h2><p id="8e7f" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">ESlint 用歪歪扭扭的字体对你大喊大叫，让你的代码保持整洁。您可以将它链接到您的 IDE。最佳实践是保留您自己的 ESLint <a class="ae lh" href="https://eslint.org/docs/user-guide/configuring" rel="noopener ugc nofollow" target="_blank">配置文件</a>。</p><blockquote class="oh oi oj"><p id="6c71" class="li lj oe lk b ll lm kd ln lo lp kg lq ok ls lt lu ol lw lx ly om ma mb mc md im bi translated">一个好的开发人员会修复所有的 ESlint 错误和警告，而不是禁用那个错误。</p></blockquote><p id="170e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮</a>是一个代码格式化工具。漂亮有一套代码格式和缩进的规则。您可以使用<a class="ae lh" href="https://www.sonarlint.org/" rel="noopener ugc nofollow" target="_blank"> Sonarlint </a>来检查法术、功能长度和更好方法的建议。使用<a class="ae lh" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank"> Husky </a>不仅对 React 是一个好的实践，对 Git 也是一个好的实践。可以在<strong class="lk jd"> <em class="oe"> package.json </em> </strong>文件中定义哈士奇。Husky 防止您的应用程序出现错误提交和错误推送。</p><p id="9113" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码片段有助于您编写最佳代码和趋势语法。它们使你的代码相对没有错误。你可以使用很多代码片段库，比如 ES7 React，JavaScript (ES6)代码片段等。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/9e897d43320779569cf0f3de616557de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3jAUHwtjMHPJ6wiFTLgWw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Picture credit: <a class="ae lh" href="https://medium.com/dubizzletechblog/setting-up-prettier-and-eslint-for-js-and-react-apps-bbc779d29062" rel="noopener">https://medium.com/dubizzletechblog/setting-up-prettier-and-eslint-for-js-and-react-apps-bbc779d29062</a></figcaption></figure><h2 id="7745" class="ne mh it bd mi nf ng dn mm nh ni dp mq lr nj nk ms lv nl nm mu lz nn no mw iz bi translated">18.使用 React 开发工具🛠️</h2><p id="f6b6" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">React Developer Tools 是 Chrome 和 Firefox 的扩展。如果您使用 Safari 或其他独立 shell，请使用以下命令来安装它。</p><pre class="ks kt ku kv gt oy ou oz pa aw pb bi"><span id="e74f" class="ne mh it ou b gy pc pd l pe pf">npm install -g react-devtools@^4</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/77604f4b20e504e3e30ed3dc3da03d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nupP4CoyJ9nrQOvn6kg7SA.png"/></div></div></figure><p id="327f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您正在寻找 React 中内置的 web 应用程序，您可以在 Components 选项卡中看到组件层次结构。如果您点击一个组件，您可以查看该组件的属性和状态。如你所见，React Developer Tools extension 是一款非常有价值的工具，可用于测试和调试，并真正了解该应用程序发生了什么。</p><h1 id="aafd" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">结论✌️</h1><p id="9344" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">本文描述了 React 中的最佳实践。这些实践提高了您的应用程序性能、应用程序代码和编码技能。作为我的第 25 篇文章，我想动态更新这篇文章。这意味着我会用新的趋势来更新这篇文章。如果我更新这篇文章，我会通过<a class="ae lh" href="https://twitter.com/TheSabesan" rel="noopener ugc nofollow" target="_blank">推特</a>通知。保持联系。呜哇！！！🙌</p><p id="35b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">快乐编码😎</p></div><div class="ab cl pm pn hx po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="im in io ip iq"><p id="a9e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="oe">关注我的</em></strong><a class="ae lh" href="https://twitter.com/TheSabesan" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd"><em class="oe">Twitter</em></strong></a><strong class="lk jd"><em class="oe">和 Medium 如果你将来对这些更深入、更翔实的文章感兴趣的话！</em>T19】</strong></p></div></div>    
</body>
</html>