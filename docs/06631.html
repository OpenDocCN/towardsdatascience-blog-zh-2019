<html>
<head>
<title>System availability formula -assumptions to remember</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">系统可用性公式-要记住的假设</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/system-availability-formula-assumptions-to-remember-34ca55baff01?source=collection_archive---------14-----------------------#2019-09-22">https://towardsdatascience.com/system-availability-formula-assumptions-to-remember-34ca55baff01?source=collection_archive---------14-----------------------#2019-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2f4f6acacfbe130660a0e2886387fb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FM7O7GoAvX2RKhthiutbDA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Image by Author</figcaption></figure><p id="1435" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">系统可用性，即系统在需要时工作的概率，直接影响系统维护策略、效率和系统设计中的冗余。上述公式是描述和计算系统可用性最常用的表达式。这个公式的主要优点是简单。然而，不幸的是，人们经常误解这个公式本身就是可用性的实际定义。它不是。上述公式是一系列数学计算的结果，基于单个独立组件的假设，在稳态条件下故障和修复呈指数分布。</p><p id="f7cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，我将一步一步地概述这个公式是如何推导出来的。</p><h1 id="2d98" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">介绍</h1><p id="189b" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">假设<em class="mg">S(</em><strong class="kh iu"><em class="mg">B</em></strong><em class="mg">)= 1</em>表示一个状态(<em class="mg"> B </em>)，或者一个给定系统被定义为可操作的状态的联合(<strong class="kh iu"> <em class="mg"> B </em> </strong>)，那么<strong class="kh iu"> <em class="mg">系统可用性</em> </strong>，<em class="mg"> A(t)，</em>是在时间<em class="mg"> t </em>，<em class="mg">S()</em> <strong class="kh iu"> <em class="mg">系统可靠度</em> </strong>，<em class="mg"> R(t) </em>是到时间<em class="mg"> t，</em>系统尚未处于故障状态的概率，<em class="mg">S(</em><strong class="kh iu"><em class="mg">B</em></strong><em class="mg">)= 0</em>。因此，可靠性可以表示如下:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/97ff9f99779fd0f0ef9c2eb1546393f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfYkLke3pV-g1xVt_hxhCg.png"/></div></div></figure><p id="ef02" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可靠性与单个部件的故障概率有着简单的关系，<em class="mg"> F </em> ₁ <em class="mg"> (t) </em>。然而，可用性是一个更复杂的问题。有许多不同的方法来解决这个问题。在这篇文章中，我将介绍马尔可夫方程方法。</p><h1 id="a076" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">危险功能和系统工程</h1><p id="6170" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">在系统工程领域，危险函数<em class="mg">h(x)</em>描述事件(系统故障)在时间<em class="mg"> t </em>发生的概率，假设该事件在该时间点之前尚未发生。风险函数(也称为失效率、风险率或死亡率)<em class="mg"> h(x) </em>是概率密度函数(PDF)<em class="mg">F(t)</em>和生存函数<em class="mg">S(t)</em><em class="mg">1-F(t)</em>之间的比值。其中<em class="mg"> F(t) </em>，是累积分布函数(CDF)。危险函数在系统工程中起着重要的作用，因为只要系统在运行，系统工程中数据集的收集就通过观察系统中的故障来进行<br/>。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/5e9ff1cffe5dafbe46e704364a157484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yD8nWb5euC17LwdB2LS9Mw.png"/></div></div></figure><p id="a7a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">等式(2)是使用贝叶斯定理的危险定义公式，其中:</p><p id="78be" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"><em class="mg">【F(t)</em></strong><em class="mg"/>表示事件(系统故障)在 0 到 t 之间发生的概率</p><p id="46fc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">1- <strong class="kh iu"> <em class="mg"> F(t) </em> </strong>表示事件直到时间 t <em class="mg">才发生的<strong class="kh iu"> <em class="mg"> </em> </strong>概率。</em></p><p id="59bd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="mg"> f(t)dt </em> </strong>表示事件在时间<em class="mg"> t </em>的小区间<em class="mg"> dt </em>内发生的概率。</p><p id="08f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="mg"> z(t)dt </em> </strong>表示某事件在<em class="mg"> t </em>的小区间<em class="mg"> dt </em>内发生的条件概率，假设该事件在该时间之前尚未发生。</p><p id="910e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mg"> z(t) </em>采用了危险函数的名称，因为它与故障有关。系统故障是系统工程中的重要事件，但考虑到系统的生命史，它们不是唯一可能的事件。还有许多其他事件，如维修、检查、维护、运行状态的变化，以及许多其他可能具有统计性质的事件。</p><h1 id="6bd0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">指数分布</h1><p id="17e8" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">指数分布是风险不变的特殊情况。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/a14805fa297b54a1b713401b735b24b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1x4NKw79q40rLf3Nwx63A.png"/></div></div></figure><p id="6655" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，指数失效密度对应于一个与时间无关的常数风险函数，换句话说，不会老化。常数风险函数是指数分布的无记忆特性的结果:假设受试者已经存活到时间<em class="mg"> t </em>的剩余存活时间的分布不依赖于<em class="mg"> t </em>。把<br/>换个说法，一个时间区间内的死亡概率<em class="mg">【t，t+y】</em>独立于起点，<em class="mg">t</em><a class="ae mo" href="http://people.stat.sfu.ca/~raltman/stat402/402L32.pdf" rel="noopener ugc nofollow" target="_blank">【1】</a>。</p><p id="ddfa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">指数分布是系统工程应用中最广泛使用的分布。这主要是因为它是最简单的函数，而不是因为它是正确的函数。</p><h1 id="b292" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">马尔可夫过程</h1><p id="9b17" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">马尔可夫过程是一个随机过程，在这个过程中，给定现在，系统的未来状态独立于过去。在这种模型中，系统的未来状态完全由系统的当前状态决定。<strong class="kh iu">如果系统中的所有组件都具有指数分布</strong>，那么系统是马尔可夫的，未来只取决于现在的状态。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/e21440f05c0567df99d1f0e8d377e330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pAvUzoJadx2ZwdAC-CG9A.png"/></div></div></figure><p id="f814" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">等式(4)被称为马尔可夫等式<a class="ae mo" href="https://www.amazon.com/Monte-Carlo-Applications-Systems-Engineering/dp/0471981729" rel="noopener ugc nofollow" target="_blank">【2】</a>。它是一组联立的一阶微分方程，是作为<em class="mg"> n </em>单入口状态传输方程的特例而导出的。马尔可夫方程有一个简单的物理解释。<em class="mg"> zᵢ </em>代表离开状态<em class="mg"> i </em>的比率，因此<em class="mg"> zᵢPᵢ(t) </em>代表该状态下人口的减少。同样，组件从其他状态进入状态<em class="mg"> i </em>。从任一状态<em class="mg"> j </em>转移到状态<em class="mg"> i </em>的速率为<em class="mg"> zᵢⱼ </em>，导致单位时间内<em class="mg">zᵢⱼpᵢ(t</em>状态<em class="mg"> i </em>的人口增加。马尔可夫链有有限数量的<em class="mg"> n </em>个状态，在任何时间处于任何状态的概率是<em class="mg"> 1 </em>(这就是所谓的归一化方程)</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/64942a7d86162f0043a21c7c0459239b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CWFqSfgClKlJCDQ18fk6w.png"/></div></div></figure><p id="4ed8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于具有指数分布的两个状态的简单情况，等式(4)采用简单的形式:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/d57ca86e3e2e32fde33c0b945af603da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTuuV7ZYTnc3ahjrRyELJA.png"/></div></div></figure><p id="7ef9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">其中λ是失效的危险，通常称为<em class="mg">失效率</em>，μ称为<em class="mg">修复率</em>。</p><p id="e072" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">利用归一化方程<em class="mg"> P₁(t)+P₀(t)=1 </em>，得出:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/bf3c66fa2bb7dde89c3286f448944ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIScwvkHNljLh-kCbdUgSw.png"/></div></div></figure><p id="d87d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">具有边界条件<em class="mg"> P₁(0)=1 </em>的方程(6)的解产生:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/be362ad83246eef2fbec482fb92eeab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_RrWL8dS9b1-kmfjwfNOA.png"/></div></div></figure><p id="683d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">具有两种状态的单个组件的可用性包含两个术语。第二项是瞬态的，随着时间的增加而变为零。第一项称为<em class="mg">稳态可用性</em> <em class="mg"> A </em> ∞，注意到<em class="mg"> 1/λ </em>是<strong class="kh iu">平均无故障时间</strong> (MTTF)和<em class="mg">1/μ</em><strong class="kh iu">平均修复时间</strong> (MTTR)，可以得到:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/f85ab866c040471c7f79acf6387ce631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-B9ZbY5jEuSGJFvB2SKH2Q.png"/></div></div></figure><p id="742a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是描述和计算可用性最常用的表达式之一。等式(7)的主要优点是简单。事实上，许多人很直观地认为这个等式就是可用性的定义。可用性公式为真<strong class="kh iu">当且仅当</strong>故障概率密度函数以及修复 PDF 为指数函数，且仅针对稳态(<em class="mg"> t </em> → ∞时)。</p><p id="6bdb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种误用公式的情况，在数值计算领域是很常见的。正如英国统计学家乔治·博克斯的名言:“所有的数字计算模型都是错误的，有些是有用的”。由于模型和公式是基于假设的，所以当试图将这些模型应用到现实生活中以产生现实结果时，不应该忘记这些假设。</p></div></div>    
</body>
</html>