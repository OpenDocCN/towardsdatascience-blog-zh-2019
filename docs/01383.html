<html>
<head>
<title>A Keras Pipeline for Image Segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种用于图像分割的 Keras 流水线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-keras-pipeline-for-image-segmentation-part-1-6515a421157d?source=collection_archive---------2-----------------------#2019-03-05">https://towardsdatascience.com/a-keras-pipeline-for-image-segmentation-part-1-6515a421157d?source=collection_archive---------2-----------------------#2019-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b9aa727e0c2f7e439fd1b0e5acc857b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdiFOoxRLHn2sNOSGupH0Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/photos/aV5xrpB0bwQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Soragrit Wongsa</a> on <a class="ae kf" href="https://unsplash.com/search/photos/image-segmentation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="706e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网上有数百个教程，教你如何使用 Keras 完成图像分割任务。这些非常有帮助，通常对您的用例来说已经足够了。然而，对于初学者来说，即使是从普通的深度学习任务开始，也可能显得势不可挡。在开始训练过程之前，有一些普通的操作需要完成——准备数据，创建分区(train，val，test ),准备模型。在本教程(分为 3 个部分)中，我试图创建一个可访问的整个图像分割管道的演练。这包括:</p><p id="f5b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">a)创建和结构化数据集</p><p id="e3bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">b)生成训练和评估图像</p><p id="e940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">c)模型选择、加载和编译以及培训。</p><p id="5de8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望在本课程结束时，您能够轻松地尝试自己的图像分割初学者项目，或者任何此类专注于图像的深度学习问题。</p><p id="f879" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们开始吧！</p><h1 id="f780" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">第一部分:数据集</strong></h1><p id="f565" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">图像分割中的问题稍微复杂一点<em class="mh"/>(不像分类)，因为你必须跟踪你的图像<em class="mh">和</em>它们的遮罩。</p><p id="8470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，你会使用<a class="ae kf" href="http://host.robots.ox.ac.uk/pascal/VOC/" rel="noopener ugc nofollow" target="_blank"> PASCAL VOC </a>，或者<a class="ae kf" href="http://cocodataset.org/#home" rel="noopener ugc nofollow" target="_blank"> MS COCO </a>，或者<a class="ae kf" href="https://www.cityscapes-dataset.com/" rel="noopener ugc nofollow" target="_blank"> Cityscapes </a>，这取决于你想要解决什么问题。</p><p id="0ae2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是这样的话，那么您的大部分工作就完成了，因为这些存储库已经为您创建了 train、val 和 test 集。你所要做的就是下载它们，并把它们放到相关的目录中[更多细节见下文]。</p><p id="8152" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您希望在自己的数据集上运行图像分割模型，请参考以下内容:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/d24c80456f08ae54f24a0de68f6b7ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*UHKgtjiJMgkY9oPKUXQjlg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Structure of your data</figcaption></figure><p id="d39a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<strong class="ki iu"> mask_001.png </strong>对应<strong class="ki iu"> frame_001.png </strong>的掩码，以此类推。</p><p id="94fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些已经在使用我上面提到的公共数据集的人来说，你所要做的就是保持上面提到的目录结构。</p><p id="5597" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于其他使用自己的数据集的人，您需要编写一个脚本来完成这项工作。我写了一个给你参考:</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7fae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们浏览一下这段代码。</p><p id="7177" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我假设所有的图像都在“帧”目录中，相应的蒙版在“蒙版”目录中，都在<code class="fe mp mq mr ms b">DATA_PATH</code>中</p><p id="ac32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随机化 train、test 和 val 分区的一个好方法是列出文件，<strong class="ki iu">按 id 对它们进行排序</strong>并对它们进行洗牌【注意使用一个恒定的随机种子——改变的种子将在洗牌中产生改变的顺序】。</p><p id="4c7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是线<strong class="ki iu">23–34</strong>所实现的。</p><p id="3a3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们分别为我们的训练集、val 集和测试集使用一个<strong class="ki iu">70–20–10</strong>比率。这是通常使用的测试，尽管<strong class="ki iu">60–30–10</strong>或<strong class="ki iu">80–10–10</strong>并非闻所未闻。这是 Python 中一个简单的列表索引操作。</p><p id="c2bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在第<strong class="ki iu">39–44</strong>行中这样做。</p><p id="ae0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随后的几行运行一个 list comprehension 来遍历所有帧，并简单地将训练帧添加到<strong class="ki iu"> train_frames </strong>，将验证帧添加到<strong class="ki iu"> val_frames </strong>，将测试帧添加到<strong class="ki iu"> test_frames </strong>。</p><p id="2aa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有了包含图像 id 的必要列表。但是，我们仍然需要将这些列表中的图像保存到相应的[正确]文件夹中。函数<strong class="ki iu"> add_frames() </strong>和<strong class="ki iu"> add_masks() </strong>对此有所帮助。</p><p id="cf4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您可能已经猜到的，有多种方法可以做到这一点。你可以通过实验找到最快的<strong class="ki iu"><em class="mh"/></strong><em class="mh"/>的方法，但是我发现了一个相当有效的方法:</p><ol class=""><li id="027a" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">从两个元组列表开始。元组构成了图像列表，以及它们相应的目录名。将这些<strong class="ki iu"> frame_folders </strong>和<strong class="ki iu"> mask_folders </strong>，前者保存我们所有帧列表的细节——train、val、test——后者保存我们所有 mask 列表的细节。</li><li id="99f0" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">遍历<strong class="ki iu"> frame_folders </strong>和<strong class="ki iu"> mask_folders【一个接一个】</strong>，使用<strong class="ki iu"> map() </strong>函数将每张图片分别映射到<strong class="ki iu"> add_frames() </strong>和<strong class="ki iu"> add_masks() </strong>函数。我使用 map 代替琐碎的循环，只是因为 Python 的内置<strong class="ki iu"> map() </strong>比<em class="mh">快得多。我还没有测试它更快的确切顺序，如果有读者这样做，我会很高兴。</em></li></ol><p id="046e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于 1000 个图像[+1000 个遮罩]的非常小的数据集，设置文件夹只需不到一分钟的时间。一个很好的实验是找到更快的方法来做到这一点。我很想听听你的想法。</p><p id="eed8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就有了数据集！</p><p id="9efc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第 1 部分到此结束。</p><p id="c6d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第 2 部分中，我们将研究图像分割管道的另一个重要方面——为训练生成批量图像。</p><p id="9d4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程的第一部分，我们学习了如何准备和组织我们的图像分割任务中使用的数据。在这一部分，我们将我们的任务向前推进了一步——生成这些图像。</p><h1 id="99b8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第 2 部分:发电机</h1><h1 id="6076" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Keras 图像数据生成器</h1><p id="7bf5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了训练你的模型，理想情况下你需要生成一批图像来支持它。当你这样做的时候，你可能想对所有的图像进行普通的操作——像缩放、旋转、裁剪和移动等操作。这被称为<em class="mh">数据增强</em>。事实上，一个非常常见的做法是将所有图像的大小调整为一个形状，以使训练过程统一。</p><p id="addd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，数据扩充不会<em class="mh">改变</em>你的图像——它只是创建了同一图像的另一种表示。想象一下，如果有人给你拍了一张照片，然后将这张照片旋转了某个角度。这是两张不同的图片，但是图片的对象【你】没有变化。</p><p id="17c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这一点，我们使用 Keras 的<a class="ae kf" href="https://keras.io/preprocessing/image/" rel="noopener ugc nofollow" target="_blank"> ImageDataGenerator </a>。</p><p id="f41b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据文件:</p><blockquote class="nh ni nj"><p id="24ba" class="kg kh mh ki b kj kk kl km kn ko kp kq nk ks kt ku nl kw kx ky nm la lb lc ld im bi translated">通过实时数据扩充生成批量张量图像数据。数据将(分批)循环。</p></blockquote><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d103" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们分别创建我们的训练和验证生成器对象。您可以看到，训练图像将通过重新缩放、水平翻转、剪切范围和缩放范围得到增强。</p><p id="951b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这些操作意味着什么的描述，更重要的是，它们看起来像什么，到<a class="ae kf" rel="noopener" target="_blank" href="/image-augmentation-examples-in-python-d552c26f2873">这里</a>。</p><blockquote class="nh ni nj"><p id="a9a3" class="kg kh mh ki b kj kk kl km kn ko kp kq nk ks kt ku nl kw kx ky nm la lb lc ld im bi translated">当谈到如何初始化对象时，没有唯一正确的答案。这取决于谁在设计它们，以及他的目标是什么。</p></blockquote><p id="aeae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们的生成器对象已经创建好了，我们使用非常有用的<code class="fe mp mq mr ms b">flow_from_directory():</code>来启动生成过程</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要向 Keras 提供的只是目录路径和批处理大小。还有其他的选择，但是现在，这已经足够让你开始了。</p><p id="836c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，一旦我们分别有了训练集和验证集的框架和掩码生成器，我们就<strong class="ki iu"> zip() </strong>它们一起创建:</p><p id="8061" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">a) <strong class="ki iu"> train_generator </strong>:训练帧和掩码的生成器。</p><p id="cf92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">b) <strong class="ki iu"> val_generator </strong>:验证帧和掩码的生成器。</p><h1 id="4930" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建您自己的数据生成器</h1><p id="9188" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在设计生成器时，Keras ImageDataGenerator 绝不是唯一的选择。自定义生成器也经常使用。这些为设计者提供了更大的选择灵活性。请参见下面的示例:</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a07e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经决定让所有图像的大小为(512 * 512 * n)，其中 n = 3，如果它是正常的 RGB 图像，n = 1，用于该图像的相应蒙版，这显然是灰度图像。</p><p id="8246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们初始化两个数组来保存每个图像(和每个遮罩)的细节，这将是三维数组本身。所以，<strong class="ki iu"> img </strong>和<strong class="ki iu">遮罩</strong>是数组的数组。</p><p id="70bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<strong class="ki iu"> yield </strong>的简单目的是生成一批图像，而不是使用<strong class="ki iu"> return </strong>一次生成所有图像。关于何时使用其中一个而不是另一个的清晰解释，请参见<a class="ae kf" href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do" rel="noopener ugc nofollow" target="_blank">本</a>。</p><p id="a3c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们创建我们的训练和验证生成器，通过一次 传递训练图像、遮罩路径和验证图像、遮罩路径以及批处理大小<strong class="ki iu">。</strong></p><p id="0e5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在这种情况下，我们并没有即时使用随机变换。假设您正在处理一个图像分割问题，其中要分割的对象的位置也很重要。你还会使用旋转、缩放和移动吗？精神食粮。</p><blockquote class="nh ni nj"><p id="5e6e" class="kg kh mh ki b kj kk kl km kn ko kp kq nk ks kt ku nl kw kx ky nm la lb lc ld im bi translated">归根结底，这都是个人的选择。这两种方法都有效。在特定情况下，人们可能会发现一种方法比另一种更有用，反之亦然。</p></blockquote><p id="221a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！现在我们已经准备好了生成器对象。</p><p id="f93d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">训练时间到了！</p><h1 id="4e6e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第 3 部分:培训</h1><p id="e02b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在前两节中，我们学习了如何准备数据，以及如何创建图像生成器来帮助培训。在这最后一部分，我们将看到如何使用这些生成器来训练我们的模型。</p><p id="6482" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分将结束我们的整个管道。</p><p id="ea15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始训练之前，我们需要决定使用哪种架构。幸运的是，大多数流行的都已经实现了，并免费提供给公众使用。一些例子包括:</p><ol class=""><li id="5e9e" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">Keras <a class="ae kf" href="https://github.com/zhixuhao/unet/blob/master/model.py" rel="noopener ugc nofollow" target="_blank"> UNet </a>实施</li><li id="fcef" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">Keras <a class="ae kf" href="https://github.com/aurora95/Keras-FCN/blob/master/models.py" rel="noopener ugc nofollow" target="_blank"> FCNet </a>实现。</li></ol><p id="adac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始时，您不必太担心这些体系结构中的差异，以及在哪里使用什么。到目前为止，您可以简单地将这个<strong class="ki iu"> model.py </strong>文件放在您的工作目录中，并将其导入到<strong class="ki iu"> train.py </strong>中，这将是培训代码所在的文件。</p><p id="f6af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望您的工作目录如下所示:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2a438c0ab9acd826e0f2c32204053aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*rW90_404RUy4vIrlV_P9EQ.png"/></div></figure><p id="e0b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意新的代码文件，以及我们之前看到的数据目录。</p><p id="e899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您正在使用<strong class="ki iu"> FCNet_VGG16_32s </strong>，让我们来看看加载、编译和运行模型的一行程序。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ed54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在必要的导入之后，第<strong class="ki iu">8–13</strong>行初始化完全取决于您的数据集和您选择的输入的变量——例如:您决定的批量大小，以及您的模型将训练的时期数。</p><p id="a634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">线<strong class="ki iu"> 15 </strong>初始化路径，每个时期后的权重[一个<strong class="ki iu"> .h5 </strong>文件]将被保存到该路径。</p><p id="b96e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第<strong class="ki iu">17–22 行</strong>是加载和编译模型的必要步骤。请注意，我没有指定使用什么度量标准。对于图像分割任务，一个流行的度量是<strong class="ki iu">骰子系数【反之，骰子损失】</strong>。这里可以找到一个很好的实现<a class="ae kf" href="https://gist.github.com/wassname/7793e2058c5c9dacb5212c0ac0b18a8a" rel="noopener ugc nofollow" target="_blank"/></p><p id="4634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第<strong class="ki iu">24–32</strong>行也是样板 Keras 代码，封装在一系列称为<a class="ae kf" href="https://keras.io/callbacks/" rel="noopener ugc nofollow" target="_blank">回调</a>的操作下。</p><p id="d7cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅当满足<strong class="ki iu">模式</strong>参数时，我们才使用模型检查点来保存权重。要了解什么是<strong class="ki iu">监视器</strong>和<strong class="ki iu">模式</strong>参数，请继续阅读。</p><p id="1222" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们确保我们的模型不会在不必要的长时间内训练，例如:如果损失在连续的时期内没有显著减少，我们设置一个<strong class="ki iu">耐心</strong>参数，在我们的损失没有显著减少的一定数量的时期后自动停止训练。当我提到“显著”时，我指的是<strong class="ki iu"> min_delta </strong>参数。在这种情况下，我们检查我们的损失是否至少减少了 0.1%。在这种情况下，我们的耐心是<strong class="ki iu"> 3 </strong>，这是连续<em class="mh">个</em>周期的数量，在此之后，如果损失没有减少至少 0.1，训练将自动停止。</p><p id="0f49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">监视器</strong>参数定义了您想要检查其值的指标——在我们的例子中，是骰子损失。<strong class="ki iu">模式</strong>参数定义了训练停止的时间，如果监控量减少，则为<strong class="ki iu">【最大】</strong>，如果增加，则为<strong class="ki iu">【最小】</strong>。</p><p id="df71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果你在监控精度，<strong class="ki iu">模式</strong>应该是<strong class="ki iu">最大</strong>。但是如果你在监控<strong class="ki iu">均方差</strong>，模式将会是<strong class="ki iu">最小</strong>。</p><p id="a05e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这整个现象叫做<a class="ae kf" href="https://keras.io/callbacks/#earlystopping" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"/></a>。希望到现在为止，你已经理解了<em class="mh">为什么这么叫</em>了。</p><p id="9b95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第 34 行是训练步骤。我们传递所有需要的输入，包括:</p><p id="d506" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">a)训练和验证图像生成器，如前所述。</p><p id="7076" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">b)历元的数量。</p><p id="7d52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">c)每个时期的步骤数取决于图像总数和批次大小。</p><p id="7fcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">d)最后，我们的回调列表，包括模型检查点和提前停止的条件。</p><p id="791c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后我们调用<a class="ae kf" href="https://keras.io/models/sequential/#fit_generator" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> fit_generator </strong> </a>在这些生成器上进行训练。</p><p id="4b59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">训练开始了！</p><p id="ca9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦训练完成，您可以使用<strong class="ki iu">保存</strong>功能保存检查点架构及其所有权重。你可以随便给它起什么名字。</p><h1 id="2992" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="6b13" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这个由三部分组成的系列中，我们介绍了图像分割任务的整个 Keras 流程。从构建数据，到创建图像生成器，再到最终训练我们的模型，我们已经为初学者介绍了足够多的内容。当然，我们还可以做更多的事情。</p><p id="001c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以尝试不同的架构、不同的超参数(比如使用不同于<strong class="ki iu"> Adam </strong>的优化器)、不同的停止条件(使用<strong class="ki iu">耐心</strong>参数)等等。</p><p id="31d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个好主意是为<strong class="ki iu">不同的</strong>超参数绘制提前停止之前的时期数<strong class="ki iu">，评估度量值，并检查是否存在任何最佳超参数-模型-时期组合。</strong></p><p id="f517" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这个系列是可以理解的，如果有任何部分不清楚，我很乐意听到你的问题。</p><p id="2407" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快乐深度学习！</p></div></div>    
</body>
</html>