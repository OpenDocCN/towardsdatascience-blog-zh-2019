<html>
<head>
<title>5 Python Packages a Data Scientist can’t live without</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家离不开的 5 个 Python 包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-python-packages-a-data-scientist-cant-live-without-531566b93c90?source=collection_archive---------21-----------------------#2019-09-04">https://towardsdatascience.com/5-python-packages-a-data-scientist-cant-live-without-531566b93c90?source=collection_archive---------21-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e1e76aa2a1f3290659b93783d93d32e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZXyVzO8Jc7qRsgXCRh4og.png"/></div></div></figure><div class=""/><div class=""><h2 id="732d" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">介绍性概述</h2></div><p id="ac64" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Python 是一种通用语言，因此，它提供了大量的扩展，从科学编程到数据可视化，从统计工具到机器学习。</p><p id="9f28" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">了解每个可用的扩展几乎是不可能的，但是如果你的任务包括分析数据并在其上建立机器学习模型，那么有几个扩展是至关重要的。</p><p id="c10e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，在这篇文章中，我将详述 5 个主要的包，它们将使您的 Python 变得非常通用，它们是:</p><p id="89d1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以我们开始吧！</p><h1 id="9e4a" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">Numpy</h1><p id="9e68" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">Numpy 是一个科学计算包。它允许您执行任何种类的数学和统计操作。特别是(这也是为什么它是机器学习的基础)，它允许你非常快速和容易地执行 N 维计算。任何时候你被要求操作向量和矩阵，你知道你必须使用 Numpy 来达到这个目的。</p><p id="d271" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在让我们看一些例子。</p><p id="9406" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Numpy 的主要对象是同构多维数组，它可能看起来像向量(如果维度是 n，1)或矩阵(如果维度是 n，m)。让我们创建包含 1，2，3 的第一个数组:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4549" class="mv lq je mr b gy mw mx l my mz">import numpy as np<br/>a=np.array([1,2,3])<br/>a<br/><br/>Output: array([1, 2, 3])</span></pre><p id="2211" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以用以下方法检查这个数组的一些属性:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="064e" class="mv lq je mr b gy mw mx l my mz">a.shape<br/>Output: (3,)<br/><br/>a.dtype<br/>Output: dtype('int32')<br/><br/>type(a)<br/>Output: numpy.ndarray</span></pre><p id="f6a4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以通过指定组件的数量和形状来初始化数组。也就是说，如果我想创建一个数字从 0 到 11 的 3×4 矩阵，我将写:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b7bc" class="mv lq je mr b gy mw mx l my mz">b=np.arange(12).reshape(3,4)<br/>b<br/><br/>Output: array([[ 0,  1,  2,  3],<br/>       [ 4,  5,  6,  7],<br/>       [ 8,  9, 10, 11]])</span></pre><p id="f330" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你也可以把不是数组的对象转换成数组，比如列表。每当你需要计算列表项时，这是非常有用的。假设你想减去这两个列表:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3647" class="mv lq je mr b gy mw mx l my mz">list_1=[1,2,3]<br/>list_2=[4,5,6]<br/>list_2-list_1<br/><br/>---------------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-11-4c6e19f7626c&gt; in &lt;module&gt;<br/>      1 list_1=[1,2,3]<br/>      2 list_2=[4,5,6]<br/>----&gt; 3 list_2-list_1<br/><br/>TypeError: unsupported operand type(s) for -: 'list' and 'list'</span></pre><p id="6e7e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如你所见，因为你不能减去两个列表，所以出现了一个错误。但是，如果你使用这个技巧:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cfb6" class="mv lq je mr b gy mw mx l my mz">np.asarray(list_2)-np.asarray(list_1)<br/><br/>Output: array([3, 3, 3])</span></pre><p id="eb46" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">问题绕过了！</p><h1 id="1eb7" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">熊猫</h1><p id="bd10" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">Pandas 提供数据结构和数据分析工具，这些工具对于您的数据进行清理和用于机器学习任务是必不可少的。</p><p id="cb81" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">pandas 中的主要对象是数据帧，它只是结构化的数据集，可以很容易地修改和访问。您可以创建或导入(从 web、csv 文件、文本文件等)您的数据框架。</p><p id="62c5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们从头开始创建一个:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="388b" class="mv lq je mr b gy mw mx l my mz">import pandas as pd <br/><br/>data = [['alex', 10], ['tom', 15], ['jim', 14]] <br/>df = pd.DataFrame(data, columns = ['Name', 'Age']) <br/> <br/>df</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/77e7ff019d77eb5bc7dde98e1fb6fa88.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/0*PXJuWaT4NjfjNKbU"/></div></figure><p id="9d4d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以访问这个 df 的元素，因为它是一个矩阵:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e7d6" class="mv lq je mr b gy mw mx l my mz">df[:1] #showing only the first row</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/000e60a8b6ddac46086b8bcf4e39731c.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*VsBM2nLV76cyCFiw"/></div></figure><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4b45" class="mv lq je mr b gy mw mx l my mz">df.iloc[:,1] </span><span id="37bf" class="mv lq je mr b gy nc mx l my mz">Output: <br/>0    10<br/>1    15<br/>2    14<br/>Name: Age, dtype: int64</span></pre><p id="8506" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">熊猫数据框架的所有列都是系列对象:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6935" class="mv lq je mr b gy mw mx l my mz">type(df['Age']) <br/>Output: pandas.core.series.Series</span></pre><p id="1033" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以向数据集追加新列，并设置索引:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="08fe" class="mv lq je mr b gy mw mx l my mz">g=['M','M','M']<br/>df['Gender']=g<br/>df.set_index('Name',inplace=True)<br/>df</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c4ed0a0f97e68a3efe924a3bd586477c.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/0*iU1bCxu2puVK6fLJ"/></div></figure><p id="6102" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Pandas 是处理大量数据的基础，因为它还能够总结相关信息(如缺失值、异常值、平均值和频率等)。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5a57" class="mv lq je mr b gy mw mx l my mz">df.isnull().sum() #for missing values </span><span id="acdc" class="mv lq je mr b gy nc mx l my mz">Output: <br/>Age       0<br/>Gender    0<br/>dtype: int64</span><span id="3bfc" class="mv lq je mr b gy nc mx l my mz">df.describe()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/149d7cc215cbd4eac00f4ac8d37debd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/0*pfJVB9GWUkdex9f4"/></div></figure><h1 id="2ffd" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">Matplotlib</h1><p id="e6da" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">Matplotlib 提供了不同的数据可视化工具。它不是 Python 中唯一可用的可视化包，然而它是最直观的，并且能生成非常好的结果。</p><p id="2863" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们看看如何绘制不同的图表:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cd98" class="mv lq je mr b gy mw mx l my mz">import matplotlib.pyplot as plt<br/>import numpy as np<br/><br/><br/>men_means = [20, 34, 30, 35, 27]<br/><br/>x = np.arange(len(labels)) <br/><br/>fig, ax = plt.subplots()<br/>ax.bar(x - width/2, men_means, width, label='Men')<br/>ax.set_title('Men Means')</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/76ae7e8e9ca9eda26fc6945cc7db147e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wl419tHgblfWT7Td"/></div></div></figure><p id="b0cf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以在同一个图表中显示多个条形:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3050" class="mv lq je mr b gy mw mx l my mz">import matplotlib<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/><br/><br/>men_means = [20, 34, 30, 35, 27]<br/>women_means = [25, 32, 34, 20, 25]<br/><br/>x = np.arange(len(labels)) <br/><br/>fig, ax = plt.subplots()<br/>rects1 = ax.bar(x - width/2, men_means, width, label='Men')<br/>rects2 = ax.bar(x + width/2, women_means, width, label='Women')<br/>ax.set_title('Men and Women Means')</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/2285bae66bdb9cb18243f6b6b30383f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r66Q-fP9b_2-4RU_"/></div></div></figure><p id="9429" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，让我们用直方图和正态分布图近似来模拟正态随机变量:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6d63" class="mv lq je mr b gy mw mx l my mz">import matplotlib.pyplot as plt<br/>mu, sigma = 0, 0.1 # mean and standard deviation<br/>s = np.random.normal(mu, sigma, 1000)<br/>count, bins, ignored = plt.hist(s, 30, normed=True)<br/>plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *np.exp( - (bins - mu)**2 / (2 * sigma**2) ),linewidth=2, color='r')<br/>plt.show()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/73ff3fe1dd9a80c3627a1e66bfca9391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tzZfCQz0BgcTm1el"/></div></div></figure><p id="31a9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在想象一下，我们要绘制一个调查结果，让人们说出他们最喜欢的意大利面食。调查的结果是:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ae99" class="mv lq je mr b gy mw mx l my mz">import matplotlib.pyplot as plt<br/><br/><br/>labels = 'Gnocchi', 'Tortellini', 'Spaghetti', 'Penne'<br/>sizes = [15, 30, 45, 10]<br/>explode=(0,0,0,0)<br/><br/>fig1, ax1 = plt.subplots()<br/>ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',<br/>        shadow=True, startangle=90)<br/>ax1.axis('equal')  <br/><br/>plt.show()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fc0e02fcf908b7675274eb2522281c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*o37dHshDzFKft-C4"/></div></figure><p id="dac8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您也可以使用“爆炸”选项来强调最受欢迎的答案:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5e69" class="mv lq je mr b gy mw mx l my mz">explode=(0,0,0.1,0)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/902d03edfcbe650124e8c9797afeaddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/0*TAGhXSrg6hBmgW69"/></div></figure><p id="207e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">作为一名数据科学家，数据可视化至关重要，因为您总是需要以直观而强大的方式展示您的结果。此外，甚至在开始构建模型之前，相关的图表通常对识别数据中的模式很有用，因此它们可能会建议您应该运行哪种分析。</p><h1 id="14d2" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">sci kit-学习</h1><p id="fe17" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">这可能是机器学习最重要的包，因为它提供了所有的算法，从监督到非监督，从分类到回归。此外，它包括 ROC、MSE R 平方等评估指标，这些指标将在每次算法训练后自动计算。</p><p id="ae2c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们来看一个非常简单的 ML 任务示例，使用波士顿房价数据集，并尝试仅针对一个变量对价格进行建模，以便我们可以将其可视化。由于这是一项回归任务(目标变量“价格”是连续的)，我们将使用<a class="ae nk" rel="noopener" target="_blank" href="/simple-linear-regression-with-python-1b028386e5cd">简单线性回归</a>:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="22d1" class="mv lq je mr b gy mw mx l my mz">import pandas as pd <br/>from sklearn.datasets import load_boston<br/><br/>dataset = load_boston()<br/>df = pd.DataFrame(dataset.data, columns=dataset.feature_names)<br/>df['target'] = dataset.target<br/><br/>df.head()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/3ef8673482e36ceed78df244fcf2d194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N3xQ6uwmZYnFCOqN"/></div></div></figure><p id="fe80" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由于我们想要建立一个简单的线性回归(只有一个特征)，我们需要将维数从 13 减少到 1，并且在不丢失相关信息的情况下，我们需要运行一个<a class="ae nk" rel="noopener" target="_blank" href="/pca-eigenvectors-and-eigenvalues-1f968bc6777a">主成分分析</a>:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="18f8" class="mv lq je mr b gy mw mx l my mz">from sklearn.decomposition import PCA   <br/>pca = PCA(1)    <br/>projected = pca.fit_transform(dataset.data)  <br/>print(dataset.data.shape)  <br/>print(projected.shape) <br/><br/>Output:<br/>(506, 13)<br/>(506, 1)</span></pre><p id="5688" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">很好，现在让我们导入并训练我们的模型:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5dac" class="mv lq je mr b gy mw mx l my mz">from sklearn.model_selection import train_test_split  <br/>X_train, X_test, y_train, y_test = train_test_split(projected, dataset.target, random_state=0)<br/>from sklearn.linear_model import LinearRegression  <br/>lm = LinearRegression()  <br/>lm.fit(X_train,y_train)  <br/>y_pred = lm.predict(X_test)<br/><br/>#let's visualize the results<br/><br/>plt.scatter(X_test, y_test,  color='black')  <br/>plt.plot(X_test, y_pred, color='blue', linewidth=3)  <br/>plt.xticks(())  <br/>plt.yticks(())  <br/>plt.xlabel('First Principal component')  <br/>plt.ylabel('price')   <br/>plt.show()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/0c56f614e250f83ca25e18814225983b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-9Pocu28AuRN2IHT"/></div></div></figure><p id="5638" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以要求对我们算法的性能进行“反馈”:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="beb7" class="mv lq je mr b gy mw mx l my mz">from sklearn.metrics import mean_squared_error, r2_score  <br/>print("MSE: {:.2f}".format(mean_squared_error(y_test, y_pred)))  <br/>print("R2: {:.2f}".format(r2_score(y_test, y_pred)))<br/><br/>Output:<br/><br/>MSE: 73.04<br/>R2: 0.11</span></pre><p id="4088" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如你所见，用几行代码(不到 2 分钟)我们训练了一个 ML 模型，没有任何手工计算。</p><h1 id="af58" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">海生的</h1><p id="f802" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">和 matplotlib 一样，seaborn 是一个用于数据可视化的 Python 包。然而，它对于统计表示特别有用，并且它返回关于您的数据的更多相关信息。</p><p id="20b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">特别是，它非常方便地显示数据之间可能的相关性:通过<em class="nm"> pairplot() </em>和<em class="nm"> heatmap() </em>您可以初步了解所有特性(和目标)之间的关系:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ee02" class="mv lq je mr b gy mw mx l my mz">import seaborn as sns sns.set(style="ticks") <br/>df = sns.load_dataset("iris") <br/>sns.pairplot(df, hue="species")</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/125a28bb839ea0ddaca8cb95cac62b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0hThbZsInMZ7dot"/></div></div></figure><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="34e5" class="mv lq je mr b gy mw mx l my mz">sns.heatmap(df.corr(),annot=True)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0b8bf7394c262dbbd363f621ac10906c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/0*P2UK9IeucRcRXCso"/></div></figure><p id="5bce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以可视化数据的联合分布(比如，sepal_length 和 sepal_width 这两个特征):</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7f03" class="mv lq je mr b gy mw mx l my mz">sns.jointplot(x='sepal_length',y='sepal_width',data=df,size=5)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/11f1d641e034191fd582388b634896e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/0*nWGuBD-ddaf22CWF"/></div></figure><p id="1efd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，让我们看看每个物种的萼片长度值的分布:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="59ed" class="mv lq je mr b gy mw mx l my mz">ax=sns.boxplot(x='species',y='sepal_length',data=df) ax=sns.stripplot(x='species',y='sepal_length',data=df,jitter=True,edgecolor='gray')</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/59c49eb5df430d2a92f9c9d2d10512fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/0*OFjo_KvDTvJHIt1x"/></div></figure><p id="34d2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Seaborn 显示相关信息的速度非常快，功能非常强大，如果您正在执行探索性分析，它可能会节省您的大量时间，并为您提供关于最佳算法的线索。</p><p id="7e7a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不用说，涵盖这些方案的所有潜力几乎是不可能的。然而，了解哪些是您需要的工具以及如何在您的分析过程中部署它们是很重要的。作为一种良好的实践，请记住，无论您的分析需要何种计算，python 都提供了一种最快、最智能的方法:边做边发现是探索这些工具的一种非常好的策略。</p><p id="d47d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您有兴趣了解这些软件包的更多信息，这里有官方文档:</p><ul class=""><li id="3022" class="nq nr je kv b kw kx kz la lc ns lg nt lk nu lo nv nw nx ny bi translated"><a class="ae nk" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank">https://numpy.org/</a></li><li id="ef98" class="nq nr je kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated">【https://pandas.pydata.org/ T2】号</li><li id="d51f" class="nq nr je kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated">【https://matplotlib.org/ T4】</li><li id="1812" class="nq nr je kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><a class="ae nk" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/index.html</a></li><li id="7aa2" class="nq nr je kv b kw nz kz oa lc ob lg oc lk od lo nv nw nx ny bi translated"><a class="ae nk" href="https://seaborn.pydata.org/index.html" rel="noopener ugc nofollow" target="_blank">https://seaborn.pydata.org/index.html</a></li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="34c6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="nm">原载于 2019 年 9 月 4 日</em><a class="ae nk" href="https://datasciencechalktalk.com/2019/09/04/5-python-packages-a-data-scientist-cant-live-without/" rel="noopener ugc nofollow" target="_blank"><em class="nm">http://datasciencechalktalk.com</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>