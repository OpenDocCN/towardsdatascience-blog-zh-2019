<html>
<head>
<title>The Fastest and Easiest Way to Forecast Data on Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 上预测数据的最快最简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-fastest-and-easiest-way-to-forecast-data-on-python-d7ff29f3add6?source=collection_archive---------4-----------------------#2019-12-08">https://towardsdatascience.com/the-fastest-and-easiest-way-to-forecast-data-on-python-d7ff29f3add6?source=collection_archive---------4-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cf0940b5804e831a354f03961467fb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ooaESiGlO1FILkWU"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="11cb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">超快速预测:NBA 全明星预测得分。</h2></div><h1 id="8e61" class="ky kz jj bd la lb lc ld le lf lg lh li kp lj kq lk ks ll kt lm kv ln kw lo lp bi translated">||我||简介</h1><p id="f80e" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最近了解到<strong class="ls jk">先知</strong> ( <strong class="ls jk"> fbprophet) </strong>。如果你是一个处理时间序列数据的数据科学家，你会喜欢这个工具的。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/4b023361493a2a2944edd8986ac0947a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Bq3T1dCx8C7_4Zn"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@alexhaney?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Haney</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6342" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">对于那些不知道的人，Prophet 是由脸书开发的，通过其简单的 Sk-Learn 风格的 API 来帮助数据科学家自动预测时间序列数据。<br/> Prophet 可以由数据科学家进行微调，以实现更高的特异性。这是一个附加的预测模型，并假设每年的季节性影响是相似的。因此，它不会考虑太多，但它的准确性可以通过多种反馈机制随着时间的推移而提高。它的网站上说，Prophet 最适合处理有规律的季节性成分和大量历史数据可供参考的时间序列数据。</p><p id="04c2" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">由于它是开源的，任何人都可以下载和使用 Prophet。查看以下链接，了解有关 Prophet 的更多信息，以及为什么应该使用来预测时间序列数据:</p><div class="is it gp gr iu mw"><a href="https://facebook.github.io/prophet/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jk gy z fp nb fr fs nc fu fw ji bi translated">先知</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">Prophet 是一个用 R 和 Python 实现的预测程序。它速度很快，并提供完全自动化的预测…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">facebook.github.io</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ja mw"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="d174" class="ky kz jj bd la lb ns ld le lf nt lh li kp nu kq lk ks nv kt lm kv nw kw lo lp bi translated">|| II ||安装</h1><p id="2482" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我不会在这里详细介绍，但由于我第一次下载 Prophet 时确实遇到了一些问题，我将解释我是如何正确安装它的:</p><ul class=""><li id="304e" class="nx ny jj ls b lt mr lw ms lz nz md oa mh ob ml oc od oe of bi translated">首先，如果可行的话，您可以尝试一个简单的 pip 安装:<br/> <code class="fe og oh oi oj b">pip install fbprophet</code></li><li id="4e66" class="nx ny jj ls b lt ok lw ol lz om md on mh oo ml oc od oe of bi translated">然而，fbprophet 有一个主要的依赖项可能会导致问题:<code class="fe og oh oi oj b">pystan</code></li><li id="7afa" class="nx ny jj ls b lt ok lw ol lz om md on mh oo ml oc od oe of bi translated">理想情况下，你要在<code class="fe og oh oi oj b">fbprophet</code>:<br/><a class="ae jg" href="https://pystan.readthedocs.io/en/latest/installation_beginner.html" rel="noopener ugc nofollow" target="_blank">https://pystan . readthedocs . io/en/latest/installation _ beginner . html</a>之前 pip 安装<code class="fe og oh oi oj b">pystan</code></li><li id="c2ed" class="nx ny jj ls b lt ok lw ol lz om md on mh oo ml oc od oe of bi translated">WINDOWS: <code class="fe og oh oi oj b">pystan</code>需要一个编译器。遵循此处的说明<a class="ae jg" href="https://pystan.readthedocs.io/en/latest/windows.html" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="45e5" class="nx ny jj ls b lt ok lw ol lz om md on mh oo ml oc od oe of bi translated">最简单的方法是在 anaconda 中安装 Prophet。使用<code class="fe og oh oi oj b">conda install gcc</code>设置 gcc。然后安装 Prophet 是通过 conda-forge: <br/> <code class="fe og oh oi oj b">conda install -c conda-forge fbprophet</code></li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8387" class="ky kz jj bd la lb ns ld le lf nt lh li kp nu kq lk ks nv kt lm kv nw kw lo lp bi translated">|| III ||导入和数据</h1><p id="8ac6" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在本教程中，我们将使用以下库。除 Prophet 之外的所有基本库。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="c008" class="ot kz jj oj b gy ou ov l ow ox">import matplotlib.pyplot as plt<br/>import pandas as pd<br/>import numpy as np<br/>import os<br/>from fbprophet import Prophet</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/642684b502b25a8ac4c321117961bd07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6WV6dIjzXbZeUTh-"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@maxwinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Winkler</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="593c" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">关于数据集，我从<a class="ae jg" href="https://www.basketball-reference.com/players/h/hardeja01.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ls jk">这里</strong> </a>下载了詹姆斯·哈登近 10 年的比赛数据。基本上，我们有哈登几乎每一场比赛的数据(包括常规赛和季后赛)。)</p><p id="9510" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">要使用我正在使用的数据，请访问这个<a class="ae jg" href="https://github.com/dataxienxe/NBAplayersdata" rel="noopener ugc nofollow" target="_blank"> GitHub 页面</a>，下载 CSV 文件。</p><p id="24f8" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">下面，我已经导入了每个包含詹姆斯·哈登数据的 CSV 文件。<code class="fe og oh oi oj b">19rs</code>'将是“2019-2020 年常规赛”，<code class="fe og oh oi oj b">18po</code>'将是“2018-2019 年季后赛”，让你知道每个文件是如何命名的。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="5a33" class="ot kz jj oj b gy ou ov l ow ox">harden19rs = pd.read_csv('Downloads/NBAML/harden19rs.csv')<br/>harden19po = pd.read_csv('Downloads/NBAML/harden19po.csv')<br/>harden18rs = pd.read_csv('Downloads/NBAML/harden18rs.csv')<br/>harden18po = pd.read_csv('Downloads/NBAML/harden18po.csv')<br/>harden17rs = pd.read_csv('Downloads/NBAML/harden17rs.csv')<br/>harden17po = pd.read_csv('Downloads/NBAML/harden17po.csv')<br/>harden16rs = pd.read_csv('Downloads/NBAML/harden16rs.csv')<br/>harden16po = pd.read_csv('Downloads/NBAML/harden16po.csv')<br/>harden15rs = pd.read_csv('Downloads/NBAML/harden15rs.csv')<br/>harden15po = pd.read_csv('Downloads/NBAML/harden15po.csv')<br/>harden14rs = pd.read_csv('Downloads/NBAML/harden14rs.csv')<br/>harden14po = pd.read_csv('Downloads/NBAML/harden14po.csv')<br/>harden13rs = pd.read_csv('Downloads/NBAML/harden13rs.csv')<br/>harden13po = pd.read_csv('Downloads/NBAML/harden13po.csv')<br/>harden12rs = pd.read_csv('Downloads/NBAML/harden12rs.csv')<br/>harden12po = pd.read_csv('Downloads/NBAML/harden12po.csv')<br/>harden11rs = pd.read_csv('Downloads/NBAML/harden11rs.csv')<br/>harden11po = pd.read_csv('Downloads/NBAML/harden11po.csv')<br/>harden10rs = pd.read_csv('Downloads/NBAML/harden10po.csv')<br/>harden10po = pd.read_csv('Downloads/NBAML/harden10rs.csv')<br/>harden09rs = pd.read_csv('Downloads/NBAML/harden09rs.csv')</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="3787" class="ky kz jj bd la lb ns ld le lf nt lh li kp nu kq lk ks nv kt lm kv nw kw lo lp bi translated">|| IV ||清理数据</h1><p id="8328" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下一步非常重要，因为我们希望确保我们的数据包含所有必需的字段，否则我们将无法用它做很多事情。</p><p id="65c6" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">让我们从追加每个 CSV 文件开始。我们可以按时间顺序排列，因为有一个日期部分。首先，我们以下列方式附加每个文件:</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="c60b" class="ot kz jj oj b gy ou ov l ow ox">harden = harden19rs.append(harden19po, ignore_index=True, sort=True)<br/>harden = harden.append(harden18rs, ignore_index=True, sort=True)<br/>...<br/>harden = harden.append(harden09rs, ignore_index=True, sort=True)</span></pre><p id="e9db" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">接下来，我将重命名一些列，以便我们可以了解它们是什么，并删除不需要的列:</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="967f" class="ot kz jj oj b gy ou ov l ow ox">harden = harden.rename(columns={'Unnamed: 7': 'Game', 'MP':'Mins'})<br/>#harden['Game'] = pd.concat([harden['Unnamed: 7'].dropna(), harden['Game'].dropna()]).reindex_like(harden)<br/>#harden = harden.drop(columns=['Unnamed: 7'])<br/>harden = harden.drop(columns=['Unnamed: 5']) <br/>harden = harden.drop(columns=['▲'])<br/>harden = harden.sort_values(by=['Date'])<br/>harden = harden.reset_index(drop=True)</span></pre><p id="671c" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">最终数据集看起来有点像这样:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/fb60e20d7be6962448f0ec2371bc6a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ul9C8SwfK0YpoJQdHdqtIg.png"/></div></div></figure><p id="4c00" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">中间有一些列我们看不到，但大部分都是游戏统计。詹姆斯·哈登每场比赛都有不同的统计数据。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e269" class="ky kz jj bd la lb ns ld le lf nt lh li kp nu kq lk ks nv kt lm kv nw kw lo lp bi translated">|| V ||设置索引并删除空值</h1><p id="6429" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">因为我们希望数据按时间顺序排列，所以我们将日期设置为索引值，并将数据类型更改为 pandas datetime 变量:</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="ca75" class="ot kz jj oj b gy ou ov l ow ox">harden.set_index(‘Date’)<br/>harden[‘Date’] = pd.to_datetime(harden[‘Date’])</span></pre><p id="ca0d" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">接下来，我们希望删除数据中的任何值(即使我怀疑我们有任何值)。我们将使用 pandas dropna 函数，并删除一个所有值都为空的行。一旦我们这样做了，我们将重置索引，以确保它仍然是连贯的。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="c509" class="ot kz jj oj b gy ou ov l ow ox">harden = harden.dropna(how='all')<br/>harden = harden.reset_index(drop=True)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/f190d068fff7946ccab8a8fcb92839d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HcbRa_TAvOUD6ZxR"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@rapiana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ramiro Pianarosa</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6f28" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">接下来，我们还有另一个重要的数据清理步骤。在一些比赛中，詹姆斯·哈登是不活跃的，被禁赛，不比赛或不穿衣服。某些列将这些值“挂起”，而不是应该在那里的数值。</p><p id="13a6" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这样，我们就可以去掉哈登没有上场/着装或者不活动/停赛的所有排(场)。然而，这可能会大大减少我的数据量。因此，我将使用每个相应列的<em class="pb">中值替换这些值。</em></p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="e6ca" class="ot kz jj oj b gy ou ov l ow ox">for i in harden:<br/>    harden[i] = harden[i].replace('Inactive', <br/>    np.median(pd.to_numeric(harden[i], errors='coerce')))<br/>    <br/>for i in harden:<br/>    harden[i] = harden[i].replace('Did Not Play', <br/>    np.median(pd.to_numeric(harden[i], errors='coerce')))<br/>    <br/>for i in harden:<br/>    harden[i] = harden[i].replace('Did Not Dress', <br/>    np.median(pd.to_numeric(harden[i], errors='coerce')))<br/>    <br/>for i in harden:<br/>    harden[i] = harden[i].replace('Player Suspended', <br/>    np.median(pd.to_numeric(harden[i], errors='coerce')))<br/>    <br/>harden = harden.dropna(how='any')<br/>harden = harden.reset_index(drop=True)<br/>harden.set_index('Date')</span></pre><h2 id="e7df" class="ot kz jj bd la pc pd dn le pe pf dp li lz pg ph lk md pi pj lm mh pk pl lo pm bi translated">确保你的数据类型是正确的</h2><p id="670e" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">包含数字数据的列应该被明确指定该数据类型，以避免将来出现错误。因此，我将为每一列分配正确的数据类型。对浮点(十进制)列使用<code class="fe og oh oi oj b">downcast='float'</code>。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="dd81" class="ot kz jj oj b gy ou ov l ow ox">harden['3P'] = pd.to_numeric(harden['3P'])<br/>harden['3PA'] = pd.to_numeric(harden['3PA'])<br/>harden['AST'] = pd.to_numeric(harden['AST'])<br/>harden['BLK'] = pd.to_numeric(harden['BLK'])<br/>harden['DRB'] = pd.to_numeric(harden['DRB'])<br/>harden['ORB'] = pd.to_numeric(harden['ORB'])<br/>harden['FG'] = pd.to_numeric(harden['FG'])<br/>harden['FGA'] = pd.to_numeric(harden['FGA'])<br/>harden['PTS'] = pd.to_numeric(harden['PTS'])<br/>harden['PF'] = pd.to_numeric(harden['PF'])<br/>harden['TOV'] = pd.to_numeric(harden['TOV'])<br/>harden['STL'] = pd.to_numeric(harden['STL'])<br/>harden['TRB'] = pd.to_numeric(harden['TRB'])<br/>harden['3P%'] = pd.to_numeric(harden['3P%'], downcast='float')<br/>harden['FG%'] = pd.to_numeric(harden['FG%'], downcast='float')<br/>harden['FT%'] = pd.to_numeric(harden['FT%'], downcast='float')<br/>harden['GmSc'] = pd.to_numeric(harden['GmSc'], downcast='float')<br/>harden['FTA'] = pd.to_numeric(harden['FTA'])<br/>harden['FT'] = pd.to_numeric(harden['FT'])</span><span id="7ec4" class="ot kz jj oj b gy pn ov l ow ox">print(harden.dtypes)</span><span id="d08b" class="ot kz jj oj b gy pn ov l ow ox">Output: <br/>3P               int64<br/>3P%            float32<br/>3PA              int64<br/>AST              int64<br/>BLK              int64<br/>DRB              int64<br/>Date    datetime64[ns]<br/>FG               int64<br/>FG%            float32<br/>FGA              int64<br/>FT               int64<br/>FT%            float32<br/>FTA              int64<br/>GmSc           float32<br/>ORB              int64<br/>Opp             object<br/>PF               int64<br/>PTS              int64<br/>STL              int64<br/>TOV              int64<br/>TRB              int64<br/>dtype: object</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4907" class="ky kz jj bd la lb ns ld le lf nt lh li kp nu kq lk ks nv kt lm kv nw kw lo lp bi translated">|| VI ||预测数据</h1><p id="babb" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在是最精彩的部分。我们将使用 Prophet 预测该数据集中的任何列。输出将为我们提供预测的图像(图表)。为了创建图表，我们需要首先使 Prophet 模型符合我们的数据集。我们将把我们需要的列和日期列分开。在这种情况下，我预测点，所以我将采取' PTS '和' Date '列。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="1c1f" class="ot kz jj oj b gy ou ov l ow ox">df = harden[['PTS', 'Date']]</span></pre><p id="bd6b" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这些后续步骤非常重要，因为我们将使 prophet 模型符合我们的数据。我们想将我们的列重命名为“ds”(日期)和“y”(目标)。然后，我们用任何给定的<code class="fe og oh oi oj b">interval_width</code>来定义我们的先知模型。然后，我们用日期和目标变量来拟合我们的 Prophet 模型。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="15db" class="ot kz jj oj b gy ou ov l ow ox">jh = df.rename(columns={'Date': 'ds', 'PTS': 'y'})<br/>jh_model = Prophet(interval_width=0.95)<br/>jh_model.fit(jh)</span></pre><p id="b444" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">为了预测值，我们使用<code class="fe og oh oi oj b">make_future_dataframe</code>函数，指定周期数，频率为‘MS’，这是乘季节性。<br/>然后我们为预测创建 matplotlib 图。代码下面的图像向您展示了输出。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="fa31" class="ot kz jj oj b gy ou ov l ow ox">jh_forecast = jh_model.make_future_dataframe(periods=36, freq='MS')<br/>jh_forecast = jh_model.predict(jh_forecast)</span><span id="0f7f" class="ot kz jj oj b gy pn ov l ow ox">plt.figure(figsize=(18, 6))<br/>jh_model.plot(jh_forecast, xlabel = 'Date', ylabel = 'PTS')<br/>plt.title('James Harden Points')</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi po"><img src="../Images/bb2a4177bc76e23355db349a5799c2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I86LMZFH0-59AHwUky9lWg.png"/></div></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8176" class="ky kz jj bd la lb ns ld le lf nt lh li kp nu kq lk ks nv kt lm kv nw kw lo lp bi translated">|| VII ||比较多个预测</h1><p id="80d1" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，如果我想将詹姆斯·哈登的预测与扬尼斯·阿德托昆博、勒布朗·詹姆斯和科怀·伦纳德进行比较，会怎么样呢？</p><p id="3ea8" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">为此，我将所有的预处理放在一个函数中，这样我就可以预处理数据，而不用重复代码行。下面，我提供了包含所需功能的要点。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="97b6" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">一旦你处理了数据，我们就可以开始合并所有的帧，并绘制成如下图。</p><pre class="mn mo mp mq gt op oj oq or aw os bi"><span id="c657" class="ot kz jj oj b gy ou ov l ow ox">harden = harden.rename(columns={'Date': 'ds', 'PTS': 'y'})<br/>jh_model = Prophet(interval_width=0.95)<br/>jh_model.fit(harden)</span><span id="b1e4" class="ot kz jj oj b gy pn ov l ow ox">lebron = lebron.rename(columns={'Date': 'ds', 'PTS': 'y'})<br/>lj_model = Prophet(interval_width=0.95)<br/>lj_model.fit(lebron)</span><span id="936e" class="ot kz jj oj b gy pn ov l ow ox">giannis = giannis.rename(columns={'Date': 'ds', 'PTS': 'y'})<br/>ga_model = Prophet(interval_width=0.95)<br/>ga_model.fit(giannis)</span><span id="5ad4" class="ot kz jj oj b gy pn ov l ow ox">kawhi = kawhi.rename(columns={'Date': 'ds', 'PTS': 'y'})<br/>kl_model = Prophet(interval_width=0.95)<br/>kl_model.fit(kawhi)</span><span id="f6b5" class="ot kz jj oj b gy pn ov l ow ox">jh_forecast = jh_model.make_future_dataframe(periods=36, freq='MS')<br/>jh_forecast = jh_model.predict(jh_forecast)<br/>lj_forecast = lj_model.make_future_dataframe(periods=36, freq='MS')<br/>lj_forecast = lj_model.predict(lj_forecast)<br/>ga_forecast = ga_model.make_future_dataframe(periods=36, freq='MS')<br/>ga_forecast = ga_model.predict(ga_forecast)<br/>kl_forecast = kl_model.make_future_dataframe(periods=36, freq='MS')<br/>kl_forecast = kl_model.predict(kl_forecast)</span><span id="dd86" class="ot kz jj oj b gy pn ov l ow ox">hardens = ['harden_%s' % column for column in jh_forecast.columns]<br/>lebrons = ['lebron_%s' % column for column in lj_forecast.columns]<br/>kawhis = ['kawhi_%s' % column for column in kl_forecast.columns]<br/>gianniss = ['giannis_%s' % column for column in ga_forecast.columns]</span><span id="56a2" class="ot kz jj oj b gy pn ov l ow ox">merge_jh_forecast = jh_forecast.copy()<br/>merge_lj_forecast = lj_forecast.copy()<br/>merge_kl_forecast = kl_forecast.copy()<br/>merge_ga_forecast = ga_forecast.copy()</span><span id="d5c1" class="ot kz jj oj b gy pn ov l ow ox">merge_jh_forecast.columns = hardens<br/>merge_lj_forecast.columns = lebrons<br/>merge_kl_forecast.columns = kawhis<br/>merge_ga_forecast.columns = gianniss</span><span id="6716" class="ot kz jj oj b gy pn ov l ow ox">forecast = pd.merge(merge_jh_forecast, merge_lj_forecast, <br/>                    how = 'inner', left_on='harden_ds', right_on='lebron_ds')<br/>forecast = pd.merge(forecast, merge_kl_forecast, <br/>                    how = 'inner', left_on='lebron_ds', right_on='kawhi_ds')<br/>forecast = pd.merge(forecast, merge_ga_forecast, <br/>                    how = 'inner', left_on='kawhi_ds', right_on='giannis_ds')</span><span id="2f7b" class="ot kz jj oj b gy pn ov l ow ox">forecast = forecast.rename(columns={'harden_ds': 'Date'})<br/>forecast.head()</span><span id="fddb" class="ot kz jj oj b gy pn ov l ow ox">plt.figure(figsize=(10, 7))<br/>plt.plot(forecast['Date'], forecast['harden_yhat'], 'b-')<br/>plt.plot(forecast['Date'], forecast['lebron_yhat'], 'r-')<br/>plt.plot(forecast['Date'], forecast['kawhi_yhat'], 'g-')<br/>plt.plot(forecast['Date'], forecast['giannis_yhat'], 'y-')<br/>plt.legend(['Harden', 'Lebron', 'Kawhi', 'Giannis'])<br/>plt.xlabel('Date')<br/>plt.ylabel('Points')<br/>plt.title('Harden vs LeBron vs Giannis vs Kawhi');<br/>plt.show()</span></pre><p id="0a8f" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">最终输出应该如下所示:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pr"><img src="../Images/9681b9ca550c628ad9af54a92d2d2971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEWq9aJLW05Yg7brHT9vvQ.png"/></div></div></figure><p id="a1dc" class="pw-post-body-paragraph lq lr jj ls b lt mr kk lv lw ms kn ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">看起来詹姆斯·哈登场均得分超过了所有人，尽管詹尼斯有一些季节性高峰(也许他在周五表现不错)。下一次，我可能会写另一个教程，比较更多的球员与更多的特殊性。如果你有任何反馈/想法，请在评论中告诉我。</p><blockquote class="ps"><p id="889c" class="pt pu jj bd pv pw px py pz qa qb ml dk translated">感谢你的阅读！希望你学到了有用的东西。关注我，了解更多关于数据科学的内容！</p></blockquote></div></div>    
</body>
</html>