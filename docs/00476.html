<html>
<head>
<title>A shiny Web App from LEGO— truck + trailer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自乐高的闪亮网络应用——卡车+拖车</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-shiny-web-app-from-lego-truck-trailer-c977015bc6a9?source=collection_archive---------20-----------------------#2019-01-21">https://towardsdatascience.com/a-shiny-web-app-from-lego-truck-trailer-c977015bc6a9?source=collection_archive---------20-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="60c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何建造闪亮的“卡车”第 2 部分——让乐高“卡车”应用程序拉拖车。一个模块化闪亮应用的例子。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37510b2fb9fa3fb2c4215fdc93c49530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0Z7Ks2O4QRLXlWNdBcpfA.jpeg"/></div></div></figure><p id="cc01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在 2018 年 9 月的<a class="ae ln" href="https://rviews.rstudio.com/2018/09/04/how-to-build-shiny-trucks-not-shiny-cars/" rel="noopener ugc nofollow" target="_blank">中，我用了一个汽车隐喻来解释一个大规模的闪亮应用。RViews 发表了这篇文章。我将用一句话来概括这篇文章。在 R shiny 中构建大型应用程序(卡车)时，有许多事情需要记住。为了在一个应用程序中涵盖所有这些内容，我提供了这个教程。</a></p><p id="f705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在 https://github.com/zappingseb/biowarptruck<a class="ae ln" href="https://github.com/zappingseb/biowarptruck" rel="noopener ugc nofollow" target="_blank">下找到该应用的所有文件—文件夹:example_packaged</a></p><h2 id="5efa" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">摘要(如果您阅读 RViews 中的文章，请跳过)</h2><p id="a1b1" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我在 RViews 上写的文章告诉读者，任何闪亮的应用程序都有可能在某一天变得巨大。从头开始，它必须是精心策划的。此外，应该可以删除或添加应用程序的任何部分。因此它必须是模块化的。每个模块必须像乐高积木一样工作。乐高积木有不同的功能。这些砖块遵循一定的规则，这使得它们彼此粘在一起。这些规则我们称之为标准。像乐高积木一样设计的模块增加了你的灵活性。因此，你的模块的可重用性增加了。当你设置你的应用程序时，你可以添加无限数量的乐高积木。它可以生长。想象像汽车这样的小规模应用。大规模应用是卡车。这篇文章解释了如何建造一辆乐高卡车。</p><blockquote class="mm mn mo"><p id="7a0d" class="kr ks mp kt b ku kv jr kw kx ky ju kz mq lb lc ld mr lf lg lh ms lj lk ll lm ij bi translated">如果你用乐高组装你的车，更多不同的零件可以让它成为一辆卡车。</p><p id="bc01" class="kr ks mp kt b ku kv jr kw kx ky ju kz mq lb lc ld mr lf lg lh ms lj lk ll lm ij bi translated">如果你用标准化的模块构建你的应用程序，你可以灵活地插入更多的功能。</p></blockquote><h1 id="fb92" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">模块化的闪亮应用——从哪里开始？</h1><p id="d673" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">下图解释了模块化闪亮应用的想法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/7064860256cc144067fd0167e6242a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJ8j8BrQFbGEL0EvGeIvUw.jpeg"/></div></div></figure><p id="9f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你从一个闪亮的核心应用程序开始。把它看成你汽车的底盘。它是由乐高制成的。乐高制成的任何其他部分都可以粘在你的底盘上。这样的部件可以改变其功能。不同的模块将帮助你制造不同的汽车。此外，您希望有一个砖块说明(计划)。这个计划告诉我们该拿走哪些部分，以增加灵活性。砖块说明的背面可以包含相同砖块的不同型号。如果您可以从您的模块构建一个应用程序，您也可以构建一个包含相同模块的不同应用程序。如果你清楚这一点，我们可以开始在<a class="ae ln" href="https://shiny.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> R-shiny </a>开发我们的应用程序:</p><p id="9d88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实施规则:</p><ul class=""><li id="59b4" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm nk nl nm nn bi translated">每个模块是一个 R 包</li><li id="ae15" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">核心 R 包定义了砖块的标准化</li><li id="1432" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">核心应用是一个基本的闪亮应用</li><li id="70b5" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">砖块指令(计划)文件不在 R 中</li></ul><p id="b057" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么这些规则存在，读了这篇文章就会明白了。</p><h1 id="1c37" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">我们想要建立的应用程序</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/8a9d707fc67ddc8ecdf0da9843c1bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iGC8wDQZ10BB1VgBZlW-g.png"/></div></div></figure><p id="b665" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想要构建的应用程序将从一组用户输入中创建不同类型的输出。这些不同的输出将显示在应用程序中。此外，所有输出将进入一个<strong class="kt ir"> PDF </strong>文件。该示例将包括绘图模块中的两个绘图和表格模块中的一个表格。由于每个模块都是一个 R 包，您可以想象逐步添加更多的 R 包。在 shiny 中，很多输出都是可能的。这个应用程序的主要特点是可以添加越来越多的模块。更多的模块不会搞砸 PDF 报告功能或查看功能。在这个应用程序中，模块根本不交互。</p><h1 id="bc9f" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">核心 R 包</h1><p id="71b2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">核心包包含模块必须遵循的结构，以适应核心应用程序。有两种结构我们将定义为 R-S4 类。一个表示模块，另一个表示这些模块中的输出元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/905798c0ca425c9463a5b7ae5c5321e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIk70hbFIVsq6ILS19pwhg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk"><strong class="bd nz">Class diagram of the core application</strong>: The left side shows the reports. The app can generate each of those. Each contains a list of elements to go into the report (plots). The right-hand side contains the class definition of such elements. Each element is of kind AnyPlot. This class contains a call (plot_element) that produces the element upon calling evalElement.</figcaption></figure><p id="56b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于任务一，我们称这个对象(类)为报表。报告是我们在核心应用程序中定义的主要模块。它包含:</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="98a9" class="lo lp iq ob b gy of og l oh oi"><strong class="ob ir">plots </strong>— A list of all elements shown in the report <br/><strong class="ob ir">filename</strong> - The name of the output file (where to report to) <br/><strong class="ob ir">obs </strong>- The handling of the input value input$obs <br/><strong class="ob ir">rendered</strong> - Whether it shows up in the app right now</span></pre><p id="2d6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，Report 类还带有一些生成漂亮输出的功能。此外，它允许创建 PDF 报告。这些功能包含在方法 shinyElement()和 pdfElement()中。在<a class="ae ln" href="http://adv-r.had.co.nz/S4.html" rel="noopener ugc nofollow" target="_blank"> R-S4 </a>中，这看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e229" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们还要定义，如何构造这样的每个元素。因此，我们定义了一个类 AnyPlot，它携带一个表达式，因为它是唯一的槽。<code class="fe ol om on ob b">evalElement</code>方法将计算这个表达式。<code class="fe ol om on ob b">pdfElement</code>方法创建一个可以输出到 PDF 的输出。<code class="fe ol om on ob b">shinyElement</code>通过调用<code class="fe ol om on ob b">shiny::renderPlot()</code>创建一个 PlotOutput。<code class="fe ol om on ob b">logElement</code>方法将表达式写入日志文件。<a class="ae ln" href="http://adv-r.had.co.nz/S4.html" rel="noopener ugc nofollow" target="_blank"> R-S4 </a>代码显示如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="460b" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">核心应用程序</h1><p id="ffc2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了使这个例子简单，核心应用程序将包括所有的输入。这个应用程序的输出将是模块化的。核心应用程序必须完成以下任务:</p><ol class=""><li id="791b" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm oo nl nm nn bi translated">有一个显示模块的容器</li><li id="42f3" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oo nl nm nn bi translated">阅读计划—添加容器</li><li id="2d68" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oo nl nm nn bi translated">包括将模块打印成 PDF 的按钮</li><li id="9558" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oo nl nm nn bi translated"><em class="mp">想象一下还有一个按钮打印模块来”。png“，”。jpg“，”。xlsx" </em></li><li id="2457" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oo nl nm nn bi translated">包括输入</li></ol><h2 id="c62c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">显示模块</h2><p id="239b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">对于任务一，我们使用给定对象的<code class="fe ol om on ob b">shinyElement</code>方法，并将其插入到任何输出中。我为每个模块决定了一个选项卡输出。因此每个模块都在不同的选项卡中呈现。</p><h2 id="e8e5" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">阅读计划</h2><p id="f493" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">现在，应用程序的最难部分来了。正如我所说，我想增加两个模块。一个有图，一个有表。计划(config.xml)文件必须包含这些信息。所以我把它作为一个计划文件:</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="8643" class="lo lp iq ob b gy of og l oh oi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;modules&gt;<br/>  &lt;module&gt;<br/>    &lt;id&gt;module1&lt;/id&gt;<br/>    &lt;name&gt;Plot Module&lt;/name&gt;<br/>    &lt;package&gt;module1&lt;/package&gt;<br/>    &lt;class&gt;PlotReport&lt;/class&gt;<br/>  &lt;/module&gt;<br/>  &lt;module&gt;<br/>    &lt;id&gt;module2&lt;/id&gt;<br/>    &lt;name&gt;Text Output&lt;/name&gt;<br/>    &lt;package&gt;module2&lt;/package&gt;<br/>    &lt;class&gt;TableReport&lt;/class&gt;<br/>  &lt;/module&gt;<br/>&lt;/modules&gt;</span></pre></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/9557ffc7760b61caee8acf4acdb2287f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*gC9KOT8S0UiPO6pfGqgaVQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Construction plan of the web App</figcaption></figure><p id="c0b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到我有两个模块。每个模块都有一个包。在这个包中，一个类定义了(参见<a class="ae ln" href="http://www.hemingwayapp.com/#07bb" rel="noopener ugc nofollow" target="_blank">模块包</a>一节)输出。这个班是我们<strong class="kt ir">报</strong>班的子班。</p><p id="75e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该模块在我们的应用程序中显示为一个选项卡。我们将一步一步地完成这个过程。首先，我们需要一个函数来加载每个模块的包:</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="f100" class="lo lp iq ob b gy of og l oh oi">library(XML)<br/>load_module &lt;- function(xmlItem){<br/>  devtools::load_all(paste0("./",xmlValue(xmlItem[["package"]]))) <br/>}</span></pre><p id="0d1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们需要一个函数来从模块的信息中生成一个选项卡:</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="1ec5" class="lo lp iq ob b gy of og l oh oi">library(shiny)<br/>module_tab &lt;- function(xmlItem){<br/>  tabPanel(XML::xmlValue(xmlItem[["name"]]),<br/>           uiOutput(xmlValue(xmlItem[["id"]]))<br/>  )<br/>}</span></pre><p id="67c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了这两个函数，我们可以迭代 XML 文件并构建我们的应用程序。首先，我们需要一个像<code class="fe ol om on ob b">tabPanel(id='modules')</code>这样的 UI 中的<code class="fe ol om on ob b">TabPanel</code>。之后，我们可以将应用程序的配置读入<code class="fe ol om on ob b">TabPane</code>。因此我们使用<code class="fe ol om on ob b">appendTab</code>功能。函数<code class="fe ol om on ob b">XML::xmlApply</code>让我们遍历 XML (config.xml)的每个节点并执行这些任务。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="ae00" class="lo lp iq ob b gy of og l oh oi">configuration &lt;- xmlApply(xmlRoot(xmlParse("config.xml")),function(xmlItem){</span><span id="3542" class="lo lp iq ob b gy ox og l oh oi">    load_module(xmlItem)<br/>    <br/>    appendTab("modules",module_tab(xmlItem),select = TRUE)<br/>    <br/>    list(<br/>      name = xmlValue(xmlItem[["name"]]),<br/>      class = xmlValue(xmlItem[["class"]]),<br/>      id = xmlValue(xmlItem[["id"]])<br/>    )<br/>  })</span></pre><p id="949e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，每个模块都以静态方式加载到应用程序中。下一部分将讨论如何使其具有反应性。</p><h2 id="08a5" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">将内容呈现到面板中</h2><p id="3c0e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">对于面板的动态渲染，有必要知道一些输入。首先是用户选择的选项卡。<code class="fe ol om on ob b">input$modules</code>变量定义了选择的选项卡。此外，我们闪亮的应用程序的输出必须通过另一个输入更新，<code class="fe ol om on ob b">input$obs</code>。因此，在更改选项卡或更改<code class="fe ol om on ob b">input$obs</code>时，我们需要调用一个事件。这个事件将调用我们的 S4 对象的构造函数。在此之后，<code class="fe ol om on ob b">shinyElement</code>方法呈现输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/b93af9d61e89f65046d10dde6482be62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*US5Oh7A1Aoo7fkSzv75b-g.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">The module class gets reconstructed up on changes in the input$modules or input$obs</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="25c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">reactive <code class="fe ol om on ob b">report_obj</code>是一个可以调用我们<strong class="kt ir"> Report </strong>对象的构造函数的函数。对<code class="fe ol om on ob b">input$obs</code>和<code class="fe ol om on ob b">input$modules</code>使用<code class="fe ol om on ob b">observeEvent</code>功能，我们称之为反应式。这允许对用户输入做出反应。</p><h2 id="42af" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">从报告中导出 PDF 文件</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/a2f53ae2f70c182a99a66e76fb2e81da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uro1pbb1uZoQru7kGJyMbw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Adding a PDF render button to enable the download of PDF files.</figcaption></figure><p id="830f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ol om on ob b">pdfElement</code>函数将 S4 对象渲染为 PDF 文件。如果这样做很好，PDF 元素加起来就是下载按钮。</p><p id="9c64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个额外的标签检查 PDF 渲染是否成功。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="c28d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们完成了核心应用程序。可以在这里找到 app:<a class="ae ln" href="https://github.com/zappingseb/biowarptruck/blob/master/example_packaged/app.R" rel="noopener ugc nofollow" target="_blank">app。R </a>还有这里的核心包:<a class="ae ln" href="https://github.com/zappingseb/biowarptruck/tree/master/example_packaged/core" rel="noopener ugc nofollow" target="_blank">核心</a>。</p><p id="f50b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一步是把整辆卡车组装起来。</p><h1 id="07bb" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">模块包</h1><p id="f152" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">这两个模块包现在将包含两个类。两者都必须是类<strong class="kt ir"> Report 的子类。这些类中的每个元素必须是类的子类。</strong>下图中的红砖代表<strong class="kt ir">报告</strong>，黄砖代表<strong class="kt ir">任何地块。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/39ef8926a0f7c7111d3fbba476a8644d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7Wh6vJgGBwL5XnVAa5e_w.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Final app: The truck consists of a core app with a PlotReport and a TableReport. These consist of three AnyPlot elements that the trailer of the truck carries.</figcaption></figure><h2 id="7451" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">绘图包</h2><p id="e663" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">第一个模块包将生成散点图和直方图。两者都是类定义中<code class="fe ol om on ob b">contains='AnyPlot'</code>的<strong class="kt ir"> AnyPlot </strong>的子元素。<code class="fe ol om on ob b">PlotReport</code>是该包中<strong class="kt ir">报表</strong>的类。它在<code class="fe ol om on ob b">plots</code>槽中包含了这两个图。有关这些类的构造函数，请参见下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="6ec8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">桌子包装</h2><p id="cfe4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">表格包遵循与地块包相同的规则。主要区别在于<code class="fe ol om on ob b">plots</code>槽内只有一个元素。这个元素不是情节。这就是为什么它包含一个<code class="fe ol om on ob b">data.frame</code>调用作为它的表达式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="fa82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使内部的<code class="fe ol om on ob b">data.frame</code>调用闪亮，我们必须重写<code class="fe ol om on ob b">shinyElement</code>方法。我们将返回一个<code class="fe ol om on ob b">renderDataTable</code>输出，而不是返回一个<code class="fe ol om on ob b">renderPlot</code>输出。此外，<code class="fe ol om on ob b">pdfElement</code>方法必须返回一个<code class="fe ol om on ob b">gridExtra::grid.table</code>输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="4e87" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">包装优势</h2><p id="dfe4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">打包每个模块的一个主要优点是依赖关系的定义。描述文件指定了模块包的所有依赖关系。例如，表格模块需要<code class="fe ol om on ob b">gridExtra</code>包。核心 app 包需要<code class="fe ol om on ob b">shiny, methods, XML, devtools</code>。app 不需要额外的<code class="fe ol om on ob b">library</code>调用。任何同事都可以安装所有依赖项</p><h1 id="c69e" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">最后的话</h1><p id="2514" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">现在，您必须有工具来开始构建自己的大型闪亮应用程序。使用包将应用模块化。使用 S4 或任何其他面向对象的 R 风格将其标准化。使用 XML 或 JSON 文档设置应用程序。你可以走了。在一个目录中设置核心包和模块包。你可以用<em class="mp"> devtools </em>加载它们，并开始构建你的<em class="mp">闪亮的</em>文件<code class="fe ol om on ob b">app.R</code>。现在，您可以构建自己的应用程序来交换模块包。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/26764cfc6d53bef76194bb2a2ca28fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOESts4ESpL5ik7H8GxJRw.png"/></div></div></figure><p id="e204" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像每个孩子一样，你现在可以尽情地玩你的卡车了，你可以走了。我不能告诉你是建造更有趣还是滚动更有趣。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/5901ffa6e3c43aec5b3645bcb515fae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cK03RmRfxwiI88tlwQe1VA.png"/></div></div></figure><p id="c8ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">亲爱的读者:写下我在构建模块化闪亮应用程序方面的工作总是令人愉快的。感谢你一直读到这篇文章的结尾。如果你喜欢这篇文章，你可以在 <a class="ae ln" href="https://medium.com/p/c977015bc6a9" rel="noopener"> <em class="mp">中</em> </a> <em class="mp">或者在</em><a class="ae ln" href="https://github.com/zappingseb/biowarptruck" rel="noopener ugc nofollow" target="_blank"><em class="mp">github</em></a><em class="mp">上为它鼓掌。如有任何意见，请在此留言或在我的 LinkedIn 个人资料上留言</em><a class="ae ln" href="http://linkedin.com/in/zappingseb." rel="noopener ugc nofollow" target="_blank"><em class="mp">http://linkedin.com/in/zappingseb.</em></a></p><h1 id="7f9f" class="mt lp iq bd lq mu mv mw lt mx my mz lw jw na jx lz jz nb ka mc kc nc kd mf nd bi translated">进一步阅读</h1><ul class=""><li id="fa73" class="nf ng iq kt b ku mh kx mi la pb le pc li pd lm nk nl nm nn bi translated"><a class="ae ln" href="https://medium.com/@zappingseb/7-steps-that-make-custom-inputs-in-shiny-easy-504b303a2973" rel="noopener">如何在闪亮的应用中构建自定义输入</a></li><li id="b683" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">如何让人们在一小时内做好准备</li><li id="735b" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae ln" href="https://medium.com/datadriveninvestor/tutorial-an-app-in-r-shiny-visualizing-biopsy-data-in-a-pharmaceutical-company-f15f06395f3e" rel="noopener">教程:可视化活检数据的应用</a></li></ul></div></div>    
</body>
</html>