<html>
<head>
<title>How To Structure Your PyTorch Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建您的 PyTorch 项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-structure-your-pytorch-project-89310b8b2da9?source=collection_archive---------14-----------------------#2019-10-22">https://towardsdatascience.com/how-to-structure-your-pytorch-project-89310b8b2da9?source=collection_archive---------14-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个构建 PyTorch 培训代码的建议</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff0167ce84c25da5d123ee178a5ba454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBnlM0161Zyx-akt3uEb8w.png"/></div></div></figure><p id="df84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自从我开始训练深度神经网络，我就在想我所有的 Python 代码应该是什么结构。理想情况下，一个好的结构应该支持广泛的模型实验，允许在一个紧凑的框架中实现各种不同的模型，并且容易被每个阅读代码的人理解。您必须能够通过编码和重用各种数据加载器来使用来自不同数据源的数据。此外，如果模型支持在一个模型中组合多个网络(如 GANs 或原始 R-CNN 的情况)，那就更好了。该框架还应该具有足够的灵活性，以允许复杂的可视化(这是我在数据科学中的核心信念之一，即可视化使一切变得更容易，尤其是在计算机视觉任务的情况下)。</p><p id="6910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">深度学习框架的详细实现当然取决于您正在使用的底层库，无论是 TensorFlow、PyTorch 还是 CNTK。在这篇文章中，我将介绍我基于 PyTorch 的方法。然而，我认为通用结构同样适用于您正在使用的任何库。你可以在 https://github.com/branislav1991/PyTorchProjectFramework 的<a class="ae lq" href="https://github.com/branislav1991/PyTorchProjectFramework" rel="noopener ugc nofollow" target="_blank">找到整个资料库。</a></p><h1 id="9608" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">总体结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/eed62c7047c63eb669eec190f8b36170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CA6NihNCwRcqzf4Lx5m7GQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Project structure for our deep learning framework.</figcaption></figure><p id="c7d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的图片上(取自 VS code，我选择的 Python 编辑器)，你可以看到我为我的框架创建的一般文件夹结构。<strong class="kw iu">框架由一些启动脚本</strong> (train.py，validate.py，hyperopt.py)以及隐藏在文件夹内的库组成。<strong class="kw iu">数据集文件夹</strong>包含<strong class="kw iu">类和方法，用于加载各种类型的数据</strong>进行训练。<strong class="kw iu">损失文件夹</strong>可能包含额外的损失函数或验证指标。如果您的项目不需要任何自定义损失函数，您可能不需要此文件夹。<strong class="kw iu">模型文件夹</strong>是最重要的:它<strong class="kw iu">包含实际的模型</strong>。<strong class="kw iu">优化器文件夹</strong>包含定制优化器的代码。与 losses 文件夹一样，如果您没有任何自定义优化器，也可以忽略该文件夹。最后，<strong class="kw iu"> utils 文件夹包含了在整个框架中使用的各种实用程序</strong>，最著名的是<strong class="kw iu">可视化器</strong>。您还会注意到项目根文件夹中的 config_segmentation.json 文件。该文件包含培训所需的所有配置选项。</p><p id="e0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经猜到，训练是通过调用 train.py 脚本启动的。使用适当的配置文件作为命令行参数调用该脚本。它负责所有高级别的训练工作，例如加载训练和验证数据集以及模型，设置可视化，运行训练循环，最后导出训练好的模型。</p><p id="a5fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，通过调用适当的脚本并将配置文件作为参数传递来使用验证。</p><h1 id="abd4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数据集</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/0187fe45a741e2c4b8e83283c2a00d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*AetR6BloiKjh5GUvwolCPQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Files in the datasets folder with a 2D segmentation dataset as an example.</figcaption></figure><p id="36e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上图中，你可以看到数据集文件夹的结构。它包括 __init__。py 模块，包括一些必要的函数来查找和创建正确的数据集，以及一个自定义的数据加载器，它将数据转发到训练管道(有关这方面的更多信息，请查看<a class="ae lq" href="https://pytorch.org/tutorials/beginner/data_loading_tutorial.html" rel="noopener ugc nofollow" target="_blank"> PyTorch API 文档</a>)。顾名思义，base_dataset.py 为您在框架中定义的每个数据集定义了抽象基类。</p><p id="ccdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于您定义的每个自定义数据集，您必须实现<em class="mp"> __getitem__ </em>和<em class="mp"> __len__ </em>方法，以便 PyTorch 可以对其进行迭代。您不必再处理数据加载器，因为它是在 datasets/__init__ 中定义的。已经开始了。您还可以为数据集定义自定义回调，以便在每个时期之前和之后调用。如果您希望使用某种预热方法，在最初的几个时期向模型提供不同的数据，然后切换到更复杂的数据集，这可能会很有用。</p><p id="7510" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实例化数据集，train.py 脚本调用以下代码:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="c219" class="mv ls it mr b gy mw mx l my mz">print(‘Initializing dataset…’)<br/>train_dataset =<br/>   create_dataset(configuration[‘train_dataset_params’])</span><span id="4d85" class="mv ls it mr b gy na mx l my mz">train_dataset_size = len(train_dataset)<br/>print(‘The number of training samples = {0}’.format(train_dataset_size))</span></pre><p id="c68b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将调用<em class="mp"> create_dataset </em>函数，该函数查看配置文件并根据其名称选择正确的数据集。在命名数据集时，遵循约定&lt;dataset name&gt;_ dataset . py 很重要，因为这是脚本能够根据配置文件中的字符串找到数据集的方式。最后，上面的脚本调用数据集上的<em class="mp"> len() </em>函数来通知您数据集的大小。</p><h1 id="6994" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">模型</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f758130880ac688406f391632b8ead28.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*L67zencW5KLgWtKQZlgwYQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Files in the models folder with a segmentation model as an example.</figcaption></figure><p id="5873" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">框架中的模型以与数据集相同的方式工作:init__。py 模块包括根据模块名和配置文件中定义的字符串查找和创建正确模型的函数。模型类本身继承自抽象的 BaseModel 类，并且必须实现两个方法:</p><ul class=""><li id="6d8e" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated"><em class="mp"> forward(self) </em>运行正向预测，并且</li><li id="bbb7" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><em class="mp">optimize _ parameters(self)</em>在训练通过后修改网络的权重。</li></ul><p id="e3ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有其他方法都可以被重写，或者您可以使用默认的基类实现。您可能想要覆盖的函数包括<em class="mp"> pre_epoch_callback </em>和<em class="mp"> post_epoch_callback </em>(在每个 epoch 之前和之后调用)或<em class="mp"> test </em>(在验证期间调用)。</p><p id="2ef4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了正确使用框架，了解如何使用网络、优化器和模型中的损耗是很重要的。由于在一个模型中可能有多个使用不同优化器的网络以及多个不同的损失(例如，您可能想要显示语义本地化模型的边界框分类和回归损失)，所以界面会更复杂一些。具体来说，您为 BaseModel 类提供损失和网络的名称以及优化器，以了解如何训练您的模型。在提供的代码中，我包含了一个 2D 分割模型的例子和一个数据集例子，让你看看这个框架应该如何使用。</p><p id="3948" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看提供的 2D 分段模型的 __init__()函数:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="6c70" class="mv ls it mr b gy mw mx l my mz">class Segmentation2DModel(BaseModel):<br/>   def __init__(self, configuration):<br/>      super().__init__(configuration)<br/>      self.loss_names = [‘segmentation’]<br/>      self.network_names = [‘unet’]<br/>      self.netunet = UNet(1, 2)<br/>      self.netunet = self.netunet.to(self.device)</span><span id="3af9" class="mv ls it mr b gy na mx l my mz">      if self.is_train: # only defined during training time<br/>         self.criterion_loss = torch.nn.CrossEntropyLoss()<br/>         self.optimizer = torch.optim.Adam(self.netunet.parameters(), lr=configuration[‘lr’])</span><span id="95c4" class="mv ls it mr b gy na mx l my mz">         self.optimizers = [self.optimizer]</span></pre><p id="4ec3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生的事情是这样的:首先，我们读取模型配置。然后，我们定义“分段”损失，并将其放入<em class="mp"> self.loss_names </em>列表中。损失的名称很重要，因为我们使用变量<em class="mp"> self.loss_segmentation </em>来表示损失。通过了解名称，<em class="mp">基本模型</em>可以查找损失，并在控制台中打印或可视化(下一节将详细介绍可视化)。同样，我们定义网络的名称。这确保了<em class="mp"> BaseModel </em>知道如何训练模型，而无需我们明确定义它。接下来，我们初始化网络(在本例中是 U-Net ),并将其移动到 GPU。如果我们处于训练模式，我们还定义损失标准并实例化优化器(在本例中是 Adam)。最后，我们将优化器放入<em class="mp">self . optimizer</em>列表中。该列表再次在<em class="mp">基本模型</em>类中使用，以更新学习率或从给定的检查点恢复训练。</p><p id="3ca4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们也来看看<em class="mp"> forward() </em>和<em class="mp"> optimize_parameters() </em>函数:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="bdb5" class="mv ls it mr b gy mw mx l my mz">def forward(self):<br/>   self.output = self.netunet(self.input)</span><span id="f1d5" class="mv ls it mr b gy na mx l my mz">def backward(self):<br/>   self.loss_segmentation = self.criterion_loss(self.output, self.label)</span><span id="3db0" class="mv ls it mr b gy na mx l my mz">def optimize_parameters(self):<br/>   self.loss_segmentation.backward() # calculate gradients<br/>   self.optimizer.step()<br/>   self.optimizer.zero_grad()</span></pre><p id="1b5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，这是标准的 PyTorch 代码:它唯一的职责是在网络上调用 forward()，在计算梯度后逐步优化程序，并再次将它们归零。为您自己的模型实现这一点应该很容易。</p><h1 id="f63d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">形象化</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e7d82e88442bba56f6cf2dbb94ea9c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*bIaKxItXGP-fUztwy75-RA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Files in the utils folder.</figcaption></figure><p id="09b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可视化可以在<em class="mp">可视化器</em>类中找到。这个类负责将损失信息打印到终端，以及使用<a class="ae lq" href="https://github.com/facebookresearch/visdom" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> visdom </strong> </a> <strong class="kw iu">库</strong>可视化各种结果。它在训练脚本开始时初始化(加载 visdom 服务器)。训练脚本还调用其<em class="mp"> plot_current_losses() </em>和<em class="mp"> print_current_losses() </em>函数来可视化并写出训练损失。它还包含类似<em class="mp">plot _ current _ validation _ metrics()</em>、<em class="mp"> plot_roc_curve() </em>和<em class="mp">show _ validation _ images()</em>的函数，这些函数不会自动调用，但可以从<em class="mp"> post_epoch_callback() </em>中的模型中调用，以在验证时进行一些有用的可视化。我试图让可视化工具相当通用。当然，您可以自己扩展可视化工具的功能，让它对您更有用。</p><h1 id="41f0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="4001" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">我提出了一种编写通用深度学习框架的方法，该框架可以用于深度学习的所有领域。通过使用这种结构，您将为进一步的开发获得一个清晰而灵活的代码库。当然，解决这个问题还有许多其他方法。如果你有其他建议，请在评论中告诉我！</p></div></div>    
</body>
</html>