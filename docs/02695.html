<html>
<head>
<title>Data Science for Startups: Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创业公司的数据科学:容器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-for-startups-containers-d1d785bfe5b?source=collection_archive---------10-----------------------#2019-05-02">https://towardsdatascience.com/data-science-for-startups-containers-d1d785bfe5b?source=collection_archive---------10-----------------------#2019-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7f4bddd00e1ad39d7e0fc6994a03a808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tk9qKgRw_DshtfAi4Ps_iQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source: <a class="ae jd" href="https://commons.wikimedia.org/wiki/File:CMA_CGM_Benjamin_Franklin.jpeg" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:CMA_CGM_Benjamin_Franklin.jpeg</a></figcaption></figure><div class=""/><div class=""><h2 id="7585" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">为机器学习构建可重复的设置</h2></div><p id="118a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据科学家越来越需要的技能之一是再现分析的能力。让代码和脚本只在你的机器上工作是不可持续的。您需要能够分享您的工作，并让其他团队能够重复您的结果。我在数据科学组织中看到的一些最大的影响是当其他团队将旧代码重新用于新用例时。这篇博文是关于鼓励通过容器重用分析的，这意味着你的工作可以转移。</p><p id="0bf3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">容器的概念是，它是一个隔离的环境，您可以在其中设置执行任务所需的依赖关系。任务可以是执行 ETL 工作、监控数据质量、建立 API 或者托管交互式 web 应用程序。容器框架的目标是提供轻量级实例之间的隔离。容器是虚拟机的替代品，虚拟机是隔离的一个很好的解决方案，但是需要很大的开销。使用容器框架，您可以指定代码需要的依赖项，并让框架处理管理不同执行环境的跑腿工作。Docker 实际上是容器的标准，围绕 Docker 有很多工具。</p><p id="aa64" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一般来说，与本地部署相比，数据科学家使用 Docker 需要做更多的工作。然而，Docker 有几个好处:</p><ul class=""><li id="0575" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx jh">可重复的研究:</strong>如果你能以容器的形式交付你的分析，那么其他数据科学家可以重新运行你的工作。</li><li id="8808" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh">显式依赖:</strong>为了将你的脚本设置成一个容器，你需要理解你的代码的依赖关系和任何可能需要的额外的库，以及它们的版本。</li><li id="c2be" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh">改进的工程协作:</strong>如果你想扩大你已经建立的模型，给你的工程团队提供一个 docker 文件比提交一个 R 或 Python 脚本要好得多。它还调出代码执行所需的依赖项。</li><li id="a0bc" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh">更广泛的技能集:</strong>能够将基础设施作为代码是一种有价值的技能集，使用 Docker 容器可以帮助数据科学家开始开发这种技能集。</li></ul><p id="9334" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个有效的数据科学组织的理想状态是团队的任何成员都可以复制以前的研究。作为一名前学者，我想进一步推广这个建议，并鼓励所有提交给 arXiv 的内容都包含可复制的环境。建立一个标准的研究框架是很棒的，作为概念验证，我将我以前的一篇研究论文移植到了一个容器环境中:</p><div class="ip iq gp gr ir mf"><a rel="noopener follow" target="_blank" href="/reproducible-research-starcraft-mining-ea140d6789b9"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd jh gy z fp mk fr fs ml fu fw jf bi translated">可再生研究:星际采矿</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">2009 年，我发表了一篇关于预测《星际争霸:育雏战争》建造顺序的论文，使用了不同的分类…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ix mf"/></div></div></a></div><p id="7997" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多围绕容器环境构建的生态系统，比如 Kubernetes 和弹性容器服务(ECS)。与这些环境所提供的关注规模不同，我们将关注获取一个现有的脚本并将其包装在一个容器中。</p><div class="ip iq gp gr ir mf"><a rel="noopener follow" target="_blank" href="/deploying-keras-deep-learning-models-with-flask-5da4181436a2"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd jh gy z fp mk fr fs ml fu fw jf bi translated">使用 Flask 部署 Keras 深度学习模型</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">这篇文章演示了如何使用 Keras 构建的深度学习模型来设置端点以服务于预测。它…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt ix mf"/></div></div></a></div><p id="e81b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章中使用的所有代码都可以在<a class="ae jd" href="https://github.com/bgweber/StartupDataScience/tree/master/containers" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。当使用 Docker 时，我鼓励在源代码控制中托管所有文件，以确保您的容器可以部署到新的环境中。在这篇文章中，我将介绍 Docker 安装，在 Docker 中包装一个简单的 web 应用程序，然后作为 Docker 容器托管一个深度学习模型。</p><h2 id="0724" class="mv mw jg bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">安装 Docker</h2><p id="f02d" class="pw-post-body-paragraph kv kw jg kx b ky no kh la lb np kk ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">使用 Docker 的第一步是在您想要构建和测试映像的机器上设置 Docker。在这篇文章中，我用新的 AWS AMI ( <a class="ae jd" rel="noopener" target="_blank" href="/data-science-for-startups-r-python-2ca2cd149c5c">设置指令</a>)构建了一个 EC2 实例。您可以使用以下命令安装并验证 Docker 安装:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="47d0" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># python 3 </strong><br/>sudo yum install -y python3-pip python3 python3-setuptools</span><span id="461c" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># docker install<br/></strong>sudo yum update -y<br/>sudo amazon-linux-extras install docker<br/>sudo service docker start</span><span id="1297" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># test docker setup<br/></strong>sudo docker ps</span></pre><p id="d087" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于 AWS，如果您使用不同的实例类型，这里的<a class="ae jd" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html" rel="noopener ugc nofollow" target="_blank">提供了更多的细节。对于所有其他环境，参见 docker </a><a class="ae jd" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">说明</a>。运行完这些步骤后，您可以通过运行以下命令来检查哪些容器正在运行:<code class="fe oh oi oj ny b">sudo docker ps</code>。</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/ba636d4a3698727d7fc2ea0bf588b2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-ozbAh04v72tlpODV8WCg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">An empty Docker Install</figcaption></figure><p id="2404" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然还没有任何活动的容器，但是这个输出表明 Docker 已经启动并在您的实例上运行。我们现在准备开始托管 web 应用程序和 Python 脚本作为 Docker 容器！</p><h2 id="48bd" class="mv mw jg bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">回声服务</h2><p id="b699" class="pw-post-body-paragraph kv kw jg kx b ky no kh la lb np kk ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">在 Python 中支持 web 服务最常用的工具之一是 Flask。首先，我们将建立一个简单的 echo web 服务，其中传入的消息被返回给调用者。这是一个相对简单的环境。我们需要安装 Python 3，我们在安装 Docker 时已经这样做了，然后安装 Flask，如下所示:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="3520" class="mv mw jg ny b gy oc od l oe of">pip3 install --user Flask</span></pre><p id="5cf6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以编写一个 Flask 应用程序来实现这个 echo 服务，其中传递给服务的参数被回显到终端:</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6a88" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个简单的 web 应用程序，它将返回一个有效负载，其中的<code class="fe oh oi oj ny b">msg</code>参数将回显到 web 响应中。因为我们使用的是 Flask，所以我们可以用一个命令来部署应用程序:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="de73" class="mv mw jg ny b gy oc od l oe of">python3 echo.py</span></pre><p id="9b19" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是我们可以向服务发布消息:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="891c" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># web call</strong><br/><a class="ae jd" href="http://ec2-3-88-9-61.compute-1.amazonaws.com:5000/predict?msg=HelloWorld" rel="noopener ugc nofollow" target="_blank">http://ec2-3-88-9-61.compute-1.amazonaws.com:5000/predict?msg=HelloWorld</a></span><span id="1d32" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># result<br/></strong>{"response":"HelloWorld","success":true}</span></pre><p id="49e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，我们所做的大部分工作都围绕着设置 AWS 以允许传入连接，以及在 EC2 实例上安装 Python 3。现在我们可以专注于服务的容器化。</p><h2 id="ee0d" class="mv mw jg bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">将服务作为容器回应</h2><p id="9f8c" class="pw-post-body-paragraph kv kw jg kx b ky no kh la lb np kk ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">自从我们让 echo 服务在一个新的 EC2 实例上工作以来，我们已经完成了设置可再现环境的一些过程。在执行简单的服务之前，我们需要设置 Python 3 和 Flask。使用 Docker，我们需要做同样的过程，但是是以自动化的方式。要指定如何用 Docker 构建环境，您需要在项目中创建一个 Dockerfile 对象，它枚举了设置环境的细节。复制 echo 服务应用程序的 dockerfile 文件如下所示，位于<a class="ae jd" href="https://github.com/bgweber/StartupDataScience/blob/master/containers/echo/Dockerfile" rel="noopener ugc nofollow" target="_blank"> github </a>上:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="ef15" class="mv mw jg ny b gy oc od l oe of">FROM ubuntu:latest<br/>MAINTAINER Ben Weber  </span><span id="1b90" class="mv mw jg ny b gy og od l oe of">RUN apt-get update \  <br/>  &amp;&amp; apt-get install -y python3-pip python3-dev \  <br/>  &amp;&amp; cd /usr/local/bin \  <br/>  &amp;&amp; ln -s /usr/bin/python3 python \  <br/>  &amp;&amp; pip3 install flask  </span><span id="a0ab" class="mv mw jg ny b gy og od l oe of">COPY echo.py echo.py </span><span id="abe8" class="mv mw jg ny b gy og od l oe of">ENTRYPOINT ["python3","echo.py"]</span></pre><p id="617d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该 Dockerfile 文件提供了一些条目:</p><ul class=""><li id="4215" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx jh"> From: </strong>列出了一个基础容器。</li><li id="9030" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh"> Run: </strong>指定构建容器时要运行的命令。</li><li id="35d4" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh"> Copy: </strong>告诉 Docker 将文件从 EC2 实例复制到容器中。</li><li id="de6b" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh"> Entrypoint: </strong>指定容器实例化时运行的脚本。</li></ul><p id="b8b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从 Ubuntu 环境开始，设置 Python 3，将我们的脚本复制到容器中，然后在实例化容器时启动脚本。我使用以下脚本测试了这个容器:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="34a5" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># install git<br/></strong>sudo yum -y install git</span><span id="81ae" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># Clone the repo and build the docker image <br/></strong>git clone <a class="ae jd" href="https://github.com/bgweber/StartupDataScience" rel="noopener ugc nofollow" target="_blank">https://github.com/bgweber/StartupDataScience</a><br/>cd StartupDataScience/containers/echo/<br/>sudo docker image build -t "echo_service" .</span><span id="aa4d" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># list the docker images <br/></strong>sudo docker images</span></pre><p id="03e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在 EC2 实例上安装了 git，将代码从我的 repo 克隆到本地机器上，然后构建容器。运行 ps 命令会产生以下命令行输出:</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/2deaf2aba4cb1d2ee32b9ae0d07006ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GQPGsLzEwgQRJeG9mX_Vw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Docker Images</figcaption></figure><p id="a40a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在有了一个可以运行的容器！要运行它，我们需要指定映像名称和标识容器端口(5000)和外部端口(80)的端口映射:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="176d" class="mv mw jg ny b gy oc od l oe of">sudo docker run -d -p 80:5000 echo_service<br/>sudo docker ps</span></pre><p id="f014" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于暴露 EC2 端口的更多细节可在<a class="ae jd" rel="noopener" target="_blank" href="/data-science-for-startups-r-python-2ca2cd149c5c">这里</a>获得。当我运行上面的命令时，我得到了以下输出:</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/044b9a5a0b538e7b8e5fd0705c488390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i1_ufAEu4PFsEFznsf-rBg.png"/></div></div></figure><p id="229d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该输出表明 echo 服务现在作为一个容器运行，并作为一个端点向 web 公开。结果与之前完全相同，但不是将端口公开为 Flask 应用程序，而是将端口公开为运行 Flask 应用程序的 Docker 实例的映射端口。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="443a" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># web call<br/></strong><a class="ae jd" href="http://ec2-18-204-206-75.compute-1.amazonaws.com/predict?msg=Hi_from_docker" rel="noopener ugc nofollow" target="_blank">http://ec2-18-204-206-75.compute-1.amazonaws.com/predict?msg=Hi_from_docker</a></span><span id="297e" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># result<br/></strong>{"response":"Hi_from_docker","success":true}</span></pre><p id="aaea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在功能上，初始设置和停靠设置之间的 API 调用是相似的。关键区别在于，dockerized 设置使用容器范围的 python 库，而直接 flask 设置依赖于系统范围的 python 库。用容器方法在一个新的实例上建立这个服务是微不足道的，但是如果不使用 Docker，在一台新机器上复制这个服务可能就不那么容易了。</p><h2 id="7ee7" class="mv mw jg bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">托管复杂模型</h2><p id="e97c" class="pw-post-body-paragraph kv kw jg kx b ky no kh la lb np kk ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">在使用复杂的库时，Docker 的威力更加明显。在本节中，我们将在本地训练一个 Keras 模型，然后将其部署为一个容器。为了在本地训练模型，我们需要安装几个库:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="5f29" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># Deep Learning setup <br/></strong>pip3 install --user tensorflow<br/>pip3 install --user keras<br/>pip3 install --user  pandas</span></pre><p id="68bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将通过在本地运行 Python 脚本来训练模型。这个脚本的输出是一个我们希望作为端点托管的<em class="op"> h5 </em>模型。更多关于训练代码的细节可以在<a class="ae jd" rel="noopener" target="_blank" href="/deploying-keras-deep-learning-models-with-flask-5da4181436a2">这里</a>找到。</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e420" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们已经在主机 EC2 实例上安装了必要的库，所以我们可以使用以下命令构建模型文件:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="5605" class="mv mw jg ny b gy oc od l oe of">python3 train_model.py</span></pre><p id="059d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是一个<code class="fe oh oi oj ny b">games.h5</code>模型，我们希望将它包含在我们的预测容器中。虽然我们可以将这一步打包到 Docker 设置中，但是在第一次设置 Docker 工作流时，将这些步骤分开会更容易。</p><p id="43c0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了模型规范，我们可以将深度学习模型作为 Flask 应用程序托管，作为 Docker 容器管理。下面的代码显示了如何设置 Flask 应用程序来服务于该模型，并且没有修改您之前关于使用 Flask 托管深度学习模型的帖子:</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="9abb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是指定 Dockerfile，它在构建容器时接收代码和模型。下面的脚本显示，我们已经添加了几个库，并且还将一个模型文件从本地机器复制到 docker 映像，这意味着它可以在提供预测时使用:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="69b6" class="mv mw jg ny b gy oc od l oe of">FROM ubuntu:latest<br/>MAINTAINER Ben Weber</span><span id="bde6" class="mv mw jg ny b gy og od l oe of">RUN apt-get update \ <br/>  &amp;&amp; apt-get install -y python3-pip python3-dev \<br/>  &amp;&amp; cd /usr/local/bin \<br/>  &amp;&amp; ln -s /usr/bin/python3 python \<br/>  &amp;&amp; pip3 install tensorflow \<br/>  &amp;&amp; pip3 install keras \<br/>  &amp;&amp; pip3 install pandas \<br/>  &amp;&amp; pip3 install flask </span><span id="ba98" class="mv mw jg ny b gy og od l oe of">COPY games.h5 games.h5<br/>COPY keras_app.py keras_app.py</span><span id="c64f" class="mv mw jg ny b gy og od l oe of">ENTRYPOINT ["python3","keras_app.py"]</span></pre><p id="3b57" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的命令行说明显示了如何将这个 docker 文件转换为一个容器，我们可以使用它来托管深度学习模型:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="3f70" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># Clone the repo and build the docker image<br/></strong>git clone <a class="ae jd" href="https://github.com/bgweber/StartupDataScience" rel="noopener ugc nofollow" target="_blank">https://github.com/bgweber/StartupDataScience</a><br/>cd StartupDataScience/containers/model/<br/>sudo docker image build -t "model_service" .</span><span id="7a04" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># Expose a model endpoint</strong><br/>sudo docker run -d -p 80:5000 model_service</span></pre><p id="f73e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行该容器的结果是，我们现在有了一个深度学习模型，该模型作为 Flask 端点公开，我们可以向其传递参数以获得预测。下面的代码块显示了我如何测试这个接口以获得一个预测结果。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="b9db" class="mv mw jg ny b gy oc od l oe of"><strong class="ny jh"># web call  </strong><a class="ae jd" href="http://ec2-18-204-206-75.compute-1.amazonaws.com/predict?g1=1&amp;g2=0&amp;g3=0&amp;g4=0&amp;g5=0&amp;g6=0&amp;g7=0&amp;g8=0&amp;g9=0&amp;g10=0" rel="noopener ugc nofollow" target="_blank"><strong class="ny jh"><br/></strong>http://ec2-18-204-206-75.compute-1.amazonaws.com/predict?g1=1&amp;g2=0&amp;g3=0&amp;g4=0&amp;g5=0&amp;g6=0&amp;g7=0&amp;g8=0&amp;g9=0&amp;g10=0</a></span><span id="3034" class="mv mw jg ny b gy og od l oe of"><strong class="ny jh"># result<br/></strong>{"prediction":"2.160104e-16","success":true}</span></pre><p id="a4fe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些工作的结果是，我们在 Docker 容器中包装了一个 Keras 模型，但是维护了 Flask 接口以将模型作为 web 上的端点公开。与我在 Flask 上发表的第一篇文章的主要区别在于，该模型现在是在容器范围的环境中定义的，而不是在 EC2 范围的环境中定义的，并且在新机器上设置该模型是很简单的。除了设计可以在容器中工作的模型，急切地瞄准 Docker 和云工具意味着数据科学家项目更容易在整个组织中共享使用。</p><h2 id="51a4" class="mv mw jg bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">结论</h2><p id="ddab" class="pw-post-body-paragraph kv kw jg kx b ky no kh la lb np kk ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">数据科学家应该能够创作超出其本地工作空间的模型和数据工作流。Docker 之类的容器环境是实现这一目标的一种方式，熟悉这些类型的工具有助于利用诸如将基础设施指定为代码之类的技能来构建您的投资组合。这篇文章展示了如何使用 Docker 将 Keras 模型作为一个 webpoint，但只是对这些工具支持的可重复研究能力的一瞥。</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="9789" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本·韦伯是 Zynga 的杰出数据科学家，也是 T2 恶作剧公司的顾问。</p></div></div>    
</body>
</html>