<html>
<head>
<title>Productionize a Machine Learning model with Flask and Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Flask 和 Heroku 制作一个机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/productionize-a-machine-learning-model-with-flask-and-heroku-8201260503d2?source=collection_archive---------14-----------------------#2019-12-09">https://towardsdatascience.com/productionize-a-machine-learning-model-with-flask-and-heroku-8201260503d2?source=collection_archive---------14-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="423d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在互联网上的 Flask API 背后部署一个经过训练的 ML 模型？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0295bb47828cb15f0aaffdfd665c32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q94F90dkndPfQfpWgdxXBA.png"/></div></div></figure><p id="c3c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一名软件开发背景的人，我从未对生产我的模型有过任何犹豫。但是对于任何刚刚进入编码领域的人来说，作为一名数据科学家，这可能并不明显。</p><p id="9398" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个模型要在现实世界中使用，你需要把它生产出来。</p><p id="9f1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将讨论一些事情。创建一个 ML 模型<br/> 2。将其包装在 API <br/> 3 的烧瓶中。将 API 部署到 Heroku 上</p><h1 id="9a13" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建一个快速而肮脏的模型</h1><p id="1e0a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">本教程不是关于训练模型的，所以我们将在波士顿住房数据集上训练一个非常简单的模型，而不考虑它的工作情况。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8a9a" class="ms lr it mo b gy mt mu l mv mw"># import dataset<br/>from sklearn.datasets import load_boston</span><span id="eaf2" class="ms lr it mo b gy mx mu l mv mw"># load data<br/>data = load_boston()</span><span id="c991" class="ms lr it mo b gy mx mu l mv mw">import pandas as pd</span><span id="3222" class="ms lr it mo b gy mx mu l mv mw"># load into a dataframe<br/>df = pd.DataFrame(data['data'], columns=data['feature_names'].tolist())<br/>df['label'] = data['target']<br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/f306726df7fe651ab1e52b4c1e217ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2E5TVELHn_nAjbs7dRPz1Q.png"/></div></div></figure><p id="dfee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">左边的<code class="fe mz na nb mo b">label</code>代表<code class="fe mz na nb mo b">Median value of owner-occupied homes in $1000’s</code>每个地区以千美元计的平均房屋价值。该数据集背后的想法是使用其他列中的值来预测平均房价。</p><p id="ba7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将只使用<code class="fe mz na nb mo b">RM</code>、<code class="fe mz na nb mo b">average number of rooms per dwelling</code>来进行预测，完全知道这不会创建一个准确的模型。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="314b" class="ms lr it mo b gy mt mu l mv mw"># shuffle data<br/>shuffled_df = df.sample(frac=1)</span><span id="0f66" class="ms lr it mo b gy mx mu l mv mw"># split data<br/>split = int(len(shuffled_df) * .7)<br/>train_df = shuffled_df[:split]<br/>test_df = shuffled_df[split:]</span><span id="c298" class="ms lr it mo b gy mx mu l mv mw"># stock function for extracting X,y columns from df<br/>def X_and_y_from_df(df, y_column, X_columns = []):<br/>    X = {}<br/>    for feature in X_columns:<br/>        X[feature] = df[feature].tolist()<br/>    y = df[y_column].tolist()<br/>    return X, y</span><span id="5be1" class="ms lr it mo b gy mx mu l mv mw"># extract X and y<br/>X_train, y_train = X_and_y_from_df(train_df, 'label', ['RM'])<br/>X_test, y_test = X_and_y_from_df(test_df, 'label', ['RM'])</span><span id="0835" class="ms lr it mo b gy mx mu l mv mw"># reshape<br/>import numpy as np<br/>X_train_arr = np.array(X_train['RM'])<br/>X_train_arr = X_train_arr.reshape(X_train_arr.shape[0],1)<br/>X_test_arr = np.array(X_test['RM'])<br/>X_test_arr = X_test_arr.reshape(X_test_arr.shape[0],1)</span><span id="fb2d" class="ms lr it mo b gy mx mu l mv mw"># train model<br/>from sklearn.linear_model import LinearRegression<br/>model = LinearRegression()<br/>model.fit(X_arr, y_train)</span><span id="d80d" class="ms lr it mo b gy mx mu l mv mw"># predict results<br/>y_pred = model.predict(X_test_arr)</span></pre><p id="d36b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经预测了这里的结果，但坦率地说，我们不在乎。如果我们在这个问题上花更多的时间，我们可以建立一个更精确的模型。</p><h1 id="51a5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">酸洗模型</h1><p id="5760" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">泡菜什么？！</p><p id="6473" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Pickling 将对象转换成字节流，该字节流可以存储、传输并在以后转换回原始模型。Pickles 是 python 允许您保存几乎任何开箱即用对象的方法之一。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="75bf" class="ms lr it mo b gy mt mu l mv mw">import pickle</span><span id="165a" class="ms lr it mo b gy mx mu l mv mw">pickl = {'model': model}<br/>pickle.dump( pickl, open( 'model_file' + ".p", "wb" ) )</span></pre><p id="2765" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嘣。我们的模型现在作为泡菜保存在与我们的 jupyter 笔记本相同的目录中。</p><h1 id="60c0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">构建一个 Flask API</h1><p id="f0b1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Flask 是 Python 的一个微框架。它没有其他框架的多余功能，因此非常适合构建简单的 API。</p><p id="8cfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在命令行上运行几个命令来开始。</p><p id="5764" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个目录来存储应用程序<br/> <code class="fe mz na nb mo b">mkdir FlaskAPI</code></p><p id="ec00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">光盘进入<br/>目录<code class="fe mz na nb mo b">cd FlaskAPI</code></p><p id="885f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建虚拟环境<br/> <code class="fe mz na nb mo b">python3 -m venv vir_env</code></p><p id="6287" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">激活虚拟环境<br/> <code class="fe mz na nb mo b">source vir_env/bin/activate</code></p><p id="9415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装我们需要的所有软件包<br/> <code class="fe mz na nb mo b">pip3 install flask gunicorn sklearn</code></p><p id="6d2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保存生产需要安装<br/> <code class="fe mz na nb mo b">pip3 freeze &gt; requirements.txt</code>的包和版本列表</p><p id="a0fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们创建的最后一个目录中，用命令行创建几个文件和另一个目录。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1e08" class="ms lr it mo b gy mt mu l mv mw">touch app.py<br/>touch Procfile<br/>touch wsgi.py<br/>mkdir models</span></pre><p id="c5e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您喜欢的代码编辑器中打开<code class="fe mz na nb mo b">FlaskAPI</code>目录。我喜欢 sublime，所以我将用<code class="fe mz na nb mo b">sublime .</code>在当前目录中启动它。</p><p id="725b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将以下内容复制到<code class="fe mz na nb mo b">app.py</code>中。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1953" class="ms lr it mo b gy mt mu l mv mw">import flask<br/>from flask import Flask, jsonify, request<br/>import json</span><span id="7552" class="ms lr it mo b gy mx mu l mv mw">app = Flask(__name__)</span><span id="221f" class="ms lr it mo b gy mx mu l mv mw"><a class="ae nc" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict', methods=['GET'])<br/>def predict():<br/> response = json.dumps({'response': 'yahhhh!'})<br/> return response, 200</span><span id="3fb6" class="ms lr it mo b gy mx mu l mv mw">if __name__ == '__main__':<br/> application.run(debug=True)</span></pre><p id="d607" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并将以下内容复制到<code class="fe mz na nb mo b">wsgi.py</code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d957" class="ms lr it mo b gy mt mu l mv mw">from app import app as application</span><span id="0d26" class="ms lr it mo b gy mx mu l mv mw">if __name__ == "__main__":<br/>    application.run()</span></pre><p id="e50a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在启动应用程序！在同一个目录下运行<code class="fe mz na nb mo b">gunicorn --bind 0.0.0.0:8080 wsgi:application -w 1</code></p><p id="b0ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该看看…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/5fc6a40839f6f2c4ee03ed9e65993ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OK9y8ieKEOFX8tADuggsQ.png"/></div></div></figure><p id="0665" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尝试用<code class="fe mz na nb mo b">curl -X GET <a class="ae nc" href="http://0.0.0.0:8080/predict" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080/predict</a></code>从另一个终端窗口向它发出请求</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/067849a89d86ac4166bfaabb17c41c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*myot571AGHvwAsCwNVaW9w.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/dd5fafee3850e9db2eace85d5f8b14a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*pvw5gEPuZ902lKVhmQNkyQ.png"/></div></figure><p id="8db1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">成功。我们有一个本地运行的 Flask API。</p><p id="5874" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是时候添加我们的机器学习模型了。拿起你的<code class="fe mz na nb mo b">model_file.p</code>泡菜，放入我们制作的应用程序中的<code class="fe mz na nb mo b">/models/</code>目录，这样你的文件树现在看起来像左边。</p><p id="6502" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将此功能添加到<code class="fe mz na nb mo b">app.py</code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="f238" class="ms lr it mo b gy mt mu l mv mw">def load_models():<br/>    file_name = "models/model_file.p"<br/>    with open(file_name, 'rb') as pickled:<br/>        data = pickle.load(pickled)<br/>        model = data['model']<br/>    return model</span></pre><p id="4fb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并修改您的<code class="fe mz na nb mo b">predict()</code>函数，如下所示</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e8ee" class="ms lr it mo b gy mt mu l mv mw">def predict():</span><span id="ce40" class="ms lr it mo b gy mx mu l mv mw">    # stub input features<br/>    x = 5.963</span><span id="ab7b" class="ms lr it mo b gy mx mu l mv mw">    # load model<br/>    model = load_models()<br/>    prediction = model.predict([[x]])[0]</span><span id="5376" class="ms lr it mo b gy mx mu l mv mw">    response = json.dumps({'response': prediction})<br/>    return response, 200</span></pre><p id="07ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还需要将<code class="fe mz na nb mo b">import json</code>和<code class="fe mz na nb mo b">import pickle</code>添加到<code class="fe mz na nb mo b">app.py</code>的顶部。</p><p id="49a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mz na nb mo b">app.py</code>现在的样子</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d1d5" class="ms lr it mo b gy mt mu l mv mw">import flask<br/>from flask import Flask, jsonify, request<br/>import json<br/>import pickle</span><span id="4b59" class="ms lr it mo b gy mx mu l mv mw">app = Flask(__name__)</span><span id="30a8" class="ms lr it mo b gy mx mu l mv mw">def load_models():<br/>    file_name = "models/model_file.p"<br/>    with open(file_name, 'rb') as pickled:<br/>       data = pickle.load(pickled)<br/>       model = data['model']<br/>    return model</span><span id="184d" class="ms lr it mo b gy mx mu l mv mw"><a class="ae nc" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict', methods=['GET'])<br/>def predict():</span><span id="beeb" class="ms lr it mo b gy mx mu l mv mw">    # stub input features<br/>    x = 5.963</span><span id="b32f" class="ms lr it mo b gy mx mu l mv mw">    # load model<br/>    model = load_models()<br/>    prediction = model.predict([[x]])[0]</span><span id="4e99" class="ms lr it mo b gy mx mu l mv mw">    response = json.dumps({'response': prediction})<br/>    return response, 200</span><span id="7251" class="ms lr it mo b gy mx mu l mv mw">if __name__ == '__main__':<br/>    application.run(debug=True)</span></pre><p id="ff24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们是在模拟输入值，而不是实际发送给应用程序并解析响应——这就来了。</p><p id="bfc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再次测试应用程序，以确保模型在我们的 API 后面工作。</p><p id="ee7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">停止网络服务器，用<code class="fe mz na nb mo b">gunicorn — bind 0.0.0.0:8080 wsgi:application -w 1</code>重启</p><p id="6060" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在提出另一个请求，<code class="fe mz na nb mo b">curl -X GET <a class="ae nc" href="http://0.0.0.0:8080/predict" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080/predict</a></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/639b51aa0bbf880f1f450435ec03662e.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*Va9VffsTQvC4tVlpEtsCPA.png"/></div></div></figure><p id="c6c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完美。我们的模型根据 API 中输入的特性预测标签！</p><p id="2168" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们的 API 接受来自请求的输入特性。</p><p id="a79e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将此添加到<code class="fe mz na nb mo b">predict()</code></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d451" class="ms lr it mo b gy mt mu l mv mw"># parse input features from request<br/>request_json = request.get_json()<br/>x = float(request_json['input'])</span></pre><p id="3afe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe mz na nb mo b">app.py</code>看起来像</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d3aa" class="ms lr it mo b gy mt mu l mv mw">import flask<br/>from flask import Flask, jsonify, request<br/>import json<br/>import pickle</span><span id="d896" class="ms lr it mo b gy mx mu l mv mw">app = Flask(__name__)</span><span id="ed2c" class="ms lr it mo b gy mx mu l mv mw">def load_models():<br/>    file_name = "models/model_file.p"<br/>    with open(file_name, 'rb') as pickled:<br/>        data = pickle.load(pickled)<br/>        model = data['model']<br/>    return model</span><span id="af1a" class="ms lr it mo b gy mx mu l mv mw"><a class="ae nc" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict', methods=['GET'])<br/>def predict():</span><span id="cc10" class="ms lr it mo b gy mx mu l mv mw">    # parse input features from request<br/>    request_json = request.get_json()<br/>    x = float(request_json['input'])<br/> <br/>    # load model<br/>    model = load_models()<br/>    prediction = model.predict([[x]])[0]</span><span id="6767" class="ms lr it mo b gy mx mu l mv mw">    response = json.dumps({'response': prediction})<br/>    return response, 200</span><span id="fbaf" class="ms lr it mo b gy mx mu l mv mw">if __name__ == '__main__':<br/>    application.run(debug=True)</span></pre><p id="8683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要把这个加到<code class="fe mz na nb mo b">Procfile</code>，它实际上没有扩展名。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="abc5" class="ms lr it mo b gy mt mu l mv mw">web: gunicorn app:app --preload</span></pre><p id="d587" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再提一个要求。这次我们稍微修改了一下，这样我们的 API 就知道它得到了一个 JSON。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="86e2" class="ms lr it mo b gy mt mu l mv mw">curl -X GET http://0.0.0.0:8080/predict -H "Content-Type: application/json" -d '{"input":"7"}'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e3a4f56a5d4b1e505425e8ddf1350cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*B6RDkdDypaWIZyDtmVHIUQ.png"/></div></figure><p id="2964" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次，成功！我们有一个内部包含模型的工作 API。</p><h1 id="f73c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">部署到 Heroku</h1><p id="25bc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过在命令行运行<code class="fe mz na nb mo b">git init</code>将 git 添加到应用程序中。</p><p id="acb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后运行<code class="fe mz na nb mo b">nano .gitignore</code>并添加以下几行:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d9d7" class="ms lr it mo b gy mt mu l mv mw">vir_env<br/>__pycache__/<br/>.DS_Store</span></pre><p id="0cdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后按<code class="fe mz na nb mo b">ctrl+x</code>、<code class="fe mz na nb mo b">y</code>，再按<code class="fe mz na nb mo b">enter</code>保存并关闭 mac 上的文件。这将防止将不必要的文件推送到 Heroku。</p><p id="9a31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在命令行运行<code class="fe mz na nb mo b">git add . -A</code>和<code class="fe mz na nb mo b">git commit -m 'first commit'</code>继续向 git 添加文件。</p><p id="b92c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<a class="ae nc" href="http://heroku create flask-ml-api-123" rel="noopener ugc nofollow" target="_blank"> Heroku </a>创建一个账户。然后在命令行用<code class="fe mz na nb mo b">heroku login</code>登录 Heroku，再用<code class="fe mz na nb mo b">heroku create flask-ml-api-123</code>创建一个 app。<code class="fe mz na nb mo b">flask-ml-api-123 </code>是我选的应用名称。你需要找一个没人用过的名字。</p><p id="c96a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在用<code class="fe mz na nb mo b">git push heroku master</code>把我们的 app 推送到 heroku。</p><p id="3996" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部署时，您将看到 Heroku 为您的应用程序提供的 URL。这是您发送 API 请求的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/17a35dd1de13947e61cb9462d3602560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8wAbB3p7lpyGCD9YhzNtA.png"/></div></div></figure><p id="3bf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说是<code class="fe mz na nb mo b"><a class="ae nc" href="https://flask-ml-api-123.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://flask-ml-api-123.herokuapp.com/</a></code>。</p><p id="3bd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在在那里提出一个请求</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e658" class="ms lr it mo b gy mt mu l mv mw">curl -X GET <a class="ae nc" href="https://flask-ml-api-123.herokuapp.com/predict" rel="noopener ugc nofollow" target="_blank">https://flask-ml-api-123.herokuapp.com/predict</a> -H “Content-Type: application/json” -d '{"input”:”9"}'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d77de24f1a928b7c3c25566db47290bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*TqEAQR-j8JVrnwHfYd-G4A.png"/></div></figure><p id="75b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们正在谈话！我们已经训练了一个模型，将其包装在一个 API 中，并将其部署到 Heroku。显然，我们还应该添加很多东西，比如身份验证。但是这应该让你开始！</p></div></div>    
</body>
</html>