<html>
<head>
<title>Kubeflow for Poets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">诗人的库伯流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubeflow-for-poets-a05a5d4158ce?source=collection_archive---------5-----------------------#2019-04-20">https://towardsdatascience.com/kubeflow-for-poets-a05a5d4158ce?source=collection_archive---------5-----------------------#2019-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3366" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">机器学习生产流水线的容器化指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c270e8a7b453c8f6098619571a5e3d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PshD8n5B_7h-cmmFYpurqA.png"/></div></div></figure><p id="9a28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本系列文章提供了一种在 Kubernetes 上使用 Kubeflow 生产机器学习管道的系统方法。构建机器学习模型只是一个更广泛的任务和过程系统的一部分，这些任务和过程共同交付一个机器学习产品。Kubeflow 使得利用容器化的微服务范例来分离在 Kubernetes 上编排的应用程序的模块化组件成为可能。虽然 Kubernetes 是平台不可知的，但本系列将重点关注在 Google 云平台上部署一个机器学习产品，利用 Google Cloud BigQuery、Google Cloud Dataflow 和在 Google Kubernetes 引擎上编排的 Google Cloud 机器学习引擎。</p><h1 id="a015" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">内容</h1><p id="ae97" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">内容安排如下:</p><ul class=""><li id="a893" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#1fb7" rel="noopener">简介</a></li><li id="61ee" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#ca52" rel="noopener">微服务架构</a></li><li id="2d8d" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#a20b" rel="noopener">码头工人</a></li><li id="65af" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#58d3" rel="noopener"> Kubernetes </a></li><li id="6e3c" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#6474" rel="noopener"> Kubeflow </a></li><li id="9303" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#e593" rel="noopener"> Kubeflow 管道</a></li><li id="df8e" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/p/a05a5d4158ce#a200" rel="noopener">在 Kubeflow 管道上部署端到端机器学习解决方案</a></li></ul><h1 id="bd0b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">源代码和贡献:</h1><p id="bad9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">完整的源代码可以在<a class="ae mw" href="https://github.com/dvdbisong/kubeflow-for-poets" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。贡献和更正是受欢迎的拉请求。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="1fb7" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">介绍</h1><p id="931d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">机器学习通常被正确地视为使用数学算法来教会计算机学习任务，这些任务在计算上不可编程为一组指定的指令。然而，从工程的角度来看，这些算法的使用只占整个学习过程的一小部分。构建高性能和动态的学习模型包括许多其他重要的组成部分。这些组件实际上主导了交付端到端机器学习产品的关注空间。</p><p id="5119" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">典型的机器学习生产管道如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/2f49ee276c2ca37eb7c3d9ee6f31d2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgGy9E4UDiz6XxwZkauFDQ.png"/></div></div></figure><p id="8dcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上图中，可以观察到管道中的流程流是迭代的。这种重复模式是机器学习实验、设计和部署的核心。</p><h2 id="0c3b" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">效率挑战</h2><p id="6cda" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">很容易认识到，在构建学习模型时，流水线需要大量的开发操作来实现从一个组件到另一个组件的无缝转换。这种零件的互操作性产生了机器学习操作，也称为 MLOps。这个术语是机器学习和 DevOps 的混合体。</p><p id="b177" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进行机器学习的传统方式是在 Jupyter 笔记本电脑上执行所有的实验和开发工作，模型被导出并发送给软件开发团队进行部署和端点生成，以集成到下游软件产品中，而 DevOps 团队处理机器的基础设施和配置以进行模型开发。这种单一的工作方式导致机器学习过程不可重用，难以扩展和维护，更难以审计和执行模型改进，并且容易充满错误和不必要的复杂性。</p><p id="51bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，通过将微服务设计模式整合到机器学习开发中，我们可以解决这些问题，并真正简化生产过程。</p><h2 id="1e2c" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">谷歌云平台上的一句话(GCP)</h2><p id="7ac3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">该教程将重点关注在谷歌云平台的基础设施上开发和部署生产模型。云的优势是易于根据资源需求分发和扩展单个工作流组件。然而，当使用微服务时，容器化管道是机器无关的，可以快速部署在任何其他本地基础设施或公共云服务提供商，如 AWS 或 Azure 上。</p><p id="da7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谷歌云平台拥有一系列强大的人工智能无服务器服务，我们将整合这些服务来处理生产管道的一些组件。这些服务包括 Google BigQuery，用于暂存我们的转换数据集以进行轻松分析，Google Dataflow 用于大规模数据转换，Google Cloud Machine Learning Engine 用于大规模模型训练和模型部署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/2b937605ee932205a9384aa6ae6e2806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-HVouQEX4qu3P9pg9HgFA.png"/></div></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="ca52" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">微服务架构</h1><p id="1c35" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">微服务架构是一种开发和部署企业云原生软件应用的方法，它涉及将应用的核心业务功能分离成分离的组件。每个业务功能都代表应用程序作为服务提供给最终用户的一些功能。微服务的概念与整体架构形成对比，后者将应用程序构建为其“单独”功能的组合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/5a68941e7a461dd1a44c47899643c16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJRbVzLeaX5MsDeZwX5LSQ.png"/></div></div></figure><p id="8a2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">微服务使用表述性状态转移(REST)通信进行交互，以实现无状态互操作性。所谓无状态，我们指的是<a class="ae mw" href="https://stackoverflow.com/a/3105337/3353760" rel="noopener ugc nofollow" target="_blank">“服务器不存储关于客户端会话的状态”</a>。这些协议可以是 HTTP 请求/响应 API 或异步消息队列。这种灵活性允许微服务轻松扩展并响应请求，即使另一个微服务出现故障。</p><h2 id="05e3" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">微服务的优势</h2><ul class=""><li id="3a33" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp ms mt mu mv bi translated">松散耦合的组件使应用程序具有容错能力。</li><li id="2572" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">能够横向扩展，使每个组件高度可用。</li><li id="e4fe" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">组件的模块化使得扩展现有功能变得更加容易。</li></ul><h2 id="9007" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">微服务的挑战</h2><ul class=""><li id="eedb" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp ms mt mu mv bi translated">软件架构的复杂性增加了。</li><li id="2709" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">微服务管理和编排的开销。然而，我们将在接下来的会议中看到 Docker 和 Kubernetes 如何努力缓解这一挑战。</li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="a20b" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">码头工人</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/6fde75eed510a9fec663145c8b064e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NF7SSEHtoiEW7Jt2OzqBBQ.png"/></div></div></figure><p id="ddaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker 是一个虚拟化应用程序，它将应用程序抽象到被称为<em class="oh">容器</em>的隔离环境中。容器背后的想法是提供一个统一的平台，其中包括用于开发和部署应用程序的软件工具和依赖项。</p><p id="953a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开发应用程序的传统方式是在单个服务器上设计和托管应用程序。这种设置导致了许多问题，包括著名的“它在我的机器上工作，但在你的机器上不工作”。此外，在这种体系结构中，应用程序难以扩展和迁移，从而导致巨大的成本和缓慢的部署。</p><h2 id="8d1a" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">虚拟机与容器</h2><div class="kj kk kl km gt ab cb"><figure class="oi kn oj ok ol om on paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/2a6c18f6822f62cc51a153245bff515b.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*7d63ehDojPBrMlRbRJoQFg.png"/></div></figure><figure class="oi kn oo ok ol om on paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/21fa47fef76e5911defd39095c5cc6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*WXsalHwcS3b7dO5OSupF2A.png"/></div><figcaption class="op oq gj gh gi or os bd b be z dk ot di ou ov"><strong class="bd ow">Left:</strong> Virtual machines. <strong class="bd ow">Right:</strong> Containers</figcaption></figure></div><p id="9e2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虚拟机(VMs)模拟物理机的功能，使得通过使用虚拟机管理程序来安装和运行操作系统成为可能。虚拟机管理程序是物理机(主机)上的一个软件，它使虚拟化成为可能，在虚拟化中，多个客户机由主机管理。</p><p id="d3b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，容器通过自己的库和软件依赖关系隔离了应用程序的宿主环境，然而，与 VM 相反，机器上的容器都共享相同的操作系统内核。Docker 是容器的一个例子。</p><h2 id="a1ee" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">使用 Docker</h2><p id="9eb3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">首先在本地机器上安装 Docker 软件，使其能够运行 Docker 容器。参观 https://www.docker.com/get-started<a class="ae mw" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank"/>开始吧。</p><p id="cb5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的关键概念是:</p><ul class=""><li id="4964" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">docker file:docker file 是一个指定如何创建图像的文本文件。</li><li id="7b00" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu"> Docker 图像:</strong>通过构建 Docker 文件来创建图像。</li><li id="a961" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu"> Docker 容器:</strong> Docker 容器是图像的运行实例。</li></ul><p id="7c79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图突出显示了构建映像和运行 Docker 容器的过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/6e4b20d2a27f6b03a4885555c1046d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J52De29jInAzByroyDf5QA.png"/></div></div></figure><h2 id="d4b2" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">介绍 DockerHub</h2><p id="93d4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">DockerHub 是一个托管 Docker 图像的库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/208d2c7f0497da76d999274f4255134e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9gRZk6viJybsG8LSOkL6A.png"/></div></div></figure><h2 id="cde6" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">编写 docker 文件时的关键例程</h2><p id="6eea" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">以下是创建 docker 文件时的关键例程。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="d724" class="np lr it pa b gy pe pf l pg ph">+------------+-----------------------------------------------------+<br/>| <strong class="pa iu">Command</strong>    | <strong class="pa iu">Description                                         </strong>|<br/>+------------+-----------------------------------------------------+<br/>| <strong class="pa iu">FROM</strong>       | The base Docker image for the Dockerfile.           |<br/>| <strong class="pa iu">LABEL      </strong>| Key-value pair for specifying image metadata.       |<br/>| <strong class="pa iu">RUN</strong>        | It execute commands on top of the current image as  |                              |              new layers.                                         |<br/>| <strong class="pa iu">COPY</strong>       | Copies files from the local machine to the          |<br/>|              container filesystem.                               |<br/>| <strong class="pa iu">EXPOSE</strong>     | Exposes runtime ports for the Docker container.     |<br/>| <strong class="pa iu">CMD</strong>        | Specifies the command to execute when running the   |   |              container. This command is overridden if another    |   |              command is specified at runtime.                    |<br/>| <strong class="pa iu">ENTRYPOINT</strong> | Specifies the command to execute when running the   |      |              container. Entrypoint commands are not overridden   |<br/>|              by a command specified at runtime.                  |<br/>| <strong class="pa iu">WORKDIR</strong>    | Set working directory of the container.             |<br/>| <strong class="pa iu">VOLUME</strong>     | Mount a volume from the local machine filesystem to | |              the Docker container.                               |<br/>| <strong class="pa iu">ARG</strong>        | Set Environment variable as a key-value pair when   |              |              building the image.                                 |<br/>| <strong class="pa iu">ENV</strong>        | Set Environment variable as a key-value pair that   | |              will be available in the container after building.  |<br/>+------------+-----------------------------------------------------+</span></pre><h2 id="1c09" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">构建并运行一个简单的 Docker 容器</h2><p id="8eb1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这个简单的例子中，我们有一个名为<code class="fe pi pj pk pa b">date-script.sh</code>的 bash 脚本。该脚本将当前日期赋给一个变量，然后将日期打印到控制台。Dockerfile 会将脚本从本地机器复制到 docker 容器文件系统，并在运行容器时执行 shell 脚本。构建容器的 Dockerfile 文件存储在<code class="fe pi pj pk pa b">docker-intro/hello-world</code>中。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="cd70" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># navigate to folder with images</em></strong><br/>cd docker-intro/hello-world</span></pre><p id="78ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看 bash 脚本。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="4280" class="np lr it pa b gy pe pf l pg ph">cat date-script.sh</span><span id="60a9" class="np lr it pa b gy pl pf l pg ph"><em class="oh">#! /bin/sh</em><br/>DATE<strong class="pa iu">=</strong>"<strong class="pa iu">$(</strong>date<strong class="pa iu">)</strong>"<br/>echo "Todays date is $DATE"</span></pre><p id="58a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看文档。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="c30a" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># view the Dockerfile</em></strong><br/>cat Dockerfile</span><span id="9e59" class="np lr it pa b gy pl pf l pg ph"><em class="oh"># base image for building container</em><br/>FROM docker.io/alpine<br/><em class="oh"># add maintainer label</em><br/>LABEL maintainer<strong class="pa iu">=</strong>"dvdbisong@gmail.com"<br/><em class="oh"># copy script from local machine to container filesystem</em><br/>COPY date-script.sh /date-script.sh<br/><em class="oh"># execute script</em><br/>CMD sh date-script.sh</span></pre><ul class=""><li id="c894" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">Docker 映像将基于 Alpine Linux 包构建。参见<a class="ae mw" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/alpine</a></li><li id="287e" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">当容器运行时,<code class="fe pi pj pk pa b">CMD</code>例程执行脚本。</li></ul><h2 id="c016" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">建立形象</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="4312" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># build the image</em></strong><br/>docker build -t ekababisong.org/first_image .</span></pre><p id="b1f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成输出:</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="c991" class="np lr it pa b gy pe pf l pg ph">Sending build context to Docker daemon  2.048kB<br/>Step 1/4 : FROM docker.io/alpine<br/>latest: Pulling from library/alpine<br/>6c40cc604d8e: Pull complete <br/>Digest: sha256:b3dbf31b77fd99d9c08f780ce6f5282aba076d70a513a8be859d8d3a4d0c92b8<br/>Status: Downloaded newer image for alpine:latest<br/> ---&gt; caf27325b298<br/>Step 2/4 : LABEL maintainer="dvdbisong@gmail.com"<br/> ---&gt; Running in 306600656ab4<br/>Removing intermediate container 306600656ab4<br/> ---&gt; 33beb1ebcb3c<br/>Step 3/4 : COPY date-script.sh /date-script.sh<br/> ---&gt; Running in 688dc55c502a<br/>Removing intermediate container 688dc55c502a<br/> ---&gt; dfd6517a0635<br/>Step 4/4 : CMD sh date-script.sh<br/> ---&gt; Running in eb80136161fe<br/>Removing intermediate container eb80136161fe<br/> ---&gt; e97c75dcc5ba<br/>Successfully built e97c75dcc5ba<br/>Successfully tagged ekababisong.org/first_image:latest</span></pre><h2 id="75c4" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">运行容器</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="5f21" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># show the images on the image</em></strong><br/>docker images</span><span id="a98d" class="np lr it pa b gy pl pf l pg ph">REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE<br/>ekababisong.org/first_image   latest              e97c75dcc5ba        32 minutes ago      5.52MB<br/>alpine                        latest              caf27325b298        3 weeks ago         5.52MB</span><span id="e0fd" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># run the docker container from the image</em></strong><br/>docker run ekababisong.org/first_image</span><span id="598e" class="np lr it pa b gy pl pf l pg ph">Todays date is Sun Feb 24 04:45:08 UTC 2019</span></pre><h2 id="ace2" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">用于管理图像的命令</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="4173" class="np lr it pa b gy pe pf l pg ph">+---------------------------------+--------------------------------+<br/>| <strong class="pa iu">Command</strong>                         | <strong class="pa iu">Description                    </strong>|<br/>+---------------------------------+--------------------------------+<br/>| <strong class="pa iu">docker images</strong>                   | List all images on the         |   |                                   machine.                       |<br/>| <strong class="pa iu">docker rmi [IMAGE_NAME]         </strong>| Remove the image with name     | |                                   <!-- -->IMAGE_NAME<!-- --> on the machine.     |<br/>| <strong class="pa iu">docker rmi $(docker images -q)</strong>  | Remove all images from the     | |                                   machine.                       |<br/>+------------+-----------------------------------------------------+</span></pre><h2 id="66fb" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">用于管理容器的命令</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="360c" class="np lr it pa b gy pe pf l pg ph">+-------------------------------+----------------------------------+<br/>| <strong class="pa iu">Command</strong>                       | <strong class="pa iu">Description                      </strong>|<br/>+-------------------------------+----------------------------------+<br/>| <strong class="pa iu">docker ps</strong>                     | List all containers. Append <!-- -->-a<!-- -->   |<br/>|                                 to also list containers not      | |                                 running.                         |<br/>| <strong class="pa iu">docker stop [CONTAINER_ID]    </strong>| Gracefully stop the container    |                                 |                                 with <!-- -->[CONTAINER_ID]<!-- --> on the       |   |                                 machine.                         |<br/>| <strong class="pa iu">docker kill CONTAINER_ID]</strong>     | Forcefully stop the container    |<br/>|                                 with <!-- -->[CONTAINER_ID]<!-- --> on the       |                              |                                 machine.                         |<br/>| <strong class="pa iu">docker rm [CONTAINER_ID]</strong>      | Remove the container with        |   |                                 <!-- -->[CONTAINER_ID<!-- -->] from the machine. |<br/>| <strong class="pa iu">docker rm $(docker ps -a -q)</strong>  | Remove all containers from the   | |                                 machine.                         |<br/>+------------+-----------------------------------------------------+</span></pre><h2 id="e2f3" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">运行 Docker 容器</h2><p id="572a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们分解下面运行 Docker 容器的命令。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="f496" class="np lr it pa b gy pe pf l pg ph">docker run -d -it --rm --name [CONTAINER_NAME] -p 8081:80 [IMAGE_NAME]</span></pre><p id="df99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在哪里，</p><ul class=""><li id="94e2" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><code class="fe pi pj pk pa b">-d</code>:以分离模式运行容器。该模式在后台运行容器。</li><li id="0e8b" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><code class="fe pi pj pk pa b">-it</code>:以交互模式运行，附带终端会话。</li><li id="7d90" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><code class="fe pi pj pk pa b">--rm</code>:退出时取出容器。</li><li id="b7fe" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><code class="fe pi pj pk pa b">--name</code>:指定容器的名称。</li><li id="98e3" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><code class="fe pi pj pk pa b">-p</code>:从主机到容器的端口转发(即主机:容器)。</li></ul><h2 id="e230" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">使用 Docker 在<code class="fe pi pj pk pa b">nginx</code>网络服务器上提供网页</h2><h2 id="2dc0" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">文档文件</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="e52b" class="np lr it pa b gy pe pf l pg ph"># base image for building container<br/>FROM docker.io/nginx<br/># add maintainer label<br/>LABEL maintainer="dvdbisong@gmail.com"<br/># copy html file from local machine to container filesystem<br/>COPY html/index.html /usr/share/nginx/html<br/># port to expose to the container<br/>EXPOSE 80</span></pre><h2 id="ac52" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">建立形象</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="b2c4" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"># navigate to directory</strong><br/>cd docker-intro/nginx-server/</span><span id="86d5" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"># build the image</strong><br/>docker build -t ekababisong.org/nginx_server .</span><span id="dddd" class="np lr it pa b gy pl pf l pg ph">Sending build context to Docker daemon  2.048kB<br/>Step 1/4 : FROM docker.io/nginx<br/>latest: Pulling from library/nginx<br/>6ae821421a7d: Pull complete<br/>da4474e5966c: Pull complete<br/>eb2aec2b9c9f: Pull complete<br/>Digest: sha256:dd2d0ac3fff2f007d99e033b64854be0941e19a2ad51f174d9240dda20d9f534<br/>Status: Downloaded newer image for nginx:latest<br/> ---&gt; f09fe80eb0e7<br/>Step 2/4 : LABEL maintainer="dvdbisong@gmail.com"<br/> ---&gt; Running in 084c2484893a<br/>Removing intermediate container 084c2484893a<br/> ---&gt; 2ced9e52fb67<br/>Step 3/4 : COPY html/index.html /usr/share/nginx/html<br/> ---&gt; 1d9684901bd3<br/>Step 4/4 : EXPOSE 80<br/> ---&gt; Running in 3f5738a94220<br/>Removing intermediate container 3f5738a94220<br/> ---&gt; 7f8e2fe2db73<br/>Successfully built 7f8e2fe2db73<br/>Successfully tagged ekababisong.org/nginx_server:latest</span><span id="15d3" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"># list images on machine</strong><br/>docker images</span><span id="830e" class="np lr it pa b gy pl pf l pg ph">REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE<br/>ekababisong.org/nginx_server     latest              0928acf9fcbf        18 hours ago        109MB<br/>ekababisong.org/first_image      latest              773973d28958        20 hours ago        5.53MB</span></pre><h2 id="c0cd" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">运行容器</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="7afd" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"># run the container</strong><br/>docker run -d -it --name ebisong-nginx -p 8081:80 ekababisong.org/nginx_server</span><span id="2381" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"># list containers</strong><br/>docker ps</span><span id="c5d3" class="np lr it pa b gy pl pf l pg ph">CONTAINER ID        IMAGE                          COMMAND                  CREATED             STATUS              PORTS                  NAMES<br/>b3380cc02551        ekababisong.org/nginx_server   "nginx -g 'daemon of…"   7 seconds ago       Up 4 seconds        0.0.0.0:8081-&gt;80/tcp   ebisong-nginx</span></pre><h2 id="9964" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在运行的服务器上查看网页</h2><p id="382f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">打开 web 浏览器并转到:0.0.0.0:8081</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/28c64382f6d4d9f8b2907fcca6d41d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0dRuTjTqUXexp5_Z.png"/></div></div></figure><h2 id="9e37" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">清除</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="1504" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"># shutdown the container</strong><br/>docker stop b3380cc02551</span><span id="8226" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"># remove the container</strong><br/>docker rm ebisong-nginx</span></pre><h2 id="46d0" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">将图像推送到 Dockerhub</h2><p id="f397" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">登录 Docker 并提供您的<code class="fe pi pj pk pa b">userid</code>和<code class="fe pi pj pk pa b">password</code>。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="315b" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"># login to docker</strong><br/>docker login</span><span id="64b5" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"># tag the image</strong><br/>docker tag 096e538abc1e ekababisong/ebisong-nginx-server:latest</span><span id="a4f4" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"># push to Dockerhub</strong><br/>docker push ekababisong/ebisong-nginx-server</span><span id="12e7" class="np lr it pa b gy pl pf l pg ph">The push refers to repository [docker.io/ekababisong/ebisong-nginx-server]<br/>db4c3e547e3f: Pushed<br/>6b5e2ed60418: Mounted from library/nginx<br/>92c15149e23b: Mounted from library/nginx<br/>0a07e81f5da3: Mounted from library/nginx<br/>latest: digest: sha256:733009c33c6cf2775fedea36a3e1032006f1fe3d5155f49d4ddc742ea1dce1f1 size: 1155</span></pre><h2 id="3873" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">卷</h2><p id="51f1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">本地目录可以作为卷安装到正在运行的容器中，而不是容器文件系统本身。对于卷，数据可以与容器共享，同时保存在本地机器上。卷在<code class="fe pi pj pk pa b">docker run</code>命令中贴有<code class="fe pi pj pk pa b">-v</code>标签。</p><h2 id="2037" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">将卷挂载到容器化的<code class="fe pi pj pk pa b">nginx</code> Web 服务器</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="7f77" class="np lr it pa b gy pe pf l pg ph">docker run -d -it --name ebisong-nginx -p 8081:80 -v /Users/ekababisong/Documents/Talks/kubeflow-for-poets/docker-intro/nginx-server/html:/usr/share/nginx/html  ekababisong.org/nginx_server</span></pre><p id="ae9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，无论对文件<code class="fe pi pj pk pa b">index.html</code>做了什么更改，都可以从 Docker 容器中的<code class="fe pi pj pk pa b">nginx</code>服务器的 web 浏览器上立即看到。</p><h2 id="348a" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">从 Dockerhub 运行 Tensorflow Jupyter 图像</h2><p id="3901" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">注意:这张图片很大，从 Dockerhub 中提取需要一段时间。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="164b" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"># pull the image from dockerhub</strong><br/>docker pull jupyter/tensorflow-notebook</span><span id="2a5d" class="np lr it pa b gy pl pf l pg ph">Using default tag: latest<br/>latest: Pulling from jupyter/tensorflow-notebook<br/>a48c500ed24e: Pull complete<br/>...<br/>edbe68d32a46: Pull complete<br/>Digest: sha256:75f1ffa1582a67eace0f96aec95ded82ce6bf491e915af80ddc039befea926aa<br/>Status: Downloaded newer image for jupyter/tensorflow-notebook:latest</span></pre><h2 id="68e2" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">运行 Tensorflow Jupyter 容器</h2><p id="90ba" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这个命令启动一个运行 Jupyter 笔记本服务器的<em class="oh">短暂</em>容器，并在主机端口 8888 上公开服务器。服务器日志出现在终端中。访问 http:// &lt;主机名&gt; :8888/？浏览器中的 token= &lt; token &gt;加载 Jupyter 笔记本仪表板页面。它是短暂的，因为 Docker 在笔记本服务器退出后销毁了容器。这是因为<code class="fe pi pj pk pa b">docker run</code>命令中的<code class="fe pi pj pk pa b">--rm</code>标签。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="d182" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"># run the image</strong><br/>docker run --rm -p 8888:8888 jupyter/tensorflow-notebook</span></pre><p id="56d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图显示了一个从 Docker 容器运行的笔记本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/522bfcae69d9e7312553f214eae459e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8akt-bWVTw241Lqx.png"/></div></div></figure><p id="52d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">按下<code class="fe pi pj pk pa b">control + c</code>收回本地终端。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="58d3" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">库伯内特斯</h1><p id="c33b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当微服务应用程序被部署到生产环境中时，它通常会有许多正在运行的容器，需要为这些容器分配适量的资源来响应用户的需求。此外，还需要确保容器在线、正在运行并相互通信。高效管理和协调集装箱化应用集群的需求催生了 Kubernetes。</p><p id="cdcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes 是一个软件系统，它解决了部署、扩展和监控容器的问题。因此，它被称为<em class="oh">容器编排器</em>。其他类似的例子有 Docker Swarm、Mesos Marathon 和 Hashicorp Nomad。</p><p id="b56b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes 是由谷歌作为开源软件构建和发布的，现在由<a class="ae mw" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会(CNCF) </a>管理。谷歌云平台提供了一个名为<a class="ae mw" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">的托管 Kubernetes 服务，谷歌 Kubernetes 引擎(GKE) </strong> </a>。<a class="ae mw" href="https://aws.amazon.com/kubernetes/" rel="noopener ugc nofollow" target="_blank">针对 Kubernetes (EKS)的亚马逊弹性容器服务</a>也提供托管的 Kubernetes 服务。</p><h2 id="9790" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">库伯内特的特点</h2><ul class=""><li id="8064" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp ms mt mu mv bi translated"><strong class="kw iu">水平自动缩放:</strong>根据资源需求动态缩放容器。</li><li id="7118" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">自我修复:</strong>重新配置失败的节点以响应健康检查。</li><li id="96da" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">负载平衡:</strong>有效地在 pod 中的容器之间分配请求。</li><li id="2b09" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">回滚和更新:</strong>轻松更新或恢复到以前的容器部署，而不会导致应用程序停机。</li><li id="ffbb" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu"> DNS 服务发现:</strong>使用域名系统(DNS)作为 Kubernetes 服务来管理容器组。</li></ul><h2 id="d84c" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">库伯内特斯的成分</h2><p id="ea8d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Kubernetes 发动机的主要部件有:</p><ul class=""><li id="0e83" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu">主节点</strong>:管理 Kubernetes 集群。出于容错目的，它们可以是处于高可用性模式的多个主节点。在这种情况下，只有一个是主，其他的都是从。</li><li id="8e08" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">工作节点</strong>:运行被调度为 pod 的容器化应用程序的机器。</li></ul><p id="5cbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图提供了 Kubernetes 架构的概述。稍后，我们将简要介绍各个子组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/7175b86780112c90c61c178ccdd2326f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LyvNyxxCDcLGLkli.png"/></div></div></figure><h2 id="a8bb" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">主节点</h2><ul class=""><li id="e635" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp ms mt mu mv bi translated"><strong class="kw iu"> etcd(分布式密钥存储):</strong>管理 Kubernetes 集群状态。这个分布式密钥库可以是主节点的一部分，也可以在主节点之外。然而，所有主节点都连接到它。</li><li id="524e" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu"> api 服务器:</strong>管理所有管理任务。<code class="fe pi pj pk pa b">api server</code>接收来自用户的命令(<code class="fe pi pj pk pa b">kubectl</code> cli、REST 或 GUI)，执行这些命令，并将新的集群状态存储在分布式密钥库中。</li><li id="ae89" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">调度器:</strong>通过分配 pod 将工作调度到工作节点。它负责资源分配。</li><li id="9226" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">控制器:</strong>确保 Kubernetes 集群保持所需的状态。理想状态是 JSON 或 YAML 部署文件中包含的状态。</li></ul><h2 id="1ecd" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">工作节点</h2><ul class=""><li id="ad11" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp ms mt mu mv bi translated"><strong class="kw iu">kube let:</strong><code class="fe pi pj pk pa b">kubelet</code>代理运行在每个工人节点上。它将工作节点连接到主节点上的<code class="fe pi pj pk pa b">api server</code>,并从它那里接收指令。确保节点上的单元运行正常。</li><li id="aeca" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">kube-proxy: 它是运行在每个工作节点上的 Kubernetes 网络代理。它会监听<code class="fe pi pj pk pa b">api server</code>，并将请求转发给适当的 pod。这对负载平衡很重要。</li><li id="880d" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">pod:</strong>由一个或多个共享网络和存储资源以及容器运行时指令的容器组成。豆荚是库伯内特最小的可部署单位。</li></ul><h2 id="63b9" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">编写 Kubernetes 部署文件</h2><p id="f46b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Kubernetes 部署文件定义了各种 Kubernetes 对象所需的状态。Kubernetes 对象的示例有:</p><ul class=""><li id="a1d2" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">一个或多个容器的集合。</li><li id="5dd1" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">副本集:</strong>主节点中<code class="fe pi pj pk pa b">controller</code>的一部分。指定在任何给定时间应该运行的 pod 的副本数量。它确保在集群中维护指定数量的 pod。</li><li id="4079" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">部署:</strong>自动创建<code class="fe pi pj pk pa b">ReplicaSets</code>。它也是主节点中<code class="fe pi pj pk pa b">controller</code>的一部分。确保集群的当前状态与所需状态相匹配。</li><li id="cff5" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">名称空间:</strong>将集群划分成子集群，以便将用户组织成组。</li><li id="916b" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">服务:</strong>一组逻辑单元，具有访问它们的策略。</li><li id="1fd1" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><em class="oh">服务类型:</em>指定服务的类型，如<code class="fe pi pj pk pa b">ClusterIP</code>、<code class="fe pi pj pk pa b">NodePort</code>、<code class="fe pi pj pk pa b">LoadBalancer</code>、<code class="fe pi pj pk pa b">ExternalName</code>。例如，<code class="fe pi pj pk pa b">LoadBalancer</code>使用云提供商的负载均衡器对外公开服务。</li></ul><p id="fc35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编写 Kubernetes 部署文件的其他重要标记。</p><ul class=""><li id="f30b" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu">规格:</strong>描述集群的期望状态。</li><li id="c4ef" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">元数据:</strong>包含对象的信息。</li><li id="b0b3" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">标签:</strong>用于将对象的属性指定为键值对。</li><li id="4314" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><strong class="kw iu">选择器:</strong>用于根据标签值选择对象的子集。</li></ul><p id="823a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部署文件被指定为一个<code class="fe pi pj pk pa b">yaml</code>文件。</p><p id="a7fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一节中的示例将在前面的章节中推送到 Dockerhub 的 nginx 服务器映像部署到 Kubernetes 集群。该图像可在<a class="ae mw" href="https://hub.docker.com/r/ekababisong/ebisong-nginx-server" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/ekababisong/ebisong-nginx-server</a>获得。</p><h2 id="ea82" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">服务对象的示例</h2><p id="5339" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这个<code class="fe pi pj pk pa b">Service</code>对象的代码片段保存在<code class="fe pi pj pk pa b">kubernetes-intro/deployment.yaml</code>中。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="e502" class="np lr it pa b gy pe pf l pg ph">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: nginx-server-service<br/>spec:<br/>  <em class="oh"># service applies to the application with name `nginx-server`</em><br/>  selector:<br/>    app: nginx-server<br/>  ports:<br/>    - protocol: "TCP"<br/>      <em class="oh"># port inside cluster</em><br/>      port: 8080<br/>      <em class="oh"># forward to port inside the pod</em><br/>      targetPort: 80<br/>      <em class="oh"># accessible outside cluster</em><br/>      nodePort: 30001<br/>  <em class="oh"># load balance between 5 instances of the container application</em><br/>  type: LoadBalancer</span></pre><h2 id="f7e7" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">部署对象的示例</h2><p id="f5b2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这个<code class="fe pi pj pk pa b">Deployment</code>对象的代码片段保存在<code class="fe pi pj pk pa b">kubernetes-intro/deployment.yaml</code>中。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="1054" class="np lr it pa b gy pe pf l pg ph">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-server-deployment<br/>spec:<br/>  replicas: 5<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx-server<br/>    spec:<br/>      containers:<br/>        - name: nginx-server<br/>          image: ekababisong/ebisong-nginx-server<br/>          ports:<br/>            - containerPort: 80</span></pre><h2 id="6a14" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">使用 Minikube 在本地机器上运行 Kubernetes</h2><p id="50b0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Minikube 使得在本地机器上安装和运行单节点 Kubernetes 集群变得很容易。前往<a class="ae mw" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/tasks/tools/install-minikube/</a>获取安装 Minikube 的说明。</p><ol class=""><li id="7859" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp po mt mu mv bi translated">安装一个管理程序，例如<a class="ae mw" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener ugc nofollow" target="_blank"> VirtualBox </a>。</li><li id="63ab" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp po mt mu mv bi translated">安装 Kubernetes 命令行界面<code class="fe pi pj pk pa b">kubectl</code>。对于 mac:</li></ol><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="c09f" class="np lr it pa b gy pe pf l pg ph">brew install kubernetes-cli</span></pre><p id="ea08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查安装的版本:</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="a7ae" class="np lr it pa b gy pe pf l pg ph">kubectl version</span></pre><p id="6bce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.安装 Minikube。对于 mac:</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="79f3" class="np lr it pa b gy pe pf l pg ph">brew cask install minikube</span></pre><h2 id="85f4" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">Minikube 命令概述</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="7448" class="np lr it pa b gy pe pf l pg ph">+---------------------+--------------------------------------------+<br/>| <strong class="pa iu">Command</strong>             | <strong class="pa iu">Description                                </strong>|<br/>+---------------------+--------------------------------------------+<br/>| <strong class="pa iu">minikube status</strong>     | Check if Minikube is running.              |<br/>| <strong class="pa iu">minikube start      </strong>| Create local kubernetes cluster.           |                                 <br/>| <strong class="pa iu">minikube stop</strong>       | Stop a running local kubernetes cluster.   |<br/>| <strong class="pa iu">minikube dashboard</strong>  | Open Minikube GUI for interacting with the | |                       Kubernetes cluster. Append <!-- -->&amp;<!-- --> to open in    | |                       background mode <!-- -->minikube dashboard &amp;<!-- -->.      |<br/>| <strong class="pa iu">minikube ip</strong>         | get ip address of Kubernetes cluster.      |<br/>+------------+-----------------------------------------------------+</span></pre><h2 id="55a3" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated"><code class="fe pi pj pk pa b">kubectl</code>命令概述</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="d827" class="np lr it pa b gy pe pf l pg ph">+-------------------------------------------+----------------------+<br/>| <strong class="pa iu">Command</strong>                                   | <strong class="pa iu">Description          </strong>|<br/>+-------------------------------------------+----------------------+<br/>| <strong class="pa iu">kubectl get all</strong>                           | list all resources.  |<br/>| <strong class="pa iu">kubectl get pods                          </strong>| list pods.           |                                 <br/>| <strong class="pa iu">kubectl get service                       </strong>| list services.       | <br/>| <strong class="pa iu">kubectl get deployments --all-namespaces</strong>  | list deployments for | |                                             all namespaces.      | | <strong class="pa iu">kubectl create -f [DEPLOYMENT_FILE.yaml]</strong>  | create a new resource|  |                                             based on the desired | |                                             state in the <!-- -->yaml    |  |                                             <!-- -->file.                | | <strong class="pa iu">kubectl apply -f [DEPLOYMENT_FILE.yaml]</strong>   | if the resource      |  |                                             already exists,      | |                                             refresh the resource |<!-- -->  |                                             <!-- -->based on the yaml.   |             |                                             file.                |<br/>| <strong class="pa iu">kubectl delete -f [DEPLOYMENT_FILE.yaml]</strong>  | remove all resources |  |                                             from the <!-- -->yaml<!-- --> file.  |<br/>| <strong class="pa iu">kubectl get nodes</strong>                         | get the nodes of the | |                                             Kubernetes cluster.  | | <strong class="pa iu">kubectl delete deployment [DEPLOYMENT_NAME] </strong>| delete the         | |                                               deployment with    | |                                               <!-- -->[DEPLOYMENT_NAME]<!-- -->. |<br/>| <strong class="pa iu">kubectl delete svc [SERVICE_NAME]         </strong>| delete the service   | |                                             with <!-- -->[SERVICE_NAME]<!-- -->. |<br/>| <strong class="pa iu">kubectl delete pod [POD_NAME]</strong>             | delete the pod with  | |                                             <!-- -->[POD_NAME]<!-- -->.          |<br/>+------------+-----------------------------------------------------+</span></pre><h2 id="59fc" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">使用<code class="fe pi pj pk pa b">kubectl</code>在带有 Minikube 的本地机器上部署 Kubernetes</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="213a" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># create local kubernetes cluster</em></strong><br/>minikube start</span><span id="995c" class="np lr it pa b gy pl pf l pg ph">Starting local Kubernetes v1.13.2 cluster...<br/>Starting VM...</span><span id="87da" class="np lr it pa b gy pl pf l pg ph">Getting VM IP address...<br/>Moving files into cluster...<br/>Setting up certs...<br/>Connecting to cluster...<br/>Setting up kubeconfig...<br/>Stopping extra container runtimes...<br/>Machine exists, restarting cluster components...<br/>Verifying kubelet health ...<br/>Verifying apiserver health ....<br/>Kubectl is now configured to use the cluster.<br/>Loading cached images from config file.</span><span id="242e" class="np lr it pa b gy pl pf l pg ph">Everything looks great. Please enjoy minikube!</span><span id="9b32" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># navigate to the directory with deployment file</em></strong><br/>cd kubernetes-intro/</span><span id="2dfc" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># create a new resource from yaml file</em></strong><br/>kubectl create -f deployment.yaml</span><span id="f068" class="np lr it pa b gy pl pf l pg ph">service "nginx-server-service" created<br/>deployment.extensions "nginx-server-deployment" created</span><span id="8c2f" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># launch minikube dashboard</em></strong><br/>minikube dashboard</span><span id="1fb5" class="np lr it pa b gy pl pf l pg ph">Verifying dashboard health ...<br/>Launching proxy ...<br/>Verifying proxy health ...<br/>Opening http://127.0.0.1:54356/api/v1/namespaces/kube-system/services/http:kubernetes-dashboard:/proxy/ in your default browser...</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/fa7f22c1eabf7fe7458c43cbdc5b7aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0cTLmUvNI3tcENcy.png"/></div></div></figure><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="1422" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># list pods</em></strong><br/>kubectl get pods</span><span id="4d53" class="np lr it pa b gy pl pf l pg ph">NAME                                      READY     STATUS    RESTARTS   AGE<br/>nginx-server-deployment-f878d8679-5ptlc   1/1       Running   0          10m<br/>nginx-server-deployment-f878d8679-6gk26   1/1       Running   0          10m<br/>nginx-server-deployment-f878d8679-9hdhh   1/1       Running   0          10m<br/>nginx-server-deployment-f878d8679-pfm27   1/1       Running   0          10m<br/>nginx-server-deployment-f878d8679-rnmhw   1/1       Running   0          10m</span><span id="d118" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># get ip address of kubernetes cluster</em></strong><br/>$ minikube ip</span><span id="6715" class="np lr it pa b gy pl pf l pg ph">192.168.99.102</span></pre><h2 id="00e0" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在由 Kubernetes 编排的 pod 上运行网页</h2><p id="7d47" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们通过运行<a class="ae mw" href="http://192.168.99.102:30001/" rel="noopener ugc nofollow" target="_blank"> 192.168.99.102:30001 </a>来访问 Kubernetes 集群中的应用程序。我们使用端口<code class="fe pi pj pk pa b">30001</code>,因为我们从集群外部访问应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/ba4af212c8f146b64359eda731ccdfb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ruvky_xi4D5btxTn.png"/></div></div></figure><h2 id="5240" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">删除部署并停止 Minikube</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="62e8" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># delete the deployment</em></strong><br/>kubectl delete -f deployment.yaml</span><span id="414e" class="np lr it pa b gy pl pf l pg ph">service "nginx-server-service" deleted<br/>deployment.extensions "nginx-server-deployment" deleted</span><span id="29e9" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># stop minikube</em></strong><br/>minikube stop</span><span id="9312" class="np lr it pa b gy pl pf l pg ph">Stopping local Kubernetes cluster...<br/>Machine stopped.</span></pre><h2 id="c6a0" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在 Google Kubernetes 引擎上部署 Kubernetes</h2><p id="cb4c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了从本地 shell 在 GCP 上创建和部署资源，必须安装和配置 Google 命令行 SDK <code class="fe pi pj pk pa b">gcloud</code>。如果您的机器不是这种情况，请遵循<a class="ae mw" href="https://cloud.google.com/sdk/gcloud/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/sdk/gcloud/</a>中的说明。否则，更简单的选择是使用已经安装了<code class="fe pi pj pk pa b">gcloud</code>和<code class="fe pi pj pk pa b">kubectl</code>(Kubernetes 命令行界面)的 Google Cloud Shell。</p><h2 id="08d2" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">创建 GKE 集群</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="0425" class="np lr it pa b gy pe pf l pg ph"><em class="oh"># create a GKE cluster</em><br/>gcloud container clusters create ekaba-gke-cluster</span></pre><p id="7727" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes 集群在 GCP 上创建，有 3 个节点(默认)。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="14a5" class="np lr it pa b gy pe pf l pg ph">Creating cluster ekaba-gke-cluster in us-central1-a... Cluster is being deployed...done.<br/>Created [https://container.googleapis.com/v1/projects/oceanic-sky-230504/zones/us-central1-a/clusters/ekaba-gke-cluster].<br/>To inspect the contents of your cluster, go to: https://console.cloud.google.com/kubernetes/workload_/gcloud/us-central1-a/ekaba-gke-cluster?project=oceanic-sky-230504<br/>kubeconfig entry generated for ekaba-gke-cluster.<br/>NAME               LOCATION       MASTER_VERSION  MASTER_IP     MACHINE_TYPE   NODE_VERSION  NUM_NODES  STATUS<br/>ekaba-gke-cluster  us-central1-a  1.11.7-gke.4    35.226.72.40  n1-standard-1  1.11.7-gke.4  3          RUNNING</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/b0f832ebdc97568ff605e416f5deee95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N6aDODoWMXfM6Khk.png"/></div></div></figure><p id="af16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要了解有关使用 Google Kubernetes 引擎创建集群的更多信息，请访问<a class="ae mw" href="https://cloud.google.com/kubernetes-engine/docs/how-to/creating-a-cluster" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/Kubernetes-Engine/docs/how-to/creating-a-cluster</a>。</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="f951" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># get the nodes of the kubernetes cluster on GKE</em></strong><br/>kubectl get nodes</span><span id="c33a" class="np lr it pa b gy pl pf l pg ph">NAME                                               STATUS    ROLES     AGE       VERSION<br/>gke-ekaba-gke-cluster-default-pool-e28c64e0-8fk1   Ready     &lt;none&gt;    45m       v1.11.7-gke.4<br/>gke-ekaba-gke-cluster-default-pool-e28c64e0-fmck   Ready     &lt;none&gt;    45m       v1.11.7-gke.4<br/>gke-ekaba-gke-cluster-default-pool-e28c64e0-zzz1   Ready     &lt;none&gt;    45m       v1.11.7-gke.4</span></pre><h2 id="1e9a" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在 GKE 上部署 Nginx Web 服务器</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="c685" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># navigate to directory with deployment file</em></strong><br/>cd kubernetes-intro/</span><span id="7f0e" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># create new resource from yaml file</em></strong><br/>kubectl create -f deployment.yaml</span><span id="74bb" class="np lr it pa b gy pl pf l pg ph">service "nginx-server-service" created<br/>deployment.extensions "nginx-server-deployment" created</span></pre><p id="9a57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部署详情可在 GCP Kubernetes 发动机控制台上查看:</p><p id="5bc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">Kubernetes 引擎控制台上的工作负载</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/cc59a298e7217dabb7ed2a1f9b5cb020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YkFUXKNyVgI_izr0.png"/></div></div></figure><p id="0b38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">GKE 控制台上的部署详情</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/f0f76cb19b0fcdc50853081af2e3ac95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vg7BrWIBg1__136y.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/b0f17f443c9f09485d02367c73709ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ToX8B56lwvJafgNI.png"/></div></div></figure><p id="ec6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">列表框</strong></p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="9004" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># list pods</em></strong><br/>kubectl get pods</span><span id="f8c8" class="np lr it pa b gy pl pf l pg ph">NAME                                       READY     STATUS    RESTARTS   AGE<br/>nginx-server-deployment-6d4cf7bb78-4swcb   1/1       Running   0          41m<br/>nginx-server-deployment-6d4cf7bb78-5cdqc   1/1       Running   0          41m<br/>nginx-server-deployment-6d4cf7bb78-bkjrp   1/1       Running   0          41m<br/>nginx-server-deployment-6d4cf7bb78-d8b2l   1/1       Running   0          41m<br/>nginx-server-deployment-6d4cf7bb78-mhpss   1/1       Running   0          41m</span></pre><p id="9ca5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">获取 GKE 上吊舱部署的外部 IP</strong></p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="8743" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># get kubernetes service</em></strong><br/>kubectl get service</span><span id="e7f9" class="np lr it pa b gy pl pf l pg ph">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE<br/>kubernetes             ClusterIP      10.23.240.1     &lt;none&gt;           443/TCP          1h<br/>nginx-server-service   LoadBalancer   10.23.248.194   35.188.151.138   8080:30001/TCP   57m</span></pre><h2 id="76d5" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在 GKE 上运行的应用程序</h2><p id="a6fb" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过运行<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/35.188.151.138:8080">35.188.151.138:8080</a>来访问部署在 GKE 上的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/3830be1c75a126ddf6774f290fd5c97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3wyarYiopRjL6Y3E.png"/></div></div></figure><h2 id="af34" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">删除在 GKE 的部署</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="1004" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># delete the deployment</em></strong><br/>kubectl delete -f deployment.yaml</span><span id="ce06" class="np lr it pa b gy pl pf l pg ph">service "nginx-server-service" deleted<br/>deployment.extensions "nginx-server-deployment" deleted</span></pre><h2 id="15c1" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">删除 GKE 上的 Kubernetes 集群</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="95e3" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># delete the kubernetes cluster</em></strong><br/>gcloud container clusters delete ekaba-gke-cluster</span><span id="428f" class="np lr it pa b gy pl pf l pg ph">The following clusters will be deleted.<br/> - [ekaba-gke-cluster] in [us-central1-a]</span><span id="a53f" class="np lr it pa b gy pl pf l pg ph">Do you want to continue (Y/n)?  Y</span><span id="6c91" class="np lr it pa b gy pl pf l pg ph">Deleting cluster ekaba-gke-cluster...done.<br/>Deleted [https://container.googleapis.com/v1/projects/oceanic-sky-230504/zones/us-central1-a/clusters/ekaba-gke-cluster].</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="6474" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">库贝弗洛</h1><p id="bcdc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Kubeflow 是一个平台，旨在增强和简化在 Kubernetes 上部署机器学习工作流的过程。使用 Kubeflow，通过将组件(如培训、服务、监控和记录组件)放入 Kubernetes 集群上的容器中，管理分布式机器学习部署变得更加容易。</p><p id="efc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubeflow 的目标是抽象出管理 Kubernetes 集群的技术细节，以便机器学习从业者可以快速利用 Kubernetes 的能力和在微服务框架内部署产品的好处。在 2017 年底开源之前，Kubeflow 一直是谷歌在 Kubernetes 上实现机器学习管道的内部框架。</p><h2 id="ea3f" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">使用 Kubeflow</h2><p id="d6bd" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">以下是 Kubeflow 上运行的一些组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/95d8e1009dae60b574470037f618c898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wfi6xk6h-yAWnyc_.png"/></div></div></figure><h2 id="c32a" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在 GKE 建立一个 Kubernetes 集群</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="8b37" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># create a GKE cluster</em></strong><br/>gcloud container clusters create ekaba-gke-cluster</span><span id="3871" class="np lr it pa b gy pl pf l pg ph">Creating cluster ekaba-gke-cluster in us-central1-a... Cluster is being health-checked (master is healthy)...done.<br/>Created [https://container.googleapis.com/v1/projects/oceanic-sky-230504/zones/us-central1-a/clusters/ekaba-gke-cluster].<br/>To inspect the contents of your cluster, go to: https://console.cloud.google.com/kubernetes/workload_/gcloud/us-central1-a/ekaba-gke-cluster?project=oceanic-sky-230504<br/>kubeconfig entry generated for ekaba-gke-cluster.<br/>NAME               LOCATION       MASTER_VERSION  MASTER_IP      MACHINE_TYPE   NODE_VERSION  NUM_NODES  STATUS<br/>ekaba-gke-cluster  us-central1-a  1.11.7-gke.4    35.193.101.24  n1-standard-1  1.11.7-gke.4  3          RUNNING</span><span id="69dc" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># view the nodes of the kubernetes cluster on GKE</em></strong><br/>kubectl get nodes</span><span id="7c15" class="np lr it pa b gy pl pf l pg ph">NAME                                               STATUS    ROLES     AGE       VERSION<br/>gke-ekaba-gke-cluster-default-pool-0f55a72b-0707   Ready     &lt;none&gt;    4m        v1.11.7-gke.4<br/>gke-ekaba-gke-cluster-default-pool-0f55a72b-b0xv   Ready     &lt;none&gt;    4m        v1.11.7-gke.4<br/>gke-ekaba-gke-cluster-default-pool-0f55a72b-g4w8   Ready     &lt;none&gt;    4m        v1.11.7-gke.4</span></pre><h2 id="d30a" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">创建 OAuth 客户端 ID 来标识云 IAP</h2><p id="fdb1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Kubeflow 使用云身份感知代理(Cloud IAP)安全地连接到 Jupyter 和其他正在运行的 web 应用。Kubeflow 使用电子邮件地址进行身份验证。在本节中，我们将创建一个 OAuth 客户端 ID，用于在请求访问用户的电子邮件帐户时识别 Cloud IAP。</p><ul class=""><li id="0bd6" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">转到 GCP 控制台中的<a class="ae mw" href="https://console.cloud.google.com/apis/credentials" rel="noopener ugc nofollow" target="_blank">API&amp;服务- &gt;凭证</a>页面。</li><li id="23e5" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">转到 OAuth 同意屏幕:</li><li id="6380" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">分配一个应用程序名称，例如 My-Kubeflow-App</li><li id="b6e1" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">对于授权域，请使用[您的产品 ID].cloud.goog</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/d41425cb7379cb7fdd12a36d3ebd0d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GkQzKxb54_LIIjCM.png"/></div></div></figure><ul class=""><li id="b983" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">转到凭据选项卡:</li><li id="5d52" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">单击创建凭据，然后单击 OAuth 客户端 ID。</li><li id="2ded" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">在应用程序类型下，选择 Web 应用程序。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/06eda990d589b09af99a6dd1e3205bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B-1iQ05Uxr4KdpFA.png"/></div></div></figure><ul class=""><li id="8e15" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">选择一个<strong class="kw iu">名称</strong>来标识 OAuth 客户端 ID。</li><li id="6d14" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">在“授权重定向 URIs”框中，输入以下内容:</li></ul><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="bd30" class="np lr it pa b gy pe pf l pg ph">https://&lt;deployment_name&gt;.endpoints.&lt;project&gt;.cloud.goog/_gcp_gatekeeper/authenticate</span></pre><ul class=""><li id="ea44" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><deployment_name>必须是库巴流部署的名称。</deployment_name></li><li id="d5dd" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><project>是 GCP 项目 ID。</project></li><li id="1fb9" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">在这种情况下，它将是:</li></ul><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="e819" class="np lr it pa b gy pe pf l pg ph"><a class="ae mw" href="https://ekaba-kubeflow-app.endpoints.oceanic-sky-230504.cloud.goog/_gcp_gatekeeper/authenticate" rel="noopener ugc nofollow" target="_blank">https://ekaba-kubeflow-app.endpoints.oceanic-sky-230504.cloud.goog/_gcp_gatekeeper/authenticate</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/7fe18527b060b573a695d3e88e6bfe03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j0CdSxKKQcjlNAJc.png"/></div></div></figure><ul class=""><li id="ac7d" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">记下 OAuth 客户端窗口中出现的客户端 ID 和客户端密码。这是启用云 IAP 所必需的。</li></ul><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="bafb" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># Create environment variables from the OAuth client ID and secret earlier obtained.</em><br/></strong>export CLIENT_ID<strong class="pa iu">=</strong>506126439013-drbrj036hihvdolgki6lflovm4bjb6c1.apps.googleusercontent.com<br/>export CLIENT_SECRET<strong class="pa iu">=</strong>bACWJuojIVm7PIMphzTOYz9D<br/>export PROJECT<strong class="pa iu">=</strong>oceanic-sky-230504</span></pre><h2 id="c1cc" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">下载 kfctl.sh</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="946b" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># create a folder on the local machine</em></strong><br/>mkdir kubeflow</span><span id="1896" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># move to created folder</em></strong><br/>cd kubeflow</span><span id="a8a1" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># save folder path as a variable</em></strong><br/>export KUBEFLOW_SRC<strong class="pa iu">=$(</strong>pwd<strong class="pa iu">)</strong></span><span id="b1e8" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># download kubeflow `kfctl.sh`</em></strong><br/>export KUBEFLOW_TAG<strong class="pa iu">=</strong>v0.4.1</span><span id="52de" class="np lr it pa b gy pl pf l pg ph">curl https://raw.githubusercontent.com/kubeflow/kubeflow/<strong class="pa iu">${</strong>KUBEFLOW_TAG<strong class="pa iu">}</strong>/scripts/download.sh | bash</span><span id="d37b" class="np lr it pa b gy pl pf l pg ph">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br/>                                 Dload  Upload   Total   Spent    Left  Speed<br/>100   800  100   800    0     0   1716      0 --:--:-- --:--:-- --:--:--  1716<br/>+ '[' '!' -z 0.4.1 ']'<br/>+ KUBEFLOW_TAG=v0.4.1<br/>+ KUBEFLOW_TAG=v0.4.1<br/>++ mktemp -d /tmp/tmp.kubeflow-repo-XXXX<br/>+ TMPDIR=/tmp/tmp.kubeflow-repo-MJcy<br/>+ curl -L -o /tmp/tmp.kubeflow-repo-MJcy/kubeflow.tar.gz https://github.com/kubeflow/kubeflow/archive/v0.4.1.tar.gz<br/>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br/>                                 Dload  Upload   Total   Spent    Left  Speed<br/>100   125    0   125    0     0     64      0 --:--:--  0:00:01 --:--:--    64<br/>100 8099k    0 8099k    0     0  1309k      0 --:--:--  0:00:06 --:--:-- 2277k<br/>+ tar -xzvf /tmp/tmp.kubeflow-repo-MJcy/kubeflow.tar.gz -C /tmp/tmp.kubeflow-repo-MJcy<br/>...<br/>x kubeflow-0.4.1/tf-controller-examples/tf-cnn/README.md<br/>x kubeflow-0.4.1/tf-controller-examples/tf-cnn/create_job_specs.py<br/>x kubeflow-0.4.1/tf-controller-examples/tf-cnn/launcher.py<br/>++ find /tmp/tmp.kubeflow-repo-MJcy -maxdepth 1 -type d -name 'kubeflow*'<br/>+ KUBEFLOW_SOURCE=/tmp/tmp.kubeflow-repo-MJcy/kubeflow-0.4.1<br/>+ cp -r /tmp/tmp.kubeflow-repo-MJcy/kubeflow-0.4.1/kubeflow ./<br/>+ cp -r /tmp/tmp.kubeflow-repo-MJcy/kubeflow-0.4.1/scripts ./<br/>+ cp -r /tmp/tmp.kubeflow-repo-MJcy/kubeflow-0.4.1/deployment ./</span><span id="f62a" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># list directory elements</em></strong><br/>ls -la</span><span id="fd1c" class="np lr it pa b gy pl pf l pg ph">drwxr-xr-x   6 ekababisong  staff   204 17 Mar 04:15 .<br/>drwxr-xr-x  25 ekababisong  staff   850 17 Mar 04:09 ..<br/>drwxr-xr-x   4 ekababisong  staff   136 17 Mar 04:18 deployment<br/>drwxr-xr-x  36 ekababisong  staff  1224 17 Mar 04:14 kubeflow<br/>drwxr-xr-x  16 ekababisong  staff   544 17 Mar 04:14 scripts</span></pre><h2 id="440f" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">部署 Kubeflow</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="4fe8" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># assign the name for the Kubeflow deployment</em><br/><em class="oh"># The ksonnet app is created in the directory ${KFAPP}/ks_app</em></strong><br/>export KFAPP<strong class="pa iu">=</strong>ekaba-kubeflow-app</span><span id="9d76" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># run setup script</em></strong><br/><strong class="pa iu">${</strong>KUBEFLOW_SRC<strong class="pa iu">}</strong>/scripts/kfctl.sh init <strong class="pa iu">${</strong>KFAPP<strong class="pa iu">}</strong> --platform gcp --project <strong class="pa iu">${</strong>PROJECT<strong class="pa iu">}</strong></span><span id="d6ab" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># navigate to the deployment directory</em></strong><br/>cd <strong class="pa iu">${</strong>KFAPP<strong class="pa iu">}</strong></span><span id="cf31" class="np lr it pa b gy pl pf l pg ph"><em class="oh"># creates config files defining the various resources for gcp</em><br/><strong class="pa iu">${</strong>KUBEFLOW_SRC<strong class="pa iu">}</strong>/scripts/kfctl.sh generate platform<br/><em class="oh"># creates or updates gcp resources</em><br/><strong class="pa iu">${</strong>KUBEFLOW_SRC<strong class="pa iu">}</strong>/scripts/kfctl.sh apply platform<br/><em class="oh"># creates config files defining the various resources for gke</em><br/><strong class="pa iu">${</strong>KUBEFLOW_SRC<strong class="pa iu">}</strong>/scripts/kfctl.sh generate k8s<br/><em class="oh"># creates or updates gke resources</em><br/><strong class="pa iu">${</strong>KUBEFLOW_SRC<strong class="pa iu">}</strong>/scripts/kfctl.sh apply k8s</span><span id="6353" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># view resources deployed in namespace kubeflow</em></strong><br/>kubectl -n kubeflow get  all</span></pre><p id="9270" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubeflow 可从以下网址获得:<a class="ae mw" href="https://ekaba-kubeflow-app.endpoints.oceanic-sky-230504.cloud.goog/" rel="noopener ugc nofollow" target="_blank">https://e kaba-kube flow-app . endpoints . oceanic-sky-230504 . cloud . goog/</a></p><p id="13db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>URI 可能需要 10-15 分钟才能可用。Kubeflow 需要提供一个签名的 SSL 证书并注册一个 DNS 名称。</p><p id="1604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">kube flow 主屏幕</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/8f4f47eaa8b425a9a2746cbed6aeb199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-Pgz2sgPFbmYT0uZGDdcg.png"/></div></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="e593" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">库伯弗洛管道公司</h1><p id="92bb" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Kubeflow Pipelines 是一个简单的平台，用于在 Kubernetes 上构建和部署容器化的机器学习工作流。Kubeflow 管道使得实现生产级机器学习管道变得容易，而不需要考虑管理 Kubernetes 集群的底层细节。</p><p id="2010" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubeflow 管道是 Kubeflow 的核心组件，也是在部署 Kubeflow 时部署的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/034b88471489934deaef426ad9be34a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w5MiRzHwRkXnIZM4.png"/></div></div></figure><h2 id="a89d" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">Kubeflow 管道的组件</h2><p id="99d3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">管道描述了机器学习工作流，其中管道的每个组件都是一组自包含的代码，这些代码被打包为 Docker 图像。每个管道都可以单独上传，并在 Kubeflow 管道用户界面(UI)上共享。管道接收运行管道所需的输入(参数)以及每个组件的输入和输出。</p><p id="e577" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubeflow 管道平台包括:</p><ul class=""><li id="8a37" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">用于管理和跟踪实验、作业和运行的用户界面(UI)。</li><li id="4908" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">用于安排多步骤 ML 工作流的引擎。</li><li id="8edf" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">用于定义和操作管道和组件的 SDK。</li><li id="5932" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">使用 SDK 与系统交互的笔记本电脑。(摘自:<a class="ae mw" href="https://www.kubeflow.org/docs/pipelines/pipelines-overview/" rel="noopener ugc nofollow" target="_blank">库贝弗管道概述</a>)</li></ul><h2 id="9d3d" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">执行示例管道</h2><ol class=""><li id="8463" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp po mt mu mv bi translated">点击名称<strong class="kw iu">【样本】基本—条件</strong>。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/74ff9ec2b61828cfe59591962cd275f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EX83HxqpXbx7f5WC.png"/></div></div></figure><p id="bafe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.点击<strong class="kw iu">开始实验</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/d7dbd56fd71ef3b7e878ac34f86f6dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U8_FETPSk6vkYueC.png"/></div></div></figure><p id="9deb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.给实验起个名字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/81ddb02d23643d7ee966b9e4ee15a293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R3l1FRhWvYiRHESa.png"/></div></div></figure><p id="32b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.给出运行名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/109a1801ddc0a716be0e3ad9d8132516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hRzP-dy6qD-YSmFr.png"/></div></div></figure><p id="0195" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">5.点击<strong class="kw iu">运行名称</strong>开始运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/d0ec1eed31ddecf4536c53ad49d9cd8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4K-ZgDsNnZx5L6ET80PsgA.png"/></div></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="a200" class="lq lr it bd ls lt nj lv lw lx nk lz ma jz nl ka mc kc nm kd me kf nn kg mg mh bi translated">在 Kubeflow 管道上部署端到端机器学习解决方案</h1><p id="0a01" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Kubeflow 管道组件是管道任务的实现。组件是工作流中的一个步骤。每个任务将一个或多个工件作为输入，并可能产生一个或多个工件作为输出。</p><p id="749e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个组件通常包括两个部分:</p><ul class=""><li id="0a5a" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">客户端代码:与端点对话以提交作业的代码。比如连接谷歌云机器学习引擎的代码。</li><li id="20cd" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated">运行时代码:执行实际工作的代码，通常在集群中运行。例如，为云 MLE 上的训练准备模型的代码。</li></ul><p id="95fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件由接口(输入/输出)、实现(Docker 容器映像和命令行参数)和元数据(名称、描述)组成。</p><h2 id="ef94" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">简单的端到端解决方案管道概述</h2><p id="edf0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这个简单的例子中，我们将实现一个深度神经回归器网络来预测比特币加密货币的收盘价。机器学习代码本身非常基础，因为它不是本文的重点。这里的目标是在具有 Kubeflow 管道的 Kubernetes 上使用微服务架构来编排机器学习工程解决方案。</p><p id="3ab2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">管道由以下组件组成:</p><ol class=""><li id="23fe" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp po mt mu mv bi translated">将 Github 上托管的原始数据移动到存储桶中。</li><li id="32c5" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp po mt mu mv bi translated">使用谷歌数据流转换数据集。</li><li id="1327" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp po mt mu mv bi translated">在云机器学习引擎上进行超参数训练。</li><li id="f2ef" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp po mt mu mv bi translated">用优化的超参数训练模型。</li><li id="eabc" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp po mt mu mv bi translated">部署在云 MLE 上服务的模型。</li></ol><h2 id="03ca" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">为每个组件创建一个容器图像</h2><p id="f6f7" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">首先，我们将把客户机和运行时代码打包成一个 Docker 映像。该映像还包含安全服务帐户密钥，用于针对 GCP 进行身份验证。例如，使用数据流转换数据集的组件在其映像中内置了以下文件:</p><p id="e8f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">| _ _ data flow transform<br/>| _ _ _ _ _ _ _ _ Docker file:Docker file 来构建 Docker 映像。<br/> |_____ build.sh:启动容器构建并上传到 Google 容器注册表的脚本。<br/> |_____ dataflow_transform.py:在云数据流上运行 beam 管道的代码。<br/> |_____ service_account.json:在 GCP 上验证容器的安全密钥。<br/> |_____ local_test.sh:本地运行图像管道组件的脚本。</p><h2 id="3f29" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">在上传到 Kubeflow 管道之前构建容器</h2><p id="7546" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在将管道上传到 Kubeflow 管道之前，请确保构建组件容器，以便将最新版本的代码打包并作为映像上传到容器注册中心。代码提供了一个方便的<code class="fe pi pj pk pa b">bash</code>脚本来构建所有容器。</p><h2 id="bdfc" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">使用 Kubeflow 管道 DSL 语言编译管道</h2><p id="b750" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">管道代码包含组件如何相互作用的规范。每个组件都有一个输出，作为管道中下一个组件的输入。Kubeflow Pipelines SDK 中的 Kubeflow 管道 DSL 语言<code class="fe pi pj pk pa b">dsl-compile</code>用于编译 Python 中的管道代码，以便上传到 Kubeflow 管道。</p><p id="857b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过运行以下命令，确保 Kubeflow Pipelines SDK 安装在本地计算机上:</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="3f6b" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># install kubeflow pipeline sdk</em></strong><br/>pip install https://storage.googleapis.com/ml-pipeline/release/0.1.12/kfp.tar.gz --upgrade</span><span id="8f2a" class="np lr it pa b gy pl pf l pg ph"><em class="oh"># verify the install</em><br/>which dsl-compile</span></pre><p id="a13d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过运行以下命令编译管道:</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="54ef" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># compile the pipeline</em></strong><br/>python3 <strong class="pa iu">[</strong>path/to/python/file.py] <strong class="pa iu">[</strong>path/to/output/tar.gz]</span></pre><p id="74d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于示例代码，我们使用了:</p><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="5aa9" class="np lr it pa b gy pe pf l pg ph">python3 crypto_pipeline.py crypto_pipeline.tar.gz</span></pre><h1 id="e615" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">将管道上传并执行到 Kubeflow 管道</h1><ol class=""><li id="54a3" class="mn mo it kw b kx mi la mj ld od lh oe ll of lp po mt mu mv bi translated">将管道上传到 Kubeflow 管道。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/df2dbadabd4735e1cfe7f5e1d7558b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XtNpJ990APMgs0xH.png"/></div></div></figure><p id="0635" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.单击管道以查看流量的静态图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/5efbbdcf5f8ba2510dfb29c1d2a1c58c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MbZ_2hZyWrONNxZK.png"/></div></div></figure><p id="bb9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.创建一个<code class="fe pi pj pk pa b">Experiment</code>和<code class="fe pi pj pk pa b">Run</code>来执行流水线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/3c36d1add019377e0dc4ae47c5af1705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AU2EnUCo6aYIlzH6.png"/></div></div></figure><p id="5db6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.完成管道运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/ca4a3c561cd61906d1ca0fe9fd02269c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zyCXM6mLuOVlbC6x.png"/></div></div></figure><h2 id="1f0d" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">完整的数据流管道</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/13a694313cd9f7aba62048dc5ee41948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rnlUS_wn7bPOwTFd.png"/></div></div></figure><h2 id="5f73" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">云 MLE 上部署的模型</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/bdb73548946c13f73bbfe80173a74dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xZQFeiVq7cvEZt6j.png"/></div></div></figure><h2 id="8495" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">删除 Kubeflow</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="4121" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># navigate to kubeflow app</em></strong><br/>cd <strong class="pa iu">${</strong>KFAPP<strong class="pa iu">}</strong></span><span id="9d4a" class="np lr it pa b gy pl pf l pg ph"><strong class="pa iu"><em class="oh"># run script to delete the deployment</em></strong><br/><strong class="pa iu">${</strong>KUBEFLOW_SRC<strong class="pa iu">}</strong>/scripts/kfctl.sh delete all</span></pre><h2 id="3cc6" class="np lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">删除 Kubernetes 集群</h2><pre class="kj kk kl km gt oz pa pb pc aw pd bi"><span id="f7e3" class="np lr it pa b gy pe pf l pg ph"><strong class="pa iu"><em class="oh"># delete the kubernetes cluster</em></strong><br/>gcloud container clusters delete ekaba-gke-cluster</span></pre><h1 id="2517" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">参考</h1><p id="cb43" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">以下资源有助于创建和部署 Kubeflow 管道。</p><ul class=""><li id="14ef" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><a class="ae mw" rel="noopener" target="_blank" href="/how-to-create-and-deploy-a-kubeflow-machine-learning-pipeline-part-1-efea7a4b650f">如何创建和部署 Kubeflow 机器学习管道(第一部分)</a></li><li id="5e59" class="mn mo it kw b kx mx la my ld mz lh na ll nb lp ms mt mu mv bi translated"><a class="ae mw" rel="noopener" target="_blank" href="/how-to-deploy-jupyter-notebooks-as-components-of-a-kubeflow-ml-pipeline-part-2-b1df77f4e5b3">如何将 Jupyter 笔记本电脑部署为 Kubeflow ML 管道的组件(第 2 部分)</a></li></ul></div></div>    
</body>
</html>