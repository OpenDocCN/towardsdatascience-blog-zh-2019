<html>
<head>
<title>Publishing Machine Learning API with Python Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python Flask 发布机器学习 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/publishing-machine-learning-api-with-python-flask-98be46fb2440?source=collection_archive---------4-----------------------#2019-03-31">https://towardsdatascience.com/publishing-machine-learning-api-with-python-flask-98be46fb2440?source=collection_archive---------4-----------------------#2019-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3687" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">描述如何通过 Python Flask REST API 向外界公开机器学习模型的一组指令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff746aac6c6b2b1d3f4f2cae72bf3f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kz-3jQbSoa0rPsjzHtQcLg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Source: Pixabay</figcaption></figure><p id="c410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如 Flask <a class="ae lu" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank">网站</a>上所说，Flask 很有趣，也很容易设置。这是事实。这个 Python 的微框架提供了一种用 REST endpoint 注释 Python 函数的强大方法。我使用 Flask 来发布 ML 模型 API，以供第三方业务应用程序访问。</p><p id="cc3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子基于 XGBoost。</p><p id="c316" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更好地维护代码，我建议使用一个单独的 Jupyter 笔记本，ML 模型 API 将在那里发布。连同烧瓶 CORS 一起导入烧瓶模块:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="637d" class="ma mb it lw b gy mc md l me mf">from flask import Flask, jsonify, request<br/>from flask_cors import CORS, cross_origin</span><span id="2025" class="ma mb it lw b gy mg md l me mf">import pickle<br/>import pandas as pd</span></pre><p id="2326" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae lu" href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.names" rel="noopener ugc nofollow" target="_blank">皮马印第安人糖尿病数据库</a>上训练模型。CSV 数据可以从<a class="ae lu" href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv" rel="noopener ugc nofollow" target="_blank">这里</a>下载。要构建 Pandas 数据框变量作为模型<em class="mh">预测</em>函数的输入，我们需要定义一个数据集列数组:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="32fe" class="ma mb it lw b gy mc md l me mf"># Get headers for payload<br/>headers = ['times_pregnant', 'glucose', 'blood_pressure', 'skin_fold_thick', 'serum_insuling', 'mass_index', 'diabetes_pedigree', 'age']</span></pre><p id="187d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 Pickle 加载先前训练和保存的模型:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a197" class="ma mb it lw b gy mc md l me mf"># Use pickle to load in the pre-trained model<br/>with open(f'diabetes-model.pkl', 'rb') as f:<br/>    model = pickle.load(f)</span></pre><p id="87ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">做一个测试运行并检查模型是否运行良好总是一个好的实践。使用列名数组和数据数组(使用新数据，即训练或测试数据集中不存在的数据)构建数据框架。调用两个函数— <em class="mh"> model.predict </em>和<em class="mh"> model.predict_proba </em>。通常我更喜欢使用<em class="mh"> model.predict_proba </em>，它返回描述可能性为 0/1 的概率，这有助于解释基于特定范围(例如 0.25 到 0.75)的结果。Pandas 数据帧由样本有效载荷构成，然后执行模型预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0460" class="ma mb it lw b gy mc md l me mf"># Test model with data frame<br/>input_variables = pd.DataFrame([[1, 106, 70, 28, 135, 34.2, 0.142, 22]],<br/>                                columns=headers, <br/>                                dtype=float,<br/>                                index=['input'])</span><span id="c243" class="ma mb it lw b gy mg md l me mf"># Get the model's prediction<br/>prediction = model.predict(input_variables)<br/>print("Prediction: ", prediction)<br/>prediction_proba = model.predict_proba(input_variables)<br/>print("Probabilities: ", prediction_proba)</span></pre><p id="c59a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">烧瓶 API。确保您启用了 CORS，否则 API 调用将无法在另一台主机上工作。在要通过 REST API 公开的函数之前写注释。提供一个端点名和支持的 REST 方法(在这个例子中是 POST)。从请求中检索有效载荷数据，构建 Pandas 数据帧并执行 model <em class="mh"> predict_proba </em>函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8040" class="ma mb it lw b gy mc md l me mf">app = Flask(__name__)<br/>CORS(app)</span><span id="d376" class="ma mb it lw b gy mg md l me mf"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/katana-ml/api/v1.0/diabetes", methods=['POST'])<br/>def predict():<br/>    payload = request.json['data']<br/>    values = [float(i) for i in payload.split(',')]<br/>    <br/>    input_variables = pd.DataFrame([values],<br/>                                columns=headers, <br/>                                dtype=float,<br/>                                index=['input'])</span><span id="532f" class="ma mb it lw b gy mg md l me mf">    # Get the model's prediction<br/>    prediction_proba = model.predict_proba(input_variables)<br/>    prediction = (prediction_proba[0])[1]<br/>    <br/>    ret = '{"prediction":' + str(float(prediction)) + '}'<br/>    <br/>    return ret</span><span id="f747" class="ma mb it lw b gy mg md l me mf"># running REST interface, port=5000 for direct test<br/>if __name__ == "__main__":<br/>    app.run(debug=False, host='0.0.0.0', port=5000)</span></pre><p id="e605" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">响应 JSON 字符串被构造并作为函数结果返回。我在 Docker 容器中运行 Flask，这就是为什么使用 0.0.0.0 作为它运行的主机。端口 5000 被映射为外部端口，这允许来自外部的呼叫。</p><p id="ab59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然在 Jupyter notebook 中直接启动 Flask interface 是可行的，但我建议将其转换为 Python 脚本，并作为服务从命令行运行。使用 Jupyter <em class="mh"> nbconvert </em>命令转换为 Python 脚本:</p><p id="778b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mh">jupyter nb convert—to python diabetes _ redsamurai _ endpoint _ db . ipynb</em></p><p id="7452" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带有 Flask endpoint 的 Python 脚本可以通过 PM2 进程管理器作为后台进程启动。这允许将端点作为服务运行，并在不同的端口上启动其他进程。PM2 开始命令:</p><p id="3d4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mh">PM2 start diabetes _ redsamurai _ endpoint _ db . py</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/7a8333f487b65bf66323075b54d49085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymbjE3X9BAgcyqZA3CLJPQ.png"/></div></div></figure><p id="5455" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mh"> pm2 监视器</em>帮助显示正在运行的进程的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/f4b6d149443db0d9e8cfa4156120b90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtdDZqNcgFhCF4lLjQVnLg.png"/></div></div></figure><p id="965a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从邮递员通过由 Flask 服务的端点的 ML 模型分类 REST API 调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/8bc1f9bfb66acc56865526c05a0350d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnMgVWFXiUlJj9NnF4peHA.png"/></div></div></figure><p id="5e93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更多信息:</p><ul class=""><li id="7faa" class="ml mm it la b lb lc le lf lh mn ll mo lp mp lt mq mr ms mt bi translated">带有源代码的 GitHub <a class="ae lu" href="https://github.com/abaranovskis-redsamurai/automation-repo" rel="noopener ugc nofollow" target="_blank">回购</a></li><li id="b0d6" class="ml mm it la b lb mu le mv lh mw ll mx lp my lt mq mr ms mt bi translated">上一篇<a class="ae lu" href="https://bit.ly/2Hs38C5" rel="noopener ugc nofollow" target="_blank">帖子</a>关于 XGBoost 模型训练</li></ul></div></div>    
</body>
</html>