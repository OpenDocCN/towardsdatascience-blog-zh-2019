<html>
<head>
<title>Experiments with treemaps and happy little accidents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树状图和快乐小意外的实验</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/experiments-with-treemaps-and-happy-little-accidents-e9e1c5360dce?source=collection_archive---------27-----------------------#2019-09-23">https://towardsdatascience.com/experiments-with-treemaps-and-happy-little-accidents-e9e1c5360dce?source=collection_archive---------27-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1361" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的<a class="ae ko" href="https://medium.com/@etienne.ramstein/goal-oriented-data-visualization-tools-supported-by-object-constancy-f3f4296a3151" rel="noopener">目标导向图表</a>实验中，数据集中的每一项都由一个小矩形表示。根据用户想要看到的内容，它们会飞来飞去，堆叠成各种形状。因此，我需要针对分类和/或定量维度的不同组合的可视化类型。</p><p id="7004" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设我们的矩形是电影，用户想看看他们有多少预算。我们有 1 个量化维度来表示，因此我们可以简单地根据预算按比例调整每部电影的大小:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/79804f9f02f87fa599e9efcc543309af.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*yVryh7_VyBAm_CNNE1AArQ.png"/></div></figure><p id="a4ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单类型的<a class="ae ko" href="http://www.cs.umd.edu/hcil/treemap-history/" rel="noopener ugc nofollow" target="_blank">树形图</a>。</p><p id="c0c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在用户想知道电影的预算是多少，取决于它们的类型。我们增加了一个范畴。矩形飞来飞去形成一个条形图，每个条形代表一个流派的电影总预算。与一个简单的条形图相比，条形图是一个树形图，我们可以看到各个元素，这给了我们额外的洞察力:这种类型的第一名是因为一些大型电影，还是许多普通电影？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/4a618daa695953666792d5b475b9078f.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*srSiLCYoOntX9e67eZ8DIw.png"/></div></figure><p id="3696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户再一次添加了另一个分类维度:他们想按类型和来源国查看电影的预算。矩形再次飞来飞去，这次为每个流派/国家组合形成一个树状图。它们按流派垂直排列，但现在水平分布在每个国家的一栏中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ky"><img src="../Images/8b4b8b75f7c13a5ab66bdefa9f335e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g16duCoDHhQg7eK5Q5_RYw.png"/></div></div></figure><p id="45cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">已满的“单元格”(第 2 列，第 5 行)是总预算最大的一个，其余部分的大小与此相比。</p><p id="cbc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种热图，我们确实可以使用每个单元格的整体大小，并使用梯度来显示它们各自承载的价值。但在我看来，这让事情更难比较:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ld"><img src="../Images/a3bc4e5ec6e916ee2750c9e9cfc643a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOHjiWC9FWJgkQuh3m_Zpg.png"/></div></div></figure><p id="651a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们添加第三个分类维度。这一次我们可以使用颜色——每个树形图都被分割成子部分，每种颜色一个子部分。部分在树形图中按总值降序排序:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi le"><img src="../Images/76c7fe4f34009a45d5b927cbdc53446e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fw7W0GA4wui0APT1dwteAg.png"/></div></div></figure><p id="6fab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于二维版本，我们还可以使用条形图和颜色:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lf"><img src="../Images/f60c17c60bf2b216ece41614fb2c659e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*206SgjKlyEOwz2UmaDzfLQ.png"/></div></div></figure></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="bde4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于实现的一些注意事项。</p><p id="e219" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当构建一个树形图时，我们有以下问题:我们需要定位和确定矩形的大小，以便它们填充一个目标区域，同时每个矩形的表面等于它的重量。这是一个挑战，因为解决方案还必须使可视化对人类有用——我们需要看到有多少个项目，它们各自的大小是多少，并能够按需点击它们查看详细信息。</p><p id="0e8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现可读性最好的方法是将它们“方形化”,使它们看起来尽可能的方形，同时满足上面的约束。不幸的是，为了进行计算，我们不能独立地逐个放置矩形，我们需要在每次迭代中考虑整个数据集。这使得一个完美的解决方案规模很小，实际上这是一个 NP 难题。所以我们需要寻求妥协。来自埃因霍温大学的这篇论文提出了一种实用、高效的方法，并产生了非常令人满意的结果。它也很容易理解和实现，绝对是我推荐的一本有趣的读物。</p><p id="088b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我在应用程序中编写的代码。然而，当我在为那个模块搭建脚手架的时候，我有一个占位符 treemap 函数来提前开始测试整个模块。它使用了最简单的方法:只在一个维度上进行插值，即只在一行薄矩形上进行插值:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/608ac45db849e102f0903d00973b0298.png" data-original-src="https://miro.medium.com/v2/resize:fit:156/format:webp/1*Z-zyeCEupL-9FiRZ_oStKQ.png"/></div></figure><p id="02a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我并不期望这是一个非常有用的可视化，然而就在那时，一些意想不到的有趣的事情发生了。我使用了一个带有简单 2D 上下文的 HTML 画布。事实证明，如果在有限的区域中有成千上万个这样的矩形，尤其是在这样薄的布局中，浏览器没有足够的像素来显示所有的矩形及其 1 像素宽的白色分隔符。所以它试图平滑事物，1 蓝+ 1 白+ 1 蓝变成了 1 淡蓝色。</p><p id="bb0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它创造了这样的梯度:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi le"><img src="../Images/9be34ea940715a6cf2fa985d3e8653d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOxnF4HDIXKHKvNldspcbw.png"/></div></div></figure><p id="1c7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这非常有用，因为它回答了我们的问题:条形的大小是由几个大元素(亮色部分)还是许多小元素(亮色部分)决定的。我最终在应用程序中保留了这一点，以防我们有大量的矩形，而“方形”算法开始出现问题。诸如此类的事情使得数据可视化的开发变得非常有趣。</p></div></div>    
</body>
</html>