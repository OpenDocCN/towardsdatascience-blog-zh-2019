<html>
<head>
<title>Breaking Down the Basics of an Effective Git Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解有效 Git 工作流的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/breaking-down-the-basics-of-an-effective-git-workflow-a94c53c3fa99?source=collection_archive---------19-----------------------#2019-07-21">https://towardsdatascience.com/breaking-down-the-basics-of-an-effective-git-workflow-a94c53c3fa99?source=collection_archive---------19-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3292df00794638443188c60aacda0961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lip49A_DUn3WwNpHhljRw.jpeg"/></div></div></figure><div class=""/><p id="dd1f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一名初露头角的数据科学家，我们学到的第一件事就是如何使用而不破坏 Git。我们课程中的所有内容都是通过 GitHub Enterprise repository 提供给我们的，因此能够使用 Git repositories 并将其克隆到我们自己的机器上是一项非常重要的技能。我们将负责根据当地教师对课程的需求来更新他的作品库，并维护一个提交作品和项目的运行库。不用说，精通 Git 中的基本命令对我们来说是成败的关键。</p><p id="31f0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，在项目进行七周后，我们开始了我们的第一个真正的团队项目，而我，这个受虐狂，想要确保我的团队制定出一个集中的 Git 存储库，以真正掌握真正的 Git 工作流是什么感觉。虽然我们熟悉 Git，但我想探索一下对于我的三人小组来说，一个易于使用但有效的 Git 工作流的元素是什么样的。这并不是详尽的指南，而是如何让 Git 和 GitHub 为较小的团队工作的基本参考。</p><p id="b7ce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，我们来分解一下步骤。在我的假想团队“Nate”和“David”中，我们决定为即将到来的项目创建一个新的神经网络模型。为了创建这个特性，我们需要在<strong class="kd jf">分支</strong>中工作。分支允许我们的团队在这个项目的几个方面工作，而不会潜在地覆盖团队成员的个人工作。</p><figure class="kz la lb lc gt iv gh gi paragraph-image"><div class="ab gu cl ld"><img src="../Images/d551e4ec63bb5ab33c5ae8850e34f4ec.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hpYODo8TqUIE30Ki4G7QEA.jpeg"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">The simple Git workflow in our group, visualized.</figcaption></figure><h1 id="eec4" class="li lj je bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">合并</h1><p id="87d6" class="pw-post-body-paragraph kb kc je kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">因此，对于 Nate 来说，创建一个特性分支并将其合并回<em class="ml">主</em>分支，他需要遵循以下步骤。</p><p id="298d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.从远程库<em class="ml">原点</em>拉最新的<em class="ml">主</em>分支</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="964f" class="mr lj je mn b gy ms mt l mu mv">$ git pull origin master</span></pre><p id="6cc8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.创建特征分支<em class="ml">神经网络</em></p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="f1c3" class="mr lj je mn b gy ms mt l mu mv">$ git checkout -b neural-net</span></pre><p id="fabb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.Nate 正在开发他的功能，注意其他团队成员可能正在开发的文件的变化。他添加要登台的文件，<em class="ml"> </em>提交更改，并将它们推送到远程存储库。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="47c6" class="mr lj je mn b gy ms mt l mu mv"># add all files in local repository directory, or add files individually<br/>$ git add .</span><span id="ba15" class="mr lj je mn b gy mw mt l mu mv"># commit files to the HEAD of "neural-net"<br/>$ git commit -m "a short but descriptive commit message"</span><span id="6106" class="mr lj je mn b gy mw mt l mu mv"># push commits to remote repository "origin"<br/>$ git push origin neural-net</span></pre><p id="3830" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.我们现在准备好让<em class="ml">神经网络</em>跟上<em class="ml">主设备的速度。</em>在 Nate 从他的远程<em class="ml">神经网络</em>分支中取出最新的提交之后，他从远程存储库中取出<em class="ml"> master </em>以确保对 master 的更改反映在他的合并中</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="081e" class="mr lj je mn b gy ms mt l mu mv">$ git pull origin neural-net<br/>$ git checkout neural-net<br/>$ git pull origin master</span></pre><p id="7b22" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，内特仍然在分支<em class="ml">神经网络</em>中，但是从<em class="ml">主</em>分支中提取变化。</p><p id="a2db" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">5.内特将<em class="ml">神经网络</em>合并到<em class="ml">主机。他必须首先从远程存储库中检出主分支。他可能不得不再次拉出<em class="ml">主机</em>，这取决于他的本地<em class="ml">主机</em>在提交历史中的位置。</em></p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="0d58" class="mr lj je mn b gy ms mt l mu mv">$ git checkout master<br/>$ git pull origin master<br/>$ git merge neural-net<br/>$ git branch -d neural-net</span></pre><p id="b86e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将提交历史保存在<em class="ml">神经网络</em>和<em class="ml">主</em>中。冲突可能会发生，但是只要团队意识到他们所做的改变，这些冲突就可以被最小化。在这个序列中，内特还在“分支”命令中添加了“-d”标记，以删除<em class="ml">神经网络</em>分支，因为他已经完成了他的特性的实现。</p><h1 id="0c37" class="li lj je bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重置基础</h1><p id="b8f4" class="pw-post-body-paragraph kb kc je kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">将主分支“重新基准化”到特征分支上也是为了将分支合并在一起，并保留提交历史。Nate 不会合并，而是将提交给<em class="ml"> master 的<em class="ml">神经网络</em>分支重新定基。</em></p><p id="d349" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“Rebasing”从<em class="ml">主</em>分支引入新的提交，如果有提交还不在特性分支中，将其添加到特性分支，并将来自特性的提交添加到<em class="ml">主分支之上。</em>在本例中，Nate 的提交将是 HEAD 中的最新提交，但也将包含来自<em class="ml"> master </em>的任何更改。例如，下面是 rebase 方法的一种更详细的工作方式:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="6d3a" class="mr lj je mn b gy ms mt l mu mv"># Create a new branch off of master<br/>$ git checkout master<br/>$ git pull<br/>$ git checkout -b neural-net<br/>$ git push neural-net</span><span id="0664" class="mr lj je mn b gy mw mt l mu mv"># Add some commits<br/>$ git commit -a -m "descriptive yet short commit message"<br/>$ git commit -a -m "another descriptive yet short commit message"<br/>$ git push neural-net</span><span id="2e16" class="mr lj je mn b gy mw mt l mu mv"># Get the latest changes off of master and rebase neural-net<br/>$ git checkout master<br/>$ git pull<br/>$ git checkout neural-net<br/>$ git rebase master<br/>$ git push -f neural-net</span></pre><p id="d8a0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这里开始，<em class="ml">神经网络</em>现在将与<em class="ml">主</em>同步。</p><p id="28bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">内特完成了他的神经网络特征。在团队的同意下，Nate 会:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="1b66" class="mr lj je mn b gy ms mt l mu mv">$ git checkout master<br/>$ git pull<br/>$ git checkout neural-net<br/>$ git rebase master<br/>$ git push -f neural-net<br/>$ git checkout master<br/>$ git merge --no-ff neural-net<br/>$ git push master</span></pre><p id="022f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，内特的特征现在将成为<em class="ml">主</em>分支的一部分。</p><p id="0721" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这简单吗？假设，是的，它与我们班上熟悉的 Git 工作流相对相似，任何熟悉 Git 的人都可以为他们工作。然而，正如人类做的许多事情一样，事情<em class="ml">发生</em>，而使用 Git，这些<em class="ml">事情</em>被称为“合并冲突”。</p><h1 id="5782" class="li lj je bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">合并冲突</h1><p id="006d" class="pw-post-body-paragraph kb kc je kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">所以，让我们假设在上面的一个 merge 中，Nate 检查他的存储库的状态，Git 向 Nate 抛出这个消息:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="87b0" class="mr lj je mn b gy ms mt l mu mv">$ git status <br/># On branch contact-form <br/># You have unmerged paths. <br/>#     (fix conflicts and run “git commit”) <br/># <br/># Unmerged paths: <br/>#     (use “git add &lt;file&gt;…” to mark resolution) <br/># <br/># both modified: stocks.html <br/>no changes added to commit (use “git add” and/or “git commit -a”)</span></pre><p id="782b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Git 不喜欢 Nate 版本的“stocks.html”与当前的提交历史不同。最有可能的原因是 David 可能已经更改了“stocks.html”的内容，将这些更改提交给了<em class="ml"> master、</em>，而 Nate 在尝试合并其功能之前无法从<em class="ml"> master </em>获得最新的提交。</p><p id="bf41" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好消息是这个问题可以解决。Git 很好地标记了文件中“stocks.html”中的问题区域，方法是将它包含在一个如下所示的标记中:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="3d46" class="mr lj je mn b gy ms mt l mu mv">“&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD” and “&gt;&gt;&gt;&gt;&gt;&gt;&gt; [other/branch/name]"</span></pre><p id="289f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“HEAD”是对当前检出分支中最后一次提交的引用。你可以把“头”想象成“当前分支”。“stocks.html”中的合并冲突示例可能如下所示:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="252e" class="mr lj je mn b gy ms mt l mu mv">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD or neural-net</span><span id="ad0d" class="mr lj je mn b gy mw mt l mu mv">Nate's list of stocks</span><span id="934b" class="mr lj je mn b gy mw mt l mu mv">=======</span><span id="9bec" class="mr lj je mn b gy mw mt l mu mv">David's list of securities</span><span id="a0e6" class="mr lj je mn b gy mw mt l mu mv">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span><span id="3283" class="mr lj je mn b gy mw mt l mu mv">A LIST OF STOCKS</span></pre><p id="9732" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Git 概述了哪些行不同步，并相信用户可以手动解决这些问题:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="77d7" class="mr lj je mn b gy ms mt l mu mv">Nate's list of stocks</span><span id="7204" class="mr lj je mn b gy mw mt l mu mv">A LIST OF STOCKS</span></pre><p id="d461" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这确保了<em class="ml">主</em>和<em class="ml">神经网络</em>拥有相同版本的 stocks.html</p><p id="40c5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，Nate 会将这些更改提交给<em class="ml">主模块</em>。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="91a2" class="mr lj je mn b gy ms mt l mu mv">$ git add stocks.html<br/>$ git commit -m "Merged master fixed conflict."</span></pre><p id="be33" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:并非所有的文件类型或编辑器都会标记这些冲突，但是 Git 在描述终端中的合并冲突时总是会突出显示冲突存在的位置。然而，Git 有一个内置的 GUI，它可以引导您处理冲突，并允许合并冲突的相对简单的集成。</p></div></div>    
</body>
</html>