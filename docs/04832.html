<html>
<head>
<title>MNIST Dataset Python Example Using CNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 CNN 的 MNIST 数据集 Python 示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mnist-cnn-python-c61a5bce7a19?source=collection_archive---------7-----------------------#2019-07-22">https://towardsdatascience.com/mnist-cnn-python-c61a5bce7a19?source=collection_archive---------7-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/de5e4ab055c9af219398dba6c7761a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LC_5IF2XfYbJ91Kg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://www.pexels.com/photo/person-encoding-in-laptop-574071/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/person-encoding-in-laptop-574071/</a></figcaption></figure><div class=""/><p id="dcc0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自动驾驶汽车普及只是时间问题。没有卷积神经网络，这项巨大的工程壮举是不可能实现的。卷积神经网络使用的算法比传统人工神经网络中使用的算法更适合视觉图像处理。卷积神经网络由卷积层和池层组成。</p><h1 id="4459" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">卷积层</h1><p id="2099" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">卷积层利用了所有图像都可以按照<em class="mh"> 1s </em>和<em class="mh"> 0s </em>到<em class="mh">T11】进行编码的事实，创建特征图。特征检测器只是一个矩阵，它的值对应于图像的一个特征(即尖耳朵，狭缝眼睛……)。该矩阵覆盖图像的一部分，并对该位置的所有值执行逐位乘法。逐位乘法的结果被求和并放入特征图的相应位置。然后，它转移到图像的另一部分，并重复该过程，直到它遍历了整个图像。</em></p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mi"><img src="../Images/e6e0c456263bbfff667c7a93d94ab126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeTDgfmEfIBOtMbyPsfilA.png"/></div></div></figure><h1 id="6cc4" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">汇集层</h1><p id="4027" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">池很像卷积，只是我们不使用特征检测器。相反，我们使用最大池。最大汇集的过程包括在由窗口(nxn 矩阵)覆盖的特征图区域内取最大值，并将其放入汇集的特征图的相应位置。汇集是有用的，因为它减小了图像的大小，使得即使在空间方向上存在差异，也能更容易地计算和检测模式。</p><p id="4273" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设数字 4 与猫的眼睛吻合。无论照片拍摄时猫的眼睛是直视相机还是偏向一侧，max pooling 可能仍然会得出相同的值。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mn"><img src="../Images/7cc28bf97642337adc016b93b7893e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9JQDh-5QLHeOpFzwMVffg.png"/></div></div></figure><p id="50ed" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是足够的背景资料，对代码。前面的示例使用 Keras(一种高级 API)在 TensorFlow 中构建和训练模型。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="25c8" class="mt lf jj mp b gy mu mv l mw mx">import keras<br/>from keras.datasets import fashion_mnist <br/>from keras.layers import Dense, Activation, Flatten, Conv2D, MaxPooling2D<br/>from keras.models import Sequential<br/>from keras.utils import to_categorical<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="675e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行下面的代码行来导入我们的数据集。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="0931" class="mt lf jj mp b gy mu mv l mw mx">(train_X,train_Y), (test_X,test_Y) = fashion_mnist.load_data()</span></pre><p id="25be" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank">时尚 MNIST </a>数据集包含 10 个类别的 70，000 幅灰度图像。这些图像以低分辨率(28 x 28 像素)显示了单件衣服，如下所示:</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/16d6abb989c97f47510e9038b1234e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dOOHSSWACxZJ_eIR"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk"><a class="ae jg" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank">https://github.com/zalandoresearch/fashion-mnist</a></figcaption></figure><h1 id="89fb" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数据预处理</h1><p id="7b09" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当使用卷积层作为我们模型的第一层时，我们需要将我们的数据整形为(<code class="fe mz na nb mp b">n_images</code>、<code class="fe mz na nb mp b">x_shape</code>、<code class="fe mz na nb mp b">y_shape</code>、<code class="fe mz na nb mp b">channels</code>)。你真正需要知道的是，对于灰度图像，你应该将<code class="fe mz na nb mp b">channels </code>设置为 1，当你有一组 RGB 图像作为输入时，将<code class="fe mz na nb mp b">channels </code>设置为 3。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="4547" class="mt lf jj mp b gy mu mv l mw mx">train_X = train_X.reshape(-1, 28,28, 1)<br/>test_X = test_X.reshape(-1, 28,28, 1)</span></pre><p id="61ba" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">负一与指定训练集中的图像总数相同。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="f84a" class="mt lf jj mp b gy mu mv l mw mx">train_X.shape</span><span id="9590" class="mt lf jj mp b gy nc mv l mw mx">Out[00]: (60000, 28, 28, 1)</span></pre><p id="cdc3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修改每个像素的值，使它们的范围从 0 到 1，将提高我们的模型学习的速度。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="154d" class="mt lf jj mp b gy mu mv l mw mx">train_X = train_X.astype('float32')<br/>test_X = test_X.astype('float32')</span><span id="3f44" class="mt lf jj mp b gy nc mv l mw mx">train_X = train_X / 255<br/>test_X = test_X / 255</span></pre><p id="6f4b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的模型不能直接处理分类数据。因此，我们必须使用一个热编码。在一种热编码中，数字 0 到 9 被表示为一组 9 个 0 和一个 1。该数字由数字 1 的位置决定。例如，你可以将 3 表示为<code class="fe mz na nb mp b">[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]</code>。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="b50d" class="mt lf jj mp b gy mu mv l mw mx">train_Y_one_hot = to_categorical(train_Y)<br/>test_Y_one_hot = to_categorical(test_Y)</span></pre><h1 id="2019" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">培养</h1><p id="2e51" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的卷积层将有 64 个神经元(特征映射)和一个 3×3 特征检测器。反过来，我们的池层将使用具有 2x2 矩阵的最大池。卷积神经网络几乎总是由人工神经网络处理。在 Keras 中，<code class="fe mz na nb mp b">Dense</code>层实现了操作<code class="fe mz na nb mp b">output = activation(dot(input, weight) + bias)</code>。我们的人工神经网络的输入必须是一维的，因此我们预先将其展平。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="1705" class="mt lf jj mp b gy mu mv l mw mx">model = Sequential()</span><span id="ec31" class="mt lf jj mp b gy nc mv l mw mx">model.add(Conv2D(64, (3,3), input_shape=(28, 28, 1)))<br/>model.add(Activation('relu'))<br/>model.add(MaxPooling2D(pool_size=(2,2)))</span><span id="63ac" class="mt lf jj mp b gy nc mv l mw mx">model.add(Conv2D(64, (3,3)))<br/>model.add(Activation('relu'))<br/>model.add(MaxPooling2D(pool_size=(2,2)))</span><span id="ba23" class="mt lf jj mp b gy nc mv l mw mx">model.add(Flatten())<br/>model.add(Dense(64))</span><span id="dc41" class="mt lf jj mp b gy nc mv l mw mx">model.add(Dense(10))<br/>model.add(Activation('softmax'))</span><span id="496b" class="mt lf jj mp b gy nc mv l mw mx">model.compile(loss=keras.losses.categorical_crossentropy, optimizer=keras.optimizers.Adam(),metrics=['accuracy'])</span></pre><p id="59f8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于卷积神经网络中涉及的算法使用矩阵，您可以从在 GPU 上运行 TensorFlow 中受益匪浅。如果你使用 CPU 训练模型，我不建议超过 10 个历元，因为这需要一段时间。批量大小必须与进入第一个卷积层的图像数量相匹配。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="7846" class="mt lf jj mp b gy mu mv l mw mx">model.fit(train_X, train_Y_one_hot, batch_size=64, epochs=10</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nd"><img src="../Images/5b5ce13f7ef8657edf87d9b90daa88fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xATXu8RrFsFA5eZIuTF-Q.png"/></div></div></figure><p id="eed8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到了第十个纪元，我们获得了 94%的准确度<strong class="ki jk"><em class="mh"/></strong>，从各方面考虑，这确实是很好的。让我们看看我们的模型在分类新图像方面做得有多好。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="239b" class="mt lf jj mp b gy mu mv l mw mx">test_loss, test_acc = model.evaluate(test_X, test_Y_one_hot)<br/>print('Test loss', test_loss)<br/>print('Test accuracy', test_acc)</span><span id="1736" class="mt lf jj mp b gy nc mv l mw mx">Out[]: Test loss 0.2947616615891457<br/>Out[]: Test accuracy 0.9006</span></pre><p id="1c7e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，基于测试的准确性，我们稍微过度拟合了我们的模型。</p><p id="bcfa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看我们的模型做出的第一个预测。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="4b33" class="mt lf jj mp b gy mu mv l mw mx">predictions = model.predict(test_X)<br/>print(np.argmax(np.round(predictions[0])))</span><span id="a25f" class="mt lf jj mp b gy nc mv l mw mx">Out[30]: 9</span></pre><p id="a575" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数字 9 有一个匹配的类别<code class="fe mz na nb mp b">Ankle boot</code>。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/d77e70ac3fdb676611220bb189b7f95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9qjnoX8GNBtXYb0tf3QdA.png"/></div></div></figure><p id="813d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行以下代码将显示第一幅图像。</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="7982" class="mt lf jj mp b gy mu mv l mw mx">plt.imshow(test_X[0].reshape(28, 28), cmap = plt.cm.binary)<br/>plt.show()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0689636eaf06041d55628a3da907f9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/0*cq2euyNsKqrZl4xs.png"/></div></figure><p id="1141" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的模型正确地对测试数据集中的第一幅图像进行了分类。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>