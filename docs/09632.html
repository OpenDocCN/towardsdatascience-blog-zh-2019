<html>
<head>
<title>Computer Vision — Detecting objects using Haar Cascade Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉——利用哈尔级联分类器检测物体</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computer-vision-detecting-objects-using-haar-cascade-classifier-4585472829a9?source=collection_archive---------0-----------------------#2019-12-18">https://towardsdatascience.com/computer-vision-detecting-objects-using-haar-cascade-classifier-4585472829a9?source=collection_archive---------0-----------------------#2019-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq"><div class="bz fp l di"><div class="jr js l"/></div></figure><p id="7f98" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">在开始进入细节之前，我们先来了解一下什么是计算机视觉以及它的一些应用。</p><h1 id="be22" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是计算机视觉？</h1><p id="ee1e" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">计算机视觉是一个研究领域，包括计算机如何看到和理解数字图像和视频。</p><p id="1ccb" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">计算机视觉包括看到或感知视觉刺激，理解所看到的内容，并提取可用于其他机器学习活动的复杂信息。</p><h1 id="3439" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">计算机视觉的应用</h1><p id="f6df" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">计算机视觉有许多实际应用:</p><ul class=""><li id="5fd3" class="lu lv iq jv b jw jx ka kb ke lw ki lx km ly kq lz ma mb mc bi translated">自动驾驶汽车 —这是计算机视觉最重要的应用之一，自动驾驶汽车需要收集周围的信息，以决定如何行动。</li><li id="eae8" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq lz ma mb mc bi translated"><strong class="jv ir">面部识别— </strong>这也是计算机视觉的一个非常重要的应用，电子设备使用面部识别技术来验证用户的身份。</li><li id="bd38" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq lz ma mb mc bi translated"><strong class="jv ir">图像搜索和物体识别</strong> —现在我们可以使用图像搜索在图像中搜索物体。一个很好的例子是谷歌镜头，我们可以通过点击图像的照片来搜索图像中的特定对象，计算机视觉算法将搜索图像目录，并从图像中提取信息。</li><li id="1c62" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq lz ma mb mc bi translated"><strong class="jv ir">机器人</strong> —大多数机器人机器，通常在制造业中，需要看到它们的周围环境来执行手头的任务。在制造业中，机器可以通过“观察”来检查装配公差。</li></ul><p id="b00a" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">既然我们知道了计算机视觉的含义和它的一些应用，让我们深入研究它的实现。为了实现计算机视觉的各种例子，我们将使用 OpenCV 库。</p><p id="749b" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated"><strong class="jv ir"> OpenCV </strong>(开源计算机视觉库:<a class="ae mi" href="http://opencv.org/" rel="noopener ugc nofollow" target="_blank">http://opencv.org</a>)是一个开源的 BSD 许可库，包括数百种计算机视觉算法。</p><p id="4476" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated"><strong class="jv ir"> Haar 级联分类器:</strong>我们将使用 Haar 级联分类器来实现我们的用例。Haar 级联分类器是一种有效的目标检测方法，由 Paul Viola 和 Michael Jones 于 2001 年在他们的论文“使用简单特征的增强级联的快速目标检测”中提出。</p><p id="a04b" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">那么，让我们试着理解这些哈尔级联分类器是什么。这基本上是一种基于机器学习的方法，其中从大量正面和负面图像中训练级联函数。基于该训练，然后使用它来检测其他图像中的对象。</p><p id="135e" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">所以这是如何工作的，他们是巨大的个体。具有许多特性集的 xml 文件，每个 xml 对应于一个非常特定的用例类型。</p><p id="f24e" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">例如，如果你去 haarcascade 的<a class="ae mi" href="https://github.com/opencv/opencv/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank"> github </a>页面，你会看到有一个特定的 xml 文件，其中包含检测<a class="ae mi" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_fullbody.xml" rel="noopener ugc nofollow" target="_blank">全身</a>、<a class="ae mi" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_lowerbody.xml" rel="noopener ugc nofollow" target="_blank">下体</a>、<a class="ae mi" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_eye.xml" rel="noopener ugc nofollow" target="_blank">眼睛</a>、<a class="ae mi" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml" rel="noopener ugc nofollow" target="_blank">正面</a>等等的特征集。</p><p id="e70b" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">为了理解 haar 级联分类器如何工作，以及它将如何用于计算机视觉，让我们实现一些用例。</p><h1 id="64e0" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak"> 1。面部检测</strong></h1><p id="9120" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">在这个用例中，我们将尝试使用<strong class="jv ir">Haar cascade _ front alface _ default . XML</strong>来检测个人的面部</p><p id="6682" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">我们在这里使用的图像尺寸相当大，所以为了更好的输出，我们缩小了图像尺寸。</p><p id="2d91" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">我们使用下面的代码来调整图像的大小:</p><figure class="mk ml mm mn gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mj"><img src="../Images/d89068a0033286dfda6ecc186199c968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbZ35kVXExBLAtQ7SYvkxQ.png"/></div></div></figure><h2 id="bb5c" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第一步</h2><p id="75df" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">现在我们已经调整了图像的大小，让我们继续导入<strong class="jv ir"> cv2 </strong>和<strong class="jv ir"> numpy </strong>并使用 OpenCV 的<strong class="jv ir"> CascadeClassifier </strong>函数指向我们存储 XML 文件的位置，在我们的例子中是<strong class="jv ir">Haar cascade _ frontal face _ default . XML</strong>。<strong class="jv ir"> </strong>我已经将 xml 文件下载到我的本地，并使用了我的机器的路径，但是如果你愿意，你可以直接将它指向 github 的位置。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="6b25" class="mu ks iq nh b gy nl nm l nn no">import cv2<br/>import numpy as np</span><span id="6a18" class="mu ks iq nh b gy np nm l nn no">face_classifier = cv2.CascadeClassifier('/haarcascade_frontalface_default.xml')</span></pre><h2 id="b84d" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第二步</h2><p id="9778" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">现在第二步是加载图像并将其转换成灰度。在展示代码之前，我想告诉你我们在这里将图像转换为灰度的原因。</p><p id="c04d" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">通常我们看到的图像是 RGB 通道(红、绿、蓝)的形式。因此，当 OpenCV 读取 RGB 图像时，它通常将图像存储在 BGR(蓝、绿、红)通道中。为了图像识别的目的，我们需要将 BGR 通道转换成灰色通道。这是因为灰色通道易于处理，并且计算量较小，因为它只包含 1 个黑白通道。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="a866" class="mu ks iq nh b gy nl nm l nn no">gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)</span></pre><p id="5464" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">这里，函数 cvtColor 的参数将是图像变量名(<strong class="jv ir">调整大小</strong>)和<strong class="jv ir"> COLOR_BGR2GRAY。</strong></p><h2 id="70c9" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第三步</h2><p id="ff08" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">现在，在将图像从 RGB 转换为灰度后，我们现在将尝试定位我们面部的确切特征。让我们看看如何用代码实现它。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="73c8" class="mu ks iq nh b gy nl nm l nn no">faces = face_classifier.detectMultiScale(gray, 1.0485258, 6)</span></pre><p id="c0aa" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">在这段代码中，我们要做的是，使用<strong class="jv ir"> face_classifier </strong>，它是一个加载了<strong class="jv ir">Haar cascode _ frontal face _ default</strong>的对象。<strong class="jv ir"> xml，</strong>我们使用了一个内置的函数，叫做<strong class="jv ir"> detectMultiScale。</strong></p><p id="9f16" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">该功能将帮助我们找到新图像的特征/位置。其方式是，它将使用来自<strong class="jv ir"> face_classifier </strong>对象的所有特征来检测新图像的特征。</p><p id="4c03" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">我们将传递给该函数的参数是:</p><ol class=""><li id="b546" class="lu lv iq jv b jw jx ka kb ke lw ki lx km ly kq nq ma mb mc bi translated">灰度变量—在我们的例子中是灰色</li><li id="097f" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq nq ma mb mc bi translated"><strong class="jv ir">比例因子</strong> —指定图像尺寸在每个图像比例下缩小多少的参数<br/>。基本上，比例因子用于创建您的比例金字塔。更多的解释是，您的模型在训练期间定义了一个固定的大小，这在 XML 中是可见的。这意味着如果存在的话，在图像中检测到脸部的这个尺寸。但是，通过重新调整输入图像的比例，您可以将较大的人脸调整为较小的人脸，从而使算法可以检测到它。1.05 是一个很好的可能值，这意味着您使用一个小步骤来调整大小，即减少 5%的大小，您增加了找到与检测模型匹配的大小的机会。这也意味着该算法工作较慢，因为它更彻底。为了更快地检测，您可以将它增加到 1.4，但有可能会完全错过一些面孔。在我们的例子中，我使用 1.0485258 作为<strong class="jv ir">比例因子</strong>，因为这对我正在使用的图像来说是完美的。</li><li id="5791" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq nq ma mb mc bi translated"><strong class="jv ir">最小邻居</strong> —指定每个候选矩形应该有多少邻居来保留它的参数。该参数将影响检测到的人脸的质量。值越高，检测次数越少，但质量越高。3~6 是一个很好的值。在我们的例子中，我选择了 6 作为我的邻居，这对于我使用的图片来说是完美的。</li></ol><h2 id="be36" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第四步</h2><p id="7f28" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">从上面的步骤中，函数<strong class="jv ir"> detectMultiScale </strong>返回 4 个值——检测到的面部特征的 x 坐标、y 坐标、宽度(w)和高度(h)。基于这 4 个值，我们将在脸部周围画一个矩形。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="4dc0" class="mu ks iq nh b gy nl nm l nn no">if faces is ():<br/>    print("No faces found")<br/>for (x,y,w,h) in faces:<br/>    cv2.rectangle(resized, (x,y), (x+w,y+h), (127,0,255), 2)<br/>    cv2.imshow('Face Detection', resized)<br/>    cv2.waitKey(0)<br/>    <br/>cv2.destroyAllWindows()</span></pre><p id="640c" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">将所有 4 个步骤整合在一起，下面是代码:</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="d277" class="mu ks iq nh b gy nl nm l nn no">import cv2<br/>import numpy as np</span><span id="8593" class="mu ks iq nh b gy np nm l nn no">face_classifier = cv2.CascadeClassifier('/haarcascade_frontalface_default.xml')</span><span id="3357" class="mu ks iq nh b gy np nm l nn no">gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)</span><span id="049b" class="mu ks iq nh b gy np nm l nn no">''' Our classifier returns the ROI of the detected face as a tuple, <br/>It stores the top left coordinate and the bottom right coordiantes'''</span><span id="3e8d" class="mu ks iq nh b gy np nm l nn no">faces = face_classifier.detectMultiScale(gray, 1.0485258, 6)</span><span id="5095" class="mu ks iq nh b gy np nm l nn no">'''When no faces detected, face_classifier returns and empty tuple'''<br/>if faces is ():<br/>    print("No faces found")</span><span id="53a5" class="mu ks iq nh b gy np nm l nn no">'''We iterate through our faces array and draw a rectangle over each face in faces'''<br/>for (x,y,w,h) in faces:<br/>    cv2.rectangle(resized, (x,y), (x+w,y+h), (127,0,255), 2)<br/>    cv2.imshow('Face Detection', resized)<br/>    cv2.waitKey(0)<br/>    <br/>cv2.destroyAllWindows()</span></pre><p id="f10b" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">我已经创建了上述程序的输出作为一个视频，并将其嵌入下面。如果你看到，程序不能正确地检测到一些面孔。原因是为了使 haarcascade 分类器正常工作，人脸应该是适当可见的。在输出中没有被检测到的那个有点不清楚。</p><p id="c9d2" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">尽管如此，我将在未来的帖子中尝试改进这一点，我们将使用不同类型的涉及深度学习的算法来减轻这一点。</p><figure class="mk ml mm mn gt jq"><div class="bz fp l di"><div class="nr js l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Face detection using haar cascade classifier</figcaption></figure><h1 id="ecdd" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">2.人脸和眼睛检测</h1><p id="6119" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">现在我们已经对人脸检测的工作原理有了一些了解，让我们看看如何检测人脸和眼睛</p><p id="202d" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">在这个实现中，与<strong class="jv ir">人脸检测</strong>代码相比，我们做了一些改动。</p><h2 id="b0b7" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第一步</h2><p id="f1b9" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">为了检测眼睛，我们还导入了<strong class="jv ir"> haarcascade_eye.xml </strong>文件。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="0017" class="mu ks iq nh b gy nl nm l nn no">eye_classifier = cv2.CascadeClassifier('/haarcascade_eye.xml')</span></pre><h2 id="2140" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第二步</h2><p id="152e" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">一旦我们使用<strong class="jv ir"> detectMultiScale </strong>函数获得人脸检测特征的 x 坐标、y 坐标、宽度(w)和高度(h ),我们将创建 2 个 numpy 数组— <strong class="jv ir"> roi_gray </strong>和<strong class="jv ir"> roi_color。</strong><strong class="jv ir">ROI _ gray</strong>是使用变量“gray”创建的 numpy 数组。我们创建它的原因是在提取眼睛的特征(例如，ey，ew，eh)时，将这个灰色通道版本传递给<strong class="jv ir"> detectMultiScale </strong>函数。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="146e" class="mu ks iq nh b gy nl nm l nn no">for (x,y,w,h) in faces:<br/>    cv2.rectangle(img,(x,y),(x+w,y+h),(127,0,255),2)<br/>    cv2.imshow('img',img)<br/>    cv2.waitKey(0)<br/>    roi_gray = gray[y:y+h, x:x+w]<br/>    roi_color = img[y:y+h, x:x+w]<br/>    eyes = eye_classifier.detectMultiScale(roi_gray)</span></pre><h2 id="fb13" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第三步</h2><p id="42a6" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">一旦我们提取了眼睛的特征(例如，ey，ew，eh ),我们将遍历它们并通过传递 numpy 数组<strong class="jv ir"> roi_color 创建一个矩形。</strong>传递<strong class="jv ir"> roi_color </strong>而不传递<strong class="jv ir"> roi_gray </strong>的原因是<strong class="jv ir"> roi_color </strong>是实际 RGB 比例图像的数组，而<strong class="jv ir"> roi_gray </strong>是图像的灰度，我们在代码中使用它来加快处理速度，同时提取图像的尺寸/坐标，然后使用这些尺寸将它传递到原始数组中，在我们的示例中是<strong class="jv ir"> roi_color </strong>。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="1f04" class="mu ks iq nh b gy nl nm l nn no">for (ex,ey,ew,eh) in eyes:<br/>        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(255,255,0),2)</span></pre><p id="a384" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">将所有步骤整合在一起:</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="d6a8" class="mu ks iq nh b gy nl nm l nn no">import numpy as np<br/>import cv2<br/> <br/>face_classifier = cv2.CascadeClassifier('/haarcascade_frontalface_default.xml')<br/>eye_classifier = cv2.CascadeClassifier('/haarcascade_eye.xml')</span><span id="4108" class="mu ks iq nh b gy np nm l nn no">img = cv2.imread('/group.jpg')<br/>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><span id="a7f7" class="mu ks iq nh b gy np nm l nn no">faces = face_classifier.detectMultiScale(gray, 1.05, 3)</span><span id="9f20" class="mu ks iq nh b gy np nm l nn no"># When no faces detected, face_classifier returns and empty tuple<br/>if faces is ():<br/>    print("No Face Found")</span><span id="dde7" class="mu ks iq nh b gy np nm l nn no">for (x,y,w,h) in faces:<br/>    cv2.rectangle(img,(x,y),(x+w,y+h),(127,0,255),2)<br/>    cv2.imshow('img',img)<br/>    cv2.waitKey(0)<br/>    roi_gray = gray[y:y+h, x:x+w]<br/>    roi_color = img[y:y+h, x:x+w]<br/>    eyes = eye_classifier.detectMultiScale(roi_gray)<br/>    for (ex,ey,ew,eh) in eyes:<br/>        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(255,255,0),2)<br/>        cv2.imshow('img',img)<br/>        cv2.waitKey(0)<br/>    <br/>cv2.destroyAllWindows()</span></pre><p id="9331" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">我已经创建了上述程序的输出作为一个视频，并将其嵌入下面。如果你看到程序不能正确检测戴眼镜的人的眼睛。也许我们需要一个更复杂的算法。</p><figure class="mk ml mm mn gt jq"><div class="bz fp l di"><div class="nr js l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Face and Eye detection using haar cascade classifier</figcaption></figure><h2 id="a848" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">3.流式视频中的车辆检测</h2><p id="9cf1" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">让我们再实现一个 haar 级联分类器的用例。在这个用例中，我们将从流视频中检测车辆。我实现了这些用例来展示它是如何工作的。对于这个分类器，还有很多其他的 XML，你可以用来实现其他一些计算机视觉的例子。这是 xmls 的 github 链接。</p><p id="9d2a" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">这里的实现与我们为人脸检测所做的一样，所以我不会详细解释整个过程。然而，代码中有一些变化。</p><h2 id="98f9" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第一步</h2><p id="ab7c" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">为了检测车辆的特征，我们需要导入<strong class="jv ir"> haarcascade_car.xml. </strong></p><p id="eae0" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">使用 cv2 的<strong class="jv ir">视频捕捉</strong>并将值存储在<strong class="jv ir"> cap </strong>中</p><p id="c6b3" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">从一个<code class="fe nw nx ny nh b">VideoCapture</code>中读取(<code class="fe nw nx ny nh b">cap.read()</code>)返回一个元组<code class="fe nw nx ny nh b">(ret, frame)</code>。对于第一项，您检查读取是否成功，如果成功，则继续使用返回的<code class="fe nw nx ny nh b">frame.</code></p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="01bc" class="mu ks iq nh b gy nl nm l nn no">cap = cv2.VideoCapture('/vehicle.mp4')</span><span id="1aef" class="mu ks iq nh b gy np nm l nn no"># Loop once video is successfully loaded<br/>while cap.isOpened():<br/>    <br/>    time.sleep(.05)<br/>    # Read first frame<br/>    ret, frame = cap.read()</span></pre><h2 id="835b" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第二步</h2><p id="c00b" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">现在我们有了<code class="fe nw nx ny nh b">(ret, frame)</code>的元组，我们将把 BGR 通道图像转换成灰色通道。出于同样的原因，我们将图像转换为灰度，并使用分类器函数<strong class="jv ir"> detectMultiScale </strong>来提取 x 坐标、y 坐标、宽度(w)和高度(h)，灰度用于更好的性能吞吐量。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="71ae" class="mu ks iq nh b gy nl nm l nn no">gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>   <br/>    # Pass frame to our car classifier<br/>    cars = car_classifier.detectMultiScale(gray, 1.1, 2)</span></pre><h2 id="9b3e" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">第三步</h2><p id="b0bc" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">基于提取的汽车特征/尺寸，我们将遍历它们，并在图像的每一帧周围绘制一个矩形。</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="32e8" class="mu ks iq nh b gy nl nm l nn no">for (x,y,w,h) in cars:<br/>        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 255), 2)</span></pre><p id="54be" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">下面是这方面的综合代码:</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="5ef2" class="mu ks iq nh b gy nl nm l nn no">import time<br/>import numpy as np<br/>import cv2</span><span id="bf6c" class="mu ks iq nh b gy np nm l nn no"># Create our body classifier<br/>car_classifier = cv2.CascadeClassifier('\haarcascade_car.xml')</span><span id="24a6" class="mu ks iq nh b gy np nm l nn no"># Initiate video capture for video file<br/>cap = cv2.VideoCapture('/vehicle.mp4')</span><span id="67c0" class="mu ks iq nh b gy np nm l nn no"># Loop once video is successfully loaded<br/>while cap.isOpened():<br/>    <br/>    time.sleep(.05)<br/>    # Read first frame<br/>    ret, frame = cap.read()<br/>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>   <br/>    # Pass frame to our car classifier<br/>    cars = car_classifier.detectMultiScale(gray, 1.1, 2)<br/>    <br/>    # Extract bounding boxes for any bodies identified<br/>    for (x,y,w,h) in cars:<br/>        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 255), 2)<br/>        cv2.imshow('Cars', frame)</span><span id="3cb2" class="mu ks iq nh b gy np nm l nn no">if cv2.waitKey(1) == 13: #13 is the Enter Key<br/>        break</span><span id="91fd" class="mu ks iq nh b gy np nm l nn no">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="ae64" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">现在我们有了完整的代码，让我们检查它的输出。</p><figure class="mk ml mm mn gt jq"><div class="bz fp l di"><div class="nr js l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Car detection using haar cascade classifier</figcaption></figure><h2 id="62d4" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">4.流式视频中的行人检测</h2><p id="5f25" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">实现与车辆检测完全相同。这里唯一的不同是，我们将使用<strong class="jv ir"> haarcascade_fullbody.xml </strong>来识别行人身体的特征。</p><p id="89c7" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">下面是它的代码:</p><pre class="mk ml mm mn gt ng nh ni nj aw nk bi"><span id="b937" class="mu ks iq nh b gy nl nm l nn no">import numpy as np<br/>import cv2</span><span id="2a30" class="mu ks iq nh b gy np nm l nn no"># Create our body classifier<br/>body_classifier = cv2.CascadeClassifier('\haarcascade_fullbody.xml')</span><span id="d358" class="mu ks iq nh b gy np nm l nn no"># Initiate video capture for video file<br/>cap = cv2.VideoCapture('/moskva.mov')</span><span id="14ef" class="mu ks iq nh b gy np nm l nn no"># Loop once video is successfully loaded<br/>while cap.isOpened():<br/>    <br/>    # Read first frame<br/>    ret, frame = cap.read()</span><span id="ed85" class="mu ks iq nh b gy np nm l nn no">gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    # Pass frame to our body classifier<br/>    bodies = body_classifier.detectMultiScale(gray, 1.1, 3)<br/>    <br/>    # Extract bounding boxes for any bodies identified<br/>    for (x,y,w,h) in bodies:<br/>        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 255), 2)<br/>        cv2.imshow('Pedestrians', frame)</span><span id="4989" class="mu ks iq nh b gy np nm l nn no">if cv2.waitKey(1) == 13: #13 is the Enter Key<br/>        break</span><span id="301e" class="mu ks iq nh b gy np nm l nn no">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="0e51" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">让我们看看下面视频中的输出是什么样的:</p><figure class="mk ml mm mn gt jq"><div class="bz fp l di"><div class="nr js l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Pedestrians detection using haar cascade classifier.</figcaption></figure><h2 id="7e7c" class="mu ks iq bd kt mv mw dn kx mx my dp lb ke mz na lf ki nb nc lj km nd ne ln nf bi translated">离别的思绪</h2><p id="daf4" class="pw-post-body-paragraph jt ju iq jv b jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km lt ko kp kq ij bi translated">尽管 haarcascade 分类器非常有用，但这种方法也有一些缺点。</p><ol class=""><li id="86fc" class="lu lv iq jv b jw jx ka kb ke lw ki lx km ly kq nq ma mb mc bi translated">其中最具挑战性的部分是精确指定<strong class="jv ir">检测多尺度</strong>函数的<strong class="jv ir">比例因子</strong>和<strong class="jv ir">最小邻居</strong>的参数值。我们经常会遇到需要逐个图像地调整这两个参数的情况，对于图像检测用例来说，这是一个很大的障碍。</li><li id="6be8" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq nq ma mb mc bi translated"><strong class="jv ir">比例因子</strong>主要用于控制图像金字塔，进而用于在图像的不同比例下检测物体。如果<strong class="jv ir">比例因子</strong>太大，那么图像检测可能会不准确，我们将会错过处于金字塔层之间<em class="nz">比例的对象。</em></li><li id="aed2" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq nq ma mb mc bi translated">然而，如果我们降低<strong class="jv ir">比例因子</strong>的值，那么你将在相同的图像比例上得到许多层金字塔，这使得检测更慢并增加假阳性。</li></ol><p id="2ff6" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">请继续关注即将发布的帖子，在那里我们将看到使用一些复杂的深度学习算法以更有效的方式检测图像的其他酷方法。</p><p id="8209" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">还有，如果你想了解 devops，可以参考这个网站。</p><p id="7853" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">参考资料:</p><ol class=""><li id="aec6" class="lu lv iq jv b jw jx ka kb ke lw ki lx km ly kq nq ma mb mc bi translated"><a class="ae mi" href="https://docs.opencv.org/3.4/db/d28/tutorial_cascade_classifier.html" rel="noopener ugc nofollow" target="_blank">https://docs . opencv . org/3.4/db/d28/tutorial _ cascade _ classifier . html</a></li><li id="02c7" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq nq ma mb mc bi translated"><a class="ae mi" href="https://www.pyimagesearch.com/2016/06/20/detecting-cats-in-images-with-opencv/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2016/06/20/detecting-cats-in-images-with-opencv/</a></li><li id="a0a0" class="lu lv iq jv b jw md ka me ke mf ki mg km mh kq nq ma mb mc bi translated">https://github.com/krishnaik06/Computer-Vision-Tutorial<a class="ae mi" href="https://github.com/krishnaik06/Computer-Vision-Tutorial" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>