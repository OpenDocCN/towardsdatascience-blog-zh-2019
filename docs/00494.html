<html>
<head>
<title>EEG Motor Imagery Classification in Node.js with BCI.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 BCI.js 在 Node.js 中进行脑电运动想象分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/eeg-motor-imagery-classification-in-node-js-with-bci-js-d21f29cf165?source=collection_archive---------14-----------------------#2019-01-22">https://towardsdatascience.com/eeg-motor-imagery-classification-in-node-js-with-bci-js-d21f29cf165?source=collection_archive---------14-----------------------#2019-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c9a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">检测与想象动作相关的脑电波</h2></div><p id="9735" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脑机接口(BCI)允许只使用你的思想来控制计算机和其他设备。实现这一点的一种流行方法是用脑电图(EEG)检测运动想象。本教程将介绍运动想象的检测和分类。我把它分成了五个部分:</p><ol class=""><li id="5b1d" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">加载数据</li><li id="b345" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">特征抽出</li><li id="13ef" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">训练分类器</li><li id="ee8e" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">测试和分析结果</li><li id="7704" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">改善结果</li></ol><p id="9a8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在其<a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到本教程中使用的完整代码和数据。</p><h1 id="b3eb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">第 1 部分—加载数据</h1><p id="7efe" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">首先，为项目创建一个新目录。然后，在项目目录中，将数据下载到名为“data”的文件夹中。我们将使用在 http://bnci-horizon-2020.eu/database/data-sets 的<a class="ae lp" href="http://bnci-horizon-2020.eu/database/data-sets" rel="noopener ugc nofollow" target="_blank">发现的‘四级运动想象(001–2014)’数据集。我已经将数据集制作成 CSV 文件，您可以从下面下载:</a></p><ul class=""><li id="5c6b" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la mn lh li lj bi translated"><a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial/blob/master/data/righthand-training.csv" rel="noopener ugc nofollow" target="_blank">右手训练. csv </a></li><li id="2e85" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated"><a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial/blob/master/data/righthand-testing.csv" rel="noopener ugc nofollow" target="_blank">右手测试. csv </a></li><li id="5ecb" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated"><a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial/blob/master/data/feet-testing.csv" rel="noopener ugc nofollow" target="_blank">双脚测试. csv </a></li><li id="b654" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la mn lh li lj bi translated"><a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial/blob/master/data/feet-training.csv" rel="noopener ugc nofollow" target="_blank">foots-training . CSV</a></li></ul><p id="8db5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以使用 bash 的<a class="ae lp" href="https://gist.github.com/pwstegman/d10bc2980e336294b7d2389f9b0c75bf" rel="noopener ugc nofollow" target="_blank">这个脚本</a>或 PowerShell 的<a class="ae lp" href="https://gist.github.com/pwstegman/7291c74ef43202faae6ab844c7ff224b" rel="noopener ugc nofollow" target="_blank">这个脚本</a>下载数据。</p><p id="f4dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想试验来自不同主题或数据集的数据，可以使用。mat 文件可以在本教程的<a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。您还可以在<a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial/tree/master/data" rel="noopener ugc nofollow" target="_blank"> data/ </a>目录中找到包含其他想象运动的 CSV 文件。</p><p id="9565" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<a class="ae lp" href="https://www.npmjs.com/package/bcijs" rel="noopener ugc nofollow" target="_blank"> BCI.js </a>将数据加载到 Node.js 中。如果你没有安装 Node.js，可以在这里下载<a class="ae lp" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5637" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦安装了 Node.js 和 NPM，通过在项目目录中运行以下命令来安装 BCI.js</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="25e3" class="mx lr iq mt b gy my mz l na nb">npm install bcijs</span></pre><p id="de91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以从项目目录的根目录下的 classify.js 开始。首先需要 BCI.js 并加载相关的 CSV 文件。由于 CSV 加载方法是异步的，我们必须将它们包装在一个异步函数中，并使用 await 关键字，这样 Node.js 在文件加载之前不会继续:</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="d512" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">第 2 部分—特征提取</h1><p id="47bb" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">一旦数据被加载，我们将使用<a class="ae lp" href="https://en.wikipedia.org/wiki/Common_spatial_pattern" rel="noopener ugc nofollow" target="_blank">公共空间模式</a> (CSP)作为特征提取方法的一部分。CSP 试图设计数据，使得当想象脚运动时，第一个信号将具有高的方差，而最后一个信号将具有最低的方差，而当想象右手运动时则相反。考虑到这一点，我们可以使用每个 CSP 信号的方差作为分类的特征向量。</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/c9af3d9afb23bcbad14974bbf73e901b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWdigl2M9Y2xMAq3yaF5EQ.png"/></div></div></figure><p id="6315" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程遵循 Christian Kothe 在他的 CSP 讲座<a class="ae lp" href="https://www.youtube.com/watch?v=zsOULC16USU&amp;list=PLbbCsk7MUIGcO_lZMbyymWU2UezVHNaMq&amp;index=43" rel="noopener ugc nofollow" target="_blank">中描述的方法。如果你想了解更多，他有关于 CSP 和 BCIs 的精彩讲座。</a></p><p id="c29a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以开始研究特征提取方法了。CSV 中的每 750 个样本来自单独的 3 秒试验。我们可以使用 BCI.js 中的 windowApply 方法从每个试验中选择数据。第三个参数是窗口的大小，最后一个参数是窗口每次迭代应该走多少步:</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ee8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每次试验，我们将数据分成大约四分之一秒的窗口或时段，我们可以使用 CSP 生成一个特征向量。取方差的对数使数据更加正态分布，这将有助于以后训练分类器。</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="78c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传递 epochSize/2 作为窗口步长，因此窗口之间有 50%的重叠。方法<a class="ae lp" href="https://bci.js.org/docs/module-bcijs.features.html#.logvar" rel="noopener ugc nofollow" target="_blank"> bci.features.logvar </a>用于计算每个 CSP 信号方差的对数。值“columns”被传递，因为在 2d 数组“cspSignals”中，每一列是一个信号，每一行是一个样本。最后，我们将每次试验的特征连接成一个长的特征向量阵列。</p><h1 id="1124" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">第 3 部分—训练分类器</h1><p id="fc72" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在我们有了特征，让我们学习一个分类器。线性判别分析(LDA)是 BCIs 的一种常用分类器。它使用训练集数据的均值和标准差来绘制两个类之间的分界线(或更高维度中的超平面)。你可以在 https://bci.js.org/examples/lda/找到关于 LDA 如何工作的视频演示。</p><p id="a52b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 LDA 分类器，您可以使用<a class="ae lp" href="https://bci.js.org/docs/module-bcijs.html#.ldaLearn" rel="noopener ugc nofollow" target="_blank"> ldaLearn </a>方法:</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="6f82" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">第 4 部分—测试和分析结果</h1><p id="12ad" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在我们已经学习了一个分类器，让我们使用测试集来评估它。为此，我们将使用<a class="ae lp" href="https://bci.js.org/docs/module-bcijs.html#.ldaProject" rel="noopener ugc nofollow" target="_blank"> ldaProject </a>方法。当预测是第一类时，它返回负数，当预测是另一类时，它返回正数。如果它返回一个接近零的值，那么它对分类就更加不确定。</p><p id="32d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们使用 ldaProject 来预测训练集数据的类别，我们就可以使用混淆矩阵来评估它的性能。混淆矩阵将数据放入 2x2 矩阵中，其中每个单元代表以下内容:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/393de2f1a3a303a24dbefd08a9d5f402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Cf-lwu_9y5wPeF0UU2kkQ.png"/></div></div></figure><p id="6f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<a class="ae lp" href="https://bci.js.org/docs/module-bcijs.html#.confusionMatrix" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a>方法计算这个混淆矩阵。最后，我们计算平衡的准确度(脚运动的准确度和右手运动的准确度的平均值)，以查看我们的分类器执行得有多好(完整的脚本可在此处找到<a class="ae lp" href="https://github.com/pwstegman/motor-imagery-tutorial/blob/master/classify-noUnknowns.js" rel="noopener ugc nofollow" target="_blank"/>):</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="65c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过运行这段代码，我们获得了以下结果:</p><p id="e962" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">混淆矩阵:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2189" class="mx lr iq mt b gy my mz l na nb">1243  275<br/>198   1342</span></pre><p id="f1d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平衡精度:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d194" class="mx lr iq mt b gy my mz l na nb">0.84513</span></pre><p id="acdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个不错的结果，在 3058 个特征中，2585 个被正确分类。然而，当 ldaProject 返回值接近零时，我们可以通过让分类器返回“unknown”来实现更高的准确性。</p><p id="1058" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过过滤掉 LDA 预测接近零的值，我们可以看到添加“未知”会如何影响我们的结果:</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="208d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种修改，我们得到以下结果:</p><p id="a9d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">混淆矩阵:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="173d" class="mx lr iq mt b gy my mz l na nb">925  81<br/>67   940</span></pre><p id="e613" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平衡精度:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0320" class="mx lr iq mt b gy my mz l na nb">0.92647</span></pre><p id="a241" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">34.17%的分类被返回为未知。虽然这是一个很高的百分比，在每秒四个分类的情况下，大约每三个结果中就有一个被丢弃仍然会产生相当快的响应时间。代价是，我们达到了 92.6%的准确率。通过一些改进，我们可以得到更高的结果。</p><h1 id="4544" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">第 5 部分—改善结果</h1><h2 id="bead" class="mx lr iq bd ls nn no dn lw np nq dp ma ko nr ns mc ks nt nu me kw nv nw mg nx bi translated">带通滤波</h2><p id="c510" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们可以通过对数据进行带通滤波来去除噪声和不需要的频带，从而进一步改善结果。在 Christian Kothe 关于 CSP 的<a class="ae lp" href="https://www.youtube.com/watch?v=zsOULC16USU&amp;list=PLbbCsk7MUIGcO_lZMbyymWU2UezVHNaMq&amp;index=43" rel="noopener ugc nofollow" target="_blank">讲座中，他建议在 7 到 30 赫兹之间进行过滤。我们可以使用</a><a class="ae lp" href="https://github.com/markert/fili.js" rel="noopener ugc nofollow" target="_blank"> fili </a>添加一个带通滤波器:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="15da" class="mx lr iq mt b gy my mz l na nb">npm install fili</span></pre><p id="465a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，修改特征提取方法以包括带通滤波器:</p><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ffb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一修改为我们提供了以下结果:</p><p id="9ed6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">混淆矩阵:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e4f3" class="mx lr iq mt b gy my mz l na nb">898  54<br/>54   960</span></pre><p id="8f30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平衡精度:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="025e" class="mx lr iq mt b gy my mz l na nb">0.94501</span></pre><p id="fd1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了准确率上升到 94.5%，分类为未知的结果的百分比下降到 21.4%。</p><p id="eb78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在修改后的代码中，您可以看到我们将 filterOrder 设置为 128。高阶滤波器意味着它可以更精确地过滤 7 到 30 Hz 之间的频率。Fili 包含一个关于滤波器阶数如何影响滤波器的<a class="ae lp" href="http://markert.github.io/fili.js/" rel="noopener ugc nofollow" target="_blank">互动演示</a>。例如，传入以下参数:</p><p id="9fe0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型:FIR，Fs: 250，Fc: 7，Fc2: 30，FIR 阶数:32，计算:Sinc 带通</p><p id="6044" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ny"><img src="../Images/bb45f5f1ec44ac8a0cde180773071c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDgsg-sMQ6oSSj-CnmMGhg.png"/></div></div></figure><p id="db0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是将滤波器阶数从 32 改为 128，我们得到:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nz"><img src="../Images/fc0275817dcfe68105bc101f8b418aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-elm8_Q7e_0f8aKysn9bg.png"/></div></div></figure><p id="f2d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个例子中，只有大约 19 Hz 保持接近 100%,而其他频带被最小化。然而，在具有高阶滤波器的第二示例中，7 和 30 Hz 之间的值保持接近 100%,而其他频带被过滤到大约 0。</p><p id="9b51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，如果我们允许更多的未知数，我们可以达到更高的精度。通过将分类方法中的阈值从 0.5 更改为 1，我们将未知百分比增加到 47.7%，并得到以下结果:</p><p id="b396" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">混淆矩阵:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="986d" class="mx lr iq mt b gy my mz l na nb">672  16<br/>22   599</span></pre><p id="54f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平衡精度:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a72f" class="mx lr iq mt b gy my mz l na nb">0.97066</span></pre><h2 id="787f" class="mx lr iq bd ls nn no dn lw np nq dp ma ko nr ns mc ks nt nu me kw nv nw mg nx bi translated">逻辑回归</h2><p id="3766" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们还可以将 LDA 视为一种降维方法，并将输出传递给逻辑回归，逻辑回归估计样本在每个类别中的概率。为此，我们可以使用<a class="ae lp" href="https://github.com/chen0040/js-regression" rel="noopener ugc nofollow" target="_blank"> js-regression </a>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6feb" class="mx lr iq mt b gy my mz l na nb">npm install js-regression</span></pre><figure class="mo mp mq mr gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="467a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述代码将 58.4%归类为未知，并给出以下结果:</p><p id="f106" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">混淆矩阵:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d635" class="mx lr iq mt b gy my mz l na nb">568  10<br/>11   451</span></pre><p id="0871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平衡精度:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e678" class="mx lr iq mt b gy my mz l na nb">0.97944</span></pre><h1 id="3df0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">就是这样！</h1><p id="d7e1" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是我的第一个教程。我感谢任何反馈，并将回答任何问题。如果你对更多与 BCI 相关的帖子感兴趣，你也可以在 Twitter 上找到我。</p><p id="5330" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GitHub 上的 BCI.js:</p><div class="oa ob gp gr oc od"><a href="https://github.com/pwstegman/bcijs" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">pwstegman/bcijs</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">JavaScript — pwstegman/bcijs 中的脑电信号处理和机器学习</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or nk od"/></div></div></a></div><p id="3b2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BCI.js:</p><div class="oa ob gp gr oc od"><a href="https://www.npmjs.com/package/bcijs" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">bcijs</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">脑电信号处理和机器学习</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.npmjs.com</p></div></div><div class="om l"><div class="os l oo op oq om or nk od"/></div></div></a></div><p id="62fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他库:</p><p id="2498" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lp" href="https://github.com/markert/fili.js" rel="noopener ugc nofollow" target="_blank"> fili </a> —一个用于 JavaScript 的数字过滤器库</p><p id="aad8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lp" href="https://github.com/chen0040/js-regression" rel="noopener ugc nofollow" target="_blank"> js-regression </a> —线性回归和逻辑回归的 JavaScript 实现</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="c073" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">早在 2017 年，我就开始了 WebBCI 的工作，后来它变成了 BCI.js。我后来<a class="ae lp" href="https://www.researchgate.net/publication/325529881_WebBCI_An_Electroencephalography_Toolkit_Built_on_Modern_Web_Technologies" rel="noopener ugc nofollow" target="_blank">在 WebBCI 上发表了一篇论文</a>，并讨论了初步的基准测试以及用 JavaScript 处理脑电图的有效性。如果你很好奇或者想在发表的作品中使用 BCI.js，请查看我关于这个主题的论文:</p><p id="dcdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">页（page 的缩写）Stegman，C. Crawford 和 J. Gray，“WebBCI:建立在现代网络技术上的脑电图工具包”，载于《增强认知:智能技术》，2018 年，第 212-221 页。</p></div></div>    
</body>
</html>