<html>
<head>
<title>A Simple Introduction to TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流的简单介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-introduction-to-tensorflow-d992eb2e3dbb?source=collection_archive---------20-----------------------#2019-10-23">https://towardsdatascience.com/a-simple-introduction-to-tensorflow-d992eb2e3dbb?source=collection_archive---------20-----------------------#2019-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3af971265b95eb02bfcb3267593245de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4PeYv2f2AFqwnZFPST143g.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Don’t lie, this was you at some point</figcaption></figure><p id="b081" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据我的经验，学习任何对计算机科学有用的东西都落在了理论和实践的奇怪交叉点上。我们很容易忽略一些我们编码的东西的深度。机器学习将这一点发挥到了极致，如今每个人都想成为机器学习工程师。(包括我自己)</p><p id="876b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">《统计学习要素》是一本很棒的书。如果你能熬过这一关，你会知道很多，但如果你不能将其中任何一点付诸实践，那就没什么意义了。TensorFlow 是一个用于构建、训练和部署机器学习模型的框架。Keras 是一个构建在 TensorFlow 之上的包装器，使它更容易访问，更容易使用，也更干净。</p><p id="3d80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码块相当于 TensorFlow 中的“Hello World”。尽管这是使用 TensorFlow 的第一步，但这里还有很多东西要解开。所以让我们开始吧。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Full Code for this article</figcaption></figure><p id="97c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python 令人惊奇的一点是，少量代码中可以包含如此多的内容。跟随教程并让代码做事情是非常容易的。对某些人来说，这就够了。其他人可能想知道每一行或每一个函数的作用。我属于后一类。</p><h1 id="6d94" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">数据</h1><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="c9a7" class="mf ld iq mb b gy mg mh l mi mj">import tensorflow as tf<br/>mnist = tf.keras.datasets.mnist<br/>(x_train, y_train),(x_test, y_test) = mnist.load_data()</span></pre><p id="187c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MNIST 数据集由手写数字组成；60000 幅训练图像和 10000 幅测试图像。一个<strong class="ka ir">训练集</strong>是一个集合，在其中我们被给予我们正在观察的特征的结果。<strong class="ka ir">特征</strong>是可以测量的物体的特征。一个更熟悉的特性术语可能是变量或属性。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/05a66bc1fa03bea7ab1b56fc35123106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*3JEaWfrb6wAGc-xhuCONPw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Digits in the MNIST Dataset</figcaption></figure><p id="ddd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用训练集中对象的特征，我们的模型将<em class="ml">学习</em>，然后对新的相似对象进行预测。</p><p id="13ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">测试集</strong>是我们将(你猜对了)用来测试通过使用训练集创建的模型。</p><p id="3003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的几行中，我们告诉 TensorFlow 我们想要 MNIST 数据集中的文件，然后我们将数据加载到训练和测试变量中。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="30d2" class="mf ld iq mb b gy mg mh l mi mj">print(x_train.shape)</span><span id="087f" class="mf ld iq mb b gy mm mh l mi mj">(60000, 28, 28)</span></pre><p id="5dd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经知道我们的训练集有 60，000 张图片。28，28 指的是每个图像的尺寸，28 像素乘 28 像素。因此，让我们进一步探索这些数据。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="0871" class="mf ld iq mb b gy mg mh l mi mj">import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="6fcf" class="mf ld iq mb b gy mm mh l mi mj">plt.figure()<br/>plt.imshow(x_train[5])<br/>plt.colorbar()<br/>plt.grid(False)<br/>plt.show()</span></pre><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/5db012355224b4f42c858ea5b5e80ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*qOFr3p5OC966z-8QrNWnNA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Result of plt.imshow(x_train[5])</figcaption></figure><p id="84b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于图像的任何给定像素，分配给该像素的值可以在 0 到 255 之间。这就引出了下一行代码:</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="0e7b" class="mf ld iq mb b gy mg mh l mi mj">x_train, x_test <strong class="mb ir">=</strong> x_train <strong class="mb ir">/</strong> 255.0, x_test <strong class="mb ir">/</strong> 255.0</span></pre><p id="9aa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它标准化了我们训练和测试集中的所有值。</p><p id="c773" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，酷的时候到了:</p><h1 id="e4ee" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">模型</h1><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="2768" class="mf ld iq mb b gy mg mh l mi mj">model = tf.keras.models.Sequential([<br/> tf.keras.layers.Flatten(input_shape=(28, 28)),<br/> tf.keras.layers.Dense(512, activation=tf.nn.relu),<br/> tf.keras.layers.Dropout(0.2),<br/> tf.keras.layers.Dense(10, activation=tf.nn.softmax)<br/>])</span><span id="e59e" class="mf ld iq mb b gy mm mh l mi mj">model.compile(optimizer=’adam’,<br/> loss=’sparse_categorical_crossentropy’,<br/> metrics=[‘accuracy’])</span></pre><p id="6e90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第一行指定了我们正在使用的模型:</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="d9b0" class="mf ld iq mb b gy mg mh l mi mj">tf.keras.models.Sequential</span></pre><p id="9cac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺序模型可以被认为是一堆煎饼。每一层都是煎饼。因为我们正在努力成为高级厨师，制作机器学习模型，所以我们的煎饼有馅料。馅料即使不比它们的成分更好，也尽量做得一样好。我们的原料是我们的训练装备。<br/>第一层之后的层可以自动识别出模型的输入形状是连续的，这就是为什么只做一次的原因。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="fb90" class="mf ld iq mb b gy mg mh l mi mj">tf.keras.layers.Flatten(input_shape<strong class="mb ir">=</strong>(28, 28)),</span></pre><p id="e313" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在把输入的图像“展平”成一个 2D 数组。输入形状是输入到图层中的图像的尺寸。可以把这看作是为模型重新格式化图像。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="a781" class="mf ld iq mb b gy mg mh l mi mj">tf.keras.layers.Dense(512, activation<strong class="mb ir">=</strong>tf.nn.relu)</span></pre><p id="c997" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就产生了一个紧密连接的神经层。层中的每个输入节点都连接到一个输出节点。它接收来自前一层的输入，这就是为什么它是<em class="ml">密集</em>。512 表示输出空间的维数，乍一看，这对大多数人来说意义不大。这意味着什么的答案是比这篇文章更深入的神经网络。<br/>一个激活函数接受网络中一个节点的输入，并生成将被传递到下一层的输出。如果没有非线性激活函数，这将只是一个线性回归模型。这里使用的激活函数类型是 RELU 或整流线性单元，这是最常用的激活函数之一。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="c69a" class="mf ld iq mb b gy mg mh l mi mj">tf.keras.layers.Dropout(0.2),</span></pre><p id="ae4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">丢弃层是一种正则化技术，其中随机选择的神经元在训练中被忽略。这里我们有一个 20%的比率集，它将在下一个训练周期中丢弃每五个输入中的一个。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="716c" class="mf ld iq mb b gy mg mh l mi mj">tf.keras.layers.Dense(10, activation<strong class="mb ir">=</strong>tf.nn.softmax)</span></pre><p id="0e93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与上面的 RELU 层类似，这一层使用了一个 Softmax 激活函数。Softmax 激活函数的输出类似于分类概率分布，因此它表示类为真的概率。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="857d" class="mf ld iq mb b gy mg mh l mi mj">model.compile(optimizer<strong class="mb ir">=</strong>'adam',<br/>              loss<strong class="mb ir">=</strong>'sparse_categorical_crossentropy',<br/>              metrics<strong class="mb ir">=</strong>['accuracy'])</span></pre><p id="1e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们编译这个模型。<br/>首先，亚当到底是谁？不是一个人。显然它是从“自适应矩估计”中推导出来的。应该是一个叫亚当的人想出来的，应该能写出更好的段落。<br/>无论如何，优化器确实做了它听起来做的事情。Adam 优化算法用于根据训练数据更新网络权重。<br/>损失函数用于衡量预测值和实际值之间的差异。目标是最小化损失函数。</p><h1 id="e0d4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结果</h1><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="dc09" class="mf ld iq mb b gy mg mh l mi mj">model.fit(x_train, y_train, epochs<strong class="mb ir">=</strong>5)<br/>model.evaluate(x_test, y_test)</span></pre><p id="b1ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们拟合和评估我们的模型。需要注意的是，一个<em class="ml">纪元</em>与一次迭代不是一回事。历元是训练数据的完整传递。让一个模型运行太少的时期，在性能方面会有很多不足之处。让一个模型运行太多的时期会有开始“记住”它可能想要的输出的风险，因此会损害它的准确性。</p><p id="07bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个模型的训练无论如何都不是很好，但这只是来自 TensorFlow 教程。</p><pre class="kw kx ky kz gt ma mb mc md aw me bi"><span id="5120" class="mf ld iq mb b gy mg mh l mi mj">model.fit(x_train, y_train, epochs=5)<br/>model.evaluate(x_test, y_test)</span><span id="7ca4" class="mf ld iq mb b gy mm mh l mi mj">Epoch 1/5<br/>60000/60000 [==============================]60000/60000 [==============================] - 8s 126us/step - loss: 9.9728 - acc: 0.3813<br/><br/>Epoch 2/5<br/>60000/60000 [==============================]60000/60000 [==============================] - 8s 127us/step - loss: 10.1151 - acc: 0.3724<br/><br/>Epoch 3/5<br/>60000/60000 [==============================]60000/60000 [==============================] - 8s 127us/step - loss: 10.0101 - acc: 0.3789<br/><br/>Epoch 4/5<br/>60000/60000 [==============================]60000/60000 [==============================] - 8s 126us/step - loss: 10.0149 - acc: 0.3786<br/><br/>Epoch 5/5<br/>60000/60000 [==============================]60000/60000 [==============================] - 8s 127us/step - loss: 10.0893 - acc: 0.3740<br/><br/>10000/10000 [==============================]10000/10000 [==============================] - 0s 32us/step</span><span id="2040" class="mf ld iq mb b gy mm mh l mi mj">[10.388112817382812, 0.3555]</span></pre><p id="7b24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你知道了！首次尝试 TensorFlow。虽然它只有几行代码，但还有很多要解开，但这将变成一本书。如果你读了所有这些，我希望你学到了一些东西！</p></div></div>    
</body>
</html>