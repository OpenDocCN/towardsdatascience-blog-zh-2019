<html>
<head>
<title>Unsupervised Classification Project: Building a Movie Recommender with Clustering Analysis and K-Means</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无监督分类项目:用聚类分析和 K-Means 构建一个电影推荐器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unsupervised-classification-project-building-a-movie-recommender-with-clustering-analysis-and-4bab0738efe6?source=collection_archive---------2-----------------------#2019-03-19">https://towardsdatascience.com/unsupervised-classification-project-building-a-movie-recommender-with-clustering-analysis-and-4bab0738efe6?source=collection_archive---------2-----------------------#2019-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/33cdb06e02a7dbafd00f31935ac86057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pJLKsH7EzlTsJsWD"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Picture from <a class="ae kf" href="https://unsplash.com/photos/95YRwf6CNw8" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e432" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="0c09" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个项目的目标是找出人群中的相似之处，以便为用户建立一个电影推荐系统。我们将分析网飞数据库中的一个数据集，根据人们对电影的评价来探索人们在电影品味上的共同特征。</p><p id="2c37" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">数据将来自<a class="ae kf" href="https://movielens.org/" rel="noopener ugc nofollow" target="_blank"> MovieLens </a> <a class="ae kf" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank">用户评分数据集</a>。</p><h1 id="1d2e" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">数据集概述</h1><p id="5c6a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">该数据集有两个文件，我们将导入这两个文件并使用它们。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="03b7" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Import Libraries</strong><br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>from scipy.sparse import csr_matrix<br/>from mpl_toolkits.axes_grid1 import make_axes_locatable<br/>from sklearn.cluster import KMeans<br/>from sklearn.metrics import mean_squared_error<br/>import itertools<br/>from sklearn.metrics import silhouette_samples, silhouette_score</span><span id="89df" class="mq kh it mm b gy mv ms l mt mu">%matplotlib inline</span><span id="eb4c" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Import the Movies dataset</strong><br/>movies = pd.read_csv('ml-latest-small/movies.csv')<br/>movies.head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3e12906527be2311f2dc906ba15ccdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*hGfEjMg4lXs1rbiParxTeQ.png"/></div></figure><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="819b" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Import the ratings dataset</strong><br/>ratings = pd.read_csv('ml-latest-small/ratings.csv')<br/>ratings.head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/be2f879029c26a7e790d4e0b6cb4f890.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*DxXW5Q72Yri1pSJ5AjIW9g.png"/></div></figure><p id="f1f8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们希望了解数据集的结构是如何工作的，以及在每个表中有多少条记录。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9ca0" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Print the number of records and the total number of movies</strong><br/>print('The dataset contains: ', len(ratings), ' ratings of ', len(movies), ' movies.')</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/90498848f0673025c328a604fdd14d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*5u4BrC5HjfOVaQ9_Wx0-cQ.png"/></div></figure><h1 id="18d6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">浪漫与科幻</h1><p id="80e8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将从考虑用户子集开始，发现他们最喜欢的类型。我们将通过定义一个函数来计算每个用户对所有科幻和爱情电影的平均评分。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9a66" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Function to get the genre ratings</strong><br/>def get_genre_ratings(ratings, movies, genres, column_names):<br/>    genre_ratings = pd.DataFrame()<br/>    for genre in genres:        <br/>        genre_movies = movies[movies['genres'].str.contains(genre) ]<br/>        avg_genre_votes_per_user = ratings[ratings['movieId'].isin(genre_movies['movieId'])].loc[:, ['userId', 'rating']].groupby(['userId'])['rating'].mean().round(2)<br/>        <br/>        genre_ratings = pd.concat([genre_ratings, avg_genre_votes_per_user], axis=1)<br/>        <br/>    genre_ratings.columns = column_names<br/>    return genre_ratings</span><span id="3870" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Calculate the average rating of romance and scifi movies</strong><br/>genre_ratings = get_genre_ratings(ratings, movies, ['Romance', 'Sci-Fi'], ['avg_romance_rating', 'avg_scifi_rating'])<br/>genre_ratings.head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/66e0d137a235b016db943c87b9a57caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*yDhroz1Ek0-KM7QooSvK3Q.png"/></div></figure><p id="cda2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了有一个更明确的人群子集来研究，我们将偏向我们的分组，只从那些喜欢浪漫或科幻电影的用户那里获得评级。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d4e7" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Function to get the biased dataset</strong><br/>def bias_genre_rating_dataset(genre_ratings, score_limit_1, score_limit_2):<br/>    biased_dataset =    genre_ratings[((genre_ratings['avg_romance_rating'] &lt; score_limit_1 - 0.2) &amp; (genre_ratings['avg_scifi_rating'] &gt; score_limit_2)) | ((genre_ratings['avg_scifi_rating'] &lt; score_limit_1) &amp; (genre_ratings['avg_romance_rating'] &gt; score_limit_2))]<br/>    biased_dataset = pd.concat([biased_dataset[:300], genre_ratings[:2]])<br/>    biased_dataset = pd.DataFrame(biased_dataset.to_records())</span><span id="2eea" class="mq kh it mm b gy mv ms l mt mu">    return biased_dataset</span><span id="2cb2" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Bias the dataset</strong><br/>biased_dataset = bias_genre_rating_dataset(genre_ratings, 3.2, 2.5)</span><span id="97bb" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Printing the resulting number of records &amp; the head of the dataset</strong><br/>print( "Number of records: ", len(biased_dataset))<br/>biased_dataset.head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e61f2f5b9903af858a3d7d0ecabdfabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*CUtQAmQE0pLtCCJTDHoepg.png"/></div></figure><p id="7f15" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们可以看到有 183 个记录，每一个都有一个浪漫和科幻电影分级。</p><p id="42ff" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，我们将进行一些可视化分析，以便更好地了解有偏差数据集及其特征。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="814a" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Defining the scatterplot drawing function</strong><br/>def draw_scatterplot(x_data, x_label, y_data, y_label):<br/>    fig = plt.figure(figsize=(8,8))<br/>    ax = fig.add_subplot(111)</span><span id="18f5" class="mq kh it mm b gy mv ms l mt mu">    plt.xlim(0, 5)<br/>    plt.ylim(0, 5)<br/>    ax.set_xlabel(x_label)<br/>    ax.set_ylabel(y_label)<br/>    ax.scatter(x_data, y_data, s=30)</span><span id="00b2" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot the scatterplot</strong><br/>draw_scatterplot(biased_dataset['avg_scifi_rating'],'Avg scifi rating', biased_dataset['avg_romance_rating'], 'Avg romance rating')</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b88609855b84d903055085927e6aac61.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*e2rXn7LSJXE10iIRvkTgFQ.png"/></div></figure><p id="24ee" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们之前制造的偏见现在已经非常清楚了。我们将通过应用 K-Means 把样本分成两个不同的组来进行下一步。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="294a" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Let's turn our dataset into a list</strong><br/>X = biased_dataset[['avg_scifi_rating','avg_romance_rating']].values</span><span id="c9de" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Import KMeans</strong><br/>from sklearn.cluster import KMeans</span><span id="90d8" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Create an instance of KMeans to find two clusters</strong><br/>kmeans_1 = KMeans(n_clusters=2)</span><span id="7d04" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Use fit_predict to cluster the dataset</strong><br/>predictions = kmeans_1.fit_predict(X)</span><span id="6ff4" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Defining the cluster plotting function</strong><br/>def draw_clusters(biased_dataset, predictions, cmap='viridis'):<br/>    fig = plt.figure(figsize=(8,8))<br/>    ax = fig.add_subplot(111)<br/>    plt.xlim(0, 5)<br/>    plt.ylim(0, 5)<br/>    ax.set_xlabel('Avg scifi rating')<br/>    ax.set_ylabel('Avg romance rating')</span><span id="eb95" class="mq kh it mm b gy mv ms l mt mu">clustered = pd.concat([biased_dataset.reset_index(), pd.DataFrame({'group':predictions})], axis=1)<br/>    plt.scatter(clustered['avg_scifi_rating'], clustered['avg_romance_rating'], c=clustered['group'], s=20, cmap=cmap)</span><span id="3cbd" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot</strong><br/>draw_clusters(biased_dataset, predictions)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c9464359c1242902d45a5952c692e65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*WtfQgqB7-OzTKF5QIqqzpg.png"/></div></figure><p id="c90e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">很明显，分组逻辑是基于每个人对爱情电影的评价。对爱情电影平均评分为 3 分或更高的人将属于一组，平均评分低于 3 分的人将属于另一组。</p><p id="5787" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在我们来看看如果我们将数据集分成三组会发生什么。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="062e" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Create an instance of KMeans to find three clusters</strong><br/>kmeans_2 = KMeans(n_clusters=3)</span><span id="cd4d" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Use fit_predict to cluster the dataset</strong><br/>predictions_2 = kmeans_2.fit_predict(X)</span><span id="65da" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot</strong><br/>draw_clusters(biased_dataset, predictions_2)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/ae7b7750cb5ea1a4248825b4d045eb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*OKlulMvy-fJV2PfnHjy09g.png"/></div></figure><p id="2a51" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在很明显，科幻小说的评级已经开始发挥作用:</p><ul class=""><li id="e9f2" class="nd ne it lg b lh mc ll md lp nf lt ng lx nh mb ni nj nk nl bi translated">喜欢科幻和浪漫的人属于黄色群体。</li><li id="09b3" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">喜欢科幻但不喜欢浪漫的人属于绿色群体。</li><li id="669f" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">喜欢浪漫但不喜欢科幻的人属于紫色群体。</li></ul><p id="e5ed" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们看看如果我们添加另一个组会发生什么。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8847" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Create an instance of KMeans to find three clusters</strong><br/>kmeans_3 = KMeans(n_clusters=4)</span><span id="c791" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Use fit_predict to cluster the dataset</strong><br/>predictions_3 = kmeans_3.fit_predict(X)</span><span id="b5b1" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot</strong><br/>draw_clusters(biased_dataset, predictions_3)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/649edf12f9d0bd024205751146d35916.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*DBkOFwkCcO0FbLE46WO_RQ.png"/></div></figure><p id="cd27" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">从这个分析中，我们可以认识到，我们把数据集分成的组越多，属于每个组的人的偏好就越相似。</p><h1 id="dc8c" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">选择正确的 K 个集群</h1><p id="536b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如我们在文章<a class="ae kf" rel="noopener" target="_blank" href="/unsupervised-machine-learning-clustering-analysis-d40f2b34ae7e">“无监督机器学习:聚类分析”</a>中讨论的:</p><blockquote class="ns nt nu"><p id="d3c7" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">选择正确的聚类数是 K-Means 算法的关键点之一。有一些方法可以找到这个数字:</p><p id="3f50" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">领域知识</p><p id="b55b" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">商业决策</p><p id="eaf4" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">肘法</p><p id="515a" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">由于与数据科学的动机和性质一致，肘方法是首选方法，因为它依赖数据支持的分析方法来做出决策。</p><p id="5ae6" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated"><strong class="lg iu">肘法</strong></p><p id="6793" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">肘方法用于确定数据集中聚类的正确数量。它的工作原理是绘制 K 的递增值与使用该 K 时获得的总误差的关系图。</p></blockquote><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b6f7d2fdea84eace299ff792326d8464.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*yD_1yRUKD_0ed-eYw_I9wA.png"/></div></figure><blockquote class="ns nt nu"><p id="76bf" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">目标是找到对于每个聚类不会显著增加方差的 k</p></blockquote><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/8b79f8a5f810d27ca6ab30c830f36814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*86R1OByRi6JoLq1JPAUnpQ.png"/></div></div></figure><blockquote class="ns nt nu"><p id="df0c" class="le lf nv lg b lh mc lj lk ll md ln lo nw me lr ls nx mf lv lw ny mg lz ma mb im bi translated">在这种情况下，我们将选择弯头所在的 k=3。</p></blockquote><p id="febd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了更好地理解这种方法，当我们谈到方差时，我们指的是误差。计算该误差的方法之一是:</p><ul class=""><li id="8c97" class="nd ne it lg b lh mc ll md lp nf lt ng lx nh mb ni nj nk nl bi translated">首先，减去从每个聚类的每个点到其相应组的质心的欧几里德距离。</li><li id="c487" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">然后，平方这个值(去掉负项)。</li><li id="264c" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">最后，将所有这些值相加，获得总误差。</li></ul><p id="a216" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">所以，现在我们想为我们的数据集找出正确的聚类数。为此，我们将对 Kl 的所有可能值执行肘方法，Kl 的范围将在 1 和我们的数据集的所有元素之间。这样，我们将考虑极端情况下的每一种可能性:</p><ul class=""><li id="7bf3" class="nd ne it lg b lh mc ll md lp nf lt ng lx nh mb ni nj nk nl bi translated">如果 K = 1，则所有的点只属于一个群。</li><li id="fb04" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">如果 K =所有数据点，每个数据点是一个单独的组。</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a557" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Selecting our dataset to study</strong><br/>df = biased_dataset[['avg_scifi_rating','avg_romance_rating']]</span><span id="17df" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Choose the range of k values to test.<br/># We added a stride of 5 to improve performance. We don't need to calculate the error for every k value</strong><br/>possible_k_values = range(2, len(X)+1, 5)</span><span id="7166" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Define function to calculate the clustering errors</strong><br/>def clustering_errors(k, data):<br/>    kmeans = KMeans(n_clusters=k).fit(data)<br/>    predictions = kmeans.predict(data)<br/>    #cluster_centers = kmeans.cluster_centers_<br/>    # errors = [mean_squared_error(row, cluster_centers[cluster]) for row, cluster in zip(data.values, predictions)]<br/>    # return sum(errors)<br/>    silhouette_avg = silhouette_score(data, predictions)<br/>    return silhouette_avg</span><span id="cda7" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Calculate error values for all k values we're interested in</strong><br/>errors_per_k = [helper.clustering_errors(k, X) for k in possible_k_values]</span><span id="57aa" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot the each value of K vs. the silhouette score at that value</strong><br/>fig, ax = plt.subplots(figsize=(16, 6))<br/>plt.plot(possible_k_values, errors_per_k)</span><span id="3c49" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Ticks and grid</strong><br/>xticks = np.arange(min(possible_k_values), max(possible_k_values)+1, 5.0)<br/>ax.set_xticks(xticks, minor=False)<br/>ax.set_xticks(xticks, minor=True)<br/>ax.xaxis.grid(True, which='both')<br/>yticks = np.arange(round(min(errors_per_k), 2), max(errors_per_k), .05)<br/>ax.set_yticks(yticks, minor=False)<br/>ax.set_yticks(yticks, minor=True)<br/>ax.yaxis.grid(True, which='both')</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/505124e5effaac17766e99a89cf420f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnGZ8_W_cdl6uNqJmfgnOg.png"/></div></div></figure><p id="cba7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">从图中可以看出，K 值的最佳选择是:7，22，27，31。根据轮廓分数，增加超出该范围的聚类数会导致最差的聚类。</p><p id="7ab9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们将选择 K = 7，因为它是产生最佳分数的一个，并且将更容易可视化。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ff18" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Create an instance of KMeans to find seven clusters</strong><br/>kmeans_4 = KMeans(n_clusters=7)</span><span id="cc29" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Use fit_predict to cluster the dataset</strong><br/>predictions_4 = kmeans_4.fit_predict(X)</span><span id="ab0b" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot</strong><br/>draw_clusters(biased_dataset, predictions_4, cmap='Accent')</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/04543f02049a6e031748f5fd1a43e159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*9JjI1BO0RQ1KnrKiWKRexQ.png"/></div></figure><h1 id="aa3a" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">为我们的分析增加行动</h1><p id="2788" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">到目前为止，我们只分析了爱情片和科幻片。让我们看看当我们通过添加动作片来添加其他类型时会发生什么。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a5c0" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Select our biased dataset and add action genre</strong><br/>biased_dataset_3_genres = get_genre_ratings(ratings, movies, ['Romance','Sci-Fi', 'Action'],                                          <br/>['avg_romance_rating', 'avg_scifi_rating', 'avg_action_rating'])</span><span id="7b4d" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Drop null values</strong><br/>biased_dataset_3_genres = bias_genre_rating_dataset(biased_dataset_3_genres, 3.2, 2.5).dropna()</span><span id="ed73" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Print the number of records and the head of our dataset</strong><br/>print( "Number of records: ", len(biased_dataset_3_genres))<br/>biased_dataset_3_genres.head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c3eb16267f8c5450e7b0cc8737f9a6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*GgdjsINWJboWZGLoYyzUCg.png"/></div></figure><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ea7b" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Turn dataset into a list</strong><br/>X_with_action = biased_dataset_3_genres[['avg_scifi_rating',                                                   'avg_romance_rating',                                                         'avg_action_rating']].values</span><span id="00e5" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Create an instance of KMeans to find seven clusters</strong><br/>kmeans_5 = KMeans(n_clusters=7)</span><span id="766d" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Use fit_predict to cluster the dataset</strong><br/>predictions_5 = kmeans_5.fit_predict(X_with_action)</span><span id="75b8" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Define 3d plotting function</strong><br/>def draw_clusters_3d(biased_dataset_3, predictions):<br/>    fig = plt.figure(figsize=(8,8))<br/>    ax = fig.add_subplot(111)</span><span id="1db6" class="mq kh it mm b gy mv ms l mt mu">plt.xlim(0, 5)<br/>    plt.ylim(0, 5)<br/>    ax.set_xlabel('Avg scifi rating')<br/>    ax.set_ylabel('Avg romance rating')</span><span id="fa9f" class="mq kh it mm b gy mv ms l mt mu">clustered = pd.concat([biased_dataset_3.reset_index(), pd.DataFrame({'group':predictions})], axis=1)</span><span id="ff25" class="mq kh it mm b gy mv ms l mt mu">colors = itertools.cycle(plt.rcParams["axes.prop_cycle"].by_key()["color"])</span><span id="1194" class="mq kh it mm b gy mv ms l mt mu">for g in clustered.group.unique():<br/>        color = next(colors)<br/>        for index, point in clustered[clustered.group == g].iterrows():<br/>            if point['avg_action_rating'].astype(float) &gt; 3: <br/>                size = 50<br/>            else:<br/>                size = 15<br/>            plt.scatter(point['avg_scifi_rating'], <br/>                        point['avg_romance_rating'], <br/>                        s=size, <br/>                        color=color)</span><span id="6527" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Plot</strong><br/>draw_clusters_3d(biased_dataset_3_genres, predictions_5)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/636e7a7929c63136abd38a31c1573bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*HUul-BYFExYIKdRukhshjg.png"/></div></figure><p id="c31b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这里，我们仍然使用浪漫和科幻评分的 x 轴和 y 轴。此外，我们用圆点的大小来表示动作片的评分(圆点越大，动作片的评分越高)。</p><p id="3111" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们可以看到，随着动作基因的加入，聚类发生了显著的变化。我们添加到 k-means 模型中的数据越多，每个群体的偏好就越相似。</p><p id="bd58" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">糟糕的是，用这种方法绘图，我们开始失去在分析三维或更多维时正确可视化的能力。因此，在下一节中，我们将研究其他绘图方法，以正确地可视化高达五维的集群。</p><h1 id="f66b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">更高级别的聚类</h1><p id="ed63" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦我们看到并理解了 K-Means 算法如何根据用户的电影类型偏好对他们进行分组，我们将对数据集进行更大的了解，并探索用户如何对单部电影进行评级。</p><p id="eb2c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为此，我们将按“用户标识”与“用户评级”对数据集进行分组，如下所示。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e255" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Merge the two tables then pivot so we have Users X Movies dataframe</strong><br/>ratings_title = pd.merge(ratings, movies[['movieId', 'title']], on='movieId' )<br/>user_movie_ratings = pd.pivot_table(ratings_title, index='userId', columns= 'title', values='rating')</span><span id="ce58" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Print he number of dimensions and a subset of the dataset</strong><br/>print('dataset dimensions: ', user_movie_ratings.shape, '\n\nSubset example:')<br/>user_movie_ratings.iloc[:6, :10]</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e2731fe2502cbf75cbf4346ba25ca3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-fJ9QaDlh8eUIpxIRCsmw.png"/></div></div></figure><p id="fa74" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">看看这个数据集的子集，很明显有很多“NaN”值，因为大多数用户没有对大多数电影进行评级。这种具有大量“空”值的数据集被称为“稀疏”或“低密度”数据集。</p><p id="6b12" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了解决这个问题，我们将根据评分最高的电影和对电影评分最多的用户对 datsaset 进行排序。因此，我们将在数据集的顶部获得一个更加“密集”的区域。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e02a" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Define the sorting by rating function</strong><br/>def sort_by_rating_density(user_movie_ratings, n_movies, n_users):<br/>    most_rated_movies = get_most_rated_movies(user_movie_ratings, n_movies)<br/>    most_rated_movies = get_users_who_rate_the_most(most_rated_movies, n_users)<br/>    return most_rated_movies</span><span id="3a66" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># choose the number of movies and users and sort</strong><br/>n_movies = 30<br/>n_users = 18<br/>most_rated_movies_users_selection = sort_by_rating_density(user_movie_ratings, n_movies, n_users)</span><span id="0b25" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Print the result</strong><br/>print('dataset dimensions: ', most_rated_movies_users_selection.shape()<br/>most_rated_movies_users_selection.head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/2c09ade3dc8e77b3f35e1547ffa8469d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TA8yXQz5jyXL3sLyB-0tPA.png"/></div></div></figure><p id="7a28" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，我们想把它形象化。由于我们有大量的维度和数据要绘制，这种情况下的首选方法是“热图”。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cccc" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Define the plotting heatmap function</strong><br/>def draw_movies_heatmap(most_rated_movies_users_selection, axis_labels=True):<br/>    <br/>    fig = plt.figure(figsize=(15,4))<br/>    ax = plt.gca()<br/>    <br/>    # Draw heatmap<br/>    heatmap = ax.imshow(most_rated_movies_users_selection,  interpolation='nearest', vmin=0, vmax=5, aspect='auto')</span><span id="e1a2" class="mq kh it mm b gy mv ms l mt mu">if axis_labels:<br/>        ax.set_yticks(np.arange(most_rated_movies_users_selection.shape[0]) , minor=False)<br/>        ax.set_xticks(np.arange(most_rated_movies_users_selection.shape[1]) , minor=False)<br/>        ax.invert_yaxis()<br/>        ax.xaxis.tick_top()<br/>        labels = most_rated_movies_users_selection.columns.str[:40]<br/>        ax.set_xticklabels(labels, minor=False)<br/>        ax.set_yticklabels(most_rated_movies_users_selection.index, minor=False)<br/>        plt.setp(ax.get_xticklabels(), rotation=90)<br/>    else:<br/>        ax.get_xaxis().set_visible(False)<br/>        ax.get_yaxis().set_visible(False)<br/>    <br/>    ax.grid(False)<br/>    ax.set_ylabel('User id')</span><span id="83b4" class="mq kh it mm b gy mv ms l mt mu"># Separate heatmap from color bar<br/>    divider = make_axes_locatable(ax)<br/>    cax = divider.append_axes("right", size="5%", pad=0.05)</span><span id="4d5d" class="mq kh it mm b gy mv ms l mt mu"># Color bar<br/>    cbar = fig.colorbar(heatmap, ticks=[5, 4, 3, 2, 1, 0], cax=cax)<br/>    cbar.ax.set_yticklabels(['5 stars', '4 stars','3 stars','2 stars','1 stars','0 stars'])</span><span id="e648" class="mq kh it mm b gy mv ms l mt mu">plt.show()</span><span id="92ed" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Print the heatmap</strong><br/>draw_movies_heatmap(most_rated_movies_users_selection)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/b290621985149772f736588108f97cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WG_Tpjq1kbYrD6taTNzAg.png"/></div></div></figure><p id="459c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要理解这张热图:</p><ul class=""><li id="a570" class="nd ne it lg b lh mc ll md lp nf lt ng lx nh mb ni nj nk nl bi translated">每个专栏都是一部不同的电影。</li><li id="29c6" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">每一行都是不同的用户。</li><li id="51e4" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">单元格的颜色是每个用户对每部电影的评价。每种颜色的数值可以在右边的刻度中查看。</li><li id="ff2e" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">白色值对应于尚未给电影评分的用户。</li></ul><p id="5570" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了提高模型的性能，我们将只对 1000 部电影使用评级。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="06c7" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Define Function to get the most rated movies</strong><br/>def get_most_rated_movies(user_movie_ratings, max_number_of_movies):<br/>    # 1- Count<br/>    user_movie_ratings = user_movie_ratings.append(user_movie_ratings.count(), ignore_index=True)<br/>    # 2- sort<br/>    user_movie_ratings_sorted = user_movie_ratings.sort_values(len(user_movie_ratings)-1, axis=1, ascending=False)<br/>    user_movie_ratings_sorted = user_movie_ratings_sorted.drop(user_movie_ratings_sorted.tail(1).index)<br/>    # 3- slice<br/>    most_rated_movies = user_movie_ratings_sorted.iloc[:, :max_number_of_movies]<br/>    return most_rated_movies</span><span id="a7ae" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Pivot the dataset and choose the first 1000 movies</strong><br/>user_movie_ratings =  pd.pivot_table(ratings_title, index='userId', columns= 'title', values='rating')<br/>most_rated_movies_1k = get_most_rated_movies(user_movie_ratings, 1000)</span></pre><p id="4899" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此外，由于 k-means 算法不能很好地处理稀疏数据集，我们需要将其转换为 SciPi 库中定义的<a class="ae kf" href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.sparse.csr_matrix.html" rel="noopener ugc nofollow" target="_blank">稀疏 csr 矩阵</a>类型。为此，我们首先需要将数据集转换为稀疏数据帧，然后使用 pandas 中的<code class="fe oh oi oj mm b">to_coo()</code>方法将其转换为稀疏矩阵。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c68e" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Conversion to sparse csr matrix</strong><br/>sparse_ratings = csr_matrix(pd.SparseDataFrame(most_rated_movies_1k).to_coo())</span></pre><h1 id="1bc2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">大规模聚类</h1><p id="7902" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将选取任意数量的群组，以便对所获得的结果进行分析，并找出每个群组内的某些趋势和共性。这个数将是 K = 20。之后，我们将把每个集群绘制成热图。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c989" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># 20 clusters</strong><br/>predictions = KMeans(n_clusters=20, algorithm='full').fit_predict(sparse_ratings)</span><span id="94d8" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Select the mas number of users and movies heatmap cluster</strong><br/>max_users = 70<br/>max_movies = 50</span><span id="c0b3" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Cluster and print some of them</strong><br/>clustered = pd.concat([most_rated_movies_1k.reset_index(), pd.DataFrame({'group':predictions})], axis=1)<br/>draw_movie_clusters(clustered, max_users, max_movies)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/c54497a10c3a57c7ea3ab24cd04f723b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3GghERO_2NydHfsVuyw9A.png"/></div></div></figure><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/b87a61b7bea13cf9645e5e31e7be0412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5OP7OPaPcqQ-S-wzl8YrA.png"/></div></div></figure><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/93aa7530b68d7ad621fb9656a3604d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzCtGjeeAKZzYYiw_Xi0yg.png"/></div></div></figure><p id="a4fd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们可以从这些热图中注意到一些事情:</p><ul class=""><li id="423e" class="nd ne it lg b lh mc ll md lp nf lt ng lx nh mb ni nj nk nl bi translated">聚类中相同颜色的垂直线越多，该聚类中的评级就越相似。</li><li id="539c" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">一些聚类比其他的更稀疏，这表明该算法倾向于将观看和评价较少电影的人也分组。</li><li id="f7ae" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">集群往往有一个主色:如果他们喜欢他们的分级电影，黄色，如果不喜欢，蓝色。</li><li id="8d4e" class="nd ne it lg b lh nm ll nn lp no lt np lx nq mb ni nj nk nl bi translated">具有相同颜色的水平线对应于其评级变化低的用户，他们倾向于喜欢或不喜欢大多数电影。</li></ul><h1 id="202a" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">预言；预测；预告</h1><p id="1fa9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，我们将选择一个集群进行分析，并尝试使用它进行预测。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7e32" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Pick a cluster ID from the clusters above</strong><br/>cluster_number = 11</span><span id="1bda" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Let's filter to only see the region of the dataset with the most number of values </strong><br/>n_users = 75<br/>n_movies = 300<br/>cluster = clustered[clustered.group == cluster_number].drop(['index', 'group'], axis=1)</span><span id="f0c1" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Sort and print the cluster</strong><br/>cluster = sort_by_rating_density(cluster, n_movies, n_users)<br/>draw_movies_heatmap(cluster, axis_labels=False)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/66642fe96a82583ef89c4ff298a55918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GTPw0uICFrkbX8svZ69Kg.png"/></div></div></figure><p id="7580" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在我们将展示评级:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7d9d" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Print the ratings</strong><br/>cluster.fillna('').head()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/25651738010a584aaa5a4e8323e54392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sY4c_0LlxXuFlMkCVfro_w.png"/></div></div></figure><p id="9ee4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，我们将选取一个空白单元格，这些单元格是尚未被用户评级的电影，我们将尝试预测他/她是否会喜欢这部电影。</p><p id="374e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">用户被分在一个群中，其他用户可能与他们有相似的品味，因此有理由认为他/她会用该群中其他用户的平均值来评价一部空白电影。这就是我们将如何进行。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cc9a" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Fill in the name of the column/movie. e.g. 'Forrest Gump (1994)'</strong><br/>movie_name = "Matrix, The (1999)"</span><span id="431a" class="mq kh it mm b gy mv ms l mt mu">cluster[movie_name].mean()</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6d93d153897fd283009492684505bc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*-Dm12i9CpsxuT62YOVVs_A.png"/></div></figure><h1 id="e2b3" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">推荐</h1><p id="6dd5" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用上一步的逻辑，如果我们计算每部电影在聚类中的平均分，我们将了解客户对数据集中每部电影的感受。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fe9b" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># The average rating of 20 movies as rated by the users in the cluster</strong><br/>cluster.mean().head(20)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/eafc00966a4c5a813e3f5482737e7357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*X3XVrenlLDV8Eu2uQuwU2A.png"/></div></figure><p id="cffa" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这对我们真的很有用，因为我们可以用它作为推荐引擎，推荐用户去发现他们可能喜欢的电影。</p><p id="2b0f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当用户登录我们的应用程序时，我们现在可以向他们展示适合他们口味的推荐。这些推荐的公式是选择该群中用户还没有评级的最高评级的电影。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d334" class="mq kh it mm b gy mr ms l mt mu"><strong class="mm iu"># Pick a user ID from the dataset<br/></strong>user_id = 19</span><span id="1d64" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Get all this user's ratings</strong><br/>user_2_ratings  = cluster.loc[user_id, :]</span><span id="73da" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Which movies did they not rate?</strong> <br/>user_2_unrated_movies =  user_2_ratings[user_2_ratings.isnull()]</span><span id="c4e1" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># What are the ratings of these movies the user did not rate?</strong><br/>avg_ratings = pd.concat([user_2_unrated_movies, cluster.mean()], axis=1, join='inner').loc[:,0]</span><span id="3254" class="mq kh it mm b gy mv ms l mt mu"><strong class="mm iu"># Let's sort by rating so the highest rated movies are presented first</strong><br/>avg_ratings.sort_values(ascending=False)[:20]</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi or"><img src="../Images/60aab69347e86776adaf022557bd9e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*S1V1hvqYL9z4eWk_iFzwxQ.png"/></div></figure><p id="30fe" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这些将是我们给用户的前 20 条推荐。</p><h1 id="0fa8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">最后的话</h1><p id="2e03" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><em class="nv">如果你喜欢这篇文章，那么你可以看看我关于数据科学和机器学习的其他文章</em> <a class="ae kf" href="https://medium.com/@rromanss23" rel="noopener"> <em class="nv">这里</em> </a> <em class="nv">。</em></p><p id="d223" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="nv">如果你想了解更多关于机器学习、数据科学和人工智能的知识</em> <strong class="lg iu"> <em class="nv">请在 Medium </em> </strong> <em class="nv">上关注我，敬请关注我的下一篇帖子！</em></p></div></div>    
</body>
</html>