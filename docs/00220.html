<html>
<head>
<title>Reduced branching, robot sensing, and cyclomatic complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少分支、机器人感知和圈复杂度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/code-kata-robot-sensing-reduce-branching-and-cyclomatic-complexity-fe290b3050d1?source=collection_archive---------21-----------------------#2019-01-09">https://towardsdatascience.com/code-kata-robot-sensing-reduce-branching-and-cyclomatic-complexity-fe290b3050d1?source=collection_archive---------21-----------------------#2019-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e69c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习最佳实践的代码形</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/249033991195c872287ce7d829ef22ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSuC_JcOyS7U-Ap-9tEnLw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">source: <a class="ae ky" href="https://www.pexels.com/@steve" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> via <a class="ae ky" href="https://www.pexels.com/photo/brown-panel-door-near-roll-up-gate-845242/" rel="noopener ugc nofollow" target="_blank">pexels</a></figcaption></figure><p id="8a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个快速代码形来说明“减少分支”原则，并在 5 分钟内激起你对机器人感应的兴趣。</p><p id="d6c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们创建一个机器人代理时，天真的解决方案是首先假设机器人有一致的可能性去“任何地方”在数学上，这被建模为机器人将向任何方向移动的等概率。为了简单起见，让我们将其限制在一维的情况下，假设我们的机器人只能在直线 1-D / X 轴上行进并访问 5 个门。</p><p id="6089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有 5 个门，并且所有概率都是均匀分布的，那么机器人位置的初始向量表示是 1 / 5 = 0.2。</p><p id="cb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，假设给你一个向量，代表你的统一的，简单的概率:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9f4b" class="ma mb it lw b gy mc md l me mf">probs = [0.2, 0.2, 0.2, 0.2, 0.2]</span></pre><p id="ceb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，机器人<strong class="lb iu">感知</strong>它们的环境，这应该与它们的目标目的地一致。比方说，我们告诉我们的机器人，他只能旅行到一个“粉红色的门”，而不是蓝色的门。"</p><p id="bb42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的机器人感觉到他在一扇粉色的门旁，他的传感器会说有 0.90 的概率他确实在一扇粉色的门旁。</p><p id="5d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们给自己一些额外的变量，代表一个成功的“击中”失败的“错过”，以及一个变量，代表我们的环境或门。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="401d" class="ma mb it lw b gy mc md l me mf">doors = [‘pink’, ‘blue’, ‘blue’, ‘blue’, ‘pink’]</span><span id="515f" class="ma mb it lw b gy mg md l me mf">T = ‘pink’</span><span id="58bf" class="ma mb it lw b gy mg md l me mf">pHit = 0.90</span><span id="7f2e" class="ma mb it lw b gy mg md l me mf">pMiss = 0.10</span></pre><h1 id="1672" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">你的目标是<strong class="ak">为我们的机器人编写一个感知函数，评估我们的目标 T 是否与它所在的门匹配，并根据它的均匀分布乘以它感知目标门的概率。</strong></h1><p id="af00" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">下面，我用 Python 3 提供了两个解决方案，一个是简单的解决方案，另一个抓住了上面的“代码形”本质。一个是天真的，另一个可以说是稍微好一点的。</p><p id="dafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">天真的实现</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3515" class="ma mb it lw b gy mc md l me mf">def sense(probs, T):</span><span id="add6" class="ma mb it lw b gy mg md l me mf">   afterSense=[]</span><span id="4c6b" class="ma mb it lw b gy mg md l me mf">   for i in range(len(probs)):</span><span id="db8b" class="ma mb it lw b gy mg md l me mf">       if doors[i] == T:</span><span id="5edf" class="ma mb it lw b gy mg md l me mf">          afterSense.append(probs[i]*pHit)</span><span id="2f22" class="ma mb it lw b gy mg md l me mf">       else:</span><span id="5f01" class="ma mb it lw b gy mg md l me mf">          afterSense.append(probs[i]*pMiss)</span><span id="2a34" class="ma mb it lw b gy mg md l me mf">   return afterSense</span></pre><p id="23da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更好的实现</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="47f6" class="ma mb it lw b gy mc md l me mf">def sense(probs, T):</span><span id="6860" class="ma mb it lw b gy mg md l me mf">   afterSense = []</span><span id="643b" class="ma mb it lw b gy mg md l me mf">   for i in range(len(probs)):</span><span id="fb5a" class="ma mb it lw b gy mg md l me mf">      hit = (T == doors[i])</span><span id="687b" class="ma mb it lw b gy mg md l me mf">      afterSense.append(probs[i]*(hit*pHit + (1-hit) *pMiss))</span><span id="211d" class="ma mb it lw b gy mg md l me mf">   return afterSense</span></pre><p id="de6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更好的实现中，您将自己从执行庞大的 4 行 if/then 评估中解放出来。相反，您可以在我们的代码中生成一个独立的、线性的路径，它可以被遍历并折叠成一行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8656" class="ma mb it lw b gy mc md l me mf">afterSense.append(probs[i]*(hit*pHit + (1-hit) *pMiss))</span></pre><p id="5067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为当我们评估:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="86e0" class="ma mb it lw b gy mc md l me mf">hits = (T == doors[i])</span></pre><p id="8152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储在 hits 中的值将返回布尔值真(1)或布尔值假(0)。这符合一般的“良好的编码风格”原则，通常被称为<strong class="lb iu">减少或最小化分支</strong>。</p><h2 id="5bf1" class="ma mb it bd mi nd ne dn mm nf ng dp mq li nh ni ms lm nj nk mu lq nl nm mw nn bi translated">最终，目标是限制<a class="ae ky" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="noopener ugc nofollow" target="_blank">圈复杂度</a>的水平，圈复杂度是另一个度量“分支”或线性独立路径数量的指标。</h2><blockquote class="no np nq"><p id="1fc2" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">一段<a class="ae ky" href="https://en.wikipedia.org/wiki/Source_code" rel="noopener ugc nofollow" target="_blank">源代码</a>的圈复杂度是其中线性独立的<a class="ae ky" href="https://en.wikipedia.org/wiki/Control_flow" rel="noopener ugc nofollow" target="_blank">路径</a>的数量。</p></blockquote><p id="bb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是视觉生物，也许这个图会对你有帮助。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/cc4cdbe09220440021bec0c2ff7119fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*ryph6p8_HRgvOplKTMck8A.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image adopted from <a class="ae ky" href="https://ieeexplore.ieee.org/document/1702388" rel="noopener ugc nofollow" target="_blank">McCabe, T.J., “A complexity measure”, <em class="nw">IEEE Trans. on Software Engineering</em>, SE-2(4), pp.308–320(1976)</a></figcaption></figure><p id="27d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这对其他开发者和好奇的人有所帮助！欢迎给我发信息或在下面评论，我随时欢迎反馈。</p></div></div>    
</body>
</html>