<html>
<head>
<title>Everything You Need To Know About Saving Weights In PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于在 PyTorch 减肥，你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-saving-weights-in-pytorch-572651f3f8de?source=collection_archive---------0-----------------------#2019-08-13">https://towardsdatascience.com/everything-you-need-to-know-about-saving-weights-in-pytorch-572651f3f8de?source=collection_archive---------0-----------------------#2019-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3b79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">一旦我们完成了对模型的训练，我们深度学习实践者会做什么？</p><p id="169f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们心寒！！！</strong></p><p id="29ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kx">哈哈哈</em> <em class="kx">开个玩笑……</em></p><p id="c920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们要么保存学习到的权重，要么保存整个模型，以便我们可以进一步训练模型，或者使用训练好的模型进行推理！</p><p id="a7dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来你们可能有兴趣知道的是，我们什么时候只保存学习过的权重，什么时候保存整个模型。</p><p id="e3a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇博客中，我们将试图找到这些问题的答案。</p><p id="0696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将非常简单明了地向您解释在 PyTorch 中保存模型架构及其权重的艺术的来龙去脉。</p><p id="184e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将学习如何访问不同的模块。准确地说，在任何给定的 PyTorch 模型中。</p><p id="b4b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以可以随意分叉这个 kaggle 内核并使用<a class="ae ky" href="https://www.kaggle.com/n0obcoder/things-to-know-about-saving-weights-in-pytorch" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">代码</strong> </a>:)</p><p id="5a4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧！！！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="640d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从使用 PyTorch 导入编码的<a class="ae ky" href="https://www.youtube.com/watch?v=5dhSdnDb3tk" rel="noopener ugc nofollow" target="_blank"> <em class="kx">基本必需品</em> </a>开始。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="fcef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义一个基于 CNN 的模型。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="4263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们初始化并打印<em class="kx">模型</em>，看看里面有什么。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="7349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打印出<em class="kx">模型</em>向你展示它的架构。但是我们要潜得更深，因为我们是深度学习的实践者！</p><p id="30fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要确保我们理解模型里面到底有什么。</p><p id="ef68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一种方法可以访问模型的每个可学习参数及其名称。顺便说一下，<a class="ae ky" href="https://pytorch.org/docs/stable/nn.html#torch.nn.Parameter" rel="noopener ugc nofollow" target="_blank"><em class="kx">torch . nn . parameter</em></a>是一个张量子类，当与<a class="ae ky" href="https://pytorch.org/docs/stable/nn.html#torch.nn.Module" rel="noopener ugc nofollow" target="_blank"><em class="kx">torch . nn . module</em></a>一起使用时，它会自动添加到其参数列表中，并出现在例如<em class="kx"> parameters() </em>或<em class="kx">named _ parameters()</em><strong class="js iu"><em class="kx"/></strong>迭代器中。另一方面添加一个<em class="kx"> torch.nn.Tensor </em>则没有这样的效果。稍后将详细介绍这一点！</p><p id="602e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到打印模型的所有参数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="8a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">喔喔喔！这里刚刚发生了什么？</p><p id="430a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们进入<em class="kx"> named_parameters() </em>函数。</p><p id="a3cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">model.named_parameters()本身就是一个生成器。它返回<em class="kx">名称</em>和<em class="kx">参数</em>，它们只不过是参数的名称和参数本身。这里返回的参数是<em class="kx"> torch.nn.Parameter </em>类，是一种张量。由于 param 是张量的一种类型，所以它也具有<em class="kx">形状</em> <strong class="js iu"> </strong>和<em class="kx">要求 _grad </em> <strong class="js iu"> </strong>属性。<em class="kx"> param.shape </em>是张量的简单形状，而<em class="kx">param . requires _ grad</em><strong class="js iu"/>是一个布尔值，它表明参数是否可学习。由于模型中的所有参数都具有<strong class="js iu">requires _ grad</strong><strong class="js iu">= True</strong>，这意味着所有参数都是可学习的，并且将在训练模型时更新。如果任何特定的<em class="kx">参数</em>被设置为<strong class="js iu">假</strong>，则该参数的权重不会在训练模型时更新。</p><p id="cb1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，<em class="kx"> requires_grad </em>是当您想要<em class="kx">训练/冻结</em>您的模型的一组特定层时，您可能想要更改的标志。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a84d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们将尝试冻结所有，但最后一层的模型。如果我们浏览模型所有参数的所有名称，我们可以看到最后一层的名称是<em class="kx">‘fc’</em>，代表‘全连接’。</p><p id="1897" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们冻结所有参数，除了名称为<em class="kx">【fc . weight】</em>或<em class="kx">【fc . bias】</em>的参数</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="1e71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过为模型的所有参数打印出<em class="kx"> requires_grad </em>来验证所需的更改已经成功完成</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="645a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，所需的更改已经成功完成！</p><p id="db4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们已经了解了如何为模型的任何所需参数更改<em class="kx"> requires_grad </em>标志。我们还了解到，在我们想要<em class="kx">学习/冻结</em>模型中某些特定参数/层的权重的情况下，这样做非常方便。</p><p id="c84b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将学习两种广为人知的保存模型权重/参数的方法。</p><ol class=""><li id="5862" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated">torch.save(model.state_dict()，' weights_path_name.pth') <br/>它只保存模型的<strong class="js iu"/><strong class="js iu">权重</strong></li><li id="0d09" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">torch.save(model，' model_path_name.pth') <br/>保存整个模型(架构<strong class="js iu">以及权重</strong>)</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="32a0" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">state_dict()是什么，在哪里使用？</h1><p id="bf97" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我们将首先看看如何编写<em class="kx"> state_dict </em>的语法。这很简单。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="91e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个 python 的有序字典。</p><p id="4166" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，打印这个，会导致混乱。所以我们不会在这里打印整个模型的<em class="kx"> state_dict </em>，但是我鼓励你们继续在屏幕上打印出来！</p><p id="23b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想这是转移话题的好时机。</p><p id="91ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看，打印<em class="kx">帮助(模型)</em>告诉我们，模型是<em class="kx"> nn 的一个实例。模块</em></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="8cc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也可以使用 python 的 isinstance 函数进行验证</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="c943" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kx"> model.fc </em>也是<em class="kx"> nn 的实例吗？模块</em>？</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="ebe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然是的！</p><p id="82e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是<em class="kx"> fc </em> <strong class="js iu">，</strong>到底是什么，又是从何而来？</p><p id="8747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们什么都能看到<em class="kx"> nn。模块</em>对象位于模型下</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="dbc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在任何<em class="kx"> nn 上应用的<em class="kx"> named_children() </em>。模块</em>对象返回它的所有直接子对象(也是<em class="kx"> nn。模块</em>对象)。看看上面这段代码的结果，我们知道<em class="kx">‘sequential’，‘layer 1’，‘layer 2’，</em>和<em class="kx">‘fc’，</em>都是 model 的子节点，所有这些都是<em class="kx"> nn。模块</em>类对象。现在我们都知道<em class="kx">【fc】</em>是从哪里来的了。</p><p id="d83e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你知道吗？<em class="kx"> state_dict() </em>作用于任何<em class="kx"> nn。模块</em>对象并返回它的所有直接子对象(属于类<em class="kx"> nn。模块</em>)。</p><p id="0eab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们来试试模型的<em class="kx">‘fc’</em>层上的<em class="kx"> state_dict() </em>函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="c006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住<em class="kx"> model.fc.state_dict() </em>或者任何<em class="kx"> nnModule.state_dict() </em>都是一个<strong class="js iu">有序字典</strong>。所以迭代它给了我们字典的键，可以用来访问参数张量，顺便说一下，它不是一个<em class="kx"> nn。模块</em>对象，而是一个简单的<em class="kx">火炬。具有<em class="kx">形状</em>和<em class="kx">的张量</em>需要 _grad </em>属性。</p><p id="e768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以一定要注意，当我们保存一个<em class="kx"> nn 的<em class="kx"> state_dict() </em>时。模块</em>对象例如模型、<em class="kx">焊枪。张量</em>物体被保存！</p><p id="1953" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们保存整个模型的<em class="kx"> state_dict </em>的方法。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="084a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在工作目录中生成了一个<em class="kx"> 'weights_only.pth' </em>文件，它在一个有序的字典中保存了<em class="kx">火炬。张量</em>模型所有层的对象。</p><p id="d356" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将尝试加载保存的重量。但是在此之前，我们需要首先定义模型架构。首先定义模型，然后在其中加载权重是有意义的，因为保存的信息<strong class="js iu">只是</strong>权重而<strong class="js iu">不是</strong>模型架构。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="829a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦权重被加载到定义的模型中，让我们检查 model_new 所有层的<em class="kx"> requires_grad </em>属性。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="5a0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等等！什么？</p><p id="f48e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为所有不同层设置的所有<em class="kx"> requires_grad </em>标志发生了什么变化？似乎所有的<em class="kx"> requires_grad </em>标志都被重置为<strong class="js iu"> True </strong>。</p><p id="d495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其实我们从来没有在第一时间保存参数的<em class="kx"> required_grad </em>标志。记住，一个<em class="kx"> state_dict </em> <strong class="js iu"> </strong>只是一个 python 字典对象，它将每个层映射到它的参数张量。它不保存参数的<em class="kx"> requires_grad </em>属性。</p><p id="7258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们需要再次对所有参数的<em class="kx"> requires_grad </em>属性进行必要的更改，然后才能继续对模型进行更多时期的训练</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d143" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">如何保存整个模型，什么时候做？</h1><p id="9f08" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">是的，我们有第二种保存东西的方法，也可以保存整个模型。对于整个模型，我指的是模型的<strong class="js iu">架构</strong>以及它的<strong class="js iu">重量</strong>。</p><p id="9860" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们将从冻结模型的最后一层(即<em class="kx">‘fc’</em>层)的地方继续，并保存整个模型。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="02cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在工作目录中创建一个<em class="kx">‘entire _ model . PTH’</em>文件，它包含模型架构<strong class="js iu">以及</strong>保存的权重。</p><p id="1375" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将尝试加载保存的模型。这一次，我们不需要定义模型架构，因为关于模型架构的信息已经存储在保存的文件中。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="36a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦模型被加载，让我们检查 model_new 所有层的属性。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="2e6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这正是我们想要看到的，不是吗？:D</p><p id="6f44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以当我们保存整个模型时，我们保存了<em class="kx"> nn。模块</em>对象，这样做也保存了其所有参数的<em class="kx"> requires_grad </em>标志。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="6268" class="ne mc it bd md nf ng dn mh nh ni dp ml kb nj nk mp kf nl nm mt kj nn no mx np bi translated">我强烈建议你们把这个<a class="ae ky" href="https://www.kaggle.com/n0obcoder/things-to-know-about-saving-weights-in-pytorch" rel="noopener ugc nofollow" target="_blank"><strong class="ak">public ka ggle kernel</strong></a>叉出来，玩玩代码，感受一下！</h2></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="91dd" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated"><strong class="ak">总结</strong></h1><p id="bd43" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我们在这个博客中学到了很多东西。</p><ol class=""><li id="8937" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated">在<em class="kx"> nn 上应用<strong class="js iu"> <em class="kx">命名参数()</em> </strong>。模块</em>对象，例如<em class="kx">模型</em>或<br/>或<em class="kx">模型.图层 2 </em>或<em class="kx">模型. fc </em>返回所有的名称和各自的参数。这些参数是<em class="kx"> nn。参数</em>(<em class="kx">火炬的子类。张量</em>对象，因此它们具有<em class="kx">形状</em>和<em class="kx">要求 _grad </em>属性。</li></ol><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="051b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<strong class="js iu"> <em class="kx">需要<em class="kx"> nn 的 _grad </em> </em></strong>属性。参数对象(可学习参数对象)决定是否训练或冻结特定参数。例如，如果我们想要冻结模型的<em class="kx">层 1 </em>，我们将使用下面的代码。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="7ee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.将<strong class="js iu"> <em class="kx">命名为 _children() </em> </strong>应用于任何<em class="kx"> nn 上。模块</em>对象返回它的所有直接子对象(也是<em class="kx"> nn。模块</em>对象)。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="68b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.任何<em class="kx"> nn 的一个<strong class="js iu"> <em class="kx"> state_dict() </em> </strong>。模块</em>对象，例如<em class="kx">模型</em>或<em class="kx">模型.层 2 </em>或<em class="kx">模型. fc </em>只是一个 python <strong class="js iu">有序字典</strong>对象，它将每个参数映射到其参数张量(<em class="kx">火炬。张量</em>对象)。该有序字典的<strong class="js iu">键</strong>是参数的名称，可用于访问相应的参数张量。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="89f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.保存一个<em class="kx"> nn。模块</em>对象的<em class="kx"> state_dict </em>仅<strong class="js iu">保存该对象的各种参数的</strong> <strong class="js iu">权重</strong>而<strong class="js iu">不保存模型架构</strong>。也不涉及权重的<strong class="js iu"> requires_grad </strong>属性。所以在加载 state_dict 之前，必须先定义模型。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="c802" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.整个模型(<em class="kx"> nn。模块</em>对象)也可以被保存，这将包括<strong class="js iu">模型架构及其权重</strong>。既然我们在拯救<em class="kx"> nn。模块</em>对象，<strong class="js iu"> requires_grad </strong>属性也以这种方式<strong class="js iu">保存</strong>。此外，我们不需要在加载保存的文件之前定义模型架构，因为保存的文件中已经保存了模型架构。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="a587" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">7.保存<em class="kx"> state_dict </em>只能用来保存模型的权重。它不会保存<em class="kx"> required_grad </em>标志，而保存整个模型会保存模型架构、它的权重以及所有参数的<em class="kx"> requires_grad </em>属性。</p><p id="87a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">8.state _ dict 和整个模型都可以被保存以进行推断。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0fdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我写这篇博客是因为我通过阅读别人的博客学到了很多东西，我觉得我也应该尽可能多地写下并分享我的学习和知识。所以请在下面的评论区留下你的反馈。此外，我是写博客的新手，所以任何关于如何提高我的写作的建议将不胜感激！:D</p><p id="ee3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我也是一个独立的音乐艺术家，喜欢在空闲时间演奏和录制音乐。也许你可以在 Spotify 上查看我的艺人页面，表示支持:)<br/><a class="ae ky" href="https://open.spotify.com/artist/7G2BgSnludIYl1gFyJKG6X?si=Bv5L4ZAVQrmIsl5SgGRAUw" rel="noopener ugc nofollow" target="_blank">Spotify 上的 8 楼和声！</a></p></div></div>    
</body>
</html>