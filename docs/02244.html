<html>
<head>
<title>Bitcoin Predictive Price Modeling with Facebook’s Prophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">脸书先知的比特币预测价格建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bitcoin-predictive-price-modeling-with-facebooks-prophet-b66efd0169a0?source=collection_archive---------10-----------------------#2019-04-14">https://towardsdatascience.com/bitcoin-predictive-price-modeling-with-facebooks-prophet-b66efd0169a0?source=collection_archive---------10-----------------------#2019-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/468738e61dffa2b7a5bc4af5484c520b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruStI0aFLhrvBsT0zrqEDg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Two Bitcoin price predictions (blue and red lines) generated using Facebook’s Prophet package. The actual price data is in green, while the shaded areas denote the respective uncertainty in the estimate. As you can the uncertainty increases into the future. This is particularly the case with the tighter fitting price model (red).</figcaption></figure><p id="538d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个快速浏览脸书的先知机器学习包使用比特币的例子。它假设您具备基本的 Python 知识，并对熊猫有所了解。</p><p id="7466" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Prophet 是脸书为时间序列数据开发的开源预测程序。这个想法是，它应该使完全自动的预测变得容易，即使有杂乱的数据，而且它目前在 R 和 Python 中可用。在这篇文章中，我将使用 Python 2.7。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="eff4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="lk">注来自《走向数据科学》的编辑:</em> </strong> <em class="lk">虽然我们允许独立作者根据我们的</em> <a class="ae ll" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="lk">规则和指导方针</em> </a> <em class="lk">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae ll" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="lk">读者术语</em> </a> <em class="lk">。</em></p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="2cda" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">安装 Prophet</h1><p id="6a4b" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">如果你已经安装了 pip，你需要做的就是打开一个控制台，输入</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="db11" class="my ln it mu b gy mz na l nb nc">pip install fbprophet</span></pre><p id="d3dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在 Windows 上，我遇到了一些与 Anaconda 相关的依赖问题，不得不首先运行</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="fbc3" class="my ln it mu b gy mz na l nb nc">conda clean --all<br/>conda update pystan</span></pre><h1 id="6d6d" class="lm ln it bd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj bi translated">下载和准备数据</h1><p id="473a" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">一旦你安装好了，我们将导入我们需要的模块</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e42a" class="my ln it mu b gy mz na l nb nc">import quandl as qd<br/>import pandas as pd<br/>import numpy as np</span><span id="fc19" class="my ln it mu b gy ni na l nb nc">import fbprophet<br/>import matplotlib.pyplot as plt</span></pre><p id="fe3d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Quandl 是一个惊人的存储库，拥有大量极其不同的数据集。你需要注册一个免费账户并生成一个 API。那我们准备开始了。首先从 Quandl 下载比特币市场数据，去掉零值(由于某种原因，价格数据在初始行中包含零)</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ea47" class="my ln it mu b gy mz na l nb nc">KEY = "YOUR_API_KEY"<br/>qd.ApiConfig.api_key = KEY</span><span id="3375" class="my ln it mu b gy ni na l nb nc">bitcoin = qd.get("BCHAIN/MKPRU")<br/>bitcoin = bitcoin.loc[(bitcoin !=0).any(1)]</span></pre><p id="418b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将价格数据放入一个名为比特币的熊猫数据框架中。要检查前几行，请键入</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="db17" class="my ln it mu b gy mz na l nb nc">bitcoin.head()</span></pre><p id="be2c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您应该得到一个名为“值”的列和一个日期时间索引</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ac16" class="my ln it mu b gy mz na l nb nc">           Value<br/>Date <br/>2010–08–17 0.076900<br/>2010–08–18 0.074000<br/>2010–08–19 0.068800<br/>2010–08–20 0.066700<br/>2010–08–21 0.066899</span></pre><p id="af49" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们想将记录的数据绘制在线性图表上(原因将在后面变得明显)，所以用比特币为记录的价格值创建一个新列</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a936" class="my ln it mu b gy mz na l nb nc">bitcoin["log_y"] = np.log(bitcoin["Value"])</span></pre><h1 id="5666" class="lm ln it bd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj bi translated">与先知一起工作</h1><p id="195a" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">我们需要做的第一件事是做点家务。Prophet 要求我们将“日期”列的名称改为“ds ”,而我们的 y 列应该简单地称为“y”</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9cf2" class="my ln it mu b gy mz na l nb nc">bitcoin = bitcoin.rename(columns={"Date": "ds", "log_y" : "y"})</span></pre><p id="4187" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Prophet 所做的大部分工作都发生在幕后，但是有一些超参数允许我们轻松地微调我们的模型。我们将只调整<em class="lk">change point _ prior _ scale</em>参数。</p><p id="0dbc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">转折点基本上是趋势突然改变方向的点，例如反转。Prophet 可以自动为您找到这些点，尽管您可以自己定义它们，尽管对于大型和特殊的数据集来说这是不切实际的。嘿，这就是机器的作用，对吧？<em class="lk">change point _ prior _ scale</em>参数基本上允许您选择您希望变点与数据匹配的紧密程度。</p><p id="b3d8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">构建任何模型的目标是能够将其推广到其他数据/场景，并获得类似的结果。所以我们不希望我们的模型过多地跟随训练数据，这叫做过拟合。同样，拟合不足也会产生泛化能力差的模型。</p><p id="6e54" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，我们将使用这个超参数进行所有微调。该值越高，拟合越紧密，同样，该值越低，拟合越松散。在这个演示中，我选择的值(0.0015 和 0.015)之间相隔一个数量级。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="facf" class="my ln it mu b gy mz na l nb nc">priors = [0.0015, 0.015]<br/>prophets, labels = [], []<br/>for prior in priors:<br/>    prophet = fbprophet.Prophet(changepoint_prior_scale=prior)<br/>    prophet.fit(bitcoin)<br/> <br/>    prophets.append(prophet)<br/>    labels.append(r"CP Prior = " + str(prior))</span></pre><p id="0e03" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此时，您应该有一个包含两个 prophet 对象的列表和一个用于绘制的标签列表。下一步是使用这些 prophet 对象来生成预测对象。(我们还将使用<em class="lk"> changepoint_prior_scale </em>值前缀重命名“ds”列，以便跟踪数据。)</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0137" class="my ln it mu b gy mz na l nb nc">forecasts = []<br/>for prophet in prophets:<br/>    forecast = prophet.make_future_dataframe(periods=365 * 2,                                                    freq="D")<br/>    forecast = prophet.predict(forecast)<br/> <br/>    forecast = forecast.rename(columns={"ds" : str(priors[prophets.index(prophet)]) + "_ds"})<br/>    forecasts.append(forecast)</span></pre><p id="3e02" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">差不多就是这样。如果一切顺利，您应该已经生成了两个预测对象的列表(实际上只是熊猫数据帧)。让我们将它们合并成一个数据帧，并将其中一个' _ds '列重命名为' Date ',删除另一个。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="403d" class="my ln it mu b gy mz na l nb nc">output = pd.merge(forecasts[0], forecasts[1], how = "inner", left_on = "0.0015_ds", right_on = "0.015_ds")<br/>output = output.rename(columns={"0.0015_ds": "Date"}).drop("0.015_ds", axis=1)</span></pre><p id="f77a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们将索引设置为“日期”列</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5c8a" class="my ln it mu b gy mz na l nb nc">output = output.set_index(‘Date’)</span></pre><p id="4ae3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在将在一张图表上绘制所有内容</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="eb2e" class="my ln it mu b gy mz na l nb nc">fig, ax = plt.subplots(1, 1, figsize=(10, 8))<br/>ax.plot(output.index, output["yhat_x"], label=labels[0])<br/>ax.fill_between(output.index, output["yhat_upper_x"], output["yhat_lower_x"], alpha=0.6, edgecolor = "k")</span><span id="14d3" class="my ln it mu b gy ni na l nb nc">ax.plot(output.index, output["yhat_y"], "r", label=labels[1]);<br/>ax.fill_between(output.index, output["yhat_upper_y"], output["yhat_lower_y"], alpha=0.6, edgecolor = "k")<br/>ax.plot(bitcoin.ds, bitcoin.y, color="green", linewidth=3, label=r"Bitcoin price (logged)")<br/>a=ax.get_yticks().tolist()<br/>ax.set_yticklabels(np.round(np.exp(a), 1))<br/>plt.legend(loc="upper left")<br/>plt.ylabel(r"Price /$")<br/>plt.show()</span></pre><p id="84f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“y_hat”标签是 Prophet 提供的估计值，x 或 y 后缀表示数据最初来自哪个数据框架(这里 x 是 0.0015 参数值，y 是 0.015)。</p><h1 id="4703" class="lm ln it bd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj bi translated">结论</h1><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/468738e61dffa2b7a5bc4af5484c520b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruStI0aFLhrvBsT0zrqEDg.png"/></div></div></figure><p id="b4b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里的目标只是简单地摆弄一下 Prophet 包，我认为比特币会成为一个有趣的数据集。</p><p id="38ca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">仅仅通过目测，我认为从比特币最大化的角度来看，这两个预测都非常合理，我的意思是它们符合许多看涨投资者认为价格会发生的情况。</p><p id="3a2c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">蓝色拟合可能有点不合适，但你可以看到，随着时间的推移，估计的不确定性保持相当稳定，甚至到未来。一般来说，它提供了更多的概括空间，但对趋势变化的反应可能太慢。因此我认为这是不可靠的。我不认为价格会长期保持这种趋势。</p><p id="1290" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一方面，红色拟合似乎过度拟合了数据。它紧紧跟随历史价格波动，并对趋势变化做出快速反应，然而不确定性真的会在未来爆发，使得这个预测也不可靠，尽管红色趋势更可信一些。</p><p id="5cab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就我个人而言，我并不觉得这种价格预测特别有用，但关注这一点并观察脸书算法的结果会很有趣。</p></div></div>    
</body>
</html>