<html>
<head>
<title>Optimization Techniques: Genetic Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化技术:遗传算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimizing-machine-learning-models-with-genetic-algorithms-2a38682a0610?source=collection_archive---------8-----------------------#2019-09-21">https://towardsdatascience.com/optimizing-machine-learning-models-with-genetic-algorithms-2a38682a0610?source=collection_archive---------8-----------------------#2019-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3960" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种自适应且众所周知的优化技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d71ac8834a030e94f710e0040e9e2d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1BQQ1oDl6_hDyKLqgIzHQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@nasa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NASA</a> on <a class="ae ky" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dcfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在复杂的机器学习模型中，性能通常取决于多个输入参数。为了得到最佳模型，必须适当地调整参数。然而，当有多个参数变量时，每个变量的取值范围很宽，每组参数有太多可能的配置需要测试。在这些情况下，应使用优化方法来获得最佳输入参数，而无需花费大量时间来寻找它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/4be4127d5d304b3932939831549a12ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2F6D7FXUYueTgxpbwTXN9w.png"/></div></div></figure><p id="1811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，它显示了仅基于两个参数的模型分布。如示例所示，找到曲线的最大值或最小值并不总是一件容易的事情。这就是优化方法和算法在机器学习领域至关重要的原因。</p><h1 id="046c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">遗传算法</h1><p id="cbbd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最常用的优化策略是遗传算法。遗传算法是基于达尔文的自然选择理论。它相对容易实现，并且算法的设置有很大的灵活性，因此它可以应用于广泛的问题。</p><h2 id="6c6d" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">选择健身功能</h2><p id="d56f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，必须有一个适应度函数来衡量一组输入参数的表现。从适应度函数得到的具有较高适应度的解将比具有较低适应度的解更好。</p><blockquote class="nf ng nh"><p id="ed95" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">例如，如果一个解决方案的成本为 x + y + z，那么适应度函数应该尝试最小化成本。这可以通过以下健身功能来实现:</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a5ea68304659d64f45a194792c40683f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*K6x9kOpDnaxE7Z2673zNbA.png"/></div></figure><p id="6f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该适应度函数将为每组输入参数生成一个适应度值，并用于评估每组参数的执行情况。</p><h2 id="978a" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">产生一个群体</h2><p id="8181" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要运行遗传算法，首先从一群个体开始，其中每个个体都是一个解。解决方案由一组基因表示，其中解决方案中的每个基因都是模型中的一个变量。每个解决方案都是随机生成的，并根据适应度函数进行评估，以生成适应度分数。选择一个合适的人口规模是非常重要的。如果群体规模太低，那么就很难探索问题的整个状态空间。如果群体太大，那么将需要很长时间来处理每一代，因为计算适应度和生成每个群体的系统成本将需要指数级的更多时间来处理。</p><h2 id="4a76" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">亲代选择</h2><p id="0ee4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来，群体经历一个称为<strong class="lb iu">父代选择</strong>的过程，其中最佳解决方案(最适合的个体)将被选择以创建下一代解决方案。有许多方法可以做到这一点，如<strong class="lb iu">健身比例选择(FPS)，基于排名的选择，以及锦标赛选择。</strong>这些方法各有利弊，应根据模型进行选择。</p><h2 id="a6e0" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">交叉</h2><p id="64ba" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一旦亲本被选中，亲本将经历一个叫做<strong class="lb iu">交叉</strong>的过程。交叉是指两个父母为了创造一个新的解决方案而交叉他们的基因(也称为孩子)。这促进了在问题的状态空间中的<strong class="lb iu">探索</strong>，并且潜在地产生了从未被测试过的新的解决方案。</p><p id="6f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是根据解决方案的数据类型以不同方式完成的。对于基因用二进制表示的解，有<em class="ni"> 1 点交叉、n 点交叉、</em>和<em class="ni">均匀交叉</em>等方法。</p><p id="6673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于基因是实值的解决方案，有诸如<em class="ni">单算术交叉</em>和<em class="ni">全算术交叉</em>的方法。</p><p id="fffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，对于排列问题(如旅行推销员问题等)，有一些方法，如<em class="ni">部分映射交叉(又名 PMX)、边交叉、顺序 1 交叉</em>和<em class="ni">循环交叉</em>。</p><h2 id="1ab0" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">变化</h2><p id="561e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在交叉阶段之后，产生的子代经历一个<strong class="lb iu">突变</strong>阶段。突变是指每个基因都可能根据随机概率发生变化。这允许<strong class="lb iu">利用</strong>,因为子解决方案不会像交叉阶段那样剧烈变化，但仍然能够在其当前解决方案的邻域内探索。</p><p id="b380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于二进制解决方案，变异过程相对简单，每个位根据某种变异概率进行切换。</p><p id="40e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于实值解，可以根据该变量的一些可接受的范围或者通过添加一些以 0 为中心并且根据一些高斯分布变化的噪声来选择不同的基因。</p><p id="904f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，对于排列问题，主要有四种方法；<em class="ni">插入突变、交换突变、倒位突变、</em>和<em class="ni">争夺突变</em>。</p><h2 id="0178" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">幸存者选择</h2><p id="6899" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一旦创建了儿童群体，下一个阶段就是<strong class="lb iu">幸存者选择</strong>。这一阶段决定了哪些个体可以继续传给下一代。有多种方法可以做到这一点，因为新一代可以从父母和子女中选择。选择每一代幸存者的方法主要有两种，<em class="ni">基于年龄的选择</em>和<em class="ni">基于适应度的选择(FBS) </em>。在 FBS 中，有<em class="ni">精英主义</em>，其中每个群体中最适合的被选择，还有<em class="ni">天才</em>，其中每个群体中最不适合的被淘汰。</p><h2 id="801d" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">算法重复</h2><p id="6873" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一旦选择了新一代，整个过程重复进行，直到算法根据某些收敛标准收敛。在整个算法运行之后，返回所有代中的最佳解决方案。</p><h1 id="1024" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">履行</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="3c43" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="c0c4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">遗传算法因其广泛的适用问题而被广泛应用。简单版本的遗传算法相对容易实现，但有更复杂的变化。例如，这些遗传算法可以并行执行，其中整组可调参数可以在并行遗传算法上分开。根据问题的计算量，这些并行 GAs 可以被配置为细粒度的或粗粒度的。算法也可以采用主从方式，从机控制计算，主机控制选择过程。此外，解决方案还可以被配置为在不同的并行遗传算法之间结合不同的拓扑和迁移策略。所有这些变化使得遗传算法具有广泛的灵活性，并且绝对是一个需要了解的重要算法。</p></div></div>    
</body>
</html>