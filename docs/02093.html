<html>
<head>
<title>Deep learning to identify Malaria cells using CNN on Kaggle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Kaggle 上使用 CNN 进行深度学习以识别疟疾细胞</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-to-identify-malaria-cells-using-cnn-on-kaggle-b9a987f55ea5?source=collection_archive---------12-----------------------#2019-04-06">https://towardsdatascience.com/deep-learning-to-identify-malaria-cells-using-cnn-on-kaggle-b9a987f55ea5?source=collection_archive---------12-----------------------#2019-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bff64175bd2aa3797eb94109f2763b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qe8YyoaPoAiK6PUU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@hikendal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kendal James</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2e33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">深度学习有着广泛的应用，它在医疗保健行业的应用一直让我着迷。作为一名敏锐的学习者和 Kaggle noob，我决定研究疟疾细胞数据集，以获得一些实践经验，并学习如何在 Kaggle 平台上使用卷积神经网络、Keras 和图像。</p><p id="4bb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢 Kaggle 的一个原因是它以内核和讨论的形式保存了大量的知识。从各种内核和专家那里获取线索和参考资料确实帮助我更好地产生高度准确的结果。一定要看看其他内核，了解他们的方法，以便为您自己的开发和知识建设获得更多的见解。</p><h2 id="a834" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">快速来源</h2><ol class=""><li id="57db" class="lx ly it ki b kj lz kn ma kr mb kv mc kz md ld me mf mg mh bi translated"><strong class="ki iu">数据集:</strong><a class="ae kf" href="https://www.kaggle.com/iarunava/cell-images-for-detecting-malaria" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/iarunava/cell-images-for-detecting-malaria</a></li><li id="c830" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated"><strong class="ki iu"> Kaggle 笔记本:</strong><a class="ae kf" href="https://www.kaggle.com/bhanotkaran22/keras-cnn-data-augmentation" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/bhanotkaran 22/keras-CNN-data-augmentation</a></li></ol><h1 id="7c1f" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated">导入库和数据集</h1><p id="117a" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">我从导入<code class="fe nh ni nj nk b">numpy</code>、<code class="fe nh ni nj nk b">pandas</code>和<code class="fe nh ni nj nk b">matplotlib</code>开始。我决定使用 Keras 和 Tensorflow backend 来实现 CNN 模型。所以，我从<code class="fe nh ni nj nk b">keras.layers</code>中导入了一些图层，包括<code class="fe nh ni nj nk b">Convolution2D</code>、<code class="fe nh ni nj nk b">MaxPooling2D</code>、<code class="fe nh ni nj nk b">Flatten</code>、<code class="fe nh ni nj nk b">Dense</code>、<code class="fe nh ni nj nk b">BatchNormalization</code>和<code class="fe nh ni nj nk b">Dropout</code>。我用的是<code class="fe nh ni nj nk b">Sequential</code>型号。为了处理数据集中的图像，我导入了<code class="fe nh ni nj nk b">os</code>、<code class="fe nh ni nj nk b">cv2</code>和<code class="fe nh ni nj nk b">Image</code>包。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="b816" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated">导入数据集</h1><p id="7948" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">在 Kaggle 中，所有数据文件都位于笔记本所在位置的上一级文件夹<code class="fe nh ni nj nk b">input</code>中。图像在<code class="fe nh ni nj nk b">cell_images</code>文件夹中。因此，我将数据目录设置为<code class="fe nh ni nj nk b">DATA_DIR</code>来指向那个位置。为了存储特性，我使用了变量<code class="fe nh ni nj nk b">dataset</code>，对于标签，我使用了<code class="fe nh ni nj nk b">label</code>。对于这个项目，我将每个图像的大小设置为 64x64。</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="908a" class="le lf it nk b gy nv nw l nx ny">DATA_DIR = '../input/cell_images/cell_images/'<br/>SIZE = 64<br/>dataset = []<br/>label = []</span></pre><p id="bc3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是导入数据。寄生(感染)的细胞图像在<code class="fe nh ni nj nk b">Parasitized</code>文件夹内，未感染的图像在<code class="fe nh ni nj nk b">Uninfected</code>文件夹内。</p><p id="09ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这两个文件夹，我遍历了所有扩展名为<code class="fe nh ni nj nk b">png</code>的文件。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b9da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于被寄生的细胞图像，我使用<code class="fe nh ni nj nk b">cv2.imread()</code>读取图像，使用<code class="fe nh ni nj nk b">Image.fromarray()</code>将其从数组转换，并将其大小调整为 64x64。最后，我将它保存到<code class="fe nh ni nj nk b">dataset</code>变量中，并将每张图片的<code class="fe nh ni nj nk b">0</code>附加到<code class="fe nh ni nj nk b">label</code>中。我对未感染的细胞图像重复了相同的过程，但这次将标签设置为<code class="fe nh ni nj nk b">1</code>。</p><h1 id="4b27" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated">可视化数据</h1><p id="2c0e" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">我用 matplotlib 随机绘制了 5 个被寄生和 5 个未被感染的细胞。</p><h2 id="a1ef" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">寄生细胞</h2><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/150547df2d21785d68181fb958ba69ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-ACPktwuGdUgWutl9lSVw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Parasitized cells</figcaption></figure><h2 id="5909" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">未感染的细胞</h2><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/6e98d23b9dc857aeec8e1d8a2a5aa224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gjdAIsVlrnhMQcByhZxmw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Uninfected cells</figcaption></figure><h1 id="de98" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated">应用 CNN</h1><p id="08ac" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">卷积神经网络是处理图像和进行分类的最有效的神经网络之一。我使用 Keras 创建模型。</p><h2 id="e0a3" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">卷积 2D</h2><p id="0c1c" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">这将创建一个卷积核。我设置了一些如下定义的属性:</p><ul class=""><li id="1a7e" class="lx ly it ki b kj kk kn ko kr ob kv oc kz od ld oe mf mg mh bi translated"><strong class="ki iu">过滤器:</strong>第一个参数定义层的输出形状。在这种情况下，对于两个层，我都将值保持为<code class="fe nh ni nj nk b">32</code>。</li><li id="8054" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld oe mf mg mh bi translated"><strong class="ki iu"> kernel_size: </strong>它定义了我们想要使用的沿着图像遍历的窗口的大小。我设置为<code class="fe nh ni nj nk b">3x3</code>。</li><li id="53ad" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld oe mf mg mh bi translated"><strong class="ki iu"> input_shape: </strong>用于定义每张图像的输入尺寸。在这个项目中，我使用 64x64 大小的图像，图像是彩色的，即它们由红色，蓝色和绿色组成。因此通道是 3 个。因此，参数<code class="fe nh ni nj nk b">input_shape</code>将为<code class="fe nh ni nj nk b">(64, 64, 3)</code>。我们只需要为第一层定义<code class="fe nh ni nj nk b">input_shape</code>。</li><li id="18e5" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld oe mf mg mh bi translated"><strong class="ki iu">激活:</strong>激活功能在此参数中定义。我使用<code class="fe nh ni nj nk b">relu</code>作为激活函数，它是整流线性单元。</li></ul><h2 id="b878" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">MaxPool2D</h2><p id="c442" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">它用于缩减输出，我使用了以下参数:</p><ul class=""><li id="97e3" class="lx ly it ki b kj kk kn ko kr ob kv oc kz od ld oe mf mg mh bi translated"><strong class="ki iu"> pool_size: </strong>定义了矩阵大小，矩阵大小定义了将被转换为 1 个值的像素值的数量。我使用的值是<code class="fe nh ni nj nk b">2x2</code>，因此大小为<code class="fe nh ni nj nk b">62x62</code>的图像将被转换为<code class="fe nh ni nj nk b">31x31</code>。</li><li id="4340" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld oe mf mg mh bi translated"><strong class="ki iu"> data_format: </strong>描述了在输入中，通道是定义在开头还是结尾。在这种情况下，第三个值用于<code class="fe nh ni nj nk b">(64, 64, 3)</code>中的通道，我将<code class="fe nh ni nj nk b">data_format</code>设置为<code class="fe nh ni nj nk b">channels_last</code>。</li></ul><h2 id="0751" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">批量标准化</h2><p id="1953" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">它将前一个激活函数的输出标准化，我只修改了一个参数:</p><ul class=""><li id="9bd0" class="lx ly it ki b kj kk kn ko kr ob kv oc kz od ld oe mf mg mh bi translated"><strong class="ki iu">轴:</strong>定义要归一化的轴。当我使用<code class="fe nh ni nj nk b">channels_last</code>时，我将值设置为<code class="fe nh ni nj nk b">-1</code>。</li></ul><h2 id="94e0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">拒绝传统社会的人</h2><p id="2b4b" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">它随机选择一些值设置为<code class="fe nh ni nj nk b">0</code>，以防止在模型中过度拟合，我只使用了速率参数:</p><ul class=""><li id="fdbf" class="lx ly it ki b kj kk kn ko kr ob kv oc kz od ld oe mf mg mh bi translated"><strong class="ki iu">比率:</strong>要丢弃的输入分数。我把汇率保持为<code class="fe nh ni nj nk b">0.2</code>。</li></ul><h2 id="00b5" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">变平</h2><p id="babb" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">它将完整的 n 维矩阵展平为单个数组。因此，如果它的大小是<code class="fe nh ni nj nk b">64x64x3</code>，它将被转换成大小为<code class="fe nh ni nj nk b">12,288</code>的数组。它作为前面致密层的输入。</p><h2 id="36c2" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">稠密的</h2><p id="7049" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">它定义了一个密集连接的神经网络层，我定义了以下参数:</p><ul class=""><li id="9771" class="lx ly it ki b kj kk kn ko kr ob kv oc kz od ld oe mf mg mh bi translated"><strong class="ki iu">激活:</strong>定义了除最后(输出)层外，我设置为<code class="fe nh ni nj nk b">relu</code>的激活函数。对于最后一个密集层，我设置激活为<code class="fe nh ni nj nk b">sigmoid</code>。</li><li id="c524" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld oe mf mg mh bi translated"><strong class="ki iu">单位:</strong>定义给定层的神经元个数。我创建了三层，神经元数量分别为 512、256 和 2。</li></ul><h2 id="591d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">本项目中 CNN 模型的结构</h2><p id="932b" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">我为 CNN 制作了一个<code class="fe nh ni nj nk b">Sequential</code>模型。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5147" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建了一个卷积层，然后是一个最大池层。接下来是<code class="fe nh ni nj nk b">BatchNormalization</code>以标准化来自先前层的输出并应用<code class="fe nh ni nj nk b">Dropout</code>规则化。然后附加另一组这些层。然后我<code class="fe nh ni nj nk b">Flatten</code>输出。然后，展平的输出被传递到人工神经网络，该网络包括具有 512、256 和 2 个节点的三个密集层。最后一层是带有激活功能<code class="fe nh ni nj nk b">sigmoid</code>的输出层。你可以在这里阅读更多关于激活功能<a class="ae kf" rel="noopener" target="_blank" href="/activation-functions-neural-networks-1cbd9f8d91d6">的信息。</a></p><p id="633e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步是编译模型。优化器是<code class="fe nh ni nj nk b">adam</code>，这是一个分类问题，我使用损失作为<code class="fe nh ni nj nk b">categorical_crossentropy</code>，评估指标作为<code class="fe nh ni nj nk b">accuracy</code>。</p><h1 id="67ba" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated">培训和准确性</h1><p id="ad7b" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">我将数据集分成 80%的训练数据和 20%的测试数据。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5404" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe nh ni nj nk b">fit</code>的方法，我用<code class="fe nh ni nj nk b">X_train</code>和<code class="fe nh ni nj nk b">y_train</code>训练模型。我使用总时期作为<code class="fe nh ni nj nk b">50</code>，它基本上是完整数据集的 50 次迭代，批量大小为<code class="fe nh ni nj nk b">64</code>。我还添加了 0.1 的验证，这样模型在 90%的训练数据上训练，在 10%的训练数据上验证。</p><blockquote class="of"><p id="eff6" class="og oh it bd oi oj ok ol om on oo ld dk translated">该模型达到了 95.75%的准确率。</p></blockquote><h1 id="ce36" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu op mw lp mx oq mz ls na or nc lv nd bi translated">数据扩充和准确性改进</h1><p id="7619" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">数据扩充有助于增加数据集，并在更多不同的数据上训练模型。可供模型学习的数据越多，模型的表现就越好。Keras 提供了一个可以创建这些数据的子包<code class="fe nh ni nj nk b">ImageDataGenerator</code>。</p><h2 id="360d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">数据扩充</h2><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3794" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于训练数据，我通过除以<code class="fe nh ni nj nk b">255</code>来重新缩放图像，以<code class="fe nh ni nj nk b">0.3</code>的范围缩放图像，水平翻转图像并旋转<code class="fe nh ni nj nk b">30</code>的角度。为了测试数据，我只是重新缩放图像。<code class="fe nh ni nj nk b">train_generator</code>和<code class="fe nh ni nj nk b">test_generator</code>以<code class="fe nh ni nj nk b">64</code>的批量创建。</p><h2 id="02ac" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">计算新精度</h2><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="791b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我使用<code class="fe nh ni nj nk b">fit_generator</code>训练分类器，并计算新的准确度。</p><blockquote class="of"><p id="9a8a" class="og oh it bd oi oj ok ol om on oo ld dk translated">该模型通过数据扩充达到了 96.41%的准确率。</p></blockquote><p id="1bdb" class="pw-post-body-paragraph kg kh it ki b kj os kl km kn ot kp kq kr ou kt ku kv ov kx ky kz ow lb lc ld im bi translated">正如我们所看到的，通过数据扩充，我能够提高模型的准确性，同时仍然拥有相同的数据。乍一看，它可能看起来准确性没有增加多少，但在医疗领域，一个百分点的增加真的很有用，可以正确识别更多的患者。</p><h1 id="8456" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated">结论</h1><p id="f884" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">在本文中，我讨论了对疟疾细胞图像使用卷积神经网络和数据增强，并实现了 96.41%的测试准确率。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="9cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。请分享你的想法、想法和建议。</p></div></div>    
</body>
</html>