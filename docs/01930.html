<html>
<head>
<title>Interpretable Convolutional Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可解释卷积神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interpretable-convolutional-neural-network-3f7ef6c9b7ae?source=collection_archive---------13-----------------------#2019-03-30">https://towardsdatascience.com/interpretable-convolutional-neural-network-3f7ef6c9b7ae?source=collection_archive---------13-----------------------#2019-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a482" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://arxiv.org/abs/1710.00935" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">这篇论文</strong> </a> <strong class="js iu">由美国加州大学洛杉机分校的张全世、吴英年和宋提出了一种将传统的卷积神经网络(CNN)修改为可解释的 CNN 的方法，以阐明 CNN 的高 conv 层中的知识表示。</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/df3c420a224b77355293c0116471e8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DGs0o1DFHCaCMZvY"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Figure 1: Comparison of a filter’s feature maps in an interpretable CNN and those in a traditional CNN</figcaption></figure><p id="ebae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题:在没有任何额外的人工监督的情况下，我们能修改 CNN 以在其 conv 层获得可解释的知识表示吗？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lf"><img src="../Images/b2b4015702842cf9237d54ef51ae0eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QSn6tv_AD_Vwp-2e"/></div></div></figure><p id="9d0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Bau et al .<a class="ae ko" href="https://arxiv.org/abs/1704.05796" rel="noopener ugc nofollow" target="_blank">【1】</a>在 CNN 中定义了六种语义，即物体、零件、场景、纹理、材质、颜色。</p><p id="19dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，我们可以大致将前两种语义认为是<strong class="js iu">具有特定形状的对象-部分模式</strong>，将后四种语义概括为<strong class="js iu">没有清晰轮廓的纹理模式。</strong>低 conv 层中的过滤器通常描述简单的纹理，而高 conv 层中的过滤器更可能表示对象部分。</p><p id="ca16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们的方法是在一个高 conv 层中训练每个滤波器来表示一个对象部分。在传统的 CNN 中，高层过滤器可以描述一个<strong class="js iu">混合模式</strong>，即过滤器可以被猫的头部和腿部激活(图 1)。高 conv 层中的这种复杂表示大大降低了网络的可解释性。因此，他们的方法<strong class="js iu"> <em class="lg">迫使</em> </strong>可解释 CNN 中的滤波器被某个部分激活。</p><h1 id="47cf" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">学习更好的表达方式</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mf"><img src="../Images/89b4e1054b69f106da2935c5e442edf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r2BoUbmJ-hRksiu_"/></div></div></figure><p id="ddee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文发明了一种通用损失来正则化滤波器的表示，以提高其可解释性。</p><p id="35a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该损失促使<strong class="js iu">类别间激活的低熵</strong>和<strong class="js iu">神经激活的空间分布的低熵</strong>，这意味着迫使 CNN 中层的特征图不被对象的不同区域随机激活，并且具有一致的激活分布。</p><p id="63a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">滤镜必须由对象的单个部分激活，而不是重复出现在不同的对象区域。</p><p id="ccaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们假设不同区域上的重复形状更倾向于描述低级纹理(例如颜色和边缘)，而不是高级部分。</p><h1 id="19c8" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">如何做到这一点？</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mg"><img src="../Images/0dadcbd921e55475fe19472ee4c7e555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tCLQrMXk9r5W3DSd"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Figure 3</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl mh"><img src="../Images/b5328d6ed5c3cdf65524518eef5a578f.png" data-original-src="https://miro.medium.com/v2/0*CmNxHYkvitujQiSN"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Figure 4</figcaption></figure><ol class=""><li id="44cb" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">设 I 表示一组训练图像，其中<em class="lg"> I_c ⊂ I </em>表示属于类别<em class="lg"> c </em>的子集，(<em class="lg"> c </em> = 1，2，.。。，C)。</li><li id="b5bf" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">在 ReLU 操作后，给滤波器<em class="lg"> f </em>的特征图<em class="lg"> x </em>增加一个损耗</li><li id="dee1" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">特征图<em class="lg"> x </em>是一个<em class="lg"> n × n </em>矩阵，<em class="lg"> x_ij </em> ≥ 0。</li><li id="5500" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><em class="lg"> f </em>对应的对象部分可能出现在不同图像的不同位置，为<em class="lg"> f {T_ </em> <em class="lg"> 1，…，T_ </em> <em class="lg"> n } </em>设计<em class="lg"> n </em>模板</li><li id="ef35" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">每个模板<em class="lg"> T_ i </em>也是一个<em class="lg"> n × n </em>矩阵，它描述了当目标零件主要触发<em class="lg"> x </em>中的<em class="lg"> i-th </em>单元时，特征图<em class="lg"> x </em>的激活的理想分布</li><li id="6138" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><em class="lg"> = argmax_[i，j] x_ij </em></li><li id="5e23" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><em class="lg"> x^masked = max{x .* T_，0} </em></li></ol><p id="b9c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在他们的代码实现中，实际上他们在特征图中寻找最大值(有 2 种方法，但最简单的是最大值)，然后创建一个类似高斯形状的掩码(如图 3)与特征图具有相同的形状(例如，特征图的大小为 6x6，然后模板掩码的大小为 6x6)，然后与掩码执行元素乘法，并产生一个新的掩码特征图(图 4)。如果特征映射中的最大值为 0，则该模板被视为负模板，这意味着该过滤器不会为该对象激活。</p><h2 id="703f" class="mw li it bd lj mx my dn ln mz na dp lr kb nb nc lv kf nd ne lz kj nf ng md nh bi translated"><strong class="ak">注释</strong></h2><p id="b92a" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">1.要素地图=图层中的过滤器。<br/> 2。本文中的训练数据每幅图像只包含一个零件/对象，如果有两个相同的对象，训练可能会失败？或者两个相同的对象可能有一点不同，因此被两个滤波器激活。</p><h1 id="01bd" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">损失函数</h1><p id="e138" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">我太年轻了，无法解释这个，只能说说我对损失函数的理解。请阅读原文，了解这些方程的更多细节。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nn"><img src="../Images/211cd36a5d68018c1a918e8f11894c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VbdX-sSqPHq0WHEB"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 1: the loss for f as the mutual information between X and T. The prior probability of a template is given as p(Tµ) = α n2 , p(T −) = 1 − α, where α is a constant prior likelihood.</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi no"><img src="../Images/3704248dbf4cb06e445b84e3938311d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_XTr527hyadnnQIa8sk9Q.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 2: The fitness between a feature map x and a template T is measured as the conditional likelihood p(x|T).</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi np"><img src="../Images/ce70e7de4f1ae4cb26aa6f9c245d5c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cr17WjAwJTcUH6U6h9eWBA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 3: each filter in an interpretable conv-layer receives gradients w.r.t. its feature map x from both the final task loss L(ˆyk, y∗ k) and the local filter loss Lossf</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/055322831bc283915909dd1d97648f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*O-KUlRYXWEEYQq_1GxYurw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 4: compute gradients of Lossf w.r.t. each element xij of feature map x as follows</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/11217efdde55839a485391a0c37f9a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*8bFmCga4kSqxKxr5CO9Rmw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 5: rewrite Equation 1, H(T) = − P T ∈T p(T) log p(T) is a constant, which denotes the prior entropy of part templates.</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8ef8817c10f7eeaebecaa581bea122e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*wR-vx5kGdHOhvfgxsaiSrQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 6: Low inter-category entropy</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3b87b5ec6f3924c1cc4715fd3c12818c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*q_CuwRvoCZnGZpn27f4RBw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Equation 7: Low spatial entropy</figcaption></figure><p id="fe48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> TLDR: </strong>所有这些方程对我来说仍然是清晰的，就我的理解而言，损失函数推动过滤器<em class="lg"> f </em>来表示类别 c 的特定对象部分，并对 CNN 中的其他类别的图像和层的特征图保持沉默，以不被对象的不同区域随机激活，并具有一致的激活分布。</p><h1 id="2a1c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">实验设置</h1><p id="f01c" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">为了简单起见，VGG</p><p id="32be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">三个基准数据集:</strong>因为他们需要物体地标(部分)的地面实况注释来评估每个过滤器的语义清晰度，所以他们选择了三个带有地标/部分注释的基准数据集来进行训练和测试，包括 ILSVRC 2013 DET 动物部分数据集、cub 200–2011 数据集和 Pascal VOC 部分数据库。</p><h1 id="b62e" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">实验结果</h1><p id="b5a8" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">他们在<strong class="js iu">零件可解释性</strong>和<strong class="js iu">位置稳定性</strong>上取得了较好的成绩。普通 CNN 在单类别分类中表现更好。然而，对于多类别分类，<strong class="js iu">可解释 CNN 表现出比普通 CNN</strong>更好的性能。在多类别分类中的良好表现可能是因为早期阶段的过滤器语义的澄清降低了后期阶段过滤器学习的难度。更多结果，请阅读原文。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nu"><img src="../Images/64ded0cee142415ae74988552445d1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ptvGRWk6RDKTD6YI"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">The top four rows visualize filters in interpretable CNNs, and the bottom two rows correspond to filters in ordinary CNNs. They found that interpretable CNNs usually encoded head patterns of animals in its top conv-layer for classification.</figcaption></figure><p id="4099" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与普通 CNN 相比，可解释 CNN 具有更一致和更容易理解的激活。我们可以<strong class="js iu">确认</strong>顶部 conv 层中的特定滤镜代表特定动物的头部图案。</p><h1 id="8809" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><ul class=""><li id="b9b1" class="mi mj it js b jt ni jx nj kb nv kf nw kj nx kn ny mo mp mq bi translated">提出了一种通用的方法来修改传统的细胞神经网络，以增强其可解释性</li><li id="c273" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn ny mo mp mq bi translated">损失被设计成将高 conv 层中的过滤器推向对象部分的表示，而没有用于监督的附加注释</li><li id="663d" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn ny mo mp mq bi translated">与传统的 CNN 相比，可解释的 CNN 在高 conv 层编码了更多语义上有意义的知识。</li></ul><p id="24e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">参考</strong></p><p id="adf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代号:<a class="ae ko" href="https://github.com/zqs1022/interpretableCNN" rel="noopener ugc nofollow" target="_blank">https://github.com/zqs1022/interpretableCNN</a></p><p id="2a18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">论文:<a class="ae ko" href="https://arxiv.org/abs/1710.00935" rel="noopener ugc nofollow" target="_blank">张全世，吴英年，宋，“可解释卷积神经网络”，2018 </a></p></div></div>    
</body>
</html>