<html>
<head>
<title>Use Scikit-Learn Pipelines to clean data and train models faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Scikit-Learn 管道更快地清理数据和训练模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/use-scikit-learn-pipelines-to-clean-data-and-train-models-faster-82a5171f50dc?source=collection_archive---------9-----------------------#2019-09-19">https://towardsdatascience.com/use-scikit-learn-pipelines-to-clean-data-and-train-models-faster-82a5171f50dc?source=collection_archive---------9-----------------------#2019-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将管道纳入机器学习工作流程的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e14413144ed126639761e3121a96eea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKU6_W8SdOdiovqaSdpQsw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by Gerd Altmann from Pixabay</figcaption></figure><p id="605f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在寻找一种方法来组织您的数据处理工作流并减少代码冗余，Scikit-Learn 管道将是您的数据科学工具包的一个很好的补充。在解释了它们是什么以及为什么使用它们之后，我将向你展示如何使用它们来自动化数据处理，通过使用它们来预测<a class="ae lu" href="https://www.kaggle.com/c/tmdb-box-office-prediction/data" rel="noopener ugc nofollow" target="_blank">全球票房收入</a>。</p><h2 id="ae39" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">什么是 Scikit-Learn 管道？</h2><p id="3f12" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">管道可能是一个非常模糊的术语，但一旦你意识到它在建立机器学习模型的背景下做什么，它就非常合适了。Scikit-Learn 管道将多个数据处理步骤链接成一个可调用的方法。</p><p id="a002" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设您想要从电影数据中转换连续的特征。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/6eab6dacf5237724a6f5211f86bda7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*N6k8Aow-KJwOYYsGsff3pw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Continuous features from movie data</figcaption></figure><p id="8a48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要处理回归模型的连续数据，标准处理工作流包括输入缺失值、转换倾斜变量以及标准化数据。您可以在单独的步骤中处理数据，就像这样。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a990" class="lv lw it mv b gy mz na l nb nc">cont_vars = ['budget', 'popularity', 'runtime']</span><span id="b268" class="lv lw it mv b gy nd na l nb nc">imputer = SimpleImputer(strategy = 'median')<br/>transformer = PowerTransformer(method = 'yeo-johnson', standardize = False)<br/>scaler = StandardScaler()</span><span id="7daa" class="lv lw it mv b gy nd na l nb nc">X_train[cont_vars] = imputer.fit_transform(X_train[cont_vars])<br/>X_train[cont_vars] = transformer.fit_transform(X_train[cont_vars])<br/>X_train[cont_vars] = scaler.fit_transform(X_train[cont_vars])<br/></span></pre><p id="785d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是如果你只是使用一个管道来一次应用所有的数据转换，那将会更干净、更高效、更简洁。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a9db" class="lv lw it mv b gy mz na l nb nc">cont_pipeline = make_pipeline(<br/>    SimpleImputer(strategy = 'median'),<br/>    PowerTransformer(method = 'yeo-johnson', standardize = False),<br/>    StandardScaler()<br/>)</span><span id="7ec5" class="lv lw it mv b gy nd na l nb nc">X_train[cont_vars] = cont_pipeline.fit_transform(train[cont_vars], columns = cont_vars)</span></pre><p id="b6e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用管道，您可以清楚地看到您的处理步骤，并快速添加或删除步骤。你也只需要调用<code class="fe ne nf ng mv b">fit_transform()</code>一次，而不是三次。</p><h2 id="abef" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">使用管道同步处理不同的数据类型</h2><p id="d1a3" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我使用管道来处理连续数据，但是在电影数据中也有离散的数字列、分类列和 JSON 类型的列。每种数据类型都需要不同的处理方法，因此您可以为每种数据类型构建唯一的管道。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d4ae" class="lv lw it mv b gy mz na l nb nc">disc_vars = list(X_train.select_dtypes(include = int).columns)</span><span id="71f6" class="lv lw it mv b gy nd na l nb nc">disc_pipeline = make_pipeline(<br/>    SimpleImputer(strategy = 'constant', fill_value = -1)<br/>)</span><span id="f981" class="lv lw it mv b gy nd na l nb nc">cat_vars = ['original_language', 'release_season']</span><span id="485c" class="lv lw it mv b gy nd na l nb nc">cat_pipeline = make_pipeline(<br/>    SimpleImputer(strategy = 'constant', fill_value = 'unknown'),<br/>    OneHotEncoder()<br/>)</span><span id="5717" class="lv lw it mv b gy nd na l nb nc">json_vars = ['Keywords', 'crew_department', 'production_countries', 'cast_name', 'crew_job', 'production_companies', 'crew_name', 'genres', 'spoken_languages']</span><span id="0825" class="lv lw it mv b gy nd na l nb nc">json_pipeline = make_pipeline(<br/>    TopCatEncoder()<br/>)</span></pre><p id="fd31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ne nf ng mv b">TopCatEncoder()</code>是我专门为电影数据编写的自定义转换器。一些数据列包含以 JSON 格式编码的信息，所以我定义了<code class="fe ne nf ng mv b">TopCatEncoder()</code>和一些帮助函数来根据键将 JSON 解析成分类变量，然后保留每个新分类变量的顶级类别。这就是你需要知道的关于 transformer 的全部内容，但是如果你想了解更多，你也可以查看我的 GitHub 中的<a class="ae lu" href="https://github.com/collindching/Mini-Projects/tree/master/Box%20Office%20Revenue%20Prediction" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><p id="8d51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我已经有了处理数据所需的所有管道——<code class="fe ne nf ng mv b">cont_pipeline</code>、<code class="fe ne nf ng mv b">disc_pipeline</code>、<code class="fe ne nf ng mv b">cat_pipeline</code>和<code class="fe ne nf ng mv b">json_pipeline</code>——我可以将它们组装成一个管道，使用<code class="fe ne nf ng mv b">ColumnTransformer()</code>来指定哪个管道转换哪个变量。变形金刚被指定为一个元组列表，看起来像这样:<code class="fe ne nf ng mv b">(name, transformer, columns)</code>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c8c6" class="lv lw it mv b gy mz na l nb nc">preprocessor = ColumnTransformer(<br/>    transformers = [<br/>        ('continuous', cont_pipeline, cont_vars),<br/>        ('discrete', disc_pipeline, disc_vars),<br/>        ('categorical', cat_pipeline, cat_vars),<br/>        ('json', json_pipeline, json_vars)<br/>    ]<br/>)</span></pre><p id="1127" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用这条管道转换我的所有数据，我只需调用<code class="fe ne nf ng mv b">preprocessor.fit_transform(X_train)</code>。</p><h2 id="499b" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">使用管道测试机器学习算法</h2><p id="bc89" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">这里，我使用一个名为<code class="fe ne nf ng mv b">quick_eval()</code>的效用函数来训练我的模型并进行测试预测。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3877" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过将<code class="fe ne nf ng mv b">processor</code>管道与回归模型相结合，<code class="fe ne nf ng mv b">pipe</code>可以同时处理数据处理、模型训练和模型评估，因此我们可以快速比较 8 个不同模型的基线模型性能。输出如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/91746d21edcda1a839979d4aad7381e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*hNRCJBH-8tFT3Ck1liJiKA.png"/></div></figure><h2 id="3aea" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">接下来的步骤:模型选择、特征选择和最终模型</h2><p id="a7d8" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">随着数据处理和模型原型化步骤的完成，我们可以选择一个模型子集来关注。我使用了随机森林回归器，因为它的表现相对较好，而且很容易解释。</p><p id="19b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此基础上，我们可以继续进行特征工程、特征选择和超参数调整，以获得最终模型。我使用了基于随机森林的交叉验证的变量选择程序，将我的数据从 194 个特征减少到 57 个特征，并改进了测试 RMSE。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5fd39d24da41aaa26dd696d75d204832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_Z43PHbSLx2KnUQTiU4PA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">5-fold CV model performance, p_hat is number of features fed into Random Forest regressor</figcaption></figure><p id="8f08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个变量选择实现不是这篇文章的重点，但是你可以在我的<a class="ae lu" href="https://github.com/collindching/Mini-Projects/tree/master/Box%20Office%20Revenue%20Prediction" rel="noopener ugc nofollow" target="_blank">代码</a>的函数<code class="fe ne nf ng mv b">rf_variable_selection()</code>中找到它的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="aea3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的<code class="fe ne nf ng mv b">TopFeatureSelector()</code>是另一个定制的转换器，它选择前 k 个特性来保持使用预先计算的特性重要性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5619df71980cff17ae73551a2d15ff7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*KFLsofNQomRlbB-RV8pCBA.png"/></div></figure><p id="9333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是你的最终模型！它的性能比具有较少特性的基线要好一点。</p><h2 id="abf5" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">要采取的其他步骤</h2><p id="f319" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">由于我专注于 Scikit-Learn 管道，所以我跳过了一些步骤，如<strong class="la iu">合并外部数据、特性工程和超参数调整。</strong>如果我重新审视这个项目，让我的模型变得更强大，我会专注于这三件事。我也没有在<code class="fe ne nf ng mv b">quick_eval()</code>函数中使用交叉验证，但是实现交叉验证会使这个工作流更加健壮。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="5ba3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nt">感谢阅读！我是 Scikit-Learn Pipelines 的新手，这篇博文帮助我巩固了迄今为止所做的工作。我将用我遇到的新用例来更新这个文档。</em></p><p id="a77f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nt">你可以在这里</em>  <em class="nt">查看这个项目的 Jupyter 笔记本</em> <a class="ae lu" href="https://github.com/collindching/Mini-Projects/tree/master/Box%20Office%20Revenue%20Prediction" rel="noopener ugc nofollow" target="_blank"> <em class="nt">。有关管道的更多信息，请查看丽贝卡·维克里的</em> </a><a class="ae lu" href="https://medium.com/vickdata/a-simple-guide-to-scikit-learn-pipelines-4ac0d974bdcf" rel="noopener"> <em class="nt">帖子</em> </a> <em class="nt">和 Scikit-Learn 的</em> <a class="ae lu" href="https://scikit-learn.org/stable/modules/compose.html#pipeline" rel="noopener ugc nofollow" target="_blank"> <em class="nt">管道官方指南</em> </a> <em class="nt">。</em></p></div></div>    
</body>
</html>