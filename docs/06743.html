<html>
<head>
<title>Validating your Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验证你的机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/validating-your-machine-learning-model-25b4c8643fb7?source=collection_archive---------1-----------------------#2019-09-26">https://towardsdatascience.com/validating-your-machine-learning-model-25b4c8643fb7?source=collection_archive---------1-----------------------#2019-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2c0c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="528f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">超越 k 倍交叉验证</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7e6e858aac95cd0b233ac057064da768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TQzNiJdTICLs-2C4"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae lh" href="https://unsplash.com/s/photos/wrong?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">我</span>认为创建你的机器学习模型最被低估的一个方面是<strong class="lk jd">彻底的验证</strong>。使用适当的验证技术有助于您理解您的模型，但最重要的是，估计一个无偏的泛化性能。</p><p id="e599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有适用于所有场景的单一验证方法。了解您是在处理组、时间索引数据，还是在验证过程中泄漏数据是很重要的。</p><blockquote class="mn"><p id="ca14" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">哪种验证方法适合我的用例？</p></blockquote><p id="d74d" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在研究这些方面时，我发现了大量描述评估技术的文章，但是验证技术通常停留在<strong class="lk jd"> k 倍</strong>交叉验证。</p><p id="ee03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将向您展示使用 k-Fold CV 的世界，并进一步深入到<em class="nc">嵌套 CV </em>、<em class="nc"> LOOCV </em>，以及<strong class="lk jd">模型选择</strong>技术。</p><p id="006c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将演示以下验证方法:</p><ul class=""><li id="b3e5" class="nd ne it lk b ll lm lo lp lr nf lv ng lz nh md ni nj nk nl bi translated">训练/测试分割</li><li id="92a3" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">k 倍交叉验证</li><li id="8f0f" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">留一交叉验证</li><li id="448a" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">留一组交叉验证</li><li id="575f" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">嵌套交叉验证</li><li id="39b7" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">时间序列交叉验证</li><li id="d5ae" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">Wilcoxon 符号秩检验</li><li id="67fe" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">麦克内马试验</li><li id="f106" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">5x2CV 配对 t 检验</li><li id="f36c" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">5x2CV 组合 F 测试</li></ul><h1 id="2f40" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">1.拆分您的数据</h1><p id="a1ae" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">所有验证技术的基础是在训练模型时拆分数据。这样做的原因是为了理解如果你的模型面对<strong class="lk jd">之前</strong>没有见过的数据会发生什么。</p><h2 id="0d12" class="oo ns it bd nt op oq dn nx or os dp ob lr ot ou od lv ov ow of lz ox oy oh iz bi translated">训练/测试分割</h2><p id="e91e" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">最基本的方法是训练/测试分离。原理很简单，您只需将数据随机分成大约 70%用于训练模型，30%用于测试模型。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Creating a train/test split with X being your features and y the target</figcaption></figure><p id="f227" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法的好处是，我们可以看到模型如何对以前看不到的数据做出反应。</p><p id="fac5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果我们数据的一个子集只有特定年龄或收入水平的人呢？这通常被称为<strong class="lk jd">采样偏差</strong>:</p><blockquote class="pb pc pd"><p id="08d9" class="li lj nc lk b ll lm kd ln lo lp kg lq pe ls lt lu pf lw lx ly pg ma mb mc md im bi translated">抽样偏倚是由于人口中的非随机样本引起的系统误差，导致人口中的一些成员比其他成员更不可能被包括在内，从而导致有偏倚的样本。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/6609c40e5230aaac12b102ec299ef816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ru7bVLgmt-ccHbJN.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">A great illustration of sampling bias by <a class="ae lh" href="http://www.jondornart.com/" rel="noopener ugc nofollow" target="_blank">http://www.jondornart.com/</a></figcaption></figure><p id="d2a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在讨论有助于解决采样偏差的方法(如 k 倍交叉验证)之前，我想先讨论一下额外的维持集。</p><h2 id="1082" class="oo ns it bd nt op oq dn nx or os dp ob lr ot ou od lv ov ow of lz ox oy oh iz bi translated">维持集</h2><p id="3e3a" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">当优化您的模型的超参数时，如果您使用训练/测试分割进行优化，您可能会<strong class="lk jd">过度拟合</strong>您的模型。</p><p id="952c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为什么？因为模型会搜索符合您所做的特定训练/测试的超参数。</p><p id="4d0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要解决这个问题，您可以创建一个额外的<strong class="lk jd">保持</strong>集。这通常是您在任何处理/验证步骤中没有使用的数据的 10%。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/4eefcf6ea2b282c029c30e90b60a32be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNKH3xAOFYfbyXDl2ScjPA.png"/></div></div></figure><p id="a1cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在训练/测试分割上优化您的模型之后，您可以通过验证维持集来检查您是否没有过度拟合。</p><p id="2057" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">提示</strong>:如果只使用训练/测试分割，那么我建议比较你的训练和测试集的分布。如果它们差别很大，那么你可能会遇到泛化的问题。使用<a class="ae lh" href="https://github.com/PAIR-code/facets" rel="noopener ugc nofollow" target="_blank">刻面</a>轻松比较它们的分布。</p><h1 id="0fad" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">2.k 倍交叉验证(k 倍 CV)</h1><p id="1310" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">为了最小化抽样偏差，我们可以考虑稍微不同的方法验证。如果我们不是进行一次拆分，而是进行多次拆分，并对这些拆分的所有组合进行验证，会怎么样呢？</p><p id="ce55" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是<em class="nc"> k </em>折叠交叉验证的用武之地。它将数据分成<em class="nc"> k </em>个折叠，然后在<em class="nc"> k </em> -1 个折叠上训练数据，并在被遗漏的一个折叠上进行测试。它对所有组合执行此操作，并对每个实例的结果进行平均。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/86f02f9239e0354f0e67166f7d644143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDH0DSCecArPmzQtEBh0yg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">5-Fold Cross-Validation</figcaption></figure><p id="050e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">优点是所有的观察值都用于训练和验证，并且每个观察值只用于一次验证。我们通常选择 i=5 或 k  =10，因为它们在计算复杂性和验证准确性之间找到了一个很好的平衡:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="8696" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">提示</strong>:交叉验证技术得出的每个折叠的分数比人们想象的更有洞察力。它们主要用于简单地提取平均性能。然而，人们也可以查看结果折叠的<strong class="lk jd">方差</strong>或<strong class="lk jd">标准偏差</strong>，因为它将给出关于不同数据输入的模型稳定性的信息。</p><h1 id="00eb" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">3.留一法交叉验证(LOOCV)</h1><p id="8db3" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">k 折叠 CV 的一个变体是留一交叉验证(LOOCV)。LOOCV 使用数据中的每个样本作为单独的测试集，而所有剩余的样本形成训练集。此变体与<em class="nc"> k </em>相同——当<em class="nc"> k = n </em>(观察次数)时折叠 CV。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/55d81434c75df809f6514ccfa7bff0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bs3OMsKOJntR8blRnVE9g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Leave-one-out Cross-Validation</figcaption></figure><p id="b5a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用 sklearn 可以轻松实现:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Leave-one-out Cross-Validation</figcaption></figure><p id="092d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>由于模型需要训练<em class="nc"> n </em>次，LOOCV 的计算成本非常高。只有当数据很小或者你能处理那么多计算时才这样做。</p><h2 id="9d48" class="oo ns it bd nt op oq dn nx or os dp ob lr ot ou od lv ov ow of lz ox oy oh iz bi translated">留一组交叉验证</h2><p id="f1c4" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">k 文件夹 CV 的问题是，你可能希望每个文件夹只包含一个组。例如，假设您有一个包含 20 家公司及其客户的数据集，您希望预测这些公司的成功。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/439720e557f6aefe0981db14077d5909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wC3rtgM0DTec-ePTf0vAAg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Leave-one-group-out Cross-Validation</figcaption></figure><p id="9392" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了保持文件夹的“纯粹性”并且只包含一个公司，您可以为每个公司创建一个文件夹。这样，你就创建了一个 k 倍简历和 LOOCV 的版本，其中你漏掉了一家公司/集团。</p><p id="0598" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，可以使用 sklearn 实现:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Leave-one-group Out Cross-Validation</figcaption></figure><h1 id="3b5c" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">4.嵌套交叉验证</h1><p id="5dc9" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">当您优化模型的超参数，并使用相同的 k-Fold CV 策略来调整模型和评估性能时，您会面临<strong class="lk jd">过度拟合</strong>的风险。您不希望在找到最佳超参数的同一分割上评估模型的准确性。</p><p id="4c33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我们使用嵌套交叉验证策略，允许将超参数调整步骤与误差估计步骤分开。为此，我们嵌套了两个 k 重交叉验证循环:</p><ul class=""><li id="4773" class="nd ne it lk b ll lm lo lp lr nf lv ng lz nh md ni nj nk nl bi translated">超参数调谐的内循环和</li><li id="454f" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">估算精确度的外环。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/b1e0702eb2827802d7cd8e2b1750bc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WAHvOZkLwtwFLwWPVNhow.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Nested Cross-Validation (Outer loop: 5-Fold CV, Inner loop: 2-Fold CV)</figcaption></figure><p id="6487" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的示例显示了一个对内部和外部循环都使用 k-Fold CV 的实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="83bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以自由选择在内部和外部循环中使用的交叉验证方法。例如，如果要按特定的组进行分割，可以对内部循环和外部循环都使用 Leave-one-group-out。</p><h1 id="732a" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">5.时间序列 CV</h1><p id="a457" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">现在，如果你对时间序列数据使用<em class="nc"> k </em> -Fold CV 会发生什么？过度拟合将是一个主要问题，因为你的训练数据可能包含来自未来的信息。重要的是，所有的训练数据都发生在测试数据之前。</p><p id="f174" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">验证时间序列数据的一种方法是使用<em class="nc"> k </em> -fold CV，并确保在每个 fold 中，训练数据发生在测试数据之前。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/9ceac7356533bf7e158f3fa4ce85b2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Ly3DO_CQFQ3L53sVWvwiA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">5-Fold Time Series CV</figcaption></figure><p id="3da0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，sklearn 再次伸出了援手，它有一个内置的时间序列 CV:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="ce3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意</strong>:确保根据您使用的时间索引对数据进行排序，因为您没有为时间序列片段提供时间索引。因此，它将简单地根据记录出现的顺序创建拆分。</p><h1 id="1c58" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">6.比较模型</h1><p id="69c4" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">什么时候你认为一个模型比另一个更好？如果一个模型的准确性比另一个高得不明显，这是选择最佳模型的充分理由吗？</p><p id="3d0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一名数据科学家，我想确保我了解一个模型是否真的比另一个模型更准确。幸运的是，有许多方法将统计学应用于机器学习模型的选择。</p><h2 id="1143" class="oo ns it bd nt op oq dn nx or os dp ob lr ot ou od lv ov ow of lz ox oy oh iz bi translated">Wilcoxon 符号秩检验</h2><p id="599d" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">其中一种方法是 Wilcoxon 符号等级测试，这是配对学生的<em class="nc"> t </em>测试的非参数版本。当样本量很小并且数据不符合正态分布时，可以使用它。</p><p id="aaa7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以应用这个显著性测试来比较两个机器学习模型。使用<em class="nc"> k </em>折叠交叉验证，我们可以为每个模型创建<em class="nc"> k </em>个准确度分数。这将产生两个样本，每个模型一个。</p><p id="35de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可以使用 Wilcoxon 符号秩检验来检验这两个样本是否存在显著差异。如果是的话，那么一个比另一个更准确。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/c46e6d0bd25e10207cf21c409da61ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Am0ZXUChrN-QIJMnW5lJ5w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Wilcoxon signed-rank test procedure for comparing two Machine Learning models</figcaption></figure><p id="4d29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面，您可以看到这个过程的实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Application of the Wilcoxon signed-rank test</figcaption></figure><p id="d0b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果将是一个<em class="nc"> p- </em>值。如果该值低于 0.05，我们可以拒绝模型之间没有显著差异的无效假设。</p><p id="fffc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意</strong>:在模型之间保持相同的折叠是很重要的，以确保样本来自相同的人群。这可以通过在交叉验证过程中简单地设置相同的 random_state 来实现。</p><h2 id="f28e" class="oo ns it bd nt op oq dn nx or os dp ob lr ot ou od lv ov ow of lz ox oy oh iz bi translated">麦克内马试验</h2><p id="385d" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">McNemar 检验用于检查一个模型和另一个模型之间的预测匹配程度。这被称为列联表的同质性。从该表中，我们可以计算出<strong class="lk jd"> x </strong>，该值可用于计算<em class="nc">p</em>-值:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/11f540297a9c422c9153c758a31816da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHx46teJtwg77zasreI-WA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">McNemar’s test for comparing two Machine Learning models</figcaption></figure><p id="431c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，如果<em class="nc">p</em>-值低于 0.05，我们可以拒绝零假设，并看到一个模型明显优于另一个。</p><p id="d17d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用<code class="fe pp pq pr ps b"><a class="ae lh" href="http://rasbt.github.io/mlxtend/installation/" rel="noopener ugc nofollow" target="_blank">mlxtend</a></code>包创建表格并计算相应的<em class="nc">p</em>-值:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">McNemar’s test</figcaption></figure><h2 id="6580" class="oo ns it bd nt op oq dn nx or os dp ob lr ot ou od lv ov ow of lz ox oy oh iz bi translated">5x2CV 成对<em class="pt">t</em>-测试</h2><p id="9de7" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">5x2CV 配对<em class="nc">t</em>-测试由于其强大的统计学基础，是一种常用于比较机器学习模型的方法。</p><p id="0496" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该方法工作如下。假设我们有两个分类器，A 和 b。我们随机地将数据分成 50%的训练和 50%的测试。然后，我们根据训练数据训练每个模型，并计算来自测试集的模型之间的精确度差异，称为<strong class="lk jd"><em class="nc"/></strong>。然后，在<strong class="lk jd"> <em class="nc"> DiffB </em> </strong>中反转训练和测试分割并再次计算差异。</p><p id="7c72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这重复五次，之后计算差异的平均方差(<strong class="lk jd"> <em class="nc"> S </em> </strong>)。然后，用于计算<em class="nc">t</em>-统计量:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/9bffed260163467adf7d60ffb5bdc649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkvdVW1FMAQHcGzGUaSoiw.png"/></div></div></figure><p id="9159" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中<strong class="lk jd"> <em class="nc"> DiffA₁ </em> </strong>为第一次迭代的均值方差。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/c42f41dcab183a43ca4dd64e23e19781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rC0TSvoaxn7l7oxZ4UdLjg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">5x2CV paired t-test procedure for comparing two Machine Learning models</figcaption></figure><p id="d386" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，我们可以使用<code class="fe pp pq pr ps b"><a class="ae lh" href="http://rasbt.github.io/mlxtend/installation/" rel="noopener ugc nofollow" target="_blank">mlxtend</a></code>包来计算相应的<em class="nc">p</em>-值:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="22cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注</strong>:你可以使用组合的 5x2CV F 检验来代替，它被证明是稍微更稳健的(<a class="ae lh" href="http://rasbt.github.io/mlxtend/user_guide/evaluate/combined_ftest_5x2cv/" rel="noopener ugc nofollow" target="_blank"> Alpaydin，1999 </a>)。该方法在<code class="fe pp pq pr ps b">mlxtend</code>中实现为<br/> <code class="fe pp pq pr ps b">from mlxtend.evluate import combined_ftest_5x2cv</code>。</p><h1 id="f436" class="nr ns it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">结论</h1><p id="c7c6" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">验证可能是一个棘手的问题，因为它需要对数据有深刻的理解，以便选择正确的程序。希望这能帮助你对经常用于验证的方法有所了解。</p><p id="6c58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有的<strong class="lk jd">代码</strong>都可以在这里找到:</p><div class="pw px gp gr py pz"><a href="https://github.com/MaartenGr/validation" rel="noopener  ugc nofollow" target="_blank"><div class="qa ab fo"><div class="qb ab qc cl cj qd"><h2 class="bd jd gy z fp qe fr fs qf fu fw jc bi translated">MaartenGr/验证</h2><div class="qg l"><h3 class="bd b gy z fp qe fr fs qf fu fw dk translated">这个报告包含了验证博客的代码。</h3></div><div class="qh l"><p class="bd b dl z fp qe fr fs qf fu fw dk translated">github.com</p></div></div><div class="qi l"><div class="qj l qk ql qm qi qn lb pz"/></div></div></a></div></div><div class="ab cl qo qp hx qq" role="separator"><span class="qr bw bk qs qt qu"/><span class="qr bw bk qs qt qu"/><span class="qr bw bk qs qt"/></div><div class="im in io ip iq"><h1 id="289f" class="nr ns it bd nt nu qv nw nx ny qw oa ob ki qx kj od kl qy km of ko qz kp oh oi bi translated">感谢您的阅读！</h1><p id="c0c6" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">如果你像我一样，对人工智能、数据科学或心理学充满热情，请随时在<a class="ae lh" href="https://www.linkedin.com/in/mgrootendorst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上添加我，或者在<a class="ae lh" href="https://twitter.com/MaartenGr" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>