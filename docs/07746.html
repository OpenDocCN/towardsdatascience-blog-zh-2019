<html>
<head>
<title>Build a Text Generator Web App in under 50 Lines of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用不到 50 行 Python 代码构建一个文本生成器 Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-text-generator-web-app-in-under-50-lines-of-python-9b63d47edabb?source=collection_archive---------9-----------------------#2019-10-27">https://towardsdatascience.com/build-a-text-generator-web-app-in-under-50-lines-of-python-9b63d47edabb?source=collection_archive---------9-----------------------#2019-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f32d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习构建一个自动完成任何输入文本的 web 应用程序</h2></div><blockquote class="ki kj kk"><p id="d04d" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们将使用<a class="ae li" href="https://openai.com/blog/better-language-models/" rel="noopener ugc nofollow" target="_blank"> OpenAI 的 GPT-2 </a>作为模型，使用<a class="ae li" href="https://panel.pyviz.org/index.html" rel="noopener ugc nofollow" target="_blank">面板</a>作为网络仪表板框架。本指南将分为两部分。在第一部分中，我们将加载我们的模型并编写一个预测函数。第二，我们将构建 web 应用程序。</p></blockquote><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/946743422b1b1415a600bac78d61eeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Pg5qfCgDY28l1Jr-zlcaUQ.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Example text generation application. We will be building a simpler variation of this web app.</figcaption></figure><h2 id="0d27" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">你需要什么</h2><p id="debc" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">本教程假设你已经安装了<a class="ae li" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Python 3.7+ </a>，并且对<a class="ae li" href="https://openai.com/blog/better-language-models/" rel="noopener ugc nofollow" target="_blank">语言模型</a>有所了解。虽然相关步骤可以在 Jupyter 之外完成，但是强烈推荐使用<a class="ae li" href="https://jupyter.org/install" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本</a>。</p><p id="d57c" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">我们将使用<a class="ae li" href="https://pytorch.org/get-started/locally/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko iu"> PyTorch </strong> </a>作为我们深度学习库的选择。在 PyTorch 内，我们将使用<a class="ae li" href="https://huggingface.co/transformers/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko iu">变形金刚</strong> </a>库导入预先训练好的 OpenGPT-2 模型。您可以通过在 bash 中单独输入以下命令来安装这些库:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="fa2d" class="lv lw it mx b gy nb nc l nd ne">pip install torch</span><span id="90dd" class="lv lw it mx b gy nf nc l nd ne">pip install transformers</span></pre><p id="b770" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">对于我们的 web 应用程序，我们将利用<a class="ae li" href="https://panel.pyviz.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko iu">面板</strong> </a>，这是一个很好的工具，可以从 jupyter 笔记本或常规 python 脚本轻松创建可服务的仪表板。使用以下命令安装 panel:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="e593" class="lv lw it mx b gy nb nc l nd ne">pip install panel</span></pre><h1 id="dc2c" class="ng lw it bd lx nh ni nj ma nk nl nm md jz nn ka mh kc no kd ml kf np kg mp nq bi translated"><strong class="ak">第一部分:建立模型</strong></h1><p id="79cd" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">OpenAI 的 GPT 是一种变形金刚模型，它产生类似人类文本的能力引起了很多关注。如果你以前没有尝试过，在读完这篇文章后，你可能会有同样的想法。</p><h2 id="2201" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">加载模型</h2><p id="1a70" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">首先，我们需要导入所需的包。</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="1a62" class="lv lw it mx b gy nb nc l nd ne">import numpy as np<br/>import torch<br/>import torch.nn.functional as F<br/>from transformers import GPT2Tokenizer, GPT2LMHeadModel<br/>from random import choice</span></pre><p id="f539" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">接下来，我们将加载 OpenGPT2 标记器和语言模型:(如果第一次运行，可能需要几分钟来下载预训练的模型)</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="a10e" class="lv lw it mx b gy nb nc l nd ne">tok = GPT2Tokenizer.from_pretrained("gpt2")<br/>model = GPT2LMHeadModel.from_pretrained("gpt2")</span></pre><h2 id="1f34" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">预测功能</h2><p id="663f" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">在这个阶段，大部分工作已经完成。由于我们的模型是预先训练好的，所以我们不需要训练它，也不需要做任何修改。我们只需要编写一个函数，它可以向模型输入文本并生成预测。</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="9fe9" class="lv lw it mx b gy nb nc l nd ne">def get_pred(text, model, tok, p=0.7):<br/>    input_ids = torch.tensor(tok.encode(text)).unsqueeze(0)<br/>    logits = model(input_ids)[0][:, -1]<br/>    probs = F.softmax(logits, dim=-1).squeeze()<br/>    idxs = torch.argsort(probs, descending=True)<br/>    res, cumsum = [], 0.<br/>    for idx in idxs:<br/>        res.append(idx)<br/>        cumsum += probs[idx]<br/>        if cumsum &gt; p:<br/>            pred_idx = idxs.new_tensor([choice(res)])<br/>            break<br/>    pred = tok.convert_ids_to_tokens(int(pred_idx))<br/>    return tok.convert_tokens_to_string(pred)</span></pre><p id="1f27" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">这个函数中发生了很多事情。所以，我们来分解一下。首先，我们对来自<em class="kn"> input_ids </em>的输入文本进行标记和编码。然后，我们要求我们的模型为下一个单词/单词生成一个<em class="kn"> logits </em>向量。在应用 softmax 并按降序排列这些概率后，我们有了一个向量，<em class="kn"> idxs </em>，它按概率顺序列出了我们的 vocab 中每个令牌的索引。</p><p id="0f61" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">在这个阶段，我们可以只选择概率最高的令牌。然而，我们希望能够混合我们的结果，以便相同的输入文本可以生成多种文本。为此，我们将添加一个随机元素，从最有可能的下一个令牌列表中选择一个随机令牌。这样，我们就不会每次都选择相同的预测标记。为此，我们利用<a class="ae li" href="https://youtu.be/3oEb_fFmPnY?list=PLtmWHNX-gukKocXQOkQjuVxglSDYWsSh9&amp;t=1084" rel="noopener ugc nofollow" target="_blank"> <strong class="ko iu">核(Top- <em class="kn"> p </em>)采样</strong> </a>。</p><p id="a813" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">我们通过遍历每个概率来执行这个操作，直到我们遍历的所有概率之和大于<em class="kn"> p，</em>0 到 1 之间的任意数。在超过<em class="kn"> p </em>之前迭代的所有令牌都存储在列表<em class="kn"> res </em>中。一旦超过了<em class="kn"> p </em>，我们就从这个列表中随机选择一个令牌。请记住，我们正在循环的概率列表包含按概率排序的索引。请注意，如果<em class="kn"> p </em>更高，我们的列表中将包含更多的令牌。反之亦然。因此，如果每次想要相同的结果，可以将<em class="kn"> p </em>设置为 0。</p><p id="35d2" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">现在，让我们测试几次 pred 函数:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/77cc41c82f6a77567f1c0cd31f5415a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qKv5HJVnvMmu46dfH0NA_g.gif"/></div></div></figure><p id="0b4a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">每一次，都有不同的结果，这正是我们所期待的。我们的预测函数现在已经准备好了。让我们构建我们的 web 应用程序吧！</p><h1 id="c056" class="ng lw it bd lx nh ni nj ma nk nl nm md jz nn ka mh kc no kd ml kf np kg mp nq bi translated">第 2 部分:构建 Web 应用程序</h1><h2 id="5e7a" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">面板概述</h2><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/53b2efb7d2886289d2ea5a5be245c097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*-RrwrJXm8EXZA0IK.png"/></div></figure><p id="d163" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">如果您不熟悉<a class="ae li" href="https://panel.pyviz.org" rel="noopener ugc nofollow" target="_blank">面板</a>，它可以简化创建 web 仪表盘和应用程序的过程。乍一看，您需要知道它有三个主要组件:</p><ul class=""><li id="540b" class="nx ny it ko b kp kq ks kt me nz mi oa mm ob lh oc od oe of bi translated"><strong class="ko iu">面板</strong>:可以包含一个或多个窗格(对象)的容器，如文本、图像、图表、小部件等。(它们也可以包含其他面板)</li><li id="85e1" class="nx ny it ko b kp og ks oh me oi mi oj mm ok lh oc od oe of bi translated"><strong class="ko iu">窗格</strong>:任何单个对象，如文本、图像、数据帧等。</li><li id="2707" class="nx ny it ko b kp og ks oh me oi mi oj mm ok lh oc od oe of bi translated"><strong class="ko iu"> Widgets </strong>:用户可调整的项目，如文本输入、滑块、按钮、复选框，可以改变窗格的行为</li></ul><p id="e127" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">为了我们的目的，你需要知道的下一件也是最后一件事是，我们有多种方法来定义不同的窗格和小部件如何相互交互。这些被称为“回调”例如，如果某个按钮被按下，其他窗格应该如何更新？稍后我们将定义一个回调函数来完成这个任务。</p><h2 id="28cc" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">高级应用概述</h2><p id="5a07" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">我们的文本生成器应用程序将有一个输入用户输入他们想要的文本。接下来，用户应该能够通过按下按钮来生成新的令牌。此后，将使用我们在第 1 部分中定义的函数中的预测标记生成新文本。最后，用户应该能够在已经预测的标记之上继续生成新的文本。</p><h2 id="1628" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">履行</h2><p id="a1b4" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">让我们首先导入面板并创建文本输入小部件:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="0490" class="lv lw it mx b gy nb nc l nd ne">import panel as pn<br/>pn.extension() # loading panel's extension for jupyter compatibility </span><span id="725b" class="lv lw it mx b gy nf nc l nd ne">text_input = pn.widgets.TextInput()</span></pre><p id="fee6" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">现在，如果我们在 jupyter 中执行<em class="kn"> text_input </em>，我们会得到以下结果:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/957edbf40c8eb519f80668bddd0b5a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*lbES7SsDfpLdMIZYVAayiA.gif"/></div></figure><p id="254a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">接下来，我们需要一个面板，它将在我们生成越来越多的令牌时存储整个文本:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="fce3" class="lv lw it mx b gy nb nc l nd ne">generated_text = pn.pane.Markdown(object=text_input.value)</span></pre><p id="466a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">注意，我们将文本对象设置为<em class="kn"> text_input </em>的值。我们希望<em class="kn"> generated_text </em>的值与<em class="kn"> text_input </em>的值相同，因为我们将在<em class="kn"> generated_text </em>的顶部预测新文本。随着更多的令牌被添加到我们的序列中，我们将继续预测<em class="kn"> generated_text </em>，直到用户更改<em class="kn"> text_input </em>。在这种情况下，该过程将重新开始。</p><p id="1566" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">然而，我们还没有完全完成。虽然<em class="kn"> generated_text </em>在初始化时会采用<em class="kn"> text_input </em>的值，但如果<em class="kn"> text_input </em>的值发生变化，它不会自行更新。为此，我们需要将这两个对象链接在一起，如下所示:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="7497" class="lv lw it mx b gy nb nc l nd ne">text_input.link(generated_text, value='object')</span></pre><p id="2024" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">这里，我们在<em class="kn"> text_input </em>到<em class="kn"> generated_text </em>之间形成了一个单向链接。因此，每当<em class="kn"> text_input </em>的值改变时，<em class="kn"> generated_text </em>的值也会改变为新值。参见:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fa1912c7f19c71d34b7549b80911fb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/1*GZknvh6JJSe1nA7_2EN9wQ.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk"><em class="on">observing linked behavior between text_input and generated_text in a panel. Note: pn.Row as a component is a panel i.e. container of panes and widgets</em></figcaption></figure><p id="5be7" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">现在我们有了两个文本对象，让我们创建按钮小部件:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="7540" class="lv lw it mx b gy nb nc l nd ne">button = pn.widgets.Button(name="Generate",button_type="primary")</span></pre><p id="3973" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">很好，现在我们有了一个按钮，我们只需要把它和我们想要的行为联系起来。为此，我们将编写一个回调函数，它将在每次单击按钮时运行:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="30af" class="lv lw it mx b gy nb nc l nd ne">def click_cb(event):<br/>    pred = get_pred(generated_text.object, model, tok)<br/>    generated_text.object += pred</span></pre><p id="1d51" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">这里发生了两件事。首先，我们将<em class="kn"> generated_text </em>作为输入传递给我们之前编写的预测函数，该函数给出了一个新的令牌。其次，将此令牌添加到<em class="kn"> generated_text </em>中。每当有新的按钮点击时，重复这个过程。</p><p id="f712" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">说到这里，我们还是要把按钮点击和回调函数捆绑起来。我们可以通过以下方式做到这一点:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="0565" class="lv lw it mx b gy nb nc l nd ne">button.on_click(click_cb)</span></pre><p id="454f" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">我们现在已经创建了所有的小部件、窗格和功能。我们只需要把这些东西放在一个面板上，瞧:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="dfdd" class="lv lw it mx b gy nb nc l nd ne">app = pn.Column(text_input, button, generated_text); app</span></pre><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a55dcabe51c73fc5684112c27d522eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*qGiRMtAxCCYc_ETkPu92CA.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Note: pn.Column, similar to pn.Row is another type of panel i.e. container of widgets, panes and even other panels.</figcaption></figure><p id="18f5" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">让我们添加一个标题和一个简短的描述，我们通过了！</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="0d22" class="lv lw it mx b gy nb nc l nd ne">title = pn.pane.Markdown("# **Text Generator**")<br/>desc = pn.pane.HTML("&lt;marquee scrollamount='10'&gt;&lt;b&gt;Welcome to the text generator! In order to get started, simply enter some starting input text below, click generate a few times and watch it go!&lt;/b&gt;&lt;/marquee&gt;")</span><span id="ee0e" class="lv lw it mx b gy nf nc l nd ne">final_app = pn.Column(title, desc ,app)</span></pre><h2 id="7b6e" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">为应用服务</h2><p id="989a" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku me mt kx ky mi mu lb lc mm mv lf lg lh im bi translated">Panel 使服务应用程序变得非常容易。有两种方法可以用来做这件事。第一个是”。show()"命令。这通常用于调试，用法如下。这将启动一个新窗口，我们的<em class="kn"> final_app </em>面板作为 web 应用程序运行。</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="b96a" class="lv lw it mx b gy nb nc l nd ne">final_app.show()</span></pre><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e865e32cc4c8ad986efabe7dd9d8f1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*YClietKupvUKsEba8x4N3w.gif"/></div></figure><p id="cc84" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">为了将其投入生产环境，您需要使用“.servable()"方法。但是，如果您以类似于 show 方法的方式运行它，那么在您当前的笔记本中不会发生任何不同。相反，您必须像这样通过计算机的 bash 来服务笔记本:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="25d3" class="lv lw it mx b gy nb nc l nd ne">panel serve --show text_generation_app.ipynb</span></pre><p id="227b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">这将在本地端口上启动您的应用程序，只要您在笔记本中有以下代码:</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="f1ba" class="lv lw it mx b gy nb nc l nd ne">final_app.servable()</span></pre><p id="78d2" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku me kw kx ky mi la lb lc mm le lf lg lh im bi translated">完成了。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><blockquote class="ki kj kk"><p id="6195" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">到目前为止，您已经有能力构建自己的文本生成应用程序了。您可以通过添加更多面板组件来进一步构建它。你甚至可以<a class="ae li" href="https://panel.pyviz.org/user_guide/Deploy_and_Export.html#Embedding" rel="noopener ugc nofollow" target="_blank">将这个应用</a>嵌入到你的其他项目中。一如既往，你可以在<a class="ae li" href="https://github.com/devkosal/gpt-panel-app" rel="noopener ugc nofollow" target="_blank"> <strong class="ko iu"> github </strong> </a>上找到我的代码库。注:题图中的 app 是我在教程笔记本中找到的高级变体:<a class="ae li" href="https://github.com/devkosal/gpt-panel-app/blob/master/text_generation_app.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="ko iu">text _ generation _ app . ipynb</strong></a>。</p></blockquote><div class="ox oy gp gr oz pa"><a href="https://github.com/devkosal/gpt-panel-app" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">devkosal/gpt-panel-app</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">github.com</p></div></div></div></a></div><h2 id="fa54" class="lv lw it bd lx ly lz dn ma mb mc dp md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">额外资源</h2><ul class=""><li id="4acf" class="nx ny it ko b kp mr ks ms me pj mi pk mm pl lh oc od oe of bi translated"><a class="ae li" rel="noopener" target="_blank" href="/openai-gpt-2-understanding-language-generation-through-visualization-8252f683b2f8"> OpenAI GPT-2:通过可视化理解语言生成</a></li><li id="4d46" class="nx ny it ko b kp og ks oh me oi mi oj mm ok lh oc od oe of bi translated"><a class="ae li" href="https://panel.pyviz.org/getting_started/index.html" rel="noopener ugc nofollow" target="_blank">开始使用面板</a></li><li id="b7a4" class="nx ny it ko b kp og ks oh me oi mi oj mm ok lh oc od oe of bi translated"><a class="ae li" href="https://www.youtube.com/watch?v=7deGS4IPAQ0" rel="noopener ugc nofollow" target="_blank">轻松可视化任何数据，从笔记本到仪表盘| Scipy 2019 教程| James Bednar(视频:第一个小时是关于面板)</a></li><li id="ee86" class="nx ny it ko b kp og ks oh me oi mi oj mm ok lh oc od oe of bi translated"><a class="ae li" href="https://panel.pyviz.org/user_guide/Server_Deployment.html" rel="noopener ugc nofollow" target="_blank">在服务器上部署 Panel 应用</a></li></ul></div></div>    
</body>
</html>