<html>
<head>
<title>Sarcasm Detection using Word Embeddings in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 中基于单词嵌入的讽刺检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sarcasm-detection-using-word-embeddings-in-android-999a791d676a?source=collection_archive---------20-----------------------#2019-06-13">https://towardsdatascience.com/sarcasm-detection-using-word-embeddings-in-android-999a791d676a?source=collection_archive---------20-----------------------#2019-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7b1a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">📱<a class="ae ep" href="https://equipintelligence.medium.com/list/stories-on-mobile-ml-with-kotlin-and-tf-lite-3ebee822c87b" rel="noopener">移动机器学习</a></h2><div class=""/><div class=""><h2 id="0fa6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在 Android 中使用单词嵌入的惊人力量。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dd9136e774b4803f43fc33b14e3db268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ny_bT2SgGpt6jVS-"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3933" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">喜欢在<a class="ae lh" href="https://www.tensorflow.org/guide/keras" rel="noopener ugc nofollow" target="_blank"> TensorFlow Keras </a>中使用<a class="ae lh" href="https://keras.io/examples/pretrained_word_embeddings/" rel="noopener ugc nofollow" target="_blank">预训练嵌入</a>？他们只是把验证精度提高到 80 和 90。无论是<a class="ae lh" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank"> GloVe </a>还是<a class="ae lh" href="https://www.tensorflow.org/tutorials/representation/word2vec" rel="noopener ugc nofollow" target="_blank"> Word2Vec </a>，单词嵌入在<a class="ae lh" href="https://machinelearningmastery.com/natural-language-processing/" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP ) </a>中都显示出了巨大的成效。我们如何在您的 Android 应用中利用这种强大的嵌入功能？此外，没有使用任何第三方库和 API，只有<a class="ae lh" href="https://www.tensorflow.org/lite" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite </a>和 Android SDK。兴奋吧？我们走吧！</p><p id="6063" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python 项目的源代码可从→<a class="ae lh" href="https://github.com/shubham0204/Sarcasm_Detection_NLP_TensorFlow" rel="noopener ugc nofollow" target="_blank">https://github . com/Shu bham 0204/sarcash _ Detection _ NLP _ tensor flow</a>获得</p><p id="9bad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Android 应用程序的代码→<a class="ae lh" href="https://github.com/shubham0204/Sarcaso_for_Android" rel="noopener ugc nofollow" target="_blank">https://github.com/shubham0204/Sarcaso_for_Android</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="689d" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">一目了然。</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="my mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">See the code!</figcaption></figure><p id="6f15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将创建一个应用程序，检测 Android 应用程序中讽刺的推文/文本。</p><blockquote class="mz"><p id="409b" class="na nb it bd nc nd ne nf ng nh ni md dk translated">我们的主要挑战是将<code class="fe nj nk nl nm b">tf.keras.layers.Embedding</code>层导出到包含单词嵌入对的 JSON 文件。</p></blockquote><p id="7d1c" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">JSON 文件将在我们的 Android 应用程序中被解析。它将包含成对的<em class="ns">单词嵌入</em>，其中<em class="ns">嵌入</em>将是 50 个浮点数的数组。</p><h2 id="109e" class="nt mh it bd mi nu nv dn mm nw nx dp mq lr ny nz ms lv oa ob mu lz oc od mw iz bi translated">什么是单词嵌入？</h2><p id="3342" class="pw-post-body-paragraph li lj it lk b ll oe kd ln lo of kg lq lr og lt lu lv oh lx ly lz oi mb mc md im bi translated"><a class="ae lh" href="https://machinelearningmastery.com/what-are-word-embeddings/" rel="noopener ugc nofollow" target="_blank">单词嵌入</a>是属于某个语料库的单词的密集表示。比如，</p><pre class="ks kt ku kv gt oj nm ok ol aw om bi"><span id="3cb8" class="nt mh it nm b gy on oo l op oq">[ [ 'king' ] , [ 'queen' ] ] = [ [ 0.1 , 0.78 ] , [ 0.456 , 0.23 ] ]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/d41c0b9feeb92a806acf372649199079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_FJbKJuRS7-Iu7p720z7g.jpeg"/></div></div></figure><p id="2c9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当投影到 2 或 3 维空间时，嵌入向量在方向或接近度上表现出某种相似性。因此，在我们的例子中，一个单词的上下文(来自语料库)被打包在一个 50 维的向量中。</p><p id="5bf1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ns">它们建立文档之间的关系。被分类为同一类别的文档在它们的嵌入中具有相似性，这由神经网络学习。</em></p><h2 id="12b7" class="nt mh it bd mi nu nv dn mm nw nx dp mq lr ny nz ms lv oa ob mu lz oc od mw iz bi translated">在张量流和 Keras 的背景下。</h2><p id="8b52" class="pw-post-body-paragraph li lj it lk b ll oe kd ln lo of kg lq lr og lt lu lv oh lx ly lz oi mb mc md im bi translated">在 Keras ( TensorFlow)中，我们在<code class="fe nj nk nl nm b">tf.keras.layers</code>模块中有一个<code class="fe nj nk nl nm b"><a class="ae lh" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Embedding" rel="noopener ugc nofollow" target="_blank">Embedding</a></code>层。</p><pre class="ks kt ku kv gt oj nm ok ol aw om bi"><span id="19d3" class="nt mh it nm b gy on oo l op oq">embedding = tf.keras.layers.Embedding( input_dim , output_dim , input_length )</span></pre><p id="a0b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nj nk nl nm b">input_dim</code>:一个值为<code class="fe nj nk nl nm b">max_index_in_vocab + 1</code>的<code class="fe nj nk nl nm b">int</code>对象。<code class="fe nj nk nl nm b">max_index_in_vocab</code>是分配给词汇表中一个单词的最大索引。</p><p id="aa9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nj nk nl nm b">output_dim</code>:嵌入的维度。每个记号/单词将被转换成一个<code class="fe nj nk nl nm b">output_dim</code>维嵌入向量。</p><p id="13c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nj nk nl nm b">input_length</code>:输入序列的长度。</p><h1 id="0885" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">Keras 模型入门。</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="os mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Keras with TensorFlow is just…</figcaption></figure><p id="88d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我建议看一下下面的文章，以便更好地理解。有些步骤已经在里面详细说明了。</p><div class="ot ou gp gr ov ow"><a href="https://medium.com/dataseries/spam-classification-in-android-with-tensorflow-lite-cde417e81260" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">基于 TensorFlow 的 Android 文本分类</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">事实证明，机器学习在一些使用案例中非常出色，例如垃圾邮件分类，我们将在…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lb ow"/></div></div></a></div><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 1.1</figcaption></figure><p id="17f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们的 Keras 模型。我们将使用<code class="fe nj nk nl nm b">Conv1D</code>层而不是<code class="fe nj nk nl nm b">LSTM</code>层(尽管<code class="fe nj nk nl nm b">LSTM</code>层提供了更高的精度)，因为 TensorFlow Lite 不支持该 op(操作)。见<a class="ae lh" href="https://www.tensorflow.org/lite/guide/ops_compatibility" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 1.2</figcaption></figure><p id="45c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将模型转换为带有<code class="fe nj nk nl nm b">TFLiteConverter</code>和<code class="fe nj nk nl nm b">post_training_quantize=</code>标志的<code class="fe nj nk nl nm b">.tflite</code>模型，以减小模型的大小。见<a class="ae lh" href="https://www.tensorflow.org/lite/convert" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="0f8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ns">注意:</em> </strong> <em class="ns">我们需要先从模型中去掉</em> <code class="fe nj nk nl nm b"><em class="ns">Embedding</em></code> <em class="ns">图层。TF Lite 中也不支持</em> <code class="fe nj nk nl nm b"><em class="ns">Embedding</em></code> <em class="ns">图层。我们将在推理时直接向模型提供 Android 中的嵌入。</em></p><h2 id="40b2" class="nt mh it bd mi nu nv dn mm nw nx dp mq lr ny nz ms lv oa ob mu lz oc od mw iz bi translated">将嵌入层权重导出到 JSON 文件。</h2><p id="97e9" class="pw-post-body-paragraph li lj it lk b ll oe kd ln lo of kg lq lr og lt lu lv oh lx ly lz oi mb mc md im bi translated">下面是代码中发生的事情的摘要:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 1.3</figcaption></figure><ol class=""><li id="b6e1" class="pl pm it lk b ll lm lo lp lr pn lv po lz pp md pq pr ps pt bi translated">从文件中加载模型。使用<code class="fe nj nk nl nm b">model.layers[0].get_weights()[0]</code>获得第一层的权重，在我们的例子中是<code class="fe nj nk nl nm b">Embedding</code>层。</li><li id="2643" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md pq pr ps pt bi translated">加载分词器的<code class="fe nj nk nl nm b">word_index</code>。<code class="fe nj nk nl nm b">word_index</code>是一个<code class="fe nj nk nl nm b">dict</code>，它将单词映射到它们的索引。我们对这个<code class="fe nj nk nl nm b">dict</code>进行转换，以便它将索引映射到单词(为了方便)。</li><li id="2d24" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md pq pr ps pt bi translated">使用<code class="fe nj nk nl nm b">embedding_matrix</code>和修改过的<code class="fe nj nk nl nm b">word_index</code>，我们创建一个新的<code class="fe nj nk nl nm b">dict</code>，命名为<code class="fe nj nk nl nm b">embedding_dict</code>，它将单词映射到嵌入。这是一个简单的 for 循环。</li><li id="bb29" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md pq pr ps pt bi translated">使用 Python 的<code class="fe nj nk nl nm b"><a class="ae lh" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank">json</a></code>模块将<code class="fe nj nk nl nm b">embedding_dict</code>转换成 JSON 文件。</li></ol><p id="d56e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码片段中也标记了这些步骤。</p><p id="96f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nj nk nl nm b"><em class="ns">tokenizer.pkl</em></code> <em class="ns">是</em> <code class="fe nj nk nl nm b"><a class="ae lh" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/text/Tokenizer?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="ns">tf.keras.preprocessing.text.Tokenizer</em></a></code> <em class="ns">的腌制版。最终，我们需要分词器的</em> <code class="fe nj nk nl nm b"><em class="ns">word_index</em></code> <em class="ns">。还有，</em> <strong class="lk jd"> <em class="ns">注:</em> </strong> <em class="ns">在提供的源代码中，我自己创建了一个自定义的分词器，同样包含</em> <code class="fe nj nk nl nm b"><em class="ns">word_index</em></code> <em class="ns">。看这里。</em></p><h2 id="59fc" class="nt mh it bd mi nu nv dn mm nw nx dp mq lr ny nz ms lv oa ob mu lz oc od mw iz bi translated">源代码中的代码片段引用:</h2><ul class=""><li id="4cbe" class="pl pm it lk b ll oe lo of lr pz lv qa lz qb md qc pr ps pt bi translated"><a class="ae lh" href="https://github.com/shubham0204/Sarcasm_Detection_NLP_TensorFlow/blob/master/Model.py" rel="noopener ugc nofollow" target="_blank">片段:1.1 </a></li><li id="1a9d" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md qc pr ps pt bi translated"><a class="ae lh" href="https://github.com/shubham0204/Sarcasm_Detection_NLP_TensorFlow/blob/master/EmbeddingExporter.py" rel="noopener ugc nofollow" target="_blank">片段:1.2 和片段:1.3 </a></li></ul><h1 id="ce83" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">现在在安卓。</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qd mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">I just you can try this in iOS too!</figcaption></figure><p id="0baa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要读取使用<code class="fe nj nk nl nm b"><a class="ae lh" href="https://developer.android.com/reference/org/json/JSONObject?hl=en" rel="noopener ugc nofollow" target="_blank">JSONObject</a></code>在 Python 中创建的嵌入的 JSON 文件。对于嵌入了 50 维的大约 18000 个单词的词汇表，JSON 文件的大小是 17–19mb。这就足够挂 Android 里的 UI 线程了。我们需要解析一个<code class="fe nj nk nl nm b"><a class="ae lh" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank">AsyncTask</a></code>中的文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 2.1</figcaption></figure><p id="aea6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嵌入已经被解析为一个<code class="fe nj nk nl nm b">DoubleArray</code>，并且该单词已经被传递给一个<code class="fe nj nk nl nm b">String</code>。<code class="fe nj nk nl nm b">VocabCallback</code>用于在词汇表或 JSON 文件加载后调用方法。</p><p id="366d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">原始文本的填充和标记也有所改变。这些是填充和标记原始字符串文本的方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 2.2</figcaption></figure><p id="ddce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，<code class="fe nj nk nl nm b">embeddingDim</code>是嵌入的维数，在我们的例子中是 50。<code class="fe nj nk nl nm b">embeddingData</code>是<code class="fe nj nk nl nm b">Hashmap</code>，我们通过解析 snippet-2.1 中的 JSON 文件创建的。这里的可以看到<code class="fe nj nk nl nm b">Tokenizer.getTokens()</code>方法<a class="ae lh" href="https://github.com/shubham0204/Sarcaso_for_Android/blob/master/app/src/main/java/com/ml/quaterion/sarcaso/Tokenizer.kt" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="6c25" class="nt mh it bd mi nu nv dn mm nw nx dp mq lr ny nz ms lv oa ob mu lz oc od mw iz bi translated">加载 TFLite 模型和词汇表。</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 2.3</figcaption></figure><p id="6ee2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nj nk nl nm b">loadModelFile()</code>返回存储在应用程序的 assets 文件夹中的 TFLite 模型的<code class="fe nj nk nl nm b">MappedByteBuffer</code>。</p><p id="9b1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于 TensorFlow Lite 不支持<code class="fe nj nk nl nm b">Double</code>数据类型，<code class="fe nj nk nl nm b">classifySequence()</code>做出最终推断，并将<code class="fe nj nk nl nm b">Array&lt;DoubleArray&gt;</code>转换为<code class="fe nj nk nl nm b">Array&lt;FloatArray&gt;</code>。</p><p id="440c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们创建了一个回调函数，当词汇表加载到后台线程中时，这个回调函数就会被触发。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 2.4</figcaption></figure><p id="c1bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当点击“分类”按钮时，我们执行最后的推断。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Snippet: 2.5</figcaption></figure><h2 id="12c3" class="nt mh it bd mi nu nv dn mm nw nx dp mq lr ny nz ms lv oa ob mu lz oc od mw iz bi translated">源代码中的代码段引用。</h2><ul class=""><li id="7c00" class="pl pm it lk b ll oe lo of lr pz lv qa lz qb md qc pr ps pt bi translated"><a class="ae lh" href="https://github.com/shubham0204/Sarcaso_for_Android/blob/master/app/src/main/java/com/ml/quaterion/sarcaso/EmbeddingBuilder.kt" rel="noopener ugc nofollow" target="_blank">片段:2.1 和 2.2 </a></li><li id="444d" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md qc pr ps pt bi translated"><a class="ae lh" href="https://github.com/shubham0204/Sarcaso_for_Android/blob/master/app/src/main/java/com/ml/quaterion/sarcaso/MainActivity.kt" rel="noopener ugc nofollow" target="_blank">片段:2.3、2.4、2.5 </a></li></ul><h1 id="42cb" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">对 TensorFlow 和 Android 有帮助的资源。</h1><p id="c88e" class="pw-post-body-paragraph li lj it lk b ll oe kd ln lo of kg lq lr og lt lu lv oh lx ly lz oi mb mc md im bi translated">我知道上面的东西对初学者来说可能是惊人的。参考这些资料。</p><ul class=""><li id="623b" class="pl pm it lk b ll lm lo lp lr pn lv po lz pp md qc pr ps pt bi translated"><a class="ae lh" href="https://machinelearningmastery.com/use-word-embedding-layers-deep-learning-keras/" rel="noopener ugc nofollow" target="_blank">如何用 Keras 使用单词嵌入层进行深度学习</a></li><li id="4cfc" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md qc pr ps pt bi translated"><a class="ae lh" href="https://blog.keras.io/using-pre-trained-word-embeddings-in-a-keras-model.html" rel="noopener ugc nofollow" target="_blank">在 Keras 模型中使用预训练的单词嵌入。</a></li><li id="6514" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md qc pr ps pt bi translated"><a class="ae lh" href="https://stackoverflow.com/questions/2591098/how-to-parse-json-in-java" rel="noopener ugc nofollow" target="_blank">如何在 Java 中解析 JSON</a></li><li id="20a6" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md qc pr ps pt bi translated"><a class="ae lh" href="https://stackoverflow.com/questions/9671546/asynctask-android-example" rel="noopener ugc nofollow" target="_blank"> AsyncTask Android 示例</a></li><li id="3e8a" class="pl pm it lk b ll pu lo pv lr pw lv px lz py md qc pr ps pt bi translated"><a class="ae lh" href="https://www.javatpoint.com/kotlin-array" rel="noopener ugc nofollow" target="_blank">科特林阵</a></li></ul><h1 id="b13a" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">还有呢！</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="cf87" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">仅此而已。</h1><p id="1395" class="pw-post-body-paragraph li lj it lk b ll oe kd ln lo of kg lq lr og lt lu lv oh lx ly lz oi mb mc md im bi translated">有一个专业建议。在源代码中，我使用了手套字嵌入。自己看代码实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qe mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Machine Learning on Android!</figcaption></figure><p id="1a1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望你喜欢。机器学习快乐！</p></div></div>    
</body>
</html>