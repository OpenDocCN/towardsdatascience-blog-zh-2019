<html>
<head>
<title>Part II: All you need to know about Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二部分:关于正则表达式您需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regular-expressions-in-python-92d09c419cce?source=collection_archive---------19-----------------------#2019-03-04">https://towardsdatascience.com/regular-expressions-in-python-92d09c419cce?source=collection_archive---------19-----------------------#2019-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e173" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 和反斜杠瘟疫的简短教程。</h2></div><p id="34c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你知道什么是正则表达式(<a class="ae lb" href="https://medium.com/@ria.kulshrestha16/regular-expressions-in-python-a212b1c73d7f" rel="noopener">如果你不知道，请查看本教程的第 1 部分以获得快速概述</a>)我们现在将学习如何在 Python 中使用它们。:)</p><p id="50ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“re”模块为正则表达式引擎提供了一个接口，并允许我们将 re 编译成对象，然后对它们执行匹配。</p><p id="5167" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从导入模块开始。然后，我们将通过将正则表达式作为字符串传递来组合它，并将其转换为模式对象。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a5aa" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; import re<br/>&gt;&gt;&gt; pat_obj = re.compile('[a-z]+')<br/>&gt;&gt;&gt; print(pat_obj)<br/>re.compile('[a-z]+')</span></pre><h2 id="73f6" class="ll lm iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">如何处理模式对象？</h2><figure class="lc ld le lf gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mi"><img src="../Images/0f2f2c56d17ece14111bacaa4c84c03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoxfPBlY1WD6esveskqtYg.jpeg"/></div></div></figure><ul class=""><li id="c06f" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir"> match(): </strong>判断 RE 是否匹配字符串的开头。</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="89ca" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; m = pat_obj.match('helloworld')<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(0, 10), match='helloworld'&gt;</em></span><span id="8e6e" class="ll lm iq lh b gy na lo l lp lq"><strong class="lh ir">#Note how it doesn't take into account white spaces.</strong><br/>&gt;&gt;&gt; m = pat_obj.match('hello world')<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(0, 5), match='hello'&gt;</em></span><span id="4251" class="ll lm iq lh b gy na lo l lp lq"><strong class="lh ir"># Note that it is case-sensitive.</strong><br/>&gt;&gt;&gt; m = pat_obj.match('Helloworld')<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">None</em></span><span id="778d" class="ll lm iq lh b gy na lo l lp lq"><strong class="lh ir">#To ignore case<br/></strong>&gt;&gt;&gt; pat_obj = re.compile('[a-z]+', re.IGNORECASE)<br/>&gt;&gt;&gt; m = pat_obj.match('Helloworld')<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(0, 10), match='Helloworld'&gt;</em></span></pre><ul class=""><li id="1d9c" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir"> search(): </strong>扫描一个字符串，寻找这个 re 匹配的任何位置。</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5a57" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">#Note how it only prints the first match</strong><br/>&gt;&gt;&gt; s = pat_obj.search('Hello World!')<br/>&gt;&gt;&gt; print(s)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(1, 5), match='ello'&gt;</em></span></pre><ul class=""><li id="9121" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated">要打印所有匹配项，<br/> <strong class="kh ir"> findall(): </strong>查找 re 匹配的所有子字符串，并将它们作为一个列表返回。</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a4f2" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; s = pat_obj.findall('Hello World!')<br/>&gt;&gt;&gt; print(s)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(1, 5), match='ello'&gt;<br/>['ello', 'orld']</em></span><span id="7491" class="ll lm iq lh b gy na lo l lp lq"><strong class="lh ir">#To find all the numbers in a string</strong><br/>&gt;&gt;&gt;<strong class="lh ir"> </strong>pat_obj_num = re.compile(r'\d+')<br/>&gt;&gt;&gt; pat_obj_num.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')<br/><em class="mz">['12', '11', '10']</em></span></pre><ul class=""><li id="7c20" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir"> group(): </strong>返回 RE 匹配的字符串。因为说实话，这才是你感兴趣的。没人有时间听这些信息。</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="733e" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">#Using group with search</strong><br/>&gt;&gt;&gt; s = pat_obj.search('Hello World!')<br/>&gt;&gt;&gt; print(s)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(1, 5), match='ello'&gt;<br/></em>&gt;&gt;&gt; print(s.group())<br/><em class="mz">ello</em></span><span id="04a0" class="ll lm iq lh b gy na lo l lp lq"><strong class="lh ir">#Using group with match</strong><br/>&gt;&gt;&gt; m =  pat_obj.match("hello world")<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(0, 5), match='hello'&gt;<br/></em>&gt;&gt;&gt; print(m.group())<em class="mz"><br/>hello</em></span><span id="d742" class="ll lm iq lh b gy na lo l lp lq"><strong class="lh ir">#Using group with findall<br/></strong>&gt;&gt;&gt; m =  pat_obj.findall("hello world")<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">['hello', 'world']<br/></em>&gt;&gt;&gt; print(m.group())<em class="mz"><br/>Error!</em></span></pre><ul class=""><li id="e7ae" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir"> span(): </strong>返回一个包含匹配(开始，结束)位置的元组。<br/> <strong class="kh ir"> start()，end(): </strong>分别返回匹配的开始和结束位置。</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="7c68" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; pat_obj = re.compile('[a-z]+', re.IGNORECASE)<br/>&gt;&gt;&gt; m = pat_obj.match('Helloworld')<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(0, 10), match='Helloworld'&gt;</em><br/>&gt;&gt;&gt; print(m.start())<br/><em class="mz">0<br/></em>&gt;&gt;&gt; print(m.end())<br/><em class="mz">10</em><br/>&gt;&gt;&gt; print(m.span())<br/><em class="mz">(0, 10)</em></span></pre><h2 id="4dc4" class="ll lm iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">分组</h2><figure class="lc ld le lf gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nb"><img src="../Images/db0ce81bc8643cedb79e115859feb147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p9MzCNPcROqwyIQW"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@jeffreyflin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeffrey F Lin</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8cdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组由()元字符标记。它们将包含在其中的表达式组合在一起，您可以使用重复限定符重复组的内容，例如*、+、？或者{m，n}。<br/>组从 0 开始编号。组 0 始终存在；这是整个 RE，所以 match 对象方法都将 group 0 作为它们的默认参数。</p><p id="a9e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子组从左到右，从 1 向上编号。组可以嵌套；要确定数字，只需从左到右计算左括号中的字符。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="b2d7" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; pat_obj_group = re.compile('(a(b)c(d))e')<br/>&gt;&gt;&gt; m = pat_obj_group.match('abcde')<br/>&gt;&gt;&gt; print(m)<br/><em class="mz">&lt;_sre.SRE_Match object; span=(0, 5), match='abcde'&gt;<br/></em><strong class="lh ir"><em class="mz">#Note m.group(0) matches the same regex as m.match()<br/></em></strong>&gt;&gt;&gt; print(m.group(0))<br/><em class="mz">abcde</em><br/>&gt;&gt;&gt; print(m.group(1))<br/><em class="mz">abcd<br/></em><strong class="lh ir"><em class="mz">#Note the number is determined left to right<br/></em></strong>&gt;&gt;&gt; print(m.group(2))<br/><em class="mz">b</em><strong class="lh ir"><em class="mz"><br/></em></strong><em class="mz">&gt;&gt;&gt; print(m.group(3))<br/>d<br/></em><strong class="lh ir"><em class="mz"># Note that multiple arguments can be passes to group()<br/></em></strong>&gt;&gt;&gt; print(m.group(2,1,3))<br/><em class="mz">('b', 'abcd', 'd')</em></span></pre><ul class=""><li id="eeb1" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir"> groups(): </strong>返回一个包含所有子组字符串的元组，从 1 到所有子组。</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="cd65" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; print(m.groups())<br/><em class="mz">('abcd', 'b', 'd')</em></span></pre><h2 id="27c1" class="ll lm iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">代替</h2><figure class="lc ld le lf gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ng"><img src="../Images/459476ce1719fdea6d08161d169211c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rR_9am_eGZMMqJf2q4ApA.jpeg"/></div></div></figure><p id="6170" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> sub(): </strong>返回用替换<em class="mz"> repl </em>替换<em class="mz">字符串</em>中<em class="mz">模式</em>最左边不重叠出现的字符串。如果没有找到该模式，则返回不变的<em class="mz">字符串</em>。<br/> <em class="mz"> repl </em>可以是字符串，也可以是函数；如果它是一个字符串，其中的任何反斜杠转义都会被处理。也就是说，\n 被转换为单个换行符，\r 被转换为回车符，依此类推。</p><p id="e72d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模式的空匹配只有在不与先前的空匹配相邻时才被替换。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="7f46" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; print(re.sub('x','-','abxd'))<br/><em class="mz">ab-d</em><br/>&gt;&gt;&gt; print(re.sub('ab*','-','abxd'))<br/><em class="mz">-xd</em><br/>&gt;&gt;&gt; print(re.sub('x*','-','abxd'))<br/><em class="mz">-a-b-d-</em></span></pre><p id="b97d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可选参数<em class="mz"> count </em>是要替换的模式出现的最大数量；<em class="mz">计数</em>必须为非负整数。如果省略或为零，将替换所有出现的内容。</p><h2 id="a9cb" class="ll lm iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">反斜杠瘟疫</h2><figure class="lc ld le lf gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nh"><img src="../Images/c14f060200fd49cfbf9ed0bac6cc73d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3TmRevJe6d_MdKb-"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@blancotejedor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aarón Blanco Tejedor</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0ff4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管传递正则表达式有助于保持简单，但它有一个缺点。反斜杠字符(“\”)用于允许使用特殊字符而不调用它们的特殊含义，这与 Python 在字符串文字中使用相同字符的用法相冲突，在字符串文字中使用反斜杠字符以不同方式解释后面的字符。<br/>例如，“n”本身只是一个字母，但是当你在它前面加一个反斜杠时，它就变成了\n，这是换行符。啊哦！</p><p id="7d9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您想要编写一个匹配字符串'<em class="mz">\ section【T6]'的 RE，这个字符串可能在 LaTeX 文件中找到。<br/>我们将从想要匹配的字符串开始。接下来，我们必须通过在反斜杠前面加上反斜杠来转义任何反斜杠和其他元字符，从而得到字符串'<em class="mz"> \\section </em>'。必须传递给 re.compil()的结果字符串必须是'<em class="mz"> \\section </em>'。然而，要将其表示为 Python 字符串文字，必须再次对两个反斜杠<em class="mz">进行转义，</em>导致字符串“<em class="mz"> \\\\section </em>”。</em></p><p id="f629" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，要匹配一个文字反斜杠，必须将' \\\\ '写成 RE 字符串，因为正则表达式必须是\\，并且每个反斜杠必须在一个常规 Python 字符串文字中表示为\\。</p><figure class="lc ld le lf gt mj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/77447c03785c3b10b255f3443f0c69d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*Uor5Dzhe8WeCNKiwnL1nsA.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Source: <a class="ae lb" href="https://xkcd.com/1638/" rel="noopener ugc nofollow" target="_blank">XKCD</a></figcaption></figure><p id="293a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案是对正则表达式使用 Python 的原始字符串表示法；在以' r '为前缀的字符串文字中，不会以任何特殊方式处理反斜杠，因此 r'\n '是包含' \ '和' n '的双字符字符串，而' \n '是包含换行符的单字符字符串。</p><p id="0280" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">常规字符串和相应的原始字符串</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ba0f" class="ll lm iq lh b gy ln lo l lp lq">"ab*" -&gt; r"ab*"</span><span id="78fa" class="ll lm iq lh b gy na lo l lp lq">"\\\\section" -&gt; r"\\section"</span><span id="1126" class="ll lm iq lh b gy na lo l lp lq">"\\w+\\s+\\1" -&gt; r"\w+\s+\1"</span></pre><h2 id="2f3b" class="ll lm iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">学习正则表达式的有趣工具和资源</h2><ul class=""><li id="ac4c" class="mq mr iq kh b ki nj kl nk ko nl ks nm kw nn la mv mw mx my bi translated"><a class="ae lb" href="https://regexone.com/" rel="noopener ugc nofollow" target="_blank"> Regexone </a></li><li id="e934" class="mq mr iq kh b ki no kl np ko nq ks nr kw ns la mv mw mx my bi translated"><a class="ae lb" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank">可视化工具</a></li><li id="4c3a" class="mq mr iq kh b ki no kl np ko nq ks nr kw ns la mv mw mx my bi translated"/></ul><h2 id="50ca" class="ll lm iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">我写的其他文章，我认为你可能会喜欢:D</h2><ul class=""><li id="80e5" class="mq mr iq kh b ki nj kl nk ko nl ks nm kw nn la mv mw mx my bi translated">8 分钟内学会 Git！</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><blockquote class="oa ob oc"><p id="2b56" class="kf kg mz kh b ki kj jr kk kl km ju kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">我很高兴你坚持到了这篇文章的结尾。<em class="iq">🎉我希望你的阅读体验和我写这篇文章时一样丰富。<em class="iq">💖</em></em></p><p id="fe6b" class="kf kg mz kh b ki kj jr kk kl km ju kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">请点击查看我的其他文章<a class="ae lb" href="https://medium.com/@ria.kulshrestha16" rel="noopener">。</a></p><p id="7281" class="kf kg mz kh b ki kj jr kk kl km ju kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">如果你想联系我，我会选择推特。</p></blockquote></div></div>    
</body>
</html>