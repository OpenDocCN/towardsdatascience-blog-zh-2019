<html>
<head>
<title>Soup of the Day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今日汤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/soup-of-the-day-97d71e6c07ec?source=collection_archive---------8-----------------------#2019-07-26">https://towardsdatascience.com/soup-of-the-day-97d71e6c07ec?source=collection_archive---------8-----------------------#2019-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c18b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数字音乐</h2><div class=""/><div class=""><h2 id="eec6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">美汤网刮——初学者指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e6311dd36b17c9f5febe8dc0ecde5481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnKXtLsTK6VhQ0LslJkVNw.jpeg"/></div></div></figure><p id="2274" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尽管有成千上万可爱干净的数据集可供数据科学家们使用(大部分在<a class="ae lz" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上)，但你总是会有那些讨厌的假设不在他们的范围之内。从头开始创建你<em class="ma">需要的数据集是一个潜在的令人生畏的前景——即使你能在网页上看到数据，实际上将它转换成可供分析的格式可能涉及大量的手工工作。</em></p><p id="b1da" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">令人高兴的是，网络抓取自动化了从网页中检索信息的过程，通过使用正确的工具，我们可以创建可靠的数据存储，然后进行分析。</p><blockquote class="mb mc md"><p id="c925" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">注意——这是一系列文章中的第一篇。在这里，我们将一步一步地用漂亮的 Soup 库介绍 webscraping Metacritic 的机制。随后的博客将深入探讨我们对其背后进行的分析。</p></blockquote><h1 id="c7e0" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated"><strong class="ak">第一步。对 HTML 的理解刚刚好</strong></h1><p id="f15b" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">超文本标记语言(HTML)是告诉网络浏览器在页面上显示什么信息的代码。重要的是，它没有说太多关于<em class="ma">如何</em>显示信息(网站通常组合两组代码，HTML 和<a class="ae lz" href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets" rel="noopener ugc nofollow" target="_blank">层叠样式表</a> (CSS)来呈现页面，CSS 负责页面的外观)。</p><p id="25b9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这很重要，因为我们感兴趣的是网页的<em class="ma">信息</em>，我们知道这些信息将被存储在 HTML 代码中的某个地方。</p><p id="fd02" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有益的是，大多数浏览器提供了一种简单的方法来查看 HTML 代码的哪一部分引用了页面上的特定元素。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ne"><img src="../Images/339efe510bdde8fad6273ca3a3bc144e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vww5hDQb3Dz9n2bZpHhdWg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">Right-click on any element on the page, then select ‘Inspect Element’</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nj"><img src="../Images/7177c8f5ce061a80fd95c148b7798628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcqmnb7NEoOhnfZg2e8IOg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">This brings up the browser’s ‘Inspector’, and shows which line of the HTML refers to which element on the web page</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/ff8c02bf28d2ee71994dfdce5e17b4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1BoPe5KyaoRFbY6XCLv1Q.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">This process also works in reverse — we can hover over a line of code in the Inspector, and it’ll highlight the part of the web page that this code refers to</figcaption></figure><p id="5038" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">HTML 代码本身可能看起来吓人，但是结构比看起来要简单。内容通常包含在“标签”中，标签是在&lt;&gt;括号内的东西。例如，当声明一段文本时，HTML 代码可能如下所示:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="ae41" class="nq mi it nm b gy nr ns l nt nu">&lt;p&gt;My text here, inside the paragraph tags&lt;/p&gt;</span></pre><p id="e05a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">HTML 有不同类型的标签，做不同的事情——最常见的(正如你在上面的截图中看到的)是:</p><ul class=""><li id="065b" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated"><strong class="lf jd">表头:</strong> &lt; h1 &gt; &lt; /h1 &gt;(注意，我们可以有 h1，h2，…，h6，这取决于想要的表头层次结构)。</li><li id="3ed9" class="nv nw it lf b lg oe lj of lm og lq oh lu oi ly oa ob oc od bi translated"><strong class="lf jd">有序列表:</strong> &lt;李&gt;&lt;/李&gt;</li><li id="e40b" class="nv nw it lf b lg oe lj of lm og lq oh lu oi ly oa ob oc od bi translated"><strong class="lf jd">无序列表:</strong> &lt; ul &gt; &lt; /ul &gt;(即项目符号样式列表)</li><li id="b470" class="nv nw it lf b lg oe lj of lm og lq oh lu oi ly oa ob oc od bi translated"><strong class="lf jd">超链接:</strong>&lt;a href = "<em class="ma">EXAMPLE _ URL</em>"&gt;&lt;/a&gt;</li><li id="c750" class="nv nw it lf b lg oe lj of lm og lq oh lu oi ly oa ob oc od bi translated"><strong class="lf jd">Span:</strong>&lt;Span&gt;&lt;/Span&gt;(用于<a class="ae lz" href="https://www.w3schools.com/tags/tag_span.asp" rel="noopener ugc nofollow" target="_blank">识别段落</a>中的子字符串——如果您希望您的同伴 CSS 代码只格式化句子中的某些单词，这很有用)</li><li id="443f" class="nv nw it lf b lg oe lj of lm og lq oh lu oi ly oa ob oc od bi translated"><strong class="lf jd">语义元素:</strong> &lt; div &gt; &lt; /div &gt;</li></ul><p id="f75c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意——语义元素是一个包罗万象的范畴，而“div”是一个你会在 HTML 的许多块中经常看到的术语。这些“div”标签的典型用途是创建“子元素”，其中可以包含列表、其他标题和其他子元素。</p><p id="10c5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这就像计算机文件资源管理器中的文件夹树结构——根“我的文档”文件夹可能包含文档和文件，但也可能包含其他文件夹。这些文件夹可以依次包含更多的文件夹。</p><p id="def1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，如果我们想在这个元符号页面上隔离特定专辑的“发布日期”,我们可以看到它包含在几个嵌套的子元素中。最终，我们可以在代码本身中找到发布日期。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/79698d84a1d934375c342116d9cf7e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUt4qi6hw9y8FttLL0W64Q.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/a5d9c87f5e3ecb1b52b803dd0d6e420a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8tFY5Owb6KPD4RHZBiE7Q.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/d59a7ddba9bdfbde1dc207c6b5e72d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I530_F6urrAToRzMshM1Ww.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/0859d0f44a8f6af6b417a466cb346d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2V4rHotamFlGwgiV0nuTbw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/04efe0b4aa62260446dafa363eb4e791.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*IljiQgN3OeoUaf7GWGAcTg.png"/></div></figure><p id="4baa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们所看到的，许多标签还具有其他属性来进一步区分它们自己。这些通常被标记为元素的“id”或“class”。当我们从 HTML 代码中提取数据时，这些将是至关重要的。</p><h1 id="0d5a" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">第二步。将 HTML 提取到 Jupyter 笔记本中</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/bfe25c5f48d7a66eb64599846153aa5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/0*7voaAvp7oWgWPpJO.png"/></div></figure><p id="6961" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以在浏览器中看到 HTML 现在我们需要将它放入 Jupyter 笔记本(或等效物)中，以便我们可以分析它。为此，我们使用 python 的'<a class="ae lz" href="https://2.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank">请求</a>库。</p><p id="dd0a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请求的语法非常简单。假设我们想从上面提到的 Metacritic 中获取 HTML。我们可以使用。get()方法:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="2e10" class="nq mi it nm b gy nr ns l nt nu"><strong class="nm jd">import</strong> requests</span><span id="5b95" class="nq mi it nm b gy op ns l nt nu">url = <a class="ae lz" href="https://www.metacritic.com/browse/albums/artist/a?num_items=100" rel="noopener ugc nofollow" target="_blank">https://www.metacritic.com/browse/albums/artist/a?num_items=100</a></span><span id="7f71" class="nq mi it nm b gy op ns l nt nu">page = requests.get(url)</span></pre><p id="a1eb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们现在可以在“page”变量上调用一些其他有用的方法。例如，我们可以检查<a class="ae lz" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank">状态码</a>。</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="4417" class="nq mi it nm b gy nr ns l nt nu">page.status_code</span></pre><p id="26f6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果这返回‘200’，那么我们都很好，尽管其他的<a class="ae lz" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank">状态代码</a>可能表明我们需要修改最初的‘请求’。</p><h1 id="57dd" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">第三步。阅读 HTML 汤</h1><p id="777a" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">一旦我们有了“请求”对象(“页面”)，我们就可以使用<a class="ae lz" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> Beautiful Soup </a>库中的 html.parser 特性来理解它的内容。</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="eb12" class="nq mi it nm b gy nr ns l nt nu"><strong class="nm jd">from</strong> bs4 <strong class="nm jd">import</strong> BeautifulSoup</span><span id="1756" class="nq mi it nm b gy op ns l nt nu">soup = BeautifulSoup(page.content, ‘html.parser’)</span></pre><p id="4663" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，如果我们实际调用“soup”变量，我们会看到事情仍然有点混乱(当然远远谈不上美好)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/d779c8d23fc48ed1cf1cb98fc3c99dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZfBV-sBY8quhrLGpqn14Q.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">This output goes on for quite some time…</figcaption></figure><p id="68e3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这就是浏览器的检查器派上用场的地方。因为我们可能有一个好主意，知道我们想从页面中获得什么信息，所以我们能够在 inspector 中找到相应的 HTML。</p><p id="829f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，如果我想在这个页面上创建一个所有艺术家名字的列表，我可以在第一个这样的名字上‘检查元素’,并查看信息是如何存储在 HTML 中的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/ae44eed0741a3cfff9bc944647f6f844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4IGA1GBsELw3qBqHp61vw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/dfbd672d815ce27dae74e0f9d786bf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*kQ8deNEp0M19khG6hhs2Sg.png"/></div></figure><p id="f01e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以看到，艺术家名“A Camp”存储在一个“有序列表”(由<li>标记表示)中，其类为“stat product_artist”。给定网站的结构，我们可以猜测所有艺术家的名字将以相同的方式存储(尽管我们当然可以通过检查元素来检查这一点，就像我们对“A Camp”所做的那样)。</li></p><p id="9ba4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们用漂亮的汤。findAll()方法，使用类“stat product_artist”查找有序列表的所有实例，将这两个特征指定为单独的参数。</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="aef0" class="nq mi it nm b gy nr ns l nt nu">artistHTML = soup.findAll(‘li’,class_=”stat product_artist”)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/231b781402c284f885692ea2fae427dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*RHkm3r-sewJymV6-8KI1PA.png"/></div></figure><p id="c933" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这给了我们一个“bs4.element.ResultSet”类型的对象。仔细观察这个对象，我们可以看到它看起来有点像 python 列表。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/0e9eb351777d454378907fd082f7a754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*iX9gRQP5WgQOnaTDhZeXlA.png"/></div></figure><p id="cbbb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">特别是，我们可以索引这个 ResultSet 对象来隔离不同的艺术家名字(我们可以使用' len '函数来检查我们有多少，在这个例子中是 99)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/708688038664c23a59d565ce9e76f8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*OTNrlQXBLXFNbM1ezA7DGw.png"/></div></figure><p id="8098" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，“bs4.element.ResultSet”对象中的这些元素本身是类型为“bs4.element.tag”的对象。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/3571acb309ba15f8d5769fbbcfe9be6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*7hfRg43c4CcuNs0kfz4Nnw.png"/></div></figure><p id="a25c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这意味着他们带来了一些新的方法，可以帮助我们提取我们需要的信息。</p><blockquote class="mb mc md"><p id="026f" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">在这一点上我们应该注意，这不是获取艺术家姓名信息的唯一方式。我们还可以在 HTML 中更深入一层，尝试 soup.findAll('span '，class_= "data))。然而，这种方法增加了一层复杂性——事实证明，使用这种标签存储的每个相册有三种不同类型的信息；艺术家姓名、发行日期和 metascore。这是可以管理的，但是所描述的方法可能会更加直接。</p></blockquote><h1 id="5558" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">第四步。从 HTML 标签中提取数据</h1><p id="2963" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">获取存储在标签中的信息(并确保它以正确的格式返回给我们)并不总是最直接的任务，可能需要一些尝试和错误。我倾向于先采用几种不同的方法。</p><p id="4621" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">。get_text()往往是最可靠的。有时，我们需要对它输出的字符串进行编辑，以使它们成为所需的形式。因此，我们应该在不同的元素上尝试该方法，以确保我们可以在所有元素上进行相同的编辑。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/1cc4a075f19b88e7c6085e920aba6be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*3HHVO2trkc4foHQsI_eM2w.png"/></div></figure><p id="a5ce" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以看到，我们需要去掉艺术家姓名两边的子字符串。我们可以为此使用一个<a class="ae lz" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">正则表达式方法</a>，但是，我们可以偷懒，将两个。请改为 replace()方法:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="6599" class="nq mi it nm b gy nr ns l nt nu">artistHTML[0].get_text().replace(‘\n’, ‘’).replace(‘Artist:’, ‘’)</span></pre><p id="7618" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们现在可以遍历 artistHTML 中的不同元素，提取艺术家的名字，并将它们放入一个列表中。我们可以使用循环来实现这一点:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="0fa9" class="nq mi it nm b gy nr ns l nt nu">artists = []<br/><strong class="nm jd">for</strong> element <strong class="nm jd">in</strong> artistHTML:<br/>    artist = element.get_text()<br/>    artist_final = artist.replace(‘\n’,’’).replace(‘Artist:’,’’)<br/>    artists.append(artist_final)</span></pre><p id="9db6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">…或者是列表理解，我发现这样更有条理:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="bc6e" class="nq mi it nm b gy nr ns l nt nu">artists = [element.get_text().replace(‘\n’,’’).replace(‘Artist:’,’’)<br/>           <strong class="nm jd">for</strong> element <strong class="nm jd">in</strong> artistHTML]</span></pre><p id="f677" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后这些列表可以按原样存储，或者例如可以将它们放入熊猫数据帧中。</p><p id="3479" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如前所述，从汤里提取数据有许多不同的方法。和大多数“编码”一样，很少有一种正确的方法来做某事——<a class="ae lz" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank">漂亮的汤文档</a>是一个很好的地方来看看不同的元素方法在起作用。</p><h1 id="a9d9" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">第五步。正在获取所有数据…</h1><p id="4a39" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">一旦我们从网页中提取了我们想要的所有数据。根据站点的结构，下一个任务是从新页面中提取数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/139846416ddceeb9e99d694f62dfd975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9v8kzYuCTKzeAFdM8yGJxQ.png"/></div></div></figure><p id="5279" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，如果我们想要 Metacritic 中的所有艺术家的名字，我们将需要转到第 2 页，然后是第 3 页，依此类推(这只是针对以“A”开头的艺术家！).显然，我们希望这样的过程可以通过代码自动完成。有几种方法可以解决这个问题。</p><ol class=""><li id="dac9" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oz ob oc od bi translated"><strong class="lf jd">第二次猜测网址</strong></li></ol><p id="3f03" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们刚刚抓取的网址是:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="a28d" class="nq mi it nm b gy nr ns l nt nu"><a class="ae lz" href="https://www.metacritic.com/browse/albums/artist/a?num_items=100" rel="noopener ugc nofollow" target="_blank">https://www.metacritic.com/browse/albums/artist/a?num_items=100</a><a class="ae lz" href="https://www.metacritic.com/browse/albums/artist/a?num_items=100&amp;page=1" rel="noopener ugc nofollow" target="_blank">&amp;page=0</a></span></pre><p id="014a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们跟随链接到第 2 页，然后到第 3 页，我们看到的网址是:</p><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="a6f8" class="nq mi it nm b gy nr ns l nt nu"><a class="ae lz" href="https://www.metacritic.com/browse/albums/artist/a?num_items=100&amp;page=1" rel="noopener ugc nofollow" target="_blank">https://www.metacritic.com/browse/albums/artist/a?num_items=100&amp;page=1</a></span><span id="3f00" class="nq mi it nm b gy op ns l nt nu"><a class="ae lz" href="https://www.metacritic.com/browse/albums/artist/a?num_items=100&amp;page=2" rel="noopener ugc nofollow" target="_blank">https://www.metacritic.com/browse/albums/artist/a?num_items=100&amp;page=2</a></span></pre><p id="100a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">显然，我们有一个模式 URL 末尾的数字是页码减一。这意味着我们可以非常简单地遍历 URL，依次抓取每个 URL。</p><p id="d865" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们需要确定给定字母有多少页(以“A”开头的艺术家有 11 页，但显然以其他字母开头的艺术家会有多或少)。</p><p id="631e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">鉴于这个数字显示在页面上，我们可以在 HTML 中找到它。我们可以使用步骤 2、3 和 4 中描述的过程来分离这个数字，并将其分配给 python 中的一个变量(我们称之为“pages”)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/f2e4c05b30b231707b4b0a7b8ed5ec25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFNkay457iy0_W3ZmffEFw.png"/></div></div></figure><pre class="ks kt ku kv gt nl nm nn no aw np bi"><span id="aaa0" class="nq mi it nm b gy nr ns l nt nu"><strong class="nm jd">for</strong> page_number <strong class="nm jd">in</strong> range(pages):</span><span id="7332" class="nq mi it nm b gy op ns l nt nu">    url = f'https://www.metacritic.com/browse/albums/artist/a?num_items=100&amp;page={page_number}'</span><span id="0ae7" class="nq mi it nm b gy op ns l nt nu">    page = requests.get(url)</span><span id="8ff5" class="nq mi it nm b gy op ns l nt nu"><em class="ma"># We then include the scraping code </em><strong class="nm jd"><em class="ma">inside</em></strong><em class="ma"> the loop, ensuring that data from each new URL is appended to data collected from the previous pages - either in lists, or Pandas dataframes</em></span></pre><p id="9935" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> 2。在 HTML 本身中查找下一个 URL</strong></p><p id="47a1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于组织良好的网站(如 Metacritic ),第二次猜测 URL 就足够了，但是对于其他不太整洁的网站，这种方法可能不起作用。然而，假设我们在页面上有一个“下一页”按钮，我们可以在 HTML 中找到它及其相应的超链接。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/c49730c121ad1e82d0a03cff48723bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2b8rqu-TIwYmGJ4ckOf6w.png"/></div></div></figure><p id="6a9d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设我们在寻找一个超链接，我们应该留意<a>标签。我们可以像第 3 步一样使用 soup.findAll()方法。注意，即使只有一个这样的元素，findAll 方法仍然是一个类似列表的对象，我们需要对它进行索引。</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/b0c199c9b8366681a832474cfd1adc17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wnBhxDBQ_X8c6tZH0eQ6Q.png"/></div></div></figure><p id="95ea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">考虑到 URL 就在标签本身中，我们信任的。get_text()方法将在这里工作。相反，我们可以查看元素的属性，使用。attrs 的财产。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/da4c53f810d4ebe24863390c5a681b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*ZCVp80H4Di2K7XuzQR90gg.png"/></div></figure><p id="90f3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意 attrs 对象看起来很像一本字典。因此，我们可以使用“href”键来查找所需的值。然后我们可以使用 f 字符串输出完整的 URL。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/726c45c527bca5dddbaaba9e9aed527b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*CRtryGdd1_ZqwFno_y5Tpw.png"/></div></figure><p id="19cf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个 URL 可以被传递到请求中(参见步骤 1)，并且生成的页面可以被抓取。通过将这些代码行作为循环的一部分，我们可以让我们的抓取代码自动依次遍历每个页面。</p><blockquote class="mb mc md"><p id="2b1b" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">网络搜集是一项非常强大的技术，也是任何数据科学家弓上的一根弦。上面的指南是作为一个起点写的，尽管还有许多其他的免费技术(事实上，除了漂亮的汤之外还有其他的刮库)。</p><p id="16b5" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">刮的开心！</p></blockquote></div></div>    
</body>
</html>