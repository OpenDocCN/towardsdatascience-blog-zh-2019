<html>
<head>
<title>Everything About Javascript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 Javascript 对象的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-about-javascript-object-part-1-854025d71fea?source=collection_archive---------12-----------------------#2019-09-05">https://towardsdatascience.com/everything-about-javascript-object-part-1-854025d71fea?source=collection_archive---------12-----------------------#2019-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/18bb142aabc06d0f91f8a21b01ed00f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZNqrra6djsJMNjoi_CjhQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Object in Javascript</figcaption></figure><p id="88fc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="ld">近</em></strong>JavaScript 中的一切都是除了<strong class="kh iu">之外的对象六个</strong>是<strong class="kh iu">不是对象</strong>是——<code class="fe le lf lg lh b"><strong class="kh iu"><em class="ld">null</em></strong></code>、<code class="fe le lf lg lh b"><strong class="kh iu"><em class="ld">undefined</em></strong></code>、<strong class="kh iu">、<em class="ld">字符串</em>、<strong class="kh iu">、<em class="ld">数字</em>、<strong class="kh iu">、<em class="ld">布尔</em>、<strong class="kh iu">、<em class="ld">符号</em>、</strong>。这些被称为原始值或原始类型。</strong></strong></strong></p><p id="94dc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">任何不是原始值的东西都是一个<strong class="kh iu">对象</strong>。这包括<strong class="kh iu">数组</strong>、<strong class="kh iu">函数</strong>、构造函数和对象本身。</p><p id="9e87" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">是啊！函数和数组也是对象，我们将在本文后面看到。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="4a36" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">目标</h1><p id="b178" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">从概念上讲，对象在所有编程语言中都是一样的，也就是说，它们代表了我们希望在程序中用特征/属性和方法来表示的真实世界的事物。</p><p id="26f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，如果你的对象是一个学生，那么它将拥有姓名、年龄、地址、id 等属性和<code class="fe le lf lg lh b">updateAddress</code>、<code class="fe le lf lg lh b">updateName</code>等方法。</p><p id="a9b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在 JavaScript 中，把一个对象想象成一个包含条目的列表，列表中的每个条目(一个属性或一个方法)都由一个键值对存储在内存中作为引用。</p><p id="5fe1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看一个对象示例。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="095f" class="na lq it lh b gy nb nc l nd ne">const firstObj = {<br/>  1: "deepak",<br/>  "age": 28<br/>}</span></pre><p id="19fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">firstObj</code>是一个有 2 个属性 1，年龄和值为<code class="fe le lf lg lh b">deepak</code>和<code class="fe le lf lg lh b">28</code>的对象。</p><p id="9a3c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">JavaScript 对象在创建方式上有些不同。对<code class="fe le lf lg lh b">class</code>本身没有要求，可以使用文字符号来声明。</p><h2 id="e042" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated">对象创建</h2><p id="e2e6" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">在 javascript 中，我们可以用多种方式创建对象，让我们来看看每一种方式。</p><ol class=""><li id="4bb5" class="nq nr it kh b ki kj km kn kq ns ku nt ky nu lc nv nw nx ny bi translated"><code class="fe le lf lg lh b">Object literal</code>(D \直接方式)。对象文字是用大括号括起来的逗号分隔的键值对列表。对象文字属性值可以是任何数据类型，包括数组文字、函数、嵌套对象文字或原始数据类型。</li></ol><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="63af" class="na lq it lh b gy nb nc l nd ne">var student = {<br/>  id: 1,<br/>  name: "deepak",<br/>  age: "27",<br/>  updateAddress: () =&gt; {<br/>   // logic to update address<br/>  },<br/>  grade: ['A', 'A+', 'A']<br/>}</span></pre><blockquote class="nz oa ob"><p id="4ff0" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:上面的学生对象键可以通过点符号访问，即<code class="fe le lf lg lh b">student.id</code>、<code class="fe le lf lg lh b">student.name</code>或通过方括号符号访问，即<code class="fe le lf lg lh b">student[‘id’]</code>、<code class="fe le lf lg lh b">student[‘name’]</code>等</p></blockquote><p id="ad2a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2.<code class="fe le lf lg lh b">Object.create()</code>。方法使用旧对象的指定原型和属性创建新对象。</p><blockquote class="nz oa ob"><p id="166c" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:每个 JavaScript 函数默认都有一个<code class="fe le lf lg lh b">prototype</code>对象属性(默认为空)。方法或属性可以附加到此属性。</p></blockquote><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="4290" class="na lq it lh b gy nb nc l nd ne">// syntax - Object.create(prototype[, propertiesObject])<br/>var newStudent = Object.create(student); <br/>// this create a new object with old object added in its prototype // chain </span></pre><p id="ba0a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是对象<code class="fe le lf lg lh b">__proto__</code>的输出</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/3c6ba19cb2217d8c5d32f6f258291c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbwjYzj56ggqa7pLdMqd7Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Object in Javascript</figcaption></figure><p id="fb7d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在可以使用我们在这里学习的方法向<code class="fe le lf lg lh b">newStudent</code>对象添加新的属性和数据。</p><blockquote class="nz oa ob"><p id="6b3f" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:<code class="fe le lf lg lh b">newStudent</code>将可以访问父<code class="fe le lf lg lh b">student</code>对象的键和值，因为它已经被添加到了<code class="fe le lf lg lh b">newStudent</code>原型链中，这是我们在 javascript 中进行继承的一种方式。<strong class="kh iu"> </strong>也就是说，<code class="fe le lf lg lh b"><em class="it">newStudent</em></code>会存储一个到<code class="fe le lf lg lh b"><em class="it">student</em></code>对象的链接。当读取一个属性时，这个<em class="it">父对象</em>也被参考。</p><p id="d933" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">父级可以有父级，依此类推。重复这一过程，直到我们到达一个没有任何父对象的对象，即父对象是<code class="fe le lf lg lh b">null</code>。</p></blockquote><p id="e819" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">3.<code class="fe le lf lg lh b">Object Instance</code>。结合使用<code class="fe le lf lg lh b">Object</code>构造函数和"<code class="fe le lf lg lh b">new</code>"关键字允许我们初始化新的对象。</p><p id="fb02" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看一个例子</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="ea30" class="na lq it lh b gy nb nc l nd ne">const newObj = new Object();<br/>newObj.name = ‘Deepak’;<br/>newObj.location = ‘Delhi, India’;</span></pre><p id="8ca8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，上述使用<code class="fe le lf lg lh b">new Object()</code>的方法不太适合需要创建多个同类对象的程序，因为这将涉及为每个此类对象重复编写上述代码行。</p><p id="3877" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了处理这个问题，我们可以使用下一种方法</p><p id="5d5b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">4.<code class="fe le lf lg lh b">Object construtor</code>。当我们需要一种方法来创建一个可以多次使用的对象“类型”而不必每次都重新定义对象时，构造函数会很有用，这可以通过使用对象构造函数来实现。</p><p id="bf58" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看一个例子</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="4d58" class="na lq it lh b gy nb nc l nd ne">function Vehicle(name, model) { <br/>   this.name = name; <br/>   this.model = model; <br/>} <br/>  <br/>let car1 = new Vehicle('Fiesta', '2019'); <br/>let car2 = new Vehicle('DC avanti', '2018');</span></pre><p id="276c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们创建了两个属性相同但值不同的对象。</p><p id="ba9d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> 5。</strong> <code class="fe le lf lg lh b">Object.assign()</code>。这是从其他对象创建新对象的另一种方法。</p><blockquote class="nz oa ob"><p id="107d" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:我们将在下一部分讨论可枚举/所有权，所以请原谅我。</p></blockquote><p id="d5a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。让我们通过一个例子来理解:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="5577" class="na lq it lh b gy nb nc l nd ne">var obj = { a: 1 };<br/>var copy = Object.assign({}, obj);<br/>console.log(copy); // { a: 1 }</span></pre><p id="fff4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">Object.assign()</code>有很多用例，比如对象克隆、合并对象等。</p><p id="7663" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">6。 <code class="fe le lf lg lh b">Object.fromEntries()</code> <strong class="kh iu">。M </strong>方法将一个键值对列表转换成一个对象。让我们看一个例子</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="4bcc" class="na lq it lh b gy nb nc l nd ne">const entries = new Map([<br/>  ['foo', 'bar'],<br/>  ['baz', 42]<br/>]);</span><span id="766d" class="na lq it lh b gy og nc l nd ne">const obj = Object.fromEntries(entries);</span><span id="4a6c" class="na lq it lh b gy og nc l nd ne">console.log(obj);<br/>// expected output: Object { foo: "bar", baz: 42 }</span></pre><blockquote class="nz oa ob"><p id="5ce4" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:创建对象的最好方法是通过文字符号，因为它在源代码中占用较少的空间。对于正在发生的事情，这是显而易见的，所以使用<code class="fe le lf lg lh b">new Object()</code>，您实际上只是输入了更多内容，并且(理论上，如果没有被 JavaScript 引擎优化)执行了一个不必要的函数调用。此外，文字符号在同一行代码中创建对象并分配属性，这与其他符号不同。</p></blockquote><h2 id="1168" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated">如何添加/更新和删除对象的属性</h2><p id="cde5" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">如前所述，对象的属性可通过<strong class="kh iu">点或括号符号</strong>添加。让我们看一个例子</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="0fe1" class="na lq it lh b gy nb nc l nd ne">const a = {};<br/>a.name = 'deepak';<br/>a['city'] = 'delhi';<br/>a[1] = 'dope';</span></pre><p id="ecb4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里，<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">city</code>是对象属性。</p><p id="d3f7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个对象只能包含一个具有一个值的键。我们不能让一个键有两个不同的值。</p><p id="5616" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">属性名可以是字符串、数字、特殊字符或动态属性，但如果属性名不是字符串，则必须用括号符号来访问。因此，如果我们需要访问上面例子中的属性<code class="fe le lf lg lh b"><em class="ld">1</em></code>，我们可以执行<code class="fe le lf lg lh b"><em class="ld">a[1]</em></code>，但是<code class="fe le lf lg lh b"><em class="ld">a.1</em></code>将返回一个语法错误。然而，属性情况，即<code class="fe le lf lg lh b"><em class="ld">a.name</em></code>或<code class="fe le lf lg lh b"><em class="ld">a["name"]</em></code>将会起作用。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="9619" class="na lq it lh b gy nb nc l nd ne">a.first name = 'deepak' // will return syntax error<br/>a['first name'] = 'deepak' // will work </span></pre><p id="5341" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要更新一个属性，我们可以再次使用上述两种符号类型。如果我们向已经创建的属性添加值，那么该值将被更新或创建。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="0392" class="na lq it lh b gy nb nc l nd ne">a.city = 'new york';</span></pre><p id="c334" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面将城市值从<code class="fe le lf lg lh b">delhi</code>更新为<code class="fe le lf lg lh b">new york</code>。</p><p id="4ffa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们也可以通过像<code class="fe le lf lg lh b"><strong class="kh iu">Object.defineProperties()</strong></code> <strong class="kh iu">或</strong> <code class="fe le lf lg lh b"><strong class="kh iu">Object.defineProperty()</strong></code>这样的<code class="fe le lf lg lh b">Object</code>函数方法来创建和更新对象的属性</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="b8d0" class="na lq it lh b gy nb nc l nd ne">Object.defineProperties(a, {<br/>  pincode: {<br/>    value: 10012,<br/>    writable: true<br/>  },<br/>  property2: {}<br/>});</span><span id="4a58" class="na lq it lh b gy og nc l nd ne">console.log(a.pincode); // 10012</span></pre><p id="6298" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要删除一个对象的属性，我们可以使用<code class="fe le lf lg lh b">delete</code>关键字，我们可以同时使用这两种符号。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="748b" class="na lq it lh b gy nb nc l nd ne">delete a['city'];<br/>delete a.city;</span></pre><p id="7550" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果成功删除属性，返回值<code class="fe le lf lg lh b">delete</code>为<code class="fe le lf lg lh b">true</code>。要不然就是<code class="fe le lf lg lh b">false</code>。</p><blockquote class="oh"><p id="6009" class="oi oj it bd ok ol om on oo op oq lc dk translated">你知道不允许属性更新或删除的方法吗？如果是，请在下面评论。如果不是，请不要担心，我会带着更多的问题深入下一篇文章。</p></blockquote><h2 id="26e8" class="na lq it bd lr nf or dn lv nh os dp lz kq ot nk md ku ou nm mh ky ov no ml np bi translated">如何迭代对象属性？</h2><p id="0b73" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">实际编码时会有这样的情况，我们想要访问所有的对象键值对。</p><p id="de7f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">使用循环——for in 和 for of 循环</strong></p><p id="254b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于中的<strong class="kh iu"> for，它遍历一个对象并逐个返回属性。</strong></p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="5a3f" class="na lq it lh b gy nb nc l nd ne">for (const key in a) {<br/>   console.log(key, a[key]);<br/>}</span></pre><p id="4bb6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Key 将一个接一个地拥有所有属性，<code class="fe le lf lg lh b">a[key]</code>将返回值。For in 循环也迭代原型链，并且也将返回父键，所以如果您看到更多的键，请不要感到惊讶。为了避免看到更多的键，我们可以做一个<code class="fe le lf lg lh b">hasOwnProperty</code>检查，只获取当前对象的键。</p><p id="fccf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在的<strong class="kh iu"> for 的情况下，在<a class="ae ow" href="https://medium.com/@ideepak.jsd/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener">可迭代对象</a>上迭代。更多阅读请点击这里。</strong></p><p id="1107" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对象函数中有各种方法帮助访问对象属性和值，而不是原型链。</p><ol class=""><li id="73df" class="nq nr it kh b ki kj km kn kq ns ku nt ky nu lc nv nw nx ny bi translated"><code class="fe le lf lg lh b"><strong class="kh iu">Object.keys()</strong></code> <strong class="kh iu">或</strong> <code class="fe le lf lg lh b"><strong class="kh iu">Object.getOwnPropertyNames()</strong></code> <strong class="kh iu">。返回一个字符串键数组。</strong></li></ol><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="e556" class="na lq it lh b gy nb nc l nd ne">const keys = Object.keys(a) <br/>// return ["name", "first name", "city", "1"];</span><span id="4fad" class="na lq it lh b gy og nc l nd ne">const newKeys = Object.getOwnPropertyNames(a);<br/>// return ["name", "first name", "city", "1"];</span><span id="b544" class="na lq it lh b gy og nc l nd ne">keys.map(key =&gt; console.log(a[key])); <br/>// return ["deepak", "deepak", "new york", "dope"];</span></pre><p id="98b9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> 2。</strong> <code class="fe le lf lg lh b"><strong class="kh iu">Object.values()</strong></code> <strong class="kh iu">。返回一个数值数组。</strong></p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="837d" class="na lq it lh b gy nb nc l nd ne">const keys = Object.values(a);</span><span id="d86b" class="na lq it lh b gy og nc l nd ne">// return ["deepak", "deepak", "new york", "dope"]</span></pre><p id="3a28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> 3。</strong> <code class="fe le lf lg lh b"><strong class="kh iu">Object.entries()</strong></code> <strong class="kh iu">。</strong>返回一个由<code class="fe le lf lg lh b">[key, value]</code>对组成的数组。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="89c2" class="na lq it lh b gy nb nc l nd ne">const data = Object.entries(a);</span><span id="c4fd" class="na lq it lh b gy og nc l nd ne">// returns <br/>[ ["1", "dope"], ["name", "deepak"], ["first name", "deepak"], ["city", "new york"]]</span></pre><p id="530f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从上面我们可以看出，一个物体的属性出现的顺序并不是固定的。</p><h2 id="3661" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated">如何检查对象中的属性存在</h2><p id="f16e" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">有三种方法可以检查对象中是否存在该属性。</p><ol class=""><li id="ce0a" class="nq nr it kh b ki kj km kn kq ns ku nt ky nu lc nv nw nx ny bi translated"><strong class="kh iu">使用</strong> <code class="fe le lf lg lh b"><strong class="kh iu">hasOwnProperty</strong></code>。此方法返回一个布尔值，该值指示对象是否将指定的属性作为自己的属性，而不是父/继承属性。</li></ol><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="7ec0" class="na lq it lh b gy nb nc l nd ne">console.log(a.hasOwnProperty(1)); // return true;<br/>console.log(a.hasOwnProperty('1')); // return false;</span><span id="e4de" class="na lq it lh b gy og nc l nd ne">const b = Object.create(a); // this will add a as parent of b<br/>console.log(b.hasOwnProperty(1)); // return false</span></pre><blockquote class="nz oa ob"><p id="c4d8" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:<code class="fe le lf lg lh b"><em class="it">hasOwnProperty</em></code>返回 true，即使属性的值是<code class="fe le lf lg lh b"><em class="it">null</em></code>或<code class="fe le lf lg lh b"><em class="it">undefined</em></code>。</p></blockquote><blockquote class="oh"><p id="0115" class="oi oj it bd ok ol ox oy oz pa pb lc dk translated">如果我们在一个对象中使用<code class="fe le lf lg lh b">hasOwnProperty</code>作为属性名会怎么样？在下面评论你的想法。</p></blockquote><p id="5dea" class="pw-post-body-paragraph kf kg it kh b ki pc kk kl km pd ko kp kq pe ks kt ku pf kw kx ky pg la lb lc im bi translated"><strong class="kh iu"> 2。在操作符中使用<em class="ld">—</em></strong><code class="fe le lf lg lh b"><strong class="kh iu">in</strong></code><strong class="kh iu">操作符</strong>返回<code class="fe le lf lg lh b">true</code>如果指定的属性在指定的对象或其原型链中，即在其父对象中。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="f694" class="na lq it lh b gy nb nc l nd ne">console.log(1 in a); // return true;<br/>console.log('1' in a); // return false;</span><span id="0f75" class="na lq it lh b gy og nc l nd ne">const b = Object.create(a); // this will add a as parent of b<br/>console.log(b.hasOwnProperty(1)); // return true</span></pre><blockquote class="nz oa ob"><p id="360e" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:<code class="fe le lf lg lh b"><em class="it">hasOwnProperty</em></code> <em class="it">只检查当前对象属性，而</em> <code class="fe le lf lg lh b"><em class="it">in</em></code> <em class="it">运算符检查当前+父属性</em></p></blockquote><h2 id="03aa" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated">3.使用定制的功能</h2><p id="3bf9" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">通过自定义方法检查属性是否存在有多种方法。其中一个是通过<code class="fe le lf lg lh b">Object.keys</code>获得的 eg。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="9f80" class="na lq it lh b gy nb nc l nd ne">Object.keys(a).indexOf(1) !== -1 // return true</span></pre><p id="299b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在你的自定义方法下面写下注释来做同样的事情😃。</p><h2 id="22ca" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated">什么是按引用复制/共享和按值复制，它如何应用于对象？</h2><p id="4fe8" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">不同之处在于，通过值，我们的意思是每次创建新的内存分配，而在引用的情况下，我们指向已经创建的内存空间。</p><p id="73b4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在 javascript 的上下文中，所有的原始数据类型都是通过值方法分配内存的，对于一个对象来说，根据实现的不同，它可以通过值或引用进行复制。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="c214" class="na lq it lh b gy nb nc l nd ne">// pass by value<br/>let a = 5; <br/>let b = a;</span><span id="eb61" class="na lq it lh b gy og nc l nd ne">a = 6;<br/>console.log(b) // return 5 as each time a new memory is allocated</span><span id="9c1a" class="na lq it lh b gy og nc l nd ne">// pass by reference<br/>const a = {x: 1};<br/>const b = a; </span><span id="98f6" class="na lq it lh b gy og nc l nd ne">a.x = 3;<br/>console.log(b.x) // it returns 3 as its a shared memory between a and b</span></pre><h2 id="8f35" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated">什么是对象的浅层和深层复制/克隆？</h2><p id="6b47" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">浅层拷贝和深层拷贝的核心区别在于如何将属性复制到新对象中。</p><p id="36e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<strong class="kh iu">浅拷贝</strong>中，新对象与旧对象共享数据，即在上述示例中，使用<code class="fe le lf lg lh b">=</code>创建<code class="fe le lf lg lh b">a</code>对象的浅拷贝<code class="fe le lf lg lh b">b</code>。所以按引用传递在大多数情况下是浅层拷贝。</p><p id="a2f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，浅层副本将复制顶级属性，但嵌套对象在原始对象(源)和副本对象(目标)之间共享。</p><p id="8382" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">浅层复制的另一种方法是使用<code class="fe le lf lg lh b">Object.assign()</code>,这将在开始部分讨论。让我们看看这个例子</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="3fa1" class="na lq it lh b gy nb nc l nd ne">let obj = {<br/>  a: 1,<br/>  b: {<br/>    c: 2,<br/>  },<br/>}</span><span id="0efb" class="na lq it lh b gy og nc l nd ne">let newObj = Object.assign({}, obj);<br/>console.log(newObj); // { a: 1, b: { c: 2} }<br/><br/>obj.a = 10;<br/>console.log(obj); // { a: 10, b: { c: 2} }<br/>console.log(newObj); // { a: 1, b: { c: 2} }</span><span id="748a" class="na lq it lh b gy og nc l nd ne">newObj.b.c = 30;<br/>console.log(obj); // { a: 10, b: { c: 30} }<br/>console.log(newObj); // { a: 20, b: { c: 30} }</span></pre><p id="8f77" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">正如我们在上面的<code class="fe le lf lg lh b">obj.b.c = 30</code>中看到的，这是<code class="fe le lf lg lh b">Object.assign()</code>的一个缺陷。<code class="fe le lf lg lh b">Object.assign</code>只做浅仿。<code class="fe le lf lg lh b">newObj.b</code>和<code class="fe le lf lg lh b">obj.b</code>共享对该对象的相同引用，因为没有制作单独的副本，而是复制了对该对象的引用。</p><p id="df41" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<strong class="kh iu">深度复制中，</strong>新对象将拥有自己的一组键-值对(与原始对象具有相同的值)，而不是共享。</p><p id="a525" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们来看看做深度复制的一些方法</p><ol class=""><li id="8334" class="nq nr it kh b ki kj km kn kq ns ku nt ky nu lc nv nw nx ny bi translated"><code class="fe le lf lg lh b">JSON.parse(JSON.stringify(object))</code></li></ol><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="bca6" class="na lq it lh b gy nb nc l nd ne">let obj = { <br/>  a: 1,<br/>  b: { <br/>    c: 2,<br/>  },<br/>}<br/><br/>let newObj = JSON.parse(JSON.stringify(obj));<br/><br/>obj.b.c = 20;<br/>console.log(obj); // { a: 1, b: { c: 20 } }<br/>console.log(newObj); // { a: 1, b: { c: 2 } } (New Object!)</span></pre><p id="6aec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的问题是我们不能复制值为<code class="fe le lf lg lh b">undefined</code>或<code class="fe le lf lg lh b">Symbol</code>的用户定义的对象函数或键。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="8d0a" class="na lq it lh b gy nb nc l nd ne">let obj = { <br/>  a: 1,<br/>  b: { <br/>    c: 2,<br/>  },<br/>  d: () =&gt; {}<br/>}<br/><br/>let newObj = JSON.parse(JSON.stringify(obj));<br/><br/>console.log(newObj); // { a: 1, b: { c: 2 } } (New Object!)<!-- --> </span></pre><p id="9de1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，这种方法不适用于圆形对象。</p><blockquote class="nz oa ob"><p id="749d" class="kf kg ld kh b ki kj kk kl km kn ko kp oc kr ks kt od kv kw kx oe kz la lb lc im bi translated">注意:圆形对象是具有引用自身的属性的对象。</p></blockquote><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="778a" class="na lq it lh b gy nb nc l nd ne">let obj = { <br/>  a: 'a',<br/>  b: { <br/>    c: 'c',<br/>    d: 'd',<br/>  },<br/>}<br/><br/>obj.c = obj.b;<br/>obj.e = obj.a;<br/>obj.b.c = obj.c;<br/>obj.b.d = obj.b;<br/>obj.b.e = obj.b.c;<br/><br/>let newObj = JSON.parse(JSON.stringify(obj));<br/><br/>console.log(newObj);</span></pre><p id="1032" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面会抛出一个错误说<code class="fe le lf lg lh b">converting circular structure to JSON.</code></p><p id="37fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> 2。使用 ES6 扩展运算符— </strong></p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="6e50" class="na lq it lh b gy nb nc l nd ne">let obj = {<br/>  one: 1,<br/>  two: 2,<br/>  nested: {<br/>    three: 3<br/>  },<br/>}<br/><br/>let newObj = { ...obj }; <br/>console.log(newObj); // { one:1, two:2, nested: {three: 3}} <br/>(New Object!)</span></pre><p id="ef01" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不过<code class="fe le lf lg lh b">nested</code>还是被浅浅的抄了<em class="ld"/>。</p><h2 id="0453" class="na lq it bd lr nf ng dn lv nh ni dp lz kq nj nk md ku nl nm mh ky nn no ml np bi translated"><strong class="ak">如何比较两个物体？</strong></h2><p id="5be7" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">对象的相等操作符<code class="fe le lf lg lh b">==</code>和严格相等操作符<code class="fe le lf lg lh b">===</code>的工作方式完全相同，即只有当两个对象共享相同的内存引用时，它们才相等。</p><p id="08a5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，如果两个变量引用同一个对象，则它们相等:</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="f4f1" class="na lq it lh b gy nb nc l nd ne">const a = {};<br/>const b = a;</span><span id="6988" class="na lq it lh b gy og nc l nd ne">console.log(b == a); // return true</span><span id="805d" class="na lq it lh b gy og nc l nd ne">const c = {};<br/>console.log(c == a); //return false</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="4ebb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您想加入我的电子邮件列表，请考虑在这里输入您的电子邮件地址 和<strong class="kh iu">关注我的</strong><a class="ae ow" href="https://medium.com/@ideepak.jsd" rel="noopener"><strong class="kh iu">medium</strong></a><strong class="kh iu">阅读更多关于 javascript 和</strong><a class="ae ow" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">Github</strong></a><strong class="kh iu">的文章，查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><ol class=""><li id="dff3" class="nq nr it kh b ki kj km kn kq ns ku nt ky nu lc nv nw nx ny bi translated"><a class="ae ow" href="https://levelup.gitconnected.com/javascript-execution-context-and-hoisting-c2cc4993e37d" rel="noopener ugc nofollow" target="_blank"> Javascript 执行上下文和提升</a></li><li id="ae72" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="edcb" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解 Javascript‘this’关键字(上下文)</a>。</li><li id="43be" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://levelup.gitconnected.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener ugc nofollow" target="_blank"> Javascript 数据结构与映射、归约、过滤</a></li><li id="201e" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="7b8f" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="a8af" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a></li><li id="5443" class="nq nr it kh b ki ph km pi kq pj ku pk ky pl lc nv nw nx ny bi translated"><a class="ae ow" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li></ol></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="4ace" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如果你喜欢这篇文章，请随意分享，以帮助他人找到它！</h1><h1 id="02d0" class="lp lq it bd lr ls pm lu lv lw pn ly lz ma po mc md me pp mg mh mi pq mk ml mm bi translated"><strong class="ak">谢谢！</strong></h1></div></div>    
</body>
</html>