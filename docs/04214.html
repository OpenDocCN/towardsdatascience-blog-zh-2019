<html>
<head>
<title>Building a better query engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建更好的查询引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-better-query-engine-ff52cb6364cd?source=collection_archive---------33-----------------------#2019-07-01">https://towardsdatascience.com/building-a-better-query-engine-ff52cb6364cd?source=collection_archive---------33-----------------------#2019-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/30bb7441b14c70f7020fb78eca513131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Lrgdxioon196mqBeTBnIw.jpeg"/></div></div></figure><div class=""/><blockquote class="jy jz ka"><p id="d250" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jc"><em class="jb">TL；博士</em> </strong> <em class="jb">这篇文章讲述了我们如何引入一个自由文本查询引擎来取代传统的基于过滤器的方法，使用命名实体识别和一些其他技巧来查询数据。</em></p></blockquote><p id="16d2" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">所有企业都在以巨大的速度生成数据。当数据量很大时，我们会希望查看我们可能感兴趣的数据子集(应用过滤器)。所以传统上这些过滤器转化为数据库查询。对 IBM 中所有概要文件的简单查询如下所示</p><blockquote class="jy jz ka"><p id="1efe" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">SELECT * from profiles where company = " IBM "</p></blockquote><p id="ecec" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">当以有意义的方式向用户呈现数据时，Draup 面临着非常类似的挑战。它有一个庞大的配置文件生态系统，用户可以根据几个过滤器参数缩小范围。您可以根据公司、位置、技能、业务职能等选择个人资料。</p><p id="f181" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是基于过滤器的方法的样子。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ld"><img src="../Images/9fe6e3ee4f175c328c8a88dcb3bb1dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUHPJWXnaSWW7bAvLVXV8w.jpeg"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Filter-Based Approach</figcaption></figure><p id="1aee" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">当每个类别只有几个选项时，过滤很容易，但随着每个类别的选项增加，复杂性就会不成比例。</p><h1 id="09e1" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">另一种查询方法</h1><p id="eaab" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">在 Draup，我们希望摒弃这种过滤搜索结果的方式，改善我们的用户体验。所以我们研究了另一种查询平台的方法。用户现在可以输入自由文本查询，告别所有由过滤器造成的混乱。这里有几个例子</p><pre class="le lf lg lh gt mp mq mr ms aw mt bi"><span id="cc60" class="mu ln jb mq b gy mv mw l mx my">- Show me data engineers skilled in python<br/>- Someone who is located at san francisco with the qualification of a data scientist.<br/>- Show me top executives in Amazon<br/>- Adam from Microsoft, Redmond</span></pre><p id="9922" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">所以第一个查询应该转换成下面的 SQL 查询。</p><blockquote class="jy jz ka"><p id="cd49" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jc">从<strong class="ke jc">档案</strong>中选择</strong> *，其中<strong class="ke jc">JOB _ TITLE = " data engineer "</strong>和<strong class="ke jc"> SKILL = "python" </strong></p></blockquote><p id="561a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们从机器学习的角度来处理这个问题。这个问题在 ML 世界中被称为命名实体识别(NER)。</p><h1 id="2c0b" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">构建命名实体识别系统</h1><p id="9d67" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated"><strong class="ke jc">命名实体识别</strong>是<a class="ae mz" href="https://en.wikipedia.org/wiki/Information_extraction" rel="noopener ugc nofollow" target="_blank">信息提取</a>的一个子任务，旨在定位非结构化文本中的命名实体提及并将其分类为预定义的类别，例如<strong class="ke jc">个人和组织名称、位置</strong>、<strong class="ke jc">日期、</strong>等。</p><p id="b7f4" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">NER 有出色的开源模型 ( <a class="ae mz" href="https://github.com/explosion/spaCy/tree/master/spacy" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae mz" href="https://stanfordnlp.github.io/stanfordnlp/" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae mz" href="https://www.nltk.org/" rel="noopener ugc nofollow" target="_blank"> 3 </a>、<a class="ae mz" href="https://github.com/zalandoresearch/flair" rel="noopener ugc nofollow" target="_blank"> 4 </a>)，但它们本质上非常普通。这些模型适用于一般的实体类型，如人名、位置、组织、日期等，但是在 Draup 中，我们关心的要多得多。我们还有其他几个实体，如技能、子垂直行业、业务职能、组织级别等，这些都是这些预训练模型无法涵盖的。所以我们得出结论，我们必须建立自己的 NER 系统。</p><h1 id="7394" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">构建数据集</h1><p id="f19f" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">这通常是任何机器学习(ML)过程中最关键的部分。ML 遵循一个简单的规则，<strong class="ke jc">“垃圾入，垃圾出”</strong>。这意味着一个 ML 模型的好坏取决于它所训练的数据。牢记这一点，我们努力产生尽可能多的例子。我们可以达到大约 200 个可能的查询。这是用于训练模型的相对较小的数据集。对用户查询模式的仔细研究给了我们关于如何通过数据扩充生成更多数据的想法。人们似乎并不关心自由文本查询中重要单词的大写。许多用户没有注意到<strong class="ke jc">使用正确的标点符号</strong>，但是仍然期望模型能够工作。这些见解有助于我们建立一个快速的数据增强管道，为我们创建更多的训练示例。所有这些努力总共产生了<strong class="ke jc"> 1000 个培训示例</strong>。</p><h1 id="e1c3" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">建模技术的选择</h1><p id="b373" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">构建 NER 系统有两大主题:</p><ol class=""><li id="04f2" class="na nb jb ke b kf kg kj kk la nc lb nd lc ne kz nf ng nh ni bi translated">传统算法如<strong class="ke jc">条件随机场</strong> (CRF)</li><li id="e34d" class="na nb jb ke b kf nj kj nk la nl lb nm lc nn kz nf ng nh ni bi translated">基于深度学习的方法</li></ol><p id="49aa" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果你有一个大的数据集，基于深度学习的方法在文本数据领域非常有效。大约 1000 个例子还不够。最近，通用语言模型，如谷歌的伯特 T21 或 OpenAI 的 GPT-2 已经在较小的数据集上显示出有希望的结果。然而，这些模型体积庞大，我们觉得它们对我们的任务来说有点大材小用。与传统方法相比，深度学习的另一个重要缺点是很难解释和说明模型行为。</p><p id="426b" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">另一方面，条件随机场即使在数据有限的情况下也能很好地完成 NER 任务。</p><h1 id="ac5a" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">条件随机场模型</h1><blockquote class="jy jz ka"><p id="35a3" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本节以一些直观的细节讨论了 CRF，但涉及一些数学问题。您可以选择跳过它。</p></blockquote><p id="1edf" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">当我们处理序列时，使用<a class="ae mz" href="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1162&amp;context=cis_papers" rel="noopener ugc nofollow" target="_blank"> <strong class="ke jc">条件随机场</strong> </a>模型。在我们的例子中，输入是一个单词序列，输出是一个实体标签序列。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/88b6c317b79216f9c5915cbe2a1dbcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrWMzsuSiV29lLxpq-dY8A.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Words and Tags sequence</figcaption></figure><p id="6b9c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们把单词序列叫做 x̄，把标签序列叫做 y̅.<br/>同样，让我们定义所谓的特征函数:f(yᵢ₋₁、yᵢ、x̅，i) <br/>这里，特征函数采用 4 个参数:-</p><blockquote class="jy jz ka"><p id="e8b5" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1: i，当前索引在序列<br/> 2: x̄，整个输入序列<br/> 3: yᵢ₋₁，先前的输出标签索引在 i <br/> 4: yᵢ，当前输出标签索引在 I</p></blockquote><p id="90e6" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">为了让事情更清楚，让我们定义一个示例特征函数。</p><p id="a15a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">f(yᵢ₋₁、yᵢ、x̅、i) = { 1 如果 yᵢ₋₁和 yᵢ都是<strong class="ke jc">头衔</strong>并且现在的单词是‘<strong class="ke jc">工程师</strong>’,否则为 0}</p><p id="459e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">正如您所看到的，这是一个非常具有描述性的特征函数，如果我们定义了很多这样的特征函数，我们就可以提取出很多关于文本数据的信息。这是另一个功能。</p><p id="5574" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">f(yᵢ₋₁、yᵢ、x̅、i) = { 1 如果 yᵢ₋₁是其他人，yᵢ是标题，当前单词是大写的<strong class="ke jc">，否则 0}</strong></p><p id="5537" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在收集了一系列特征函数之后，我们想要找到一个概率分布函数。这个函数应该告诉给定 x̅.，每个可能的 y̅的概率是多少下面的等式定义了这个概率。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/407b3d664c9c15400d7e0a455ec63a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbeoiMOTsHbZpEKRBYNhFA.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Image Credit: Sameer Maskey slides</figcaption></figure><p id="d2c0" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这里 exp 是指数函数。上述函数使用指数平滑地将概率分布在所有可能的标签序列上，并确保概率之和为 1。</p><p id="6ca2" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果你仔细观察，你会发现<strong class="ke jc">每个特征函数都被赋予了一个权重</strong>，这在直觉上是有意义的，因为不是所有的特征函数都具有同等的重要性。现在，给定数据，我们希望<strong class="ke jc">最大化我们的数据的条件似然</strong>并找到最佳的权重集。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/86b2ba89dd3ac4d9eecf17ad72a27e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*fvclPeoGu_VAu5q7kEho8w.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Conditional Likelihood function</figcaption></figure><p id="d430" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这里 L 是条件似然函数，k 迭代所有的训练例子。使用梯度下降，我们可以学习最适合我们数据集的参数(权重)。</p><p id="d053" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">嗯，这看起来需要做很多工作，但是我们使用了<a class="ae mz" href="https://sklearn-crfsuite.readthedocs.io/en/latest/tutorial.html" rel="noopener ugc nofollow" target="_blank"><strong class="ke jc">sklearn-CRF suite</strong></a>库，在大约 1000 个例子的数据集上训练 CRF 模型。</p><h1 id="9e31" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">准确率、召回率和 F1 评分</h1><p id="27ef" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">下面用一个简单的例子来解释一下<a class="ae mz" rel="noopener" target="_blank" href="/precision-vs-recall-386cf9f89488"> <strong class="ke jc">精度和回忆一下</strong> </a>。假设我们建立了一个模型，可以预测/提取文本中提到的所有技能，我们的输入文本有 9 项技能。假设模型预测了 10 项技能，其中 6 项实际上是技能，另外 4 项不是技能。</p><blockquote class="jy jz ka"><p id="f966" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">A =相关记录数= 9 <br/> B =检索到的相关记录数= 6 <br/> C =检索到的记录数= 10 <br/> D =检索到的不相关记录数= 10–6 = 4</p><p id="b6d2" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jc">精度= B/C = 0.6 <br/>召回=B/A = 0.667 </strong></p></blockquote><p id="cb05" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">一个好的模型在精确度和召回率上都有很高的值。然而，有时用一个值来评估模型的好坏是有好处的。f1 分数由此而来。它将精确度和召回率和谐地结合在一起。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f65cfdc8afdd495cc6ad27a8be7267c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*G0hsmpeDeWhk-hExhST1KA.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">f1-score</figcaption></figure><p id="c892" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">所以在我们的例子中，f1 分数是 0.632</p><h1 id="6aa1" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">模型验证和改进</h1><p id="34cf" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">如果模型不能识别查询中的所有实体，这是可以接受的。但是如果模型错误地识别了实体，那么结果就会受到负面影响。例如，如果模型将一个人的名字识别为一家公司，那么很可能不会有搜索结果，甚至更糟的是，系统会产生错误的结果。因此，我们需要非常好的精确度和尽可能多的召回率。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a1a4660d769293f721bb561af997964b.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*yJSQeSt-0uRPRNA0aDX7RA.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Initial Model</figcaption></figure><p id="8f9b" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们最初的努力导致了以下结果。</p><blockquote class="jy jz ka"><p id="8a2d" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">精确度:0.790 <br/>召回率:0.635<br/>F1-得分:0.702</p></blockquote><p id="060e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这些结果是基于完全看不见的数据。</p><p id="bd83" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果看召回，好像挺低的。这通常是 CRF 技术的一个问题。CRF 通常可以达到很好的精度，但是在召回率上有所欠缺。</p><blockquote class="nt"><p id="7c3c" class="nu nv jb bd nw nx ny nz oa ob oc kz dk translated">为了解决低召回率的问题，我们引入了几个特征函数，它们使用我们的几个实体的管理列表。</p></blockquote><blockquote class="jy jz ka"><p id="6dae" class="kb kc kd ke b kf od kh ki kj oe kl km kn of kp kq kr og kt ku kv oh kx ky kz ij bi translated">f(yᵢ₋₁，yᵢ，x̅，我)= {1 如果 yᵢ₋₁是其他，yᵢ是技能，并且当前单词存在于我们的已知技能列表中，否则 0}</p></blockquote><p id="a987" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">假设我们的列表中有这样的技能:<br/> ('AutoCAD '，' python '，' java '，' MongoDB '，' nodejs '，……)</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/35f5186848e6045e903a3c8600f9d320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lj8w-XwomgEd_9ddleC8mg.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Value of skill lookup function for each index in the original sequence</figcaption></figure><p id="d200" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在为其他一些实体定义了这样的特性之后，我们取得了巨大的进步。在引入这些特性后构建的模型给出了以下结果。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fe75558e45cf4bd757161861e6ea3d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*NmAngS8IU8RADzI6Hzu0AQ.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Improved Model</figcaption></figure><p id="c4b5" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">精确度:0.862 <br/>召回率:0.754<br/>F1-得分:0.803</p><p id="e07d" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">帮助我们的引擎在生产中表现良好的另一个技巧是使用<a class="ae mz" href="https://norvig.com/spell-correct.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke jc">拼写纠正</strong> </a>。用户在向系统查询时似乎很匆忙。我们经常会遇到这样的查询:</p><blockquote class="jy jz ka"><p id="1398" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="jb">向我展示</em><strong class="ke jc"><em class="jb">amzon</em></strong><em class="jb"><br/>Java</em><strong class="ke jc"><em class="jb">伦敦</em> </strong> <em class="jb">的开发人员</em></p></blockquote><p id="e171" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">拼写纠正过程帮助我们在很大程度上纠正这种情况，并使我们的系统更可用。</p><h1 id="26f5" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">它看起来像什么</h1><p id="855b" class="pw-post-body-paragraph kb kc jb ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">系统现在允许用户输入自由文本查询，然后提取实体并显示给用户，以及显示基于这些实体/过滤器的结果。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/27575b833ab43f05721be005c75744b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hj1vwo664ZnVfO6iKsR8-g.jpeg"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">New Search Interface</figcaption></figure><p id="3135" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">上面的例子显示了微软中的查询“<strong class="ke jc"> Director”。系统正确地识别出实体<strong class="ke jc">董事</strong>和<strong class="ke jc">微软</strong>，并为您应用这些过滤器。</strong></p><p id="f5e0" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这只是自由文本查询引擎的开始。我们的系统将随着我们获得更多数据的训练而改进。</p><p id="c848" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke jc">参考文献:- </strong></p><ul class=""><li id="1943" class="na nb jb ke b kf kg kj kk la nc lb nd lc ne kz ok ng nh ni bi translated"><a class="ae mz" href="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1162&amp;context=cis_papers" rel="noopener ugc nofollow" target="_blank"> <em class="kd">条件随机场:用于分割和标记序列数据的概率模型</em> </a></li><li id="6ccf" class="na nb jb ke b kf nj kj nk la nl lb nm lc nn kz ok ng nh ni bi translated"><a class="ae mz" href="http://www.cs.columbia.edu/~smaskey/CS6998-0412/slides/week13_statnlp_web.pdf" rel="noopener ugc nofollow" target="_blank"><em class="kd">Web 对数线性模型的统计 NLP，MEMM，条件随机字段</em></a><em class="kd">:</em><strong class="ke jc">same er Maskey</strong></li><li id="51f0" class="na nb jb ke b kf nj kj nk la nl lb nm lc nn kz ok ng nh ni bi translated"><a class="ae mz" href="https://www.nltk.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kd">自然语言工具包</em> </a></li><li id="31b0" class="na nb jb ke b kf nj kj nk la nl lb nm lc nn kz ok ng nh ni bi translated"><a class="ae mz" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kd"> Spacy:工业级自然语言处理</em> </a></li><li id="d284" class="na nb jb ke b kf nj kj nk la nl lb nm lc nn kz ok ng nh ni bi translated"><a class="ae mz" href="https://sklearn-crfsuite.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"><em class="kd">sk learn-CRF suite</em></a></li><li id="cb0b" class="na nb jb ke b kf nj kj nk la nl lb nm lc nn kz ok ng nh ni bi translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation" rel="noopener ugc nofollow" target="_blank"> <em class="kd">最大似然估计</em> </a></li></ul></div></div>    
</body>
</html>