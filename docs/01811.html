<html>
<head>
<title>What is TensorFrames? TensorFlow + Apache Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是张量框架？TensorFlow + Apache Spark</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-tensorframes-tensorflow-apache-spark-a385ec4bc1d5?source=collection_archive---------24-----------------------#2019-03-25">https://towardsdatascience.com/what-is-tensorframes-tensorflow-apache-spark-a385ec4bc1d5?source=collection_archive---------24-----------------------#2019-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f9af6d5362feeeeef409aaed76a3c977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWBS9uQiG8TzkrFl20elKw.jpeg"/></div></div></figure><p id="ea38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">首先，什么是张量框架？</strong></p><p id="fda3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TensorFrames 是由 Apache Spark 贡献者创建的开源软件。其函数和参数的命名与 TensorFlow 框架中的相同。它是 Apache Spark 数据帧的 Apache Spark DSL(特定领域语言)包装器。它允许我们用 TensorFlow 功能操作数据帧。而且不，它是<strong class="kd iu">而不是</strong> <a class="ae kz" href="https://www.tutorialspoint.com/python_pandas/python_pandas_dataframe.htm" rel="noopener ugc nofollow" target="_blank">熊猫数据帧</a>，它是基于阿帕奇 Spark 数据帧。</p><p id="8138" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">..但是等等，TensorFlow (TF)是什么？</strong></p><p id="b56a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TensorFlow 是一个开源软件库，用于数据流和跨一系列任务的差异化编程。它是一个符号数学库，也用于机器学习应用，如神经网络。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi la"><img src="../Images/76315788e6605a4942a60cde7f49dc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/0*HUlDKdJEBnF3gbEr.jpeg"/></div></figure><p id="f551" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">..还有阿帕奇 Spark？</strong></p><p id="f599" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Apache Spark 是一个开源的分布式通用集群计算框架。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/9a98779a064fed13f833123033bfee08.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/0*tjXkt8QaQpbwZPVc.png"/></div></figure><h2 id="7ea1" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">关于规模的一句话</h2><p id="4ade" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">今天当我们提到规模时，我们通常会谈到两种选择；水平缩放和垂直缩放。</p><ul class=""><li id="08e8" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><strong class="kd iu">水平刻度</strong> —添加额外的具有大致相同计算能力的机器</li><li id="d6ad" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd iu">垂直比例</strong> —为我们目前使用的机器增加更多资源。它可以是从 CPU 升级到 GPU 的处理器、更多内存(RAM)等等。</li></ul><p id="12b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了 TensorFrames，我们可以两者兼得，更多的处理器计算能力，更多的机器。在只有 TensorFlow 的情况下，我们通常专注于通过垂直扩展来增加更多功能，现在有了 Apache Spark 支持，我们可以同时进行垂直和水平扩展。但是，我们怎么知道我们实际上需要多少呢？要回答这个问题，我们需要了解应用程序的全部使用情况，并相应地进行规划。</p><p id="d390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于每个变化，比如增加一台机器或从 CPU 升级到 GPU，我们都有<em class="ms">停机时间。</em>在云中，调整集群大小或增加更多计算能力只需几分钟，而在本地，我们需要添加新机器和升级机器处理器，这可能需要几天，有时甚至几个月。</p><p id="39c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，更灵活的解决方案是公共云。</p><p id="ae43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下图中，水平缩放是 X 轴，垂直缩放是 Y 轴。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/2fb3336045336231b534efcded2164b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ftyhVsmFr9q_oLnb.png"/></div></div></figure><p id="d2b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">* * Apache Spark conf 上蒂姆·亨特演示的幻灯片</p><h1 id="552e" class="mu lh it bd li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh ni nj lx nk bi translated">在开始函数之前，让我们了解一些重要的张量流词汇:</h1><h2 id="88ad" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">张量</h2><p id="49c6" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">一个静态类型的多维数组，其元素属于泛型类型。</p><h2 id="6b22" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">GraphDef</h2><p id="ffa8" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated"><code class="fe nl nm nn no b">Graph</code>或<code class="fe nl nm nn no b">Computional Graph</code>是 TensorFlow 呈现计算的核心概念。当我们使用 TensorFlow 时，我们首先创建自己的<code class="fe nl nm nn no b">Computation Graph</code>，并将<code class="fe nl nm nn no b">Graph</code>传递给 TensorFlow。<code class="fe nl nm nn no b">GraphDf</code>是<code class="fe nl nm nn no b">Graph</code>的连载版。</p><h2 id="b41f" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">操作</h2><p id="a134" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">对张量执行计算的图形节点。操作是<code class="fe nl nm nn no b">Graph</code>中的一个节点，它将零个或多个<code class="fe nl nm nn no b">Tensors</code>(由图中的其他操作产生)作为输入，并产生零个或多个<code class="fe nl nm nn no b">Tensor</code>作为输出。</p><h2 id="6273" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">身份</h2><p id="3f37" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">当我们想要在设备之间显式传输张量时(例如，从 GPU 到 CPU)，使用<code class="fe nl nm nn no b">tf.identity</code>。该操作将节点添加到图中，当输入和输出的设备不同时，该操作会生成一个副本。</p><h2 id="670c" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">常数</h2><p id="806b" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">常量有以下参数，可以根据需要调整这些参数以获得所需的函数。它和变量一样，但是它的值不能改变。常数可以是:</p><ul class=""><li id="a8e4" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><code class="fe nl nm nn no b">value</code>:输出类型<code class="fe nl nm nn no b">dtype</code>的常量值(或列表)。</li><li id="dd00" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe nl nm nn no b">dtype</code>:结果张量的元素类型。</li><li id="3289" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe nl nm nn no b">shape</code>:结果张量的可选维度。</li><li id="47ef" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe nl nm nn no b">name</code>:张量的可选名称。</li><li id="ceba" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe nl nm nn no b">verify_shape</code>:允许验证值的形状的布尔值。</li></ul><h2 id="ed3a" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">占位符</h2><p id="cca5" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">为数据分配存储空间(例如，在输入期间为图像像素数据分配存储空间)。初始值不是必需的(但可以设置，见<code class="fe nl nm nn no b">tf.placeholder_with_default</code>)。相对于变量，你需要声明初始值。\</p><h1 id="9451" class="mu lh it bd li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh ni nj lx nk bi translated">一些 Apache Spark 词汇</h1><h2 id="4714" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">数据帧</h2><p id="c082" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">这是一个<em class="ms">分布式的</em>数据集合，这些数据被组织成命名的列，这些列提供过滤、分组或计算集合的操作。Dataframe 数据通常分布在多台机器上。它可以在内存数据中，也可以在磁盘上。</p><h2 id="c41a" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">RelationalGroupedDataset</h2><p id="ed52" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">由<a class="ae kz" href="http://maxpumperla.com/java-book/api/scala/org/apache/spark/sql/Dataset.html#groupBy(col1:String,cols:String*):org.apache.spark.sql.RelationalGroupedDataset" rel="noopener ugc nofollow" target="_blank"> groupBy </a>、<a class="ae kz" href="http://maxpumperla.com/java-book/api/scala/org/apache/spark/sql/Dataset.html#cube(col1:String,cols:String*):org.apache.spark.sql.RelationalGroupedDataset" rel="noopener ugc nofollow" target="_blank"> cube </a>或<a class="ae kz" href="http://maxpumperla.com/java-book/api/scala/org/apache/spark/sql/Dataset.html#rollup(col1:String,cols:String*):org.apache.spark.sql.RelationalGroupedDataset" rel="noopener ugc nofollow" target="_blank"> rollup </a>创建的一组在<code class="fe nl nm nn no b">DataFrame</code>上聚合的方法。</p><p id="c0d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主要方法是<code class="fe nl nm nn no b">agg</code>函数，它有多个变量。为了方便起见，该类还包含一些一阶统计量，如<code class="fe nl nm nn no b">mean</code>、<code class="fe nl nm nn no b">sum</code>。</p><p id="1124" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们更好地理解了术语，让我们看看功能。</p><h1 id="ee01" class="mu lh it bd li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh ni nj lx nk bi translated">功能— TensorFlow 版本 0.6.0</h1><p id="3c61" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">众所周知，Apache Spark 是一个大规模数据分析平台，与 TensorFlow 一起，我们得到了 TensorFrames，其中包含三类数据操作:</p><p id="de54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来了解一下每个功能。</p><pre class="lb lc ld le gt np no nq nr aw ns bi"><span id="a52f" class="lg lh it no b gy nt nu l nv nw">-1- Mapping</span></pre><p id="3373" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">映射操作将列转换和/或添加到给定的数据帧中。</p><p id="1fee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个功能都通过两个 API 来访问，一个接收 Operation，另一个接收 DataFrame、GraphDef 和 ShapeDescription。</p><p id="8942" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">公开的 API:</p><h2 id="82df" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">映射行</h2><p id="9217" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated"><code class="fe nl nm nn no b">def mapRows(o0: Operation, os: Operation*): DataFrame</code></p><p id="46c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于用户来说，这是更常用的函数，因为没有创建 GraphDef 和 ShapeDescription 对象的直接请求。对于有经验的 TensorFlow 开发人员来说，这种方式更具可读性:</p><p id="97a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mapRows 接收两个参数 operation 和 operation*，这意味着第二个操作可以是操作的集合。随后，它将它们转换成一个序列，并将其转换成一个图形，它从图形中创建 ShapeDiscription，并将其与数据帧一起发送给一个内部函数。其中它根据图中给出的变换逐行变换分布式数据。图中的所有输入都应该用给定数据帧或常数中的一些数据填充。意思是，我们不能用 null。最后，该函数返回一个带有新模式的新数据帧，该模式将包含原始模式<strong class="kd iu">以及与图形输出相对应的</strong>新列。ShapeDiscription 提供了输出的形状，它在幕后用于优化和绕过内核的限制。</p><h2 id="3d1d" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">地图块</h2><p id="bd8b" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">执行与<code class="fe nl nm nn no b">MapRows</code>类似的任务，但是，因为它是针对压缩优化的，所以它在数据块中应用图形转换器，而不是逐行应用。</p><p id="58d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn no b">def mapBlocks(o0: Operation, os: Operation*): DataFrame</code></p><p id="d8ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经常使用的函数是:</p><p id="48f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码示例:我们创建类型为 DataFrame 的<em class="ms"> val df </em>，有两行，一行包含值 1.0，第二行包含值 2.0。列名是 x。</p><p id="18eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ms"> val x </em>是输出占位符的声明，<em class="ms"> y </em>是从 CPU 到 GPU 或从机器到机器传输张量的标识，它接收<em class="ms"> val x </em>作为它的值。</p><p id="1ece" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ms"> z </em>是计算函数本身。这里，<code class="fe nl nm nn no b">df.MapBlock</code> functions 得到两个操作，<em class="ms"> y </em>和<em class="ms"> z </em>，并返回一个名为<em class="ms"> df2 </em>的新数据帧，多了一列<em class="ms"> z </em>。<em class="ms"> z </em>列是输出中的<em class="ms"> x+x. </em>之和，<em class="ms">列 x </em>是原始值，<em class="ms">列 y </em>是相同值，<em class="ms">列 z </em>是图形的输出。</p><h2 id="d020" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">地图区块规划</h2><p id="ea4c" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">这与<code class="fe nl nm nn no b">MapBlock</code>相同，但是，它从结果数据帧中删除了原始数据帧列。这意味着输出数据帧将只包含计算出的列。</p><p id="a09a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn no b">def mapBlocksTrimmed(o0: Operation, os: Operation*): DataFrame</code></p><p id="1031" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看:</p><p id="b336" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码示例:我们创建一个名为<em class="ms"> df </em>的 DataFrame，其中两行的值分别为 3.0 和 4.0。<strong class="kd iu">注意</strong>我们创建了一个名为<em class="ms"> out </em>的常数，值为 1.0 和 2.0，这个常数是 TensorFrame dsl 功能，模拟 TensorFlow 功能。然后我们叫<code class="fe nl nm nn no b">df.MapBlocksTrimmed</code>。输出模式将只包含名为“out”的结果列，在我们的例子中，它只包含常量值 1.0 和 2.0。</p><p id="e527" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">重要提示</strong>在第一行代码中，我们导入 TesnorFrames dsl，并将其命名为 tf，代表 TensorFlow，我们这样做是因为这是 TesnorFlow 用户过去使用它的方式，并且我们坚持 TensorFlow 的最佳实践。</p><pre class="lb lc ld le gt np no nq nr aw ns bi"><span id="d7de" class="lg lh it no b gy nt nu l nv nw">-2- Reducing</span></pre><p id="8b21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">归约操作合并一对或一组行，并将它们转换成一行，然后重复相同的操作，直到剩下一行。在幕后，TensorFrames 通过首先减少每台计算机上的所有行，然后通过网络发送剩余的行来执行最后的减少，从而最大限度地减少了计算机之间的数据传输。</p><p id="6019" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn no b">f(f(a, b), c) == f(a, f(b, c))</code></p><p id="595d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">transforms 函数必须被归类为<a class="ae kz" href="https://en.wikipedia.org/wiki/Morphism" rel="noopener ugc nofollow" target="_blank">态射</a>:它们完成的顺序并不重要。在数学术语中，给定一些函数<code class="fe nl nm nn no b">f</code>和一些函数输入<code class="fe nl nm nn no b">a</code>、<code class="fe nl nm nn no b">b</code>、<code class="fe nl nm nn no b">c</code>，以下必须成立:</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/6f466f6eec24f3b23fe54129d72cf34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HVRLXNzSYxrrGBQc.png"/></div></div></figure><p id="8db7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过<a class="ae kz" href="https://www.researchgate.net/profile/Christopher_Scherb" rel="noopener ugc nofollow" target="_blank"> Christopher Scherb </a>映射 reduce 模式</p><p id="1978" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reduce 功能 API，和其他的一样，我们每个功能有 2 个 API，接收操作的那个更直观，但是在 TensorFlow 中没有直接的 reduce rows 操作，而是有很多 reduce 操作，比如<code class="fe nl nm nn no b">tf.math.reduce_sum</code>和<code class="fe nl nm nn no b">tf.reduce_sum</code>。</p><h2 id="f9d7" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">减少行数</h2><p id="0426" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">该功能使用 TensorFlow 操作将两行合并在一起，直到剩下一行。它接收数据图表、图形和形状描述。</p><p id="3d6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn no b">def reduceRows(o0: Operation, os: Operation*): Row</code></p><p id="3116" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用户界面:</p><p id="3d07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一个代码示例中。我们创建一个 DataFrame，在中有一个名为<em class="ms">的列和两行。dtype 和 x 的占位符 x1 和 x2——这是 x1 和 x2 的加法运算。reduceRows，返回一个值为 3 的行，该值为 1.0 和 2.0 之和。</em></p><h2 id="41e3" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">减少块</h2><p id="af9e" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">与<code class="fe nl nm nn no b">ReduceRows</code>的工作原理相同，但是，它是在行的向量上工作，而不是逐行工作。</p><p id="942e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn no b">def reduceBlocks(o0: Operation, os: Operation*): Row</code></p><p id="07ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更多使用的功能:</p><p id="eed7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码示例:这里我们创建一个包含两列的 data frame—<em class="ms">key 2</em>和<em class="ms"> x </em>。一个占位符名为<em class="ms"> x1 </em>，一个 reduce_sum 张量流操作名为<em class="ms"> x </em>。reduce 功能根据 reduce_sum 以其命名的所需列返回 DataFrame 中各行的总和，即<em class="ms"> x </em>。</p><pre class="lb lc ld le gt np no nq nr aw ns bi"><span id="e8b2" class="lg lh it no b gy nt nu l nv nw">-3- Aggregation</span></pre><p id="d3f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn no b">def aggregate(data: RelationalGroupedDataset, graph: GraphDef, shapeHints: ShapeDescription): DataFrame</code></p><p id="c7c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">聚合是 Apache Spark 和 TensorFlow 的额外操作。它不同于 TensorFlow 中的聚合功能，使用 RelationalGroupedDataset。API 功能:</p><p id="aea7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Aggregate 接收一个 RelationalGroupedDataset，这是一个 Apache Spark 对象，它包装数据帧并添加聚合功能、一系列表达式和一个组类型。</p><p id="4efa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">聚合函数接收图形和 ShareDescriptiom。它使用分组数据的归约变换将行聚合在一起。当数据已经按键分组时，这很有用。目前，只支持数字数据。</p><p id="6786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码示例:在这个示例中，我们有一个包含两列的 DataFrame，<em class="ms"> key </em>和<em class="ms"> x </em>。<em class="ms"> x1 </em>作为占位符，<em class="ms"> x </em>作为名为<em class="ms"> x </em>的 reduce_sum 功能。</p><p id="2363" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="ms"> groupby </em>功能，我们按键对行进行分组，之后，我们用操作调用<em class="ms"> aggregate </em>。我们可以在输出中看到，聚合是根据<em class="ms">键</em>计算的，对于值为 1 的键，我们接收 2.1 作为<em class="ms">列 x </em>的值，对于值为 2 的键，我们接收 2.0 作为<em class="ms">列 x </em>的值。</p><h1 id="be3d" class="mu lh it bd li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh ni nj lx nk bi translated">张量框架基本过程</h1><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/895f85189044c9833166156b1210d6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/0*AMdUqo5WZz93E-dj.png"/></div></figure><p id="3f89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在所有 TensorFrames 功能中，数据帧与计算图一起发送。DataFrame 表示分布式数据，这意味着在每台机器上都有一大块数据要经过图形操作/转换。这将发生在每台有相关数据的机器上。钨二进制格式是经过转换的实际二进制内存数据，首先转换到 Apache Spark Java 对象，然后从那里发送到 TensorFlow Jave API 进行图形计算。这都发生在 Spark worker 进程中，Spark Worker 进程可以旋转许多任务，这意味着在内存数据上同时进行各种计算。</p><h1 id="1713" class="mu lh it bd li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh ni nj lx nk bi translated">值得注意的</h1><ul class=""><li id="1620" class="me mf it kd b ke lz ki ma km nz kq oa ku ob ky mj mk ml mm bi translated">scala 的 DataFrames 目前是 T21 的一个实验版本。</li><li id="9300" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">Scala DSL 只有张量流变换的一个子集。</li><li id="0ead" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">TensorFrames 是开源的，可以支持<a class="ae kz" href="https://github.com/databricks/tensorframes" rel="noopener ugc nofollow" target="_blank">这里</a>。</li><li id="3f94" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">Python 是 TensorFlow 支持的第一种客户端语言，目前支持大多数特性。越来越多的功能被转移到 TensorFlow 的核心(用 C++实现)，并通过 C API 公开。后来通过其他语言 API，如 Java 和 JavaScript 公开。</li><li id="8c8f" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">有兴趣与 Keras 合作吗？查看<a class="ae kz" href="https://github.com/maxpumperla/elephas" rel="noopener ugc nofollow" target="_blank"> Elephas:使用 Keras &amp; Spark </a>的分布式深度学习。</li><li id="8e2f" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">对公共云上的 TensorFrames 项目感兴趣？检查<a class="ae kz" href="https://docs.microsoft.com/en-us/learn/paths/azure-fundamentals/?WT.mc_id=devto-blog-adpolak" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae kz" rel="noopener" target="_blank" href="/get-started-with-apache-spark-and-tensorflow-on-azure-databricks-163eb3fdb8f3">这个</a>。</li></ul><p id="bcab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">现在你对 TensorFrames 有了更多的了解，你将如何推进它？</strong></p><p id="cc46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" href="https://twitter.com/AdiPolak" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很乐意接受您的话题建议。</p></div></div>    
</body>
</html>