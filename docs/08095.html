<html>
<head>
<title>Next Better Player? GBDT + LR for Binary Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一个更好的玩家？用于二元分类的 GBDT + LR</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/next-better-player-gbdt-lr-for-binary-classification-f8dc6f32628e?source=collection_archive---------18-----------------------#2019-11-06">https://towardsdatascience.com/next-better-player-gbdt-lr-for-binary-classification-f8dc6f32628e?source=collection_archive---------18-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dbfe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">另一种有效的叠加预测算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2f57d560b8f0a99578cde11720d4594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dt9Lv8HQk4aDjmnl"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Clarke Quay @ Singapore</figcaption></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><blockquote class="lf lg lh"><p id="b7c9" class="li lj lk ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">例如，具有逻辑回归的堆积梯度推进决策树(GBDT)在解决二元分类问题时可以是非常有效的算法。CTR 预测。</p></blockquote></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="738d" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">从 2014 年发布的论文<a class="ae mi" href="https://www.semanticscholar.org/paper/Practical-Lessons-from-Predicting-Clicks-on-Ads-at-He-Pan/daf9ed5dc6c6bad5367d7fd8561527da30e9b8dd" rel="noopener ugc nofollow" target="_blank">脸书</a>预测广告点击的实践经验中，脸书通过结合决策树和逻辑回归为他们的点击预测系统引入了这种算法。该算法将系统性能提高了 3%，对在线业务产生了重大影响。</p><p id="c39a" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">在本文中，我将介绍以下议程:</p><ul class=""><li id="bf0c" class="mj mk it ll b lm ln lp lq mf ml mg mm mh mn me mo mp mq mr bi translated">算法解释</li><li id="cb4a" class="mj mk it ll b lm ms lp mt mf mu mg mv mh mw me mo mp mq mr bi translated">使用<a class="ae mi" href="https://archive.ics.uci.edu/ml/datasets/Credit+Approval" rel="noopener ugc nofollow" target="_blank">信用审批</a>数据集的 Python 实现</li><li id="759c" class="mj mk it ll b lm ms lp mt mf mu mg mv mh mw me mo mp mq mr bi translated">RAM 问题和潜在解决方案</li></ul><p id="6c36" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">我们开始吧！</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="a59f" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">算法解释</h1><p id="0e4a" class="pw-post-body-paragraph li lj it ll b lm np ju lo lp nq jx lr mf nr lu lv mg ns ly lz mh nt mc md me im bi translated">GBDT 和逻辑回归都是众所周知的分类模型。GBDT-LR 算法通过将每棵树的预测叶节点的索引作为线性分类器逻辑回归的稀疏输入来组合这两个模型。</p><p id="0f26" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">让我们假设我们已经训练和调整了一个有 300 棵树的 GBDT 模型，每棵树有 3 个叶节点。第二步是使用该模型再次对训练数据集进行预测。然而，不是输出标签，而是为 300 棵树中的每一棵树返回预测叶节点的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/0c17f504142f633a7d62e86b29d858b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jC5T3FeI_X8Zwa-rbf8cfg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">GBDT output prediction leaf node index</figcaption></figure><p id="bcd0" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">在上面的示例中，第一棵树返回 3，因为预测是在第三个叶节点上。同样，第二棵树返回 2，最后一棵树返回 1。GBDT 模型的输出将看起来像[3，2，…]。,1].由于模型包含 300 棵树，这个列表应该有 300 个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ad9b4beaa64b9f1847315f996e526abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivIuVXL7JpnJx83DqWI9GQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">One-hot encode GBDT output</figcaption></figure><p id="4f3a" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">接下来，列表中的每个数字都被一键编码。比如 3 变成[0，0，1]，2 变成[0，1，0]，1 变成[1，0，0]。这些一键列表被附加在一起以形成逻辑回归模型的输入。因为每棵树包含 3 个叶节点，所以最终的列表应该有 300 * 3 个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/0bce2ac99e3d9d6ff8bca2f5f5accf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzLBOdDH0ypuY0Ez8p9nKA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Overall Structure</figcaption></figure><p id="992f" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">现在，我们已经成功地为逻辑回归构建了训练数据集。很明显，输入数据非常稀疏。因此，L1 正则化用于解决这个问题，并避免过度拟合。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="4738" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">Python 实现</h1><p id="eac2" class="pw-post-body-paragraph li lj it ll b lm np ju lo lp nq jx lr mf nr lu lv mg ns ly lz mh nt mc md me im bi translated">让我们用 UCI <a class="ae mi" href="https://archive.ics.uci.edu/ml/datasets/Credit+Approval" rel="noopener ugc nofollow" target="_blank">信用审批</a>数据集来看一下 Python 的实现。<a class="ae mi" href="https://gist.github.com/ianforme/6459aefb61323c529a51026e2e50bc5f" rel="noopener ugc nofollow" target="_blank">源代码</a>可用。数据集包含 15 个不同的标称和序数特征(A1 至 A15)以及一个二元目标标签(A16)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/224f09d9c300dc39fbb7e76c9b9775bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*I9K4y_GeD-9o7gWhdf9g3w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Data Glance</figcaption></figure><p id="fbde" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">为了快速处理数据，丢失值的记录将被删除。分类特征是一次性编码的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/e7ab4e3b04d1589626df8b44575674fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2w85oMmEb2Zhh6TwiZGDRg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Quick Data Processing</figcaption></figure><p id="b873" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">首先，让我们训练一个 GBDT 和一个逻辑回归模型用于基准测试。对于 GBDT，网格搜索用于寻找最优参数。选择 ROCAUC 分数作为评估标准。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/685429f01e1cfff33284c3dc66bca5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*JUvqV1iXodr2WkxfSNH_4Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Benchmark Models</figcaption></figure><p id="a636" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">从上面的脚本可以看出，我使用 lightgbm 来训练 GBDT 模型。Lightgbm 分类器适用于该算法，因为我们可以通过调整“num_leaves”参数来指定每棵树中的叶节点数。树的数量由“n_estimators”控制。</p><p id="df9d" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">接下来，我们将使用经过训练的 GBDT 模型对训练和测试数据进行预测。将“pred”函数中的“pred_leaf”设置为 True，以输出每棵树的预测叶节点的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fd86c92930b8950e44759294f7241941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*akECMNiRpHuuDCOrOy6WDw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Output Prediction Leaf Node Index</figcaption></figure><p id="c367" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">最后，我们需要将 GBDT 输出转换为独热格式，并使用稀疏数据来训练具有 L1 正则化的逻辑回归。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/16f1531236dcfa956cd2468d61b6e428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*FJVjJ_AW2picpPkxfjkF-g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">GBDT-LR Performance</figcaption></figure><p id="25b8" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">嘣！GBDT-LR 算法实现了 0.86 的 ROCAUC 分数，这优于基线 GBDT (0.83)和 LR (0.82)模型。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="9205" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">RAM 问题</h1><p id="aa73" class="pw-post-body-paragraph li lj it ll b lm np ju lo lp nq jx lr mf nr lu lv mg ns ly lz mh nt mc md me im bi translated">到目前为止，一切看起来都很好，对吗？然而，这个数据集非常小。处理后只包含 653 条记录。因此，我们正在训练只有 20 个叶节点的小树。想象一下，在 GBDT 模型中，我们有一个更大的数据集，包含更多的要素，需要更多的叶节点和更多的树，这种一次性编码的输出可能非常巨大。</p><p id="dabc" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">矩阵的大小可以通过<em class="lk">记录数*叶节点数*树数</em>来计算。在解决复杂问题时，我们需要小心处理这个矩阵。一个潜在的解决方案是将该矩阵转换成稀疏矩阵对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/fab8691c8656872cca318835b4dd486f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z97K5zROtq_F47aB-gc05A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Use of Sparse Matrix</figcaption></figure><p id="0e07" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">注意，通过将独热矩阵转换成稀疏矩阵，RAM 使用从 4，272 字节减少到 56 字节。然而，随着处理时间从 419 毫秒增加到 898 毫秒，这个技巧给 CPU 计算带来了更多的负担。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="8ed9" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结束注释</h1><p id="f808" class="pw-post-body-paragraph li lj it ll b lm np ju lo lp nq jx lr mf nr lu lv mg ns ly lz mh nt mc md me im bi translated">同样，上面用作示例代码在@ <a class="ae mi" href="https://gist.github.com/ianforme/6459aefb61323c529a51026e2e50bc5f" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p><p id="9407" class="pw-post-body-paragraph li lj it ll b lm ln ju lo lp lq jx lr mf lt lu lv mg lx ly lz mh mb mc md me im bi translated">感谢阅读！</p></div></div>    
</body>
</html>