<html>
<head>
<title>Predicting Click through rate for a website</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测网站的点击率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-click-through-rate-for-a-website-7cd2a892d26e?source=collection_archive---------4-----------------------#2019-06-20">https://towardsdatascience.com/predicting-click-through-rate-for-a-website-7cd2a892d26e?source=collection_archive---------4-----------------------#2019-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a200" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一个二元分类项目，根据给定的特征预测用户是否会在网站上申请。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34b1d8dea50f9e87c7f1d9c8276e9431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ER4Vw9mP22dCo3cLhuJfGw.png"/></div></div></figure><h1 id="ddac" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="da16" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">想象一个用户访问一个网站，并执行工作搜索。从显示的结果集合中，用户点击他/她感兴趣的某些结果，并且在检查工作描述之后，她进一步点击其中的应用按钮以进入应用页面。申请率被定义为申请的分数(在访问职位描述页面后)，目标是使用下一节中描述的数据集来预测此指标。</p><p id="1867" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这篇文章将为任何机器学习新手提供完整的指南。我的目标是为您提供一个应用机器学习的端到端蓝图，同时尽可能保持它的可操作性和简洁。</p><h1 id="747e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">蓝图</h1><ol class=""><li id="6b14" class="mn mo it lo b lp lq ls lt lv mp lz mq md mr mh ms mt mu mv bi translated"><strong class="lo iu">数据收集</strong></li><li id="b645" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">探索性数据分析</strong> —首先，“了解”数据。这一步应该快速、高效、果断。</li><li id="22aa" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">数据清理</strong>——然后，清理你的数据以避免许多常见的陷阱。更好的数据胜过更好的算法。</li><li id="e8d6" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">功能工程</strong> —接下来，通过创建新功能来帮助您的算法“专注于”重要的东西。</li><li id="a670" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">算法选择</strong> —选择最佳、最合适的算法，不浪费您的时间</li><li id="f0ac" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">模型训练和调优</strong> —最后，训练你的模型。一旦你完成了前 5 步，这一步就相当公式化了</li><li id="f067" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">洞察力</strong> —最终将推动业务发展的最终结果</li></ol><h1 id="2da3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">数据收集和问题描述</h1><p id="17cd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可以从<a class="ae nb" href="https://github.com/animeshgoyal9/Data_Challenge_2" rel="noopener ugc nofollow" target="_blank">这里</a>下载数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/50e465b64ba58069ab8b8cdab8bdecbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sf0em0-ydTvwdRe0S74e4A.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Dataset</figcaption></figure><p id="4849" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">数据集中的每一行都对应于一个职务列表的用户视图。它有 10 列，如下所述。<br/> 1。职位接近度 tf idf:衡量查询和职位的接近度。<br/> 2。描述接近度 tf idf:衡量查询和工作描述的接近度。<br/> 3。主查询 tf idf:与用户查询与职位名称和职位描述的接近程度相关的分数。<br/> 4。查询 jl 得分:衡量查询和职务列表对的流行程度。<br/> 5。查询职称得分:衡量查询和职称对的受欢迎程度。<br/> 6。城市匹配:指明职务列表是否与用户(或用户指定的)位置匹配。7。职务年龄天数:指明已发布职务列表的年龄。8。申请:指明用户是否已申请此职务列表。9。太平洋搜索日期:活动日期。10。类别 id:单击的职位的类别 ID。</p><p id="3e22" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个问题有两个部分。</p><ol class=""><li id="e450" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">我们必须只关注前 7 列，并使用这些功能来预测有多少用户申请该网站。</li><li id="e2e2" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">我们必须考虑将最后一列添加到特征集(“类 id”)，并检查分类性能是否提高。</li></ol><h1 id="3554" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">探索性数据分析</h1><p id="b724" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">探索性分析的目的是<strong class="lo iu">“了解”</strong>数据集。预先这样做将使项目的其余部分更加顺利，主要有三个方面:</p><ol class=""><li id="0aa5" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">您将获得关于数据清理的有价值的提示(这将决定您的模型的成败)。</li><li id="20d6" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">你会想到特征工程的想法(可以让你的模型从好变得更好)。</li><li id="6958" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">您将获得对数据集的“感觉”，这将有助于您交流结果并产生更大的影响。</li></ol><p id="2293" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是，机器学习的探索性分析应该是<strong class="lo iu">快速、高效、果断</strong> …而不是冗长！</p><p id="f425" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">不要跳过这一步，但也不要在这一步上卡住。</p><p id="d232" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你看，有无限可能的图、图表和表格，但是你只需要一把<strong class="lo iu">的</strong>来“了解”足够好的数据来使用它。</p><p id="1263" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这一步中，我们将向您展示为您的投资带来最大收益的可视化效果。</p><h2 id="b62a" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">从基础开始</h2><p id="2401" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，您需要回答一组关于数据集的基本问题:</p><ul class=""><li id="f97b" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh nw mt mu mv bi translated">我有多少观察值？</li><li id="cb5a" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">有多少功能？</li><li id="a213" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">我的要素的数据类型是什么？它们是数字吗？绝对的？</li><li id="48ae" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">我有目标变量吗？</li></ul><p id="a87a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该数据集总共包含 1200890 个观察值，其中 789586 个观察值是在 2018 年 1 月 21 日至 2018 年 1 月 26 日之间收集的，而其余的观察值是在 2018 年 1 月 27 日收集的。总共有 9 个特性和 1 个目标变量(“应用”)。没有明确的特征。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/22436af7cc05eaa035442f05fb61d487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P93J6iUDA7v2w9TKDxwS2g.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Dataset info</figcaption></figure><h2 id="9faf" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">缺少值</h2><p id="328f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">接下来，我们可以检查数据集中有多少缺失值。从上表可以清楚地看出，标题邻近 tfidf、描述邻近 tfidf 和城市匹配包含空值。</p><h2 id="6ee3" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">类别分布</h2><p id="6fd5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">由于该数据集是关于有多少访问网站的客户点击应用，它可能不是很多，我们可以假设这将是一个不平衡的数据。让我们看看我们是否正确。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/df7edea170d2fd10df5af854292aff52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wlss4pJXpSYgJaX0OxrsXw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Data Distribution (1 = Apply, 0 = Not Apply)</figcaption></figure><p id="25e5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以看到，这种分布确实是不平衡的。为了处理这种情况，有各种技术，如欠采样、过采样、SMOTE，使用 AUC 等指标。但这些将在以后讨论。</p><h2 id="429b" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">数据描述</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c9cd476416260ea9faf352709ec6e728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uc3PnA71jnVXaBs_nCNsGA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Data Description</figcaption></figure><p id="193f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">以下是该表中的观察结果:</p><ol class=""><li id="359b" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">大多数预测值的 75%瓦片和最大值之间存在显著差异。</li><li id="421f" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">' title_proximity_tfidf '，' description_proximity_tfidf '，' main_query_tfidf '，' query_jl_score '，' query_title_score '，' job_age_days '的中值低于平均值</li><li id="bd12" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">因此，观察值 1 和 2 表明数据中存在大量异常值</li></ol><h2 id="b921" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">相互关系</h2><p id="cc54" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">相关性允许您查看数字特征和其他数字特征之间的<em class="oa">关系。</em></p><p id="9bea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">相关性是一个介于-1 和 1 之间的值，表示两个要素协调移动的程度。你不需要记住数学来计算它们。只要知道以下直觉:</p><ol class=""><li id="f044" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated"><strong class="lo iu">正</strong>相关意味着随着一个特征的增加，另一个特征也增加。例如孩子的年龄和身高。</li><li id="dce8" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">负</strong>相关性意味着一个特征增加，另一个特征减少。例如花在学习上的时间和参加的聚会。</li><li id="8da4" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">接近-1 或 1 的相关性表示<strong class="lo iu">强关系</strong>。</li><li id="5715" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">那些接近 0 的表示弱关系。</li><li id="86c2" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">0 表示<strong class="lo iu">没有关系</strong></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0dfbf4e0c05dc0b23f156685b6837ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9tD7fzWdd4Gg4sDT3antw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Correlation between variables</figcaption></figure><p id="b598" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">大多数特征彼此之间并不高度相关。仅有的两个具有某种相关性的特征是主查询 tfidf 和标题接近度 tfidf(大约 0.8)。</p><h2 id="75ac" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">极端值</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/196e125194832c0baa794a142f36a00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PZirGTuWijeZ_HboPJWrTQ.jpeg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Outliers</figcaption></figure><p id="31f0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">探索性数据分析中最重要的步骤之一是异常值检测和处理。机器学习算法对数据点的范围和分布非常敏感。数据异常值会欺骗训练过程，导致训练时间更长，模型更不准确。离群值被定义为与剩余数据显著不同的样本。这些点位于分布的整体模式之外。均值、方差和相关性等统计指标很容易受到异常值的影响。</p><p id="9221" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="oa">异常值的性质:</em></p><p id="441d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于以下原因之一，数据集中可能会出现异常值，</p><ol class=""><li id="b57a" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">数据集中真正的极高值和极低值</li><li id="a7ad" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">由于人为或机械错误而引入</li><li id="9ec0" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">通过替换缺失值引入</li></ol><p id="b981" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="oa">异常值检测</em></p><ul class=""><li id="497e" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh nw mt mu mv bi translated">极值分析</li><li id="38ea" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">z 分数法</li><li id="dc98" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">k 表示基于聚类的方法</li><li id="5695" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">可视化数据</li><li id="063b" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">箱线图</li></ul><p id="7e6c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="oa">异常值处理</em></p><ul class=""><li id="9ad8" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh nw mt mu mv bi translated">均值/中值或随机插补</li><li id="70f5" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">整理</li><li id="b54d" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">顶部、底部和零编码</li><li id="0d95" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">[数]离散化</li></ul><p id="a832" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，在本文中，我将使用箱线图方法检测异常值。如果您想深入了解如何检测和处理异常值，请参考这篇<a class="ae nb" href="https://medium.com/@swethalakshmanan14/outlier-detection-and-treatment-a-beginners-guide-c44af0699754" rel="noopener">文章</a>。箱线图也称为晶须图，是一种图形方法，通常用四分位数和四分位数间距来描述，有助于定义上限和下限，超出上限和下限的任何数据都将被视为异常值。</p><p id="3a42" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">简而言之，分位数是分布中与该分布中值的等级顺序相关的点。对于给定的样本，您可以通过对样本进行排序来找到任何分位数。排序样本的中间值是中间分位数或第 50 个百分位数(也称为样本的中位数)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3310591ddd87538ba540d1eb202bc399.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*xeXADJpjhTyK6S9tYc8New.png"/></div></figure><p id="1351" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是我们数据集的箱线图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/de71cf36c92b5a1ba501014f9537f3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yD5CNTRHgJ-MPAOEHgqSrg.png"/></div></div></figure><p id="4517" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如您所见，数据集中有许多异常值。删除它们可能会导致重要信息的丢失。</p><h1 id="a57e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">数据清理</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c3b281d2055ed10ec1d27e79932ad5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOcUoH-Wc0OGeaRGUa-qnw.jpeg"/></div></div></figure><p id="593a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">数据清理是每个人都在做但没有人真正谈论的事情之一。当然，这不是机器学习中“最性感”的部分。不，没有隐藏的技巧和秘密要揭开。</p><p id="d7b0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，适当的数据清理可以成就或破坏您的项目。专业数据科学家通常会在这一步花费大量时间。</p><p id="2222" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为什么？因为机器学习中一个简单的道理:</p><blockquote class="og"><p id="30bd" class="oh oi it bd oj ok ol om on oo op mh dk translated">更好的数据胜过更好的算法。</p></blockquote><p id="d408" class="pw-post-body-paragraph lm ln it lo b lp or ju lr ls os jx lu lv ot lx ly lz ou mb mc md ov mf mg mh im bi translated">换句话说……垃圾进来，垃圾出去。即使你忘记了本课程的其他内容，请记住这一点。</p><p id="e8bf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">事实上，如果您有一个适当清理的数据集，即使简单的算法也可以从数据中获得令人印象深刻的见解！</p><p id="035e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">显然，不同类型的数据需要不同类型的清理。然而，本文中介绍的系统化方法总是可以作为一个很好的起点。</p><h2 id="1395" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">移除不需要的观察</h2><p id="cc00" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">数据清理的第一步是从数据集中移除不需要的观测值。这包括<strong class="lo iu">重复的</strong>或<strong class="lo iu">不相关的</strong>观察值。我们的数据集包含相当多的重复条目，这些条目将被删除。</p><h2 id="4b12" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">处理缺失值</h2><p id="93db" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在应用机器学习中，缺失数据是一个看似棘手的问题。</p><p id="ba9b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，明确一点，<strong class="lo iu"> <em class="oa">你不能简单地忽略数据集中的缺失值</em>。你必须以某种方式处理它们，因为大多数算法不接受缺失值。</strong></p><blockquote class="og"><p id="f5bf" class="oh oi it bd oj ok ol om on oo op mh dk translated"><strong class="ak">“常识”在这里是不理智的</strong></p></blockquote><p id="d488" class="pw-post-body-paragraph lm ln it lo b lp or ju lr ls os jx lu lv ot lx ly lz ou mb mc md ov mf mg mh im bi translated">以下是处理缺失数据的最常用方法:</p><ol class=""><li id="b66f" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">删除有缺失值的<strong class="lo iu"> </strong>观察值</li><li id="9af2" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">输入<strong class="lo iu"> </strong>基于其他观察的缺失值</li><li id="8495" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">插值和外推</li><li id="65bd" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">使用 KNN</li><li id="d18b" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">均值/中位数插补</li><li id="addf" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">回归插补</li><li id="cd23" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">随机回归插补</li><li id="1d49" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">热卡插补</li></ol><p id="7a4f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你想更详细地了解他们，请参考这篇<a class="ae nb" rel="noopener" target="_blank" href="/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779">文章</a>。在我们的例子中，两个特征(标题邻近 tfidf 和描述邻近 tfidf)主要包含 0，因此我将用 0 替换缺少的值。对于城市匹配特征，1 和 0 分布几乎相等。在这里，我可以选择删除包含 null 的值，或者使用 mean 替换。我已经删除了这种情况下的值。</p><h1 id="f978" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">特征工程</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/a6190260575824806c0dba87d308623f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCc7n28VDcToEmGryqzV-Q.png"/></div></div></figure><p id="f0c6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">特征工程是关于<em class="oa">从现有的输入特征中创建新的输入特征</em>。</p><p id="b014" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一般来说，你可以把数据清理看成是一个减法的过程，把特征工程看成是一个加法的过程。</p><p id="0579" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这通常是数据科学家为提高模型性能所能做的最有价值的任务之一，原因有三:</p><ol class=""><li id="5a74" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">您可以隔离并突出显示关键信息，这有助于您的算法“专注于”重要的内容。</li><li id="9454" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">可以自带<strong class="lo iu"> <em class="oa">领域专长</em> </strong> <em class="oa">。</em></li><li id="986f" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">最重要的是，一旦你理解了特性工程的“词汇表”，你就可以引入其他人的领域专长！</li></ol><p id="ff26" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">以下是我们可以执行特征工程的一些方法，但是请注意，这并不是所有特征工程的详尽概要，因为这个步骤有无限的可能性。好消息是，随着你获得更多的经验，这项技能自然会提高。</p><ol class=""><li id="6648" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">注入领域知识</li><li id="b818" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">创建交互式功能</li><li id="b1dc" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">组合稀疏类</li><li id="7717" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">添加虚拟变量</li><li id="7489" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">移除未使用的功能</li></ol><p id="1242" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们的例子中，由于没有太多关于数据集的领域知识，我们在特征工程的应用中受到限制。我应用的唯一特征工程是将两个相关的特征(title_proximity_tfid 和 main_query_tfidf)相乘，以创建一个名为 main title tfidf 的新列。</p><h1 id="74a1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">算法选择</h1><p id="cc29" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">影响模型选择的一些因素有:</p><ol class=""><li id="2a24" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">模型是否满足业务目标</li><li id="ec86" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">模型需要多少预处理</li><li id="167a" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">模型有多精确</li><li id="12bd" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">这个模型的解释力有多强</li><li id="6446" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">模型有多快:建立模型需要多长时间，模型做预测需要多长时间。</li><li id="1c33" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">模型的可伸缩性如何</li></ol><p id="4aad" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">影响算法选择的一个重要标准是模型复杂度。一般来说，较复杂的模型是:</p><ol class=""><li id="7080" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">它依赖于更多的特征来学习和预测(例如，使用两个特征对十个特征来预测目标)</li><li id="a14a" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">它依赖于更复杂的特征工程(例如，使用多项式、相互作用或主成分)</li><li id="f5f7" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">它有更多的计算开销(例如，单个决策树与 100 棵树的随机森林相比)。</li></ol><p id="b7f5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">除此之外，基于参数的数量或一些超参数的选择，相同的机器学习算法可以变得更加复杂。举个例子，</p><ol class=""><li id="1940" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">一个回归模型可以有更多的特征，或者多项式项和交互项。</li><li id="8c95" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">决策树可以有或多或少的深度。</li></ol><p id="7f2e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使相同的算法更复杂会增加过度拟合的机会。</p><h2 id="3c7d" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated"><strong class="ak">用于分类的常用机器学习算法</strong></h2><p id="4c50" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu"> <em class="oa">逻辑回归</em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/0daa9da38d588454a23cfbe10b5b3c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdlMczIMQvSVDd1gQg8dRA.png"/></div></div></figure><p id="a5cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">逻辑回归模型符合一条“直线”。实际上，他们很少表现良好。对于大多数机器学习问题，我们实际上建议跳过它们。</p><p id="de70" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它们的主要优点是易于解释和理解。但是，我们的目标不是研究数据，写研究报告。我们的目标是建立一个可以做出准确预测的模型。</p><p id="ff46" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这方面，逻辑回归有两个主要缺陷:</p><ol class=""><li id="c137" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated"><strong class="lo iu"> <em class="oa">输入特征多了容易过拟合。</em>T15】</strong></li><li id="b8f8" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu"> <em class="oa">它不能轻易表达非线性关系。</em>T3】</strong></li></ol><p id="4fdf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="oa">正规化</em> </strong></p><p id="da9a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如上所述，逻辑回归遭受过拟合和处理非线性关系的困难。正则化是一种通过人为惩罚模型系数来防止过度拟合的技术。</p><ul class=""><li id="64c7" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh nw mt mu mv bi translated">它可以阻止大系数(通过抑制它们)。</li><li id="b7bc" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">它还可以完全移除要素(通过将它们的系数设置为 0)。</li><li id="3e61" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">惩罚的“力度”是<strong class="lo iu"> <em class="oa">可调</em> </strong>。(明天会有更多相关内容……)</li></ul><p id="5b9d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正则化的类型有套索(L1)、脊(L2)和弹性网(脊和套索的折衷)</p><p id="7e99" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="oa">决策树</em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/5d0886800942e044bca171644ed36146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlFmOh1r8RYqs0qjMKbMVA.png"/></div></div></figure><p id="a6ce" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">决策树将数据建模为分层分支的“树”。它们分支，直到到达代表预测的“叶子”。由于它们的分支结构，决策树可以很容易地模拟非线性关系。</p><p id="9480" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">不幸的是，决策树也有一个重大缺陷。如果你允许他们无限制地增长，他们可以完全“记住”训练数据，只是从创建越来越多的分支开始。因此，单个无约束决策树非常容易过度拟合。​</p><p id="972d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">那么，我们如何利用决策树的灵活性，同时防止它们过度拟合训练数据呢？</p><p id="556a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="oa">树系综</em> </strong></p><p id="3a0a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">集成是用于组合来自多个独立模型的预测的机器学习方法。有几种不同的组装方法，但最常用的两种是:</p><ol class=""><li id="0b9f" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated"><strong class="lo iu">装袋</strong>:试图<em class="oa">减少复杂模型过度拟合的机会</em>。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/25a13c59ecc19c78f786db30e1832a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQ7VcJZCcPMGI_KFi9QMjw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Bagging</figcaption></figure><ul class=""><li id="6fd9" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh nw mt mu mv bi translated">它并行培养了大量的“强”学习者。</li><li id="b87b" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">一个<strong class="lo iu"> <em class="oa">强学习者</em> </strong>是一个相对<em class="oa">无约束</em>的模型。</li><li id="2ac2" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">Bagging 然后将所有强学习者结合在一起，以便“平滑”他们的预测。</li><li id="881e" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">常用的技术是随机森林</li></ul><p id="83cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">2.<strong class="lo iu">助推</strong>:试图<em class="oa">提高简单模型的预测灵活性</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/fc694c13170e0627d1cad010f036b6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QiwIGYmzbnG9pPgBxoNG0A.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Boosting</figcaption></figure><ul class=""><li id="d366" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh nw mt mu mv bi translated">它按顺序训练出大量的“弱”学习者。</li><li id="86bb" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">一个<strong class="lo iu"> <em class="oa">弱学习器</em> </strong> <em class="oa"> </em>是一个<em class="oa">约束</em>模型(即你可以限制每个决策树的最大深度)。</li><li id="5e65" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">序列中的每一个都着重于从之前的错误中学习。</li><li id="bc15" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">然后，Boosting 将所有弱学习者组合成一个强学习者。</li><li id="2a14" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nw mt mu mv bi translated">常用的技术是 XGBoost 和 LightGBM</li></ul><p id="ae4d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">3.<strong class="lo iu"> LightGBM: </strong> Light GBM 是一个使用基于树的学习算法的梯度推进框架。轻型 GBM 垂直生长树<strong class="lo iu"> </strong>而其他算法水平生长树意味着轻型 GBM 逐叶生长<strong class="lo iu"> </strong>而其他算法逐级生长。它会选择 delta 损失最大的叶子来生长。当生长相同的叶子时，逐叶算法可以比逐层算法减少更多的损失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/57718c10aeded87849f716855e79e6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*377wN1hVfoME-0Mopc9upA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">How LightGBM works</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/350e834e35158f3f42a10e8980368251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXyV22fqRvIScGOZi86TRg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">How other boosting algorithm works</figcaption></figure><p id="6099" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还有许多其他算法，如支持向量机、神经网络等。但我们不会在这里接受。</p><p id="a5ee" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于我们的例子，我将使用 XGBoost、Random Forest 和 LightGBM。</p><h1 id="e748" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">模型训练和调整</h1><p id="16d9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">培训模式:2018 年 1 月 21 日至 2018 年 1 月 26 日</p><p id="d2e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">测试型号:2018 年 1 月 27 日</p><p id="6d9d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们将使用的指标是 AUC。我们得到的初始 AUC 值</p><ol class=""><li id="42ee" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">XGBoost: 0.5803</li><li id="ae76" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">LightGBM: 0.5807</li><li id="15da" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">随机森林:0.5806</li></ol><h2 id="28ef" class="nk kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">使用贝叶斯优化的超参数调整</h2><p id="880c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在几乎所有实际情况下，都需要搜索机器学习模型的参数以获得最佳交叉验证性能，从而获得具有最佳泛化估计的模型。scikit-learn 中的一个标准方法是使用 GridSearchCV 类，它为每个要尝试的参数取一组值，并简单地枚举参数值的所有组合。随着新参数的增加，这种搜索的复杂性呈指数增长。一种更可扩展的方法是使用 RandomizedSearchCV，但是它没有利用搜索空间的结构。</p><p id="0db1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Scikit-optimize 为 GridSearchCV 提供了一个替代方案，它利用贝叶斯优化，其中一个称为“代理”的预测模型用于对搜索空间建模，并用于尽快获得良好的参数值组合。</p><p id="1245" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae nb" href="https://en.wikipedia.org/wiki/Bayesian_optimization" rel="noopener ugc nofollow" target="_blank">贝叶斯优化</a>，一种基于模型的寻找函数最小值的方法，最近被应用于机器学习超参数调整，结果表明这种方法可以在测试集上实现更好的性能，同时比随机搜索需要更少的迭代。</p><p id="167d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在应用贝叶斯优化和交叉验证后，AUC 值:</p><ol class=""><li id="4192" class="mn mo it lo b lp mi ls mj lv nh lz ni md nj mh ms mt mu mv bi translated">XGBoost: 0.5819</li><li id="2b21" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">LightGBM: 0.5819</li><li id="c826" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">随机森林:0.5810</li></ol><p id="3cc5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">尽管改进并不显著，但贝叶斯优化器能够以更快的速度执行调优操作。</p><h1 id="71fc" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">堆垛</h1><p id="02e4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">堆叠</strong>是一种集成<strong class="lo iu">学习</strong>技术，通过元分类器或元回归器组合多个分类或回归模型。基于完整的训练集来训练基础级模型，然后在基础级模型的输出上训练元模型作为特征。</p><p id="a227" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基础层通常由不同的学习算法组成，因此堆叠集成通常是异构的。在我们的例子中，我将组合 XGBoost 和 LGBoost 输出，并将使用投票分类器，这是 Scikit-learn 中提供的一个包。</p><p id="2682" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如下图所示，叠加两个输出后，AUC 得分从 0.5819 提高到 0.5848。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/42373bf05de46eedcb923a46e30a0027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7Nf28p5ml09YwwgWvCZpA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">ROC Graph for XGB, LGB, and Stacking</figcaption></figure><h1 id="8cb2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><code class="fe pe pf pg ph b">Insights</code></h1><ol class=""><li id="7841" class="mn mo it lo b lp lq ls lt lv mp lz mq md mr mh ms mt mu mv bi translated">如此低的 AUC 分数 0.5848 可能是由于我们在数据集中没有太多的特征，这使得算法很难正确地对目标变量进行分类。</li></ol><h1 id="ccc0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">待办事项:</h1><ol class=""><li id="c7ef" class="mn mo it lo b lp lq ls lt lv mp lz mq md mr mh ms mt mu mv bi translated">包含最后一列(class_id)以改善结果</li></ol><p id="2b6e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你对代码感兴趣，你可以在这里找到我的笔记本<a class="ae nb" href="https://github.com/animeshgoyal9/Data_Challenge_2" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="bdd4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/detecting-credit-card-fraud-using-machine-learning-a3d83423d3b8"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">利用机器学习检测信用卡欺诈</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">用数据科学抓坏人</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://elitedatascience.com/algorithm-selection" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">第五章:机器学习中的算法选择-数据科学入门</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">在本指南中，我们将向您展示如何在众多选项中选择最有效的机器学习算法…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">elitedatascience.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/automated-machine-learning-hyperparameter-tuning-in-python-dfda59b72f8a"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">Python 中的自动机器学习超参数调整</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">Python 中使用贝叶斯优化进行自动超参数调优的完整演练</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz ks pl"/></div></div></a></div></div></div>    
</body>
</html>