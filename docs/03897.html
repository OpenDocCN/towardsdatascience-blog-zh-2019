<html>
<head>
<title>Elastic Deformation on Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像的弹性变形</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/elastic-deformation-on-images-b00c21327372?source=collection_archive---------16-----------------------#2019-06-19">https://towardsdatascience.com/elastic-deformation-on-images-b00c21327372?source=collection_archive---------16-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3ac3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当前技术发展如此之快，我们的处理能力比以往任何时候都强。我们现在能够保存大量的数据，并对它们进行处理以获得相关信息。然而，即使我们有强大的硬件基础设施，如果我们没有足够的数据来训练我们的算法，我们也无法取得令人满意的结果。数据是 ML 和 DL 问题中最重要的部分。如果我们没有庞大的数据集，这些领域的所有快速发展都是不可能的。</p><p id="3227" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数情况下，我们无法找到大量不同的数据类型，我们需要从现有的数据集创建新的数据集。为此，我们可以应用几种技术和算法。今天，我将主要关注图像数据集。图像用于物体检测、图像分类等几个问题。我们需要训练我们的模型同一对象类型的许多不同版本，以便为将来的目的快速确定它。然而，我们可能没有足够的数据集，这是大多数问题的瓶颈。</p><p id="0705" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我发现了一个非常棒的 Python 库。它被称为“增强器”。它有许多不同的技术来从数据集生成新的图像。Augmentor 真的很快，它每秒可以创建大约 100 张图像。它能自动增强图像。我用 Augmentor 用几种技术来创建手绘的条形图。首先，您可以通过以下方式快速安装 Augmentor</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="8e30" class="kx ky it kt b gy kz la l lb lc">pip install Augmentor</span></pre><p id="4fcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，您需要将它添加到您的项目中，并创建一个管道。流水线只是图像操作的一系列操作。</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="435b" class="kx ky it kt b gy kz la l lb lc">import Augmentor<br/>p = Augmentor.Pipeline('./pathToImages')</span></pre><p id="2b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦实例化了管道对象，就可以向其中添加操作。你可以在这里找到增强器文档。操作示例有:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="5bba" class="kx ky it kt b gy kz la l lb lc">p.rotate(probability=0.7, max_left_rotation=10, max_right_rotation=10) <br/>p.zoom(probability=0.5, min_factor=1.1, max_factor=1.5)</span></pre><p id="445c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个操作都有一个概率值，用于指定一旦图像通过管道，应用该操作的可能性有多大。</p><p id="b60a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想随机应用类似鱼眼的操作，并且不想旋转或缩放以保留一些图像特征，我会推荐这样的管道:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="e7be" class="kx ky it kt b gy kz la l lb lc">p.random_distortion(probability=1, grid_width=3, grid_height=3, magnitude=5)<br/>p.gaussian_distortion(probability=1, grid_width=3, grid_height=3, magnitude=5, corner='bell', method='in')</span></pre><p id="7d78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将把这条管道应用到我的数据集中。下面是我的数据集中的一个例子:</p><figure class="ko kp kq kr gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi le"><img src="../Images/d371c2e7b5beff14dbce8b9c688a1338.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*Stee74Oc0yhiB3Pb3j-6Ng.png"/></div></div></figure><p id="2bc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它创建了惊人的图像数据集。当我将示例结果应用于反色 Python 绘图时，我会分享它们。</p><figure class="ko kp kq kr gt lf gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/b7a627e1f25f1d29ed554ca3ed6cbfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*TeSdBa259weL8Df87M1Nlw.png"/></div></figure><p id="ba64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">管道准备就绪后，您可以通过以下方式调用来创建数据集:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="2173" class="kx ky it kt b gy kz la l lb lc">p.sample(10000)</span></pre><p id="3ba9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单地说，它使用您的数据集创建随机增强的 10.000 图像样本，并扩展您的限制。默认情况下，它们存储在目录的输出文件夹中，但是您可以在实例化管道对象时更改它。如果您只想处理一次图像以对数据集应用操作，则可以调用:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="033b" class="kx ky it kt b gy kz la l lb lc">p.process()</span></pre><p id="553e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以用它来裁剪或调整你的图像，为此你还需要给你的操作赋予概率 1。</p><p id="3bed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Augmentor 还提供了许多不同的其他操作。您可以对图像应用几何和透视变换。但是，这些转换可能会导致图像上的信息丢失，如下图所示。</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="03ad" class="kx ky it kt b gy kz la l lb lc">p.shear(0.5, 10, 10)  #Size Preserving Shearing<br/>p.skew_tilt(0.5, magnitude=0.2) #Perspective Transforms</span></pre><figure class="ko kp kq kr gt lf gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/9a016e026f47190f6a9e953f3400f2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*LibXnxqanycjrbGyDWre6Q.png"/></div></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="5bc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些例子中，我也使用随机删除角，因为大多数时候人们不会在绘图中画出完美的形状，而边缘在真实的绘图中也不会出现。为了实现这个想法，您可以使用一个简单的函数，如；</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="9a8d" class="kx ky it kt b gy kz la l lb lc">def remove_corners(image):<br/>    img=cv2.imread(image,0)<br/>    corners = cv2.goodFeaturesToTrack(img, 100, 0.01, 10)<br/>    corners = np.int0(corners)<br/>    <br/>    for corner in corners:<br/>        n = random.randint(1,4)<br/>        if(n != 3):<br/>            x,y = corner.ravel()<br/>            cv2.circle(img,(x,y),3,255,-1)<br/>    return img</span></pre><p id="cc25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将此功能应用于文件夹中的图片。顶部的图像是源数据集，下面是应用了“移除角点”功能的图像。</p><figure class="ko kp kq kr gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi le"><img src="../Images/69d73a590343bb34a1888548130309f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*_7NJgQrOISFhTHXPyRBAbw.png"/></div></div></figure><p id="382b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OpenCV 很容易做到这一点。它读取图像，找到图像内部的角点，并对它们进行着色，以消除它们。我添加了简单的概率方法来从均匀分布中确定 75%的角点，并移除它们以向我们的数据集添加一些随机方法。</p></div></div>    
</body>
</html>