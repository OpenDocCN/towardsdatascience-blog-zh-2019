<html>
<head>
<title>8 Console API Functions Other Than Console.log()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">除 Console.log()以外的 8 个控制台 API 函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-console-api-functions-other-than-console-log-81cc6b7164b?source=collection_archive---------8-----------------------#2019-12-12">https://towardsdatascience.com/8-console-api-functions-other-than-console-log-81cc6b7164b?source=collection_archive---------8-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f04f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">除 console.log 之外的一些重要控制台 API 函数的深入指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cd333e1da7898e330e5047b700ea20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9cjNBwf_L4TU_6-7fXSkg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Console API Functions</figcaption></figure><p id="d70c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">控制台 API 最常用的方法无疑是<code class="fe lu lv lw lx b">console.log</code>。然而，它还附带了几个其他有用的方法，可以提高我们的调试效率。</p><p id="44f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧🏊并了解其他一些方法👇</p><blockquote class="ly lz ma"><p id="0ca6" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:从 10.0.0 版本开始，NodeJS 和几乎所有主流浏览器都提供了所有方法。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f07f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">console.table(数据[，属性])👇</h1><p id="0096" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在调试时，如果有一个复杂的嵌套对象或一组相同类型的对象，我们在阅读、理解和比较对象时会遇到困难。</p><p id="c3c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">console.table()</code>是来救我们的。它以清晰的表格格式呈现数据。因此提高了可读性。</p><p id="041f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法有两个参数:</p><ul class=""><li id="159f" class="nj nk it la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><code class="fe lu lv lw lx b">data</code>:任意类型的数据集合，通常是对象数组。</li><li id="94cd" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><code class="fe lu lv lw lx b">properties</code>:您想要用来显示表格的字段的字符串数组。</li></ul><p id="7096" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个例子来了解更多:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="2a55" class="ob mn it lx b gy oc od l oe of">const data = [<br/>  {<br/>    "id": "0001",<br/>    "type": "donut",<br/>    "name": "Cake",<br/>    "ppu": 0.55,<br/>  },<br/>  {<br/>    "id": "0002",<br/>    "type": "donut",<br/>    "name": "Raised",<br/>    "ppu": 0.55,<br/>  }<br/>];</span></pre><p id="7507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一系列的对象<code class="fe lu lv lw lx b">data</code>。让我们来看看数据的表格方法输出。</p><ol class=""><li id="e136" class="nj nk it la b lb lc le lf lh nl ll nm lp nn lt og np nq nr bi translated"><code class="fe lu lv lw lx b">console.table(data)</code></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/55ac67f29aa67a2eb53e50356535dde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udXiwK6kppBsDQJ4Y9F5iw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><code class="fe lu lv lw lx b">console.table(data)</code></figcaption></figure><p id="40c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.<code class="fe lu lv lw lx b">console.table(data, ['name'])</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/920a9ff3f72ed89188439be6c8f25e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxYytlo1FyTCltTWJT7i0Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><code class="fe lu lv lw lx b">console.table(data, ['name'])</code></figcaption></figure><p id="4681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对嵌套对象进行同样的尝试，并查看输出😄</p><blockquote class="ly lz ma"><p id="7024" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:您可以通过单击列的标签按列对表格进行排序。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f325" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">控制台.组(标签)&amp;控制台.组结束(标签)</strong>👇</h1><p id="1920" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">有时，可能会有这样一种情况，我们希望在一个循环中记录值。最好的办法是在每个循环的末尾添加一个分隔符来分隔每次迭代的值，但这仍然不够有效，因为没有标签来描述日志。</p><p id="6032" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">console.group</code>,在登录到控制台时，正确组织相关数据并使用确定的组标签表示每个组变得非常简单。</p><p id="eadd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些方法带有一个可选参数— <code class="fe lu lv lw lx b">label</code>，它是组的名称。</p><p id="f2ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管不要求将参数传递给<code class="fe lu lv lw lx b">console.group()</code>，但是我们还是应该这样做，以便弄清楚哪些值被分组在一起。</p><p id="44fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不必将组名传递给<code class="fe lu lv lw lx b">console.groupEnd()</code>，因为它总是会关闭最近创建的组。</p><p id="0fb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在一个已经创建的组中调用<code class="fe lu lv lw lx b">console.group()</code>，我们也可以创建嵌套组。这里有一个简单的例子，可以帮助我们更好地理解它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8407653147c91ff8c9d33b19ce82e3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARQ_xPxiv6n_Lq_du7yEtg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.group() and console.groupEnd()</figcaption></figure><blockquote class="ly lz ma"><p id="3dd7" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:由<code class="fe lu lv lw lx b">console.group(label)</code>创建的组最初是打开的，如果我们调用<code class="fe lu lv lw lx b">console.groupCollapsed(label)</code>，我们可以从一开始就将组显示为折叠的。这里有一个例子:</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/0656fca686c72b41a9bd2cd0bbd0c974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRM1qKN9B1Be0eP1VNkgBw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.groupCollapsed(label)</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f589" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">console.dir(对象)和 console.dirxml(对象)👇</h1><p id="9e53" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在过去，<code class="fe lu lv lw lx b">console.log</code>和<code class="fe lu lv lw lx b">console.dir</code>之间的行为非常不同，特别是在记录对象内容时，但是新的 JavaScript 引擎已经扩展了<code class="fe lu lv lw lx b">console.log</code>的功能，所以和<code class="fe lu lv lw lx b">console.dir</code>已经没有太大的区别了。</p><p id="7e4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现的唯一区别是在浏览器控制台中访问 DOM 元素时。</p><ul class=""><li id="d939" class="nj nk it la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><code class="fe lu lv lw lx b">console.log</code>在类似 HTML 的树中打印元素</li><li id="fa6d" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><code class="fe lu lv lw lx b">console.dir</code>在一个类似 JSON 的树中打印元素，从这里我们可以检查元素的 DOM 属性</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fda19ddd185cd401c35d7fd257fe211f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAGbXXMimKVTWgQj9H3dfw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Difference between console.log() and console.dir()</figcaption></figure><p id="a162" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 Node.js 的情况下，<code class="fe lu lv lw lx b">console.dir(obj[, options])</code>函数接受一个可选参数，该参数是一个可以有以下键的对象:</p><ul class=""><li id="699e" class="nj nk it la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><code class="fe lu lv lw lx b">showHidden</code> <a class="ae om" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="noopener ugc nofollow" target="_blank"> &lt;布尔&gt; </a>。如果<code class="fe lu lv lw lx b">true</code>那么对象的不可枚举和符号属性也将被显示。<strong class="la iu">默认:</strong> <code class="fe lu lv lw lx b">false</code>。</li><li id="9ef4" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><code class="fe lu lv lw lx b">depth</code> <a class="ae om" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="noopener ugc nofollow" target="_blank"> &lt;编号&gt; </a>。告知在格式化对象时递归的次数。这对于检查大型复杂物体很有用。要使其无限递归，请传递<code class="fe lu lv lw lx b">null</code>。<strong class="la iu">默认:</strong> <code class="fe lu lv lw lx b">2</code>。</li><li id="2343" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><code class="fe lu lv lw lx b">colors</code> <a class="ae om" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="noopener ugc nofollow" target="_blank"> &lt;布尔&gt; </a>。如果<code class="fe lu lv lw lx b">true</code>，则输出将采用 ANSI 颜色代码。颜色可定制。<strong class="la iu">默认:</strong> <code class="fe lu lv lw lx b">false</code>。</li></ul><blockquote class="ly lz ma"><p id="6b75" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:如果你知道更多的区别，请随时用例子在下面评论😊</p></blockquote><p id="6926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对 HTML 和 XML 元素或对象调用<code class="fe lu lv lw lx b">console.dirxml()</code>等同于调用<code class="fe lu lv lw lx b">console.log()</code></p><blockquote class="ly lz ma"><p id="444d" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:Node.js 内部的<code class="fe lu lv lw lx b">console.dirxml</code>也调用<code class="fe lu lv lw lx b">console.log</code>作为其参数。</p></blockquote><p id="5645" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/0b35f49261a0e12c1dd05d5ec0e3a671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJnb5m6d8WClEZpzWEvwMA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Difference between console.log() and console.dirxml()</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8712" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">console.profile([，label]) &amp; console.profileEnd([，label])👇</h1><p id="09dd" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated"><code class="fe lu lv lw lx b">console.profile([,label])</code>开始记录调用它的地方(Browser 或 Node.js)的 CPU 和内存使用情况的性能概要。</p><p id="732e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">探查器的每次运行都保存为一个单独的选项卡，由作为参数传递的标签标识。</p><p id="b67a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住使用<code class="fe lu lv lw lx b">console.profileEnd(label)</code>结束剖析。</p><p id="ec7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过一个例子来理解:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/9f9ecc789439d4d5cf7f14c8a8ccbb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*q6sk3WKlc39P12Z8Fo2dTQ.png"/></div></figure><p id="da13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这会创建一个名为<code class="fe lu lv lw lx b">test1</code>的 JavaScript 分析器，并开始记录浏览器的性能(假设它运行在浏览器中)。以查看 Chrome 浏览器中记录的性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/871b4af47474cbf40612c7b17b404116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spA56m4iziY2Reh4s9SdVw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.profile([, label]) &amp; console.profileEnd([, label])</figcaption></figure><blockquote class="ly lz ma"><p id="ec38" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:如果你在开发者工具中没有看到 JavaScript profiler 面板，那么请点击这个——点击三点菜单(在右上角)⋮-&gt;更多工具-&gt; JavaScript Profiler。</p></blockquote><p id="7843" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于 Node.js，该方法不显示任何内容，除非在检查器中使用。停止当前的 JavaScript CPU 性能分析会话(如果已经启动),并将报告打印到检查器的<strong class="la iu">性能分析</strong>面板。</p><p id="213f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果在没有标签的情况下调用<code class="fe lu lv lw lx b">console.profileEnd()</code>方法，最近启动的概要文件将被停止。</p><blockquote class="ly lz ma"><p id="d330" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:此功能是非标准的，不在标准轨道上。不要在面向 Web 的生产网站上使用它。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b598" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">控制台.时间([，标签]) &amp;控制台.时间结束([，标签]) </strong>👇</h1><p id="4c89" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated"><code class="fe lu lv lw lx b">console.time()</code>启动可用于计算操作持续时间的计时器。<code class="fe lu lv lw lx b">console.timeEnd()</code>停止计时器并以毫秒为单位打印总运行时间。</p><p id="c3fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定时器由唯一的<code class="fe lu lv lw lx b">label</code>标识，如果没有指定，<code class="fe lu lv lw lx b">timeEnd</code>将采用最近的时间功能并停止它。</p><p id="8f30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您需要对一段代码进行性能检查时，通常会用到它们。你也可以向<code class="fe lu lv lw lx b">time</code>和<code class="fe lu lv lw lx b">timeEnd</code>传递一个字符串，它将启动另一个同名的定时器。</p><p id="0272" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用一个小例子来了解一下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a290517206753b51d5826fd319700ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*tGNY6XyDYO7U7pIT2g9BNw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.time([, label]) &amp; console.timeEnd([, label])</figcaption></figure><p id="ea13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">循环完成所用的时间是 0.01784375 毫秒</p><blockquote class="or"><p id="3851" class="os ot it bd ou ov ow ox oy oz pa lt dk translated">注:查看<a class="ae om" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank">这个性能分析开源代码</a>完全是使用上述两个函数制作的。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="523e" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> console.count([，label])&amp;console . count reset(</strong>[，label] <strong class="ak"> ) </strong>👇</h1><p id="8617" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated"><code class="fe lu lv lw lx b"><a class="ae om" href="https://developer.mozilla.org/en-US/docs/Web/API/Console/count" rel="noopener ugc nofollow" target="_blank">console.count</a>([,label])</code>在作为参数传递的标签上放置一个计数器。每次调用它时，计数器的值都会增加。调试控制台中显示一个标签和一个数字，如果<code class="fe lu lv lw lx b">label</code>没有通过，<code class="fe lu lv lw lx b">console.count()</code>将记录当时它被调用的次数，默认标签如下:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="2657" class="ob mn it lx b gy oc od l oe of">[label]: X    //when label is passed<br/>default: X    //when label is not passed</span></pre><p id="b4ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">console.countReset()</code>将重置 count 的值，如果它与参数<code class="fe lu lv lw lx b">label</code>一起使用，那么它将重置该特定标签的计数值。</p><p id="c4be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子可以更好地理解这些方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/ce687930b02cd3e151dabfdda755b701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFvD4s359gIHMj8jeihqwA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.count([, label]) &amp; console.countReset([, label])</figcaption></figure><p id="b778" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，当我们使用<code class="fe lu lv lw lx b">console.countReset()</code>重置计数器的值，并再次调用<code class="fe lu lv lw lx b">console.count()</code>方法时，我们看到它返回计数器 1，就像它调用一次一样。</p><p id="631e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，请注意带标签和不带标签调用这些方法的区别。🌟</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d8d9" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">console.assert(表达式，消息)👇</h1><p id="37ec" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">该方法用于运行简单的断言测试。它需要两个必需的参数:</p><ul class=""><li id="ea7a" class="nj nk it la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><code class="fe lu lv lw lx b">expression</code>:布尔表达式。</li><li id="ce2b" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><code class="fe lu lv lw lx b">message</code> : <strong class="la iu"> </strong>写入控制台的字符串或对象。</li></ul><blockquote class="ly lz ma"><p id="cc4a" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated"><strong class="la iu">注意:如果一个表达式为 false，它会向控制台写入一条消息并抛出异常。如果这是真的，那么它将什么也不做。</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/a36a587daa6cc339b59a5696011a0d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XME09smuu1dRI3hrN3vq5Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.assert(expression, message)</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7df6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">console.trace([，data])👇</h1><p id="3abf" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">有时，在调试复杂的函数调用时，我们会陷入检测可调用函数及其参数值的困境。这就是<code class="fe lu lv lw lx b">console.trace()</code>出现的地方，它从被调用的点打印可调用函数的堆栈跟踪到控制台。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/3aeb62ca944f704f5ad06bf84dd3096c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Izt7K2dwFzRhoVgdrS2jnA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">console.trace([,data])</figcaption></figure><blockquote class="ly lz ma"><p id="e376" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">注意:当 Node.js 中抛出异常时，或者当我们在浏览器中调试函数时，可以使用这种方法的一个实例是跟踪堆栈。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/8589d2f669af68695c81a397836c3c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKNO-QM2_4PPw6jIipbA4w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">A stack trace example from Node.js</figcaption></figure><h1 id="f132" class="mm mn it bd mo mp pf mr ms mt pg mv mw jz ph ka my kc pi kd na kf pj kg nc nd bi translated">输出太多？</h1><p id="52b1" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">使用<code class="fe lu lv lw lx b"><strong class="la iu">console.clear()</strong></code> <strong class="la iu">清除所有内容即可😃</strong></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="b126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想加入我的电子邮件列表，请考虑在此处输入您的电子邮件地址 和<strong class="la iu">关注我的</strong><a class="ae om" href="https://medium.com/@ideepak.jsd" rel="noopener"><strong class="la iu">medium</strong></a><strong class="la iu">阅读更多关于 javascript 和</strong><a class="ae om" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">Github</strong></a><strong class="la iu">的文章，查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="0f96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="14a2" class="nj nk it la b lb lc le lf lh nl ll nm lp nn lt og np nq nr bi translated"><a class="ae om" href="https://medium.com/better-programming/20-vs-code-shortcuts-for-fast-coding-cheatsheet-10b0e72fd5d" rel="noopener"> 20 VS 快速编码的代码快捷键</a></li><li id="d4ea" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt og np nq nr bi translated"><a class="ae om" href="https://medium.com/better-programming/vs-code-extension-for-web-dev-productivity-fa541654161f" rel="noopener">VS Web 开发效率的代码扩展</a></li><li id="c121" class="nj nk it la b lb ns le nt lh nu ll nv lp nw lt og np nq nr bi translated">Nodejs 应用程序结构——构建高度可扩展的架构。</li></ol><p id="442e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="mb">如果你喜欢这篇文章，请随意分享，帮助他人找到它！</em> </strong></p><p id="f54b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">谢谢！</strong></p></div></div>    
</body>
</html>