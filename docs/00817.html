<html>
<head>
<title>Time Series Forecasting (1): Initial analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测(1):初步分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-1-initial-analysis-87e017501e98?source=collection_archive---------12-----------------------#2019-02-07">https://towardsdatascience.com/time-series-forecasting-1-initial-analysis-87e017501e98?source=collection_archive---------12-----------------------#2019-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="5993" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">所有这些信息都可以在我的 kaggle 个人资料中找到。</p></blockquote><p id="3724" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们从定义什么是时间序列开始这个系列。我选择了最简单的方法，并询问了维基百科，答案如下:</p><blockquote class="jn jo jp"><p id="caff" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">时间序列是按时间顺序索引(或列出或绘制)的一系列数据点。最常见的是，时间序列是在连续的等间隔时间点取得的序列。因此，它是一个离散时间数据序列。—维基百科</p></blockquote><p id="3978" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">因此，时间序列基本上与任何其他数据集相似，但具有两个重要特征:</p><ul class=""><li id="315e" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated">数据的顺序很重要，我们不仅关心数据的值，还关心这些值何时出现。</li><li id="52cd" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated">我们有观察每个实例的时间信息:我们或者有一个包含日期时间信息的列，或者我们知道数据在时间上是等间距的(例如，每秒一个值)。</li></ul><p id="5792" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在这里，我将介绍时间序列的概念，并对数据进行初步分析和调整；由于 Kaggle 数据通常非常清楚，这项工作比现实生活中容易得多，但其想法是表示过程，而不是编写复杂的代码。我要遵循的流程是这样的:</p><ol class=""><li id="d2cb" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko lh kz la lb bi translated">加载数据并设置子集(我不会在这里使用整个数据集)</li><li id="c9d6" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko lh kz la lb bi translated">可视化数据</li><li id="5697" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko lh kz la lb bi translated">清理数据:是否有丢失的值？所有的数据都是期望的格式吗？</li><li id="a529" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko lh kz la lb bi translated">查看统计数据:有异常值吗？</li><li id="f62c" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko lh kz la lb bi translated">寻找平稳性和自相关性</li><li id="fb75" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko lh kz la lb bi translated">趋势和季节性分解</li></ol><h2 id="c2fb" class="li lj iq bd lk ll lm dn ln lo lp dp lq kq lr ls lt kr lu lv lw ks lx ly lz ma bi translated">数据</h2><p id="85d2" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">我正在使用来自 Kaggle 知识库的<a class="ae kp" href="https://www.kaggle.com/selfishgene/historical-hourly-weather-data/home" rel="noopener ugc nofollow" target="_blank">历史每小时天气数据</a>。该数据集包含不同城市大约 5 年的天气信息，包括温度、湿度、压力、风和天气描述等信息。我将把重点放在<strong class="jt ir">温度</strong>数据上，因为我觉得它更直观。</p><p id="411c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">为了举例，我将使用两个城市的温度数据，选择的将是旧金山(因为我喜欢它)和变化最大的城市。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f8d4" class="mn lj iq bd lk mo mp mq ln mr ms mt lq mu mv mw lt mx my mz lw na nb nc lz nd bi translated">加载数据</h1><p id="9925" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">我将在整个笔记本中使用 Pandas 来处理数据和 matplotlib 进行可视化。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e224" class="li lj iq nj b gy nn no l np nq">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span></pre><p id="b863" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们从加载数据 a 开始，快速浏览一下它的形状和第一个值。因为我已经知道这是一个时间序列，所以我将把 datetime 列设置为索引。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1a2f" class="li lj iq nj b gy nn no l np nq">temp = pd.read_csv('../input/temperature.csv', parse_dates=['datetime'])<br/>temp = temp.set_index('datetime')<br/>print('Dataset shape: {}'.format(temp.shape))<br/>temp.head()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nr"><img src="../Images/5aa1f43f32998aec8da30591a40a835f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GSmxuzhslPVoJEM5t1VMQ.png"/></div></div></figure><p id="6e44" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">该数据集由 36 列组成，对应 36 个不同的城市，45253 行，给出了从 2012 年末到 2017 年末每小时的温度值。</p><p id="a5d1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如我所说，我要使用的城市之一是年气温变化最大的城市。让我们找出是哪一个。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e5b8" class="li lj iq nj b gy nn no l np nq">all_std = temp.std(axis=0)<br/>max_std = all_std.max()<br/>city_max_std = temp.columns[all_std==max_std][0]</span><span id="6e66" class="li lj iq nj b gy nz no l np nq">print('City with highest temperature variation: {} ({} degrees)'.format(city_max_std,round(max_std,2)))</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oa"><img src="../Images/9a485e48e719a3190475ad9411dc78bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyAipTeFdO3hHflDkTHtGg.png"/></div></div></figure><p id="bd36" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">现在让我们对数据进行子集划分，使其仅包含旧金山和明尼阿波利斯的值，并查看一些统计数据。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e98b" class="li lj iq nj b gy nn no l np nq">data = temp[['San Francisco','Minneapolis']]<br/>data.describe()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e713256bf6730138de719eb529081f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*QAYedcECZu8liR_9IKwFRw.png"/></div></figure><p id="a4fd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我看到的第一件事是两列中都有丢失的数据，我将很快处理这个问题。此外，这个温度值显然不在日常温度的正常范围内。因为我住在欧洲，所以我要将数据从开尔文转换为摄氏度(抱歉，如果你用的是 Farenheit，但是国际系统)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="64dd" class="li lj iq nj b gy nn no l np nq">data = data-273.15<br/>data.describe()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/72d5336f2a1f388fd7456e90324fe349.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*2K5tzDw35ReVywmSsEJ2xg.png"/></div></figure><h1 id="c332" class="mn lj iq bd lk mo od mq ln mr oe mt lq mu of mw lt mx og mz lw na oh nc lz nd bi translated">可视化数据</h1><p id="aa05" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">让我们来看看这两个城市历年的气温情况。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4a64" class="li lj iq nj b gy nn no l np nq">_=data.plot(<br/>    figsize=(15,5),<br/>    subplots=False,<br/>    title='Temperature',<br/>    alpha=0.7<br/>)<br/>_=plt.xlabel('Date')<br/>_=plt.ylabel('Temperature')</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oi"><img src="../Images/fa8a8278ee562c9988bcd8ddbfd5db31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ygN8PYkdNTnp_FJ3HPYuQ.png"/></div></div></figure><p id="c250" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">还不错，明尼阿波利斯的天气似乎很冷，也许冬天我不会去那里。</p><p id="eb41" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">此外，数据有明显的季节性，周期为一年。也有更多的变化，我稍后会检查这种变化是否与一些日常季节性有关，或者它更随机。</p><p id="4d69" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">从这个图中我可以看出，旧金山的数据更少。蓝线距离 2018 年并没有那么近。</p><h1 id="940d" class="mn lj iq bd lk mo od mq ln mr oe mt lq mu of mw lt mx og mz lw na oh nc lz nd bi translated">清理数据</h1><p id="2cb5" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">正如我们所看到的，这里明显缺少值，图中引起我注意的一些东西可能是原因之一。正如我提到的，旧金山的数据结束得更早，为了同时处理这两个系列，我将丢失明尼阿波利斯系列的最终值。</p><p id="a26d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">为此，我将保留旧金山的所有非缺失值，并查看它们到达的最大日期。然后，我们将删除日期大于该日期的所有数据。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c91d" class="li lj iq nj b gy nn no l np nq">SF_non_missing = data['San Francisco'].dropna()<br/>max_date = SF_non_missing.index.max()<br/>data = data[data.index &lt;= max_date]</span></pre><p id="3990" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们看看我们是否还有丢失的值。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="7871" class="li lj iq nj b gy nn no l np nq">print(data.isna().sum())</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oa"><img src="../Images/959529f21da271b5886cc883d8a3d576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-zqac9cINQUV--aBjcyrA.png"/></div></div></figure><p id="d4c7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">好了，我们还是要处理数据缺失的问题，不过有件事我想先处理一下。我在这里的目的是研究数据的年度行为，我对每日变化不感兴趣，所以我将通过取当天所有温度的平均值、最小值和最大值，将数据重新采样为每日频率。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="d727" class="li lj iq nj b gy nn no l np nq">data_mean = data.resample('D').mean()<br/>data_min = data.resample('D').min()<br/>data_max = data.resample('D').max()<br/>print('Resample shape: {}'.format(data_mean.shape))<br/>data_mean.describe()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oj"><img src="../Images/493d142bb2fd281c7e028d3e8151b5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HJBRUVG-E2r4HsUHsYjMA.png"/></div></div></figure><p id="16a5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果每天都有更多没有丢失数据的行，这也可以解决我们丢失数据的问题。让我们检查一下。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="cf79" class="li lj iq nj b gy nn no l np nq">print('Missing data now?')<br/>print(data_mean.isna().sum())</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ok"><img src="../Images/f938b37641c026b9fbb37ed16c03fe8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4GVM2ZSD_1ledNma5yTrA.png"/></div></div></figure><p id="64c8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">现在没有丢失数据！这意味着我们每天至少有一个值。</p><p id="4f9f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果不是这样，我会使用前一天的值。对于时间序列，我更喜欢这种解决方案，而不仅仅是删除行(最好在所有行之间有相同的时间间隔)或只使用平均值(因为这会扰乱曲线的形状)。</p><p id="de01" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们检查一下重采样后数据的外观。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="70fe" class="li lj iq nj b gy nn no l np nq">_=data_mean.plot(<br/>    figsize=(15,5),<br/>    subplots=False,<br/>    title='Temperature',<br/>    alpha=0.7<br/>)<br/>_=plt.fill_between(<br/>    x=data_mean.index,<br/>    y1=data_min['San Francisco'].values,<br/>    y2=data_max['San Francisco'].values,<br/>    alpha=0.3<br/>)<br/>_=plt.fill_between(<br/>    x=data_mean.index,<br/>    y1=data_min['Minneapolis'].values,<br/>    y2=data_max['Minneapolis'].values,<br/>    color='orange',<br/>    alpha=0.3<br/>)<br/>_=plt.xlabel('Date')<br/>_=plt.ylabel('Temperature')</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nr"><img src="../Images/3619f91f5ef80b65d05e1fc70fb71467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Czr_kJ4X9IW1CLNrzoX_hA.png"/></div></div></figure><p id="63b4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">曲线周围的阴影显示当天的最小值-最大值，而主线显示平均值。</p><p id="7e45" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">现在两条曲线都在同一点结束，我们有更少的每日变化。</p><h1 id="f4f1" class="mn lj iq bd lk mo od mq ln mr oe mt lq mu of mw lt mx og mz lw na oh nc lz nd bi translated">极端值</h1><p id="2834" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">有时奇怪的事情会发生，我们最终得到的值会搞乱整个模型。例如，一个传感器可能发生故障，在夏天测量到零下 10 度的温度，这肯定是不正常的。在夏天的其他时候，你可以看到 10，这很低，但可能不是一个错误，有时它会变冷，你不能删除这种类型的值，因为它可能有一些原因。我们必须小心对待异常值，除非我们知道它是一个错误或者是一次性的，不应该影响我们的模型，否则我们不应该删除它。</p><p id="922a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">识别哪些点是异常值以及如何处理它们并不总是很容易，但是一个好的起点是检查数据以查看是否有值非常高或非常低的点。直观地看到这一点的一个好方法是使用直方图。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1157" class="li lj iq nj b gy nn no l np nq">_=plt.hist(data_mean['San Francisco'], alpha=0.5, label='San Francisco')<br/>_=plt.hist(data_mean['Minneapolis'], alpha=0.5, label='Minneapolis')<br/>_=plt.legend()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/19023892abab351fc1e3e48ed0618aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*h9Kb9p9_yaSybJYam_wN4g.png"/></div></figure><p id="229b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们分别来看看每个城市:</p><ul class=""><li id="d9d0" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated">旧金山的值似乎遵循具有小标准偏差的高斯分布，我们在该数据中看不到任何异常值。</li><li id="f7d9" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated">明尼阿波利斯的曲线不太完美，向右偏高(负偏)。虽然我们不能说这些点中的任何一个是异常值，因为有相当多的异常值，同样，在温度的可视化表示中，我们可以看到每年都达到非常低的值。</li></ul><p id="05f8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我没有看到任何异常值，也不认为我应该删除任何点。</p><h1 id="f6f0" class="mn lj iq bd lk mo od mq ln mr oe mt lq mu of mw lt mx og mz lw na oh nc lz nd bi translated">寻找平稳性和自相关性</h1><p id="67d6" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">我们先前绘制的高斯型直方图是时间序列可以是平稳的第一个线索。</p><p id="fd2b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">另一个线索是计算不同时间范围内的时间序列的一些统计数据，并寻找变化。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f3f7" class="li lj iq nj b gy nn no l np nq">cut = data_mean.index[int(0.5*len(data_mean))]<br/>print('Mean before {}:'.format(cut))<br/>print(data_mean.loc[:cut].mean())<br/>print('')<br/>print('Mean after {}:'.format(cut))<br/>print(data_mean.loc[cut:].mean())<br/>print('')<br/>print('---------------------------')<br/>print('')<br/>print('Std before {}:'.format(cut))<br/>print(data_mean.loc[:cut].std())<br/>print('')<br/>print('Std after {}:'.format(cut))<br/>print(data_mean.loc[cut:].std())</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi om"><img src="../Images/fb3699fbec05784d4035ca52cb636b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hv-IiXPnOFhKp27BnPaPIw.png"/></div></div></figure><p id="0974" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们可以看到，旧金山的值非常接近，但明尼阿波利斯的值更远，它们仍然足够接近，时间序列是平稳的，因为我们需要考虑标准偏差。</p><p id="24e7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这种方法并不证明或否认我们的时间序列是平稳的，它只是表明它可以是平稳的。</p><p id="c24e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们还可以使用统计测试来确定是否应该拒绝非平稳性假设<strong class="jt ir">增强的 Dickey-Fuller 测试。</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0827" class="li lj iq nj b gy nn no l np nq">from statsmodels.tsa.stattools import adfuller</span><span id="dfc9" class="li lj iq nj b gy nz no l np nq">result = adfuller(data_mean['San Francisco'])<br/>print('San Francisco')<br/>print('--------------------------')<br/>print('ADF Statistic: %f' % result[0])<br/>print('p-value: %f' % result[1])<br/>print('Critical Values:')<br/>for key, value in result[4].items():<br/>    print('\t%s: %.3f' % (key, value))</span><span id="1619" class="li lj iq nj b gy nz no l np nq">print('\n\n')<br/>    <br/>result = adfuller(data_mean['Minneapolis'])<br/>print('Minneapolis')<br/>print('--------------------------')<br/>print('ADF Statistic: %f' % result[0])<br/>print('p-value: %f' % result[1])<br/>print('Critical Values:')<br/>for key, value in result[4].items():<br/>    print('\t%s: %.3f' % (key, value))</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi on"><img src="../Images/53bf31ce6ec43d1ab7e2c60463c4b355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QryGPxjWgOuCSMlPcr4eHg.png"/></div></div></figure><p id="9092" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">那么，这些值意味着什么呢？</p><ul class=""><li id="a6a7" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated">ADF 统计量是扩大的 Dicken-Fuller 评分，该值越负，我们可以拒绝零假设(时间序列是平稳的概率)的确定性越高。</li><li id="59fa" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated">p 值是零假设的置信度。这个值的通常阈值是 0.05，这意味着如果<em class="js"> p 值&lt; = 0.05 </em>，我们可以拒绝零假设。</li><li id="241e" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated">其余值分别是 99%、95%和 90%置信区间的临界值。</li></ul><p id="63d4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">因此，在这种情况下，所有这些意味着我们可以拒绝旧金山的零假设，因为<em class="js"> p </em>低于 0.05，并且 ADF 得分低于 99%置信区间的限制。然而，我们无法拒绝明尼阿波利斯的这一假设，我们可以说它是具有 90%置信区间的平稳性，但是由于阈值是 95% ( <em class="js"> p = 0.05 </em>)，我们不能拒绝它。这意味着我们应该在应用任何模型之前区别数据。</p><p id="02ee" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">可以在下面找到一些参考资料来理解这些测试:</p><ul class=""><li id="bfe4" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated"><a class="ae kp" href="https://pythondata.com/stationary-data-tests-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">时间序列预测的平稳数据检验</a></li><li id="76c5" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated"><a class="ae kp" href="https://machinelearningmastery.com/time-series-data-stationary-python/" rel="noopener ugc nofollow" target="_blank">如何用 Python 检查时间序列数据是否平稳</a></li></ul><h1 id="48f3" class="mn lj iq bd lk mo od mq ln mr oe mt lq mu of mw lt mx og mz lw na oh nc lz nd bi translated">自相关</h1><p id="7837" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">最后要检查的是数据是否自相关。我想使用一些自回归方法来预测未来的帖子，我只能在数据自相关的情况下这样做(意味着特定时间点的值取决于以前的值)。</p><p id="14c2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">statmodels 库提供了一个很好的工具来检查这一点。阴影区域之外的一切都很有可能是自相关的(超过 95%的置信区间)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e300" class="li lj iq nj b gy nn no l np nq">import statsmodels.api as sm<br/>print('San Francisco')<br/>_=sm.graphics.tsa.plot_acf(data_mean['San Francisco'])<br/>plt.show()<br/>print('Minneapolis')<br/>_=sm.graphics.tsa.plot_acf(data_mean['Minneapolis'])<br/>plt.show()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oj"><img src="../Images/5c274eb8b2edeef45e48e7da9005be1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiSuGpcoExpFjxZgamnyJg.png"/></div></div></figure><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oo"><img src="../Images/398db91694a1948782fd68a8de3b546c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7zRelnHmWd0OXM6YaaM3Q.png"/></div></div></figure><p id="14ef" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们把重点放在最重要的滞后(更接近要点的)，例如，一年范围的数据。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="548a" class="li lj iq nj b gy nn no l np nq">import statsmodels.api as sm<br/>print('San Francisco')<br/>_=sm.graphics.tsa.plot_acf(data_mean['San Francisco'], lags=365)<br/>plt.show()<br/>print('Minneapolis')<br/>_=sm.graphics.tsa.plot_acf(data_mean['Minneapolis'], lags=365)<br/>plt.show()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi om"><img src="../Images/a6040d585d8eb2f78cbfe62276126e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKfdCl1ELwxp_V90IdZbIg.png"/></div></div></figure><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi om"><img src="../Images/a5d86cf26adacb6edbfa0376a49e7de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJDqjUu_04SVe1eaMRSUTg.png"/></div></div></figure><p id="f309" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们还可以检查部分自相关，它计算去除任何其他先前点(更接近新值的点)的影响的相关性。在这里，更远的点失去了重要性，我将重点放在一个月的范围。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="6431" class="li lj iq nj b gy nn no l np nq">print('San Francisco')<br/>_=sm.graphics.tsa.plot_pacf(data_mean['San Francisco'], lags=30)<br/>plt.show()<br/>print('Minneapolis')<br/>_=sm.graphics.tsa.plot_pacf(data_mean['Minneapolis'], lags=30)<br/>plt.show()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oa"><img src="../Images/32d460f9f46dbb6db25bfd9bd93cdd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2PkOSSuuZhqRwnjeJb_KQ.png"/></div></div></figure><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oa"><img src="../Images/6ab2a14c04f2ef3256a51e59a93c89ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyW2w6Ekg4td2aiCrRPstg.png"/></div></div></figure><p id="35c8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">以下是一些关于自相关的参考资料:</p><ul class=""><li id="c3f0" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated"><a class="ae kp" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.acf.html" rel="noopener ugc nofollow" target="_blank"> Statsmodels 参考 acf 功能</a></li><li id="01d1" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated"><a class="ae kp" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.pacf.html" rel="noopener ugc nofollow" target="_blank"> Statsmodels 引用 pacf 函数</a></li><li id="c065" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated"><a class="ae kp" href="https://machinelearningmastery.com/gentle-introduction-autocorrelation-partial-autocorrelation/" rel="noopener ugc nofollow" target="_blank">自相关和偏自相关的简明介绍</a></li></ul><h1 id="5d6c" class="mn lj iq bd lk mo od mq ln mr oe mt lq mu of mw lt mx og mz lw na oh nc lz nd bi translated">趋势-季节性分解</h1><p id="578e" class="pw-post-body-paragraph jq jr iq jt b ju mb jw jx jy mc ka kb kq md ke kf kr me ki kj ks mf km kn ko ij bi translated">我们可以把时间序列看作趋势、季节性和残差(噪声或其他随机行为)的组合。由这些部分组成的时间序列可以是加法的，也可以是乘法的:</p><ul class=""><li id="57a9" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated">加法:<em class="js">数据=趋势+季节性+残差</em></li><li id="5295" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated">乘法:<em class="js">数据=趋势季节性残差</em></li></ul><p id="7efd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">Statsmodels 包提供了一个函数来一次提取这 3 个组件:<a class="ae kp" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html" rel="noopener ugc nofollow" target="_blank">季节性分解</a></p><p id="05b4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这里的分解很简单，因为我们知道周期是 365 天。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="cb4a" class="li lj iq nj b gy nn no l np nq">from statsmodels.tsa.seasonal import seasonal_decompose as sd<br/>sd_SF = sd(data_mean['San Francisco'], freq=365)<br/>sd_M = sd(data_mean['Minneapolis'], freq=365)</span><span id="e575" class="li lj iq nj b gy nz no l np nq">_=plt.figure(figsize=(15,10))<br/>ax1=plt.subplot(311)<br/>_=ax1.plot(sd_SF.trend, label='San Francisco', alpha=0.7)<br/>_=ax1.plot(sd_M.trend, label='Minneapolis', alpha=0.7)<br/>_=plt.legend()<br/>ax2=plt.subplot(312)<br/>_=ax2.plot(sd_SF.seasonal, label='San Francisco', alpha=0.7)<br/>_=ax2.plot(sd_M.seasonal, label='Minneapolis', alpha=0.7)<br/>_=plt.legend()<br/>ax3=plt.subplot(313)<br/>_=ax3.plot(sd_SF.resid, label='San Francisco', alpha=0.7)<br/>_=ax3.plot(sd_M.resid, label='Minneapolis', alpha=0.7)<br/>_=plt.legend()</span></pre><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi op"><img src="../Images/bc225722c61975ffc5764438258e09f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Psx6XKmz-PR6OXIf9cZMKA.png"/></div></div></figure><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oq"><img src="../Images/b0aa94efcf5debf94c7f69707f753762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HEAyR-fRXziRVU8-jcXRA.png"/></div></div></figure><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi or"><img src="../Images/53d53a3b538440690d55670ad6540e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6D48_qE8shN2xs0DzrdtQ.png"/></div></div></figure><p id="3b3e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">看到这一点，我们可以理解为什么我们发现明尼阿波利斯的数据是不稳定的，温度有明显的上升。</p><p id="aa1f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们还可以通过移动平均来发现趋势，我在这里不会这样做，因为这是季节性分解函数在幕后做的事情。</p><p id="61eb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">暂时就这样了。以后的帖子我先说一些预测算法。</p><p id="263a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">希望这能帮助到一些和我一样的初学者，感谢阅读！:)</p><p id="4814" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">警察。:我非常希望得到一些反馈</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="b4e8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">Pd2。:我要感谢 Jason Brownlee 的博客 machinelearningmastery，因为我在这里学到了我所知道的关于时间序列数据的大部分知识，他有许多关于这个主题的帖子，他的解释和例子非常清楚，如果你刚刚开始，或者想扩展你关于这个或任何其他机器学习主题的知识，我完全推荐它</p></div></div>    
</body>
</html>